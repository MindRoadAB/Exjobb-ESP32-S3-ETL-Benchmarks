
build/Benchmarks.elf:     file format elf32-xtensa-le


Disassembly of section .iram0.vectors:

40374000 <_WindowOverflow4>:

    .org    0x0
    .global _WindowOverflow4
_WindowOverflow4:

    s32e    a0, a5, -16     /* save a0 to call[j+1]'s stack frame */
40374000:	49c500        	s32e	a0, a5, -16
    s32e    a1, a5, -12     /* save a1 to call[j+1]'s stack frame */
40374003:	49d510        	s32e	a1, a5, -12
    s32e    a2, a5,  -8     /* save a2 to call[j+1]'s stack frame */
40374006:	49e520        	s32e	a2, a5, -8
    s32e    a3, a5,  -4     /* save a3 to call[j+1]'s stack frame */
40374009:	49f530        	s32e	a3, a5, -4
    rfwo                    /* rotates back to call[i] position */
4037400c:	003400        	rfwo
	...

40374040 <_WindowUnderflow4>:

    .org    0x40
    .global _WindowUnderflow4
_WindowUnderflow4:

    l32e    a0, a5, -16     /* restore a0 from call[i+1]'s stack frame */
40374040:	09c500        	l32e	a0, a5, -16
    l32e    a1, a5, -12     /* restore a1 from call[i+1]'s stack frame */
40374043:	09d510        	l32e	a1, a5, -12
    l32e    a2, a5,  -8     /* restore a2 from call[i+1]'s stack frame */
40374046:	09e520        	l32e	a2, a5, -8
    l32e    a3, a5,  -4     /* restore a3 from call[i+1]'s stack frame */
40374049:	09f530        	l32e	a3, a5, -4
    rfwu
4037404c:	003500        	rfwu
	...

40374050 <_xt_alloca_exc>:

    .align  4
    .global _xt_alloca_exc
_xt_alloca_exc:

    rsr     a0, WINDOWBASE  /* grab WINDOWBASE before rotw changes it */
40374050:	034800        	rsr.windowbase	a0
    rotw    -1              /* WINDOWBASE goes to a4, new a0-a3 are scratch */
40374053:	4080f0        	rotw	-1
    rsr     a2, PS
40374056:	03e620        	rsr.ps	a2
    extui   a3, a2, XCHAL_PS_OWB_SHIFT, XCHAL_PS_OWB_BITS
40374059:	343820        	extui	a3, a2, 8, 4
    xor     a3, a3, a4      /* bits changed from old to current windowbase */
4037405c:	303340        	xor	a3, a3, a4
    rsr     a4, EXCSAVE_1   /* restore original a0 (now in a4) */
4037405f:	03d140        	rsr.excsave1	a4
    slli    a3, a3, XCHAL_PS_OWB_SHIFT
40374062:	113380        	slli	a3, a3, 8
    xor     a2, a2, a3      /* flip changed bits in old window base */
40374065:	302230        	xor	a2, a2, a3
    wsr     a2, PS          /* update PS.OWB to new window base */
40374068:	13e620        	wsr.ps	a2
    rsync
4037406b:	002010        	rsync

    bbci.l a4, 31, _WindowUnderflow4
4037406e:	ce74f7        	bbci	a4, 31, 40374040 <_WindowUnderflow4>
    rotw    -1              /* original a0 goes to a8 */
40374071:	4080f0        	rotw	-1
    bbci.l a8, 30, _WindowUnderflow8
40374074:	4878e7        	bbci	a8, 30, 403740c0 <_WindowUnderflow8>
    rotw    -1
40374077:	4080f0        	rotw	-1
    j               _WindowUnderflow12
4037407a:	003086        	j	40374140 <_WindowUnderflow12>
4037407d:	000000        	ill

40374080 <_WindowOverflow8>:

    .org    0x80
    .global _WindowOverflow8
_WindowOverflow8:

    s32e    a0, a9, -16     /* save a0 to call[j+1]'s stack frame */
40374080:	49c900        	s32e	a0, a9, -16
    l32e    a0, a1, -12     /* a0 <- call[j-1]'s sp
40374083:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1, a9, -12     /* save a1 to call[j+1]'s stack frame */
40374086:	49d910        	s32e	a1, a9, -12
    s32e    a2, a9,  -8     /* save a2 to call[j+1]'s stack frame */
40374089:	49e920        	s32e	a2, a9, -8
    s32e    a3, a9,  -4     /* save a3 to call[j+1]'s stack frame */
4037408c:	49f930        	s32e	a3, a9, -4
    s32e    a4, a0, -32     /* save a4 to call[j]'s stack frame */
4037408f:	498040        	s32e	a4, a0, -32
    s32e    a5, a0, -28     /* save a5 to call[j]'s stack frame */
40374092:	499050        	s32e	a5, a0, -28
    s32e    a6, a0, -24     /* save a6 to call[j]'s stack frame */
40374095:	49a060        	s32e	a6, a0, -24
    s32e    a7, a0, -20     /* save a7 to call[j]'s stack frame */
40374098:	49b070        	s32e	a7, a0, -20
    rfwo                    /* rotates back to call[i] position */
4037409b:	003400        	rfwo
	...

403740c0 <_WindowUnderflow8>:

    .org    0xC0
    .global _WindowUnderflow8
_WindowUnderflow8:

    l32e    a0, a9, -16     /* restore a0 from call[i+1]'s stack frame */
403740c0:	09c900        	l32e	a0, a9, -16
    l32e    a1, a9, -12     /* restore a1 from call[i+1]'s stack frame */
403740c3:	09d910        	l32e	a1, a9, -12
    l32e    a2, a9,  -8     /* restore a2 from call[i+1]'s stack frame */
403740c6:	09e920        	l32e	a2, a9, -8
    l32e    a7, a1, -12     /* a7 <- call[i-1]'s sp
403740c9:	09d170        	l32e	a7, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3, a9,  -4     /* restore a3 from call[i+1]'s stack frame */
403740cc:	09f930        	l32e	a3, a9, -4
    l32e    a4, a7, -32     /* restore a4 from call[i]'s stack frame */
403740cf:	098740        	l32e	a4, a7, -32
    l32e    a5, a7, -28     /* restore a5 from call[i]'s stack frame */
403740d2:	099750        	l32e	a5, a7, -28
    l32e    a6, a7, -24     /* restore a6 from call[i]'s stack frame */
403740d5:	09a760        	l32e	a6, a7, -24
    l32e    a7, a7, -20     /* restore a7 from call[i]'s stack frame */
403740d8:	09b770        	l32e	a7, a7, -20
    rfwu
403740db:	003500        	rfwu
	...

40374100 <_WindowOverflow12>:

    .org    0x100
    .global _WindowOverflow12
_WindowOverflow12:

    s32e    a0,  a13, -16   /* save a0 to call[j+1]'s stack frame */
40374100:	49cd00        	s32e	a0, a13, -16
    l32e    a0,  a1,  -12   /* a0 <- call[j-1]'s sp
40374103:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1,  a13, -12   /* save a1 to call[j+1]'s stack frame */
40374106:	49dd10        	s32e	a1, a13, -12
    s32e    a2,  a13,  -8   /* save a2 to call[j+1]'s stack frame */
40374109:	49ed20        	s32e	a2, a13, -8
    s32e    a3,  a13,  -4   /* save a3 to call[j+1]'s stack frame */
4037410c:	49fd30        	s32e	a3, a13, -4
    s32e    a4,  a0,  -48   /* save a4 to end of call[j]'s stack frame */
4037410f:	494040        	s32e	a4, a0, -48
    s32e    a5,  a0,  -44   /* save a5 to end of call[j]'s stack frame */
40374112:	495050        	s32e	a5, a0, -44
    s32e    a6,  a0,  -40   /* save a6 to end of call[j]'s stack frame */
40374115:	496060        	s32e	a6, a0, -40
    s32e    a7,  a0,  -36   /* save a7 to end of call[j]'s stack frame */
40374118:	497070        	s32e	a7, a0, -36
    s32e    a8,  a0,  -32   /* save a8 to end of call[j]'s stack frame */
4037411b:	498080        	s32e	a8, a0, -32
    s32e    a9,  a0,  -28   /* save a9 to end of call[j]'s stack frame */
4037411e:	499090        	s32e	a9, a0, -28
    s32e    a10, a0,  -24   /* save a10 to end of call[j]'s stack frame */
40374121:	49a0a0        	s32e	a10, a0, -24
    s32e    a11, a0,  -20   /* save a11 to end of call[j]'s stack frame */
40374124:	49b0b0        	s32e	a11, a0, -20
    rfwo                    /* rotates back to call[i] position */
40374127:	003400        	rfwo
	...

40374140 <_WindowUnderflow12>:

    .org 0x140
    .global _WindowUnderflow12
_WindowUnderflow12:

    l32e    a0,  a13, -16   /* restore a0 from call[i+1]'s stack frame */
40374140:	09cd00        	l32e	a0, a13, -16
    l32e    a1,  a13, -12   /* restore a1 from call[i+1]'s stack frame */
40374143:	09dd10        	l32e	a1, a13, -12
    l32e    a2,  a13,  -8   /* restore a2 from call[i+1]'s stack frame */
40374146:	09ed20        	l32e	a2, a13, -8
    l32e    a11, a1,  -12   /* a11 <- call[i-1]'s sp
40374149:	09d1b0        	l32e	a11, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3,  a13,  -4   /* restore a3 from call[i+1]'s stack frame */
4037414c:	09fd30        	l32e	a3, a13, -4
    l32e    a4,  a11, -48   /* restore a4 from end of call[i]'s stack frame */
4037414f:	094b40        	l32e	a4, a11, -48
    l32e    a5,  a11, -44   /* restore a5 from end of call[i]'s stack frame */
40374152:	095b50        	l32e	a5, a11, -44
    l32e    a6,  a11, -40   /* restore a6 from end of call[i]'s stack frame */
40374155:	096b60        	l32e	a6, a11, -40
    l32e    a7,  a11, -36   /* restore a7 from end of call[i]'s stack frame */
40374158:	097b70        	l32e	a7, a11, -36
    l32e    a8,  a11, -32   /* restore a8 from end of call[i]'s stack frame */
4037415b:	098b80        	l32e	a8, a11, -32
    l32e    a9,  a11, -28   /* restore a9 from end of call[i]'s stack frame */
4037415e:	099b90        	l32e	a9, a11, -28
    l32e    a10, a11, -24   /* restore a10 from end of call[i]'s stack frame */
40374161:	09aba0        	l32e	a10, a11, -24
    l32e    a11, a11, -20   /* restore a11 from end of call[i]'s stack frame */
40374164:	09bbb0        	l32e	a11, a11, -20
    rfwu
40374167:	003500        	rfwu
	...

40374180 <_Level2Vector>:
    wsr     a0, EXCSAVE_2                   /* preserve a0 */
40374180:	13d200        	wsr.excsave2	a0
    call0   _xt_medint2                     /* load interrupt handler */
40374183:	02fbc5        	call0	40377140 <_xt_medint2>
	...

403741c0 <_Level3Vector>:
    wsr     a0, EXCSAVE_3                   /* preserve a0 */
403741c0:	13d300        	wsr.excsave3	a0
    call0   _xt_medint3                     /* load interrupt handler */
403741c3:	0302c5        	call0	403771f0 <_xt_medint3>
	...

40374200 <_Level4Vector>:
    wsr     a0, EXCSAVE_4                   /* preserve a0 */
40374200:	13d400        	wsr.excsave4	a0
    call0   xt_highint4                     /* load interrupt handler */
40374203:	013b85        	call0	403755bc <xt_highint4>
	...

40374240 <_Level5Vector>:
    wsr     a0, EXCSAVE_5                   /* preserve a0 */
40374240:	13d500        	wsr.excsave5	a0
    call0   xt_highint5                    /* load interrupt handler */
40374243:	030645        	call0	403772a8 <xt_highint5>
	...

40374280 <_DebugExceptionVector>:
    wsr     a0, EXCSAVE+XCHAL_DEBUGLEVEL    /* preserve a0 */
40374280:	13d600        	wsr.excsave6	a0
    J   xt_debugexception            /* load exception handler */
40374283:	0a9346        	j	40376cd4 <xt_debugexception>
	...

403742c0 <_NMIExceptionVector>:
    wsr     a0, EXCSAVE + XCHAL_NMILEVEL   /* preserve a0 */
403742c0:	13d700        	wsr.excsave7	a0
    call0   xt_nmi                         /* load interrupt handler */
403742c3:	02fec5        	call0	403772b0 <xt_nmi>
	...

40374300 <_KernelExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374300:	13d100        	wsr.excsave1	a0
    call0   _xt_kernel_exc                  /* kernel exception handler */
40374303:	029e85        	call0	40376cec <_xt_kernel_exc>
	...

40374340 <_UserExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374340:	13d100        	wsr.excsave1	a0
    call0   _xt_user_exc                    /* user exception handler */
40374343:	029c85        	call0	40376d0c <_xt_user_exc>
	...

403743c0 <_DoubleExceptionVector>:
    break   1, 4                            /* unhandled double exception */
403743c0:	004140        	break	1, 4
    movi    a0,PANIC_RSN_DOUBLEEXCEPTION
403743c3:	200c      	movi.n	a0, 2
    wsr     a0,EXCCAUSE
403743c5:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
403743c8:	03d105        	call0	403780dc <_xt_panic>
    rfde                                    /* make a0 point here not later */
403743cb:	003200        	rfde
	...

40374400 <_invalid_pc_placeholder>:
_invalid_pc_placeholder:
    /* This should be an entry instruction for correct stack unwinding.
     * There could be just a line ".cfi_startproc", but unfortunately,
     * CFI is not supported for the Xtensa architecture. */
#define UNREACHABLE_INSTRUCTION_CHECK_PREVIOUS_FRAMES ENTRY0
    UNREACHABLE_INSTRUCTION_CHECK_PREVIOUS_FRAMES
40374400:	002136        	entry	a1, 16
	...

Disassembly of section .iram0.text:

40374404 <call_start_cpu1-0xd98>:
40374404:	374000        	lsi	f0, a0, 220
40374407:	e0d840        	subx4	a13, a8, a4
4037440a:	600c      	movi.n	a0, 6
4037440c:	e0dc      	bnez.n	a0, 4037442e <_iram_text_start+0x2a>
4037440e:	600c      	movi.n	a0, 6
40374410:	49a8      	l32i.n	a10, a9, 16
40374412:	3fc9      	s32i.n	a12, a15, 12
40374414:	c949a4        	lsi	f10, a9, 0x324
40374417:	3f          	.byte	0x3f
40374418:	c949a0        	lsi	f10, a9, 0x324
4037441b:	3f          	.byte	0x3f
4037441c:	027180        	andb	b7, b1, b8
4037441f:	203c      	movi.n	a0, 50
40374421:	400007        	bnone	a0, a0, 40374465 <_iram_text_start+0x61>
40374424:	0095d0        	all4	b13, b4:b5:b6:b7
40374427:	06c042        	addi	a4, a0, 6
4037442a:	c04000        	sub	a4, a0, a0
4037442d:	420014        	lsi	f1, a0, 0x108
40374430:	1aa8      	l32i.n	a10, a10, 4
40374432:	004200        	break	2, 0
40374435:	400006        	j	40384439 <_coredump_iram_end+0x2439>
40374438:	0c4064        	lsi	f6, a0, 48
4037443b:	400460        	lsi	f6, a4, 0x100
4037443e:	600c      	movi.n	a0, 6
40374440:	5438      	l32i.n	a3, a4, 20
40374442:	3fc9      	s32i.n	a12, a15, 12
40374444:	c94980        	lsi	f8, a9, 0x324
40374447:	3f          	.byte	0x3f
40374448:	000000        	ill
4037444b:	000050        	lsi	f5, a0, 0
4037444e:	005000        	syscall
40374451:	000040        	lsi	f4, a0, 0
40374454:	008000        	any4	b0, b0:b1:b2:b3
40374457:	723e00        	lsi	f0, a14, 0x1c8
4037445a:	204201        	l32r	a0, 4033c564 <rom_rx_gain_force+0x336138>
4037445d:	420000        	xorb	b0, b0, b0
40374460:	ff          	.byte	0xff
40374461:	ff          	.byte	0xff
40374462:	3c0000        	lsi	f0, a0, 240
40374465:	3c02a5        	call8	403b0490 <_coredump_iram_end+0x2e490>
40374468:	020020        	andb	b0, b0, b2
4037446b:	3c3c      	movi.n	a12, 51
4037446d:	3fc920        	f64cmph	a12, a9, a2, 3
40374470:	0202e4        	lsi	f14, a2, 8
40374473:	b43c      	movi.n	a4, 59
40374475:	3c0204        	muls.ad.ll	a2, m2
40374478:	49d8      	l32i.n	a13, a9, 16
4037447a:	3fc9      	s32i.n	a12, a15, 12
4037447c:	0204d0        	andb	b0, b4, b13
4037447f:	a03c      	movi.n	a0, 58
40374481:	3c0270        	lsi	f7, a2, 240
40374484:	020534        	lsi	f3, a5, 8
40374487:	783c      	movi.n	a8, 55
40374489:	3c0205        	call0	403b04ac <_coredump_iram_end+0x2e4ac>
4037448c:	057c      	movi.n	a5, -16
4037448e:	e84000        	lsi	f0, a0, 0x3a0
40374491:	400011        	l32r	a1, 40344494 <rom_rx_gain_force+0x33e068>
40374494:	1a1c      	movi.n	a10, 17
40374496:	284000        	lsi	f0, a0, 160
40374499:	001a      	add.n	a0, a0, a1
4037449b:	18c040        	lsxp	f12, a0, a4
4037449e:	144000        	extui	a4, a0, 0, 2
403744a1:	0019      	s32i.n	a1, a0, 0
403744a3:	95d840        	extui	a13, a4, 24, 10
403744a6:	b84200        	lsi	f0, a2, 0x2e0
403744a9:	420016        	beqz	a0, 403748cd <_iram_text_start+0x4c9>
403744ac:	9738      	l32i.n	a3, a7, 36
403744ae:	cc4200        	lsi	f0, a2, 0x330
403744b1:	9f          	.byte	0x9f
403744b2:	d04200        	subx2	a4, a2, a0
403744b5:	400005        	call0	403b44b8 <_coredump_iram_end+0x324b8>
403744b8:	0014e4        	lsi	f14, a4, 0
403744bb:	195042        	s16i	a4, a0, 50
403744be:	e04000        	subx4	a4, a0, a0
403744c1:	420016        	beqz	a0, 403748e5 <_iram_text_start+0x4e1>
403744c4:	1808      	l32i.n	a0, a8, 4
403744c6:	ec4200        	lsi	f0, a2, 0x3b0
403744c9:	420031        	l32r	a3, 40344ccc <rom_rx_gain_force+0x33e8a0>
403744cc:	003c10        	rfi	12
403744cf:	506c42        	s32i	a4, a12, 0x140
403744d2:	f44200        	extui	a4, a0, 2, 16
403744d5:	400011        	l32r	a1, 403444d8 <rom_rx_gain_force+0x33e0ac>
403744d8:	0051f4        	lsi	f15, a1, 0
403744db:	28c442        	addi	a4, a4, 40
403744de:	004200        	break	2, 0
403744e1:	600080        	neg	a0, a8
403744e4:	28ec      	bnez.n	a8, 4037450a <_iram_text_start+0x106>
403744e6:	3fc9      	s32i.n	a12, a15, 12
403744e8:	c928c0        	lsi	f12, a8, 0x324
403744eb:	3f          	.byte	0x3f
403744ec:	0c0020        	lsi	f2, a0, 48
403744ef:	001860        	movsp	a6, a8
403744f2:	600c      	movi.n	a0, 6
403744f4:	069c      	beqz.n	a6, 40374508 <_iram_text_start+0x104>
403744f6:	d84000        	lsi	f0, a0, 0x360
403744f9:	400006        	j	403844fd <_coredump_iram_end+0x24fd>
403744fc:	ff          	.byte	0xff
403744fd:	ff          	.byte	0xff
403744fe:	ff          	.byte	0xff
403744ff:	bcfd      	lsi	f15, a12, 48
40374501:	c949      	s32i.n	a4, a9, 48
40374503:	3f          	.byte	0x3f
40374504:	040025        	call8	40378508 <mspi_timing_set_pin_drive_strength+0x34>
40374507:	59f800        	s32nb	a0, a8, 60
4037450a:	ff4037        	ball	a0, a3, 4037450d <_iram_text_start+0x109>
4037450d:	7f          	.byte	0x7f
4037450e:	5c0000        	lsi	f0, a0, 0x170
40374511:	3c0206        	j	4038351d <_coredump_iram_end+0x151d>
40374514:	0270d4        	lsi	f13, a0, 8
40374517:	ad3c      	movi.n	a13, 58
40374519:	3c0206        	j	40383525 <_coredump_iram_end+0x1525>
4037451c:	000000        	ill
4037451f:	80c880        	add	a12, a8, a8
40374522:	186000        	lsxp	f6, a0, a0
40374525:	600260        	lsi	f6, a2, 0x180
40374528:	af          	.byte	0xaf
40374529:	3f          	.byte	0x3f
4037452a:	070000        	lsi	f0, a0, 28
4037452d:	201200        	or	a1, a2, a0
40374530:	0c0024        	lsi	f2, a0, 48
40374533:	004460        	break	4, 6
40374536:	600c      	movi.n	a0, 6
40374538:	0270f0        	andb	b7, b0, b15
4037453b:	f83c      	movi.n	a8, 63
4037453d:	3c0270        	lsi	f7, a2, 240
40374540:	004154        	lsi	f5, a1, 0
40374543:	415860        	srli	a5, a6, 8
40374546:	5c6000        	lsi	f0, a0, 0x170
40374549:	600041        	l32r	a4, 4034c54c <rom_rx_gain_force+0x346120>
4037454c:	004160        	break	1, 6
4037454f:	416460        	srli	a6, a6, 4
40374552:	686000        	lsi	f0, a0, 0x1a0
40374555:	600041        	l32r	a4, 4034c558 <rom_rx_gain_force+0x34612c>
40374558:	0c0004        	lsi	f0, a0, 48
4037455b:	0dbc60        	lsi	f6, a12, 52
4037455e:	444000        	extui	a4, a0, 0, 5
40374561:	400025        	call8	403b4564 <_coredump_iram_end+0x32564>
40374564:	000de0        	callx8	a13
40374567:	0dd440        	lsi	f4, a4, 52
4037456a:	284000        	lsi	f0, a0, 160
4037456d:	0e          	.byte	0xe
4037456e:	ec4000        	lsi	f0, a0, 0x3b0
40374571:	000d      	mov.n	a0, a0
40374573:	0e0440        	lsi	f4, a4, 56
40374576:	6c4000        	lsi	f0, a0, 0x1b0
40374579:	0018      	l32i.n	a1, a0, 0
4037457b:	188440        	lsxp	f8, a4, a4
4037457e:	e44000        	extui	a4, a0, 0, 15
40374581:	400006        	j	40384585 <_coredump_iram_end+0x2585>
40374584:	c92000        	lsi	f0, a0, 0x324
40374587:	3f          	.byte	0x3f
40374588:	c949c0        	lsi	f12, a9, 0x324
4037458b:	3f          	.byte	0x3f
4037458c:	0e1c      	movi.n	a14, 16
4037458e:	d04000        	subx2	a4, a0, a0
40374591:	c949      	s32i.n	a4, a9, 48
40374593:	3f          	.byte	0x3f
40374594:	49cc      	bnez.n	a9, 4037459c <_iram_text_start+0x198>
40374596:	3fc9      	s32i.n	a12, a15, 12
40374598:	c949d1        	l32r	a13, 40366abc <rom_rx_gain_force+0x360690>
4037459b:	3f          	.byte	0x3f
4037459c:	002074        	lsi	f7, a0, 0
4037459f:	6c1842        	l16ui	a4, a8, 216
403745a2:	f84201        	l32r	a0, 403726ac <rom_rx_gain_force+0x36c280>
403745a5:	0019      	s32i.n	a1, a0, 0
403745a7:	21b042        	l32ai	a4, a0, 132
403745aa:	e84200        	lsi	f0, a2, 0x3a0
403745ad:	c949      	s32i.n	a4, a9, 48
403745af:	3f          	.byte	0x3f
403745b0:	201c      	movi.n	a0, 18
403745b2:	3fc9      	s32i.n	a12, a15, 12
403745b4:	000000        	ill
403745b7:	003c10        	rfi	12
403745ba:	600c      	movi.n	a0, 6
403745bc:	0038      	l32i.n	a3, a0, 0
403745be:	600c      	movi.n	a0, 6
403745c0:	c949f4        	lsi	f15, a9, 0x324
403745c3:	3f          	.byte	0x3f
403745c4:	c949f0        	lsi	f15, a9, 0x324
403745c7:	3f          	.byte	0x3f
403745c8:	49ec      	bnez.n	a9, 403745f0 <_iram_text_start+0x1ec>
403745ca:	3fc9      	s32i.n	a12, a15, 12
403745cc:	2018      	l32i.n	a1, a0, 8
403745ce:	3fc9      	s32i.n	a12, a15, 12
403745d0:	09c8      	l32i.n	a12, a9, 0
403745d2:	643c02        	lsi	f0, a12, 0x190
403745d5:	0e          	.byte	0xe
403745d6:	683c02        	lsi	f0, a12, 0x1a0
403745d9:	0e          	.byte	0xe
403745da:	903c02        	lsi	f0, a12, 0x240
403745dd:	001d      	mov.n	a1, a0
403745df:	1dbc42        	l32ai	a4, a12, 116
403745e2:	f04200        	subx8	a4, a2, a0
403745e5:	7f          	.byte	0x7f
403745e6:	e0c037        	bnall	a0, a3, 403745ca <_iram_text_start+0x1c6>
403745e9:	7f          	.byte	0x7f
403745ea:	000007        	bnone	a0, a0, 403745ee <_iram_text_start+0x1ea>
403745ed:	9ff020        	f64cmph	a15, a0, a2, 9
403745f0:	ff          	.byte	0xff
403745f1:	1f          	.byte	0x1f
403745f2:	000000        	ill
403745f5:	400000        	ssr	a0
403745f8:	fffd      	lsi	f15, a15, 60
403745fa:	ff          	.byte	0xff
403745fb:	ffbd      	lsi	f11, a15, 60
403745fd:	ff          	.byte	0xff
403745fe:	ff          	.byte	0xff
403745ff:	fffd01        	l32r	a0, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40374602:	bfc8      	l32i.n	a12, a15, 44
40374604:	ff          	.byte	0xff
40374605:	ff          	.byte	0xff
40374606:	fd0006        	j	40373a0a <rom_rx_gain_force+0x36d5de>
40374609:	ff          	.byte	0xff
4037460a:	ff          	.byte	0xff
4037460b:	bf          	.byte	0xbf
4037460c:	ff          	.byte	0xff
4037460d:	ff          	.byte	0xff
4037460e:	fd0005        	call0	40371610 <rom_rx_gain_force+0x36b1e4>
40374611:	1f          	.byte	0x1f
40374612:	7c9ff0        	lsi	f15, a15, 0x1f0
40374615:	0e          	.byte	0xe
40374616:	8c3c02        	lsi	f0, a12, 0x230
40374619:	0e          	.byte	0xe
4037461a:	9c3c02        	lsi	f0, a12, 0x270
4037461d:	0e          	.byte	0xe
4037461e:	ac3c02        	lsi	f0, a12, 0x2b0
40374621:	0e          	.byte	0xe
40374622:	203c02        	lsi	f0, a12, 128
40374625:	0f          	.byte	0xf
40374626:	a83c02        	lsi	f0, a12, 0x2a0
40374629:	3c0272        	l8ui	a7, a2, 60
4037462c:	0f58      	l32i.n	a5, a15, 0
4037462e:	003c02        	lsi	f0, a12, 0
40374631:	c94a      	add.n	a12, a9, a4
40374633:	3f          	.byte	0x3f
40374634:	c94a04        	lsi	f0, a10, 0x324
40374637:	3f          	.byte	0x3f
40374638:	49f8      	l32i.n	a15, a9, 16
4037463a:	3fc9      	s32i.n	a12, a15, 12
4037463c:	4a1c      	movi.n	a10, 20
4037463e:	3fc9      	s32i.n	a12, a15, 12
40374640:	c94a14        	lsi	f1, a10, 0x324
40374643:	3f          	.byte	0x3f
40374644:	4a0c      	movi.n	a10, 4
40374646:	3fc9      	s32i.n	a12, a15, 12
40374648:	c94a24        	lsi	f2, a10, 0x324
4037464b:	3f          	.byte	0x3f
4037464c:	002374        	lsi	f7, a3, 0
4037464f:	4a3c42        	lsi	f4, a12, 0x128
40374652:	3fc9      	s32i.n	a12, a15, 12
40374654:	007000        	waiti	0
40374657:	285860        	lsi	f6, a8, 160
4037465a:	d03c02        	lsi	f0, a12, 0x340
4037465d:	c94b      	addi.n	a12, a9, 4
4037465f:	3f          	.byte	0x3f
40374660:	027a24        	lsi	f2, a10, 8
40374663:	403c      	movi.n	a0, 52
40374665:	3fc920        	f64cmph	a12, a9, a2, 3
40374668:	001800        	movsp	a0, a8
4037466b:	140000        	extui	a0, a0, 0, 2
4037466e:	000000        	ill
40374671:	000010        	lsi	f1, a0, 0
40374674:	7a08      	l32i.n	a0, a10, 28
40374676:	d83c02        	lsi	f0, a12, 0x360
40374679:	0279      	s32i.n	a7, a2, 0
4037467b:	ec3c      	movi.n	a12, 62
4037467d:	0279      	s32i.n	a7, a2, 0
4037467f:	c43c      	movi.n	a4, 60
40374681:	0279      	s32i.n	a7, a2, 0
40374683:	003c      	movi.n	a0, 48
40374685:	c03780        	sub	a3, a7, a8
40374688:	ff          	.byte	0xff
40374689:	7f          	.byte	0x7f
4037468a:	d40006        	j	4036968e <rom_rx_gain_force+0x363262>
4037468d:	3c0232        	l8ui	a3, a2, 60
40374690:	027d24        	lsi	f2, a13, 8
40374693:	3e3c      	movi.n	a14, 51
40374695:	3c0233        	lsi	f3, a2, 240
40374698:	7ffc      	bnez.n	a15, 403746d3 <_iram_text_start+0x2cf>
4037469a:	fcc037        	bnall	a0, a3, 4037469a <_iram_text_start+0x296>
4037469d:	1f          	.byte	0x1f
4037469e:	509ff0        	lsi	f15, a15, 0x140
403746a1:	3c0233        	lsi	f3, a2, 240
403746a4:	0233a0        	andb	b3, b3, b10
403746a7:	b43c      	movi.n	a4, 59
403746a9:	3c0233        	lsi	f3, a2, 240
403746ac:	6f0000        	f64cmph	a0, a0, a0, 6
403746af:	800000        	add	a0, a0, a0
403746b2:	bfc8      	l32i.n	a12, a15, 44
403746b4:	c94bd4        	lsi	f13, a11, 0x324
403746b7:	3f          	.byte	0x3f
403746b8:	0233c4        	lsi	f12, a3, 8
403746bb:	3c3c      	movi.n	a12, 51
403746bd:	027d      	mov.n	a7, a2
403746bf:	003c      	movi.n	a0, 48
403746c1:	020000        	andb	b0, b0, b0
403746c4:	023404        	lsi	f0, a4, 8
403746c7:	0c3c      	movi.n	a12, 48
403746c9:	027d      	mov.n	a7, a2
403746cb:	403c      	movi.n	a0, 52
403746cd:	3c0234        	lsi	f3, a2, 240
403746d0:	0f4240        	f64cmph	a4, a2, a4, 0
403746d3:	1a4000        	sub.s	f4, f0, f0
403746d6:	504000        	iitlb	a0
403746d9:	3fc920        	f64cmph	a12, a9, a2, 3
403746dc:	c94be4        	lsi	f14, a11, 0x324
403746df:	3f          	.byte	0x3f
403746e0:	4bd8      	l32i.n	a13, a11, 16
403746e2:	3fc9      	s32i.n	a12, a15, 12
403746e4:	4bdc      	bnez.n	a11, 403746fc <_iram_text_start+0x2f8>
403746e6:	3fc9      	s32i.n	a12, a15, 12
403746e8:	0234a4        	lsi	f10, a4, 8
403746eb:	6c3c      	movi.n	a12, 54
403746ed:	027d      	mov.n	a7, a2
403746ef:	d03c      	movi.n	a0, 61
403746f1:	3c0234        	lsi	f3, a2, 240
403746f4:	001b54        	lsi	f5, a11, 0
403746f7:	205840        	or	a5, a8, a4
403746fa:	3fc9      	s32i.n	a12, a15, 12
403746fc:	c94bf0        	lsi	f15, a11, 0x324
403746ff:	3f          	.byte	0x3f
40374700:	8048      	l32i.n	a4, a0, 32
40374702:	406000        	rer	a0, a0
40374705:	c92a      	add.n	a12, a9, a2
40374707:	3f          	.byte	0x3f
40374708:	2a48      	l32i.n	a4, a10, 8
4037470a:	3fc9      	s32i.n	a12, a15, 12
4037470c:	804c      	movi.n	a0, 72
4037470e:	4c6000        	lsi	f0, a0, 0x130
40374711:	c92a      	add.n	a12, a9, a2
40374713:	3f          	.byte	0x3f
40374714:	c92a50        	lsi	f5, a10, 0x324
40374717:	3f          	.byte	0x3f
40374718:	c92a54        	lsi	f5, a10, 0x324
4037471b:	3f          	.byte	0x3f
4037471c:	c92060        	lsi	f6, a0, 0x324
4037471f:	3f          	.byte	0x3f
40374720:	005d54        	lsi	f5, a13, 0
40374723:	5d6040        	lsi	f4, a0, 0x174
40374726:	6c4000        	lsi	f0, a0, 0x1b0
40374729:	005d      	mov.n	a5, a0
4037472b:	4f0040        	f64cmph	a0, a0, a4, 4
4037472e:	3fc9      	s32i.n	a12, a15, 12
40374730:	c92100        	lsi	f0, a1, 0x324
40374733:	3f          	.byte	0x3f
40374734:	024da4        	lsi	f10, a13, 8
40374737:	dc3c      	movi.n	a12, 61
40374739:	3c0284        	lsi	f8, a2, 240
4037473c:	4dec      	bnez.n	a13, 40374764 <_iram_text_start+0x360>
4037473e:	f43c02        	lsi	f0, a12, 0x3d0
40374741:	024d      	mov.n	a4, a2
40374743:	083c      	movi.n	a8, 48
40374745:	3c0285        	call0	403b0770 <_coredump_iram_end+0x2e770>
40374748:	2b98      	l32i.n	a9, a11, 8
4037474a:	f03c02        	lsi	f0, a12, 0x3c0
4037474d:	3c0284        	lsi	f8, a2, 240
40374750:	4e08      	l32i.n	a0, a14, 16
40374752:	203c02        	lsi	f0, a12, 128
40374755:	3c0285        	call0	403b0780 <_coredump_iram_end+0x2e780>
40374758:	10c433        	ssip	f3, a4, 64
4037475b:	78bb      	addi.n	a7, a8, 11
4037475d:	4f          	.byte	0x4f
4037475e:	3fc9      	s32i.n	a12, a15, 12
40374760:	c94f24        	lsi	f2, a15, 0x324
40374763:	3f          	.byte	0x3f
40374764:	005cb4        	lsi	f11, a12, 0
40374767:	5d6c42        	s32i	a4, a12, 0x174
4037476a:	744200        	extui	a4, a0, 2, 8
4037476d:	400025        	call8	403b4770 <_coredump_iram_end+0x32770>
40374770:	27c8      	l32i.n	a12, a7, 8
40374772:	3fc9      	s32i.n	a12, a15, 12
40374774:	4ff8      	l32i.n	a15, a15, 16
40374776:	3fc9      	s32i.n	a12, a15, 12
40374778:	c95000        	lsi	f0, a0, 0x324
4037477b:	3f          	.byte	0x3f
4037477c:	038000        	rsr.ibreaka0	a0
4037477f:	501060        	lsi	f6, a0, 0x140
40374782:	3fc9      	s32i.n	a12, a15, 12
40374784:	500c      	movi.n	a0, 5
40374786:	3fc9      	s32i.n	a12, a15, 12
40374788:	5d68      	l32i.n	a6, a13, 20
4037478a:	243c02        	lsi	f0, a12, 144
4037478d:	000400        	lsi	f0, a4, 0
40374790:	000000        	ill
40374793:	24d8c0        	extui	a13, a12, 8, 3
40374796:	3fc9      	s32i.n	a12, a15, 12
40374798:	6da8      	l32i.n	a10, a13, 24
4037479a:	604037        	ball	a0, a3, 403747fe <_iram_text_start+0x3fa>
4037479d:	3c0287        	bnone	a2, a8, 403747dd <_iram_text_start+0x3d9>
403747a0:	c926e0        	lsi	f14, a6, 0x324
403747a3:	3f          	.byte	0x3f
403747a4:	c92700        	lsi	f0, a7, 0x324
403747a7:	3f          	.byte	0x3f
403747a8:	028740        	andb	b8, b7, b4
403747ab:	213c      	movi.n	a1, 50
403747ad:	000400        	lsi	f0, a4, 0
403747b0:	ff          	.byte	0xff
403747b1:	000637        	bnone	a6, a3, 403747b5 <_iram_text_start+0x3b1>
403747b4:	22d8      	l32i.n	a13, a2, 8
403747b6:	3fc9      	s32i.n	a12, a15, 12
403747b8:	71dc      	bnez.n	a1, 403747d3 <_iram_text_start+0x3cf>
403747ba:	224037        	ball	a0, a3, 403747e0 <_iram_text_start+0x3dc>
403747bd:	000400        	lsi	f0, a4, 0
403747c0:	380000        	lsi	f0, a0, 224
403747c3:	728c00        	lsi	f0, a12, 0x1c8
403747c6:	234037        	ball	a0, a3, 403747ed <_iram_text_start+0x3e9>
403747c9:	000400        	lsi	f0, a4, 0
403747cc:	c08800        	sub	a8, a8, a0
403747cf:	3028      	l32i.n	a2, a0, 12
403747d1:	5e          	.byte	0x5e
403747d2:	9c3c02        	lsi	f0, a12, 0x270
403747d5:	0288      	l32i.n	a8, a2, 0
403747d7:	793c      	movi.n	a9, 55
403747d9:	5e          	.byte	0x5e
403747da:	8c3c02        	lsi	f0, a12, 0x230
403747dd:	5e          	.byte	0x5e
403747de:	003c02        	lsi	f0, a12, 0
403747e1:	600020        	neg	a0, a2
403747e4:	200000        	or	a0, a0, a0
403747e7:	000000        	ill
403747ea:	ff7000        	f64cmph	a7, a0, a0, 15
403747ed:	ff          	.byte	0xff
403747ee:	ff          	.byte	0xff
403747ef:	bf          	.byte	0xbf
403747f0:	ceffe4        	lsi	f14, a15, 0x338
403747f3:	3f          	.byte	0x3f
403747f4:	ff          	.byte	0xff
403747f5:	ff          	.byte	0xff
403747f6:	ff          	.byte	0xff
403747f7:	df          	.byte	0xdf
403747f8:	ff          	.byte	0xff
403747f9:	ff          	.byte	0xff
403747fa:	ff          	.byte	0xff
403747fb:	fffff7        	bbsi	a15, 31, 403747fe <_iram_text_start+0x3fa>
403747fe:	ff          	.byte	0xff
403747ff:	ef          	.byte	0xef
40374800:	040000        	extui	a0, a0, 0, 1
40374803:	205800        	or	a5, a8, a0
40374806:	ff6000        	f64cmph	a6, a0, a0, 15
40374809:	ff          	.byte	0xff
4037480a:	ff          	.byte	0xff
4037480b:	7f          	.byte	0x7f
4037480c:	003000        	rfe
4037480f:	ffff60        	f64cmph	a15, a15, a6, 15
40374812:	ff          	.byte	0xff
40374813:	ffff41        	l32r	a4, 40374810 <_iram_text_start+0x40c> (41ffffff <_coredump_iram_end+0x1c7dfff>)
40374816:	ff          	.byte	0xff
40374817:	ffff43        	lsi	f4, a15, 0x3fc
4037481a:	ff          	.byte	0xff
4037481b:	ff3b      	addi.n	a15, a15, 3
4037481d:	ff          	.byte	0xff
4037481e:	ff          	.byte	0xff
4037481f:	983d      	lsi	f3, a8, 32
40374821:	3c0245        	call0	403b0848 <_coredump_iram_end+0x2e848>
40374824:	891c      	movi.n	a9, 24
40374826:	803c02        	lsi	f0, a12, 0x200
40374829:	3c0204        	muls.ad.ll	a2, m2
4037482c:	50c8      	l32i.n	a12, a0, 20
4037482e:	3fc9      	s32i.n	a12, a15, 12
40374830:	0008      	l32i.n	a0, a0, 0
40374832:	0e          	.byte	0xe
40374833:	ffff00        	f64cmph	a15, a15, a0, 15
40374836:	fff9      	s32i.n	a15, a15, 60
40374838:	ff          	.byte	0xff
40374839:	ff          	.byte	0xff
4037483a:	fffff7        	bbsi	a15, 31, 4037483d <_iram_text_start+0x439>
4037483d:	7f          	.byte	0x7f
4037483e:	200007        	bnone	a0, a0, 40374862 <_iram_text_start+0x45e>
40374841:	3c0263        	lsi	f6, a2, 240
40374844:	89a8      	l32i.n	a10, a9, 32
40374846:	0f3c02        	lsi	f0, a12, 60
40374849:	3c0263        	lsi	f6, a2, 240
4037484c:	272c      	movi.n	a7, 34
4037484e:	3fc9      	s32i.n	a12, a15, 12
40374850:	6348      	l32i.n	a4, a3, 24
40374852:	603c02        	lsi	f0, a12, 0x180
40374855:	3c0263        	lsi	f6, a2, 240
40374858:	c950f7        	bbc	a0, a15, 40374825 <_iram_text_start+0x421>
4037485b:	3f          	.byte	0x3f
4037485c:	377980        	lsi	f8, a9, 220
4037485f:	50fc40        	rdtlb1	a4, a12
40374862:	3fc9      	s32i.n	a12, a15, 12
40374864:	9e2c      	movi.n	a14, 41
40374866:	d44200        	extui	a4, a0, 2, 14
40374869:	420026        	beqi	a0, -1, 403748af <_iram_text_start+0x4ab>
4037486c:	c950f6        	bgeui	a0, 5, 40374839 <_iram_text_start+0x435>
4037486f:	3f          	.byte	0x3f
40374870:	026374        	lsi	f7, a3, 8
40374873:	743c      	movi.n	a4, 55
40374875:	0289      	s32i.n	a8, a2, 0
40374877:	8c3c      	movi.n	a12, 56
40374879:	3c0263        	lsi	f6, a2, 240
4037487c:	009e40        	all4	b4, b12:b13:b14:b15
4037487f:	000042        	l8ui	a4, a0, 0
40374882:	ff          	.byte	0xff
40374883:	ff          	.byte	0xff
40374884:	010000        	slli	a0, a0, 32
40374887:	510400        	lsi	f0, a4, 0x144
4037488a:	3fc9      	s32i.n	a12, a15, 12
4037488c:	000894        	lsi	f9, a8, 0
4037488f:	367840        	lsi	f4, a8, 216
40374892:	3fc9      	s32i.n	a12, a15, 12
40374894:	006003        	lsi	f0, a0, 0
40374897:	510800        	lsi	f0, a8, 0x144
4037489a:	3fc9      	s32i.n	a12, a15, 12
4037489c:	276c      	movi.n	a7, -30
4037489e:	3fc9      	s32i.n	a12, a15, 12
403748a0:	368c      	beqz.n	a6, 403748a7 <_iram_text_start+0x4a3>
403748a2:	3fc9      	s32i.n	a12, a15, 12
403748a4:	0264e0        	andb	b6, b4, b14
403748a7:	053c      	movi.n	a5, 48
403748a9:	000060        	lsi	f6, a0, 0
403748ac:	026500        	andb	b6, b5, b0
403748af:	483c      	movi.n	a8, 52
403748b1:	3c0266        	bnei	a2, -1, 403748f1 <_iram_text_start+0x4ed>
403748b4:	000000        	ill
403748b7:	652801        	l32r	a0, 4034dd58 <rom_rx_gain_force+0x34792c>
403748ba:	203c02        	lsi	f0, a12, 128
403748bd:	028a      	add.n	a0, a2, a8
403748bf:	983c      	movi.n	a8, 57
403748c1:	3c0265        	call8	403b08e8 <_coredump_iram_end+0x2e8e8>
403748c4:	00a024        	lsi	f2, a0, 0
403748c7:	270f42        	l8ui	a4, a15, 39
403748ca:	1f0000        	f64cmph	a0, a0, a0, 1
403748cd:	4e          	.byte	0x4e
403748ce:	540000        	extui	a0, a0, 0, 6
403748d1:	0268      	l32i.n	a6, a2, 0
403748d3:	fc3c      	movi.n	a12, 63
403748d5:	028a      	add.n	a0, a2, a8
403748d7:	833c      	movi.n	a3, 56
403748d9:	0268      	l32i.n	a6, a2, 0
403748db:	043c      	movi.n	a4, 48
403748dd:	0008      	l32i.n	a0, a0, 0
403748df:	2c6000        	lsi	f0, a0, 176
403748e2:	ac4200        	lsi	f0, a2, 0x2b0
403748e5:	00a8      	l32i.n	a10, a0, 0
403748e7:	a8fc42        	s32ri	a4, a12, 0x2a0
403748ea:	304200        	xor	a4, a2, a0
403748ed:	600c00        	lsi	f0, a12, 0x180
403748f0:	0c0034        	lsi	f3, a0, 48
403748f3:	279460        	lsi	f6, a4, 156
403748f6:	3fc9      	s32i.n	a12, a15, 12
403748f8:	689c      	beqz.n	a8, 40374912 <_iram_text_start+0x50e>
403748fa:	183c02        	lsi	f0, a12, 96
403748fd:	028b      	addi.n	a0, a2, 8
403748ff:	e43c      	movi.n	a4, 62
40374901:	0268      	l32i.n	a6, a2, 0
40374903:	143c      	movi.n	a4, 49
40374905:	3fc951        	l32r	a5, 4034482c <rom_rx_gain_force+0x33e400>
40374908:	000000        	ill
4037490b:	00fc      	bnez.n	a0, 4037493f <_iram_text_start+0x53b>
4037490d:	03f000        	rsr.ccompare0	a0
40374910:	023450        	andb	b3, b4, b5
40374913:	5c3c      	movi.n	a12, 53
40374915:	027d      	mov.n	a7, a2
40374917:	9c3c      	movi.n	a12, 57
40374919:	3c0234        	lsi	f3, a2, 240
4037491c:	008000        	any4	b0, b0:b1:b2:b3
4037491f:	80bc60        	add	a11, a12, a6
40374922:	4c6000        	lsi	f0, a0, 0x130
40374925:	027d      	mov.n	a7, a2
40374927:	4c3c      	movi.n	a12, 52
40374929:	c939      	s32i.n	a3, a9, 48
4037492b:	3f          	.byte	0x3f
4037492c:	3808      	l32i.n	a0, a8, 12
4037492e:	3fc9      	s32i.n	a12, a15, 12
40374930:	c93aa0        	lsi	f10, a10, 0x324
40374933:	3f          	.byte	0x3f
40374934:	060003        	lsi	f0, a0, 24
40374937:	3ad400        	lsi	f0, a4, 232
4037493a:	3fc9      	s32i.n	a12, a15, 12
4037493c:	3828      	l32i.n	a2, a8, 12
4037493e:	3fc9      	s32i.n	a12, a15, 12
40374940:	c93b20        	lsi	f2, a11, 0x324
40374943:	3f          	.byte	0x3f
40374944:	003014        	lsi	f1, a0, 0
40374947:	201460        	or	a1, a4, a6
4037494a:	e46000        	extui	a6, a0, 0, 15
4037494d:	3fc937        	bnall	a9, a3, 40374990 <_iram_text_start+0x58c>
40374950:	003050        	lsi	f5, a0, 0
40374953:	33fc60        	clamps	a15, a12, 13
40374956:	4c6000        	lsi	f0, a0, 0x130
40374959:	c938      	l32i.n	a3, a9, 48
4037495b:	3f          	.byte	0x3f
4037495c:	000c00        	lsi	f0, a12, 0
4037495f:	4c2800        	lsi	f0, a8, 0x130
40374962:	3fc9      	s32i.n	a12, a15, 12
40374964:	3988      	l32i.n	a8, a9, 12
40374966:	3fc9      	s32i.n	a12, a15, 12
40374968:	c93870        	lsi	f7, a8, 0x324
4037496b:	3f          	.byte	0x3f
4037496c:	39d9      	s32i.n	a13, a9, 12
4037496e:	3fc9      	s32i.n	a12, a15, 12
40374970:	0c0010        	lsi	f1, a0, 48
40374973:	e04060        	subx4	a4, a0, a6
40374976:	206000        	or	a6, a0, a0
40374979:	c94c      	movi.n	a9, 76
4037497b:	3f          	.byte	0x3f
4037497c:	0084c0        	any4	b12, b4:b5:b6:b7
4037497f:	000060        	lsi	f6, a0, 0
40374982:	0008      	l32i.n	a0, a0, 0
40374984:	0084c4        	lsi	f12, a4, 0
40374987:	806060        	add	a6, a0, a6
4037498a:	ff6000        	f64cmph	a6, a0, a0, 15
4037498d:	ff          	.byte	0xff
4037498e:	7f          	.byte	0x7f
4037498f:	ff          	.byte	0xff
40374990:	ff          	.byte	0xff
40374991:	ff          	.byte	0xff
40374992:	00fff1        	l32r	a15, 40334d90 <rom_rx_gain_force+0x32e964>
40374995:	000600        	lsi	f0, a6, 0
40374998:	ff          	.byte	0xff
40374999:	1f          	.byte	0x1f
4037499a:	ff          	.byte	0xff
4037499b:	ff          	.byte	0xff
4037499c:	ff          	.byte	0xff
4037499d:	ffffe3        	lsi	f14, a15, 0x3fc
403749a0:	ff          	.byte	0xff
403749a1:	ff          	.byte	0xff
403749a2:	fe          	.byte	0xfe
403749a3:	ff          	.byte	0xff
403749a4:	009040        	all4	b4, b0:b1:b2:b3
403749a7:	890460        	lsi	f6, a4, 0x224
403749aa:	d86000        	lsi	f0, a0, 0x360
403749ad:	600080        	neg	a0, a8
403749b0:	800000        	add	a0, a0, a0
403749b3:	807400        	add	a7, a4, a0
403749b6:	1c6000        	lsi	f0, a0, 112
403749b9:	600080        	neg	a0, a8
403749bc:	3f          	.byte	0x3f
403749bd:	ffffc0        	f64cmph	a15, a15, a12, 15
403749c0:	394c      	movi.n	a9, 67
403749c2:	3fc9      	s32i.n	a12, a15, 12
403749c4:	c938a0        	lsi	f10, a8, 0x324
403749c7:	3f          	.byte	0x3f
403749c8:	c939e4        	lsi	f14, a9, 0x324
403749cb:	3f          	.byte	0x3f
403749cc:	5a8c      	beqz.n	a10, 403749d5 <_iram_text_start+0x5d1>
403749ce:	404200        	ssai	2
403749d1:	000213        	lsi	f1, a2, 0
403749d4:	010b07        	bnone	a11, a0, 403749d9 <_iram_text_start+0x5d5>
403749d7:	000000        	ill
403749da:	c02000        	sub	a2, a0, a0
403749dd:	600080        	neg	a0, a8
403749e0:	3a1c      	movi.n	a10, 19
403749e2:	3fc9      	s32i.n	a12, a15, 12
403749e4:	c93a24        	lsi	f2, a10, 0x324
403749e7:	3f          	.byte	0x3f
403749e8:	0c0060        	lsi	f6, a0, 48
403749eb:	3a6060        	lsi	f6, a0, 232
403749ee:	3fc9      	s32i.n	a12, a15, 12
403749f0:	c94c24        	lsi	f2, a12, 0x324
403749f3:	3f          	.byte	0x3f
403749f4:	666667        	bbci	a6, 6, 40374a5e <_iram_text_start+0x65a>
403749f7:	207066        	bnei	a0, 7, 40374a1b <_iram_text_start+0x617>
403749fa:	3fc9      	s32i.n	a12, a15, 12
403749fc:	c92074        	lsi	f7, a0, 0x324
403749ff:	3f          	.byte	0x3f
40374a00:	81fc      	bnez.n	a1, 40374a3c <_iram_text_start+0x638>
40374a02:	ff6000        	f64cmph	a6, a0, a0, 15
40374a05:	1f          	.byte	0x1f
40374a06:	fff8      	l32i.n	a15, a15, 60
40374a08:	ff          	.byte	0xff
40374a09:	fffff3        	lsi	f15, a15, 0x3fc
40374a0c:	c4b400        	extui	a11, a0, 4, 13
40374a0f:	206804        	lsi	f0, a8, 128
40374a12:	3fc9      	s32i.n	a12, a15, 12
40374a14:	206c      	movi.n	a0, -30
40374a16:	3fc9      	s32i.n	a12, a15, 12
40374a18:	1a4c      	movi.n	a10, 65
40374a1a:	944000        	extui	a4, a0, 0, 10
40374a1d:	c93a      	add.n	a12, a9, a3
40374a1f:	3f          	.byte	0x3f
40374a20:	3888      	l32i.n	a8, a8, 12
40374a22:	3fc9      	s32i.n	a12, a15, 12
40374a24:	00e000        	lsi	f0, a0, 0
40374a27:	809000        	add	a9, a0, a0
40374a2a:	886000        	lsi	f0, a0, 0x220
40374a2d:	600080        	neg	a0, a8
40374a30:	ff          	.byte	0xff
40374a31:	fffff7        	bbsi	a15, 31, 40374a34 <_iram_text_start+0x630>
40374a34:	609c      	beqz.n	a0, 40374a4e <_iram_text_start+0x64a>
40374a36:	546002        	s32i	a0, a0, 0x150
40374a39:	6001d0        	abs	a0, a13
40374a3c:	01ccd4        	lsi	f13, a12, 4
40374a3f:	609060        	neg	a9, a6
40374a42:	f06000        	subx8	a6, a0, a0
40374a45:	600050        	neg	a0, a5
40374a48:	0260b0        	andb	b6, b0, b11
40374a4b:	3ff860        	f64cmph	a15, a8, a6, 3
40374a4e:	070000        	lsi	f0, a0, 28
40374a51:	ffffc0        	f64cmph	a15, a15, a12, 15
40374a54:	f068      	l32i.n	a6, a0, 60
40374a56:	806001        	l32r	a0, 40354bd8 <rom_rx_gain_force+0x34e7ac>
40374a59:	6001f0        	abs	a0, a15
40374a5c:	ff          	.byte	0xff
40374a5d:	9f          	.byte	0x9f
40374a5e:	ff          	.byte	0xff
40374a5f:	ff          	.byte	0xff
40374a60:	ff          	.byte	0xff
40374a61:	ef          	.byte	0xef
40374a62:	ff          	.byte	0xff
40374a63:	ff          	.byte	0xff
40374a64:	ff          	.byte	0xff
40374a65:	ff          	.byte	0xff
40374a66:	6c8000        	lsi	f0, a0, 0x1b0
40374a69:	6001f0        	abs	a0, a15
40374a6c:	3758      	l32i.n	a5, a7, 12
40374a6e:	803c02        	lsi	f0, a12, 0x200
40374a71:	7e          	.byte	0x7e
40374a72:	953c02        	lsi	f0, a12, 0x254
40374a75:	3c0237        	bnone	a2, a3, 40374ab5 <_iram_text_start+0x6b1>
40374a78:	0237a0        	andb	b3, b7, b10
40374a7b:	683c      	movi.n	a8, 54
40374a7d:	7e          	.byte	0x7e
40374a7e:	0c3c02        	lsi	f0, a12, 48
40374a81:	600080        	neg	a0, a8
40374a84:	008010        	any4	b1, b0:b1:b2:b3
40374a87:	801460        	add	a1, a4, a6
40374a8a:	006000        	rsil	a0, 0
40374a8d:	600c00        	lsi	f0, a12, 0x180
40374a90:	002000        	isync
40374a93:	dfff00        	f64cmph	a15, a15, a0, 13
40374a96:	ff          	.byte	0xff
40374a97:	ff          	.byte	0xff
40374a98:	01f000        	slli	a15, a0, 32
40374a9b:	bfff60        	f64cmph	a15, a15, a6, 11
40374a9e:	ff          	.byte	0xff
40374a9f:	ff          	.byte	0xff
40374aa0:	38b8      	l32i.n	a11, a8, 12
40374aa2:	3fc9      	s32i.n	a12, a15, 12
40374aa4:	c93b94        	lsi	f9, a11, 0x324
40374aa7:	3f          	.byte	0x3f
40374aa8:	3b9c      	beqz.n	a11, 40374abf <_iram_text_start+0x6bb>
40374aaa:	3fc9      	s32i.n	a12, a15, 12
40374aac:	6e88      	l32i.n	a8, a14, 24
40374aae:	583c02        	lsi	f0, a12, 0x160
40374ab1:	3c0293        	lsi	f9, a2, 240
40374ab4:	026e51        	l32r	a5, 4033546c <rom_rx_gain_force+0x32f040>
40374ab7:	443c      	movi.n	a4, 52
40374ab9:	3c0293        	lsi	f9, a2, 240
40374abc:	0c4130        	lsi	f3, a1, 48
40374abf:	189c60        	lsxp	f9, a12, a6
40374ac2:	b44000        	extui	a4, a0, 0, 12
40374ac5:	0018      	l32i.n	a1, a0, 0
40374ac7:	18e440        	lsxp	f14, a4, a4
40374aca:	fc4000        	lsi	f0, a0, 0x3f0
40374acd:	0018      	l32i.n	a1, a0, 0
40374acf:	301840        	xor	a1, a8, a4
40374ad2:	006000        	rsil	a0, 0
40374ad5:	500000        	lsi	f0, a0, 0x140
40374ad8:	301c      	movi.n	a0, 19
40374ada:	206000        	or	a6, a0, a0
40374add:	600030        	neg	a0, a3
40374ae0:	0030e0        	lsi	f14, a0, 0
40374ae3:	08a060        	lsx	f10, a0, a6
40374ae6:	604000        	neg	a4, a0
40374ae9:	000c      	movi.n	a0, 0
40374aeb:	203440        	or	a3, a4, a4
40374aee:	3fc9      	s32i.n	a12, a15, 12
40374af0:	0006b4        	lsi	f11, a6, 0
40374af3:	ffb940        	f64cmph	a11, a9, a4, 15
40374af6:	ce          	.byte	0xce
40374af7:	3f          	.byte	0x3f
40374af8:	ffb8      	l32i.n	a11, a15, 60
40374afa:	ce          	.byte	0xce
40374afb:	3f          	.byte	0x3f
40374afc:	05e8      	l32i.n	a14, a5, 0
40374afe:	e84000        	lsi	f0, a0, 0x3a0
40374b01:	3e          	.byte	0x3e
40374b02:	3fc9      	s32i.n	a12, a15, 12
40374b04:	c93f04        	lsi	f0, a15, 0x324
40374b07:	3f          	.byte	0x3f
40374b08:	3f0c      	movi.n	a15, 3
40374b0a:	3fc9      	s32i.n	a12, a15, 12
40374b0c:	3f18      	l32i.n	a1, a15, 12
40374b0e:	3fc9      	s32i.n	a12, a15, 12
40374b10:	976d      	lsi	f6, a7, 28
40374b12:	444037        	ball	a0, a3, 40374b5a <_iram_text_start+0x756>
40374b15:	3f          	.byte	0x3f
40374b16:	3fc9      	s32i.n	a12, a15, 12
40374b18:	024180        	andb	b4, b1, b8
40374b1b:	603c      	movi.n	a0, 54
40374b1d:	3c0281        	l32r	a8, 40343b28 <rom_rx_gain_force+0x33d6fc>
40374b20:	000d21        	l32r	a2, 40334b54 <rom_rx_gain_force+0x32e728>
40374b23:	41be00        	srli	a11, a0, 14
40374b26:	c83c02        	lsi	f0, a12, 0x320
40374b29:	3c0241        	l32r	a4, 40343b34 <rom_rx_gain_force+0x33d708>
40374b2c:	000d22        	l8ui	a2, a13, 0
40374b2f:	421000        	xorb	b1, b0, b0
40374b32:	243c02        	lsi	f0, a12, 144
40374b35:	3c0282        	l8ui	a8, a2, 60
40374b38:	ff          	.byte	0xff
40374b39:	ff          	.byte	0xff
40374b3a:	3f          	.byte	0x3f
40374b3b:	4218b3        	lsi	f11, a8, 0x108
40374b3e:	3c3c02        	lsi	f0, a12, 240
40374b41:	3c0242        	l8ui	a4, a2, 60
40374b44:	0281f4        	lsi	f15, a1, 8
40374b47:	4c3c      	movi.n	a12, 52
40374b49:	3c0242        	l8ui	a4, a2, 60
40374b4c:	4268      	l32i.n	a6, a2, 16
40374b4e:	e03c02        	lsi	f0, a12, 0x380
40374b51:	3c0281        	l32r	a8, 40343b5c <rom_rx_gain_force+0x33d730>
40374b54:	024274        	lsi	f7, a2, 8
40374b57:	c83c      	movi.n	a8, 60
40374b59:	3c0281        	l32r	a8, 40343b64 <rom_rx_gain_force+0x33d738>
40374b5c:	817c      	movi.n	a1, -8
40374b5e:	803c02        	lsi	f0, a12, 0x200
40374b61:	3c0242        	l8ui	a4, a2, 60
40374b64:	42d8      	l32i.n	a13, a2, 16
40374b66:	283c02        	lsi	f0, a12, 160
40374b69:	3c0243        	lsi	f4, a2, 240
40374b6c:	022934        	lsi	f3, a9, 8
40374b6f:	103c      	movi.n	a0, 49
40374b71:	3c0282        	l8ui	a8, a2, 60
40374b74:	022964        	lsi	f6, a9, 8
40374b77:	7c3c      	movi.n	a12, 55
40374b79:	3c0243        	lsi	f4, a2, 240
40374b7c:	81ac      	beqz.n	a1, 40374ba8 <_iram_text_start+0x7a4>
40374b7e:	4c3c02        	lsi	f0, a12, 0x130
40374b81:	3c0281        	l32r	a8, 40343b8c <rom_rx_gain_force+0x33d760>
40374b84:	024384        	lsi	f8, a3, 8
40374b87:	a03c      	movi.n	a0, 58
40374b89:	3c0243        	lsi	f4, a2, 240
40374b8c:	024404        	lsi	f0, a4, 8
40374b8f:	383c      	movi.n	a8, 51
40374b91:	3c0281        	l32r	a8, 40343b9c <rom_rx_gain_force+0x33d770>
40374b94:	028190        	andb	b8, b1, b9
40374b97:	203c      	movi.n	a0, 50
40374b99:	3c0281        	l32r	a8, 40343ba4 <rom_rx_gain_force+0x33d778>
40374b9c:	086d      	mov.n	a6, a8
40374b9e:	6c0000        	lsi	f0, a0, 0x1b0
40374ba1:	3c0244        	muls.ad.ll	a2, m3
40374ba4:	6e          	.byte	0x6e
40374ba5:	0008      	l32i.n	a0, a0, 0
40374ba7:	811000        	src	a1, a0, a0
40374baa:	333c02        	lsi	f0, a12, 204
40374bad:	0009      	s32i.n	a0, a0, 0
40374baf:	4a4000        	madd.s	f4, f0, f0
40374bb2:	4c3c02        	lsi	f0, a12, 0x130
40374bb5:	024a      	add.n	a0, a2, a4
40374bb7:	003c      	movi.n	a0, 48
40374bb9:	be0000        	f64iter	a0, a0, a0, 3, 0
40374bbc:	c90000        	lsi	f0, a0, 0x324
40374bbf:	bf          	.byte	0xbf
40374bc0:	024a90        	andb	b4, b10, b9
40374bc3:	083c      	movi.n	a8, 48
40374bc5:	4f          	.byte	0x4f
40374bc6:	3fc9      	s32i.n	a12, a15, 12
40374bc8:	4af8      	l32i.n	a15, a10, 16
40374bca:	783c02        	lsi	f0, a12, 0x1e0
40374bcd:	3c0284        	lsi	f8, a2, 240
40374bd0:	024b56        	bnez	a11, 40374bf8 <_iram_text_start+0x7f4>
40374bd3:	3c3c      	movi.n	a12, 51
40374bd5:	3c02a5        	call8	403b0c00 <_coredump_iram_end+0x2ec00>
40374bd8:	000010        	lsi	f1, a0, 0
40374bdb:	012000        	slli	a2, a0, 32
40374bde:	783c02        	lsi	f0, a12, 0x1e0
40374be1:	9f          	.byte	0x9f
40374be2:	304037        	ball	a0, a3, 40374c16 <_iram_text_start+0x812>
40374be5:	000500        	lsi	f0, a5, 0
40374be8:	a54b      	addi.n	a10, a5, 4
40374bea:	383c02        	lsi	f0, a12, 224
40374bed:	001c      	movi.n	a0, 16
40374bef:	293440        	lsi	f4, a4, 164
40374bf2:	643c02        	lsi	f0, a12, 0x190
40374bf5:	3c0284        	lsi	f8, a2, 240
40374bf8:	022964        	lsi	f6, a9, 8
40374bfb:	603c      	movi.n	a0, 54
40374bfd:	024b      	addi.n	a0, a2, 4
40374bff:	883c      	movi.n	a8, 56
40374c01:	024b      	addi.n	a0, a2, 4
40374c03:	a83c      	movi.n	a8, 58
40374c05:	024b      	addi.n	a0, a2, 4
40374c07:	663c      	movi.n	a6, 54
40374c09:	000066        	bnei	a0, -1, 40374c0d <_iram_text_start+0x809>
40374c0c:	4bbc      	beqz.n	a11, 40374c44 <_iram_text_start+0x840>
40374c0e:	003c02        	lsi	f0, a12, 0
40374c11:	024c      	movi.n	a2, 64
40374c13:	f83c      	movi.n	a8, 63
40374c15:	4e          	.byte	0x4e
40374c16:	3fc9      	s32i.n	a12, a15, 12
40374c18:	c94ef0        	lsi	f15, a14, 0x324
40374c1b:	3f          	.byte	0x3f
40374c1c:	843c      	movi.n	a4, 56
40374c1e:	143c02        	lsi	f0, a12, 80
40374c21:	024c      	movi.n	a2, 64
40374c23:	343c      	movi.n	a4, 51
40374c25:	024c      	movi.n	a2, 64
40374c27:	483c      	movi.n	a8, 52
40374c29:	024c      	movi.n	a2, 64
40374c2b:	503c      	movi.n	a0, 53
40374c2d:	3c0284        	lsi	f8, a2, 240
40374c30:	024c54        	lsi	f5, a12, 8
40374c33:	7c3c      	movi.n	a12, 55
40374c35:	024c      	movi.n	a2, 64
40374c37:	743c      	movi.n	a4, 55
40374c39:	400013        	lsi	f1, a0, 0x100
40374c3c:	4ee8      	l32i.n	a14, a14, 16
40374c3e:	3fc9      	s32i.n	a12, a15, 12
40374c40:	c94ee0        	lsi	f14, a14, 0x324
40374c43:	3f          	.byte	0x3f
40374c44:	c93060        	lsi	f6, a0, 0x324
40374c47:	3f          	.byte	0x3f
40374c48:	3668      	l32i.n	a6, a6, 12
40374c4a:	3fc9      	s32i.n	a12, a15, 12
40374c4c:	c93664        	lsi	f6, a6, 0x324
40374c4f:	3f          	.byte	0x3f
40374c50:	fbfff0        	f64subc	a15, a15, 3, 1
40374c53:	ff          	.byte	0xff
40374c54:	c93660        	lsi	f6, a6, 0x324
40374c57:	3f          	.byte	0x3f
40374c58:	ff          	.byte	0xff
40374c59:	7f          	.byte	0x7f
40374c5a:	000075        	call12	40374c60 <_iram_text_start+0x85c>
40374c5d:	b00000        	addx8	a0, a0, a0
40374c60:	024c90        	andb	b4, b12, b9
40374c63:	903c      	movi.n	a0, 57
40374c65:	3c0284        	lsi	f8, a2, 240
40374c68:	024cc2        	s8i	a12, a12, 2
40374c6b:	d03c      	movi.n	a0, 61
40374c6d:	024c      	movi.n	a2, 64
40374c6f:	103c      	movi.n	a0, 49
40374c71:	4f          	.byte	0x4f
40374c72:	3fc9      	s32i.n	a12, a15, 12
40374c74:	a828      	l32i.n	a2, a8, 40
40374c76:	ec4037        	ball	a0, a3, 40374c66 <_iram_text_start+0x862>
40374c79:	024c      	movi.n	a2, 64
40374c7b:	b83c      	movi.n	a8, 59
40374c7d:	3c0284        	lsi	f8, a2, 240
40374c80:	4d6c      	movi.n	a13, -28
40374c82:	b03c02        	lsi	f0, a12, 0x2c0
40374c85:	3c0284        	lsi	f8, a2, 240
40374c88:	002710        	lsi	f1, a7, 0
40374c8b:	138800        	lsi	f0, a8, 76
40374c8e:	540000        	extui	a0, a0, 0, 6
40374c91:	0039      	s32i.n	a3, a0, 0
40374c93:	4f1c42        	l16ui	a4, a12, 158
40374c96:	3fc9      	s32i.n	a12, a15, 12
40374c98:	c94c30        	lsi	f3, a12, 0x324
40374c9b:	3f          	.byte	0x3f
40374c9c:	c94cc0        	lsi	f12, a12, 0x324
40374c9f:	3f          	.byte	0x3f
40374ca0:	c94c40        	lsi	f4, a12, 0x324
40374ca3:	3f          	.byte	0x3f
40374ca4:	0244c0        	andb	b4, b4, b12
40374ca7:	e43c      	movi.n	a4, 62
40374ca9:	3c0283        	lsi	f8, a2, 240
40374cac:	024502        	s8i	a0, a5, 2
40374caf:	5c3c      	movi.n	a12, 53
40374cb1:	c94c      	movi.n	a9, 76
40374cb3:	3f          	.byte	0x3f
40374cb4:	4cec      	bnez.n	a12, 40374cdc <_iram_text_start+0x8d8>
40374cb6:	3fc9      	s32i.n	a12, a15, 12
40374cb8:	450c      	movi.n	a5, 4
40374cba:	7c3c02        	lsi	f0, a12, 0x1f0
40374cbd:	3c0283        	lsi	f8, a2, 240
40374cc0:	2e          	.byte	0x2e
40374cc1:	0e          	.byte	0xe
40374cc2:	340000        	extui	a0, a0, 0, 4
40374cc5:	3c0245        	call0	403b0cec <_coredump_iram_end+0x2ecec>
40374cc8:	841c      	movi.n	a4, 24
40374cca:	393c02        	lsi	f0, a12, 228
40374ccd:	000013        	lsi	f1, a0, 0
40374cd0:	c328      	l32i.n	a2, a3, 48
40374cd2:	f84200        	lsi	f0, a2, 0x3e0
40374cd5:	3fc920        	f64cmph	a12, a9, a2, 3
40374cd8:	c94c80        	lsi	f8, a12, 0x324
40374cdb:	3f          	.byte	0x3f
40374cdc:	c94c64        	lsi	f6, a12, 0x324
40374cdf:	3f          	.byte	0x3f
40374ce0:	4c7c      	movi.n	a12, -12
40374ce2:	3fc9      	s32i.n	a12, a15, 12
40374ce4:	4c88      	l32i.n	a8, a12, 16
40374ce6:	3fc9      	s32i.n	a12, a15, 12
40374ce8:	c94c60        	lsi	f6, a12, 0x324
40374ceb:	3f          	.byte	0x3f
40374cec:	4c68      	l32i.n	a6, a12, 16
40374cee:	3fc9      	s32i.n	a12, a15, 12
40374cf0:	4cbc      	beqz.n	a12, 40374d28 <_iram_text_start+0x924>
40374cf2:	3fc9      	s32i.n	a12, a15, 12
40374cf4:	002784        	lsi	f8, a7, 0
40374cf7:	456842        	s32i	a4, a8, 0x114
40374cfa:	583c02        	lsi	f0, a12, 0x160
40374cfd:	3c0282        	l8ui	a8, a2, 60
40374d00:	4cd8      	l32i.n	a13, a12, 16
40374d02:	3fc9      	s32i.n	a12, a15, 12
40374d04:	c94cc4        	lsi	f12, a12, 0x324
40374d07:	3f          	.byte	0x3f
40374d08:	c94c94        	lsi	f9, a12, 0x324
40374d0b:	3f          	.byte	0x3f
40374d0c:	4c58      	l32i.n	a5, a12, 16
40374d0e:	3fc9      	s32i.n	a12, a15, 12
40374d10:	c94c44        	lsi	f4, a12, 0x324
40374d13:	3f          	.byte	0x3f
40374d14:	024584        	lsi	f8, a5, 8
40374d17:	9c3c      	movi.n	a12, 57
40374d19:	3c0283        	lsi	f8, a2, 240
40374d1c:	0c7b      	addi.n	a0, a12, 7
40374d1e:	9c0000        	lsi	f0, a0, 0x270
40374d21:	3c0245        	call0	403b0d48 <_coredump_iram_end+0x2ed48>
40374d24:	0c9b      	addi.n	a0, a12, 9
40374d26:	480000        	ssx	f0, a0, a0
40374d29:	c94c      	movi.n	a9, 76
40374d2b:	3f          	.byte	0x3f
40374d2c:	4c4c      	movi.n	a12, 68
40374d2e:	3fc9      	s32i.n	a12, a15, 12
40374d30:	c94c54        	lsi	f5, a12, 0x324
40374d33:	3f          	.byte	0x3f
40374d34:	a5a5a5        	call8	4031a790 <rom_rx_gain_force+0x314364>
40374d37:	4614a5        	call8	403bae80 <_coredump_iram_end+0x38e80>
40374d3a:	643c02        	lsi	f0, a12, 0x190
40374d3d:	3c0283        	lsi	f8, a2, 240
40374d40:	000e95        	call4	40374e2c <_iram_text_start+0xa28>
40374d43:	462000        	lsi	f0, a0, 0x118
40374d46:	483c02        	lsi	f0, a12, 0x120
40374d49:	3c0283        	lsi	f8, a2, 240
40374d4c:	0f2a      	add.n	a0, a15, a2
40374d4e:	300000        	xor	a0, a0, a0
40374d51:	3c0246        	j	40383d5e <_coredump_iram_end+0x1d5e>
40374d54:	0f4d      	mov.n	a4, a15
40374d56:	6c0000        	lsi	f0, a0, 0x1b0
40374d59:	3c0246        	j	40383d66 <_coredump_iram_end+0x1d66>
40374d5c:	028330        	andb	b8, b3, b3
40374d5f:	3a3c      	movi.n	a10, 51
40374d61:	000010        	lsi	f1, a0, 0
40374d64:	4678      	l32i.n	a7, a6, 16
40374d66:	3b3c02        	lsi	f0, a12, 236
40374d69:	000010        	lsi	f1, a0, 0
40374d6c:	4688      	l32i.n	a8, a6, 16
40374d6e:	fc3c02        	lsi	f0, a12, 0x3f0
40374d71:	3c0283        	lsi	f8, a2, 240
40374d74:	457c      	movi.n	a5, -12
40374d76:	b03c02        	lsi	f0, a12, 0x2c0
40374d79:	3c0283        	lsi	f8, a2, 240
40374d7c:	000ac4        	lsi	f12, a10, 0
40374d7f:	46a000        	lsi	f0, a0, 0x118
40374d82:	2c3c02        	lsi	f0, a12, 176
40374d85:	3c0284        	lsi	f8, a2, 240
40374d88:	028410        	andb	b8, b4, b1
40374d8b:	203c      	movi.n	a0, 50
40374d8d:	3c0247        	bnone	a2, a4, 40374dcd <_iram_text_start+0x9c9>
40374d90:	0283c0        	andb	b8, b3, b12
40374d93:	0d3c      	movi.n	a13, 48
40374d95:	000a      	add.n	a0, a0, a0
40374d97:	47a000        	lsi	f0, a0, 0x11c
40374d9a:	183c02        	lsi	f0, a12, 96
40374d9d:	3c0283        	lsi	f8, a2, 240
40374da0:	001412        	l16ui	a1, a4, 0
40374da3:	47cc00        	lsi	f0, a12, 0x11c
40374da6:	133c02        	lsi	f0, a12, 76
40374da9:	000014        	lsi	f1, a0, 0
40374dac:	0282f4        	lsi	f15, a2, 8
40374daf:	693c      	movi.n	a9, 54
40374db1:	000014        	lsi	f1, a0, 0
40374db4:	0247e4        	lsi	f14, a7, 8
40374db7:	843c      	movi.n	a4, 56
40374db9:	000014        	lsi	f1, a0, 0
40374dbc:	024810        	andb	b4, b8, b1
40374dbf:	dc3c      	movi.n	a12, 61
40374dc1:	3c0282        	l8ui	a8, a2, 60
40374dc4:	001654        	lsi	f5, a6, 0
40374dc7:	482400        	ssx	f2, a4, a0
40374dca:	c83c02        	lsi	f0, a12, 0x320
40374dcd:	3c0282        	l8ui	a8, a2, 60
40374dd0:	001702        	l16ui	a0, a7, 0
40374dd3:	483800        	ssx	f3, a8, a0
40374dd6:	033c02        	lsi	f0, a12, 12
40374dd9:	000017        	bnone	a0, a1, 40374ddd <_iram_text_start+0x9d9>
40374ddc:	4848      	l32i.n	a4, a8, 16
40374dde:	383c02        	lsi	f0, a12, 224
40374de1:	000017        	bnone	a0, a1, 40374de5 <_iram_text_start+0x9e1>
40374de4:	4868      	l32i.n	a6, a8, 16
40374de6:	473c02        	lsi	f0, a12, 0x11c
40374de9:	000017        	bnone	a0, a1, 40374ded <_iram_text_start+0x9e9>
40374dec:	82a8      	l32i.n	a10, a2, 32
40374dee:	093c02        	lsi	f0, a12, 36
40374df1:	0018      	l32i.n	a1, a0, 0
40374df3:	180a00        	lsxp	f0, a10, a0
40374df6:	330000        	clamps	a0, a0, 7
40374df9:	0018      	l32i.n	a1, a0, 0
40374dfb:	48a800        	ssx	f10, a8, a0
40374dfe:	883c02        	lsi	f0, a12, 0x220
40374e01:	3c0282        	l8ui	a8, a2, 60
40374e04:	0248e0        	andb	b4, b8, b14
40374e07:	003c      	movi.n	a0, 48
40374e09:	0249      	s32i.n	a4, a2, 0
40374e0b:	703c      	movi.n	a0, 55
40374e0d:	3c0282        	l8ui	a8, a2, 60
40374e10:	49bc      	beqz.n	a9, 40374e48 <_iram_text_start+0xa44>
40374e12:	383c02        	lsi	f0, a12, 224
40374e15:	3c0282        	l8ui	a8, a2, 60
40374e18:	0249e4        	lsi	f14, a9, 8
40374e1b:	083c      	movi.n	a8, 48
40374e1d:	024a      	add.n	a0, a2, a4
40374e1f:	243c      	movi.n	a4, 50
40374e21:	024a      	add.n	a0, a2, a4
40374e23:	ec3c      	movi.n	a12, 62
40374e25:	ae          	.byte	0xae
40374e26:	384037        	ball	a0, a3, 40374e62 <_iram_text_start+0xa5e>
40374e29:	c94c      	movi.n	a9, 76
40374e2b:	3f          	.byte	0x3f
40374e2c:	4a2c      	movi.n	a10, 36
40374e2e:	d03c02        	lsi	f0, a12, 0x340
40374e31:	3c0283        	lsi	f8, a2, 240
40374e34:	098b      	addi.n	a0, a9, 8
40374e36:	380000        	lsi	f0, a0, 224
40374e39:	3c0284        	lsi	f8, a2, 240
40374e3c:	404c      	movi.n	a0, 68
40374e3e:	600c      	movi.n	a0, 6
40374e40:	4abc      	beqz.n	a10, 40374e78 <_iram_text_start+0xa74>
40374e42:	3fc9      	s32i.n	a12, a15, 12
40374e44:	0c40a0        	lsi	f10, a0, 48
40374e47:	187860        	lsxp	f7, a8, a6
40374e4a:	904000        	addx2	a4, a0, a0
40374e4d:	0018      	l32i.n	a1, a0, 0
40374e4f:	38d040        	lsi	f4, a0, 224
40374e52:	3fc9      	s32i.n	a12, a15, 12
40374e54:	c942a0        	lsi	f10, a2, 0x324
40374e57:	3f          	.byte	0x3f
40374e58:	c93904        	lsi	f0, a9, 0x324
40374e5b:	3f          	.byte	0x3f
40374e5c:	428c      	beqz.n	a2, 40374e64 <_iram_text_start+0xa60>
40374e5e:	3fc9      	s32i.n	a12, a15, 12
40374e60:	4278      	l32i.n	a7, a2, 16
40374e62:	3fc9      	s32i.n	a12, a15, 12
40374e64:	c94264        	lsi	f6, a2, 0x324
40374e67:	3f          	.byte	0x3f
40374e68:	18a8      	l32i.n	a10, a8, 4
40374e6a:	004000        	break	0, 0
40374e6d:	600c40        	lsi	f4, a12, 0x180
40374e70:	0c4060        	lsi	f6, a0, 48
40374e73:	ffff60        	f64cmph	a15, a15, a6, 15
40374e76:	ff          	.byte	0xff
40374e77:	00bd      	mov.n	a11, a0
40374e79:	c40000        	extui	a0, a0, 0, 13
40374e7c:	ff          	.byte	0xff
40374e7d:	ff          	.byte	0xff
40374e7e:	ff          	.byte	0xff
40374e7f:	16b0c3        	lsi	f12, a0, 88
40374e82:	504000        	iitlb	a0
40374e85:	3fc942        	addi	a4, a9, 63
40374e88:	423c      	movi.n	a2, 52
40374e8a:	3fc9      	s32i.n	a12, a15, 12
40374e8c:	0018f0        	movsp	a15, a8
40374e8f:	190840        	lsi	f4, a8, 100
40374e92:	244000        	extui	a4, a0, 0, 3
40374e95:	c939      	s32i.n	a3, a9, 48
40374e97:	3f          	.byte	0x3f
40374e98:	421c      	movi.n	a2, 20
40374e9a:	3fc9      	s32i.n	a12, a15, 12
40374e9c:	394c      	movi.n	a9, 67
40374e9e:	3fc9      	s32i.n	a12, a15, 12
40374ea0:	c94204        	lsi	f0, a2, 0x324
40374ea3:	3f          	.byte	0x3f
40374ea4:	c93954        	lsi	f5, a9, 0x324
40374ea7:	3f          	.byte	0x3f
40374ea8:	15fc      	bnez.n	a5, 40374edd <_iram_text_start+0xad9>
40374eaa:	084000        	lsx	f4, a0, a0
40374ead:	400016        	beqz	a0, 403752b1 <call_start_cpu0+0x5>
40374eb0:	c93f54        	lsi	f5, a15, 0x324
40374eb3:	3f          	.byte	0x3f
40374eb4:	c94304        	lsi	f0, a3, 0x324
40374eb7:	3f          	.byte	0x3f
40374eb8:	c93f74        	lsi	f7, a15, 0x324
40374ebb:	3f          	.byte	0x3f
40374ebc:	031400        	lsi	f0, a4, 12
40374ebf:	ec18      	l32i.n	a1, a12, 56
40374ec1:	3fc942        	addi	a4, a9, 63
40374ec4:	42cc      	bnez.n	a2, 40374ecc <_iram_text_start+0xac8>
40374ec6:	3fc9      	s32i.n	a12, a15, 12
40374ec8:	ff          	.byte	0xff
40374ec9:	ff          	.byte	0xff
40374eca:	ff          	.byte	0xff
40374ecb:	3f          	.byte	0x3f
40374ecc:	3fa8      	l32i.n	a10, a15, 12
40374ece:	3fc9      	s32i.n	a12, a15, 12
40374ed0:	c942b4        	lsi	f11, a2, 0x324
40374ed3:	3f          	.byte	0x3f
40374ed4:	3fdc      	bnez.n	a15, 40374eeb <_iram_text_start+0xae7>
40374ed6:	3fc9      	s32i.n	a12, a15, 12
40374ed8:	000000        	ill
40374edb:	000042        	l8ui	a4, a0, 0
40374ede:	fc3c00        	lsi	f0, a12, 0x3f0
40374ee1:	3f          	.byte	0x3f
40374ee2:	3fc9      	s32i.n	a12, a15, 12
40374ee4:	c94350        	lsi	f5, a3, 0x324
40374ee7:	3f          	.byte	0x3f
40374ee8:	401c      	movi.n	a0, 20
40374eea:	3fc9      	s32i.n	a12, a15, 12
40374eec:	403c      	movi.n	a0, 52
40374eee:	3fc9      	s32i.n	a12, a15, 12
40374ef0:	c94070        	lsi	f7, a0, 0x324
40374ef3:	3f          	.byte	0x3f
40374ef4:	4338      	l32i.n	a3, a3, 16
40374ef6:	3fc9      	s32i.n	a12, a15, 12
40374ef8:	c940d4        	lsi	f13, a0, 0x324
40374efb:	3f          	.byte	0x3f
40374efc:	c94320        	lsi	f2, a3, 0x324
40374eff:	3f          	.byte	0x3f
40374f00:	c94134        	lsi	f3, a1, 0x324
40374f03:	3f          	.byte	0x3f
40374f04:	c94364        	lsi	f6, a3, 0x324
40374f07:	3f          	.byte	0x3f
40374f08:	c94174        	lsi	f7, a1, 0x324
40374f0b:	3f          	.byte	0x3f
40374f0c:	0cc000        	lsi	f0, a0, 48
40374f0f:	004c60        	break	12, 6
40374f12:	600c      	movi.n	a0, 6
40374f14:	0cc044        	lsi	f4, a0, 48
40374f17:	c04060        	sub	a4, a0, a6
40374f1a:	600c      	movi.n	a0, 6
40374f1c:	c048      	l32i.n	a4, a0, 48
40374f1e:	600c      	movi.n	a0, 6
40374f20:	c04c      	movi.n	a0, 76
40374f22:	600c      	movi.n	a0, 6
40374f24:	c058      	l32i.n	a5, a0, 48
40374f26:	600c      	movi.n	a0, 6
40374f28:	0cc050        	lsi	f5, a0, 48
40374f2b:	c05460        	sub	a5, a4, a6
40374f2e:	600c      	movi.n	a0, 6
40374f30:	9f          	.byte	0x9f
40374f31:	ff3c      	movi.n	a15, 63
40374f33:	ff          	.byte	0xff
40374f34:	ff          	.byte	0xff
40374f35:	cf          	.byte	0xcf
40374f36:	ff          	.byte	0xff
40374f37:	ff          	.byte	0xff
40374f38:	100000        	and	a0, a0, a0
40374f3b:	ffff00        	f64cmph	a15, a15, a0, 15
40374f3e:	fffb      	addi.n	a15, a15, 15
40374f40:	ff          	.byte	0xff
40374f41:	ff          	.byte	0xff
40374f42:	3f          	.byte	0x3f
40374f43:	fff8      	l32i.n	a15, a15, 60
40374f45:	ff          	.byte	0xff
40374f46:	00ffc1        	l32r	a12, 40335344 <rom_rx_gain_force+0x32ef18>
40374f49:	f00000        	subx8	a0, a0, a0
40374f4c:	8f          	.byte	0x8f
40374f4d:	6fbd      	lsi	f11, a15, 60
40374f4f:	fe          	.byte	0xfe
40374f50:	400000        	ssr	a0
40374f53:	000000        	ill
40374f56:	ff5c00        	f64cmph	a5, a12, a0, 15
40374f59:	fffe01        	l32r	a0, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
40374f5c:	ff          	.byte	0xff
40374f5d:	ffff03        	lsi	f0, a15, 0x3fc
40374f60:	fff003        	lsi	f0, a0, 0x3fc
40374f63:	ff          	.byte	0xff
40374f64:	624dd3        	ssi	f13, a13, 0x188
40374f67:	ffff10        	f64cmph	a15, a15, a1, 15
40374f6a:	ff          	.byte	0xff
40374f6b:	080081        	l32r	a8, 40336f6c <rom_rx_gain_force+0x330b40>
40374f6e:	000000        	ill
40374f71:	600230        	lsi	f3, a2, 0x180
40374f74:	ff          	.byte	0xff
40374f75:	ff          	.byte	0xff
40374f76:	ff          	.byte	0xff
40374f77:	41b803        	lsi	f0, a8, 0x104
40374f7a:	3fc9      	s32i.n	a12, a15, 12
40374f7c:	4388      	l32i.n	a8, a3, 16
40374f7e:	3fc9      	s32i.n	a12, a15, 12
40374f80:	41cc      	bnez.n	a1, 40374f88 <_iram_text_start+0xb84>
40374f82:	3fc9      	s32i.n	a12, a15, 12
40374f84:	29e8      	l32i.n	a14, a9, 8
40374f86:	4c3c02        	lsi	f0, a12, 0x130
40374f89:	022a      	add.n	a0, a2, a2
40374f8b:	6c3c      	movi.n	a12, 54
40374f8d:	027a      	add.n	a0, a2, a7
40374f8f:	3e3c      	movi.n	a14, 51
40374f91:	022a      	add.n	a0, a2, a2
40374f93:	743c      	movi.n	a4, 55
40374f95:	3c0230        	lsi	f3, a2, 240
40374f98:	7af8      	l32i.n	a15, a10, 28
40374f9a:	db3c02        	lsi	f0, a12, 0x36c
40374f9d:	022a      	add.n	a0, a2, a2
40374f9f:	503c      	movi.n	a0, 53
40374fa1:	022b      	addi.n	a0, a2, 2
40374fa3:	c83c      	movi.n	a8, 60
40374fa5:	027b      	addi.n	a0, a2, 7
40374fa7:	833c      	movi.n	a3, 56
40374fa9:	022b      	addi.n	a0, a2, 2
40374fab:	ac3c      	movi.n	a12, 58
40374fad:	3c0230        	lsi	f3, a2, 240
40374fb0:	027ae4        	lsi	f14, a10, 8
40374fb3:	5b3c      	movi.n	a11, 53
40374fb5:	022c      	movi.n	a2, 32
40374fb7:	d83c      	movi.n	a8, 61
40374fb9:	3c0230        	lsi	f3, a2, 240
40374fbc:	022dd4        	lsi	f13, a13, 8
40374fbf:	883c      	movi.n	a8, 56
40374fc1:	027b      	addi.n	a0, a2, 7
40374fc3:	003c      	movi.n	a0, 48
40374fc5:	2e          	.byte	0x2e
40374fc6:	203c02        	lsi	f0, a12, 128
40374fc9:	3c0231        	l32r	a3, 40343fd4 <rom_rx_gain_force+0x33dba8>
40374fcc:	027ad4        	lsi	f13, a10, 8
40374fcf:	003c      	movi.n	a0, 48
40374fd1:	000000        	ill
40374fd4:	3158      	l32i.n	a5, a1, 12
40374fd6:	c03c02        	lsi	f0, a12, 0x300
40374fd9:	027a      	add.n	a0, a2, a7
40374fdb:	103c      	movi.n	a0, 49
40374fdd:	022c      	movi.n	a2, 32
40374fdf:	a83c      	movi.n	a8, 58
40374fe1:	027b      	addi.n	a0, a2, 7
40374fe3:	743c      	movi.n	a4, 55
40374fe5:	022c      	movi.n	a2, 32
40374fe7:	b03c      	movi.n	a0, 59
40374fe9:	022c      	movi.n	a2, 32
40374feb:	603c      	movi.n	a0, 54
40374fed:	2e          	.byte	0x2e
40374fee:	bc3c02        	lsi	f0, a12, 0x2f0
40374ff1:	027b      	addi.n	a0, a2, 7
40374ff3:	a03c      	movi.n	a0, 58
40374ff5:	2e          	.byte	0x2e
40374ff6:	483c02        	lsi	f0, a12, 0x120
40374ff9:	027b      	addi.n	a0, a2, 7
40374ffb:	dc3c      	movi.n	a12, 61
40374ffd:	2e          	.byte	0x2e
40374ffe:	603c02        	lsi	f0, a12, 0x180
40375001:	027b      	addi.n	a0, a2, 7
40375003:	f83c      	movi.n	a8, 63
40375005:	2e          	.byte	0x2e
40375006:	343c02        	lsi	f0, a12, 208
40375009:	027b      	addi.n	a0, a2, 7
4037500b:	183c      	movi.n	a8, 49
4037500d:	2f          	.byte	0x2f
4037500e:	243c02        	lsi	f0, a12, 144
40375011:	027b      	addi.n	a0, a2, 7
40375013:	483c      	movi.n	a8, 52
40375015:	2f          	.byte	0x2f
40375016:	183c02        	lsi	f0, a12, 96
40375019:	027b      	addi.n	a0, a2, 7
4037501b:	bc3c      	movi.n	a12, 59
4037501d:	2f          	.byte	0x2f
4037501e:	fc3c02        	lsi	f0, a12, 0x3f0
40375021:	2f          	.byte	0x2f
40375022:	9c3c02        	lsi	f0, a12, 0x270
40375025:	027b      	addi.n	a0, a2, 7
40375027:	483c      	movi.n	a8, 52
40375029:	3c0230        	lsi	f3, a2, 240
4037502c:	027b04        	lsi	f0, a11, 8
4037502f:	b03c      	movi.n	a0, 59
40375031:	027a      	add.n	a0, a2, a7
40375033:	843c      	movi.n	a4, 56
40375035:	3c0231        	l32r	a3, 40344040 <rom_rx_gain_force+0x33dc14>
40375038:	027aa0        	andb	b7, b10, b10
4037503b:	cc3c      	movi.n	a12, 60
4037503d:	c94b      	addi.n	a12, a9, 4
4037503f:	3f          	.byte	0x3f
40375040:	c94ac0        	lsi	f12, a10, 0x324
40375043:	3f          	.byte	0x3f
40375044:	2038      	l32i.n	a3, a0, 8
40375046:	3fc9      	s32i.n	a12, a15, 12
40375048:	717c      	movi.n	a1, -9
4037504a:	114201        	l32r	a0, 40339554 <rom_rx_gain_force+0x333128>
4037504d:	37fd      	lsi	f15, a7, 28
4037504f:	3b3840        	ueq.s	b3, f8, f4
40375052:	3fc9      	s32i.n	a12, a15, 12
40375054:	c93b54        	lsi	f5, a11, 0x324
40375057:	3f          	.byte	0x3f
40375058:	0014c4        	lsi	f12, a4, 0
4037505b:	fd7e40        	lsi	f4, a14, 0x3f4
4037505e:	604037        	ball	a0, a3, 403750c2 <_iram_text_start+0xcbe>
40375061:	c93b      	addi.n	a12, a9, 3
40375063:	3f          	.byte	0x3f
40375064:	c93b74        	lsi	f7, a11, 0x324
40375067:	3f          	.byte	0x3f
40375068:	3b78      	l32i.n	a7, a11, 12
4037506a:	3fc9      	s32i.n	a12, a15, 12
4037506c:	3b88      	l32i.n	a8, a11, 12
4037506e:	3fc9      	s32i.n	a12, a15, 12
40375070:	3b8c      	beqz.n	a11, 40375077 <_iram_text_start+0xc73>
40375072:	3fc9      	s32i.n	a12, a15, 12
40375074:	c93b90        	lsi	f9, a11, 0x324
40375077:	3f          	.byte	0x3f
40375078:	3fd8      	l32i.n	a13, a15, 12
4037507a:	3fc9      	s32i.n	a12, a15, 12
4037507c:	1248      	l32i.n	a4, a2, 4
4037507e:	604000        	neg	a4, a0
40375081:	400012        	l8ui	a1, a0, 64
40375084:	27a8      	l32i.n	a10, a7, 8
40375086:	3fc9      	s32i.n	a12, a15, 12
40375088:	c950f5        	call12	4033e598 <rom_rx_gain_force+0x33816c>
4037508b:	3f          	.byte	0x3f
4037508c:	c950f4        	lsi	f15, a0, 0x324
4037508f:	3f          	.byte	0x3f
40375090:	ff          	.byte	0xff
40375091:	ff          	.byte	0xff
40375092:	ff          	.byte	0xff
40375093:	43f800        	min	a15, a8, a0
40375096:	3fc9      	s32i.n	a12, a15, 12
40375098:	c93e44        	lsi	f4, a14, 0x324
4037509b:	3f          	.byte	0x3f
4037509c:	3e7c      	movi.n	a14, -13
4037509e:	3fc9      	s32i.n	a12, a15, 12
403750a0:	43dc      	bnez.n	a3, 403750b8 <_iram_text_start+0xcb4>
403750a2:	3fc9      	s32i.n	a12, a15, 12
403750a4:	c93eb3        	lsi	f11, a14, 0x324
403750a7:	3f          	.byte	0x3f
403750a8:	c943c4        	lsi	f12, a3, 0x324
403750ab:	3f          	.byte	0x3f
403750ac:	3ec8      	l32i.n	a12, a14, 12
403750ae:	3fc9      	s32i.n	a12, a15, 12
403750b0:	43a8      	l32i.n	a10, a3, 16
403750b2:	3fc9      	s32i.n	a12, a15, 12
403750b4:	378c      	beqz.n	a7, 403750bb <_iram_text_start+0xcb7>
403750b6:	3fc9      	s32i.n	a12, a15, 12
403750b8:	c94400        	lsi	f0, a4, 0x324
403750bb:	3f          	.byte	0x3f
403750bc:	a3d8      	l32i.n	a13, a3, 40
403750be:	004200        	break	2, 0
403750c1:	000060        	lsi	f6, a0, 0
403750c4:	076c      	movi.n	a7, -32
403750c6:	4038      	l32i.n	a3, a0, 16
403750c8:	3807a4        	lsi	f10, a7, 224
403750cb:	0a8040        	add.s	f8, f0, f4
403750ce:	4038      	l32i.n	a3, a0, 16
403750d0:	0ae8      	l32i.n	a14, a10, 0
403750d2:	4038      	l32i.n	a3, a0, 16
403750d4:	c93774        	lsi	f7, a7, 0x324
403750d7:	3f          	.byte	0x3f
403750d8:	3778      	l32i.n	a7, a7, 12
403750da:	3fc9      	s32i.n	a12, a15, 12
403750dc:	375c      	movi.n	a7, 83
403750de:	3fc9      	s32i.n	a12, a15, 12
403750e0:	460c      	movi.n	a6, 4
403750e2:	3fc9      	s32i.n	a12, a15, 12
403750e4:	c93ca0        	lsi	f10, a12, 0x324
403750e7:	3f          	.byte	0x3f
403750e8:	3cdc      	bnez.n	a12, 403750ff <_iram_text_start+0xcfb>
403750ea:	3fc9      	s32i.n	a12, a15, 12
403750ec:	455c      	movi.n	a5, 84
403750ee:	3fc9      	s32i.n	a12, a15, 12
403750f0:	0f          	.byte	0xf
403750f1:	c93d      	lsi	f3, a9, 36
403750f3:	3f          	.byte	0x3f
403750f4:	3d28      	l32i.n	a2, a13, 12
403750f6:	3fc9      	s32i.n	a12, a15, 12
403750f8:	c93d80        	lsi	f8, a13, 0x324
403750fb:	3f          	.byte	0x3f
403750fc:	21cc      	bnez.n	a1, 40375102 <_iram_text_start+0xcfe>
403750fe:	004000        	break	0, 0
40375101:	cf          	.byte	0xcf
40375102:	b80000        	lsi	f0, a0, 0x2e0
40375105:	380a      	add.n	a3, a8, a0
40375107:	0ad040        	add.s	f13, f0, f4
4037510a:	4038      	l32i.n	a3, a0, 16
4037510c:	ff9f60        	f64cmph	a9, a15, a6, 15
4037510f:	ff          	.byte	0xff
40375110:	ffde21        	l32r	a2, 40375088 <_iram_text_start+0xc84> (3fc950f5 <flash_brownout_needs_reset>)
40375113:	ff          	.byte	0xff
40375114:	23dc      	bnez.n	a3, 4037512a <_iram_text_start+0xd26>
40375116:	120000        	andbc	b0, b0, b0
40375119:	ffed      	lsi	f14, a15, 60
4037511b:	ff          	.byte	0xff
4037511c:	13ec      	bnez.n	a3, 40375141 <_iram_text_start+0xd3d>
4037511e:	ee0000        	f64iter	a0, a0, a0, 2, 1
40375121:	000011        	l32r	a1, 40335124 <rom_rx_gain_force+0x32ecf8>
40375124:	3dc8      	l32i.n	a12, a13, 12
40375126:	3fc9      	s32i.n	a12, a15, 12
40375128:	c94750        	lsi	f5, a7, 0x324
4037512b:	3f          	.byte	0x3f
4037512c:	c93e27        	bltu	a14, a2, 403750f9 <_iram_text_start+0xcf5>
4037512f:	3f          	.byte	0x3f
40375130:	9f          	.byte	0x9f
40375131:	000060        	lsi	f6, a0, 0
40375134:	47fc      	bnez.n	a7, 4037516c <_iram_text_start+0xd68>
40375136:	3fc9      	s32i.n	a12, a15, 12
40375138:	c93e44        	lsi	f4, a14, 0x324
4037513b:	3f          	.byte	0x3f
4037513c:	21d8      	l32i.n	a13, a1, 8
4037513e:	714000        	lsi	f0, a0, 0x1c4
40375141:	8e          	.byte	0x8e
40375142:	ff          	.byte	0xff
40375143:	ff          	.byte	0xff
40375144:	c93e60        	lsi	f6, a14, 0x324
40375147:	3f          	.byte	0x3f
40375148:	c94724        	lsi	f2, a7, 0x324
4037514b:	3f          	.byte	0x3f
4037514c:	490c      	movi.n	a9, 4
4037514e:	3fc9      	s32i.n	a12, a15, 12
40375150:	c93ca0        	lsi	f10, a12, 0x324
40375153:	3f          	.byte	0x3f
40375154:	ffe8      	l32i.n	a14, a15, 60
40375156:	ce          	.byte	0xce
40375157:	3f          	.byte	0x3f
40375158:	c92730        	lsi	f3, a7, 0x324
4037515b:	3f          	.byte	0x3f
4037515c:	9078      	l32i.n	a7, a0, 36
4037515e:	f06000        	subx8	a6, a0, a0
40375161:	c93b      	addi.n	a12, a9, 3
40375163:	3f          	.byte	0x3f
40375164:	3bfc      	bnez.n	a11, 4037519b <_iram_text_start+0xd97>
40375166:	3fc9      	s32i.n	a12, a15, 12
40375168:	093c      	movi.n	a9, 48
4037516a:	b84000        	lsi	f0, a0, 0x2e0
4037516d:	0008      	l32i.n	a0, a0, 0
4037516f:	0a4440        	add.s	f4, f4, f4
40375172:	144000        	extui	a4, a0, 0, 2
40375175:	c949      	s32i.n	a4, a9, 48
40375177:	3f          	.byte	0x3f
40375178:	cefff4        	lsi	f15, a15, 0x338
4037517b:	3f          	.byte	0x3f
4037517c:	000954        	lsi	f5, a9, 0
4037517f:	096040        	l32e	a4, a0, -40
40375182:	e84000        	lsi	f0, a0, 0x3a0
40375185:	0008      	l32i.n	a0, a0, 0
40375187:	276440        	lsi	f4, a4, 156
4037518a:	3fc9      	s32i.n	a12, a15, 12
4037518c:	c95110        	lsi	f1, a1, 0x324
4037518f:	3f          	.byte	0x3f
40375190:	510c      	movi.n	a1, 5
40375192:	3fc9      	s32i.n	a12, a15, 12
40375194:	3c3c      	movi.n	a12, 51
40375196:	3fc9      	s32i.n	a12, a15, 12
40375198:	040020        	extui	a0, a2, 0, 1
	...

4037519c <call_start_cpu1>:
{
    s_resume_cores = true;
}

void IRAM_ATTR call_start_cpu1(void)
{
4037519c:	004136        	entry	a1, 32
 * @param ivt_addr Interrupt Vector Table's base address
 */
FORCE_INLINE_ATTR void esp_cpu_intr_set_ivt_addr(const void *ivt_addr)
{
#ifdef __XTENSA__
    xt_utils_set_vecbase((uint32_t)ivt_addr);
4037519f:	fc9981        	l32r	a8, 40374404 <_iram_text_start> (40374000 <_WindowOverflow4>)

// --------------- Interrupt Configuration -----------------

FORCE_INLINE_ATTR void xt_utils_set_vecbase(uint32_t vecbase)
{
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
403751a2:	13e780        	wsr.vecbase	a8
     * the CPU jumps to this base address + 4 * interrupt_id.
     */
    esp_cpu_intr_set_mtvt_addr(&_mtvt_table);
#endif

    ets_set_appcpu_boot_addr(0);
403751a5:	0a0c      	movi.n	a10, 0
403751a7:	fc9e81        	l32r	a8, 40374420 <_iram_text_start+0x1c> (40000720 <ets_set_appcpu_boot_addr>)
403751aa:	0008e0        	callx8	a8

    bootloader_init_mem();
403751ad:	fc9d81        	l32r	a8, 40374424 <_iram_text_start+0x20> (420095d0 <bootloader_init_mem>)
403751b0:	0008e0        	callx8	a8

#if CONFIG_ESP_CONSOLE_NONE
    esp_rom_install_channel_putc(1, NULL);
    esp_rom_install_channel_putc(2, NULL);
#elif !CONFIG_ESP_CONSOLE_USB_CDC
    esp_rom_install_uart_printf();
403751b3:	0453e5        	call8	403796f0 <esp_rom_install_uart_printf>
    esp_rom_output_set_as_console(CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM);
403751b6:	4a0c      	movi.n	a10, 4
403751b8:	fc9c81        	l32r	a8, 40374428 <_iram_text_start+0x24> (400006c0 <esp_rom_output_set_as_console>)
403751bb:	0008e0        	callx8	a8
    DPORT_REG_CLR_BIT(DPORT_APP_CPU_RECORD_CTRL_REG, DPORT_APP_CPU_RECORD_ENABLE);
#elif CONFIG_IDF_TARGET_ESP32P4
    REG_SET_BIT(ASSIST_DEBUG_CORE_1_RCD_EN_REG, ASSIST_DEBUG_CORE_1_RCD_PDEBUGEN);
    REG_SET_BIT(ASSIST_DEBUG_CORE_1_RCD_EN_REG, ASSIST_DEBUG_CORE_1_RCD_RECORDEN);
#else
    REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_PDEBUGENABLE_REG, 1);
403751be:	170c      	movi.n	a7, 1
403751c0:	fc9281        	l32r	a8, 40374408 <_iram_text_start+0x4> (600ce0d8 <SYSTEM+0xe0d8>)
403751c3:	0020c0        	memw
403751c6:	0879      	s32i.n	a7, a8, 0
    REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_RECORDING_REG, 1);
403751c8:	fc9181        	l32r	a8, 4037440c <_iram_text_start+0x8> (600ce0dc <SYSTEM+0xe0dc>)
403751cb:	0020c0        	memw
403751ce:	006872        	s32i	a7, a8, 0
#endif

    s_cpu_up[1] = true;
403751d1:	fc8f81        	l32r	a8, 40374410 <_iram_text_start+0xc> (3fc949a8 <s_cpu_up>)
403751d4:	0020c0        	memw
403751d7:	014872        	s8i	a7, a8, 1
    ESP_EARLY_LOGD(TAG, "App cpu up");

    // Clear interrupt matrix for APP CPU core
    core_intr_matrix_clear();
403751da:	fc9481        	l32r	a8, 4037442c <_iram_text_start+0x28> (420014c0 <core_intr_matrix_clear>)
403751dd:	0008e0        	callx8	a8

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    //Take care putting stuff here: if asked, FreeRTOS will happily tell you the scheduler
    //has started, but it isn't active *on this CPU* yet.
    esp_cache_err_int_init();
403751e0:	fc9481        	l32r	a8, 40374430 <_iram_text_start+0x2c> (42001aa8 <esp_cache_err_int_init>)
403751e3:	0008e0        	callx8	a8
#if (CONFIG_IDF_TARGET_ESP32 && CONFIG_ESP32_TRAX_TWOBANKS) || \
    (CONFIG_IDF_TARGET_ESP32S3 && CONFIG_ESP32S3_TRAX_TWOBANKS)
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif

    s_cpu_inited[1] = true;
403751e6:	fc8b81        	l32r	a8, 40374414 <_iram_text_start+0x10> (3fc949a4 <s_cpu_inited>)
403751e9:	0020c0        	memw
403751ec:	014872        	s8i	a7, a8, 1

    while (!s_resume_cores) {
403751ef:	000286        	j	403751fd <call_start_cpu1+0x61>
403751f2:	a20000        	muluh	a0, a0, a0
        esp_rom_delay_us(100);
403751f5:	8164a0        	src	a6, a4, a10
403751f8:	8f          	.byte	0x8f
403751f9:	e0fc      	bnez.n	a0, 4037523b <do_multicore_settings+0x1b>
403751fb:	0008      	l32i.n	a0, a0, 0
    while (!s_resume_cores) {
403751fd:	fc8681        	l32r	a8, 40374418 <_iram_text_start+0x14> (3fc949a0 <s_resume_cores>)
40375200:	0020c0        	memw
40375203:	000882        	l8ui	a8, a8, 0
40375206:	748080        	extui	a8, a8, 0, 8
40375209:	fe7816        	beqz	a8, 403751f4 <call_start_cpu1+0x58>
    asm volatile (
4037520c:	03eb80        	rsr.prid	a8
4037520f:	048d80        	extui	a8, a8, 13, 1
    }

    SYS_STARTUP_FN();
40375212:	fc8291        	l32r	a9, 4037441c <_iram_text_start+0x18> (3c027180 <g_startup_fn>)
40375215:	a08890        	addx4	a8, a8, a9
40375218:	0888      	l32i.n	a8, a8, 0
4037521a:	0008e0        	callx8	a8
}
4037521d:	f01d      	retw.n
	...

40375220 <do_multicore_settings>:
}
#endif
// This function is needed to make the multicore app runnable on a unicore bootloader (built with FREERTOS UNICORE).
// It does some cache settings for other CPUs.
void IRAM_ATTR do_multicore_settings(void)
{
40375220:	004136        	entry	a1, 32
{
    cache_bus_mask_t mask = (cache_bus_mask_t)0;
    HAL_ASSERT(cache_id <= CACHE_LL_ID_ALL);
    //On esp32s3, only `CACHE_BUS_IBUS0` and `CACHE_BUS_DBUS0` are supported. Use `cache_ll_l1_get_bus()` to get your bus first

    uint32_t ibus_mask = REG_READ(EXTMEM_ICACHE_CTRL1_REG);
40375223:	fc8581        	l32r	a8, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
40375226:	0020c0        	memw
40375229:	0888      	l32i.n	a8, a8, 0
    if (cache_id == 0) {
        mask = (cache_bus_mask_t)(mask | ((!(ibus_mask & EXTMEM_ICACHE_SHUT_CORE0_BUS)) ? CACHE_BUS_IBUS0 : 0));
4037522b:	05e807        	bbsi	a8, 0, 40375234 <do_multicore_settings+0x14>
4037522e:	170c      	movi.n	a7, 1
40375230:	000086        	j	40375236 <do_multicore_settings+0x16>
40375233:	070c00        	lsi	f0, a12, 28
    } else {
        mask = (cache_bus_mask_t)(mask | ((!(ibus_mask & EXTMEM_ICACHE_SHUT_CORE1_BUS)) ? CACHE_BUS_IBUS0 : 0));
    }

    uint32_t dbus_mask = REG_READ(EXTMEM_DCACHE_CTRL1_REG);
40375236:	fc8181        	l32r	a8, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
40375239:	0020c0        	memw
4037523c:	0888      	l32i.n	a8, a8, 0
    if (cache_id == 1) {
        mask = (cache_bus_mask_t)(mask | ((!(dbus_mask & EXTMEM_DCACHE_SHUT_CORE0_BUS)) ? CACHE_BUS_DBUS0 : 0));
    } else {
        mask = (cache_bus_mask_t)(mask | ((!(dbus_mask & EXTMEM_DCACHE_SHUT_CORE1_BUS)) ? CACHE_BUS_DBUS0 : 0));
4037523e:	04e817        	bbsi	a8, 1, 40375246 <do_multicore_settings+0x26>
40375241:	880c      	movi.n	a8, 8
40375243:	000086        	j	40375249 <do_multicore_settings+0x29>
40375246:	00a082        	movi	a8, 0
40375249:	207780        	or	a7, a7, a8
#endif

    cache_bus_mask_t cache_bus_mask_core0 = cache_ll_l1_get_enabled_bus(0);
#ifndef CONFIG_IDF_TARGET_ESP32
    // 1. disable the cache before changing its settings.
    cache_hal_disable(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
4037524c:	02a0b2        	movi	a11, 2
4037524f:	01a0a2        	movi	a10, 1
40375252:	077265        	call8	4037c978 <cache_hal_disable>
#endif
    for (unsigned core = 1; core < SOC_CPU_CORES_NUM; core++) {
40375255:	180c      	movi.n	a8, 1
40375257:	001146        	j	403752a0 <do_multicore_settings+0x80>
    if (cache_id == 0) {
4037525a:	48cc      	bnez.n	a8, 40375262 <do_multicore_settings+0x42>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE0_BUS : 0);
4037525c:	049070        	extui	a9, a7, 0, 1
4037525f:	000186        	j	40375269 <do_multicore_settings+0x49>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE1_BUS : 0);
40375262:	977a      	add.n	a9, a7, a7
40375264:	2a0c      	movi.n	a10, 2
40375266:	1099a0        	and	a9, a9, a10
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
40375269:	fc73a1        	l32r	a10, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
4037526c:	0020c0        	memw
4037526f:	0ab8      	l32i.n	a11, a10, 0
40375271:	1099b0        	and	a9, a9, a11
40375274:	3099b0        	xor	a9, a9, a11
40375277:	0020c0        	memw
4037527a:	0a99      	s32i.n	a9, a10, 0
    if (cache_id == 1) {
4037527c:	051866        	bnei	a8, 1, 40375285 <do_multicore_settings+0x65>
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE0_BUS : 0);
4037527f:	419370        	srli	a9, a7, 3
40375282:	000086        	j	40375288 <do_multicore_settings+0x68>
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE1_BUS : 0);
40375285:	419270        	srli	a9, a7, 2
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
40375288:	fc6da1        	l32r	a10, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
4037528b:	0020c0        	memw
4037528e:	002ab2        	l32i	a11, a10, 0
40375291:	1099b0        	and	a9, a9, a11
40375294:	3099b0        	xor	a9, a9, a11
40375297:	0020c0        	memw
4037529a:	006a92        	s32i	a9, a10, 0
4037529d:	01c882        	addi	a8, a8, 1
403752a0:	b628b6        	bltui	a8, 2, 4037525a <do_multicore_settings+0x3a>
        // 2. change cache settings. All cores must have the same settings.
        cache_ll_l1_enable_bus(core, cache_bus_mask_core0);
    }
#ifndef CONFIG_IDF_TARGET_ESP32
    // 3. enable the cache after changing its settings.
    cache_hal_enable(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403752a3:	2b0c      	movi.n	a11, 2
403752a5:	1a0c      	movi.n	a10, 1
403752a7:	0770e5        	call8	4037c9b4 <cache_hal_enable>
#endif
}
403752aa:	f01d      	retw.n

403752ac <call_start_cpu0>:
/*
 * We arrive here after the bootloader finished loading the program from flash. The hardware is mostly uninitialized,
 * and the app CPU is in reset. We do have a stack, so we can do the initialization in C.
 */
void IRAM_ATTR call_start_cpu0(void)
{
403752ac:	00c136        	entry	a1, 96
403752af:	fc5581        	l32r	a8, 40374404 <_iram_text_start> (40374000 <_WindowOverflow4>)
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
403752b2:	13e780        	wsr.vecbase	a8
#if CONFIG_SECURE_ENABLE_TEE
    extern uint32_t esp_tee_service_call(int argc, ...);
    esprv_int_setup_mgmt_cb((void *)esp_tee_service_call);
#endif

    rst_reas[0] = esp_rom_get_reset_reason(0);
403752b5:	0a0c      	movi.n	a10, 0
403752b7:	fc7581        	l32r	a8, 4037448c <_iram_text_start+0x88> (4000057c <esp_rom_get_reset_reason>)
403752ba:	0008e0        	callx8	a8
403752bd:	0a5d      	mov.n	a5, a10
403752bf:	01a9      	s32i.n	a10, a1, 0
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    rst_reas[1] = esp_rom_get_reset_reason(1);
403752c1:	1a0c      	movi.n	a10, 1
403752c3:	fc7281        	l32r	a8, 4037448c <_iram_text_start+0x88> (4000057c <esp_rom_get_reset_reason>)
403752c6:	0008e0        	callx8	a8
403752c9:	11a9      	s32i.n	a10, a1, 4
    //Clear BSS. Please do not attempt to do any complex stuff (like early logging) before this.
#if SOC_MEM_NON_CONTIGUOUS_SRAM
    memset(&_bss_start_low, 0, (&_bss_end_low - &_bss_start_low) * sizeof(_bss_start_low));
    memset(&_bss_start_high, 0, (&_bss_end_high - &_bss_start_high) * sizeof(_bss_start_high));
#else
    memset(&_bss_start, 0, (&_bss_end - &_bss_start) * sizeof(_bss_start));
403752cb:	fc5ea1        	l32r	a10, 40374444 <_iram_text_start+0x40> (3fc94980 <app_elf_sha256_str>)
403752ce:	fc5cc1        	l32r	a12, 40374440 <_iram_text_start+0x3c> (3fc95438 <_bss_end>)
403752d1:	c0cca0        	sub	a12, a12, a10
403752d4:	0b0c      	movi.n	a11, 0
403752d6:	fc6e81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403752d9:	0008e0        	callx8	a8
    memset(&_iram_bss_start, 0, (&_iram_bss_end - &_iram_bss_start) * sizeof(_iram_bss_start));
#endif

#if SOC_RTC_FAST_MEM_SUPPORTED || SOC_RTC_SLOW_MEM_SUPPORTED
    /* Unless waking from deep sleep (implying RTC memory is intact), clear RTC bss */
    if (rst_reas[0] != RESET_REASON_CORE_DEEP_SLEEP) {
403752dc:	105526        	beqi	a5, 5, 403752f0 <call_start_cpu0+0x44>
        memset(&_rtc_bss_start, 0, (&_rtc_bss_end - &_rtc_bss_start) * sizeof(_rtc_bss_start));
403752df:	fc5ba1        	l32r	a10, 4037444c <_iram_text_start+0x48> (50000000 <_coredump_rtc_end>)
403752e2:	fc59c1        	l32r	a12, 40374448 <_iram_text_start+0x44> (50000000 <_coredump_rtc_end>)
403752e5:	c0cca0        	sub	a12, a12, a10
403752e8:	0b0c      	movi.n	a11, 0
403752ea:	fc6981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403752ed:	0008e0        	callx8	a8
    }
#endif

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP && !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE && !SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE
    // It helps to fix missed cache settings for other cores. It happens when bootloader is unicore.
    do_multicore_settings();
403752f0:	fff2e5        	call8	40375220 <do_multicore_settings>
#endif

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    //cache hal ctx needs to be initialised
    cache_hal_init();
403752f3:	075ee5        	call8	4037c8e0 <cache_hal_init>
#endif

#if CONFIG_IDF_TARGET_ESP32S3
    /* Configure the mode of instruction cache : cache size, cache line size. */
    extern void rom_config_instruction_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_instruction_cache_mode(CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE, CONFIG_ESP32S3_ICACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE);
403752f6:	0c2c      	movi.n	a12, 32
403752f8:	8b0c      	movi.n	a11, 8
403752fa:	fc55a1        	l32r	a10, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
403752fd:	fc6581        	l32r	a8, 40374494 <_iram_text_start+0x90> (40001a1c <rom_config_instruction_cache_mode>)
40375300:	0008e0        	callx8	a8

    /* If we need use SPIRAM, we should use data cache.
       Configure the mode of data : cache size, cache line size.*/
    Cache_Suspend_DCache();
40375303:	0429e5        	call8	403795a0 <Cache_Suspend_DCache>
    extern void rom_config_data_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_data_cache_mode(CONFIG_ESP32S3_DATA_CACHE_SIZE, CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE);
40375306:	0c2c      	movi.n	a12, 32
40375308:	8b0c      	movi.n	a11, 8
4037530a:	fc52a1        	l32r	a10, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
4037530d:	fc6281        	l32r	a8, 40374498 <_iram_text_start+0x94> (40001a28 <rom_config_data_cache_mode>)
40375310:	0008e0        	callx8	a8
    Cache_Resume_DCache(0);
40375313:	0a0c      	movi.n	a10, 0
40375315:	fc6181        	l32r	a8, 4037449c <_iram_text_start+0x98> (400018c0 <Cache_Resume_DCache>)
40375318:	0008e0        	callx8	a8
    // are all in internal RAM. If the RAM loadable ELF has any requirement to memory map the
    // external flash then it should use flash or partition mmap APIs.
    uint32_t cache_mmu_irom_size = 0;
    __attribute__((unused)) uint32_t cache_mmu_drom_size = 0;
#else // CONFIG_APP_BUILD_TYPE_ELF_RAM
    uint32_t _instruction_size = (uint32_t)&_instruction_reserved_end - (uint32_t)&_instruction_reserved_start;
4037531b:	fc4f71        	l32r	a7, 40374458 <_iram_text_start+0x54> (4201723e <_etext>)
4037531e:	fc4f81        	l32r	a8, 4037445c <_iram_text_start+0x58> (42000020 <_instruction_reserved_start>)
40375321:	c07780        	sub	a7, a7, a8
    uint32_t cache_mmu_irom_size = ((_instruction_size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
40375324:	fc4f81        	l32r	a8, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40375327:	778a      	add.n	a7, a7, a8
40375329:	f57070        	extui	a7, a7, 16, 16
4037532c:	11a7e0        	slli	a10, a7, 2

    uint32_t _rodata_size = (uint32_t)&_rodata_reserved_end - (uint32_t)&_rodata_reserved_start;
4037532f:	fc4d31        	l32r	a3, 40374464 <_iram_text_start+0x60> (3c02a53c <_esp_system_init_fn_array_end>)
40375332:	fc4d41        	l32r	a4, 40374468 <_iram_text_start+0x64> (3c020020 <esp_app_desc>)
40375335:	c06340        	sub	a6, a3, a4
    __attribute__((unused)) uint32_t cache_mmu_drom_size = ((_rodata_size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
40375338:	668a      	add.n	a6, a6, a8
4037533a:	f56060        	extui	a6, a6, 16, 16
#endif // !CONFIG_APP_BUILD_TYPE_ELF_RAM

    /* Configure the Cache MMU size for instruction and rodata in flash. */
    Cache_Set_IDROM_MMU_Size(cache_mmu_irom_size, CACHE_DROM_MMU_MAX_END - cache_mmu_irom_size);
4037533d:	fcdab2        	addmi	a11, a10, 0xfffffc00
40375340:	60b0b0        	neg	a11, a11
40375343:	fc5781        	l32r	a8, 403744a0 <_iram_text_start+0x9c> (40001914 <Cache_Set_IDROM_MMU_Size>)
40375346:	0008e0        	callx8	a8
        ESP_DRAM_LOGE(TAG, "Octal Flash option selected, but EFUSE not configured!");
        abort();
    }
#endif

    esp_mspi_pin_init();
40375349:	027d65        	call8	40377b20 <esp_mspi_pin_init>
    // For Octal flash, it's hard to implement a read_id function in OPI mode for all vendors.
    // So we have to read it here in SPI mode, before entering the OPI mode.
    bootloader_flash_update_id();
4037534c:	fc5681        	l32r	a8, 403744a4 <_iram_text_start+0xa0> (420095d8 <bootloader_flash_update_id>)
4037534f:	0008e0        	callx8	a8

    // Configure the power related stuff. After this the MSPI timing tuning can be done.
    esp_rtc_init();
40375352:	fc5581        	l32r	a8, 403744a8 <_iram_text_start+0xa4> (420016b8 <esp_rtc_init>)
40375355:	0008e0        	callx8	a8
     *
     * In bootloader, we only init Flash (and MSPI) to a preliminary state, for being flexible to
     * different chips.
     * In this stage, we re-configure the Flash (and MSPI) to required configuration
     */
    spi_flash_init_chip_state();
40375358:	027de5        	call8	40377b38 <spi_flash_init_chip_state>
#if SOC_MEMSPI_SRC_FREQ_120M_SUPPORTED
    // This function needs to be called when PLL is enabled. Needs to be called after spi_flash_init_chip_state in case
    // some state of flash is modified.
    mspi_timing_flash_tuning();
4037535b:	031de5        	call8	40378538 <mspi_timing_flash_tuning>
#endif

    esp_mmu_map_init();
4037535e:	fc5381        	l32r	a8, 403744ac <_iram_text_start+0xa8> (42009738 <esp_mmu_map_init>)
40375361:	0008e0        	callx8	a8
    /**
     * @note
     * After this stage, you can access the flash through the cache, i.e. run code which is not placed in IRAM
     * or print string which locates on flash
     */
    esp_mspi_pin_reserve();
40375364:	fc5381        	l32r	a8, 403744b0 <_iram_text_start+0xac> (42009fcc <esp_mspi_pin_reserve>)
40375367:	0008e0        	callx8	a8
__attribute__((always_inline))
static inline esp_log_level_t esp_log_get_default_level(void)
{
#if CONFIG_LOG_DYNAMIC_LEVEL_CONTROL
    extern esp_log_level_t esp_log_default_level;
    return esp_log_default_level;
4037536a:	fc4081        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
4037536d:	0888      	l32i.n	a8, a8, 0
#endif // !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP

#if CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    ESP_EARLY_LOGI(TAG, "Unicore app");
#else
    ESP_EARLY_LOGI(TAG, "Multicore app");
4037536f:	1138b6        	bltui	a8, 3, 40375384 <call_start_cpu0+0xd8>
40375372:	0a8be5        	call8	4037fc30 <esp_log_timestamp>
40375375:	fc3ec1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
40375378:	20baa0        	or	a11, a10, a10
4037537b:	fc3ea1        	l32r	a10, 40374474 <_iram_text_start+0x70> (3c0204b4 <_flash_rodata_start+0x394>)
4037537e:	fc4d81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375381:	0008e0        	callx8	a8
#endif
    /* NOTE: When ESP-TEE is enabled, it configures its own memory protection
     * scheme using the CPU-inherent features PMP and PMA and the APM peripheral.
     */
#if !CONFIG_SECURE_ENABLE_TEE
    bootloader_init_mem();
40375384:	fc2881        	l32r	a8, 40374424 <_iram_text_start+0x20> (420095d0 <bootloader_init_mem>)
40375387:	0008e0        	callx8	a8
#endif

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_up[0] = true;
4037538a:	fc2181        	l32r	a8, 40374410 <_iram_text_start+0xc> (3fc949a8 <s_cpu_up>)
4037538d:	01a092        	movi	a9, 1
40375390:	0020c0        	memw
40375393:	004892        	s8i	a9, a8, 0

    ESP_EARLY_LOGD(TAG, "Pro cpu up");

#if SOC_CPU_CORES_NUM > 1 // there is no 'single-core mode' for natively single-core processors
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    start_other_core();
40375396:	fc4881        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (420014e4 <start_other_core>)
40375399:	0008e0        	callx8	a8
    s_instr_flash2spiram_off = instruction_flash2spiram_offset();
#endif
#if CONFIG_SPIRAM_RODATA
    s_rodata_flash2spiram_off = rodata_flash2spiram_offset();
#endif
    Cache_Set_IDROM_MMU_Info(cache_mmu_irom_size / sizeof(uint32_t), \
4037539c:	0f0c      	movi.n	a15, 0
4037539e:	0fed      	mov.n	a14, a15
403753a0:	03dd      	mov.n	a13, a3
403753a2:	04cd      	mov.n	a12, a4
403753a4:	20b660        	or	a11, a6, a6
403753a7:	20a770        	or	a10, a7, a7
403753aa:	fc4481        	l32r	a8, 403744bc <_iram_text_start+0xb8> (40001950 <Cache_Set_IDROM_MMU_Info>)
403753ad:	0008e0        	callx8	a8
    trax_enable(TRAX_ENA_PRO);
#endif
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif // CONFIG_ESP32_TRAX || CONFIG_ESP32S2_TRAX || CONFIG_ESP32S3_TRAX

    esp_clk_init();
403753b0:	fc4481        	l32r	a8, 403744c0 <_iram_text_start+0xbc> (420016e0 <esp_clk_init>)
403753b3:	0008e0        	callx8	a8
    esp_perip_clk_init();
403753b6:	fc4381        	l32r	a8, 403744c4 <_iram_text_start+0xc0> (42001808 <esp_perip_clk_init>)
403753b9:	0008e0        	callx8	a8

    // Now that the clocks have been set-up, set the startup time from RTC
    // and default RTC-backed system time provider.
    g_startup_time = esp_rtc_get_time_us();
403753bc:	fc4381        	l32r	a8, 403744c8 <_iram_text_start+0xc4> (420031ec <esp_rtc_get_time_us>)
403753bf:	0008e0        	callx8	a8
403753c2:	fc2d81        	l32r	a8, 40374478 <_iram_text_start+0x74> (3fc949d8 <g_startup_time>)
403753c5:	08a9      	s32i.n	a10, a8, 0
403753c7:	0168b2        	s32i	a11, a8, 4

    // Clear interrupt matrix for PRO CPU core
    core_intr_matrix_clear();
403753ca:	fc1881        	l32r	a8, 4037442c <_iram_text_start+0x28> (420014c0 <core_intr_matrix_clear>)
403753cd:	0008e0        	callx8	a8
#endif
#endif

#if SOC_DEEP_SLEEP_SUPPORTED
    // Need to unhold the IOs that were hold right before entering deep sleep, which are used as wakeup pins
    if (rst_reas[0] == RESET_REASON_CORE_DEEP_SLEEP) {
403753d0:	055566        	bnei	a5, 5, 403753d9 <call_start_cpu0+0x12d>
        esp_deep_sleep_wakeup_io_reset();
403753d3:	fc3e81        	l32r	a8, 403744cc <_iram_text_start+0xc8> (42003c10 <esp_deep_sleep_wakeup_io_reset>)
403753d6:	0008e0        	callx8	a8
    }
#endif  //#if SOC_DEEP_SLEEP_SUPPORTED

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    esp_cache_err_int_init();
403753d9:	fc1581        	l32r	a8, 40374430 <_iram_text_start+0x2c> (42001aa8 <esp_cache_err_int_init>)
403753dc:	0008e0        	callx8	a8
    // If such a situation appears, it is likely an malicious attempt to bypass the system safety setup -> print error & reset

#if CONFIG_IDF_TARGET_ESP32S2
    if (esp_memprot_is_locked_any()) {
#else
    bool is_locked = false;
403753df:	080c      	movi.n	a8, 0
403753e1:	084182        	s8i	a8, a1, 8
    if (esp_mprot_is_conf_locked_any(&is_locked) != ESP_OK || is_locked) {
403753e4:	a18b      	addi.n	a10, a1, 8
403753e6:	fc3a81        	l32r	a8, 403744d0 <_iram_text_start+0xcc> (4200506c <esp_mprot_is_conf_locked_any>)
403753e9:	0008e0        	callx8	a8
403753ec:	3acc      	bnez.n	a10, 403753f3 <call_start_cpu0+0x147>
403753ee:	080182        	l8ui	a8, a1, 8
403753f1:	d89c      	beqz.n	a8, 40375412 <call_start_cpu0+0x166>
403753f3:	fc1e81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
403753f6:	0888      	l32i.n	a8, a8, 0
#endif
        ESP_EARLY_LOGE(TAG, "Memprot feature locked after the system reset! Potential safety corruption, rebooting.");
403753f8:	089c      	beqz.n	a8, 4037540c <call_start_cpu0+0x160>
403753fa:	0a8365        	call8	4037fc30 <esp_log_timestamp>
403753fd:	fc1cc1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
40375400:	20baa0        	or	a11, a10, a10
40375403:	fc1ea1        	l32r	a10, 4037447c <_iram_text_start+0x78> (3c0204d0 <_flash_rodata_start+0x3b0>)
40375406:	fc2b81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375409:	0008e0        	callx8	a8
        esp_restart_noos();
4037540c:	201110        	or	a1, a1, a1
4037540f:	003525        	call8	40375760 <esp_restart_noos>
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_LOCK, NULL);
#else
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_UNLOCK, NULL);
#endif
#else //CONFIG_IDF_TARGET_ESP32S2 specific end
    esp_memp_config_t memp_cfg = ESP_MEMPROT_DEFAULT_CONFIG();
40375412:	71cb      	addi.n	a7, a1, 12
40375414:	8c1c      	movi.n	a12, 24
40375416:	fc1ab1        	l32r	a11, 40374480 <_iram_text_start+0x7c> (3c0270a0 <__func__$0+0x20>)
40375419:	07ad      	mov.n	a10, a7
4037541b:	fc2e81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037541e:	0008e0        	callx8	a8
#if !CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK
    memp_cfg.lock_feature = false;
#endif
    memp_err = esp_mprot_set_prot(&memp_cfg);
40375421:	07ad      	mov.n	a10, a7
40375423:	fc2d81        	l32r	a8, 403744d8 <_iram_text_start+0xd4> (420051f4 <esp_mprot_set_prot>)
40375426:	0008e0        	callx8	a8
40375429:	0a7d      	mov.n	a7, a10
#endif //other IDF_TARGETS end

    if (memp_err != ESP_OK) {
4037542b:	9aac      	beqz.n	a10, 40375458 <call_start_cpu0+0x1ac>
4037542d:	fc0f81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40375430:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Failed to set Memprot feature (0x%08X: %s), rebooting.", memp_err, esp_err_to_name(memp_err));
40375433:	e89c      	beqz.n	a8, 40375455 <call_start_cpu0+0x1a9>
40375435:	0a7fa5        	call8	4037fc30 <esp_log_timestamp>
40375438:	0a6d      	mov.n	a6, a10
4037543a:	07ad      	mov.n	a10, a7
4037543c:	fc2881        	l32r	a8, 403744dc <_iram_text_start+0xd8> (420028c4 <esp_err_to_name>)
4037543f:	0008e0        	callx8	a8
40375442:	0aed      	mov.n	a14, a10
40375444:	07dd      	mov.n	a13, a7
40375446:	fc0ac1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
40375449:	20b660        	or	a11, a6, a6
4037544c:	fc0ea1        	l32r	a10, 40374484 <_iram_text_start+0x80> (3c020534 <_flash_rodata_start+0x414>)
4037544f:	fc1981        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375452:	0008e0        	callx8	a8
        esp_restart_noos();
40375455:	0030a5        	call8	40375760 <esp_restart_noos>

#if !CONFIG_APP_BUILD_TYPE_RAM
    // Normal startup flow. We arrive here with the help of 1st, 2nd bootloader. There are valid headers (app/bootloader)

    // Read the application binary image header. This will also decrypt the header if the image is encrypted.
    __attribute__((unused)) esp_image_header_t fhdr = {0};
40375458:	24c162        	addi	a6, a1, 36
4037545b:	851c      	movi.n	a5, 24
4037545d:	05cd      	mov.n	a12, a5
4037545f:	0b0c      	movi.n	a11, 0
40375461:	06ad      	mov.n	a10, a6
40375463:	fc0b81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40375466:	0008e0        	callx8	a8

    // We can access the image header through the cache by reading from the memory-mapped virtual DROM start offset
    uint32_t fhdr_src_addr = (uint32_t)(&_rodata_reserved_start) - sizeof(esp_image_header_t) - sizeof(esp_image_segment_header_t);
    hal_memcpy(&fhdr, (void *) fhdr_src_addr, sizeof(fhdr));
40375469:	05cd      	mov.n	a12, a5
4037546b:	e0c4b2        	addi	a11, a4, -32
4037546e:	06ad      	mov.n	a10, a6
40375470:	fc1981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375473:	0008e0        	callx8	a8
    if (fhdr.magic != ESP_IMAGE_HEADER_MAGIC) {
40375476:	240192        	l8ui	a9, a1, 36
40375479:	e9a082        	movi	a8, 233
4037547c:	1c1987        	beq	a9, a8, 4037549c <call_start_cpu0+0x1f0>
4037547f:	fbfb81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40375482:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Invalid app image header");
40375485:	010816        	beqz	a8, 40375499 <call_start_cpu0+0x1ed>
40375488:	0a7a65        	call8	4037fc30 <esp_log_timestamp>
4037548b:	fbf9c1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
4037548e:	0abd      	mov.n	a11, a10
40375490:	fbfea1        	l32r	a10, 40374488 <_iram_text_start+0x84> (3c020578 <_flash_rodata_start+0x458>)
40375493:	fc0881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375496:	0008e0        	callx8	a8
        abort();
40375499:	0a84a5        	call8	4037fce4 <abort>
    bootloader_flash_unlock();
#endif
#endif //!CONFIG_APP_BUILD_TYPE_PURE_RAM_APP

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_inited[0] = true;
4037549c:	fbde81        	l32r	a8, 40374414 <_iram_text_start+0x10> (3fc949a4 <s_cpu_inited>)
4037549f:	190c      	movi.n	a9, 1
403754a1:	0020c0        	memw
403754a4:	004892        	s8i	a9, a8, 0

    volatile bool cpus_inited = false;
403754a7:	080c      	movi.n	a8, 0
403754a9:	0020c0        	memw
403754ac:	3c4182        	s8i	a8, a1, 60

    while (!cpus_inited) {
403754af:	000e46        	j	403754ec <call_start_cpu0+0x240>
        cpus_inited = true;
403754b2:	180c      	movi.n	a8, 1
403754b4:	0020c0        	memw
403754b7:	3c4182        	s8i	a8, a1, 60
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
403754ba:	079d      	mov.n	a9, a7
403754bc:	000806        	j	403754e0 <call_start_cpu0+0x234>
403754bf:	810000        	src	a0, a0, a0
            cpus_inited &= s_cpu_inited[i];
403754c2:	9afbd4        	lsi	f13, a11, 0x268
403754c5:	c088      	l32i.n	a8, a0, 48
403754c7:	a20020        	muluh	a0, a0, a2
403754ca:	0008      	l32i.n	a0, a0, 0
403754cc:	0020c0        	memw
403754cf:	3c0182        	l8ui	a8, a1, 60
403754d2:	748080        	extui	a8, a8, 0, 8
403754d5:	1088a0        	and	a8, a8, a10
403754d8:	0020c0        	memw
403754db:	3c4182        	s8i	a8, a1, 60
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
403754de:	991b      	addi.n	a9, a9, 1
403754e0:	dd29a6        	blti	a9, 2, 403754c1 <call_start_cpu0+0x215>
        }
        esp_rom_delay_us(100);
403754e3:	64a0a2        	movi	a10, 100
403754e6:	fbd381        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
403754e9:	0008e0        	callx8	a8
    while (!cpus_inited) {
403754ec:	0020c0        	memw
403754ef:	3c0182        	l8ui	a8, a1, 60
403754f2:	748080        	extui	a8, a8, 0, 8
403754f5:	fb9816        	beqz	a8, 403754b2 <call_start_cpu0+0x206>
    asm volatile (
403754f8:	03eb80        	rsr.prid	a8
403754fb:	048d80        	extui	a8, a8, 13, 1
    }
#endif

    SYS_STARTUP_FN();
403754fe:	fbc791        	l32r	a9, 4037441c <_iram_text_start+0x18> (3c027180 <g_startup_fn>)
40375501:	a08890        	addx4	a8, a8, a9
40375504:	0888      	l32i.n	a8, a8, 0
40375506:	0008e0        	callx8	a8
}
40375509:	f01d      	retw.n
	...

4037550c <rtc_brownout_isr_handler>:

static __attribute__((unused)) DRAM_ATTR const char TAG[] = "BOD";

#if CONFIG_ESP_SYSTEM_BROWNOUT_INTR
IRAM_ATTR static void rtc_brownout_isr_handler(void *arg)
{
4037550c:	004136        	entry	a1, 32
 * @brief Clear interrupt bits.
 */
__attribute__((always_inline))
static inline void brownout_ll_intr_clear(void)
{
    RTCCNTL.int_clr.rtc_brown_out = 1;
4037550f:	fbf491        	l32r	a9, 403744e0 <_iram_text_start+0xdc> (60008000 <RTCCNTL>)
40375512:	0020c0        	memw
40375515:	132982        	l32i	a8, a9, 76
40375518:	00a2a2        	movi	a10, 0x200
4037551b:	2088a0        	or	a8, a8, a10
4037551e:	0020c0        	memw
40375521:	136982        	s32i	a8, a9, 76
40375524:	03eba0        	rsr.prid	a10
40375527:	04ada0        	extui	a10, a10, 13, 1

    // Stop the other core.
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    const uint32_t core_id = esp_cpu_get_core_id();
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
    esp_cpu_stall(other_core_id);
4037552a:	40faa0        	nsau	a10, a10
4037552d:	41a5a0        	srli	a10, a10, 5
40375530:	02c8a5        	call8	403781bc <esp_cpu_stall>
#endif

    esp_reset_reason_set_hint(ESP_RST_BROWNOUT);
40375533:	9a0c      	movi.n	a10, 9
40375535:	001325        	call8	40375668 <esp_reset_reason_set_hint>
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    if (spi_flash_brownout_need_reset()) {
40375538:	0aa5a5        	call8	4037ff94 <spi_flash_brownout_need_reset>
4037553b:	5a8c      	beqz.n	a10, 40375544 <rtc_brownout_isr_handler+0x38>
        bootloader_flash_reset_chip();
4037553d:	0209e5        	call8	403775dc <bootloader_flash_reset_chip>
40375540:	001a86        	j	403755ae <rtc_brownout_isr_handler+0xa2>
40375543:	ca8100        	float.s	f8, a1, 0
40375546:	88fb      	addi.n	a8, a8, 15
40375548:	b608      	l32i.n	a0, a6, 44
    } else
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET
    {
        ESP_DRAM_LOGI(TAG, "Brownout detector was triggered\r\n\r\n");
4037554a:	6138      	l32i.n	a3, a1, 24
4037554c:	fbe6b1        	l32r	a11, 403744e4 <_iram_text_start+0xe0> (3fc928ec <TAG>)
4037554f:	fbe6a1        	l32r	a10, 403744e8 <_iram_text_start+0xe4> (3fc928c0 <__c$0>)
40375552:	fbd881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375555:	0008e0        	callx8	a8
40375558:	001486        	j	403755ae <rtc_brownout_isr_handler+0xa2>
4037555b:	079d00        	lsi	f0, a13, 28
 *
 * @return true: enabled; false: disabled
 */
FORCE_INLINE_ATTR bool uart_ll_is_enabled(uint32_t uart_num)
{
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
4037555e:	679c      	beqz.n	a7, 40375578 <rtc_brownout_isr_handler+0x6c>
                            (uart_num == 1) ? SYSTEM_UART1_RST :
40375560:	1c1726        	beqi	a7, 1, 40375580 <rtc_brownout_isr_handler+0x74>
                            (uart_num == 2) ? SYSTEM_UART2_RST : 0);
40375563:	052766        	bnei	a7, 2, 4037556c <rtc_brownout_isr_handler+0x60>
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
40375566:	00a282        	movi	a8, 0x200
40375569:	000046        	j	4037556e <rtc_brownout_isr_handler+0x62>
4037556c:	080c      	movi.n	a8, 0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
4037556e:	162966        	bnei	a9, 2, 40375588 <rtc_brownout_isr_handler+0x7c>
40375571:	00a2a2        	movi	a10, 0x200
40375574:	000486        	j	4037558a <rtc_brownout_isr_handler+0x7e>
40375577:	480c00        	ssx	f0, a12, a0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
4037557a:	08ad      	mov.n	a10, a8
4037557c:	000286        	j	4037558a <rtc_brownout_isr_handler+0x7e>
4037557f:	082c00        	lsx	f2, a12, a0
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
40375582:	0a2c      	movi.n	a10, 32
40375584:	000086        	j	4037558a <rtc_brownout_isr_handler+0x7e>
40375587:	0a0c00        	add.s	f0, f12, f0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
4037558a:	fbd891        	l32r	a9, 403744ec <_iram_text_start+0xe8> (600c0020 <SYSTEM+0x20>)
4037558d:	0020c0        	memw
40375590:	0998      	l32i.n	a9, a9, 0
40375592:	138987        	bany	a9, a8, 403755a9 <rtc_brownout_isr_handler+0x9d>
        DPORT_REG_GET_BIT(SYSTEM_PERIP_CLK_EN0_REG, uart_en_bit) != 0;
40375595:	fbd681        	l32r	a8, 403744f0 <_iram_text_start+0xec> (600c0018 <SYSTEM+0x18>)
40375598:	0020c0        	memw
4037559b:	0888      	l32i.n	a8, a8, 0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
4037559d:	0808a7        	bnone	a8, a10, 403755a9 <rtc_brownout_isr_handler+0x9d>
    }

    // Flush any data left in UART FIFOs
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
        if (uart_ll_is_enabled(i)) {
            esp_rom_output_tx_wait_idle(i);
403755a0:	74a070        	extui	a10, a7, 0, 8
403755a3:	fbd481        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (4000069c <esp_rom_output_tx_wait_idle>)
403755a6:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
403755a9:	771b      	addi.n	a7, a7, 1
403755ab:	000046        	j	403755b0 <rtc_brownout_isr_handler+0xa4>
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
403755ae:	070c      	movi.n	a7, 0
403755b0:	a837a6        	blti	a7, 3, 4037555c <rtc_brownout_isr_handler+0x50>
        }
    }

    esp_rom_software_reset_system();
403755b3:	fbd181        	l32r	a8, 403744f8 <_iram_text_start+0xf4> (400006d8 <esp_rom_software_reset_system>)
403755b6:	0008e0        	callx8	a8

    ESP_INFINITE_LOOP();
403755b9:	ffff06        	j	403755b9 <rtc_brownout_isr_handler+0xad>

403755bc <xt_highint4>:
    .align      4
xt_highint4:

#ifndef CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    /* See if we're here for the IPC_ISR interrupt */
    rsr     a0, INTERRUPT
403755bc:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_IPC_ISR_INUM, 1
403755bf:	050c00        	extui	a0, a0, 28, 1
    bnez    a0, jump_to_esp_ipc_isr_handler
403755c2:	07f056        	bnez	a0, 40375645 <jump_to_esp_ipc_isr_handler>
#endif // not CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE

    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
403755c5:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
403755c7:	ffd112        	addmi	a1, a1, 0xffffff00
403755ca:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
403755cd:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
403755cf:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
403755d2:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
403755d5:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_4                       /* save interruptee's PC */
403755d7:	03b400        	rsr.epc4	a0
    s32i    a0, sp, XT_STK_PC
403755da:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_4                   /* save interruptee's a0 */
403755dc:	03d400        	rsr.excsave4	a0
    s32i    a0, sp, XT_STK_A0
403755df:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
403755e1:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
403755e4:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
403755e6:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
403755e9:	0c7785        	call0	40381d64 <_xt_context_save>

    /* Save vaddr into exception frame */
    rsr     a0, EXCVADDR
403755ec:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
403755ef:	156102        	s32i	a0, a1, 84

    /* Figure out reason, save into EXCCAUSE reg */

    rsr     a0, INTERRUPT
403755f2:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_CACHEERR_INUM, 1 /* get cacheerr int bit */
403755f5:	050900        	extui	a0, a0, 25, 1
    beqz    a0, 1f
403755f8:	009c      	beqz.n	a0, 4037560c <xt_highint4+0x50>
    /* Kill this interrupt; we cannot reset it. */
    rsr     a0, INTENABLE
403755fa:	03e400        	rsr.intenable	a0
    movi    a4, ~(1<<ETS_CACHEERR_INUM)
403755fd:	fbbf41        	l32r	a4, 403744fc <_iram_text_start+0xf8> (fdffffff <_rtc_reserved_end+0x9defffff>)
    and     a0, a4, a0
40375600:	100400        	and	a0, a4, a0
    wsr     a0, INTENABLE
40375603:	13e400        	wsr.intenable	a0
    movi    a0, PANIC_RSN_CACHEERR
40375606:	700c      	movi.n	a0, 7
    j 9f
40375608:	000406        	j	4037561c <xt_highint4+0x60>
4037560b:	bd0100        	lsi	f0, a1, 0x2f4

1:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    /* Check if the cause is the app cpu failing to tick.*/
    movi    a0, int_wdt_cpu1_ticked
4037560e:	08fb      	addi.n	a0, a8, 15
    l32i    a0, a0, 0
40375610:	40cc00        	lsi	f0, a12, 0x100
    bnez    a0, 2f
    /* It is. Modify cause. */
    movi    a0,PANIC_RSN_INTWDT_CPU1
40375613:	600c      	movi.n	a0, 6
    j 9f
40375615:	0000c6        	j	4037561c <xt_highint4+0x60>
40375618:	a00200        	addx4	a0, a2, a0
2:
#endif

    /* Set EXCCAUSE to reflect cause of the wdt int trigger */
    movi    a0,PANIC_RSN_INTWDT_CPU0
4037561b:	610205        	call0	403d663c <_coredump_iram_end+0x5463c>
9:
    /* Found the reason, now save it. */
    s32i    a0, sp, XT_STK_EXCCAUSE
4037561e:	b90114        	lsi	f1, a1, 0x2e4

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(5) | PS_UM | PS_WOE
40375621:	00fb      	addi.n	a0, a0, 15
    wsr     a0, PS
40375623:	1013e6        	bgei	a3, 1, 40375637 <xt_highint4+0x7b>

    //Call panic handler
    mov     a6,sp
40375626:	552061        	l32r	a6, 4034aaa8 <rom_rx_gain_force+0x34467c>
    call4   panicHandler
40375629:	0039      	s32i.n	a3, a0, 0

    call0   _xt_context_restore
4037562b:	0c7dc5        	call0	40381e08 <_xt_context_restore>
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
4037562e:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40375630:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40375633:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_4
40375635:	13b400        	wsr.epc4	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40375638:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
4037563a:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
4037563c:	002010        	rsync

    rsr     a0, EXCSAVE_4                   /* restore a0 */
4037563f:	03d400        	rsr.excsave4	a0
    rfi     4
40375642:	003410        	rfi	4

40375645 <jump_to_esp_ipc_isr_handler>:

#ifdef CONFIG_ESP_IPC_ISR_ENABLE
jump_to_esp_ipc_isr_handler:
    /* Address of `esp_ipc_isr_handler_address` will always be in `movi` range
     * as it is defined right above. */
    movi    a0, esp_ipc_isr_handler
40375645:	fbb001        	l32r	a0, 40374508 <_iram_text_start+0x104> (403759f8 <esp_ipc_isr_handler>)
    jx      a0
40375648:	0000a0        	jx	a0

4037564b <ld_include_highint_hdl>:
	...

4037564c <recalib_bbpll>:
}

// Workaround for bootloader not calibrated well issue.
// Placed in IRAM because disabling BBPLL may influence the cache
static void IRAM_ATTR NOINLINE_ATTR recalib_bbpll(void)
{
4037564c:	006136        	entry	a1, 48
    rtc_cpu_freq_config_t old_config;
    rtc_clk_cpu_freq_get_config(&old_config);
4037564f:	20a110        	or	a10, a1, a1
40375652:	034f25        	call8	40378b44 <rtc_clk_cpu_freq_get_config>
    // There are two paths we arrive here: 1. CPU reset. 2. Other reset reasons.
    // - For other reasons, the bootloader will set CPU source to BBPLL and enable it. But there are calibration issues.
    //   Turn off the BBPLL and do calibration again to fix the issue.
    // - For CPU reset, the CPU source will be set to XTAL, while the BBPLL is kept to meet USB Serial JTAG's
    //   requirements. In this case, we don't touch BBPLL to avoid USJ disconnection.
    if (old_config.source == SOC_CPU_CLK_SRC_PLL) {
40375655:	002182        	l32i	a8, a1, 0
40375658:	081866        	bnei	a8, 1, 40375664 <recalib_bbpll+0x18>
        rtc_clk_cpu_freq_set_xtal();
4037565b:	038b65        	call8	40378f10 <rtc_clk_cpu_freq_set_xtal>
        rtc_clk_cpu_freq_set_config(&old_config);
4037565e:	20a110        	or	a10, a1, a1
40375661:	0383e5        	call8	40378ea0 <rtc_clk_cpu_freq_set_config>
    }
}
40375664:	f01d      	retw.n
	...

40375668 <esp_reset_reason_set_hint>:
#define RST_REASON_MASK 0x7FFF
#define RST_REASON_SHIFT 16

/* in IRAM, can be called from panic handler */
void IRAM_ATTR esp_reset_reason_set_hint(esp_reset_reason_t hint)
{
40375668:	004136        	entry	a1, 32
    assert((hint & (~RST_REASON_MASK)) == 0);
4037566b:	fba881        	l32r	a8, 4037450c <_iram_text_start+0x108> (7fff <UserFrameTotalSize+0x7eff>)
4037566e:	0eb827        	bgeu	a8, a2, 40375680 <esp_reset_reason_set_hint+0x18>
40375671:	fba7d1        	l32r	a13, 40374510 <_iram_text_start+0x10c> (3c02065c <_flash_rodata_start+0x53c>)
40375674:	fba8c1        	l32r	a12, 40374514 <_iram_text_start+0x110> (3c0270d4 <__func__$0>)
40375677:	5da0b2        	movi	a11, 93
4037567a:	fba7a1        	l32r	a10, 40374518 <_iram_text_start+0x114> (3c0206ad <_flash_rodata_start+0x58d>)
4037567d:	0a7225        	call8	4037fda0 <__assert_func>
    uint32_t val = hint | (hint << RST_REASON_SHIFT) | RST_REASON_BIT;
40375680:	118200        	slli	a8, a2, 16
40375683:	208820        	or	a8, a8, a2
40375686:	fba591        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
40375689:	208890        	or	a8, a8, a9
    REG_WRITE(RTC_RESET_CAUSE_REG, val);
4037568c:	fba591        	l32r	a9, 40374520 <_iram_text_start+0x11c> (600080c8 <RTCCNTL+0xc8>)
4037568f:	0020c0        	memw
40375692:	006982        	s32i	a8, a9, 0
}
40375695:	000090        	retw

40375698 <esp_system_reset_modules_on_exit>:
#define ALIGN_DOWN(val, align)  ((val) & ~((align) - 1))

extern int _bss_end;

void IRAM_ATTR esp_system_reset_modules_on_exit(void)
{
40375698:	004136        	entry	a1, 32
    // Flush any data left in UART FIFOs before reset the UART peripheral
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
4037569b:	070c      	movi.n	a7, 0
4037569d:	001386        	j	403756ef <esp_system_reset_modules_on_exit+0x57>
        if (uart_ll_is_enabled(i)) {
403756a0:	079d      	mov.n	a9, a7
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
403756a2:	679c      	beqz.n	a7, 403756bc <esp_system_reset_modules_on_exit+0x24>
                            (uart_num == 1) ? SYSTEM_UART1_RST :
403756a4:	1c1726        	beqi	a7, 1, 403756c4 <esp_system_reset_modules_on_exit+0x2c>
                            (uart_num == 2) ? SYSTEM_UART2_RST : 0);
403756a7:	052766        	bnei	a7, 2, 403756b0 <esp_system_reset_modules_on_exit+0x18>
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
403756aa:	00a282        	movi	a8, 0x200
403756ad:	000046        	j	403756b2 <esp_system_reset_modules_on_exit+0x1a>
403756b0:	080c      	movi.n	a8, 0
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
403756b2:	162966        	bnei	a9, 2, 403756cc <esp_system_reset_modules_on_exit+0x34>
403756b5:	00a2a2        	movi	a10, 0x200
403756b8:	000486        	j	403756ce <esp_system_reset_modules_on_exit+0x36>
403756bb:	480c00        	ssx	f0, a12, a0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
403756be:	08ad      	mov.n	a10, a8
403756c0:	000286        	j	403756ce <esp_system_reset_modules_on_exit+0x36>
403756c3:	082c00        	lsx	f2, a12, a0
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
403756c6:	08ad      	mov.n	a10, a8
403756c8:	000086        	j	403756ce <esp_system_reset_modules_on_exit+0x36>
403756cb:	0a0c00        	add.s	f0, f12, f0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
403756ce:	fb8791        	l32r	a9, 403744ec <_iram_text_start+0xe8> (600c0020 <SYSTEM+0x20>)
403756d1:	0020c0        	memw
403756d4:	0998      	l32i.n	a9, a9, 0
403756d6:	138987        	bany	a9, a8, 403756ed <esp_system_reset_modules_on_exit+0x55>
        DPORT_REG_GET_BIT(SYSTEM_PERIP_CLK_EN0_REG, uart_en_bit) != 0;
403756d9:	fb8581        	l32r	a8, 403744f0 <_iram_text_start+0xec> (600c0018 <SYSTEM+0x18>)
403756dc:	0020c0        	memw
403756df:	0888      	l32i.n	a8, a8, 0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
403756e1:	0808a7        	bnone	a8, a10, 403756ed <esp_system_reset_modules_on_exit+0x55>
            esp_rom_output_tx_wait_idle(i);
403756e4:	74a070        	extui	a10, a7, 0, 8
403756e7:	fb8381        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (4000069c <esp_rom_output_tx_wait_idle>)
403756ea:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
403756ed:	771b      	addi.n	a7, a7, 1
403756ef:	ad37a6        	blti	a7, 3, 403756a0 <esp_system_reset_modules_on_exit+0x8>
        }
    }

    // Reset wifi/bluetooth/ethernet/sdio (bb/mac)
    SET_PERI_REG_MASK(SYSTEM_CORE_RST_EN_REG,
403756f2:	fb8c81        	l32r	a8, 40374524 <_iram_text_start+0x120> (60026018 <SYSCON+0x18>)
403756f5:	0020c0        	memw
403756f8:	0898      	l32i.n	a9, a8, 0
403756fa:	fb8ba1        	l32r	a10, 40374528 <_iram_text_start+0x124> (3faf <UserFrameTotalSize+0x3eaf>)
403756fd:	2099a0        	or	a9, a9, a10
40375700:	0020c0        	memw
40375703:	0899      	s32i.n	a9, a8, 0
                      SYSTEM_WIFIBB_RST | SYSTEM_FE_RST | SYSTEM_WIFIMAC_RST | SYSTEM_SDIO_RST |
                      SYSTEM_EMAC_RST | SYSTEM_MACPWR_RST | SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST |
                      SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
    REG_WRITE(SYSTEM_CORE_RST_EN_REG, 0);
40375705:	090c      	movi.n	a9, 0
40375707:	0020c0        	memw
4037570a:	0899      	s32i.n	a9, a8, 0

    // Reset timer, systimer, spi, uart, mcpwm
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG,
4037570c:	fb7881        	l32r	a8, 403744ec <_iram_text_start+0xe8> (600c0020 <SYSTEM+0x20>)
4037570f:	0020c0        	memw
40375712:	08a8      	l32i.n	a10, a8, 0
40375714:	fb86b1        	l32r	a11, 4037452c <_iram_text_start+0x128> (20120007 <UserFrameTotalSize+0x2011ff07>)
40375717:	20aab0        	or	a10, a10, a11
4037571a:	0020c0        	memw
4037571d:	08a9      	s32i.n	a10, a8, 0
                      SYSTEM_TIMERS_RST | SYSTEM_SPI01_RST | SYSTEM_UART_RST | SYSTEM_SYSTIMER_RST |
                      SYSTEM_PWM0_RST | SYSTEM_PWM1_RST);
    REG_WRITE(SYSTEM_PERIP_RST_EN0_REG, 0);
4037571f:	0020c0        	memw
40375722:	0899      	s32i.n	a9, a8, 0

    // Reset dma
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_DMA_RST);
40375724:	fb8381        	l32r	a8, 40374530 <_iram_text_start+0x12c> (600c0024 <SYSTEM+0x24>)
40375727:	0020c0        	memw
4037572a:	08a8      	l32i.n	a10, a8, 0
4037572c:	0b4c      	movi.n	a11, 64
4037572e:	20aab0        	or	a10, a10, a11
40375731:	0020c0        	memw
40375734:	08a9      	s32i.n	a10, a8, 0
    REG_WRITE(SYSTEM_PERIP_RST_EN1_REG, 0);
40375736:	0020c0        	memw
40375739:	0899      	s32i.n	a9, a8, 0

    SET_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
4037573b:	fb7e81        	l32r	a8, 40374534 <_iram_text_start+0x130> (600c0044 <SYSTEM+0x44>)
4037573e:	0020c0        	memw
40375741:	0898      	l32i.n	a9, a8, 0
40375743:	2a0c      	movi.n	a10, 2
40375745:	2099a0        	or	a9, a9, a10
40375748:	0020c0        	memw
4037574b:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
4037574d:	0020c0        	memw
40375750:	0898      	l32i.n	a9, a8, 0
40375752:	da7c      	movi.n	a10, -3
40375754:	1099a0        	and	a9, a9, a10
40375757:	0020c0        	memw
4037575a:	0899      	s32i.n	a9, a8, 0
}
4037575c:	f01d      	retw.n
	...

40375760 <esp_restart_noos>:
/* "inner" restart function for after RTOS, interrupts & anything else on this
 * core are already stopped. Stalls other core, resets hardware,
 * triggers restart.
*/
void IRAM_ATTR esp_restart_noos(void)
{
40375760:	008136        	entry	a1, 64
 * @param intr_mask Bit mask of the interrupts to disable
 */
FORCE_INLINE_ATTR void esp_cpu_intr_disable(uint32_t intr_mask)
{
#ifdef __XTENSA__
    xt_ints_off(intr_mask);
40375763:	fa7c      	movi.n	a10, -1
40375765:	0c7aa5        	call8	40381f10 <xt_ints_off>
    // Disable interrupts
    esp_cpu_intr_disable(0xFFFFFFFF);

    // Enable RTC watchdog for 1 second
    wdt_hal_context_t rtc_wdt_ctx;
    wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
40375768:	0d0c      	movi.n	a13, 0
4037576a:	0dcd      	mov.n	a12, a13
4037576c:	0dbd      	mov.n	a11, a13
4037576e:	01ad      	mov.n	a10, a1
40375770:	fb7b81        	l32r	a8, 4037455c <_iram_text_start+0x158> (40000dbc <wdt_hal_init>)
40375773:	0008e0        	callx8	a8
    uint32_t stage_timeout_ticks = (uint32_t)(1000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
40375776:	032ba5        	call8	40378a30 <rtc_clk_slow_freq_get_hz>
40375779:	060c      	movi.n	a6, 0
4037577b:	e8a3c2        	movi	a12, 0x3e8
4037577e:	a2bca0        	muluh	a11, a12, a10
40375781:	06dd      	mov.n	a13, a6
40375783:	82aca0        	mull	a10, a12, a10
40375786:	fb7681        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
40375789:	0008e0        	callx8	a8
4037578c:	0a7d      	mov.n	a7, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
4037578e:	01ad      	mov.n	a10, a1
40375790:	fb7581        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
40375793:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_SYSTEM);
40375796:	3d0c      	movi.n	a13, 3
40375798:	07cd      	mov.n	a12, a7
4037579a:	06bd      	mov.n	a11, a6
4037579c:	01ad      	mov.n	a10, a1
4037579e:	fb7281        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
403757a1:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE1, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
403757a4:	4d0c      	movi.n	a13, 4
403757a6:	07cd      	mov.n	a12, a7
403757a8:	1b0c      	movi.n	a11, 1
403757aa:	01ad      	mov.n	a10, a1
403757ac:	fb6f81        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
403757af:	0008e0        	callx8	a8
    //Enable flash boot mode so that flash booting after restart is protected by the RTC WDT.
    wdt_hal_set_flashboot_en(&rtc_wdt_ctx, true);
403757b2:	1b0c      	movi.n	a11, 1
403757b4:	01ad      	mov.n	a10, a1
403757b6:	fb6d81        	l32r	a8, 4037456c <_iram_text_start+0x168> (40000e28 <wdt_hal_set_flashboot_en>)
403757b9:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
403757bc:	01ad      	mov.n	a10, a1
403757be:	fb6c81        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
403757c1:	0008e0        	callx8	a8

    // Disable TG0/TG1 watchdogs
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
403757c4:	fb5d81        	l32r	a8, 40374538 <_iram_text_start+0x134> (3c0270f0 <__func__$0+0x1c>)
403757c7:	718b      	addi.n	a7, a1, 8
403757c9:	0898      	l32i.n	a9, a8, 0
403757cb:	1888      	l32i.n	a8, a8, 4
403757cd:	2199      	s32i.n	a9, a1, 8
403757cf:	3189      	s32i.n	a8, a1, 12
    wdt_hal_write_protect_disable(&wdt0_context);
403757d1:	07ad      	mov.n	a10, a7
403757d3:	fb6481        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
403757d6:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
403757d9:	07ad      	mov.n	a10, a7
403757db:	fb6681        	l32r	a8, 40374574 <_iram_text_start+0x170> (40000e04 <wdt_hal_disable>)
403757de:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
403757e1:	07ad      	mov.n	a10, a7
403757e3:	fb6381        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
403757e6:	0008e0        	callx8	a8

    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
403757e9:	fb5481        	l32r	a8, 4037453c <_iram_text_start+0x138> (3c0270f8 <__func__$0+0x24>)
403757ec:	10c172        	addi	a7, a1, 16
403757ef:	0898      	l32i.n	a9, a8, 0
403757f1:	1888      	l32i.n	a8, a8, 4
403757f3:	4199      	s32i.n	a9, a1, 16
403757f5:	5189      	s32i.n	a8, a1, 20
    wdt_hal_write_protect_disable(&wdt1_context);
403757f7:	07ad      	mov.n	a10, a7
403757f9:	fb5a81        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
403757fc:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
403757ff:	07ad      	mov.n	a10, a7
40375801:	fb5c81        	l32r	a8, 40374574 <_iram_text_start+0x170> (40000e04 <wdt_hal_disable>)
40375804:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
40375807:	07ad      	mov.n	a10, a7
40375809:	fb5981        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
4037580c:	0008e0        	callx8	a8
        SET_STACK(new_sp);
    }
#endif

    // Disable cache
    Cache_Disable_ICache();
4037580f:	fb5a81        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
40375812:	0008e0        	callx8	a8
    Cache_Disable_DCache();
40375815:	fb5981        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
40375818:	0008e0        	callx8	a8
4037581b:	03eb50        	rsr.prid	a5
4037581e:	045d50        	extui	a5, a5, 13, 1
    // CPU must be reset before stalling, in case it was running a s32c1i
    // instruction. This would cause memory pool to be locked by arbiter
    // to the stalled CPU, preventing current CPU from accessing this pool.
    const uint32_t core_id = esp_cpu_get_core_id();
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
40375821:	40f570        	nsau	a7, a5
40375824:	417570        	srli	a7, a7, 5
    esp_rom_software_reset_cpu(other_core_id);
40375827:	07ad      	mov.n	a10, a7
40375829:	fb5581        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
4037582c:	0008e0        	callx8	a8
    esp_cpu_stall(other_core_id);
4037582f:	07ad      	mov.n	a10, a7
40375831:	0298a5        	call8	403781bc <esp_cpu_stall>
#endif

    // 2nd stage bootloader reconfigures SPI flash signals.
    // Reset them to the defaults expected by ROM.
    WRITE_PERI_REG(GPIO_FUNC0_IN_SEL_CFG_REG, 0x30);
40375834:	083c      	movi.n	a8, 48
40375836:	fb4291        	l32r	a9, 40374540 <_iram_text_start+0x13c> (60004154 <GPIO+0x154>)
40375839:	0020c0        	memw
4037583c:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC1_IN_SEL_CFG_REG, 0x30);
4037583e:	fb4191        	l32r	a9, 40374544 <_iram_text_start+0x140> (60004158 <GPIO+0x158>)
40375841:	0020c0        	memw
40375844:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC2_IN_SEL_CFG_REG, 0x30);
40375846:	fb4091        	l32r	a9, 40374548 <_iram_text_start+0x144> (6000415c <GPIO+0x15c>)
40375849:	0020c0        	memw
4037584c:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC3_IN_SEL_CFG_REG, 0x30);
4037584e:	fb3f91        	l32r	a9, 4037454c <_iram_text_start+0x148> (60004160 <GPIO+0x160>)
40375851:	0020c0        	memw
40375854:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC4_IN_SEL_CFG_REG, 0x30);
40375856:	fb3e91        	l32r	a9, 40374550 <_iram_text_start+0x14c> (60004164 <GPIO+0x164>)
40375859:	0020c0        	memw
4037585c:	006982        	s32i	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC5_IN_SEL_CFG_REG, 0x30);
4037585f:	fb3d91        	l32r	a9, 40374554 <_iram_text_start+0x150> (60004168 <GPIO+0x168>)
40375862:	0020c0        	memw
40375865:	006982        	s32i	a8, a9, 0

    // reset necessary peripheral modules
    esp_system_reset_modules_on_exit();
40375868:	ffe2e5        	call8	40375698 <esp_system_reset_modules_on_exit>

    // Set CPU back to XTAL source, same as hard reset, but keep BBPLL on so that USB Serial JTAG can log at 1st stage bootloader.
#if !CONFIG_IDF_ENV_FPGA
    rtc_clk_cpu_set_to_default_config();
4037586b:	036965        	call8	40378f00 <rtc_clk_cpu_set_to_default_config>
#endif

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // Clear entry point for APP CPU
    REG_WRITE(SYSTEM_CORE_1_CONTROL_1_REG, 0);
4037586e:	fb3a81        	l32r	a8, 40374558 <_iram_text_start+0x154> (600c0004 <SYSTEM+0x4>)
40375871:	0020c0        	memw
40375874:	0869      	s32i.n	a6, a8, 0
#endif

    // Reset CPUs
    if (core_id == 0) {
40375876:	25dc      	bnez.n	a5, 4037588c <esp_restart_noos+0x12c>
        // Running on PRO CPU: APP CPU is stalled. Can reset both CPUs.
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
        esp_rom_software_reset_cpu(1);
40375878:	1a0c      	movi.n	a10, 1
4037587a:	fb4181        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
4037587d:	0008e0        	callx8	a8
#endif
        esp_rom_software_reset_cpu(0);
40375880:	0a0c      	movi.n	a10, 0
40375882:	fb3f81        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
40375885:	0008e0        	callx8	a8
40375888:	000606        	j	403758a4 <esp_restart_noos+0x144>
4037588b:	a0a200        	addx4	a10, a2, a0
    }
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    else {
        // Running on APP CPU: need to reset PRO CPU and unstall it,
        // then reset APP CPU
        esp_rom_software_reset_cpu(0);
4037588e:	3c8100        	lsi	f0, a1, 240
40375891:	e0fb      	addi.n	a14, a0, 15
40375893:	0008      	l32i.n	a0, a0, 0
        esp_cpu_unstall(0);
40375895:	00a0a2        	movi	a10, 0
40375898:	029a65        	call8	40378240 <esp_cpu_unstall>
        esp_rom_software_reset_cpu(1);
4037589b:	01a0a2        	movi	a10, 1
4037589e:	fb3881        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
403758a1:	0008e0        	callx8	a8
    }
#endif

    ESP_INFINITE_LOOP();
403758a4:	ffff06        	j	403758a4 <esp_restart_noos+0x144>
	...

403758a8 <apb_backup_dma_unlock>:
        portENTER_CRITICAL(&s_apb_backup_dma_mutex);
    }
}

static void IRAM_ATTR apb_backup_dma_unlock(void)
{
403758a8:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403758ab:	048625        	call8	4037a10c <xPortInIsrContext>
403758ae:	aa8c      	beqz.n	a10, 403758bc <apb_backup_dma_unlock+0x14>
        portEXIT_CRITICAL_ISR(&s_apb_backup_dma_mutex);
403758b0:	fb35a1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc92000 <s_apb_backup_dma_mutex>)
403758b3:	049ce5        	call8	4037a280 <vPortExitCritical>
403758b6:	000206        	j	403758c2 <apb_backup_dma_unlock+0x1a>
403758b9:	000000        	ill
    } else {
        portEXIT_CRITICAL(&s_apb_backup_dma_mutex);
403758bc:	fb32a1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc92000 <s_apb_backup_dma_mutex>)
403758bf:	049c25        	call8	4037a280 <vPortExitCritical>
    }
}
403758c2:	f01d      	retw.n

403758c4 <apb_backup_dma_lock>:
{
403758c4:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403758c7:	048465        	call8	4037a10c <xPortInIsrContext>
403758ca:	00ba16        	beqz	a10, 403758d9 <apb_backup_dma_lock+0x15>

// ------------------ Critical Sections --------------------

static inline void __attribute__((always_inline)) vPortEnterCritical(portMUX_TYPE *mux)
{
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403758cd:	fb7c      	movi.n	a11, -1
403758cf:	fb2da1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc92000 <s_apb_backup_dma_mutex>)
403758d2:	0485e5        	call8	4037a130 <xPortEnterCriticalTimeout>
}
403758d5:	000206        	j	403758e1 <apb_backup_dma_lock+0x1d>
403758d8:	fb7c00        	f64addc	a0, a12, 3, 1
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403758db:	fb2aa1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc92000 <s_apb_backup_dma_mutex>)
403758de:	048525        	call8	4037a130 <xPortEnterCriticalTimeout>
}
403758e1:	f01d      	retw.n
	...

403758e4 <tick_hook>:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
volatile bool int_wdt_cpu1_ticked = false;
#endif

static void IRAM_ATTR tick_hook(void)
{
403758e4:	004136        	entry	a1, 32
403758e7:	03eb80        	rsr.prid	a8
403758ea:	048d80        	extui	a8, a8, 13, 1
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    if (esp_cpu_get_core_id() != 0) {
403758ed:	c88c      	beqz.n	a8, 403758fd <tick_hook+0x19>
        int_wdt_cpu1_ticked = true;
403758ef:	fb0481        	l32r	a8, 40374500 <_iram_text_start+0xfc> (3fc949bc <int_wdt_cpu1_ticked>)
403758f2:	190c      	movi.n	a9, 1
403758f4:	0020c0        	memw
403758f7:	004892        	s8i	a9, a8, 0
403758fa:	001586        	j	40375954 <tick_hook+0x70>
    } else {
        // Only feed wdt if app cpu also ticked.
        if (int_wdt_cpu1_ticked) {
403758fd:	fb0081        	l32r	a8, 40374500 <_iram_text_start+0xfc> (3fc949bc <int_wdt_cpu1_ticked>)
40375900:	0020c0        	memw
40375903:	000882        	l8ui	a8, a8, 0
40375906:	748080        	extui	a8, a8, 0, 8
40375909:	047816        	beqz	a8, 40375954 <tick_hook+0x70>
            // Todo: Check if there's a way to avoid reconfiguring the stages on each feed.
            wdt_hal_write_protect_disable(&iwdt_context);
4037590c:	fb1f71        	l32r	a7, 40374588 <_iram_text_start+0x184> (3fc949c0 <iwdt_context>)
4037590f:	20a770        	or	a10, a7, a7
40375912:	fb1481        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
40375915:	0008e0        	callx8	a8
#if CONFIG_ESP32_ECO3_CACHE_LOCK_FIX
            _lx_intr_livelock_counter = 0;
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE0,
                                 CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US / (_lx_intr_livelock_max + 1), WDT_STAGE_ACTION_INT);                    // Set timeout before interrupt
#else
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);          // Set timeout before interrupt
40375918:	01a0d2        	movi	a13, 1
4037591b:	58a2c2        	movi	a12, 0x258
4037591e:	00a0b2        	movi	a11, 0
40375921:	20a770        	or	a10, a7, a7
40375924:	fb1181        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
40375927:	0008e0        	callx8	a8
#endif
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
4037592a:	3d0c      	movi.n	a13, 3
4037592c:	b0a4c2        	movi	a12, 0x4b0
4037592f:	1b0c      	movi.n	a11, 1
40375931:	07ad      	mov.n	a10, a7
40375933:	fb0d81        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
40375936:	0008e0        	callx8	a8
            wdt_hal_feed(&iwdt_context);
40375939:	07ad      	mov.n	a10, a7
4037593b:	fb1481        	l32r	a8, 4037458c <_iram_text_start+0x188> (40000e1c <wdt_hal_feed>)
4037593e:	0008e0        	callx8	a8
            wdt_hal_write_protect_enable(&iwdt_context);
40375941:	07ad      	mov.n	a10, a7
40375943:	fb0b81        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
40375946:	0008e0        	callx8	a8
            int_wdt_cpu1_ticked = false;
40375949:	faed81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (3fc949bc <int_wdt_cpu1_ticked>)
4037594c:	090c      	movi.n	a9, 0
4037594e:	0020c0        	memw
40375951:	004892        	s8i	a9, a8, 0
        wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
        wdt_hal_feed(&iwdt_context);
        wdt_hal_write_protect_enable(&iwdt_context);
    }
#endif // CONFIG_ESP_INT_WDT_CHECK_CPU1
}
40375954:	f01d      	retw.n
	...

40375958 <panic_abort>:
#endif /* CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT || CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT */
#endif /* CONFIG_ESP_SYSTEM_PANIC_GDBSTUB */
}

void IRAM_ATTR __attribute__((noreturn, no_sanitize_undefined)) panic_abort(const char *details)
{
40375958:	004136        	entry	a1, 32
    g_panic_abort = true;
4037595b:	fb0d81        	l32r	a8, 40374590 <_iram_text_start+0x18c> (3fc949d0 <g_panic_abort>)
4037595e:	190c      	movi.n	a9, 1
40375960:	004892        	s8i	a9, a8, 0
    g_panic_abort_details = (char *) details;
40375963:	fb0c81        	l32r	a8, 40374594 <_iram_text_start+0x190> (3fc949cc <g_panic_abort_details>)
40375966:	0829      	s32i.n	a2, a8, 0
                              APPTRACE_ONPANIC_HOST_FLUSH_TMO);
#endif
#endif

#ifdef __XTENSA__
    asm("ill");     // should be an invalid operation on xtensa targets
40375968:	000000        	ill
#elif __riscv
    asm("unimp");   // should be an invalid operation on RISC-V targets
#endif

    ESP_INFINITE_LOOP();
4037596b:	ffff06        	j	4037596b <panic_abort+0x13>
	...

40375970 <start_cpu_other_cores>:

/* This function has to be in IRAM, as while it is running on CPU1, CPU0 may do some flash operations
 * (e.g. initialize the core dump), which means that cache will be disabled.
 */
static void IRAM_ATTR start_cpu_other_cores_default(void)
{
40375970:	004136        	entry	a1, 32
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_SECONDARY);
40375973:	01a0a2        	movi	a10, 1
40375976:	fb0981        	l32r	a8, 4037459c <_iram_text_start+0x198> (42002074 <do_system_init_fn>)
40375979:	0008e0        	callx8	a8

    while (!s_system_full_inited) {
4037597c:	000206        	j	40375988 <start_cpu_other_cores+0x18>
        esp_rom_delay_us(100);
4037597f:	64a0a2        	movi	a10, 100
40375982:	faac81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40375985:	0008e0        	callx8	a8
    while (!s_system_full_inited) {
40375988:	fb0481        	l32r	a8, 40374598 <_iram_text_start+0x194> (3fc949d1 <s_system_full_inited>)
4037598b:	0020c0        	memw
4037598e:	000882        	l8ui	a8, a8, 0
40375991:	748080        	extui	a8, a8, 0, 8
40375994:	fe7816        	beqz	a8, 4037597f <start_cpu_other_cores+0xf>
    }

    esp_startup_start_app_other_cores();
40375997:	fb0281        	l32r	a8, 403745a0 <_iram_text_start+0x19c> (42016c18 <esp_startup_start_app_other_cores>)
4037599a:	0008e0        	callx8	a8
4037599d:	000000        	ill

403759a0 <panic_enable_cache>:
 * This function must always be in IRAM as it is required to
 * re-enable the flash cache.
 */
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
static void IRAM_ATTR panic_enable_cache(void)
{
403759a0:	004136        	entry	a1, 32
403759a3:	03eb70        	rsr.prid	a7
403759a6:	047d70        	extui	a7, a7, 13, 1
    int core_id = esp_cpu_get_core_id();
    if (!spi_flash_cache_enabled()) {
403759a9:	020b25        	call8	40377a5c <spi_flash_cache_enabled>
403759ac:	008a56        	bnez	a10, 403759b8 <panic_enable_cache+0x18>
        esp_ipc_isr_stall_abort();
403759af:	0003a5        	call8	403759e8 <esp_ipc_isr_stall_abort>
        spi_flash_enable_cache(core_id);
403759b2:	20a770        	or	a10, a7, a7
403759b5:	020965        	call8	40377a4c <spi_flash_enable_cache>
    }

#if SOC_CACHE_ACS_INVALID_STATE_ON_PANIC
    // Some errors need to be cleared here to allow cache to operate normally again
    // for certain circumstances.
    esp_cache_err_acs_save_and_clr();
403759b8:	fafb81        	l32r	a8, 403745a4 <_iram_text_start+0x1a0> (420019f8 <esp_cache_err_acs_save_and_clr>)
403759bb:	0008e0        	callx8	a8
#endif //SOC_CACHE_ACS_INVALID_STATE_ON_PANIC
}
403759be:	f01d      	retw.n

403759c0 <panicHandler>:
#endif

void IRAM_ATTR panicHandler(void *frame)
{
403759c0:	004136        	entry	a1, 32
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    panic_enable_cache();
403759c3:	fffde5        	call8	403759a0 <panic_enable_cache>
#endif
    // This panic handler gets called for when the double exception vector,
    // kernel exception vector gets used; as well as handling interrupt-based
    // faults cache error, wdt expiry. EXCAUSE register gets written with
    // one of PANIC_RSN_* values.
    panic_handler(frame, true);
403759c6:	1b0c      	movi.n	a11, 1
403759c8:	02ad      	mov.n	a10, a2
403759ca:	faf781        	l32r	a8, 403745a8 <_iram_text_start+0x1a4> (420021b0 <panic_handler>)
403759cd:	0008e0        	callx8	a8
}
403759d0:	f01d      	retw.n
	...

403759d4 <xt_unhandled_exception>:

void IRAM_ATTR xt_unhandled_exception(void *frame)
{
403759d4:	004136        	entry	a1, 32
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    panic_enable_cache();
403759d7:	fffca5        	call8	403759a0 <panic_enable_cache>
#endif
    panic_handler(frame, false);
403759da:	0b0c      	movi.n	a11, 0
403759dc:	02ad      	mov.n	a10, a2
403759de:	faf281        	l32r	a8, 403745a8 <_iram_text_start+0x1a4> (420021b0 <panic_handler>)
403759e1:	0008e0        	callx8	a8
}
403759e4:	f01d      	retw.n
	...

403759e8 <esp_ipc_isr_stall_abort>:
    s_stall_state = STALL_STATE_IDLE;
    IPC_ISR_EXIT_CRITICAL();
}

void IRAM_ATTR esp_ipc_isr_stall_abort(void)
{
403759e8:	004136        	entry	a1, 32
    //Note: We don't enter a critical section here as we are calling this from a panic.
    s_stall_state = STALL_STATE_IDLE;
403759eb:	faf081        	l32r	a8, 403745ac <_iram_text_start+0x1a8> (3fc949e8 <s_stall_state>)
403759ee:	090c      	movi.n	a9, 0
403759f0:	0020c0        	memw
403759f3:	0899      	s32i.n	a9, a8, 0
}
403759f5:	f01d      	retw.n
	...

403759f8 <esp_ipc_isr_handler>:
       allows one cpu to enter in the IPC_ISR section of the LX
       interrupt at one time, there's no need to have two
       _lx_intr_stack for each cpu */

    /* Save A0, A2, A3, A4 so we can use those registers further*/
    movi    a0, _lx_intr_stack
403759f8:	faee01        	l32r	a0, 403745b0 <_iram_text_start+0x1ac> (3fc9201c <_lx_intr_stack>)
    s32i    a2, a0, LX_INTR_A2_OFFSET
403759fb:	1029      	s32i.n	a2, a0, 4
    s32i    a3, a0, LX_INTR_A3_OFFSET
403759fd:	2039      	s32i.n	a3, a0, 8
    s32i    a4, a0, LX_INTR_A4_OFFSET
403759ff:	3049      	s32i.n	a4, a0, 12
    rsr     a2, EXCSAVE_X
40375a01:	03d420        	rsr.excsave4	a2
    s32i    a2, a0, LX_INTR_A0_OFFSET
40375a04:	0029      	s32i.n	a2, a0, 0

    /* disable nested iterrupts */
    /* PS.EXCM is changed from 1 to 0 . It allows using usually exception handler instead of the Double exception handler. */
    /* PS_UM = 1 */
    movi    a0, PS_INTLEVEL(5) | PS_UM
40375a06:	502c      	movi.n	a0, 37
    wsr     a0, PS
40375a08:	13e600        	wsr.ps	a0
    rsync
40375a0b:	002010        	rsync
#if CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5
    /* This int is level-triggered and doesn't need clearing.
       Do nothing here and clear int status by peripheral register later.*/
#elif CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4
    /* This int is edge-triggered and needs clearing. */
    movi    a3, (1 << ETS_IPC_ISR_INUM)
40375a0e:	fae931        	l32r	a3, 403745b4 <_iram_text_start+0x1b0> (10000000 <UserFrameTotalSize+0xfffff00>)
    wsr     a3, INTCLEAR
40375a11:	13e330        	wsr.intclear	a3
#endif /* CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5 */

    /* get CORE_ID */
    getcoreid   a3
40375a14:	03eb30        	rsr.prid	a3
40375a17:	043d30        	extui	a3, a3, 13, 1
    beqz    a3, 1f
40375a1a:	a38c      	beqz.n	a3, 40375a28 <esp_ipc_isr_handler+0x30>

    /* current cpu is 1 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_3_REG
40375a1c:	fae731        	l32r	a3, 403745b8 <_iram_text_start+0x1b4> (600c003c <SYSTEM+0x3c>)
    movi    a4, 0
40375a1f:	040c      	movi.n	a4, 0
    s32i    a4, a3, 0   /* clear intr */
40375a21:	0349      	s32i.n	a4, a3, 0
    j       2f
40375a23:	000206        	j	40375a2f <esp_ipc_isr_handler+0x37>
40375a26:	310000        	srai	a0, a0, 16
1:
    /* current cpu is 0 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_2_REG
40375a29:	0cfae5        	call8	403829d8 <_coredump_iram_end+0x9d8>
    movi    a4, 0
40375a2c:	034904        	lsi	f0, a9, 12
    s32i    a4, a3, 0   /* clear intr */
2:

    /* set the start flag */
    movi    a0, esp_ipc_isr_start_fl
40375a2f:	fae401        	l32r	a0, 403745c0 <_iram_text_start+0x1bc> (3fc949f4 <esp_ipc_isr_start_fl>)
    memw
40375a32:	0020c0        	memw
    s32i    a0, a0, 0
40375a35:	0009      	s32i.n	a0, a0, 0

    /* Call the esp_ipc_function(void* arg) */
    movi    a0, esp_ipc_func
40375a37:	fae301        	l32r	a0, 403745c4 <_iram_text_start+0x1c0> (3fc949f0 <esp_ipc_func>)
    l32i    a0, a0, 0
40375a3a:	0008      	l32i.n	a0, a0, 0
    movi    a2, esp_ipc_func_arg
40375a3c:	fae321        	l32r	a2, 403745c8 <_iram_text_start+0x1c4> (3fc949ec <esp_ipc_func_arg>)
    l32i    a2, a2, 0
40375a3f:	0228      	l32i.n	a2, a2, 0
    callx0  a0
40375a41:	0000c0        	callx0	a0

    /* Done. Restore registers and return. */
    movi    a0, _lx_intr_stack
40375a44:	fadb01        	l32r	a0, 403745b0 <_iram_text_start+0x1ac> (3fc9201c <_lx_intr_stack>)
    l32i    a2, a0, LX_INTR_A2_OFFSET
40375a47:	1028      	l32i.n	a2, a0, 4
    l32i    a3, a0, LX_INTR_A3_OFFSET
40375a49:	2038      	l32i.n	a3, a0, 8
    l32i    a4, a0, LX_INTR_A4_OFFSET
40375a4b:	3048      	l32i.n	a4, a0, 12

    /* set the end flag */
    movi    a0, esp_ipc_isr_end_fl
40375a4d:	fadf01        	l32r	a0, 403745cc <_iram_text_start+0x1c8> (3fc92018 <esp_ipc_isr_end_fl>)
    memw
40375a50:	0020c0        	memw
    s32i    a0, a0, 0
40375a53:	0009      	s32i.n	a0, a0, 0

    /* restore a0 */
    rsr     a0, EXCSAVE_X
40375a55:	03d400        	rsr.excsave4	a0
    /* restores PS from EPS[X] and jumps to the address in EPC[X] */
    rfi     RFI_X
40375a58:	003410        	rfi	4
	...

40375a5c <print_entry>:
    //Return true if both sp and pc of frame(i-1) are sane, false otherwise
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
}

static void IRAM_ATTR print_entry(uint32_t pc, uint32_t sp, bool panic)
{
40375a5c:	004136        	entry	a1, 32
    if (panic) {
40375a5f:	54ac      	beqz.n	a4, 40375a88 <print_entry+0x2c>
        panic_print_str(" 0x");
40375a61:	fadba1        	l32r	a10, 403745d0 <_iram_text_start+0x1cc> (3c0209c8 <_flash_rodata_start+0x8a8>)
40375a64:	fade81        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (42001d90 <panic_print_str>)
40375a67:	0008e0        	callx8	a8
        panic_print_hex(pc);
40375a6a:	02ad      	mov.n	a10, a2
40375a6c:	fadd81        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (42001dbc <panic_print_hex>)
40375a6f:	0008e0        	callx8	a8
        panic_print_str(":0x");
40375a72:	fad8a1        	l32r	a10, 403745d4 <_iram_text_start+0x1d0> (3c020e64 <_flash_rodata_start+0xd44>)
40375a75:	fad981        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (42001d90 <panic_print_str>)
40375a78:	0008e0        	callx8	a8
        panic_print_hex(sp);
40375a7b:	20a330        	or	a10, a3, a3
40375a7e:	fad881        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (42001dbc <panic_print_hex>)
40375a81:	0008e0        	callx8	a8
40375a84:	000346        	j	40375a95 <print_entry+0x39>
40375a87:	03cd00        	lsi	f0, a13, 12
    } else {
        esp_rom_printf(" 0x%08" PRIX32 ":0x%08" PRIX32, pc, sp);
40375a8a:	02bd      	mov.n	a11, a2
40375a8c:	fad3a1        	l32r	a10, 403745d8 <_iram_text_start+0x1d4> (3c020e68 <_flash_rodata_start+0xd48>)
40375a8f:	fa8981        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375a92:	0008e0        	callx8	a8
    }
}
40375a95:	f01d      	retw.n
	...

40375a98 <print_str>:

static void IRAM_ATTR print_str(const char* str, bool panic)
{
40375a98:	004136        	entry	a1, 32
40375a9b:	02ad      	mov.n	a10, a2
    if (panic) {
40375a9d:	738c      	beqz.n	a3, 40375aa8 <print_str+0x10>
        panic_print_str(str);
40375a9f:	facf81        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (42001d90 <panic_print_str>)
40375aa2:	0008e0        	callx8	a8
40375aa5:	000146        	j	40375aae <print_str+0x16>
    } else {
        esp_rom_printf(str);
40375aa8:	fa8381        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375aab:	0008e0        	callx8	a8
    }
}
40375aae:	f01d      	retw.n

40375ab0 <esp_backtrace_get_next_frame>:
{
40375ab0:	004136        	entry	a1, 32
    void *base_save = (void *)frame->sp;     //Base save area consists of 4 words under SP
40375ab3:	1288      	l32i.n	a8, a2, 4
    frame->pc = frame->next_pc;
40375ab5:	22a8      	l32i.n	a10, a2, 8
40375ab7:	02a9      	s32i.n	a10, a2, 0
    frame->next_pc = *((uint32_t *)(base_save - 16));     //If next_pc = 0, indicates frame(i-1) is the last frame on the stack
40375ab9:	f0c892        	addi	a9, a8, -16
40375abc:	0998      	l32i.n	a9, a9, 0
40375abe:	2299      	s32i.n	a9, a2, 8
    frame->sp =  *((uint32_t *)(base_save - 12));
40375ac0:	f4c882        	addi	a8, a8, -12
40375ac3:	0888      	l32i.n	a8, a8, 0
40375ac5:	1289      	s32i.n	a8, a2, 4
 */
__attribute__((always_inline))
inline static bool esp_stack_ptr_in_dram(uint32_t sp)
{
    //Check if stack ptr is in between SOC_DRAM_LOW and SOC_DRAM_HIGH, and 16 byte aligned.
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375ac7:	fac791        	l32r	a9, 403745e4 <_iram_text_start+0x1e0> (c0377ff0 <_rtc_reserved_end+0x60277ff0>)
40375aca:	809890        	add	a9, a8, a9
40375acd:	fac6b1        	l32r	a11, 403745e8 <_iram_text_start+0x1e4> (77fe0 <UserFrameTotalSize+0x77ee0>)
40375ad0:	053b97        	bltu	a11, a9, 40375ad9 <esp_backtrace_get_next_frame+0x29>
40375ad3:	349080        	extui	a9, a8, 0, 4
40375ad6:	00b916        	beqz	a9, 40375ae5 <esp_backtrace_get_next_frame+0x35>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40375ad9:	fac491        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40375adc:	808890        	add	a8, a8, a9
    return esp_stack_ptr_in_dram(sp)
#if CONFIG_FREERTOS_TASK_CREATE_ALLOW_EXT_MEM
        || esp_stack_ptr_in_extram(sp)
#endif
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375adf:	fac491        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375ae2:	543987        	bltu	a9, a8, 40375b3a <esp_backtrace_get_next_frame+0x8a>
 * @param pc PC value of the current backtrace frame
 *
 */
static inline uint32_t esp_cpu_process_stack_pc(uint32_t pc)
{
    if (pc & 0x80000000) {
40375ae5:	00bad6        	bgez	a10, 40375af4 <esp_backtrace_get_next_frame+0x44>
        //Top two bits of a0 (return address) specify window increment. Overwrite to map to address space.
        pc = (pc & 0x3fffffff) | 0x40000000;
40375ae8:	11aae0        	slli	a10, a10, 2
40375aeb:	41a2a0        	srli	a10, a10, 2
40375aee:	fac181        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375af1:	20aa80        	or	a10, a10, a8
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40375af4:	fac191        	l32r	a9, 403745f8 <_iram_text_start+0x1f4> (bdfffffd <_rtc_reserved_end+0x5deffffd>)
40375af7:	9a9a      	add.n	a9, a10, a9
40375af9:	fac081        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
40375afc:	628890        	lsi	f9, a8, 0x188
40375aff:	880b      	addi.n	a8, a8, -1
40375b01:	608080        	neg	a8, a8
40375b04:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40375b07:	fabeb1        	l32r	a11, 40374600 <_iram_text_start+0x1fc> (bfc8fffd <_rtc_reserved_end+0x5fb8fffd>)
40375b0a:	baba      	add.n	a11, a10, a11
40375b0c:	fabe91        	l32r	a9, 40374604 <_iram_text_start+0x200> (6ffff <UserFrameTotalSize+0x6feff>)
40375b0f:	6299b0        	lsi	f11, a9, 0x188
40375b12:	990b      	addi.n	a9, a9, -1
40375b14:	609090        	neg	a9, a9
40375b17:	749090        	extui	a9, a9, 0, 8
40375b1a:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375b1d:	f8dc      	bnez.n	a8, 40375b40 <esp_backtrace_get_next_frame+0x90>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40375b1f:	faba81        	l32r	a8, 40374608 <_iram_text_start+0x204> (bffffffd <_rtc_reserved_end+0x5feffffd>)
40375b22:	8a8a      	add.n	a8, a10, a8
40375b24:	faba91        	l32r	a9, 4037460c <_iram_text_start+0x208> (5ffff <UserFrameTotalSize+0x5feff>)
40375b27:	1ab987        	bgeu	a9, a8, 40375b45 <esp_backtrace_get_next_frame+0x95>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375b2a:	fab981        	l32r	a8, 40374610 <_iram_text_start+0x20c> (9ff01ffd <_rtc_reserved_end+0x3fe01ffd>)
40375b2d:	aa8a      	add.n	a10, a10, a8
40375b2f:	fab081        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375b32:	1438a7        	bltu	a8, a10, 40375b4a <esp_backtrace_get_next_frame+0x9a>
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
40375b35:	120c      	movi.n	a2, 1
40375b37:	000446        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b3a:	020c      	movi.n	a2, 0
40375b3c:	000306        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b3f:	120c00        	andbc	b0, b12, b0
40375b42:	000186        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b45:	120c      	movi.n	a2, 1
40375b47:	000046        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b4a:	020c      	movi.n	a2, 0
}
40375b4c:	f01d      	retw.n
	...

40375b50 <esp_backtrace_print_from_frame>:

esp_err_t IRAM_ATTR esp_backtrace_print_from_frame(int depth, const esp_backtrace_frame_t* frame, bool panic)
{
40375b50:	006136        	entry	a1, 48
40375b53:	20b330        	or	a11, a3, a3
40375b56:	744040        	extui	a4, a4, 0, 8
    //Check arguments
    if (depth <= 0) {
40375b59:	0212e6        	bgei	a2, 1, 40375b5f <esp_backtrace_print_from_frame+0xf>
40375b5c:	004e46        	j	40375c99 <esp_backtrace_print_from_frame+0x149>
        return ESP_ERR_INVALID_ARG;
    }

    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t stk_frame;
    memcpy(&stk_frame, frame, sizeof(esp_backtrace_frame_t));
40375b5f:	10a0c2        	movi	a12, 16
40375b62:	20a110        	or	a10, a1, a1
40375b65:	fa5b81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375b68:	0008e0        	callx8	a8

    print_str("\r\n\r\nBacktrace:", panic);
40375b6b:	04bd      	mov.n	a11, a4
40375b6d:	faa9a1        	l32r	a10, 40374614 <_iram_text_start+0x210> (3c020e7c <_flash_rodata_start+0xd5c>)
40375b70:	fff265        	call8	40375a98 <print_str>
    print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
40375b73:	01a8      	l32i.n	a10, a1, 0
    if (pc & 0x80000000) {
40375b75:	00bad6        	bgez	a10, 40375b84 <esp_backtrace_print_from_frame+0x34>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375b78:	11aae0        	slli	a10, a10, 2
40375b7b:	41a2a0        	srli	a10, a10, 2
40375b7e:	fa9d81        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375b81:	20aa80        	or	a10, a10, a8
40375b84:	04cd      	mov.n	a12, a4
40375b86:	11b8      	l32i.n	a11, a1, 4
40375b88:	fdcaa2        	addi	a10, a10, -3
40375b8b:	ffed25        	call8	40375a5c <print_entry>

    //Check if first frame is valid
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375b8e:	1188      	l32i.n	a8, a1, 4
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375b90:	fa9591        	l32r	a9, 403745e4 <_iram_text_start+0x1e0> (c0377ff0 <_rtc_reserved_end+0x60277ff0>)
40375b93:	989a      	add.n	a9, a8, a9
40375b95:	fa94a1        	l32r	a10, 403745e8 <_iram_text_start+0x1e4> (77fe0 <UserFrameTotalSize+0x77ee0>)
40375b98:	053a97        	bltu	a10, a9, 40375ba1 <esp_backtrace_print_from_frame+0x51>
40375b9b:	349080        	extui	a9, a8, 0, 4
40375b9e:	00a916        	beqz	a9, 40375bac <esp_backtrace_print_from_frame+0x5c>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40375ba1:	fa9291        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40375ba4:	889a      	add.n	a8, a8, a9
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375ba6:	fa9291        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375ba9:	623987        	bltu	a9, a8, 40375c0f <esp_backtrace_print_from_frame+0xbf>
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
40375bac:	01a8      	l32i.n	a10, a1, 0
    if (pc & 0x80000000) {
40375bae:	00bad6        	bgez	a10, 40375bbd <esp_backtrace_print_from_frame+0x6d>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375bb1:	11aae0        	slli	a10, a10, 2
40375bb4:	41a2a0        	srli	a10, a10, 2
40375bb7:	fa8f81        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375bba:	20aa80        	or	a10, a10, a8
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40375bbd:	fa8e91        	l32r	a9, 403745f8 <_iram_text_start+0x1f4> (bdfffffd <_rtc_reserved_end+0x5deffffd>)
40375bc0:	9a9a      	add.n	a9, a10, a9
40375bc2:	fa8e81        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
40375bc5:	628890        	lsi	f9, a8, 0x188
40375bc8:	880b      	addi.n	a8, a8, -1
40375bca:	608080        	neg	a8, a8
40375bcd:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40375bd0:	fa8cb1        	l32r	a11, 40374600 <_iram_text_start+0x1fc> (bfc8fffd <_rtc_reserved_end+0x5fb8fffd>)
40375bd3:	baba      	add.n	a11, a10, a11
40375bd5:	fa8b91        	l32r	a9, 40374604 <_iram_text_start+0x200> (6ffff <UserFrameTotalSize+0x6feff>)
40375bd8:	6299b0        	lsi	f11, a9, 0x188
40375bdb:	990b      	addi.n	a9, a9, -1
40375bdd:	609090        	neg	a9, a9
40375be0:	749090        	extui	a9, a9, 0, 8
40375be3:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375be6:	a8ec      	bnez.n	a8, 40375c14 <esp_backtrace_print_from_frame+0xc4>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40375be8:	fa8881        	l32r	a8, 40374608 <_iram_text_start+0x204> (bffffffd <_rtc_reserved_end+0x5feffffd>)
40375beb:	8a8a      	add.n	a8, a10, a8
40375bed:	fa8791        	l32r	a9, 4037460c <_iram_text_start+0x208> (5ffff <UserFrameTotalSize+0x5feff>)
40375bf0:	25b987        	bgeu	a9, a8, 40375c19 <esp_backtrace_print_from_frame+0xc9>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375bf3:	fa8781        	l32r	a8, 40374610 <_iram_text_start+0x20c> (9ff01ffd <_rtc_reserved_end+0x3fe01ffd>)
40375bf6:	aa8a      	add.n	a10, a10, a8
40375bf8:	fa7e81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375bfb:	1fb8a7        	bgeu	a8, a10, 40375c1e <esp_backtrace_print_from_frame+0xce>
                        /* Ignore the first corrupted PC in case of InstrFetchProhibited */
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375bfe:	3188      	l32i.n	a8, a1, 12
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
40375c00:	08ac      	beqz.n	a8, 40375c24 <esp_backtrace_print_from_frame+0xd4>
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375c02:	142892        	l32i	a9, a8, 80
40375c05:	481c      	movi.n	a8, 20
40375c07:	1e9987        	bne	a9, a8, 40375c29 <esp_backtrace_print_from_frame+0xd9>
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375c0a:	070c      	movi.n	a7, 0
40375c0c:	001246        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c0f:	170c      	movi.n	a7, 1
40375c11:	001106        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c14:	070c      	movi.n	a7, 0
40375c16:	000fc6        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c19:	070c      	movi.n	a7, 0
40375c1b:	000e86        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c1e:	070c      	movi.n	a7, 0
40375c20:	000d46        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c23:	170c00        	lsi	f0, a12, 92
40375c26:	000bc6        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c29:	170c      	movi.n	a7, 1

    uint32_t i = (depth <= 0) ? INT32_MAX : depth;
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375c2b:	000a86        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
        if (!esp_backtrace_get_next_frame(&stk_frame)) {    //Get previous stack frame
40375c2e:	20a110        	or	a10, a1, a1
40375c31:	ffe7e5        	call8	40375ab0 <esp_backtrace_get_next_frame>
40375c34:	002a56        	bnez	a10, 40375c3a <esp_backtrace_print_from_frame+0xea>
            corrupted = true;
40375c37:	01a072        	movi	a7, 1
        }
        print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
40375c3a:	0021a2        	l32i	a10, a1, 0
    if (pc & 0x80000000) {
40375c3d:	00bad6        	bgez	a10, 40375c4c <esp_backtrace_print_from_frame+0xfc>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375c40:	11aae0        	slli	a10, a10, 2
40375c43:	41a2a0        	srli	a10, a10, 2
40375c46:	fa6b81        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375c49:	20aa80        	or	a10, a10, a8
40375c4c:	20c440        	or	a12, a4, a4
40375c4f:	11b8      	l32i.n	a11, a1, 4
40375c51:	fdcaa2        	addi	a10, a10, -3
40375c54:	ffe065        	call8	40375a5c <print_entry>
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375c57:	062d      	mov.n	a2, a6
40375c59:	620b      	addi.n	a6, a2, -1
40375c5b:	528c      	beqz.n	a2, 40375c64 <esp_backtrace_print_from_frame+0x114>
40375c5d:	2188      	l32i.n	a8, a1, 8
40375c5f:	188c      	beqz.n	a8, 40375c64 <esp_backtrace_print_from_frame+0x114>
40375c61:	fc9716        	beqz	a7, 40375c2e <esp_backtrace_print_from_frame+0xde>
    }

    //Print backtrace termination marker
    esp_err_t ret = ESP_OK;
    if (corrupted) {
40375c64:	d78c      	beqz.n	a7, 40375c75 <esp_backtrace_print_from_frame+0x125>
        print_str(" |<-CORRUPTED", panic);
40375c66:	04bd      	mov.n	a11, a4
40375c68:	fa6ca1        	l32r	a10, 40374618 <_iram_text_start+0x214> (3c020e8c <_flash_rodata_start+0xd6c>)
40375c6b:	ffe2e5        	call8	40375a98 <print_str>
        ret =  ESP_FAIL;
40375c6e:	f27c      	movi.n	a2, -1
40375c70:	0005c6        	j	40375c8b <esp_backtrace_print_from_frame+0x13b>
40375c73:	820000        	mull	a0, a0, a0
    } else if (stk_frame.next_pc != 0) {    //Backtrace continues
40375c76:	160221        	l32r	a2, 4033b480 <rom_rx_gain_force+0x335054>
40375c79:	00d8      	l32i.n	a13, a0, 0
        print_str(" |<-CONTINUES", panic);
40375c7b:	20b440        	or	a11, a4, a4
40375c7e:	fa67a1        	l32r	a10, 4037461c <_iram_text_start+0x218> (3c020e9c <_flash_rodata_start+0xd7c>)
40375c81:	ffe165        	call8	40375a98 <print_str>
    esp_err_t ret = ESP_OK;
40375c84:	020c      	movi.n	a2, 0
40375c86:	000046        	j	40375c8b <esp_backtrace_print_from_frame+0x13b>
40375c89:	020c      	movi.n	a2, 0
    }
    print_str("\r\n\r\n", panic);
40375c8b:	04bd      	mov.n	a11, a4
40375c8d:	fa64a1        	l32r	a10, 40374620 <_iram_text_start+0x21c> (3c020eac <_flash_rodata_start+0xd8c>)
40375c90:	ffe065        	call8	40375a98 <print_str>
    return ret;
40375c93:	000146        	j	40375c9c <esp_backtrace_print_from_frame+0x14c>
40375c96:	000000        	ill
        return ESP_ERR_INVALID_ARG;
40375c99:	02a122        	movi	a2, 0x102
}
40375c9c:	f01d      	retw.n
	...

40375ca0 <esp_backtrace_print>:

esp_err_t IRAM_ATTR esp_backtrace_print(int depth)
{
40375ca0:	006136        	entry	a1, 48
    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t start = { 0 };
40375ca3:	10a0c2        	movi	a12, 16
40375ca6:	00a0b2        	movi	a11, 0
40375ca9:	20a110        	or	a10, a1, a1
40375cac:	f9f981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40375caf:	0008e0        	callx8	a8
    esp_backtrace_get_start(&(start.pc), &(start.sp), &(start.next_pc));
40375cb2:	c18b      	addi.n	a12, a1, 8
40375cb4:	b14b      	addi.n	a11, a1, 4
40375cb6:	01ad      	mov.n	a10, a1
40375cb8:	0000e5        	call8	40375cc8 <esp_backtrace_get_start>
    return esp_backtrace_print_from_frame(depth, &start, false);
40375cbb:	0c0c      	movi.n	a12, 0
40375cbd:	01bd      	mov.n	a11, a1
40375cbf:	02ad      	mov.n	a10, a2
40375cc1:	ffe8e5        	call8	40375b50 <esp_backtrace_print_from_frame>
}
40375cc4:	0a2d      	mov.n	a2, a10
40375cc6:	f01d      	retw.n

40375cc8 <esp_backtrace_get_start>:
    .section    .iram1, "ax"
    .align      4
    .global     esp_backtrace_get_start
    .type       esp_backtrace_get_start, @function
esp_backtrace_get_start:
    entry   a1, 32
40375cc8:	004136        	entry	a1, 32
    call8   xthal_window_spill  //Spill registers onto stack (excluding this function)
40375ccb:	0c0165        	call8	40381ce0 <xthal_window_spill>
    //a2, a3, a4 should be out arguments for i SP, i PC, i-1 PC respectively. Use a5 and a6 as scratch
    l32e    a5, sp, -16         //Get i PC, which is ret addres of i+1
40375cce:	09c150        	l32e	a5, a1, -16
    s32i    a5, a2, 0           //Store i PC to arg *pc
40375cd1:	006252        	s32i	a5, a2, 0
    l32e    a6, sp, -12         //Get i+1 SP. Used to access i BS
40375cd4:	09d160        	l32e	a6, a1, -12
    l32e    a5, a6, -12         //Get i SP
40375cd7:	09d650        	l32e	a5, a6, -12
    s32i    a5, a3, 0           //Store i SP to arg *sp
40375cda:	006352        	s32i	a5, a3, 0
    l32e    a5, a6, -16         //Get i-1 PC, which is ret address of i
40375cdd:	09c650        	l32e	a5, a6, -16
    s32i    a5, a4, 0           //Store i-1 PC to arg *next_pc
40375ce0:	006452        	s32i	a5, a4, 0
    retw
40375ce3:	f01d      	retw.n
40375ce5:	000000        	ill

40375ce8 <ipc_task>:
static volatile esp_ipc_func_t s_no_block_func[portNUM_PROCESSORS] = { 0 };
static volatile bool s_no_block_func_and_arg_are_ready[portNUM_PROCESSORS] = { 0 };
static void * volatile s_no_block_func_arg[portNUM_PROCESSORS];

static void IRAM_ATTR ipc_task(void* arg)
{
40375ce8:	004136        	entry	a1, 32
40375ceb:	027d      	mov.n	a7, a2
40375ced:	03eb80        	rsr.prid	a8
40375cf0:	048d80        	extui	a8, a8, 13, 1
    const int cpuid = (int) arg;

    assert(cpuid == xPortGetCoreID());
40375cf3:	0d1287        	beq	a2, a8, 40375d04 <ipc_task+0x1c>
40375cf6:	fa4bd1        	l32r	a13, 40374624 <_iram_text_start+0x220> (3c020f20 <_flash_rodata_start+0xe00>)
40375cf9:	fa4bc1        	l32r	a12, 40374628 <_iram_text_start+0x224> (3c0272a8 <__func__$0>)
40375cfc:	8b3c      	movi.n	a11, 56
40375cfe:	fa4ba1        	l32r	a10, 4037462c <_iram_text_start+0x228> (3c020f58 <_flash_rodata_start+0xe38>)
40375d01:	0a09e5        	call8	4037fda0 <__assert_func>
#ifdef CONFIG_ESP_IPC_ISR_ENABLE
    esp_ipc_isr_init();
40375d04:	fa5281        	l32r	a8, 4037464c <_iram_text_start+0x248> (42002374 <esp_ipc_isr_init>)
40375d07:	0008e0        	callx8	a8
#endif

    while (true) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
40375d0a:	fc7c      	movi.n	a12, -1
40375d0c:	1b0c      	movi.n	a11, 1
40375d0e:	00a0a2        	movi	a10, 0
40375d11:	063c65        	call8	4037c0d8 <ulTaskGenericNotifyTake>

        if (s_no_block_func_and_arg_are_ready[cpuid] && s_no_block_func[cpuid]) {
40375d14:	fa4781        	l32r	a8, 40374630 <_iram_text_start+0x22c> (3fc94a00 <s_no_block_func_and_arg_are_ready>)
40375d17:	887a      	add.n	a8, a8, a7
40375d19:	0020c0        	memw
40375d1c:	000882        	l8ui	a8, a8, 0
40375d1f:	748080        	extui	a8, a8, 0, 8
40375d22:	b8bc      	beqz.n	a8, 40375d61 <ipc_task+0x79>
40375d24:	fa4481        	l32r	a8, 40374634 <_iram_text_start+0x230> (3fc94a04 <s_no_block_func>)
40375d27:	a08780        	addx4	a8, a7, a8
40375d2a:	0020c0        	memw
40375d2d:	0888      	l32i.n	a8, a8, 0
40375d2f:	02e816        	beqz	a8, 40375d61 <ipc_task+0x79>
            (*s_no_block_func[cpuid])(s_no_block_func_arg[cpuid]);
40375d32:	fa4061        	l32r	a6, 40374634 <_iram_text_start+0x230> (3fc94a04 <s_no_block_func>)
40375d35:	a06760        	addx4	a6, a7, a6
40375d38:	0020c0        	memw
40375d3b:	0698      	l32i.n	a9, a6, 0
40375d3d:	fa3e81        	l32r	a8, 40374638 <_iram_text_start+0x234> (3fc949f8 <s_no_block_func_arg>)
40375d40:	a08780        	addx4	a8, a7, a8
40375d43:	0020c0        	memw
40375d46:	0028a2        	l32i	a10, a8, 0
40375d49:	0009e0        	callx8	a9
            s_no_block_func_and_arg_are_ready[cpuid] = false;
40375d4c:	fa3981        	l32r	a8, 40374630 <_iram_text_start+0x22c> (3fc94a00 <s_no_block_func_and_arg_are_ready>)
40375d4f:	887a      	add.n	a8, a8, a7
40375d51:	090c      	movi.n	a9, 0
40375d53:	0020c0        	memw
40375d56:	004892        	s8i	a9, a8, 0
            s_no_block_func[cpuid] = NULL;
40375d59:	080c      	movi.n	a8, 0
40375d5b:	0020c0        	memw
40375d5e:	006682        	s32i	a8, a6, 0
        }

#ifndef CONFIG_FREERTOS_UNICORE
        if (s_func[cpuid]) {
40375d61:	fa3681        	l32r	a8, 4037463c <_iram_text_start+0x238> (3fc94a1c <s_func>)
40375d64:	a08780        	addx4	a8, a7, a8
40375d67:	0020c0        	memw
40375d6a:	0888      	l32i.n	a8, a8, 0
40375d6c:	f9a816        	beqz	a8, 40375d0a <ipc_task+0x22>
            // we need to cache s_func, s_func_arg and ipc_ack variables locally
            // because they can be changed by a subsequent IPC call (after xTaskNotify(caller_task_handle)).
            esp_ipc_func_t func = s_func[cpuid];
40375d6f:	fa3381        	l32r	a8, 4037463c <_iram_text_start+0x238> (3fc94a1c <s_func>)
40375d72:	a08780        	addx4	a8, a7, a8
40375d75:	0020c0        	memw
40375d78:	0868      	l32i.n	a6, a8, 0
            void* func_arg = s_func_arg[cpuid];
40375d7a:	fa3191        	l32r	a9, 40374640 <_iram_text_start+0x23c> (3fc94a14 <s_func_arg>)
40375d7d:	a09790        	addx4	a9, a7, a9
40375d80:	0020c0        	memw
40375d83:	0958      	l32i.n	a5, a9, 0
            esp_ipc_wait_t ipc_wait = s_wait_for[cpuid];
40375d85:	fa2f91        	l32r	a9, 40374644 <_iram_text_start+0x240> (3fc94a0c <s_wait_for>)
40375d88:	a09790        	addx4	a9, a7, a9
40375d8b:	0020c0        	memw
40375d8e:	09a8      	l32i.n	a10, a9, 0
            SemaphoreHandle_t ipc_ack = s_ipc_ack[cpuid];
40375d90:	fa2e91        	l32r	a9, 40374648 <_iram_text_start+0x244> (3fc94a24 <s_ipc_ack>)
40375d93:	a09790        	addx4	a9, a7, a9
40375d96:	0948      	l32i.n	a4, a9, 0
            s_func[cpuid] = NULL;
40375d98:	090c      	movi.n	a9, 0
40375d9a:	0020c0        	memw
40375d9d:	0899      	s32i.n	a9, a8, 0

            if (ipc_wait == IPC_WAIT_FOR_START) {
40375d9f:	121a66        	bnei	a10, 1, 40375db5 <ipc_task+0xcd>
                xSemaphoreGive(ipc_ack);
40375da2:	09dd      	mov.n	a13, a9
40375da4:	09cd      	mov.n	a12, a9
40375da6:	09bd      	mov.n	a11, a9
40375da8:	04ad      	mov.n	a10, a4
40375daa:	03d2e5        	call8	40379ad8 <xQueueGenericSend>
                (*func)(func_arg);
40375dad:	05ad      	mov.n	a10, a5
40375daf:	0006e0        	callx8	a6
40375db2:	ffd506        	j	40375d0a <ipc_task+0x22>
            } else if (ipc_wait == IPC_WAIT_FOR_END) {
40375db5:	132a66        	bnei	a10, 2, 40375dcc <ipc_task+0xe4>
                (*func)(func_arg);
40375db8:	05ad      	mov.n	a10, a5
40375dba:	0006e0        	callx8	a6
                xSemaphoreGive(ipc_ack);
40375dbd:	0d0c      	movi.n	a13, 0
40375dbf:	0dcd      	mov.n	a12, a13
40375dc1:	0dbd      	mov.n	a11, a13
40375dc3:	04ad      	mov.n	a10, a4
40375dc5:	03d125        	call8	40379ad8 <xQueueGenericSend>
40375dc8:	ffcf86        	j	40375d0a <ipc_task+0x22>
40375dcb:	f16500        	lsi	f0, a5, 0x3c4
            } else {
                abort();
40375dce:	0009      	s32i.n	a0, a0, 0

40375dd0 <esp_vApplicationTickHook>:
static portMUX_TYPE hooks_spinlock = portMUX_INITIALIZER_UNLOCKED;
static esp_freertos_idle_cb_t idle_cb[CONFIG_FREERTOS_NUMBER_OF_CORES][MAX_HOOKS] = {0};
static esp_freertos_tick_cb_t tick_cb[CONFIG_FREERTOS_NUMBER_OF_CORES][MAX_HOOKS] = {0};

void IRAM_ATTR esp_vApplicationTickHook(void)
{
40375dd0:	004136        	entry	a1, 32
40375dd3:	03eb60        	rsr.prid	a6
40375dd6:	046d60        	extui	a6, a6, 13, 1
    int n;
    int core = xPortGetCoreID();
    for (n = 0; n < MAX_HOOKS; n++) {
40375dd9:	070c      	movi.n	a7, 0
40375ddb:	0004c6        	j	40375df2 <esp_vApplicationTickHook+0x22>
40375dde:	700000        	lsi	f0, a0, 0x1c0
        if (tick_cb[core][n] != NULL) {
40375de1:	91b086        	j	4035a4a7 <rom_rx_gain_force+0x35407b>
40375de4:	fa1b      	addi.n	a15, a10, 1
40375de6:	a08890        	addx4	a8, a8, a9
40375de9:	0888      	l32i.n	a8, a8, 0
40375deb:	188c      	beqz.n	a8, 40375df0 <esp_vApplicationTickHook+0x20>
            tick_cb[core][n]();
40375ded:	0008e0        	callx8	a8
    for (n = 0; n < MAX_HOOKS; n++) {
40375df0:	771b      	addi.n	a7, a7, 1
40375df2:	ea87a6        	blti	a7, 8, 40375de0 <esp_vApplicationTickHook+0x10>
        }
    }
}
40375df5:	f01d      	retw.n
	...

40375df8 <efuse_hal_chip_revision>:
    *((uint32_t*)&mac[0]) = efuse_ll_get_mac0();
    *((uint16_t*)&mac[4]) = (uint16_t) efuse_ll_get_mac1();
}

IRAM_ATTR uint32_t efuse_hal_chip_revision(void)
{
40375df8:	004136        	entry	a1, 32
    return efuse_hal_get_major_chip_version() * 100 + efuse_hal_get_minor_chip_version();
40375dfb:	000525        	call8	40375e4c <efuse_hal_get_major_chip_version>
40375dfe:	a0aaa0        	addx4	a10, a10, a10
40375e01:	a0aaa0        	addx4	a10, a10, a10
40375e04:	112ae0        	slli	a2, a10, 2
40375e07:	0008e5        	call8	40375e94 <efuse_hal_get_minor_chip_version>
}
40375e0a:	8022a0        	add	a2, a2, a10
40375e0d:	000090        	retw

40375e10 <efuse_hal_get_disable_wafer_version_major>:
{
    return efuse_ll_get_blk_version_major() * 100 + efuse_ll_get_blk_version_minor();
}

IRAM_ATTR bool efuse_hal_get_disable_wafer_version_major(void)
{
40375e10:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
}

__attribute__((always_inline)) static inline bool efuse_ll_get_disable_wafer_version_major(void)
{
    return EFUSE.rd_repeat_data4.disable_wafer_version_major;
40375e13:	fa1081        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e16:	0020c0        	memw
40375e19:	102822        	l32i	a2, a8, 64
    return efuse_ll_get_disable_wafer_version_major();
}
40375e1c:	042020        	extui	a2, a2, 0, 1
40375e1f:	f01d      	retw.n
40375e21:	000000        	ill

40375e24 <efuse_hal_flash_encryption_enabled>:
{
    return efuse_ll_get_disable_blk_version_major();
}

IRAM_ATTR bool efuse_hal_flash_encryption_enabled(void)
{
40375e24:	004136        	entry	a1, 32
    return EFUSE.rd_repeat_data1.spi_boot_crypt_cnt;
40375e27:	fa0b81        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e2a:	0020c0        	memw
40375e2d:	d888      	l32i.n	a8, a8, 52
40375e2f:	258280        	extui	a8, a8, 18, 3
    uint32_t flash_crypt_cnt = efuse_ll_get_flash_crypt_cnt();
    bool enabled = false;
40375e32:	020c      	movi.n	a2, 0
    while (flash_crypt_cnt) {
40375e34:	0003c6        	j	40375e47 <efuse_hal_flash_encryption_enabled+0x23>
40375e37:	070000        	lsi	f0, a0, 28
        if (flash_crypt_cnt & 1) {
40375e3a:	0768      	l32i.n	a6, a7, 0
            enabled = !enabled;
40375e3c:	190c      	movi.n	a9, 1
40375e3e:	302290        	xor	a2, a2, a9
40375e41:	742020        	extui	a2, a2, 0, 8
        }
        flash_crypt_cnt >>= 1;
40375e44:	418180        	srli	a8, a8, 1
    while (flash_crypt_cnt) {
40375e47:	fee856        	bnez	a8, 40375e39 <efuse_hal_flash_encryption_enabled+0x15>
    }
    return enabled;
}
40375e4a:	f01d      	retw.n

40375e4c <efuse_hal_get_major_chip_version>:
    return ((minor_raw & 0x7) == 0 &&
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
}

IRAM_ATTR uint32_t efuse_hal_get_major_chip_version(void)
{
40375e4c:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
40375e4f:	fa0181        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e52:	0020c0        	memw
40375e55:	162892        	l32i	a9, a8, 88
40375e58:	0020c0        	memw
40375e5b:	142882        	l32i	a8, a8, 80
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375e5e:	258280        	extui	a8, a8, 18, 3
40375e61:	c8dc      	bnez.n	a8, 40375e81 <efuse_hal_get_major_chip_version+0x35>
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_major(void)
{
    return EFUSE.rd_sys_part1_data4.blk_version_major;
40375e63:	f9fc81        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e66:	0020c0        	memw
40375e69:	1b2882        	l32i	a8, a8, 108
40375e6c:	148080        	extui	a8, a8, 0, 2
    return ((minor_raw & 0x7) == 0 &&
40375e6f:	0e1866        	bnei	a8, 1, 40375e81 <efuse_hal_get_major_chip_version+0x35>
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_minor(void)
{
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
40375e72:	f9f881        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e75:	0020c0        	memw
40375e78:	142882        	l32i	a8, a8, 80
40375e7b:	258880        	extui	a8, a8, 24, 3
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375e7e:	0e1826        	beqi	a8, 1, 40375e90 <efuse_hal_get_major_chip_version+0x44>
    return EFUSE.rd_mac_spi_sys_5.wafer_version_major;
40375e81:	f9f481        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e84:	0020c0        	memw
40375e87:	162822        	l32i	a2, a8, 88
40375e8a:	152820        	extui	a2, a2, 24, 2
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
        return 0;
    }
    return efuse_ll_get_chip_wafer_version_major();
40375e8d:	000046        	j	40375e92 <efuse_hal_get_major_chip_version+0x46>
        return 0;
40375e90:	020c      	movi.n	a2, 0
}
40375e92:	f01d      	retw.n

40375e94 <efuse_hal_get_minor_chip_version>:

IRAM_ATTR uint32_t efuse_hal_get_minor_chip_version(void)
{
40375e94:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
40375e97:	f9ef81        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e9a:	0020c0        	memw
40375e9d:	162822        	l32i	a2, a8, 88
40375ea0:	0020c0        	memw
40375ea3:	142882        	l32i	a8, a8, 80
40375ea6:	258280        	extui	a8, a8, 18, 3
40375ea9:	052720        	extui	a2, a2, 23, 1
40375eac:	b02280        	addx8	a2, a2, a8
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375eaf:	e8dc      	bnez.n	a8, 40375ed1 <efuse_hal_get_minor_chip_version+0x3d>
    return EFUSE.rd_sys_part1_data4.blk_version_major;
40375eb1:	f9e881        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375eb4:	0020c0        	memw
40375eb7:	1b2882        	l32i	a8, a8, 108
40375eba:	148080        	extui	a8, a8, 0, 2
    return ((minor_raw & 0x7) == 0 &&
40375ebd:	101866        	bnei	a8, 1, 40375ed1 <efuse_hal_get_minor_chip_version+0x3d>
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
40375ec0:	f9e581        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375ec3:	0020c0        	memw
40375ec6:	142882        	l32i	a8, a8, 80
40375ec9:	258880        	extui	a8, a8, 24, 3
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375ecc:	011866        	bnei	a8, 1, 40375ed1 <efuse_hal_get_minor_chip_version+0x3d>
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
        return 0;
40375ecf:	020c      	movi.n	a2, 0
    }
    return minor_raw;
}
40375ed1:	f01d      	retw.n
	...

40375ed4 <fmt_abort_str>:
        uint8_t b4 = (n >> (28 - i * 4)) & 0b1111;
        buf[i] = b4 <= 9 ? '0' + b4 : 'a' + b4 - 10;
    }
}
HEAP_IRAM_ATTR static void fmt_abort_str(char dest[48], size_t size, uint32_t caps)
{
40375ed4:	006136        	entry	a1, 48
40375ed7:	20b330        	or	a11, a3, a3
    char sSize[8];
    char sCaps[8];
    hex_to_str(sSize, size);
40375eda:	20a110        	or	a10, a1, a1
40375edd:	0223e5        	call8	4037811c <hex_to_str>
    hex_to_str(sCaps, caps);
40375ee0:	718b      	addi.n	a7, a1, 8
40375ee2:	04bd      	mov.n	a11, a4
40375ee4:	07ad      	mov.n	a10, a7
40375ee6:	022365        	call8	4037811c <hex_to_str>
    memcpy(dest, "Mem alloc fail. size 0x00000000 caps 0x00000000", 48);
40375ee9:	0c3c      	movi.n	a12, 48
40375eeb:	f9dbb1        	l32r	a11, 40374658 <_iram_text_start+0x254> (3c022858 <_flash_rodata_start+0x2738>)
40375eee:	02ad      	mov.n	a10, a2
40375ef0:	f97981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375ef3:	0008e0        	callx8	a8
    memcpy(dest + 23, sSize, 8);
40375ef6:	8c0c      	movi.n	a12, 8
40375ef8:	20b110        	or	a11, a1, a1
40375efb:	17c2a2        	addi	a10, a2, 23
40375efe:	f97581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375f01:	0008e0        	callx8	a8
    memcpy(dest + 39, sCaps, 8);
40375f04:	8c0c      	movi.n	a12, 8
40375f06:	07bd      	mov.n	a11, a7
40375f08:	27c2a2        	addi	a10, a2, 39
40375f0b:	f97281        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375f0e:	0008e0        	callx8	a8
}
40375f11:	f01d      	retw.n
	...

40375f14 <heap_caps_alloc_failed>:
#endif

HEAP_IRAM_ATTR NOINLINE_ATTR static void heap_caps_alloc_failed(size_t requested_size, uint32_t caps, const char *function_name)
{
40375f14:	00a136        	entry	a1, 80
40375f17:	04cd      	mov.n	a12, a4
    if (alloc_failed_callback) {
40375f19:	f9d081        	l32r	a8, 4037465c <_iram_text_start+0x258> (3fc94bd0 <alloc_failed_callback>)
40375f1c:	0888      	l32i.n	a8, a8, 0
40375f1e:	688c      	beqz.n	a8, 40375f28 <heap_caps_alloc_failed+0x14>
        alloc_failed_callback(requested_size, caps, function_name);
40375f20:	03bd      	mov.n	a11, a3
40375f22:	20a220        	or	a10, a2, a2
40375f25:	0008e0        	callx8	a8
    }

#ifdef CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS
    char buf[48];
    fmt_abort_str(buf, requested_size, caps);
40375f28:	20c330        	or	a12, a3, a3
40375f2b:	20b220        	or	a11, a2, a2
40375f2e:	01ad      	mov.n	a10, a1
40375f30:	fffa25        	call8	40375ed4 <fmt_abort_str>
    esp_system_abort(buf);
40375f33:	01ad      	mov.n	a10, a1
40375f35:	038565        	call8	4037978c <esp_system_abort>

40375f38 <heap_caps_malloc>:

/*
Routine to allocate a bit of memory with certain capabilities. caps is a bitfield of MALLOC_CAP_* bits.
*/
HEAP_IRAM_ATTR void *heap_caps_malloc( size_t size, uint32_t caps)
{
40375f38:	004136        	entry	a1, 32
40375f3b:	207220        	or	a7, a2, a2
    void* ptr = heap_caps_malloc_base(size, caps);
40375f3e:	20b330        	or	a11, a3, a3
40375f41:	20a220        	or	a10, a2, a2
40375f44:	003625        	call8	403762a8 <heap_caps_malloc_base>
40375f47:	0a2d      	mov.n	a2, a10


    if (!ptr && size > 0){
40375f49:	40fa80        	nsau	a8, a10
40375f4c:	418580        	srli	a8, a8, 5
40375f4f:	190c      	movi.n	a9, 1
40375f51:	839770        	moveqz	a9, a7, a7
40375f54:	090897        	bnone	a8, a9, 40375f61 <heap_caps_malloc+0x29>
        heap_caps_alloc_failed(size, caps, __func__);
40375f57:	f9c2c1        	l32r	a12, 40374660 <_iram_text_start+0x25c> (3c027a24 <__func__$12>)
40375f5a:	03bd      	mov.n	a11, a3
40375f5c:	07ad      	mov.n	a10, a7
40375f5e:	fffb65        	call8	40375f14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40375f61:	f01d      	retw.n
	...

40375f64 <heap_caps_malloc_default>:

/*
 Default memory allocation implementation. Should return standard 8-bit memory. malloc() essentially resolves to this function.
*/
HEAP_IRAM_ATTR void *heap_caps_malloc_default( size_t size )
{
40375f64:	004136        	entry	a1, 32
40375f67:	207220        	or	a7, a2, a2
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375f6a:	f9be81        	l32r	a8, 40374664 <_iram_text_start+0x260> (3fc92040 <malloc_alwaysinternal_limit>)
40375f6d:	002882        	l32i	a8, a8, 0
40375f70:	0d0866        	bnei	a8, -1, 40375f81 <heap_caps_malloc_default+0x1d>
        return heap_caps_malloc( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
40375f73:	f9bdb1        	l32r	a11, 40374668 <_iram_text_start+0x264> (1800 <UserFrameTotalSize+0x1700>)
40375f76:	20a220        	or	a10, a2, a2
40375f79:	fffbe5        	call8	40375f38 <heap_caps_malloc>
40375f7c:	0a2d      	mov.n	a2, a10
40375f7e:	0011c6        	j	40375fc9 <heap_caps_malloc_default+0x65>

        // use heap_caps_malloc_base() since we'll
        // check for allocation failure ourselves

        void *r;
        if (size <= (size_t)malloc_alwaysinternal_limit) {
40375f81:	0c3827        	bltu	a8, a2, 40375f91 <heap_caps_malloc_default+0x2d>
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40375f84:	f9b9b1        	l32r	a11, 40374668 <_iram_text_start+0x264> (1800 <UserFrameTotalSize+0x1700>)
40375f87:	02ad      	mov.n	a10, a2
40375f89:	0031e5        	call8	403762a8 <heap_caps_malloc_base>
40375f8c:	0a2d      	mov.n	a2, a10
40375f8e:	000246        	j	40375f9b <heap_caps_malloc_default+0x37>
        } else {
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM );
40375f91:	f9b6b1        	l32r	a11, 4037466c <_iram_text_start+0x268> (1400 <UserFrameTotalSize+0x1300>)
40375f94:	02ad      	mov.n	a10, a2
40375f96:	003125        	call8	403762a8 <heap_caps_malloc_base>
40375f99:	0a2d      	mov.n	a2, a10
        }
        if (r==NULL && size > 0) {
40375f9b:	40f280        	nsau	a8, a2
40375f9e:	418580        	srli	a8, a8, 5
40375fa1:	160c      	movi.n	a6, 1
40375fa3:	836770        	moveqz	a6, a7, a7
40375fa6:	0b0867        	bnone	a8, a6, 40375fb5 <heap_caps_malloc_default+0x51>
            //try again while being less picky
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT );
40375fa9:	f9b1b1        	l32r	a11, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
40375fac:	20a770        	or	a10, a7, a7
40375faf:	002fa5        	call8	403762a8 <heap_caps_malloc_base>
40375fb2:	202aa0        	or	a2, a10, a10
        }

        // allocation failure?
        if (r==NULL && size > 0){
40375fb5:	40f280        	nsau	a8, a2
40375fb8:	418580        	srli	a8, a8, 5
40375fbb:	0a0687        	bnone	a6, a8, 40375fc9 <heap_caps_malloc_default+0x65>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
40375fbe:	f9adc1        	l32r	a12, 40374674 <_iram_text_start+0x270> (3c027a08 <__func__$11>)
40375fc1:	f9abb1        	l32r	a11, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
40375fc4:	07ad      	mov.n	a10, a7
40375fc6:	fff4e5        	call8	40375f14 <heap_caps_alloc_failed>
        }

        return r;
    }
}
40375fc9:	f01d      	retw.n
	...

40375fcc <heap_caps_realloc>:
    va_end( argp );
    return r;
}

HEAP_IRAM_ATTR void *heap_caps_realloc( void *ptr, size_t size, uint32_t caps)
{
40375fcc:	004136        	entry	a1, 32
40375fcf:	20a220        	or	a10, a2, a2
    ptr = heap_caps_realloc_base(ptr, size, caps);
40375fd2:	20c440        	or	a12, a4, a4
40375fd5:	20b330        	or	a11, a3, a3
40375fd8:	002de5        	call8	403762b8 <heap_caps_realloc_base>
40375fdb:	0a2d      	mov.n	a2, a10


    if (ptr == NULL && size > 0){
40375fdd:	40fa80        	nsau	a8, a10
40375fe0:	418580        	srli	a8, a8, 5
40375fe3:	190c      	movi.n	a9, 1
40375fe5:	839330        	moveqz	a9, a3, a3
40375fe8:	090897        	bnone	a8, a9, 40375ff5 <heap_caps_realloc+0x29>
        heap_caps_alloc_failed(size, caps, __func__);
40375feb:	f9a3c1        	l32r	a12, 40374678 <_iram_text_start+0x274> (3c0279d8 <__func__$6>)
40375fee:	04bd      	mov.n	a11, a4
40375ff0:	03ad      	mov.n	a10, a3
40375ff2:	fff225        	call8	40375f14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40375ff5:	f01d      	retw.n
	...

40375ff8 <heap_caps_realloc_default>:
{
40375ff8:	004136        	entry	a1, 32
40375ffb:	207220        	or	a7, a2, a2
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375ffe:	f99981        	l32r	a8, 40374664 <_iram_text_start+0x260> (3fc92040 <malloc_alwaysinternal_limit>)
40376001:	002882        	l32i	a8, a8, 0
40376004:	100866        	bnei	a8, -1, 40376018 <heap_caps_realloc_default+0x20>
        return heap_caps_realloc( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40376007:	f998c1        	l32r	a12, 40374668 <_iram_text_start+0x264> (1800 <UserFrameTotalSize+0x1700>)
4037600a:	20b330        	or	a11, a3, a3
4037600d:	02ad      	mov.n	a10, a2
4037600f:	fffbe5        	call8	40375fcc <heap_caps_realloc>
40376012:	0a2d      	mov.n	a2, a10
40376014:	001446        	j	40376069 <heap_caps_realloc_default+0x71>
40376017:	383700        	lsi	f0, a7, 224
        if (size <= (size_t)malloc_alwaysinternal_limit) {
4037601a:	93c111        	l32r	a1, 4035af20 <rom_rx_gain_force+0x354af4>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
4037601d:	30f9      	s32i.n	a15, a0, 12
4037601f:	2020b3        	lsi	f11, a0, 128
40376022:	2520a2        	l32i	a10, a0, 148
40376025:	0029      	s32i.n	a2, a0, 0
40376027:	202aa0        	or	a2, a10, a10
4037602a:	0002c6        	j	40376039 <heap_caps_realloc_default+0x41>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM);
4037602d:	f98fc1        	l32r	a12, 4037466c <_iram_text_start+0x268> (1400 <UserFrameTotalSize+0x1300>)
40376030:	03bd      	mov.n	a11, a3
40376032:	02ad      	mov.n	a10, a2
40376034:	002825        	call8	403762b8 <heap_caps_realloc_base>
40376037:	0a2d      	mov.n	a2, a10
        if (r==NULL && size>0) {
40376039:	40f280        	nsau	a8, a2
4037603c:	418580        	srli	a8, a8, 5
4037603f:	160c      	movi.n	a6, 1
40376041:	836330        	moveqz	a6, a3, a3
40376044:	0d0867        	bnone	a8, a6, 40376055 <heap_caps_realloc_default+0x5d>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT);
40376047:	f98ac1        	l32r	a12, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037604a:	03bd      	mov.n	a11, a3
4037604c:	20a770        	or	a10, a7, a7
4037604f:	0026a5        	call8	403762b8 <heap_caps_realloc_base>
40376052:	202aa0        	or	a2, a10, a10
        if (r==NULL && size>0){
40376055:	40f280        	nsau	a8, a2
40376058:	418580        	srli	a8, a8, 5
4037605b:	0a0687        	bnone	a6, a8, 40376069 <heap_caps_realloc_default+0x71>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
4037605e:	f987c1        	l32r	a12, 4037467c <_iram_text_start+0x278> (3c0279ec <__func__$10>)
40376061:	f983b1        	l32r	a11, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
40376064:	03ad      	mov.n	a10, a3
40376066:	ffeae5        	call8	40375f14 <heap_caps_alloc_failed>
}
40376069:	f01d      	retw.n
	...

4037606c <heap_caps_calloc>:

HEAP_IRAM_ATTR void *heap_caps_calloc( size_t n, size_t size, uint32_t caps)
{
4037606c:	004136        	entry	a1, 32
4037606f:	207220        	or	a7, a2, a2
    void* ptr = heap_caps_calloc_base(n, size, caps);
40376072:	20c440        	or	a12, a4, a4
40376075:	03bd      	mov.n	a11, a3
40376077:	20a220        	or	a10, a2, a2
4037607a:	003965        	call8	40376410 <heap_caps_calloc_base>
4037607d:	0a2d      	mov.n	a2, a10


    if (!ptr && size > 0){
4037607f:	40fa80        	nsau	a8, a10
40376082:	418580        	srli	a8, a8, 5
40376085:	190c      	movi.n	a9, 1
40376087:	839330        	moveqz	a9, a3, a3
4037608a:	0a0897        	bnone	a8, a9, 40376098 <heap_caps_calloc+0x2c>
        heap_caps_alloc_failed(n * size, caps, __func__);
4037608d:	f97cc1        	l32r	a12, 40374680 <_iram_text_start+0x27c> (3c0279c4 <__func__$5>)
40376090:	04bd      	mov.n	a11, a4
40376092:	82a730        	mull	a10, a7, a3
40376095:	ffe7e5        	call8	40375f14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40376098:	f01d      	retw.n
	...

4037609c <dram_alloc_to_iram_addr>:
  This takes a memory chunk in a region that can be addressed as both DRAM as well as IRAM. It will convert it to
  IRAM in such a way that it can be later freed. It assumes both the address as well as the length to be word-aligned.
  It returns a region that's 1 word smaller than the region given because it stores the original Dram address there.
*/
HEAP_IRAM_ATTR static void *dram_alloc_to_iram_addr(void *addr, size_t len)
{
4037609c:	004136        	entry	a1, 32
    uintptr_t dstart = (uintptr_t)addr; //First word
4037609f:	20a220        	or	a10, a2, a2
    uintptr_t dend __attribute__((unused)) = dstart + len - 4; //Last word
403760a2:	803230        	add	a3, a2, a3
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
403760a5:	f97791        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
403760a8:	929a      	add.n	a9, a2, a9
403760aa:	f97781        	l32r	a8, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
403760ad:	628890        	lsi	f9, a8, 0x188
403760b0:	880b      	addi.n	a8, a8, -1
403760b2:	608080        	neg	a8, a8
403760b5:	748080        	extui	a8, a8, 0, 8
    assert(esp_ptr_in_diram_dram((void *)dstart) || esp_ptr_in_rtc_dram_fast((void *)dstart));
403760b8:	38ec      	bnez.n	a8, 403760df <dram_alloc_to_iram_addr+0x43>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403760ba:	f94c91        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403760bd:	929a      	add.n	a9, a2, a9
403760bf:	f94c81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403760c2:	628890        	lsi	f9, a8, 0x188
403760c5:	880b      	addi.n	a8, a8, -1
403760c7:	608080        	neg	a8, a8
403760ca:	748080        	extui	a8, a8, 0, 8
403760cd:	00e856        	bnez	a8, 403760df <dram_alloc_to_iram_addr+0x43>
403760d0:	f96fd1        	l32r	a13, 4037468c <_iram_text_start+0x288> (3c0232d4 <_flash_rodata_start+0x31b4>)
403760d3:	f96fc1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027d24 <__func__$1>)
403760d6:	29a0b2        	movi	a11, 41
403760d9:	f96ea1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
403760dc:	09cc25        	call8	4037fda0 <__assert_func>
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
403760df:	f96e91        	l32r	a9, 40374698 <_iram_text_start+0x294> (c0377ffc <_rtc_reserved_end+0x60277ffc>)
403760e2:	939a      	add.n	a9, a3, a9
403760e4:	f96981        	l32r	a8, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
403760e7:	628890        	lsi	f9, a8, 0x188
403760ea:	880b      	addi.n	a8, a8, -1
403760ec:	608080        	neg	a8, a8
403760ef:	748080        	extui	a8, a8, 0, 8
    assert(esp_ptr_in_diram_dram((void *)dend) || esp_ptr_in_rtc_dram_fast((void *)dend));
403760f2:	28ec      	bnez.n	a8, 40376118 <dram_alloc_to_iram_addr+0x7c>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403760f4:	f96a91        	l32r	a9, 4037469c <_iram_text_start+0x298> (9ff01ffc <_rtc_reserved_end+0x3fe01ffc>)
403760f7:	939a      	add.n	a9, a3, a9
403760f9:	f93d81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403760fc:	628890        	lsi	f9, a8, 0x188
403760ff:	880b      	addi.n	a8, a8, -1
40376101:	608080        	neg	a8, a8
40376104:	748080        	extui	a8, a8, 0, 8
40376107:	00d856        	bnez	a8, 40376118 <dram_alloc_to_iram_addr+0x7c>
4037610a:	f965d1        	l32r	a13, 403746a0 <_iram_text_start+0x29c> (3c023350 <_flash_rodata_start+0x3230>)
4037610d:	f960c1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027d24 <__func__$1>)
40376110:	ab2c      	movi.n	a11, 42
40376112:	f960a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
40376115:	09c8a5        	call8	4037fda0 <__assert_func>
    assert((dstart & 3) == 0);
40376118:	1480a0        	extui	a8, a10, 0, 2
4037611b:	00d816        	beqz	a8, 4037612c <dram_alloc_to_iram_addr+0x90>
4037611e:	f961d1        	l32r	a13, 403746a4 <_iram_text_start+0x2a0> (3c0233a0 <_flash_rodata_start+0x3280>)
40376121:	f95bc1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027d24 <__func__$1>)
40376124:	bb2c      	movi.n	a11, 43
40376126:	f95ba1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
40376129:	09c765        	call8	4037fda0 <__assert_func>
    assert((dend & 3) == 0);
4037612c:	143030        	extui	a3, a3, 0, 2
4037612f:	00d316        	beqz	a3, 40376140 <dram_alloc_to_iram_addr+0xa4>
40376132:	f95dd1        	l32r	a13, 403746a8 <_iram_text_start+0x2a4> (3c0233b4 <_flash_rodata_start+0x3294>)
40376135:	f956c1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027d24 <__func__$1>)
40376138:	cb2c      	movi.n	a11, 44
4037613a:	f956a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
4037613d:	09c625        	call8	4037fda0 <__assert_func>
40376140:	f92b81        	l32r	a8, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40376143:	8a8a      	add.n	a8, a10, a8
#if SOC_DIRAM_INVERTED // We want the word before the result to hold the DRAM address
    uint32_t *iptr = esp_ptr_diram_dram_to_iram((void *)dend);
#else
    uint32_t *iptr = NULL;
    if (esp_ptr_in_rtc_dram_fast((void *)dstart)) {
40376145:	f92a91        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40376148:	04b987        	bgeu	a9, a8, 40376150 <dram_alloc_to_iram_addr+0xb4>
    return (void *) ( SOC_DIRAM_IRAM_LOW + ((intptr_t)p - SOC_DIRAM_DRAM_LOW) );
4037614b:	f95881        	l32r	a8, 403746ac <_iram_text_start+0x2a8> (6f0000 <UserFrameTotalSize+0x6eff00>)
4037614e:	228a      	add.n	a2, a2, a8
        iptr = esp_ptr_rtc_dram_to_iram((void *)dstart);
    } else {
        iptr = esp_ptr_diram_dram_to_iram((void *)dstart);
    }
#endif
    *iptr = dstart;
40376150:	02a9      	s32i.n	a10, a2, 0
    return iptr + 1;
}
40376152:	224b      	addi.n	a2, a2, 4
40376154:	f01d      	retw.n
	...

40376158 <aligned_or_unaligned_alloc>:
    multi_heap_free(heap->heap, block_owner_ptr);

    CALL_HOOK(esp_heap_trace_free_hook, ptr);
}

HEAP_IRAM_ATTR static inline void *aligned_or_unaligned_alloc(multi_heap_handle_t heap, size_t size, size_t alignment, size_t offset) {
40376158:	004136        	entry	a1, 32
4037615b:	20a220        	or	a10, a2, a2
4037615e:	20b330        	or	a11, a3, a3
40376161:	20c440        	or	a12, a4, a4
40376164:	05dd      	mov.n	a13, a5
    if (alignment<=UNALIGNED_MEM_ALIGNMENT_BYTES) { //alloc and friends align to 32-bit by default
40376166:	0754f6        	bgeui	a4, 5, 40376171 <aligned_or_unaligned_alloc+0x19>
        return multi_heap_malloc(heap, size);
40376169:	085e25        	call8	4037e74c <multi_heap_malloc>
4037616c:	0a2d      	mov.n	a2, a10
4037616e:	000106        	j	40376176 <aligned_or_unaligned_alloc+0x1e>
    } else {
        return multi_heap_aligned_alloc_offs(heap, size, alignment, offset);
40376171:	0852a5        	call8	4037e69c <multi_heap_aligned_alloc_offs>
40376174:	0a2d      	mov.n	a2, a10
    }
}
40376176:	f01d      	retw.n

40376178 <heap_caps_free>:
{
40376178:	004136        	entry	a1, 32
4037617b:	02bd      	mov.n	a11, a2
    if (ptr == NULL) {
4037617d:	044216        	beqz	a2, 403761c5 <heap_caps_free+0x4d>
    return ((intptr_t)p >= SOC_DIRAM_IRAM_LOW && (intptr_t)p < SOC_DIRAM_IRAM_HIGH);
40376180:	f94c81        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
40376183:	828a      	add.n	a8, a2, a8
    if (esp_ptr_in_diram_iram(ptr) || esp_ptr_in_rtc_iram_fast(ptr)) {
40376185:	f94091        	l32r	a9, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
40376188:	043987        	bltu	a9, a8, 40376190 <heap_caps_free+0x18>
        ptr = (void *)dramAddrPtr[-1];
4037618b:	fcc2b2        	addi	a11, a2, -4
4037618e:	0bb8      	l32i.n	a11, a11, 0
   (This confirms if ptr is inside the heap's region, doesn't confirm if 'ptr'
   is an allocated block or is some other random address inside the heap.)
*/
FORCE_INLINE_ATTR heap_t *find_containing_heap(void *ptr )
{
    intptr_t p = (intptr_t)ptr;
40376190:	0bad      	mov.n	a10, a11
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376192:	f94881        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94bd4 <registered_heaps>)
40376195:	0888      	l32i.n	a8, a8, 0
40376197:	000406        	j	403761ab <heap_caps_free+0x33>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
4037619a:	7898      	l32i.n	a9, a8, 28
4037619c:	898c      	beqz.n	a9, 403761a8 <heap_caps_free+0x30>
4037619e:	3898      	l32i.n	a9, a8, 12
403761a0:	042a97        	blt	a10, a9, 403761a8 <heap_caps_free+0x30>
403761a3:	4898      	l32i.n	a9, a8, 16
403761a5:	052a97        	blt	a10, a9, 403761ae <heap_caps_free+0x36>
    SLIST_FOREACH(heap, &registered_heaps, next) {
403761a8:	082882        	l32i	a8, a8, 32
403761ab:	feb856        	bnez	a8, 4037619a <heap_caps_free+0x22>
    assert(heap != NULL && "free() target pointer is outside heap areas");
403761ae:	00e856        	bnez	a8, 403761c0 <heap_caps_free+0x48>
403761b1:	f941d1        	l32r	a13, 403746b8 <_iram_text_start+0x2b4> (3c0233c4 <_flash_rodata_start+0x32a4>)
403761b4:	f942c1        	l32r	a12, 403746bc <_iram_text_start+0x2b8> (3c027d3c <__func__$2>)
403761b7:	4aa0b2        	movi	a11, 74
403761ba:	f936a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
403761bd:	09be25        	call8	4037fda0 <__assert_func>
    multi_heap_free(heap->heap, block_owner_ptr);
403761c0:	78a8      	l32i.n	a10, a8, 28
403761c2:	084f25        	call8	4037e6b4 <multi_heap_aligned_free>
}
403761c5:	f01d      	retw.n
	...

403761c8 <heap_caps_aligned_alloc_base>:
This function should not be called directly as it does not check for failure / call heap_caps_alloc_failed()
Note that this function does 'unaligned' alloc calls if alignment <= UNALIGNED_MEM_ALIGNMENT_BYTES (=4) as the
allocator will align to that value by default.
*/
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_aligned_alloc_base(size_t alignment, size_t size, uint32_t caps)
{
403761c8:	006136        	entry	a1, 48
403761cb:	006122        	s32i	a2, a1, 0
403761ce:	016132        	s32i	a3, a1, 4
403761d1:	026142        	s32i	a4, a1, 8
    void *ret = NULL;

    // Alignment, size and caps may need to be modified because of hardware requirements.
    esp_heap_adjust_alignment_to_hw(&alignment, &size, &caps);
403761d4:	c18b      	addi.n	a12, a1, 8
403761d6:	b14b      	addi.n	a11, a1, 4
403761d8:	01ad      	mov.n	a10, a1
403761da:	0164e5        	call8	40377828 <esp_heap_adjust_alignment_to_hw>

    // remove block owner size to HEAP_SIZE_MAX rather than adding the block owner size
    // to size to prevent overflows.
    if (size == 0 || size > MULTI_HEAP_REMOVE_BLOCK_OWNER_SIZE(HEAP_SIZE_MAX) ) {
403761dd:	1188      	l32i.n	a8, a1, 4
403761df:	980b      	addi.n	a9, a8, -1
403761e1:	f906a1        	l32r	a10, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
403761e4:	02ba97        	bgeu	a10, a9, 403761ea <heap_caps_aligned_alloc_base+0x22>
403761e7:	002c86        	j	4037629d <heap_caps_aligned_alloc_base+0xd5>
        // Avoids int overflow when adding small numbers to size, or
        // calculating 'end' from start+size, by limiting 'size' to the possible range
        return NULL;
    }

    if (caps & MALLOC_CAP_EXEC) {
403761ea:	2198      	l32i.n	a9, a1, 8
403761ec:	0c6907        	bbci	a9, 0, 403761fc <heap_caps_aligned_alloc_base+0x34>
        //MALLOC_CAP_EXEC forces an alloc from IRAM. There is a region which has both this as well as the following
        //caps, but the following caps are not possible for IRAM.  Thus, the combination is impossible and we return
        //NULL directly, even although our heap capabilities (based on soc_memory_tags & soc_memory_regions) would
        //indicate there is a tag for this.
        if ((caps & MALLOC_CAP_8BIT) || (caps & MALLOC_CAP_DMA)) {
403761ef:	14a290        	extui	a10, a9, 2, 2
403761f2:	0aca56        	bnez	a10, 403762a2 <heap_caps_aligned_alloc_base+0xda>
            return NULL;
        }
        caps |= MALLOC_CAP_32BIT; // IRAM is 32-bit accessible RAM
403761f5:	2a0c      	movi.n	a10, 2
403761f7:	2099a0        	or	a9, a9, a10
403761fa:	2199      	s32i.n	a9, a1, 8
    }

    if (caps & MALLOC_CAP_32BIT) {
403761fc:	2198      	l32i.n	a9, a1, 8
403761fe:	02e917        	bbsi	a9, 1, 40376204 <heap_caps_aligned_alloc_base+0x3c>
40376201:	0022c6        	j	40376290 <heap_caps_aligned_alloc_base+0xc8>
        /* 32-bit accessible RAM should allocated in 4 byte aligned sizes
         * (Future versions of ESP-IDF should possibly fail if an invalid size is requested)
         */
        size = (size + 3) & (~3); // int overflow checked above
40376204:	883b      	addi.n	a8, a8, 3
40376206:	c97c      	movi.n	a9, -4
40376208:	108890        	and	a8, a8, a9
4037620b:	1189      	s32i.n	a8, a1, 4
4037620d:	001fc6        	j	40376290 <heap_caps_aligned_alloc_base+0xc8>
    }

    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
        //Iterate over heaps and check capabilities at this priority
        heap_t *heap;
        SLIST_FOREACH(heap, &registered_heaps, next) {
40376210:	f92981        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94bd4 <registered_heaps>)
40376213:	0878      	l32i.n	a7, a8, 0
40376215:	001bc6        	j	40376288 <heap_caps_aligned_alloc_base+0xc0>
            if (heap->heap == NULL) {
40376218:	77a8      	l32i.n	a10, a7, 28
4037621a:	068a16        	beqz	a10, 40376286 <heap_caps_aligned_alloc_base+0xbe>
                continue;
            }
            if ((heap->caps[prio] & caps) != 0) {
4037621d:	a08670        	addx4	a8, a6, a7
40376220:	0888      	l32i.n	a8, a8, 0
40376222:	2198      	l32i.n	a9, a1, 8
40376224:	5e0897        	bnone	a8, a9, 40376286 <heap_caps_aligned_alloc_base+0xbe>
40376227:	000386        	j	40376239 <heap_caps_aligned_alloc_base+0x71>
4037622a:	700000        	lsi	f0, a0, 0x1c0
        all_caps |= heap->caps[prio];
4037622d:	a0c8      	l32i.n	a12, a0, 40
4037622f:	0cc8      	l32i.n	a12, a12, 0
40376231:	20bbc0        	or	a11, a11, a12
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
40376234:	881b      	addi.n	a8, a8, 1
40376236:	0000c6        	j	4037623d <heap_caps_aligned_alloc_base+0x75>
40376239:	080c      	movi.n	a8, 0
    uint32_t all_caps = 0;
4037623b:	08bd      	mov.n	a11, a8
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037623d:	eb38a6        	blti	a8, 3, 4037622c <heap_caps_aligned_alloc_base+0x64>
                //Heap has at least one of the caps requested. If caps has other bits set that this prio
                //doesn't cover, see if they're available in other prios.
                if ((get_all_caps(heap) & caps) == caps) {
40376240:	42cb97        	bnall	a11, a9, 40376286 <heap_caps_aligned_alloc_base+0xbe>
                    //This heap can satisfy all the requested capabilities. See if we can grab some memory using it.
                    // If MALLOC_CAP_EXEC is requested but the DRAM and IRAM are on the same addresses (like on esp32c6)
                    // proceed as for a default allocation.
                    if (((caps & MALLOC_CAP_EXEC) && !esp_dram_match_iram()) &&
40376243:	316907        	bbci	a9, 0, 40376278 <heap_caps_aligned_alloc_base+0xb0>
                        (esp_ptr_in_diram_dram((void *)heap->start) || esp_ptr_in_rtc_dram_fast((void *)heap->start))) {
40376246:	3788      	l32i.n	a8, a7, 12
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
40376248:	f90f91        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
4037624b:	989a      	add.n	a9, a8, a9
                    if (((caps & MALLOC_CAP_EXEC) && !esp_dram_match_iram()) &&
4037624d:	f90eb1        	l32r	a11, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
40376250:	0abb97        	bgeu	a11, a9, 4037625e <heap_caps_aligned_alloc_base+0x96>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40376253:	f8e691        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40376256:	889a      	add.n	a8, a8, a9
                        (esp_ptr_in_diram_dram((void *)heap->start) || esp_ptr_in_rtc_dram_fast((void *)heap->start))) {
40376258:	f8e691        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
4037625b:	193987        	bltu	a9, a8, 40376278 <heap_caps_aligned_alloc_base+0xb0>
                        //This is special, insofar that what we're going to get back is a DRAM address. If so,
                        //we need to 'invert' it (lowest address in DRAM == highest address in IRAM and vice-versa) and
                        //add a pointer to the DRAM equivalent before the address we're going to return.
                        ret = aligned_or_unaligned_alloc(heap->heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size) + 4,
4037625e:	00a0d2        	movi	a13, 0
40376261:	0021c2        	l32i	a12, a1, 0
40376264:	11b8      	l32i.n	a11, a1, 4
40376266:	bb4b      	addi.n	a11, a11, 4
40376268:	ffeee5        	call8	40376158 <aligned_or_unaligned_alloc>
                                                        alignment, MULTI_HEAP_BLOCK_OWNER_SIZE());  // int overflow checked above
                        if (ret != NULL) {
4037626b:	7a9c      	beqz.n	a10, 40376286 <heap_caps_aligned_alloc_base+0xbe>
                            MULTI_HEAP_SET_BLOCK_OWNER(ret);
                            ret = MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ret);
                            uint32_t *iptr = dram_alloc_to_iram_addr(ret, size + 4);  // int overflow checked above
4037626d:	11b8      	l32i.n	a11, a1, 4
4037626f:	bb4b      	addi.n	a11, a11, 4
40376271:	ffe2a5        	call8	4037609c <dram_alloc_to_iram_addr>
                            CALL_HOOK(esp_heap_trace_alloc_hook, iptr, size, caps);
                            return iptr;
40376274:	000b06        	j	403762a4 <heap_caps_aligned_alloc_base+0xdc>
40376277:	a0d200        	addx4	a13, a2, a0
                        }
                    } else {
                        //Just try to alloc, nothing special.
                        ret = aligned_or_unaligned_alloc(heap->heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size),
4037627a:	21c200        	srai	a12, a0, 2
4037627d:	21b200        	srai	a11, a0, 2
40376280:	ed6501        	l32r	a0, 40371814 <rom_rx_gain_force+0x36b3e8>
40376283:	ff          	.byte	0xff
                                                        alignment, MULTI_HEAP_BLOCK_OWNER_SIZE());
                        if (ret != NULL) {
40376284:	cadc      	bnez.n	a10, 403762a4 <heap_caps_aligned_alloc_base+0xdc>
        SLIST_FOREACH(heap, &registered_heaps, next) {
40376286:	8778      	l32i.n	a7, a7, 32
40376288:	f8c756        	bnez	a7, 40376218 <heap_caps_aligned_alloc_base+0x50>
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037628b:	661b      	addi.n	a6, a6, 1
4037628d:	000046        	j	40376292 <heap_caps_aligned_alloc_base+0xca>
    uint32_t all_caps = 0;
40376290:	060c      	movi.n	a6, 0
40376292:	0236e6        	bgei	a6, 3, 40376298 <heap_caps_aligned_alloc_base+0xd0>
40376295:	ffddc6        	j	40376210 <heap_caps_aligned_alloc_base+0x48>
            }
        }
    }

    //Nothing usable found.
    return NULL;
40376298:	0a0c      	movi.n	a10, 0
4037629a:	000186        	j	403762a4 <heap_caps_aligned_alloc_base+0xdc>
        return NULL;
4037629d:	0a0c      	movi.n	a10, 0
4037629f:	000046        	j	403762a4 <heap_caps_aligned_alloc_base+0xdc>
            return NULL;
403762a2:	0a0c      	movi.n	a10, 0
}
403762a4:	0a2d      	mov.n	a2, a10
403762a6:	f01d      	retw.n

403762a8 <heap_caps_malloc_base>:

//Wrapper for heap_caps_aligned_alloc_base as that can also do unaligned allocs.
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_malloc_base( size_t size, uint32_t caps) {
403762a8:	004136        	entry	a1, 32
403762ab:	02bd      	mov.n	a11, a2
403762ad:	03cd      	mov.n	a12, a3
    return heap_caps_aligned_alloc_base(UNALIGNED_MEM_ALIGNMENT_BYTES, size, caps);
403762af:	4a0c      	movi.n	a10, 4
403762b1:	fff165        	call8	403761c8 <heap_caps_aligned_alloc_base>
}
403762b4:	0a2d      	mov.n	a2, a10
403762b6:	f01d      	retw.n

403762b8 <heap_caps_realloc_base>:
/*
This function should not be called directly as it does not
check for failure / call heap_caps_alloc_failed()
*/
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_realloc_base( void *ptr, size_t size, uint32_t caps)
{
403762b8:	008136        	entry	a1, 64
403762bb:	206220        	or	a6, a2, a2
403762be:	046132        	s32i	a3, a1, 16
403762c1:	5149      	s32i.n	a4, a1, 20
    bool ptr_in_diram_case = false;
    heap_t *heap = NULL;
    void *dram_ptr = NULL;

    //See if memory needs alignment because of hardware reasons.
    size_t alignment = UNALIGNED_MEM_ALIGNMENT_BYTES;
403762c3:	480c      	movi.n	a8, 4
403762c5:	006182        	s32i	a8, a1, 0
    esp_heap_adjust_alignment_to_hw(&alignment, &size, &caps);
403762c8:	14c1c2        	addi	a12, a1, 20
403762cb:	10c1b2        	addi	a11, a1, 16
403762ce:	01ad      	mov.n	a10, a1
403762d0:	015565        	call8	40377828 <esp_heap_adjust_alignment_to_hw>

    if (ptr == NULL) {
403762d3:	d2cc      	bnez.n	a2, 403762e4 <heap_caps_realloc_base+0x2c>
        return heap_caps_aligned_alloc_base(alignment, size, caps);
403762d5:	51c8      	l32i.n	a12, a1, 20
403762d7:	41b8      	l32i.n	a11, a1, 16
403762d9:	01a8      	l32i.n	a10, a1, 0
403762db:	ffeee5        	call8	403761c8 <heap_caps_aligned_alloc_base>
403762de:	0a2d      	mov.n	a2, a10
403762e0:	004a86        	j	4037640e <heap_caps_realloc_base+0x156>
403762e3:	21c200        	srai	a12, a0, 2
    }

    if (size == 0) {
403762e6:	ac5604        	lsi	f0, a6, 0x2b0
403762e9:	a22000        	muluh	a2, a0, a0
        heap_caps_free(ptr);
403762ec:	e8a520        	lsi	f2, a5, 0x3a0
403762ef:	ff          	.byte	0xff
        return NULL;
403762f0:	020c      	movi.n	a2, 0
403762f2:	004606        	j	4037640e <heap_caps_realloc_base+0x156>
    }

    // remove block owner size to HEAP_SIZE_MAX rather than adding the block owner size
    // to size to prevent overflows.
    if (size > MULTI_HEAP_REMOVE_BLOCK_OWNER_SIZE(HEAP_SIZE_MAX)) {
403762f5:	f8f281        	l32r	a8, 403746c0 <_iram_text_start+0x2bc> (2000000 <UserFrameTotalSize+0x1ffff00>)
403762f8:	02b8c7        	bgeu	a8, a12, 403762fe <heap_caps_realloc_base+0x46>
403762fb:	004346        	j	4037640c <heap_caps_realloc_base+0x154>
    return ((intptr_t)p >= SOC_DIRAM_IRAM_LOW && (intptr_t)p < SOC_DIRAM_IRAM_HIGH);
403762fe:	f8ec81        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
40376301:	828a      	add.n	a8, a2, a8
        return NULL;
    }

    //The pointer to memory may be aliased, we need to
    //recover the corresponding address before to manage a new allocation:
    if(esp_ptr_in_diram_iram((void *)ptr)) {
40376303:	f8e191        	l32r	a9, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
40376306:	343987        	bltu	a9, a8, 4037633e <heap_caps_realloc_base+0x86>
        uint32_t *dram_addr = (uint32_t *)ptr;
        dram_ptr  = (void *)dram_addr[-1];
40376309:	fcc282        	addi	a8, a2, -4
4037630c:	0848      	l32i.n	a4, a8, 0
    intptr_t p = (intptr_t)ptr;
4037630e:	049d      	mov.n	a9, a4
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376310:	f8e981        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94bd4 <registered_heaps>)
40376313:	0878      	l32i.n	a7, a8, 0
40376315:	000406        	j	40376329 <heap_caps_realloc_base+0x71>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
40376318:	7788      	l32i.n	a8, a7, 28
4037631a:	888c      	beqz.n	a8, 40376326 <heap_caps_realloc_base+0x6e>
4037631c:	3788      	l32i.n	a8, a7, 12
4037631e:	042987        	blt	a9, a8, 40376326 <heap_caps_realloc_base+0x6e>
40376321:	4788      	l32i.n	a8, a7, 16
40376323:	052987        	blt	a9, a8, 4037632c <heap_caps_realloc_base+0x74>
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376326:	082772        	l32i	a7, a7, 32
40376329:	feb756        	bnez	a7, 40376318 <heap_caps_realloc_base+0x60>
        dram_ptr = MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(dram_ptr);

        heap = find_containing_heap(dram_ptr);
        assert(heap != NULL && "realloc() pointer is outside heap areas");
4037632c:	040756        	bnez	a7, 40376370 <heap_caps_realloc_base+0xb8>
4037632f:	f8e5d1        	l32r	a13, 403746c4 <_iram_text_start+0x2c0> (3c023404 <_flash_rodata_start+0x32e4>)
40376332:	f8e5c1        	l32r	a12, 403746c8 <_iram_text_start+0x2c4> (3c027d0c <__func__$0>)
40376335:	d8a0b2        	movi	a11, 216
40376338:	f8d7a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
4037633b:	09a665        	call8	4037fda0 <__assert_func>
    intptr_t p = (intptr_t)ptr;
4037633e:	209220        	or	a9, a2, a2
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376341:	f8dc81        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94bd4 <registered_heaps>)
40376344:	002872        	l32i	a7, a8, 0
40376347:	000406        	j	4037635b <heap_caps_realloc_base+0xa3>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
4037634a:	7788      	l32i.n	a8, a7, 28
4037634c:	888c      	beqz.n	a8, 40376358 <heap_caps_realloc_base+0xa0>
4037634e:	3788      	l32i.n	a8, a7, 12
40376350:	042987        	blt	a9, a8, 40376358 <heap_caps_realloc_base+0xa0>
40376353:	4788      	l32i.n	a8, a7, 16
40376355:	052987        	blt	a9, a8, 4037635e <heap_caps_realloc_base+0xa6>
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376358:	082772        	l32i	a7, a7, 32
4037635b:	feb756        	bnez	a7, 4037634a <heap_caps_realloc_base+0x92>
        //instead force a malloc/copy/free
        ptr_in_diram_case = true;

    } else {
        heap = find_containing_heap(ptr);
        assert(heap != NULL && "realloc() pointer is outside heap areas");
4037635e:	014756        	bnez	a7, 40376376 <heap_caps_realloc_base+0xbe>
40376361:	f8d8d1        	l32r	a13, 403746c4 <_iram_text_start+0x2c0> (3c023404 <_flash_rodata_start+0x32e4>)
40376364:	f8d9c1        	l32r	a12, 403746c8 <_iram_text_start+0x2c4> (3c027d0c <__func__$0>)
40376367:	e1a0b2        	movi	a11, 225
4037636a:	f8caa1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
4037636d:	09a325        	call8	4037fda0 <__assert_func>
        ptr_in_diram_case = true;
40376370:	01a052        	movi	a5, 1
40376373:	0000c6        	j	4037637a <heap_caps_realloc_base+0xc2>
    void *dram_ptr = NULL;
40376376:	040c      	movi.n	a4, 0
    bool ptr_in_diram_case = false;
40376378:	045d      	mov.n	a5, a4
    if (heap->heap == NULL) {
4037637a:	77a8      	l32i.n	a10, a7, 28
4037637c:	5a9c      	beqz.n	a10, 40376395 <heap_caps_realloc_base+0xdd>
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037637e:	090c      	movi.n	a9, 0
    uint32_t all_caps = 0;
40376380:	098d      	mov.n	a8, a9
40376382:	000246        	j	4037638f <heap_caps_realloc_base+0xd7>
        all_caps |= heap->caps[prio];
40376385:	a0b970        	addx4	a11, a9, a7
40376388:	0bb8      	l32i.n	a11, a11, 0
4037638a:	2088b0        	or	a8, a8, a11
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037638d:	991b      	addi.n	a9, a9, 1
4037638f:	f239a6        	blti	a9, 3, 40376385 <heap_caps_realloc_base+0xcd>
40376392:	000046        	j	40376397 <heap_caps_realloc_base+0xdf>
        return 0;
40376395:	080c      	movi.n	a8, 0
    // processing the realloc.
    ptr = MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(ptr);

    // are the existing heap's capabilities compatible with the
    // requested ones?
    bool compatible_caps = (caps & get_all_caps(heap)) == caps;
40376397:	5198      	l32i.n	a9, a1, 20
40376399:	108890        	and	a8, a8, a9
4037639c:	308890        	xor	a8, a8, a9
4037639f:	40f880        	nsau	a8, a8
403763a2:	418580        	srli	a8, a8, 5

    //Note we don't try realloc() on memory that needs to be aligned, that is handled
    //by the fallthrough code.
    if (compatible_caps && !ptr_in_diram_case && alignment<=UNALIGNED_MEM_ALIGNMENT_BYTES) {
403763a5:	190c      	movi.n	a9, 1
403763a7:	309590        	xor	a9, a5, a9
403763aa:	0e0987        	bnone	a9, a8, 403763bc <heap_caps_realloc_base+0x104>
403763ad:	0188      	l32i.n	a8, a1, 0
403763af:	0958f6        	bgeui	a8, 5, 403763bc <heap_caps_realloc_base+0x104>
        // try to reallocate this memory within the same heap
        // (which will resize the block if it can)
        void *r = multi_heap_realloc(heap->heap, ptr, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size));
403763b2:	06bd      	mov.n	a11, a6
403763b4:	083e65        	call8	4037e79c <multi_heap_realloc>
403763b7:	0a2d      	mov.n	a2, a10
        if (r != NULL) {
403763b9:	051a56        	bnez	a10, 4037640e <heap_caps_realloc_base+0x156>
        }
    }

    // if we couldn't do that, try to see if we can reallocate
    // in a different heap with requested capabilities.
    void *new_p = heap_caps_aligned_alloc_base(alignment, size, caps);
403763bc:	51c8      	l32i.n	a12, a1, 20
403763be:	41b8      	l32i.n	a11, a1, 16
403763c0:	01a8      	l32i.n	a10, a1, 0
403763c2:	ffe065        	call8	403761c8 <heap_caps_aligned_alloc_base>
403763c5:	0a2d      	mov.n	a2, a10
    if (new_p != NULL) {
403763c7:	043a16        	beqz	a10, 4037640e <heap_caps_realloc_base+0x156>
        size_t old_size = 0;

        //If we're dealing with aliased ptr, information regarding its containing
        //heap can only be obtained with translated address.
        if(ptr_in_diram_case) {
403763ca:	a58c      	beqz.n	a5, 403763d8 <heap_caps_realloc_base+0x120>
            old_size = multi_heap_get_allocated_size(heap->heap, dram_ptr);
403763cc:	04bd      	mov.n	a11, a4
403763ce:	0727a2        	l32i	a10, a7, 28
403763d1:	0832a5        	call8	4037e6fc <multi_heap_get_allocated_size>
403763d4:	000246        	j	403763e1 <heap_caps_realloc_base+0x129>
403763d7:	b66000        	lsi	f0, a0, 0x2d8
        } else {
            old_size = multi_heap_get_allocated_size(heap->heap, ptr);
403763da:	27a220        	lsi	f2, a2, 156
403763dd:	31e507        	bbsi	a5, 0, 40376412 <heap_caps_calloc_base+0x2>
403763e0:	cc08      	l32i.n	a0, a12, 48
        }

        assert(old_size > 0);
403763e2:	d1da      	add.n	a13, a1, a13
403763e4:	f8ba      	add.n	a15, a8, a11
403763e6:	f8b8c1        	l32r	a12, 403746c8 <_iram_text_start+0x2c4> (3c027d0c <__func__$0>)
403763e9:	0aa1b2        	movi	a11, 0x10a
403763ec:	f8aaa1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
403763ef:	099b25        	call8	4037fda0 <__assert_func>
        // do not copy the block owner bytes
        memcpy(new_p, MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ptr), MIN(size, old_size));
403763f2:	0421c2        	l32i	a12, a1, 16
403763f5:	63cac0        	minu	a12, a10, a12
403763f8:	20b660        	or	a11, a6, a6
403763fb:	20a220        	or	a10, a2, a2
403763fe:	f83581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40376401:	0008e0        	callx8	a8
        // add the block owner bytes to ptr since they are removed in heap_caps_free
        heap_caps_free(MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ptr));
40376404:	06ad      	mov.n	a10, a6
40376406:	ffd725        	call8	40376178 <heap_caps_free>
        return new_p;
40376409:	000046        	j	4037640e <heap_caps_realloc_base+0x156>
        return NULL;
4037640c:	020c      	movi.n	a2, 0
    }

    return NULL;
}
4037640e:	f01d      	retw.n

40376410 <heap_caps_calloc_base>:
/*
This function should not be called directly as it does not
check for failure / call heap_caps_alloc_failed()
*/
HEAP_IRAM_ATTR void *heap_caps_calloc_base( size_t n, size_t size, uint32_t caps)
{
40376410:	004136        	entry	a1, 32
40376413:	04bd      	mov.n	a11, a4
    void *result;
    size_t size_bytes;

    if (__builtin_mul_overflow(n, size, &size_bytes)) {
40376415:	080c      	movi.n	a8, 0
40376417:	827230        	mull	a7, a2, a3
4037641a:	a22230        	muluh	a2, a2, a3
4037641d:	028c      	beqz.n	a2, 40376421 <heap_caps_calloc_base+0x11>
4037641f:	180c      	movi.n	a8, 1
40376421:	017856        	bnez	a8, 4037643c <heap_caps_calloc_base+0x2c>
        return NULL;
    }

    result = heap_caps_malloc_base(size_bytes, caps);
40376424:	20a770        	or	a10, a7, a7
40376427:	ffe825        	call8	403762a8 <heap_caps_malloc_base>
4037642a:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
4037642c:	ea8c      	beqz.n	a10, 4037643e <heap_caps_calloc_base+0x2e>
        memset(result, 0, size_bytes);
4037642e:	07cd      	mov.n	a12, a7
40376430:	0b0c      	movi.n	a11, 0
40376432:	f81781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40376435:	0008e0        	callx8	a8
40376438:	000086        	j	4037643e <heap_caps_calloc_base+0x2e>
4037643b:	020c00        	andb	b0, b12, b0
    }
    return result;
}
4037643e:	f01d      	retw.n

40376440 <esp_clk_cpu_freq>:
    return g_ticks_per_us_pro;
#endif
}

int IRAM_ATTR esp_clk_cpu_freq(void)
{
40376440:	004136        	entry	a1, 32
    return esp_rom_get_cpu_ticks_per_us();
40376443:	f8a481        	l32r	a8, 403746d4 <_iram_text_start+0x2d0> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
40376446:	0008e0        	callx8	a8
    return s_get_cpu_freq_mhz() * MHZ;
}
40376449:	f8a181        	l32r	a8, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
4037644c:	822a80        	mull	a2, a10, a8
4037644f:	f01d      	retw.n
40376451:	000000        	ill

40376454 <shared_intr_isr>:
    return best;
}

//Common shared isr handler. Chain-call all ISRs.
static void IRAM_ATTR shared_intr_isr(void *arg)
{
40376454:	004136        	entry	a1, 32
    vector_desc_t *vd = (vector_desc_t*)arg;
    shared_vector_desc_t *sh_vec = vd->shared_vec_info;
40376457:	1278      	l32i.n	a7, a2, 4
40376459:	fb7c      	movi.n	a11, -1
4037645b:	f89fa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
4037645e:	03cd25        	call8	4037a130 <xPortEnterCriticalTimeout>
}
40376461:	000746        	j	40376482 <shared_intr_isr+0x2e>
    portENTER_CRITICAL_ISR(&spinlock);
    while(sh_vec) {
        if (!sh_vec->disabled) {
40376464:	001782        	l16ui	a8, a7, 0
40376467:	15e807        	bbsi	a8, 0, 40376480 <shared_intr_isr+0x2c>
            if ((sh_vec->statusreg == NULL) || (*sh_vec->statusreg & sh_vec->statusmask)) {
4037646a:	1788      	l32i.n	a8, a7, 4
4037646c:	988c      	beqz.n	a8, 40376479 <shared_intr_isr+0x25>
4037646e:	0020c0        	memw
40376471:	0898      	l32i.n	a9, a8, 0
40376473:	022782        	l32i	a8, a7, 8
40376476:	060987        	bnone	a9, a8, 40376480 <shared_intr_isr+0x2c>
                traceISR_ENTER(sh_vec->source + ETS_INTERNAL_INTR_SOURCE_OFF);
                sh_vec->isr(sh_vec->arg);
40376479:	3788      	l32i.n	a8, a7, 12
4037647b:	47a8      	l32i.n	a10, a7, 16
4037647d:	0008e0        	callx8	a8
                if (!os_task_switch_is_pended(esp_cpu_get_core_id())) {
                    traceISR_EXIT();
                }
            }
        }
        sh_vec = sh_vec->next;
40376480:	5778      	l32i.n	a7, a7, 20
    while(sh_vec) {
40376482:	fde756        	bnez	a7, 40376464 <shared_intr_isr+0x10>
    }
    portEXIT_CRITICAL_ISR(&spinlock);
40376485:	f894a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
40376488:	03df65        	call8	4037a280 <vPortExitCritical>
}
4037648b:	f01d      	retw.n
4037648d:	000000        	ill

40376490 <esp_intr_noniram_disable>:
    portEXIT_CRITICAL_SAFE(&spinlock);
    return ESP_OK;
}

void IRAM_ATTR esp_intr_noniram_disable(void)
{
40376490:	004136        	entry	a1, 32
}

static inline BaseType_t __attribute__((always_inline)) xPortEnterCriticalTimeoutSafe(portMUX_TYPE *mux, BaseType_t timeout)
{
    BaseType_t ret;
    if (xPortInIsrContext()) {
40376493:	03c7a5        	call8	4037a10c <xPortInIsrContext>
40376496:	00ba16        	beqz	a10, 403764a5 <esp_intr_noniram_disable+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376499:	ffafb2        	movi	a11, -1
4037649c:	f88fa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
4037649f:	03c925        	call8	4037a130 <xPortEnterCriticalTimeout>
403764a2:	000206        	j	403764ae <esp_intr_noniram_disable+0x1e>
    } else {
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403764a5:	ffafb2        	movi	a11, -1
403764a8:	f88ca1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
403764ab:	03c865        	call8	4037a130 <xPortEnterCriticalTimeout>
403764ae:	03eb70        	rsr.prid	a7
403764b1:	047d70        	extui	a7, a7, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t oldint;
    uint32_t cpu = esp_cpu_get_core_id();
    uint32_t non_iram_ints = non_iram_int_mask[cpu];
403764b4:	f88a81        	l32r	a8, 403746dc <_iram_text_start+0x2d8> (3fc94be4 <non_iram_int_mask>)
403764b7:	a08780        	addx4	a8, a7, a8
403764ba:	002862        	l32i	a6, a8, 0
    if (non_iram_int_disabled_flag[cpu]) {
403764bd:	f88881        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94bd8 <non_iram_int_disabled_flag>)
403764c0:	808870        	add	a8, a8, a7
403764c3:	000882        	l8ui	a8, a8, 0
403764c6:	002816        	beqz	a8, 403764cc <esp_intr_noniram_disable+0x3c>
        abort();
403764c9:	0981a5        	call8	4037fce4 <abort>
    }
    non_iram_int_disabled_flag[cpu] = true;
403764cc:	f88581        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94bd8 <non_iram_int_disabled_flag>)
403764cf:	887a      	add.n	a8, a8, a7
403764d1:	190c      	movi.n	a9, 1
403764d3:	004892        	s8i	a9, a8, 0
// ------------------ Interrupt Control --------------------

FORCE_INLINE_ATTR uint32_t xt_utils_intr_get_enabled_mask(void)
{
    uint32_t intr_mask;
    RSR(INTENABLE, intr_mask);
403764d6:	03e450        	rsr.intenable	a5
403764d9:	06ad      	mov.n	a10, a6
403764db:	0ba365        	call8	40381f10 <xt_ints_off>
    oldint = esp_cpu_intr_get_enabled_mask();
    esp_cpu_intr_disable(non_iram_ints);
    // Disable the RTC bit which don't want to be put in IRAM.
    rtc_isr_noniram_disable(cpu);
403764de:	07ad      	mov.n	a10, a7
403764e0:	0024e5        	call8	40376730 <rtc_isr_noniram_disable>
    // Save disabled ints
    non_iram_int_disabled[cpu] = oldint & non_iram_ints;
403764e3:	106650        	and	a6, a6, a5
403764e6:	f87f81        	l32r	a8, 403746e4 <_iram_text_start+0x2e0> (3fc94bdc <non_iram_int_disabled>)
403764e9:	a07780        	addx4	a7, a7, a8
403764ec:	0769      	s32i.n	a6, a7, 0
    xPortEnterCriticalTimeoutSafe(mux, portMUX_NO_TIMEOUT);
}

static inline void __attribute__((always_inline)) vPortExitCriticalSafe(portMUX_TYPE *mux)
{
    if (xPortInIsrContext()) {
403764ee:	03c1e5        	call8	4037a10c <xPortInIsrContext>
403764f1:	7a8c      	beqz.n	a10, 403764fc <esp_intr_noniram_disable+0x6c>
        portEXIT_CRITICAL_ISR(mux);
403764f3:	f879a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
403764f6:	03d8a5        	call8	4037a280 <vPortExitCritical>
403764f9:	000146        	j	40376502 <esp_intr_noniram_disable+0x72>
    } else {
        portEXIT_CRITICAL(mux);
403764fc:	f877a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
403764ff:	03d825        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
40376502:	f01d      	retw.n

40376504 <esp_intr_noniram_enable>:

void IRAM_ATTR esp_intr_noniram_enable(void)
{
40376504:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40376507:	03c065        	call8	4037a10c <xPortInIsrContext>
4037650a:	00ba16        	beqz	a10, 40376519 <esp_intr_noniram_enable+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037650d:	fb7c      	movi.n	a11, -1
4037650f:	f872a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
40376512:	03c1e5        	call8	4037a130 <xPortEnterCriticalTimeout>
40376515:	000246        	j	40376522 <esp_intr_noniram_enable+0x1e>
40376518:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037651b:	ff          	.byte	0xff
4037651c:	f86fa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
4037651f:	03c125        	call8	4037a130 <xPortEnterCriticalTimeout>
    asm volatile (
40376522:	03eb70        	rsr.prid	a7
40376525:	047d70        	extui	a7, a7, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t cpu = esp_cpu_get_core_id();
    int non_iram_ints = non_iram_int_disabled[cpu];
40376528:	f86f81        	l32r	a8, 403746e4 <_iram_text_start+0x2e0> (3fc94bdc <non_iram_int_disabled>)
4037652b:	a08780        	addx4	a8, a7, a8
4037652e:	0028a2        	l32i	a10, a8, 0
    if (!non_iram_int_disabled_flag[cpu]) {
40376531:	f86b81        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94bd8 <non_iram_int_disabled_flag>)
40376534:	808870        	add	a8, a8, a7
40376537:	000882        	l8ui	a8, a8, 0
4037653a:	002856        	bnez	a8, 40376540 <esp_intr_noniram_enable+0x3c>
        abort();
4037653d:	097a65        	call8	4037fce4 <abort>
    }
    non_iram_int_disabled_flag[cpu] = false;
40376540:	f86881        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94bd8 <non_iram_int_disabled_flag>)
40376543:	887a      	add.n	a8, a8, a7
40376545:	090c      	movi.n	a9, 0
40376547:	004892        	s8i	a9, a8, 0
    xt_ints_on(intr_mask);
4037654a:	0b9ae5        	call8	40381ef8 <xt_ints_on>
    esp_cpu_intr_enable(non_iram_ints);
    rtc_isr_noniram_enable(cpu);
4037654d:	07ad      	mov.n	a10, a7
4037654f:	002165        	call8	40376764 <rtc_isr_noniram_enable>
    if (xPortInIsrContext()) {
40376552:	03bba5        	call8	4037a10c <xPortInIsrContext>
40376555:	7a8c      	beqz.n	a10, 40376560 <esp_intr_noniram_enable+0x5c>
        portEXIT_CRITICAL_ISR(mux);
40376557:	f860a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
4037655a:	03d265        	call8	4037a280 <vPortExitCritical>
4037655d:	000146        	j	40376566 <esp_intr_noniram_enable+0x62>
        portEXIT_CRITICAL(mux);
40376560:	f85ea1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
40376563:	03d1e5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
40376566:	f01d      	retw.n

40376568 <esp_intr_enable_source>:
void IRAM_ATTR ets_isr_mask(uint32_t mask) {
    esp_cpu_intr_disable(mask);
}

void IRAM_ATTR esp_intr_enable_source(int inum)
{
40376568:	004136        	entry	a1, 32
4037656b:	1a0c      	movi.n	a10, 1
4037656d:	401200        	ssl	a2
40376570:	a1aa00        	sll	a10, a10
40376573:	0b9865        	call8	40381ef8 <xt_ints_on>
    esp_cpu_intr_enable(1 << inum);
}
40376576:	f01d      	retw.n

40376578 <esp_intr_disable_source>:

void IRAM_ATTR esp_intr_disable_source(int inum)
{
40376578:	004136        	entry	a1, 32
    xt_ints_off(intr_mask);
4037657b:	1a0c      	movi.n	a10, 1
4037657d:	401200        	ssl	a2
40376580:	a1aa00        	sll	a10, a10
40376583:	0b98e5        	call8	40381f10 <xt_ints_off>
    esp_cpu_intr_disable(1 << inum);
}
40376586:	f01d      	retw.n

40376588 <esp_intr_disable>:
{
40376588:	004136        	entry	a1, 32
    if (handle == NULL) {
4037658b:	0ea216        	beqz	a2, 40376679 <esp_intr_disable+0xf1>
    if (xPortInIsrContext()) {
4037658e:	03b7e5        	call8	4037a10c <xPortInIsrContext>
40376591:	00ca16        	beqz	a10, 403765a1 <esp_intr_disable+0x19>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376594:	ffafb2        	movi	a11, -1
40376597:	f850a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
4037659a:	03b965        	call8	4037a130 <xPortEnterCriticalTimeout>
4037659d:	000246        	j	403765aa <esp_intr_disable+0x22>
403765a0:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403765a3:	ff          	.byte	0xff
403765a4:	f84da1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
403765a7:	03b8a5        	call8	4037a130 <xPortEnterCriticalTimeout>
    if (handle->shared_vector_desc) {
403765aa:	012282        	l32i	a8, a2, 4
403765ad:	047816        	beqz	a8, 403765f8 <esp_intr_disable+0x70>
        handle->shared_vector_desc->disabled = 1;
403765b0:	001892        	l16ui	a9, a8, 0
403765b3:	1a0c      	movi.n	a10, 1
403765b5:	2099a0        	or	a9, a9, a10
403765b8:	005892        	s16i	a9, a8, 0
        source=handle->shared_vector_desc->source;
403765bb:	1288      	l32i.n	a8, a2, 4
403765bd:	08c8      	l32i.n	a12, a8, 0
403765bf:	74c1c0        	extui	a12, a12, 1, 8
403765c2:	23bc00        	sext	a11, a12, 7
        shared_vector_desc_t *svd = handle->vector_desc->shared_vec_info;
403765c5:	0288      	l32i.n	a8, a2, 0
403765c7:	1898      	l32i.n	a9, a8, 4
        assert(svd != NULL);
403765c9:	39ec      	bnez.n	a9, 403765f0 <esp_intr_disable+0x68>
403765cb:	f847d1        	l32r	a13, 403746e8 <_iram_text_start+0x2e4> (3c0234a4 <_flash_rodata_start+0x3384>)
403765ce:	f847c1        	l32r	a12, 403746ec <_iram_text_start+0x2e8> (3c027d6c <__func__$0>)
403765d1:	62a3b2        	movi	a11, 0x362
403765d4:	f847a1        	l32r	a10, 403746f0 <_iram_text_start+0x2ec> (3c0234d0 <_flash_rodata_start+0x33b0>)
403765d7:	097ca5        	call8	4037fda0 <__assert_func>
            if (svd->source == source && !svd->disabled) {
403765da:	0988      	l32i.n	a8, a9, 0
403765dc:	748180        	extui	a8, a8, 1, 8
403765df:	23ac00        	sext	a10, a12, 7
403765e2:	238800        	sext	a8, a8, 7
403765e5:	059a87        	bne	a10, a8, 403765ee <esp_intr_disable+0x66>
403765e8:	001982        	l16ui	a8, a9, 0
403765eb:	1a6807        	bbci	a8, 0, 40376609 <esp_intr_disable+0x81>
            svd = svd->next;
403765ee:	5998      	l32i.n	a9, a9, 20
        while(svd) {
403765f0:	fe6956        	bnez	a9, 403765da <esp_intr_disable+0x52>
    bool disabled = true;
403765f3:	180c      	movi.n	a8, 1
403765f5:	000486        	j	4037660b <esp_intr_disable+0x83>
        source=handle->vector_desc->source;
403765f8:	0288      	l32i.n	a8, a2, 0
403765fa:	08b8      	l32i.n	a11, a8, 0
403765fc:	75b6b0        	extui	a11, a11, 22, 8
403765ff:	23bb00        	sext	a11, a11, 7
    bool disabled = true;
40376602:	180c      	movi.n	a8, 1
40376604:	0000c6        	j	4037660b <esp_intr_disable+0x83>
40376607:	0c0000        	lsi	f0, a0, 48
                disabled = false;
4037660a:	9608      	l32i.n	a0, a6, 36
    if (source >= 0) {
4037660c:	015b      	addi.n	a0, a1, 5
        if (disabled) {
4037660e:	048816        	beqz	a8, 4037665a <esp_intr_disable+0xd2>
            esp_rom_route_intr_matrix(handle->vector_desc->cpu, source, INT_MUX_DISABLED_INTNO);
40376611:	0288      	l32i.n	a8, a2, 0
40376613:	08a8      	l32i.n	a10, a8, 0
40376615:	6c0c      	movi.n	a12, 6
40376617:	05a0a0        	extui	a10, a10, 16, 1
4037661a:	f83681        	l32r	a8, 403746f4 <_iram_text_start+0x2f0> (40001b54 <esp_rom_route_intr_matrix>)
4037661d:	0008e0        	callx8	a8
40376620:	000d86        	j	4037665a <esp_intr_disable+0xd2>
40376623:	229200        	orb	b9, b2, b0
        if (handle->vector_desc->cpu != esp_cpu_get_core_id()) {
40376626:	298200        	lsi	f0, a2, 164
40376629:	808000        	add	a8, a0, a0
4037662c:	eba005        	call0	40362030 <rom_rx_gain_force+0x35bc04>
4037662f:	ada003        	lsi	f0, a0, 0x2b4
40376632:	18a704        	lsi	f0, a7, 96
40376635:	651a      	add.n	a6, a5, a1
    if (xPortInIsrContext()) {
40376637:	03ad      	mov.n	a10, a3
40376639:	7a8c      	beqz.n	a10, 40376644 <esp_intr_disable+0xbc>
        portEXIT_CRITICAL_ISR(mux);
4037663b:	f827a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
4037663e:	03c425        	call8	4037a280 <vPortExitCritical>
40376641:	000146        	j	4037664a <esp_intr_disable+0xc2>
        portEXIT_CRITICAL(mux);
40376644:	f825a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
40376647:	03c3a5        	call8	4037a280 <vPortExitCritical>
            return ESP_ERR_INVALID_ARG; //Can only enable these ints on this cpu
4037664a:	02a122        	movi	a2, 0x102
4037664d:	000ac6        	j	4037667c <esp_intr_disable+0xf4>
40376650:	29a200        	lsi	f0, a2, 164
        ESP_INTR_DISABLE(handle->vector_desc->intno);
40376653:	a1a000        	sll	a10, a0
40376656:	f22545        	call0	403688ac <rom_rx_gain_force+0x362480>
40376659:	ff          	.byte	0xff
    if (xPortInIsrContext()) {
4037665a:	03ab25        	call8	4037a10c <xPortInIsrContext>
4037665d:	0a2d      	mov.n	a2, a10
4037665f:	00aa16        	beqz	a10, 4037666d <esp_intr_disable+0xe5>
        portEXIT_CRITICAL_ISR(mux);
40376662:	f81da1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
40376665:	03c1a5        	call8	4037a280 <vPortExitCritical>
    return ESP_OK;
40376668:	020c      	movi.n	a2, 0
4037666a:	000386        	j	4037667c <esp_intr_disable+0xf4>
        portEXIT_CRITICAL(mux);
4037666d:	f81aa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc92050 <spinlock>)
40376670:	03c0e5        	call8	4037a280 <vPortExitCritical>
40376673:	000146        	j	4037667c <esp_intr_disable+0xf4>
40376676:	000000        	ill
        return ESP_ERR_INVALID_ARG;
40376679:	02a122        	movi	a2, 0x102
}
4037667c:	f01d      	retw.n
	...

40376680 <periph_rcc_enter>:
static portMUX_TYPE periph_spinlock = portMUX_INITIALIZER_UNLOCKED;

static uint8_t ref_counts[PERIPH_MODULE_MAX] = {0};

IRAM_ATTR void periph_rcc_enter(void)
{
40376680:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40376683:	03a8a5        	call8	4037a10c <xPortInIsrContext>
40376686:	00ba16        	beqz	a10, 40376695 <periph_rcc_enter+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376689:	ffafb2        	movi	a11, -1
4037668c:	f81ba1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc92058 <periph_spinlock>)
4037668f:	03aa25        	call8	4037a130 <xPortEnterCriticalTimeout>
40376692:	0001c6        	j	4037669d <periph_rcc_enter+0x1d>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
40376695:	fb7c      	movi.n	a11, -1
40376697:	f818a1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc92058 <periph_spinlock>)
4037669a:	03a965        	call8	4037a130 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL_SAFE(&periph_spinlock);
}
4037669d:	f01d      	retw.n
	...

403766a0 <periph_rcc_exit>:

IRAM_ATTR void periph_rcc_exit(void)
{
403766a0:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403766a3:	03a6a5        	call8	4037a10c <xPortInIsrContext>
403766a6:	aa8c      	beqz.n	a10, 403766b4 <periph_rcc_exit+0x14>
        portEXIT_CRITICAL_ISR(mux);
403766a8:	f814a1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc92058 <periph_spinlock>)
403766ab:	03bd65        	call8	4037a280 <vPortExitCritical>
403766ae:	000206        	j	403766ba <periph_rcc_exit+0x1a>
403766b1:	000000        	ill
        portEXIT_CRITICAL(mux);
403766b4:	f811a1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc92058 <periph_spinlock>)
403766b7:	03bca5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
}
403766ba:	f01d      	retw.n

403766bc <periph_rcc_acquire_enter>:

IRAM_ATTR uint8_t periph_rcc_acquire_enter(periph_module_t periph)
{
403766bc:	004136        	entry	a1, 32
    periph_rcc_enter();
403766bf:	fffc25        	call8	40376680 <periph_rcc_enter>
    return ref_counts[periph];
403766c2:	f80e81        	l32r	a8, 403746fc <_iram_text_start+0x2f8> (3fc94bf0 <ref_counts>)
403766c5:	282a      	add.n	a2, a8, a2
}
403766c7:	000222        	l8ui	a2, a2, 0
403766ca:	f01d      	retw.n

403766cc <periph_rcc_acquire_exit>:

IRAM_ATTR void periph_rcc_acquire_exit(periph_module_t periph, uint8_t ref_count)
{
403766cc:	004136        	entry	a1, 32
403766cf:	743030        	extui	a3, a3, 0, 8
    ref_counts[periph] = ++ref_count;
403766d2:	f80a81        	l32r	a8, 403746fc <_iram_text_start+0x2f8> (3fc94bf0 <ref_counts>)
403766d5:	808820        	add	a8, a8, a2
403766d8:	01c332        	addi	a3, a3, 1
403766db:	004832        	s8i	a3, a8, 0
    periph_rcc_exit();
403766de:	fffc25        	call8	403766a0 <periph_rcc_exit>
}
403766e1:	000090        	retw

403766e4 <rtc_isr>:
        SLIST_HEAD_INITIALIZER(s_rtc_isr_handler_list);
static DRAM_ATTR portMUX_TYPE s_rtc_isr_handler_list_lock = portMUX_INITIALIZER_UNLOCKED;
static intr_handle_t s_rtc_isr_handle;

IRAM_ATTR static void rtc_isr(void* arg)
{
403766e4:	004136        	entry	a1, 32
    uint32_t status = REG_READ(RTC_CNTL_INT_ST_REG);
403766e7:	f80681        	l32r	a8, 40374700 <_iram_text_start+0x2fc> (60008048 <RTCCNTL+0x48>)
403766ea:	0020c0        	memw
403766ed:	0868      	l32i.n	a6, a8, 0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403766ef:	ffafb2        	movi	a11, -1
403766f2:	f804a1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc92a40 <s_rtc_isr_handler_list_lock>)
403766f5:	03a3a5        	call8	4037a130 <xPortEnterCriticalTimeout>
    rtc_isr_handler_t* it;
    portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
403766f8:	f80481        	l32r	a8, 40374708 <_iram_text_start+0x304> (3fc92a48 <s_rtc_isr_handler_list>)
403766fb:	0878      	l32i.n	a7, a8, 0
403766fd:	000706        	j	4037671d <rtc_isr+0x39>
        if (it->mask & status) {
40376700:	002782        	l32i	a8, a7, 0
40376703:	140867        	bnone	a8, a6, 4037671b <rtc_isr+0x37>
            portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
40376706:	f7ffa1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc92a40 <s_rtc_isr_handler_list_lock>)
40376709:	03b765        	call8	4037a280 <vPortExitCritical>
            (*it->handler)(it->handler_arg);
4037670c:	1788      	l32i.n	a8, a7, 4
4037670e:	27a8      	l32i.n	a10, a7, 8
40376710:	0008e0        	callx8	a8
40376713:	fb7c      	movi.n	a11, -1
40376715:	f7fba1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc92a40 <s_rtc_isr_handler_list_lock>)
40376718:	03a165        	call8	4037a130 <xPortEnterCriticalTimeout>
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
4037671b:	4778      	l32i.n	a7, a7, 16
4037671d:	fdf756        	bnez	a7, 40376700 <rtc_isr+0x1c>
            portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
        }
    }
    portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
40376720:	f7f9a1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc92a40 <s_rtc_isr_handler_list_lock>)
40376723:	03b5e5        	call8	4037a280 <vPortExitCritical>
    REG_WRITE(RTC_CNTL_INT_CLR_REG, status);
40376726:	f7f981        	l32r	a8, 4037470c <_iram_text_start+0x308> (6000804c <RTCCNTL+0x4c>)
40376729:	0020c0        	memw
4037672c:	0869      	s32i.n	a6, a8, 0
}
4037672e:	f01d      	retw.n

40376730 <rtc_isr_noniram_disable>:
}
#endif


IRAM_ATTR void rtc_isr_noniram_disable(uint32_t cpu)
{
40376730:	004136        	entry	a1, 32
#if SOC_LP_PERIPH_SHARE_INTERRUPT // TODO: IDF-8008
    if (rtc_isr_cpu == cpu) {
40376733:	f7f781        	l32r	a8, 40374710 <_iram_text_start+0x30c> (3fc92a4c <rtc_isr_cpu>)
40376736:	0888      	l32i.n	a8, a8, 0
40376738:	269827        	bne	a8, a2, 40376762 <rtc_isr_noniram_disable+0x32>
        rtc_intr_enabled |= RTCCNTL.int_ena.val;
4037673b:	f76981        	l32r	a8, 403744e0 <_iram_text_start+0xdc> (60008000 <RTCCNTL>)
4037673e:	0020c0        	memw
40376741:	1028b2        	l32i	a11, a8, 64
40376744:	f7f4a1        	l32r	a10, 40374714 <_iram_text_start+0x310> (3fc92a50 <rtc_intr_enabled>)
40376747:	0a98      	l32i.n	a9, a10, 0
40376749:	2099b0        	or	a9, a9, a11
4037674c:	0a99      	s32i.n	a9, a10, 0
        RTCCNTL.int_ena.val &= rtc_intr_cache;
4037674e:	0020c0        	memw
40376751:	102892        	l32i	a9, a8, 64
40376754:	f7f1a1        	l32r	a10, 40374718 <_iram_text_start+0x314> (3fc92a54 <rtc_intr_cache>)
40376757:	0aa8      	l32i.n	a10, a10, 0
40376759:	1099a0        	and	a9, a9, a10
4037675c:	0020c0        	memw
4037675f:	106892        	s32i	a9, a8, 64
    }
#endif
}
40376762:	f01d      	retw.n

40376764 <rtc_isr_noniram_enable>:

IRAM_ATTR void rtc_isr_noniram_enable(uint32_t cpu)
{
40376764:	004136        	entry	a1, 32
#if SOC_LP_PERIPH_SHARE_INTERRUPT // TODO: IDF-8008
    if (rtc_isr_cpu == cpu) {
40376767:	f7ea81        	l32r	a8, 40374710 <_iram_text_start+0x30c> (3fc92a4c <rtc_isr_cpu>)
4037676a:	0888      	l32i.n	a8, a8, 0
4037676c:	119827        	bne	a8, a2, 40376781 <rtc_isr_noniram_enable+0x1d>
        RTCCNTL.int_ena.val = rtc_intr_enabled;
4037676f:	f7e981        	l32r	a8, 40374714 <_iram_text_start+0x310> (3fc92a50 <rtc_intr_enabled>)
40376772:	08a8      	l32i.n	a10, a8, 0
40376774:	f75b91        	l32r	a9, 403744e0 <_iram_text_start+0xdc> (60008000 <RTCCNTL>)
40376777:	0020c0        	memw
4037677a:	1069a2        	s32i	a10, a9, 64
        rtc_intr_enabled = 0;
4037677d:	090c      	movi.n	a9, 0
4037677f:	0899      	s32i.n	a9, a8, 0
    }
#endif
}
40376781:	f01d      	retw.n
	...

40376784 <regi2c_ctrl_read_reg_mask>:
    REGI2C_CLOCK_DISABLE();
    return value;
}

uint8_t IRAM_ATTR regi2c_ctrl_read_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb)
{
40376784:	004136        	entry	a1, 32
40376787:	742020        	extui	a2, a2, 0, 8
4037678a:	743030        	extui	a3, a3, 0, 8
4037678d:	744040        	extui	a4, a4, 0, 8
40376790:	745050        	extui	a5, a5, 0, 8
40376793:	746060        	extui	a6, a6, 0, 8
    if (xPortInIsrContext()) {
40376796:	039765        	call8	4037a10c <xPortInIsrContext>
40376799:	00ca16        	beqz	a10, 403767a9 <regi2c_ctrl_read_reg_mask+0x25>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037679c:	ffafb2        	movi	a11, -1
4037679f:	f7dfa1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
403767a2:	0398e5        	call8	4037a130 <xPortEnterCriticalTimeout>
403767a5:	000246        	j	403767b2 <regi2c_ctrl_read_reg_mask+0x2e>
403767a8:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403767ab:	ff          	.byte	0xff
403767ac:	f7dca1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
403767af:	039825        	call8	4037a130 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    uint8_t value = regi2c_read_reg_mask_raw(block, host_id, reg_add, msb, lsb);
403767b2:	06ed      	mov.n	a14, a6
403767b4:	05dd      	mov.n	a13, a5
403767b6:	04cd      	mov.n	a12, a4
403767b8:	03bd      	mov.n	a11, a3
403767ba:	20a220        	or	a10, a2, a2
403767bd:	f7d881        	l32r	a8, 40374720 <_iram_text_start+0x31c> (40005d54 <esp_rom_regi2c_read_mask>)
403767c0:	0008e0        	callx8	a8
403767c3:	0a2d      	mov.n	a2, a10
    if (xPortInIsrContext()) {
403767c5:	039465        	call8	4037a10c <xPortInIsrContext>
403767c8:	8a8c      	beqz.n	a10, 403767d4 <regi2c_ctrl_read_reg_mask+0x50>
        portEXIT_CRITICAL_ISR(mux);
403767ca:	f7d4a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
403767cd:	03ab25        	call8	4037a280 <vPortExitCritical>
403767d0:	000186        	j	403767da <regi2c_ctrl_read_reg_mask+0x56>
403767d3:	d2a100        	quos	a10, a1, a0
        portEXIT_CRITICAL(mux);
403767d6:	aaa5f7        	bge	a5, a15, 40376784 <regi2c_ctrl_read_reg_mask>
403767d9:	f01d03        	lsi	f0, a13, 0x3c0

403767dc <regi2c_ctrl_write_reg>:
    REGI2C_CLOCK_DISABLE();
    return value;
}

void IRAM_ATTR regi2c_ctrl_write_reg(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t data)
{
403767dc:	004136        	entry	a1, 32
403767df:	742020        	extui	a2, a2, 0, 8
403767e2:	743030        	extui	a3, a3, 0, 8
403767e5:	744040        	extui	a4, a4, 0, 8
403767e8:	745050        	extui	a5, a5, 0, 8
    if (xPortInIsrContext()) {
403767eb:	039225        	call8	4037a10c <xPortInIsrContext>
403767ee:	00ba16        	beqz	a10, 403767fd <regi2c_ctrl_write_reg+0x21>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
403767f1:	fb7c      	movi.n	a11, -1
403767f3:	f7caa1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
403767f6:	0393a5        	call8	4037a130 <xPortEnterCriticalTimeout>
403767f9:	000246        	j	40376806 <regi2c_ctrl_write_reg+0x2a>
403767fc:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403767ff:	ff          	.byte	0xff
40376800:	f7c7a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
40376803:	0392e5        	call8	4037a130 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_raw(block, host_id, reg_add, data);
40376806:	05dd      	mov.n	a13, a5
40376808:	20c440        	or	a12, a4, a4
4037680b:	20b330        	or	a11, a3, a3
4037680e:	02ad      	mov.n	a10, a2
40376810:	f7c581        	l32r	a8, 40374724 <_iram_text_start+0x320> (40005d60 <esp_rom_regi2c_write>)
40376813:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
40376816:	038f65        	call8	4037a10c <xPortInIsrContext>
40376819:	7a8c      	beqz.n	a10, 40376824 <regi2c_ctrl_write_reg+0x48>
        portEXIT_CRITICAL_ISR(mux);
4037681b:	f7c0a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
4037681e:	03a625        	call8	4037a280 <vPortExitCritical>
40376821:	000146        	j	4037682a <regi2c_ctrl_write_reg+0x4e>
        portEXIT_CRITICAL(mux);
40376824:	f7bea1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
40376827:	03a5a5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    REGI2C_CLOCK_DISABLE();
}
4037682a:	f01d      	retw.n

4037682c <regi2c_ctrl_write_reg_mask>:

void IRAM_ATTR regi2c_ctrl_write_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb, uint8_t data)
{
4037682c:	004136        	entry	a1, 32
4037682f:	742020        	extui	a2, a2, 0, 8
40376832:	743030        	extui	a3, a3, 0, 8
40376835:	744040        	extui	a4, a4, 0, 8
40376838:	745050        	extui	a5, a5, 0, 8
4037683b:	746060        	extui	a6, a6, 0, 8
4037683e:	747070        	extui	a7, a7, 0, 8
    if (xPortInIsrContext()) {
40376841:	038ca5        	call8	4037a10c <xPortInIsrContext>
40376844:	00da16        	beqz	a10, 40376855 <regi2c_ctrl_write_reg_mask+0x29>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376847:	ffafb2        	movi	a11, -1
4037684a:	f7b4a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
4037684d:	038e25        	call8	4037a130 <xPortEnterCriticalTimeout>
40376850:	000286        	j	4037685e <regi2c_ctrl_write_reg_mask+0x32>
40376853:	b20000        	mulsh	a0, a0, a0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
40376856:	af          	.byte	0xaf
40376857:	ff          	.byte	0xff
40376858:	f7b1a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
4037685b:	038d65        	call8	4037a130 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_mask_raw(block, host_id, reg_add, msb, lsb, data);
4037685e:	07fd      	mov.n	a15, a7
40376860:	06ed      	mov.n	a14, a6
40376862:	05dd      	mov.n	a13, a5
40376864:	20c440        	or	a12, a4, a4
40376867:	20b330        	or	a11, a3, a3
4037686a:	02ad      	mov.n	a10, a2
4037686c:	f7af81        	l32r	a8, 40374728 <_iram_text_start+0x324> (40005d6c <esp_rom_regi2c_write_mask>)
4037686f:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
40376872:	0389a5        	call8	4037a10c <xPortInIsrContext>
40376875:	7a8c      	beqz.n	a10, 40376880 <regi2c_ctrl_write_reg_mask+0x54>
        portEXIT_CRITICAL_ISR(mux);
40376877:	f7a9a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
4037687a:	03a065        	call8	4037a280 <vPortExitCritical>
4037687d:	000146        	j	40376886 <regi2c_ctrl_write_reg_mask+0x5a>
        portEXIT_CRITICAL(mux);
40376880:	f7a7a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc92060 <mux>)
40376883:	039fe5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    REGI2C_CLOCK_DISABLE();
}
40376886:	f01d      	retw.n

40376888 <xPortInterruptedFromISRContext>:
    /* Assert if the interrupt nesting count is > 0 */
    configASSERT(xPortInIsrContext() == 0);
}

BaseType_t IRAM_ATTR xPortInterruptedFromISRContext(void)
{
40376888:	004136        	entry	a1, 32
4037688b:	03eb80        	rsr.prid	a8
4037688e:	048d80        	extui	a8, a8, 13, 1
    return (port_interruptNesting[xPortGetCoreID()] != 0);
40376891:	f7a691        	l32r	a9, 4037472c <_iram_text_start+0x328> (3fc94f00 <port_interruptNesting>)
40376894:	a08890        	addx4	a8, a8, a9
40376897:	0828      	l32i.n	a2, a8, 0
}
40376899:	180c      	movi.n	a8, 1
4037689b:	932820        	movnez	a2, a8, a2
4037689e:	f01d      	retw.n

403768a0 <lock_init_generic>:

   Called by _lock_init*, also called by _lock_acquire* to lazily initialize locks that might have
   been initialised (to zero only) before the RTOS scheduler started.
*/
static void IRAM_ATTR lock_init_generic(_lock_t *lock, uint8_t mutex_type)
{
403768a0:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403768a3:	ffafb2        	movi	a11, -1
403768a6:	f7a2a1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92100 <lock_init_spinlock>)
403768a9:	038865        	call8	4037a130 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL(&lock_init_spinlock);
    if (*lock) {
403768ac:	0288      	l32i.n	a8, a2, 0
403768ae:	a8cc      	bnez.n	a8, 403768bc <lock_init_generic+0x1c>
           implements these as macros instead of inline functions
           (*party like it's 1998!*) it's not possible to do this
           without writing wrappers. Doing it this way seems much less
           spaghetti-like.
        */
        SemaphoreHandle_t new_sem = xQueueCreateMutex(mutex_type);
403768b0:	03ad      	mov.n	a10, a3
403768b2:	0339e5        	call8	40379c50 <xQueueCreateMutex>
        if (!new_sem) {
403768b5:	1acc      	bnez.n	a10, 403768ba <lock_init_generic+0x1a>
            abort(); /* No more semaphores available or OOM */
403768b7:	0942e5        	call8	4037fce4 <abort>
        }
        *lock = (_lock_t)new_sem;
403768ba:	02a9      	s32i.n	a10, a2, 0
    }
    portEXIT_CRITICAL(&lock_init_spinlock);
403768bc:	f79da1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92100 <lock_init_spinlock>)
403768bf:	039c25        	call8	4037a280 <vPortExitCritical>
}
403768c2:	f01d      	retw.n

403768c4 <check_lock_nonzero>:
    _lock_close_recursive(&lock);
}

/* Separate function, to prevent generating multiple assert strings */
static void IRAM_ATTR check_lock_nonzero(_LOCK_T lock)
{
403768c4:	004136        	entry	a1, 32
    assert(lock != NULL && "Uninitialized lock used");
403768c7:	00e256        	bnez	a2, 403768d9 <check_lock_nonzero+0x15>
403768ca:	f79ad1        	l32r	a13, 40374734 <_iram_text_start+0x330> (3c024da4 <_flash_rodata_start+0x4c84>)
403768cd:	f79ac1        	l32r	a12, 40374738 <_iram_text_start+0x334> (3c0284dc <__func__$3>)
403768d0:	39a1b2        	movi	a11, 0x139
403768d3:	f79aa1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
403768d6:	094ca5        	call8	4037fda0 <__assert_func>
}
403768d9:	f01d      	retw.n
	...

403768dc <lock_acquire_generic>:
{
403768dc:	006136        	entry	a1, 48
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
403768df:	002272        	l32i	a7, a2, 0
    if (!h) {
403768e2:	27ec      	bnez.n	a7, 40376908 <lock_acquire_generic+0x2c>
        if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
403768e4:	051625        	call8	4037ba48 <xTaskGetSchedulerState>
403768e7:	021a66        	bnei	a10, 1, 403768ed <lock_acquire_generic+0x11>
403768ea:	002106        	j	40376972 <lock_acquire_generic+0x96>
        lock_init_generic(lock, mutex_type);
403768ed:	04bd      	mov.n	a11, a4
403768ef:	20a220        	or	a10, a2, a2
403768f2:	fffae5        	call8	403768a0 <lock_init_generic>
        h = (SemaphoreHandle_t)(*lock);
403768f5:	0278      	l32i.n	a7, a2, 0
        configASSERT(h != NULL);
403768f7:	d7cc      	bnez.n	a7, 40376908 <lock_acquire_generic+0x2c>
403768f9:	f791d1        	l32r	a13, 40374740 <_iram_text_start+0x33c> (3c024df4 <_flash_rodata_start+0x4cd4>)
403768fc:	f792c1        	l32r	a12, 40374744 <_iram_text_start+0x340> (3c028508 <__func__$1>)
403768ff:	81a0b2        	movi	a11, 129
40376902:	f78ea1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
40376905:	0949a5        	call8	4037fda0 <__assert_func>
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376908:	201110        	or	a1, a1, a1
4037690b:	0513e5        	call8	4037ba48 <xTaskGetSchedulerState>
4037690e:	661a26        	beqi	a10, 1, 40376978 <lock_acquire_generic+0x9c>
FORCE_INLINE_ATTR bool xPortCanYield(void)
{
    uint32_t ps_reg = 0;

    //Get the current value of PS (processor status) register
    RSR(PS, ps_reg);
40376911:	03e680        	rsr.ps	a8
     * excm  = (ps_reg >> 4) & 0x1;
     * CINTLEVEL is max(excm * EXCMLEVEL, INTLEVEL), where EXCMLEVEL is 3.
     * However, just return true, only intlevel is zero.
     */

    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
40376914:	348080        	extui	a8, a8, 0, 4
    if (!xPortCanYield()) {
40376917:	18bc      	beqz.n	a8, 4037694c <lock_acquire_generic+0x70>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
40376919:	054466        	bnei	a4, 4, 40376922 <lock_acquire_generic+0x46>
            abort(); /* recursive mutexes make no sense in ISR context */
4037691c:	201110        	or	a1, a1, a1
4037691f:	093c65        	call8	4037fce4 <abort>
        BaseType_t higher_task_woken = false;
40376922:	00a0b2        	movi	a11, 0
40376925:	0061b2        	s32i	a11, a1, 0
        success = xSemaphoreTakeFromISR(h, &higher_task_woken);
40376928:	01cd      	mov.n	a12, a1
4037692a:	07ad      	mov.n	a10, a7
4037692c:	0359e5        	call8	40379ecc <xQueueReceiveFromISR>
4037692f:	0a2d      	mov.n	a2, a10
        if (!success && delay > 0) {
40376931:	40fa80        	nsau	a8, a10
40376934:	418580        	srli	a8, a8, 5
40376937:	190c      	movi.n	a9, 1
40376939:	839330        	moveqz	a9, a3, a3
4037693c:	020897        	bnone	a8, a9, 40376942 <lock_acquire_generic+0x66>
            abort(); /* Tried to block on mutex from ISR, couldn't... rewrite your program to avoid libc interactions in ISRs! */
4037693f:	093a65        	call8	4037fce4 <abort>
        if (higher_task_woken) {
40376942:	0188      	l32i.n	a8, a1, 0
40376944:	28ac      	beqz.n	a8, 4037696a <lock_acquire_generic+0x8e>
            portYIELD_FROM_ISR();
40376946:	03a365        	call8	4037a37c <_frxt_setup_switch>
40376949:	000746        	j	4037696a <lock_acquire_generic+0x8e>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
4037694c:	0e4466        	bnei	a4, 4, 4037695e <lock_acquire_generic+0x82>
            success = xSemaphoreTakeRecursive(h, delay);
4037694f:	20b330        	or	a11, a3, a3
40376952:	20a770        	or	a10, a7, a7
40376955:	035325        	call8	40379e88 <xQueueTakeMutexRecursive>
40376958:	202aa0        	or	a2, a10, a10
4037695b:	0002c6        	j	4037696a <lock_acquire_generic+0x8e>
            success = xSemaphoreTake(h, delay);
4037695e:	20b330        	or	a11, a3, a3
40376961:	20a770        	or	a10, a7, a7
40376964:	0341a5        	call8	40379d80 <xQueueSemaphoreTake>
40376967:	202aa0        	or	a2, a10, a10
    return (success == pdTRUE) ? 0 : -1;
4037696a:	0f1266        	bnei	a2, 1, 4037697d <lock_acquire_generic+0xa1>
4037696d:	020c      	movi.n	a2, 0
4037696f:	000306        	j	4037697f <lock_acquire_generic+0xa3>
            return 0; /* locking is a no-op before scheduler is up, so this "succeeds" */
40376972:	020c      	movi.n	a2, 0
40376974:	0001c6        	j	4037697f <lock_acquire_generic+0xa3>
40376977:	020c00        	andb	b0, b12, b0
        return 0; /* locking is a no-op before scheduler is up, so this "succeeds" */
4037697a:	000046        	j	4037697f <lock_acquire_generic+0xa3>
    return (success == pdTRUE) ? 0 : -1;
4037697d:	f27c      	movi.n	a2, -1
}
4037697f:	f01d      	retw.n
40376981:	000000        	ill

40376984 <lock_release_generic>:
{
40376984:	006136        	entry	a1, 48
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376987:	050c25        	call8	4037ba48 <xTaskGetSchedulerState>
4037698a:	521a26        	beqi	a10, 1, 403769e0 <lock_release_generic+0x5c>
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
4037698d:	0022a2        	l32i	a10, a2, 0
    assert(h);
40376990:	00ea56        	bnez	a10, 403769a2 <lock_release_generic+0x1e>
40376993:	f76dd1        	l32r	a13, 40374748 <_iram_text_start+0x344> (3c022b98 <_flash_rodata_start+0x2a78>)
40376996:	f76dc1        	l32r	a12, 4037474c <_iram_text_start+0x348> (3c0284f0 <__func__$2>)
40376999:	bea0b2        	movi	a11, 190
4037699c:	f768a1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
4037699f:	094025        	call8	4037fda0 <__assert_func>
    RSR(PS, ps_reg);
403769a2:	03e680        	rsr.ps	a8
    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
403769a5:	348080        	extui	a8, a8, 0, 4
    if (!xPortCanYield()) {
403769a8:	01c816        	beqz	a8, 403769c8 <lock_release_generic+0x44>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
403769ab:	024366        	bnei	a3, 4, 403769b1 <lock_release_generic+0x2d>
            abort(); /* indicates logic bug, it shouldn't be possible to lock recursively in ISR */
403769ae:	093365        	call8	4037fce4 <abort>
        BaseType_t higher_task_woken = false;
403769b1:	00a082        	movi	a8, 0
403769b4:	006182        	s32i	a8, a1, 0
        xSemaphoreGiveFromISR(h, &higher_task_woken);
403769b7:	20b110        	or	a11, a1, a1
403769ba:	0330a5        	call8	40379cc4 <xQueueGiveFromISR>
        if (higher_task_woken) {
403769bd:	0188      	l32i.n	a8, a1, 0
403769bf:	d89c      	beqz.n	a8, 403769e0 <lock_release_generic+0x5c>
            portYIELD_FROM_ISR();
403769c1:	039ba5        	call8	4037a37c <_frxt_setup_switch>
403769c4:	000606        	j	403769e0 <lock_release_generic+0x5c>
403769c7:	436600        	min	a6, a6, a0
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
403769ca:	a508      	l32i.n	a0, a5, 40
            xSemaphoreGiveRecursive(h);
403769cc:	032b      	addi.n	a0, a3, 2
403769ce:	000386        	j	403769e0 <lock_release_generic+0x5c>
403769d1:	000000        	ill
            xSemaphoreGive(h);
403769d4:	00a0d2        	movi	a13, 0
403769d7:	20cdd0        	or	a12, a13, a13
403769da:	20bdd0        	or	a11, a13, a13
403769dd:	030fa5        	call8	40379ad8 <xQueueGenericSend>
}
403769e0:	f01d      	retw.n
	...

403769e4 <_lock_close>:
{
403769e4:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403769e7:	ffafb2        	movi	a11, -1
403769ea:	f751a1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92100 <lock_init_spinlock>)
403769ed:	037425        	call8	4037a130 <xPortEnterCriticalTimeout>
    if (*lock) {
403769f0:	0278      	l32i.n	a7, a2, 0
403769f2:	d79c      	beqz.n	a7, 40376a13 <_lock_close+0x2f>
        configASSERT(xSemaphoreGetMutexHolder(h) == NULL); /* mutex should not be held */
403769f4:	07ad      	mov.n	a10, a7
403769f6:	030aa5        	call8	40379aa0 <xQueueGetMutexHolder>
403769f9:	da8c      	beqz.n	a10, 40376a0a <_lock_close+0x26>
403769fb:	f755d1        	l32r	a13, 40374750 <_iram_text_start+0x34c> (3c024e08 <_flash_rodata_start+0x4ce8>)
403769fe:	f755c1        	l32r	a12, 40374754 <_iram_text_start+0x350> (3c028520 <__func__$0>)
40376a01:	6aa0b2        	movi	a11, 106
40376a04:	f74ea1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
40376a07:	0939a5        	call8	4037fda0 <__assert_func>
        vSemaphoreDelete(h);
40376a0a:	07ad      	mov.n	a10, a7
40376a0c:	035465        	call8	40379f54 <vQueueDelete>
        *lock = 0;
40376a0f:	080c      	movi.n	a8, 0
40376a11:	0289      	s32i.n	a8, a2, 0
    portEXIT_CRITICAL(&lock_init_spinlock);
40376a13:	f747a1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92100 <lock_init_spinlock>)
40376a16:	0386a5        	call8	4037a280 <vPortExitCritical>
}
40376a19:	f01d      	retw.n
	...

40376a1c <_lock_acquire>:
{
40376a1c:	004136        	entry	a1, 32
40376a1f:	02ad      	mov.n	a10, a2
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_MUTEX);
40376a21:	1c0c      	movi.n	a12, 1
40376a23:	fb7c      	movi.n	a11, -1
40376a25:	ffeb65        	call8	403768dc <lock_acquire_generic>
}
40376a28:	f01d      	retw.n
	...

40376a2c <_lock_acquire_recursive>:
{
40376a2c:	004136        	entry	a1, 32
40376a2f:	02ad      	mov.n	a10, a2
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a31:	4c0c      	movi.n	a12, 4
40376a33:	fb7c      	movi.n	a11, -1
40376a35:	ffea65        	call8	403768dc <lock_acquire_generic>
}
40376a38:	f01d      	retw.n
	...

40376a3c <_lock_try_acquire>:
{
40376a3c:	004136        	entry	a1, 32
40376a3f:	02ad      	mov.n	a10, a2
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_MUTEX);
40376a41:	1c0c      	movi.n	a12, 1
40376a43:	0b0c      	movi.n	a11, 0
40376a45:	ffe965        	call8	403768dc <lock_acquire_generic>
}
40376a48:	0a2d      	mov.n	a2, a10
40376a4a:	f01d      	retw.n

40376a4c <_lock_try_acquire_recursive>:
{
40376a4c:	004136        	entry	a1, 32
40376a4f:	02ad      	mov.n	a10, a2
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a51:	4c0c      	movi.n	a12, 4
40376a53:	0b0c      	movi.n	a11, 0
40376a55:	ffe865        	call8	403768dc <lock_acquire_generic>
}
40376a58:	0a2d      	mov.n	a2, a10
40376a5a:	f01d      	retw.n

40376a5c <_lock_release>:
{
40376a5c:	004136        	entry	a1, 32
40376a5f:	20a220        	or	a10, a2, a2
    lock_release_generic(lock, queueQUEUE_TYPE_MUTEX);
40376a62:	01a0b2        	movi	a11, 1
40376a65:	fff1e5        	call8	40376984 <lock_release_generic>
}
40376a68:	000090        	retw
	...

40376a6c <_lock_release_recursive>:
{
40376a6c:	004136        	entry	a1, 32
40376a6f:	20a220        	or	a10, a2, a2
    lock_release_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a72:	04a0b2        	movi	a11, 4
40376a75:	fff0e5        	call8	40376984 <lock_release_generic>
}
40376a78:	000090        	retw
	...

40376a7c <__retarget_lock_init>:
{
40376a7c:	004136        	entry	a1, 32
40376a7f:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376a82:	00a082        	movi	a8, 0
40376a85:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_MUTEX);
40376a88:	1b0c      	movi.n	a11, 1
40376a8a:	ffe165        	call8	403768a0 <lock_init_generic>
}
40376a8d:	f01d      	retw.n
	...

40376a90 <__retarget_lock_init_recursive>:
{
40376a90:	004136        	entry	a1, 32
40376a93:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376a96:	00a082        	movi	a8, 0
40376a99:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a9c:	4b0c      	movi.n	a11, 4
40376a9e:	ffe025        	call8	403768a0 <lock_init_generic>
}
40376aa1:	f01d      	retw.n
	...

40376aa4 <__retarget_lock_close>:
{
40376aa4:	006136        	entry	a1, 48
40376aa7:	006122        	s32i	a2, a1, 0
    _lock_close(&lock);
40376aaa:	20a110        	or	a10, a1, a1
40376aad:	fff365        	call8	403769e4 <_lock_close>
}
40376ab0:	000090        	retw
	...

40376ab4 <__retarget_lock_close_recursive>:
{
40376ab4:	006136        	entry	a1, 48
40376ab7:	006122        	s32i	a2, a1, 0
    _lock_close_recursive(&lock);
40376aba:	20a110        	or	a10, a1, a1
40376abd:	fff265        	call8	403769e4 <_lock_close>
}
40376ac0:	000090        	retw
	...

40376ac4 <__retarget_lock_acquire>:

void IRAM_ATTR __retarget_lock_acquire(_LOCK_T lock)
{
40376ac4:	006136        	entry	a1, 48
40376ac7:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376ac9:	027d      	mov.n	a7, a2
40376acb:	02ad      	mov.n	a10, a2
40376acd:	ffdf65        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376ad0:	0298      	l32i.n	a9, a2, 0
40376ad2:	f72181        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376ad5:	049987        	bne	a9, a8, 40376add <__retarget_lock_acquire+0x19>
40376ad8:	f72181        	l32r	a8, 4037475c <_iram_text_start+0x358> (3fc94f78 <__lock___arc4random_mutex>)
40376adb:	0189      	s32i.n	a8, a1, 0
    _lock_acquire(&lock);
40376add:	01ad      	mov.n	a10, a1
40376adf:	fff3e5        	call8	40376a1c <_lock_acquire>
}
40376ae2:	f01d      	retw.n

40376ae4 <__retarget_lock_acquire_recursive>:

void IRAM_ATTR __retarget_lock_acquire_recursive(_LOCK_T lock)
{
40376ae4:	006136        	entry	a1, 48
40376ae7:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376ae9:	027d      	mov.n	a7, a2
40376aeb:	02ad      	mov.n	a10, a2
40376aed:	ffdd65        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376af0:	0298      	l32i.n	a9, a2, 0
40376af2:	f71981        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376af5:	049987        	bne	a9, a8, 40376afd <__retarget_lock_acquire_recursive+0x19>
40376af8:	f71a81        	l32r	a8, 40374760 <_iram_text_start+0x35c> (3fc94f24 <__lock___atexit_recursive_mutex>)
40376afb:	0189      	s32i.n	a8, a1, 0
    _lock_acquire_recursive(&lock);
40376afd:	01ad      	mov.n	a10, a1
40376aff:	fff2e5        	call8	40376a2c <_lock_acquire_recursive>
}
40376b02:	f01d      	retw.n

40376b04 <__retarget_lock_try_acquire>:

int IRAM_ATTR __retarget_lock_try_acquire(_LOCK_T lock)
{
40376b04:	006136        	entry	a1, 48
40376b07:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376b09:	027d      	mov.n	a7, a2
40376b0b:	02ad      	mov.n	a10, a2
40376b0d:	ffdb65        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376b10:	0298      	l32i.n	a9, a2, 0
40376b12:	f71181        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376b15:	049987        	bne	a9, a8, 40376b1d <__retarget_lock_try_acquire+0x19>
40376b18:	f71181        	l32r	a8, 4037475c <_iram_text_start+0x358> (3fc94f78 <__lock___arc4random_mutex>)
40376b1b:	0189      	s32i.n	a8, a1, 0
    return _lock_try_acquire(&lock);
40376b1d:	20a110        	or	a10, a1, a1
40376b20:	fff1a5        	call8	40376a3c <_lock_try_acquire>
}
40376b23:	202aa0        	or	a2, a10, a10
40376b26:	000090        	retw
40376b29:	000000        	ill

40376b2c <__retarget_lock_try_acquire_recursive>:

int IRAM_ATTR __retarget_lock_try_acquire_recursive(_LOCK_T lock)
{
40376b2c:	006136        	entry	a1, 48
40376b2f:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376b31:	027d      	mov.n	a7, a2
40376b33:	02ad      	mov.n	a10, a2
40376b35:	ffd8e5        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376b38:	0298      	l32i.n	a9, a2, 0
40376b3a:	f70781        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376b3d:	049987        	bne	a9, a8, 40376b45 <__retarget_lock_try_acquire_recursive+0x19>
40376b40:	f70881        	l32r	a8, 40374760 <_iram_text_start+0x35c> (3fc94f24 <__lock___atexit_recursive_mutex>)
40376b43:	0189      	s32i.n	a8, a1, 0
    return _lock_try_acquire_recursive(&lock);
40376b45:	20a110        	or	a10, a1, a1
40376b48:	fff025        	call8	40376a4c <_lock_try_acquire_recursive>
}
40376b4b:	202aa0        	or	a2, a10, a10
40376b4e:	000090        	retw
40376b51:	000000        	ill

40376b54 <__retarget_lock_release>:

void IRAM_ATTR __retarget_lock_release(_LOCK_T lock)
{
40376b54:	006136        	entry	a1, 48
40376b57:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376b5a:	20a220        	or	a10, a2, a2
40376b5d:	ffd665        	call8	403768c4 <check_lock_nonzero>
    _lock_release(&lock);
40376b60:	01ad      	mov.n	a10, a1
40376b62:	ffefa5        	call8	40376a5c <_lock_release>
}
40376b65:	f01d      	retw.n
	...

40376b68 <__retarget_lock_release_recursive>:

void IRAM_ATTR __retarget_lock_release_recursive(_LOCK_T lock)
{
40376b68:	006136        	entry	a1, 48
40376b6b:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376b6e:	20a220        	or	a10, a2, a2
40376b71:	ffd525        	call8	403768c4 <check_lock_nonzero>
    _lock_release_recursive(&lock);
40376b74:	01ad      	mov.n	a10, a1
40376b76:	ffef65        	call8	40376a6c <_lock_release_recursive>
}
40376b79:	f01d      	retw.n
	...

40376b7c <_gettimeofday_r>:
    _gettimeofday_r(r, &tv, NULL);
    return (clock_t) tv.tv_sec;
}

WEAK_UNLESS_TIMEFUNC_IMPL int IRAM_ATTR _gettimeofday_r(struct _reent *r, struct timeval *tv, void *tz)
{
40376b7c:	004136        	entry	a1, 32
    (void) tz;

#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
40376b7f:	041316        	beqz	a3, 40376bc4 <_gettimeofday_r+0x48>
        uint64_t microseconds = get_adjusted_boot_time() + esp_time_impl_get_time_since_boot();
40376b82:	f6f881        	l32r	a8, 40374764 <_iram_text_start+0x360> (42005cb4 <get_adjusted_boot_time>)
40376b85:	0008e0        	callx8	a8
40376b88:	206aa0        	or	a6, a10, a10
40376b8b:	207bb0        	or	a7, a11, a11
40376b8e:	f6f681        	l32r	a8, 40374768 <_iram_text_start+0x364> (42005d6c <esp_time_impl_get_time_since_boot>)
40376b91:	0008e0        	callx8	a8
40376b94:	77ba      	add.n	a7, a7, a11
40376b96:	66aa      	add.n	a6, a6, a10
40376b98:	01b6a7        	bgeu	a6, a10, 40376b9d <_gettimeofday_r+0x21>
40376b9b:	771b      	addi.n	a7, a7, 1
        tv->tv_sec = microseconds / 1000000;
40376b9d:	f6ccc1        	l32r	a12, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40376ba0:	0d0c      	movi.n	a13, 0
40376ba2:	20a660        	or	a10, a6, a6
40376ba5:	20b770        	or	a11, a7, a7
40376ba8:	f66e81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
40376bab:	0008e0        	callx8	a8
40376bae:	03a9      	s32i.n	a10, a3, 0
40376bb0:	13b9      	s32i.n	a11, a3, 4
        tv->tv_usec = microseconds % 1000000;
40376bb2:	f6c7c1        	l32r	a12, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40376bb5:	0d0c      	movi.n	a13, 0
40376bb7:	06ad      	mov.n	a10, a6
40376bb9:	20b770        	or	a11, a7, a7
40376bbc:	f6ec81        	l32r	a8, 4037476c <_iram_text_start+0x368> (40002574 <__umoddi3>)
40376bbf:	0008e0        	callx8	a8
40376bc2:	23a9      	s32i.n	a10, a3, 8
    return 0;
#else
    __errno_r(r) = ENOSYS;
    return -1;
#endif
}
40376bc4:	020c      	movi.n	a2, 0
40376bc6:	f01d      	retw.n

40376bc8 <_times_r>:
{
40376bc8:	006136        	entry	a1, 48
    clock_t t = xTaskGetTickCount() * (portTICK_PERIOD_MS * CLK_TCK / 1000);
40376bcb:	0460e5        	call8	4037b1d8 <xTaskGetTickCount>
40376bce:	a0aaa0        	addx4	a10, a10, a10
40376bd1:	80aaa0        	add	a10, a10, a10
    ptms->tms_cstime = 0;
40376bd4:	00a0c2        	movi	a12, 0
40376bd7:	33c9      	s32i.n	a12, a3, 12
    ptms->tms_cutime = 0;
40376bd9:	23c9      	s32i.n	a12, a3, 8
    ptms->tms_stime = t;
40376bdb:	13a9      	s32i.n	a10, a3, 4
    ptms->tms_utime = 0;
40376bdd:	03c9      	s32i.n	a12, a3, 0
    struct timeval tv = {0, 0};
40376bdf:	01c9      	s32i.n	a12, a1, 0
40376be1:	11c9      	s32i.n	a12, a1, 4
40376be3:	21c9      	s32i.n	a12, a1, 8
    _gettimeofday_r(r, &tv, NULL);
40376be5:	01bd      	mov.n	a11, a1
40376be7:	02ad      	mov.n	a10, a2
40376be9:	fff925        	call8	40376b7c <_gettimeofday_r>
}
40376bec:	0128      	l32i.n	a2, a1, 0
40376bee:	f01d      	retw.n

40376bf0 <esp_reent_init>:
 * is a bit too much on a small embedded system. So we point streams
 * to the streams of the global struct _reent, which are initialized in
 * startup code.
 */
void IRAM_ATTR esp_reent_init(struct _reent* r)
{
40376bf0:	004136        	entry	a1, 32
    memset(r, 0, sizeof(*r));
40376bf3:	f0a0c2        	movi	a12, 240
40376bf6:	0b0c      	movi.n	a11, 0
40376bf8:	02ad      	mov.n	a10, a2
40376bfa:	f62581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40376bfd:	0008e0        	callx8	a8
    _REENT_STDIN(r) = _REENT_STDIN(_GLOBAL_REENT);
40376c00:	f6dc81        	l32r	a8, 40374770 <_iram_text_start+0x36c> (3fc927c8 <_impure_data>)
40376c03:	1898      	l32i.n	a9, a8, 4
40376c05:	1299      	s32i.n	a9, a2, 4
    _REENT_STDOUT(r) = _REENT_STDOUT(_GLOBAL_REENT);
40376c07:	2898      	l32i.n	a9, a8, 8
40376c09:	2299      	s32i.n	a9, a2, 8
    _REENT_STDERR(r) = _REENT_STDERR(_GLOBAL_REENT);
40376c0b:	3898      	l32i.n	a9, a8, 12
40376c0d:	3299      	s32i.n	a9, a2, 12
    _REENT_CLEANUP(r) = _REENT_CLEANUP(_GLOBAL_REENT);
40376c0f:	a898      	l32i.n	a9, a8, 40
40376c11:	a299      	s32i.n	a9, a2, 40
    _REENT_SDIDINIT(r) = _REENT_SDIDINIT(_GLOBAL_REENT);
40376c13:	6888      	l32i.n	a8, a8, 24
40376c15:	6289      	s32i.n	a8, a2, 24
}
40376c17:	f01d      	retw.n
40376c19:	000000        	ill

40376c1c <esp_system_get_time>:
    }
#endif
}

int64_t IRAM_ATTR esp_system_get_time(void)
{
40376c1c:	004136        	entry	a1, 32
    return esp_timer_get_time() + s_correction_us;
40376c1f:	0001a5        	call8	40376c38 <esp_timer_get_time>
40376c22:	f6d491        	l32r	a9, 40374774 <_iram_text_start+0x370> (3fc94ff8 <s_correction_us>)
40376c25:	002982        	l32i	a8, a9, 0
40376c28:	012992        	l32i	a9, a9, 4
40376c2b:	803b90        	add	a3, a11, a9
40376c2e:	2a8a      	add.n	a2, a10, a8
40376c30:	01b287        	bgeu	a2, a8, 40376c35 <esp_system_get_time+0x19>
40376c33:	331b      	addi.n	a3, a3, 1
}
40376c35:	f01d      	retw.n
	...

40376c38 <esp_timer_get_time>:
{
    return systimer_hal_get_counter_value(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER);
}

int64_t IRAM_ATTR esp_timer_impl_get_time(void)
{
40376c38:	004136        	entry	a1, 32
    // we hope the execution time of this function won't > 1us
    // thus, to save one function call, we didn't use the existing `systimer_hal_get_time`
    return systimer_hal.ticks_to_us(systimer_hal_get_counter_value(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER));
40376c3b:	f6cfa1        	l32r	a10, 40374778 <_iram_text_start+0x374> (3fc95000 <systimer_hal>)
40376c3e:	1a78      	l32i.n	a7, a10, 4
40376c40:	0b0c      	movi.n	a11, 0
40376c42:	077a25        	call8	4037e3e4 <systimer_hal_get_counter_value>
40376c45:	0007e0        	callx8	a7
}
40376c48:	0a2d      	mov.n	a2, a10
40376c4a:	0b3d      	mov.n	a3, a11
40376c4c:	f01d      	retw.n
	...

40376c50 <usb_serial_jtag_sof_tick_hook>:
{
    return s_usb_serial_jtag_conn_status;
}

static void IRAM_ATTR usb_serial_jtag_sof_tick_hook(void)
{
40376c50:	004136        	entry	a1, 32
 *
 * @return The USB_SERIAL_JTAG raw interrupt status.
 */
static inline __attribute__((always_inline)) uint32_t usb_serial_jtag_ll_get_intraw_mask(void)
{
    return USB_SERIAL_JTAG.int_raw.val;
40376c53:	f6ca91        	l32r	a9, 4037477c <_iram_text_start+0x378> (60038000 <USB_SERIAL_JTAG>)
40376c56:	0020c0        	memw
40376c59:	2988      	l32i.n	a8, a9, 8
    // SOF packet is sent by the HOST every 1ms on a full speed bus
    // Between two consecutive tick hooks, there will be at least 1ms (selectable tick rate range is 1 - 1000Hz)
    // Therefore, SOF intr bit must have be raised at every tick hook if it is connected to a HOST
    // Here, the strategy is: Always assume USB Serial/JTAG is connected until we are sure it is not connected
    // Consider it is disconnected only if SOF intr bit is not raised within (ALLOWED_NO_SOF_TICKS + 1) tick periods
    bool sof_received = (usb_serial_jtag_ll_get_intraw_mask() & USB_SERIAL_JTAG_INTR_SOF);
40376c5b:	2a0c      	movi.n	a10, 2
40376c5d:	1088a0        	and	a8, a8, a10
40376c60:	1b0c      	movi.n	a11, 1
40376c62:	83b880        	moveqz	a11, a8, a8
 *
 * @return None
 */
static inline __attribute__((always_inline)) void usb_serial_jtag_ll_clr_intsts_mask(uint32_t mask)
{
    USB_SERIAL_JTAG.int_clr.val = mask;
40376c65:	0020c0        	memw
40376c68:	59a9      	s32i.n	a10, a9, 20
    usb_serial_jtag_ll_clr_intsts_mask(USB_SERIAL_JTAG_INTR_SOF);
    if (s_usb_serial_jtag_conn_status != sof_received) {
40376c6a:	f6c591        	l32r	a9, 40374780 <_iram_text_start+0x37c> (3fc95010 <s_usb_serial_jtag_conn_status>)
40376c6d:	0020c0        	memw
40376c70:	000992        	l8ui	a9, a9, 0
40376c73:	749090        	extui	a9, a9, 0, 8
40376c76:	3e19b7        	beq	a9, a11, 40376cb8 <usb_serial_jtag_sof_tick_hook+0x68>
        if (!sof_received) {
40376c79:	38ec      	bnez.n	a8, 40376ca0 <usb_serial_jtag_sof_tick_hook+0x50>
            if (remaining_allowed_no_sof_ticks > 0) {
40376c7b:	f6c281        	l32r	a8, 40374784 <_iram_text_start+0x380> (3fc9500c <remaining_allowed_no_sof_ticks>)
40376c7e:	0888      	l32i.n	a8, a8, 0
40376c80:	888c      	beqz.n	a8, 40376c8c <usb_serial_jtag_sof_tick_hook+0x3c>
                remaining_allowed_no_sof_ticks--;
40376c82:	880b      	addi.n	a8, a8, -1
40376c84:	f6c091        	l32r	a9, 40374784 <_iram_text_start+0x380> (3fc9500c <remaining_allowed_no_sof_ticks>)
40376c87:	0989      	s32i.n	a8, a9, 0
40376c89:	000ac6        	j	40376cb8 <usb_serial_jtag_sof_tick_hook+0x68>
                // Tolerance credit used up, considered as USJ disconnected
#if CONFIG_USJ_NO_AUTO_LS_ON_CONNECTION
                esp_pm_lock_release(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
                rtc_clk_bbpll_remove_consumer();
40376c8c:	01a6e5        	call8	403786fc <rtc_clk_bbpll_remove_consumer>
#endif
                s_usb_serial_jtag_conn_status = false;
40376c8f:	f6bc81        	l32r	a8, 40374780 <_iram_text_start+0x37c> (3fc95010 <s_usb_serial_jtag_conn_status>)
40376c92:	090c      	movi.n	a9, 0
40376c94:	0020c0        	memw
40376c97:	004892        	s8i	a9, a8, 0
40376c9a:	000686        	j	40376cb8 <usb_serial_jtag_sof_tick_hook+0x68>
40376c9d:	000000        	ill
            // USJ re-connected
#if CONFIG_USJ_NO_AUTO_LS_ON_CONNECTION
            esp_pm_lock_acquire(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
            rtc_clk_bbpll_add_consumer();
40376ca0:	01a4a5        	call8	403786ec <rtc_clk_bbpll_add_consumer>
#endif
            s_usb_serial_jtag_conn_status = true;
40376ca3:	f6b781        	l32r	a8, 40374780 <_iram_text_start+0x37c> (3fc95010 <s_usb_serial_jtag_conn_status>)
40376ca6:	01a092        	movi	a9, 1
40376ca9:	0020c0        	memw
40376cac:	004892        	s8i	a9, a8, 0
            remaining_allowed_no_sof_ticks = ALLOWED_NO_SOF_TICKS;
40376caf:	f6b581        	l32r	a8, 40374784 <_iram_text_start+0x380> (3fc9500c <remaining_allowed_no_sof_ticks>)
40376cb2:	00a092        	movi	a9, 0
40376cb5:	006892        	s32i	a9, a8, 0
        }
    }
}
40376cb8:	f01d      	retw.n
	...

40376cbc <xt_unhandled_interrupt>:

/*
  Default handler for unhandled interrupts.
*/
void IRAM_ATTR xt_unhandled_interrupt(void * arg)
{
40376cbc:	004136        	entry	a1, 32
40376cbf:	02bd      	mov.n	a11, a2
40376cc1:	03ebc0        	rsr.prid	a12
40376cc4:	04cdc0        	extui	a12, a12, 13, 1
    esp_rom_printf("Unhandled interrupt %d on cpu %d!\n", (int)arg, xPortGetCoreID());
40376cc7:	f6b0a1        	l32r	a10, 40374788 <_iram_text_start+0x384> (3c025d68 <_flash_rodata_start+0x5c48>)
40376cca:	f5fa81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40376ccd:	0008e0        	callx8	a8
}
40376cd0:	f01d      	retw.n
	...

40376cd4 <xt_debugexception>:
    movi    a0,PANIC_RSN_DEBUGEXCEPTION
40376cd4:	100c      	movi.n	a0, 1
    wsr     a0,EXCCAUSE
40376cd6:	13e800        	wsr.exccause	a0
    rsr     a0,(EPC + XCHAL_DEBUGLEVEL)
40376cd9:	03b600        	rsr.epc6	a0
    wsr     a0,EPC_1
40376cdc:	13b100        	wsr.epc1	a0
    rsr     a0,(EXCSAVE + XCHAL_DEBUGLEVEL)
40376cdf:	03d600        	rsr.excsave6	a0
    wsr     a0,EXCSAVE_1
40376ce2:	13d100        	wsr.excsave1	a0
    call0   _xt_panic                       /* does not return */
40376ce5:	013f45        	call0	403780dc <_xt_panic>
    rfi     XCHAL_DEBUGLEVEL
40376ce8:	003610        	rfi	6
	...

40376cec <_xt_kernel_exc>:
    break   1, 0                            /* unhandled kernel exception */
40376cec:	004100        	break	1, 0
    movi    a0,PANIC_RSN_KERNELEXCEPTION
40376cef:	300c      	movi.n	a0, 3
    wsr     a0,EXCCAUSE
40376cf1:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
40376cf4:	013e45        	call0	403780dc <_xt_panic>
    rfe                                     /* make a0 point here not there */
40376cf7:	003000        	rfe
	...

40376cfc <_xt_to_alloca_exc>:
    call0   _xt_alloca_exc                  /* in window vectors section */
40376cfc:	201110        	or	a1, a1, a1
40376cff:	fd3505        	call0	40374050 <_xt_alloca_exc>
	...

40376d04 <_xt_to_syscall_exc>:
    call0   _xt_syscall_exc
40376d04:	000b45        	call0	40376dbc <_xt_syscall_exc>
	...

40376d08 <_xt_to_coproc_exc>:
    call0   _xt_coproc_exc
40376d08:	000f85        	call0	40376e04 <_xt_coproc_exc>
	...

40376d0c <_xt_user_exc>:
    rsr     a0, EXCCAUSE
40376d0c:	03e800        	rsr.exccause	a0
    bnei    a0, EXCCAUSE_LEVEL1INTERRUPT, _xt_handle_exc
40376d0f:	024066        	bnei	a0, 4, 40376d15 <_xt_handle_exc>
    j       _xt_lowint1
40376d12:	00e386        	j	403770a4 <_xt_lowint1>

40376d15 <_xt_handle_exc>:
    bgeui   a0, EXCCAUSE_CP0_DISABLED, _xt_to_coproc_exc
40376d15:	efc0f6        	bgeui	a0, 32, 40376d08 <_xt_to_coproc_exc>
    beqi    a0, EXCCAUSE_ALLOCA,  _xt_to_alloca_exc
40376d18:	e05026        	beqi	a0, 5, 40376cfc <_xt_to_alloca_exc>
    beqi    a0, EXCCAUSE_SYSCALL, _xt_to_syscall_exc
40376d1b:	e51026        	beqi	a0, 1, 40376d04 <_xt_to_syscall_exc>
    mov     a0, sp
40376d1e:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ
40376d21:	ffd112        	addmi	a1, a1, 0xffffff00
40376d24:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40376d27:	046102        	s32i	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
40376d2a:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
40376d2d:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376d30:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376d32:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376d35:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376d37:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40376d3a:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
40376d3c:	49c100        	s32e	a0, a1, -16
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40376d3f:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40376d42:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40376d45:	0b01c5        	call0	40381d64 <_xt_context_save>
    rsr     a0, EXCCAUSE
40376d48:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
40376d4b:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
40376d4e:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
40376d51:	156102        	s32i	a0, a1, 84
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
40376d54:	f68e01        	l32r	a0, 4037478c <_iram_text_start+0x388> (40024 <UserFrameTotalSize+0x3ff24>)
    wsr     a0, PS
40376d57:	13e600        	wsr.ps	a0
    l32i    a3, sp, XT_STK_A0               /* Copy pre-exception a0 (return address) */
40376d5a:	3138      	l32i.n	a3, a1, 12
    s32e    a3, sp, -16
40376d5c:	49c130        	s32e	a3, a1, -16
    l32i    a3, sp, XT_STK_A1               /* Copy pre-exception a1 (stack pointer) */
40376d5f:	4138      	l32i.n	a3, a1, 16
    s32e    a3, sp, -12
40376d61:	49d130        	s32e	a3, a1, -12
    rsr     a0, EPC_1                       /* return address for debug backtrace */
40376d64:	03b100        	rsr.epc1	a0
    movi    a5, 0xC0000000                  /* constant with top 2 bits set (call size) */
40376d67:	f68a51        	l32r	a5, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
    rsync                                   /* wait for WSR.PS to complete */
40376d6a:	002010        	rsync
    or      a0, a0, a5                      /* set top 2 bits */
40376d6d:	200050        	or	a0, a0, a5
    addx2   a0, a5, a0                      /* clear top bit -- thus simulating call4 size */
40376d70:	900500        	addx2	a0, a5, a0
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376d73:	03e820        	rsr.exccause	a2
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376d76:	03e820        	rsr.exccause	a2
    movi    a3, _xt_exception_table
40376d79:	f68631        	l32r	a3, 40374794 <_iram_text_start+0x390> (3fc924d8 <_xt_exception_table>)
    get_percpu_entry_for a2, a4
40376d7c:	03eb40        	rsr.prid	a4
40376d7f:	044d40        	extui	a4, a4, 13, 1
40376d82:	902240        	addx2	a2, a2, a4
    addx4   a4, a2, a3                      /* a4 = address of exception table entry */
40376d85:	a04230        	addx4	a4, a2, a3
    l32i    a4, a4, 0                       /* a4 = handler address */
40376d88:	0448      	l32i.n	a4, a4, 0
    mov     a6, sp                          /* a6 = pointer to exc frame */
40376d8a:	016d      	mov.n	a6, a1
    callx4  a4                              /* call handler */
40376d8c:	0004d0        	callx4	a4
    call0   _xt_context_restore
40376d8f:	0b0785        	call0	40381e08 <_xt_context_restore>
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376d92:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40376d94:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376d97:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
40376d99:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376d9c:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
40376d9e:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
40376da0:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
40376da3:	003000        	rfe
	...

40376da8 <_xt_user_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376da8:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40376daa:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376dad:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
40376daf:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376db2:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40376db4:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
40376db6:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
40376db9:	003000        	rfe

40376dbc <_xt_syscall_exc>:
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376dbc:	ffd112        	addmi	a1, a1, 0xffffff00
40376dbf:	40c112        	addi	a1, a1, 64
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40376dc2:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40376dc5:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40376dc8:	0af985        	call0	40381d64 <_xt_context_save>
    rsr     a2, EPC_1                       /* a2 = PC of 'syscall' */
40376dcb:	03b120        	rsr.epc1	a2
    addi    a3, a2, 3                       /* ++PC                 */
40376dce:	03c232        	addi	a3, a2, 3
    rsr     a0, LEND                        /* if (PC == LEND       */
40376dd1:	030100        	rsr.lend	a0
    bne     a3, a0, 1f
40376dd4:	0d9307        	bne	a3, a0, 40376de5 <_xt_syscall_exc+0x29>
    rsr     a0, LCOUNT                      /*     && LCOUNT != 0)  */
40376dd7:	030200        	rsr.lcount	a0
    beqz    a0, 1f                          /* {                    */
40376dda:	007016        	beqz	a0, 40376de5 <_xt_syscall_exc+0x29>
    addi    a0, a0, -1                      /*   --LCOUNT           */
40376ddd:	000b      	addi.n	a0, a0, -1
    rsr     a3, LBEG                        /*   PC = LBEG          */
40376ddf:	030030        	rsr.lbeg	a3
    wsr     a0, LCOUNT                      /* }                    */
40376de2:	130200        	wsr.lcount	a0
1:  wsr     a3, EPC_1                       /* update PC            */
40376de5:	13b130        	wsr.epc1	a3
    call0   _xt_context_restore
40376de8:	0b01c5        	call0	40381e08 <_xt_context_restore>
    addi    sp, sp, XT_STK_FRMSZ
40376deb:	01d112        	addmi	a1, a1, 0x100
40376dee:	c0c112        	addi	a1, a1, -64
    movi    a0, -1
40376df1:	f07c      	movi.n	a0, -1
    movnez  a2, a0, a2                      /* return -1 if not syscall 0 */
40376df3:	932020        	movnez	a2, a0, a2
    rsr     a0, EXCSAVE_1
40376df6:	03d100        	rsr.excsave1	a0
    rfe
40376df9:	003000        	rfe
    j   .L_xt_coproc_invalid    /* not in a thread (invalid) */
40376dfc:	00a646        	j	40377099 <_xt_coproc_exc+0x295>
40376dff:	980600        	lsi	f0, a6, 0x260
	...

40376e04 <_xt_coproc_exc>:
    mov     a0, sp                          /* sp == a1 */
40376e04:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376e07:	ffd112        	addmi	a1, a1, 0xffffff00
40376e0a:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40376e0d:	046102        	s32i	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
40376e10:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
40376e13:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376e16:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376e18:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376e1b:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376e1d:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40376e20:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
40376e22:	49c100        	s32e	a0, a1, -16
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
40376e25:	f65c01        	l32r	a0, 40374798 <_iram_text_start+0x394> (40376da8 <_xt_user_exit>)
    s32i    a0, sp, XT_STK_EXIT
40376e28:	0109      	s32i.n	a0, a1, 0
    rsr     a0, EXCCAUSE
40376e2a:	03e800        	rsr.exccause	a0
    s32i    a5, sp, XT_STK_A5               /* save a5 */
40376e2d:	8159      	s32i.n	a5, a1, 32
    addi    a5, a0, -EXCCAUSE_CP0_DISABLED  /* a5 = CP index */
40376e2f:	e0c052        	addi	a5, a0, -32
    s32i    a2,  sp, XT_STK_A2
40376e32:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
40376e34:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
40376e36:	7149      	s32i.n	a4, a1, 28
    s32i    a6,  sp, XT_STK_A6
40376e38:	096162        	s32i	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
40376e3b:	a179      	s32i.n	a7, a1, 40
    s32i    a15, sp, XT_STK_A15
40376e3d:	1261f2        	s32i	a15, a1, 72
    call0   XT_RTOS_CP_EXC_HOOK
40376e40:	037205        	call0	4037a564 <_frxt_coproc_exc_hook>
    call0   XT_RTOS_CP_STATE                /* a15 = new owner's save area */
40376e43:	036e05        	call0	4037a524 <_frxt_task_coproc_state>
    beqz    a15, .L_goto_invalid            /* not in a thread (invalid) */
40376e46:	fb2f16        	beqz	a15, 40376dfc <_xt_syscall_exc+0x40>
    movi    a0, _xt_coproc_mask
40376e49:	f65401        	l32r	a0, 4037479c <_iram_text_start+0x398> (3c028760 <_xt_coproc_mask>)
    rsr     a4, CPENABLE                    /* a4 = CPENABLE */
40376e4c:	03e040        	rsr.cpenable	a4
    addx4   a0, a5, a0                      /* a0 = &_xt_coproc_mask[n] */
40376e4f:	a00500        	addx4	a0, a5, a0
    l32i    a0, a0, 0                       /* a0 = (n << 16) | (1 << n) */
40376e52:	0008      	l32i.n	a0, a0, 0
    extui   a2, a0, 0, 16                   /* coprocessor bitmask portion */
40376e54:	f42000        	extui	a2, a0, 0, 16
    or      a4, a4, a2                      /* a4 = CPENABLE | (1 << n) */
40376e57:	204420        	or	a4, a4, a2
    wsr     a4, CPENABLE
40376e5a:	13e040        	wsr.cpenable	a4
    getcoreid a3                            /* a3 = current core ID */
40376e5d:	03eb30        	rsr.prid	a3
40376e60:	043d30        	extui	a3, a3, 13, 1
    movi    a2, XCHAL_CP_MAX << 2           /* a2 = size of an owner array */
40376e63:	021c      	movi.n	a2, 16
    mull    a2, a2, a3                      /* a2 = offset to the owner array of the current core*/
40376e65:	822230        	mull	a2, a2, a3
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of all owner arrays */
40376e68:	f64e31        	l32r	a3, 403747a0 <_iram_text_start+0x39c> (3fc926e0 <_xt_coproc_owner_sa>)
    add     a3, a3, a2                      /* a3 = base of owner array of the current core */
40376e6b:	332a      	add.n	a3, a3, a2
    spinlock_take a6 a7 _xt_coproc_owner_sa_lock
40376e6d:	f64d61        	l32r	a6, 403747a4 <_iram_text_start+0x3a0> (3fc92700 <_xt_coproc_owner_sa_lock>)
40376e70:	070c      	movi.n	a7, 0
40376e72:	130c70        	wsr.scompare1	a7
40376e75:	002010        	rsync
40376e78:	03eb70        	rsr.prid	a7
40376e7b:	00e672        	s32c1i	a7, a6, 0
40376e7e:	fee756        	bnez	a7, 40376e70 <_xt_coproc_exc+0x6c>
    addx4   a3,  a5, a3                      /* a3 = &_xt_coproc_owner_sa[n] */
40376e81:	a03530        	addx4	a3, a5, a3
    l32i    a2,  a3, 0                       /* a2 = old owner's save area */
40376e84:	0328      	l32i.n	a2, a3, 0
    s32i    a15, a3, 0                       /* _xt_coproc_owner_sa[n] = new */
40376e86:	03f9      	s32i.n	a15, a3, 0
    rsync                                    /* ensure wsr.CPENABLE is complete */
40376e88:	002010        	rsync
    spinlock_release a6 a7 _xt_coproc_owner_sa_lock
40376e8b:	f64661        	l32r	a6, 403747a4 <_iram_text_start+0x3a0> (3fc92700 <_xt_coproc_owner_sa_lock>)
40376e8e:	070c      	movi.n	a7, 0
40376e90:	0679      	s32i.n	a7, a6, 0
    bne     a15, a2, .L_switch_context
40376e92:	029f27        	bne	a15, a2, 40376e98 <_xt_coproc_exc+0x94>
    j    .L_goto_done                       /* new owner == old, we're done */
40376e95:	ffd9c6        	j	40376e00 <_xt_syscall_exc+0x44>
    beqz    a2, .L_check_new
40376e98:	0e8216        	beqz	a2, 40376f84 <_xt_coproc_exc+0x180>
    l16ui   a4,  a2,  XT_CPENABLE           /* a4 = old owner's CPENABLE */
40376e9b:	001242        	l16ui	a4, a2, 0
    bnone   a4,  a0,  .L_check_new          /* old owner not using CP    */
40376e9e:	028407        	bany	a4, a0, 40376ea4 <_xt_coproc_exc+0xa0>
40376ea1:	0037c6        	j	40376f84 <_xt_coproc_exc+0x180>
    movi    a5, _xt_coproc_sa_offset
40376ea4:	f64151        	l32r	a5, 403747a8 <_iram_text_start+0x3a4> (3c028740 <_xt_coproc_sa_offset>)
    xor     a4,  a4,  a0                    /* clear CP bit in CPENABLE    */
40376ea7:	304400        	xor	a4, a4, a0
    s16i    a4,  a2,  XT_CPENABLE           /* update old owner's CPENABLE */
40376eaa:	005242        	s16i	a4, a2, 0
    extui   a4,  a0,  16,  5                /* a4 = CP index = n */
40376ead:	454000        	extui	a4, a0, 16, 5
    addx4   a5,  a4,  a5                    /* a5 = &_xt_coproc_sa_offset[n] */
40376eb0:	a05450        	addx4	a5, a4, a5
    l16ui   a4,  a2,  XT_CPSTORED           /* a4 = old owner's CPSTORED */
40376eb3:	011242        	l16ui	a4, a2, 2
    l32i    a5,  a5,  0                     /* a5 = XT_CP[n]_SA offset */
40376eb6:	0558      	l32i.n	a5, a5, 0
    or      a4,  a4,  a0                    /* set CP in old owner's CPSTORED */
40376eb8:	204400        	or	a4, a4, a0
    s16i    a4,  a2,  XT_CPSTORED           /* update old owner's CPSTORED */
40376ebb:	015242        	s16i	a4, a2, 2
    l32i    a2, a2, XT_CP_ASA               /* ptr to actual (aligned) save area */
40376ebe:	2228      	l32i.n	a2, a2, 8
    extui   a3, a0, 16, 5                   /* a3 = CP index = n */
40376ec0:	453000        	extui	a3, a0, 16, 5
    add     a2, a2, a5                      /* a2 = old owner's area for CP n */
40376ec3:	225a      	add.n	a2, a2, a5
    xchal_cpi_store_funcbody
40376ec5:	b3fc      	bnez.n	a3, 40376f04 <_xt_coproc_exc+0x100>
40376ec7:	e33e80        	rur.fcr	a3
40376eca:	0239      	s32i.n	a3, a2, 0
40376ecc:	e33e90        	rur.fsr	a3
40376ecf:	1239      	s32i.n	a3, a2, 4
40376ed1:	024203        	ssi	f0, a2, 8
40376ed4:	034213        	ssi	f1, a2, 12
40376ed7:	044223        	ssi	f2, a2, 16
40376eda:	054233        	ssi	f3, a2, 20
40376edd:	064243        	ssi	f4, a2, 24
40376ee0:	074253        	ssi	f5, a2, 28
40376ee3:	084263        	ssi	f6, a2, 32
40376ee6:	094273        	ssi	f7, a2, 36
40376ee9:	0a4283        	ssi	f8, a2, 40
40376eec:	0b4293        	ssi	f9, a2, 44
40376eef:	0c42a3        	ssi	f10, a2, 48
40376ef2:	0d42b3        	ssi	f11, a2, 52
40376ef5:	0e42c3        	ssi	f12, a2, 56
40376ef8:	0f42d3        	ssi	f13, a2, 60
40376efb:	1042e3        	ssi	f14, a2, 64
40376efe:	1142f3        	ssi	f15, a2, 68
40376f01:	001fc6        	j	40376f84 <_xt_coproc_exc+0x180>
40376f04:	7c3366        	bnei	a3, 3, 40376f84 <_xt_coproc_exc+0x180>
40376f07:	e33000        	lsi	f0, a0, 0x38c
40376f0a:	0239      	s32i.n	a3, a2, 0
40376f0c:	e33010        	lsi	f1, a0, 0x38c
40376f0f:	1239      	s32i.n	a3, a2, 4
40376f11:	e33020        	lsi	f2, a0, 0x38c
40376f14:	2239      	s32i.n	a3, a2, 8
40376f16:	e33030        	lsi	f3, a0, 0x38c
40376f19:	3239      	s32i.n	a3, a2, 12
40376f1b:	e33040        	lsi	f4, a0, 0x38c
40376f1e:	4239      	s32i.n	a3, a2, 16
40376f20:	e33050        	lsi	f5, a0, 0x38c
40376f23:	5239      	s32i.n	a3, a2, 20
40376f25:	e33060        	lsi	f6, a0, 0x38c
40376f28:	6239      	s32i.n	a3, a2, 24
40376f2a:	e33070        	lsi	f7, a0, 0x38c
40376f2d:	7239      	s32i.n	a3, a2, 28
40376f2f:	e33080        	lsi	f8, a0, 0x38c
40376f32:	8239      	s32i.n	a3, a2, 32
40376f34:	e33090        	lsi	f9, a0, 0x38c
40376f37:	9239      	s32i.n	a3, a2, 36
40376f39:	e330a0        	lsi	f10, a0, 0x38c
40376f3c:	a239      	s32i.n	a3, a2, 40
40376f3e:	e330b0        	lsi	f11, a0, 0x38c
40376f41:	b239      	s32i.n	a3, a2, 44
40376f43:	e330d0        	lsi	f13, a0, 0x38c
40376f46:	c239      	s32i.n	a3, a2, 48
40376f48:	e330e0        	lsi	f14, a0, 0x38c
40376f4b:	d239      	s32i.n	a3, a2, 52
40376f4d:	e330f0        	lsi	f15, a0, 0x38c
40376f50:	e239      	s32i.n	a3, a2, 56
40376f52:	e33100        	lsi	f0, a1, 0x38c
40376f55:	f239      	s32i.n	a3, a2, 60
40376f57:	e33110        	lsi	f1, a1, 0x38c
40376f5a:	106232        	s32i	a3, a2, 64
40376f5d:	e33120        	lsi	f2, a1, 0x38c
40376f60:	116232        	s32i	a3, a2, 68
40376f63:	cd6524        	lsi	f2, a5, 0x334
40376f66:	cde624        	lsi	f2, a6, 0x334
40376f69:	dd6724        	lsi	f2, a7, 0x374
40376f6c:	01d222        	addmi	a2, a2, 0x100
40376f6f:	80c222        	addi	a2, a2, -128
40376f72:	dde024        	lsi	f2, a0, 0x374
40376f75:	ed6124        	lsi	f2, a1, 0x3b4
40376f78:	ede224        	lsi	f2, a2, 0x3b4
40376f7b:	fd6324        	lsi	f2, a3, 0x3f4
40376f7e:	fde424        	lsi	f2, a4, 0x3f4
40376f81:	ffffc6        	j	40376f84 <_xt_coproc_exc+0x180>
    beqz    a15, .L_xt_coproc_done
40376f84:	0dcf16        	beqz	a15, 40377064 <_xt_coproc_exc+0x260>
    l16ui   a3,  a15, XT_CPSTORED           /* a3 = new owner's CPSTORED */
40376f87:	011f32        	l16ui	a3, a15, 2
    movi    a4, _xt_coproc_sa_offset
40376f8a:	f60741        	l32r	a4, 403747a8 <_iram_text_start+0x3a4> (3c028740 <_xt_coproc_sa_offset>)
    bnone   a3,  a0,  .L_check_cs           /* full CP not saved, check callee-saved */
40376f8d:	028307        	bany	a3, a0, 40376f93 <_xt_coproc_exc+0x18f>
40376f90:	003906        	j	40377078 <_xt_coproc_exc+0x274>
    xor     a3,  a3,  a0                    /* CPSTORED bit is set, clear it */
40376f93:	303300        	xor	a3, a3, a0
    s16i    a3,  a15, XT_CPSTORED           /* update new owner's CPSTORED */
40376f96:	015f32        	s16i	a3, a15, 2
    extui   a3,  a0, 16, 5                  /* a3 = CP index = n */
40376f99:	453000        	extui	a3, a0, 16, 5
    addx4   a4,  a3, a4                     /* a4 = &_xt_coproc_sa_offset[n] */
40376f9c:	a04340        	addx4	a4, a3, a4
    l32i    a4,  a4, 0                      /* a4 = XT_CP[n]_SA */
40376f9f:	0448      	l32i.n	a4, a4, 0
    l32i    a5, a15, XT_CP_ASA              /* ptr to actual (aligned) save area */
40376fa1:	2f58      	l32i.n	a5, a15, 8
    add     a2,  a4, a5                     /* a2 = new owner's area for CP */
40376fa3:	245a      	add.n	a2, a4, a5
    xchal_cpi_load_funcbody
40376fa5:	b3fc      	bnez.n	a3, 40376fe4 <_xt_coproc_exc+0x1e0>
40376fa7:	0238      	l32i.n	a3, a2, 0
40376fa9:	f3e830        	wur.fcr	a3
40376fac:	1238      	l32i.n	a3, a2, 4
40376fae:	f3e930        	wur.fsr	a3
40376fb1:	020203        	lsi	f0, a2, 8
40376fb4:	030213        	lsi	f1, a2, 12
40376fb7:	040223        	lsi	f2, a2, 16
40376fba:	050233        	lsi	f3, a2, 20
40376fbd:	060243        	lsi	f4, a2, 24
40376fc0:	070253        	lsi	f5, a2, 28
40376fc3:	080263        	lsi	f6, a2, 32
40376fc6:	090273        	lsi	f7, a2, 36
40376fc9:	0a0283        	lsi	f8, a2, 40
40376fcc:	0b0293        	lsi	f9, a2, 44
40376fcf:	0c02a3        	lsi	f10, a2, 48
40376fd2:	0d02b3        	lsi	f11, a2, 52
40376fd5:	0e02c3        	lsi	f12, a2, 56
40376fd8:	0f02d3        	lsi	f13, a2, 60
40376fdb:	1002e3        	lsi	f14, a2, 64
40376fde:	1102f3        	lsi	f15, a2, 68
40376fe1:	001fc6        	j	40377064 <_xt_coproc_exc+0x260>
40376fe4:	7c3366        	bnei	a3, 3, 40377064 <_xt_coproc_exc+0x260>
40376fe7:	0238      	l32i.n	a3, a2, 0
40376fe9:	f30030        	lsi	f3, a0, 0x3cc
40376fec:	1238      	l32i.n	a3, a2, 4
40376fee:	f30130        	lsi	f3, a1, 0x3cc
40376ff1:	2238      	l32i.n	a3, a2, 8
40376ff3:	f30230        	lsi	f3, a2, 0x3cc
40376ff6:	3238      	l32i.n	a3, a2, 12
40376ff8:	f30330        	lsi	f3, a3, 0x3cc
40376ffb:	4238      	l32i.n	a3, a2, 16
40376ffd:	f30430        	lsi	f3, a4, 0x3cc
40377000:	5238      	l32i.n	a3, a2, 20
40377002:	f30530        	lsi	f3, a5, 0x3cc
40377005:	6238      	l32i.n	a3, a2, 24
40377007:	f30630        	lsi	f3, a6, 0x3cc
4037700a:	7238      	l32i.n	a3, a2, 28
4037700c:	f30730        	lsi	f3, a7, 0x3cc
4037700f:	8238      	l32i.n	a3, a2, 32
40377011:	f30830        	lsi	f3, a8, 0x3cc
40377014:	9238      	l32i.n	a3, a2, 36
40377016:	f30930        	lsi	f3, a9, 0x3cc
40377019:	a238      	l32i.n	a3, a2, 40
4037701b:	f30a30        	lsi	f3, a10, 0x3cc
4037701e:	b238      	l32i.n	a3, a2, 44
40377020:	f30b30        	lsi	f3, a11, 0x3cc
40377023:	c238      	l32i.n	a3, a2, 48
40377025:	f30d30        	lsi	f3, a13, 0x3cc
40377028:	d238      	l32i.n	a3, a2, 52
4037702a:	f30e30        	lsi	f3, a14, 0x3cc
4037702d:	e238      	l32i.n	a3, a2, 56
4037702f:	f30f30        	lsi	f3, a15, 0x3cc
40377032:	f238      	l32i.n	a3, a2, 60
40377034:	f31030        	lsi	f3, a0, 0x3cc
40377037:	102232        	l32i	a3, a2, 64
4037703a:	f31130        	lsi	f3, a1, 0x3cc
4037703d:	112232        	l32i	a3, a2, 68
40377040:	f31230        	lsi	f3, a2, 0x3cc
40377043:	cd2524        	lsi	f2, a5, 0x334
40377046:	cda624        	lsi	f2, a6, 0x334
40377049:	dd2724        	lsi	f2, a7, 0x374
4037704c:	01d222        	addmi	a2, a2, 0x100
4037704f:	80c222        	addi	a2, a2, -128
40377052:	dda024        	lsi	f2, a0, 0x374
40377055:	ed2124        	lsi	f2, a1, 0x3b4
40377058:	eda224        	lsi	f2, a2, 0x3b4
4037705b:	fd2324        	lsi	f2, a3, 0x3f4
4037705e:	fda424        	lsi	f2, a4, 0x3f4
40377061:	ffffc6        	j	40377064 <_xt_coproc_exc+0x260>
    l32i    a15, sp, XT_STK_A15
40377064:	1221f2        	l32i	a15, a1, 72
    l32i    a6,  sp, XT_STK_A6
40377067:	9168      	l32i.n	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
40377069:	a178      	l32i.n	a7, a1, 40
    l32i    a5,  sp, XT_STK_A5
4037706b:	8158      	l32i.n	a5, a1, 32
    l32i    a4,  sp, XT_STK_A4
4037706d:	7148      	l32i.n	a4, a1, 28
    l32i    a3,  sp, XT_STK_A3
4037706f:	062132        	l32i	a3, a1, 24
    l32i    a2,  sp, XT_STK_A2
40377072:	052122        	l32i	a2, a1, 20
    call0   _xt_user_exit                   /* return via exit dispatcher */
40377075:	ffd305        	call0	40376da8 <_xt_user_exit>
    l16ui   a2, a15, XT_CP_CS_ST            /* a2 = mask of CPs saved    */
40377078:	021f22        	l16ui	a2, a15, 4
    bnone   a2,  a0, .L_xt_coproc_done      /* if no match then done     */
4037707b:	e50207        	bnone	a2, a0, 40377064 <_xt_coproc_exc+0x260>
    and     a2,  a2, a0                     /* a2 = which CPs to restore */
4037707e:	102200        	and	a2, a2, a0
    extui   a2,  a2, 0, 8                   /* extract low 8 bits        */
40377081:	742020        	extui	a2, a2, 0, 8
    s32i    a13, sp, XT_STK_A13
40377084:	1061d2        	s32i	a13, a1, 64
    s32i    a14, sp, XT_STK_A14
40377087:	1161e2        	s32i	a14, a1, 68
    call0   _xt_coproc_restorecs            /* restore CP registers      */
4037708a:	0ae445        	call0	40381ed0 <_xt_coproc_restorecs>
    l32i    a13, sp, XT_STK_A13
4037708d:	1021d2        	l32i	a13, a1, 64
    l32i    a14, sp, XT_STK_A14
40377090:	1121e2        	l32i	a14, a1, 68
    j       .L_xt_coproc_done
40377093:	fff346        	j	40377064 <_xt_coproc_exc+0x260>
40377096:	000000        	ill
    movi    a0,PANIC_RSN_COPROCEXCEPTION
40377099:	400c      	movi.n	a0, 4
    wsr     a0,EXCCAUSE
4037709b:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* not in a thread (invalid) */
4037709e:	201110        	or	a1, a1, a1
403770a1:	010385        	call0	403780dc <_xt_panic>

403770a4 <_xt_lowint1>:
    mov     a0, sp                          /* sp == a1 */
403770a4:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
403770a7:	ffd112        	addmi	a1, a1, 0xffffff00
403770aa:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
403770ad:	046102        	s32i	a0, a1, 16
    rsr     a0, PS                          /* save interruptee's PS */
403770b0:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
403770b3:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
403770b6:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
403770b9:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
403770bb:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
403770be:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
403770c0:	f5b601        	l32r	a0, 40374798 <_iram_text_start+0x394> (40376da8 <_xt_user_exit>)
    s32i    a0, sp, XT_STK_EXIT
403770c3:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
403770c5:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_1
403770c7:	13d100        	wsr.excsave1	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
403770ca:	032c85        	call0	4037a394 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(1) | PS_UM | PS_WOE
403770cd:	f5b701        	l32r	a0, 403747ac <_iram_text_start+0x3a8> (40021 <UserFrameTotalSize+0x3ff21>)
    wsr     a0, PS
403770d0:	13e600        	wsr.ps	a0
    rsync
403770d3:	002010        	rsync
    dispatch_c_isr 1 XCHAL_INTLEVEL1_MASK
403770d6:	03e420        	rsr.intenable	a2
403770d9:	03e230        	rsr.interrupt	a3
403770dc:	f5b541        	l32r	a4, 403747b0 <_iram_text_start+0x3ac> (637ff <UserFrameTotalSize+0x636ff>)
403770df:	102230        	and	a2, a2, a3
403770e2:	102240        	and	a2, a2, a4
403770e5:	04f216        	beqz	a2, 40377138 <_xt_lowint1+0x94>
403770e8:	03d100        	rsr.excsave1	a0
403770eb:	3038      	l32i.n	a3, a0, 12
403770ed:	49c130        	s32e	a3, a1, -16
403770f0:	4038      	l32i.n	a3, a0, 16
403770f2:	49d130        	s32e	a3, a1, -12
403770f5:	03b100        	rsr.epc1	a0
403770f8:	f5a641        	l32r	a4, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
403770fb:	200040        	or	a0, a0, a4
403770fe:	900400        	addx2	a0, a4, a0
40377101:	420b      	addi.n	a4, a2, -1
40377103:	102240        	and	a2, a2, a4
40377106:	ff7256        	bnez	a2, 40377101 <_xt_lowint1+0x5d>
40377109:	441b      	addi.n	a4, a4, 1
4037710b:	13e340        	wsr.intclear	a4
4037710e:	f31c      	movi.n	a3, 31
40377110:	40f440        	nsau	a4, a4
40377113:	c03340        	sub	a3, a3, a4
40377116:	03ebc0        	rsr.prid	a12
40377119:	04cdc0        	extui	a12, a12, 13, 1
4037711c:	9033c0        	addx2	a3, a3, a12
4037711f:	f5a541        	l32r	a4, 403747b4 <_iram_text_start+0x3b0> (3fc922d8 <_xt_interrupt_table>)
40377122:	b03340        	addx8	a3, a3, a4
40377125:	0348      	l32i.n	a4, a3, 0
40377127:	202660        	or	a2, a6, a6
4037712a:	012362        	l32i	a6, a3, 4
4037712d:	0004d0        	callx4	a4
40377130:	ffe886        	j	403770d6 <_xt_lowint1+0x32>
40377133:	460000        	lsi	f0, a0, 0x118
40377136:	10ffe7        	bbsi	a15, 30, 4037714a <_xt_medint2+0xa>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40377139:	c52011        	l32r	a1, 403685bc <rom_rx_gain_force+0x362190>
4037713c:	0329      	s32i.n	a2, a3, 0
	...

40377140 <_xt_medint2>:
    mov     a0, sp                          /* sp == a1 */
40377140:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40377143:	ffd112        	addmi	a1, a1, 0xffffff00
40377146:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40377149:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_2                       /* save interruptee's PS */
4037714c:	03c200        	rsr.eps2	a0
    s32i    a0, sp, XT_STK_PS
4037714f:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_2                       /* save interruptee's PC */
40377152:	03b200        	rsr.epc2	a0
    s32i    a0, sp, XT_STK_PC
40377155:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_2                   /* save interruptee's a0 */
40377157:	03d200        	rsr.excsave2	a0
    s32i    a0, sp, XT_STK_A0
4037715a:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint2_exit            /* save exit point for dispatch */
4037715c:	f59701        	l32r	a0, 403747b8 <_iram_text_start+0x3b4> (403771dc <_xt_medint2_exit>)
    s32i    a0, sp, XT_STK_EXIT
4037715f:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40377161:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_2
40377163:	13d200        	wsr.excsave2	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40377166:	0322c5        	call0	4037a394 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(2) | PS_UM | PS_WOE
40377169:	f59401        	l32r	a0, 403747bc <_iram_text_start+0x3b8> (40022 <UserFrameTotalSize+0x3ff22>)
    wsr     a0, PS
4037716c:	13e600        	wsr.ps	a0
    rsync
4037716f:	002010        	rsync
    dispatch_c_isr 2 XCHAL_INTLEVEL2_MASK
40377172:	03e420        	rsr.intenable	a2
40377175:	03e230        	rsr.interrupt	a3
40377178:	f59241        	l32r	a4, 403747c0 <_iram_text_start+0x3bc> (380000 <UserFrameTotalSize+0x37ff00>)
4037717b:	102230        	and	a2, a2, a3
4037717e:	102240        	and	a2, a2, a4
40377181:	04f216        	beqz	a2, 403771d4 <_xt_medint2+0x94>
40377184:	03d200        	rsr.excsave2	a0
40377187:	3038      	l32i.n	a3, a0, 12
40377189:	49c130        	s32e	a3, a1, -16
4037718c:	4038      	l32i.n	a3, a0, 16
4037718e:	49d130        	s32e	a3, a1, -12
40377191:	03b200        	rsr.epc2	a0
40377194:	f57f41        	l32r	a4, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40377197:	200040        	or	a0, a0, a4
4037719a:	900400        	addx2	a0, a4, a0
4037719d:	420b      	addi.n	a4, a2, -1
4037719f:	102240        	and	a2, a2, a4
403771a2:	ff7256        	bnez	a2, 4037719d <_xt_medint2+0x5d>
403771a5:	441b      	addi.n	a4, a4, 1
403771a7:	13e340        	wsr.intclear	a4
403771aa:	f31c      	movi.n	a3, 31
403771ac:	40f440        	nsau	a4, a4
403771af:	c03340        	sub	a3, a3, a4
403771b2:	03ebc0        	rsr.prid	a12
403771b5:	04cdc0        	extui	a12, a12, 13, 1
403771b8:	9033c0        	addx2	a3, a3, a12
403771bb:	f57e41        	l32r	a4, 403747b4 <_iram_text_start+0x3b0> (3fc922d8 <_xt_interrupt_table>)
403771be:	b03340        	addx8	a3, a3, a4
403771c1:	0348      	l32i.n	a4, a3, 0
403771c3:	202660        	or	a2, a6, a6
403771c6:	012362        	l32i	a6, a3, 4
403771c9:	0004d0        	callx4	a4
403771cc:	ffe886        	j	40377172 <_xt_medint2+0x32>
403771cf:	460000        	lsi	f0, a0, 0x118
403771d2:	10ffe7        	bbsi	a15, 30, 403771e6 <_xt_medint2_exit+0xa>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
403771d5:	052011        	l32r	a1, 40338658 <rom_rx_gain_force+0x33222c>
403771d8:	000320        	lsi	f2, a3, 0
	...

403771dc <_xt_medint2_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
403771dc:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_2
403771de:	13c200        	wsr.eps2	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
403771e1:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_2
403771e3:	13b200        	wsr.epc2	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
403771e6:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
403771e8:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
403771ea:	002010        	rsync
    rfi     2
403771ed:	003210        	rfi	2

403771f0 <_xt_medint3>:
    mov     a0, sp                          /* sp == a1 */
403771f0:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
403771f3:	ffd112        	addmi	a1, a1, 0xffffff00
403771f6:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
403771f9:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_3                       /* save interruptee's PS */
403771fc:	03c300        	rsr.eps3	a0
    s32i    a0, sp, XT_STK_PS
403771ff:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_3                       /* save interruptee's PC */
40377202:	03b300        	rsr.epc3	a0
    s32i    a0, sp, XT_STK_PC
40377205:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_3                   /* save interruptee's a0 */
40377207:	03d300        	rsr.excsave3	a0
    s32i    a0, sp, XT_STK_A0
4037720a:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint3_exit            /* save exit point for dispatch */
4037720c:	f56e01        	l32r	a0, 403747c4 <_iram_text_start+0x3c0> (4037728c <_xt_medint3_exit>)
    s32i    a0, sp, XT_STK_EXIT
4037720f:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40377211:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_3
40377213:	13d300        	wsr.excsave3	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40377216:	0317c5        	call0	4037a394 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(3) | PS_UM | PS_WOE
40377219:	f56b01        	l32r	a0, 403747c8 <_iram_text_start+0x3c4> (40023 <UserFrameTotalSize+0x3ff23>)
    wsr     a0, PS
4037721c:	13e600        	wsr.ps	a0
    rsync
4037721f:	002010        	rsync
    dispatch_c_isr 3 XCHAL_INTLEVEL3_MASK
40377222:	03e420        	rsr.intenable	a2
40377225:	03e230        	rsr.interrupt	a3
40377228:	f56941        	l32r	a4, 403747cc <_iram_text_start+0x3c8> (28c08800 <UserFrameTotalSize+0x28c08700>)
4037722b:	102230        	and	a2, a2, a3
4037722e:	102240        	and	a2, a2, a4
40377231:	04f216        	beqz	a2, 40377284 <_xt_medint3+0x94>
40377234:	03d300        	rsr.excsave3	a0
40377237:	3038      	l32i.n	a3, a0, 12
40377239:	49c130        	s32e	a3, a1, -16
4037723c:	4038      	l32i.n	a3, a0, 16
4037723e:	49d130        	s32e	a3, a1, -12
40377241:	03b300        	rsr.epc3	a0
40377244:	f55341        	l32r	a4, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40377247:	200040        	or	a0, a0, a4
4037724a:	900400        	addx2	a0, a4, a0
4037724d:	420b      	addi.n	a4, a2, -1
4037724f:	102240        	and	a2, a2, a4
40377252:	ff7256        	bnez	a2, 4037724d <_xt_medint3+0x5d>
40377255:	441b      	addi.n	a4, a4, 1
40377257:	13e340        	wsr.intclear	a4
4037725a:	f31c      	movi.n	a3, 31
4037725c:	40f440        	nsau	a4, a4
4037725f:	c03340        	sub	a3, a3, a4
40377262:	03ebc0        	rsr.prid	a12
40377265:	04cdc0        	extui	a12, a12, 13, 1
40377268:	9033c0        	addx2	a3, a3, a12
4037726b:	f55241        	l32r	a4, 403747b4 <_iram_text_start+0x3b0> (3fc922d8 <_xt_interrupt_table>)
4037726e:	b03340        	addx8	a3, a3, a4
40377271:	0348      	l32i.n	a4, a3, 0
40377273:	202660        	or	a2, a6, a6
40377276:	012362        	l32i	a6, a3, 4
40377279:	0004d0        	callx4	a4
4037727c:	ffe886        	j	40377222 <_xt_medint3+0x32>
4037727f:	ffe7c6        	j	40377222 <_xt_medint3+0x32>
40377282:	100000        	and	a0, a0, a0
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40377285:	052011        	l32r	a1, 40338708 <rom_rx_gain_force+0x3322dc>
40377288:	000315        	call4	403772bc <bootloader_flash_execute_command_common+0x4>
	...

4037728c <_xt_medint3_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
4037728c:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_3
4037728e:	13c300        	wsr.eps3	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40377291:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_3
40377293:	13b300        	wsr.epc3	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40377296:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40377298:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
4037729a:	002010        	rsync
    rfi     3
4037729d:	003310        	rfi	3

403772a0 <_xt_highint4>:
    rsr     a0, EXCSAVE_4                   /* restore a0 */
403772a0:	03d400        	rsr.excsave4	a0
    rfi     4
403772a3:	003410        	rfi	4
	...

403772a8 <xt_highint5>:
    rsr     a0, EXCSAVE_5                   /* restore a0 */
403772a8:	03d500        	rsr.excsave5	a0
    rfi     5
403772ab:	003510        	rfi	5
	...

403772b0 <xt_nmi>:
    rsr     a0, EXCSAVE + XCHAL_NMILEVEL    /* restore a0 */
403772b0:	03d700        	rsr.excsave7	a0
    rfi     XCHAL_NMILEVEL
403772b3:	003710        	rfi	7
	...

403772b8 <bootloader_flash_execute_command_common>:
    uint8_t command,
    uint32_t addr_len, uint32_t address,
    uint8_t dummy_len,
    uint8_t mosi_len, uint32_t mosi_data,
    uint8_t miso_len)
{
403772b8:	00a136        	entry	a1, 80
403772bb:	4179      	s32i.n	a7, a1, 16
403772bd:	749020        	extui	a9, a2, 0, 8
403772c0:	745050        	extui	a5, a5, 0, 8
403772c3:	746060        	extui	a6, a6, 0, 8
403772c6:	500122        	l8ui	a2, a1, 80
    assert(mosi_len <= 32);
403772c9:	082c      	movi.n	a8, 32
403772cb:	0eb867        	bgeu	a8, a6, 403772dd <bootloader_flash_execute_command_common+0x25>
403772ce:	f540d1        	l32r	a13, 403747d0 <_iram_text_start+0x3cc> (3c025e30 <_flash_rodata_start+0x5d10>)
403772d1:	f540c1        	l32r	a12, 403747d4 <_iram_text_start+0x3d0> (3c02889c <__func__$4>)
403772d4:	faa2b2        	movi	a11, 0x2fa
403772d7:	f540a1        	l32r	a10, 403747d8 <_iram_text_start+0x3d4> (3c025e79 <_flash_rodata_start+0x5d59>)
403772da:	08ac65        	call8	4037fda0 <__assert_func>
    assert(miso_len <= 32);
403772dd:	082c      	movi.n	a8, 32
403772df:	0eb827        	bgeu	a8, a2, 403772f1 <bootloader_flash_execute_command_common+0x39>
403772e2:	f53ed1        	l32r	a13, 403747dc <_iram_text_start+0x3d8> (3c025e8c <_flash_rodata_start+0x5d6c>)
403772e5:	f53bc1        	l32r	a12, 403747d4 <_iram_text_start+0x3d0> (3c02889c <__func__$4>)
403772e8:	fba2b2        	movi	a11, 0x2fb
403772eb:	f53ba1        	l32r	a10, 403747d8 <_iram_text_start+0x3d4> (3c025e79 <_flash_rodata_start+0x5d59>)
403772ee:	08ab25        	call8	4037fda0 <__assert_func>
 * @param user1_reg user1_reg
 * @param user2_reg user2_reg
 */
static inline void spimem_flash_ll_get_common_command_register_info(spi_mem_dev_t *dev, uint32_t *ctrl_reg, uint32_t *user_reg, uint32_t *user1_reg, uint32_t *user2_reg)
{
    *ctrl_reg = dev->ctrl.val;
403772f1:	f53b81        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403772f4:	0020c0        	memw
403772f7:	28a8      	l32i.n	a10, a8, 8
403772f9:	51a9      	s32i.n	a10, a1, 20
    *user_reg = dev->user.val;
403772fb:	0020c0        	memw
403772fe:	68a8      	l32i.n	a10, a8, 24
40377300:	61a9      	s32i.n	a10, a1, 24
    *user1_reg = dev->user1.val;
40377302:	0020c0        	memw
40377305:	78a8      	l32i.n	a10, a8, 28
40377307:	71a9      	s32i.n	a10, a1, 28
    *user2_reg = dev->user2.val;
40377309:	0020c0        	memw
4037730c:	88a8      	l32i.n	a10, a8, 32
4037730e:	81a9      	s32i.n	a10, a1, 32
    uint32_t old_ctrl_reg = 0;
    uint32_t old_user_reg = 0;
    uint32_t old_user1_reg = 0;
    uint32_t old_user2_reg = 0;
    spi_flash_ll_get_common_command_register_info(&SPIMEM_LL_APB, &old_ctrl_reg, &old_user_reg, &old_user1_reg, &old_user2_reg);
    SPIMEM_LL_APB.ctrl.val = 0;
40377310:	0a0c      	movi.n	a10, 0
40377312:	0020c0        	memw
40377315:	28a9      	s32i.n	a10, a8, 8
    dev->ctrl.wp = level;
40377317:	0020c0        	memw
4037731a:	28a8      	l32i.n	a10, a8, 8
4037731c:	f532b1        	l32r	a11, 403747e4 <_iram_text_start+0x3e0> (200000 <UserFrameTotalSize+0x1fff00>)
4037731f:	20aab0        	or	a10, a10, a11
40377322:	0020c0        	memw
40377325:	28a9      	s32i.n	a10, a8, 8
    dev->user.usr_command = 1;
40377327:	0020c0        	memw
4037732a:	68a8      	l32i.n	a10, a8, 24
4037732c:	f47cb1        	l32r	a11, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037732f:	20aab0        	or	a10, a10, a11
40377332:	0020c0        	memw
40377335:	68a9      	s32i.n	a10, a8, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
40377337:	0020c0        	memw
4037733a:	88a8      	l32i.n	a10, a8, 32
4037733c:	0020c0        	memw
4037733f:	21a9      	s32i.n	a10, a1, 8
40377341:	0020c0        	memw
40377344:	21a8      	l32i.n	a10, a1, 8
40377346:	f5a0a0        	extui	a10, a10, 16, 16
40377349:	11aa00        	slli	a10, a10, 16
4037734c:	2099a0        	or	a9, a9, a10
4037734f:	0020c0        	memw
40377352:	2199      	s32i.n	a9, a1, 8
40377354:	0020c0        	memw
40377357:	2198      	l32i.n	a9, a1, 8
40377359:	0020c0        	memw
4037735c:	8899      	s32i.n	a9, a8, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037735e:	0020c0        	memw
40377361:	8898      	l32i.n	a9, a8, 32
40377363:	0020c0        	memw
40377366:	1199      	s32i.n	a9, a1, 4
40377368:	0020c0        	memw
4037736b:	1198      	l32i.n	a9, a1, 4
4037736d:	1199c0        	slli	a9, a9, 4
40377370:	419490        	srli	a9, a9, 4
40377373:	f51da1        	l32r	a10, 403747e8 <_iram_text_start+0x3e4> (70000000 <_rtc_reserved_end+0xff00000>)
40377376:	2099a0        	or	a9, a9, a10
40377379:	0020c0        	memw
4037737c:	1199      	s32i.n	a9, a1, 4
4037737e:	0020c0        	memw
40377381:	1198      	l32i.n	a9, a1, 4
40377383:	0020c0        	memw
40377386:	8899      	s32i.n	a9, a8, 32
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
40377388:	e0c392        	addi	a9, a3, -32
4037738b:	0020c0        	memw
4037738e:	f8a8      	l32i.n	a10, a8, 60
40377390:	40f990        	nsau	a9, a9
40377393:	419590        	srli	a9, a9, 5
40377396:	999a      	add.n	a9, a9, a9
40377398:	db7c      	movi.n	a11, -3
4037739a:	10aab0        	and	a10, a10, a11
4037739d:	209a90        	or	a9, a10, a9
403773a0:	0020c0        	memw
403773a3:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
403773a5:	a30b      	addi.n	a10, a3, -1
403773a7:	0020c0        	memw
403773aa:	7898      	l32i.n	a9, a8, 28
403773ac:	01aa60        	slli	a10, a10, 26
403773af:	1199a0        	slli	a9, a9, 6
403773b2:	419690        	srli	a9, a9, 6
403773b5:	2099a0        	or	a9, a9, a10
403773b8:	0020c0        	memw
403773bb:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
403773bd:	0020c0        	memw
403773c0:	6898      	l32i.n	a9, a8, 24
403773c2:	1a0c      	movi.n	a10, 1
403773c4:	83a330        	moveqz	a10, a3, a3
403773c7:	01aa20        	slli	a10, a10, 30
403773ca:	f508b1        	l32r	a11, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
403773cd:	1099b0        	and	a9, a9, a11
403773d0:	2099a0        	or	a9, a9, a10
403773d3:	0020c0        	memw
403773d6:	6899      	s32i.n	a9, a8, 24
    dev->addr = addr;
403773d8:	0020c0        	memw
403773db:	1849      	s32i.n	a4, a8, 4
    spi_flash_ll_set_command(&SPIMEM_LL_APB, command, 8);
    //addr phase
    spi_flash_ll_set_addr_bitlen(&SPIMEM_LL_APB, addr_len);
    spi_flash_ll_set_usr_address(&SPIMEM_LL_APB, address, addr_len);
    //dummy phase
    uint32_t total_dummy = dummy_len;
403773dd:	058d      	mov.n	a8, a5
    if (miso_len > 0) {
403773df:	928c      	beqz.n	a2, 403773ec <bootloader_flash_execute_command_common+0x134>
        total_dummy += g_rom_spiflash_dummy_len_plus[1];
403773e1:	f50381        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
403773e4:	0888      	l32i.n	a8, a8, 0
403773e6:	190882        	l8ui	a8, a8, 25
403773e9:	808580        	add	a8, a5, a8
    dev->user.usr_dummy = dummy_n ? 1 : 0;
403773ec:	f4fdb1        	l32r	a11, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403773ef:	0020c0        	memw
403773f2:	6b98      	l32i.n	a9, a11, 24
403773f4:	1a0c      	movi.n	a10, 1
403773f6:	83a880        	moveqz	a10, a8, a8
403773f9:	01aa30        	slli	a10, a10, 29
403773fc:	f4fec1        	l32r	a12, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
403773ff:	1099c0        	and	a9, a9, a12
40377402:	2099a0        	or	a9, a9, a10
40377405:	0020c0        	memw
40377408:	6b99      	s32i.n	a9, a11, 24
    if (dummy_n > 0) {
4037740a:	a89c      	beqz.n	a8, 40377428 <bootloader_flash_execute_command_common+0x170>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037740c:	880b      	addi.n	a8, a8, -1
4037740e:	0bad      	mov.n	a10, a11
40377410:	0020c0        	memw
40377413:	072b92        	l32i	a9, a11, 28
40377416:	548080        	extui	a8, a8, 0, 6
40377419:	c0afb2        	movi	a11, -64
4037741c:	1099b0        	and	a9, a9, a11
4037741f:	208980        	or	a8, a9, a8
40377422:	0020c0        	memw
40377425:	076a82        	s32i	a8, a10, 28
    dev->user.usr_mosi = bitlen > 0;
40377428:	f4eea1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037742b:	0020c0        	memw
4037742e:	6a88      	l32i.n	a8, a10, 24
40377430:	190c      	movi.n	a9, 1
40377432:	839660        	moveqz	a9, a6, a6
40377435:	019950        	slli	a9, a9, 27
40377438:	f4f0b1        	l32r	a11, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037743b:	1088b0        	and	a8, a8, a11
4037743e:	208890        	or	a8, a8, a9
40377441:	0020c0        	memw
40377444:	6a89      	s32i.n	a8, a10, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
40377446:	668c      	beqz.n	a6, 40377450 <bootloader_flash_execute_command_common+0x198>
40377448:	860b      	addi.n	a8, a6, -1
4037744a:	948080        	extui	a8, a8, 0, 10
4037744d:	000046        	j	40377452 <bootloader_flash_execute_command_common+0x19a>
40377450:	080c      	movi.n	a8, 0
40377452:	f4e3a1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
40377455:	0020c0        	memw
40377458:	9a98      	l32i.n	a9, a10, 36
4037745a:	00acb2        	movi	a11, 0xfffffc00
4037745d:	1099b0        	and	a9, a9, a11
40377460:	208890        	or	a8, a8, a9
40377463:	0020c0        	memw
40377466:	9a89      	s32i.n	a8, a10, 36
    }
    spi_flash_ll_set_dummy(&SPIMEM_LL_APB, total_dummy);
    //output data

    spi_flash_ll_set_mosi_bitlen(&SPIMEM_LL_APB, mosi_len);
    spi_flash_ll_set_buffer_data(&SPIMEM_LL_APB, &mosi_data, mosi_len / 8);
40377468:	416360        	srli	a6, a6, 3
    int num_words = (length + 3) / 4;
4037746b:	363b      	addi.n	a3, a6, 3
4037746d:	413230        	srli	a3, a3, 2
    for (int i = 0; i < num_words; i++) {
40377470:	050c      	movi.n	a5, 0
40377472:	10c142        	addi	a4, a1, 16
40377475:	000ac6        	j	403774a4 <bootloader_flash_execute_command_common+0x1ec>
        uint32_t word = 0;
40377478:	080c      	movi.n	a8, 0
4037747a:	3189      	s32i.n	a8, a1, 12
        uint32_t word_len = MIN(length, sizeof(word));
4037747c:	470c      	movi.n	a7, 4
4037747e:	637670        	minu	a7, a6, a7
        memcpy(&word, buffer, word_len);
40377481:	07cd      	mov.n	a12, a7
40377483:	04bd      	mov.n	a11, a4
40377485:	a1cb      	addi.n	a10, a1, 12
40377487:	f41381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037748a:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037748d:	14c582        	addi	a8, a5, 20
40377490:	f4d491        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
40377493:	a08890        	addx4	a8, a8, a9
40377496:	3198      	l32i.n	a9, a1, 12
40377498:	0020c0        	memw
4037749b:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037749d:	c06670        	sub	a6, a6, a7
        buffer = (void *)((intptr_t)buffer + word_len);
403774a0:	474a      	add.n	a4, a7, a4
    for (int i = 0; i < num_words; i++) {
403774a2:	551b      	addi.n	a5, a5, 1
403774a4:	d02537        	blt	a5, a3, 40377478 <bootloader_flash_execute_command_common+0x1c0>
    dev->user.usr_miso = bitlen > 0;
403774a7:	f4cea1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403774aa:	0020c0        	memw
403774ad:	6a88      	l32i.n	a8, a10, 24
403774af:	190c      	movi.n	a9, 1
403774b1:	839220        	moveqz	a9, a2, a2
403774b4:	019940        	slli	a9, a9, 28
403774b7:	f4d1b1        	l32r	a11, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
403774ba:	1088b0        	and	a8, a8, a11
403774bd:	208890        	or	a8, a8, a9
403774c0:	0020c0        	memw
403774c3:	6a89      	s32i.n	a8, a10, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
403774c5:	628c      	beqz.n	a2, 403774cf <bootloader_flash_execute_command_common+0x217>
403774c7:	920b      	addi.n	a9, a2, -1
403774c9:	949090        	extui	a9, a9, 0, 10
403774cc:	000046        	j	403774d1 <bootloader_flash_execute_command_common+0x219>
403774cf:	090c      	movi.n	a9, 0
403774d1:	f4c381        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403774d4:	0020c0        	memw
403774d7:	a8a8      	l32i.n	a10, a8, 40
403774d9:	00acb2        	movi	a11, 0xfffffc00
403774dc:	10aab0        	and	a10, a10, a11
403774df:	2099a0        	or	a9, a9, a10
403774e2:	0020c0        	memw
403774e5:	a899      	s32i.n	a9, a8, 40
    dev->cmd.val |= usr_pe;
403774e7:	0020c0        	memw
403774ea:	0898      	l32i.n	a9, a8, 0
403774ec:	f4c5a1        	l32r	a10, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
403774ef:	2099a0        	or	a9, a9, a10
403774f2:	0020c0        	memw
403774f5:	006892        	s32i	a9, a8, 0
    return (dev->cmd.val == 0);
403774f8:	f4ba81        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403774fb:	0020c0        	memw
403774fe:	0878      	l32i.n	a7, a8, 0
    //input data
    spi_flash_ll_set_miso_bitlen(&SPIMEM_LL_APB, miso_len);

    spi_flash_ll_user_start(&SPIMEM_LL_APB, false);
    while(!spi_flash_ll_cmd_is_done(&SPIMEM_LL_APB)) {
40377500:	ff4756        	bnez	a7, 403774f8 <bootloader_flash_execute_command_common+0x240>
 * @param user1_reg user1_reg
 * @param user2_reg user2_reg
 */
static inline void spimem_flash_ll_set_common_command_register_info(spi_mem_dev_t *dev, uint32_t ctrl_reg, uint32_t user_reg, uint32_t user1_reg, uint32_t user2_reg)
{
    dev->ctrl.val = ctrl_reg;
40377503:	5198      	l32i.n	a9, a1, 20
40377505:	0020c0        	memw
40377508:	2899      	s32i.n	a9, a8, 8
    dev->user.val = user_reg;
4037750a:	6198      	l32i.n	a9, a1, 24
4037750c:	0020c0        	memw
4037750f:	6899      	s32i.n	a9, a8, 24
    dev->user1.val = user1_reg;
40377511:	7198      	l32i.n	a9, a1, 28
40377513:	0020c0        	memw
40377516:	7899      	s32i.n	a9, a8, 28
    dev->user2.val = user2_reg;
40377518:	8198      	l32i.n	a9, a1, 32
4037751a:	0020c0        	memw
4037751d:	8899      	s32i.n	a9, a8, 32
    }
    spi_flash_ll_set_common_command_register_info(&SPIMEM_LL_APB, old_ctrl_reg, old_user_reg, old_user1_reg, old_user2_reg);

    uint32_t output_data = 0;
4037751f:	080c      	movi.n	a8, 0
40377521:	0189      	s32i.n	a8, a1, 0
    spi_flash_ll_get_buffer_data(&SPIMEM_LL_APB, &output_data, miso_len / 8);
40377523:	413320        	srli	a3, a2, 3
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
40377526:	148320        	extui	a8, a2, 3, 2
40377529:	f8cc      	bnez.n	a8, 4037753c <bootloader_flash_execute_command_common+0x284>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037752b:	03cd      	mov.n	a12, a3
4037752d:	f4b5b1        	l32r	a11, 40374804 <_iram_text_start+0x400> (60002058 <SPIMEM1+0x58>)
40377530:	01ad      	mov.n	a10, a1
40377532:	f3e881        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40377535:	0008e0        	callx8	a8
40377538:	000e06        	j	40377574 <bootloader_flash_execute_command_common+0x2bc>
4037753b:	034d00        	lsi	f0, a13, 12
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037753e:	015d      	mov.n	a5, a1
40377540:	000a06        	j	4037756c <bootloader_flash_execute_command_common+0x2b4>
40377543:	460c00        	lsi	f0, a12, 0x118
            int word_len = MIN(sizeof(uint32_t), copy_len);
40377546:	636460        	minu	a6, a4, a6
            uint32_t word = dev->data_buf[i];
40377549:	14c782        	addi	a8, a7, 20
4037754c:	f4a591        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037754f:	a08890        	addx4	a8, a8, a9
40377552:	0020c0        	memw
40377555:	2888      	l32i.n	a8, a8, 8
40377557:	3189      	s32i.n	a8, a1, 12
            memcpy(buffer, &word, word_len);
40377559:	06cd      	mov.n	a12, a6
4037755b:	b1cb      	addi.n	a11, a1, 12
4037755d:	05ad      	mov.n	a10, a5
4037755f:	f3dd81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40377562:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
40377565:	565a      	add.n	a5, a6, a5
            copy_len -= word_len;
40377567:	c04460        	sub	a4, a4, a6
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037756a:	771b      	addi.n	a7, a7, 1
4037756c:	833b      	addi.n	a8, a3, 3
4037756e:	418280        	srli	a8, a8, 2
40377571:	cf3787        	bltu	a7, a8, 40377544 <bootloader_flash_execute_command_common+0x28c>
    uint32_t ret = output_data;
40377574:	0188      	l32i.n	a8, a1, 0
    if (miso_len < 32) {
40377576:	f91c      	movi.n	a9, 31
40377578:	0d3927        	bltu	a9, a2, 40377589 <bootloader_flash_execute_command_common+0x2d1>
        //set unused bits to 0
        ret &= ~(UINT32_MAX << miso_len);
4037757b:	f97c      	movi.n	a9, -1
4037757d:	401200        	ssl	a2
40377580:	a19900        	sll	a9, a9
40377583:	109980        	and	a9, a9, a8
40377586:	308980        	xor	a8, a9, a8
    }
    return ret;
}
40377589:	082d      	mov.n	a2, a8
4037758b:	f01d      	retw.n
4037758d:	000000        	ill

40377590 <bootloader_execute_flash_command>:

uint32_t IRAM_ATTR bootloader_execute_flash_command(uint8_t command, uint32_t mosi_data, uint8_t mosi_len, uint8_t miso_len)
{
40377590:	006136        	entry	a1, 48
40377593:	20f330        	or	a15, a3, a3
40377596:	745050        	extui	a5, a5, 0, 8
    const uint8_t addr_len = 0;
    const uint8_t address = 0;
    const uint8_t dummy_len = 0;

    return bootloader_flash_execute_command_common(command, addr_len, address,
40377599:	006152        	s32i	a5, a1, 0
4037759c:	74e040        	extui	a14, a4, 0, 8
4037759f:	00a0d2        	movi	a13, 0
403775a2:	0dcd      	mov.n	a12, a13
403775a4:	0dbd      	mov.n	a11, a13
403775a6:	74a020        	extui	a10, a2, 0, 8
403775a9:	ffd0e5        	call8	403772b8 <bootloader_flash_execute_command_common>
            dummy_len, mosi_len, mosi_data, miso_len);
}
403775ac:	0a2d      	mov.n	a2, a10
403775ae:	f01d      	retw.n

403775b0 <bootloader_read_flash_id>:
{
    bootloader_execute_flash_command(CMD_WRDI, 0, 0, 0);   /* Exit OTP mode */
}

uint32_t IRAM_ATTR bootloader_read_flash_id(void)
{
403775b0:	004136        	entry	a1, 32
    uint32_t id = bootloader_execute_flash_command(CMD_RDID, 0, 0, 24);
403775b3:	8d1c      	movi.n	a13, 24
403775b5:	0c0c      	movi.n	a12, 0
403775b7:	20bcc0        	or	a11, a12, a12
403775ba:	9fa0a2        	movi	a10, 159
403775bd:	fffd25        	call8	40377590 <bootloader_execute_flash_command>
    id = ((id & 0xff) << 16) | ((id >> 16) & 0xff) | (id & 0xff00);
403775c0:	112a00        	slli	a2, a10, 16
403775c3:	752020        	extui	a2, a2, 16, 8
403775c6:	112200        	slli	a2, a2, 16
403775c9:	7580a0        	extui	a8, a10, 16, 8
403775cc:	202280        	or	a2, a2, a8
403775cf:	74a8a0        	extui	a10, a10, 8, 8
403775d2:	11aa80        	slli	a10, a10, 8
    return id;
}
403775d5:	2022a0        	or	a2, a2, a10
403775d8:	f01d      	retw.n
	...

403775dc <bootloader_flash_reset_chip>:
}

#endif //XMC_SUPPORT

esp_err_t IRAM_ATTR bootloader_flash_reset_chip(void)
{
403775dc:	004136        	entry	a1, 32
    SPIMEM1.ctrl2.sync_reset = 0;
403775df:	f48071        	l32r	a7, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403775e2:	0020c0        	memw
403775e5:	0427a2        	l32i	a10, a7, 16
403775e8:	f48881        	l32r	a8, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
403775eb:	109a80        	and	a9, a10, a8
403775ee:	0020c0        	memw
403775f1:	4799      	s32i.n	a9, a7, 16
    SPIMEM0.ctrl2.sync_reset = 0;
403775f3:	f48691        	l32r	a9, 4037480c <_iram_text_start+0x408> (60003000 <SPIMEM0>)
403775f6:	0020c0        	memw
403775f9:	49b8      	l32i.n	a11, a9, 16
403775fb:	10ab80        	and	a10, a11, a8
403775fe:	0020c0        	memw
40377601:	49a9      	s32i.n	a10, a9, 16
    SPIMEM1.ctrl2.sync_reset = 1;
40377603:	0020c0        	memw
40377606:	47c8      	l32i.n	a12, a7, 16
40377608:	f3c5a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037760b:	20bca0        	or	a11, a12, a10
4037760e:	0020c0        	memw
40377611:	47b9      	s32i.n	a11, a7, 16
    SPIMEM0.ctrl2.sync_reset = 1;
40377613:	0020c0        	memw
40377616:	49b8      	l32i.n	a11, a9, 16
40377618:	20aba0        	or	a10, a11, a10
4037761b:	0020c0        	memw
4037761e:	49a9      	s32i.n	a10, a9, 16
    SPIMEM1.ctrl2.sync_reset = 0;
40377620:	0020c0        	memw
40377623:	47b8      	l32i.n	a11, a7, 16
40377625:	10ab80        	and	a10, a11, a8
40377628:	0020c0        	memw
4037762b:	47a9      	s32i.n	a10, a7, 16
    SPIMEM0.ctrl2.sync_reset = 0;
4037762d:	0020c0        	memw
40377630:	49a8      	l32i.n	a10, a9, 16
40377632:	108a80        	and	a8, a10, a8
40377635:	0020c0        	memw
40377638:	4989      	s32i.n	a8, a9, 16
    spi_flash_ll_sync_reset();
    // Seems that sync_reset cannot make host totally idle.'
    // Sending an extra(useless) command to make the host idle in order to send reset command.
    bootloader_execute_flash_command(0x05, 0, 0, 0);
4037763a:	0d0c      	movi.n	a13, 0
4037763c:	0dcd      	mov.n	a12, a13
4037763e:	20bdd0        	or	a11, a13, a13
40377641:	5a0c      	movi.n	a10, 5
40377643:	fff4e5        	call8	40377590 <bootloader_execute_flash_command>
    return dev->cmd.val == 0;
40377646:	0020c0        	memw
40377649:	0788      	l32i.n	a8, a7, 0
#if CONFIG_IDF_TARGET_ESP32
    if (SPI1.ext2.st != 0)
#else
    if (!spimem_flash_ll_host_idle(&SPIMEM1))
4037764b:	b8dc      	bnez.n	a8, 4037766a <bootloader_flash_reset_chip+0x8e>
#endif
    {
        return ESP_FAIL;
    }
    bootloader_execute_flash_command(0x66, 0, 0, 0);
4037764d:	0d0c      	movi.n	a13, 0
4037764f:	0dcd      	mov.n	a12, a13
40377651:	0dbd      	mov.n	a11, a13
40377653:	66a0a2        	movi	a10, 102
40377656:	fff3a5        	call8	40377590 <bootloader_execute_flash_command>
    bootloader_execute_flash_command(0x99, 0, 0, 0);
40377659:	0d0c      	movi.n	a13, 0
4037765b:	0dcd      	mov.n	a12, a13
4037765d:	0dbd      	mov.n	a11, a13
4037765f:	99a0a2        	movi	a10, 153
40377662:	fff2e5        	call8	40377590 <bootloader_execute_flash_command>

    return ESP_OK;
40377665:	020c      	movi.n	a2, 0
40377667:	000046        	j	4037766c <bootloader_flash_reset_chip+0x90>
        return ESP_FAIL;
4037766a:	f27c      	movi.n	a2, -1
}
4037766c:	f01d      	retw.n
	...

40377670 <bootloader_flash_is_octal_mode_enabled>:

bool IRAM_ATTR bootloader_flash_is_octal_mode_enabled(void)
{
40377670:	004136        	entry	a1, 32
    return EFUSE.rd_repeat_data3.flash_type;
40377673:	f3f881        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40377676:	0020c0        	memw
40377679:	f828      	l32i.n	a2, a8, 60
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    return efuse_ll_get_flash_type();
#else
    return false;
#endif
}
4037767b:	042920        	extui	a2, a2, 9, 1
4037767e:	f01d      	retw.n

40377680 <esp_flash_encryption_enabled>:
 * would require the caller component to include `efuse` as part of its `REQUIRES` or
 * `PRIV_REQUIRES` entries.
 * Attribute IRAM_ATTR must be specified for the app build.
 */
bool IRAM_ATTR esp_flash_encryption_enabled(void)
{
40377680:	004136        	entry	a1, 32
#ifndef CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
    return efuse_hal_flash_encryption_enabled();
40377683:	fe7a25        	call8	40375e24 <efuse_hal_flash_encryption_enabled>
        }
        flash_crypt_cnt >>= 1;
    }
    return enabled;
#endif // CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
}
40377686:	0a2d      	mov.n	a2, a10
40377688:	f01d      	retw.n
	...

4037768c <s_do_cache_invalidate>:
    *out_caps = found_block->caps;
    return ESP_OK;
}

static void IRAM_ATTR NOINLINE_ATTR s_do_cache_invalidate(uint32_t vaddr_start, uint32_t size)
{
4037768c:	004136        	entry	a1, 32
4037768f:	20a220        	or	a10, a2, a2
40377692:	20b330        	or	a11, a3, a3
     * easy way to sync between cache and external memory wrt
     * certain range. So we do a full sync here
     */
    cache_sync();
#else   //Other chips
    cache_hal_invalidate_addr(vaddr_start, size);
40377695:	054ee5        	call8	4037cb84 <cache_hal_invalidate_addr>
#endif // CONFIG_IDF_TARGET_ESP32
}
40377698:	000090        	retw
	...

4037769c <s_do_mapping>:
    return actual_mapped_len;
}
#endif

static void IRAM_ATTR NOINLINE_ATTR s_do_mapping(mmu_target_t target, uint32_t vaddr_start, esp_paddr_t paddr_start, uint32_t size)
{
4037769c:	006136        	entry	a1, 48
    /**
     * Disable Cache, after this function, involved code and data should be placed in internal RAM.
     *
     * @note we call this for now, but this will be refactored to move out of `spi_flash`
     */
    spi_flash_disable_interrupts_caches_and_other_cpu();
4037769f:	002025        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
    uint32_t actual_mapped_len = 0;
403776a2:	00a0a2        	movi	a10, 0
403776a5:	01a9      	s32i.n	a10, a1, 0
    mmu_hal_map_region(0, target, vaddr_start, paddr_start, size, &actual_mapped_len);
403776a7:	01fd      	mov.n	a15, a1
403776a9:	05ed      	mov.n	a14, a5
403776ab:	04dd      	mov.n	a13, a4
403776ad:	03cd      	mov.n	a12, a3
403776af:	02bd      	mov.n	a11, a2
403776b1:	057465        	call8	4037cdf8 <mmu_hal_map_region>
    uint32_t vaddr_end = vaddr_start + len - 1;
403776b4:	a35a      	add.n	a10, a3, a5
403776b6:	aa0b      	addi.n	a10, a10, -1
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
403776b8:	f45691        	l32r	a9, 40374810 <_iram_text_start+0x40c> (41ffffff <_coredump_iram_end+0x1c7dfff>)
403776bb:	629930        	lsi	f3, a9, 0x188
403776be:	f45581        	l32r	a8, 40374814 <_iram_text_start+0x410> (43ffffff <_etext+0x1fe8dc1>)
403776c1:	6288a0        	lsi	f10, a8, 0x188
403776c4:	880b      	addi.n	a8, a8, -1
403776c6:	608080        	neg	a8, a8
403776c9:	10b890        	and	a11, a8, a9
403776cc:	228897        	bany	a8, a9, 403776f2 <s_do_mapping+0x56>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
403776cf:	f45291        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
403776d2:	629930        	lsi	f3, a9, 0x188
403776d5:	f45181        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd5ac3>)
403776d8:	6288a0        	lsi	f10, a8, 0x188
403776db:	880b      	addi.n	a8, a8, -1
403776dd:	608080        	neg	a8, a8
403776e0:	148897        	bany	a8, a9, 403776f8 <s_do_mapping+0x5c>
        HAL_ASSERT(0);      //Out of region
403776e3:	f44fd1        	l32r	a13, 40374820 <_iram_text_start+0x41c> (3c024598 <_flash_rodata_start+0x4478>)
403776e6:	f44fc1        	l32r	a12, 40374824 <_iram_text_start+0x420> (3c02891c <__func__$9>)
403776e9:	3aa2b2        	movi	a11, 0x23a
403776ec:	f44fa1        	l32r	a10, 40374828 <_iram_text_start+0x424> (3c020480 <_flash_rodata_start+0x360>)
403776ef:	086b25        	call8	4037fda0 <__assert_func>
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_IBUS0);    //Both cores have their own IBUS0
403776f2:	180c      	movi.n	a8, 1
403776f4:	0000c6        	j	403776fb <s_do_mapping+0x5f>
403776f7:	a08200        	addx4	a8, a2, a0
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_DBUS0);    //Both cores have their own DBUS0
403776fa:	8008      	l32i.n	a0, a0, 32
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE0_BUS : 0);
403776fc:	c10490        	mul16u	a0, a4, a9
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
403776ff:	4e          	.byte	0x4e
40377700:	20c0f3        	ssip	f15, a0, 128
40377703:	0cd800        	lsi	f0, a8, 48
40377706:	1099d0        	and	a9, a9, a13
40377709:	3099d0        	xor	a9, a9, a13
4037770c:	0020c0        	memw
4037770f:	0c99      	s32i.n	a9, a12, 0
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE1_BUS : 0);
40377711:	419280        	srli	a9, a8, 2
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
40377714:	f34ac1        	l32r	a12, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
40377717:	0020c0        	memw
4037771a:	0cd8      	l32i.n	a13, a12, 0
4037771c:	1099d0        	and	a9, a9, a13
4037771f:	3099d0        	xor	a9, a9, a13
40377722:	0020c0        	memw
40377725:	0c99      	s32i.n	a9, a12, 0
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
40377727:	1bec      	bnez.n	a11, 4037774c <s_do_mapping+0xb0>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
40377729:	f43bb1        	l32r	a11, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037772c:	62bb30        	lsi	f3, a11, 0x188
4037772f:	f43b91        	l32r	a9, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd5ac3>)
40377732:	6299a0        	lsi	f10, a9, 0x188
40377735:	990b      	addi.n	a9, a9, -1
40377737:	609090        	neg	a9, a9
4037773a:	0e89b7        	bany	a9, a11, 4037774c <s_do_mapping+0xb0>
        HAL_ASSERT(0);      //Out of region
4037773d:	f438d1        	l32r	a13, 40374820 <_iram_text_start+0x41c> (3c024598 <_flash_rodata_start+0x4478>)
40377740:	f439c1        	l32r	a12, 40374824 <_iram_text_start+0x420> (3c02891c <__func__$9>)
40377743:	3aa2b2        	movi	a11, 0x23a
40377746:	f438a1        	l32r	a10, 40374828 <_iram_text_start+0x424> (3c020480 <_flash_rodata_start+0x360>)
40377749:	086565        	call8	4037fda0 <__assert_func>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE1_BUS : 0);
4037774c:	988a      	add.n	a9, a8, a8
4037774e:	2a0c      	movi.n	a10, 2
40377750:	1099a0        	and	a9, a9, a10
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
40377753:	f339a1        	l32r	a10, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
40377756:	0020c0        	memw
40377759:	0ab8      	l32i.n	a11, a10, 0
4037775b:	1099b0        	and	a9, a9, a11
4037775e:	3099b0        	xor	a9, a9, a11
40377761:	0020c0        	memw
40377764:	0a99      	s32i.n	a9, a10, 0
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE0_BUS : 0);
40377766:	418380        	srli	a8, a8, 3
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
40377769:	f33491        	l32r	a9, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
4037776c:	0020c0        	memw
4037776f:	09a8      	l32i.n	a10, a9, 0
40377771:	1088a0        	and	a8, a8, a10
40377774:	3088a0        	xor	a8, a8, a10
40377777:	0020c0        	memw
4037777a:	0989      	s32i.n	a8, a9, 0
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    bus_mask = cache_ll_l1_get_bus(0, vaddr_start, size);
    cache_ll_l1_enable_bus(1, bus_mask);
#endif

    s_do_cache_invalidate(vaddr_start, size);
4037777c:	05bd      	mov.n	a11, a5
4037777e:	03ad      	mov.n	a10, a3
40377780:	fff0a5        	call8	4037768c <s_do_cache_invalidate>

    //enable Cache, after this function, internal RAM access is no longer mandatory
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377783:	002465        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>

    ESP_EARLY_LOGV(TAG, "actual_mapped_len is 0x%"PRIx32, actual_mapped_len);
}
40377786:	f01d      	retw.n

40377788 <s_do_unmapping>:
#endif //  #if (SOC_MMU_PERIPH_NUM == 2)
}
#endif

static void IRAM_ATTR NOINLINE_ATTR s_do_unmapping(uint32_t vaddr_start, uint32_t size)
{
40377788:	004136        	entry	a1, 32
    /**
     * Disable Cache, after this function, involved code and data should be placed in internal RAM.
     *
     * @note we call this for now, but this will be refactored to move out of `spi_flash`
     */
    spi_flash_disable_interrupts_caches_and_other_cpu();
4037778b:	001165        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
    mmu_hal_unmap_region(0, vaddr_start, size);
4037778e:	20c330        	or	a12, a3, a3
40377791:	02bd      	mov.n	a11, a2
40377793:	0a0c      	movi.n	a10, 0
40377795:	0571e5        	call8	4037ceb4 <mmu_hal_unmap_region>

    s_unmapping_operation(vaddr_start, size);

    //enable Cache, after this function, internal RAM access is no longer mandatory
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377798:	0022e5        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>
}
4037779b:	f01d      	retw.n
4037779d:	000000        	ill

403777a0 <s_vaddr_to_paddr>:

/*---------------------------------------------------------------
    Helper APIs for conversion between vaddr and paddr
---------------------------------------------------------------*/
static bool NOINLINE_ATTR IRAM_ATTR s_vaddr_to_paddr(uint32_t vaddr, esp_paddr_t *out_paddr, mmu_target_t *out_target)
{
403777a0:	004136        	entry	a1, 32
    //we call this for now, but this will be refactored to move out of `spi_flash`
    spi_flash_disable_interrupts_caches_and_other_cpu();
403777a3:	000fe5        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
    bool is_mapped = mmu_hal_vaddr_to_paddr(0, vaddr, out_paddr, out_target);
403777a6:	20d440        	or	a13, a4, a4
403777a9:	03cd      	mov.n	a12, a3
403777ab:	02bd      	mov.n	a11, a2
403777ad:	00a0a2        	movi	a10, 0
403777b0:	0576a5        	call8	4037cf1c <mmu_hal_vaddr_to_paddr>
403777b3:	0a2d      	mov.n	a2, a10
#if SOC_MMU_PER_EXT_MEM_TARGET
    if (!is_mapped) {
        is_mapped = mmu_hal_vaddr_to_paddr(1, vaddr, out_paddr, out_target);
    }
#endif
    spi_flash_enable_interrupts_caches_and_other_cpu();
403777b5:	002125        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>

    return is_mapped;
}
403777b8:	f01d      	retw.n
	...

403777bc <esp_mmu_paddr_find_caps>:
{
403777bc:	004136        	entry	a1, 32
    if (out_caps == NULL) {
403777bf:	055316        	beqz	a3, 40377818 <esp_mmu_paddr_find_caps+0x5c>
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
403777c2:	0a0c      	movi.n	a10, 0
    mem_block_t *found_block = NULL;
403777c4:	0aed      	mov.n	a14, a10
    bool found = false;
403777c6:	0add      	mov.n	a13, a10
403777c8:	000e06        	j	40377804 <esp_mmu_paddr_find_caps+0x48>
403777cb:	8aa000        	round.s	a10, f0, 0
        TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
403777ce:	1791a0        	lsi	f10, a1, 92
403777d1:	8890f4        	lsi	f15, a0, 0x220
403777d4:	98c8b0        	lsi	f11, a8, 0x260
403777d7:	0c8d      	mov.n	a8, a12
403777d9:	0006c6        	j	403777f8 <esp_mmu_paddr_find_caps+0x3c>
            if (mem_block == TAILQ_FIRST(&region->mem_block_head) || mem_block == TAILQ_LAST(&region->mem_block_head, mem_block_head_)) {
403777dc:	1618c7        	beq	a8, a12, 403777f6 <esp_mmu_paddr_find_caps+0x3a>
403777df:	a09aa0        	addx4	a9, a10, a10
403777e2:	f412b1        	l32r	a11, 4037482c <_iram_text_start+0x428> (3fc950c8 <s_mmu_ctx>)
403777e5:	b099b0        	addx8	a9, a9, a11
403777e8:	a998      	l32i.n	a9, a9, 40
403777ea:	1998      	l32i.n	a9, a9, 4
403777ec:	0998      	l32i.n	a9, a9, 0
403777ee:	041987        	beq	a9, a8, 403777f6 <esp_mmu_paddr_find_caps+0x3a>
            if (mem_block->paddr_start == paddr) {
403777f1:	6898      	l32i.n	a9, a8, 24
403777f3:	071927        	beq	a9, a2, 403777fe <esp_mmu_paddr_find_caps+0x42>
        TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
403777f6:	9888      	l32i.n	a8, a8, 36
403777f8:	fe0856        	bnez	a8, 403777dc <esp_mmu_paddr_find_caps+0x20>
403777fb:	0000c6        	j	40377802 <esp_mmu_paddr_find_caps+0x46>
                found_block = mem_block;
403777fe:	08ed      	mov.n	a14, a8
                found = true;
40377800:	1d0c      	movi.n	a13, 1
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
40377802:	aa1b      	addi.n	a10, a10, 1
40377804:	f40a81        	l32r	a8, 4037482c <_iram_text_start+0x428> (3fc950c8 <s_mmu_ctx>)
40377807:	0888      	l32i.n	a8, a8, 0
40377809:	bf3a87        	bltu	a10, a8, 403777cc <esp_mmu_paddr_find_caps+0x10>
    if (!found) {
4037780c:	0d9c      	beqz.n	a13, 40377820 <esp_mmu_paddr_find_caps+0x64>
    *out_caps = found_block->caps;
4037780e:	5e88      	l32i.n	a8, a14, 20
40377810:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40377812:	020c      	movi.n	a2, 0
40377814:	0002c6        	j	40377823 <esp_mmu_paddr_find_caps+0x67>
40377817:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4037781a:	010602        	l8ui	a0, a6, 1
4037781d:	000000        	ill
        return ESP_ERR_NOT_FOUND;
40377820:	05a122        	movi	a2, 0x105
}
40377823:	f01d      	retw.n
40377825:	000000        	ill

40377828 <esp_heap_adjust_alignment_to_hw>:
#endif

#define CAPS_NEEDING_ALIGNMENT (MALLOC_CAP_DMA|MALLOC_CAP_DMA_DESC_AHB|MALLOC_CAP_DMA_DESC_AXI|MALLOC_CAP_CACHE_ALIGNED)

HEAP_IRAM_ATTR void esp_heap_adjust_alignment_to_hw(size_t *p_alignment, size_t *p_size, uint32_t *p_caps)
{
40377828:	006136        	entry	a1, 48
    size_t size = *p_size;
4037782b:	002362        	l32i	a6, a3, 0
    size_t alignment = *p_alignment;
4037782e:	002252        	l32i	a5, a2, 0
    uint32_t caps = *p_caps;
40377831:	002472        	l32i	a7, a4, 0

    //Bail out early if we don't need alignment
    if (!(caps & CAPS_NEEDING_ALIGNMENT)) {
40377834:	f3ff81        	l32r	a8, 40374830 <_iram_text_start+0x42c> (e0008 <UserFrameTotalSize+0xdff08>)
40377837:	510787        	bnone	a7, a8, 4037788c <esp_heap_adjust_alignment_to_hw+0x64>
#endif
    return;
#endif

    //Ask cache driver what alignment is applicable here.
    size_t cache_alignment_bytes = 0;
4037783a:	080c      	movi.n	a8, 0
4037783c:	0189      	s32i.n	a8, a1, 0
    esp_err_t ret = esp_cache_get_alignment(caps, &cache_alignment_bytes);
4037783e:	01bd      	mov.n	a11, a1
40377840:	07ad      	mov.n	a10, a7
40377842:	01c6a5        	call8	403794ac <esp_cache_get_alignment>
    if (ret != ESP_OK) {
40377845:	ca8c      	beqz.n	a10, 40377855 <esp_heap_adjust_alignment_to_hw+0x2d>
        //This is not supposed to happen.
        *p_caps |= MALLOC_CAP_INVALID;
40377847:	0488      	l32i.n	a8, a4, 0
40377849:	f33491        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037784c:	208890        	or	a8, a8, a9
4037784f:	0489      	s32i.n	a8, a4, 0
        return;
40377851:	000dc6        	j	4037788c <esp_heap_adjust_alignment_to_hw+0x64>
40377854:	018800        	slli	a8, a8, 32
    // do this because:
    // - DMA alignment in current chips always is a power of two, and is unlikely to ever
    //   be something else,
    // - Requested alignment is checked by heap_caps_aligned_check_args to be a power
    //   of two.
    if (cache_alignment_bytes > alignment) {
40377857:	013587        	bltu	a5, a8, 4037785c <esp_heap_adjust_alignment_to_hw+0x34>
    size_t alignment = *p_alignment;
4037785a:	058d      	mov.n	a8, a5
        alignment = cache_alignment_bytes;
    }
    // Align up `size` to resulting alignment as well.
    size = (size + alignment - 1) & (~(alignment - 1));
4037785c:	686a      	add.n	a6, a8, a6
4037785e:	660b      	addi.n	a6, a6, -1
40377860:	609080        	neg	a9, a8
40377863:	106690        	and	a6, a6, a9

    // For the heap allocator itself, there's no difference between data and descriptor DMA; the regions
    // are only marked as DMA-capable.
    if (caps & (MALLOC_CAP_DMA_DESC_AHB | MALLOC_CAP_DMA_DESC_AXI)) {
40377866:	159170        	extui	a9, a7, 17, 2
40377869:	00b916        	beqz	a9, 40377878 <esp_heap_adjust_alignment_to_hw+0x50>
        caps &= ~(MALLOC_CAP_DMA_DESC_AHB | MALLOC_CAP_DMA_DESC_AXI);
4037786c:	f3f291        	l32r	a9, 40374834 <_iram_text_start+0x430> (fff9ffff <_rtc_reserved_end+0x9fe9ffff>)
4037786f:	109790        	and	a9, a7, a9
        caps |= MALLOC_CAP_DMA;
40377872:	08a072        	movi	a7, 8
40377875:	207970        	or	a7, a9, a7
    }

    // Workaround: the heap allocator doesn't have regions marked `MALLOC_CAP_DMA | MALLOC_CAP_SPIRAM`
    // so we need to request those without the DMA flag.
    if (caps & MALLOC_CAP_SPIRAM) {
40377878:	0467a7        	bbci	a7, 10, 40377880 <esp_heap_adjust_alignment_to_hw+0x58>
        caps &= ~MALLOC_CAP_DMA;
4037787b:	797c      	movi.n	a9, -9
4037787d:	107790        	and	a7, a7, a9
        //memory, so the MALLOC_CAP_SPIRAM|MALLOC_CAP_DMA_DESC_* simply will not return any
        //usable memory.
    }
    // MALLOC_CAP_CACHE_ALIGNED is not a real flag the heap_base component will understand; it
    // only sets alignment (which we handled here)
    caps &= ~ MALLOC_CAP_CACHE_ALIGNED;
40377880:	f3ee91        	l32r	a9, 40374838 <_iram_text_start+0x434> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
40377883:	107790        	and	a7, a7, a9

    *p_size = size;
40377886:	0369      	s32i.n	a6, a3, 0
    *p_alignment = alignment;
40377888:	0289      	s32i.n	a8, a2, 0
    *p_caps = caps;
4037788a:	0479      	s32i.n	a7, a4, 0
}
4037788c:	f01d      	retw.n
	...

40377890 <spi_flash_disable_cache>:
    spi_flash_restore_cache(0, 0); // TODO cache_value should be non-zero
#endif
}

void IRAM_ATTR spi_flash_disable_cache(uint32_t cpuid, uint32_t *saved_state)
{
40377890:	004136        	entry	a1, 32
#if SOC_BRANCH_PREDICTOR_SUPPORTED
    //branch predictor will start cache request as well
    esp_cpu_branch_prediction_disable();
#endif
    cache_hal_suspend(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377893:	02a0b2        	movi	a11, 2
40377896:	01a0a2        	movi	a10, 1
40377899:	051865        	call8	4037ca20 <cache_hal_suspend>
}
4037789c:	000090        	retw
	...

403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>:
{
403778a0:	004136        	entry	a1, 32
    asm volatile ("mov %0, sp;" : "=r" (sp));
403778a3:	209110        	or	a9, a1, a1
    return ((intptr_t)p >= SOC_DRAM_LOW && (intptr_t)p < SOC_DRAM_HIGH);
403778a6:	f37781        	l32r	a8, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
403778a9:	808980        	add	a8, a9, a8
           || esp_ptr_in_rtc_dram_fast(sp)
403778ac:	f3e4a1        	l32r	a10, 4037483c <_iram_text_start+0x438> (77fff <UserFrameTotalSize+0x77eff>)
403778af:	1aba87        	bgeu	a10, a8, 403778cd <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403778b2:	f34e81        	l32r	a8, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403778b5:	809980        	add	a9, a9, a8
403778b8:	f34e81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403778bb:	0eb897        	bgeu	a8, a9, 403778cd <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    assert(esp_task_stack_is_sane_cache_disabled());
403778be:	f3e0d1        	l32r	a13, 40374840 <_iram_text_start+0x43c> (3c026320 <_flash_rodata_start+0x6200>)
403778c1:	f3e0c1        	l32r	a12, 40374844 <_iram_text_start+0x440> (3c0289a8 <__func__$1>)
403778c4:	86a0b2        	movi	a11, 134
403778c7:	f3e0a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c02630f <_flash_rodata_start+0x61ef>)
403778ca:	084d65        	call8	4037fda0 <__assert_func>
    spi_flash_op_lock();
403778cd:	f3e581        	l32r	a8, 40374864 <_iram_text_start+0x460> (42009e2c <spi_flash_op_lock>)
403778d0:	0008e0        	callx8	a8
    asm volatile (
403778d3:	03eb70        	rsr.prid	a7
403778d6:	047d70        	extui	a7, a7, 13, 1
    return (int)xt_utils_get_core_id();
403778d9:	076d      	mov.n	a6, a7
    assert(s_flash_op_cpu == -1);
403778db:	f3dc81        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9272c <s_flash_op_cpu>)
403778de:	0020c0        	memw
403778e1:	0888      	l32i.n	a8, a8, 0
403778e3:	0e0826        	beqi	a8, -1, 403778f5 <spi_flash_disable_interrupts_caches_and_other_cpu+0x55>
403778e6:	f3dad1        	l32r	a13, 40374850 <_iram_text_start+0x44c> (3c026348 <_flash_rodata_start+0x6228>)
403778e9:	f3d6c1        	l32r	a12, 40374844 <_iram_text_start+0x440> (3c0289a8 <__func__$1>)
403778ec:	8ea0b2        	movi	a11, 142
403778ef:	f3d6a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c02630f <_flash_rodata_start+0x61ef>)
403778f2:	084ae5        	call8	4037fda0 <__assert_func>
    s_flash_op_cpu = cpuid;
403778f5:	f3d581        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9272c <s_flash_op_cpu>)
403778f8:	0020c0        	memw
403778fb:	0879      	s32i.n	a7, a8, 0
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
403778fd:	0414a5        	call8	4037ba48 <xTaskGetSchedulerState>
40377900:	111a66        	bnei	a10, 1, 40377915 <spi_flash_disable_interrupts_caches_and_other_cpu+0x75>
        assert(other_cpuid == 1);
40377903:	058716        	beqz	a7, 4037795f <spi_flash_disable_interrupts_caches_and_other_cpu+0xbf>
40377906:	f3d3d1        	l32r	a13, 40374854 <_iram_text_start+0x450> (3c026360 <_flash_rodata_start+0x6240>)
40377909:	f3cec1        	l32r	a12, 40374844 <_iram_text_start+0x440> (3c0289a8 <__func__$1>)
4037790c:	98a0b2        	movi	a11, 152
4037790f:	f3cea1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c02630f <_flash_rodata_start+0x61ef>)
40377912:	0848e5        	call8	4037fda0 <__assert_func>
            vTaskSuspendAll();
40377915:	038925        	call8	4037b1a8 <vTaskSuspendAll>
40377918:	03eb80        	rsr.prid	a8
4037791b:	048d80        	extui	a8, a8, 13, 1
4037791e:	086d      	mov.n	a6, a8
            other_cpuid = (cpuid == 0) ? 1 : 0;
40377920:	40f8a0        	nsau	a10, a8
40377923:	41a5a0        	srli	a10, a10, 5
            s_flash_op_cpu = cpuid;
40377926:	f3c991        	l32r	a9, 4037484c <_iram_text_start+0x448> (3fc9272c <s_flash_op_cpu>)
40377929:	0020c0        	memw
4037792c:	006982        	s32i	a8, a9, 0
            s_flash_op_can_start = false;
4037792f:	090c      	movi.n	a9, 0
40377931:	f3c981        	l32r	a8, 40374858 <_iram_text_start+0x454> (3fc950f7 <s_flash_op_can_start>)
40377934:	0020c0        	memw
40377937:	004892        	s8i	a9, a8, 0
            ipc_call_was_send_to_other_cpu = esp_ipc_call_nonblocking(other_cpuid, &spi_flash_op_block_func, (void *) other_cpuid) == ESP_OK;
4037793a:	0acd      	mov.n	a12, a10
4037793c:	f3c8b1        	l32r	a11, 4037485c <_iram_text_start+0x458> (40377980 <spi_flash_op_block_func>)
4037793f:	f3ca81        	l32r	a8, 40374868 <_iram_text_start+0x464> (420026d4 <esp_ipc_call_nonblocking>)
40377942:	0008e0        	callx8	a8
40377945:	0a7d      	mov.n	a7, a10
            if (!ipc_call_was_send_to_other_cpu) {
40377947:	002a16        	beqz	a10, 4037794d <spi_flash_disable_interrupts_caches_and_other_cpu+0xad>
                xTaskResumeAll();
4037794a:	042665        	call8	4037bbb0 <xTaskResumeAll>
        } while (!ipc_call_was_send_to_other_cpu);
4037794d:	fc4756        	bnez	a7, 40377915 <spi_flash_disable_interrupts_caches_and_other_cpu+0x75>
        while (!s_flash_op_can_start) {
40377950:	f3c281        	l32r	a8, 40374858 <_iram_text_start+0x454> (3fc950f7 <s_flash_op_can_start>)
40377953:	0020c0        	memw
40377956:	000882        	l8ui	a8, a8, 0
40377959:	748080        	extui	a8, a8, 0, 8
4037795c:	ff0816        	beqz	a8, 40377950 <spi_flash_disable_interrupts_caches_and_other_cpu+0xb0>
    esp_intr_noniram_disable();
4037795f:	feb325        	call8	40376490 <esp_intr_noniram_disable>
    spi_flash_disable_cache(cpuid, &s_flash_op_cache_state[cpuid]);
40377962:	f3bfb1        	l32r	a11, 40374860 <_iram_text_start+0x45c> (3fc950fc <s_flash_op_cache_state>)
40377965:	a0b6b0        	addx4	a11, a6, a11
40377968:	06ad      	mov.n	a10, a6
4037796a:	fff265        	call8	40377890 <spi_flash_disable_cache>
}
4037796d:	f01d      	retw.n
	...

40377970 <spi_flash_restore_cache>:

void IRAM_ATTR spi_flash_restore_cache(uint32_t cpuid, uint32_t saved_state)
{
40377970:	004136        	entry	a1, 32
    cache_hal_resume(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377973:	02a0b2        	movi	a11, 2
40377976:	01a0a2        	movi	a10, 1
40377979:	050de5        	call8	4037ca58 <cache_hal_resume>
#if SOC_BRANCH_PREDICTOR_SUPPORTED
    esp_cpu_branch_prediction_enable();
#endif
}
4037797c:	000090        	retw
	...

40377980 <spi_flash_op_block_func>:
{
40377980:	004136        	entry	a1, 32
    vTaskSuspendAll();
40377983:	038265        	call8	4037b1a8 <vTaskSuspendAll>
    esp_intr_noniram_disable();
40377986:	feb0a5        	call8	40376490 <esp_intr_noniram_disable>
    s_flash_op_complete = false;
40377989:	f3b881        	l32r	a8, 4037486c <_iram_text_start+0x468> (3fc950f6 <s_flash_op_complete>)
4037798c:	00a092        	movi	a9, 0
4037798f:	0020c0        	memw
40377992:	004892        	s8i	a9, a8, 0
    s_flash_op_can_start = true;
40377995:	f3b081        	l32r	a8, 40374858 <_iram_text_start+0x454> (3fc950f7 <s_flash_op_can_start>)
40377998:	01a092        	movi	a9, 1
4037799b:	0020c0        	memw
4037799e:	004892        	s8i	a9, a8, 0
    while (!s_flash_op_complete) {
403779a1:	f3b281        	l32r	a8, 4037486c <_iram_text_start+0x468> (3fc950f6 <s_flash_op_complete>)
403779a4:	0020c0        	memw
403779a7:	000882        	l8ui	a8, a8, 0
403779aa:	748080        	extui	a8, a8, 0, 8
403779ad:	ff0816        	beqz	a8, 403779a1 <spi_flash_op_block_func+0x21>
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
403779b0:	f3ac81        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc950fc <s_flash_op_cache_state>)
403779b3:	a08280        	addx4	a8, a2, a8
403779b6:	0028b2        	l32i	a11, a8, 0
403779b9:	02ad      	mov.n	a10, a2
403779bb:	fffb65        	call8	40377970 <spi_flash_restore_cache>
    esp_intr_noniram_enable();
403779be:	feb465        	call8	40376504 <esp_intr_noniram_enable>
    xTaskResumeAll();
403779c1:	041ee5        	call8	4037bbb0 <xTaskResumeAll>
}
403779c4:	f01d      	retw.n
	...

403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>:
{
403779c8:	004136        	entry	a1, 32
403779cb:	03eb70        	rsr.prid	a7
403779ce:	047d70        	extui	a7, a7, 13, 1
    assert(cpuid == s_flash_op_cpu);
403779d1:	f39e81        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9272c <s_flash_op_cpu>)
403779d4:	0020c0        	memw
403779d7:	002882        	l32i	a8, a8, 0
403779da:	0e1877        	beq	a8, a7, 403779ec <spi_flash_enable_interrupts_caches_and_other_cpu+0x24>
403779dd:	f3a4d1        	l32r	a13, 40374870 <_iram_text_start+0x46c> (3c026374 <_flash_rodata_start+0x6254>)
403779e0:	f3a5c1        	l32r	a12, 40374874 <_iram_text_start+0x470> (3c028974 <__func__$0>)
403779e3:	d0a0b2        	movi	a11, 208
403779e6:	f398a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c02630f <_flash_rodata_start+0x61ef>)
403779e9:	083b65        	call8	4037fda0 <__assert_func>
    assert(!(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED && cpuid != 0));
403779ec:	0405a5        	call8	4037ba48 <xTaskGetSchedulerState>
403779ef:	111a66        	bnei	a10, 1, 40377a04 <spi_flash_enable_interrupts_caches_and_other_cpu+0x3c>
403779f2:	00e716        	beqz	a7, 40377a04 <spi_flash_enable_interrupts_caches_and_other_cpu+0x3c>
403779f5:	f3a0d1        	l32r	a13, 40374878 <_iram_text_start+0x474> (3c02638c <_flash_rodata_start+0x626c>)
403779f8:	f39fc1        	l32r	a12, 40374874 <_iram_text_start+0x470> (3c028974 <__func__$0>)
403779fb:	d2a0b2        	movi	a11, 210
403779fe:	f392a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c02630f <_flash_rodata_start+0x61ef>)
40377a01:	0839e5        	call8	4037fda0 <__assert_func>
    s_flash_op_cpu = -1;
40377a04:	f39281        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9272c <s_flash_op_cpu>)
40377a07:	f97c      	movi.n	a9, -1
40377a09:	0020c0        	memw
40377a0c:	0899      	s32i.n	a9, a8, 0
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
40377a0e:	f39481        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc950fc <s_flash_op_cache_state>)
40377a11:	a08780        	addx4	a8, a7, a8
40377a14:	08b8      	l32i.n	a11, a8, 0
40377a16:	07ad      	mov.n	a10, a7
40377a18:	fff565        	call8	40377970 <spi_flash_restore_cache>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
40377a1b:	0402e5        	call8	4037ba48 <xTaskGetSchedulerState>
40377a1e:	0a1a26        	beqi	a10, 1, 40377a2c <spi_flash_enable_interrupts_caches_and_other_cpu+0x64>
        s_flash_op_complete = true;
40377a21:	f39281        	l32r	a8, 4037486c <_iram_text_start+0x468> (3fc950f6 <s_flash_op_complete>)
40377a24:	190c      	movi.n	a9, 1
40377a26:	0020c0        	memw
40377a29:	004892        	s8i	a9, a8, 0
    esp_intr_noniram_enable();
40377a2c:	201110        	or	a1, a1, a1
40377a2f:	fead65        	call8	40376504 <esp_intr_noniram_enable>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
40377a32:	201110        	or	a1, a1, a1
40377a35:	040125        	call8	4037ba48 <xTaskGetSchedulerState>
40377a38:	051a26        	beqi	a10, 1, 40377a41 <spi_flash_enable_interrupts_caches_and_other_cpu+0x79>
        xTaskResumeAll();
40377a3b:	201110        	or	a1, a1, a1
40377a3e:	041725        	call8	4037bbb0 <xTaskResumeAll>
    spi_flash_op_unlock();
40377a41:	f38e81        	l32r	a8, 4037487c <_iram_text_start+0x478> (42009e40 <spi_flash_op_unlock>)
40377a44:	0008e0        	callx8	a8
}
40377a47:	f01d      	retw.n
40377a49:	000000        	ill

40377a4c <spi_flash_enable_cache>:
{
40377a4c:	004136        	entry	a1, 32
    spi_flash_restore_cache(0, 0); // TODO cache_value should be non-zero
40377a4f:	00a0b2        	movi	a11, 0
40377a52:	20abb0        	or	a10, a11, a11
40377a55:	fff1a5        	call8	40377970 <spi_flash_restore_cache>
}
40377a58:	000090        	retw
	...

40377a5c <spi_flash_cache_enabled>:

bool IRAM_ATTR spi_flash_cache_enabled(void)
{
40377a5c:	004136        	entry	a1, 32
    return cache_hal_is_cache_enabled(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377a5f:	02a0b2        	movi	a11, 2
40377a62:	01a0a2        	movi	a10, 1
40377a65:	0505e5        	call8	4037cac4 <cache_hal_is_cache_enabled>
}
40377a68:	202aa0        	or	a2, a10, a10
40377a6b:	f01d      	retw.n
40377a6d:	000000        	ill

40377a70 <is_page_mapped_in_cache>:
    esp_mmu_map_get_max_consecutive_free_block_size(caps, MMU_TARGET_FLASH0, &len);
    return len / CONFIG_MMU_PAGE_SIZE;
}

static bool IRAM_ATTR is_page_mapped_in_cache(uint32_t phys_addr, const void **out_ptr)
{
40377a70:	006136        	entry	a1, 48
    *out_ptr = NULL;
40377a73:	080c      	movi.n	a8, 0
40377a75:	0389      	s32i.n	a8, a3, 0
    mmu_mem_caps_t caps = 0;
40377a77:	0189      	s32i.n	a8, a1, 0

    esp_err_t err = esp_mmu_paddr_find_caps(phys_addr, &caps);
40377a79:	01bd      	mov.n	a11, a1
40377a7b:	02ad      	mov.n	a10, a2
40377a7d:	ffd3e5        	call8	403777bc <esp_mmu_paddr_find_caps>
    if (err == ESP_OK) {
40377a80:	1afc      	bnez.n	a10, 40377ab5 <is_page_mapped_in_cache+0x45>
    // On ESP32, we will always flush all, so always return true, and don't care the vaddr
#if !CONFIG_IDF_TARGET_ESP32
        uint32_t vaddr = 0;
40377a82:	080c      	movi.n	a8, 0
40377a84:	1189      	s32i.n	a8, a1, 4
        if (caps & MMU_MEM_CAP_EXEC) {
40377a86:	0188      	l32i.n	a8, a1, 0
40377a88:	106807        	bbci	a8, 0, 40377a9c <is_page_mapped_in_cache+0x2c>
            mmu_hal_paddr_to_vaddr(0, phys_addr, MMU_TARGET_FLASH0, MMU_VADDR_INSTRUCTION, &vaddr);
40377a8b:	e14b      	addi.n	a14, a1, 4
40377a8d:	2d0c      	movi.n	a13, 2
40377a8f:	01a0c2        	movi	a12, 1
40377a92:	20b220        	or	a11, a2, a2
40377a95:	052b25        	call8	4037cd48 <mmu_hal_paddr_to_vaddr>
40377a98:	000406        	j	40377aac <is_page_mapped_in_cache+0x3c>
40377a9b:	c1e200        	mul16u	a14, a2, a0
        } else {
            mmu_hal_paddr_to_vaddr(0, phys_addr, MMU_TARGET_FLASH0, MMU_VADDR_DATA, &vaddr);
40377a9e:	a0d204        	lsi	f0, a2, 0x280
40377aa1:	cdd001        	l32r	a0, 4036b1e4 <rom_rx_gain_force+0x364db8>
40377aa4:	02bd20        	andb	b11, b13, b2
40377aa7:	0a0c      	movi.n	a10, 0
40377aa9:	0529e5        	call8	4037cd48 <mmu_hal_paddr_to_vaddr>
        }
        *out_ptr = (void *)vaddr;
40377aac:	1188      	l32i.n	a8, a1, 4
40377aae:	0389      	s32i.n	a8, a3, 0
#endif
        return true;
40377ab0:	120c      	movi.n	a2, 1
40377ab2:	000046        	j	40377ab7 <is_page_mapped_in_cache+0x47>
    }
    return false;
40377ab5:	020c      	movi.n	a2, 0
}
40377ab7:	f01d      	retw.n
40377ab9:	000000        	ill

40377abc <spi_flash_check_and_flush_cache>:

/* Validates if given flash address has corresponding cache mapping, if yes, flushes cache memories */
IRAM_ATTR bool spi_flash_check_and_flush_cache(size_t start_addr, size_t length)
{
40377abc:	006136        	entry	a1, 48
    bool ret = false;
    /* align start_addr & length to full MMU pages */
    uint32_t page_start_addr = start_addr & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377abf:	f37081        	l32r	a8, 40374880 <_iram_text_start+0x47c> (ffff0000 <_rtc_reserved_end+0x9fef0000>)
40377ac2:	104280        	and	a4, a2, a8
    length += (start_addr - page_start_addr);
40377ac5:	c02240        	sub	a2, a2, a4
40377ac8:	223a      	add.n	a2, a2, a3
    length = (length + SPI_FLASH_MMU_PAGE_SIZE - 1) & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377aca:	f26591        	l32r	a9, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40377acd:	529a      	add.n	a5, a2, a9
40377acf:	105580        	and	a5, a5, a8
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377ad2:	047d      	mov.n	a7, a4
    bool ret = false;
40377ad4:	020c      	movi.n	a2, 0
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377ad6:	000cc6        	j	40377b0d <spi_flash_check_and_flush_cache+0x51>
        if (addr >= g_rom_flashchip.chip_size) {
40377ad9:	f34581        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40377adc:	0888      	l32i.n	a8, a8, 0
40377ade:	1888      	l32i.n	a8, a8, 4
40377ae0:	043787        	bltu	a7, a8, 40377ae8 <spi_flash_check_and_flush_cache+0x2c>
            return false; /* invalid address */
40377ae3:	020c      	movi.n	a2, 0
40377ae5:	000a46        	j	40377b12 <spi_flash_check_and_flush_cache+0x56>
        }

        const void *vaddr = NULL;
40377ae8:	00a082        	movi	a8, 0
40377aeb:	006182        	s32i	a8, a1, 0
        if (is_page_mapped_in_cache(addr, &vaddr)) {
40377aee:	01bd      	mov.n	a11, a1
40377af0:	07ad      	mov.n	a10, a7
40377af2:	fff7e5        	call8	40377a70 <is_page_mapped_in_cache>
40377af5:	0a6d      	mov.n	a6, a10
40377af7:	00da16        	beqz	a10, 40377b08 <spi_flash_check_and_flush_cache+0x4c>
#if CONFIG_IDF_TARGET_ESP32
            cache_sync();
            return true;
#else // CONFIG_IDF_TARGET_ESP32
            if (vaddr != NULL) {
40377afa:	0021a2        	l32i	a10, a1, 0
40377afd:	007a16        	beqz	a10, 40377b08 <spi_flash_check_and_flush_cache+0x4c>
                cache_hal_invalidate_addr((uint32_t)vaddr, SPI_FLASH_MMU_PAGE_SIZE);
40377b00:	f361b1        	l32r	a11, 40374884 <_iram_text_start+0x480> (10000 <UserFrameTotalSize+0xff00>)
40377b03:	050825        	call8	4037cb84 <cache_hal_invalidate_addr>
                ret = true;
40377b06:	062d      	mov.n	a2, a6
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377b08:	f35f81        	l32r	a8, 40374884 <_iram_text_start+0x480> (10000 <UserFrameTotalSize+0xff00>)
40377b0b:	778a      	add.n	a7, a7, a8
40377b0d:	845a      	add.n	a8, a4, a5
40377b0f:	c63787        	bltu	a7, a8, 40377ad9 <spi_flash_check_and_flush_cache+0x1d>
#endif // CONFIG_IDF_TARGET_ESP32

        }
    }
    return ret;
}
40377b12:	f01d      	retw.n

40377b14 <spi_flash_guard_set>:
};

static const spi_flash_guard_funcs_t *s_flash_guard_ops;

void IRAM_ATTR spi_flash_guard_set(const spi_flash_guard_funcs_t *funcs)
{
40377b14:	004136        	entry	a1, 32
    s_flash_guard_ops = funcs;
40377b17:	f35c81        	l32r	a8, 40374888 <_iram_text_start+0x484> (3fc95104 <s_flash_guard_ops>)
40377b1a:	0829      	s32i.n	a2, a8, 0
}
40377b1c:	f01d      	retw.n
	...

40377b20 <esp_mspi_pin_init>:
    spi_flash_mmap_page_num_init(128);
}
#endif

void IRAM_ATTR esp_mspi_pin_init(void)
{
40377b20:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    bool octal_mspi_required = bootloader_flash_is_octal_mode_enabled();
40377b23:	ffb4e5        	call8	40377670 <bootloader_flash_is_octal_mode_enabled>
#if CONFIG_SPIRAM_MODE_OCT
    octal_mspi_required |= true;
#endif

    if (octal_mspi_required) {
40377b26:	008a16        	beqz	a10, 40377b32 <esp_mspi_pin_init+0x12>
        esp_rom_opiflash_pin_config();
40377b29:	f35881        	l32r	a8, 4037488c <_iram_text_start+0x488> (40000894 <esp_rom_opiflash_pin_config>)
40377b2c:	0008e0        	callx8	a8
        mspi_timing_set_pin_drive_strength();
40377b2f:	009a65        	call8	403784d4 <mspi_timing_set_pin_drive_strength>
    }
    //Set F4R4 board pin drive strength. TODO: IDF-3663
#endif
}
40377b32:	000090        	retw
40377b35:	000000        	ill

40377b38 <spi_flash_init_chip_state>:
    }
    esp_gpio_reserve(reserve_pin_mask);
}

esp_err_t IRAM_ATTR spi_flash_init_chip_state(void)
{
40377b38:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    if (bootloader_flash_is_octal_mode_enabled()) {
40377b3b:	ffb365        	call8	40377670 <bootloader_flash_is_octal_mode_enabled>
40377b3e:	00fa16        	beqz	a10, 40377b51 <spi_flash_init_chip_state+0x19>
        return esp_opiflash_init(rom_spiflash_legacy_data->chip.device_id);
40377b41:	f32b81        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40377b44:	002882        	l32i	a8, a8, 0
40377b47:	08a8      	l32i.n	a10, a8, 0
40377b49:	0a01e5        	call8	40381b68 <esp_opiflash_init>
40377b4c:	0a2d      	mov.n	a2, a10
40377b4e:	000106        	j	40377b56 <spi_flash_init_chip_state+0x1e>
    }
#endif
#if CONFIG_SPI_FLASH_HPM_ON
        return spi_flash_enable_high_performance_mode();
40377b51:	09e225        	call8	40381974 <spi_flash_enable_high_performance_mode>
40377b54:	0a2d      	mov.n	a2, a10
#endif // CONFIG_SPI_FLASH_HPM_ON
    return ESP_OK;
}
40377b56:	f01d      	retw.n

40377b58 <flash_end_flush_cache>:
    }
    return ESP_OK;
}

static IRAM_ATTR esp_err_t flash_end_flush_cache(esp_flash_t* chip, esp_err_t err, bool bus_acquired, uint32_t address, uint32_t length)
{
40377b58:	004136        	entry	a1, 32
40377b5b:	744040        	extui	a4, a4, 0, 8
    if (!bus_acquired) {
40377b5e:	64dc      	bnez.n	a4, 40377b78 <flash_end_flush_cache+0x20>
        // Try to acquire the bus again to flush the cache before exit.
        esp_err_t acquire_err = rom_spiflash_api_funcs->start(chip);
40377b60:	f34c81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377b63:	0888      	l32i.n	a8, a8, 0
40377b65:	0888      	l32i.n	a8, a8, 0
40377b67:	02ad      	mov.n	a10, a2
40377b69:	0008e0        	callx8	a8
        if (acquire_err != ESP_OK) {
40377b6c:	8a8c      	beqz.n	a10, 40377b78 <flash_end_flush_cache+0x20>
            return (err == ESP_OK)? acquire_err: err;
40377b6e:	03cc      	bnez.n	a3, 40377b72 <flash_end_flush_cache+0x1a>
40377b70:	0a3d      	mov.n	a3, a10
40377b72:	032d      	mov.n	a2, a3
40377b74:	000906        	j	40377b9c <flash_end_flush_cache+0x44>
40377b77:	02a800        	andb	b10, b8, b0
        }
    }

    if (chip->host->driver->flush_cache) {
40377b7a:	0a88      	l32i.n	a8, a10, 0
40377b7c:	112882        	l32i	a8, a8, 68
40377b7f:	988c      	beqz.n	a8, 40377b8c <flash_end_flush_cache+0x34>
        esp_err_t flush_err = chip->host->driver->flush_cache(chip->host, address, length);
40377b81:	06cd      	mov.n	a12, a6
40377b83:	05bd      	mov.n	a11, a5
40377b85:	0008e0        	callx8	a8
        if (err == ESP_OK) {
40377b88:	03cc      	bnez.n	a3, 40377b8c <flash_end_flush_cache+0x34>
            err = flush_err;
40377b8a:	0a3d      	mov.n	a3, a10
        }
    }
    return rom_spiflash_api_funcs->end(chip, err);
40377b8c:	f34181        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377b8f:	0888      	l32i.n	a8, a8, 0
40377b91:	1888      	l32i.n	a8, a8, 4
40377b93:	03bd      	mov.n	a11, a3
40377b95:	02ad      	mov.n	a10, a2
40377b97:	0008e0        	callx8	a8
40377b9a:	0a2d      	mov.n	a2, a10
}
40377b9c:	f01d      	retw.n
	...

40377ba0 <check_chip_pointer_default>:
{
40377ba0:	004136        	entry	a1, 32
    esp_flash_t *chip = *inout_chip;
40377ba3:	0022a2        	l32i	a10, a2, 0
    if (chip == NULL) {
40377ba6:	009a56        	bnez	a10, 40377bb3 <check_chip_pointer_default+0x13>
        chip = esp_flash_default_chip;
40377ba9:	f33b81        	l32r	a8, 40374898 <_iram_text_start+0x494> (3fc95108 <esp_flash_default_chip>)
40377bac:	0028a2        	l32i	a10, a8, 0
    *inout_chip = chip;
40377baf:	02a9      	s32i.n	a10, a2, 0
    if (chip == NULL || !esp_flash_chip_driver_initialized(chip)) {
40377bb1:	3a8c      	beqz.n	a10, 40377bb8 <check_chip_pointer_default+0x18>
40377bb3:	005e65        	call8	40378198 <esp_flash_chip_driver_initialized>
40377bb6:	4acc      	bnez.n	a10, 40377bbe <check_chip_pointer_default+0x1e>
        return ESP_ERR_FLASH_NOT_INITIALISED;
40377bb8:	f33721        	l32r	a2, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
40377bbb:	000046        	j	40377bc0 <check_chip_pointer_default+0x20>
    return ESP_OK;
40377bbe:	020c      	movi.n	a2, 0
}
40377bc0:	f01d      	retw.n
	...

40377bc4 <detect_spi_flash_chip>:

    return read_unique_id(chip, out_uid);
}

static esp_err_t IRAM_ATTR detect_spi_flash_chip(esp_flash_t *chip)
{
40377bc4:	004136        	entry	a1, 32
40377bc7:	027d      	mov.n	a7, a2
    esp_err_t err;
    uint32_t flash_id = chip->chip_id;
40377bc9:	6258      	l32i.n	a5, a2, 24

    // Detect the chip and set the chip_drv structure for it
    const spi_flash_chip_t **drivers = esp_flash_registered_chips;
40377bcb:	f33481        	l32r	a8, 4037489c <_iram_text_start+0x498> (3fc9276c <esp_flash_registered_chips>)
40377bce:	0868      	l32i.n	a6, a8, 0
    while (*drivers != NULL && !esp_flash_chip_driver_initialized(chip)) {
40377bd0:	000f06        	j	40377c10 <detect_spi_flash_chip+0x4c>
40377bd3:	172900        	lsi	f0, a9, 92
        chip->chip_drv = *drivers;
        // start/end SPI operation each time, for multitasking
        // and also so esp_flash_registered_flash_drivers can live in flash
        ESP_EARLY_LOGD(TAG, "trying chip: %s", chip->chip_drv->name);

        err = rom_spiflash_api_funcs->start(chip);
40377bd6:	f32e81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377bd9:	0888      	l32i.n	a8, a8, 0
40377bdb:	0888      	l32i.n	a8, a8, 0
40377bdd:	07ad      	mov.n	a10, a7
40377bdf:	0008e0        	callx8	a8
40377be2:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40377be4:	068a56        	bnez	a10, 40377c50 <detect_spi_flash_chip+0x8c>
            return err;
        }

        if (chip->chip_drv->probe(chip, flash_id) != ESP_OK) {
40377be7:	1788      	l32i.n	a8, a7, 4
40377be9:	2888      	l32i.n	a8, a8, 8
40377beb:	05bd      	mov.n	a11, a5
40377bed:	07ad      	mov.n	a10, a7
40377bef:	0008e0        	callx8	a8
40377bf2:	2a8c      	beqz.n	a10, 40377bf8 <detect_spi_flash_chip+0x34>
            chip->chip_drv = NULL;
40377bf4:	080c      	movi.n	a8, 0
40377bf6:	1789      	s32i.n	a8, a7, 4
        }
        // if probe succeeded, chip->drv stays set
        drivers++;
40377bf8:	04c662        	addi	a6, a6, 4

        err = rom_spiflash_api_funcs->end(chip, err);
40377bfb:	f32581        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377bfe:	002882        	l32i	a8, a8, 0
40377c01:	012882        	l32i	a8, a8, 4
40377c04:	02bd      	mov.n	a11, a2
40377c06:	07ad      	mov.n	a10, a7
40377c08:	0008e0        	callx8	a8
40377c0b:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40377c0d:	03fa56        	bnez	a10, 40377c50 <detect_spi_flash_chip+0x8c>
    while (*drivers != NULL && !esp_flash_chip_driver_initialized(chip)) {
40377c10:	0628      	l32i.n	a2, a6, 0
40377c12:	628c      	beqz.n	a2, 40377c1c <detect_spi_flash_chip+0x58>
40377c14:	07ad      	mov.n	a10, a7
40377c16:	005825        	call8	40378198 <esp_flash_chip_driver_initialized>
40377c19:	fb7a16        	beqz	a10, 40377bd4 <detect_spi_flash_chip+0x10>
            return err;
        }
    }
    if (!esp_flash_chip_driver_initialized(chip)) {
40377c1c:	20a770        	or	a10, a7, a7
40377c1f:	0057a5        	call8	40378198 <esp_flash_chip_driver_initialized>
40377c22:	022a16        	beqz	a10, 40377c48 <detect_spi_flash_chip+0x84>
40377c25:	f21181        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40377c28:	0888      	l32i.n	a8, a8, 0
        return ESP_ERR_NOT_FOUND;
    }
    ESP_EARLY_LOGI(TAG, "detected chip: %s", chip->chip_drv->name);
40377c2a:	2038b6        	bltui	a8, 3, 40377c4e <detect_spi_flash_chip+0x8a>
40377c2d:	080025        	call8	4037fc30 <esp_log_timestamp>
40377c30:	1788      	l32i.n	a8, a7, 4
40377c32:	08d8      	l32i.n	a13, a8, 0
40377c34:	f31bc1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9368c <TAG>)
40377c37:	0abd      	mov.n	a11, a10
40377c39:	f31aa1        	l32r	a10, 403748a4 <_iram_text_start+0x4a0> (3c0264e0 <_flash_rodata_start+0x63c0>)
40377c3c:	f21e81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377c3f:	0008e0        	callx8	a8
    return ESP_OK;
40377c42:	020c      	movi.n	a2, 0
40377c44:	000206        	j	40377c50 <detect_spi_flash_chip+0x8c>
40377c47:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40377c4a:	004605        	call0	403780ac <esp_crosscore_int_send+0x34>
40377c4d:	020c00        	andb	b0, b12, b0
}
40377c50:	f01d      	retw.n
	...

40377c54 <read_id_core>:
{
40377c54:	006136        	entry	a1, 48
40377c57:	027d      	mov.n	a7, a2
    bool installed = esp_flash_chip_driver_initialized(chip);
40377c59:	02ad      	mov.n	a10, a2
40377c5b:	0053e5        	call8	40378198 <esp_flash_chip_driver_initialized>
40377c5e:	0a6d      	mov.n	a6, a10
    esp_err_t err = rom_spiflash_api_funcs->start(chip);
40377c60:	f30c81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377c63:	0888      	l32i.n	a8, a8, 0
40377c65:	0888      	l32i.n	a8, a8, 0
40377c67:	02ad      	mov.n	a10, a2
40377c69:	0008e0        	callx8	a8
40377c6c:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377c6e:	04ca56        	bnez	a10, 40377cbe <read_id_core+0x6a>
    if (installed && chip->chip_drv->read_id) {
40377c71:	568c      	beqz.n	a6, 40377c7a <read_id_core+0x26>
40377c73:	1788      	l32i.n	a8, a7, 4
40377c75:	182822        	l32i	a2, a8, 96
40377c78:	92cc      	bnez.n	a2, 40377c85 <read_id_core+0x31>
        read_id_func = (void*)chip->host->driver->read_id;
40377c7a:	0768      	l32i.n	a6, a7, 0
40377c7c:	0688      	l32i.n	a8, a6, 0
40377c7e:	2828      	l32i.n	a2, a8, 8
        read_id_arg = (void*)chip->host;
40377c80:	0000c6        	j	40377c87 <read_id_core+0x33>
40377c83:	6d0000        	lsi	f0, a0, 0x1b4
        read_id_arg = (void*)chip;
40377c86:	03bd07        	bgeu	a13, a0, 40377c8d <read_id_core+0x39>
    err = read_id_func(read_id_arg, out_id);
40377c89:	06ad      	mov.n	a10, a6
40377c8b:	0002e0        	callx8	a2
40377c8e:	0abd      	mov.n	a11, a10
    if (sanity_check && err == ESP_OK) {
40377c90:	40fa80        	nsau	a8, a10
40377c93:	418580        	srli	a8, a8, 5
40377c96:	160847        	bnone	a8, a4, 40377cb0 <read_id_core+0x5c>
        err = read_id_func(read_id_arg, &new_id);
40377c99:	20b110        	or	a11, a1, a1
40377c9c:	20a660        	or	a10, a6, a6
40377c9f:	0002e0        	callx8	a2
40377ca2:	0abd      	mov.n	a11, a10
        if (err == ESP_OK && (new_id != *out_id)) {
40377ca4:	8acc      	bnez.n	a10, 40377cb0 <read_id_core+0x5c>
40377ca6:	0398      	l32i.n	a9, a3, 0
40377ca8:	0188      	l32i.n	a8, a1, 0
40377caa:	021987        	beq	a9, a8, 40377cb0 <read_id_core+0x5c>
            err = ESP_ERR_FLASH_NOT_INITIALISED;
40377cad:	f2f9b1        	l32r	a11, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
    return rom_spiflash_api_funcs->end(chip, err);
40377cb0:	f2f881        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377cb3:	0888      	l32i.n	a8, a8, 0
40377cb5:	1888      	l32i.n	a8, a8, 4
40377cb7:	07ad      	mov.n	a10, a7
40377cb9:	0008e0        	callx8	a8
40377cbc:	0a2d      	mov.n	a2, a10
}
40377cbe:	f01d      	retw.n

40377cc0 <esp_flash_get_physical_size>:

esp_err_t IRAM_ATTR esp_flash_get_physical_size(esp_flash_t *chip, uint32_t *flash_size)
{
40377cc0:	008136        	entry	a1, 64
40377cc3:	4129      	s32i.n	a2, a1, 16
    esp_err_t err = rom_spiflash_api_funcs->chip_check(&chip);
40377cc5:	f2f281        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377cc8:	0888      	l32i.n	a8, a8, 0
40377cca:	2888      	l32i.n	a8, a8, 8
40377ccc:	10c1a2        	addi	a10, a1, 16
40377ccf:	0008e0        	callx8	a8
40377cd2:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377cd4:	054a56        	bnez	a10, 40377d2c <esp_flash_get_physical_size+0x6c>
        return err;
    }
    VERIFY_CHIP_OP(detect_size);
40377cd7:	41a8      	l32i.n	a10, a1, 16
40377cd9:	1a88      	l32i.n	a8, a10, 4
40377cdb:	4888      	l32i.n	a8, a8, 16
40377cdd:	040816        	beqz	a8, 40377d21 <esp_flash_get_physical_size+0x61>
    if (flash_size == NULL) {
40377ce0:	045316        	beqz	a3, 40377d29 <esp_flash_get_physical_size+0x69>
        return ESP_ERR_INVALID_ARG;
    }

    err = rom_spiflash_api_funcs->start(chip);
40377ce3:	f2eb81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377ce6:	0888      	l32i.n	a8, a8, 0
40377ce8:	002882        	l32i	a8, a8, 0
40377ceb:	0008e0        	callx8	a8
40377cee:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377cf0:	8afc      	bnez.n	a10, 40377d2c <esp_flash_get_physical_size+0x6c>
        return err;
    }
    uint32_t detect_size;
    err = chip->chip_drv->detect_size(chip, &detect_size);
40377cf2:	41a8      	l32i.n	a10, a1, 16
40377cf4:	1a88      	l32i.n	a8, a10, 4
40377cf6:	4888      	l32i.n	a8, a8, 16
40377cf8:	20b110        	or	a11, a1, a1
40377cfb:	0008e0        	callx8	a8
40377cfe:	0abd      	mov.n	a11, a10
    if (err == ESP_OK) {
40377d00:	cacc      	bnez.n	a10, 40377d10 <esp_flash_get_physical_size+0x50>
        if (chip->size == 0) {
40377d02:	4188      	l32i.n	a8, a1, 16
40377d04:	5898      	l32i.n	a9, a8, 20
40377d06:	29cc      	bnez.n	a9, 40377d0c <esp_flash_get_physical_size+0x4c>
            // chip->size will not be changed if detected, it will always be equal to configured flash size.
            chip->size = detect_size;
40377d08:	0198      	l32i.n	a9, a1, 0
40377d0a:	5899      	s32i.n	a9, a8, 20
        }
        *flash_size = detect_size;
40377d0c:	0188      	l32i.n	a8, a1, 0
40377d0e:	0389      	s32i.n	a8, a3, 0
    }
    return rom_spiflash_api_funcs->end(chip, err);
40377d10:	f2e081        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377d13:	0888      	l32i.n	a8, a8, 0
40377d15:	1888      	l32i.n	a8, a8, 4
40377d17:	41a8      	l32i.n	a10, a1, 16
40377d19:	0008e0        	callx8	a8
40377d1c:	0a2d      	mov.n	a2, a10
40377d1e:	000286        	j	40377d2c <esp_flash_get_physical_size+0x6c>
    VERIFY_CHIP_OP(detect_size);
40377d21:	f2e121        	l32r	a2, 403748a8 <_iram_text_start+0x4a4> (6005 <UserFrameTotalSize+0x5f05>)
40377d24:	000106        	j	40377d2c <esp_flash_get_physical_size+0x6c>
40377d27:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
40377d2a:	1d02a1        	l32r	a10, 4033f134 <rom_rx_gain_force+0x338d08>
}
40377d2d:	0000f0        	callx12	a0

40377d30 <esp_flash_init_main>:
{
40377d30:	006136        	entry	a1, 48
40377d33:	027d      	mov.n	a7, a2
    if (chip == NULL || chip->host == NULL || chip->host->driver == NULL ||
40377d35:	14b216        	beqz	a2, 40377e84 <esp_flash_init_main+0x154>
40377d38:	0288      	l32i.n	a8, a2, 0
40377d3a:	14e816        	beqz	a8, 40377e8c <esp_flash_init_main+0x15c>
40377d3d:	0898      	l32i.n	a9, a8, 0
40377d3f:	14f916        	beqz	a9, 40377e92 <esp_flash_init_main+0x162>
        ((memspi_host_inst_t*)chip->host)->spi == NULL) {
40377d42:	1888      	l32i.n	a8, a8, 4
    if (chip == NULL || chip->host == NULL || chip->host->driver == NULL ||
40377d44:	151816        	beqz	a8, 40377e99 <esp_flash_init_main+0x169>
    octal_mode = (chip->read_mode >= SPI_FLASH_OPI_FLAG);
40377d47:	4258      	l32i.n	a5, a2, 16
    uint32_t flash_id = 0;
40377d49:	080c      	movi.n	a8, 0
40377d4b:	0189      	s32i.n	a8, a1, 0
    if (octal_mode) {
40377d4d:	f80c      	movi.n	a8, 15
40377d4f:	0bb857        	bgeu	a8, a5, 40377d5e <esp_flash_init_main+0x2e>
        flash_id = g_rom_flashchip.device_id;
40377d52:	f2a781        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40377d55:	0888      	l32i.n	a8, a8, 0
40377d57:	0888      	l32i.n	a8, a8, 0
40377d59:	0189      	s32i.n	a8, a1, 0
    if (err != ESP_OK) {
40377d5b:	000846        	j	40377d80 <esp_flash_init_main+0x50>
        int retries = 10;
40377d5e:	a60c      	movi.n	a6, 10
40377d60:	000086        	j	40377d66 <esp_flash_init_main+0x36>
40377d63:	086d00        	lsx	f6, a13, a0
            err = esp_flash_read_chip_id(chip, &flash_id);
40377d66:	01bd      	mov.n	a11, a1
40377d68:	07ad      	mov.n	a10, a7
40377d6a:	f2d681        	l32r	a8, 403748c4 <_iram_text_start+0x4c0> (4200a024 <esp_flash_read_chip_id>)
40377d6d:	0008e0        	callx8	a8
40377d70:	0a2d      	mov.n	a2, a10
        } while (err == ESP_ERR_FLASH_NOT_INITIALISED && retries-- > 0);
40377d72:	f2c881        	l32r	a8, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
40377d75:	049a87        	bne	a10, a8, 40377d7d <esp_flash_init_main+0x4d>
40377d78:	860b      	addi.n	a8, a6, -1
40377d7a:	e616e6        	bgei	a6, 1, 40377d64 <esp_flash_init_main+0x34>
    if (err != ESP_OK) {
40377d7d:	11b256        	bnez	a2, 40377e9c <esp_flash_init_main+0x16c>
    chip->chip_id = flash_id;
40377d80:	0188      	l32i.n	a8, a1, 0
40377d82:	6789      	s32i.n	a8, a7, 24
    if (!esp_flash_chip_driver_initialized(chip)) {
40377d84:	07ad      	mov.n	a10, a7
40377d86:	004125        	call8	40378198 <esp_flash_chip_driver_initialized>
40377d89:	9acc      	bnez.n	a10, 40377d96 <esp_flash_init_main+0x66>
        err = detect_spi_flash_chip(chip);
40377d8b:	07ad      	mov.n	a10, a7
40377d8d:	ffe365        	call8	40377bc4 <detect_spi_flash_chip>
40377d90:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
40377d93:	105a56        	bnez	a10, 40377e9c <esp_flash_init_main+0x16c>
    err = esp_flash_get_physical_size(chip, &size);
40377d96:	04c1b2        	addi	a11, a1, 4
40377d99:	20a770        	or	a10, a7, a7
40377d9c:	fff225        	call8	40377cc0 <esp_flash_get_physical_size>
40377d9f:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377da1:	01ca16        	beqz	a10, 40377dc1 <esp_flash_init_main+0x91>
40377da4:	f1b281        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40377da7:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "failed to get chip size");
40377daa:	0ee816        	beqz	a8, 40377e9c <esp_flash_init_main+0x16c>
40377dad:	07e825        	call8	4037fc30 <esp_log_timestamp>
40377db0:	f2bcc1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9368c <TAG>)
40377db3:	0abd      	mov.n	a11, a10
40377db5:	f2bda1        	l32r	a10, 403748ac <_iram_text_start+0x4a8> (3c026500 <_flash_rodata_start+0x63e0>)
40377db8:	f1bf81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377dbb:	0008e0        	callx8	a8
        return err;
40377dbe:	003686        	j	40377e9c <esp_flash_init_main+0x16c>
    if (chip->chip_drv->get_chip_caps == NULL) {
40377dc1:	1788      	l32i.n	a8, a7, 4
40377dc3:	1d2882        	l32i	a8, a8, 116
40377dc6:	01c856        	bnez	a8, 40377de6 <esp_flash_init_main+0xb6>
40377dc9:	f1a881        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40377dcc:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGW(TAG, "get_chip_caps function pointer hasn't been initialized");
40377dce:	4328b6        	bltui	a8, 2, 40377e15 <esp_flash_init_main+0xe5>
40377dd1:	07e5e5        	call8	4037fc30 <esp_log_timestamp>
40377dd4:	f2b3c1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9368c <TAG>)
40377dd7:	0abd      	mov.n	a11, a10
40377dd9:	f2b5a1        	l32r	a10, 403748b0 <_iram_text_start+0x4ac> (3c026648 <_flash_rodata_start+0x6528>)
40377ddc:	f1b681        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377ddf:	0008e0        	callx8	a8
40377de2:	000bc6        	j	40377e15 <esp_flash_init_main+0xe5>
40377de5:	07ad00        	lsi	f0, a13, 28
        if (((chip->chip_drv->get_chip_caps(chip) & SPI_FLASH_CHIP_CAP_32MB_SUPPORT) == 0) && (size > (16 *1024 * 1024))) {
40377de8:	0008e0        	callx8	a8
40377deb:	26ea17        	bbsi	a10, 1, 40377e15 <esp_flash_init_main+0xe5>
40377dee:	1188      	l32i.n	a8, a1, 4
40377df0:	f2b191        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
40377df3:	1eb987        	bgeu	a9, a8, 40377e15 <esp_flash_init_main+0xe5>
40377df6:	f19d81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40377df9:	0888      	l32i.n	a8, a8, 0
            ESP_EARLY_LOGW(TAG, "Detected flash size > 16 MB, but access beyond 16 MB is not supported for this flash model yet.");
40377dfb:	1128b6        	bltui	a8, 2, 40377e10 <esp_flash_init_main+0xe0>
40377dfe:	07e325        	call8	4037fc30 <esp_log_timestamp>
40377e01:	f2a7c1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9368c <TAG>)
40377e04:	20baa0        	or	a11, a10, a10
40377e07:	f2aca1        	l32r	a10, 403748b8 <_iram_text_start+0x4b4> (3c026528 <_flash_rodata_start+0x6408>)
40377e0a:	f1aa81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377e0d:	0008e0        	callx8	a8
            size = (16 * 1024 * 1024);
40377e10:	f2a981        	l32r	a8, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
40377e13:	1189      	s32i.n	a8, a1, 4
40377e15:	f19581        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40377e18:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "flash io: %s", io_mode_str[chip->read_mode]);
40377e1a:	1b38b6        	bltui	a8, 3, 40377e39 <esp_flash_init_main+0x109>
40377e1d:	07e125        	call8	4037fc30 <esp_log_timestamp>
40377e20:	47d8      	l32i.n	a13, a7, 16
40377e22:	a0ddd0        	addx4	a13, a13, a13
40377e25:	f2a581        	l32r	a8, 403748bc <_iram_text_start+0x4b8> (3c028a20 <io_mode_str>)
40377e28:	90dd80        	addx2	a13, a13, a8
40377e2b:	f29dc1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9368c <TAG>)
40377e2e:	0abd      	mov.n	a11, a10
40377e30:	f2a4a1        	l32r	a10, 403748c0 <_iram_text_start+0x4bc> (3c026598 <_flash_rodata_start+0x6478>)
40377e33:	f1a081        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377e36:	0008e0        	callx8	a8
    err = rom_spiflash_api_funcs->start(chip);
40377e39:	f29581        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93678 <rom_spiflash_api_funcs>)
40377e3c:	0888      	l32i.n	a8, a8, 0
40377e3e:	0888      	l32i.n	a8, a8, 0
40377e40:	07ad      	mov.n	a10, a7
40377e42:	0008e0        	callx8	a8
40377e45:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377e47:	051a56        	bnez	a10, 40377e9c <esp_flash_init_main+0x16c>
    if (err == ESP_OK && !octal_mode) {
40377e4a:	f80c      	movi.n	a8, 15
40377e4c:	203857        	bltu	a8, a5, 40377e70 <esp_flash_init_main+0x140>
        err = chip->chip_drv->set_io_mode(chip);
40377e4f:	1788      	l32i.n	a8, a7, 4
40377e51:	162882        	l32i	a8, a8, 88
40377e54:	07ad      	mov.n	a10, a7
40377e56:	0008e0        	callx8	a8
        if (err == ESP_ERR_FLASH_NO_RESPONSE && !esp_flash_is_quad_mode(chip)) {
40377e59:	08a182        	movi	a8, 0x108
40377e5c:	0e9a87        	bne	a10, a8, 40377e6e <esp_flash_init_main+0x13e>
 *
 * @return true if flash works in quad mode, otherwise false
 */
static inline bool esp_flash_is_quad_mode(const esp_flash_t *chip)
{
    return (chip->read_mode == SPI_FLASH_QIO) || (chip->read_mode == SPI_FLASH_QOUT);
40377e5f:	4788      	l32i.n	a8, a7, 16
40377e61:	fcc882        	addi	a8, a8, -4
40377e64:	0828f6        	bgeui	a8, 2, 40377e70 <esp_flash_init_main+0x140>
        err = chip->chip_drv->set_io_mode(chip);
40377e67:	0a2d      	mov.n	a2, a10
40377e69:	0000c6        	j	40377e70 <esp_flash_init_main+0x140>
40377e6c:	2d0000        	lsi	f0, a0, 180
40377e6f:	810a      	add.n	a8, a1, a0
    return rom_spiflash_api_funcs->end(chip, err);
40377e71:	f288      	l32i.n	a8, a2, 60
40377e73:	0888      	l32i.n	a8, a8, 0
40377e75:	1888      	l32i.n	a8, a8, 4
40377e77:	02bd      	mov.n	a11, a2
40377e79:	07ad      	mov.n	a10, a7
40377e7b:	0008e0        	callx8	a8
40377e7e:	0a2d      	mov.n	a2, a10
40377e80:	000606        	j	40377e9c <esp_flash_init_main+0x16c>
40377e83:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
40377e86:	044602        	s8i	a0, a6, 4
40377e89:	000000        	ill
40377e8c:	02a122        	movi	a2, 0x102
40377e8f:	000246        	j	40377e9c <esp_flash_init_main+0x16c>
40377e92:	02a122        	movi	a2, 0x102
40377e95:	0000c6        	j	40377e9c <esp_flash_init_main+0x16c>
40377e98:	a12200        	sll	a2, a2
40377e9b:	f01d02        	l16ui	a0, a13, 0x1e0
	...

40377ea0 <spi_flash_os_yield>:
    }
    return ret;
}

static IRAM_ATTR esp_err_t spi_flash_os_yield(void *arg, uint32_t* out_status)
{
40377ea0:	004136        	entry	a1, 32
    if (likely(xTaskGetSchedulerState() == taskSCHEDULER_RUNNING)) {
40377ea3:	03ba65        	call8	4037ba48 <xTaskGetSchedulerState>
40377ea6:	052a66        	bnei	a10, 2, 40377eaf <spi_flash_os_yield+0xf>
#ifdef CONFIG_SPI_FLASH_ERASE_YIELD_TICKS
        vTaskDelay(CONFIG_SPI_FLASH_ERASE_YIELD_TICKS);
40377ea9:	01a0a2        	movi	a10, 1
40377eac:	03cc65        	call8	4037bb74 <vTaskDelay>
    // in that function instead.
}

static inline IRAM_ATTR void on_spi_yielded(app_func_arg_t* ctx)
{
    uint32_t time = esp_system_get_time();
40377eaf:	fed6e5        	call8	40376c1c <esp_system_get_time>
    ctx->acquired_since_us = time;
40377eb2:	22a9      	s32i.n	a10, a2, 8
}
40377eb4:	020c      	movi.n	a2, 0
40377eb6:	f01d      	retw.n

40377eb8 <on_spi_check_yield>:
{
40377eb8:	004136        	entry	a1, 32
    uint32_t time = esp_system_get_time();
40377ebb:	fed625        	call8	40376c1c <esp_system_get_time>
    if ((time - ctx->released_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_TICKS * portTICK_PERIOD_MS * 1000) {
40377ebe:	032282        	l32i	a8, a2, 12
40377ec1:	c08a80        	sub	a8, a10, a8
40377ec4:	f28191        	l32r	a9, 403748c8 <_iram_text_start+0x4c4> (270f <UserFrameTotalSize+0x260f>)
40377ec7:	09b987        	bgeu	a9, a8, 40377ed4 <on_spi_check_yield+0x1c>
        ctx->acquired_since_us = time;
40377eca:	0262a2        	s32i	a10, a2, 8
    return false;
40377ecd:	00a022        	movi	a2, 0
40377ed0:	000486        	j	40377ee6 <on_spi_check_yield+0x2e>
40377ed3:	228800        	orb	b8, b8, b0
    } else if ((time - ctx->acquired_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS * 1000) {
40377ed6:	c0aa80        	sub	a10, a10, a8
40377ed9:	f27c81        	l32r	a8, 403748cc <_iram_text_start+0x4c8> (4e1f <UserFrameTotalSize+0x4d1f>)
40377edc:	0438a7        	bltu	a8, a10, 40377ee4 <on_spi_check_yield+0x2c>
    return false;
40377edf:	020c      	movi.n	a2, 0
40377ee1:	000046        	j	40377ee6 <on_spi_check_yield+0x2e>
        return true;
40377ee4:	120c      	movi.n	a2, 1
}
40377ee6:	f01d      	retw.n

40377ee8 <spi_flash_os_check_yield>:
{
40377ee8:	004136        	entry	a1, 32
40377eeb:	02ad      	mov.n	a10, a2
    assert (chip_status == 0);  //TODO: support suspend
40377eed:	039c      	beqz.n	a3, 40377f01 <spi_flash_os_check_yield+0x19>
40377eef:	f278d1        	l32r	a13, 403748d0 <_iram_text_start+0x4cc> (3c026854 <_flash_rodata_start+0x6734>)
40377ef2:	f278c1        	l32r	a12, 403748d4 <_iram_text_start+0x4d0> (3c028afc <__func__$0>)
40377ef5:	afa0b2        	movi	a11, 175
40377ef8:	f278a1        	l32r	a10, 403748d8 <_iram_text_start+0x4d4> (3c026883 <_flash_rodata_start+0x6763>)
40377efb:	201110        	or	a1, a1, a1
40377efe:	07ea25        	call8	4037fda0 <__assert_func>
    if (on_spi_check_yield((app_func_arg_t *)arg)) {
40377f01:	fffb65        	call8	40377eb8 <on_spi_check_yield>
40377f04:	9acc      	bnez.n	a10, 40377f11 <spi_flash_os_check_yield+0x29>
    uint32_t request = 0;
40377f06:	080c      	movi.n	a8, 0
    esp_err_t ret = ESP_ERR_TIMEOUT;    //Nothing happened
40377f08:	07a122        	movi	a2, 0x107
40377f0b:	000186        	j	40377f15 <spi_flash_os_check_yield+0x2d>
40377f0e:	000000        	ill
        request = SPI_FLASH_YIELD_REQ_YIELD;
40377f11:	180c      	movi.n	a8, 1
        ret = ESP_OK;
40377f13:	020c      	movi.n	a2, 0
    if (out_request) {
40377f15:	048c      	beqz.n	a4, 40377f19 <spi_flash_os_check_yield+0x31>
        *out_request = request;
40377f17:	0489      	s32i.n	a8, a4, 0
}
40377f19:	f01d      	retw.n
	...

40377f1c <release_buffer_malloc>:
{
40377f1c:	004136        	entry	a1, 32
40377f1f:	03ad      	mov.n	a10, a3
    free(temp_buf);
40377f21:	07f7a5        	call8	4037fe9c <cfree>
}
40377f24:	f01d      	retw.n
	...

40377f28 <get_buffer_malloc>:
{
40377f28:	004136        	entry	a1, 32
    unsigned retries = 5;
40377f2b:	580c      	movi.n	a8, 5
    void* ret = NULL;
40377f2d:	0a0c      	movi.n	a10, 0
    while(ret == NULL && retries--) {
40377f2f:	000a86        	j	40377f5d <get_buffer_malloc+0x35>
40377f32:	a10000        	sll	a0, a0
        read_chunk_size = MIN(read_chunk_size, heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT));
40377f35:	f26a      	add.n	a15, a2, a6
40377f37:	f26a81        	l32r	a8, 403748e0 <_iram_text_start+0x4dc> (42002c60 <heap_caps_get_largest_free_block>)
40377f3a:	0008e0        	callx8	a8
40377f3d:	0b33a7        	bltu	a3, a10, 40377f4c <get_buffer_malloc+0x24>
40377f40:	f267a1        	l32r	a10, 403748dc <_iram_text_start+0x4d8> (804 <UserFrameTotalSize+0x704>)
40377f43:	f26781        	l32r	a8, 403748e0 <_iram_text_start+0x4dc> (42002c60 <heap_caps_get_largest_free_block>)
40377f46:	0008e0        	callx8	a8
40377f49:	203aa0        	or	a3, a10, a10
        read_chunk_size = (read_chunk_size + 3) & ~3;
40377f4c:	333b      	addi.n	a3, a3, 3
40377f4e:	c87c      	movi.n	a8, -4
40377f50:	103380        	and	a3, a3, a8
        ret = heap_caps_malloc(read_chunk_size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
40377f53:	f262b1        	l32r	a11, 403748dc <_iram_text_start+0x4d8> (804 <UserFrameTotalSize+0x704>)
40377f56:	03ad      	mov.n	a10, a3
40377f58:	fdfde5        	call8	40375f38 <heap_caps_malloc>
    while(ret == NULL && retries--) {
40377f5b:	078d      	mov.n	a8, a7
40377f5d:	3acc      	bnez.n	a10, 40377f64 <get_buffer_malloc+0x3c>
40377f5f:	780b      	addi.n	a7, a8, -1
40377f61:	fcf856        	bnez	a8, 40377f34 <get_buffer_malloc+0xc>
    *out_size = (ret != NULL? read_chunk_size: 0);
40377f64:	0acc      	bnez.n	a10, 40377f68 <get_buffer_malloc+0x40>
40377f66:	030c      	movi.n	a3, 0
40377f68:	0439      	s32i.n	a3, a4, 0
}
40377f6a:	0a2d      	mov.n	a2, a10
40377f6c:	f01d      	retw.n
	...

40377f70 <delay_us>:
{
40377f70:	004136        	entry	a1, 32
40377f73:	20a330        	or	a10, a3, a3
    esp_rom_delay_us(us);
40377f76:	f12f81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40377f79:	0008e0        	callx8	a8
}
40377f7c:	020c      	movi.n	a2, 0
40377f7e:	f01d      	retw.n

40377f80 <main_flash_op_status>:
{
40377f80:	004136        	entry	a1, 32
    spi_flash_set_erasing_flag(is_erasing);
40377f83:	04a020        	extui	a10, a2, 0, 1
40377f86:	080025        	call8	4037ff88 <spi_flash_set_erasing_flag>
}
40377f89:	f01d      	retw.n
	...

40377f8c <main_flash_region_protected>:
{
40377f8c:	004136        	entry	a1, 32
    if (!esp_partition_is_flash_region_writable(start_addr, size)) {
40377f8f:	04bd      	mov.n	a11, a4
40377f91:	03ad      	mov.n	a10, a3
40377f93:	f25481        	l32r	a8, 403748e4 <_iram_text_start+0x4e0> (4200a8ac <esp_partition_is_flash_region_writable>)
40377f96:	0008e0        	callx8	a8
40377f99:	4a9c      	beqz.n	a10, 40377fb1 <main_flash_region_protected+0x25>
    if (((app_func_arg_t*)arg)->no_protect || esp_partition_main_flash_region_safe(start_addr, size)) {
40377f9b:	040282        	l8ui	a8, a2, 4
40377f9e:	a8cc      	bnez.n	a8, 40377fac <main_flash_region_protected+0x20>
40377fa0:	04bd      	mov.n	a11, a4
40377fa2:	03ad      	mov.n	a10, a3
40377fa4:	f25181        	l32r	a8, 403748e8 <_iram_text_start+0x4e4> (4200a8fc <esp_partition_main_flash_region_safe>)
40377fa7:	0008e0        	callx8	a8
40377faa:	aa8c      	beqz.n	a10, 40377fb8 <main_flash_region_protected+0x2c>
        return ESP_OK;
40377fac:	020c      	movi.n	a2, 0
40377fae:	000246        	j	40377fbb <main_flash_region_protected+0x2f>
        return ESP_ERR_NOT_ALLOWED;
40377fb1:	0da122        	movi	a2, 0x10d
40377fb4:	0000c6        	j	40377fbb <main_flash_region_protected+0x2f>
40377fb7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
40377fba:	f01d06        	j	40374032 <_WindowOverflow4+0x32>
40377fbd:	000000        	ill

40377fc0 <cache_enable>:
{
40377fc0:	004136        	entry	a1, 32
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377fc3:	ffa065        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>
}
40377fc6:	f01d      	retw.n

40377fc8 <spi1_end>:
{
40377fc8:	004136        	entry	a1, 32
    cache_enable(NULL);
40377fcb:	00a0a2        	movi	a10, 0
40377fce:	ffff25        	call8	40377fc0 <cache_enable>
    ctx->released_since_us = esp_system_get_time();
40377fd1:	fec4a5        	call8	40376c1c <esp_system_get_time>
40377fd4:	0362a2        	s32i	a10, a2, 12
}
40377fd7:	00a022        	movi	a2, 0
40377fda:	f01d      	retw.n

40377fdc <cache_disable>:
{
40377fdc:	004136        	entry	a1, 32
    spi_flash_disable_interrupts_caches_and_other_cpu();
40377fdf:	ff8c25        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
}
40377fe2:	f01d      	retw.n

40377fe4 <spi1_start>:
{
40377fe4:	004136        	entry	a1, 32
    cache_disable(NULL);
40377fe7:	0a0c      	movi.n	a10, 0
40377fe9:	ffff25        	call8	40377fdc <cache_disable>
}
40377fec:	020c      	movi.n	a2, 0
40377fee:	f01d      	retw.n

40377ff0 <delay_us>:

    return ESP_OK;
}

static IRAM_ATTR esp_err_t delay_us(void *arg, uint32_t us)
{
40377ff0:	004136        	entry	a1, 32
40377ff3:	20a330        	or	a10, a3, a3
    esp_rom_delay_us(us);
40377ff6:	f10f81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40377ff9:	0008e0        	callx8	a8
    return ESP_OK;
}
40377ffc:	020c      	movi.n	a2, 0
40377ffe:	f01d      	retw.n

40378000 <end>:
{
40378000:	004136        	entry	a1, 32
    cache_hal_resume(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40378003:	02a0b2        	movi	a11, 2
40378006:	01a0a2        	movi	a10, 1
40378009:	04a4e5        	call8	4037ca58 <cache_hal_resume>
}
4037800c:	00a022        	movi	a2, 0
4037800f:	f01d      	retw.n
40378011:	000000        	ill

40378014 <start>:
{
40378014:	004136        	entry	a1, 32
    cache_hal_suspend(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40378017:	02a0b2        	movi	a11, 2
4037801a:	01a0a2        	movi	a10, 1
4037801d:	04a025        	call8	4037ca20 <cache_hal_suspend>
}
40378020:	00a022        	movi	a2, 0
40378023:	f01d      	retw.n
40378025:	000000        	ill

40378028 <esp_crosscore_isr>:
{
    portYIELD_FROM_ISR();
}

static void IRAM_ATTR esp_crosscore_isr(void *arg)
{
40378028:	004136        	entry	a1, 32
4037802b:	03eb80        	rsr.prid	a8
4037802e:	048d80        	extui	a8, a8, 13, 1
/**
 * @brief Clear the crosscore interrupt that just occurred on the current core
 */
FORCE_INLINE_ATTR void crosscore_int_ll_clear_interrupt(int core_id)
{
    if (core_id == 0) {
40378031:	b8cc      	bnez.n	a8, 40378040 <esp_crosscore_isr+0x18>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, 0);
40378033:	f22e81        	l32r	a8, 403748ec <_iram_text_start+0x4e8> (600c0030 <SYSTEM+0x30>)
40378036:	090c      	movi.n	a9, 0
40378038:	0020c0        	memw
4037803b:	0899      	s32i.n	a9, a8, 0
4037803d:	000246        	j	4037804a <esp_crosscore_isr+0x22>
    } else {
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, 0);
40378040:	f22c81        	l32r	a8, 403748f0 <_iram_text_start+0x4ec> (600c0034 <SYSTEM+0x34>)
40378043:	090c      	movi.n	a9, 0
40378045:	0020c0        	memw
40378048:	0899      	s32i.n	a9, a8, 0
4037804a:	fb7c      	movi.n	a11, -1
4037804c:	f22aa1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92794 <reason_spinlock>)
4037804f:	020e25        	call8	4037a130 <xPortEnterCriticalTimeout>
    //Clear the interrupt first.
    crosscore_int_ll_clear_interrupt(esp_cpu_get_core_id());

    //Grab the reason and clear it.
    portENTER_CRITICAL_ISR(&reason_spinlock);
    my_reason_val = *my_reason;
40378052:	0020c0        	memw
40378055:	002272        	l32i	a7, a2, 0
    *my_reason = 0;
40378058:	080c      	movi.n	a8, 0
4037805a:	0020c0        	memw
4037805d:	006282        	s32i	a8, a2, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40378060:	f225a1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92794 <reason_spinlock>)
40378063:	0221e5        	call8	4037a280 <vPortExitCritical>

    //Check what we need to do.
    if (my_reason_val & REASON_YIELD) {
40378066:	026707        	bbci	a7, 0, 4037806c <esp_crosscore_isr+0x44>
    portYIELD_FROM_ISR();
40378069:	023125        	call8	4037a37c <_frxt_setup_switch>
    if (my_reason_val & REASON_GDB_CALL) {
        update_breakpoints();
    }
#endif // !CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME

    if (my_reason_val & REASON_PRINT_BACKTRACE) {
4037806c:	056727        	bbci	a7, 2, 40378075 <esp_crosscore_isr+0x4d>
        esp_backtrace_print(100);
4037806f:	64a0a2        	movi	a10, 100
40378072:	fdc2e5        	call8	40375ca0 <esp_backtrace_print>
         * the TWDT interrupt, call the function with `false` as a parameter. */
        task_wdt_timeout_abort(false);
    }
#endif // CONFIG_ESP_TASK_WDT_EN

}
40378075:	f01d      	retw.n
	...

40378078 <esp_crosscore_int_send>:
#endif
    ESP_ERROR_CHECK(err);
}

static void IRAM_ATTR esp_crosscore_int_send(int core_id, uint32_t reason_mask)
{
40378078:	004136        	entry	a1, 32
    assert(core_id < CONFIG_FREERTOS_NUMBER_OF_CORES);
4037807b:	01a082        	movi	a8, 1
4037807e:	0ea827        	bge	a8, a2, 40378090 <esp_crosscore_int_send+0x18>
40378081:	f21dd1        	l32r	a13, 403748f8 <_iram_text_start+0x4f4> (3c02689c <_flash_rodata_start+0x677c>)
40378084:	f21ec1        	l32r	a12, 403748fc <_iram_text_start+0x4f8> (3c028b18 <__func__$0>)
40378087:	71a0b2        	movi	a11, 113
4037808a:	f21da1        	l32r	a10, 40374900 <_iram_text_start+0x4fc> (3c0268e4 <_flash_rodata_start+0x67c4>)
4037808d:	07d125        	call8	4037fda0 <__assert_func>
40378090:	fb7c      	movi.n	a11, -1
40378092:	f218a1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92794 <reason_spinlock>)
40378095:	0209a5        	call8	4037a130 <xPortEnterCriticalTimeout>
    //Mark the reason we interrupt the other CPU
    portENTER_CRITICAL_ISR(&reason_spinlock);
    reason[core_id] |= reason_mask;
40378098:	f21b81        	l32r	a8, 40374904 <_iram_text_start+0x500> (3fc95114 <reason>)
4037809b:	a08280        	addx4	a8, a2, a8
4037809e:	0020c0        	memw
403780a1:	0898      	l32i.n	a9, a8, 0
403780a3:	209930        	or	a9, a9, a3
403780a6:	0020c0        	memw
403780a9:	0899      	s32i.n	a9, a8, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
403780ab:	f212a1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92794 <reason_spinlock>)
403780ae:	021d25        	call8	4037a280 <vPortExitCritical>
 *
 * @param core_id Core to trigger an interrupt on.
 */
FORCE_INLINE_ATTR void crosscore_int_ll_trigger_interrupt(int core_id)
{
    if (core_id == 0) {
403780b1:	b2cc      	bnez.n	a2, 403780c0 <esp_crosscore_int_send+0x48>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, SYSTEM_CPU_INTR_FROM_CPU_0);
403780b3:	f20e81        	l32r	a8, 403748ec <_iram_text_start+0x4e8> (600c0030 <SYSTEM+0x30>)
403780b6:	190c      	movi.n	a9, 1
403780b8:	0020c0        	memw
403780bb:	0899      	s32i.n	a9, a8, 0
403780bd:	000246        	j	403780ca <esp_crosscore_int_send+0x52>
    } else {
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, SYSTEM_CPU_INTR_FROM_CPU_1);
403780c0:	f20c81        	l32r	a8, 403748f0 <_iram_text_start+0x4ec> (600c0034 <SYSTEM+0x34>)
403780c3:	190c      	movi.n	a9, 1
403780c5:	0020c0        	memw
403780c8:	0899      	s32i.n	a9, a8, 0
    //Poke the other CPU.
    crosscore_int_ll_trigger_interrupt(core_id);
}
403780ca:	f01d      	retw.n

403780cc <esp_crosscore_int_send_yield>:

void IRAM_ATTR esp_crosscore_int_send_yield(int core_id)
{
403780cc:	004136        	entry	a1, 32
403780cf:	20a220        	or	a10, a2, a2
    esp_crosscore_int_send(core_id, REASON_YIELD);
403780d2:	01a0b2        	movi	a11, 1
403780d5:	fffa25        	call8	40378078 <esp_crosscore_int_send>
}
403780d8:	000090        	retw
	...

403780dc <_xt_panic>:
    .literal_position
    .align      4

_xt_panic:
    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
403780dc:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
403780de:	ffd112        	addmi	a1, a1, 0xffffff00
403780e1:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
403780e4:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
403780e6:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
403780e9:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
403780ec:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
403780ee:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
403780f1:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
403780f3:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
403780f6:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
403780f8:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
403780fb:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
403780fd:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40378100:	09c605        	call0	40381d64 <_xt_context_save>

    /* Save exc cause and vaddr into exception frame */
    rsr     a0, EXCCAUSE
40378103:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
40378106:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
40378109:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
4037810c:	156102        	s32i	a0, a1, 84

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
4037810f:	f19f01        	l32r	a0, 4037478c <_iram_text_start+0x388> (40024 <UserFrameTotalSize+0x3ff24>)
    wsr     a0, PS
40378112:	13e600        	wsr.ps	a0

    //Call panic handler
    mov     a6,sp
40378115:	016d      	mov.n	a6, a1
    call4 panicHandler
40378117:	fd8a95        	call4	403759c0 <panicHandler>

    ret
4037811a:	f00d      	ret.n

4037811c <hex_to_str>:
{
4037811c:	004136        	entry	a1, 32
    for (int i = 0; i < 8; i++) {
4037811f:	090c      	movi.n	a9, 0
40378121:	000986        	j	4037814b <hex_to_str+0x2f>
        uint8_t b4 = (n >> (28 - i * 4)) & 0b1111;
40378124:	f9c982        	addi	a8, a9, -7
40378127:	608080        	neg	a8, a8
4037812a:	1188e0        	slli	a8, a8, 2
4037812d:	400800        	ssr	a8
40378130:	918030        	srl	a8, a3
40378133:	348080        	extui	a8, a8, 0, 4
        buf[i] = b4 <= 9 ? '0' + b4 : 'a' + b4 - 10;
40378136:	9a0c      	movi.n	a10, 9
40378138:	053a87        	bltu	a10, a8, 40378141 <hex_to_str+0x25>
4037813b:	30c882        	addi	a8, a8, 48
4037813e:	000086        	j	40378144 <hex_to_str+0x28>
40378141:	57c882        	addi	a8, a8, 87
40378144:	a29a      	add.n	a10, a2, a9
40378146:	004a82        	s8i	a8, a10, 0
    for (int i = 0; i < 8; i++) {
40378149:	991b      	addi.n	a9, a9, 1
4037814b:	d589a6        	blti	a9, 8, 40378124 <hex_to_str+0x8>
}
4037814e:	f01d      	retw.n

40378150 <esp_mspi_32bit_address_flash_feature_check>:
#endif // SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE
}

#if !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM  // IDF-10019
esp_err_t IRAM_ATTR esp_mspi_32bit_address_flash_feature_check(void)
{
40378150:	004136        	entry	a1, 32
        return ESP_ERR_NOT_SUPPORTED;
    }
#endif

    return ESP_OK;
}
40378153:	020c      	movi.n	a2, 0
40378155:	f01d      	retw.n
	...

40378158 <spiflash_start_default>:
{
40378158:	004136        	entry	a1, 32
4037815b:	027d      	mov.n	a7, a2
    if (chip->os_func != NULL && chip->os_func->start != NULL) {
4037815d:	2288      	l32i.n	a8, a2, 8
4037815f:	b88c      	beqz.n	a8, 4037816e <spiflash_start_default+0x16>
40378161:	0888      	l32i.n	a8, a8, 0
40378163:	788c      	beqz.n	a8, 4037816e <spiflash_start_default+0x16>
        esp_err_t err = chip->os_func->start(chip->os_func_data);
40378165:	32a8      	l32i.n	a10, a2, 12
40378167:	0008e0        	callx8	a8
4037816a:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
4037816c:	aacc      	bnez.n	a10, 4037817a <spiflash_start_default+0x22>
    chip->host->driver->dev_config(chip->host);
4037816e:	07a8      	l32i.n	a10, a7, 0
40378170:	002a82        	l32i	a8, a10, 0
40378173:	0888      	l32i.n	a8, a8, 0
40378175:	0008e0        	callx8	a8
    return ESP_OK;
40378178:	020c      	movi.n	a2, 0
}
4037817a:	f01d      	retw.n

4037817c <spiflash_end_default>:
{
4037817c:	004136        	entry	a1, 32
4037817f:	028d      	mov.n	a8, a2
40378181:	032d      	mov.n	a2, a3
    if (chip->os_func != NULL
40378183:	2898      	l32i.n	a9, a8, 8
40378185:	b98c      	beqz.n	a9, 40378194 <spiflash_end_default+0x18>
        && chip->os_func->end != NULL) {
40378187:	1998      	l32i.n	a9, a9, 4
40378189:	798c      	beqz.n	a9, 40378194 <spiflash_end_default+0x18>
        esp_err_t end_err = chip->os_func->end(chip->os_func_data);
4037818b:	38a8      	l32i.n	a10, a8, 12
4037818d:	0009e0        	callx8	a9
        if (err == ESP_OK) {
40378190:	03cc      	bnez.n	a3, 40378194 <spiflash_end_default+0x18>
            err = end_err; // Only return the 'end' error if we haven't already failed
40378192:	0a2d      	mov.n	a2, a10
}
40378194:	f01d      	retw.n
	...

40378198 <esp_flash_chip_driver_initialized>:
{
40378198:	004136        	entry	a1, 32
    if (!chip->chip_drv) return false;
4037819b:	1288      	l32i.n	a8, a2, 4
4037819d:	388c      	beqz.n	a8, 403781a4 <esp_flash_chip_driver_initialized+0xc>
    return true;
4037819f:	120c      	movi.n	a2, 1
403781a1:	000046        	j	403781a6 <esp_flash_chip_driver_initialized+0xe>
    if (!chip->chip_drv) return false;
403781a4:	020c      	movi.n	a2, 0
}
403781a6:	f01d      	retw.n

403781a8 <esp_cpu_compare_and_set>:
#if __XTENSA__ && XCHAL_HAVE_S32C1I && CONFIG_SPIRAM
static DRAM_ATTR uint32_t external_ram_cas_lock = 0;
#endif

bool esp_cpu_compare_and_set(volatile uint32_t *addr, uint32_t compare_value, uint32_t new_value)
{
403781a8:	004136        	entry	a1, 32
    temp = *addr;
    *addr = temp;
#endif
    // Atomic compare and set using S32C1I instruction
    uint32_t old_value = new_value;
    __asm__ __volatile__ (
403781ab:	130c30        	wsr.scompare1	a3
403781ae:	00e242        	s32c1i	a4, a2, 0
        "S32C1I %0, %1, 0 \n"
        :"=r"(old_value)
        :"r"(addr), "r"(compare_value), "0"(old_value)
    );

    return (old_value == compare_value);
403781b1:	c03340        	sub	a3, a3, a4
    return ret;

#else // __riscv
    return rv_utils_compare_and_set(addr, compare_value, new_value);
#endif
}
403781b4:	40f320        	nsau	a2, a3
403781b7:	412520        	srli	a2, a2, 5
403781ba:	f01d      	retw.n

403781bc <esp_cpu_stall>:
{
403781bc:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
403781bf:	01a082        	movi	a8, 1
403781c2:	0eb827        	bgeu	a8, a2, 403781d4 <esp_cpu_stall+0x18>
403781c5:	f1d2d1        	l32r	a13, 40374910 <_iram_text_start+0x50c> (3c023450 <_flash_rodata_start+0x3330>)
403781c8:	f1d3c1        	l32r	a12, 40374914 <_iram_text_start+0x510> (3c027d5c <__func__$2>)
403781cb:	21a0b2        	movi	a11, 33
403781ce:	f1d2a1        	l32r	a10, 40374918 <_iram_text_start+0x514> (3c02349c <_flash_rodata_start+0x337c>)
403781d1:	07bce5        	call8	4037fda0 <__assert_func>

        Note: This function can be called when the cache is disabled. We use "ternary if" instead of an array so that the
        "rodata" of the register masks/shifts will be stored in this function's "rodata" section, instead of the source
        file's "rodata" section (see IDF-5214).
    */
    uint32_t rtc_cntl_c0_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
403781d4:	00c256        	bnez	a2, 403781e4 <esp_cpu_stall+0x28>
    uint32_t rtc_cntl_c0_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_S : RTC_CNTL_SW_STALL_APPCPU_C0_S;
    uint32_t rtc_cntl_c1_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
403781d7:	f1cc81        	l32r	a8, 40374908 <_iram_text_start+0x504> (fc000000 <_rtc_reserved_end+0x9bf00000>)
    uint32_t rtc_cntl_c0_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
403781da:	2d0c      	movi.n	a13, 2
403781dc:	c90c      	movi.n	a9, 12
    uint32_t rtc_cntl_c1_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
403781de:	ac1c      	movi.n	a12, 26
403781e0:	000246        	j	403781ed <esp_cpu_stall+0x31>
403781e3:	ca8100        	float.s	f8, a1, 0
    uint32_t rtc_cntl_c1_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
403781e6:	0d0cf1        	l32r	a15, 4033b618 <rom_rx_gain_force+0x3351ec>
403781e9:	390c      	movi.n	a9, 3
    uint32_t rtc_cntl_c1_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
403781eb:	4c1c      	movi.n	a12, 20
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0_m);
403781ed:	f1cba1        	l32r	a10, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
403781f0:	0020c0        	memw
403781f3:	0ab8      	l32i.n	a11, a10, 0
403781f5:	1099b0        	and	a9, a9, a11
403781f8:	3099b0        	xor	a9, a9, a11
403781fb:	0020c0        	memw
403781fe:	0a99      	s32i.n	a9, a10, 0
    SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, 2 << rtc_cntl_c0_s);
40378200:	0020c0        	memw
40378203:	0a98      	l32i.n	a9, a10, 0
40378205:	2b0c      	movi.n	a11, 2
40378207:	401d00        	ssl	a13
4037820a:	a1bb00        	sll	a11, a11
4037820d:	2099b0        	or	a9, a9, a11
40378210:	0020c0        	memw
40378213:	0a99      	s32i.n	a9, a10, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1_m);
40378215:	f1c291        	l32r	a9, 40374920 <_iram_text_start+0x51c> (600080bc <RTCCNTL+0xbc>)
40378218:	0020c0        	memw
4037821b:	09a8      	l32i.n	a10, a9, 0
4037821d:	1088a0        	and	a8, a8, a10
40378220:	3088a0        	xor	a8, a8, a10
40378223:	0020c0        	memw
40378226:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, 0x21 << rtc_cntl_c1_s);
40378228:	0020c0        	memw
4037822b:	0988      	l32i.n	a8, a9, 0
4037822d:	1a2c      	movi.n	a10, 33
4037822f:	401c00        	ssl	a12
40378232:	a1aa00        	sll	a10, a10
40378235:	2088a0        	or	a8, a8, a10
40378238:	0020c0        	memw
4037823b:	0989      	s32i.n	a8, a9, 0
}
4037823d:	f01d      	retw.n
	...

40378240 <esp_cpu_unstall>:
{
40378240:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
40378243:	01a082        	movi	a8, 1
40378246:	0eb827        	bgeu	a8, a2, 40378258 <esp_cpu_unstall+0x18>
40378249:	f1b1d1        	l32r	a13, 40374910 <_iram_text_start+0x50c> (3c023450 <_flash_rodata_start+0x3330>)
4037824c:	f1b6c1        	l32r	a12, 40374924 <_iram_text_start+0x520> (3c027d4c <__func__$1>)
4037824f:	29a0b2        	movi	a11, 41
40378252:	f1b1a1        	l32r	a10, 40374918 <_iram_text_start+0x514> (3c02349c <_flash_rodata_start+0x337c>)
40378255:	07b4a5        	call8	4037fda0 <__assert_func>

        Note: This function can be called when the cache is disabled. We use "ternary if" instead of an array so that the
        "rodata" of the register masks/shifts will be stored in this function's "rodata" section, instead of the source
        file's "rodata" section (see IDF-5214).
    */
    uint32_t rtc_cntl_c0 = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
40378258:	004256        	bnez	a2, 40378260 <esp_cpu_unstall+0x20>
4037825b:	c80c      	movi.n	a8, 12
4037825d:	000046        	j	40378262 <esp_cpu_unstall+0x22>
40378260:	380c      	movi.n	a8, 3
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0);
40378262:	f1ae91        	l32r	a9, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
40378265:	0020c0        	memw
40378268:	09a8      	l32i.n	a10, a9, 0
4037826a:	1088a0        	and	a8, a8, a10
4037826d:	3088a0        	xor	a8, a8, a10
40378270:	0020c0        	memw
40378273:	0989      	s32i.n	a8, a9, 0
    int rtc_cntl_c1 = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40378275:	42cc      	bnez.n	a2, 4037827d <esp_cpu_unstall+0x3d>
40378277:	f1a481        	l32r	a8, 40374908 <_iram_text_start+0x504> (fc000000 <_rtc_reserved_end+0x9bf00000>)
4037827a:	000086        	j	40378280 <esp_cpu_unstall+0x40>
4037827d:	f1a381        	l32r	a8, 4037490c <_iram_text_start+0x508> (3f00000 <UserFrameTotalSize+0x3efff00>)
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1);
40378280:	f1a891        	l32r	a9, 40374920 <_iram_text_start+0x51c> (600080bc <RTCCNTL+0xbc>)
40378283:	0020c0        	memw
40378286:	09a8      	l32i.n	a10, a9, 0
40378288:	1088a0        	and	a8, a8, a10
4037828b:	3088a0        	xor	a8, a8, a10
4037828e:	0020c0        	memw
40378291:	0989      	s32i.n	a8, a9, 0
}
40378293:	f01d      	retw.n
40378295:	000000        	ill

40378298 <esp_cpu_wait_for_intr>:
{
40378298:	004136        	entry	a1, 32
    asm volatile ("waiti 0\n");
4037829b:	007000        	waiti	0
}
4037829e:	f01d      	retw.n

403782a0 <esp_ptr_byte_accessible>:
    return false;
#endif  //CONFIG_SPIRAM
}

bool esp_ptr_byte_accessible(const void *p)
{
403782a0:	004136        	entry	a1, 32
    intptr_t ip = (intptr_t) p;
    bool r;
    r = (ip >= SOC_BYTE_ACCESSIBLE_LOW && ip < SOC_BYTE_ACCESSIBLE_HIGH);
403782a3:	f0f891        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
403782a6:	929a      	add.n	a9, a2, a9
403782a8:	f16581        	l32r	a8, 4037483c <_iram_text_start+0x438> (77fff <UserFrameTotalSize+0x77eff>)
403782ab:	628890        	lsi	f9, a8, 0x188
403782ae:	880b      	addi.n	a8, a8, -1
403782b0:	608080        	neg	a8, a8
403782b3:	748080        	extui	a8, a8, 0, 8
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
    /* For ESP32 case, RTC fast memory is accessible to PRO cpu only and hence
     * for single core configuration (where it gets added to system heap) following
     * additional check is required */
    r |= (ip >= SOC_RTC_DRAM_LOW && ip < SOC_RTC_DRAM_HIGH);
403782b6:	f0cd91        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403782b9:	929a      	add.n	a9, a2, a9
403782bb:	f0cd21        	l32r	a2, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403782be:	622290        	lsi	f9, a2, 0x188
403782c1:	220b      	addi.n	a2, a2, -1
403782c3:	602020        	neg	a2, a2
403782c6:	742020        	extui	a2, a2, 0, 8
     * from the internal RAM in terms of hardware attributes. It is a part of
     * the internal RAM when added to the heap and is byte-accessible .*/
    r |= (ip >= SOC_DROM_LOW && ip < (SOC_DROM_LOW + 0x4000));
#endif
    return r;
}
403782c9:	202280        	or	a2, a2, a8
403782cc:	f01d      	retw.n
	...

403782d0 <s_mspi_flash_set_core_clock>:
/**
 * Currently we only need these on chips with timing tuning
 */
//-------------------------------------MSPI Clock Setting-------------------------------------//
static void s_mspi_flash_set_core_clock(uint8_t spi_num, uint32_t core_clock_mhz)
{
403782d0:	004136        	entry	a1, 32
__attribute__((always_inline))
static inline void mspi_timing_ll_set_core_clock(uint8_t spi_num, uint32_t core_clk_mhz)
{
    uint32_t reg_val = 0;

    switch (core_clk_mhz) {
403782d3:	a0a082        	movi	a8, 160
403782d6:	271387        	beq	a3, a8, 40378301 <s_mspi_flash_set_core_clock+0x31>
403782d9:	0f3837        	bltu	a8, a3, 403782ec <s_mspi_flash_set_core_clock+0x1c>
403782dc:	085c      	movi.n	a8, 80
403782de:	271387        	beq	a3, a8, 40378309 <s_mspi_flash_set_core_clock+0x39>
403782e1:	78a082        	movi	a8, 120
403782e4:	261387        	beq	a3, a8, 4037830e <s_mspi_flash_set_core_clock+0x3e>
403782e7:	0001c6        	j	403782f2 <s_mspi_flash_set_core_clock+0x22>
403782ea:	820000        	mull	a0, a0, a0
403782ed:	87f0a0        	lsi	f10, a0, 0x21c
403782f0:	d12113        	lsi	f1, a1, 0x344
            break;
        case 240:
            reg_val = 3;
            break;
        default:
            HAL_ASSERT(false);
403782f3:	f18d      	lsi	f8, a1, 4
403782f5:	f18dc1        	l32r	a12, 4037492c <_iram_text_start+0x528> (3fc93808 <__func__$1>)
403782f8:	b0a0b2        	movi	a11, 176
403782fb:	f18da1        	l32r	a10, 40374930 <_iram_text_start+0x52c> (3fc93aa0 <__FUNCTION__$0+0x1e8>)
403782fe:	07aa25        	call8	4037fda0 <__assert_func>
            reg_val = 2;
40378301:	2b0c      	movi.n	a11, 2
40378303:	0003c6        	j	40378316 <s_mspi_flash_set_core_clock+0x46>
40378306:	000000        	ill
    switch (core_clk_mhz) {
40378309:	0b0c      	movi.n	a11, 0
4037830b:	0001c6        	j	40378316 <s_mspi_flash_set_core_clock+0x46>
            reg_val = 1;
4037830e:	1b0c      	movi.n	a11, 1
40378310:	000086        	j	40378316 <s_mspi_flash_set_core_clock+0x46>
40378313:	3b0c00        	ueq.s	b0, f12, f0
    }

    REG_SET_FIELD(SPI_MEM_CORE_CLK_SEL_REG(spi_num), SPI_MEM_CORE_CLK_SEL, reg_val);
40378316:	f18781        	l32r	a8, 40374934 <_iram_text_start+0x530> (60003 <UserFrameTotalSize+0x5ff03>)
40378319:	c08820        	sub	a8, a8, a2
4037831c:	118840        	slli	a8, a8, 12
4037831f:	eca092        	movi	a9, 236
40378322:	889a      	add.n	a8, a8, a9
40378324:	0020c0        	memw
40378327:	0898      	l32i.n	a9, a8, 0
40378329:	ca7c      	movi.n	a10, -4
4037832b:	1099a0        	and	a9, a9, a10
4037832e:	2099b0        	or	a9, a9, a11
40378331:	0020c0        	memw
40378334:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_core_clock(spi_num, core_clock_mhz);
}
40378336:	f01d      	retw.n

40378338 <s_mspi_psram_set_core_clock>:

static void s_mspi_psram_set_core_clock(uint8_t spi_num, uint32_t core_clock_mhz)
{
40378338:	004136        	entry	a1, 32
    switch (core_clk_mhz) {
4037833b:	a0a082        	movi	a8, 160
4037833e:	271387        	beq	a3, a8, 40378369 <s_mspi_psram_set_core_clock+0x31>
40378341:	0f3837        	bltu	a8, a3, 40378354 <s_mspi_psram_set_core_clock+0x1c>
40378344:	085c      	movi.n	a8, 80
40378346:	271387        	beq	a3, a8, 40378371 <s_mspi_psram_set_core_clock+0x39>
40378349:	78a082        	movi	a8, 120
4037834c:	261387        	beq	a3, a8, 40378376 <s_mspi_psram_set_core_clock+0x3e>
4037834f:	0001c6        	j	4037835a <s_mspi_psram_set_core_clock+0x22>
40378352:	820000        	mull	a0, a0, a0
40378355:	87f0a0        	lsi	f10, a0, 0x21c
40378358:	d12113        	lsi	f1, a1, 0x344
            HAL_ASSERT(false);
4037835b:	c1f173        	lsi	f7, a1, 0x304
4037835e:	b2f173        	lsi	f7, a1, 0x2c8
40378361:	a1b0a0        	lsi	f10, a0, 0x284
40378364:	a5f173        	lsi	f7, a1, 0x294
40378367:	0c07a3        	lsi	f10, a7, 48
            reg_val = 2;
4037836a:	c62b      	addi.n	a12, a6, 2
4037836c:	000003        	lsi	f0, a0, 0
4037836f:	0c0000        	lsi	f0, a0, 48
    switch (core_clk_mhz) {
40378372:	c60b      	addi.n	a12, a6, -1
40378374:	0c0001        	l32r	a0, 4033b374 <rom_rx_gain_force+0x334f48>
            reg_val = 1;
40378377:	861b      	addi.n	a8, a6, 1
40378379:	000000        	ill
            reg_val = 3;
4037837c:	3b0c      	movi.n	a11, 3
    REG_SET_FIELD(SPI_MEM_CORE_CLK_SEL_REG(spi_num), SPI_MEM_CORE_CLK_SEL, reg_val);
4037837e:	f16d81        	l32r	a8, 40374934 <_iram_text_start+0x530> (60003 <UserFrameTotalSize+0x5ff03>)
40378381:	c08820        	sub	a8, a8, a2
40378384:	118840        	slli	a8, a8, 12
40378387:	eca092        	movi	a9, 236
4037838a:	889a      	add.n	a8, a8, a9
4037838c:	0020c0        	memw
4037838f:	0898      	l32i.n	a9, a8, 0
40378391:	ca7c      	movi.n	a10, -4
40378393:	1099a0        	and	a9, a9, a10
40378396:	2099b0        	or	a9, a9, a11
40378399:	0020c0        	memw
4037839c:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_core_clock(spi_num, core_clock_mhz);
}
4037839e:	f01d      	retw.n

403783a0 <mspi_timing_config_set_flash_clock>:

void mspi_timing_config_set_flash_clock(uint32_t flash_freq_mhz, mspi_timing_speed_mode_t speed_mode, bool control_both_mspi)
{
403783a0:	004136        	entry	a1, 32
403783a3:	744040        	extui	a4, a4, 0, 8
        core_clock_mhz = FLASH_LOW_SPEED_CORE_CLOCK_MHZ;
    } else {
        core_clock_mhz = FLASH_HIGH_SPEED_CORE_CLOCK_MHZ;
    }
    //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
    s_mspi_flash_set_core_clock(0, core_clock_mhz);
403783a6:	50a0b2        	movi	a11, 80
403783a9:	00a0a2        	movi	a10, 0
403783ac:	fff225        	call8	403782d0 <s_mspi_flash_set_core_clock>

    uint32_t freqdiv = core_clock_mhz / flash_freq_mhz;
403783af:	095c      	movi.n	a9, 80
403783b1:	c28920        	quou	a8, a9, a2
    assert(freqdiv > 0);
403783b4:	0db927        	bgeu	a9, a2, 403783c5 <mspi_timing_config_set_flash_clock+0x25>
403783b7:	f160d1        	l32r	a13, 40374938 <_iram_text_start+0x534> (3fc93ad4 <__FUNCTION__$0+0x21c>)
403783ba:	f160c1        	l32r	a12, 4037493c <_iram_text_start+0x538> (3fc93828 <__func__$2>)
403783bd:	1b3c      	movi.n	a11, 49
403783bf:	f160a1        	l32r	a10, 40374940 <_iram_text_start+0x53c> (3fc93b20 <__FUNCTION__$0+0x268>)
403783c2:	079de5        	call8	4037fda0 <__assert_func>
 * @param freqdiv  Divider value
 */
__attribute__((always_inline))
static inline void mspi_timing_ll_set_flash_clock(uint8_t spi_num, uint32_t freqdiv)
{
    if (freqdiv == 1) {
403783c5:	0d1866        	bnei	a8, 1, 403783d6 <mspi_timing_config_set_flash_clock+0x36>
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
403783c8:	f15f91        	l32r	a9, 40374944 <_iram_text_start+0x540> (60003014 <SPIMEM0+0x14>)
403783cb:	f054a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403783ce:	0020c0        	memw
403783d1:	09a9      	s32i.n	a10, a9, 0
403783d3:	000686        	j	403783f1 <mspi_timing_config_set_flash_clock+0x51>
    } else {
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
403783d6:	a80b      	addi.n	a10, a8, -1
403783d8:	11ba00        	slli	a11, a10, 16
403783db:	419180        	srli	a9, a8, 1
403783de:	990b      	addi.n	a9, a9, -1
403783e0:	119980        	slli	a9, a9, 8
403783e3:	209b90        	or	a9, a11, a9
403783e6:	20aa90        	or	a10, a10, a9
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), freqbits);
403783e9:	f15691        	l32r	a9, 40374944 <_iram_text_start+0x540> (60003014 <SPIMEM0+0x14>)
403783ec:	0020c0        	memw
403783ef:	09a9      	s32i.n	a10, a9, 0
    mspi_timing_ll_set_flash_clock(0, freqdiv);
    if (control_both_mspi) {
403783f1:	b4ac      	beqz.n	a4, 40378420 <mspi_timing_config_set_flash_clock+0x80>
    if (freqdiv == 1) {
403783f3:	0e1866        	bnei	a8, 1, 40378405 <mspi_timing_config_set_flash_clock+0x65>
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
403783f6:	f15481        	l32r	a8, 40374948 <_iram_text_start+0x544> (60002014 <SPIMEM1+0x14>)
403783f9:	f04891        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403783fc:	0020c0        	memw
403783ff:	0899      	s32i.n	a9, a8, 0
40378401:	0006c6        	j	40378420 <mspi_timing_config_set_flash_clock+0x80>
40378404:	980b00        	lsi	f0, a11, 0x260
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
40378407:	11a900        	slli	a10, a9, 16
4037840a:	418180        	srli	a8, a8, 1
4037840d:	880b      	addi.n	a8, a8, -1
4037840f:	118880        	slli	a8, a8, 8
40378412:	208a80        	or	a8, a10, a8
40378415:	209980        	or	a9, a9, a8
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), freqbits);
40378418:	f14c81        	l32r	a8, 40374948 <_iram_text_start+0x544> (60002014 <SPIMEM1+0x14>)
4037841b:	0020c0        	memw
4037841e:	0899      	s32i.n	a9, a8, 0
        mspi_timing_ll_set_flash_clock(1, freqdiv);
    }
}
40378420:	f01d      	retw.n
	...

40378424 <mspi_timing_config_set_psram_clock>:

void mspi_timing_config_set_psram_clock(uint32_t psram_freq_mhz, mspi_timing_speed_mode_t speed_mode, bool control_both_mspi)
{
40378424:	004136        	entry	a1, 32
        core_clock_mhz = PSRAM_LOW_SPEED_CORE_CLOCK_MHZ;
    } else {
        core_clock_mhz = PSRAM_HIGH_SPEED_CORE_CLOCK_MHZ;
    }
    //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
    s_mspi_psram_set_core_clock(0, core_clock_mhz);
40378427:	0b5c      	movi.n	a11, 80
40378429:	0a0c      	movi.n	a10, 0
4037842b:	fff0e5        	call8	40378338 <s_mspi_psram_set_core_clock>

    uint32_t freqdiv = core_clock_mhz / psram_freq_mhz;
4037842e:	095c      	movi.n	a9, 80
40378430:	c28920        	quou	a8, a9, a2
    assert(freqdiv > 0);
40378433:	0db927        	bgeu	a9, a2, 40378444 <mspi_timing_config_set_psram_clock+0x20>
40378436:	f140d1        	l32r	a13, 40374938 <_iram_text_start+0x534> (3fc93ad4 <__FUNCTION__$0+0x21c>)
40378439:	f144c1        	l32r	a12, 4037494c <_iram_text_start+0x548> (3fc937e4 <__func__$0>)
4037843c:	5b4c      	movi.n	a11, 69
4037843e:	f140a1        	l32r	a10, 40374940 <_iram_text_start+0x53c> (3fc93b20 <__FUNCTION__$0+0x268>)
40378441:	0795e5        	call8	4037fda0 <__assert_func>
 * @param freqdiv  Divider value
 */
__attribute__((always_inline))
static inline void mspi_timing_ll_set_psram_clock(uint8_t spi_num, uint32_t freqdiv)
{
    if (freqdiv == 1) {
40378444:	0d1866        	bnei	a8, 1, 40378455 <mspi_timing_config_set_psram_clock+0x31>
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), SPI_MEM_SCLK_EQU_SYSCLK);
40378447:	f14281        	l32r	a8, 40374950 <_iram_text_start+0x54c> (60003050 <SPIMEM0+0x50>)
4037844a:	f03491        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037844d:	0020c0        	memw
40378450:	0899      	s32i.n	a9, a8, 0
40378452:	000686        	j	40378470 <mspi_timing_config_set_psram_clock+0x4c>
    } else {
        uint32_t freqbits = (((freqdiv-1)<<SPI_MEM_SCLKCNT_N_S)) | (((freqdiv/2-1)<<SPI_MEM_SCLKCNT_H_S)) | ((freqdiv-1)<<SPI_MEM_SCLKCNT_L_S);
40378455:	980b      	addi.n	a9, a8, -1
40378457:	11a900        	slli	a10, a9, 16
4037845a:	418180        	srli	a8, a8, 1
4037845d:	880b      	addi.n	a8, a8, -1
4037845f:	118880        	slli	a8, a8, 8
40378462:	208a80        	or	a8, a10, a8
40378465:	209980        	or	a9, a9, a8
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), freqbits);
40378468:	f13a81        	l32r	a8, 40374950 <_iram_text_start+0x54c> (60003050 <SPIMEM0+0x50>)
4037846b:	0020c0        	memw
4037846e:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_psram_clock(0, freqdiv);
}
40378470:	f01d      	retw.n
	...

40378474 <mspi_timing_enter_low_speed_mode>:

/*------------------------------------------------------------------------------
 * APIs to make SPI0 (and SPI1) FLASH work for high/low freq
 *----------------------------------------------------------------------------*/
void mspi_timing_enter_low_speed_mode(bool control_spi1)
{
40378474:	004136        	entry	a1, 32
40378477:	742020        	extui	a2, a2, 0, 8
     *
     * Currently we only need to change these clocks on chips with timing tuning
     * Should be extended to other no-timing-tuning chips if needed. e.g.:
     * we still need to turn down Flash / PSRAM clock speed at a certain period of time
     */
    mspi_timing_config_set_flash_clock(20, MSPI_TIMING_SPEED_MODE_LOW_PERF, control_spi1);
4037847a:	20c220        	or	a12, a2, a2
4037847d:	00a0b2        	movi	a11, 0
40378480:	4a1c      	movi.n	a10, 20
40378482:	fff1e5        	call8	403783a0 <mspi_timing_config_set_flash_clock>
    mspi_timing_config_set_psram_clock(20, MSPI_TIMING_SPEED_MODE_LOW_PERF, control_spi1);
40378485:	02cd      	mov.n	a12, a2
40378487:	0b0c      	movi.n	a11, 0
40378489:	4a1c      	movi.n	a10, 20
4037848b:	fff9a5        	call8	40378424 <mspi_timing_config_set_psram_clock>

#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
    mspi_timing_flash_config_clear_tuning_regs(control_spi1);
    mspi_timing_psram_config_clear_tuning_regs(control_spi1);
#endif  //#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
}
4037848e:	f01d      	retw.n

40378490 <mspi_timing_enter_high_speed_mode>:
 * iF control_spi1 == 1, will also update SPI1 timing registers. Should only be set to 1 when do tuning.
 *
 * This function should always be called after `mspi_timing_flash_tuning` or `calculate_best_flash_tuning_config`
 */
void mspi_timing_enter_high_speed_mode(bool control_spi1)
{
40378490:	004136        	entry	a1, 32
    /**
     * Currently we only need to change these clocks on chips with timing tuning
     * Should be extended to other no-timing-tuning chips if needed. e.g.:
     * we still need to turn down Flash / PSRAM clock speed at a certain period of time
     */
    mspi_timing_config_set_flash_clock(FLASH_FREQUENCY_MHZ, MSPI_TIMING_SPEED_MODE_NORMAL_PERF, control_spi1);
40378493:	74c020        	extui	a12, a2, 0, 8
40378496:	01a0b2        	movi	a11, 1
40378499:	50a0a2        	movi	a10, 80
4037849c:	fff025        	call8	403783a0 <mspi_timing_config_set_flash_clock>

#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
    mspi_timing_flash_config_set_tuning_regs(control_spi1);
    mspi_timing_psram_config_set_tuning_regs(control_spi1);
#endif  //#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
}
4037849f:	000090        	retw
	...

403784a4 <mspi_timing_change_speed_mode_cache_safe>:

void mspi_timing_change_speed_mode_cache_safe(bool switch_down)
{
403784a4:	004136        	entry	a1, 32
403784a7:	742020        	extui	a2, a2, 0, 8
     * - or other way
     *
     * for preventing concurrent from MSPI to external memory
     */
#if SOC_CACHE_FREEZE_SUPPORTED
    cache_hal_freeze(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403784aa:	2b0c      	movi.n	a11, 2
403784ac:	1a0c      	movi.n	a10, 1
403784ae:	046fe5        	call8	4037cbac <cache_hal_freeze>
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

    if (switch_down) {
403784b1:	728c      	beqz.n	a2, 403784bc <mspi_timing_change_speed_mode_cache_safe+0x18>
        //enter MSPI low speed mode, extra delays should be removed
        mspi_timing_enter_low_speed_mode(false);
403784b3:	0a0c      	movi.n	a10, 0
403784b5:	fffbe5        	call8	40378474 <mspi_timing_enter_low_speed_mode>
403784b8:	000186        	j	403784c2 <mspi_timing_change_speed_mode_cache_safe+0x1e>
403784bb:	a0a200        	addx4	a10, a2, a0
    } else {
        //enter MSPI high speed mode, extra delays should be considered
        mspi_timing_enter_high_speed_mode(false);
403784be:	fd2500        	lsi	f0, a5, 0x3f4
403784c1:	ff          	.byte	0xff
    }

#if SOC_CACHE_FREEZE_SUPPORTED
    cache_hal_unfreeze(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403784c2:	02a0b2        	movi	a11, 2
403784c5:	1a0c      	movi.n	a10, 1
403784c7:	047225        	call8	4037cbe8 <cache_hal_unfreeze>
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE && !CONFIG_FREERTOS_UNICORE
    esp_ipc_isr_release_other_cpu();
#endif
}
403784ca:	f01d      	retw.n

403784cc <spi_timing_get_flash_timing_param>:
    // Get CS setup/hold value here.
    mspi_timing_config_get_cs_timing(&out_timing_config->cs_setup, &out_timing_config->cs_hold);
}
#else
void spi_timing_get_flash_timing_param(spi_flash_hal_timing_config_t *out_timing_config)
{
403784cc:	004136        	entry	a1, 32
    // This function shouldn't be called if timing tuning is not used.
    abort();
403784cf:	078165        	call8	4037fce4 <abort>
	...

403784d4 <mspi_timing_set_pin_drive_strength>:

/*------------------------------------------------------------------------------
 * Common settings
 *----------------------------------------------------------------------------*/
void mspi_timing_set_pin_drive_strength(void)
{
403784d4:	00a136        	entry	a1, 80
    SET_PERI_REG_MASK(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPICLK_PAD_DRV_CTL_EN);
403784d7:	f11f81        	l32r	a8, 40374954 <_iram_text_start+0x550> (600033fc <SPIMEM0+0x3fc>)
403784da:	0020c0        	memw
403784dd:	0898      	l32i.n	a9, a8, 0
403784df:	0a1c      	movi.n	a10, 16
403784e1:	2099a0        	or	a9, a9, a10
403784e4:	0020c0        	memw
403784e7:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPI_SMEM_SPICLK_FUN_DRV, val);
403784e9:	0020c0        	memw
403784ec:	0898      	l32i.n	a9, a8, 0
403784ee:	3a0c      	movi.n	a10, 3
403784f0:	2099a0        	or	a9, a9, a10
403784f3:	0020c0        	memw
403784f6:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPI_FMEM_SPICLK_FUN_DRV, val);
403784f8:	0020c0        	memw
403784fb:	0898      	l32i.n	a9, a8, 0
403784fd:	ca0c      	movi.n	a10, 12
403784ff:	2099a0        	or	a9, a9, a10
40378502:	0020c0        	memw
40378505:	0899      	s32i.n	a9, a8, 0
    uint32_t regs[] = {IO_MUX_GPIO27_REG, IO_MUX_GPIO28_REG,
40378507:	4c2c      	movi.n	a12, 36
40378509:	f113b1        	l32r	a11, 40374958 <_iram_text_start+0x554> (3fc9384c <__func__$2+0x24>)
4037850c:	01ad      	mov.n	a10, a1
4037850e:	eff181        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40378511:	0008e0        	callx8	a8
    for (int i = 0; i < ARRAY_SIZE(regs); i++) {
40378514:	080c      	movi.n	a8, 0
40378516:	000586        	j	40378530 <mspi_timing_set_pin_drive_strength+0x5c>
        PIN_SET_DRV(regs[i], val);
40378519:	a09810        	addx4	a9, a8, a1
4037851c:	09a8      	l32i.n	a10, a9, 0
4037851e:	0020c0        	memw
40378521:	0a98      	l32i.n	a9, a10, 0
40378523:	f10eb1        	l32r	a11, 4037495c <_iram_text_start+0x558> (c00 <UserFrameTotalSize+0xb00>)
40378526:	2099b0        	or	a9, a9, a11
40378529:	0020c0        	memw
4037852c:	0a99      	s32i.n	a9, a10, 0
    for (int i = 0; i < ARRAY_SIZE(regs); i++) {
4037852e:	881b      	addi.n	a8, a8, 1
40378530:	890c      	movi.n	a9, 8
40378532:	e3b987        	bgeu	a9, a8, 40378519 <mspi_timing_set_pin_drive_strength+0x45>
#if SOC_MEMSPI_TIMING_TUNING_BY_MSPI_DELAY
    //For now, set them all to 3. Need to check after QVL test results are out. TODO: IDF-3663
    //Set default pin drive
    mspi_timing_ll_set_all_pin_drive(0, 3);
#endif  //  #if SOC_MEMSPI_TIMING_TUNING_BY_MSPI_DELAY
}
40378535:	f01d      	retw.n
	...

40378538 <mspi_timing_flash_tuning>:
{
40378538:	004136        	entry	a1, 32
}
4037853b:	f01d      	retw.n
4037853d:	000000        	ill

40378540 <spi_flash_timing_is_tuned>:
{
40378540:	004136        	entry	a1, 32
}
40378543:	020c      	movi.n	a2, 0
40378545:	f01d      	retw.n
	...

40378548 <rtc_clk_bbpll_disable>:
{
    return clk_ll_rtc_fast_get_src();
}

static void rtc_clk_bbpll_disable(void)
{
40378548:	004136        	entry	a1, 32
/**
 * @brief Power down BBPLL circuit
 */
static inline __attribute__((always_inline)) void clk_ll_bbpll_disable(void)
{
    REG_SET_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
4037854b:	f0f491        	l32r	a9, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
4037854e:	0020c0        	memw
40378551:	0988      	l32i.n	a8, a9, 0
40378553:	40a5a2        	movi	a10, 0x540
40378556:	2088a0        	or	a8, a8, a10
40378559:	0020c0        	memw
4037855c:	0989      	s32i.n	a8, a9, 0
    clk_ll_bbpll_disable();
    s_cur_pll_freq = 0;
4037855e:	f10081        	l32r	a8, 40374960 <_iram_text_start+0x55c> (3fc94c28 <s_cur_pll_freq>)
40378561:	090c      	movi.n	a9, 0
40378563:	0899      	s32i.n	a9, a8, 0
}
40378565:	f01d      	retw.n
	...

40378568 <rtc_clk_bbpll_enable>:

static void rtc_clk_bbpll_enable(void)
{
40378568:	004136        	entry	a1, 32
    REG_CLR_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
4037856b:	f0ec91        	l32r	a9, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
4037856e:	0020c0        	memw
40378571:	0988      	l32i.n	a8, a9, 0
40378573:	bfaaa2        	movi	a10, 0xfffffabf
40378576:	1088a0        	and	a8, a8, a10
40378579:	0020c0        	memw
4037857c:	0989      	s32i.n	a8, a9, 0
    clk_ll_bbpll_enable();
}
4037857e:	f01d      	retw.n

40378580 <rtc_clk_cpu_freq_to_8m>:

    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
}

static void rtc_clk_cpu_freq_to_8m(void)
{
40378580:	004136        	entry	a1, 32
    assert(0 && "LDO dbias need to modified");
40378583:	f0f8d1        	l32r	a13, 40374964 <_iram_text_start+0x560> (3fc93988 <__FUNCTION__$0+0xd0>)
40378586:	f0f8c1        	l32r	a12, 40374968 <_iram_text_start+0x564> (3fc93870 <__func__$2>)
40378589:	9da1b2        	movi	a11, 0x19d
4037858c:	f0f8a1        	l32r	a10, 4037496c <_iram_text_start+0x568> (3fc939d9 <__FUNCTION__$0+0x121>)
4037858f:	078125        	call8	4037fda0 <__assert_func>
	...

40378594 <rtc_clk_bbpll_configure>:
{
40378594:	004136        	entry	a1, 32
 *
 * @param pll_freq_mhz PLL frequency, in MHz
 */
static inline __attribute__((always_inline)) void clk_ll_bbpll_set_freq_mhz(uint32_t pll_freq_mhz)
{
    switch (pll_freq_mhz) {
40378597:	40a182        	movi	a8, 0x140
4037859a:	0a1387        	beq	a3, a8, 403785a8 <rtc_clk_bbpll_configure+0x14>
4037859d:	e0a182        	movi	a8, 0x1e0
403785a0:	191387        	beq	a3, a8, 403785bd <rtc_clk_bbpll_configure+0x29>
403785a3:	000ac6        	j	403785d2 <rtc_clk_bbpll_configure+0x3e>
403785a6:	910000        	srl	a0, a0
    case CLK_LL_PLL_320M_FREQ_MHZ: // PLL_320M
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 0);
403785a9:	c0f0f2        	s32ri	a15, a0, 0x300
403785ac:	880020        	lsi	f2, a0, 0x220
403785af:	7c09      	s32i.n	a0, a12, 28
403785b1:	a0ba      	add.n	a10, a0, a11
403785b3:	1088      	l32i.n	a8, a0, 4
403785b5:	0020c0        	memw
403785b8:	0989      	s32i.n	a8, a9, 0
        break;
403785ba:	0005c6        	j	403785d5 <rtc_clk_bbpll_configure+0x41>
    case CLK_LL_PLL_480M_FREQ_MHZ: // PLL_480M
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 1);
403785bd:	f0ec91        	l32r	a9, 40374970 <_iram_text_start+0x56c> (600c0010 <SYSTEM+0x10>)
403785c0:	0020c0        	memw
403785c3:	0988      	l32i.n	a8, a9, 0
403785c5:	4a0c      	movi.n	a10, 4
403785c7:	2088a0        	or	a8, a8, a10
403785ca:	0020c0        	memw
403785cd:	0989      	s32i.n	a8, a9, 0
        break;
403785cf:	000086        	j	403785d5 <rtc_clk_bbpll_configure+0x41>
    default:
        abort();
403785d2:	077125        	call8	4037fce4 <abort>
/**
 * @brief Start BBPLL self-calibration
 */
static inline __attribute__((always_inline)) void regi2c_ctrl_ll_bbpll_calibration_start(void)
{
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
403785d5:	f0e781        	l32r	a8, 40374974 <_iram_text_start+0x570> (6000e040 <SENS+0x5840>)
403785d8:	0020c0        	memw
403785db:	002892        	l32i	a9, a8, 0
403785de:	fbafa2        	movi	a10, -5
403785e1:	1099a0        	and	a9, a9, a10
403785e4:	0020c0        	memw
403785e7:	006892        	s32i	a9, a8, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
403785ea:	0020c0        	memw
403785ed:	0898      	l32i.n	a9, a8, 0
403785ef:	8a0c      	movi.n	a10, 8
403785f1:	2099a0        	or	a9, a9, a10
403785f4:	0020c0        	memw
403785f7:	0899      	s32i.n	a9, a8, 0
    uint8_t dr3;
    uint8_t dchgp;
    uint8_t dcur;
    uint8_t dbias = 3;

    if (pll_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
403785f9:	e0a182        	movi	a8, 0x1e0
403785fc:	2c9387        	bne	a3, a8, 4037862c <rtc_clk_bbpll_configure+0x98>
        /* Configure 480M PLL */
        switch (xtal_freq_mhz) {
403785ff:	0ac226        	beqi	a2, 32, 4037860d <rtc_clk_bbpll_configure+0x79>
            div_ref = 0;
            div7_0 = 8;
            dr1 = 0;
            dr3 = 0;
            dchgp = 5;
            dcur = 3;
40378602:	370c      	movi.n	a7, 3
            dchgp = 5;
40378604:	520c      	movi.n	a2, 5
            div7_0 = 8;
40378606:	0a4d      	mov.n	a4, a10
            div_ref = 0;
40378608:	050c      	movi.n	a5, 0
4037860a:	000286        	j	40378618 <rtc_clk_bbpll_configure+0x84>
            div_ref = 1;
            div7_0 = 26;
            dr1 = 1;
            dr3 = 1;
            dchgp = 4;
            dcur = 0;
4037860d:	00a072        	movi	a7, 0
            dchgp = 4;
40378610:	04a022        	movi	a2, 4
            div7_0 = 26;
40378613:	1aa042        	movi	a4, 26
            div_ref = 1;
40378616:	150c      	movi.n	a5, 1
            dr3 = 0;
            dchgp = 5;
            dcur = 3;
            break;
        }
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x6B);
40378618:	6ba0d2        	movi	a13, 107
4037861b:	4c0c      	movi.n	a12, 4
4037861d:	1b0c      	movi.n	a11, 1
4037861f:	66a0a2        	movi	a10, 102
40378622:	fe1ba5        	call8	403767dc <regi2c_ctrl_write_reg>
40378625:	056d      	mov.n	a6, a5
40378627:	000886        	j	4037864d <rtc_clk_bbpll_configure+0xb9>
4037862a:	260000        	lsi	f0, a0, 152
    } else {
        /* Configure 320M PLL */
        switch (xtal_freq_mhz) {
4037862d:	0c06c2        	l8ui	a12, a6, 12
        case SOC_XTAL_FREQ_40M:
            div_ref = 0;
            div7_0 = 4;
40378630:	050c44        	lsi	f4, a12, 20
            div_ref = 0;
40378633:	0000c6        	j	4037863a <rtc_clk_bbpll_configure+0xa6>
            dchgp = 5;
            dcur = 3;
            break;
        case SOC_XTAL_FREQ_32M:
            div_ref = 1;
            div7_0 = 6;
40378636:	640c      	movi.n	a4, 6
            div_ref = 1;
40378638:	150c      	movi.n	a5, 1
            dr3 = 0;
            dchgp = 5;
            dcur = 3;
            break;
        }
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x69);
4037863a:	69a0d2        	movi	a13, 105
4037863d:	4c0c      	movi.n	a12, 4
4037863f:	1b0c      	movi.n	a11, 1
40378641:	66a0a2        	movi	a10, 102
40378644:	fe1965        	call8	403767dc <regi2c_ctrl_write_reg>
40378647:	370c      	movi.n	a7, 3
40378649:	520c      	movi.n	a2, 5
4037864b:	060c      	movi.n	a6, 0
    }
    uint8_t i2c_bbpll_lref  = (dchgp << I2C_BBPLL_OC_DCHGP_LSB) | (div_ref);
4037864d:	11d2c0        	slli	a13, a2, 4
    uint8_t i2c_bbpll_div_7_0 = div7_0;
    uint8_t i2c_bbpll_dcur = (1 << I2C_BBPLL_OC_DLREF_SEL_LSB ) | (3 << I2C_BBPLL_OC_DHREF_SEL_LSB) | dcur;
40378650:	70a082        	movi	a8, 112
40378653:	207780        	or	a7, a7, a8
40378656:	747070        	extui	a7, a7, 0, 8
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_REF_DIV, i2c_bbpll_lref);
40378659:	20d5d0        	or	a13, a5, a13
4037865c:	2c0c      	movi.n	a12, 2
4037865e:	1b0c      	movi.n	a11, 1
40378660:	66a0a2        	movi	a10, 102
40378663:	fe17a5        	call8	403767dc <regi2c_ctrl_write_reg>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DIV_7_0, i2c_bbpll_div_7_0);
40378666:	04dd      	mov.n	a13, a4
40378668:	3c0c      	movi.n	a12, 3
4037866a:	1b0c      	movi.n	a11, 1
4037866c:	66a0a2        	movi	a10, 102
4037866f:	fe16e5        	call8	403767dc <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR1, dr1);
40378672:	06fd      	mov.n	a15, a6
40378674:	0e0c      	movi.n	a14, 0
40378676:	2d0c      	movi.n	a13, 2
40378678:	5c0c      	movi.n	a12, 5
4037867a:	1b0c      	movi.n	a11, 1
4037867c:	66a0a2        	movi	a10, 102
4037867f:	fe1ae5        	call8	4037682c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR3, dr3);
40378682:	06fd      	mov.n	a15, a6
40378684:	4e0c      	movi.n	a14, 4
40378686:	6d0c      	movi.n	a13, 6
40378688:	5c0c      	movi.n	a12, 5
4037868a:	01a0b2        	movi	a11, 1
4037868d:	66a0a2        	movi	a10, 102
40378690:	fe19a5        	call8	4037682c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DCUR, i2c_bbpll_dcur);
40378693:	07dd      	mov.n	a13, a7
40378695:	6c0c      	movi.n	a12, 6
40378697:	01a0b2        	movi	a11, 1
4037869a:	66a0a2        	movi	a10, 102
4037869d:	fe13e5        	call8	403767dc <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_VCO_DBIAS, dbias);
403786a0:	3f0c      	movi.n	a15, 3
403786a2:	0e0c      	movi.n	a14, 0
403786a4:	1d0c      	movi.n	a13, 1
403786a6:	9c0c      	movi.n	a12, 9
403786a8:	20bdd0        	or	a11, a13, a13
403786ab:	66a0a2        	movi	a10, 102
403786ae:	fe17e5        	call8	4037682c <regi2c_ctrl_write_reg_mask>
 *
 * @return True if calibration is done; otherwise false
 */
static inline __attribute__((always_inline)) bool regi2c_ctrl_ll_bbpll_calibration_is_done(void)
{
    return REG_GET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_CAL_DONE);
403786b1:	f0b081        	l32r	a8, 40374974 <_iram_text_start+0x570> (6000e040 <SENS+0x5840>)
403786b4:	0020c0        	memw
403786b7:	0888      	l32i.n	a8, a8, 0
    while(!regi2c_ctrl_ll_bbpll_calibration_is_done());
403786b9:	f47887        	bbci	a8, 24, 403786b1 <rtc_clk_bbpll_configure+0x11d>
    esp_rom_delay_us(10);
403786bc:	aa0c      	movi.n	a10, 10
403786be:	ef5d81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
403786c1:	0008e0        	callx8	a8
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
403786c4:	f0ac81        	l32r	a8, 40374974 <_iram_text_start+0x570> (6000e040 <SENS+0x5840>)
403786c7:	0020c0        	memw
403786ca:	0898      	l32i.n	a9, a8, 0
403786cc:	7a7c      	movi.n	a10, -9
403786ce:	1099a0        	and	a9, a9, a10
403786d1:	0020c0        	memw
403786d4:	0899      	s32i.n	a9, a8, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
403786d6:	0020c0        	memw
403786d9:	0898      	l32i.n	a9, a8, 0
403786db:	4a0c      	movi.n	a10, 4
403786dd:	2099a0        	or	a9, a9, a10
403786e0:	0020c0        	memw
403786e3:	0899      	s32i.n	a9, a8, 0
    s_cur_pll_freq = pll_freq;
403786e5:	f09e81        	l32r	a8, 40374960 <_iram_text_start+0x55c> (3fc94c28 <s_cur_pll_freq>)
403786e8:	0839      	s32i.n	a3, a8, 0
}
403786ea:	f01d      	retw.n

403786ec <rtc_clk_bbpll_add_consumer>:
{
403786ec:	004136        	entry	a1, 32
    s_bbpll_digi_consumers_ref_count += 1;
403786ef:	f0a291        	l32r	a9, 40374978 <_iram_text_start+0x574> (3fc94c20 <s_bbpll_digi_consumers_ref_count>)
403786f2:	0988      	l32i.n	a8, a9, 0
403786f4:	881b      	addi.n	a8, a8, 1
403786f6:	0989      	s32i.n	a8, a9, 0
}
403786f8:	f01d      	retw.n
	...

403786fc <rtc_clk_bbpll_remove_consumer>:
{
403786fc:	004136        	entry	a1, 32
    s_bbpll_digi_consumers_ref_count -= 1;
403786ff:	f09e91        	l32r	a9, 40374978 <_iram_text_start+0x574> (3fc94c20 <s_bbpll_digi_consumers_ref_count>)
40378702:	0988      	l32i.n	a8, a9, 0
40378704:	880b      	addi.n	a8, a8, -1
40378706:	0989      	s32i.n	a8, a9, 0
}
40378708:	f01d      	retw.n
	...

4037870c <rtc_clk_32k_enable>:
{
4037870c:	004136        	entry	a1, 32
4037870f:	742020        	extui	a2, a2, 0, 8
    if (enable) {
40378712:	0be216        	beqz	a2, 403787d4 <rtc_clk_32k_enable+0xc8>
        SET_PERI_REG_MASK(RTC_IO_XTAL_32P_PAD_REG, RTC_IO_X32P_MUX_SEL);
40378715:	f09991        	l32r	a9, 4037497c <_iram_text_start+0x578> (600084c0 <RTCIO+0xc0>)
40378718:	0020c0        	memw
4037871b:	0988      	l32i.n	a8, a9, 0
4037871d:	f098a1        	l32r	a10, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
40378720:	2088a0        	or	a8, a8, a10
40378723:	0020c0        	memw
40378726:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_IO_XTAL_32N_PAD_REG, RTC_IO_X32N_MUX_SEL);
40378728:	f09791        	l32r	a9, 40374984 <_iram_text_start+0x580> (600084c4 <RTCIO+0xc4>)
4037872b:	0020c0        	memw
4037872e:	0988      	l32i.n	a8, a9, 0
40378730:	2088a0        	or	a8, a8, a10
40378733:	0020c0        	memw
40378736:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_GPIO_SEL);
40378738:	f09491        	l32r	a9, 40374988 <_iram_text_start+0x584> (60008060 <RTCCNTL+0x60>)
4037873b:	0020c0        	memw
4037873e:	0988      	l32i.n	a8, a9, 0
40378740:	f093a1        	l32r	a10, 4037498c <_iram_text_start+0x588> (ff7fffff <_rtc_reserved_end+0x9f6fffff>)
40378743:	1088a0        	and	a8, a8, a10
40378746:	0020c0        	memw
40378749:	0989      	s32i.n	a8, a9, 0
        clk_ll_xtal32k_config_t cfg = CLK_LL_XTAL32K_CONFIG_DEFAULT();
4037874b:	380c      	movi.n	a8, 3
4037874d:	c0a0a2        	movi	a10, 192
40378750:	2088a0        	or	a8, a8, a10
40378753:	00a6a2        	movi	a10, 0x600
40378756:	2088a0        	or	a8, a8, a10
40378759:	efc5a1        	l32r	a10, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037875c:	2088a0        	or	a8, a8, a10
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DAC_XTAL_32K, cfg.dac);
4037875f:	0020c0        	memw
40378762:	09a8      	l32i.n	a10, a9, 0
40378764:	f08bb1        	l32r	a11, 40374990 <_iram_text_start+0x58c> (fff1ffff <_rtc_reserved_end+0x9fe1ffff>)
40378767:	10aab0        	and	a10, a10, a11
4037876a:	f08ab1        	l32r	a11, 40374994 <_iram_text_start+0x590> (60000 <UserFrameTotalSize+0x5ff00>)
4037876d:	20aab0        	or	a10, a10, a11
40378770:	0020c0        	memw
40378773:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DRES_XTAL_32K, cfg.dres);
40378775:	0020c0        	memw
40378778:	09a8      	l32i.n	a10, a9, 0
4037877a:	f087b1        	l32r	a11, 40374998 <_iram_text_start+0x594> (ffff1fff <_rtc_reserved_end+0x9fef1fff>)
4037877d:	10aab0        	and	a10, a10, a11
40378780:	24b680        	extui	a11, a8, 6, 3
40378783:	11bb30        	slli	a11, a11, 13
40378786:	20aab0        	or	a10, a10, a11
40378789:	0020c0        	memw
4037878c:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DGM_XTAL_32K, cfg.dgm);
4037878e:	0020c0        	memw
40378791:	09a8      	l32i.n	a10, a9, 0
40378793:	f082b1        	l32r	a11, 4037499c <_iram_text_start+0x598> (ffffe3ff <_rtc_reserved_end+0x9fefe3ff>)
40378796:	10aab0        	and	a10, a10, a11
40378799:	24b980        	extui	a11, a8, 9, 3
4037879c:	11bb60        	slli	a11, a11, 10
4037879f:	20aab0        	or	a10, a10, a11
403787a2:	0020c0        	memw
403787a5:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DBUF_XTAL_32K, cfg.dbuf);
403787a7:	0020c0        	memw
403787aa:	09a8      	l32i.n	a10, a9, 0
403787ac:	ffadb2        	movi	a11, 0xfffffdff
403787af:	10aab0        	and	a10, a10, a11
403787b2:	048c80        	extui	a8, a8, 12, 1
403787b5:	118870        	slli	a8, a8, 9
403787b8:	208a80        	or	a8, a10, a8
403787bb:	0020c0        	memw
403787be:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
403787c0:	0020c0        	memw
403787c3:	0988      	l32i.n	a8, a9, 0
403787c5:	f02fa1        	l32r	a10, 40374884 <_iram_text_start+0x480> (10000 <UserFrameTotalSize+0xff00>)
403787c8:	2088a0        	or	a8, a8, a10
403787cb:	0020c0        	memw
403787ce:	0989      	s32i.n	a8, a9, 0
403787d0:	0008c6        	j	403787f7 <rtc_clk_32k_enable+0xeb>
403787d3:	6d8100        	lsi	f0, a1, 0x1b4
    SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_XPD_FORCE);
403787d6:	20c0f0        	or	a12, a0, a15
403787d9:	089800        	lsx	f9, a8, a0
403787dc:	80a0a2        	movi	a10, 128
403787df:	2099a0        	or	a9, a9, a10
403787e2:	0020c0        	memw
403787e5:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
403787e7:	0020c0        	memw
403787ea:	0898      	l32i.n	a9, a8, 0
403787ec:	f06da1        	l32r	a10, 403749a0 <_iram_text_start+0x59c> (fffeffff <_rtc_reserved_end+0x9feeffff>)
403787ef:	1099a0        	and	a9, a9, a10
403787f2:	0020c0        	memw
403787f5:	0899      	s32i.n	a9, a8, 0
}
403787f7:	f01d      	retw.n
403787f9:	000000        	ill

403787fc <rtc_clk_32k_enable_external>:
{
403787fc:	004136        	entry	a1, 32
    PIN_INPUT_ENABLE(IO_MUX_GPIO15_REG);
403787ff:	f06991        	l32r	a9, 403749a4 <_iram_text_start+0x5a0> (60009040 <SENS+0x840>)
40378802:	0020c0        	memw
40378805:	0988      	l32i.n	a8, a9, 0
40378807:	00a2a2        	movi	a10, 0x200
4037880a:	2088a0        	or	a8, a8, a10
4037880d:	0020c0        	memw
40378810:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(SENS_SAR_PERI_CLK_GATE_CONF_REG, SENS_IOMUX_CLK_EN);
40378812:	f06591        	l32r	a9, 403749a8 <_iram_text_start+0x5a4> (60008904 <SENS+0x104>)
40378815:	0020c0        	memw
40378818:	0988      	l32i.n	a8, a9, 0
4037881a:	ef40a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037881d:	2088a0        	or	a8, a8, a10
40378820:	0020c0        	memw
40378823:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, RTC_CNTL_X32P_HOLD);
40378825:	f06191        	l32r	a9, 403749ac <_iram_text_start+0x5a8> (600080d8 <RTCCNTL+0xd8>)
40378828:	0020c0        	memw
4037882b:	0988      	l32i.n	a8, a9, 0
4037882d:	ef09a1        	l32r	a10, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
40378830:	2088a0        	or	a8, a8, a10
40378833:	0020c0        	memw
40378836:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_GPIO_SEL);
40378838:	f05491        	l32r	a9, 40374988 <_iram_text_start+0x584> (60008060 <RTCCNTL+0x60>)
4037883b:	0020c0        	memw
4037883e:	0988      	l32i.n	a8, a9, 0
40378840:	f05ca1        	l32r	a10, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
40378843:	2088a0        	or	a8, a8, a10
40378846:	0020c0        	memw
40378849:	0989      	s32i.n	a8, a9, 0
}
4037884b:	f01d      	retw.n
4037884d:	000000        	ill

40378850 <rtc_clk_8m_enable>:
{
40378850:	004136        	entry	a1, 32
40378853:	742020        	extui	a2, a2, 0, 8
40378856:	743030        	extui	a3, a3, 0, 8
    if (clk_8m_en) {
40378859:	72bc      	beqz.n	a2, 40378894 <rtc_clk_8m_enable+0x44>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
4037885b:	f05691        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
4037885e:	0020c0        	memw
40378861:	0988      	l32i.n	a8, a9, 0
40378863:	bfafa2        	movi	a10, -65
40378866:	1088a0        	and	a8, a8, a10
40378869:	0020c0        	memw
4037886c:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, CLK_LL_RC_FAST_ENABLE_WAIT_DEFAULT);
4037886e:	f05291        	l32r	a9, 403749b8 <_iram_text_start+0x5b4> (6000801c <RTCCNTL+0x1c>)
40378871:	0020c0        	memw
40378874:	0988      	l32i.n	a8, a9, 0
40378876:	f051a1        	l32r	a10, 403749bc <_iram_text_start+0x5b8> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
40378879:	1088a0        	and	a8, a8, a10
4037887c:	40a1a2        	movi	a10, 0x140
4037887f:	2088a0        	or	a8, a8, a10
40378882:	0020c0        	memw
40378885:	0989      	s32i.n	a8, a9, 0
        esp_rom_delay_us(SOC_DELAY_RC_FAST_ENABLE);
40378887:	32a0a2        	movi	a10, 50
4037888a:	eeea81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
4037888d:	0008e0        	callx8	a8
40378890:	000ac6        	j	403788bf <rtc_clk_8m_enable+0x6f>
40378893:	489100        	ssx	f9, a1, a0
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
40378896:	20c0f0        	or	a12, a0, a15
40378899:	098800        	l32e	a0, a8, -32
4037889c:	0a4c      	movi.n	a10, 64
4037889e:	2088a0        	or	a8, a8, a10
403788a1:	0020c0        	memw
403788a4:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, CLK_LL_RC_FAST_WAIT_DEFAULT);
403788a6:	f04491        	l32r	a9, 403749b8 <_iram_text_start+0x5b4> (6000801c <RTCCNTL+0x1c>)
403788a9:	0020c0        	memw
403788ac:	0988      	l32i.n	a8, a9, 0
403788ae:	f043a1        	l32r	a10, 403749bc <_iram_text_start+0x5b8> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
403788b1:	1088a0        	and	a8, a8, a10
403788b4:	00a5a2        	movi	a10, 0x500
403788b7:	2088a0        	or	a8, a8, a10
403788ba:	0020c0        	memw
403788bd:	0989      	s32i.n	a8, a9, 0
    if (d256_en) {
403788bf:	539c      	beqz.n	a3, 403788d8 <rtc_clk_8m_enable+0x88>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
403788c1:	f03c91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403788c4:	0020c0        	memw
403788c7:	0988      	l32i.n	a8, a9, 0
403788c9:	7fafa2        	movi	a10, -129
403788cc:	1088a0        	and	a8, a8, a10
403788cf:	0020c0        	memw
403788d2:	0989      	s32i.n	a8, a9, 0
}
403788d4:	0004c6        	j	403788eb <rtc_clk_8m_enable+0x9b>
403788d7:	379100        	lsi	f0, a1, 220
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
403788da:	20c0f0        	or	a12, a0, a15
403788dd:	098800        	l32e	a0, a8, -32
403788e0:	80a0a2        	movi	a10, 128
403788e3:	2088a0        	or	a8, a8, a10
403788e6:	0020c0        	memw
403788e9:	0989      	s32i.n	a8, a9, 0
}
403788eb:	f01d      	retw.n
403788ed:	000000        	ill

403788f0 <rtc_clk_8md256_enabled>:
{
403788f0:	004136        	entry	a1, 32
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
403788f3:	f03081        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403788f6:	0020c0        	memw
403788f9:	0828      	l32i.n	a2, a8, 0
403788fb:	80a082        	movi	a8, 128
403788fe:	102280        	and	a2, a2, a8
}
40378901:	40f220        	nsau	a2, a2
40378904:	412520        	srli	a2, a2, 5
40378907:	f01d      	retw.n
40378909:	000000        	ill

4037890c <rtc_clk_slow_src_set>:
{
4037890c:	004136        	entry	a1, 32
 *
 * @return Currently selected clock source (one of soc_rtc_slow_clk_src_t values)
 */
static inline __attribute__((always_inline)) soc_rtc_slow_clk_src_t clk_ll_rtc_slow_get_src(void)
{
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
4037890f:	f02981        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378912:	0020c0        	memw
40378915:	0888      	l32i.n	a8, a8, 0
40378917:	158e80        	extui	a8, a8, 30, 2
    switch (clk_sel) {
4037891a:	131826        	beqi	a8, 1, 40378931 <rtc_clk_slow_src_set+0x25>
4037891d:	102826        	beqi	a8, 2, 40378931 <rtc_clk_slow_src_set+0x25>
40378920:	d88c      	beqz.n	a8, 40378931 <rtc_clk_slow_src_set+0x25>
        return SOC_RTC_SLOW_CLK_SRC_XTAL32K;
    case 2:
        return SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256;
    default:
        // Invalid ANA_CLK_RTC_SEL value
        HAL_ASSERT(false);
40378922:	f027d1        	l32r	a13, 403749c0 <_iram_text_start+0x5bc> (3fc9394c <__FUNCTION__$0+0x94>)
40378925:	f027c1        	l32r	a12, 403749c4 <_iram_text_start+0x5c0> (3fc938a0 <__func__$0>)
40378928:	1aa2b2        	movi	a11, 0x21a
4037892b:	f027a1        	l32r	a10, 403749c8 <_iram_text_start+0x5c4> (3fc939e4 <__FUNCTION__$0+0x12c>)
4037892e:	074725        	call8	4037fda0 <__assert_func>
    if (clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256 && clk_src_before_switch != SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {       // Switch to RC_FAST_D256
40378931:	fec292        	addi	a9, a2, -2
40378934:	40f990        	nsau	a9, a9
40378937:	419590        	srli	a9, a9, 5
4037893a:	fec8b2        	addi	a11, a8, -2
4037893d:	1a0c      	movi.n	a10, 1
4037893f:	83abb0        	moveqz	a10, a11, a11
40378942:	0d09a7        	bnone	a9, a10, 40378953 <rtc_clk_slow_src_set+0x47>
        esp_sleep_sub_mode_config(ESP_SLEEP_RTC_USE_RC_FAST_MODE, true);
40378945:	1b0c      	movi.n	a11, 1
40378947:	00a0a2        	movi	a10, 0
4037894a:	f02081        	l32r	a8, 403749cc <_iram_text_start+0x5c8> (42005a8c <esp_sleep_sub_mode_config>)
4037894d:	0008e0        	callx8	a8
40378950:	000746        	j	40378971 <rtc_clk_slow_src_set+0x65>
    } else if (clk_src != SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256 && clk_src_before_switch == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) { // Switch away from RC_FAST_D256
40378953:	fec2a2        	addi	a10, a2, -2
40378956:	190c      	movi.n	a9, 1
40378958:	839aa0        	moveqz	a9, a10, a10
4037895b:	fec882        	addi	a8, a8, -2
4037895e:	40f880        	nsau	a8, a8
40378961:	418580        	srli	a8, a8, 5
40378964:	090987        	bnone	a9, a8, 40378971 <rtc_clk_slow_src_set+0x65>
        esp_sleep_sub_mode_config(ESP_SLEEP_RTC_USE_RC_FAST_MODE, false);
40378967:	0b0c      	movi.n	a11, 0
40378969:	0bad      	mov.n	a10, a11
4037896b:	f01881        	l32r	a8, 403749cc <_iram_text_start+0x5c8> (42005a8c <esp_sleep_sub_mode_config>)
4037896e:	0008e0        	callx8	a8
    switch (in_sel) {
40378971:	1b1226        	beqi	a2, 1, 40378990 <rtc_clk_slow_src_set+0x84>
40378974:	342226        	beqi	a2, 2, 403789ac <rtc_clk_slow_src_set+0xa0>
40378977:	04d256        	bnez	a2, 403789c8 <rtc_clk_slow_src_set+0xbc>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 0);
4037897a:	f00e91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
4037897d:	0020c0        	memw
40378980:	0988      	l32i.n	a8, a9, 0
40378982:	1188e0        	slli	a8, a8, 2
40378985:	418280        	srli	a8, a8, 2
40378988:	0020c0        	memw
4037898b:	0989      	s32i.n	a8, a9, 0
        break;
4037898d:	000e86        	j	403789cb <rtc_clk_slow_src_set+0xbf>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 1);
40378990:	f00991        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378993:	0020c0        	memw
40378996:	0988      	l32i.n	a8, a9, 0
40378998:	1188e0        	slli	a8, a8, 2
4037899b:	418280        	srli	a8, a8, 2
4037899e:	ef15a1        	l32r	a10, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
403789a1:	2088a0        	or	a8, a8, a10
403789a4:	0020c0        	memw
403789a7:	0989      	s32i.n	a8, a9, 0
        break;
403789a9:	000786        	j	403789cb <rtc_clk_slow_src_set+0xbf>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 2);
403789ac:	f00291        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403789af:	0020c0        	memw
403789b2:	0988      	l32i.n	a8, a9, 0
403789b4:	1188e0        	slli	a8, a8, 2
403789b7:	418280        	srli	a8, a8, 2
403789ba:	eed8a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403789bd:	2088a0        	or	a8, a8, a10
403789c0:	0020c0        	memw
403789c3:	0989      	s32i.n	a8, a9, 0
        break;
403789c5:	000086        	j	403789cb <rtc_clk_slow_src_set+0xbf>
        abort();
403789c8:	0731a5        	call8	4037fce4 <abort>
    if (clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
403789cb:	151266        	bnei	a2, 1, 403789e4 <rtc_clk_slow_src_set+0xd8>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
403789ce:	eff991        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403789d1:	0020c0        	memw
403789d4:	0988      	l32i.n	a8, a9, 0
403789d6:	00a1a2        	movi	a10, 0x100
403789d9:	2088a0        	or	a8, a8, a10
403789dc:	0020c0        	memw
403789df:	0989      	s32i.n	a8, a9, 0
}
403789e1:	000486        	j	403789f7 <rtc_clk_slow_src_set+0xeb>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
403789e4:	eff491        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403789e7:	0020c0        	memw
403789ea:	0988      	l32i.n	a8, a9, 0
403789ec:	ffaea2        	movi	a10, 0xfffffeff
403789ef:	1088a0        	and	a8, a8, a10
403789f2:	0020c0        	memw
403789f5:	0989      	s32i.n	a8, a9, 0
    esp_rom_delay_us(SOC_DELAY_RTC_SLOW_CLK_SWITCH);
403789f7:	2ca1a2        	movi	a10, 0x12c
403789fa:	ee8e81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
403789fd:	0008e0        	callx8	a8
}
40378a00:	f01d      	retw.n
	...

40378a04 <rtc_clk_slow_src_get>:
{
40378a04:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
40378a07:	efeb81        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378a0a:	0020c0        	memw
40378a0d:	002822        	l32i	a2, a8, 0
40378a10:	152e20        	extui	a2, a2, 30, 2
    switch (clk_sel) {
40378a13:	141226        	beqi	a2, 1, 40378a2b <rtc_clk_slow_src_get+0x27>
40378a16:	112226        	beqi	a2, 2, 40378a2b <rtc_clk_slow_src_get+0x27>
40378a19:	00e216        	beqz	a2, 40378a2b <rtc_clk_slow_src_get+0x27>
        HAL_ASSERT(false);
40378a1c:	efe9d1        	l32r	a13, 403749c0 <_iram_text_start+0x5bc> (3fc9394c <__FUNCTION__$0+0x94>)
40378a1f:	efe9c1        	l32r	a12, 403749c4 <_iram_text_start+0x5c0> (3fc938a0 <__func__$0>)
40378a22:	1aa2b2        	movi	a11, 0x21a
40378a25:	efe8a1        	l32r	a10, 403749c8 <_iram_text_start+0x5c4> (3fc939e4 <__FUNCTION__$0+0x12c>)
40378a28:	073765        	call8	4037fda0 <__assert_func>
}
40378a2b:	000090        	retw
	...

40378a30 <rtc_clk_slow_freq_get_hz>:
{
40378a30:	004136        	entry	a1, 32
    switch (rtc_clk_slow_src_get()) {
40378a33:	fffd25        	call8	40378a04 <rtc_clk_slow_src_get>
40378a36:	0a1a26        	beqi	a10, 1, 40378a44 <rtc_clk_slow_freq_get_hz+0x14>
40378a39:	0f2a26        	beqi	a10, 2, 40378a4c <rtc_clk_slow_freq_get_hz+0x1c>
40378a3c:	2adc      	bnez.n	a10, 40378a52 <rtc_clk_slow_freq_get_hz+0x22>
40378a3e:	efe421        	l32r	a2, 403749d0 <_iram_text_start+0x5cc> (21340 <UserFrameTotalSize+0x21240>)
40378a41:	0003c6        	j	40378a54 <rtc_clk_slow_freq_get_hz+0x24>
    case SOC_RTC_SLOW_CLK_SRC_XTAL32K: return SOC_CLK_XTAL32K_FREQ_APPROX;
40378a44:	ee8421        	l32r	a2, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
40378a47:	000246        	j	40378a54 <rtc_clk_slow_freq_get_hz+0x24>
40378a4a:	210000        	srai	a0, a0, 0
    case SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256: return SOC_CLK_RC_FAST_D256_FREQ_APPROX;
40378a4d:	46efe2        	s32c1i	a14, a15, 0x118
40378a50:	0c0000        	lsi	f0, a0, 48
    default: return 0;
40378a53:	f01d02        	l16ui	a0, a13, 0x1e0
	...

40378a58 <rtc_clk_fast_src_set>:
{
40378a58:	004136        	entry	a1, 32
 *
 * @param in_sel One of the clock sources in soc_rtc_fast_clk_src_t
 */
static inline __attribute__((always_inline)) void clk_ll_rtc_fast_set_src(soc_rtc_fast_clk_src_t in_sel)
{
    switch (in_sel) {
40378a5b:	428c      	beqz.n	a2, 40378a63 <rtc_clk_fast_src_set+0xb>
40378a5d:	181226        	beqi	a2, 1, 40378a79 <rtc_clk_fast_src_set+0x21>
40378a60:	000ac6        	j	40378a8f <rtc_clk_fast_src_set+0x37>
    case SOC_RTC_FAST_CLK_SRC_XTAL_D2:
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 0);
40378a63:	efd491        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378a66:	0020c0        	memw
40378a69:	0988      	l32i.n	a8, a9, 0
40378a6b:	ef62a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
40378a6e:	1088a0        	and	a8, a8, a10
40378a71:	0020c0        	memw
40378a74:	0989      	s32i.n	a8, a9, 0
        break;
40378a76:	000606        	j	40378a92 <rtc_clk_fast_src_set+0x3a>
    case SOC_RTC_FAST_CLK_SRC_RC_FAST:
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 1);
40378a79:	efce91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378a7c:	0020c0        	memw
40378a7f:	0988      	l32i.n	a8, a9, 0
40378a81:	efd5a1        	l32r	a10, 403749d8 <_iram_text_start+0x5d4> (20000000 <UserFrameTotalSize+0x1fffff00>)
40378a84:	2088a0        	or	a8, a8, a10
40378a87:	0020c0        	memw
40378a8a:	0989      	s32i.n	a8, a9, 0
        break;
40378a8c:	000086        	j	40378a92 <rtc_clk_fast_src_set+0x3a>
    default:
        // Unsupported RTC_FAST_CLK mux input sel
        abort();
40378a8f:	072565        	call8	4037fce4 <abort>
    esp_rom_delay_us(SOC_DELAY_RTC_FAST_CLK_SWITCH);
40378a92:	3a0c      	movi.n	a10, 3
40378a94:	ee6881        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378a97:	0008e0        	callx8	a8
}
40378a9a:	f01d      	retw.n

40378a9c <rtc_clk_xtal_freq_get>:
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
}

soc_xtal_freq_t rtc_clk_xtal_freq_get(void)
{
40378a9c:	004136        	entry	a1, 32
 * @return XTAL frequency, in MHz. Returns 0 if value in reg is invalid.
 */
static inline __attribute__((always_inline)) uint32_t clk_ll_xtal_load_freq_mhz(void)
{
    // Read from the RTC storage register
    uint32_t xtal_freq_reg = READ_PERI_REG(RTC_XTAL_FREQ_REG);
40378a9f:	efcf81        	l32r	a8, 403749dc <_iram_text_start+0x5d8> (600080c0 <RTCCNTL+0xc0>)
40378aa2:	0020c0        	memw
40378aa5:	0828      	l32i.n	a2, a8, 0
    if ((xtal_freq_reg & 0xFFFF) == ((xtal_freq_reg >> 16) & 0xFFFF) &&
40378aa7:	f49020        	extui	a9, a2, 0, 16
40378aaa:	f58020        	extui	a8, a2, 16, 16
40378aad:	0e9987        	bne	a9, a8, 40378abf <rtc_clk_xtal_freq_get+0x23>
        xtal_freq_reg != 0 && xtal_freq_reg != UINT32_MAX) {
40378ab0:	820b      	addi.n	a8, a2, -1
40378ab2:	d97c      	movi.n	a9, -3
40378ab4:	073987        	bltu	a9, a8, 40378abf <rtc_clk_xtal_freq_get+0x23>
        return xtal_freq_reg & ~RTC_DISABLE_ROM_LOG & UINT16_MAX;
40378ab7:	e42120        	extui	a2, a2, 1, 15
40378aba:	222a      	add.n	a2, a2, a2
    uint32_t xtal_freq_mhz = clk_ll_xtal_load_freq_mhz();
    if (xtal_freq_mhz == 0) {
40378abc:	01a256        	bnez	a2, 40378ada <rtc_clk_xtal_freq_get+0x3e>
40378abf:	ee6b81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40378ac2:	0888      	l32i.n	a8, a8, 0
        ESP_HW_LOGW(TAG, "invalid RTC_XTAL_FREQ_REG value, assume 40MHz");
40378ac4:	1028b6        	bltui	a8, 2, 40378ad8 <rtc_clk_xtal_freq_get+0x3c>
40378ac7:	0716a5        	call8	4037fc30 <esp_log_timestamp>
40378aca:	efc5c1        	l32r	a12, 403749e0 <_iram_text_start+0x5dc> (3fc93a1c <__FUNCTION__$0+0x164>)
40378acd:	0abd      	mov.n	a11, a10
40378acf:	efc5a1        	l32r	a10, 403749e4 <_iram_text_start+0x5e0> (3fc93a24 <__FUNCTION__$0+0x16c>)
40378ad2:	ee7881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40378ad5:	0008e0        	callx8	a8
        return SOC_XTAL_FREQ_40M;
40378ad8:	822c      	movi.n	a2, 40
    }
    return (soc_xtal_freq_t)xtal_freq_mhz;
}
40378ada:	f01d      	retw.n

40378adc <rtc_clk_cpu_freq_mhz_to_config>:
{
40378adc:	004136        	entry	a1, 32
    uint32_t xtal_freq = (uint32_t)rtc_clk_xtal_freq_get();
40378adf:	fffbe5        	call8	40378a9c <rtc_clk_xtal_freq_get>
    if (freq_mhz <= xtal_freq && freq_mhz != 0) {
40378ae2:	ffc282        	addi	a8, a2, -1
40378ae5:	17b8a7        	bgeu	a8, a10, 40378b00 <rtc_clk_cpu_freq_mhz_to_config+0x24>
        divider = xtal_freq / freq_mhz;
40378ae8:	c29a20        	quou	a9, a10, a2
        real_freq_mhz = (xtal_freq + divider / 2) / divider; /* round */
40378aeb:	418190        	srli	a8, a9, 1
40378aee:	8088a0        	add	a8, a8, a10
40378af1:	c28890        	quou	a8, a8, a9
        if (real_freq_mhz != freq_mhz) {
40378af4:	429287        	bne	a2, a8, 40378b3a <rtc_clk_cpu_freq_mhz_to_config+0x5e>
        real_freq_mhz = (xtal_freq + divider / 2) / divider; /* round */
40378af7:	202880        	or	a2, a8, a8
        source = SOC_CPU_CLK_SRC_XTAL;
40378afa:	080c      	movi.n	a8, 0
40378afc:	000b46        	j	40378b2d <rtc_clk_cpu_freq_mhz_to_config+0x51>
40378aff:	085c00        	lsx	f5, a12, a0
    } else if (freq_mhz == 80) {
40378b02:	161287        	beq	a2, a8, 40378b1c <rtc_clk_cpu_freq_mhz_to_config+0x40>
    } else if (freq_mhz == 160) {
40378b05:	a0a082        	movi	a8, 160
40378b08:	1a1287        	beq	a2, a8, 40378b26 <rtc_clk_cpu_freq_mhz_to_config+0x4a>
    } else if (freq_mhz == 240) {
40378b0b:	f0a082        	movi	a8, 240
40378b0e:	2e9287        	bne	a2, a8, 40378b40 <rtc_clk_cpu_freq_mhz_to_config+0x64>
        divider = 2;
40378b11:	290c      	movi.n	a9, 2
        source = SOC_CPU_CLK_SRC_PLL;
40378b13:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
40378b15:	e0a1a2        	movi	a10, 0x1e0
40378b18:	000446        	j	40378b2d <rtc_clk_cpu_freq_mhz_to_config+0x51>
40378b1b:	690c00        	lsi	f0, a12, 0x1a4
        source = SOC_CPU_CLK_SRC_PLL;
40378b1e:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
40378b20:	e0a1a2        	movi	a10, 0x1e0
40378b23:	000186        	j	40378b2d <rtc_clk_cpu_freq_mhz_to_config+0x51>
        divider = 3;
40378b26:	390c      	movi.n	a9, 3
        source = SOC_CPU_CLK_SRC_PLL;
40378b28:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
40378b2a:	e0a1a2        	movi	a10, 0x1e0
    *out_config = (rtc_cpu_freq_config_t) {
40378b2d:	0389      	s32i.n	a8, a3, 0
40378b2f:	13a9      	s32i.n	a10, a3, 4
40378b31:	2399      	s32i.n	a9, a3, 8
40378b33:	3329      	s32i.n	a2, a3, 12
    return true;
40378b35:	120c      	movi.n	a2, 1
40378b37:	0001c6        	j	40378b42 <rtc_clk_cpu_freq_mhz_to_config+0x66>
            return false;
40378b3a:	020c      	movi.n	a2, 0
40378b3c:	000086        	j	40378b42 <rtc_clk_cpu_freq_mhz_to_config+0x66>
40378b3f:	020c00        	andb	b0, b12, b0
}
40378b42:	f01d      	retw.n

40378b44 <rtc_clk_cpu_freq_get_config>:
{
40378b44:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
40378b47:	efa881        	l32r	a8, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378b4a:	0020c0        	memw
40378b4d:	002872        	l32i	a7, a8, 0
40378b50:	147a70        	extui	a7, a7, 10, 2
    switch (clk_sel) {
40378b53:	291726        	beqi	a7, 1, 40378b80 <rtc_clk_cpu_freq_get_config+0x3c>
40378b56:	022766        	bnei	a7, 2, 40378b5c <rtc_clk_cpu_freq_get_config+0x18>
40378b59:	003586        	j	40378c33 <rtc_clk_cpu_freq_get_config+0xef>
40378b5c:	014756        	bnez	a7, 40378b74 <rtc_clk_cpu_freq_get_config+0x30>
    return REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT) + 1;
40378b5f:	0020c0        	memw
40378b62:	002862        	l32i	a6, a8, 0
40378b65:	946060        	extui	a6, a6, 0, 10
40378b68:	661b      	addi.n	a6, a6, 1
        source_freq_mhz = (uint32_t)rtc_clk_xtal_freq_get();
40378b6a:	fff325        	call8	40378a9c <rtc_clk_xtal_freq_get>
        freq_mhz = source_freq_mhz / div;
40378b6d:	c2ba60        	quou	a11, a10, a6
    break;
40378b70:	003506        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
40378b73:	3e8100        	f64norm	a8, a1, a0, 1
40378b76:	ee          	.byte	0xee
40378b77:	0888      	l32i.n	a8, a8, 0
        ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378b79:	0d3816        	beqz	a8, 40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
40378b7c:	0027c6        	j	40378c1f <rtc_clk_cpu_freq_get_config+0xdb>
40378b7f:	7c8100        	lsi	f0, a1, 0x1f0
    uint32_t cpu_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL);
40378b82:	ef          	.byte	0xef
40378b83:	0020c0        	memw
40378b86:	0888      	l32i.n	a8, a8, 0
40378b88:	148080        	extui	a8, a8, 0, 2
    switch (cpu_freq_sel) {
40378b8b:	091826        	beqi	a8, 1, 40378b98 <rtc_clk_cpu_freq_get_config+0x54>
40378b8e:	0e2826        	beqi	a8, 2, 40378ba0 <rtc_clk_cpu_freq_get_config+0x5c>
40378b91:	18dc      	bnez.n	a8, 40378ba6 <rtc_clk_cpu_freq_get_config+0x62>
40378b93:	0b5c      	movi.n	a11, 80
40378b95:	0003c6        	j	40378ba8 <rtc_clk_cpu_freq_get_config+0x64>
        return CLK_LL_PLL_160M_FREQ_MHZ;
40378b98:	a0a0b2        	movi	a11, 160
40378b9b:	000246        	j	40378ba8 <rtc_clk_cpu_freq_get_config+0x64>
40378b9e:	b20000        	mulsh	a0, a0, a0
        return CLK_LL_PLL_240M_FREQ_MHZ;
40378ba1:	46f0a0        	lsi	f10, a0, 0x118
40378ba4:	0c0000        	lsi	f0, a0, 48
        return 0;
40378ba7:	810b      	addi.n	a8, a1, -1
    uint32_t pll_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
40378ba9:	c0ef72        	s32c1i	a7, a15, 0x300
40378bac:	880020        	lsi	f2, a0, 0x220
40378baf:	8008      	l32i.n	a0, a0, 32
40378bb1:	270492        	l8ui	a9, a4, 39
    switch (pll_freq_sel) {
40378bb4:	0968      	l32i.n	a6, a9, 0
40378bb6:	0c1966        	bnei	a9, 1, 40378bc6 <rtc_clk_cpu_freq_get_config+0x82>
        return CLK_LL_PLL_480M_FREQ_MHZ;
40378bb9:	e0a1a2        	movi	a10, 0x1e0
40378bbc:	000206        	j	40378bc8 <rtc_clk_cpu_freq_get_config+0x84>
40378bbf:	a1a200        	sll	a10, a2
    switch (pll_freq_sel) {
40378bc2:	004640        	break	6, 4
40378bc5:	0a0c00        	add.s	f0, f12, f0
        if (freq_mhz == CLK_LL_PLL_80M_FREQ_MHZ) {
40378bc8:	085c      	movi.n	a8, 80
40378bca:	0a9b87        	bne	a11, a8, 40378bd8 <rtc_clk_cpu_freq_get_config+0x94>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
40378bcd:	e0a182        	movi	a8, 0x1e0
40378bd0:	689a87        	bne	a10, a8, 40378c3c <rtc_clk_cpu_freq_get_config+0xf8>
40378bd3:	660c      	movi.n	a6, 6
40378bd5:	001bc6        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
        } else if (freq_mhz == CLK_LL_PLL_160M_FREQ_MHZ) {
40378bd8:	a0a082        	movi	a8, 160
40378bdb:	0a9b87        	bne	a11, a8, 40378be9 <rtc_clk_cpu_freq_get_config+0xa5>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
40378bde:	e0a182        	movi	a8, 0x1e0
40378be1:	5c9a87        	bne	a10, a8, 40378c41 <rtc_clk_cpu_freq_get_config+0xfd>
40378be4:	360c      	movi.n	a6, 3
40378be6:	001786        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
        } else if (freq_mhz == CLK_LL_PLL_240M_FREQ_MHZ  && source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
40378be9:	10af92        	movi	a9, -240
40378bec:	9b9a      	add.n	a9, a11, a9
40378bee:	40f990        	nsau	a9, a9
40378bf1:	419590        	srli	a9, a9, 5
40378bf4:	20ae82        	movi	a8, 0xfffffe20
40378bf7:	8a8a      	add.n	a8, a10, a8
40378bf9:	40f880        	nsau	a8, a8
40378bfc:	418580        	srli	a8, a8, 5
40378bff:	438987        	bany	a9, a8, 40378c46 <rtc_clk_cpu_freq_get_config+0x102>
40378c02:	ee1a81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40378c05:	0888      	l32i.n	a8, a8, 0
            ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378c07:	045816        	beqz	a8, 40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
40378c0a:	070265        	call8	4037fc30 <esp_log_timestamp>
40378c0d:	ef74c1        	l32r	a12, 403749e0 <_iram_text_start+0x5dc> (3fc93a1c <__FUNCTION__$0+0x164>)
40378c10:	20baa0        	or	a11, a10, a10
40378c13:	ef76a1        	l32r	a10, 403749ec <_iram_text_start+0x5e8> (3fc93a60 <__FUNCTION__$0+0x1a8>)
40378c16:	ee2781        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40378c19:	0008e0        	callx8	a8
            return;
40378c1c:	000c06        	j	40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
        ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378c1f:	070125        	call8	4037fc30 <esp_log_timestamp>
40378c22:	ef6fc1        	l32r	a12, 403749e0 <_iram_text_start+0x5dc> (3fc93a1c <__FUNCTION__$0+0x164>)
40378c25:	0abd      	mov.n	a11, a10
40378c27:	ef71a1        	l32r	a10, 403749ec <_iram_text_start+0x5e8> (3fc93a60 <__FUNCTION__$0+0x1a8>)
40378c2a:	ee2281        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40378c2d:	0008e0        	callx8	a8
40378c30:	000706        	j	40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
    switch (clk_sel) {
40378c33:	4b1c      	movi.n	a11, 20
40378c35:	160c      	movi.n	a6, 1
40378c37:	0bad      	mov.n	a10, a11
40378c39:	0002c6        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
40378c3c:	460c      	movi.n	a6, 4
40378c3e:	000186        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
40378c41:	260c      	movi.n	a6, 2
40378c43:	000046        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
            div = 2;
40378c46:	260c      	movi.n	a6, 2
    *out_config = (rtc_cpu_freq_config_t) {
40378c48:	0279      	s32i.n	a7, a2, 0
40378c4a:	12a9      	s32i.n	a10, a2, 4
40378c4c:	2269      	s32i.n	a6, a2, 8
40378c4e:	32b9      	s32i.n	a11, a2, 12
}
40378c50:	f01d      	retw.n
	...

40378c54 <rtc_clk_apb_freq_update>:
{
    clk_ll_xtal_store_freq_mhz(xtal_freq);
}

void rtc_clk_apb_freq_update(uint32_t apb_freq)
{
40378c54:	004136        	entry	a1, 32
    s_apb_freq = apb_freq;
40378c57:	ef6681        	l32r	a8, 403749f0 <_iram_text_start+0x5ec> (3fc94c24 <s_apb_freq>)
40378c5a:	0829      	s32i.n	a2, a8, 0
}
40378c5c:	f01d      	retw.n
	...

40378c60 <rtc_clk_cpu_freq_to_pll_mhz>:
{
40378c60:	006136        	entry	a1, 48
    int pd_slave = cpu_freq_mhz / 80;
40378c63:	ef6471        	l32r	a7, 403749f4 <_iram_text_start+0x5f0> (66666667 <_rtc_reserved_end+0x6566667>)
40378c66:	b27270        	mulsh	a7, a2, a7
40378c69:	217570        	srai	a7, a7, 5
40378c6c:	318f20        	srai	a8, a2, 31
40378c6f:	c07780        	sub	a7, a7, a8
    rtc_clk_cpu_freq_get_config(&cur_config);
40378c72:	01ad      	mov.n	a10, a1
40378c74:	ffece5        	call8	40378b44 <rtc_clk_cpu_freq_get_config>
    if (cpu_freq_mhz > cur_config.freq_mhz) {
40378c77:	3188      	l32i.n	a8, a1, 12
40378c79:	026d      	mov.n	a6, a2
40378c7b:	5db827        	bgeu	a8, a2, 40378cdc <rtc_clk_cpu_freq_to_pll_mhz+0x7c>
        if (cpu_freq_mhz == 240) {
40378c7e:	f0a082        	movi	a8, 240
40378c81:	309287        	bne	a2, a8, 40378cb5 <rtc_clk_cpu_freq_to_pll_mhz+0x55>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_240m);
40378c84:	ef5d81        	l32r	a8, 403749f8 <_iram_text_start+0x5f4> (3fc92070 <g_rtc_dbias_pvt_240m>)
40378c87:	0008f2        	l8ui	a15, a8, 0
40378c8a:	0e0c      	movi.n	a14, 0
40378c8c:	4d0c      	movi.n	a13, 4
40378c8e:	0dcd      	mov.n	a12, a13
40378c90:	1b0c      	movi.n	a11, 1
40378c92:	6da0a2        	movi	a10, 109
40378c95:	fdb965        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_240m);
40378c98:	ef5981        	l32r	a8, 403749fc <_iram_text_start+0x5f8> (3fc92074 <g_dig_dbias_pvt_240m>)
40378c9b:	0008f2        	l8ui	a15, a8, 0
40378c9e:	0e0c      	movi.n	a14, 0
40378ca0:	4d0c      	movi.n	a13, 4
40378ca2:	6c0c      	movi.n	a12, 6
40378ca4:	01a0b2        	movi	a11, 1
40378ca7:	6da0a2        	movi	a10, 109
40378caa:	fdb825        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            esp_rom_delay_us(40);
40378cad:	8a2c      	movi.n	a10, 40
40378caf:	ede181        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378cb2:	0008e0        	callx8	a8
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
40378cb5:	ef52a1        	l32r	a10, 40374a00 <_iram_text_start+0x5fc> (600081fc <RTCCNTL+0x1fc>)
40378cb8:	0020c0        	memw
40378cbb:	0a88      	l32i.n	a8, a10, 0
40378cbd:	ef5191        	l32r	a9, 40374a04 <_iram_text_start+0x600> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378cc0:	109890        	and	a9, a8, a9
40378cc3:	780c      	movi.n	a8, 7
40378cc5:	400700        	ssr	a7
40378cc8:	b18080        	sra	a8, a8
40378ccb:	118830        	slli	a8, a8, 13
40378cce:	548d80        	extui	a8, a8, 13, 6
40378cd1:	118830        	slli	a8, a8, 13
40378cd4:	208980        	or	a8, a9, a8
40378cd7:	0020c0        	memw
40378cda:	0a89      	s32i.n	a8, a10, 0
    switch (cpu_mhz) {
40378cdc:	a0a082        	movi	a8, 160
40378cdf:	211287        	beq	a2, a8, 40378d04 <rtc_clk_cpu_freq_to_pll_mhz+0xa4>
40378ce2:	f0a082        	movi	a8, 240
40378ce5:	371287        	beq	a2, a8, 40378d20 <rtc_clk_cpu_freq_to_pll_mhz+0xc0>
40378ce8:	085c      	movi.n	a8, 80
40378cea:	4f9287        	bne	a2, a8, 40378d3d <rtc_clk_cpu_freq_to_pll_mhz+0xdd>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 0);
40378ced:	ef2091        	l32r	a9, 40374970 <_iram_text_start+0x56c> (600c0010 <SYSTEM+0x10>)
40378cf0:	0020c0        	memw
40378cf3:	0988      	l32i.n	a8, a9, 0
40378cf5:	ca7c      	movi.n	a10, -4
40378cf7:	1088a0        	and	a8, a8, a10
40378cfa:	0020c0        	memw
40378cfd:	0989      	s32i.n	a8, a9, 0
        break;
40378cff:	000f46        	j	40378d40 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378d02:	910000        	srl	a0, a0
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 1);
40378d05:	ef1b      	addi.n	a14, a15, 1
40378d07:	0020c0        	memw
40378d0a:	0988      	l32i.n	a8, a9, 0
40378d0c:	ca7c      	movi.n	a10, -4
40378d0e:	1088a0        	and	a8, a8, a10
40378d11:	1a0c      	movi.n	a10, 1
40378d13:	2088a0        	or	a8, a8, a10
40378d16:	0020c0        	memw
40378d19:	0989      	s32i.n	a8, a9, 0
        break;
40378d1b:	000846        	j	40378d40 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378d1e:	910000        	srl	a0, a0
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 2);
40378d21:	c0ef14        	lsi	f1, a15, 0x300
40378d24:	880020        	lsi	f2, a0, 0x220
40378d27:	7c09      	s32i.n	a0, a12, 28
40378d29:	a0ca      	add.n	a10, a0, a12
40378d2b:	1088      	l32i.n	a8, a0, 4
40378d2d:	2a0c      	movi.n	a10, 2
40378d2f:	2088a0        	or	a8, a8, a10
40378d32:	0020c0        	memw
40378d35:	0989      	s32i.n	a8, a9, 0
        break;
40378d37:	000146        	j	40378d40 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378d3a:	000000        	ill
        abort();
40378d3d:	06fa65        	call8	4037fce4 <abort>
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378d40:	ef2a91        	l32r	a9, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378d43:	0020c0        	memw
40378d46:	0988      	l32i.n	a8, a9, 0
40378d48:	00aca2        	movi	a10, 0xfffffc00
40378d4b:	1088a0        	and	a8, a8, a10
40378d4e:	0020c0        	memw
40378d51:	0989      	s32i.n	a8, a9, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 1);
40378d53:	0020c0        	memw
40378d56:	0988      	l32i.n	a8, a9, 0
40378d58:	ef2ca1        	l32r	a10, 40374a08 <_iram_text_start+0x604> (fffff3ff <_rtc_reserved_end+0x9feff3ff>)
40378d5b:	1088a0        	and	a8, a8, a10
40378d5e:	00a4a2        	movi	a10, 0x400
40378d61:	2088a0        	or	a8, a8, a10
40378d64:	0020c0        	memw
40378d67:	006982        	s32i	a8, a9, 0
    rtc_clk_apb_freq_update(80 * MHZ);
40378d6a:	ef28a1        	l32r	a10, 40374a0c <_iram_text_start+0x608> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
40378d6d:	ffee65        	call8	40378c54 <rtc_clk_apb_freq_update>
    esp_rom_set_cpu_ticks_per_us(cpu_freq_mhz);
40378d70:	02ad      	mov.n	a10, a2
40378d72:	ef2981        	l32r	a8, 40374a18 <_iram_text_start+0x614> (40001a4c <esp_rom_set_cpu_ticks_per_us>)
40378d75:	0008e0        	callx8	a8
    if (cpu_freq_mhz < cur_config.freq_mhz) {
40378d78:	3188      	l32i.n	a8, a1, 12
40378d7a:	5eb687        	bgeu	a6, a8, 40378ddc <rtc_clk_cpu_freq_to_pll_mhz+0x17c>
        if (cur_config.freq_mhz == 240) {
40378d7d:	f0a092        	movi	a9, 240
40378d80:	319897        	bne	a8, a9, 40378db5 <rtc_clk_cpu_freq_to_pll_mhz+0x155>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378d83:	ef2381        	l32r	a8, 40374a10 <_iram_text_start+0x60c> (3fc92068 <g_rtc_dbias_pvt_non_240m>)
40378d86:	0008f2        	l8ui	a15, a8, 0
40378d89:	0e0c      	movi.n	a14, 0
40378d8b:	4d0c      	movi.n	a13, 4
40378d8d:	0dcd      	mov.n	a12, a13
40378d8f:	01a0b2        	movi	a11, 1
40378d92:	6da0a2        	movi	a10, 109
40378d95:	fda965        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
40378d98:	ef1f81        	l32r	a8, 40374a14 <_iram_text_start+0x610> (3fc9206c <g_dig_dbias_pvt_non_240m>)
40378d9b:	0008f2        	l8ui	a15, a8, 0
40378d9e:	0e0c      	movi.n	a14, 0
40378da0:	4d0c      	movi.n	a13, 4
40378da2:	6c0c      	movi.n	a12, 6
40378da4:	01a0b2        	movi	a11, 1
40378da7:	6da0a2        	movi	a10, 109
40378daa:	fda825        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            esp_rom_delay_us(40);
40378dad:	8a2c      	movi.n	a10, 40
40378daf:	eda181        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378db2:	0008e0        	callx8	a8
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
40378db5:	ef12a1        	l32r	a10, 40374a00 <_iram_text_start+0x5fc> (600081fc <RTCCNTL+0x1fc>)
40378db8:	0020c0        	memw
40378dbb:	0a88      	l32i.n	a8, a10, 0
40378dbd:	ef1191        	l32r	a9, 40374a04 <_iram_text_start+0x600> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378dc0:	109890        	and	a9, a8, a9
40378dc3:	780c      	movi.n	a8, 7
40378dc5:	400700        	ssr	a7
40378dc8:	b18080        	sra	a8, a8
40378dcb:	118830        	slli	a8, a8, 13
40378dce:	548d80        	extui	a8, a8, 13, 6
40378dd1:	118830        	slli	a8, a8, 13
40378dd4:	208980        	or	a8, a9, a8
40378dd7:	0020c0        	memw
40378dda:	0a89      	s32i.n	a8, a10, 0
}
40378ddc:	f01d      	retw.n
	...

40378de0 <rtc_clk_cpu_freq_to_xtal>:
{
40378de0:	006136        	entry	a1, 48
    rtc_clk_cpu_freq_get_config(&cur_config);
40378de3:	01ad      	mov.n	a10, a1
40378de5:	ffd5e5        	call8	40378b44 <rtc_clk_cpu_freq_get_config>
    esp_rom_set_cpu_ticks_per_us(cpu_freq);
40378de8:	02ad      	mov.n	a10, a2
40378dea:	ef0b81        	l32r	a8, 40374a18 <_iram_text_start+0x614> (40001a4c <esp_rom_set_cpu_ticks_per_us>)
40378ded:	0008e0        	callx8	a8
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378df0:	eefe91        	l32r	a9, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378df3:	0020c0        	memw
40378df6:	0988      	l32i.n	a8, a9, 0
40378df8:	00aca2        	movi	a10, 0xfffffc00
40378dfb:	1088a0        	and	a8, a8, a10
40378dfe:	0020c0        	memw
40378e01:	0989      	s32i.n	a8, a9, 0
    HAL_ASSERT(divider > 0);
40378e03:	00e356        	bnez	a3, 40378e15 <rtc_clk_cpu_freq_to_xtal+0x35>
40378e06:	ef05d1        	l32r	a13, 40374a1c <_iram_text_start+0x618> (3fc93a94 <__FUNCTION__$0+0x1dc>)
40378e09:	ef05c1        	l32r	a12, 40374a20 <_iram_text_start+0x61c> (3fc93888 <__func__$1>)
40378e0c:	e4a1b2        	movi	a11, 0x1e4
40378e0f:	eeeea1        	l32r	a10, 403749c8 <_iram_text_start+0x5c4> (3fc939e4 <__FUNCTION__$0+0x12c>)
40378e12:	06f8e5        	call8	4037fda0 <__assert_func>
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378e15:	eef491        	l32r	a9, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378e18:	0020c0        	memw
40378e1b:	002982        	l32i	a8, a9, 0
40378e1e:	00aca2        	movi	a10, 0xfffffc00
40378e21:	1088a0        	and	a8, a8, a10
40378e24:	330b      	addi.n	a3, a3, -1
40378e26:	943030        	extui	a3, a3, 0, 10
40378e29:	208830        	or	a8, a8, a3
40378e2c:	0020c0        	memw
40378e2f:	0989      	s32i.n	a8, a9, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 0);
40378e31:	0020c0        	memw
40378e34:	0988      	l32i.n	a8, a9, 0
40378e36:	eef4a1        	l32r	a10, 40374a08 <_iram_text_start+0x604> (fffff3ff <_rtc_reserved_end+0x9feff3ff>)
40378e39:	1088a0        	and	a8, a8, a10
40378e3c:	0020c0        	memw
40378e3f:	006982        	s32i	a8, a9, 0
    rtc_clk_apb_freq_update(cpu_freq * MHZ);
40378e42:	ee23a1        	l32r	a10, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40378e45:	82a2a0        	mull	a10, a2, a10
40378e48:	ffe0a5        	call8	40378c54 <rtc_clk_apb_freq_update>
    if (cur_config.freq_mhz == 240) {
40378e4b:	3198      	l32i.n	a9, a1, 12
40378e4d:	f0a082        	movi	a8, 240
40378e50:	309987        	bne	a9, a8, 40378e84 <rtc_clk_cpu_freq_to_xtal+0xa4>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378e53:	eeef81        	l32r	a8, 40374a10 <_iram_text_start+0x60c> (3fc92068 <g_rtc_dbias_pvt_non_240m>)
40378e56:	0008f2        	l8ui	a15, a8, 0
40378e59:	0e0c      	movi.n	a14, 0
40378e5b:	4d0c      	movi.n	a13, 4
40378e5d:	0dcd      	mov.n	a12, a13
40378e5f:	01a0b2        	movi	a11, 1
40378e62:	6da0a2        	movi	a10, 109
40378e65:	fd9c65        	call8	4037682c <regi2c_ctrl_write_reg_mask>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
40378e68:	eeeb81        	l32r	a8, 40374a14 <_iram_text_start+0x610> (3fc9206c <g_dig_dbias_pvt_non_240m>)
40378e6b:	0008f2        	l8ui	a15, a8, 0
40378e6e:	0e0c      	movi.n	a14, 0
40378e70:	4d0c      	movi.n	a13, 4
40378e72:	6c0c      	movi.n	a12, 6
40378e74:	1b0c      	movi.n	a11, 1
40378e76:	6da0a2        	movi	a10, 109
40378e79:	fd9b25        	call8	4037682c <regi2c_ctrl_write_reg_mask>
        esp_rom_delay_us(40);
40378e7c:	8a2c      	movi.n	a10, 40
40378e7e:	ed6d81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378e81:	0008e0        	callx8	a8
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
40378e84:	eedf91        	l32r	a9, 40374a00 <_iram_text_start+0x5fc> (600081fc <RTCCNTL+0x1fc>)
40378e87:	0020c0        	memw
40378e8a:	0988      	l32i.n	a8, a9, 0
40378e8c:	eedea1        	l32r	a10, 40374a04 <_iram_text_start+0x600> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378e8f:	1088a0        	and	a8, a8, a10
40378e92:	eee4a1        	l32r	a10, 40374a24 <_iram_text_start+0x620> (e000 <UserFrameTotalSize+0xdf00>)
40378e95:	2088a0        	or	a8, a8, a10
40378e98:	0020c0        	memw
40378e9b:	0989      	s32i.n	a8, a9, 0
}
40378e9d:	f01d      	retw.n
	...

40378ea0 <rtc_clk_cpu_freq_set_config>:
{
40378ea0:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
40378ea3:	eed181        	l32r	a8, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378ea6:	0020c0        	memw
40378ea9:	002872        	l32i	a7, a8, 0
40378eac:	147a70        	extui	a7, a7, 10, 2
    switch (clk_sel) {
40378eaf:	081726        	beqi	a7, 1, 40378ebb <rtc_clk_cpu_freq_set_config+0x1b>
40378eb2:	052726        	beqi	a7, 2, 40378ebb <rtc_clk_cpu_freq_set_config+0x1b>
40378eb5:	002716        	beqz	a7, 40378ebb <rtc_clk_cpu_freq_set_config+0x1b>
        return SOC_CPU_CLK_SRC_INVALID;
40378eb8:	03a072        	movi	a7, 3
    if (config->source == SOC_CPU_CLK_SRC_XTAL) {
40378ebb:	002282        	l32i	a8, a2, 0
40378ebe:	68dc      	bnez.n	a8, 40378ed8 <rtc_clk_cpu_freq_set_config+0x38>
        rtc_clk_cpu_freq_to_xtal(config->freq_mhz, config->div);
40378ec0:	22b8      	l32i.n	a11, a2, 8
40378ec2:	32a8      	l32i.n	a10, a2, 12
40378ec4:	fff1a5        	call8	40378de0 <rtc_clk_cpu_freq_to_xtal>
        if ((old_cpu_clk_src == SOC_CPU_CLK_SRC_PLL) && !s_bbpll_digi_consumers_ref_count) {
40378ec7:	331766        	bnei	a7, 1, 40378efe <rtc_clk_cpu_freq_set_config+0x5e>
40378eca:	eeab81        	l32r	a8, 40374978 <_iram_text_start+0x574> (3fc94c20 <s_bbpll_digi_consumers_ref_count>)
40378ecd:	0888      	l32i.n	a8, a8, 0
40378ecf:	b8ec      	bnez.n	a8, 40378efe <rtc_clk_cpu_freq_set_config+0x5e>
            rtc_clk_bbpll_disable();
40378ed1:	ff6765        	call8	40378548 <rtc_clk_bbpll_disable>
40378ed4:	000986        	j	40378efe <rtc_clk_cpu_freq_set_config+0x5e>
40378ed7:	186600        	lsxp	f6, a6, a0
    } else if (config->source == SOC_CPU_CLK_SRC_PLL) {
40378eda:	2619      	s32i.n	a1, a6, 8
        if (old_cpu_clk_src != SOC_CPU_CLK_SRC_PLL) {
40378edc:	a50b17        	bnone	a11, a1, 40378e85 <rtc_clk_cpu_freq_to_xtal+0xa5>
            rtc_clk_bbpll_enable();
40378edf:	ff68      	l32i.n	a6, a15, 60
            rtc_clk_bbpll_configure(rtc_clk_xtal_freq_get(), config->source_freq_mhz);
40378ee1:	ffbba5        	call8	40378a9c <rtc_clk_xtal_freq_get>
40378ee4:	0122b2        	l32i	a11, a2, 4
40378ee7:	ff6ae5        	call8	40378594 <rtc_clk_bbpll_configure>
        rtc_clk_cpu_freq_to_pll_mhz(config->freq_mhz);
40378eea:	32a8      	l32i.n	a10, a2, 12
40378eec:	ffd725        	call8	40378c60 <rtc_clk_cpu_freq_to_pll_mhz>
40378eef:	0002c6        	j	40378efe <rtc_clk_cpu_freq_set_config+0x5e>
40378ef2:	000000        	ill
    } else if (config->source == SOC_CPU_CLK_SRC_RC_FAST) {
40378ef5:	052866        	bnei	a8, 2, 40378efe <rtc_clk_cpu_freq_set_config+0x5e>
        rtc_clk_cpu_freq_to_8m();
40378ef8:	201110        	or	a1, a1, a1
40378efb:	ff6865        	call8	40378580 <rtc_clk_cpu_freq_to_8m>
}
40378efe:	f01d      	retw.n

40378f00 <rtc_clk_cpu_set_to_default_config>:
{
40378f00:	004136        	entry	a1, 32
    int freq_mhz = (int)rtc_clk_xtal_freq_get();
40378f03:	ffb9a5        	call8	40378a9c <rtc_clk_xtal_freq_get>
    rtc_clk_cpu_freq_to_xtal(freq_mhz, 1);
40378f06:	01a0b2        	movi	a11, 1
40378f09:	ffed65        	call8	40378de0 <rtc_clk_cpu_freq_to_xtal>
}
40378f0c:	000090        	retw
	...

40378f10 <rtc_clk_cpu_freq_set_xtal>:
{
40378f10:	004136        	entry	a1, 32
    rtc_clk_cpu_set_to_default_config();
40378f13:	fffee5        	call8	40378f00 <rtc_clk_cpu_set_to_default_config>
    rtc_clk_bbpll_disable();
40378f16:	ff6325        	call8	40378548 <rtc_clk_bbpll_disable>
}
40378f19:	f01d      	retw.n
	...

40378f1c <rtc_sleep_pu>:
/**
 * Configure whether certain peripherals are powered up in sleep
 * @param cfg power down flags as rtc_sleep_pu_config_t structure
 */
void rtc_sleep_pu(rtc_sleep_pu_config_t cfg)
{
40378f1c:	004136        	entry	a1, 32
    REG_SET_FIELD(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_LSLP_MEM_FORCE_PU, cfg.dig_fpu);
40378f1f:	eec2b1        	l32r	a11, 40374a28 <_iram_text_start+0x624> (60008090 <RTCCNTL+0x90>)
40378f22:	0020c0        	memw
40378f25:	0b88      	l32i.n	a8, a11, 0
40378f27:	fa6c      	movi.n	a10, -17
40378f29:	1088a0        	and	a8, a8, a10
40378f2c:	049020        	extui	a9, a2, 0, 1
40378f2f:	1199c0        	slli	a9, a9, 4
40378f32:	208890        	or	a8, a8, a9
40378f35:	0020c0        	memw
40378f38:	0b89      	s32i.n	a8, a11, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_FASTMEM_FORCE_LPU, cfg.rtc_fpu);
40378f3a:	eebc91        	l32r	a9, 40374a2c <_iram_text_start+0x628> (60008088 <RTCCNTL+0x88>)
40378f3d:	0020c0        	memw
40378f40:	0988      	l32i.n	a8, a9, 0
40378f42:	ffaeb2        	movi	a11, 0xfffffeff
40378f45:	1088b0        	and	a8, a8, a11
40378f48:	04b120        	extui	a11, a2, 1, 1
40378f4b:	11bb80        	slli	a11, a11, 8
40378f4e:	2088b0        	or	a8, a8, a11
40378f51:	0020c0        	memw
40378f54:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_LPU, cfg.rtc_fpu);
40378f56:	0020c0        	memw
40378f59:	0988      	l32i.n	a8, a9, 0
40378f5b:	eeb5b1        	l32r	a11, 40374a30 <_iram_text_start+0x62c> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
40378f5e:	1088b0        	and	a8, a8, a11
40378f61:	04b120        	extui	a11, a2, 1, 1
40378f64:	11bb50        	slli	a11, a11, 11
40378f67:	2088b0        	or	a8, a8, a11
40378f6a:	0020c0        	memw
40378f6d:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_DC_MEM_FORCE_PU, cfg.fe_fpu);
40378f6f:	eeb181        	l32r	a8, 40374a34 <_iram_text_start+0x630> (6002609c <SYSCON+0x9c>)
40378f72:	0020c0        	memw
40378f75:	0898      	l32i.n	a9, a8, 0
40378f77:	1099a0        	and	a9, a9, a10
40378f7a:	04a620        	extui	a10, a2, 6, 1
40378f7d:	11aac0        	slli	a10, a10, 4
40378f80:	2099a0        	or	a9, a9, a10
40378f83:	0020c0        	memw
40378f86:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_PBUS_MEM_FORCE_PU, cfg.fe_fpu);
40378f88:	0020c0        	memw
40378f8b:	0898      	l32i.n	a9, a8, 0
40378f8d:	ba7c      	movi.n	a10, -5
40378f8f:	1099a0        	and	a9, a9, a10
40378f92:	04a620        	extui	a10, a2, 6, 1
40378f95:	11aae0        	slli	a10, a10, 2
40378f98:	2099a0        	or	a9, a9, a10
40378f9b:	0020c0        	memw
40378f9e:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_AGC_MEM_FORCE_PU, cfg.fe_fpu);
40378fa0:	0020c0        	memw
40378fa3:	0898      	l32i.n	a9, a8, 0
40378fa5:	ea7c      	movi.n	a10, -2
40378fa7:	1099a0        	and	a9, a9, a10
40378faa:	04a620        	extui	a10, a2, 6, 1
40378fad:	2099a0        	or	a9, a9, a10
40378fb0:	0020c0        	memw
40378fb3:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(BBPD_CTRL, BB_FFT_FORCE_PU, cfg.bb_fpu);
40378fb5:	eea091        	l32r	a9, 40374a38 <_iram_text_start+0x634> (6001d054 <SENS+0x14854>)
40378fb8:	0020c0        	memw
40378fbb:	0988      	l32i.n	a8, a9, 0
40378fbd:	7c7c      	movi.n	a12, -9
40378fbf:	1088c0        	and	a8, a8, a12
40378fc2:	04a420        	extui	a10, a2, 4, 1
40378fc5:	11aad0        	slli	a10, a10, 3
40378fc8:	2088a0        	or	a8, a8, a10
40378fcb:	0020c0        	memw
40378fce:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(BBPD_CTRL, BB_DC_EST_FORCE_PU, cfg.bb_fpu);
40378fd0:	0020c0        	memw
40378fd3:	0988      	l32i.n	a8, a9, 0
40378fd5:	db7c      	movi.n	a11, -3
40378fd7:	1088b0        	and	a8, a8, a11
40378fda:	04a420        	extui	a10, a2, 4, 1
40378fdd:	aaaa      	add.n	a10, a10, a10
40378fdf:	2088a0        	or	a8, a8, a10
40378fe2:	0020c0        	memw
40378fe5:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_RX_ROT_FORCE_PU, cfg.nrx_fpu);
40378fe7:	ee9581        	l32r	a8, 40374a3c <_iram_text_start+0x638> (6001ccd4 <SENS+0x144d4>)
40378fea:	0020c0        	memw
40378fed:	0898      	l32i.n	a9, a8, 0
40378fef:	dfafa2        	movi	a10, -33
40378ff2:	1099a0        	and	a9, a9, a10
40378ff5:	04d520        	extui	a13, a2, 5, 1
40378ff8:	11ddb0        	slli	a13, a13, 5
40378ffb:	2099d0        	or	a9, a9, a13
40378ffe:	0020c0        	memw
40379001:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_VIT_FORCE_PU, cfg.nrx_fpu);
40379003:	0020c0        	memw
40379006:	0898      	l32i.n	a9, a8, 0
40379008:	1099c0        	and	a9, a9, a12
4037900b:	04c520        	extui	a12, a2, 5, 1
4037900e:	11ccd0        	slli	a12, a12, 3
40379011:	2099c0        	or	a9, a9, a12
40379014:	0020c0        	memw
40379017:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_DEMAP_FORCE_PU, cfg.nrx_fpu);
40379019:	0020c0        	memw
4037901c:	0898      	l32i.n	a9, a8, 0
4037901e:	1099b0        	and	a9, a9, a11
40379021:	04b520        	extui	a11, a2, 5, 1
40379024:	bbba      	add.n	a11, a11, a11
40379026:	2099b0        	or	a9, a9, a11
40379029:	0020c0        	memw
4037902c:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(FE_GEN_CTRL, FE_IQ_EST_FORCE_PU, cfg.fe_fpu);
4037902e:	ee84b1        	l32r	a11, 40374a40 <_iram_text_start+0x63c> (60006090 <GPIO+0x2090>)
40379031:	0020c0        	memw
40379034:	0b88      	l32i.n	a8, a11, 0
40379036:	1088a0        	and	a8, a8, a10
40379039:	049620        	extui	a9, a2, 6, 1
4037903c:	1199b0        	slli	a9, a9, 5
4037903f:	208890        	or	a8, a8, a9
40379042:	0020c0        	memw
40379045:	0b89      	s32i.n	a8, a11, 0
    REG_SET_FIELD(FE2_TX_INTERP_CTRL, FE2_TX_INF_FORCE_PU, cfg.fe_fpu);
40379047:	ee7fa1        	l32r	a10, 40374a44 <_iram_text_start+0x640> (600050f0 <GPIO+0x10f0>)
4037904a:	0020c0        	memw
4037904d:	0a88      	l32i.n	a8, a10, 0
4037904f:	ffab92        	movi	a9, 0xfffffbff
40379052:	108890        	and	a8, a8, a9
40379055:	049620        	extui	a9, a2, 6, 1
40379058:	119960        	slli	a9, a9, 10
4037905b:	208890        	or	a8, a8, a9
4037905e:	0020c0        	memw
40379061:	0a89      	s32i.n	a8, a10, 0
    if (cfg.sram_fpu) {
40379063:	80a082        	movi	a8, 128
40379066:	108280        	and	a8, a2, a8
40379069:	f48080        	extui	a8, a8, 0, 16
4037906c:	489c      	beqz.n	a8, 40379084 <rtc_sleep_pu+0x168>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, SYSCON_SRAM_POWER_UP);
4037906e:	ee7691        	l32r	a9, 40374a48 <_iram_text_start+0x644> (600260b0 <SYSCON+0xb0>)
40379071:	0020c0        	memw
40379074:	0988      	l32i.n	a8, a9, 0
40379076:	ee75a1        	l32r	a10, 40374a4c <_iram_text_start+0x648> (3ff8 <UserFrameTotalSize+0x3ef8>)
40379079:	2088a0        	or	a8, a8, a10
4037907c:	0020c0        	memw
4037907f:	0989      	s32i.n	a8, a9, 0
40379081:	000486        	j	40379097 <rtc_sleep_pu+0x17b>
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, 0);
40379084:	ee7191        	l32r	a9, 40374a48 <_iram_text_start+0x644> (600260b0 <SYSCON+0xb0>)
40379087:	0020c0        	memw
4037908a:	0988      	l32i.n	a8, a9, 0
4037908c:	ee71a1        	l32r	a10, 40374a50 <_iram_text_start+0x64c> (ffffc007 <_rtc_reserved_end+0x9fefc007>)
4037908f:	1088a0        	and	a8, a8, a10
40379092:	0020c0        	memw
40379095:	0989      	s32i.n	a8, a9, 0
    }
    if (cfg.rom_ram_fpu) {
40379097:	00a182        	movi	a8, 0x100
4037909a:	102280        	and	a2, a2, a8
4037909d:	f42020        	extui	a2, a2, 0, 16
403790a0:	429c      	beqz.n	a2, 403790b8 <rtc_sleep_pu+0x19c>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, SYSCON_ROM_POWER_UP);
403790a2:	ee6991        	l32r	a9, 40374a48 <_iram_text_start+0x644> (600260b0 <SYSCON+0xb0>)
403790a5:	0020c0        	memw
403790a8:	0988      	l32i.n	a8, a9, 0
403790aa:	7a0c      	movi.n	a10, 7
403790ac:	2088a0        	or	a8, a8, a10
403790af:	0020c0        	memw
403790b2:	0989      	s32i.n	a8, a9, 0
403790b4:	000486        	j	403790ca <rtc_sleep_pu+0x1ae>
403790b7:	649100        	extui	a9, a0, 1, 7
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, 0);
403790ba:	ee          	.byte	0xee
403790bb:	0020c0        	memw
403790be:	0988      	l32i.n	a8, a9, 0
403790c0:	8a7c      	movi.n	a10, -8
403790c2:	1088a0        	and	a8, a8, a10
403790c5:	0020c0        	memw
403790c8:	0989      	s32i.n	a8, a9, 0
    }
}
403790ca:	f01d      	retw.n

403790cc <rtc_clk_cal_internal>:
 * @param cal_clk which clock to calibrate
 * @param slowclk_cycles number of slow clock cycles to count
 * @return number of XTAL clock cycles within the given number of slow clock cycles
 */
uint32_t rtc_clk_cal_internal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
403790cc:	004136        	entry	a1, 32
403790cf:	027d      	mov.n	a7, a2
    /* On ESP32S3, choosing RTC_CAL_RTC_MUX results in calibration of
     * the 150k RTC clock regardless of the currently selected SLOW_CLK.
     * On the ESP32, it used the currently selected SLOW_CLK.
     * The following code emulates ESP32 behavior:
     */
    if (cal_clk == RTC_CAL_RTC_MUX) {
403790d1:	b2cc      	bnez.n	a2, 403790e0 <rtc_clk_cal_internal+0x14>
        soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
403790d3:	ff9325        	call8	40378a04 <rtc_clk_slow_src_get>
        if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
403790d6:	0c1a26        	beqi	a10, 1, 403790e6 <rtc_clk_cal_internal+0x1a>
            cal_clk = RTC_CAL_32K_XTAL;
        } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
403790d9:	172a66        	bnei	a10, 2, 403790f4 <rtc_clk_cal_internal+0x28>
403790dc:	000346        	j	403790ed <rtc_clk_cal_internal+0x21>
403790df:	326600        	orbc	b6, b6, b0
            cal_clk = RTC_CAL_8MD256;
        }
    } else if (cal_clk == RTC_CAL_INTERNAL_OSC) {
403790e2:	02c610        	andb	b12, b6, b1
403790e5:	270c00        	lsi	f0, a12, 156
            cal_clk = RTC_CAL_32K_XTAL;
403790e8:	000206        	j	403790f4 <rtc_clk_cal_internal+0x28>
403790eb:	0c0000        	lsi	f0, a0, 48
            cal_clk = RTC_CAL_8MD256;
403790ee:	004617        	ball	a6, a1, 403790f2 <rtc_clk_cal_internal+0x26>
403790f1:	070c00        	lsi	f0, a12, 28
    return REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN);
403790f4:	ee3081        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403790f7:	0020c0        	memw
403790fa:	08a8      	l32i.n	a10, a8, 0
        cal_clk = RTC_CAL_RTC_MUX;
    }

    /* Enable requested clock (150k clock is always on) */
    bool dig_32k_xtal_enabled = clk_ll_xtal32k_digi_is_enabled();
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
403790fc:	fec782        	addi	a8, a7, -2
403790ff:	40f880        	nsau	a8, a8
40379102:	418580        	srli	a8, a8, 5
40379105:	04a8a0        	extui	a10, a10, 8, 1
40379108:	190c      	movi.n	a9, 1
4037910a:	3099a0        	xor	a9, a9, a10
4037910d:	104980        	and	a4, a9, a8
40379110:	130987        	bnone	a9, a8, 40379127 <rtc_clk_cal_internal+0x5b>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40379113:	ee2891        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40379116:	0020c0        	memw
40379119:	0988      	l32i.n	a8, a9, 0
4037911b:	00a1a2        	movi	a10, 0x100
4037911e:	2088a0        	or	a8, a8, a10
40379121:	0020c0        	memw
40379124:	006982        	s32i	a8, a9, 0
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M) == 0;
40379127:	ee2381        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
4037912a:	0020c0        	memw
4037912d:	0868      	l32i.n	a6, a8, 0
4037912f:	094c      	movi.n	a9, 64
40379131:	106690        	and	a6, a6, a9
40379134:	40f660        	nsau	a6, a6
40379137:	416560        	srli	a6, a6, 5
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
4037913a:	0020c0        	memw
4037913d:	0858      	l32i.n	a5, a8, 0
4037913f:	80a082        	movi	a8, 128
40379142:	105580        	and	a5, a5, a8
40379145:	40f550        	nsau	a5, a5
40379148:	415550        	srli	a5, a5, 5
        clk_ll_xtal32k_digi_enable();
    }

    bool rc_fast_enabled = clk_ll_rc_fast_is_enabled();
    bool rc_fast_d256_enabled = clk_ll_rc_fast_d256_is_enabled();
    if (cal_clk == RTC_CAL_8MD256) {
4037914b:	191766        	bnei	a7, 1, 40379168 <rtc_clk_cal_internal+0x9c>
        rtc_clk_8m_enable(true, true);
4037914e:	1b0c      	movi.n	a11, 1
40379150:	0bad      	mov.n	a10, a11
40379152:	ff6fe5        	call8	40378850 <rtc_clk_8m_enable>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
40379155:	ee1791        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40379158:	0020c0        	memw
4037915b:	0988      	l32i.n	a8, a9, 0
4037915d:	00a2a2        	movi	a10, 0x200
40379160:	2088a0        	or	a8, a8, a10
40379163:	0020c0        	memw
40379166:	0989      	s32i.n	a8, a9, 0
        clk_ll_rc_fast_d256_digi_enable();
    }
    /* There may be another calibration process already running during we call this function,
     * so we should wait the last process is done.
     */
    if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING)) {
40379168:	ee3b81        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
4037916b:	0020c0        	memw
4037916e:	0888      	l32i.n	a8, a8, 0
40379170:	2c68c7        	bbci	a8, 12, 403791a0 <rtc_clk_cal_internal+0xd4>
        /**
         * Set a small timeout threshold to accelerate the generation of timeout.
         * The internal circuit will be reset when the timeout occurs and will not affect the next calibration.
         */
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, 1);
40379173:	ee3991        	l32r	a9, 40374a58 <_iram_text_start+0x654> (6001f080 <TIMERG0+0x80>)
40379176:	0020c0        	memw
40379179:	0988      	l32i.n	a8, a9, 0
4037917b:	748080        	extui	a8, a8, 0, 8
4037917e:	80a0a2        	movi	a10, 128
40379181:	2088a0        	or	a8, a8, a10
40379184:	0020c0        	memw
40379187:	0989      	s32i.n	a8, a9, 0
        while (!GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)
40379189:	ee3281        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
4037918c:	0020c0        	memw
4037918f:	0888      	l32i.n	a8, a8, 0
                && !GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT));
40379191:	0be8f7        	bbsi	a8, 15, 403791a0 <rtc_clk_cal_internal+0xd4>
40379194:	ee3181        	l32r	a8, 40374a58 <_iram_text_start+0x654> (6001f080 <TIMERG0+0x80>)
40379197:	0020c0        	memw
4037919a:	002882        	l32i	a8, a8, 0
4037919d:	e86807        	bbci	a8, 0, 40379189 <rtc_clk_cal_internal+0xbd>
    }

    /* Prepare calibration */
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_CLK_SEL, cal_clk);
403791a0:	ee2d81        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
403791a3:	0020c0        	memw
403791a6:	0898      	l32i.n	a9, a8, 0
403791a8:	ee2da1        	l32r	a10, 40374a5c <_iram_text_start+0x658> (ffff9fff <_rtc_reserved_end+0x9fef9fff>)
403791ab:	1099a0        	and	a9, a9, a10
403791ae:	11a730        	slli	a10, a7, 13
403791b1:	14ada0        	extui	a10, a10, 13, 2
403791b4:	11aa30        	slli	a10, a10, 13
403791b7:	2099a0        	or	a9, a9, a10
403791ba:	0020c0        	memw
403791bd:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING);
403791bf:	0020c0        	memw
403791c2:	0898      	l32i.n	a9, a8, 0
403791c4:	ee27a1        	l32r	a10, 40374a60 <_iram_text_start+0x65c> (ffffefff <_rtc_reserved_end+0x9fefefff>)
403791c7:	1099a0        	and	a9, a9, a10
403791ca:	0020c0        	memw
403791cd:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_MAX, slowclk_cycles);
403791cf:	0020c0        	memw
403791d2:	0898      	l32i.n	a9, a8, 0
403791d4:	ee24a1        	l32r	a10, 40374a64 <_iram_text_start+0x660> (8000ffff <_rtc_reserved_end+0x1ff0ffff>)
403791d7:	1099a0        	and	a9, a9, a10
403791da:	11a300        	slli	a10, a3, 16
403791dd:	e5a0a0        	extui	a10, a10, 16, 15
403791e0:	11aa00        	slli	a10, a10, 16
403791e3:	2099a0        	or	a9, a9, a10
403791e6:	0020c0        	memw
403791e9:	0899      	s32i.n	a9, a8, 0
    /* Figure out how long to wait for calibration to finish */

    /* Set timeout reg and expect time delay*/
    uint32_t expected_freq;
    if (cal_clk == RTC_CAL_32K_XTAL) {
403791eb:	1d2766        	bnei	a7, 2, 4037920c <rtc_clk_cal_internal+0x140>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_X32K_CAL_TIMEOUT_THRES(slowclk_cycles));
403791ee:	ee1a91        	l32r	a9, 40374a58 <_iram_text_start+0x654> (6001f080 <TIMERG0+0x80>)
403791f1:	0020c0        	memw
403791f4:	0988      	l32i.n	a8, a9, 0
403791f6:	648080        	extui	a8, a8, 0, 7
403791f9:	01a3d0        	slli	a10, a3, 19
403791fc:	2088a0        	or	a8, a8, a10
403791ff:	0020c0        	memw
40379202:	0989      	s32i.n	a8, a9, 0
        expected_freq = SOC_CLK_XTAL32K_FREQ_APPROX;
40379204:	ec94c1        	l32r	a12, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
40379207:	000ec6        	j	40379246 <rtc_clk_cal_internal+0x17a>
4037920a:	660000        	lsi	f0, a0, 0x198
    } else if (cal_clk == RTC_CAL_8MD256) {
4037920d:	911c17        	beq	a12, a1, 403791a2 <rtc_clk_cal_internal+0xd6>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_8MD256_CAL_TIMEOUT_THRES(slowclk_cycles));
40379210:	c0ee12        	s32c1i	a1, a14, 0x300
40379213:	880020        	lsi	f2, a0, 0x220
40379216:	8009      	s32i.n	a0, a0, 32
40379218:	d06480        	subx2	a6, a4, a8
4037921b:	a001a3        	lsi	f10, a1, 0x280
4037921e:	2088      	l32i.n	a8, a0, 8
40379220:	0020c0        	memw
40379223:	0989      	s32i.n	a8, a9, 0
        expected_freq = SOC_CLK_RC_FAST_D256_FREQ_APPROX;
40379225:	edebc1        	l32r	a12, 403749d4 <_iram_text_start+0x5d0> (10b07 <UserFrameTotalSize+0x10a07>)
40379228:	000686        	j	40379246 <rtc_clk_cal_internal+0x17a>
4037922b:	0b9100        	lsi	f0, a1, 44
    } else {
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_150K_CAL_TIMEOUT_THRES(slowclk_cycles));
4037922e:	ee          	.byte	0xee
4037922f:	0020c0        	memw
40379232:	0988      	l32i.n	a8, a9, 0
40379234:	648080        	extui	a8, a8, 0, 7
40379237:	01a3f0        	slli	a10, a3, 17
4037923a:	2088a0        	or	a8, a8, a10
4037923d:	0020c0        	memw
40379240:	006982        	s32i	a8, a9, 0
        expected_freq = SOC_CLK_RC_SLOW_FREQ_APPROX;
40379243:	ede3c1        	l32r	a12, 403749d0 <_iram_text_start+0x5cc> (21340 <UserFrameTotalSize+0x21240>)
    }
    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);
40379246:	ed22a1        	l32r	a10, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40379249:	a2b3a0        	muluh	a11, a3, a10
4037924c:	00a0d2        	movi	a13, 0
4037924f:	82a3a0        	mull	a10, a3, a10
40379252:	ecc381        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
40379255:	0008e0        	callx8	a8
    /* Start calibration */
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
40379258:	edff91        	l32r	a9, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
4037925b:	0020c0        	memw
4037925e:	0988      	l32i.n	a8, a9, 0
40379260:	888a      	add.n	a8, a8, a8
40379262:	418180        	srli	a8, a8, 1
40379265:	0020c0        	memw
40379268:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
4037926a:	0020c0        	memw
4037926d:	0988      	l32i.n	a8, a9, 0
4037926f:	ecabb1        	l32r	a11, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
40379272:	2088b0        	or	a8, a8, a11
40379275:	0020c0        	memw
40379278:	0989      	s32i.n	a8, a9, 0

    /* Wait for calibration to finish up to another us_time_estimate */
    esp_rom_delay_us(us_time_estimate);
4037927a:	ec6e81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
4037927d:	0008e0        	callx8	a8
    uint32_t cal_val;
    while (true) {
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)) {
40379280:	edf581        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
40379283:	0020c0        	memw
40379286:	0888      	l32i.n	a8, a8, 0
40379288:	042f80        	extui	a2, a8, 15, 1
4037928b:	112210        	slli	a2, a2, 15
4037928e:	0e68f7        	bbci	a8, 15, 403792a0 <rtc_clk_cal_internal+0x1d4>
            cal_val = REG_GET_FIELD(TIMG_RTCCALICFG1_REG(0), TIMG_RTC_CALI_VALUE);
40379291:	edf581        	l32r	a8, 40374a68 <_iram_text_start+0x664> (6001f06c <TIMERG0+0x6c>)
40379294:	0020c0        	memw
40379297:	0828      	l32i.n	a2, a8, 0
40379299:	412720        	srli	a2, a2, 7
            break;
4037929c:	0002c6        	j	403792ab <rtc_clk_cal_internal+0x1df>
4037929f:	ee8100        	f64iter	a8, a1, a0, 2, 1
        }
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT)) {
403792a2:	c0ed      	lsi	f14, a0, 0
403792a4:	880020        	lsi	f2, a0, 0x220
403792a7:	0708      	l32i.n	a0, a7, 0
403792a9:	d468      	l32i.n	a6, a4, 52
            cal_val = 0;
            break;
        }
    }
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
403792ab:	edea91        	l32r	a9, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
403792ae:	0020c0        	memw
403792b1:	0988      	l32i.n	a8, a9, 0
403792b3:	888a      	add.n	a8, a8, a8
403792b5:	418180        	srli	a8, a8, 1
403792b8:	0020c0        	memw
403792bb:	0989      	s32i.n	a8, a9, 0

    /* if dig_32k_xtal was originally off and enabled due to calibration, then set back to off state */
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
403792bd:	249c      	beqz.n	a4, 403792d3 <rtc_clk_cal_internal+0x207>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
403792bf:	edbd91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403792c2:	0020c0        	memw
403792c5:	0988      	l32i.n	a8, a9, 0
403792c7:	ffaea2        	movi	a10, 0xfffffeff
403792ca:	1088a0        	and	a8, a8, a10
403792cd:	0020c0        	memw
403792d0:	006982        	s32i	a8, a9, 0
        clk_ll_xtal32k_digi_disable();
    }

    if (cal_clk == RTC_CAL_8MD256) {
403792d3:	191766        	bnei	a7, 1, 403792f0 <rtc_clk_cal_internal+0x224>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
403792d6:	edb791        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403792d9:	0020c0        	memw
403792dc:	0988      	l32i.n	a8, a9, 0
403792de:	ffada2        	movi	a10, 0xfffffdff
403792e1:	1088a0        	and	a8, a8, a10
403792e4:	0020c0        	memw
403792e7:	0989      	s32i.n	a8, a9, 0
        clk_ll_rc_fast_d256_digi_disable();
        rtc_clk_8m_enable(rc_fast_enabled, rc_fast_d256_enabled);
403792e9:	05bd      	mov.n	a11, a5
403792eb:	06ad      	mov.n	a10, a6
403792ed:	ff5625        	call8	40378850 <rtc_clk_8m_enable>
    }

    return cal_val;
}
403792f0:	f01d      	retw.n
	...

403792f4 <rtc_clk_cal>:
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
}

uint32_t rtc_clk_cal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
403792f4:	004136        	entry	a1, 32
    assert(slowclk_cycles);
403792f7:	011356        	bnez	a3, 4037930c <rtc_clk_cal+0x18>
403792fa:	eddcd1        	l32r	a13, 40374a6c <_iram_text_start+0x668> (3c023758 <_flash_rodata_start+0x3638>)
403792fd:	eddcc1        	l32r	a12, 40374a70 <_iram_text_start+0x66c> (3c027e80 <__func__$1>)
40379300:	93a0b2        	movi	a11, 147
40379303:	eddca1        	l32r	a10, 40374a74 <_iram_text_start+0x670> (3c023795 <_flash_rodata_start+0x3675>)
40379306:	201110        	or	a1, a1, a1
40379309:	06a965        	call8	4037fda0 <__assert_func>
    soc_xtal_freq_t xtal_freq = rtc_clk_xtal_freq_get();
4037930c:	ff78e5        	call8	40378a9c <rtc_clk_xtal_freq_get>
4037930f:	0a6d      	mov.n	a6, a10
    uint64_t xtal_cycles = rtc_clk_cal_internal(cal_clk, slowclk_cycles);
40379311:	03bd      	mov.n	a11, a3
40379313:	02ad      	mov.n	a10, a2
40379315:	ffdb65        	call8	403790cc <rtc_clk_cal_internal>
40379318:	0a7d      	mov.n	a7, a10
4037931a:	050c      	movi.n	a5, 0

    if ((cal_clk == RTC_CAL_32K_XTAL) && !rtc_clk_cal_32k_valid((uint32_t)xtal_freq, slowclk_cycles, xtal_cycles)) {
4037931c:	562266        	bnei	a2, 2, 40379376 <rtc_clk_cal+0x82>
    uint64_t expected_xtal_cycles = (xtal_freq * 1000000ULL * slowclk_cycles) >> 15; // xtal_freq(hz) * slowclk_cycles / 32768
4037931f:	828630        	mull	a8, a6, a3
40379322:	a22630        	muluh	a2, a6, a3
40379325:	ecea91        	l32r	a9, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40379328:	822290        	mull	a2, a2, a9
4037932b:	824890        	mull	a4, a8, a9
4037932e:	a28890        	muluh	a8, a8, a9
40379331:	228a      	add.n	a2, a2, a8
40379333:	0182f0        	slli	a8, a2, 17
40379336:	414f40        	srli	a4, a4, 15
40379339:	204840        	or	a4, a8, a4
4037933c:	412f20        	srli	a2, a2, 15
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
4037933f:	d0a7c2        	movi	a12, 0x7d0
40379342:	05dd      	mov.n	a13, a5
40379344:	04ad      	mov.n	a10, a4
40379346:	02bd      	mov.n	a11, a2
40379348:	ec8681        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
4037934b:	0008e0        	callx8	a8
4037934e:	0a9d      	mov.n	a9, a10
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
40379350:	c082b0        	sub	a8, a2, a11
40379353:	01b4a7        	bgeu	a4, a10, 40379358 <rtc_clk_cal+0x64>
40379356:	880b      	addi.n	a8, a8, -1
40379358:	c0c4a0        	sub	a12, a4, a10
4037935b:	513587        	bltu	a5, a8, 403793b0 <rtc_clk_cal+0xbc>
4037935e:	029857        	bne	a8, a5, 40379364 <rtc_clk_cal+0x70>
40379361:	4b37c7        	bltu	a7, a12, 403793b0 <rtc_clk_cal+0xbc>
40379364:	22ba      	add.n	a2, a2, a11
40379366:	44aa      	add.n	a4, a4, a10
40379368:	01b497        	bgeu	a4, a9, 4037936d <rtc_clk_cal+0x79>
4037936b:	221b      	addi.n	a2, a2, 1
4037936d:	443257        	bltu	a2, a5, 403793b5 <rtc_clk_cal+0xc1>
40379370:	029527        	bne	a5, a2, 40379376 <rtc_clk_cal+0x82>
40379373:	3e3477        	bltu	a4, a7, 403793b5 <rtc_clk_cal+0xc1>
        return 0;
    }

    uint64_t divider = ((uint64_t)xtal_freq) * slowclk_cycles;
40379376:	82c630        	mull	a12, a6, a3
40379379:	a2d630        	muluh	a13, a6, a3
    uint64_t period_64 = ((xtal_cycles << RTC_CLK_CAL_FRACT) + divider / 2 - 1) / divider;
4037937c:	418d70        	srli	a8, a7, 13
4037937f:	01a7d0        	slli	a10, a7, 19
40379382:	01bd10        	slli	a11, a13, 31
40379385:	4191c0        	srli	a9, a12, 1
40379388:	209b90        	or	a9, a11, a9
4037938b:	41b1d0        	srli	a11, a13, 1
4037938e:	88ba      	add.n	a8, a8, a11
40379390:	80aa90        	add	a10, a10, a9
40379393:	02ba97        	bgeu	a10, a9, 40379399 <rtc_clk_cal+0xa5>
40379396:	01c882        	addi	a8, a8, 1
40379399:	f97c      	movi.n	a9, -1
4037939b:	b89a      	add.n	a11, a8, a9
4037939d:	aa9a      	add.n	a10, a10, a9
4037939f:	01ba97        	bgeu	a10, a9, 403793a4 <rtc_clk_cal+0xb0>
403793a2:	08bd      	mov.n	a11, a8
403793a4:	ec6f81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
403793a7:	0008e0        	callx8	a8
    uint32_t period = (uint32_t)(period_64 & UINT32_MAX);
403793aa:	0a2d      	mov.n	a2, a10
    return period;
403793ac:	0001c6        	j	403793b7 <rtc_clk_cal+0xc3>
403793af:	020c00        	andb	b0, b12, b0
        return 0;
403793b2:	000046        	j	403793b7 <rtc_clk_cal+0xc3>
403793b5:	020c      	movi.n	a2, 0
}
403793b7:	f01d      	retw.n
403793b9:	000000        	ill

403793bc <rtc_time_us_to_slowclk>:

uint64_t rtc_time_us_to_slowclk(uint64_t time_in_us, uint32_t period)
{
403793bc:	004136        	entry	a1, 32
403793bf:	04cd      	mov.n	a12, a4
    assert(period);
403793c1:	04dc      	bnez.n	a4, 403793d5 <rtc_time_us_to_slowclk+0x19>
403793c3:	edadd1        	l32r	a13, 40374a78 <_iram_text_start+0x674> (3c0237a0 <_flash_rodata_start+0x3680>)
403793c6:	edadc1        	l32r	a12, 40374a7c <_iram_text_start+0x678> (3c027e68 <__func__$0>)
403793c9:	a3a0b2        	movi	a11, 163
403793cc:	edaaa1        	l32r	a10, 40374a74 <_iram_text_start+0x670> (3c023795 <_flash_rodata_start+0x3675>)
403793cf:	201110        	or	a1, a1, a1
403793d2:	069ce5        	call8	4037fda0 <__assert_func>
    /* Overflow will happen in this function if time_in_us >= 2^45, which is about 400 days.
     * TODO: fix overflow.
     */
    return (time_in_us << RTC_CLK_CAL_FRACT) / period;
403793d5:	41bd20        	srli	a11, a2, 13
403793d8:	0133d0        	slli	a3, a3, 19
403793db:	0d0c      	movi.n	a13, 0
403793dd:	01a2d0        	slli	a10, a2, 19
403793e0:	20bb30        	or	a11, a11, a3
403793e3:	ec5f81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
403793e6:	0008e0        	callx8	a8
}
403793e9:	0a2d      	mov.n	a2, a10
403793eb:	0b3d      	mov.n	a3, a11
403793ed:	f01d      	retw.n
	...

403793f0 <rtc_time_get>:
{
    return (rtc_cycles * period) >> RTC_CLK_CAL_FRACT;
}

uint64_t rtc_time_get(void)
{
403793f0:	004136        	entry	a1, 32
    SET_PERI_REG_MASK(RTC_CNTL_STATE0_REG, RTC_CNTL_SLEEP_EN);
}

FORCE_INLINE_ATTR uint64_t rtc_cntl_ll_get_rtc_time(void)
{
    SET_PERI_REG_MASK(RTC_CNTL_TIME_UPDATE_REG, RTC_CNTL_TIME_UPDATE);
403793f3:	eda391        	l32r	a9, 40374a80 <_iram_text_start+0x67c> (6000800c <RTCCNTL+0xc>)
403793f6:	0020c0        	memw
403793f9:	0988      	l32i.n	a8, a9, 0
403793fb:	ec48a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403793fe:	2088a0        	or	a8, a8, a10
40379401:	0020c0        	memw
40379404:	0989      	s32i.n	a8, a9, 0
    uint64_t t = READ_PERI_REG(RTC_CNTL_TIME0_REG);
40379406:	ed9f81        	l32r	a8, 40374a84 <_iram_text_start+0x680> (60008010 <RTCCNTL+0x10>)
40379409:	0020c0        	memw
4037940c:	0828      	l32i.n	a2, a8, 0
    t |= ((uint64_t) READ_PERI_REG(RTC_CNTL_TIME1_REG)) << 32;
4037940e:	ed9e81        	l32r	a8, 40374a88 <_iram_text_start+0x684> (60008014 <RTCCNTL+0x14>)
40379411:	0020c0        	memw
40379414:	0838      	l32i.n	a3, a8, 0
    return rtc_cntl_ll_get_rtc_time();
}
40379416:	f01d      	retw.n

40379418 <enable_timer_group0_for_calibration>:
}

/// @brief if the calibration is used, we need to enable the timer group0 first
__attribute__((constructor))
static void enable_timer_group0_for_calibration(void)
{
40379418:	004136        	entry	a1, 32
#ifndef BOOTLOADER_BUILD
    PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_TIMG0_MODULE, ref_count) {
4037941b:	170c      	movi.n	a7, 1
4037941d:	001406        	j	40379471 <enable_timer_group0_for_calibration+0x59>
 * @param enable true to enable, false to disable
 */
static inline void _timer_ll_enable_bus_clock(int group_id, bool enable)
{
    if (group_id == 0) {
        SYSTEM.perip_clk_en0.timergroup_clk_en = enable;
40379420:	ed9b81        	l32r	a8, 40374a8c <_iram_text_start+0x688> (600c0000 <SYSTEM>)
40379423:	0020c0        	memw
40379426:	062892        	l32i	a9, a8, 24
40379429:	ed99a1        	l32r	a10, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037942c:	2099a0        	or	a9, a9, a10
4037942f:	0020c0        	memw
40379432:	066892        	s32i	a9, a8, 24
 * @param group_id Group ID
 */
static inline void _timer_ll_reset_register(int group_id)
{
    if (group_id == 0) {
        SYSTEM.perip_rst_en0.timergroup_rst = 1;
40379435:	0020c0        	memw
40379438:	8898      	l32i.n	a9, a8, 32
4037943a:	2099a0        	or	a9, a9, a10
4037943d:	0020c0        	memw
40379440:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup_rst = 0;
40379442:	0020c0        	memw
40379445:	8898      	l32i.n	a9, a8, 32
40379447:	ed93a1        	l32r	a10, 40374a94 <_iram_text_start+0x690> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4037944a:	1099a0        	and	a9, a9, a10
4037944d:	0020c0        	memw
40379450:	8899      	s32i.n	a9, a8, 32
        TIMERG0.wdtconfig0.wdt_flashboot_mod_en = 0;
40379452:	ed9191        	l32r	a9, 40374a98 <_iram_text_start+0x694> (6001f000 <TIMERG0>)
40379455:	0020c0        	memw
40379458:	122982        	l32i	a8, a9, 72
4037945b:	ed90a1        	l32r	a10, 40374a9c <_iram_text_start+0x698> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
4037945e:	1088a0        	and	a8, a8, a10
40379461:	0020c0        	memw
40379464:	126982        	s32i	a8, a9, 72
40379467:	aa0c      	movi.n	a10, 10
40379469:	fd2625        	call8	403766cc <periph_rcc_acquire_exit>
4037946c:	770b      	addi.n	a7, a7, -1
4037946e:	747070        	extui	a7, a7, 0, 8
40379471:	b78c      	beqz.n	a7, 40379480 <enable_timer_group0_for_calibration+0x68>
40379473:	aa0c      	movi.n	a10, 10
40379475:	fd2465        	call8	403766bc <periph_rcc_acquire_enter>
40379478:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
4037947a:	fa2a16        	beqz	a10, 40379420 <enable_timer_group0_for_calibration+0x8>
4037947d:	fff986        	j	40379467 <enable_timer_group0_for_calibration+0x4f>
    }
#else
    _timer_ll_enable_bus_clock(0, true);
    _timer_ll_reset_register(0);
#endif
}
40379480:	f01d      	retw.n
	...

40379484 <systimer_ticks_to_us>:
 * @brief systimer's clock source is fixed to XTAL (40MHz), and has a fixed fractional divider (2.5).
 *        So the resolution of the systimer is 40MHz/2.5 = 16MHz.
 */

uint64_t systimer_ticks_to_us(uint64_t ticks)
{
40379484:	004136        	entry	a1, 32
    return ticks / 16;
40379487:	018340        	slli	a8, a3, 28
4037948a:	412420        	srli	a2, a2, 4
}
4037948d:	202820        	or	a2, a8, a2
40379490:	413430        	srli	a3, a3, 4
40379493:	f01d      	retw.n
40379495:	000000        	ill

40379498 <systimer_us_to_ticks>:

uint64_t systimer_us_to_ticks(uint64_t us)
{
40379498:	004136        	entry	a1, 32
    return us * 16;
4037949b:	358c20        	extui	a8, a2, 28, 4
4037949e:	1133c0        	slli	a3, a3, 4
}
403794a1:	1122c0        	slli	a2, a2, 4
403794a4:	203830        	or	a3, a8, a3
403794a7:	f01d      	retw.n
403794a9:	000000        	ill

403794ac <esp_cache_get_alignment>:

    return ret;
}

esp_err_t esp_cache_get_alignment(uint32_t heap_caps, size_t *out_alignment)
{
403794ac:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(out_alignment, ESP_ERR_INVALID_ARG, TAG, "null pointer");
403794af:	022356        	bnez	a3, 403794d5 <esp_cache_get_alignment+0x29>
403794b2:	0677e5        	call8	4037fc30 <esp_log_timestamp>
403794b5:	ed7bb1        	l32r	a11, 40374aa4 <_iram_text_start+0x6a0> (3fc93b94 <__FUNCTION__$0+0x2dc>)
403794b8:	0fa182        	movi	a8, 0x10f
403794bb:	0189      	s32i.n	a8, a1, 0
403794bd:	ed78f1        	l32r	a15, 40374aa0 <_iram_text_start+0x69c> (3fc938b8 <__FUNCTION__$0>)
403794c0:	0bed      	mov.n	a14, a11
403794c2:	0add      	mov.n	a13, a10
403794c4:	ed79c1        	l32r	a12, 40374aa8 <_iram_text_start+0x6a4> (3fc93b9c <__FUNCTION__$0+0x2e4>)
403794c7:	1a0c      	movi.n	a10, 1
403794c9:	067ae5        	call8	4037fc78 <esp_log_write>
403794cc:	02a122        	movi	a2, 0x102
403794cf:	000646        	j	403794ec <esp_cache_get_alignment+0x40>
403794d2:	000000        	ill

    uint32_t cache_level = CACHE_LL_LEVEL_INT_MEM;
    uint32_t data_cache_line_size = 0;

    if (heap_caps & MALLOC_CAP_SPIRAM) {
403794d5:	00a482        	movi	a8, 0x400
403794d8:	10a280        	and	a10, a2, a8
403794db:	020287        	bnone	a2, a8, 403794e1 <esp_cache_get_alignment+0x35>
        cache_level = CACHE_LL_LEVEL_EXT_MEM;
403794de:	01a0a2        	movi	a10, 1
    }

    data_cache_line_size = cache_hal_get_cache_line_size(cache_level, CACHE_TYPE_DATA);
403794e1:	00a0b2        	movi	a11, 0
403794e4:	037425        	call8	4037cc28 <cache_hal_get_cache_line_size>

    *out_alignment = data_cache_line_size;
403794e7:	0063a2        	s32i	a10, a3, 0

    return ESP_OK;
403794ea:	020c      	movi.n	a2, 0
}
403794ec:	f01d      	retw.n
	...

403794f0 <xRingbufferGetCurFreeSize>:
    configASSERT(pxRingbuffer);
    return pxRingbuffer->xMaxItemSize;
}

size_t xRingbufferGetCurFreeSize(RingbufHandle_t xRingbuffer)
{
403794f0:	004136        	entry	a1, 32
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
403794f3:	00e256        	bnez	a2, 40379505 <xRingbufferGetCurFreeSize+0x15>
403794f6:	ed6dd1        	l32r	a13, 40374aac <_iram_text_start+0x6a8> (3c026e88 <_flash_rodata_start+0x6d68>)
403794f9:	ed6dc1        	l32r	a12, 40374ab0 <_iram_text_start+0x6ac> (3c029358 <__func__$7>)
403794fc:	f3a4b2        	movi	a11, 0x4f3
403794ff:	ed6da1        	l32r	a10, 40374ab4 <_iram_text_start+0x6b0> (3c026e51 <_flash_rodata_start+0x6d31>)
40379502:	0689e5        	call8	4037fda0 <__assert_func>

    size_t xFreeSize;
    portENTER_CRITICAL(&pxRingbuffer->mux);
40379505:	68c272        	addi	a7, a2, 104
40379508:	fb7c      	movi.n	a11, -1
4037950a:	20a770        	or	a10, a7, a7
4037950d:	00c225        	call8	4037a130 <xPortEnterCriticalTimeout>
    xFreeSize = pxRingbuffer->xGetCurMaxSize(pxRingbuffer);
40379510:	7288      	l32i.n	a8, a2, 28
40379512:	02ad      	mov.n	a10, a2
40379514:	0008e0        	callx8	a8
40379517:	0a2d      	mov.n	a2, a10
    portEXIT_CRITICAL(&pxRingbuffer->mux);
40379519:	07ad      	mov.n	a10, a7
4037951b:	00d665        	call8	4037a280 <vPortExitCritical>
    return xFreeSize;
}
4037951e:	f01d      	retw.n

40379520 <vRingbufferGetInfo>:
                        UBaseType_t *uxFree,
                        UBaseType_t *uxRead,
                        UBaseType_t *uxWrite,
                        UBaseType_t *uxAcquire,
                        UBaseType_t *uxItemsWaiting)
{
40379520:	006136        	entry	a1, 48
40379523:	1179      	s32i.n	a7, a1, 4
40379525:	0179      	s32i.n	a7, a1, 0
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379527:	00e256        	bnez	a2, 40379539 <vRingbufferGetInfo+0x19>
4037952a:	ed60d1        	l32r	a13, 40374aac <_iram_text_start+0x6a8> (3c026e88 <_flash_rodata_start+0x6d68>)
4037952d:	ed62c1        	l32r	a12, 40374ab8 <_iram_text_start+0x6b4> (3c029344 <__func__$4>)
40379530:	34a5b2        	movi	a11, 0x534
40379533:	ed60a1        	l32r	a10, 40374ab4 <_iram_text_start+0x6b0> (3c026e51 <_flash_rodata_start+0x6d31>)
40379536:	0686a5        	call8	4037fda0 <__assert_func>

    portENTER_CRITICAL(&pxRingbuffer->mux);
40379539:	68c272        	addi	a7, a2, 104
4037953c:	fb7c      	movi.n	a11, -1
4037953e:	07ad      	mov.n	a10, a7
40379540:	00bee5        	call8	4037a130 <xPortEnterCriticalTimeout>
    if (uxFree != NULL) {
40379543:	738c      	beqz.n	a3, 4037954e <vRingbufferGetInfo+0x2e>
        *uxFree = (UBaseType_t)(pxRingbuffer->pucFree - pxRingbuffer->pucHead);
40379545:	b288      	l32i.n	a8, a2, 44
40379547:	c298      	l32i.n	a9, a2, 48
40379549:	c08890        	sub	a8, a8, a9
4037954c:	0389      	s32i.n	a8, a3, 0
    }
    if (uxRead != NULL) {
4037954e:	848c      	beqz.n	a4, 4037955a <vRingbufferGetInfo+0x3a>
        *uxRead = (UBaseType_t)(pxRingbuffer->pucRead - pxRingbuffer->pucHead);
40379550:	a288      	l32i.n	a8, a2, 40
40379552:	c298      	l32i.n	a9, a2, 48
40379554:	c08890        	sub	a8, a8, a9
40379557:	006482        	s32i	a8, a4, 0
    }
    if (uxWrite != NULL) {
4037955a:	858c      	beqz.n	a5, 40379566 <vRingbufferGetInfo+0x46>
        *uxWrite = (UBaseType_t)(pxRingbuffer->pucWrite - pxRingbuffer->pucHead);
4037955c:	9288      	l32i.n	a8, a2, 36
4037955e:	c298      	l32i.n	a9, a2, 48
40379560:	c08890        	sub	a8, a8, a9
40379563:	006582        	s32i	a8, a5, 0
    }
    if (uxAcquire != NULL) {
40379566:	868c      	beqz.n	a6, 40379572 <vRingbufferGetInfo+0x52>
        *uxAcquire = (UBaseType_t)(pxRingbuffer->pucAcquire - pxRingbuffer->pucHead);
40379568:	8288      	l32i.n	a8, a2, 32
4037956a:	c298      	l32i.n	a9, a2, 48
4037956c:	c08890        	sub	a8, a8, a9
4037956f:	006682        	s32i	a8, a6, 0
    }
    if (uxItemsWaiting != NULL) {
40379572:	0188      	l32i.n	a8, a1, 0
40379574:	488c      	beqz.n	a8, 4037957c <vRingbufferGetInfo+0x5c>
        *uxItemsWaiting = (UBaseType_t)(pxRingbuffer->xItemsWaiting);
40379576:	e288      	l32i.n	a8, a2, 56
40379578:	1198      	l32i.n	a9, a1, 4
4037957a:	0989      	s32i.n	a8, a9, 0
    }
    portEXIT_CRITICAL(&pxRingbuffer->mux);
4037957c:	07ad      	mov.n	a10, a7
4037957e:	00d025        	call8	4037a280 <vPortExitCritical>
}
40379581:	f01d      	retw.n
	...

40379584 <Cache_Suspend_ICache>:
    }
}
// renamed for patch
extern uint32_t rom_Cache_Suspend_ICache(void);
uint32_t Cache_Suspend_ICache(void)
{
40379584:	004136        	entry	a1, 32
    uint32_t ret = rom_Cache_Suspend_ICache();
40379587:	ed4e81        	l32r	a8, 40374ac0 <_iram_text_start+0x6bc> (4000189c <rom_Cache_Suspend_ICache>)
4037958a:	0008e0        	callx8	a8
4037958d:	202aa0        	or	a2, a10, a10
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_ICACHE_STATE) != 1) {
40379590:	ed4b81        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
40379593:	0020c0        	memw
40379596:	0888      	l32i.n	a8, a8, 0
40379598:	b48080        	extui	a8, a8, 0, 12
4037959b:	f11866        	bnei	a8, 1, 40379590 <Cache_Suspend_ICache+0xc>
    Cache_Wait_Idle(1);
    return ret;
}
4037959e:	f01d      	retw.n

403795a0 <Cache_Suspend_DCache>:
extern uint32_t Cache_Suspend_ICache(void);

// renamed for patch
extern uint32_t rom_Cache_Suspend_DCache(void);
uint32_t Cache_Suspend_DCache(void)
{
403795a0:	004136        	entry	a1, 32
    uint32_t ret = rom_Cache_Suspend_DCache();
403795a3:	ed4881        	l32r	a8, 40374ac4 <_iram_text_start+0x6c0> (400018b4 <rom_Cache_Suspend_DCache>)
403795a6:	0008e0        	callx8	a8
403795a9:	202aa0        	or	a2, a10, a10
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_DCACHE_STATE) != 1) {
403795ac:	ed4481        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
403795af:	0020c0        	memw
403795b2:	0888      	l32i.n	a8, a8, 0
403795b4:	b48c80        	extui	a8, a8, 12, 12
403795b7:	118840        	slli	a8, a8, 12
403795ba:	ec2d91        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
403795bd:	eb9897        	bne	a8, a9, 403795ac <Cache_Suspend_DCache+0xc>
    Cache_Wait_Idle(0);
    return ret;
}
403795c0:	f01d      	retw.n
	...

403795c4 <Cache_Freeze_ICache_Enable>:

#if SOC_CACHE_FREEZE_SUPPORTED
// renamed for patch
extern void rom_Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode);
void Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode)
{
403795c4:	004136        	entry	a1, 32
403795c7:	20a220        	or	a10, a2, a2
    rom_Cache_Freeze_ICache_Enable(mode);
403795ca:	ed3f81        	l32r	a8, 40374ac8 <_iram_text_start+0x6c4> (400018e4 <rom_Cache_Freeze_ICache_Enable>)
403795cd:	0008e0        	callx8	a8
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_ICACHE_STATE) != 1) {
403795d0:	ed3b81        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
403795d3:	0020c0        	memw
403795d6:	0888      	l32i.n	a8, a8, 0
403795d8:	b48080        	extui	a8, a8, 0, 12
403795db:	f11866        	bnei	a8, 1, 403795d0 <Cache_Freeze_ICache_Enable+0xc>
    Cache_Wait_Idle(1);
}
403795de:	f01d      	retw.n

403795e0 <Cache_Freeze_DCache_Enable>:
extern void Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode);

// renamed for patch
extern void rom_Cache_Freeze_DCache_Enable(cache_freeze_mode_t mode);
void Cache_Freeze_DCache_Enable(cache_freeze_mode_t mode)
{
403795e0:	004136        	entry	a1, 32
403795e3:	20a220        	or	a10, a2, a2
    rom_Cache_Freeze_DCache_Enable(mode);
403795e6:	ed3981        	l32r	a8, 40374acc <_iram_text_start+0x6c8> (400018fc <rom_Cache_Freeze_DCache_Enable>)
403795e9:	0008e0        	callx8	a8
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_DCACHE_STATE) != 1) {
403795ec:	ed3481        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
403795ef:	0020c0        	memw
403795f2:	0888      	l32i.n	a8, a8, 0
403795f4:	b48c80        	extui	a8, a8, 12, 12
403795f7:	118840        	slli	a8, a8, 12
403795fa:	ec1d91        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
403795fd:	eb9897        	bne	a8, a9, 403795ec <Cache_Freeze_DCache_Enable+0xc>
    Cache_Wait_Idle(0);
}
40379600:	f01d      	retw.n
	...

40379604 <esp_rom_opiflash_cache_mode_config>:
}

#elif CONFIG_IDF_TARGET_ESP32S3
extern void esp_rom_spi_set_address_bit_len(int spi, int addr_bits);
void esp_rom_opiflash_cache_mode_config(esp_rom_spiflash_read_mode_t mode, const esp_rom_opiflash_spi0rd_t *cache)
{
40379604:	004136        	entry	a1, 32
40379607:	02bd      	mov.n	a11, a2
    esp_rom_spi_set_op_mode(0, mode);
40379609:	0a0c      	movi.n	a10, 0
4037960b:	ed3681        	l32r	a8, 40374ae4 <_iram_text_start+0x6e0> (400008a0 <esp_rom_spi_set_op_mode>)
4037960e:	0008e0        	callx8	a8
    REG_CLR_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_MOSI);
40379611:	ed2f81        	l32r	a8, 40374ad0 <_iram_text_start+0x6cc> (60003018 <SPIMEM0+0x18>)
40379614:	0020c0        	memw
40379617:	0898      	l32i.n	a9, a8, 0
40379619:	ec77a1        	l32r	a10, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037961c:	1099a0        	and	a9, a9, a10
4037961f:	0020c0        	memw
40379622:	0899      	s32i.n	a9, a8, 0
    REG_SET_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_MISO | SPI_MEM_USR_ADDR);
40379624:	0020c0        	memw
40379627:	0898      	l32i.n	a9, a8, 0
40379629:	ed2aa1        	l32r	a10, 40374ad4 <_iram_text_start+0x6d0> (50000000 <_coredump_rtc_end>)
4037962c:	2099a0        	or	a9, a9, a10
4037962f:	0020c0        	memw
40379632:	006892        	s32i	a9, a8, 0

    if (cache) {
40379635:	0b5316        	beqz	a3, 403796ee <esp_rom_opiflash_cache_mode_config+0xea>
        esp_rom_spi_set_address_bit_len(0, cache->addr_bit_len);
40379638:	0003b2        	l8ui	a11, a3, 0
4037963b:	00a0a2        	movi	a10, 0
4037963e:	ed2a81        	l32r	a8, 40374ae8 <_iram_text_start+0x6e4> (40000c60 <esp_rom_spi_set_address_bit_len>)
40379641:	0008e0        	callx8	a8
        // Patch for ROM function `esp_rom_opiflash_cache_mode_config`, because when dummy is 0,
        // `SPI_MEM_USR_DUMMY` should be 0. `esp_rom_opiflash_cache_mode_config` doesn't handle this
        // properly.
        if (cache->dummy_bit_len == 0) {
40379644:	010382        	l8ui	a8, a3, 1
40379647:	58dc      	bnez.n	a8, 40379660 <esp_rom_opiflash_cache_mode_config+0x5c>
            REG_CLR_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_DUMMY);
40379649:	ed2191        	l32r	a9, 40374ad0 <_iram_text_start+0x6cc> (60003018 <SPIMEM0+0x18>)
4037964c:	0020c0        	memw
4037964f:	0988      	l32i.n	a8, a9, 0
40379651:	ec68a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
40379654:	1088a0        	and	a8, a8, a10
40379657:	0020c0        	memw
4037965a:	0989      	s32i.n	a8, a9, 0
4037965c:	000ec6        	j	4037969b <esp_rom_opiflash_cache_mode_config+0x97>
4037965f:	1c9100        	lsi	f0, a1, 112
        } else {
            REG_SET_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_DUMMY);
40379662:	c0ed      	lsi	f14, a0, 0
40379664:	880020        	lsi	f2, a0, 0x220
40379667:	a109      	s32i.n	a0, a1, 40
40379669:	ecdc      	bnez.n	a12, 4037968b <esp_rom_opiflash_cache_mode_config+0x87>
4037966b:	2088a0        	or	a8, a8, a10
4037966e:	0020c0        	memw
40379671:	0989      	s32i.n	a8, a9, 0
            REG_SET_FIELD(SPI_MEM_USER1_REG(0), SPI_MEM_USR_DUMMY_CYCLELEN, cache->dummy_bit_len - 1 + rom_spiflash_legacy_data->dummy_len_plus[0]);
40379673:	ed19a1        	l32r	a10, 40374ad8 <_iram_text_start+0x6d4> (6000301c <SPIMEM0+0x1c>)
40379676:	0020c0        	memw
40379679:	0a88      	l32i.n	a8, a10, 0
4037967b:	c0af92        	movi	a9, -64
4037967e:	109890        	and	a9, a8, a9
40379681:	010382        	l8ui	a8, a3, 1
40379684:	880b      	addi.n	a8, a8, -1
40379686:	ec5ab1        	l32r	a11, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40379689:	0bb8      	l32i.n	a11, a11, 0
4037968b:	180bb2        	l8ui	a11, a11, 24
4037968e:	88ba      	add.n	a8, a8, a11
40379690:	548080        	extui	a8, a8, 0, 6
40379693:	208980        	or	a8, a9, a8
40379696:	0020c0        	memw
40379699:	0a89      	s32i.n	a8, a10, 0
        }
        REG_SET_FIELD(SPI_MEM_USER2_REG(0), SPI_MEM_USR_COMMAND_VALUE, cache->cmd);
4037969b:	ed10a1        	l32r	a10, 40374adc <_iram_text_start+0x6d8> (60003020 <SPIMEM0+0x20>)
4037969e:	0020c0        	memw
403796a1:	0a88      	l32i.n	a8, a10, 0
403796a3:	f58080        	extui	a8, a8, 16, 16
403796a6:	118800        	slli	a8, a8, 16
403796a9:	011392        	l16ui	a9, a3, 2
403796ac:	208890        	or	a8, a8, a9
403796af:	0020c0        	memw
403796b2:	0a89      	s32i.n	a8, a10, 0
        REG_SET_FIELD(SPI_MEM_USER2_REG(0), SPI_MEM_USR_COMMAND_BITLEN, cache->cmd_bit_len - 1);
403796b4:	0020c0        	memw
403796b7:	0a88      	l32i.n	a8, a10, 0
403796b9:	1188c0        	slli	a8, a8, 4
403796bc:	418480        	srli	a8, a8, 4
403796bf:	040392        	l8ui	a9, a3, 4
403796c2:	990b      	addi.n	a9, a9, -1
403796c4:	019940        	slli	a9, a9, 28
403796c7:	208890        	or	a8, a8, a9
403796ca:	0020c0        	memw
403796cd:	0a89      	s32i.n	a8, a10, 0
        REG_SET_FIELD(SPI_MEM_DDR_REG(0), SPI_MEM_SPI_FMEM_VAR_DUMMY, cache->var_dummy_en);
403796cf:	ed04a1        	l32r	a10, 40374ae0 <_iram_text_start+0x6dc> (600030e0 <SPIMEM0+0xe0>)
403796d2:	0020c0        	memw
403796d5:	0a88      	l32i.n	a8, a10, 0
403796d7:	d97c      	movi.n	a9, -3
403796d9:	109890        	and	a9, a8, a9
403796dc:	050382        	l8ui	a8, a3, 5
403796df:	888a      	add.n	a8, a8, a8
403796e1:	2b0c      	movi.n	a11, 2
403796e3:	1088b0        	and	a8, a8, a11
403796e6:	208980        	or	a8, a9, a8
403796e9:	0020c0        	memw
403796ec:	0a89      	s32i.n	a8, a10, 0
    }
}
403796ee:	f01d      	retw.n

403796f0 <esp_rom_install_uart_printf>:
    }
}

#if ESP_ROM_HAS_ETS_PRINTF_BUG
void esp_rom_install_uart_printf(void)
{
403796f0:	004136        	entry	a1, 32
#if !ESP_ROM_HAS_OUTPUT_TO_CHANNELS_FUNC
    _putc1 = esp_rom_output_putc;
403796f3:	ecfe81        	l32r	a8, 40374aec <_iram_text_start+0x6e8> (3fc92034 <_putc1>)
403796f6:	ecfe91        	l32r	a9, 40374af0 <_iram_text_start+0x6ec> (400006b4 <esp_rom_output_putc>)
403796f9:	0899      	s32i.n	a9, a8, 0
    extern void ets_install_uart_printf(void);
    extern bool g_uart_print;
    extern bool g_usb_print;
    // If ROM log is disabled permanently via eFuse or temporarily via RTC storage register,
    // this ROM symbol will be set to false, and cause ``esp_rom_printf`` can't work on esp-idf side.
    g_uart_print = true;
403796fb:	01a082        	movi	a8, 1
403796fe:	ecfd91        	l32r	a9, 40374af4 <_iram_text_start+0x6f0> (3fceffb9 <g_uart_print>)
40379701:	004982        	s8i	a8, a9, 0
    g_usb_print = true;
40379704:	ecfd91        	l32r	a9, 40374af8 <_iram_text_start+0x6f4> (3fceffb8 <g_usb_print>)
40379707:	004982        	s8i	a8, a9, 0
    ets_install_uart_printf();
4037970a:	ecfc81        	l32r	a8, 40374afc <_iram_text_start+0x6f8> (400005e8 <ets_install_uart_printf>)
4037970d:	0008e0        	callx8	a8
#endif // !CONFIG_IDF_TARGET_LINUX
}
40379710:	f01d      	retw.n
	...

40379714 <esp_error_check_failed_print>:
    return return_address;
}
#endif

static void esp_error_check_failed_print(const char *msg, esp_err_t rc, const char *file, int line, const char *function, const char *expression, intptr_t addr)
{
40379714:	004136        	entry	a1, 32
40379717:	02bd      	mov.n	a11, a2
    esp_rom_printf("%s failed: esp_err_t 0x%x", msg, rc);
40379719:	03cd      	mov.n	a12, a3
4037971b:	ecf9a1        	l32r	a10, 40374b00 <_iram_text_start+0x6fc> (3fc93ee8 <__FUNCTION__$0+0x630>)
4037971e:	eb6581        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40379721:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" (%s)", esp_err_to_name(rc));
40379724:	20a330        	or	a10, a3, a3
40379727:	eb6d81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (420028c4 <esp_err_to_name>)
4037972a:	0008e0        	callx8	a8
4037972d:	20baa0        	or	a11, a10, a10
40379730:	ecf5a1        	l32r	a10, 40374b04 <_iram_text_start+0x700> (3fc93f04 <__FUNCTION__$0+0x64c>)
40379733:	eb6081        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40379736:	0008e0        	callx8	a8
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" at 0x%08x\n", esp_cpu_get_call_addr(addr));
40379739:	81b8      	l32i.n	a11, a1, 32
4037973b:	fdcbb2        	addi	a11, a11, -3
4037973e:	ecf2a1        	l32r	a10, 40374b08 <_iram_text_start+0x704> (3fc93f0c <__FUNCTION__$0+0x654>)
40379741:	eb5c81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40379744:	0008e0        	callx8	a8
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    if (spi_flash_cache_enabled())  // strings may be in flash cache
40379747:	fe3165        	call8	40377a5c <spi_flash_cache_enabled>
4037974a:	fa8c      	beqz.n	a10, 4037975d <esp_error_check_failed_print+0x49>
#endif
    {
        esp_rom_printf("file: \"%s\" line %d\nfunc: %s\nexpression: %s\n", file, line, function, expression);
4037974c:	07ed      	mov.n	a14, a7
4037974e:	06dd      	mov.n	a13, a6
40379750:	05cd      	mov.n	a12, a5
40379752:	04bd      	mov.n	a11, a4
40379754:	eceea1        	l32r	a10, 40374b0c <_iram_text_start+0x708> (3fc93f18 <__FUNCTION__$0+0x660>)
40379757:	eb5781        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4037975a:	0008e0        	callx8	a8
    }
}
4037975d:	f01d      	retw.n
	...

40379760 <_esp_error_check_failed>:
{
    esp_error_check_failed_print("ESP_ERROR_CHECK_WITHOUT_ABORT", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
}

void _esp_error_check_failed(esp_err_t rc, const char *file, int line, const char *function, const char *expression)
{
40379760:	006136        	entry	a1, 48
40379763:	02bd      	mov.n	a11, a2
40379765:	03cd      	mov.n	a12, a3
40379767:	04dd      	mov.n	a13, a4
40379769:	05ed      	mov.n	a14, a5
4037976b:	06fd      	mov.n	a15, a6
    esp_error_check_failed_print("ESP_ERROR_CHECK", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
4037976d:	ece891        	l32r	a9, 40374b10 <_iram_text_start+0x70c> (4037976d <_esp_error_check_failed+0xd>)
40379770:	159e90        	extui	a9, a9, 30, 2
40379773:	019920        	slli	a9, a9, 30
40379776:	1180e0        	slli	a8, a0, 2
40379779:	418280        	srli	a8, a8, 2
4037977c:	208890        	or	a8, a8, a9
4037977f:	0189      	s32i.n	a8, a1, 0
40379781:	ece4a1        	l32r	a10, 40374b14 <_iram_text_start+0x710> (3fc93f44 <__FUNCTION__$0+0x68c>)
40379784:	fff8e5        	call8	40379714 <esp_error_check_failed_print>
    abort();
40379787:	0655e5        	call8	4037fce4 <abort>
	...

4037978c <esp_system_abort>:
{
    return IDF_VER;
}

void __attribute__((noreturn)) esp_system_abort(const char *details)
{
4037978c:	004136        	entry	a1, 32
4037978f:	02ad      	mov.n	a10, a2
    panic_abort(details);
40379791:	fc1c65        	call8	40375958 <panic_abort>

40379794 <__ubsan_include>:
    __ubsan_default_handler(&data->loc, __func__);
}

/* Hook for the linker to include this object file */
void __ubsan_include(void)
{
40379794:	004136        	entry	a1, 32
}
40379797:	f01d      	retw.n
40379799:	000000        	ill

4037979c <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
4037979c:	004136        	entry	a1, 32
4037979f:	207220        	or	a7, a2, a2
403797a2:	20b330        	or	a11, a3, a3
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
403797a5:	0020c0        	memw
403797a8:	0e2262        	l32i	a6, a2, 56

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
403797ab:	1022c2        	l32i	a12, a2, 64
403797ae:	2cdc      	bnez.n	a12, 403797c4 <prvCopyDataToQueue+0x28>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
403797b0:	0288      	l32i.n	a8, a2, 0
403797b2:	05b856        	bnez	a8, 40379811 <prvCopyDataToQueue+0x75>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
403797b5:	22a8      	l32i.n	a10, a2, 8
403797b7:	026fa5        	call8	4037beb0 <xTaskPriorityDisinherit>
403797ba:	0a2d      	mov.n	a2, a10
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
403797bc:	080c      	movi.n	a8, 0
403797be:	2789      	s32i.n	a8, a7, 8
403797c0:	0017c6        	j	40379823 <prvCopyDataToQueue+0x87>
403797c3:	d4dc00        	extui	a13, a0, 12, 14
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
403797c6:	12a8      	l32i.n	a10, a2, 4
403797c8:	eb4381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403797cb:	0008e0        	callx8	a8
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
403797ce:	1288      	l32i.n	a8, a2, 4
403797d0:	102292        	l32i	a9, a2, 64
403797d3:	889a      	add.n	a8, a8, a9
403797d5:	1289      	s32i.n	a8, a2, 4

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
403797d7:	2298      	l32i.n	a9, a2, 8
403797d9:	393897        	bltu	a8, a9, 40379816 <prvCopyDataToQueue+0x7a>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
403797dc:	0288      	l32i.n	a8, a2, 0
403797de:	1289      	s32i.n	a8, a2, 4
    BaseType_t xReturn = pdFALSE;
403797e0:	042d      	mov.n	a2, a4
403797e2:	000f46        	j	40379823 <prvCopyDataToQueue+0x87>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
403797e5:	32a8      	l32i.n	a10, a2, 12
403797e7:	eb3b81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403797ea:	0008e0        	callx8	a8
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
403797ed:	3288      	l32i.n	a8, a2, 12
403797ef:	102292        	l32i	a9, a2, 64
403797f2:	60a090        	neg	a10, a9
403797f5:	c08890        	sub	a8, a8, a9
403797f8:	3289      	s32i.n	a8, a2, 12

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
403797fa:	0298      	l32i.n	a9, a2, 0
403797fc:	05b897        	bgeu	a8, a9, 40379805 <prvCopyDataToQueue+0x69>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
403797ff:	2288      	l32i.n	a8, a2, 8
40379801:	88aa      	add.n	a8, a8, a10
40379803:	3289      	s32i.n	a8, a2, 12
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
40379805:	132466        	bnei	a4, 2, 4037981c <prvCopyDataToQueue+0x80>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
40379808:	569c      	beqz.n	a6, 40379821 <prvCopyDataToQueue+0x85>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
4037980a:	660b      	addi.n	a6, a6, -1
    BaseType_t xReturn = pdFALSE;
4037980c:	020c      	movi.n	a2, 0
4037980e:	000446        	j	40379823 <prvCopyDataToQueue+0x87>
40379811:	020c      	movi.n	a2, 0
40379813:	000306        	j	40379823 <prvCopyDataToQueue+0x87>
40379816:	042d      	mov.n	a2, a4
40379818:	0001c6        	j	40379823 <prvCopyDataToQueue+0x87>
4037981b:	020c00        	andb	b0, b12, b0
4037981e:	000046        	j	40379823 <prvCopyDataToQueue+0x87>
40379821:	020c      	movi.n	a2, 0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
40379823:	661b      	addi.n	a6, a6, 1
40379825:	0020c0        	memw
40379828:	e769      	s32i.n	a6, a7, 56

    return xReturn;
}
4037982a:	f01d      	retw.n

4037982c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
4037982c:	004136        	entry	a1, 32
4037982f:	03ad      	mov.n	a10, a3
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
40379831:	1022c2        	l32i	a12, a2, 64
40379834:	5c9c      	beqz.n	a12, 4037984d <prvCopyDataFromQueue+0x21>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
40379836:	3288      	l32i.n	a8, a2, 12
40379838:	88ca      	add.n	a8, a8, a12
4037983a:	3289      	s32i.n	a8, a2, 12

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
4037983c:	2298      	l32i.n	a9, a2, 8
4037983e:	033897        	bltu	a8, a9, 40379845 <prvCopyDataFromQueue+0x19>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
40379841:	0288      	l32i.n	a8, a2, 0
40379843:	3289      	s32i.n	a8, a2, 12
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
40379845:	32b8      	l32i.n	a11, a2, 12
40379847:	eb2381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037984a:	0008e0        	callx8	a8
    }
}
4037984d:	f01d      	retw.n
	...

40379850 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
40379850:	006136        	entry	a1, 48
40379853:	0129      	s32i.n	a2, a1, 0
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
40379855:	122272        	l32i	a7, a2, 72
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
40379858:	d7cc      	bnez.n	a7, 40379869 <prvNotifyQueueSetContainer+0x19>
4037985a:	ecafd1        	l32r	a13, 40374b18 <_iram_text_start+0x714> (3c024180 <_flash_rodata_start+0x4060>)
4037985d:	ecafc1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c028160 <__func__$13>)
40379860:	ecb0b1        	l32r	a11, 40374b20 <_iram_text_start+0x71c> (d21 <UserFrameTotalSize+0xc21>)
40379863:	ecb0a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379866:	0653a5        	call8	4037fda0 <__assert_func>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
40379869:	0020c0        	memw
4037986c:	e798      	l32i.n	a9, a7, 56
4037986e:	f788      	l32i.n	a8, a7, 60
40379870:	113987        	bltu	a9, a8, 40379885 <prvNotifyQueueSetContainer+0x35>
40379873:	ecadd1        	l32r	a13, 40374b28 <_iram_text_start+0x724> (3c0241c8 <_flash_rodata_start+0x40a8>)
40379876:	eca9c1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c028160 <__func__$13>)
40379879:	ecacb1        	l32r	a11, 40374b2c <_iram_text_start+0x728> (d22 <UserFrameTotalSize+0xc22>)
4037987c:	ecaaa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
4037987f:	201110        	or	a1, a1, a1
40379882:	0651e5        	call8	4037fda0 <__assert_func>

        /* In SMP, queue sets have their own xQueueLock. Thus we need to also
         * acquire the queue set's xQueueLock before accessing it. */
        prvENTER_CRITICAL_SAFE_SMP_ONLY( &( pxQueueSetContainer->xQueueLock ) );
40379885:	4cc762        	addi	a6, a7, 76
    #define prvEXIT_CRITICAL_SAFE_SMP_ONLY( pxLock )     prvTaskExitCriticalSafeSMPOnly( pxLock )

    static inline __attribute__( ( always_inline ) )
    void prvTaskEnterCriticalSafeSMPOnly( portMUX_TYPE * pxLock )
    {
        if( portCHECK_IF_IN_ISR() == pdFALSE )
40379888:	008825        	call8	4037a10c <xPortInIsrContext>
4037988b:	bacc      	bnez.n	a10, 4037989a <prvNotifyQueueSetContainer+0x4a>
4037988d:	ffafb2        	movi	a11, -1
40379890:	06ad      	mov.n	a10, a6
40379892:	0089e5        	call8	4037a130 <xPortEnterCriticalTimeout>
}
40379895:	000246        	j	403798a2 <prvNotifyQueueSetContainer+0x52>
40379898:	b20000        	mulsh	a0, a0, a0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037989b:	af          	.byte	0xaf
4037989c:	ff          	.byte	0xff
4037989d:	06ad      	mov.n	a10, a6
4037989f:	008925        	call8	4037a130 <xPortEnterCriticalTimeout>
        {
            if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
403798a2:	0020c0        	memw
403798a5:	e798      	l32i.n	a9, a7, 56
403798a7:	f788      	l32i.n	a8, a7, 60
403798a9:	1cb987        	bgeu	a9, a8, 403798c9 <prvNotifyQueueSetContainer+0x79>
                #endif /* queueUSE_LOCKS == 1 */

                traceQUEUE_SET_SEND( pxQueueSetContainer );

                /* The data copied is the handle of the queue that contains data. */
                xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
403798ac:	0c0c      	movi.n	a12, 0
403798ae:	01bd      	mov.n	a11, a1
403798b0:	07ad      	mov.n	a10, a7
403798b2:	ffeea5        	call8	4037979c <prvCopyDataToQueue>
403798b5:	0a2d      	mov.n	a2, a10

                if( cTxLock == queueUNLOCKED )
                {
                    if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
403798b7:	0020c0        	memw
403798ba:	9788      	l32i.n	a8, a7, 36
403798bc:	189c      	beqz.n	a8, 403798d1 <prvNotifyQueueSetContainer+0x81>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
403798be:	24c7a2        	addi	a10, a7, 36
403798c1:	01cfe5        	call8	4037b5c0 <xTaskRemoveFromEventList>
403798c4:	6acc      	bnez.n	a10, 403798ce <prvNotifyQueueSetContainer+0x7e>
403798c6:	0001c6        	j	403798d1 <prvNotifyQueueSetContainer+0x81>
        BaseType_t xReturn = pdFALSE;
403798c9:	020c      	movi.n	a2, 0
403798cb:	000086        	j	403798d1 <prvNotifyQueueSetContainer+0x81>
                        {
                            /* The task waiting has a higher priority. */
                            xReturn = pdTRUE;
403798ce:	01a022        	movi	a2, 1
    }

    static inline __attribute__( ( always_inline ) )
    void prvTaskExitCriticalSafeSMPOnly( portMUX_TYPE * pxLock )
    {
        if( portCHECK_IF_IN_ISR() == pdFALSE )
403798d1:	0083a5        	call8	4037a10c <xPortInIsrContext>
403798d4:	008a56        	bnez	a10, 403798e0 <prvNotifyQueueSetContainer+0x90>
        {
            taskEXIT_CRITICAL( pxLock );
403798d7:	06ad      	mov.n	a10, a6
403798d9:	009a65        	call8	4037a280 <vPortExitCritical>
403798dc:	000146        	j	403798e5 <prvNotifyQueueSetContainer+0x95>
403798df:	06ad00        	lsi	f0, a13, 24
        {
            #ifdef __clang_analyzer__
                /* Teach clang-tidy that ISR version macro can be different */
                configASSERT( 1 );
            #endif
            taskEXIT_CRITICAL_ISR( pxLock );
403798e2:	0099e5        	call8	4037a280 <vPortExitCritical>
        }
        /* Release the previously acquired queue set's xQueueLock. */
        prvEXIT_CRITICAL_SAFE_SMP_ONLY( &( pxQueueSetContainer->xQueueLock ) );

        return xReturn;
    }
403798e5:	f01d      	retw.n
	...

403798e8 <xQueueGenericReset>:
{
403798e8:	004136        	entry	a1, 32
    configASSERT( pxQueue );
403798eb:	00e256        	bnez	a2, 403798fd <xQueueGenericReset+0x15>
403798ee:	ec90d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
403798f1:	ec90c1        	l32r	a12, 40374b34 <_iram_text_start+0x730> (3c028224 <__func__$25>)
403798f4:	4da1b2        	movi	a11, 0x14d
403798f7:	ec8ba1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
403798fa:	064a65        	call8	4037fda0 <__assert_func>
    if( xNewQueue == pdTRUE )
403798fd:	101366        	bnei	a3, 1, 40379911 <xQueueGenericReset+0x29>
 */
static inline void __attribute__((always_inline)) spinlock_initialize(spinlock_t *lock)
{
    assert(lock);
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    lock->owner = SPINLOCK_FREE;
40379900:	ec8e81        	l32r	a8, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
40379903:	136282        	s32i	a8, a2, 76
    lock->count = 0;
40379906:	080c      	movi.n	a8, 0
40379908:	146282        	s32i	a8, a2, 80
    if( ( pxQueue != NULL ) &&
4037990b:	000146        	j	40379914 <xQueueGenericReset+0x2c>
4037990e:	000000        	ill
40379911:	06c216        	beqz	a2, 40379981 <xQueueGenericReset+0x99>
        ( pxQueue->uxLength >= 1U ) &&
40379914:	f288      	l32i.n	a8, a2, 60
    if( ( pxQueue != NULL ) &&
40379916:	067816        	beqz	a8, 40379981 <xQueueGenericReset+0x99>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
40379919:	1022a2        	l32i	a10, a2, 64
4037991c:	090c      	movi.n	a9, 0
4037991e:	a288a0        	muluh	a8, a8, a10
40379921:	088c      	beqz.n	a8, 40379925 <xQueueGenericReset+0x3d>
40379923:	190c      	movi.n	a9, 1
        ( pxQueue->uxLength >= 1U ) &&
40379925:	058956        	bnez	a9, 40379981 <xQueueGenericReset+0x99>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379928:	4cc272        	addi	a7, a2, 76
4037992b:	fb7c      	movi.n	a11, -1
4037992d:	07ad      	mov.n	a10, a7
4037992f:	008025        	call8	4037a130 <xPortEnterCriticalTimeout>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
40379932:	0288      	l32i.n	a8, a2, 0
40379934:	f2a8      	l32i.n	a10, a2, 60
40379936:	102292        	l32i	a9, a2, 64
40379939:	82ba90        	mull	a11, a10, a9
4037993c:	b8ba      	add.n	a11, a8, a11
4037993e:	22b9      	s32i.n	a11, a2, 8
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
40379940:	0b0c      	movi.n	a11, 0
40379942:	0020c0        	memw
40379945:	e2b9      	s32i.n	a11, a2, 56
            pxQueue->pcWriteTo = pxQueue->pcHead;
40379947:	1289      	s32i.n	a8, a2, 4
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
40379949:	aa0b      	addi.n	a10, a10, -1
4037994b:	8299a0        	mull	a9, a9, a10
4037994e:	889a      	add.n	a8, a8, a9
40379950:	3289      	s32i.n	a8, a2, 12
            if( xNewQueue == pdFALSE )
40379952:	a3dc      	bnez.n	a3, 40379970 <xQueueGenericReset+0x88>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379954:	0020c0        	memw
40379957:	4288      	l32i.n	a8, a2, 16
40379959:	033816        	beqz	a8, 40379990 <xQueueGenericReset+0xa8>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037995c:	10c2a2        	addi	a10, a2, 16
4037995f:	01c625        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379962:	aaac      	beqz.n	a10, 40379990 <xQueueGenericReset+0xa8>
    asm volatile (
40379964:	03eba0        	rsr.prid	a10
40379967:	04ada0        	extui	a10, a10, 13, 1
                        queueYIELD_IF_USING_PREEMPTION();
4037996a:	fe7625        	call8	403780cc <esp_crosscore_int_send_yield>
4037996d:	0007c6        	j	40379990 <xQueueGenericReset+0xa8>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
40379970:	10c2a2        	addi	a10, a2, 16
40379973:	00f5a5        	call8	4037a8cc <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
40379976:	24c2a2        	addi	a10, a2, 36
40379979:	00f525        	call8	4037a8cc <vListInitialise>
4037997c:	000406        	j	40379990 <xQueueGenericReset+0xa8>
4037997f:	d10000        	mul16s	a0, a0, a0
    configASSERT( xReturn != pdFAIL );
40379982:	6e          	.byte	0x6e
40379983:	c1ec      	bnez.n	a1, 403799b3 <prvInitialiseNewQueue+0x17>
40379985:	ec6c      	movi.n	a12, -18
40379987:	8ba1b2        	movi	a11, 0x18b
4037998a:	ec66a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
4037998d:	064125        	call8	4037fda0 <__assert_func>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379990:	20a770        	or	a10, a7, a7
40379993:	008ee5        	call8	4037a280 <vPortExitCritical>
}
40379996:	01a022        	movi	a2, 1
40379999:	f01d      	retw.n
	...

4037999c <prvInitialiseNewQueue>:
{
4037999c:	004136        	entry	a1, 32
    if( uxItemSize == ( UBaseType_t ) 0 )
4037999f:	33cc      	bnez.n	a3, 403799a6 <prvInitialiseNewQueue+0xa>
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
403799a1:	0669      	s32i.n	a6, a6, 0
403799a3:	000046        	j	403799a8 <prvInitialiseNewQueue+0xc>
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
403799a6:	0649      	s32i.n	a4, a6, 0
    pxNewQueue->uxLength = uxQueueLength;
403799a8:	f629      	s32i.n	a2, a6, 60
    pxNewQueue->uxItemSize = uxItemSize;
403799aa:	106632        	s32i	a3, a6, 64
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
403799ad:	1b0c      	movi.n	a11, 1
403799af:	06ad      	mov.n	a10, a6
403799b1:	fff365        	call8	403798e8 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
403799b4:	080c      	movi.n	a8, 0
403799b6:	126682        	s32i	a8, a6, 72
}
403799b9:	f01d      	retw.n
	...

403799bc <xQueueGenericCreateStatic>:
    {
403799bc:	006136        	entry	a1, 48
403799bf:	02ad      	mov.n	a10, a2
403799c1:	03bd      	mov.n	a11, a3
403799c3:	04cd      	mov.n	a12, a4
403799c5:	052d      	mov.n	a2, a5
403799c7:	74d060        	extui	a13, a6, 0, 8
        configASSERT( pxStaticQueue );
403799ca:	180c      	movi.n	a8, 1
403799cc:	838550        	moveqz	a8, a5, a5
403799cf:	d5cc      	bnez.n	a5, 403799e0 <xQueueGenericCreateStatic+0x24>
403799d1:	ec5bd1        	l32r	a13, 40374b40 <_iram_text_start+0x73c> (3c02423c <_flash_rodata_start+0x411c>)
403799d4:	ec5cc1        	l32r	a12, 40374b44 <_iram_text_start+0x740> (3c0281f4 <__func__$23>)
403799d7:	9fa1b2        	movi	a11, 0x19f
403799da:	ec52a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
403799dd:	063c25        	call8	4037fda0 <__assert_func>
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
403799e0:	01a092        	movi	a9, 1
403799e3:	839aa0        	moveqz	a9, a10, a10
403799e6:	400897        	bnone	a8, a9, 40379a2a <xQueueGenericCreateStatic+0x6e>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
403799e9:	40f480        	nsau	a8, a4
403799ec:	418580        	srli	a8, a8, 5
403799ef:	190c      	movi.n	a9, 1
403799f1:	839330        	moveqz	a9, a3, a3
403799f4:	208890        	or	a8, a8, a9
            ( pxStaticQueue != NULL ) &&
403799f7:	f8ac      	beqz.n	a8, 40379a2a <xQueueGenericCreateStatic+0x6e>
            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
403799f9:	180c      	movi.n	a8, 1
403799fb:	838440        	moveqz	a8, a4, a4
403799fe:	40f390        	nsau	a9, a3
40379a01:	419590        	srli	a9, a9, 5
40379a04:	208890        	or	a8, a8, a9
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
40379a07:	f89c      	beqz.n	a8, 40379a2a <xQueueGenericCreateStatic+0x6e>
                volatile size_t xSize = sizeof( StaticQueue_t );
40379a09:	485c      	movi.n	a8, 84
40379a0b:	0020c0        	memw
40379a0e:	0189      	s32i.n	a8, a1, 0
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
40379a10:	0020c0        	memw
40379a13:	002182        	l32i	a8, a1, 0
40379a16:	acc882        	addi	a8, a8, -84
40379a19:	c89c      	beqz.n	a8, 40379a39 <xQueueGenericCreateStatic+0x7d>
40379a1b:	ec4bd1        	l32r	a13, 40374b48 <_iram_text_start+0x744> (3c02424c <_flash_rodata_start+0x412c>)
40379a1e:	ec49c1        	l32r	a12, 40374b44 <_iram_text_start+0x740> (3c0281f4 <__func__$23>)
40379a21:	b1a1b2        	movi	a11, 0x1b1
40379a24:	ec40a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379a27:	0637a5        	call8	4037fda0 <__assert_func>
            configASSERT( pxNewQueue );
40379a2a:	ec48d1        	l32r	a13, 40374b4c <_iram_text_start+0x748> (3c024268 <_flash_rodata_start+0x4148>)
40379a2d:	ec45c1        	l32r	a12, 40374b44 <_iram_text_start+0x740> (3c0281f4 <__func__$23>)
40379a30:	c8a1b2        	movi	a11, 0x1c8
40379a33:	ec3ca1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379a36:	0636a5        	call8	4037fda0 <__assert_func>
                ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
40379a39:	0020c0        	memw
40379a3c:	0188      	l32i.n	a8, a1, 0
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
40379a3e:	180c      	movi.n	a8, 1
40379a40:	444582        	s8i	a8, a5, 68
            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
40379a43:	05ed      	mov.n	a14, a5
40379a45:	fff565        	call8	4037999c <prvInitialiseNewQueue>
    }
40379a48:	f01d      	retw.n
	...

40379a4c <xQueueGenericCreate>:
    {
40379a4c:	004136        	entry	a1, 32
40379a4f:	027d      	mov.n	a7, a2
40379a51:	744040        	extui	a4, a4, 0, 8
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
40379a54:	42bc      	beqz.n	a2, 40379a8c <xQueueGenericCreate+0x40>
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
40379a56:	080c      	movi.n	a8, 0
40379a58:	a29230        	muluh	a9, a2, a3
40379a5b:	001916        	beqz	a9, 40379a60 <xQueueGenericCreate+0x14>
40379a5e:	180c      	movi.n	a8, 1
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
40379a60:	88ec      	bnez.n	a8, 40379a8c <xQueueGenericCreate+0x40>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
40379a62:	82a730        	mull	a10, a7, a3
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
40379a65:	abaf82        	movi	a8, -85
40379a68:	2038a7        	bltu	a8, a10, 40379a8c <xQueueGenericCreate+0x40>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
40379a6b:	54caa2        	addi	a10, a10, 84
40379a6e:	00b265        	call8	4037a594 <pvPortMalloc>
40379a71:	0a2d      	mov.n	a2, a10
            if( pxNewQueue != NULL )
40379a73:	7aac      	beqz.n	a10, 40379a9e <xQueueGenericCreate+0x52>
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
40379a75:	080c      	movi.n	a8, 0
40379a77:	444a82        	s8i	a8, a10, 68
                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
40379a7a:	0aed      	mov.n	a14, a10
40379a7c:	04dd      	mov.n	a13, a4
40379a7e:	54cac2        	addi	a12, a10, 84
40379a81:	03bd      	mov.n	a11, a3
40379a83:	07ad      	mov.n	a10, a7
40379a85:	fff165        	call8	4037999c <prvInitialiseNewQueue>
40379a88:	000486        	j	40379a9e <xQueueGenericCreate+0x52>
40379a8b:	30d100        	xor	a13, a1, a0
            configASSERT( pxNewQueue );
40379a8e:	c1ec      	bnez.n	a1, 40379abe <xQueueGetMutexHolder+0x1e>
40379a90:	b2ec30        	mulsh	a14, a12, a3
40379a93:	a13da2        	lsi	f10, a13, 0x284
40379a96:	10ec23        	lsi	f2, a12, 64
40379a99:	652011        	l32r	a1, 40352f1c <rom_rx_gain_force+0x34caf0>
40379a9c:	1d0630        	lsi	f3, a6, 116
    }
40379a9f:	f0          	.byte	0xf0

40379aa0 <xQueueGetMutexHolder>:
    {
40379aa0:	004136        	entry	a1, 32
        configASSERT( xSemaphore );
40379aa3:	00e256        	bnez	a2, 40379ab5 <xQueueGetMutexHolder+0x15>
40379aa6:	ec2bd1        	l32r	a13, 40374b54 <_iram_text_start+0x750> (3c024274 <_flash_rodata_start+0x4154>)
40379aa9:	ec2bc1        	l32r	a12, 40374b58 <_iram_text_start+0x754> (3c0281c8 <__func__$20>)
40379aac:	c2a2b2        	movi	a11, 0x2c2
40379aaf:	ec1da1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ab2:	062ee5        	call8	4037fda0 <__assert_func>
        taskENTER_CRITICAL( &( pxSemaphore->xQueueLock ) );
40379ab5:	4cc272        	addi	a7, a2, 76
40379ab8:	fb7c      	movi.n	a11, -1
40379aba:	20a770        	or	a10, a7, a7
40379abd:	006725        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
40379ac0:	002282        	l32i	a8, a2, 0
40379ac3:	38cc      	bnez.n	a8, 40379aca <xQueueGetMutexHolder+0x2a>
                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
40379ac5:	2228      	l32i.n	a2, a2, 8
40379ac7:	000086        	j	40379acd <xQueueGetMutexHolder+0x2d>
                pxReturn = NULL;
40379aca:	00a022        	movi	a2, 0
        taskEXIT_CRITICAL( &( pxSemaphore->xQueueLock ) );
40379acd:	20a770        	or	a10, a7, a7
40379ad0:	007ae5        	call8	4037a280 <vPortExitCritical>
    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
40379ad3:	000090        	retw
	...

40379ad8 <xQueueGenericSend>:
{
40379ad8:	008136        	entry	a1, 64
40379adb:	4149      	s32i.n	a4, a1, 16
    configASSERT( pxQueue );
40379add:	02dc      	bnez.n	a2, 40379af1 <xQueueGenericSend+0x19>
40379adf:	ec14d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379ae2:	ec1ec1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c02817c <__func__$14>)
40379ae5:	a8a3b2        	movi	a11, 0x3a8
40379ae8:	ec0fa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379aeb:	201110        	or	a1, a1, a1
40379aee:	062b25        	call8	4037fda0 <__assert_func>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
40379af1:	014356        	bnez	a3, 40379b09 <xQueueGenericSend+0x31>
40379af4:	102282        	l32i	a8, a2, 64
40379af7:	00e816        	beqz	a8, 40379b09 <xQueueGenericSend+0x31>
40379afa:	ec19d1        	l32r	a13, 40374b60 <_iram_text_start+0x75c> (3c024280 <_flash_rodata_start+0x4160>)
40379afd:	ec17c1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c02817c <__func__$14>)
40379b00:	a9a3b2        	movi	a11, 0x3a9
40379b03:	ec08a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379b06:	0629a5        	call8	4037fda0 <__assert_func>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
40379b09:	132566        	bnei	a5, 2, 40379b20 <xQueueGenericSend+0x48>
40379b0c:	f288      	l32i.n	a8, a2, 60
40379b0e:	0e1826        	beqi	a8, 1, 40379b20 <xQueueGenericSend+0x48>
40379b11:	ec14d1        	l32r	a13, 40374b64 <_iram_text_start+0x760> (3c0242d8 <_flash_rodata_start+0x41b8>)
40379b14:	ec12c1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c02817c <__func__$14>)
40379b17:	aaa3b2        	movi	a11, 0x3aa
40379b1a:	ec02a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379b1d:	062825        	call8	4037fda0 <__assert_func>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
40379b20:	01f265        	call8	4037ba48 <xTaskGetSchedulerState>
40379b23:	160c      	movi.n	a6, 1
40379b25:	836aa0        	moveqz	a6, a10, a10
40379b28:	2adc      	bnez.n	a10, 40379b3e <xQueueGenericSend+0x66>
40379b2a:	4188      	l32i.n	a8, a1, 16
40379b2c:	010816        	beqz	a8, 40379b40 <xQueueGenericSend+0x68>
40379b2f:	ec0ed1        	l32r	a13, 40374b68 <_iram_text_start+0x764> (3c024328 <_flash_rodata_start+0x4208>)
40379b32:	ec0ac1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c02817c <__func__$14>)
40379b35:	ada3b2        	movi	a11, 0x3ad
40379b38:	ebfba1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379b3b:	062665        	call8	4037fda0 <__assert_func>
40379b3e:	060c      	movi.n	a6, 0
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379b40:	4cc272        	addi	a7, a2, 76
40379b43:	fb7c      	movi.n	a11, -1
40379b45:	07ad      	mov.n	a10, a7
40379b47:	005ea5        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
40379b4a:	0020c0        	memw
40379b4d:	0e2292        	l32i	a9, a2, 56
40379b50:	0f2282        	l32i	a8, a2, 60
40379b53:	023987        	bltu	a9, a8, 40379b59 <xQueueGenericSend+0x81>
40379b56:	6e2566        	bnei	a5, 2, 40379bc8 <xQueueGenericSend+0xf0>
                    const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
40379b59:	0020c0        	memw
40379b5c:	e268      	l32i.n	a6, a2, 56
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
40379b5e:	05cd      	mov.n	a12, a5
40379b60:	03bd      	mov.n	a11, a3
40379b62:	02ad      	mov.n	a10, a2
40379b64:	ffc365        	call8	4037979c <prvCopyDataToQueue>
                    if( pxQueue->pxQueueSetContainer != NULL )
40379b67:	122282        	l32i	a8, a2, 72
40379b6a:	38ac      	beqz.n	a8, 40379b91 <xQueueGenericSend+0xb9>
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
40379b6c:	fec552        	addi	a5, a5, -2
40379b6f:	40f550        	nsau	a5, a5
40379b72:	415550        	srli	a5, a5, 5
40379b75:	01a082        	movi	a8, 1
40379b78:	838660        	moveqz	a8, a6, a6
40379b7b:	3d8587        	bany	a5, a8, 40379bbc <xQueueGenericSend+0xe4>
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
40379b7e:	02ad      	mov.n	a10, a2
40379b80:	ffcce5        	call8	40379850 <prvNotifyQueueSetContainer>
40379b83:	5abc      	beqz.n	a10, 40379bbc <xQueueGenericSend+0xe4>
40379b85:	03eba0        	rsr.prid	a10
40379b88:	04ada0        	extui	a10, a10, 13, 1
                            queueYIELD_IF_USING_PREEMPTION();
40379b8b:	fe5425        	call8	403780cc <esp_crosscore_int_send_yield>
40379b8e:	000a86        	j	40379bbc <xQueueGenericSend+0xe4>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
40379b91:	0020c0        	memw
40379b94:	092282        	l32i	a8, a2, 36
40379b97:	015816        	beqz	a8, 40379bb0 <xQueueGenericSend+0xd8>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
40379b9a:	24c2a2        	addi	a10, a2, 36
40379b9d:	01a225        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379ba0:	018a16        	beqz	a10, 40379bbc <xQueueGenericSend+0xe4>
40379ba3:	03eba0        	rsr.prid	a10
40379ba6:	04ada0        	extui	a10, a10, 13, 1
                                queueYIELD_IF_USING_PREEMPTION();
40379ba9:	fe5225        	call8	403780cc <esp_crosscore_int_send_yield>
40379bac:	000306        	j	40379bbc <xQueueGenericSend+0xe4>
40379baf:	8a1600        	round.s	a1, f6, 0
                        else if( xYieldRequired != pdFALSE )
40379bb2:	eba000        	f64cmpl	a10, a0, a0
40379bb5:	ada003        	lsi	f0, a0, 0x2b4
40379bb8:	512504        	lsi	f0, a5, 0x144
                            queueYIELD_IF_USING_PREEMPTION();
40379bbb:	fe          	.byte	0xfe
                taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379bbc:	20a770        	or	a10, a7, a7
40379bbf:	006c25        	call8	4037a280 <vPortExitCritical>
                return pdPASS;
40379bc2:	120c      	movi.n	a2, 1
40379bc4:	001246        	j	40379c11 <xQueueGenericSend+0x139>
40379bc7:	218200        	srai	a8, a0, 2
                if( xTicksToWait == ( TickType_t ) 0 )
40379bca:	b85604        	lsi	f0, a6, 0x2e0
40379bcd:	a77000        	lsi	f0, a0, 0x29c
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379bd0:	6ae520        	maddn.s	f14, f5, f2
40379bd3:	020c00        	andb	b0, b12, b0
                    return errQUEUE_FULL;
40379bd6:	000dc6        	j	40379c11 <xQueueGenericSend+0x139>
40379bd9:	765600        	lsi	f0, a6, 0x1d8
                else if( xEntryTimeSet == pdFALSE )
40379bdc:	01ad00        	slli	a10, a13, 32
                    vTaskInternalSetTimeOutState( &xTimeOut );
40379bdf:	01bde5        	call8	4037b7bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
40379be2:	01a062        	movi	a6, 1
                if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
40379be5:	10c1b2        	addi	a11, a1, 16
40379be8:	01ad      	mov.n	a10, a1
40379bea:	01bee5        	call8	4037b7d8 <xTaskCheckForTimeOut>
40379bed:	7adc      	bnez.n	a10, 40379c08 <xQueueGenericSend+0x130>
                    vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
40379bef:	41b8      	l32i.n	a11, a1, 16
40379bf1:	10c2a2        	addi	a10, a2, 16
40379bf4:	019825        	call8	4037b578 <vTaskPlaceOnEventList>
40379bf7:	03eba0        	rsr.prid	a10
40379bfa:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
40379bfd:	fe4ce5        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379c00:	07ad      	mov.n	a10, a7
40379c02:	0067e5        	call8	4037a280 <vPortExitCritical>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379c05:	ffcdc6        	j	40379b40 <xQueueGenericSend+0x68>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379c08:	20a770        	or	a10, a7, a7
40379c0b:	006765        	call8	4037a280 <vPortExitCritical>
                    return errQUEUE_FULL;
40379c0e:	00a022        	movi	a2, 0
}
40379c11:	000090        	retw

40379c14 <prvInitialiseMutex>:
    {
40379c14:	004136        	entry	a1, 32
40379c17:	20a220        	or	a10, a2, a2
        if( pxNewQueue != NULL )
40379c1a:	030216        	beqz	a2, 40379c4e <prvInitialiseMutex+0x3a>
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
40379c1d:	00a082        	movi	a8, 0
40379c20:	2289      	s32i.n	a8, a2, 8
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
40379c22:	0289      	s32i.n	a8, a2, 0
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
40379c24:	3289      	s32i.n	a8, a2, 12
            portMUX_INITIALIZE( &( pxNewQueue->xQueueLock ) );
40379c26:	4cc282        	addi	a8, a2, 76
    assert(lock);
40379c29:	c8cc      	bnez.n	a8, 40379c39 <prvInitialiseMutex+0x25>
40379c2b:	ebd0d1        	l32r	a13, 40374b6c <_iram_text_start+0x768> (3c022934 <_flash_rodata_start+0x2814>)
40379c2e:	ebd0c1        	l32r	a12, 40374b70 <_iram_text_start+0x76c> (3c028210 <__func__$24>)
40379c31:	5b3c      	movi.n	a11, 53
40379c33:	ebd0a1        	l32r	a10, 40374b74 <_iram_text_start+0x770> (3c022964 <_flash_rodata_start+0x2844>)
40379c36:	0616a5        	call8	4037fda0 <__assert_func>
    lock->owner = SPINLOCK_FREE;
40379c39:	ebbf81        	l32r	a8, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
40379c3c:	136282        	s32i	a8, a2, 76
    lock->count = 0;
40379c3f:	00a0b2        	movi	a11, 0
40379c42:	1462b2        	s32i	a11, a2, 80
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
40379c45:	20dbb0        	or	a13, a11, a11
40379c48:	20cbb0        	or	a12, a11, a11
40379c4b:	ffe8e5        	call8	40379ad8 <xQueueGenericSend>
    }
40379c4e:	f01d      	retw.n

40379c50 <xQueueCreateMutex>:
    {
40379c50:	004136        	entry	a1, 32
        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
40379c53:	74c020        	extui	a12, a2, 0, 8
40379c56:	00a0b2        	movi	a11, 0
40379c59:	01a0a2        	movi	a10, 1
40379c5c:	ffdee5        	call8	40379a4c <xQueueGenericCreate>
40379c5f:	0a2d      	mov.n	a2, a10
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
40379c61:	fffb25        	call8	40379c14 <prvInitialiseMutex>
    }
40379c64:	f01d      	retw.n
	...

40379c68 <xQueueCreateMutexStatic>:
    {
40379c68:	004136        	entry	a1, 32
40379c6b:	20d330        	or	a13, a3, a3
        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
40379c6e:	74e020        	extui	a14, a2, 0, 8
40379c71:	00a0c2        	movi	a12, 0
40379c74:	0cbd      	mov.n	a11, a12
40379c76:	1a0c      	movi.n	a10, 1
40379c78:	ffd425        	call8	403799bc <xQueueGenericCreateStatic>
40379c7b:	0a2d      	mov.n	a2, a10
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
40379c7d:	fff965        	call8	40379c14 <prvInitialiseMutex>
    }
40379c80:	f01d      	retw.n
	...

40379c84 <xQueueGiveMutexRecursive>:
    {
40379c84:	004136        	entry	a1, 32
        configASSERT( pxMutex );
40379c87:	00e256        	bnez	a2, 40379c99 <xQueueGiveMutexRecursive+0x15>
40379c8a:	ebbbd1        	l32r	a13, 40374b78 <_iram_text_start+0x774> (3c02437c <_flash_rodata_start+0x425c>)
40379c8d:	ebbbc1        	l32r	a12, 40374b7c <_iram_text_start+0x778> (3c0281ac <__func__$18>)
40379c90:	fda2b2        	movi	a11, 0x2fd
40379c93:	eba4a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379c96:	0610a5        	call8	4037fda0 <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
40379c99:	2278      	l32i.n	a7, a2, 8
40379c9b:	01bf65        	call8	4037b890 <xTaskGetCurrentTaskHandle>
40379c9e:	1897a7        	bne	a7, a10, 40379cba <xQueueGiveMutexRecursive+0x36>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
40379ca1:	032282        	l32i	a8, a2, 12
40379ca4:	880b      	addi.n	a8, a8, -1
40379ca6:	3289      	s32i.n	a8, a2, 12
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
40379ca8:	38dc      	bnez.n	a8, 40379cbf <xQueueGiveMutexRecursive+0x3b>
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
40379caa:	0d0c      	movi.n	a13, 0
40379cac:	0dcd      	mov.n	a12, a13
40379cae:	0dbd      	mov.n	a11, a13
40379cb0:	02ad      	mov.n	a10, a2
40379cb2:	ffe265        	call8	40379ad8 <xQueueGenericSend>
            xReturn = pdPASS;
40379cb5:	120c      	movi.n	a2, 1
40379cb7:	000186        	j	40379cc1 <xQueueGiveMutexRecursive+0x3d>
            xReturn = pdFAIL;
40379cba:	020c      	movi.n	a2, 0
40379cbc:	000046        	j	40379cc1 <xQueueGiveMutexRecursive+0x3d>
            xReturn = pdPASS;
40379cbf:	120c      	movi.n	a2, 1
    }
40379cc1:	f01d      	retw.n
	...

40379cc4 <xQueueGiveFromISR>:
{
40379cc4:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379cc7:	00e256        	bnez	a2, 40379cd9 <xQueueGiveFromISR+0x15>
40379cca:	eb99d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379ccd:	ebacc1        	l32r	a12, 40374b80 <_iram_text_start+0x77c> (3c02814c <__func__$11>)
40379cd0:	4ea5b2        	movi	a11, 0x54e
40379cd3:	eb94a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379cd6:	060ca5        	call8	4037fda0 <__assert_func>
    configASSERT( pxQueue->uxItemSize == 0 );
40379cd9:	102282        	l32i	a8, a2, 64
40379cdc:	011816        	beqz	a8, 40379cf1 <xQueueGiveFromISR+0x2d>
40379cdf:	eba9d1        	l32r	a13, 40374b84 <_iram_text_start+0x780> (3c024384 <_flash_rodata_start+0x4264>)
40379ce2:	eba7c1        	l32r	a12, 40374b80 <_iram_text_start+0x77c> (3c02814c <__func__$11>)
40379ce5:	52a5b2        	movi	a11, 0x552
40379ce8:	eb8fa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ceb:	201110        	or	a1, a1, a1
40379cee:	060b25        	call8	4037fda0 <__assert_func>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
40379cf1:	0288      	l32i.n	a8, a2, 0
40379cf3:	016856        	bnez	a8, 40379d0d <xQueueGiveFromISR+0x49>
40379cf6:	2288      	l32i.n	a8, a2, 8
40379cf8:	011816        	beqz	a8, 40379d0d <xQueueGiveFromISR+0x49>
40379cfb:	eba3d1        	l32r	a13, 40374b88 <_iram_text_start+0x784> (3c0243a0 <_flash_rodata_start+0x4280>)
40379cfe:	eba0c1        	l32r	a12, 40374b80 <_iram_text_start+0x77c> (3c02814c <__func__$11>)
40379d01:	57a5b2        	movi	a11, 0x557
40379d04:	eb88a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379d07:	201110        	or	a1, a1, a1
40379d0a:	060965        	call8	4037fda0 <__assert_func>
    prvENTER_CRITICAL_OR_MASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379d0d:	4cc272        	addi	a7, a2, 76
40379d10:	fb7c      	movi.n	a11, -1
40379d12:	20a770        	or	a10, a7, a7
40379d15:	0041a5        	call8	4037a130 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
40379d18:	0020c0        	memw
40379d1b:	e288      	l32i.n	a8, a2, 56
        if( uxMessagesWaiting < pxQueue->uxLength )
40379d1d:	f298      	l32i.n	a9, a2, 60
40379d1f:	35b897        	bgeu	a8, a9, 40379d58 <xQueueGiveFromISR+0x94>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
40379d22:	881b      	addi.n	a8, a8, 1
40379d24:	0020c0        	memw
40379d27:	e289      	s32i.n	a8, a2, 56
                    if( pxQueue->pxQueueSetContainer != NULL )
40379d29:	122282        	l32i	a8, a2, 72
40379d2c:	f88c      	beqz.n	a8, 40379d3f <xQueueGiveFromISR+0x7b>
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
40379d2e:	20a220        	or	a10, a2, a2
40379d31:	ffb1e5        	call8	40379850 <prvNotifyQueueSetContainer>
40379d34:	5aac      	beqz.n	a10, 40379d5d <xQueueGiveFromISR+0x99>
                            if( pxHigherPriorityTaskWoken != NULL )
40379d36:	83ac      	beqz.n	a3, 40379d62 <xQueueGiveFromISR+0x9e>
                                *pxHigherPriorityTaskWoken = pdTRUE;
40379d38:	120c      	movi.n	a2, 1
40379d3a:	0329      	s32i.n	a2, a3, 0
40379d3c:	000d46        	j	40379d75 <xQueueGiveFromISR+0xb1>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
40379d3f:	0020c0        	memw
40379d42:	9288      	l32i.n	a8, a2, 36
40379d44:	08ac      	beqz.n	a8, 40379d68 <xQueueGiveFromISR+0xa4>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
40379d46:	24c2a2        	addi	a10, a2, 36
40379d49:	018765        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379d4c:	da9c      	beqz.n	a10, 40379d6d <xQueueGiveFromISR+0xa9>
                                if( pxHigherPriorityTaskWoken != NULL )
40379d4e:	03ac      	beqz.n	a3, 40379d72 <xQueueGiveFromISR+0xae>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
40379d50:	120c      	movi.n	a2, 1
40379d52:	0329      	s32i.n	a2, a3, 0
40379d54:	000746        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d57:	020c00        	andb	b0, b12, b0
            xReturn = errQUEUE_FULL;
40379d5a:	0005c6        	j	40379d75 <xQueueGiveFromISR+0xb1>
            xReturn = pdPASS;
40379d5d:	120c      	movi.n	a2, 1
40379d5f:	000486        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d62:	120c      	movi.n	a2, 1
40379d64:	000346        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d67:	120c00        	andbc	b0, b12, b0
40379d6a:	0001c6        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d6d:	120c      	movi.n	a2, 1
40379d6f:	000086        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d72:	01a022        	movi	a2, 1
    prvEXIT_CRITICAL_OR_UNMASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379d75:	20a770        	or	a10, a7, a7
40379d78:	005065        	call8	4037a280 <vPortExitCritical>
}
40379d7b:	000090        	retw
	...

40379d80 <xQueueSemaphoreTake>:
{
40379d80:	008136        	entry	a1, 64
40379d83:	4139      	s32i.n	a3, a1, 16
    configASSERT( ( pxQueue ) );
40379d85:	02dc      	bnez.n	a2, 40379d99 <xQueueSemaphoreTake+0x19>
40379d87:	eb81d1        	l32r	a13, 40374b8c <_iram_text_start+0x788> (3c024404 <_flash_rodata_start+0x42e4>)
40379d8a:	eb81c1        	l32r	a12, 40374b90 <_iram_text_start+0x78c> (3c028138 <__func__$9>)
40379d8d:	ada6b2        	movi	a11, 0x6ad
40379d90:	eb65a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379d93:	201110        	or	a1, a1, a1
40379d96:	0600a5        	call8	4037fda0 <__assert_func>
    configASSERT( pxQueue->uxItemSize == 0 );
40379d99:	102282        	l32i	a8, a2, 64
40379d9c:	d88c      	beqz.n	a8, 40379dad <xQueueSemaphoreTake+0x2d>
40379d9e:	eb79d1        	l32r	a13, 40374b84 <_iram_text_start+0x780> (3c024384 <_flash_rodata_start+0x4264>)
40379da1:	eb7bc1        	l32r	a12, 40374b90 <_iram_text_start+0x78c> (3c028138 <__func__$9>)
40379da4:	b1a6b2        	movi	a11, 0x6b1
40379da7:	eb5fa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379daa:	05ff65        	call8	4037fda0 <__assert_func>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
40379dad:	01c9a5        	call8	4037ba48 <xTaskGetSchedulerState>
40379db0:	160c      	movi.n	a6, 1
40379db2:	836aa0        	moveqz	a6, a10, a10
40379db5:	013a56        	bnez	a10, 40379dcc <xQueueSemaphoreTake+0x4c>
40379db8:	4188      	l32i.n	a8, a1, 16
40379dba:	017816        	beqz	a8, 40379dd5 <xQueueSemaphoreTake+0x55>
40379dbd:	eb6ad1        	l32r	a13, 40374b68 <_iram_text_start+0x764> (3c024328 <_flash_rodata_start+0x4208>)
40379dc0:	eb74c1        	l32r	a12, 40374b90 <_iram_text_start+0x78c> (3c028138 <__func__$9>)
40379dc3:	b6a6b2        	movi	a11, 0x6b6
40379dc6:	eb57a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379dc9:	05fd65        	call8	4037fda0 <__assert_func>
40379dcc:	050c      	movi.n	a5, 0
40379dce:	056d      	mov.n	a6, a5
40379dd0:	000106        	j	40379dd8 <xQueueSemaphoreTake+0x58>
40379dd3:	600000        	neg	a0, a0
40379dd6:	722056        	bnez	a0, 4037a4fc <vPortYieldFromInt+0xc>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379dd9:	b24cc2        	s8i	a12, a12, 178
40379ddc:	af          	.byte	0xaf
40379ddd:	ff          	.byte	0xff
40379dde:	07ad      	mov.n	a10, a7
40379de0:	0034e5        	call8	4037a130 <xPortEnterCriticalTimeout>
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
40379de3:	0020c0        	memw
40379de6:	e288      	l32i.n	a8, a2, 56
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
40379de8:	48bc      	beqz.n	a8, 40379e20 <xQueueSemaphoreTake+0xa0>
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
40379dea:	880b      	addi.n	a8, a8, -1
40379dec:	0020c0        	memw
40379def:	e289      	s32i.n	a8, a2, 56
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
40379df1:	002282        	l32i	a8, a2, 0
40379df4:	004856        	bnez	a8, 40379dfc <xQueueSemaphoreTake+0x7c>
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
40379df7:	0229a5        	call8	4037c090 <pvTaskIncrementMutexHeldCount>
40379dfa:	22a9      	s32i.n	a10, a2, 8
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379dfc:	0020c0        	memw
40379dff:	042282        	l32i	a8, a2, 16
40379e02:	010816        	beqz	a8, 40379e16 <xQueueSemaphoreTake+0x96>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
40379e05:	10c2a2        	addi	a10, a2, 16
40379e08:	017b65        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379e0b:	7a8c      	beqz.n	a10, 40379e16 <xQueueSemaphoreTake+0x96>
40379e0d:	03eba0        	rsr.prid	a10
40379e10:	04ada0        	extui	a10, a10, 13, 1
                        queueYIELD_IF_USING_PREEMPTION();
40379e13:	fe2ba5        	call8	403780cc <esp_crosscore_int_send_yield>
                taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e16:	07ad      	mov.n	a10, a7
40379e18:	004665        	call8	4037a280 <vPortExitCritical>
                return pdPASS;
40379e1b:	120c      	movi.n	a2, 1
40379e1d:	001946        	j	40379e86 <xQueueSemaphoreTake+0x106>
                if( xTicksToWait == ( TickType_t ) 0 )
40379e20:	042182        	l32i	a8, a1, 16
40379e23:	00b856        	bnez	a8, 40379e32 <xQueueSemaphoreTake+0xb2>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e26:	20a770        	or	a10, a7, a7
40379e29:	004565        	call8	4037a280 <vPortExitCritical>
                    return errQUEUE_EMPTY;
40379e2c:	020c      	movi.n	a2, 0
40379e2e:	001506        	j	40379e86 <xQueueSemaphoreTake+0x106>
40379e31:	765600        	lsi	f0, a6, 0x1d8
                else if( xEntryTimeSet == pdFALSE )
40379e34:	01ad00        	slli	a10, a13, 32
                    vTaskInternalSetTimeOutState( &xTimeOut );
40379e37:	019865        	call8	4037b7bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
40379e3a:	01a062        	movi	a6, 1
                if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
40379e3d:	10c1b2        	addi	a11, a1, 16
40379e40:	20a110        	or	a10, a1, a1
40379e43:	019965        	call8	4037b7d8 <xTaskCheckForTimeOut>
40379e46:	026a56        	bnez	a10, 40379e70 <xQueueSemaphoreTake+0xf0>
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
40379e49:	0288      	l32i.n	a8, a2, 0
40379e4b:	007856        	bnez	a8, 40379e56 <xQueueSemaphoreTake+0xd6>
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
40379e4e:	0222a2        	l32i	a10, a2, 8
40379e51:	01f4e5        	call8	4037bda0 <xTaskPriorityInherit>
40379e54:	0a5d      	mov.n	a5, a10
                    vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
40379e56:	0421b2        	l32i	a11, a1, 16
40379e59:	24c2a2        	addi	a10, a2, 36
40379e5c:	0171a5        	call8	4037b578 <vTaskPlaceOnEventList>
40379e5f:	03eba0        	rsr.prid	a10
40379e62:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
40379e65:	fe2665        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e68:	07ad      	mov.n	a10, a7
40379e6a:	004165        	call8	4037a280 <vPortExitCritical>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379e6d:	ffd9c6        	j	40379dd8 <xQueueSemaphoreTake+0x58>
                        if( xInheritanceOccurred != pdFALSE )
40379e70:	00b516        	beqz	a5, 40379e7f <xQueueSemaphoreTake+0xff>
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
40379e73:	02ad      	mov.n	a10, a2
40379e75:	00a365        	call8	4037a8ac <prvGetDisinheritPriorityAfterTimeout>
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
40379e78:	0abd      	mov.n	a11, a10
40379e7a:	22a8      	l32i.n	a10, a2, 8
40379e7c:	0211a5        	call8	4037bf98 <vTaskPriorityDisinheritAfterTimeout>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e7f:	07ad      	mov.n	a10, a7
40379e81:	003fe5        	call8	4037a280 <vPortExitCritical>
                    return errQUEUE_EMPTY;
40379e84:	020c      	movi.n	a2, 0
}
40379e86:	f01d      	retw.n

40379e88 <xQueueTakeMutexRecursive>:
    {
40379e88:	004136        	entry	a1, 32
40379e8b:	027d      	mov.n	a7, a2
        configASSERT( pxMutex );
40379e8d:	d2cc      	bnez.n	a2, 40379e9e <xQueueTakeMutexRecursive+0x16>
40379e8f:	eb3ad1        	l32r	a13, 40374b78 <_iram_text_start+0x774> (3c02437c <_flash_rodata_start+0x425c>)
40379e92:	eb40c1        	l32r	a12, 40374b94 <_iram_text_start+0x790> (3c028190 <__func__$17>)
40379e95:	35a3b2        	movi	a11, 0x335
40379e98:	eb23a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379e9b:	05f065        	call8	4037fda0 <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
40379e9e:	2228      	l32i.n	a2, a2, 8
40379ea0:	019ee5        	call8	4037b890 <xTaskGetCurrentTaskHandle>
40379ea3:	0d92a7        	bne	a2, a10, 40379eb4 <xQueueTakeMutexRecursive+0x2c>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
40379ea6:	032782        	l32i	a8, a7, 12
40379ea9:	01c882        	addi	a8, a8, 1
40379eac:	3789      	s32i.n	a8, a7, 12
            xReturn = pdPASS;
40379eae:	120c      	movi.n	a2, 1
40379eb0:	000506        	j	40379ec8 <xQueueTakeMutexRecursive+0x40>
40379eb3:	b33000        	movgez	a3, a0, a0
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
40379eb6:	a77020        	lsi	f2, a0, 0x29c
40379eb9:	ec6520        	lsi	f2, a5, 0x3b0
40379ebc:	ff          	.byte	0xff
40379ebd:	202aa0        	or	a2, a10, a10
            if( xReturn != pdFAIL )
40379ec0:	4a8c      	beqz.n	a10, 40379ec8 <xQueueTakeMutexRecursive+0x40>
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
40379ec2:	3788      	l32i.n	a8, a7, 12
40379ec4:	881b      	addi.n	a8, a8, 1
40379ec6:	3789      	s32i.n	a8, a7, 12
    }
40379ec8:	f01d      	retw.n
	...

40379ecc <xQueueReceiveFromISR>:
{
40379ecc:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379ecf:	011256        	bnez	a2, 40379ee4 <xQueueReceiveFromISR+0x18>
40379ed2:	eb17d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379ed5:	eb30c1        	l32r	a12, 40374b98 <_iram_text_start+0x794> (3c028120 <__func__$7>)
40379ed8:	eb31b1        	l32r	a11, 40374b9c <_iram_text_start+0x798> (86d <UserFrameTotalSize+0x76d>)
40379edb:	eb12a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ede:	201110        	or	a1, a1, a1
40379ee1:	05ebe5        	call8	4037fda0 <__assert_func>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
40379ee4:	53dc      	bnez.n	a3, 40379efd <xQueueReceiveFromISR+0x31>
40379ee6:	102282        	l32i	a8, a2, 64
40379ee9:	089c      	beqz.n	a8, 40379efd <xQueueReceiveFromISR+0x31>
40379eeb:	eb2dd1        	l32r	a13, 40374ba0 <_iram_text_start+0x79c> (3c02446c <_flash_rodata_start+0x434c>)
40379eee:	eb2ac1        	l32r	a12, 40374b98 <_iram_text_start+0x794> (3c028120 <__func__$7>)
40379ef1:	eb2cb1        	l32r	a11, 40374ba4 <_iram_text_start+0x7a0> (86e <UserFrameTotalSize+0x76e>)
40379ef4:	eb0ca1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ef7:	201110        	or	a1, a1, a1
40379efa:	05ea65        	call8	4037fda0 <__assert_func>
    prvENTER_CRITICAL_OR_MASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379efd:	4cc262        	addi	a6, a2, 76
40379f00:	ffafb2        	movi	a11, -1
40379f03:	20a660        	or	a10, a6, a6
40379f06:	0022a5        	call8	4037a130 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
40379f09:	0020c0        	memw
40379f0c:	0e2272        	l32i	a7, a2, 56
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
40379f0f:	57ac      	beqz.n	a7, 40379f38 <xQueueReceiveFromISR+0x6c>
            prvCopyDataFromQueue( pxQueue, pvBuffer );
40379f11:	03bd      	mov.n	a11, a3
40379f13:	02ad      	mov.n	a10, a2
40379f15:	ff9165        	call8	4037982c <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
40379f18:	770b      	addi.n	a7, a7, -1
40379f1a:	0020c0        	memw
40379f1d:	e279      	s32i.n	a7, a2, 56
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379f1f:	0020c0        	memw
40379f22:	4288      	l32i.n	a8, a2, 16
40379f24:	589c      	beqz.n	a8, 40379f3d <xQueueReceiveFromISR+0x71>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
40379f26:	10c2a2        	addi	a10, a2, 16
40379f29:	016965        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379f2c:	2a9c      	beqz.n	a10, 40379f42 <xQueueReceiveFromISR+0x76>
                        if( pxHigherPriorityTaskWoken != NULL )
40379f2e:	649c      	beqz.n	a4, 40379f48 <xQueueReceiveFromISR+0x7c>
                            *pxHigherPriorityTaskWoken = pdTRUE;
40379f30:	120c      	movi.n	a2, 1
40379f32:	0429      	s32i.n	a2, a4, 0
40379f34:	0004c6        	j	40379f4b <xQueueReceiveFromISR+0x7f>
40379f37:	020c00        	andb	b0, b12, b0
            xReturn = pdFAIL;
40379f3a:	000346        	j	40379f4b <xQueueReceiveFromISR+0x7f>
            xReturn = pdPASS;
40379f3d:	120c      	movi.n	a2, 1
40379f3f:	000206        	j	40379f4b <xQueueReceiveFromISR+0x7f>
40379f42:	120c      	movi.n	a2, 1
40379f44:	0000c6        	j	40379f4b <xQueueReceiveFromISR+0x7f>
40379f47:	a02200        	addx4	a2, a2, a0
40379f4a:	a66001        	l32r	a0, 403638cc <rom_rx_gain_force+0x35d4a0>
    prvEXIT_CRITICAL_OR_UNMASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379f4d:	332520        	clamps	a2, a5, 9
40379f50:	009000        	all4	b0, b0:b1:b2:b3
	...

40379f54 <vQueueDelete>:
{
40379f54:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379f57:	00e256        	bnez	a2, 40379f69 <vQueueDelete+0x15>
40379f5a:	eaf5d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379f5d:	eb12c1        	l32r	a12, 40374ba8 <_iram_text_start+0x7a4> (3c028110 <__func__$2>)
40379f60:	eb13b1        	l32r	a11, 40374bac <_iram_text_start+0x7a8> (933 <UserFrameTotalSize+0x833>)
40379f63:	eaf0a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379f66:	05e3a5        	call8	4037fda0 <__assert_func>
        if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
40379f69:	440282        	l8ui	a8, a2, 68
40379f6c:	68cc      	bnez.n	a8, 40379f76 <vQueueDelete+0x22>
            vPortFree( pxQueue );
40379f6e:	02ad      	mov.n	a10, a2
40379f70:	201110        	or	a1, a1, a1
40379f73:	006365        	call8	4037a5a8 <vPortFree>
}
40379f76:	f01d      	retw.n

40379f78 <vPortTaskWrapper>:
{
40379f78:	004136        	entry	a1, 32
40379f7b:	03ad      	mov.n	a10, a3
    pxCode(pvParameters);
40379f7d:	0002e0        	callx8	a2
    char *pcTaskName = pcTaskGetName(NULL);
40379f80:	0a0c      	movi.n	a10, 0
40379f82:	01a865        	call8	4037ba08 <pcTaskGetName>
40379f85:	0a7d      	mov.n	a7, a10
    ESP_LOGE("FreeRTOS", "FreeRTOS Task \"%s\" should not return, Aborting now!", pcTaskName);
40379f87:	05caa5        	call8	4037fc30 <esp_log_timestamp>
40379f8a:	eb09b1        	l32r	a11, 40374bb0 <_iram_text_start+0x7ac> (3c024a40 <_flash_rodata_start+0x4920>)
40379f8d:	07fd      	mov.n	a15, a7
40379f8f:	0bed      	mov.n	a14, a11
40379f91:	0add      	mov.n	a13, a10
40379f93:	eb08c1        	l32r	a12, 40374bb4 <_iram_text_start+0x7b0> (3c024a4c <_flash_rodata_start+0x492c>)
40379f96:	1a0c      	movi.n	a10, 1
40379f98:	05cde5        	call8	4037fc78 <esp_log_write>
    abort();
40379f9b:	05d4a5        	call8	4037fce4 <abort>
	...

40379fa0 <vPortTLSPointersDelCb>:

// --------------------- TCB Cleanup -----------------------

#if ( CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS )
static void vPortTLSPointersDelCb( void *pxTCB )
{
40379fa0:	004136        	entry	a1, 32
     * pvDummy15 corresponds to pvThreadLocalStoragePointers member of the TCB.
     */
    StaticTask_t *tcb = ( StaticTask_t * )pxTCB;

    /* The TLSP deletion callbacks are stored at an offset of (configNUM_THREAD_LOCAL_STORAGE_POINTERS/2) */
    TlsDeleteCallbackFunction_t *pvThreadLocalStoragePointersDelCallback = ( TlsDeleteCallbackFunction_t * )( &( tcb->pvDummy15[ ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ) ] ) );
40379fa3:	58c252        	addi	a5, a2, 88

    /* We need to iterate over half the depth of the pvThreadLocalStoragePointers area
     * to access all TLS pointers and their respective TLS deletion callbacks.
     */
    for ( int x = 0; x < ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ); x++ ) {
40379fa6:	070c      	movi.n	a7, 0
40379fa8:	001dc6        	j	4037a023 <vPortTLSPointersDelCb+0x83>
40379fab:	675000        	lsi	f0, a0, 0x19c
        if ( pvThreadLocalStoragePointersDelCallback[ x ] != NULL ) {  //If del cb is set
40379fae:	06c8a0        	lsi	f10, a8, 24
40379fb1:	06cc16        	beqz	a12, 4037a021 <vPortTLSPointersDelCb+0x81>
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40379fb4:	eb0191        	l32r	a9, 40374bb8 <_iram_text_start+0x7b4> (be000000 <_rtc_reserved_end+0x5df00000>)
40379fb7:	9c9a      	add.n	a9, a12, a9
40379fb9:	e99081        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
40379fbc:	628890        	lsi	f9, a8, 0x188
40379fbf:	880b      	addi.n	a8, a8, -1
40379fc1:	608080        	neg	a8, a8
40379fc4:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40379fc7:	eafda1        	l32r	a10, 40374bbc <_iram_text_start+0x7b8> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
40379fca:	acaa      	add.n	a10, a12, a10
40379fcc:	e98e91        	l32r	a9, 40374604 <_iram_text_start+0x200> (6ffff <UserFrameTotalSize+0x6feff>)
40379fcf:	6299a0        	lsi	f10, a9, 0x188
40379fd2:	990b      	addi.n	a9, a9, -1
40379fd4:	609090        	neg	a9, a9
40379fd7:	749090        	extui	a9, a9, 0, 8
40379fda:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40379fdd:	38fc      	bnez.n	a8, 4037a014 <vPortTLSPointersDelCb+0x74>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40379fdf:	e9ec81        	l32r	a8, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40379fe2:	8c8a      	add.n	a8, a12, a8
40379fe4:	e98a91        	l32r	a9, 4037460c <_iram_text_start+0x208> (5ffff <UserFrameTotalSize+0x5feff>)
40379fe7:	29b987        	bgeu	a9, a8, 4037a014 <vPortTLSPointersDelCb+0x74>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40379fea:	e98081        	l32r	a8, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40379fed:	8c8a      	add.n	a8, a12, a8
40379fef:	e98091        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40379ff2:	1eb987        	bgeu	a9, a8, 4037a014 <vPortTLSPointersDelCb+0x74>
40379ff5:	e91d81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40379ff8:	0888      	l32i.n	a8, a8, 0
            /* In case the TLSP deletion callback has been overwritten by a TLS pointer, gracefully abort. */
            if ( !esp_ptr_executable( pvThreadLocalStoragePointersDelCallback[ x ] ) ) {
                // We call EARLY log here as currently portCLEAN_UP_TCB() is called in a critical section
                ESP_EARLY_LOGE("FreeRTOS", "Fatal error: TLSP deletion callback at index %d overwritten with non-excutable pointer %p", x, pvThreadLocalStoragePointersDelCallback[ x ]);
40379ffa:	389c      	beqz.n	a8, 4037a011 <vPortTLSPointersDelCb+0x71>
40379ffc:	05c325        	call8	4037fc30 <esp_log_timestamp>
40379fff:	06e8      	l32i.n	a14, a6, 0
4037a001:	07dd      	mov.n	a13, a7
4037a003:	eaebc1        	l32r	a12, 40374bb0 <_iram_text_start+0x7ac> (3c024a40 <_flash_rodata_start+0x4920>)
4037a006:	0abd      	mov.n	a11, a10
4037a008:	eaeea1        	l32r	a10, 40374bc0 <_iram_text_start+0x7bc> (3c024a90 <_flash_rodata_start+0x4970>)
4037a00b:	e92a81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4037a00e:	0008e0        	callx8	a8
                abort();
4037a011:	05cd25        	call8	4037fce4 <abort>
            }

            pvThreadLocalStoragePointersDelCallback[ x ]( x, tcb->pvDummy15[ x ] );   //Call del cb
4037a014:	14c782        	addi	a8, a7, 20
4037a017:	a08820        	addx4	a8, a8, a2
4037a01a:	18b8      	l32i.n	a11, a8, 4
4037a01c:	07ad      	mov.n	a10, a7
4037a01e:	000ce0        	callx8	a12
    for ( int x = 0; x < ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ); x++ ) {
4037a021:	771b      	addi.n	a7, a7, 1
4037a023:	0217e6        	bgei	a7, 1, 4037a029 <vPortTLSPointersDelCb+0x89>
4037a026:	ffe086        	j	40379fac <vPortTLSPointersDelCb+0xc>
        }
    }
}
4037a029:	f01d      	retw.n
	...

4037a02c <vPortCleanUpCoprocArea>:
#endif /* CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS */

#if ( XCHAL_CP_NUM > 0 )
static void vPortCleanUpCoprocArea(void *pvTCB)
{
4037a02c:	004136        	entry	a1, 32
    UBaseType_t uxCoprocArea;
    BaseType_t xTargetCoreID;

    /* Get a pointer to the task's coprocessor save area */
    uxCoprocArea = ( UBaseType_t ) ( ( ( StaticTask_t * ) pvTCB )->pxDummy8 );  /* Get TCB_t.pxEndOfStack */
4037a02f:	122282        	l32i	a8, a2, 72
    uxCoprocArea = STACKPTR_ALIGN_DOWN(16, uxCoprocArea - XT_CP_SIZE);
4037a032:	c4ae92        	movi	a9, 0xfffffec4
4037a035:	808890        	add	a8, a8, a9
        xTargetCoreID = 0;
    #endif /* configNUMBER_OF_CORES > 1 */

    /* If task has live floating point registers somewhere, release them */
    void _xt_coproc_release(volatile void *coproc_sa_base, BaseType_t xTargetCoreID);
    _xt_coproc_release( (void *)uxCoprocArea, xTargetCoreID );
4037a038:	1122b2        	l32i	a11, a2, 68
4037a03b:	f0afa2        	movi	a10, -16
4037a03e:	10a8a0        	and	a10, a8, a10
4037a041:	07e225        	call8	40381e64 <_xt_coproc_release>
}
4037a044:	000090        	retw
	...

4037a048 <xPortStartScheduler>:
{
4037a048:	004136        	entry	a1, 32
    portDISABLE_INTERRUPTS();
4037a04b:	006380        	rsil	a8, 3
    _xt_coproc_init();
4037a04e:	07dfe5        	call8	40381e4c <_xt_coproc_init>
    vPortSetupTimer();
4037a051:	007a65        	call8	4037a7f8 <vPortSetupTimer>
4037a054:	03eb80        	rsr.prid	a8
4037a057:	048d80        	extui	a8, a8, 13, 1
    port_xSchedulerRunning[xPortGetCoreID()] = 1;
4037a05a:	eada91        	l32r	a9, 40374bc4 <_iram_text_start+0x7c0> (3fc94f08 <port_xSchedulerRunning>)
4037a05d:	a08890        	addx4	a8, a8, a9
4037a060:	01a022        	movi	a2, 1
4037a063:	0020c0        	memw
4037a066:	0829      	s32i.n	a2, a8, 0
    xthal_window_spill();
4037a068:	07c765        	call8	40381ce0 <xthal_window_spill>
    __asm__ volatile ("call0    _frxt_dispatch\n");
4037a06b:	003bc5        	call0	4037a428 <_frxt_dispatch>
}
4037a06e:	f01d      	retw.n

4037a070 <pxPortInitialiseStack>:
{
4037a070:	004136        	entry	a1, 32
    configASSERT((uxStackPointer & portBYTE_ALIGNMENT_MASK) == 0);
4037a073:	348020        	extui	a8, a2, 0, 4
4037a076:	d88c      	beqz.n	a8, 4037a087 <pxPortInitialiseStack+0x17>
4037a078:	ead4d1        	l32r	a13, 40374bc8 <_iram_text_start+0x7c4> (3c024af8 <_flash_rodata_start+0x49d8>)
4037a07b:	ead4c1        	l32r	a12, 40374bcc <_iram_text_start+0x7c8> (3c028478 <__func__$4>)
4037a07e:	a1a1b2        	movi	a11, 0x1a1
4037a081:	ead3a1        	l32r	a10, 40374bd0 <_iram_text_start+0x7cc> (3c024b56 <_flash_rodata_start+0x4a36>)
4037a084:	05d1a5        	call8	4037fda0 <__assert_func>
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - XT_CP_SIZE);
4037a087:	c4ae82        	movi	a8, 0xfffffec4
4037a08a:	728a      	add.n	a7, a2, a8
4037a08c:	027c      	movi.n	a2, -16
4037a08e:	107720        	and	a7, a7, a2
    p[0] = 0;   // Clear XT_CPENABLE and XT_CPSTORED
4037a091:	050c      	movi.n	a5, 0
4037a093:	0759      	s32i.n	a5, a7, 0
    p[1] = 0;   // Clear XT_CP_CS_ST
4037a095:	1759      	s32i.n	a5, a7, 4
    p[2] = (uint32_t)ALIGNUP(XCHAL_TOTAL_SA_ALIGN, (uint32_t)uxStackPointer + 12);
4037a097:	1bc782        	addi	a8, a7, 27
4037a09a:	108820        	and	a8, a8, a2
4037a09d:	2789      	s32i.n	a8, a7, 8
    const uint32_t tls_area_size = ALIGNUP(16, (uint32_t)&_thread_local_end - (uint32_t)&_thread_local_start);
4037a09f:	eacd61        	l32r	a6, 40374bd4 <_iram_text_start+0x7d0> (3c02a53c <_esp_system_init_fn_array_end>)
4037a0a2:	ead1c1        	l32r	a12, 40374be8 <_iram_text_start+0x7e4> (3c02a54b <_esp_system_init_fn_array_end+0xf>)
4037a0a5:	c0cc60        	sub	a12, a12, a6
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - (UBaseType_t)tls_area_size);
4037a0a8:	10cc20        	and	a12, a12, a2
4037a0ab:	c077c0        	sub	a7, a7, a12
4037a0ae:	107720        	and	a7, a7, a2
    memcpy((void *)uxStackPointer, &_thread_local_start, tls_area_size);
4037a0b1:	06bd      	mov.n	a11, a6
4037a0b3:	20a770        	or	a10, a7, a7
4037a0b6:	e90781        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037a0b9:	0008e0        	callx8	a8
    const uint32_t base = ALIGNUP(tls_section_align, TCB_SIZE);
4037a0bc:	eac781        	l32r	a8, 40374bd8 <_iram_text_start+0x7d4> (10 <_flash_rodata_align>)
4037a0bf:	a87b      	addi.n	a10, a8, 7
4037a0c1:	609080        	neg	a9, a8
    *ret_threadptr_reg_init = (uint32_t)uxStackPointer - ((uint32_t)&_thread_local_start - (uint32_t)&_flash_rodata_start) - base;
4037a0c4:	c08760        	sub	a8, a7, a6
4037a0c7:	109a90        	and	a9, a10, a9
4037a0ca:	eac461        	l32r	a6, 40374bdc <_iram_text_start+0x7d8> (3c020120 <_flash_rodata_start>)
4037a0cd:	c06690        	sub	a6, a6, a9
4037a0d0:	668a      	add.n	a6, a6, a8
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - XT_STK_FRMSZ);
4037a0d2:	40af82        	movi	a8, -192
4037a0d5:	878a      	add.n	a8, a7, a8
4037a0d7:	102820        	and	a2, a8, a2
    memset((void *)uxStackPointer, 0, (size_t)(uxStackPointerPrevious - uxStackPointer));
4037a0da:	c0c720        	sub	a12, a7, a2
4037a0dd:	05bd      	mov.n	a11, a5
4037a0df:	20a220        	or	a10, a2, a2
4037a0e2:	e8eb81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037a0e5:	0008e0        	callx8	a8
    frame->a0 = 0;                                          // Set the return address to 0 terminate GDB backtrace
4037a0e8:	3259      	s32i.n	a5, a2, 12
    frame->a1 = uxStackPointer + XT_STK_FRMSZ;              // Saved stack pointer should point to physical top of stack frame
4037a0ea:	c0a082        	movi	a8, 192
4037a0ed:	828a      	add.n	a8, a2, a8
4037a0ef:	4289      	s32i.n	a8, a2, 16
    frame->exit = (UBaseType_t) _xt_user_exit;              // User exception exit dispatcher
4037a0f1:	e9a981        	l32r	a8, 40374798 <_iram_text_start+0x394> (40376da8 <_xt_user_exit>)
4037a0f4:	0289      	s32i.n	a8, a2, 0
        frame->pc = (UBaseType_t) vPortTaskWrapper;         // Task entry point is the wrapper function
4037a0f6:	eaba81        	l32r	a8, 40374be0 <_iram_text_start+0x7dc> (40379f78 <vPortTaskWrapper>)
4037a0f9:	1289      	s32i.n	a8, a2, 4
            frame->a6 = (UBaseType_t) pxCode;               // Wrapper function's argument 0 (which is the task function), passed as if we call4'd
4037a0fb:	9239      	s32i.n	a3, a2, 36
            frame->a7 = (UBaseType_t) pvParameters;         // Wrapper function's argument 1 (which is the task function's argument), passed as if we call4'd
4037a0fd:	a249      	s32i.n	a4, a2, 40
        frame->ps = PS_UM | PS_EXCM | PS_WOE | PS_CALLINC(1);
4037a0ff:	eab981        	l32r	a8, 40374be4 <_iram_text_start+0x7e0> (50030 <UserFrameTotalSize+0x4ff30>)
4037a102:	2289      	s32i.n	a8, a2, 8
    *threadptr_reg = threadptr_reg_init;
4037a104:	1c6262        	s32i	a6, a2, 112
}
4037a107:	f01d      	retw.n
4037a109:	000000        	ill

4037a10c <xPortInIsrContext>:
{
4037a10c:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a10f:	0063a0        	rsil	a10, 3
4037a112:	03eb80        	rsr.prid	a8
4037a115:	048d80        	extui	a8, a8, 13, 1
    ret = (port_interruptNesting[xPortGetCoreID()] != 0);
4037a118:	e98591        	l32r	a9, 4037472c <_iram_text_start+0x328> (3fc94f00 <port_interruptNesting>)
4037a11b:	a08890        	addx4	a8, a8, a9
4037a11e:	0888      	l32i.n	a8, a8, 0
4037a120:	01a022        	movi	a2, 1
4037a123:	832880        	moveqz	a2, a8, a8
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037a126:	eab181        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037a129:	0008e0        	callx8	a8
}
4037a12c:	f01d      	retw.n
	...

4037a130 <xPortEnterCriticalTimeout>:
{
4037a130:	006136        	entry	a1, 48
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a133:	006380        	rsil	a8, 3
4037a136:	006182        	s32i	a8, a1, 0
    // Unused if asserts are disabled
    uint32_t __attribute__((unused)) other_core_owner_id;
    bool lock_set;
    esp_cpu_cycle_count_t start_count;

    assert(lock);
4037a139:	00e256        	bnez	a2, 4037a14b <xPortEnterCriticalTimeout+0x1b>
4037a13c:	eaadd1        	l32r	a13, 40374bf0 <_iram_text_start+0x7ec> (3c022934 <_flash_rodata_start+0x2814>)
4037a13f:	eaadc1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028464 <__func__$2>)
4037a142:	eaada1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a145:	54a0b2        	movi	a11, 84
4037a148:	05c565        	call8	4037fda0 <__assert_func>
#if __XTENSA__
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a14b:	006350        	rsil	a5, 3
    asm volatile (
4037a14e:	03eb70        	rsr.prid	a7
     *  - If "our" core_owner_id, we can drop through immediately.
     *  - If "other_core_owner_id", we spin here.
     */

    // The caller is already the owner of the lock. Simply increment the nesting count
    if (lock->owner == core_owner_id) {
4037a151:	002292        	l32i	a9, a2, 0
4037a154:	259797        	bne	a7, a9, 4037a17d <xPortEnterCriticalTimeout+0x4d>
        assert(lock->count > 0 && lock->count < 0xFF);    // Bad count value implies memory corruption
4037a157:	1298      	l32i.n	a9, a2, 4
4037a159:	fda0b2        	movi	a11, 253
4037a15c:	a90b      	addi.n	a10, a9, -1
4037a15e:	0ebba7        	bgeu	a11, a10, 4037a170 <xPortEnterCriticalTimeout+0x40>
4037a161:	eaa6d1        	l32r	a13, 40374bfc <_iram_text_start+0x7f8> (3c024b60 <_flash_rodata_start+0x4a40>)
4037a164:	eaa4c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028464 <__func__$2>)
4037a167:	eaa4a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a16a:	6aa0b2        	movi	a11, 106
4037a16d:	05c325        	call8	4037fda0 <__assert_func>
        lock->count++;
4037a170:	991b      	addi.n	a9, a9, 1
4037a172:	1299      	s32i.n	a9, a2, 4
#if __XTENSA__
        XTOS_RESTORE_INTLEVEL(irq_status);
4037a174:	13e650        	wsr.ps	a5
4037a177:	002010        	rsync
#else
        rv_utils_restore_intlevel_regval(irq_status);
#endif
        return true;
4037a17a:	003346        	j	4037a24b <xPortEnterCriticalTimeout+0x11b>
     * Note: We do a first attempt separately (instead of putting this into a loop) in order to avoid call to
     * esp_cpu_get_cycle_count(). This doing a first attempt separately makes acquiring a free lock quicker, which
     * is the case for the majority of spinlock_acquire() calls (as spinlocks are free most of the time since they
     * aren't meant to be held for long).
     */
    lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a17d:	ea6eb1        	l32r	a11, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a180:	20c770        	or	a12, a7, a7
4037a183:	20a220        	or	a10, a2, a2
4037a186:	fe0225        	call8	403781a8 <esp_cpu_compare_and_set>
    if (lock_set || timeout == SPINLOCK_NO_WAIT) {
4037a189:	53bc      	beqz.n	a3, 4037a1c2 <xPortEnterCriticalTimeout+0x92>
4037a18b:	3afc      	bnez.n	a10, 4037a1c2 <xPortEnterCriticalTimeout+0x92>
    RSR(CCOUNT, ccount);
4037a18d:	03ea40        	rsr.ccount	a4
    }

    // First attempt to take the lock has failed. Retry until the lock is taken, or until we timeout.
    start_count = esp_cpu_get_cycle_count();
    do {
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a190:	ea6a61        	l32r	a6, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a193:	190326        	beqi	a3, -1, 4037a1b0 <xPortEnterCriticalTimeout+0x80>
4037a196:	07cd      	mov.n	a12, a7
4037a198:	06bd      	mov.n	a11, a6
4037a19a:	20a220        	or	a10, a2, a2
4037a19d:	fe00a5        	call8	403781a8 <esp_cpu_compare_and_set>
        if (lock_set) {
4037a1a0:	0d5a56        	bnez	a10, 4037a279 <xPortEnterCriticalTimeout+0x149>
4037a1a3:	03ea90        	rsr.ccount	a9
            break;
        }
        // Keep looping if we are waiting forever, or check if we have timed out
    } while ((timeout == SPINLOCK_WAIT_FOREVER) || (esp_cpu_get_cycle_count() - start_count) <= (esp_cpu_cycle_count_t)timeout);
4037a1a6:	c09940        	sub	a9, a9, a4
4037a1a9:	e9b397        	bgeu	a3, a9, 4037a196 <xPortEnterCriticalTimeout+0x66>
4037a1ac:	003106        	j	4037a274 <xPortEnterCriticalTimeout+0x144>
4037a1af:	c77000        	lsi	f0, a0, 0x31c
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a1b2:	b66020        	lsi	f2, a0, 0x2d8
4037a1b5:	a22020        	muluh	a2, a0, a2
4037a1b8:	fee520        	f64iter	a14, a5, a2, 3, 1
4037a1bb:	16fd      	lsi	f15, a6, 24
        if (lock_set) {
4037a1bd:	ff0a      	add.n	a15, a15, a0

exit:
4037a1bf:	002d86        	j	4037a279 <xPortEnterCriticalTimeout+0x149>
    if (lock_set) {
        assert(lock->owner == core_owner_id);
4037a1c2:	002292        	l32i	a9, a2, 0
    if (lock_set) {
4037a1c5:	034a16        	beqz	a10, 4037a1fd <xPortEnterCriticalTimeout+0xcd>
        assert(lock->owner == core_owner_id);
4037a1c8:	0e1797        	beq	a7, a9, 4037a1da <xPortEnterCriticalTimeout+0xaa>
4037a1cb:	ea8dd1        	l32r	a13, 40374c00 <_iram_text_start+0x7fc> (3c024b88 <_flash_rodata_start+0x4a68>)
4037a1ce:	ea89c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028464 <__func__$2>)
4037a1d1:	ea89a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a1d4:	8da0b2        	movi	a11, 141
4037a1d7:	05bca5        	call8	4037fda0 <__assert_func>
        assert(lock->count == 0);   // This is the first time the lock is set, so count should still be 0
4037a1da:	1298      	l32i.n	a9, a2, 4
4037a1dc:	d98c      	beqz.n	a9, 4037a1ed <xPortEnterCriticalTimeout+0xbd>
4037a1de:	ea89d1        	l32r	a13, 40374c04 <_iram_text_start+0x800> (3c024ba8 <_flash_rodata_start+0x4a88>)
4037a1e1:	ea84c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028464 <__func__$2>)
4037a1e4:	ea85a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a1e7:	8ea0b2        	movi	a11, 142
4037a1ea:	05bb65        	call8	4037fda0 <__assert_func>
        lock->count++;  // Finally, we increment the lock count
4037a1ed:	190c      	movi.n	a9, 1
4037a1ef:	1299      	s32i.n	a9, a2, 4
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_owner_id);
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
    }

#if __XTENSA__
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a1f1:	13e650        	wsr.ps	a5
4037a1f4:	002010        	rsync
#else
    rv_utils_restore_intlevel_regval(irq_status);
#endif
    return lock_set;
4037a1f7:	001406        	j	4037a24b <xPortEnterCriticalTimeout+0x11b>
4037a1fa:	000000        	ill
    other_core_owner_id = CORE_ID_REGVAL_XOR_SWAP ^ core_owner_id;
4037a1fd:	ea82a1        	l32r	a10, 40374c08 <_iram_text_start+0x804> (6666 <UserFrameTotalSize+0x6566>)
4037a200:	30a7a0        	xor	a10, a7, a10
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_owner_id);
4037a203:	171a97        	beq	a10, a9, 4037a21e <xPortEnterCriticalTimeout+0xee>
4037a206:	ea4ca1        	l32r	a10, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a209:	1119a7        	beq	a9, a10, 4037a21e <xPortEnterCriticalTimeout+0xee>
4037a20c:	ea80d1        	l32r	a13, 40374c0c <_iram_text_start+0x808> (3c024bbc <_flash_rodata_start+0x4a9c>)
4037a20f:	ea79c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028464 <__func__$2>)
4037a212:	ea79a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a215:	91a0b2        	movi	a11, 145
4037a218:	201110        	or	a1, a1, a1
4037a21b:	05b865        	call8	4037fda0 <__assert_func>
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
4037a21e:	012282        	l32i	a8, a2, 4
4037a221:	fea092        	movi	a9, 254
4037a224:	0eb987        	bgeu	a9, a8, 4037a236 <xPortEnterCriticalTimeout+0x106>
4037a227:	ea7ad1        	l32r	a13, 40374c10 <_iram_text_start+0x80c> (3c024c00 <_flash_rodata_start+0x4ae0>)
4037a22a:	ea72c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028464 <__func__$2>)
4037a22d:	ea72a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a230:	92a0b2        	movi	a11, 146
4037a233:	05b6e5        	call8	4037fda0 <__assert_func>
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a236:	13e650        	wsr.ps	a5
4037a239:	002010        	rsync
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037a23c:	0021a2        	l32i	a10, a1, 0
        return pdFAIL;
4037a23f:	00a022        	movi	a2, 0
4037a242:	ea6a81        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037a245:	0008e0        	callx8	a8
4037a248:	000c86        	j	4037a27e <xPortEnterCriticalTimeout+0x14e>
    asm volatile (
4037a24b:	03eb80        	rsr.prid	a8
4037a24e:	048d80        	extui	a8, a8, 13, 1
    BaseType_t newNesting = port_uxCriticalNesting[coreID] + 1;
4037a251:	ea7091        	l32r	a9, 40374c14 <_iram_text_start+0x810> (3fc94ef8 <port_uxCriticalNesting>)
4037a254:	11a8e0        	slli	a10, a8, 2
4037a257:	a08890        	addx4	a8, a8, a9
4037a25a:	0898      	l32i.n	a9, a8, 0
4037a25c:	991b      	addi.n	a9, a9, 1
    port_uxCriticalNesting[coreID] = newNesting;
4037a25e:	0899      	s32i.n	a9, a8, 0
    if ( newNesting == 1 ) {
4037a260:	041926        	beqi	a9, 1, 4037a268 <xPortEnterCriticalTimeout+0x138>
    return pdPASS;
4037a263:	120c      	movi.n	a2, 1
4037a265:	000546        	j	4037a27e <xPortEnterCriticalTimeout+0x14e>
        port_uxOldInterruptState[coreID] = xOldInterruptLevel;
4037a268:	ea6c81        	l32r	a8, 40374c18 <_iram_text_start+0x814> (3fc94ef0 <port_uxOldInterruptState>)
4037a26b:	0198      	l32i.n	a9, a1, 0
4037a26d:	88aa      	add.n	a8, a8, a10
4037a26f:	0899      	s32i.n	a9, a8, 0
4037a271:	fffb86        	j	4037a263 <xPortEnterCriticalTimeout+0x133>
        assert(lock->owner == core_owner_id);
4037a274:	0298      	l32i.n	a9, a2, 0
4037a276:	ffe0c6        	j	4037a1fd <xPortEnterCriticalTimeout+0xcd>
4037a279:	0298      	l32i.n	a9, a2, 0
4037a27b:	ffd246        	j	4037a1c8 <xPortEnterCriticalTimeout+0x98>
}
4037a27e:	f01d      	retw.n

4037a280 <vPortExitCritical>:
{
4037a280:	004136        	entry	a1, 32
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE && !BOOTLOADER_BUILD
    uint32_t irq_status;
    // Return value unused if asserts are disabled
    uint32_t __attribute__((unused)) core_owner_id;

    assert(lock);
4037a283:	00e256        	bnez	a2, 4037a295 <vPortExitCritical+0x15>
4037a286:	ea5ad1        	l32r	a13, 40374bf0 <_iram_text_start+0x7ec> (3c022934 <_flash_rodata_start+0x2814>)
4037a289:	ea64c1        	l32r	a12, 40374c1c <_iram_text_start+0x818> (3c02843c <__func__$0>)
4037a28c:	ea5ba1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a28f:	b5a0b2        	movi	a11, 181
4037a292:	05b0e5        	call8	4037fda0 <__assert_func>
#if __XTENSA__
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a295:	0063a0        	rsil	a10, 3
    asm volatile (
4037a298:	03eb90        	rsr.prid	a9
    core_owner_id = xt_utils_get_raw_core_id();
#else
    irq_status = rv_utils_set_intlevel_regval(RVHAL_EXCM_LEVEL_CLIC);
    core_owner_id = rv_utils_get_core_id() == 0 ? SPINLOCK_OWNER_ID_0 : SPINLOCK_OWNER_ID_1;
#endif
    assert(core_owner_id == lock->owner); // This is a lock that we didn't acquire, or the lock is corrupt
4037a29b:	0288      	l32i.n	a8, a2, 0
4037a29d:	111987        	beq	a9, a8, 4037a2b2 <vPortExitCritical+0x32>
4037a2a0:	ea60d1        	l32r	a13, 40374c20 <_iram_text_start+0x81c> (3c024c14 <_flash_rodata_start+0x4af4>)
4037a2a3:	ea5ec1        	l32r	a12, 40374c1c <_iram_text_start+0x818> (3c02843c <__func__$0>)
4037a2a6:	ea54a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a2a9:	bea0b2        	movi	a11, 190
4037a2ac:	201110        	or	a1, a1, a1
4037a2af:	05af25        	call8	4037fda0 <__assert_func>
    lock->count--;
4037a2b2:	1288      	l32i.n	a8, a2, 4
4037a2b4:	880b      	addi.n	a8, a8, -1
4037a2b6:	1289      	s32i.n	a8, a2, 4

    if (!lock->count) { // If this is the last recursive release of the lock, mark the lock as free
4037a2b8:	98cc      	bnez.n	a8, 4037a2c5 <vPortExitCritical+0x45>
        lock->owner = SPINLOCK_FREE;
4037a2ba:	ea1f81        	l32r	a8, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a2bd:	0289      	s32i.n	a8, a2, 0
4037a2bf:	0005c6        	j	4037a2da <vPortExitCritical+0x5a>
4037a2c2:	000000        	ill
    } else {
        assert(lock->count < 0x100); // Indicates memory corruption
4037a2c5:	ffa092        	movi	a9, 255
4037a2c8:	0eb987        	bgeu	a9, a8, 4037a2da <vPortExitCritical+0x5a>
4037a2cb:	ea56d1        	l32r	a13, 40374c24 <_iram_text_start+0x820> (3c024c34 <_flash_rodata_start+0x4b14>)
4037a2ce:	ea53c1        	l32r	a12, 40374c1c <_iram_text_start+0x818> (3c02843c <__func__$0>)
4037a2d1:	ea49a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a2d4:	c4a0b2        	movi	a11, 196
4037a2d7:	05aca5        	call8	4037fda0 <__assert_func>
    }

#if __XTENSA__
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a2da:	13e6a0        	wsr.ps	a10
4037a2dd:	002010        	rsync
    asm volatile (
4037a2e0:	03eb80        	rsr.prid	a8
4037a2e3:	048d80        	extui	a8, a8, 13, 1
    BaseType_t nesting = port_uxCriticalNesting[coreID];
4037a2e6:	ea4b91        	l32r	a9, 40374c14 <_iram_text_start+0x810> (3fc94ef8 <port_uxCriticalNesting>)
4037a2e9:	11a8e0        	slli	a10, a8, 2
4037a2ec:	a08890        	addx4	a8, a8, a9
4037a2ef:	0898      	l32i.n	a9, a8, 0
    configASSERT( nesting > 0 );
4037a2f1:	1119e6        	bgei	a9, 1, 4037a306 <vPortExitCritical+0x86>
4037a2f4:	ea4dd1        	l32r	a13, 40374c28 <_iram_text_start+0x824> (3c024c48 <_flash_rodata_start+0x4b28>)
4037a2f7:	ea4dc1        	l32r	a12, 40374c2c <_iram_text_start+0x828> (3c028450 <__func__$1>)
4037a2fa:	ea35a1        	l32r	a10, 40374bd0 <_iram_text_start+0x7cc> (3c024b56 <_flash_rodata_start+0x4a36>)
4037a2fd:	faa1b2        	movi	a11, 0x1fa
4037a300:	201110        	or	a1, a1, a1
4037a303:	05a9e5        	call8	4037fda0 <__assert_func>
        nesting--;
4037a306:	990b      	addi.n	a9, a9, -1
        port_uxCriticalNesting[coreID] = nesting;
4037a308:	0899      	s32i.n	a9, a8, 0
        if ( nesting == 0 ) {
4037a30a:	b9cc      	bnez.n	a9, 4037a319 <vPortExitCritical+0x99>
            portCLEAR_INTERRUPT_MASK_FROM_ISR(port_uxOldInterruptState[coreID]);
4037a30c:	ea4381        	l32r	a8, 40374c18 <_iram_text_start+0x814> (3fc94ef0 <port_uxOldInterruptState>)
4037a30f:	88aa      	add.n	a8, a8, a10
4037a311:	08a8      	l32i.n	a10, a8, 0
4037a313:	ea3681        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037a316:	0008e0        	callx8	a8
}
4037a319:	f01d      	retw.n
	...

4037a31c <vPortYieldOtherCore>:
{
4037a31c:	004136        	entry	a1, 32
4037a31f:	02ad      	mov.n	a10, a2
    esp_crosscore_int_send_yield( coreid );
4037a321:	fddaa5        	call8	403780cc <esp_crosscore_int_send_yield>
}
4037a324:	f01d      	retw.n
	...

4037a328 <vApplicationStackOverflowHook>:
{
4037a328:	010136        	entry	a1, 128
    const char *str[] = {ERR_STR1, pcTaskName, ERR_STR2};
4037a32b:	ea4181        	l32r	a8, 40374c30 <_iram_text_start+0x82c> (3c024c54 <_flash_rodata_start+0x4b34>)
4037a32e:	0189      	s32i.n	a8, a1, 0
4037a330:	1139      	s32i.n	a3, a1, 4
4037a332:	ea4081        	l32r	a8, 40374c34 <_iram_text_start+0x830> (3c024c7c <_flash_rodata_start+0x4b5c>)
4037a335:	2189      	s32i.n	a8, a1, 8
    char buf[sizeof(ERR_STR1) + CONFIG_FREERTOS_MAX_TASK_NAME_LEN + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037a337:	71cb      	addi.n	a7, a1, 12
4037a339:	bc4c      	movi.n	a12, 75
4037a33b:	0b0c      	movi.n	a11, 0
4037a33d:	07ad      	mov.n	a10, a7
4037a33f:	e85481        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037a342:	0008e0        	callx8	a8
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a345:	060c      	movi.n	a6, 0
    char *dest = buf;
4037a347:	07ad      	mov.n	a10, a7
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a349:	0003c6        	j	4037a35c <vApplicationStackOverflowHook+0x34>
4037a34c:	861000        	lsi	f0, a0, 0x218
        dest = strcat(dest, str[i]);
4037a34f:	28b2a0        	lsi	f10, a2, 160
4037a352:	398100        	lsi	f0, a1, 228
4037a355:	e0ea      	add.n	a14, a0, a14
4037a357:	0008      	l32i.n	a0, a0, 0
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a359:	01c662        	addi	a6, a6, 1
4037a35c:	ed36b6        	bltui	a6, 3, 4037a34d <vApplicationStackOverflowHook+0x25>
    esp_system_abort(buf);
4037a35f:	0cc1a2        	addi	a10, a1, 12
4037a362:	ff42a5        	call8	4037978c <esp_system_abort>
4037a365:	000000        	ill

4037a368 <vPortTCBPreDeleteHook>:
#endif /* XCHAL_CP_NUM > 0 */

void vPortTCBPreDeleteHook( void *pxTCB )
{
4037a368:	004136        	entry	a1, 32
        vPortCleanUpTCB( pxTCB );
    #endif /* CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP */

    #if ( CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS )
        /* Call TLS pointers deletion callbacks */
        vPortTLSPointersDelCb( pxTCB );
4037a36b:	20a220        	or	a10, a2, a2
4037a36e:	ffc325        	call8	40379fa0 <vPortTLSPointersDelCb>
    #endif /* CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS */

    #if ( XCHAL_CP_NUM > 0 )
        /* Cleanup coproc save area */
        vPortCleanUpCoprocArea( pxTCB );
4037a371:	20a220        	or	a10, a2, a2
4037a374:	ffcb65        	call8	4037a02c <vPortCleanUpCoprocArea>
    #endif /* XCHAL_CP_NUM > 0 */
}
4037a377:	000090        	retw
	...

4037a37c <_frxt_setup_switch>:
    .global     _frxt_setup_switch
    .type       _frxt_setup_switch,@function
    .align      4
_frxt_setup_switch:

    ENTRY(16)
4037a37c:	002136        	entry	a1, 16

    getcoreid a3
4037a37f:	03eb30        	rsr.prid	a3
4037a382:	043d30        	extui	a3, a3, 13, 1
    movi    a2, port_switch_flag
4037a385:	ea2d21        	l32r	a2, 40374c3c <_iram_text_start+0x838> (3fc94ee8 <port_switch_flag>)
    addx4   a2,  a3, a2
4037a388:	a02320        	addx4	a2, a3, a2
    movi    a3, 1
4037a38b:	130c      	movi.n	a3, 1
    s32i    a3, a2, 0
4037a38d:	0239      	s32i.n	a3, a2, 0

    RET(16)
4037a38f:	f01d      	retw.n
4037a391:	000000        	ill

4037a394 <_frxt_int_enter>:
    .type   _frxt_int_enter,@function
    .align  4
_frxt_int_enter:

    /* Save a12-13 in the stack frame as required by _xt_context_save. */
    s32i    a12, a1, XT_STK_A12
4037a394:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, a1, XT_STK_A13
4037a396:	1061d2        	s32i	a13, a1, 64

    /* Save return address in a safe place (free a0). */
    mov     a12, a0
4037a399:	00cd      	mov.n	a12, a0

    /* Save the rest of the interrupted context (preserves A12-13). */
    call0   _xt_context_save
4037a39b:	079c85        	call0	40381d64 <_xt_context_save>
    /*
    Save interrupted task's SP in TCB only if not nesting.
    Manage nesting directly rather than call the generic IntEnter()
    (in windowed ABI we can't call a C function here anyway because PS.EXCM is still set).
    */
    getcoreid a4
4037a39e:	03eb40        	rsr.prid	a4
4037a3a1:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
4037a3a4:	ea0821        	l32r	a2, 40374bc4 <_iram_text_start+0x7c0> (3fc94f08 <port_xSchedulerRunning>)
    addx4   a2,  a4, a2
4037a3a7:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
4037a3aa:	e8e031        	l32r	a3, 4037472c <_iram_text_start+0x328> (3fc94f00 <port_interruptNesting>)
    addx4   a3,  a4, a3
4037a3ad:	a03430        	addx4	a3, a4, a3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
4037a3b0:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* scheduler not running, no tasks */
4037a3b2:	e29c      	beqz.n	a2, 4037a3d4 <_frxt_int_enter+0x40>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
4037a3b4:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, 1                  /* increment nesting count         */
4037a3b6:	221b      	addi.n	a2, a2, 1
    s32i    a2,  a3, 0                  /* save nesting count              */
4037a3b8:	0329      	s32i.n	a2, a3, 0
    bnei    a2,  1, .Lnested            /* !=0 before incr, so nested      */
4037a3ba:	161266        	bnei	a2, 1, 4037a3d4 <_frxt_int_enter+0x40>

    movi    a2,  pxCurrentTCBs
4037a3bd:	ea2021        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    addx4   a2,  a4, a2
4037a3c0:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
4037a3c3:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f
4037a3c5:	b28c      	beqz.n	a2, 4037a3d4 <_frxt_int_enter+0x40>
    s32i    a1,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCBs->pxTopOfStack = SP */
4037a3c7:	0219      	s32i.n	a1, a2, 0
    movi    a1,  port_IntStack+configISR_STACK_SIZE   /* a1 = top of intr stack for CPU 0  */
4037a3c9:	ea1e11        	l32r	a1, 40374c44 <_iram_text_start+0x840> (3fc93060 <port_IntStack+0x600>)
    movi    a2,  configISR_STACK_SIZE   /* add configISR_STACK_SIZE * cpu_num to arrive at top of stack for cpu_num */
4037a3cc:	00a622        	movi	a2, 0x600
    mull    a2,  a4, a2
4037a3cf:	822420        	mull	a2, a4, a2
    add     a1,  a1, a2                 /* for current proc */
4037a3d2:	112a      	add.n	a1, a1, a2
    movi    a3,  0              /* whilst ISRs pending keep CPENABLE exception active */
    wsr     a3,  CPENABLE
    rsync
    #endif

    mov     a0,  a12                    /* restore return addr and return  */
4037a3d4:	0c0d      	mov.n	a0, a12
    ret
4037a3d6:	f00d      	ret.n

4037a3d8 <_frxt_int_exit>:
    .globl  _frxt_int_exit
    .type   _frxt_int_exit,@function
    .align  4
_frxt_int_exit:

    getcoreid a4
4037a3d8:	03eb40        	rsr.prid	a4
4037a3db:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
4037a3de:	e9f921        	l32r	a2, 40374bc4 <_iram_text_start+0x7c0> (3fc94f08 <port_xSchedulerRunning>)
    addx4   a2,  a4, a2
4037a3e1:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
4037a3e4:	e8d231        	l32r	a3, 4037472c <_iram_text_start+0x328> (3fc94f00 <port_interruptNesting>)
    addx4   a3,  a4, a3
4037a3e7:	a03430        	addx4	a3, a4, a3
    rsil    a0,  XCHAL_EXCM_LEVEL       /* lock out interrupts             */
4037a3ea:	006300        	rsil	a0, 3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
4037a3ed:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  .Lnoswitch             /* scheduler not running, no tasks */
4037a3ef:	e2ac      	beqz.n	a2, 4037a421 <_frxt_int_exit+0x49>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
4037a3f1:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, -1                 /* decrement nesting count         */
4037a3f3:	220b      	addi.n	a2, a2, -1
    s32i    a2,  a3, 0                  /* save nesting count              */
4037a3f5:	0329      	s32i.n	a2, a3, 0
    bnez    a2,  .Lnesting              /* !=0 after decr so still nested  */
4037a3f7:	62ec      	bnez.n	a2, 4037a421 <_frxt_int_exit+0x49>
    addi    sp,  sp, 4
    wsr     a3, CPENABLE
    rsync                               /* ensure CPENABLE was modified */
    #endif

    movi    a2,  pxCurrentTCBs
4037a3f9:	ea1121        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    addx4   a2,  a4, a2
4037a3fc:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
4037a3ff:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* no task ? go to dispatcher      */
4037a401:	029c      	beqz.n	a2, 4037a415 <_frxt_int_exit+0x3d>
    l32i    a1,  a2, TOPOFSTACK_OFFS    /* SP = pxCurrentTCBs->pxTopOfStack */
4037a403:	0218      	l32i.n	a1, a2, 0

    movi    a2,  port_switch_flag       /* address of switch flag          */
4037a405:	ea0d21        	l32r	a2, 40374c3c <_iram_text_start+0x838> (3fc94ee8 <port_switch_flag>)
    addx4   a2,  a4, a2                 /* point to flag for this cpu      */
4037a408:	a02420        	addx4	a2, a4, a2
    l32i    a3,  a2, 0                  /* a3 = port_switch_flag           */
4037a40b:	0238      	l32i.n	a3, a2, 0
    beqz    a3,  .Lnoswitch             /* flag = 0 means no switch reqd   */
4037a40d:	039c      	beqz.n	a3, 4037a421 <_frxt_int_exit+0x49>
    movi    a3,  0
4037a40f:	00a032        	movi	a3, 0
    s32i    a3,  a2, 0                  /* zero out the flag for next time */
4037a412:	006232        	s32i	a3, a2, 0
    #endif

    #ifdef __XTENSA_CALL0_ABI__
    call0   vPortYieldFromInt       /* call dispatch inside the function; never returns */
    #else
    call4   vPortYieldFromInt       /* this one returns */
4037a415:	201110        	or	a1, a1, a1
4037a418:	000d55        	call4	4037a4f0 <vPortYieldFromInt>
    call0   _frxt_dispatch          /* tail-call dispatcher */
4037a41b:	201110        	or	a1, a1, a1
4037a41e:	000085        	call0	4037a428 <_frxt_dispatch>
    is a nested interrupt, or the interrupted task was not preempted.
    In either case there's no need to load the SP.
    */

    /* Restore full context from interrupt stack frame */
    call0   _xt_context_restore
4037a421:	079e45        	call0	40381e08 <_xt_context_restore>
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0,  a1, XT_STK_EXIT
4037a424:	0108      	l32i.n	a0, a1, 0
    ret
4037a426:	f00d      	ret.n

4037a428 <_frxt_dispatch>:
    call0   vTaskSwitchContext  // Get next TCB to resume
    movi    a2, pxCurrentTCBs
    getcoreid a3
    addx4   a2,  a3, a2
    #else
    call4   vTaskSwitchContext  // Get next TCB to resume
4037a428:	010a55        	call4	4037b4d0 <vTaskSwitchContext>
    movi    a2, pxCurrentTCBs
4037a42b:	ea0521        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    getcoreid a3
4037a42e:	03eb30        	rsr.prid	a3
4037a431:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
4037a434:	a02320        	addx4	a2, a3, a2
    #endif
    l32i    a3,  a2, 0
4037a437:	002232        	l32i	a3, a2, 0
    l32i    sp,  a3, TOPOFSTACK_OFFS     /* SP = next_TCB->pxTopOfStack;  */
4037a43a:	002312        	l32i	a1, a3, 0
    s32i    a3,  a2, 0
4037a43d:	006232        	s32i	a3, a2, 0

    /* Determine the type of stack frame. */
    l32i    a2,  sp, XT_STK_EXIT        /* exit dispatcher or solicited flag */
4037a440:	0128      	l32i.n	a2, a1, 0
    bnez    a2,  .L_frxt_dispatch_stk
4037a442:	f2cc      	bnez.n	a2, 4037a455 <_frxt_dispatch+0x2d>

.L_frxt_dispatch_sol:

    /* Solicited stack frame. Restore minimal context and return from vPortYield(). */
    #if XCHAL_HAVE_THREADPTR
    l32i    a2,  sp, XT_SOL_THREADPTR
4037a444:	3128      	l32i.n	a2, a1, 12
    wur.threadptr a2
4037a446:	f3e720        	wur.threadptr	a2
    #endif
    l32i    a3,  sp, XT_SOL_PS
4037a449:	2138      	l32i.n	a3, a1, 8
    l32i    a12, sp, XT_SOL_A12
    l32i    a13, sp, XT_SOL_A13
    l32i    a14, sp, XT_SOL_A14
    l32i    a15, sp, XT_SOL_A15
    #endif
    l32i    a0,  sp, XT_SOL_PC
4037a44b:	1108      	l32i.n	a0, a1, 4
    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE is complete (should be, it was cleared on entry). */
    rsync
4037a44d:	002010        	rsync
    #endif
    /* As soons as PS is restored, interrupts can happen. No need to sync PS. */
    wsr     a3,  PS
4037a450:	13e630        	wsr.ps	a3
    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, XT_SOL_FRMSZ
    ret
    #else
    retw
4037a453:	f01d      	retw.n

.L_frxt_dispatch_stk:

    #if XCHAL_CP_NUM > 0
    /* Restore CPENABLE from task's co-processor save area. */
    movi    a2, pxCurrentTCBs           /* cp_state =                       */
4037a455:	e9fa21        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    getcoreid a3
4037a458:	03eb30        	rsr.prid	a3
4037a45b:	043d30        	extui	a3, a3, 13, 1
    addx4   a2, a3, a2
4037a45e:	a02320        	addx4	a2, a3, a2
    l32i    a2, a2, 0
4037a461:	002222        	l32i	a2, a2, 0
    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a464:	e9f931        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93668 <offset_pxEndOfStack>)
4037a467:	002332        	l32i	a3, a3, 0
4037a46a:	802230        	add	a2, a2, a3
4037a46d:	0228      	l32i.n	a2, a2, 0
4037a46f:	e9f731        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93664 <offset_cpsa>)
4037a472:	0338      	l32i.n	a3, a3, 0
4037a474:	c02230        	sub	a2, a2, a3
4037a477:	037c      	movi.n	a3, -16
4037a479:	102230        	and	a2, a2, a3
    l16ui   a3, a2, XT_CPENABLE         /* CPENABLE = cp_state->cpenable;   */
4037a47c:	001232        	l16ui	a3, a2, 0
    wsr     a3, CPENABLE
4037a47f:	13e030        	wsr.cpenable	a3
    #endif

    /* Interrupt stack frame. Restore full context and return to exit dispatcher. */
    call0   _xt_context_restore
4037a482:	079845        	call0	40381e08 <_xt_context_restore>
    l32i    a15, sp, XT_STK_A15
    #endif

    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE has completed. */
    rsync
4037a485:	002010        	rsync
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0, sp, XT_STK_EXIT
4037a488:	0108      	l32i.n	a0, a1, 0
    ret
4037a48a:	f00d      	ret.n

4037a48c <vPortYield>:
vPortYield:

    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, -XT_SOL_FRMSZ
    #else
    entry   sp,  XT_SOL_FRMSZ
4037a48c:	004136        	entry	a1, 32
    #endif

    rsr     a2,  PS
4037a48f:	03e620        	rsr.ps	a2
    s32i    a0,  sp, XT_SOL_PC
4037a492:	1109      	s32i.n	a0, a1, 4
    s32i    a2,  sp, XT_SOL_PS
4037a494:	2129      	s32i.n	a2, a1, 8
    #if XCHAL_HAVE_THREADPTR
    rur.threadptr a2
4037a496:	e32e70        	rur.threadptr	a2
    s32i    a2,  sp, XT_SOL_THREADPTR
4037a499:	3129      	s32i.n	a2, a1, 12
    s32i    a15, sp, XT_SOL_A15
    #else
    /* Spill register windows. Calling xthal_window_spill() causes extra    */
    /* spills and reloads, so we will set things up to call the _nw version */
    /* instead to save cycles.                                              */
    movi    a6,  ~(PS_WOE_MASK|PS_INTLEVEL_MASK)  /* spills a4-a7 if needed */
4037a49b:	e9ed61        	l32r	a6, 40374c50 <_iram_text_start+0x84c> (fffbfff0 <_rtc_reserved_end+0x9febfff0>)
    and     a2,  a2, a6                           /* clear WOE, INTLEVEL    */
4037a49e:	102260        	and	a2, a2, a6
    addi    a2,  a2, XCHAL_EXCM_LEVEL             /* set INTLEVEL           */
4037a4a1:	03c222        	addi	a2, a2, 3
    wsr     a2,  PS
4037a4a4:	13e620        	wsr.ps	a2
    rsync
4037a4a7:	002010        	rsync
    call0   xthal_window_spill_nw
4037a4aa:	077205        	call0	40381bcc <xthal_window_spill_nw>
    l32i    a2,  sp, XT_SOL_PS                    /* restore PS             */
4037a4ad:	2128      	l32i.n	a2, a1, 8
    wsr     a2,  PS
4037a4af:	13e620        	wsr.ps	a2
    #endif

    rsil    a2,  XCHAL_EXCM_LEVEL       /* disable low/med interrupts       */
4037a4b2:	006320        	rsil	a2, 3

    #if XCHAL_CP_NUM > 0
    /* Save coprocessor callee-saved state (if any). At this point CPENABLE */
    /* should still reflect which CPs were in use (enabled).                */
    call0   _xt_coproc_savecs
4037a4b5:	079f05        	call0	40381ea8 <_xt_coproc_savecs>
    #endif

    movi    a2,  pxCurrentTCBs
4037a4b8:	e9e221        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    getcoreid a3
4037a4bb:	03eb30        	rsr.prid	a3
4037a4be:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
4037a4c1:	a02320        	addx4	a2, a3, a2
    l32i    a2,  a2, 0                  /* a2 = pxCurrentTCBs                */
4037a4c4:	0228      	l32i.n	a2, a2, 0
    movi    a3,  0
4037a4c6:	030c      	movi.n	a3, 0
    s32i    a3,  sp, XT_SOL_EXIT        /* 0 to flag as solicited frame     */
4037a4c8:	0139      	s32i.n	a3, a1, 0
    s32i    sp,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCBs->pxTopOfStack = SP  */
4037a4ca:	0219      	s32i.n	a1, a2, 0

    #if XCHAL_CP_NUM > 0
    /* Clear CPENABLE, also in task's co-processor state save area. */
    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a4cc:	e9df31        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93668 <offset_pxEndOfStack>)
4037a4cf:	0338      	l32i.n	a3, a3, 0
4037a4d1:	223a      	add.n	a2, a2, a3
4037a4d3:	0228      	l32i.n	a2, a2, 0
4037a4d5:	e9dd31        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93664 <offset_cpsa>)
4037a4d8:	0338      	l32i.n	a3, a3, 0
4037a4da:	c02230        	sub	a2, a2, a3
4037a4dd:	037c      	movi.n	a3, -16
4037a4df:	102230        	and	a2, a2, a3
    movi    a3,  0
4037a4e2:	030c      	movi.n	a3, 0
    wsr     a3,  CPENABLE
4037a4e4:	13e030        	wsr.cpenable	a3
    beqz    a2,  1f
4037a4e7:	002216        	beqz	a2, 4037a4ed <vPortYield+0x61>
    s16i    a3,  a2, XT_CPENABLE        /* clear saved cpenable             */
4037a4ea:	005232        	s16i	a3, a2, 0
1:
    #endif

    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
4037a4ed:	fff385        	call0	4037a428 <_frxt_dispatch>

4037a4f0 <vPortYieldFromInt>:
    .globl  vPortYieldFromInt
    .type   vPortYieldFromInt,@function
    .align  4
vPortYieldFromInt:

    ENTRY(16)
4037a4f0:	002136        	entry	a1, 16

    #if XCHAL_CP_NUM > 0
    /* Save CPENABLE in task's co-processor save area, and clear CPENABLE.  */
    movi    a2, pxCurrentTCBs           /* cp_state =                       */
4037a4f3:	e9d321        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    getcoreid a3
4037a4f6:	03eb30        	rsr.prid	a3
4037a4f9:	043d30        	extui	a3, a3, 13, 1
    addx4   a2, a3, a2
4037a4fc:	a02320        	addx4	a2, a3, a2
    l32i    a2, a2, 0
4037a4ff:	0228      	l32i.n	a2, a2, 0

    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a501:	e9d131        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93668 <offset_pxEndOfStack>)
4037a504:	0338      	l32i.n	a3, a3, 0
4037a506:	223a      	add.n	a2, a2, a3
4037a508:	0228      	l32i.n	a2, a2, 0
4037a50a:	e9d031        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93664 <offset_cpsa>)
4037a50d:	0338      	l32i.n	a3, a3, 0
4037a50f:	c02230        	sub	a2, a2, a3
4037a512:	037c      	movi.n	a3, -16
4037a514:	102230        	and	a2, a2, a3

    rsr     a3, CPENABLE
4037a517:	03e030        	rsr.cpenable	a3
    s16i    a3, a2, XT_CPENABLE         /* cp_state->cpenable = CPENABLE;   */
4037a51a:	005232        	s16i	a3, a2, 0
    movi    a3, 0
4037a51d:	030c      	movi.n	a3, 0
    wsr     a3, CPENABLE                /* disable all co-processors        */
4037a51f:	13e030        	wsr.cpenable	a3
    #ifdef __XTENSA_CALL0_ABI__
    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
    /* Never reaches here. */
    #else
    RET(16)
4037a522:	f01d      	retw.n

4037a524 <_frxt_task_coproc_state>:
    .align  4
_frxt_task_coproc_state:


    /* We can use a3 as a scratchpad, the instances of code calling XT_RTOS_CP_STATE don't seem to need it saved. */
    getcoreid a3
4037a524:	03eb30        	rsr.prid	a3
4037a527:	043d30        	extui	a3, a3, 13, 1
    movi    a15, port_xSchedulerRunning /* if (port_xSchedulerRunning              */
4037a52a:	e9a6f1        	l32r	a15, 40374bc4 <_iram_text_start+0x7c0> (3fc94f08 <port_xSchedulerRunning>)
    addx4   a15, a3,a15
4037a52d:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a530:	0ff8      	l32i.n	a15, a15, 0
    beqz    a15, 1f
4037a532:	afac      	beqz.n	a15, 4037a560 <_frxt_task_coproc_state+0x3c>
    movi    a15, port_interruptNesting  /* && port_interruptNesting == 0           */
4037a534:	e87ef1        	l32r	a15, 4037472c <_iram_text_start+0x328> (3fc94f00 <port_interruptNesting>)
    addx4   a15, a3, a15
4037a537:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a53a:	0ff8      	l32i.n	a15, a15, 0
    bnez    a15, 1f
4037a53c:	0fec      	bnez.n	a15, 4037a560 <_frxt_task_coproc_state+0x3c>

    movi    a15, pxCurrentTCBs
4037a53e:	e9c0f1        	l32r	a15, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    addx4   a15, a3, a15
4037a541:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0                 /* && pxCurrentTCBs != 0) {                 */
4037a544:	0ff8      	l32i.n	a15, a15, 0

    beqz    a15, 2f
4037a546:	8f9c      	beqz.n	a15, 4037a562 <_frxt_task_coproc_state+0x3e>
    get_cpsa_from_tcb a15, a3           /* After this, pointer to CP save area is in a15, a3 is destroyed */
4037a548:	e9c031        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93668 <offset_pxEndOfStack>)
4037a54b:	0338      	l32i.n	a3, a3, 0
4037a54d:	ff3a      	add.n	a15, a15, a3
4037a54f:	0ff8      	l32i.n	a15, a15, 0
4037a551:	e9be31        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93664 <offset_cpsa>)
4037a554:	0338      	l32i.n	a3, a3, 0
4037a556:	c0ff30        	sub	a15, a15, a3
4037a559:	037c      	movi.n	a3, -16
4037a55b:	10ff30        	and	a15, a15, a3
    ret
4037a55e:	f00d      	ret.n

1:  movi    a15, 0
4037a560:	0f0c      	movi.n	a15, 0
2:  ret
4037a562:	f00d      	ret.n

4037a564 <_frxt_coproc_exc_hook>:
    .type   _frxt_coproc_exc_hook,@function
    .align  4
_frxt_coproc_exc_hook:

    #if configNUM_CORES > 1
    getcoreid a2                            /* a2 = xCurCoreID */
4037a564:	03eb20        	rsr.prid	a2
4037a567:	042d20        	extui	a2, a2, 13, 1
    /* if (port_xSchedulerRunning[xCurCoreID] == 0) */
    movi    a3, port_xSchedulerRunning
4037a56a:	e99631        	l32r	a3, 40374bc4 <_iram_text_start+0x7c0> (3fc94f08 <port_xSchedulerRunning>)
    addx4   a3, a2, a3
4037a56d:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
4037a570:	0338      	l32i.n	a3, a3, 0
    beqz    a3, 1f                          /* Scheduler hasn't started yet. Return. */
4037a572:	a39c      	beqz.n	a3, 4037a590 <_frxt_coproc_exc_hook+0x2c>
    /* if (port_interruptNesting[xCurCoreID] != 0) */
    movi    a3, port_interruptNesting
4037a574:	e86e31        	l32r	a3, 4037472c <_iram_text_start+0x328> (3fc94f00 <port_interruptNesting>)
    addx4   a3, a2, a3
4037a577:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
4037a57a:	0338      	l32i.n	a3, a3, 0
    bnez    a3, 1f                          /* We are in an interrupt. Return*/
4037a57c:	03dc      	bnez.n	a3, 4037a590 <_frxt_coproc_exc_hook+0x2c>
    /* CP operations are incompatible with unpinned tasks. Thus we pin the task
    to the current running core. */
    movi    a3, pxCurrentTCBs
4037a57e:	e9b031        	l32r	a3, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
    addx4   a3, a2, a3
4037a581:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0                       /* a3 = pxCurrentTCBs[xCurCoreID] */
4037a584:	0338      	l32i.n	a3, a3, 0
    movi    a4, offset_xCoreID
4037a586:	e9b341        	l32r	a4, 40374c54 <_iram_text_start+0x850> (3fc93660 <offset_xCoreID>)
    l32i    a4, a4, 0                       /* a4 = offset_xCoreID */
4037a589:	0448      	l32i.n	a4, a4, 0
    add     a3, a3, a4                      /* a3 = &TCB.xCoreID */
4037a58b:	334a      	add.n	a3, a3, a4
    s32i    a2, a3, 0                       /* TCB.xCoreID = xCurCoreID */
4037a58d:	006322        	s32i	a2, a3, 0
1:
    #endif /* configNUM_CORES > 1 */

    ret
4037a590:	f00d      	ret.n
	...

4037a594 <pvPortMalloc>:
#define portFREERTOS_HEAP_CAPS    ( MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT )

/*-----------------------------------------------------------*/

void * pvPortMalloc(size_t xWantedSize)
{
4037a594:	004136        	entry	a1, 32
4037a597:	20a220        	or	a10, a2, a2

    /* All dynamic allocation done by FreeRTOS goes through this function. If
     * users need to allocate FreeRTOS objects into external RAM, they should
     * use the "static" equivalents of FreeRTOS API to create FreeRTOS objects
     * (e.g., queues). */
    pvReturn = heap_caps_malloc(xWantedSize, portFREERTOS_HEAP_CAPS);
4037a59a:	e8d0b1        	l32r	a11, 403748dc <_iram_text_start+0x4d8> (804 <UserFrameTotalSize+0x704>)
4037a59d:	fb99a5        	call8	40375f38 <heap_caps_malloc>

    return pvReturn;
}
4037a5a0:	202aa0        	or	a2, a10, a10
4037a5a3:	000090        	retw
	...

4037a5a8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree(void * pv)
{
4037a5a8:	004136        	entry	a1, 32
4037a5ab:	02ad      	mov.n	a10, a2
    heap_caps_free(pv);
4037a5ad:	fbbca5        	call8	40376178 <heap_caps_free>
}
4037a5b0:	f01d      	retw.n
	...

4037a5b4 <xPortCheckValidTCBMem>:
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
#endif /* CONFIG_IDF_TARGET_LINUX */
}

bool xPortCheckValidTCBMem(const void * ptr)
{
4037a5b4:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037a5b7:	e83391        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
4037a5ba:	929a      	add.n	a9, a2, a9
4037a5bc:	e9a781        	l32r	a8, 40374c58 <_iram_text_start+0x854> (757fff <UserFrameTotalSize+0x757eff>)
4037a5bf:	628890        	lsi	f9, a8, 0x188
4037a5c2:	880b      	addi.n	a8, a8, -1
4037a5c4:	608080        	neg	a8, a8
4037a5c7:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037a5ca:	e9a491        	l32r	a9, 40374c5c <_iram_text_start+0x858> (b0000000 <_rtc_reserved_end+0x4ff00000>)
4037a5cd:	929a      	add.n	a9, a2, a9
4037a5cf:	e808b1        	l32r	a11, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
4037a5d2:	629b90        	lsi	f9, a11, 0x188
4037a5d5:	990b      	addi.n	a9, a9, -1
4037a5d7:	609090        	neg	a9, a9
4037a5da:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037a5dd:	e803c1        	l32r	a12, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4037a5e0:	c2ca      	add.n	a12, a2, a12
4037a5e2:	62bbc0        	lsi	f12, a11, 0x188
4037a5e5:	bb0b      	addi.n	a11, a11, -1
4037a5e7:	60b0b0        	neg	a11, a11
4037a5ea:	74b0b0        	extui	a11, a11, 0, 8
#if CONFIG_IDF_TARGET_LINUX
    return true;
#else /* CONFIG_IDF_TARGET_LINUX */
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037a5ed:	208890        	or	a8, a8, a9
4037a5f0:	08cc      	bnez.n	a8, 4037a5f4 <xPortCheckValidTCBMem+0x40>
4037a5f2:	eb8c      	beqz.n	a11, 4037a604 <xPortCheckValidTCBMem+0x50>
4037a5f4:	20a220        	or	a10, a2, a2
4037a5f7:	fdcaa5        	call8	403782a0 <esp_ptr_byte_accessible>
4037a5fa:	00ba16        	beqz	a10, 4037a609 <xPortCheckValidTCBMem+0x55>
4037a5fd:	01a022        	movi	a2, 1
4037a600:	0001c6        	j	4037a60b <xPortCheckValidTCBMem+0x57>
4037a603:	020c00        	andb	b0, b12, b0
4037a606:	000046        	j	4037a60b <xPortCheckValidTCBMem+0x57>
4037a609:	020c      	movi.n	a2, 0
#endif /* CONFIG_IDF_TARGET_LINUX */
}
4037a60b:	f01d      	retw.n
4037a60d:	000000        	ill

4037a610 <xPortcheckValidStackMem>:

bool xPortcheckValidStackMem(const void * ptr)
{
4037a610:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037a613:	e81c91        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
4037a616:	929a      	add.n	a9, a2, a9
4037a618:	e99081        	l32r	a8, 40374c58 <_iram_text_start+0x854> (757fff <UserFrameTotalSize+0x757eff>)
4037a61b:	628890        	lsi	f9, a8, 0x188
4037a61e:	880b      	addi.n	a8, a8, -1
4037a620:	608080        	neg	a8, a8
4037a623:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037a626:	e98d91        	l32r	a9, 40374c5c <_iram_text_start+0x858> (b0000000 <_rtc_reserved_end+0x4ff00000>)
4037a629:	929a      	add.n	a9, a2, a9
4037a62b:	e7f1b1        	l32r	a11, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
4037a62e:	629b90        	lsi	f9, a11, 0x188
4037a631:	990b      	addi.n	a9, a9, -1
4037a633:	609090        	neg	a9, a9
4037a636:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037a639:	e7ecc1        	l32r	a12, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4037a63c:	c2ca      	add.n	a12, a2, a12
4037a63e:	62bbc0        	lsi	f12, a11, 0x188
4037a641:	bb0b      	addi.n	a11, a11, -1
4037a643:	60b0b0        	neg	a11, a11
4037a646:	74b0b0        	extui	a11, a11, 0, 8
    return true;
#else /* CONFIG_IDF_TARGET_LINUX */
#ifdef CONFIG_FREERTOS_TASK_CREATE_ALLOW_EXT_MEM
    return esp_ptr_byte_accessible(ptr);
#else
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037a649:	208890        	or	a8, a8, a9
4037a64c:	08cc      	bnez.n	a8, 4037a650 <xPortcheckValidStackMem+0x40>
4037a64e:	db8c      	beqz.n	a11, 4037a65f <xPortcheckValidStackMem+0x4f>
4037a650:	20a220        	or	a10, a2, a2
4037a653:	fdc4e5        	call8	403782a0 <esp_ptr_byte_accessible>
4037a656:	00aa16        	beqz	a10, 4037a664 <xPortcheckValidStackMem+0x54>
4037a659:	01a022        	movi	a2, 1
4037a65c:	000186        	j	4037a666 <xPortcheckValidStackMem+0x56>
4037a65f:	020c      	movi.n	a2, 0
4037a661:	000046        	j	4037a666 <xPortcheckValidStackMem+0x56>
4037a664:	020c      	movi.n	a2, 0
#endif
#endif /* CONFIG_IDF_TARGET_LINUX */
}
4037a666:	f01d      	retw.n

4037a668 <vApplicationGetIdleTaskMemory>:
*/
#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
                                   StackType_t **ppxIdleTaskStackBuffer,
                                   uint32_t *pulIdleTaskStackSize)
{
4037a668:	004136        	entry	a1, 32
        pxTCBBufferTemp = pvPortMalloc(sizeof(StaticTask_t));
        pxStackBufferTemp = pvPortMalloc(configMINIMAL_STACK_SIZE);
    }
#else /* portSTACK_GROWTH */
    {
        pxStackBufferTemp = pvPortMalloc(configMINIMAL_STACK_SIZE);
4037a66b:	00a6a2        	movi	a10, 0x600
4037a66e:	fff265        	call8	4037a594 <pvPortMalloc>
4037a671:	0a7d      	mov.n	a7, a10
        pxTCBBufferTemp = pvPortMalloc(sizeof(StaticTask_t));
4037a673:	54a1a2        	movi	a10, 0x154
4037a676:	fff1e5        	call8	4037a594 <pvPortMalloc>
    }
#endif /* portSTACK_GROWTH */

    assert(pxTCBBufferTemp != NULL);
4037a679:	00da56        	bnez	a10, 4037a68a <vApplicationGetIdleTaskMemory+0x22>
4037a67c:	e979d1        	l32r	a13, 40374c60 <_iram_text_start+0x85c> (3c024c90 <_flash_rodata_start+0x4b70>)
4037a67f:	e979c1        	l32r	a12, 40374c64 <_iram_text_start+0x860> (3c028490 <__func__$1>)
4037a682:	4b3c      	movi.n	a11, 52
4037a684:	e979a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c024cc2 <_flash_rodata_start+0x4ba2>)
4037a687:	0571a5        	call8	4037fda0 <__assert_func>
    assert(pxStackBufferTemp != NULL);
4037a68a:	c7cc      	bnez.n	a7, 4037a69a <vApplicationGetIdleTaskMemory+0x32>
4037a68c:	e978d1        	l32r	a13, 40374c6c <_iram_text_start+0x868> (3c024cd0 <_flash_rodata_start+0x4bb0>)
4037a68f:	e975c1        	l32r	a12, 40374c64 <_iram_text_start+0x860> (3c028490 <__func__$1>)
4037a692:	5b3c      	movi.n	a11, 53
4037a694:	e975a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c024cc2 <_flash_rodata_start+0x4ba2>)
4037a697:	0570a5        	call8	4037fda0 <__assert_func>
    //Write back pointers
    *ppxIdleTaskTCBBuffer = pxTCBBufferTemp;
4037a69a:	02a9      	s32i.n	a10, a2, 0
    *ppxIdleTaskStackBuffer = pxStackBufferTemp;
4037a69c:	0379      	s32i.n	a7, a3, 0
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
4037a69e:	00a682        	movi	a8, 0x600
4037a6a1:	0489      	s32i.n	a8, a4, 0
}
4037a6a3:	f01d      	retw.n
4037a6a5:	000000        	ill

4037a6a8 <vSystimerSetup>:
 * Both timer alarms are configured in periodic mode.
 * It is done at the same time so SysTicks for both CPUs occur at the same time or very close.
 * Shifts a time of triggering interrupts for core 0 and core 1.
 */
void vSystimerSetup(void)
{
4037a6a8:	006136        	entry	a1, 48
4037a6ab:	03eb70        	rsr.prid	a7
4037a6ae:	047d70        	extui	a7, a7, 13, 1
#endif
    /* Systimer HAL layer object */
    static systimer_hal_context_t systimer_hal;
    /* set system timer interrupt vector */

    ESP_ERROR_CHECK(esp_intr_alloc(ETS_SYSTIMER_TARGET0_INTR_SOURCE + cpuid, ESP_INTR_FLAG_IRAM | level, SysTickIsrHandler, &systimer_hal, NULL));
4037a6b1:	00a0e2        	movi	a14, 0
4037a6b4:	e96fd1        	l32r	a13, 40374c70 <_iram_text_start+0x86c> (3fc94f10 <systimer_hal$1>)
4037a6b7:	e96fc1        	l32r	a12, 40374c74 <_iram_text_start+0x870> (4037a828 <SysTickIsrHandler>)
4037a6ba:	02a4b2        	movi	a11, 0x402
4037a6bd:	39c7a2        	addi	a10, a7, 57
4037a6c0:	e97481        	l32r	a8, 40374c90 <_iram_text_start+0x88c> (42003954 <esp_intr_alloc>)
4037a6c3:	0008e0        	callx8	a8
4037a6c6:	00ea16        	beqz	a10, 4037a6d8 <vSystimerSetup+0x30>
4037a6c9:	e96be1        	l32r	a14, 40374c78 <_iram_text_start+0x874> (3c024cec <_flash_rodata_start+0x4bcc>)
4037a6cc:	e96cd1        	l32r	a13, 40374c7c <_iram_text_start+0x878> (3c0284b8 <__func__$0>)
4037a6cf:	48a0c2        	movi	a12, 72
4037a6d2:	e96bb1        	l32r	a11, 40374c80 <_iram_text_start+0x87c> (3c024d6c <_flash_rodata_start+0x4c4c>)
4037a6d5:	ff08a5        	call8	40379760 <_esp_error_check_failed>

    if (cpuid == 0) {
4037a6d8:	044716        	beqz	a7, 4037a720 <vSystimerSetup+0x78>
4037a6db:	004386        	j	4037a7ed <vSystimerSetup+0x145>
4037a6de:	810000        	src	a0, a0, a0
 *
 * @param enable true to enable, false to disable
 */
static inline void systimer_ll_enable_bus_clock(bool enable)
{
    SYSTEM.perip_clk_en0.systimer_clk_en = enable;
4037a6e1:	e8eb      	addi.n	a14, a8, 14
4037a6e3:	0020c0        	memw
4037a6e6:	062892        	l32i	a9, a8, 24
4037a6e9:	e8bba1        	l32r	a10, 403749d8 <_iram_text_start+0x5d4> (20000000 <UserFrameTotalSize+0x1fffff00>)
4037a6ec:	2099a0        	or	a9, a9, a10
4037a6ef:	0020c0        	memw
4037a6f2:	066892        	s32i	a9, a8, 24
 *
 * @param group_id Group ID
 */
static inline void systimer_ll_reset_register(void)
{
    SYSTEM.perip_rst_en0.systimer_rst = 1;
4037a6f5:	0020c0        	memw
4037a6f8:	082892        	l32i	a9, a8, 32
4037a6fb:	2099a0        	or	a9, a9, a10
4037a6fe:	0020c0        	memw
4037a701:	8899      	s32i.n	a9, a8, 32
    SYSTEM.perip_rst_en0.systimer_rst = 0;
4037a703:	0020c0        	memw
4037a706:	8898      	l32i.n	a9, a8, 32
4037a708:	e83ba1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037a70b:	1099a0        	and	a9, a9, a10
4037a70e:	0020c0        	memw
4037a711:	8899      	s32i.n	a9, a8, 32
        PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_SYSTIMER_MODULE, ref_count) {
4037a713:	4a2c      	movi.n	a10, 36
4037a715:	fbfb65        	call8	403766cc <periph_rcc_acquire_exit>
4037a718:	660b      	addi.n	a6, a6, -1
4037a71a:	746060        	extui	a6, a6, 0, 8
4037a71d:	000086        	j	4037a723 <vSystimerSetup+0x7b>
4037a720:	01a062        	movi	a6, 1
4037a723:	00e616        	beqz	a6, 4037a735 <vSystimerSetup+0x8d>
4037a726:	24a0a2        	movi	a10, 36
4037a729:	fbf925        	call8	403766bc <periph_rcc_acquire_enter>
4037a72c:	0abd      	mov.n	a11, a10
            if (ref_count == 0) {
4037a72e:	faea16        	beqz	a10, 4037a6e0 <vSystimerSetup+0x38>
4037a731:	fff786        	j	4037a713 <vSystimerSetup+0x6b>
4037a734:	4e6100        	f64rnd	a6, a1, a0, 0
                systimer_ll_enable_bus_clock(true);
                systimer_ll_reset_register();
            }
        }
        systimer_hal_init(&systimer_hal);
4037a737:	60e9      	s32i.n	a14, a0, 24
4037a739:	e520a6        	blti	a0, 2, 4037a722 <vSystimerSetup+0x7a>
4037a73c:	03c8      	l32i.n	a12, a3, 0
        systimer_hal_tick_rate_ops_t ops = {
4037a73e:	e95181        	l32r	a8, 40374c84 <_iram_text_start+0x880> (3c0284b0 <__func__$1+0x20>)
4037a741:	002892        	l32i	a9, a8, 0
4037a744:	1888      	l32i.n	a8, a8, 4
4037a746:	0199      	s32i.n	a9, a1, 0
4037a748:	1189      	s32i.n	a8, a1, 4
            .ticks_to_us = systimer_ticks_to_us,
            .us_to_ticks = systimer_us_to_ticks,
        };
        systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
4037a74a:	01bd      	mov.n	a11, a1
4037a74c:	06ad      	mov.n	a10, a6
4037a74e:	03dfe5        	call8	4037e54c <systimer_hal_set_tick_rate_ops>
        systimer_ll_set_counter_value(systimer_hal.dev, SYSTIMER_COUNTER_OS_TICK, 0);
4037a751:	0698      	l32i.n	a9, a6, 0
    return dev->unit_op[counter_id].timer_unit_value_valid;
}

__attribute__((always_inline)) static inline void systimer_ll_set_counter_value(systimer_dev_t *dev, uint32_t counter_id, uint64_t value)
{
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037a753:	0020c0        	memw
4037a756:	5988      	l32i.n	a8, a9, 20
4037a758:	b58480        	extui	a8, a8, 20, 12
4037a75b:	0188c0        	slli	a8, a8, 20
4037a75e:	0020c0        	memw
4037a761:	5989      	s32i.n	a8, a9, 20
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037a763:	080c      	movi.n	a8, 0
4037a765:	0020c0        	memw
4037a768:	6989      	s32i.n	a8, a9, 24
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
}

__attribute__((always_inline)) static inline void systimer_ll_apply_counter_value(systimer_dev_t *dev, uint32_t counter_id)
{
    dev->unit_load[counter_id].val = 0x01;
4037a76a:	180c      	movi.n	a8, 1
4037a76c:	0020c0        	memw
4037a76f:	186982        	s32i	a8, a9, 96
        systimer_ll_apply_counter_value(systimer_hal.dev, SYSTIMER_COUNTER_OS_TICK);

        for (cpuid = 0; cpuid < SOC_CPU_CORES_NUM; cpuid++) {
4037a772:	076d      	mov.n	a6, a7
4037a774:	0006c6        	j	4037a793 <vSystimerSetup+0xeb>
4037a777:	d20000        	quos	a0, a0, a0
            // Set stall option and alarm mode to default state. Below they will be set to a required state.
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, cpuid, false);
4037a77a:	6000a0        	neg	a0, a10
4037a77d:	0c20c6        	j	4037d804 <spimem_flash_ll_set_read_mode+0xc4>
4037a780:	a11b      	addi.n	a10, a1, 1
4037a782:	e93b      	addi.n	a14, a9, 3
4037a784:	03e3e5        	call8	4037e5c4 <systimer_hal_counter_can_stall_by_cpu>
            uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;
            systimer_hal_select_alarm_mode(&systimer_hal, alarm_id, SYSTIMER_ALARM_MODE_ONESHOT);
4037a787:	0c0c      	movi.n	a12, 0
4037a789:	06bd      	mov.n	a11, a6
4037a78b:	e939a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc94f10 <systimer_hal$1>)
4037a78e:	03d7e5        	call8	4037e50c <systimer_hal_select_alarm_mode>
        for (cpuid = 0; cpuid < SOC_CPU_CORES_NUM; cpuid++) {
4037a791:	661b      	addi.n	a6, a6, 1
4037a793:	e226b6        	bltui	a6, 2, 4037a779 <vSystimerSetup+0xd1>
4037a796:	001306        	j	4037a7e6 <vSystimerSetup+0x13e>

        for (cpuid = 0; cpuid < configNUM_CORES; ++cpuid) {
            uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;

            /* configure the timer */
            systimer_hal_connect_alarm_counter(&systimer_hal, alarm_id, SYSTIMER_COUNTER_OS_TICK);
4037a799:	e93561        	l32r	a6, 40374c70 <_iram_text_start+0x86c> (3fc94f10 <systimer_hal$1>)
4037a79c:	1c0c      	movi.n	a12, 1
4037a79e:	07bd      	mov.n	a11, a7
4037a7a0:	06ad      	mov.n	a10, a6
4037a7a2:	03dfe5        	call8	4037e5a0 <systimer_hal_connect_alarm_counter>
            systimer_hal_set_alarm_period(&systimer_hal, alarm_id, 1000000UL / CONFIG_FREERTOS_HZ);
4037a7a5:	e938c1        	l32r	a12, 40374c88 <_iram_text_start+0x884> (2710 <UserFrameTotalSize+0x2610>)
4037a7a8:	07bd      	mov.n	a11, a7
4037a7aa:	06ad      	mov.n	a10, a6
4037a7ac:	03c865        	call8	4037e434 <systimer_hal_set_alarm_period>
            systimer_hal_select_alarm_mode(&systimer_hal, alarm_id, SYSTIMER_ALARM_MODE_PERIOD);
4037a7af:	1c0c      	movi.n	a12, 1
4037a7b1:	07bd      	mov.n	a11, a7
4037a7b3:	06ad      	mov.n	a10, a6
4037a7b5:	03d565        	call8	4037e50c <systimer_hal_select_alarm_mode>
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, cpuid, true);
4037a7b8:	1d0c      	movi.n	a13, 1
4037a7ba:	07cd      	mov.n	a12, a7
4037a7bc:	0dbd      	mov.n	a11, a13
4037a7be:	06ad      	mov.n	a10, a6
4037a7c0:	03e025        	call8	4037e5c4 <systimer_hal_counter_can_stall_by_cpu>
            if (cpuid == 0) {
4037a7c3:	d7dc      	bnez.n	a7, 4037a7e4 <vSystimerSetup+0x13c>
                systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a7c5:	e92a61        	l32r	a6, 40374c70 <_iram_text_start+0x86c> (3fc94f10 <systimer_hal$1>)
4037a7c8:	07bd      	mov.n	a11, a7
4037a7ca:	20a660        	or	a10, a6, a6
4037a7cd:	03d8e5        	call8	4037e55c <systimer_hal_enable_alarm_int>
                systimer_hal_enable_counter(&systimer_hal, SYSTIMER_COUNTER_OS_TICK);
4037a7d0:	1b0c      	movi.n	a11, 1
4037a7d2:	20a660        	or	a10, a6, a6
4037a7d5:	03da65        	call8	4037e57c <systimer_hal_enable_counter>
#ifndef CONFIG_FREERTOS_UNICORE
                // SysTick of core 0 and core 1 are shifted by half of period
                systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, 1000000UL / CONFIG_FREERTOS_HZ / 2);
4037a7d8:	e92dc1        	l32r	a12, 40374c8c <_iram_text_start+0x888> (1388 <UserFrameTotalSize+0x1288>)
4037a7db:	0d0c      	movi.n	a13, 0
4037a7dd:	1b0c      	movi.n	a11, 1
4037a7df:	06ad      	mov.n	a10, a6
4037a7e1:	03cd65        	call8	4037e4b8 <systimer_hal_counter_value_advance>
        for (cpuid = 0; cpuid < configNUM_CORES; ++cpuid) {
4037a7e4:	771b      	addi.n	a7, a7, 1
4037a7e6:	af27b6        	bltui	a7, 2, 4037a799 <vSystimerSetup+0xf1>
4037a7e9:	000206        	j	4037a7f5 <vSystimerSetup+0x14d>
4037a7ec:	07bd00        	lsi	f0, a13, 28
#endif
            }
        }
    } else {
        uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;
        systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a7ef:	e920a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc94f10 <systimer_hal$1>)
4037a7f2:	03d6a5        	call8	4037e55c <systimer_hal_enable_alarm_int>
    }
}
4037a7f5:	f01d      	retw.n
	...

4037a7f8 <vPortSetupTimer>:
 *
 * - CCOUNT timer is used if CONFIG_FREERTOS_SYSTICK_USES_CCOUNT is set
 * - SYSTIMER is used if CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER is set
 */
void vPortSetupTimer(void)
{
4037a7f8:	004136        	entry	a1, 32
    extern void _xt_tick_divisor_init(void);
    /* Init the tick divisor value */
    _xt_tick_divisor_init();
    _frxt_tick_timer_init();
#else /* CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER */
    vSystimerSetup();
4037a7fb:	ffeae5        	call8	4037a6a8 <vSystimerSetup>
#endif /* CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER */
}
4037a7fe:	f01d      	retw.n

4037a800 <xPortSysTickHandler>:
 *  - _frxt_timer_int for xtensa with CONFIG_FREERTOS_SYSTICK_USES_CCOUNT
 *  - SysTickIsrHandler for xtensa with CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER
 *  - SysTickIsrHandler for riscv
 */
BaseType_t xPortSysTickHandler(void)
{
4037a800:	004136        	entry	a1, 32
#endif //configBENCHMARK
    traceISR_ENTER(SYSTICK_INTR_ID);

    // Call IDF Tick Hook
    extern void esp_vApplicationTickHook(void);
    esp_vApplicationTickHook();
4037a803:	fb5ce5        	call8	40375dd0 <esp_vApplicationTickHook>
4037a806:	03eb80        	rsr.prid	a8
4037a809:	048d80        	extui	a8, a8, 13, 1
    /*
    Multi-core IDF FreeRTOS requires that...
        - core 0 calls xTaskIncrementTick()
        - core 1 calls xTaskIncrementTickOtherCores()
    */
    if (xPortGetCoreID() == 0) {
4037a80c:	009856        	bnez	a8, 4037a819 <xPortSysTickHandler+0x19>
        xSwitchRequired = xTaskIncrementTick();
4037a80f:	009fa5        	call8	4037b208 <xTaskIncrementTick>
4037a812:	0a2d      	mov.n	a2, a10
4037a814:	0001c6        	j	4037a81f <xPortSysTickHandler+0x1f>
4037a817:	a50000        	extui	a0, a0, 16, 11
    } else {
        xSwitchRequired = xTaskIncrementTickOtherCores();
4037a81a:	a001d2        	l8ui	a13, a1, 160
4037a81d:	202a      	add.n	a2, a0, a2
    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
#endif /* configNUM_CORES > 1 */
#endif /* !CONFIG_FREERTOS_SMP */

    // Check if yield is required
    if (xSwitchRequired != pdFALSE) {
4037a81f:	002216        	beqz	a2, 4037a825 <xPortSysTickHandler+0x25>
        portYIELD_FROM_ISR();
4037a822:	ffb5a5        	call8	4037a37c <_frxt_setup_switch>
    } else {
        traceISR_EXIT();
    }
    return xSwitchRequired;
}
4037a825:	f01d      	retw.n
	...

4037a828 <SysTickIsrHandler>:
{
4037a828:	004136        	entry	a1, 32
4037a82b:	03eb60        	rsr.prid	a6
4037a82e:	046d60        	extui	a6, a6, 13, 1
        systimer_ll_clear_alarm_int(systimer_hal->dev, alarm_id);
4037a831:	002292        	l32i	a9, a2, 0
    return dev->int_st.val & (1 << alarm_id);
}

__attribute__((always_inline)) static inline void systimer_ll_clear_alarm_int(systimer_dev_t *dev, uint32_t alarm_id)
{
    dev->int_clr.val |= 1 << alarm_id;
4037a834:	0020c0        	memw
4037a837:	1b2982        	l32i	a8, a9, 108
4037a83a:	01a0b2        	movi	a11, 1
4037a83d:	401600        	ssl	a6
4037a840:	a15b00        	sll	a5, a11
4037a843:	208850        	or	a8, a8, a5
4037a846:	0020c0        	memw
4037a849:	1b6982        	s32i	a8, a9, 108
        uint32_t diff = systimer_hal_get_counter_value(systimer_hal, SYSTIMER_COUNTER_OS_TICK) / systimer_ll_get_alarm_period(systimer_hal->dev, alarm_id) - s_handled_systicks[cpuid];
4037a84c:	20a220        	or	a10, a2, a2
4037a84f:	03b965        	call8	4037e3e4 <systimer_hal_get_counter_value>
4037a852:	0298      	l32i.n	a9, a2, 0
    return dev->target_conf[alarm_id].target_period;
4037a854:	86cb      	addi.n	a8, a6, 12
4037a856:	a08890        	addx4	a8, a8, a9
4037a859:	0020c0        	memw
4037a85c:	18c8      	l32i.n	a12, a8, 4
4037a85e:	11cca0        	slli	a12, a12, 6
4037a861:	41c6c0        	srli	a12, a12, 6
4037a864:	0d0c      	movi.n	a13, 0
4037a866:	e73e81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
4037a869:	0008e0        	callx8	a8
4037a86c:	e90a81        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94f1c <s_handled_systicks>)
4037a86f:	a08680        	addx4	a8, a6, a8
4037a872:	0888      	l32i.n	a8, a8, 0
4037a874:	c07a80        	sub	a7, a10, a8
        if (diff > 0) {
4037a877:	1f1a87        	beq	a10, a8, 4037a89a <SysTickIsrHandler+0x72>
            if (s_handled_systicks[cpuid] == 0) {
4037a87a:	b8cc      	bnez.n	a8, 4037a889 <SysTickIsrHandler+0x61>
                s_handled_systicks[cpuid] = diff;
4037a87c:	e90681        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94f1c <s_handled_systicks>)
4037a87f:	a08680        	addx4	a8, a6, a8
4037a882:	0879      	s32i.n	a7, a8, 0
                diff = 1;
4037a884:	170c      	movi.n	a7, 1
4037a886:	0001c6        	j	4037a891 <SysTickIsrHandler+0x69>
                s_handled_systicks[cpuid] += diff;
4037a889:	e90281        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94f1c <s_handled_systicks>)
4037a88c:	a08680        	addx4	a8, a6, a8
4037a88f:	08a9      	s32i.n	a10, a8, 0
                xPortSysTickHandler();
4037a891:	fff6e5        	call8	4037a800 <xPortSysTickHandler>
            } while (--diff);
4037a894:	ffc772        	addi	a7, a7, -1
4037a897:	ff6756        	bnez	a7, 4037a891 <SysTickIsrHandler+0x69>
    } while (systimer_ll_is_alarm_int_fired(systimer_hal->dev, alarm_id));
4037a89a:	002282        	l32i	a8, a2, 0
    return dev->int_st.val & (1 << alarm_id);
4037a89d:	0020c0        	memw
4037a8a0:	1c2882        	l32i	a8, a8, 112
4037a8a3:	8a8587        	bany	a5, a8, 4037a831 <SysTickIsrHandler+0x9>
}
4037a8a6:	000090        	retw
4037a8a9:	000000        	ill

4037a8ac <prvGetDisinheritPriorityAfterTimeout>:
    {
4037a8ac:	004136        	entry	a1, 32
4037a8af:	028d      	mov.n	a8, a2
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
4037a8b1:	0020c0        	memw
4037a8b4:	9228      	l32i.n	a2, a2, 36
4037a8b6:	e28c      	beqz.n	a2, 4037a8c8 <prvGetDisinheritPriorityAfterTimeout+0x1c>
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
4037a8b8:	0020c0        	memw
4037a8bb:	c888      	l32i.n	a8, a8, 48
4037a8bd:	0020c0        	memw
4037a8c0:	0828      	l32i.n	a2, a8, 0
4037a8c2:	e7c222        	addi	a2, a2, -25
4037a8c5:	602020        	neg	a2, a2
    }
4037a8c8:	f01d      	retw.n
	...

4037a8cc <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
4037a8cc:	004136        	entry	a1, 32
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a8cf:	828b      	addi.n	a8, a2, 8
4037a8d1:	0020c0        	memw
4037a8d4:	1289      	s32i.n	a8, a2, 4

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
4037a8d6:	f97c      	movi.n	a9, -1
4037a8d8:	0020c0        	memw
4037a8db:	2299      	s32i.n	a9, a2, 8

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a8dd:	0020c0        	memw
4037a8e0:	3289      	s32i.n	a8, a2, 12
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a8e2:	0020c0        	memw
4037a8e5:	4289      	s32i.n	a8, a2, 16
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
4037a8e7:	080c      	movi.n	a8, 0
4037a8e9:	0020c0        	memw
4037a8ec:	0289      	s32i.n	a8, a2, 0

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
4037a8ee:	f01d      	retw.n

4037a8f0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
4037a8f0:	004136        	entry	a1, 32
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
4037a8f3:	080c      	movi.n	a8, 0
4037a8f5:	0020c0        	memw
4037a8f8:	4289      	s32i.n	a8, a2, 16

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
4037a8fa:	f01d      	retw.n

4037a8fc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
4037a8fc:	004136        	entry	a1, 32
    ListItem_t * const pxIndex = pxList->pxIndex;
4037a8ff:	0020c0        	memw
4037a902:	1288      	l32i.n	a8, a2, 4
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
4037a904:	0020c0        	memw
4037a907:	1389      	s32i.n	a8, a3, 4
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
4037a909:	0020c0        	memw
4037a90c:	2898      	l32i.n	a9, a8, 8
4037a90e:	0020c0        	memw
4037a911:	2399      	s32i.n	a9, a3, 8

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
4037a913:	0020c0        	memw
4037a916:	2898      	l32i.n	a9, a8, 8
4037a918:	0020c0        	memw
4037a91b:	1939      	s32i.n	a3, a9, 4
    pxIndex->pxPrevious = pxNewListItem;
4037a91d:	0020c0        	memw
4037a920:	2839      	s32i.n	a3, a8, 8

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
4037a922:	0020c0        	memw
4037a925:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037a927:	0020c0        	memw
4037a92a:	0288      	l32i.n	a8, a2, 0
4037a92c:	881b      	addi.n	a8, a8, 1
4037a92e:	0020c0        	memw
4037a931:	0289      	s32i.n	a8, a2, 0
}
4037a933:	f01d      	retw.n
4037a935:	000000        	ill

4037a938 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
4037a938:	004136        	entry	a1, 32
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
4037a93b:	0020c0        	memw
4037a93e:	03a8      	l32i.n	a10, a3, 0
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
4037a940:	080a66        	bnei	a10, -1, 4037a94c <vListInsert+0x14>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
4037a943:	0020c0        	memw
4037a946:	4288      	l32i.n	a8, a2, 16
4037a948:	0005c6        	j	4037a963 <vListInsert+0x2b>
4037a94b:	828b00        	mull	a8, a11, a0
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
4037a94e:	000106        	j	4037a956 <vListInsert+0x1e>
4037a951:	0020c0        	memw
4037a954:	1888      	l32i.n	a8, a8, 4
4037a956:	0020c0        	memw
4037a959:	1898      	l32i.n	a9, a8, 4
4037a95b:	0020c0        	memw
4037a95e:	0998      	l32i.n	a9, a9, 0
4037a960:	edba97        	bgeu	a10, a9, 4037a951 <vListInsert+0x19>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
4037a963:	0020c0        	memw
4037a966:	1898      	l32i.n	a9, a8, 4
4037a968:	0020c0        	memw
4037a96b:	1399      	s32i.n	a9, a3, 4
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
4037a96d:	0020c0        	memw
4037a970:	1398      	l32i.n	a9, a3, 4
4037a972:	0020c0        	memw
4037a975:	2939      	s32i.n	a3, a9, 8
    pxNewListItem->pxPrevious = pxIterator;
4037a977:	0020c0        	memw
4037a97a:	2389      	s32i.n	a8, a3, 8
    pxIterator->pxNext = pxNewListItem;
4037a97c:	0020c0        	memw
4037a97f:	1839      	s32i.n	a3, a8, 4

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
4037a981:	0020c0        	memw
4037a984:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037a986:	0020c0        	memw
4037a989:	0288      	l32i.n	a8, a2, 0
4037a98b:	881b      	addi.n	a8, a8, 1
4037a98d:	0020c0        	memw
4037a990:	0289      	s32i.n	a8, a2, 0
}
4037a992:	f01d      	retw.n

4037a994 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
4037a994:	004136        	entry	a1, 32
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
4037a997:	0020c0        	memw
4037a99a:	4288      	l32i.n	a8, a2, 16

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
4037a99c:	0020c0        	memw
4037a99f:	1298      	l32i.n	a9, a2, 4
4037a9a1:	0020c0        	memw
4037a9a4:	22a8      	l32i.n	a10, a2, 8
4037a9a6:	0020c0        	memw
4037a9a9:	29a9      	s32i.n	a10, a9, 8
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
4037a9ab:	0020c0        	memw
4037a9ae:	2298      	l32i.n	a9, a2, 8
4037a9b0:	0020c0        	memw
4037a9b3:	12a8      	l32i.n	a10, a2, 4
4037a9b5:	0020c0        	memw
4037a9b8:	19a9      	s32i.n	a10, a9, 4

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
4037a9ba:	0020c0        	memw
4037a9bd:	1898      	l32i.n	a9, a8, 4
4037a9bf:	099927        	bne	a9, a2, 4037a9cc <uxListRemove+0x38>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
4037a9c2:	0020c0        	memw
4037a9c5:	2298      	l32i.n	a9, a2, 8
4037a9c7:	0020c0        	memw
4037a9ca:	1899      	s32i.n	a9, a8, 4
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
4037a9cc:	090c      	movi.n	a9, 0
4037a9ce:	0020c0        	memw
4037a9d1:	4299      	s32i.n	a9, a2, 16
    ( pxList->uxNumberOfItems )--;
4037a9d3:	0020c0        	memw
4037a9d6:	0898      	l32i.n	a9, a8, 0
4037a9d8:	990b      	addi.n	a9, a9, -1
4037a9da:	0020c0        	memw
4037a9dd:	0899      	s32i.n	a9, a8, 0

    return pxList->uxNumberOfItems;
4037a9df:	0020c0        	memw
4037a9e2:	0828      	l32i.n	a2, a8, 0
}
4037a9e4:	f01d      	retw.n
	...

4037a9e8 <prvCheckTaskCanBeScheduledSMP>:
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

    static BaseType_t prvCheckTaskCanBeScheduledSMP( TCB_t * pxTCB )
    {
4037a9e8:	004136        	entry	a1, 32
        /* This function must be called from a critical section (where the kernel
         * lock is taken). */

        BaseType_t xReturn;

        if( pxTCB->xCoreID == tskNO_AFFINITY )
4037a9eb:	112282        	l32i	a8, a2, 68
4037a9ee:	e78691        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037a9f1:	189897        	bne	a8, a9, 4037aa0d <prvCheckTaskCanBeScheduledSMP+0x25>
        {
            /* Task is unpinned. As long as one core has not suspended
             * scheduling, the task can be scheduled. */
            if( ( uxSchedulerSuspended[ 0 ] == ( UBaseType_t ) 0U ) || ( uxSchedulerSuspended[ 1 ] == ( UBaseType_t ) 0U ) )
4037a9f4:	e8a981        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037a9f7:	0020c0        	memw
4037a9fa:	0888      	l32i.n	a8, a8, 0
4037a9fc:	08ac      	beqz.n	a8, 4037aa20 <prvCheckTaskCanBeScheduledSMP+0x38>
4037a9fe:	e8a681        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037aa01:	0020c0        	memw
4037aa04:	1888      	l32i.n	a8, a8, 4
4037aa06:	b8dc      	bnez.n	a8, 4037aa25 <prvCheckTaskCanBeScheduledSMP+0x3d>
            {
                xReturn = pdTRUE;
4037aa08:	120c      	movi.n	a2, 1
4037aa0a:	000786        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
            else
            {
                xReturn = pdFALSE;
            }
        }
        else if( uxSchedulerSuspended[ pxTCB->xCoreID ] == ( UBaseType_t ) 0U )
4037aa0d:	e8a291        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037aa10:	a08890        	addx4	a8, a8, a9
4037aa13:	0020c0        	memw
4037aa16:	0888      	l32i.n	a8, a8, 0
4037aa18:	e8cc      	bnez.n	a8, 4037aa2a <prvCheckTaskCanBeScheduledSMP+0x42>
        {
            /* The task is pinned to a core. If it's pinned core has not
             * suspended scheduling, the task can be scheduled. */
            xReturn = pdTRUE;
4037aa1a:	120c      	movi.n	a2, 1
4037aa1c:	000306        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
4037aa1f:	120c00        	andbc	b0, b12, b0
                xReturn = pdTRUE;
4037aa22:	000186        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
                xReturn = pdFALSE;
4037aa25:	020c      	movi.n	a2, 0
4037aa27:	000046        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
        }
        else
        {
            xReturn = pdFALSE;
4037aa2a:	020c      	movi.n	a2, 0
        }

        return xReturn;
    }
4037aa2c:	f01d      	retw.n
	...

4037aa30 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
4037aa30:	004136        	entry	a1, 32
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037aa33:	e89a81        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94cc0 <pxDelayedTaskList>)
4037aa36:	0020c0        	memw
4037aa39:	0888      	l32i.n	a8, a8, 0
4037aa3b:	0020c0        	memw
4037aa3e:	0888      	l32i.n	a8, a8, 0
4037aa40:	c8cc      	bnez.n	a8, 4037aa50 <prvResetNextTaskUnblockTime+0x20>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
4037aa42:	e89781        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94c40 <xNextTaskUnblockTime>)
4037aa45:	f97c      	movi.n	a9, -1
4037aa47:	0020c0        	memw
4037aa4a:	0899      	s32i.n	a9, a8, 0
4037aa4c:	000686        	j	4037aa6a <prvResetNextTaskUnblockTime+0x3a>
4037aa4f:	938100        	movnez	a8, a1, a0
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
4037aa52:	c0e8      	l32i.n	a14, a0, 48
4037aa54:	880020        	lsi	f2, a0, 0x220
4037aa57:	c008      	l32i.n	a0, a0, 48
4037aa59:	880020        	lsi	f2, a0, 0x220
4037aa5c:	c038      	l32i.n	a3, a0, 48
4037aa5e:	980020        	lsi	f2, a0, 0x260
4037aa61:	8108      	l32i.n	a0, a1, 32
4037aa63:	8f          	.byte	0x8f
4037aa64:	c0e8      	l32i.n	a14, a0, 48
4037aa66:	990020        	lsi	f2, a0, 0x264
4037aa69:	1d08      	l32i.n	a0, a13, 4
    }
}
4037aa6b:	f0          	.byte	0xf0

4037aa6c <prvIsYieldRequiredSMP>:
    {
4037aa6c:	004136        	entry	a1, 32
        configASSERT( uxTaskPriority < configMAX_PRIORITIES );
4037aa6f:	881c      	movi.n	a8, 24
4037aa71:	0eb837        	bgeu	a8, a3, 4037aa83 <prvIsYieldRequiredSMP+0x17>
4037aa74:	e88cd1        	l32r	a13, 40374ca4 <_iram_text_start+0x8a0> (3c0244c0 <_flash_rodata_start+0x43a0>)
4037aa77:	e88cc1        	l32r	a12, 40374ca8 <_iram_text_start+0x8a4> (3c0283e4 <__func__$37>)
4037aa7a:	1fa3b2        	movi	a11, 0x31f
4037aa7d:	e88ba1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037aa80:	0531e5        	call8	4037fda0 <__assert_func>
4037aa83:	03eba0        	rsr.prid	a10
4037aa86:	04ada0        	extui	a10, a10, 13, 1
4037aa89:	0a9d      	mov.n	a9, a10
        if( xYieldEqualPriority == pdTRUE )
4037aa8b:	011466        	bnei	a4, 1, 4037aa90 <prvIsYieldRequiredSMP+0x24>
            uxTaskPriority++;
4037aa8e:	331b      	addi.n	a3, a3, 1
        if( ( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aa90:	112282        	l32i	a8, a2, 68
4037aa93:	051897        	beq	a8, a9, 4037aa9c <prvIsYieldRequiredSMP+0x30>
4037aa96:	e75c91        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037aa99:	1c9897        	bne	a8, a9, 4037aab9 <prvIsYieldRequiredSMP+0x4d>
            ( uxTaskPriority > pxCurrentTCBs[ xCurCoreID ]->uxPriority ) &&
4037aa9c:	e86991        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037aa9f:	a09a90        	addx4	a9, a10, a9
4037aaa2:	0020c0        	memw
4037aaa5:	0998      	l32i.n	a9, a9, 0
4037aaa7:	b998      	l32i.n	a9, a9, 44
        if( ( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aaa9:	0cb937        	bgeu	a9, a3, 4037aab9 <prvIsYieldRequiredSMP+0x4d>
            ( uxSchedulerSuspended[ xCurCoreID ] == ( UBaseType_t ) 0U ) )
4037aaac:	e87b91        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037aaaf:	a09a90        	addx4	a9, a10, a9
4037aab2:	0020c0        	memw
4037aab5:	0998      	l32i.n	a9, a9, 0
            ( uxTaskPriority > pxCurrentTCBs[ xCurCoreID ]->uxPriority ) &&
4037aab7:	69bc      	beqz.n	a9, 4037aaf1 <prvIsYieldRequiredSMP+0x85>
        else if( ( taskIS_AFFINITY_COMPATIBLE( !xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aab9:	40faa0        	nsau	a10, a10
4037aabc:	41a5a0        	srli	a10, a10, 5
4037aabf:	0518a7        	beq	a8, a10, 4037aac8 <prvIsYieldRequiredSMP+0x5c>
4037aac2:	e75191        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037aac5:	2d9897        	bne	a8, a9, 4037aaf6 <prvIsYieldRequiredSMP+0x8a>
                 ( uxTaskPriority > pxCurrentTCBs[ !xCurCoreID ]->uxPriority ) &&
4037aac8:	e85e81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037aacb:	a08a80        	addx4	a8, a10, a8
4037aace:	0020c0        	memw
4037aad1:	002882        	l32i	a8, a8, 0
4037aad4:	0b2882        	l32i	a8, a8, 44
        else if( ( taskIS_AFFINITY_COMPATIBLE( !xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aad7:	21b837        	bgeu	a8, a3, 4037aafc <prvIsYieldRequiredSMP+0x90>
                 ( uxSchedulerSuspended[ !xCurCoreID ] == ( UBaseType_t ) 0U ) )
4037aada:	e86f81        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037aadd:	a08a80        	addx4	a8, a10, a8
4037aae0:	0020c0        	memw
4037aae3:	002882        	l32i	a8, a8, 0
                 ( uxTaskPriority > pxCurrentTCBs[ !xCurCoreID ]->uxPriority ) &&
4037aae6:	017856        	bnez	a8, 4037ab01 <prvIsYieldRequiredSMP+0x95>
            taskYIELD_CORE( !xCurCoreID );
4037aae9:	ff8325        	call8	4037a31c <vPortYieldOtherCore>
            xYieldRequiredCurrentCore = pdFALSE;
4037aaec:	020c      	movi.n	a2, 0
4037aaee:	000446        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
            xYieldRequiredCurrentCore = pdTRUE;
4037aaf1:	120c      	movi.n	a2, 1
4037aaf3:	000306        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
            xYieldRequiredCurrentCore = pdFALSE;
4037aaf6:	020c      	movi.n	a2, 0
4037aaf8:	0001c6        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
4037aafb:	020c00        	andb	b0, b12, b0
4037aafe:	000046        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
4037ab01:	020c      	movi.n	a2, 0
    }
4037ab03:	f01d      	retw.n
4037ab05:	000000        	ill

4037ab08 <prvSelectHighestPriorityTaskSMP>:
    {
4037ab08:	004136        	entry	a1, 32
4037ab0b:	03ebc0        	rsr.prid	a12
4037ab0e:	04cdc0        	extui	a12, a12, 13, 1
4037ab11:	0cfd      	mov.n	a15, a12
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037ab13:	e86781        	l32r	a8, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037ab16:	0020c0        	memw
4037ab19:	0898      	l32i.n	a9, a8, 0
        BaseType_t xNewTopPrioritySet = pdFALSE;
4037ab1b:	060c      	movi.n	a6, 0
        BaseType_t xTaskScheduled = pdFALSE;
4037ab1d:	067d      	mov.n	a7, a6
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037ab1f:	006a06        	j	4037accb <prvSelectHighestPriorityTaskSMP+0x1c3>
4037ab22:	000000        	ill
            if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxCurPriority ] ) ) )
4037ab25:	a08990        	addx4	a8, a9, a9
4037ab28:	11a8e0        	slli	a10, a8, 2
4037ab2b:	e86281        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037ab2e:	88aa      	add.n	a8, a8, a10
4037ab30:	0020c0        	memw
4037ab33:	0888      	l32i.n	a8, a8, 0
4037ab35:	190816        	beqz	a8, 4037acc9 <prvSelectHighestPriorityTaskSMP+0x1c1>
            if( xNewTopPrioritySet == pdFALSE )
4037ab38:	96cc      	bnez.n	a6, 4037ab45 <prvSelectHighestPriorityTaskSMP+0x3d>
                uxTopReadyPriority = uxCurPriority;
4037ab3a:	e85d81        	l32r	a8, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037ab3d:	0020c0        	memw
4037ab40:	0899      	s32i.n	a9, a8, 0
                xNewTopPrioritySet = pdTRUE;
4037ab42:	01a062        	movi	a6, 1
            pxReadyTasksLists[ uxCurPriority ].pxIndex = ( ListItem_t * ) &( pxReadyTasksLists[ uxCurPriority ].xListEnd );
4037ab45:	a0a990        	addx4	a10, a9, a9
4037ab48:	118ae0        	slli	a8, a10, 2
4037ab4b:	e85aa1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037ab4e:	88aa      	add.n	a8, a8, a10
4037ab50:	d88b      	addi.n	a13, a8, 8
4037ab52:	0020c0        	memw
4037ab55:	18d9      	s32i.n	a13, a8, 4
            listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037ab57:	0020c0        	memw
4037ab5a:	18a8      	l32i.n	a10, a8, 4
4037ab5c:	0020c0        	memw
4037ab5f:	1aa8      	l32i.n	a10, a10, 4
4037ab61:	0020c0        	memw
4037ab64:	18a9      	s32i.n	a10, a8, 4
4037ab66:	0020c0        	memw
4037ab69:	1888      	l32i.n	a8, a8, 4
4037ab6b:	199d87        	bne	a13, a8, 4037ab88 <prvSelectHighestPriorityTaskSMP+0x80>
4037ab6e:	a08990        	addx4	a8, a9, a9
4037ab71:	11a8e0        	slli	a10, a8, 2
4037ab74:	e85081        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037ab77:	88aa      	add.n	a8, a8, a10
4037ab79:	0020c0        	memw
4037ab7c:	18a8      	l32i.n	a10, a8, 4
4037ab7e:	0020c0        	memw
4037ab81:	1aa8      	l32i.n	a10, a10, 4
4037ab83:	0020c0        	memw
4037ab86:	18a9      	s32i.n	a10, a8, 4
4037ab88:	a08990        	addx4	a8, a9, a9
4037ab8b:	11a8e0        	slli	a10, a8, 2
4037ab8e:	e84981        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037ab91:	88aa      	add.n	a8, a8, a10
4037ab93:	0020c0        	memw
4037ab96:	1888      	l32i.n	a8, a8, 4
4037ab98:	38e8      	l32i.n	a14, a8, 12
4037ab9a:	0ebd      	mov.n	a11, a14
                for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037ab9c:	080c      	movi.n	a8, 0
4037ab9e:	000546        	j	4037abb7 <prvSelectHighestPriorityTaskSMP+0xaf>
                    if( x == xCurCoreID )
4037aba1:	1018c7        	beq	a8, a12, 4037abb5 <prvSelectHighestPriorityTaskSMP+0xad>
                    else if( pxCurrentTCBs[ x ] == pxTCBCur )
4037aba4:	e827a1        	l32r	a10, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037aba7:	a0a8a0        	addx4	a10, a8, a10
4037abaa:	0020c0        	memw
4037abad:	0aa8      	l32i.n	a10, a10, 0
4037abaf:	029ab7        	bne	a10, a11, 4037abb5 <prvSelectHighestPriorityTaskSMP+0xad>
4037abb2:	002f86        	j	4037ac74 <prvSelectHighestPriorityTaskSMP+0x16c>
                for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037abb5:	881b      	addi.n	a8, a8, 1
4037abb7:	e628b6        	bltui	a8, 2, 4037aba1 <prvSelectHighestPriorityTaskSMP+0x99>
                if( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCBCur ) == pdFALSE )
4037abba:	112b82        	l32i	a8, a11, 68
4037abbd:	0818f7        	beq	a8, a15, 4037abc9 <prvSelectHighestPriorityTaskSMP+0xc1>
4037abc0:	e712a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037abc3:	0218a7        	beq	a8, a10, 4037abc9 <prvSelectHighestPriorityTaskSMP+0xc1>
4037abc6:	002a86        	j	4037ac74 <prvSelectHighestPriorityTaskSMP+0x16c>
                pxCurrentTCBs[ xCurCoreID ] = pxTCBCur;
4037abc9:	e81d81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037abcc:	a08c80        	addx4	a8, a12, a8
4037abcf:	0020c0        	memw
4037abd2:	08b9      	s32i.n	a11, a8, 0
                pxReadyTasksLists[ uxCurPriority ].pxIndex = ( ListItem_t * ) &( pxReadyTasksLists[ uxCurPriority ].xListEnd );
4037abd4:	a08990        	addx4	a8, a9, a9
4037abd7:	11a8e0        	slli	a10, a8, 2
4037abda:	e83681        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037abdd:	88aa      	add.n	a8, a8, a10
4037abdf:	0020c0        	memw
4037abe2:	18d9      	s32i.n	a13, a8, 4
                listREMOVE_ITEM( &( pxTCBCur->xStateListItem ) );
4037abe4:	0020c0        	memw
4037abe7:	5b88      	l32i.n	a8, a11, 20
4037abe9:	0020c0        	memw
4037abec:	2ba8      	l32i.n	a10, a11, 8
4037abee:	0020c0        	memw
4037abf1:	3bd8      	l32i.n	a13, a11, 12
4037abf3:	0020c0        	memw
4037abf6:	2ad9      	s32i.n	a13, a10, 8
4037abf8:	0020c0        	memw
4037abfb:	3ba8      	l32i.n	a10, a11, 12
4037abfd:	0020c0        	memw
4037ac00:	2bd8      	l32i.n	a13, a11, 8
4037ac02:	0020c0        	memw
4037ac05:	1ad9      	s32i.n	a13, a10, 4
4037ac07:	0020c0        	memw
4037ac0a:	18a8      	l32i.n	a10, a8, 4
4037ac0c:	db4b      	addi.n	a13, a11, 4
4037ac0e:	0a9ad7        	bne	a10, a13, 4037ac1c <prvSelectHighestPriorityTaskSMP+0x114>
4037ac11:	0020c0        	memw
4037ac14:	3ba8      	l32i.n	a10, a11, 12
4037ac16:	0020c0        	memw
4037ac19:	0168a2        	s32i	a10, a8, 4
4037ac1c:	0a0c      	movi.n	a10, 0
4037ac1e:	0020c0        	memw
4037ac21:	5ba9      	s32i.n	a10, a11, 20
4037ac23:	0020c0        	memw
4037ac26:	08a8      	l32i.n	a10, a8, 0
4037ac28:	aa0b      	addi.n	a10, a10, -1
4037ac2a:	0020c0        	memw
4037ac2d:	08a9      	s32i.n	a10, a8, 0
                listINSERT_END( &( pxReadyTasksLists[ uxCurPriority ] ), &( pxTCBCur->xStateListItem ) );
4037ac2f:	a08990        	addx4	a8, a9, a9
4037ac32:	11a8e0        	slli	a10, a8, 2
4037ac35:	e81f81        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037ac38:	88aa      	add.n	a8, a8, a10
4037ac3a:	0020c0        	memw
4037ac3d:	18a8      	l32i.n	a10, a8, 4
4037ac3f:	0020c0        	memw
4037ac42:	2ba9      	s32i.n	a10, a11, 8
4037ac44:	0020c0        	memw
4037ac47:	2ae8      	l32i.n	a14, a10, 8
4037ac49:	0020c0        	memw
4037ac4c:	3be9      	s32i.n	a14, a11, 12
4037ac4e:	0020c0        	memw
4037ac51:	2ae8      	l32i.n	a14, a10, 8
4037ac53:	0020c0        	memw
4037ac56:	1ed9      	s32i.n	a13, a14, 4
4037ac58:	0020c0        	memw
4037ac5b:	2ad9      	s32i.n	a13, a10, 8
4037ac5d:	0020c0        	memw
4037ac60:	5b89      	s32i.n	a8, a11, 20
4037ac62:	0020c0        	memw
4037ac65:	08a8      	l32i.n	a10, a8, 0
4037ac67:	aa1b      	addi.n	a10, a10, 1
4037ac69:	0020c0        	memw
4037ac6c:	08a9      	s32i.n	a10, a8, 0
                xTaskScheduled = pdTRUE;
4037ac6e:	170c      	movi.n	a7, 1
                break;
4037ac70:	001546        	j	4037acc9 <prvSelectHighestPriorityTaskSMP+0x1c1>
4037ac73:	899000        	lsi	f0, a0, 0x224
                listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037ac76:	a8e0a0        	lsi	f10, a0, 0x2a0
4037ac79:	0e8111        	l32r	a1, 4033e680 <rom_rx_gain_force+0x338254>
4037ac7c:	aae8      	l32i.n	a14, a10, 40
4037ac7e:	c088      	l32i.n	a8, a0, 48
4037ac80:	a80020        	lsi	f2, a0, 0x2a0
4037ac83:	c018      	l32i.n	a1, a0, 48
4037ac85:	a80020        	lsi	f2, a0, 0x2a0
4037ac88:	c01a      	add.n	a12, a0, a1
4037ac8a:	a90020        	lsi	f2, a0, 0x2a4
4037ac8d:	c018      	l32i.n	a1, a0, 48
4037ac8f:	880020        	lsi	f2, a0, 0x220
4037ac92:	8718      	l32i.n	a1, a7, 32
4037ac94:	1a9d      	lsi	f9, a10, 40
4037ac96:	a08990        	addx4	a8, a9, a9
4037ac99:	11a8e0        	slli	a10, a8, 2
4037ac9c:	e80681        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037ac9f:	88aa      	add.n	a8, a8, a10
4037aca1:	0020c0        	memw
4037aca4:	18a8      	l32i.n	a10, a8, 4
4037aca6:	0020c0        	memw
4037aca9:	1aa8      	l32i.n	a10, a10, 4
4037acab:	0020c0        	memw
4037acae:	0168a2        	s32i	a10, a8, 4
4037acb1:	a08990        	addx4	a8, a9, a9
4037acb4:	11a8e0        	slli	a10, a8, 2
4037acb7:	e7ff81        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037acba:	88aa      	add.n	a8, a8, a10
4037acbc:	0020c0        	memw
4037acbf:	1888      	l32i.n	a8, a8, 4
4037acc1:	38b8      	l32i.n	a11, a8, 12
            } while( pxTCBCur != pxTCBFirst ); /* Check to see if we've walked the entire list */
4037acc3:	021eb7        	beq	a14, a11, 4037acc9 <prvSelectHighestPriorityTaskSMP+0x1c1>
4037acc6:	ffb486        	j	4037ab9c <prvSelectHighestPriorityTaskSMP+0x94>
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037acc9:	990b      	addi.n	a9, a9, -1
4037accb:	048070        	extui	a8, a7, 0, 1
4037acce:	1a0c      	movi.n	a10, 1
4037acd0:	3088a0        	xor	a8, a8, a10
4037acd3:	748080        	extui	a8, a8, 0, 8
4037acd6:	002996        	bltz	a9, 4037acdc <prvSelectHighestPriorityTaskSMP+0x1d4>
4037acd9:	e48856        	bnez	a8, 4037ab25 <prvSelectHighestPriorityTaskSMP+0x1d>
        configASSERT( xTaskScheduled == pdTRUE ); /* At this point, a task MUST have been scheduled */
4037acdc:	d7cc      	bnez.n	a7, 4037aced <prvSelectHighestPriorityTaskSMP+0x1e5>
4037acde:	e7f6d1        	l32r	a13, 40374cb8 <_iram_text_start+0x8b4> (3c02450c <_flash_rodata_start+0x43ec>)
4037ace1:	e7f6c1        	l32r	a12, 40374cbc <_iram_text_start+0x8b8> (3c02837c <__func__$24>)
4037ace4:	e7f7b1        	l32r	a11, 40374cc0 <_iram_text_start+0x8bc> (e2e <UserFrameTotalSize+0xd2e>)
4037ace7:	e7f1a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037acea:	050b65        	call8	4037fda0 <__assert_func>
    }
4037aced:	f01d      	retw.n
	...

4037acf0 <prvDeleteTCB>:
    {
4037acf0:	004136        	entry	a1, 32
        portCLEAN_UP_TCB( pxTCB );
4037acf3:	20a220        	or	a10, a2, a2
4037acf6:	ff6725        	call8	4037a368 <vPortTCBPreDeleteHook>
            configDEINIT_TLS_BLOCK( pxTCB->xTLSBlock );
4037acf9:	5cc2a2        	addi	a10, a2, 92
4037acfc:	e7f581        	l32r	a8, 40374cd0 <_iram_text_start+0x8cc> (4200c328 <_reclaim_reent>)
4037acff:	0008e0        	callx8	a8
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
4037ad02:	01d282        	addmi	a8, a2, 0x100
4037ad05:	510882        	l8ui	a8, a8, 81
4037ad08:	00d856        	bnez	a8, 4037ad19 <prvDeleteTCB+0x29>
                vPortFreeStack( pxTCB->pxStack );
4037ad0b:	c2a8      	l32i.n	a10, a2, 48
4037ad0d:	ff89a5        	call8	4037a5a8 <vPortFree>
                vPortFree( pxTCB );
4037ad10:	02ad      	mov.n	a10, a2
4037ad12:	ff8965        	call8	4037a5a8 <vPortFree>
4037ad15:	000746        	j	4037ad36 <prvDeleteTCB+0x46>
4037ad18:	186600        	lsxp	f6, a6, a0
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
4037ad1b:	02ad07        	bge	a13, a0, 4037ad21 <prvDeleteTCB+0x31>
                vPortFree( pxTCB );
4037ad1e:	ff88a5        	call8	4037a5a8 <vPortFree>
4037ad21:	000446        	j	4037ad36 <prvDeleteTCB+0x46>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
4037ad24:	0e2826        	beqi	a8, 2, 4037ad36 <prvDeleteTCB+0x46>
4037ad27:	e7e7d1        	l32r	a13, 40374cc4 <_iram_text_start+0x8c0> (3c024534 <_flash_rodata_start+0x4414>)
4037ad2a:	e7e7c1        	l32r	a12, 40374cc8 <_iram_text_start+0x8c4> (3c02841c <__func__$42>)
4037ad2d:	e7e7b1        	l32r	a11, 40374ccc <_iram_text_start+0x8c8> (1339 <UserFrameTotalSize+0x1239>)
4037ad30:	e7dfa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037ad33:	0506e5        	call8	4037fda0 <__assert_func>
    }
4037ad36:	f01d      	retw.n

4037ad38 <prvCheckTasksWaitingTermination>:
{
4037ad38:	004136        	entry	a1, 32
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
4037ad3b:	002086        	j	4037adc1 <prvCheckTasksWaitingTermination+0x89>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037ad3e:	ffafb2        	movi	a11, -1
4037ad41:	e7e4a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037ad44:	ff3ea5        	call8	4037a130 <xPortEnterCriticalTimeout>
                    if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
4037ad47:	e7e481        	l32r	a8, 40374cd8 <_iram_text_start+0x8d4> (3fc94c80 <xTasksWaitingTermination>)
4037ad4a:	0020c0        	memw
4037ad4d:	002882        	l32i	a8, a8, 0
4037ad50:	05e816        	beqz	a8, 4037adb2 <prvCheckTasksWaitingTermination+0x7a>
                        for( xEntry = listGET_HEAD_ENTRY( &xTasksWaitingTermination ); xEntry != listGET_END_MARKER( &xTasksWaitingTermination ); xEntry = listGET_NEXT( xEntry ) )
4037ad53:	e7e181        	l32r	a8, 40374cd8 <_iram_text_start+0x8d4> (3fc94c80 <xTasksWaitingTermination>)
4037ad56:	0020c0        	memw
4037ad59:	032882        	l32i	a8, a8, 12
4037ad5c:	001186        	j	4037ada6 <prvCheckTasksWaitingTermination+0x6e>
4037ad5f:	287200        	lsi	f0, a2, 160
                            if( taskIS_CURRENTLY_RUNNING( ( ( TCB_t * ) listGET_LIST_ITEM_OWNER( xEntry ) ) ) == pdFALSE )
4037ad62:	b79103        	lsi	f0, a1, 0x2dc
4037ad65:	20c0e7        	bnall	a0, a14, 4037ad89 <prvCheckTasksWaitingTermination+0x51>
4037ad68:	299200        	lsi	f0, a2, 164
4037ad6b:	179700        	lsi	f0, a7, 92
4037ad6e:	b49131        	l32r	a3, 40367fb4 <rom_rx_gain_force+0x361b88>
4037ad71:	20c0e7        	bnall	a0, a14, 4037ad95 <prvCheckTasksWaitingTermination+0x5d>
4037ad74:	299200        	lsi	f0, a2, 164
4037ad77:	179701        	l32r	a0, 40340bd4 <rom_rx_gain_force+0x33a7a8>
4037ad7a:	a74b25        	call8	4032222c <rom_rx_gain_force+0x31be00>
                                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4037ad7d:	ffc165        	call8	4037a994 <uxListRemove>
                                --uxCurrentNumberOfTasks;
4037ad80:	e7d791        	l32r	a9, 40374cdc <_iram_text_start+0x8d8> (3fc94c64 <uxCurrentNumberOfTasks>)
4037ad83:	0020c0        	memw
4037ad86:	0988      	l32i.n	a8, a9, 0
4037ad88:	880b      	addi.n	a8, a8, -1
4037ad8a:	0020c0        	memw
4037ad8d:	0989      	s32i.n	a8, a9, 0
                                --uxDeletedTasksWaitingCleanUp;
4037ad8f:	e7d491        	l32r	a9, 40374ce0 <_iram_text_start+0x8dc> (3fc94c7c <uxDeletedTasksWaitingCleanUp>)
4037ad92:	0020c0        	memw
4037ad95:	0988      	l32i.n	a8, a9, 0
4037ad97:	880b      	addi.n	a8, a8, -1
4037ad99:	0020c0        	memw
4037ad9c:	0989      	s32i.n	a8, a9, 0
                                break;
4037ad9e:	000486        	j	4037adb4 <prvCheckTasksWaitingTermination+0x7c>
                        for( xEntry = listGET_HEAD_ENTRY( &xTasksWaitingTermination ); xEntry != listGET_END_MARKER( &xTasksWaitingTermination ); xEntry = listGET_NEXT( xEntry ) )
4037ada1:	0020c0        	memw
4037ada4:	1888      	l32i.n	a8, a8, 4
4037ada6:	e7cf91        	l32r	a9, 40374ce4 <_iram_text_start+0x8e0> (3fc94c88 <xTasksWaitingTermination+0x8>)
4037ada9:	b39897        	bne	a8, a9, 4037ad60 <prvCheckTasksWaitingTermination+0x28>
                pxTCB = NULL;
4037adac:	070c      	movi.n	a7, 0
4037adae:	000086        	j	4037adb4 <prvCheckTasksWaitingTermination+0x7c>
4037adb1:	070c00        	lsi	f0, a12, 28
                taskEXIT_CRITICAL( &xKernelLock );
4037adb4:	e7c8a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037adb7:	ff4ca5        	call8	4037a280 <vPortExitCritical>
                if( pxTCB != NULL )
4037adba:	e78c      	beqz.n	a7, 4037adcc <prvCheckTasksWaitingTermination+0x94>
                    prvDeleteTCB( pxTCB );
4037adbc:	07ad      	mov.n	a10, a7
4037adbe:	fff325        	call8	4037acf0 <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
4037adc1:	e7c781        	l32r	a8, 40374ce0 <_iram_text_start+0x8dc> (3fc94c7c <uxDeletedTasksWaitingCleanUp>)
4037adc4:	0020c0        	memw
4037adc7:	0888      	l32i.n	a8, a8, 0
4037adc9:	f71856        	bnez	a8, 4037ad3e <prvCheckTasksWaitingTermination+0x6>
}
4037adcc:	f01d      	retw.n
	...

4037add0 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
4037add0:	004136        	entry	a1, 32
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
4037add3:	e7c581        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037add6:	0020c0        	memw
4037add9:	002862        	l32i	a6, a8, 0
4037addc:	03eb70        	rsr.prid	a7
4037addf:	047d70        	extui	a7, a7, 13, 1
    /* Get current core ID as we can no longer be preempted. */
    const BaseType_t xCurCoreID = portGET_CORE_ID();

    #if ( configNUMBER_OF_CORES > 1 )
    {
        if( listIS_CONTAINED_WITHIN( &xTasksWaitingTermination, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) ) == pdTRUE )
4037ade2:	e79781        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037ade5:	a08780        	addx4	a8, a7, a8
4037ade8:	0020c0        	memw
4037adeb:	002882        	l32i	a8, a8, 0
4037adee:	0020c0        	memw
4037adf1:	052892        	l32i	a9, a8, 20
4037adf4:	e7b981        	l32r	a8, 40374cd8 <_iram_text_start+0x8d4> (3fc94c80 <xTasksWaitingTermination>)
4037adf7:	029987        	bne	a9, a8, 4037adfd <prvAddCurrentTaskToDelayedList+0x2d>
4037adfa:	003a86        	j	4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
    #if ( INCLUDE_xTaskAbortDelay == 1 )
    {
        /* About to enter a delayed list, so ensure the ucDelayAborted flag is
         * reset to pdFALSE so it can be detected as having been set to pdTRUE
         * when the task leaves the Blocked state. */
        pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted = pdFALSE;
4037adfd:	e79081        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037ae00:	a08780        	addx4	a8, a7, a8
4037ae03:	0020c0        	memw
4037ae06:	0898      	l32i.n	a9, a8, 0
4037ae08:	01d992        	addmi	a9, a9, 0x100
4037ae0b:	0a0c      	movi.n	a10, 0
4037ae0d:	5249a2        	s8i	a10, a9, 82
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037ae10:	0020c0        	memw
4037ae13:	08a8      	l32i.n	a10, a8, 0
4037ae15:	aa4b      	addi.n	a10, a10, 4
4037ae17:	ffb7e5        	call8	4037a994 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
4037ae1a:	821b      	addi.n	a8, a2, 1
4037ae1c:	40f880        	nsau	a8, a8
4037ae1f:	418580        	srli	a8, a8, 5
4037ae22:	190c      	movi.n	a9, 1
4037ae24:	839330        	moveqz	a9, a3, a3
4037ae27:	5d0897        	bnone	a8, a9, 4037ae88 <prvAddCurrentTaskToDelayedList+0xb8>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037ae2a:	e7b091        	l32r	a9, 40374cec <_iram_text_start+0x8e8> (3fc94c68 <xSuspendedTaskList>)
4037ae2d:	0020c0        	memw
4037ae30:	19a8      	l32i.n	a10, a9, 4
4037ae32:	e78381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037ae35:	a08780        	addx4	a8, a7, a8
4037ae38:	0020c0        	memw
4037ae3b:	08b8      	l32i.n	a11, a8, 0
4037ae3d:	0020c0        	memw
4037ae40:	2ba9      	s32i.n	a10, a11, 8
4037ae42:	0020c0        	memw
4037ae45:	08b8      	l32i.n	a11, a8, 0
4037ae47:	0020c0        	memw
4037ae4a:	2ac8      	l32i.n	a12, a10, 8
4037ae4c:	0020c0        	memw
4037ae4f:	3bc9      	s32i.n	a12, a11, 12
4037ae51:	0020c0        	memw
4037ae54:	08b8      	l32i.n	a11, a8, 0
4037ae56:	0020c0        	memw
4037ae59:	2ac8      	l32i.n	a12, a10, 8
4037ae5b:	bb4b      	addi.n	a11, a11, 4
4037ae5d:	0020c0        	memw
4037ae60:	1cb9      	s32i.n	a11, a12, 4
4037ae62:	0020c0        	memw
4037ae65:	08b8      	l32i.n	a11, a8, 0
4037ae67:	bb4b      	addi.n	a11, a11, 4
4037ae69:	0020c0        	memw
4037ae6c:	2ab9      	s32i.n	a11, a10, 8
4037ae6e:	0020c0        	memw
4037ae71:	0888      	l32i.n	a8, a8, 0
4037ae73:	0020c0        	memw
4037ae76:	5899      	s32i.n	a9, a8, 20
4037ae78:	0020c0        	memw
4037ae7b:	0988      	l32i.n	a8, a9, 0
4037ae7d:	881b      	addi.n	a8, a8, 1
4037ae7f:	0020c0        	memw
4037ae82:	0989      	s32i.n	a8, a9, 0
4037ae84:	001806        	j	4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
4037ae87:	262000        	lsi	f0, a0, 152
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
4037ae8a:	6d8180        	lsi	f8, a1, 0x1b4

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ), xTimeToWake );
4037ae8d:	8780e7        	bany	a0, a14, 4037ae18 <prvAddCurrentTaskToDelayedList+0x48>
4037ae90:	20c0a0        	or	a12, a0, a10
4037ae93:	288200        	lsi	f0, a2, 160
4037ae96:	20c000        	or	a12, a0, a0
4037ae99:	682200        	lsi	f0, a2, 0x1a0
4037ae9c:	b26701        	l32r	a0, 40367838 <rom_rx_gain_force+0x36140c>

            if( xTimeToWake < xConstTickCount )
4037ae9f:	811c      	movi.n	a1, 24
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037aea1:	c0e794        	lsi	f9, a7, 0x300
4037aea4:	a80020        	lsi	f2, a0, 0x2a0
4037aea7:	8108      	l32i.n	a0, a1, 32
4037aea9:	80e766        	bnei	a7, 128, 4037ae2d <prvAddCurrentTaskToDelayedList+0x5d>
4037aeac:	c0a087        	bge	a0, a8, 4037ae70 <prvAddCurrentTaskToDelayedList+0xa0>
4037aeaf:	b80020        	lsi	f2, a0, 0x2e0
4037aeb2:	4b08      	l32i.n	a0, a11, 16
4037aeb4:	25bb      	addi.n	a2, a5, 11
4037aeb6:	ffa8      	l32i.n	a10, a15, 60
4037aeb8:	000b06        	j	4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
4037aebb:	810000        	src	a0, a0, a0
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037aebe:	c0e777        	bbsi	a7, 7, 4037ae82 <prvAddCurrentTaskToDelayedList+0xb2>
4037aec1:	a80020        	lsi	f2, a0, 0x2a0
4037aec4:	8108      	l32i.n	a0, a1, 32
4037aec6:	5e          	.byte	0x5e
4037aec7:	7780e7        	bany	a0, a14, 4037af42 <prvInitialiseNewTask+0x46>
4037aeca:	20c0a0        	or	a12, a0, a10
4037aecd:	07b800        	lsi	f0, a8, 28
4037aed0:	bb4b      	addi.n	a11, a11, 4
4037aed2:	ffa665        	call8	4037a938 <vListInsert>

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
4037aed5:	e77281        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94c40 <xNextTaskUnblockTime>)
4037aed8:	0020c0        	memw
4037aedb:	0888      	l32i.n	a8, a8, 0
4037aedd:	07b287        	bgeu	a2, a8, 4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
                {
                    xNextTaskUnblockTime = xTimeToWake;
4037aee0:	e77081        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94c40 <xNextTaskUnblockTime>)
4037aee3:	0020c0        	memw
4037aee6:	0829      	s32i.n	a2, a8, 0

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
4037aee8:	f01d      	retw.n
	...

4037aeec <prvIdleTask>:
{
4037aeec:	004136        	entry	a1, 32
        prvCheckTasksWaitingTermination();
4037aeef:	ffe4a5        	call8	4037ad38 <prvCheckTasksWaitingTermination>
        esp_vApplicationIdleHook();
4037aef2:	e78081        	l32r	a8, 40374cf4 <_iram_text_start+0x8f0> (42002784 <esp_vApplicationIdleHook>)
4037aef5:	0008e0        	callx8	a8
    for( ; ; )
4037aef8:	fffcc6        	j	4037aeef <prvIdleTask+0x3>
	...

4037aefc <prvInitialiseNewTask>:
{
4037aefc:	006136        	entry	a1, 48
4037aeff:	1179      	s32i.n	a7, a1, 4
4037af01:	0179      	s32i.n	a7, a1, 0
4037af03:	c178      	l32i.n	a7, a1, 48
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
4037af05:	04cd      	mov.n	a12, a4
4037af07:	a5a0b2        	movi	a11, 165
4037af0a:	c7a8      	l32i.n	a10, a7, 48
4037af0c:	e56181        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037af0f:	0008e0        	callx8	a8
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
4037af12:	c788      	l32i.n	a8, a7, 48
4037af14:	440b      	addi.n	a4, a4, -1
4037af16:	484a      	add.n	a4, a8, a4
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
4037af18:	087c      	movi.n	a8, -16
4037af1a:	104480        	and	a4, a4, a8
            pxNewTCB->pxEndOfStack = pxTopOfStack;
4037af1d:	126742        	s32i	a4, a7, 72
    if( pcName != NULL )
4037af20:	23dc      	bnez.n	a3, 4037af36 <prvInitialiseNewTask+0x3a>
4037af22:	000746        	j	4037af43 <prvInitialiseNewTask+0x47>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
4037af25:	938a      	add.n	a9, a3, a8
4037af27:	000992        	l8ui	a9, a9, 0
4037af2a:	a78a      	add.n	a10, a7, a8
4037af2c:	344a92        	s8i	a9, a10, 52
            if( pcName[ x ] == ( char ) 0x00 )
4037af2f:	b98c      	beqz.n	a9, 4037af3e <prvInitialiseNewTask+0x42>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
4037af31:	881b      	addi.n	a8, a8, 1
4037af33:	000046        	j	4037af38 <prvInitialiseNewTask+0x3c>
4037af36:	080c      	movi.n	a8, 0
4037af38:	0fa092        	movi	a9, 15
4037af3b:	e6b987        	bgeu	a9, a8, 4037af25 <prvInitialiseNewTask+0x29>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
4037af3e:	080c      	movi.n	a8, 0
4037af40:	434782        	s8i	a8, a7, 67
    configASSERT( uxPriority < configMAX_PRIORITIES );
4037af43:	881c      	movi.n	a8, 24
4037af45:	11b867        	bgeu	a8, a6, 4037af5a <prvInitialiseNewTask+0x5e>
4037af48:	e76cd1        	l32r	a13, 40374cf8 <_iram_text_start+0x8f4> (3c024568 <_flash_rodata_start+0x4448>)
4037af4b:	e76cc1        	l32r	a12, 40374cfc <_iram_text_start+0x8f8> (3c028258 <__func__$5>)
4037af4e:	40a4b2        	movi	a11, 0x440
4037af51:	e756a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037af54:	201110        	or	a1, a1, a1
4037af57:	04e4a5        	call8	4037fda0 <__assert_func>
    pxNewTCB->uxPriority = uxPriority;
4037af5a:	b769      	s32i.n	a6, a7, 44
        pxNewTCB->xCoreID = xCoreID;
4037af5c:	e188      	l32i.n	a8, a1, 56
4037af5e:	116782        	s32i	a8, a7, 68
        pxNewTCB->uxBasePriority = uxPriority;
4037af61:	136762        	s32i	a6, a7, 76
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
4037af64:	04c7a2        	addi	a10, a7, 4
4037af67:	ff98a5        	call8	4037a8f0 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
4037af6a:	18c7a2        	addi	a10, a7, 24
4037af6d:	ff9825        	call8	4037a8f0 <vListInitialiseItem>
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
4037af70:	4779      	s32i.n	a7, a7, 16
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037af72:	e7c662        	addi	a6, a6, -25
4037af75:	606060        	neg	a6, a6
4037af78:	0020c0        	memw
4037af7b:	6769      	s32i.n	a6, a7, 24
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
4037af7d:	9779      	s32i.n	a7, a7, 36
        configINIT_TLS_BLOCK( pxNewTCB->xTLSBlock );
4037af7f:	5cc7a2        	addi	a10, a7, 92
4037af82:	fbc6e5        	call8	40376bf0 <esp_reent_init>
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
4037af85:	05cd      	mov.n	a12, a5
4037af87:	02bd      	mov.n	a11, a2
4037af89:	04ad      	mov.n	a10, a4
4037af8b:	ff0e65        	call8	4037a070 <pxPortInitialiseStack>
4037af8e:	07a9      	s32i.n	a10, a7, 0
    if( pxCreatedTask != NULL )
4037af90:	0188      	l32i.n	a8, a1, 0
4037af92:	288c      	beqz.n	a8, 4037af98 <prvInitialiseNewTask+0x9c>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
4037af94:	1188      	l32i.n	a8, a1, 4
4037af96:	0879      	s32i.n	a7, a8, 0
}
4037af98:	f01d      	retw.n
	...

4037af9c <prvInitialiseTaskLists>:
{
4037af9c:	004136        	entry	a1, 32
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037af9f:	070c      	movi.n	a7, 0
4037afa1:	000406        	j	4037afb5 <prvInitialiseTaskLists+0x19>
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
4037afa4:	a09770        	addx4	a9, a7, a7
4037afa7:	1189e0        	slli	a8, a9, 2
4037afaa:	e742a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037afad:	80aa80        	add	a10, a10, a8
4037afb0:	ff91a5        	call8	4037a8cc <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037afb3:	771b      	addi.n	a7, a7, 1
4037afb5:	881c      	movi.n	a8, 24
4037afb7:	e9b877        	bgeu	a8, a7, 4037afa4 <prvInitialiseTaskLists+0x8>
    vListInitialise( &xDelayedTaskList1 );
4037afba:	e751a1        	l32r	a10, 40374d00 <_iram_text_start+0x8fc> (3fc94cd8 <xDelayedTaskList1>)
4037afbd:	ff90e5        	call8	4037a8cc <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
4037afc0:	e751a1        	l32r	a10, 40374d04 <_iram_text_start+0x900> (3fc94cc4 <xDelayedTaskList2>)
4037afc3:	ff90a5        	call8	4037a8cc <vListInitialise>
    for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037afc6:	070c      	movi.n	a7, 0
4037afc8:	000406        	j	4037afdc <prvInitialiseTaskLists+0x40>
        vListInitialise( &xPendingReadyList[ x ] );
4037afcb:	a09770        	addx4	a9, a7, a7
4037afce:	1189e0        	slli	a8, a9, 2
4037afd1:	e74da1        	l32r	a10, 40374d08 <_iram_text_start+0x904> (3fc94c94 <xPendingReadyList>)
4037afd4:	80aa80        	add	a10, a10, a8
4037afd7:	ff8f65        	call8	4037a8cc <vListInitialise>
    for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037afda:	771b      	addi.n	a7, a7, 1
4037afdc:	eb27b6        	bltui	a7, 2, 4037afcb <prvInitialiseTaskLists+0x2f>
        vListInitialise( &xTasksWaitingTermination );
4037afdf:	e73ea1        	l32r	a10, 40374cd8 <_iram_text_start+0x8d4> (3fc94c80 <xTasksWaitingTermination>)
4037afe2:	ff8ea5        	call8	4037a8cc <vListInitialise>
        vListInitialise( &xSuspendedTaskList );
4037afe5:	e741a1        	l32r	a10, 40374cec <_iram_text_start+0x8e8> (3fc94c68 <xSuspendedTaskList>)
4037afe8:	ff8e25        	call8	4037a8cc <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
4037afeb:	e72c81        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94cc0 <pxDelayedTaskList>)
4037afee:	e74491        	l32r	a9, 40374d00 <_iram_text_start+0x8fc> (3fc94cd8 <xDelayedTaskList1>)
4037aff1:	0020c0        	memw
4037aff4:	0899      	s32i.n	a9, a8, 0
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
4037aff6:	e73e81        	l32r	a8, 40374cf0 <_iram_text_start+0x8ec> (3fc94cbc <pxOverflowDelayedTaskList>)
4037aff9:	e74291        	l32r	a9, 40374d04 <_iram_text_start+0x900> (3fc94cc4 <xDelayedTaskList2>)
4037affc:	0020c0        	memw
4037afff:	0899      	s32i.n	a9, a8, 0
}
4037b001:	f01d      	retw.n
	...

4037b004 <prvAddNewTaskToReadyList>:
{
4037b004:	004136        	entry	a1, 32
4037b007:	ffafb2        	movi	a11, -1
4037b00a:	e732a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b00d:	ff1225        	call8	4037a130 <xPortEnterCriticalTimeout>
        uxCurrentNumberOfTasks++;
4037b010:	e73381        	l32r	a8, 40374cdc <_iram_text_start+0x8d8> (3fc94c64 <uxCurrentNumberOfTasks>)
4037b013:	0020c0        	memw
4037b016:	002892        	l32i	a9, a8, 0
4037b019:	991b      	addi.n	a9, a9, 1
4037b01b:	0020c0        	memw
4037b01e:	0899      	s32i.n	a9, a8, 0
        if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
4037b020:	0020c0        	memw
4037b023:	002882        	l32i	a8, a8, 0
4037b026:	021866        	bnei	a8, 1, 4037b02c <prvAddNewTaskToReadyList+0x28>
            prvInitialiseTaskLists();
4037b029:	fff725        	call8	4037af9c <prvInitialiseTaskLists>
        if( ( pxCurrentTCBs[ 0 ] == NULL ) && ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) )
4037b02c:	e70581        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b02f:	0020c0        	memw
4037b032:	0888      	l32i.n	a8, a8, 0
4037b034:	48ec      	bnez.n	a8, 4037b05c <prvAddNewTaskToReadyList+0x58>
4037b036:	112282        	l32i	a8, a2, 68
4037b039:	40f890        	nsau	a9, a8
4037b03c:	419590        	srli	a9, a9, 5
4037b03f:	e5f2a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b042:	c088a0        	sub	a8, a8, a10
4037b045:	40f880        	nsau	a8, a8
4037b048:	418580        	srli	a8, a8, 5
4037b04b:	209980        	or	a9, a9, a8
4037b04e:	a98c      	beqz.n	a9, 4037b05c <prvAddNewTaskToReadyList+0x58>
            pxCurrentTCBs[ 0 ] = pxNewTCB;
4037b050:	e6fc81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b053:	0020c0        	memw
4037b056:	0829      	s32i.n	a2, a8, 0
4037b058:	002e46        	j	4037b115 <prvAddNewTaskToReadyList+0x111>
4037b05b:	f98100        	lsi	f0, a1, 0x3e4
            else if( ( pxCurrentTCBs[ 1 ] == NULL ) && ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) )
4037b05e:	20c0e6        	bgei	a0, 32, 4037b082 <prvAddNewTaskToReadyList+0x7e>
4037b061:	188800        	lsxp	f8, a8, a0
4037b064:	58ec      	bnez.n	a8, 4037b08d <prvAddNewTaskToReadyList+0x89>
4037b066:	112282        	l32i	a8, a2, 68
4037b069:	980b      	addi.n	a9, a8, -1
4037b06b:	40f990        	nsau	a9, a9
4037b06e:	419590        	srli	a9, a9, 5
4037b071:	e5e5a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b074:	c088a0        	sub	a8, a8, a10
4037b077:	40f880        	nsau	a8, a8
4037b07a:	418580        	srli	a8, a8, 5
4037b07d:	209980        	or	a9, a9, a8
4037b080:	998c      	beqz.n	a9, 4037b08d <prvAddNewTaskToReadyList+0x89>
                pxCurrentTCBs[ 1 ] = pxNewTCB;
4037b082:	e6ef81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b085:	0020c0        	memw
4037b088:	1829      	s32i.n	a2, a8, 4
4037b08a:	0021c6        	j	4037b115 <prvAddNewTaskToReadyList+0x111>
            if( xSchedulerRunning == pdFALSE )
4037b08d:	e71f81        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94c58 <xSchedulerRunning>)
4037b090:	0020c0        	memw
4037b093:	0888      	l32i.n	a8, a8, 0
4037b095:	07c856        	bnez	a8, 4037b115 <prvAddNewTaskToReadyList+0x111>
                if( ( pxCurrentTCBs[ 0 ] != NULL ) &&
4037b098:	e6ea81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b09b:	0020c0        	memw
4037b09e:	0888      	l32i.n	a8, a8, 0
4037b0a0:	48bc      	beqz.n	a8, 4037b0d8 <prvAddNewTaskToReadyList+0xd4>
                    ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) &&
4037b0a2:	112282        	l32i	a8, a2, 68
4037b0a5:	40f890        	nsau	a9, a8
4037b0a8:	419590        	srli	a9, a9, 5
4037b0ab:	e5d7a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b0ae:	c088a0        	sub	a8, a8, a10
4037b0b1:	40f880        	nsau	a8, a8
4037b0b4:	418580        	srli	a8, a8, 5
4037b0b7:	209980        	or	a9, a9, a8
                if( ( pxCurrentTCBs[ 0 ] != NULL ) &&
4037b0ba:	a99c      	beqz.n	a9, 4037b0d8 <prvAddNewTaskToReadyList+0xd4>
                    ( pxCurrentTCBs[ 0 ]->uxPriority <= pxNewTCB->uxPriority ) )
4037b0bc:	e6e181        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b0bf:	0020c0        	memw
4037b0c2:	0888      	l32i.n	a8, a8, 0
4037b0c4:	b888      	l32i.n	a8, a8, 44
4037b0c6:	b298      	l32i.n	a9, a2, 44
                    ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) &&
4037b0c8:	0c3987        	bltu	a9, a8, 4037b0d8 <prvAddNewTaskToReadyList+0xd4>
                    pxCurrentTCBs[ 0 ] = pxNewTCB;
4037b0cb:	e6dd81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b0ce:	0020c0        	memw
4037b0d1:	0829      	s32i.n	a2, a8, 0
4037b0d3:	000f86        	j	4037b115 <prvAddNewTaskToReadyList+0x111>
4037b0d6:	810000        	src	a0, a0, a0
                    else if( ( pxCurrentTCBs[ 1 ] != NULL ) &&
4037b0d9:	e6da      	add.n	a14, a6, a13
4037b0db:	0020c0        	memw
4037b0de:	1888      	l32i.n	a8, a8, 4
4037b0e0:	18bc      	beqz.n	a8, 4037b115 <prvAddNewTaskToReadyList+0x111>
                             ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) &&
4037b0e2:	112282        	l32i	a8, a2, 68
4037b0e5:	980b      	addi.n	a9, a8, -1
4037b0e7:	40f990        	nsau	a9, a9
4037b0ea:	419590        	srli	a9, a9, 5
4037b0ed:	e5c6a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b0f0:	c088a0        	sub	a8, a8, a10
4037b0f3:	40f880        	nsau	a8, a8
4037b0f6:	418580        	srli	a8, a8, 5
4037b0f9:	209980        	or	a9, a9, a8
                    else if( ( pxCurrentTCBs[ 1 ] != NULL ) &&
4037b0fc:	599c      	beqz.n	a9, 4037b115 <prvAddNewTaskToReadyList+0x111>
                             ( pxCurrentTCBs[ 1 ]->uxPriority <= pxNewTCB->uxPriority ) )
4037b0fe:	e6d081        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b101:	0020c0        	memw
4037b104:	1888      	l32i.n	a8, a8, 4
4037b106:	b888      	l32i.n	a8, a8, 44
4037b108:	b298      	l32i.n	a9, a2, 44
                             ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) &&
4037b10a:	073987        	bltu	a9, a8, 4037b115 <prvAddNewTaskToReadyList+0x111>
                        pxCurrentTCBs[ 1 ] = pxNewTCB;
4037b10d:	e6cc81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b110:	0020c0        	memw
4037b113:	1829      	s32i.n	a2, a8, 4
        uxTaskNumber++;
4037b115:	e6fe91        	l32r	a9, 40374d10 <_iram_text_start+0x90c> (3fc94c44 <uxTaskNumber>)
4037b118:	0988      	l32i.n	a8, a9, 0
4037b11a:	881b      	addi.n	a8, a8, 1
4037b11c:	0989      	s32i.n	a8, a9, 0
        prvAddTaskToReadyList( pxNewTCB );
4037b11e:	b288      	l32i.n	a8, a2, 44
4037b120:	e6e491        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b123:	0020c0        	memw
4037b126:	0998      	l32i.n	a9, a9, 0
4037b128:	07b987        	bgeu	a9, a8, 4037b133 <prvAddNewTaskToReadyList+0x12f>
4037b12b:	e6e191        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b12e:	0020c0        	memw
4037b131:	0989      	s32i.n	a8, a9, 0
4037b133:	e6e0a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037b136:	a08880        	addx4	a8, a8, a8
4037b139:	a088a0        	addx4	a8, a8, a10
4037b13c:	0020c0        	memw
4037b13f:	1888      	l32i.n	a8, a8, 4
4037b141:	0020c0        	memw
4037b144:	2289      	s32i.n	a8, a2, 8
4037b146:	0020c0        	memw
4037b149:	2898      	l32i.n	a9, a8, 8
4037b14b:	0020c0        	memw
4037b14e:	3299      	s32i.n	a9, a2, 12
4037b150:	0020c0        	memw
4037b153:	28b8      	l32i.n	a11, a8, 8
4037b155:	924b      	addi.n	a9, a2, 4
4037b157:	0020c0        	memw
4037b15a:	1b99      	s32i.n	a9, a11, 4
4037b15c:	0020c0        	memw
4037b15f:	2899      	s32i.n	a9, a8, 8
4037b161:	b288      	l32i.n	a8, a2, 44
4037b163:	a09880        	addx4	a9, a8, a8
4037b166:	a099a0        	addx4	a9, a9, a10
4037b169:	0020c0        	memw
4037b16c:	5299      	s32i.n	a9, a2, 20
4037b16e:	0020c0        	memw
4037b171:	0998      	l32i.n	a9, a9, 0
4037b173:	991b      	addi.n	a9, a9, 1
4037b175:	a08880        	addx4	a8, a8, a8
4037b178:	a088a0        	addx4	a8, a8, a10
4037b17b:	0020c0        	memw
4037b17e:	0899      	s32i.n	a9, a8, 0
        if( xSchedulerRunning != pdFALSE )
4037b180:	e6e381        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94c58 <xSchedulerRunning>)
4037b183:	0020c0        	memw
4037b186:	0888      	l32i.n	a8, a8, 0
4037b188:	489c      	beqz.n	a8, 4037b1a0 <prvAddNewTaskToReadyList+0x19c>
            if( taskIS_YIELD_REQUIRED( pxNewTCB, pdTRUE ) == pdTRUE )
4037b18a:	1c0c      	movi.n	a12, 1
4037b18c:	b2b8      	l32i.n	a11, a2, 44
4037b18e:	20a220        	or	a10, a2, a2
4037b191:	ff8da5        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037b194:	081a66        	bnei	a10, 1, 4037b1a0 <prvAddNewTaskToReadyList+0x19c>
4037b197:	03eba0        	rsr.prid	a10
4037b19a:	04ada0        	extui	a10, a10, 13, 1
                taskYIELD_IF_USING_PREEMPTION();
4037b19d:	fcf2e5        	call8	403780cc <esp_crosscore_int_send_yield>
    taskEXIT_CRITICAL( &xKernelLock );
4037b1a0:	e6cda1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b1a3:	ff0de5        	call8	4037a280 <vPortExitCritical>
}
4037b1a6:	f01d      	retw.n

4037b1a8 <vTaskSuspendAll>:
{
4037b1a8:	004136        	entry	a1, 32
4037b1ab:	ffafb2        	movi	a11, -1
4037b1ae:	e6c9a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b1b1:	fef7e5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b1b4:	03eb80        	rsr.prid	a8
4037b1b7:	048d80        	extui	a8, a8, 13, 1
        ++uxSchedulerSuspended[ portGET_CORE_ID() ];
4037b1ba:	e6b791        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037b1bd:	a08890        	addx4	a8, a8, a9
4037b1c0:	0020c0        	memw
4037b1c3:	002892        	l32i	a9, a8, 0
4037b1c6:	991b      	addi.n	a9, a9, 1
4037b1c8:	0020c0        	memw
4037b1cb:	006892        	s32i	a9, a8, 0
    prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037b1ce:	e6c1a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b1d1:	ff0ae5        	call8	4037a280 <vPortExitCritical>
}
4037b1d4:	f01d      	retw.n
	...

4037b1d8 <xTaskGetTickCount>:
{
4037b1d8:	004136        	entry	a1, 32
        xTicks = xTickCount;
4037b1db:	e6c381        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037b1de:	0020c0        	memw
4037b1e1:	0828      	l32i.n	a2, a8, 0
}
4037b1e3:	f01d      	retw.n
4037b1e5:	000000        	ill

4037b1e8 <xTaskGetTickCountFromISR>:
{
4037b1e8:	004136        	entry	a1, 32
4037b1eb:	ffafb2        	movi	a11, -1
4037b1ee:	e6b9a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b1f1:	fef3e5        	call8	4037a130 <xPortEnterCriticalTimeout>
            xReturn = xTickCount;
4037b1f4:	e6bd81        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037b1f7:	0020c0        	memw
4037b1fa:	002822        	l32i	a2, a8, 0
    prvEXIT_CRITICAL_ISR_SMP_ONLY( &xKernelLock );
4037b1fd:	e6b5a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b200:	ff07e5        	call8	4037a280 <vPortExitCritical>
}
4037b203:	000090        	retw
	...

4037b208 <xTaskIncrementTick>:
{
4037b208:	004136        	entry	a1, 32
4037b20b:	03eb80        	rsr.prid	a8
4037b20e:	048d80        	extui	a8, a8, 13, 1
        configASSERT( portGET_CORE_ID() == 0 );
4037b211:	00e816        	beqz	a8, 4037b223 <xTaskIncrementTick+0x1b>
4037b214:	e6c0d1        	l32r	a13, 40374d14 <_iram_text_start+0x910> (3c024584 <_flash_rodata_start+0x4464>)
4037b217:	e6c0c1        	l32r	a12, 40374d18 <_iram_text_start+0x914> (3c02839c <__func__$25>)
4037b21a:	e6c0b1        	l32r	a11, 40374d1c <_iram_text_start+0x918> (c7b <UserFrameTotalSize+0xb7b>)
4037b21d:	e6a3a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b220:	04b7e5        	call8	4037fda0 <__assert_func>
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b223:	feeea5        	call8	4037a10c <xPortInIsrContext>
4037b226:	9acc      	bnez.n	a10, 4037b233 <xTaskIncrementTick+0x2b>
4037b228:	fb7c      	movi.n	a11, -1
4037b22a:	e6aaa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b22d:	fef025        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037b230:	000206        	j	4037b23c <xTaskIncrementTick+0x34>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b233:	ffafb2        	movi	a11, -1
4037b236:	e6a7a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b239:	feef65        	call8	4037a130 <xPortEnterCriticalTimeout>
        if( uxSchedulerSuspended[ 0 ] == ( UBaseType_t ) pdFALSE )
4037b23c:	e69781        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037b23f:	0020c0        	memw
4037b242:	002882        	l32i	a8, a8, 0
4037b245:	257856        	bnez	a8, 4037b4a0 <xTaskIncrementTick+0x298>
            const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
4037b248:	e6a881        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037b24b:	0020c0        	memw
4037b24e:	0878      	l32i.n	a7, a8, 0
4037b250:	771b      	addi.n	a7, a7, 1
            xTickCount = xConstTickCount;
4037b252:	0020c0        	memw
4037b255:	0879      	s32i.n	a7, a8, 0
            if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
4037b257:	04d756        	bnez	a7, 4037b2a8 <xTaskIncrementTick+0xa0>
                taskSWITCH_DELAYED_LISTS();
4037b25a:	e69081        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94cc0 <pxDelayedTaskList>)
4037b25d:	0020c0        	memw
4037b260:	0888      	l32i.n	a8, a8, 0
4037b262:	0020c0        	memw
4037b265:	0888      	l32i.n	a8, a8, 0
4037b267:	00e816        	beqz	a8, 4037b279 <xTaskIncrementTick+0x71>
4037b26a:	e6add1        	l32r	a13, 40374d20 <_iram_text_start+0x91c> (3c02459c <_flash_rodata_start+0x447c>)
4037b26d:	e6aac1        	l32r	a12, 40374d18 <_iram_text_start+0x914> (3c02839c <__func__$25>)
4037b270:	e6adb1        	l32r	a11, 40374d24 <_iram_text_start+0x920> (c9b <UserFrameTotalSize+0xb9b>)
4037b273:	e68ea1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b276:	04b2a5        	call8	4037fda0 <__assert_func>
4037b279:	e68891        	l32r	a9, 40374c9c <_iram_text_start+0x898> (3fc94cc0 <pxDelayedTaskList>)
4037b27c:	0020c0        	memw
4037b27f:	0029a2        	l32i	a10, a9, 0
4037b282:	e69b81        	l32r	a8, 40374cf0 <_iram_text_start+0x8ec> (3fc94cbc <pxOverflowDelayedTaskList>)
4037b285:	0020c0        	memw
4037b288:	0028b2        	l32i	a11, a8, 0
4037b28b:	0020c0        	memw
4037b28e:	0069b2        	s32i	a11, a9, 0
4037b291:	0020c0        	memw
4037b294:	08a9      	s32i.n	a10, a8, 0
4037b296:	e6a491        	l32r	a9, 40374d28 <_iram_text_start+0x924> (3fc94c48 <xNumOfOverflows>)
4037b299:	0020c0        	memw
4037b29c:	0988      	l32i.n	a8, a9, 0
4037b29e:	881b      	addi.n	a8, a8, 1
4037b2a0:	0020c0        	memw
4037b2a3:	0989      	s32i.n	a8, a9, 0
4037b2a5:	ff78a5        	call8	4037aa30 <prvResetNextTaskUnblockTime>
            if( xConstTickCount >= xNextTaskUnblockTime )
4037b2a8:	e67e81        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94c40 <xNextTaskUnblockTime>)
4037b2ab:	0020c0        	memw
4037b2ae:	0888      	l32i.n	a8, a8, 0
4037b2b0:	0ab787        	bgeu	a7, a8, 4037b2be <xTaskIncrementTick+0xb6>
    BaseType_t xSwitchRequired = pdFALSE;
4037b2b3:	020c      	movi.n	a2, 0
4037b2b5:	006ec6        	j	4037b474 <xTaskIncrementTick+0x26c>
                                    xSwitchRequired = pdTRUE;
4037b2b8:	120c      	movi.n	a2, 1
4037b2ba:	000086        	j	4037b2c0 <xTaskIncrementTick+0xb8>
4037b2bd:	020c00        	andb	b0, b12, b0
                    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037b2c0:	e67781        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94cc0 <pxDelayedTaskList>)
4037b2c3:	0020c0        	memw
4037b2c6:	0888      	l32i.n	a8, a8, 0
4037b2c8:	0020c0        	memw
4037b2cb:	0888      	l32i.n	a8, a8, 0
4037b2cd:	b8cc      	bnez.n	a8, 4037b2dc <xTaskIncrementTick+0xd4>
                        xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037b2cf:	e67481        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94c40 <xNextTaskUnblockTime>)
4037b2d2:	f97c      	movi.n	a9, -1
4037b2d4:	0020c0        	memw
4037b2d7:	0899      	s32i.n	a9, a8, 0
                        break;
4037b2d9:	0065c6        	j	4037b474 <xTaskIncrementTick+0x26c>
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b2dc:	e67081        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94cc0 <pxDelayedTaskList>)
4037b2df:	0020c0        	memw
4037b2e2:	0888      	l32i.n	a8, a8, 0
4037b2e4:	0020c0        	memw
4037b2e7:	3888      	l32i.n	a8, a8, 12
4037b2e9:	3888      	l32i.n	a8, a8, 12
                        xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
4037b2eb:	0020c0        	memw
4037b2ee:	1898      	l32i.n	a9, a8, 4
                        if( xConstTickCount < xItemValue )
4037b2f0:	0db797        	bgeu	a7, a9, 4037b301 <xTaskIncrementTick+0xf9>
                            xNextTaskUnblockTime = xItemValue;
4037b2f3:	e66b81        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94c40 <xNextTaskUnblockTime>)
4037b2f6:	0020c0        	memw
4037b2f9:	0899      	s32i.n	a9, a8, 0
                            break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
4037b2fb:	005d46        	j	4037b474 <xTaskIncrementTick+0x26c>
4037b2fe:	000000        	ill
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037b301:	0020c0        	memw
4037b304:	5898      	l32i.n	a9, a8, 20
4037b306:	0020c0        	memw
4037b309:	28a8      	l32i.n	a10, a8, 8
4037b30b:	0020c0        	memw
4037b30e:	38b8      	l32i.n	a11, a8, 12
4037b310:	0020c0        	memw
4037b313:	2ab9      	s32i.n	a11, a10, 8
4037b315:	0020c0        	memw
4037b318:	38a8      	l32i.n	a10, a8, 12
4037b31a:	0020c0        	memw
4037b31d:	28b8      	l32i.n	a11, a8, 8
4037b31f:	0020c0        	memw
4037b322:	1ab9      	s32i.n	a11, a10, 4
4037b324:	0020c0        	memw
4037b327:	19b8      	l32i.n	a11, a9, 4
4037b329:	a84b      	addi.n	a10, a8, 4
4037b32b:	0a9ba7        	bne	a11, a10, 4037b339 <xTaskIncrementTick+0x131>
4037b32e:	0020c0        	memw
4037b331:	0328b2        	l32i	a11, a8, 12
4037b334:	0020c0        	memw
4037b337:	19b9      	s32i.n	a11, a9, 4
4037b339:	0b0c      	movi.n	a11, 0
4037b33b:	0020c0        	memw
4037b33e:	58b9      	s32i.n	a11, a8, 20
4037b340:	0020c0        	memw
4037b343:	09b8      	l32i.n	a11, a9, 0
4037b345:	bb0b      	addi.n	a11, a11, -1
4037b347:	0020c0        	memw
4037b34a:	09b9      	s32i.n	a11, a9, 0
                        if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037b34c:	0020c0        	memw
4037b34f:	a898      	l32i.n	a9, a8, 40
4037b351:	04c916        	beqz	a9, 4037b3a1 <xTaskIncrementTick+0x199>
                            listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
4037b354:	0020c0        	memw
4037b357:	a898      	l32i.n	a9, a8, 40
4037b359:	0020c0        	memw
4037b35c:	78b8      	l32i.n	a11, a8, 28
4037b35e:	0020c0        	memw
4037b361:	88c8      	l32i.n	a12, a8, 32
4037b363:	0020c0        	memw
4037b366:	2bc9      	s32i.n	a12, a11, 8
4037b368:	0020c0        	memw
4037b36b:	88b8      	l32i.n	a11, a8, 32
4037b36d:	0020c0        	memw
4037b370:	78c8      	l32i.n	a12, a8, 28
4037b372:	0020c0        	memw
4037b375:	1bc9      	s32i.n	a12, a11, 4
4037b377:	0020c0        	memw
4037b37a:	19c8      	l32i.n	a12, a9, 4
4037b37c:	18c8b2        	addi	a11, a8, 24
4037b37f:	0a9cb7        	bne	a12, a11, 4037b38d <xTaskIncrementTick+0x185>
4037b382:	0020c0        	memw
4037b385:	0828b2        	l32i	a11, a8, 32
4037b388:	0020c0        	memw
4037b38b:	19b9      	s32i.n	a11, a9, 4
4037b38d:	0b0c      	movi.n	a11, 0
4037b38f:	0020c0        	memw
4037b392:	a8b9      	s32i.n	a11, a8, 40
4037b394:	0020c0        	memw
4037b397:	09b8      	l32i.n	a11, a9, 0
4037b399:	ffcbb2        	addi	a11, a11, -1
4037b39c:	0020c0        	memw
4037b39f:	09b9      	s32i.n	a11, a9, 0
                        prvAddTaskToReadyList( pxTCB );
4037b3a1:	b898      	l32i.n	a9, a8, 44
4037b3a3:	e643b1        	l32r	a11, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b3a6:	0020c0        	memw
4037b3a9:	002bb2        	l32i	a11, a11, 0
4037b3ac:	08bb97        	bgeu	a11, a9, 4037b3b8 <xTaskIncrementTick+0x1b0>
4037b3af:	e640b1        	l32r	a11, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b3b2:	0020c0        	memw
4037b3b5:	006b92        	s32i	a9, a11, 0
4037b3b8:	e63fb1        	l32r	a11, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037b3bb:	a09990        	addx4	a9, a9, a9
4037b3be:	a099b0        	addx4	a9, a9, a11
4037b3c1:	0020c0        	memw
4037b3c4:	1998      	l32i.n	a9, a9, 4
4037b3c6:	0020c0        	memw
4037b3c9:	2899      	s32i.n	a9, a8, 8
4037b3cb:	0020c0        	memw
4037b3ce:	29c8      	l32i.n	a12, a9, 8
4037b3d0:	0020c0        	memw
4037b3d3:	38c9      	s32i.n	a12, a8, 12
4037b3d5:	0020c0        	memw
4037b3d8:	29c8      	l32i.n	a12, a9, 8
4037b3da:	0020c0        	memw
4037b3dd:	1ca9      	s32i.n	a10, a12, 4
4037b3df:	0020c0        	memw
4037b3e2:	29a9      	s32i.n	a10, a9, 8
4037b3e4:	b898      	l32i.n	a9, a8, 44
4037b3e6:	a0a990        	addx4	a10, a9, a9
4037b3e9:	a0aab0        	addx4	a10, a10, a11
4037b3ec:	0020c0        	memw
4037b3ef:	58a9      	s32i.n	a10, a8, 20
4037b3f1:	0020c0        	memw
4037b3f4:	0aa8      	l32i.n	a10, a10, 0
4037b3f6:	aa1b      	addi.n	a10, a10, 1
4037b3f8:	a09990        	addx4	a9, a9, a9
4037b3fb:	a099b0        	addx4	a9, a9, a11
4037b3fe:	0020c0        	memw
4037b401:	09a9      	s32i.n	a10, a9, 0
                            if( taskIS_AFFINITY_COMPATIBLE( 0, pxTCB ) == pdTRUE )
4037b403:	1128b2        	l32i	a11, a8, 68
4037b406:	40fba0        	nsau	a10, a11
4037b409:	41a5a0        	srli	a10, a10, 5
4037b40c:	e4ff91        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b40f:	c09b90        	sub	a9, a11, a9
4037b412:	40f990        	nsau	a9, a9
4037b415:	419590        	srli	a9, a9, 5
4037b418:	20aa90        	or	a10, a10, a9
4037b41b:	6abc      	beqz.n	a10, 4037b455 <xTaskIncrementTick+0x24d>
                                if( pxTCB->uxPriority > pxCurrentTCBs[ 0 ]->uxPriority )
4037b41d:	b888      	l32i.n	a8, a8, 44
4037b41f:	e60891        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b422:	0020c0        	memw
4037b425:	0998      	l32i.n	a9, a9, 0
4037b427:	b998      	l32i.n	a9, a9, 44
4037b429:	02b987        	bgeu	a9, a8, 4037b42f <xTaskIncrementTick+0x227>
4037b42c:	ffa206        	j	4037b2b8 <xTaskIncrementTick+0xb0>
                                    else if( pxTCB->xCoreID == tskNO_AFFINITY )
4037b42f:	e4f691        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b432:	021b97        	beq	a11, a9, 4037b438 <xTaskIncrementTick+0x230>
4037b435:	ffa1c6        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                        if( pxTCB->uxPriority > pxCurrentTCBs[ 1 ]->uxPriority )
4037b438:	e60291        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b43b:	0020c0        	memw
4037b43e:	1998      	l32i.n	a9, a9, 4
4037b440:	b998      	l32i.n	a9, a9, 44
4037b442:	023987        	bltu	a9, a8, 4037b448 <xTaskIncrementTick+0x240>
4037b445:	ff9dc6        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                            xYieldPending[ 1 ] = pdTRUE;
4037b448:	e63981        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037b44b:	190c      	movi.n	a9, 1
4037b44d:	0020c0        	memw
4037b450:	1899      	s32i.n	a9, a8, 4
4037b452:	ff9a86        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                    if( pxTCB->uxPriority > pxCurrentTCBs[ 1 ]->uxPriority )
4037b455:	b888      	l32i.n	a8, a8, 44
4037b457:	e5fa91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b45a:	0020c0        	memw
4037b45d:	1998      	l32i.n	a9, a9, 4
4037b45f:	b998      	l32i.n	a9, a9, 44
4037b461:	023987        	bltu	a9, a8, 4037b467 <xTaskIncrementTick+0x25f>
4037b464:	ff9606        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                        xYieldPending[ 1 ] = pdTRUE;
4037b467:	e63181        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037b46a:	190c      	movi.n	a9, 1
4037b46c:	0020c0        	memw
4037b46f:	1899      	s32i.n	a9, a8, 4
4037b471:	ff92c6        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCBs[ 0 ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037b474:	e5f381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b477:	0020c0        	memw
4037b47a:	0888      	l32i.n	a8, a8, 0
4037b47c:	b888      	l32i.n	a8, a8, 44
4037b47e:	a08880        	addx4	a8, a8, a8
4037b481:	e60c91        	l32r	a9, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037b484:	a08890        	addx4	a8, a8, a9
4037b487:	0020c0        	memw
4037b48a:	0888      	l32i.n	a8, a8, 0
4037b48c:	0128b6        	bltui	a8, 2, 4037b491 <xTaskIncrementTick+0x289>
                    xSwitchRequired = pdTRUE;
4037b48f:	120c      	movi.n	a2, 1
                if( xYieldPending[ 0 ] != pdFALSE )
4037b491:	e62681        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037b494:	0020c0        	memw
4037b497:	0888      	l32i.n	a8, a8, 0
4037b499:	88dc      	bnez.n	a8, 4037b4b5 <xTaskIncrementTick+0x2ad>
4037b49b:	000646        	j	4037b4b8 <xTaskIncrementTick+0x2b0>
4037b49e:	910000        	srl	a0, a0
            ++xPendedTicks;
4037b4a1:	c0e624        	lsi	f2, a6, 0x300
4037b4a4:	880020        	lsi	f2, a0, 0x220
4037b4a7:	1b09      	s32i.n	a0, a11, 4
4037b4a9:	c088      	l32i.n	a8, a0, 48
4037b4ab:	890020        	lsi	f2, a0, 0x224
4037b4ae:	0c09      	s32i.n	a0, a12, 0
    BaseType_t xSwitchRequired = pdFALSE;
4037b4b0:	00c602        	addi	a0, a6, 0
4037b4b3:	220000        	orb	b0, b0, b0
                    xSwitchRequired = pdTRUE;
4037b4b6:	2501a0        	extui	a0, a10, 17, 3
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b4b9:	56fec5        	call0	403d24a8 <_coredump_iram_end+0x504a8>
4037b4bc:	009a      	add.n	a0, a0, a9
            taskEXIT_CRITICAL( pxLock );
4037b4be:	e605a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b4c1:	fedbe5        	call8	4037a280 <vPortExitCritical>
4037b4c4:	000186        	j	4037b4ce <xTaskIncrementTick+0x2c6>
4037b4c7:	03a100        	rsr.dbreakc1	a0
            taskEXIT_CRITICAL_ISR( pxLock );
4037b4ca:	db65e6        	bgei	a5, 6, 4037b4a9 <xTaskIncrementTick+0x2a1>
4037b4cd:	fe          	.byte	0xfe
}
4037b4ce:	f01d      	retw.n

4037b4d0 <vTaskSwitchContext>:
{
4037b4d0:	004136        	entry	a1, 32
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b4d3:	fec3a5        	call8	4037a10c <xPortInIsrContext>
4037b4d6:	00ba56        	bnez	a10, 4037b4e5 <vTaskSwitchContext+0x15>
4037b4d9:	ffafb2        	movi	a11, -1
4037b4dc:	e5fea1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b4df:	fec525        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037b4e2:	000206        	j	4037b4ee <vTaskSwitchContext+0x1e>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b4e5:	ffafb2        	movi	a11, -1
4037b4e8:	e5fba1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b4eb:	fec465        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b4ee:	03eb80        	rsr.prid	a8
4037b4f1:	048d80        	extui	a8, a8, 13, 1
        if( uxSchedulerSuspended[ xCurCoreID ] != ( UBaseType_t ) pdFALSE )
4037b4f4:	e5e991        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037b4f7:	a09890        	addx4	a9, a8, a9
4037b4fa:	0020c0        	memw
4037b4fd:	002992        	l32i	a9, a9, 0
4037b500:	010916        	beqz	a9, 4037b514 <vTaskSwitchContext+0x44>
            xYieldPending[ xCurCoreID ] = pdTRUE;
4037b503:	e60a91        	l32r	a9, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037b506:	a08890        	addx4	a8, a8, a9
4037b509:	190c      	movi.n	a9, 1
4037b50b:	0020c0        	memw
4037b50e:	0899      	s32i.n	a9, a8, 0
4037b510:	001346        	j	4037b561 <vTaskSwitchContext+0x91>
4037b513:	069100        	lsi	f0, a1, 24
            xYieldPending[ xCurCoreID ] = pdFALSE;
4037b516:	9890e6        	bgei	a0, 10, 4037b4b2 <xTaskIncrementTick+0x2aa>
4037b519:	0a0ca0        	add.s	f0, f12, f10
4037b51c:	0020c0        	memw
4037b51f:	09a9      	s32i.n	a10, a9, 0
            taskCHECK_FOR_STACK_OVERFLOW( xCurCoreID );
4037b521:	e5c791        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b524:	a09890        	addx4	a9, a8, a9
4037b527:	0020c0        	memw
4037b52a:	0998      	l32i.n	a9, a9, 0
4037b52c:	c998      	l32i.n	a9, a9, 48
4037b52e:	09b8      	l32i.n	a11, a9, 0
4037b530:	e601a1        	l32r	a10, 40374d34 <_iram_text_start+0x930> (a5a5a5a5 <_rtc_reserved_end+0x4595a5a5>)
4037b533:	119ba7        	bne	a11, a10, 4037b548 <vTaskSwitchContext+0x78>
4037b536:	19b8      	l32i.n	a11, a9, 4
4037b538:	0c9ba7        	bne	a11, a10, 4037b548 <vTaskSwitchContext+0x78>
4037b53b:	29b8      	l32i.n	a11, a9, 8
4037b53d:	079ba7        	bne	a11, a10, 4037b548 <vTaskSwitchContext+0x78>
4037b540:	39a8      	l32i.n	a10, a9, 12
4037b542:	e5fc91        	l32r	a9, 40374d34 <_iram_text_start+0x930> (a5a5a5a5 <_rtc_reserved_end+0x4595a5a5>)
4037b545:	151a97        	beq	a10, a9, 4037b55e <vTaskSwitchContext+0x8e>
4037b548:	e5be91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b54b:	a08890        	addx4	a8, a8, a9
4037b54e:	0020c0        	memw
4037b551:	08a8      	l32i.n	a10, a8, 0
4037b553:	0020c0        	memw
4037b556:	08b8      	l32i.n	a11, a8, 0
4037b558:	34cbb2        	addi	a11, a11, 52
4037b55b:	fedce5        	call8	4037a328 <vApplicationStackOverflowHook>
            taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b55e:	ff5aa5        	call8	4037ab08 <prvSelectHighestPriorityTaskSMP>
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b561:	febaa5        	call8	4037a10c <xPortInIsrContext>
4037b564:	8acc      	bnez.n	a10, 4037b570 <vTaskSwitchContext+0xa0>
            taskEXIT_CRITICAL( pxLock );
4037b566:	e5dba1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b569:	fed165        	call8	4037a280 <vPortExitCritical>
4037b56c:	000186        	j	4037b576 <vTaskSwitchContext+0xa6>
4037b56f:	d9a100        	lsi	f0, a1, 0x364
            taskEXIT_CRITICAL_ISR( pxLock );
4037b572:	d0e5e5        	call8	4034c3d0 <rom_rx_gain_force+0x345fa4>
4037b575:	fe          	.byte	0xfe
}
4037b576:	f01d      	retw.n

4037b578 <vTaskPlaceOnEventList>:
{
4037b578:	004136        	entry	a1, 32
    configASSERT( pxEventList );
4037b57b:	00e256        	bnez	a2, 4037b58d <vTaskPlaceOnEventList+0x15>
4037b57e:	e5eed1        	l32r	a13, 40374d38 <_iram_text_start+0x934> (3c024614 <_flash_rodata_start+0x44f4>)
4037b581:	e5eec1        	l32r	a12, 40374d3c <_iram_text_start+0x938> (3c028364 <__func__$23>)
4037b584:	e5efb1        	l32r	a11, 40374d40 <_iram_text_start+0x93c> (e95 <UserFrameTotalSize+0xd95>)
4037b587:	e5c9a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b58a:	048165        	call8	4037fda0 <__assert_func>
4037b58d:	fb7c      	movi.n	a11, -1
4037b58f:	e5d1a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b592:	feb9e5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b595:	03eb80        	rsr.prid	a8
4037b598:	048d80        	extui	a8, a8, 13, 1
        vListInsert( pxEventList, &( pxCurrentTCBs[ portGET_CORE_ID() ]->xEventListItem ) );
4037b59b:	e5a991        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b59e:	a08890        	addx4	a8, a8, a9
4037b5a1:	0020c0        	memw
4037b5a4:	0028b2        	l32i	a11, a8, 0
4037b5a7:	18cbb2        	addi	a11, a11, 24
4037b5aa:	20a220        	or	a10, a2, a2
4037b5ad:	ff38a5        	call8	4037a938 <vListInsert>
        prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4037b5b0:	1b0c      	movi.n	a11, 1
4037b5b2:	03ad      	mov.n	a10, a3
4037b5b4:	ff81a5        	call8	4037add0 <prvAddCurrentTaskToDelayedList>
    prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037b5b7:	e5c7a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b5ba:	fecc65        	call8	4037a280 <vPortExitCritical>
}
4037b5bd:	f01d      	retw.n
	...

4037b5c0 <xTaskRemoveFromEventList>:
    {
4037b5c0:	004136        	entry	a1, 32
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b5c3:	feb4a5        	call8	4037a10c <xPortInIsrContext>
4037b5c6:	00ca56        	bnez	a10, 4037b5d6 <xTaskRemoveFromEventList+0x16>
4037b5c9:	fb7c      	movi.n	a11, -1
4037b5cb:	e5c2a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b5ce:	feb625        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037b5d1:	000286        	j	4037b5df <xTaskRemoveFromEventList+0x1f>
4037b5d4:	b20000        	mulsh	a0, a0, a0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b5d7:	af          	.byte	0xaf
4037b5d8:	ff          	.byte	0xff
4037b5d9:	e5bea1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b5dc:	feb525        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( listLIST_IS_EMPTY( pxEventList ) == pdFALSE )
4037b5df:	0020c0        	memw
4037b5e2:	002282        	l32i	a8, a2, 0
4037b5e5:	1b4816        	beqz	a8, 4037b79d <xTaskRemoveFromEventList+0x1dd>
4037b5e8:	03eb60        	rsr.prid	a6
4037b5eb:	046d60        	extui	a6, a6, 13, 1
4037b5ee:	065d      	mov.n	a5, a6
                pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
4037b5f0:	0020c0        	memw
4037b5f3:	3288      	l32i.n	a8, a2, 12
4037b5f5:	3878      	l32i.n	a7, a8, 12
                configASSERT( pxUnblockedTCB );
4037b5f7:	00e756        	bnez	a7, 4037b609 <xTaskRemoveFromEventList+0x49>
4037b5fa:	e5d2d1        	l32r	a13, 40374d44 <_iram_text_start+0x940> (3c024620 <_flash_rodata_start+0x4500>)
4037b5fd:	e5d2c1        	l32r	a12, 40374d48 <_iram_text_start+0x944> (3c028348 <__func__$20>)
4037b600:	e5d3b1        	l32r	a11, 40374d4c <_iram_text_start+0x948> (f2a <UserFrameTotalSize+0xe2a>)
4037b603:	e5aaa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b606:	0479a5        	call8	4037fda0 <__assert_func>
                listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
4037b609:	0020c0        	memw
4037b60c:	a788      	l32i.n	a8, a7, 40
4037b60e:	0020c0        	memw
4037b611:	7798      	l32i.n	a9, a7, 28
4037b613:	0020c0        	memw
4037b616:	87a8      	l32i.n	a10, a7, 32
4037b618:	0020c0        	memw
4037b61b:	29a9      	s32i.n	a10, a9, 8
4037b61d:	0020c0        	memw
4037b620:	8798      	l32i.n	a9, a7, 32
4037b622:	0020c0        	memw
4037b625:	77a8      	l32i.n	a10, a7, 28
4037b627:	0020c0        	memw
4037b62a:	19a9      	s32i.n	a10, a9, 4
4037b62c:	0020c0        	memw
4037b62f:	1898      	l32i.n	a9, a8, 4
4037b631:	18c722        	addi	a2, a7, 24
4037b634:	099927        	bne	a9, a2, 4037b641 <xTaskRemoveFromEventList+0x81>
4037b637:	0020c0        	memw
4037b63a:	8798      	l32i.n	a9, a7, 32
4037b63c:	0020c0        	memw
4037b63f:	1899      	s32i.n	a9, a8, 4
4037b641:	00a092        	movi	a9, 0
4037b644:	0020c0        	memw
4037b647:	0a6792        	s32i	a9, a7, 40
4037b64a:	0020c0        	memw
4037b64d:	002892        	l32i	a9, a8, 0
4037b650:	990b      	addi.n	a9, a9, -1
4037b652:	0020c0        	memw
4037b655:	0899      	s32i.n	a9, a8, 0
                if( taskCAN_BE_SCHEDULED( pxUnblockedTCB ) == pdTRUE )
4037b657:	07ad      	mov.n	a10, a7
4037b659:	ff38e5        	call8	4037a9e8 <prvCheckTaskCanBeScheduledSMP>
4037b65c:	021a26        	beqi	a10, 1, 4037b662 <xTaskRemoveFromEventList+0xa2>
4037b65f:	002b86        	j	4037b711 <xTaskRemoveFromEventList+0x151>
                    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
4037b662:	0020c0        	memw
4037b665:	5788      	l32i.n	a8, a7, 20
4037b667:	0020c0        	memw
4037b66a:	2798      	l32i.n	a9, a7, 8
4037b66c:	0020c0        	memw
4037b66f:	37a8      	l32i.n	a10, a7, 12
4037b671:	0020c0        	memw
4037b674:	29a9      	s32i.n	a10, a9, 8
4037b676:	0020c0        	memw
4037b679:	3798      	l32i.n	a9, a7, 12
4037b67b:	0020c0        	memw
4037b67e:	27a8      	l32i.n	a10, a7, 8
4037b680:	0020c0        	memw
4037b683:	19a9      	s32i.n	a10, a9, 4
4037b685:	0020c0        	memw
4037b688:	18a8      	l32i.n	a10, a8, 4
4037b68a:	974b      	addi.n	a9, a7, 4
4037b68c:	099a97        	bne	a10, a9, 4037b699 <xTaskRemoveFromEventList+0xd9>
4037b68f:	0020c0        	memw
4037b692:	37a8      	l32i.n	a10, a7, 12
4037b694:	0020c0        	memw
4037b697:	18a9      	s32i.n	a10, a8, 4
4037b699:	0a0c      	movi.n	a10, 0
4037b69b:	0020c0        	memw
4037b69e:	57a9      	s32i.n	a10, a7, 20
4037b6a0:	0020c0        	memw
4037b6a3:	08a8      	l32i.n	a10, a8, 0
4037b6a5:	aa0b      	addi.n	a10, a10, -1
4037b6a7:	0020c0        	memw
4037b6aa:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxUnblockedTCB );
4037b6ac:	b788      	l32i.n	a8, a7, 44
4037b6ae:	e580a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b6b1:	0020c0        	memw
4037b6b4:	0aa8      	l32i.n	a10, a10, 0
4037b6b6:	07ba87        	bgeu	a10, a8, 4037b6c1 <xTaskRemoveFromEventList+0x101>
4037b6b9:	e57da1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b6bc:	0020c0        	memw
4037b6bf:	0a89      	s32i.n	a8, a10, 0
4037b6c1:	e57ca1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037b6c4:	a08880        	addx4	a8, a8, a8
4037b6c7:	a088a0        	addx4	a8, a8, a10
4037b6ca:	0020c0        	memw
4037b6cd:	1888      	l32i.n	a8, a8, 4
4037b6cf:	0020c0        	memw
4037b6d2:	2789      	s32i.n	a8, a7, 8
4037b6d4:	0020c0        	memw
4037b6d7:	28b8      	l32i.n	a11, a8, 8
4037b6d9:	0020c0        	memw
4037b6dc:	37b9      	s32i.n	a11, a7, 12
4037b6de:	0020c0        	memw
4037b6e1:	28b8      	l32i.n	a11, a8, 8
4037b6e3:	0020c0        	memw
4037b6e6:	1b99      	s32i.n	a9, a11, 4
4037b6e8:	0020c0        	memw
4037b6eb:	2899      	s32i.n	a9, a8, 8
4037b6ed:	b788      	l32i.n	a8, a7, 44
4037b6ef:	a09880        	addx4	a9, a8, a8
4037b6f2:	a099a0        	addx4	a9, a9, a10
4037b6f5:	0020c0        	memw
4037b6f8:	5799      	s32i.n	a9, a7, 20
4037b6fa:	0020c0        	memw
4037b6fd:	0998      	l32i.n	a9, a9, 0
4037b6ff:	991b      	addi.n	a9, a9, 1
4037b701:	a08880        	addx4	a8, a8, a8
4037b704:	a088a0        	addx4	a8, a8, a10
4037b707:	0020c0        	memw
4037b70a:	0899      	s32i.n	a9, a8, 0
4037b70c:	001bc6        	j	4037b77f <xTaskRemoveFromEventList+0x1bf>
4037b70f:	820000        	mull	a0, a0, a0
                    UBaseType_t uxPendCore = ( ( pxUnblockedTCB->xCoreID == tskNO_AFFINITY ) ? xCurCoreID : pxUnblockedTCB->xCoreID );
4037b712:	911127        	beq	a1, a2, 4037b6a7 <xTaskRemoveFromEventList+0xe7>
4037b715:	e43d      	lsi	f3, a4, 16
4037b717:	021897        	beq	a8, a9, 4037b71d <xTaskRemoveFromEventList+0x15d>
4037b71a:	206880        	or	a6, a8, a8
                    configASSERT( uxSchedulerSuspended[ uxPendCore ] != ( UBaseType_t ) 0U );
4037b71d:	e55e81        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037b720:	a08680        	addx4	a8, a6, a8
4037b723:	0020c0        	memw
4037b726:	002882        	l32i	a8, a8, 0
4037b729:	00e856        	bnez	a8, 4037b73b <xTaskRemoveFromEventList+0x17b>
4037b72c:	e589d1        	l32r	a13, 40374d50 <_iram_text_start+0x94c> (3c024630 <_flash_rodata_start+0x4510>)
4037b72f:	e586c1        	l32r	a12, 40374d48 <_iram_text_start+0x944> (3c028348 <__func__$20>)
4037b732:	e588b1        	l32r	a11, 40374d54 <_iram_text_start+0x950> (f4d <UserFrameTotalSize+0xe4d>)
4037b735:	e55da1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b738:	046665        	call8	4037fda0 <__assert_func>
                    listINSERT_END( &( xPendingReadyList[ uxPendCore ] ), &( pxUnblockedTCB->xEventListItem ) );
4037b73b:	e573a1        	l32r	a10, 40374d08 <_iram_text_start+0x904> (3fc94c94 <xPendingReadyList>)
4037b73e:	a08660        	addx4	a8, a6, a6
4037b741:	a088a0        	addx4	a8, a8, a10
4037b744:	0020c0        	memw
4037b747:	012892        	l32i	a9, a8, 4
4037b74a:	0020c0        	memw
4037b74d:	7799      	s32i.n	a9, a7, 28
4037b74f:	0020c0        	memw
4037b752:	29b8      	l32i.n	a11, a9, 8
4037b754:	0020c0        	memw
4037b757:	87b9      	s32i.n	a11, a7, 32
4037b759:	0020c0        	memw
4037b75c:	29b8      	l32i.n	a11, a9, 8
4037b75e:	0020c0        	memw
4037b761:	1b29      	s32i.n	a2, a11, 4
4037b763:	0020c0        	memw
4037b766:	2929      	s32i.n	a2, a9, 8
4037b768:	0020c0        	memw
4037b76b:	a789      	s32i.n	a8, a7, 40
4037b76d:	0020c0        	memw
4037b770:	0888      	l32i.n	a8, a8, 0
4037b772:	881b      	addi.n	a8, a8, 1
4037b774:	a06660        	addx4	a6, a6, a6
4037b777:	a066a0        	addx4	a6, a6, a10
4037b77a:	0020c0        	memw
4037b77d:	0689      	s32i.n	a8, a6, 0
                if( taskIS_YIELD_REQUIRED( pxUnblockedTCB, pdFALSE ) == pdTRUE )
4037b77f:	0c0c      	movi.n	a12, 0
4037b781:	b7b8      	l32i.n	a11, a7, 44
4037b783:	07ad      	mov.n	a10, a7
4037b785:	ff2e65        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037b788:	0a2d      	mov.n	a2, a10
4037b78a:	141a66        	bnei	a10, 1, 4037b7a2 <xTaskRemoveFromEventList+0x1e2>
                    xYieldPending[ xCurCoreID ] = pdTRUE;
4037b78d:	e56781        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037b790:	a05580        	addx4	a5, a5, a8
4037b793:	180c      	movi.n	a8, 1
4037b795:	0020c0        	memw
4037b798:	0589      	s32i.n	a8, a5, 0
4037b79a:	0001c6        	j	4037b7a5 <xTaskRemoveFromEventList+0x1e5>
                xReturn = pdFALSE;
4037b79d:	020c      	movi.n	a2, 0
4037b79f:	000086        	j	4037b7a5 <xTaskRemoveFromEventList+0x1e5>
                    xReturn = pdFALSE;
4037b7a2:	00a022        	movi	a2, 0
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b7a5:	fe9665        	call8	4037a10c <xPortInIsrContext>
4037b7a8:	008a56        	bnez	a10, 4037b7b4 <xTaskRemoveFromEventList+0x1f4>
            taskEXIT_CRITICAL( &xKernelLock );
4037b7ab:	e54aa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b7ae:	fead25        	call8	4037a280 <vPortExitCritical>
4037b7b1:	000146        	j	4037b7ba <xTaskRemoveFromEventList+0x1fa>
            taskEXIT_CRITICAL_ISR( &xKernelLock );
4037b7b4:	e548a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b7b7:	feaca5        	call8	4037a280 <vPortExitCritical>
    }
4037b7ba:	f01d      	retw.n

4037b7bc <vTaskInternalSetTimeOutState>:
{
4037b7bc:	004136        	entry	a1, 32
    pxTimeOut->xOverflowCount = xNumOfOverflows;
4037b7bf:	e55a81        	l32r	a8, 40374d28 <_iram_text_start+0x924> (3fc94c48 <xNumOfOverflows>)
4037b7c2:	0020c0        	memw
4037b7c5:	0888      	l32i.n	a8, a8, 0
4037b7c7:	0289      	s32i.n	a8, a2, 0
    pxTimeOut->xTimeOnEntering = xTickCount;
4037b7c9:	e54781        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037b7cc:	0020c0        	memw
4037b7cf:	0888      	l32i.n	a8, a8, 0
4037b7d1:	1289      	s32i.n	a8, a2, 4
}
4037b7d3:	f01d      	retw.n
4037b7d5:	000000        	ill

4037b7d8 <xTaskCheckForTimeOut>:
{
4037b7d8:	004136        	entry	a1, 32
    configASSERT( pxTimeOut );
4037b7db:	00e256        	bnez	a2, 4037b7ed <xTaskCheckForTimeOut+0x15>
4037b7de:	e55ed1        	l32r	a13, 40374d58 <_iram_text_start+0x954> (3c02466c <_flash_rodata_start+0x454c>)
4037b7e1:	e55ec1        	l32r	a12, 40374d5c <_iram_text_start+0x958> (3c028330 <__func__$17>)
4037b7e4:	e55fb1        	l32r	a11, 40374d60 <_iram_text_start+0x95c> (103a <UserFrameTotalSize+0xf3a>)
4037b7e7:	e531a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b7ea:	045b65        	call8	4037fda0 <__assert_func>
    configASSERT( pxTicksToWait );
4037b7ed:	00e356        	bnez	a3, 4037b7ff <xTaskCheckForTimeOut+0x27>
4037b7f0:	e55dd1        	l32r	a13, 40374d64 <_iram_text_start+0x960> (3c024678 <_flash_rodata_start+0x4558>)
4037b7f3:	e55ac1        	l32r	a12, 40374d5c <_iram_text_start+0x958> (3c028330 <__func__$17>)
4037b7f6:	e55cb1        	l32r	a11, 40374d68 <_iram_text_start+0x964> (103b <UserFrameTotalSize+0xf3b>)
4037b7f9:	e52ca1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b7fc:	045a25        	call8	4037fda0 <__assert_func>
4037b7ff:	fb7c      	movi.n	a11, -1
4037b801:	e534a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b804:	fe92a5        	call8	4037a130 <xPortEnterCriticalTimeout>
        const TickType_t xConstTickCount = xTickCount;
4037b807:	e53881        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037b80a:	0020c0        	memw
4037b80d:	0028b2        	l32i	a11, a8, 0
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
4037b810:	12a8      	l32i.n	a10, a2, 4
4037b812:	c0cba0        	sub	a12, a11, a10
4037b815:	03eb90        	rsr.prid	a9
4037b818:	049d90        	extui	a9, a9, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted != ( uint8_t ) pdFALSE )
4037b81b:	e50981        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b81e:	a08980        	addx4	a8, a9, a8
4037b821:	0020c0        	memw
4037b824:	0888      	l32i.n	a8, a8, 0
4037b826:	01d882        	addmi	a8, a8, 0x100
4037b829:	520882        	l8ui	a8, a8, 82
4037b82c:	689c      	beqz.n	a8, 4037b846 <xTaskCheckForTimeOut+0x6e>
                pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted = pdFALSE;
4037b82e:	e50481        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b831:	a09980        	addx4	a9, a9, a8
4037b834:	0020c0        	memw
4037b837:	0988      	l32i.n	a8, a9, 0
4037b839:	01d882        	addmi	a8, a8, 0x100
4037b83c:	090c      	movi.n	a9, 0
4037b83e:	524892        	s8i	a9, a8, 82
                xReturn = pdTRUE;
4037b841:	120c      	movi.n	a2, 1
4037b843:	001006        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
            if( *pxTicksToWait == portMAX_DELAY )
4037b846:	0388      	l32i.n	a8, a3, 0
4037b848:	390826        	beqi	a8, -1, 4037b885 <xTaskCheckForTimeOut+0xad>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
4037b84b:	02d8      	l32i.n	a13, a2, 0
4037b84d:	e53691        	l32r	a9, 40374d28 <_iram_text_start+0x924> (3fc94c48 <xNumOfOverflows>)
4037b850:	0020c0        	memw
4037b853:	0998      	l32i.n	a9, a9, 0
4037b855:	0b1d97        	beq	a13, a9, 4037b864 <xTaskCheckForTimeOut+0x8c>
4037b858:	083ba7        	bltu	a11, a10, 4037b864 <xTaskCheckForTimeOut+0x8c>
            *pxTicksToWait = ( TickType_t ) 0;
4037b85b:	080c      	movi.n	a8, 0
4037b85d:	0389      	s32i.n	a8, a3, 0
            xReturn = pdTRUE;
4037b85f:	120c      	movi.n	a2, 1
            *pxTicksToWait = ( TickType_t ) 0;
4037b861:	000886        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
4037b864:	14bc87        	bgeu	a12, a8, 4037b87c <xTaskCheckForTimeOut+0xa4>
            *pxTicksToWait -= xElapsedTime;
4037b867:	c0aab0        	sub	a10, a10, a11
4037b86a:	80aa80        	add	a10, a10, a8
4037b86d:	0063a2        	s32i	a10, a3, 0
            vTaskInternalSetTimeOutState( pxTimeOut );
4037b870:	20a220        	or	a10, a2, a2
4037b873:	fff4a5        	call8	4037b7bc <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
4037b876:	020c      	movi.n	a2, 0
4037b878:	0002c6        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
4037b87b:	080c00        	lsx	f0, a12, a0
            *pxTicksToWait = ( TickType_t ) 0;
4037b87e:	0389      	s32i.n	a8, a3, 0
            xReturn = pdTRUE;
4037b880:	120c      	movi.n	a2, 1
4037b882:	000046        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
                xReturn = pdFALSE;
4037b885:	020c      	movi.n	a2, 0
    taskEXIT_CRITICAL( &xKernelLock );
4037b887:	e513a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b88a:	fe9f65        	call8	4037a280 <vPortExitCritical>
}
4037b88d:	f01d      	retw.n
	...

4037b890 <xTaskGetCurrentTaskHandle>:
    {
4037b890:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037b893:	0063a0        	rsil	a10, 3
4037b896:	03eb80        	rsr.prid	a8
4037b899:	048d80        	extui	a8, a8, 13, 1
            xReturn = pxCurrentTCBs[ portGET_CORE_ID() ];
4037b89c:	e4e991        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b89f:	a08890        	addx4	a8, a8, a9
4037b8a2:	0020c0        	memw
4037b8a5:	0828      	l32i.n	a2, a8, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037b8a7:	e4d181        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037b8aa:	0008e0        	callx8	a8
    }
4037b8ad:	f01d      	retw.n
	...

4037b8b0 <vTaskPrioritySet>:
    {
4037b8b0:	004136        	entry	a1, 32
        configASSERT( uxNewPriority < configMAX_PRIORITIES );
4037b8b3:	881c      	movi.n	a8, 24
4037b8b5:	0eb837        	bgeu	a8, a3, 4037b8c7 <vTaskPrioritySet+0x17>
4037b8b8:	e52dd1        	l32r	a13, 40374d6c <_iram_text_start+0x968> (3c024688 <_flash_rodata_start+0x4568>)
4037b8bb:	e52dc1        	l32r	a12, 40374d70 <_iram_text_start+0x96c> (3c0283fc <__func__$38>)
4037b8be:	e9a6b2        	movi	a11, 0x6e9
4037b8c1:	e4faa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b8c4:	044da5        	call8	4037fda0 <__assert_func>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b8c7:	fb7c      	movi.n	a11, -1
4037b8c9:	e502a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037b8cc:	fe8625        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b8cf:	03eb70        	rsr.prid	a7
4037b8d2:	047d70        	extui	a7, a7, 13, 1
            pxTCB = prvGetTCBFromHandle( xTask );
4037b8d5:	004256        	bnez	a2, 4037b8dd <vTaskPrioritySet+0x2d>
4037b8d8:	fffb65        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037b8db:	0a2d      	mov.n	a2, a10
                uxCurrentBasePriority = pxTCB->uxBasePriority;
4037b8dd:	132282        	l32i	a8, a2, 76
            if( uxCurrentBasePriority != uxNewPriority )
4037b8e0:	029387        	bne	a3, a8, 4037b8e6 <vTaskPrioritySet+0x36>
4037b8e3:	0045c6        	j	4037b9fe <vTaskPrioritySet+0x14e>
                if( uxNewPriority > uxCurrentBasePriority )
4037b8e6:	2ab837        	bgeu	a8, a3, 4037b914 <vTaskPrioritySet+0x64>
                    if( taskIS_CURRENTLY_RUNNING( pxTCB ) == pdFALSE )
4037b8e9:	e4d581        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b8ec:	0020c0        	memw
4037b8ef:	0888      	l32i.n	a8, a8, 0
4037b8f1:	4c1827        	beq	a8, a2, 4037b941 <vTaskPrioritySet+0x91>
4037b8f4:	e4d381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b8f7:	0020c0        	memw
4037b8fa:	1888      	l32i.n	a8, a8, 4
4037b8fc:	461827        	beq	a8, a2, 4037b946 <vTaskPrioritySet+0x96>
                        if( taskIS_YIELD_REQUIRED_USING_PRIORITY( pxTCB, uxNewPriority, pdTRUE ) == pdTRUE )
4037b8ff:	1c0c      	movi.n	a12, 1
4037b901:	03bd      	mov.n	a11, a3
4037b903:	02ad      	mov.n	a10, a2
4037b905:	ff1665        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037b908:	0a7d      	mov.n	a7, a10
4037b90a:	471a26        	beqi	a10, 1, 4037b955 <vTaskPrioritySet+0xa5>
        BaseType_t xYieldRequired = pdFALSE;
4037b90d:	070c      	movi.n	a7, 0
4037b90f:	001086        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b912:	810000        	src	a0, a0, a0
                else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, xCurCoreID ) == pdTRUE )
4037b915:	e4cb      	addi.n	a14, a4, 12
4037b917:	a08780        	addx4	a8, a7, a8
4037b91a:	0020c0        	memw
4037b91d:	002882        	l32i	a8, a8, 0
4037b920:	281827        	beq	a8, a2, 4037b94c <vTaskPrioritySet+0x9c>
                    else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, !xCurCoreID ) == pdTRUE )
4037b923:	40f7a0        	nsau	a10, a7
4037b926:	41a5a0        	srli	a10, a10, 5
4037b929:	e4c581        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037b92c:	a08a80        	addx4	a8, a10, a8
4037b92f:	0020c0        	memw
4037b932:	002882        	l32i	a8, a8, 0
4037b935:	199827        	bne	a8, a2, 4037b952 <vTaskPrioritySet+0xa2>
                        taskYIELD_CORE( !xCurCoreID );
4037b938:	fe9e25        	call8	4037a31c <vPortYieldOtherCore>
        BaseType_t xYieldRequired = pdFALSE;
4037b93b:	00a072        	movi	a7, 0
4037b93e:	0004c6        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b941:	070c      	movi.n	a7, 0
4037b943:	000386        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b946:	070c      	movi.n	a7, 0
4037b948:	000246        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b94b:	170c00        	lsi	f0, a12, 92
                    xYieldRequired = pdTRUE;
4037b94e:	0000c6        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b951:	a07200        	addx4	a7, a2, a0
        BaseType_t xYieldRequired = pdFALSE;
4037b954:	228200        	orb	b8, b2, b0
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
4037b957:	920b      	addi.n	a9, a2, -1
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
4037b959:	871322        	l16ui	a2, a3, 0x10e
4037b95c:	0299      	s32i.n	a9, a2, 0
                        pxTCB->uxPriority = uxNewPriority;
4037b95e:	0b6232        	s32i	a3, a2, 44
                    pxTCB->uxBasePriority = uxNewPriority;
4037b961:	136232        	s32i	a3, a2, 76
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037b964:	0020c0        	memw
4037b967:	062292        	l32i	a9, a2, 24
4037b96a:	00b996        	bltz	a9, 4037b979 <vTaskPrioritySet+0xc9>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037b96d:	e7c332        	addi	a3, a3, -25
4037b970:	603030        	neg	a3, a3
4037b973:	0020c0        	memw
4037b976:	066232        	s32i	a3, a2, 24
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037b979:	0020c0        	memw
4037b97c:	5298      	l32i.n	a9, a2, 20
4037b97e:	a08880        	addx4	a8, a8, a8
4037b981:	e4cca1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037b984:	a088a0        	addx4	a8, a8, a10
4037b987:	679987        	bne	a9, a8, 4037b9f2 <vTaskPrioritySet+0x142>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037b98a:	324b      	addi.n	a3, a2, 4
4037b98c:	03ad      	mov.n	a10, a3
4037b98e:	ff0065        	call8	4037a994 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
4037b991:	b288      	l32i.n	a8, a2, 44
4037b993:	e4c791        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b996:	0020c0        	memw
4037b999:	0998      	l32i.n	a9, a9, 0
4037b99b:	07b987        	bgeu	a9, a8, 4037b9a6 <vTaskPrioritySet+0xf6>
4037b99e:	e4c491        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037b9a1:	0020c0        	memw
4037b9a4:	0989      	s32i.n	a8, a9, 0
4037b9a6:	e4c3a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037b9a9:	a08880        	addx4	a8, a8, a8
4037b9ac:	a088a0        	addx4	a8, a8, a10
4037b9af:	0020c0        	memw
4037b9b2:	1888      	l32i.n	a8, a8, 4
4037b9b4:	0020c0        	memw
4037b9b7:	2289      	s32i.n	a8, a2, 8
4037b9b9:	0020c0        	memw
4037b9bc:	2898      	l32i.n	a9, a8, 8
4037b9be:	0020c0        	memw
4037b9c1:	3299      	s32i.n	a9, a2, 12
4037b9c3:	0020c0        	memw
4037b9c6:	2898      	l32i.n	a9, a8, 8
4037b9c8:	0020c0        	memw
4037b9cb:	1939      	s32i.n	a3, a9, 4
4037b9cd:	0020c0        	memw
4037b9d0:	2839      	s32i.n	a3, a8, 8
4037b9d2:	b288      	l32i.n	a8, a2, 44
4037b9d4:	a09880        	addx4	a9, a8, a8
4037b9d7:	a099a0        	addx4	a9, a9, a10
4037b9da:	0020c0        	memw
4037b9dd:	5299      	s32i.n	a9, a2, 20
4037b9df:	0020c0        	memw
4037b9e2:	0998      	l32i.n	a9, a9, 0
4037b9e4:	991b      	addi.n	a9, a9, 1
4037b9e6:	a08880        	addx4	a8, a8, a8
4037b9e9:	a088a0        	addx4	a8, a8, a10
4037b9ec:	0020c0        	memw
4037b9ef:	006892        	s32i	a9, a8, 0
                if( xYieldRequired != pdFALSE )
4037b9f2:	008716        	beqz	a7, 4037b9fe <vTaskPrioritySet+0x14e>
4037b9f5:	03eba0        	rsr.prid	a10
4037b9f8:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037b9fb:	fc6d25        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &xKernelLock );
4037b9fe:	e4b5a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037ba01:	fe87e5        	call8	4037a280 <vPortExitCritical>
    }
4037ba04:	000090        	retw
	...

4037ba08 <pcTaskGetName>:
{
4037ba08:	004136        	entry	a1, 32
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
4037ba0b:	016256        	bnez	a2, 4037ba25 <pcTaskGetName+0x1d>
4037ba0e:	ffe825        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037ba11:	0a2d      	mov.n	a2, a10
    configASSERT( pxTCB );
4037ba13:	00ea56        	bnez	a10, 4037ba25 <pcTaskGetName+0x1d>
4037ba16:	e4d7d1        	l32r	a13, 40374d74 <_iram_text_start+0x970> (3c02457c <_flash_rodata_start+0x445c>)
4037ba19:	e4d7c1        	l32r	a12, 40374d78 <_iram_text_start+0x974> (3c0283b0 <__func__$30>)
4037ba1c:	e4d8b1        	l32r	a11, 40374d7c <_iram_text_start+0x978> (ac4 <UserFrameTotalSize+0x9c4>)
4037ba1f:	e4a3a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037ba22:	0437e5        	call8	4037fda0 <__assert_func>
}
4037ba25:	34c222        	addi	a2, a2, 52
4037ba28:	f01d      	retw.n
	...

4037ba2c <pvTaskGetThreadLocalStoragePointer>:
    {
4037ba2c:	004136        	entry	a1, 32
        if( ( xIndex >= 0 ) &&
4037ba2f:	1123f6        	bgeui	a3, 2, 4037ba44 <pvTaskGetThreadLocalStoragePointer+0x18>
            pxTCB = prvGetTCBFromHandle( xTaskToQuery );
4037ba32:	32cc      	bnez.n	a2, 4037ba39 <pvTaskGetThreadLocalStoragePointer+0xd>
4037ba34:	ffe5a5        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037ba37:	0a2d      	mov.n	a2, a10
            pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
4037ba39:	14c332        	addi	a3, a3, 20
4037ba3c:	a02320        	addx4	a2, a3, a2
4037ba3f:	1228      	l32i.n	a2, a2, 4
4037ba41:	000046        	j	4037ba46 <pvTaskGetThreadLocalStoragePointer+0x1a>
            pvReturn = NULL;
4037ba44:	020c      	movi.n	a2, 0
    }
4037ba46:	f01d      	retw.n

4037ba48 <xTaskGetSchedulerState>:
    {
4037ba48:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037ba4b:	0063a0        	rsil	a10, 3
            if( xSchedulerRunning == pdFALSE )
4037ba4e:	e4af81        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94c58 <xSchedulerRunning>)
4037ba51:	0020c0        	memw
4037ba54:	0888      	l32i.n	a8, a8, 0
4037ba56:	689c      	beqz.n	a8, 4037ba70 <xTaskGetSchedulerState+0x28>
4037ba58:	03eb80        	rsr.prid	a8
4037ba5b:	048d80        	extui	a8, a8, 13, 1
                if( uxSchedulerSuspended[ portGET_CORE_ID() ] == ( UBaseType_t ) pdFALSE )
4037ba5e:	e48e91        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037ba61:	a08890        	addx4	a8, a8, a9
4037ba64:	0020c0        	memw
4037ba67:	0888      	l32i.n	a8, a8, 0
4037ba69:	88cc      	bnez.n	a8, 4037ba75 <xTaskGetSchedulerState+0x2d>
                    xReturn = taskSCHEDULER_RUNNING;
4037ba6b:	220c      	movi.n	a2, 2
4037ba6d:	000186        	j	4037ba77 <xTaskGetSchedulerState+0x2f>
                xReturn = taskSCHEDULER_NOT_STARTED;
4037ba70:	120c      	movi.n	a2, 1
4037ba72:	000046        	j	4037ba77 <xTaskGetSchedulerState+0x2f>
                    xReturn = taskSCHEDULER_SUSPENDED;
4037ba75:	020c      	movi.n	a2, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037ba77:	e45d81        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037ba7a:	0008e0        	callx8	a8
    }
4037ba7d:	f01d      	retw.n
	...

4037ba80 <vTaskDelete>:
    {
4037ba80:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037ba83:	ffafb2        	movi	a11, -1
4037ba86:	e493a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037ba89:	fe6a65        	call8	4037a130 <xPortEnterCriticalTimeout>
4037ba8c:	03eb70        	rsr.prid	a7
4037ba8f:	047d70        	extui	a7, a7, 13, 1
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
4037ba92:	004256        	bnez	a2, 4037ba9a <vTaskDelete+0x1a>
4037ba95:	ffdfa5        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037ba98:	0a2d      	mov.n	a2, a10
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037ba9a:	04c262        	addi	a6, a2, 4
4037ba9d:	20a660        	or	a10, a6, a6
4037baa0:	feef25        	call8	4037a994 <uxListRemove>
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037baa3:	0020c0        	memw
4037baa6:	a288      	l32i.n	a8, a2, 40
4037baa8:	488c      	beqz.n	a8, 4037bab0 <vTaskDelete+0x30>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
4037baaa:	18c2a2        	addi	a10, a2, 24
4037baad:	feee65        	call8	4037a994 <uxListRemove>
            uxTaskNumber++;
4037bab0:	e49891        	l32r	a9, 40374d10 <_iram_text_start+0x90c> (3fc94c44 <uxTaskNumber>)
4037bab3:	002982        	l32i	a8, a9, 0
4037bab6:	01c882        	addi	a8, a8, 1
4037bab9:	006982        	s32i	a8, a9, 0
            if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, xCurCoreID ) == pdTRUE )
4037babc:	e46181        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037babf:	a08780        	addx4	a8, a7, a8
4037bac2:	0020c0        	memw
4037bac5:	0888      	l32i.n	a8, a8, 0
4037bac7:	2d1827        	beq	a8, a2, 4037baf8 <vTaskDelete+0x78>
                else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, !xCurCoreID ) == pdTRUE )
4037baca:	40f780        	nsau	a8, a7
4037bacd:	418580        	srli	a8, a8, 5
4037bad0:	e45c91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037bad3:	a08890        	addx4	a8, a8, a9
4037bad6:	0020c0        	memw
4037bad9:	0888      	l32i.n	a8, a8, 0
4037badb:	1f1827        	beq	a8, a2, 4037bafe <vTaskDelete+0x7e>
                --uxCurrentNumberOfTasks;
4037bade:	e47f91        	l32r	a9, 40374cdc <_iram_text_start+0x8d8> (3fc94c64 <uxCurrentNumberOfTasks>)
4037bae1:	0020c0        	memw
4037bae4:	0988      	l32i.n	a8, a9, 0
4037bae6:	880b      	addi.n	a8, a8, -1
4037bae8:	0020c0        	memw
4037baeb:	0989      	s32i.n	a8, a9, 0
                prvResetNextTaskUnblockTime();
4037baed:	fef425        	call8	4037aa30 <prvResetNextTaskUnblockTime>
                xIsCurRunning = pdFALSE;
4037baf0:	070c      	movi.n	a7, 0
                xSelfDelete = pdFALSE;
4037baf2:	075d      	mov.n	a5, a7
4037baf4:	000d06        	j	4037bb2c <vTaskDelete+0xac>
4037baf7:	150c00        	extui	a0, a0, 28, 2
                xSelfDelete = pdTRUE;
4037bafa:	0000c6        	j	4037bb01 <vTaskDelete+0x81>
4037bafd:	a05200        	addx4	a5, a2, a0
                    xSelfDelete = pdFALSE;
4037bb00:	b66000        	lsi	f0, a0, 0x2d8
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
4037bb03:	75a120        	extui	a10, a2, 17, 8
4037bb06:	df65e4        	lsi	f14, a5, 0x37c
4037bb09:	fe          	.byte	0xfe
                ++uxDeletedTasksWaitingCleanUp;
4037bb0a:	e47591        	l32r	a9, 40374ce0 <_iram_text_start+0x8dc> (3fc94c7c <uxDeletedTasksWaitingCleanUp>)
4037bb0d:	0020c0        	memw
4037bb10:	002982        	l32i	a8, a9, 0
4037bb13:	881b      	addi.n	a8, a8, 1
4037bb15:	0020c0        	memw
4037bb18:	0989      	s32i.n	a8, a9, 0
                    if( xSelfDelete == pdFALSE )
4037bb1a:	c5cc      	bnez.n	a5, 4037bb2a <vTaskDelete+0xaa>
                        taskYIELD_CORE( !xCurCoreID );
4037bb1c:	40f7a0        	nsau	a10, a7
4037bb1f:	41a5a0        	srli	a10, a10, 5
4037bb22:	fe7fa5        	call8	4037a31c <vPortYieldOtherCore>
4037bb25:	170c      	movi.n	a7, 1
4037bb27:	000046        	j	4037bb2c <vTaskDelete+0xac>
4037bb2a:	057d      	mov.n	a7, a5
        taskEXIT_CRITICAL( &xKernelLock );
4037bb2c:	e46aa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bb2f:	fe7525        	call8	4037a280 <vPortExitCritical>
        if( xIsCurRunning == pdFALSE )
4037bb32:	37cc      	bnez.n	a7, 4037bb39 <vTaskDelete+0xb9>
            prvDeleteTCB( pxTCB );
4037bb34:	02ad      	mov.n	a10, a2
4037bb36:	ff1ba5        	call8	4037acf0 <prvDeleteTCB>
4037bb39:	fb7c      	movi.n	a11, -1
4037bb3b:	e466a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bb3e:	fe5f25        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( xSchedulerRunning != pdFALSE )
4037bb41:	e47281        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94c58 <xSchedulerRunning>)
4037bb44:	0020c0        	memw
4037bb47:	002882        	l32i	a8, a8, 0
4037bb4a:	e89c      	beqz.n	a8, 4037bb6c <vTaskDelete+0xec>
                if( xSelfDelete == pdTRUE )
4037bb4c:	1c1566        	bnei	a5, 1, 4037bb6c <vTaskDelete+0xec>
                    configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdFALSE );
4037bb4f:	ffefa5        	call8	4037ba48 <xTaskGetSchedulerState>
4037bb52:	dacc      	bnez.n	a10, 4037bb63 <vTaskDelete+0xe3>
4037bb54:	e48bd1        	l32r	a13, 40374d80 <_iram_text_start+0x97c> (3c0246a0 <_flash_rodata_start+0x4580>)
4037bb57:	e48bc1        	l32r	a12, 40374d84 <_iram_text_start+0x980> (3c02842c <__func__$43>)
4037bb5a:	aba5b2        	movi	a11, 0x5ab
4037bb5d:	e453a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bb60:	0423e5        	call8	4037fda0 <__assert_func>
4037bb63:	03eba0        	rsr.prid	a10
4037bb66:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037bb69:	fc5625        	call8	403780cc <esp_crosscore_int_send_yield>
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bb6c:	e45aa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bb6f:	fe7125        	call8	4037a280 <vPortExitCritical>
    }
4037bb72:	f01d      	retw.n

4037bb74 <vTaskDelay>:
    {
4037bb74:	004136        	entry	a1, 32
        if( xTicksToDelay > ( TickType_t ) 0U )
4037bb77:	92ac      	beqz.n	a2, 4037bba4 <vTaskDelay+0x30>
            configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdFALSE );
4037bb79:	ffece5        	call8	4037ba48 <xTaskGetSchedulerState>
4037bb7c:	00ea56        	bnez	a10, 4037bb8e <vTaskDelay+0x1a>
4037bb7f:	e480d1        	l32r	a13, 40374d80 <_iram_text_start+0x97c> (3c0246a0 <_flash_rodata_start+0x4580>)
4037bb82:	e481c1        	l32r	a12, 40374d88 <_iram_text_start+0x984> (3c028410 <__func__$40>)
4037bb85:	1ba6b2        	movi	a11, 0x61b
4037bb88:	e449a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bb8b:	042165        	call8	4037fda0 <__assert_func>
4037bb8e:	fb7c      	movi.n	a11, -1
4037bb90:	e451a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bb93:	fe59e5        	call8	4037a130 <xPortEnterCriticalTimeout>
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
4037bb96:	0b0c      	movi.n	a11, 0
4037bb98:	20a220        	or	a10, a2, a2
4037bb9b:	ff2365        	call8	4037add0 <prvAddCurrentTaskToDelayedList>
            xAlreadyYielded = prvEXIT_CRITICAL_OR_RESUME_ALL( &xKernelLock );
4037bb9e:	e44da1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bba1:	fe6de5        	call8	4037a280 <vPortExitCritical>
4037bba4:	03eba0        	rsr.prid	a10
4037bba7:	04ada0        	extui	a10, a10, 13, 1
            portYIELD_WITHIN_API();
4037bbaa:	fc5225        	call8	403780cc <esp_crosscore_int_send_yield>
    }
4037bbad:	f01d      	retw.n
	...

4037bbb0 <xTaskResumeAll>:
{
4037bbb0:	004136        	entry	a1, 32
    configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdTRUE );
4037bbb3:	ffe965        	call8	4037ba48 <xTaskGetSchedulerState>
4037bbb6:	00ea16        	beqz	a10, 4037bbc8 <xTaskResumeAll+0x18>
4037bbb9:	e474d1        	l32r	a13, 40374d8c <_iram_text_start+0x988> (3c024720 <_flash_rodata_start+0x4600>)
4037bbbc:	e475c1        	l32r	a12, 40374d90 <_iram_text_start+0x98c> (3c0283c0 <__func__$31>)
4037bbbf:	e475b1        	l32r	a11, 40374d94 <_iram_text_start+0x990> (a0d <UserFrameTotalSize+0x90d>)
4037bbc2:	e43aa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bbc5:	041da5        	call8	4037fda0 <__assert_func>
4037bbc8:	fb7c      	movi.n	a11, -1
4037bbca:	e442a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bbcd:	fe5625        	call8	4037a130 <xPortEnterCriticalTimeout>
4037bbd0:	03eb60        	rsr.prid	a6
4037bbd3:	046d60        	extui	a6, a6, 13, 1
4037bbd6:	065d      	mov.n	a5, a6
        --uxSchedulerSuspended[ xCurCoreID ];
4037bbd8:	e43081        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037bbdb:	a08680        	addx4	a8, a6, a8
4037bbde:	0020c0        	memw
4037bbe1:	0898      	l32i.n	a9, a8, 0
4037bbe3:	990b      	addi.n	a9, a9, -1
4037bbe5:	0020c0        	memw
4037bbe8:	0899      	s32i.n	a9, a8, 0
        if( uxSchedulerSuspended[ xCurCoreID ] == ( UBaseType_t ) pdFALSE )
4037bbea:	0020c0        	memw
4037bbed:	0888      	l32i.n	a8, a8, 0
4037bbef:	1a3856        	bnez	a8, 4037bd96 <xTaskResumeAll+0x1e6>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
4037bbf2:	e43a81        	l32r	a8, 40374cdc <_iram_text_start+0x8d8> (3fc94c64 <uxCurrentNumberOfTasks>)
4037bbf5:	0020c0        	memw
4037bbf8:	0888      	l32i.n	a8, a8, 0
4037bbfa:	12c856        	bnez	a8, 4037bd2a <xTaskResumeAll+0x17a>
    BaseType_t xAlreadyYielded = pdFALSE;
4037bbfd:	020c      	movi.n	a2, 0
4037bbff:	006546        	j	4037bd98 <xTaskResumeAll+0x1e8>
4037bc02:	600000        	neg	a0, a0
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList[ xCurCoreID ] ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037bc05:	91a086        	j	4036028b <rom_rx_gain_force+0x359e5f>
4037bc08:	90e440        	addx2	a14, a4, a4
4037bc0b:	a088      	l32i.n	a8, a0, 40
4037bc0d:	0020c0        	memw
4037bc10:	3888      	l32i.n	a8, a8, 12
4037bc12:	3878      	l32i.n	a7, a8, 12
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
4037bc14:	0020c0        	memw
4037bc17:	a788      	l32i.n	a8, a7, 40
4037bc19:	0020c0        	memw
4037bc1c:	7798      	l32i.n	a9, a7, 28
4037bc1e:	0020c0        	memw
4037bc21:	87a8      	l32i.n	a10, a7, 32
4037bc23:	0020c0        	memw
4037bc26:	29a9      	s32i.n	a10, a9, 8
4037bc28:	0020c0        	memw
4037bc2b:	8798      	l32i.n	a9, a7, 32
4037bc2d:	0020c0        	memw
4037bc30:	77a8      	l32i.n	a10, a7, 28
4037bc32:	0020c0        	memw
4037bc35:	19a9      	s32i.n	a10, a9, 4
4037bc37:	0020c0        	memw
4037bc3a:	18a8      	l32i.n	a10, a8, 4
4037bc3c:	18c792        	addi	a9, a7, 24
4037bc3f:	099a97        	bne	a10, a9, 4037bc4c <xTaskResumeAll+0x9c>
4037bc42:	0020c0        	memw
4037bc45:	8798      	l32i.n	a9, a7, 32
4037bc47:	0020c0        	memw
4037bc4a:	1899      	s32i.n	a9, a8, 4
4037bc4c:	090c      	movi.n	a9, 0
4037bc4e:	0020c0        	memw
4037bc51:	a799      	s32i.n	a9, a7, 40
4037bc53:	0020c0        	memw
4037bc56:	0898      	l32i.n	a9, a8, 0
4037bc58:	990b      	addi.n	a9, a9, -1
4037bc5a:	0020c0        	memw
4037bc5d:	0899      	s32i.n	a9, a8, 0
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037bc5f:	0020c0        	memw
4037bc62:	5788      	l32i.n	a8, a7, 20
4037bc64:	0020c0        	memw
4037bc67:	2798      	l32i.n	a9, a7, 8
4037bc69:	0020c0        	memw
4037bc6c:	37a8      	l32i.n	a10, a7, 12
4037bc6e:	0020c0        	memw
4037bc71:	29a9      	s32i.n	a10, a9, 8
4037bc73:	0020c0        	memw
4037bc76:	3798      	l32i.n	a9, a7, 12
4037bc78:	0020c0        	memw
4037bc7b:	27a8      	l32i.n	a10, a7, 8
4037bc7d:	0020c0        	memw
4037bc80:	19a9      	s32i.n	a10, a9, 4
4037bc82:	0020c0        	memw
4037bc85:	18a8      	l32i.n	a10, a8, 4
4037bc87:	974b      	addi.n	a9, a7, 4
4037bc89:	099a97        	bne	a10, a9, 4037bc96 <xTaskResumeAll+0xe6>
4037bc8c:	0020c0        	memw
4037bc8f:	37a8      	l32i.n	a10, a7, 12
4037bc91:	0020c0        	memw
4037bc94:	18a9      	s32i.n	a10, a8, 4
4037bc96:	0a0c      	movi.n	a10, 0
4037bc98:	0020c0        	memw
4037bc9b:	57a9      	s32i.n	a10, a7, 20
4037bc9d:	0020c0        	memw
4037bca0:	08a8      	l32i.n	a10, a8, 0
4037bca2:	aa0b      	addi.n	a10, a10, -1
4037bca4:	0020c0        	memw
4037bca7:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxTCB );
4037bca9:	b788      	l32i.n	a8, a7, 44
4037bcab:	e401a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037bcae:	0020c0        	memw
4037bcb1:	0aa8      	l32i.n	a10, a10, 0
4037bcb3:	08ba87        	bgeu	a10, a8, 4037bcbf <xTaskResumeAll+0x10f>
4037bcb6:	e3fea1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037bcb9:	0020c0        	memw
4037bcbc:	006a82        	s32i	a8, a10, 0
4037bcbf:	e3fda1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037bcc2:	a08880        	addx4	a8, a8, a8
4037bcc5:	a088a0        	addx4	a8, a8, a10
4037bcc8:	0020c0        	memw
4037bccb:	1888      	l32i.n	a8, a8, 4
4037bccd:	0020c0        	memw
4037bcd0:	2789      	s32i.n	a8, a7, 8
4037bcd2:	0020c0        	memw
4037bcd5:	28b8      	l32i.n	a11, a8, 8
4037bcd7:	0020c0        	memw
4037bcda:	37b9      	s32i.n	a11, a7, 12
4037bcdc:	0020c0        	memw
4037bcdf:	28b8      	l32i.n	a11, a8, 8
4037bce1:	0020c0        	memw
4037bce4:	1b99      	s32i.n	a9, a11, 4
4037bce6:	0020c0        	memw
4037bce9:	2899      	s32i.n	a9, a8, 8
4037bceb:	b788      	l32i.n	a8, a7, 44
4037bced:	a09880        	addx4	a9, a8, a8
4037bcf0:	a099a0        	addx4	a9, a9, a10
4037bcf3:	0020c0        	memw
4037bcf6:	5799      	s32i.n	a9, a7, 20
4037bcf8:	0020c0        	memw
4037bcfb:	0998      	l32i.n	a9, a9, 0
4037bcfd:	991b      	addi.n	a9, a9, 1
4037bcff:	a08880        	addx4	a8, a8, a8
4037bd02:	a088a0        	addx4	a8, a8, a10
4037bd05:	0020c0        	memw
4037bd08:	0899      	s32i.n	a9, a8, 0
                    if( taskIS_YIELD_REQUIRED( pxTCB, pdTRUE ) == pdTRUE )
4037bd0a:	1c0c      	movi.n	a12, 1
4037bd0c:	b7b8      	l32i.n	a11, a7, 44
4037bd0e:	20a770        	or	a10, a7, a7
4037bd11:	fed5a5        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037bd14:	151a66        	bnei	a10, 1, 4037bd2d <xTaskResumeAll+0x17d>
                        xYieldPending[ xCurCoreID ] = pdTRUE;
4037bd17:	e40581        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037bd1a:	a08680        	addx4	a8, a6, a8
4037bd1d:	190c      	movi.n	a9, 1
4037bd1f:	0020c0        	memw
4037bd22:	0899      	s32i.n	a9, a8, 0
4037bd24:	000146        	j	4037bd2d <xTaskResumeAll+0x17d>
4037bd27:	000000        	ill
    TCB_t * pxTCB = NULL;
4037bd2a:	00a072        	movi	a7, 0
                while( listLIST_IS_EMPTY( &xPendingReadyList[ xCurCoreID ] ) == pdFALSE )
4037bd2d:	a08660        	addx4	a8, a6, a6
4037bd30:	e3f691        	l32r	a9, 40374d08 <_iram_text_start+0x904> (3fc94c94 <xPendingReadyList>)
4037bd33:	a08890        	addx4	a8, a8, a9
4037bd36:	0020c0        	memw
4037bd39:	002882        	l32i	a8, a8, 0
4037bd3c:	ec4856        	bnez	a8, 4037bc04 <xTaskResumeAll+0x54>
                if( pxTCB != NULL )
4037bd3f:	002716        	beqz	a7, 4037bd45 <xTaskResumeAll+0x195>
                    prvResetNextTaskUnblockTime();
4037bd42:	fecee5        	call8	4037aa30 <prvResetNextTaskUnblockTime>
                    if( xCurCoreID == 0 )
4037bd45:	f5ec      	bnez.n	a5, 4037bd78 <xTaskResumeAll+0x1c8>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
4037bd47:	e3fa81        	l32r	a8, 40374d30 <_iram_text_start+0x92c> (3fc94c54 <xPendedTicks>)
4037bd4a:	0020c0        	memw
4037bd4d:	0878      	l32i.n	a7, a8, 0
                    if( xPendedCounts > ( TickType_t ) 0U )
4037bd4f:	57ac      	beqz.n	a7, 4037bd78 <xTaskResumeAll+0x1c8>
                            if( xTaskIncrementTick() != pdFALSE )
4037bd51:	ff4b65        	call8	4037b208 <xTaskIncrementTick>
4037bd54:	00ea16        	beqz	a10, 4037bd66 <xTaskResumeAll+0x1b6>
                                xYieldPending[ xCurCoreID ] = pdTRUE;
4037bd57:	e3f581        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037bd5a:	a08680        	addx4	a8, a6, a8
4037bd5d:	01a092        	movi	a9, 1
4037bd60:	0020c0        	memw
4037bd63:	006892        	s32i	a9, a8, 0
                            --xPendedCounts;
4037bd66:	ffc772        	addi	a7, a7, -1
                        } while( xPendedCounts > ( TickType_t ) 0U );
4037bd69:	fe4756        	bnez	a7, 4037bd51 <xTaskResumeAll+0x1a1>
                        xPendedTicks = 0;
4037bd6c:	e3f181        	l32r	a8, 40374d30 <_iram_text_start+0x92c> (3fc94c54 <xPendedTicks>)
4037bd6f:	00a092        	movi	a9, 0
4037bd72:	0020c0        	memw
4037bd75:	006892        	s32i	a9, a8, 0
                if( xYieldPending[ xCurCoreID ] != pdFALSE )
4037bd78:	e3ed81        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037bd7b:	a06680        	addx4	a6, a6, a8
4037bd7e:	0020c0        	memw
4037bd81:	0628      	l32i.n	a2, a6, 0
4037bd83:	129c      	beqz.n	a2, 4037bd98 <xTaskResumeAll+0x1e8>
4037bd85:	03eba0        	rsr.prid	a10
4037bd88:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037bd8b:	fc3425        	call8	403780cc <esp_crosscore_int_send_yield>
                        xAlreadyYielded = pdTRUE;
4037bd8e:	120c      	movi.n	a2, 1
4037bd90:	000106        	j	4037bd98 <xTaskResumeAll+0x1e8>
4037bd93:	000000        	ill
    BaseType_t xAlreadyYielded = pdFALSE;
4037bd96:	020c      	movi.n	a2, 0
    taskEXIT_CRITICAL( &xKernelLock );
4037bd98:	e3cfa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bd9b:	fe4e65        	call8	4037a280 <vPortExitCritical>
}
4037bd9e:	f01d      	retw.n

4037bda0 <xTaskPriorityInherit>:
    {
4037bda0:	004136        	entry	a1, 32
4037bda3:	fb7c      	movi.n	a11, -1
4037bda5:	e3cba1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bda8:	fe3865        	call8	4037a130 <xPortEnterCriticalTimeout>
4037bdab:	03eb70        	rsr.prid	a7
4037bdae:	047d70        	extui	a7, a7, 13, 1
            if( pxMutexHolder != NULL )
4037bdb1:	0eb216        	beqz	a2, 4037bea0 <xTaskPriorityInherit+0x100>
                if( pxMutexHolderTCB->uxPriority < pxCurrentTCBs[ xCurCoreID ]->uxPriority )
4037bdb4:	b288      	l32i.n	a8, a2, 44
4037bdb6:	e3a291        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037bdb9:	a09790        	addx4	a9, a7, a9
4037bdbc:	0020c0        	memw
4037bdbf:	0998      	l32i.n	a9, a9, 0
4037bdc1:	b998      	l32i.n	a9, a9, 44
4037bdc3:	023897        	bltu	a8, a9, 4037bdc9 <xTaskPriorityInherit+0x29>
4037bdc6:	002f86        	j	4037be88 <xTaskPriorityInherit+0xe8>
                    if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bdc9:	0020c0        	memw
4037bdcc:	6298      	l32i.n	a9, a2, 24
4037bdce:	017996        	bltz	a9, 4037bde9 <xTaskPriorityInherit+0x49>
                        listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCBs[ xCurCoreID ]->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bdd1:	e39b91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037bdd4:	a09790        	addx4	a9, a7, a9
4037bdd7:	0020c0        	memw
4037bdda:	0998      	l32i.n	a9, a9, 0
4037bddc:	b998      	l32i.n	a9, a9, 44
4037bdde:	e7c992        	addi	a9, a9, -25
4037bde1:	609090        	neg	a9, a9
4037bde4:	0020c0        	memw
4037bde7:	6299      	s32i.n	a9, a2, 24
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
4037bde9:	0020c0        	memw
4037bdec:	5298      	l32i.n	a9, a2, 20
4037bdee:	a08880        	addx4	a8, a8, a8
4037bdf1:	e3b0a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037bdf4:	a088a0        	addx4	a8, a8, a10
4037bdf7:	799987        	bne	a9, a8, 4037be74 <xTaskPriorityInherit+0xd4>
                        if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bdfa:	624b      	addi.n	a6, a2, 4
4037bdfc:	06ad      	mov.n	a10, a6
4037bdfe:	feb965        	call8	4037a994 <uxListRemove>
                        pxMutexHolderTCB->uxPriority = pxCurrentTCBs[ xCurCoreID ]->uxPriority;
4037be01:	e38f81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037be04:	a08780        	addx4	a8, a7, a8
4037be07:	0020c0        	memw
4037be0a:	0888      	l32i.n	a8, a8, 0
4037be0c:	b888      	l32i.n	a8, a8, 44
4037be0e:	b289      	s32i.n	a8, a2, 44
                        prvAddTaskToReadyList( pxMutexHolderTCB );
4037be10:	e3a891        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037be13:	0020c0        	memw
4037be16:	0998      	l32i.n	a9, a9, 0
4037be18:	08b987        	bgeu	a9, a8, 4037be24 <xTaskPriorityInherit+0x84>
4037be1b:	e3a591        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037be1e:	0020c0        	memw
4037be21:	006982        	s32i	a8, a9, 0
4037be24:	e3a4a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037be27:	a08880        	addx4	a8, a8, a8
4037be2a:	a088a0        	addx4	a8, a8, a10
4037be2d:	0020c0        	memw
4037be30:	1888      	l32i.n	a8, a8, 4
4037be32:	0020c0        	memw
4037be35:	2289      	s32i.n	a8, a2, 8
4037be37:	0020c0        	memw
4037be3a:	2898      	l32i.n	a9, a8, 8
4037be3c:	0020c0        	memw
4037be3f:	3299      	s32i.n	a9, a2, 12
4037be41:	0020c0        	memw
4037be44:	2898      	l32i.n	a9, a8, 8
4037be46:	0020c0        	memw
4037be49:	1969      	s32i.n	a6, a9, 4
4037be4b:	0020c0        	memw
4037be4e:	2869      	s32i.n	a6, a8, 8
4037be50:	b288      	l32i.n	a8, a2, 44
4037be52:	a09880        	addx4	a9, a8, a8
4037be55:	a099a0        	addx4	a9, a9, a10
4037be58:	0020c0        	memw
4037be5b:	5299      	s32i.n	a9, a2, 20
4037be5d:	0020c0        	memw
4037be60:	0998      	l32i.n	a9, a9, 0
4037be62:	991b      	addi.n	a9, a9, 1
4037be64:	a08880        	addx4	a8, a8, a8
4037be67:	a088a0        	addx4	a8, a8, a10
4037be6a:	0020c0        	memw
4037be6d:	0899      	s32i.n	a9, a8, 0
                    xReturn = pdTRUE;
4037be6f:	120c      	movi.n	a2, 1
4037be71:	000c86        	j	4037bea7 <xTaskPriorityInherit+0x107>
                        pxMutexHolderTCB->uxPriority = pxCurrentTCBs[ xCurCoreID ]->uxPriority;
4037be74:	e37381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037be77:	a08780        	addx4	a8, a7, a8
4037be7a:	0020c0        	memw
4037be7d:	0888      	l32i.n	a8, a8, 0
4037be7f:	b888      	l32i.n	a8, a8, 44
4037be81:	b289      	s32i.n	a8, a2, 44
                    xReturn = pdTRUE;
4037be83:	120c      	movi.n	a2, 1
4037be85:	000786        	j	4037bea7 <xTaskPriorityInherit+0x107>
                    if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCBs[ xCurCoreID ]->uxPriority )
4037be88:	132292        	l32i	a9, a2, 76
4037be8b:	e36d81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037be8e:	a07780        	addx4	a7, a7, a8
4037be91:	0020c0        	memw
4037be94:	0788      	l32i.n	a8, a7, 0
4037be96:	b888      	l32i.n	a8, a8, 44
4037be98:	093987        	bltu	a9, a8, 4037bea5 <xTaskPriorityInherit+0x105>
        BaseType_t xReturn = pdFALSE;
4037be9b:	020c      	movi.n	a2, 0
4037be9d:	000186        	j	4037bea7 <xTaskPriorityInherit+0x107>
4037bea0:	020c      	movi.n	a2, 0
4037bea2:	000046        	j	4037bea7 <xTaskPriorityInherit+0x107>
                        xReturn = pdTRUE;
4037bea5:	120c      	movi.n	a2, 1
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bea7:	e38ba1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037beaa:	fe3d65        	call8	4037a280 <vPortExitCritical>
    }
4037bead:	f01d      	retw.n
	...

4037beb0 <xTaskPriorityDisinherit>:
    {
4037beb0:	004136        	entry	a1, 32
4037beb3:	fb7c      	movi.n	a11, -1
4037beb5:	e387a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037beb8:	fe2765        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pxMutexHolder != NULL )
4037bebb:	0c5216        	beqz	a2, 4037bf84 <xTaskPriorityDisinherit+0xd4>
4037bebe:	03eb80        	rsr.prid	a8
4037bec1:	048d80        	extui	a8, a8, 13, 1
                configASSERT( pxTCB == pxCurrentTCBs[ portGET_CORE_ID() ] );
4037bec4:	e35f91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037bec7:	a08890        	addx4	a8, a8, a9
4037beca:	0020c0        	memw
4037becd:	0888      	l32i.n	a8, a8, 0
4037becf:	0e1827        	beq	a8, a2, 4037bee1 <xTaskPriorityDisinherit+0x31>
4037bed2:	e3b1d1        	l32r	a13, 40374d98 <_iram_text_start+0x994> (3c0247a0 <_flash_rodata_start+0x4680>)
4037bed5:	e3b1c1        	l32r	a12, 40374d9c <_iram_text_start+0x998> (3c028318 <__func__$15>)
4037bed8:	e3b2b1        	l32r	a11, 40374da0 <_iram_text_start+0x99c> (1412 <UserFrameTotalSize+0x1312>)
4037bedb:	e374a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bede:	03ec25        	call8	4037fda0 <__assert_func>
                configASSERT( pxTCB->uxMutexesHeld );
4037bee1:	142282        	l32i	a8, a2, 80
4037bee4:	00e856        	bnez	a8, 4037bef6 <xTaskPriorityDisinherit+0x46>
4037bee7:	e3afd1        	l32r	a13, 40374da4 <_iram_text_start+0x9a0> (3c0247cc <_flash_rodata_start+0x46ac>)
4037beea:	e3acc1        	l32r	a12, 40374d9c <_iram_text_start+0x998> (3c028318 <__func__$15>)
4037beed:	e3aeb1        	l32r	a11, 40374da8 <_iram_text_start+0x9a4> (1413 <UserFrameTotalSize+0x1313>)
4037bef0:	e36fa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bef3:	03eae5        	call8	4037fda0 <__assert_func>
                ( pxTCB->uxMutexesHeld )--;
4037bef6:	880b      	addi.n	a8, a8, -1
4037bef8:	146282        	s32i	a8, a2, 80
                if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4037befb:	b2a8      	l32i.n	a10, a2, 44
4037befd:	132292        	l32i	a9, a2, 76
4037bf00:	029a97        	bne	a10, a9, 4037bf06 <xTaskPriorityDisinherit+0x56>
4037bf03:	002086        	j	4037bf89 <xTaskPriorityDisinherit+0xd9>
                    if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4037bf06:	084856        	bnez	a8, 4037bf8e <xTaskPriorityDisinherit+0xde>
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bf09:	04c272        	addi	a7, a2, 4
4037bf0c:	07ad      	mov.n	a10, a7
4037bf0e:	fea865        	call8	4037a994 <uxListRemove>
                        pxTCB->uxPriority = pxTCB->uxBasePriority;
4037bf11:	132282        	l32i	a8, a2, 76
4037bf14:	b289      	s32i.n	a8, a2, 44
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bf16:	e7c892        	addi	a9, a8, -25
4037bf19:	609090        	neg	a9, a9
4037bf1c:	0020c0        	memw
4037bf1f:	6299      	s32i.n	a9, a2, 24
                        prvAddTaskToReadyList( pxTCB );
4037bf21:	e36391        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037bf24:	0020c0        	memw
4037bf27:	0998      	l32i.n	a9, a9, 0
4037bf29:	07b987        	bgeu	a9, a8, 4037bf34 <xTaskPriorityDisinherit+0x84>
4037bf2c:	e36191        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037bf2f:	0020c0        	memw
4037bf32:	0989      	s32i.n	a8, a9, 0
4037bf34:	e360a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037bf37:	a08880        	addx4	a8, a8, a8
4037bf3a:	a088a0        	addx4	a8, a8, a10
4037bf3d:	0020c0        	memw
4037bf40:	1888      	l32i.n	a8, a8, 4
4037bf42:	0020c0        	memw
4037bf45:	2289      	s32i.n	a8, a2, 8
4037bf47:	0020c0        	memw
4037bf4a:	2898      	l32i.n	a9, a8, 8
4037bf4c:	0020c0        	memw
4037bf4f:	3299      	s32i.n	a9, a2, 12
4037bf51:	0020c0        	memw
4037bf54:	2898      	l32i.n	a9, a8, 8
4037bf56:	0020c0        	memw
4037bf59:	1979      	s32i.n	a7, a9, 4
4037bf5b:	0020c0        	memw
4037bf5e:	2879      	s32i.n	a7, a8, 8
4037bf60:	b288      	l32i.n	a8, a2, 44
4037bf62:	a09880        	addx4	a9, a8, a8
4037bf65:	a099a0        	addx4	a9, a9, a10
4037bf68:	0020c0        	memw
4037bf6b:	5299      	s32i.n	a9, a2, 20
4037bf6d:	0020c0        	memw
4037bf70:	0998      	l32i.n	a9, a9, 0
4037bf72:	991b      	addi.n	a9, a9, 1
4037bf74:	a08880        	addx4	a8, a8, a8
4037bf77:	a088a0        	addx4	a8, a8, a10
4037bf7a:	0020c0        	memw
4037bf7d:	0899      	s32i.n	a9, a8, 0
                        xReturn = pdTRUE;
4037bf7f:	120c      	movi.n	a2, 1
4037bf81:	0002c6        	j	4037bf90 <xTaskPriorityDisinherit+0xe0>
        BaseType_t xReturn = pdFALSE;
4037bf84:	020c      	movi.n	a2, 0
4037bf86:	000186        	j	4037bf90 <xTaskPriorityDisinherit+0xe0>
4037bf89:	020c      	movi.n	a2, 0
4037bf8b:	000046        	j	4037bf90 <xTaskPriorityDisinherit+0xe0>
4037bf8e:	020c      	movi.n	a2, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bf90:	e351a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bf93:	fe2ee5        	call8	4037a280 <vPortExitCritical>
    }
4037bf96:	f01d      	retw.n

4037bf98 <vTaskPriorityDisinheritAfterTimeout>:
    {
4037bf98:	004136        	entry	a1, 32
4037bf9b:	ffafb2        	movi	a11, -1
4037bf9e:	e34da1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037bfa1:	fe18e5        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pxMutexHolder != NULL )
4037bfa4:	0e0216        	beqz	a2, 4037c088 <vTaskPriorityDisinheritAfterTimeout+0xf0>
                configASSERT( pxTCB->uxMutexesHeld );
4037bfa7:	1422a2        	l32i	a10, a2, 80
4037bfaa:	00ea56        	bnez	a10, 4037bfbc <vTaskPriorityDisinheritAfterTimeout+0x24>
4037bfad:	e37dd1        	l32r	a13, 40374da4 <_iram_text_start+0x9a0> (3c0247cc <_flash_rodata_start+0x46ac>)
4037bfb0:	e37fc1        	l32r	a12, 40374dac <_iram_text_start+0x9a8> (3c0282f4 <__func__$14>)
4037bfb3:	e37fb1        	l32r	a11, 40374db0 <_iram_text_start+0x9ac> (1469 <UserFrameTotalSize+0x1369>)
4037bfb6:	e33da1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bfb9:	03de65        	call8	4037fda0 <__assert_func>
                if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4037bfbc:	132282        	l32i	a8, a2, 76
4037bfbf:	02b837        	bgeu	a8, a3, 4037bfc5 <vTaskPriorityDisinheritAfterTimeout+0x2d>
                    uxPriorityToUse = uxHighestPriorityWaitingTask;
4037bfc2:	208330        	or	a8, a3, a3
                if( pxTCB->uxPriority != uxPriorityToUse )
4037bfc5:	0b2292        	l32i	a9, a2, 44
4037bfc8:	029987        	bne	a9, a8, 4037bfce <vTaskPriorityDisinheritAfterTimeout+0x36>
4037bfcb:	002e46        	j	4037c088 <vTaskPriorityDisinheritAfterTimeout+0xf0>
                    if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4037bfce:	021a26        	beqi	a10, 1, 4037bfd4 <vTaskPriorityDisinheritAfterTimeout+0x3c>
4037bfd1:	002cc6        	j	4037c088 <vTaskPriorityDisinheritAfterTimeout+0xf0>
4037bfd4:	03eba0        	rsr.prid	a10
4037bfd7:	04ada0        	extui	a10, a10, 13, 1
                        configASSERT( pxTCB != pxCurrentTCBs[ portGET_CORE_ID() ] );
4037bfda:	e319b1        	l32r	a11, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037bfdd:	a0aab0        	addx4	a10, a10, a11
4037bfe0:	0020c0        	memw
4037bfe3:	002aa2        	l32i	a10, a10, 0
4037bfe6:	0e9a27        	bne	a10, a2, 4037bff8 <vTaskPriorityDisinheritAfterTimeout+0x60>
4037bfe9:	e372d1        	l32r	a13, 40374db4 <_iram_text_start+0x9b0> (3c0247e4 <_flash_rodata_start+0x46c4>)
4037bfec:	e370c1        	l32r	a12, 40374dac <_iram_text_start+0x9a8> (3c0282f4 <__func__$14>)
4037bfef:	e372b1        	l32r	a11, 40374db8 <_iram_text_start+0x9b4> (1484 <UserFrameTotalSize+0x1384>)
4037bff2:	e32ea1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bff5:	03daa5        	call8	4037fda0 <__assert_func>
                        pxTCB->uxPriority = uxPriorityToUse;
4037bff8:	b289      	s32i.n	a8, a2, 44
                        if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bffa:	0020c0        	memw
4037bffd:	62a8      	l32i.n	a10, a2, 24
4037bfff:	00aa96        	bltz	a10, 4037c00d <vTaskPriorityDisinheritAfterTimeout+0x75>
                            listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037c002:	e7c882        	addi	a8, a8, -25
4037c005:	608080        	neg	a8, a8
4037c008:	0020c0        	memw
4037c00b:	6289      	s32i.n	a8, a2, 24
                        if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037c00d:	0020c0        	memw
4037c010:	052282        	l32i	a8, a2, 20
4037c013:	a09990        	addx4	a9, a9, a9
4037c016:	e327a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037c019:	a099a0        	addx4	a9, a9, a10
4037c01c:	689897        	bne	a8, a9, 4037c088 <vTaskPriorityDisinheritAfterTimeout+0xf0>
                            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037c01f:	04c232        	addi	a3, a2, 4
4037c022:	20a330        	or	a10, a3, a3
4037c025:	fe96e5        	call8	4037a994 <uxListRemove>
                            prvAddTaskToReadyList( pxTCB );
4037c028:	b288      	l32i.n	a8, a2, 44
4037c02a:	e32191        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037c02d:	0020c0        	memw
4037c030:	0998      	l32i.n	a9, a9, 0
4037c032:	07b987        	bgeu	a9, a8, 4037c03d <vTaskPriorityDisinheritAfterTimeout+0xa5>
4037c035:	e31e91        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037c038:	0020c0        	memw
4037c03b:	0989      	s32i.n	a8, a9, 0
4037c03d:	e31da1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037c040:	a08880        	addx4	a8, a8, a8
4037c043:	a088a0        	addx4	a8, a8, a10
4037c046:	0020c0        	memw
4037c049:	1888      	l32i.n	a8, a8, 4
4037c04b:	0020c0        	memw
4037c04e:	2289      	s32i.n	a8, a2, 8
4037c050:	0020c0        	memw
4037c053:	2898      	l32i.n	a9, a8, 8
4037c055:	0020c0        	memw
4037c058:	3299      	s32i.n	a9, a2, 12
4037c05a:	0020c0        	memw
4037c05d:	2898      	l32i.n	a9, a8, 8
4037c05f:	0020c0        	memw
4037c062:	1939      	s32i.n	a3, a9, 4
4037c064:	0020c0        	memw
4037c067:	2839      	s32i.n	a3, a8, 8
4037c069:	b288      	l32i.n	a8, a2, 44
4037c06b:	a09880        	addx4	a9, a8, a8
4037c06e:	a099a0        	addx4	a9, a9, a10
4037c071:	0020c0        	memw
4037c074:	5299      	s32i.n	a9, a2, 20
4037c076:	0020c0        	memw
4037c079:	0998      	l32i.n	a9, a9, 0
4037c07b:	991b      	addi.n	a9, a9, 1
4037c07d:	a08880        	addx4	a8, a8, a8
4037c080:	a088a0        	addx4	a8, a8, a10
4037c083:	0020c0        	memw
4037c086:	0899      	s32i.n	a9, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037c088:	e313a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c08b:	fe1f65        	call8	4037a280 <vPortExitCritical>
    }
4037c08e:	f01d      	retw.n

4037c090 <pvTaskIncrementMutexHeldCount>:
    {
4037c090:	004136        	entry	a1, 32
4037c093:	ffafb2        	movi	a11, -1
4037c096:	e30fa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c099:	fe0965        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c09c:	03eb80        	rsr.prid	a8
4037c09f:	048d80        	extui	a8, a8, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ] != NULL )
4037c0a2:	e2e791        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c0a5:	a09890        	addx4	a9, a8, a9
4037c0a8:	0020c0        	memw
4037c0ab:	002992        	l32i	a9, a9, 0
4037c0ae:	012916        	beqz	a9, 4037c0c4 <pvTaskIncrementMutexHeldCount+0x34>
                ( pxCurrentTCBs[ xCurCoreID ]->uxMutexesHeld )++;
4037c0b1:	e2e391        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c0b4:	a09890        	addx4	a9, a8, a9
4037c0b7:	0020c0        	memw
4037c0ba:	09a8      	l32i.n	a10, a9, 0
4037c0bc:	142a92        	l32i	a9, a10, 80
4037c0bf:	991b      	addi.n	a9, a9, 1
4037c0c1:	146a92        	s32i	a9, a10, 80
            xReturn = pxCurrentTCBs[ xCurCoreID ];
4037c0c4:	e2df91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c0c7:	a08890        	addx4	a8, a8, a9
4037c0ca:	0020c0        	memw
4037c0cd:	0828      	l32i.n	a2, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037c0cf:	e301a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c0d2:	fe1ae5        	call8	4037a280 <vPortExitCritical>
    }
4037c0d5:	f01d      	retw.n
	...

4037c0d8 <ulTaskGenericNotifyTake>:
    {
4037c0d8:	004136        	entry	a1, 32
4037c0db:	027d      	mov.n	a7, a2
        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c0dd:	d28c      	beqz.n	a2, 4037c0ee <ulTaskGenericNotifyTake+0x16>
4037c0df:	e337d1        	l32r	a13, 40374dbc <_iram_text_start+0x9b8> (3c024810 <_flash_rodata_start+0x46f0>)
4037c0e2:	e337c1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc> (3c0282dc <__func__$13>)
4037c0e5:	e337b1        	l32r	a11, 40374dc4 <_iram_text_start+0x9c0> (1654 <UserFrameTotalSize+0x1554>)
4037c0e8:	e2f1a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c0eb:	03cb65        	call8	4037fda0 <__assert_func>
4037c0ee:	fb7c      	movi.n	a11, -1
4037c0f0:	e2f9a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c0f3:	fe03e5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c0f6:	03eb90        	rsr.prid	a9
4037c0f9:	049d90        	extui	a9, a9, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] == 0UL )
4037c0fc:	e2d181        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c0ff:	a08980        	addx4	a8, a9, a8
4037c102:	0020c0        	memw
4037c105:	08a8      	l32i.n	a10, a8, 0
4037c107:	50c282        	addi	a8, a2, 80
4037c10a:	a088a0        	addx4	a8, a8, a10
4037c10d:	0020c0        	memw
4037c110:	3888      	l32i.n	a8, a8, 12
4037c112:	a8ec      	bnez.n	a8, 4037c140 <ulTaskGenericNotifyTake+0x68>
                pxCurrentTCBs[ xCurCoreID ]->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4037c114:	e2cb81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c117:	a09980        	addx4	a9, a9, a8
4037c11a:	0020c0        	memw
4037c11d:	0988      	l32i.n	a8, a9, 0
4037c11f:	882a      	add.n	a8, a8, a2
4037c121:	50a192        	movi	a9, 0x150
4037c124:	889a      	add.n	a8, a8, a9
4037c126:	190c      	movi.n	a9, 1
4037c128:	0020c0        	memw
4037c12b:	004892        	s8i	a9, a8, 0
                if( xTicksToWait > ( TickType_t ) 0 )
4037c12e:	e48c      	beqz.n	a4, 4037c140 <ulTaskGenericNotifyTake+0x68>
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4037c130:	1b0c      	movi.n	a11, 1
4037c132:	04ad      	mov.n	a10, a4
4037c134:	fec9a5        	call8	4037add0 <prvAddCurrentTaskToDelayedList>
4037c137:	03eba0        	rsr.prid	a10
4037c13a:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037c13d:	fbf8e5        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &xKernelLock );
4037c140:	e2e541        	l32r	a4, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c143:	04ad      	mov.n	a10, a4
4037c145:	fe13a5        	call8	4037a280 <vPortExitCritical>
4037c148:	fb7c      	movi.n	a11, -1
4037c14a:	20a440        	or	a10, a4, a4
4037c14d:	fdfe25        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c150:	03eb80        	rsr.prid	a8
4037c153:	048d80        	extui	a8, a8, 13, 1
            ulReturn = pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ];
4037c156:	e2ba91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c159:	a09890        	addx4	a9, a8, a9
4037c15c:	0020c0        	memw
4037c15f:	09a8      	l32i.n	a10, a9, 0
4037c161:	50c792        	addi	a9, a7, 80
4037c164:	a099a0        	addx4	a9, a9, a10
4037c167:	0020c0        	memw
4037c16a:	3928      	l32i.n	a2, a9, 12
            if( ulReturn != 0UL )
4037c16c:	52bc      	beqz.n	a2, 4037c1a5 <ulTaskGenericNotifyTake+0xcd>
                if( xClearCountOnExit != pdFALSE )
4037c16e:	b39c      	beqz.n	a3, 4037c18d <ulTaskGenericNotifyTake+0xb5>
                    pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] = 0UL;
4037c170:	e2b491        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c173:	a09890        	addx4	a9, a8, a9
4037c176:	0020c0        	memw
4037c179:	09a8      	l32i.n	a10, a9, 0
4037c17b:	50c792        	addi	a9, a7, 80
4037c17e:	a099a0        	addx4	a9, a9, a10
4037c181:	0a0c      	movi.n	a10, 0
4037c183:	0020c0        	memw
4037c186:	39a9      	s32i.n	a10, a9, 12
4037c188:	000646        	j	4037c1a5 <ulTaskGenericNotifyTake+0xcd>
4037c18b:	910000        	srl	a0, a0
                    pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
4037c18e:	e2ac      	beqz.n	a2, 4037c1c0 <ulTaskGenericNotifyTake+0xe8>
4037c190:	a09890        	addx4	a9, a8, a9
4037c193:	0020c0        	memw
4037c196:	09b8      	l32i.n	a11, a9, 0
4037c198:	a20b      	addi.n	a10, a2, -1
4037c19a:	50c792        	addi	a9, a7, 80
4037c19d:	a099b0        	addx4	a9, a9, a11
4037c1a0:	0020c0        	memw
4037c1a3:	39a9      	s32i.n	a10, a9, 12
            pxCurrentTCBs[ xCurCoreID ]->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4037c1a5:	e2a691        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c1a8:	a08890        	addx4	a8, a8, a9
4037c1ab:	0020c0        	memw
4037c1ae:	002882        	l32i	a8, a8, 0
4037c1b1:	808870        	add	a8, a8, a7
4037c1b4:	50a192        	movi	a9, 0x150
4037c1b7:	808890        	add	a8, a8, a9
4037c1ba:	090c      	movi.n	a9, 0
4037c1bc:	0020c0        	memw
4037c1bf:	004892        	s8i	a9, a8, 0
        taskEXIT_CRITICAL( &xKernelLock );
4037c1c2:	e2c4a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c1c5:	fe0ba5        	call8	4037a280 <vPortExitCritical>
    }
4037c1c8:	f01d      	retw.n
	...

4037c1cc <xTaskGenericNotify>:
    {
4037c1cc:	004136        	entry	a1, 32
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c1cf:	00e316        	beqz	a3, 4037c1e1 <xTaskGenericNotify+0x15>
4037c1d2:	e2fdd1        	l32r	a13, 40374dc8 <_iram_text_start+0x9c4> (3c024824 <_flash_rodata_start+0x4704>)
4037c1d5:	e2fdc1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c0282c8 <__func__$11>)
4037c1d8:	e2feb1        	l32r	a11, 40374dd0 <_iram_text_start+0x9cc> (1702 <UserFrameTotalSize+0x1602>)
4037c1db:	e2b4a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c1de:	03bc25        	call8	4037fda0 <__assert_func>
        configASSERT( xTaskToNotify );
4037c1e1:	00e256        	bnez	a2, 4037c1f3 <xTaskGenericNotify+0x27>
4037c1e4:	e2fcd1        	l32r	a13, 40374dd4 <_iram_text_start+0x9d0> (3c024838 <_flash_rodata_start+0x4718>)
4037c1e7:	e2f9c1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c0282c8 <__func__$11>)
4037c1ea:	e2fbb1        	l32r	a11, 40374dd8 <_iram_text_start+0x9d4> (1703 <UserFrameTotalSize+0x1603>)
4037c1ed:	e2afa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c1f0:	03bae5        	call8	4037fda0 <__assert_func>
4037c1f3:	fb7c      	movi.n	a11, -1
4037c1f5:	e2b7a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c1f8:	fdf365        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pulPreviousNotificationValue != NULL )
4037c1fb:	00d616        	beqz	a6, 4037c20c <xTaskGenericNotify+0x40>
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
4037c1fe:	50c382        	addi	a8, a3, 80
4037c201:	a08820        	addx4	a8, a8, a2
4037c204:	0020c0        	memw
4037c207:	032882        	l32i	a8, a8, 12
4037c20a:	0689      	s32i.n	a8, a6, 0
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c20c:	823a      	add.n	a8, a2, a3
4037c20e:	50a192        	movi	a9, 0x150
4037c211:	889a      	add.n	a8, a8, a9
4037c213:	0020c0        	memw
4037c216:	000892        	l8ui	a9, a8, 0
4037c219:	749090        	extui	a9, a9, 0, 8
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c21c:	2a0c      	movi.n	a10, 2
4037c21e:	0020c0        	memw
4037c221:	0048a2        	s8i	a10, a8, 0
            switch( eAction )
4037c224:	2c2526        	beqi	a5, 2, 4037c254 <xTaskGenericNotify+0x88>
4037c227:	0935f6        	bgeui	a5, 3, 4037c234 <xTaskGenericNotify+0x68>
4037c22a:	077516        	beqz	a5, 4037c2a5 <xTaskGenericNotify+0xd9>
4037c22d:	0c1526        	beqi	a5, 1, 4037c23d <xTaskGenericNotify+0x71>
4037c230:	001606        	j	4037c28c <xTaskGenericNotify+0xc0>
4037c233:	352600        	extui	a2, a0, 22, 4
4037c236:	452631        	l32r	a3, 4034d6d0 <rom_rx_gain_force+0x3472a4>
4037c239:	863d      	lsi	f3, a6, 24
4037c23b:	320013        	lsi	f1, a0, 200
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
4037c23e:	2050c3        	lsi	f12, a0, 128
4037c241:	c0a033        	lsi	f3, a0, 0x300
4037c244:	880020        	lsi	f2, a0, 0x220
4037c247:	884033        	ssi	f3, a0, 0x220
4037c24a:	20c020        	or	a12, a0, a2
4037c24d:	338900        	clamps	a8, a9, 7
                    break;
4037c250:	001446        	j	4037c2a5 <xTaskGenericNotify+0xd9>
4037c253:	c33200        	movf	a3, a2, b0
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c256:	332050        	clamps	a2, a0, 12
4037c259:	20c0a0        	or	a12, a0, a10
4037c25c:	338800        	clamps	a8, a8, 7
4037c25f:	881b      	addi.n	a8, a8, 1
4037c261:	0020c0        	memw
4037c264:	3389      	s32i.n	a8, a3, 12
                    break;
4037c266:	000ec6        	j	4037c2a5 <xTaskGenericNotify+0xd9>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4037c269:	50c332        	addi	a3, a3, 80
4037c26c:	a03320        	addx4	a3, a3, a2
4037c26f:	0020c0        	memw
4037c272:	3349      	s32i.n	a4, a3, 12
                    break;
4037c274:	000b46        	j	4037c2a5 <xTaskGenericNotify+0xd9>
4037c277:	296600        	lsi	f0, a6, 164
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4037c27a:	428602        	lsi	f0, a6, 0x108
4037c27d:	c33200        	movf	a3, a2, b0
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4037c280:	332050        	clamps	a2, a0, 12
4037c283:	20c0a0        	or	a12, a0, a10
4037c286:	334900        	clamps	a4, a9, 7
4037c289:	000606        	j	4037c2a5 <xTaskGenericNotify+0xd9>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
4037c28c:	e29781        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037c28f:	0020c0        	memw
4037c292:	0888      	l32i.n	a8, a8, 0
4037c294:	d88c      	beqz.n	a8, 4037c2a5 <xTaskGenericNotify+0xd9>
4037c296:	e2d1d1        	l32r	a13, 40374ddc <_iram_text_start+0x9d8> (3c024848 <_flash_rodata_start+0x4728>)
4037c299:	e2ccc1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c0282c8 <__func__$11>)
4037c29c:	e2d1b1        	l32r	a11, 40374de0 <_iram_text_start+0x9dc> (1738 <UserFrameTotalSize+0x1638>)
4037c29f:	e283a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c2a2:	03afe5        	call8	4037fda0 <__assert_func>
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4037c2a5:	021926        	beqi	a9, 1, 4037c2ab <xTaskGenericNotify+0xdf>
4037c2a8:	003886        	j	4037c38e <xTaskGenericNotify+0x1c2>
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037c2ab:	0020c0        	memw
4037c2ae:	5288      	l32i.n	a8, a2, 20
4037c2b0:	0020c0        	memw
4037c2b3:	2298      	l32i.n	a9, a2, 8
4037c2b5:	0020c0        	memw
4037c2b8:	32a8      	l32i.n	a10, a2, 12
4037c2ba:	0020c0        	memw
4037c2bd:	29a9      	s32i.n	a10, a9, 8
4037c2bf:	0020c0        	memw
4037c2c2:	3298      	l32i.n	a9, a2, 12
4037c2c4:	0020c0        	memw
4037c2c7:	22a8      	l32i.n	a10, a2, 8
4037c2c9:	0020c0        	memw
4037c2cc:	19a9      	s32i.n	a10, a9, 4
4037c2ce:	0020c0        	memw
4037c2d1:	18a8      	l32i.n	a10, a8, 4
4037c2d3:	924b      	addi.n	a9, a2, 4
4037c2d5:	099a97        	bne	a10, a9, 4037c2e2 <xTaskGenericNotify+0x116>
4037c2d8:	0020c0        	memw
4037c2db:	32a8      	l32i.n	a10, a2, 12
4037c2dd:	0020c0        	memw
4037c2e0:	18a9      	s32i.n	a10, a8, 4
4037c2e2:	0a0c      	movi.n	a10, 0
4037c2e4:	0020c0        	memw
4037c2e7:	0562a2        	s32i	a10, a2, 20
4037c2ea:	0020c0        	memw
4037c2ed:	0028a2        	l32i	a10, a8, 0
4037c2f0:	aa0b      	addi.n	a10, a10, -1
4037c2f2:	0020c0        	memw
4037c2f5:	08a9      	s32i.n	a10, a8, 0
                prvAddTaskToReadyList( pxTCB );
4037c2f7:	b288      	l32i.n	a8, a2, 44
4037c2f9:	e26da1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037c2fc:	0020c0        	memw
4037c2ff:	0aa8      	l32i.n	a10, a10, 0
4037c301:	07ba87        	bgeu	a10, a8, 4037c30c <xTaskGenericNotify+0x140>
4037c304:	e26ba1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037c307:	0020c0        	memw
4037c30a:	0a89      	s32i.n	a8, a10, 0
4037c30c:	e26aa1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037c30f:	a08880        	addx4	a8, a8, a8
4037c312:	a088a0        	addx4	a8, a8, a10
4037c315:	0020c0        	memw
4037c318:	1888      	l32i.n	a8, a8, 4
4037c31a:	0020c0        	memw
4037c31d:	2289      	s32i.n	a8, a2, 8
4037c31f:	0020c0        	memw
4037c322:	28b8      	l32i.n	a11, a8, 8
4037c324:	0020c0        	memw
4037c327:	32b9      	s32i.n	a11, a2, 12
4037c329:	0020c0        	memw
4037c32c:	28b8      	l32i.n	a11, a8, 8
4037c32e:	0020c0        	memw
4037c331:	1b99      	s32i.n	a9, a11, 4
4037c333:	0020c0        	memw
4037c336:	2899      	s32i.n	a9, a8, 8
4037c338:	b288      	l32i.n	a8, a2, 44
4037c33a:	a09880        	addx4	a9, a8, a8
4037c33d:	a099a0        	addx4	a9, a9, a10
4037c340:	0020c0        	memw
4037c343:	5299      	s32i.n	a9, a2, 20
4037c345:	0020c0        	memw
4037c348:	0998      	l32i.n	a9, a9, 0
4037c34a:	991b      	addi.n	a9, a9, 1
4037c34c:	a08880        	addx4	a8, a8, a8
4037c34f:	a088a0        	addx4	a8, a8, a10
4037c352:	0020c0        	memw
4037c355:	0899      	s32i.n	a9, a8, 0
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4037c357:	0020c0        	memw
4037c35a:	a288      	l32i.n	a8, a2, 40
4037c35c:	d88c      	beqz.n	a8, 4037c36d <xTaskGenericNotify+0x1a1>
4037c35e:	e2a1d1        	l32r	a13, 40374de4 <_iram_text_start+0x9e0> (3c024868 <_flash_rodata_start+0x4748>)
4037c361:	e29ac1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c0282c8 <__func__$11>)
4037c364:	e2a1b1        	l32r	a11, 40374de8 <_iram_text_start+0x9e4> (1747 <UserFrameTotalSize+0x1647>)
4037c367:	e251a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c36a:	03a365        	call8	4037fda0 <__assert_func>
                if( taskIS_YIELD_REQUIRED( pxTCB, pdFALSE ) == pdTRUE )
4037c36d:	00a0c2        	movi	a12, 0
4037c370:	0b22b2        	l32i	a11, a2, 44
4037c373:	02ad      	mov.n	a10, a2
4037c375:	fe6f65        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037c378:	0a2d      	mov.n	a2, a10
4037c37a:	171a66        	bnei	a10, 1, 4037c395 <xTaskGenericNotify+0x1c9>
4037c37d:	03eba0        	rsr.prid	a10
4037c380:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037c383:	fbd4a5        	call8	403780cc <esp_crosscore_int_send_yield>
4037c386:	000346        	j	4037c397 <xTaskGenericNotify+0x1cb>
                        xReturn = pdFAIL;
4037c389:	020c      	movi.n	a2, 0
4037c38b:	000206        	j	4037c397 <xTaskGenericNotify+0x1cb>
4037c38e:	120c      	movi.n	a2, 1
4037c390:	0000c6        	j	4037c397 <xTaskGenericNotify+0x1cb>
4037c393:	0c0000        	lsi	f0, a0, 48
4037c396:	4fa112        	movi	a1, 0x14f
        taskEXIT_CRITICAL( &xKernelLock );
4037c399:	ee65e2        	s32i	a14, a5, 0x3b8
4037c39c:	1dfd      	lsi	f15, a13, 52
    }
4037c39e:	f0          	.byte	0xf0
	...

4037c3a0 <vTaskGenericNotifyGiveFromISR>:
    {
4037c3a0:	004136        	entry	a1, 32
        configASSERT( xTaskToNotify );
4037c3a3:	00e256        	bnez	a2, 4037c3b5 <vTaskGenericNotifyGiveFromISR+0x15>
4037c3a6:	e28bd1        	l32r	a13, 40374dd4 <_iram_text_start+0x9d0> (3c024838 <_flash_rodata_start+0x4718>)
4037c3a9:	e290c1        	l32r	a12, 40374dec <_iram_text_start+0x9e8> (3c0282a8 <__func__$9>)
4037c3ac:	e291b1        	l32r	a11, 40374df0 <_iram_text_start+0x9ec> (1809 <UserFrameTotalSize+0x1709>)
4037c3af:	e23fa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c3b2:	039ee5        	call8	4037fda0 <__assert_func>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c3b5:	00e316        	beqz	a3, 4037c3c7 <vTaskGenericNotifyGiveFromISR+0x27>
4037c3b8:	e284d1        	l32r	a13, 40374dc8 <_iram_text_start+0x9c4> (3c024824 <_flash_rodata_start+0x4704>)
4037c3bb:	e28cc1        	l32r	a12, 40374dec <_iram_text_start+0x9e8> (3c0282a8 <__func__$9>)
4037c3be:	e28db1        	l32r	a11, 40374df4 <_iram_text_start+0x9f0> (180a <UserFrameTotalSize+0x170a>)
4037c3c1:	e23aa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c3c4:	039da5        	call8	4037fda0 <__assert_func>
4037c3c7:	fb7c      	movi.n	a11, -1
4037c3c9:	e242a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c3cc:	fdd625        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c3cf:	03eb70        	rsr.prid	a7
4037c3d2:	047d70        	extui	a7, a7, 13, 1
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c3d5:	808230        	add	a8, a2, a3
4037c3d8:	50a192        	movi	a9, 0x150
4037c3db:	889a      	add.n	a8, a8, a9
4037c3dd:	0020c0        	memw
4037c3e0:	000892        	l8ui	a9, a8, 0
4037c3e3:	749090        	extui	a9, a9, 0, 8
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c3e6:	2a0c      	movi.n	a10, 2
4037c3e8:	0020c0        	memw
4037c3eb:	0048a2        	s8i	a10, a8, 0
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c3ee:	50c332        	addi	a3, a3, 80
4037c3f1:	a03320        	addx4	a3, a3, a2
4037c3f4:	0020c0        	memw
4037c3f7:	3388      	l32i.n	a8, a3, 12
4037c3f9:	881b      	addi.n	a8, a8, 1
4037c3fb:	0020c0        	memw
4037c3fe:	3389      	s32i.n	a8, a3, 12
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4037c400:	021926        	beqi	a9, 1, 4037c406 <vTaskGenericNotifyGiveFromISR+0x66>
4037c403:	004d06        	j	4037c53b <vTaskGenericNotifyGiveFromISR+0x19b>
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4037c406:	0020c0        	memw
4037c409:	a288      	l32i.n	a8, a2, 40
4037c40b:	d88c      	beqz.n	a8, 4037c41c <vTaskGenericNotifyGiveFromISR+0x7c>
4037c40d:	e275d1        	l32r	a13, 40374de4 <_iram_text_start+0x9e0> (3c024868 <_flash_rodata_start+0x4748>)
4037c410:	e277c1        	l32r	a12, 40374dec <_iram_text_start+0x9e8> (3c0282a8 <__func__$9>)
4037c413:	e279b1        	l32r	a11, 40374df8 <_iram_text_start+0x9f4> (1833 <UserFrameTotalSize+0x1733>)
4037c416:	e225a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c419:	039865        	call8	4037fda0 <__assert_func>
                if( taskCAN_BE_SCHEDULED( pxTCB ) == pdTRUE )
4037c41c:	20a220        	or	a10, a2, a2
4037c41f:	fe5ca5        	call8	4037a9e8 <prvCheckTaskCanBeScheduledSMP>
4037c422:	021a26        	beqi	a10, 1, 4037c428 <vTaskGenericNotifyGiveFromISR+0x88>
4037c425:	002bc6        	j	4037c4d8 <vTaskGenericNotifyGiveFromISR+0x138>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037c428:	0020c0        	memw
4037c42b:	052282        	l32i	a8, a2, 20
4037c42e:	0020c0        	memw
4037c431:	022292        	l32i	a9, a2, 8
4037c434:	0020c0        	memw
4037c437:	32a8      	l32i.n	a10, a2, 12
4037c439:	0020c0        	memw
4037c43c:	29a9      	s32i.n	a10, a9, 8
4037c43e:	0020c0        	memw
4037c441:	3298      	l32i.n	a9, a2, 12
4037c443:	0020c0        	memw
4037c446:	22a8      	l32i.n	a10, a2, 8
4037c448:	0020c0        	memw
4037c44b:	19a9      	s32i.n	a10, a9, 4
4037c44d:	0020c0        	memw
4037c450:	18a8      	l32i.n	a10, a8, 4
4037c452:	924b      	addi.n	a9, a2, 4
4037c454:	099a97        	bne	a10, a9, 4037c461 <vTaskGenericNotifyGiveFromISR+0xc1>
4037c457:	0020c0        	memw
4037c45a:	32a8      	l32i.n	a10, a2, 12
4037c45c:	0020c0        	memw
4037c45f:	18a9      	s32i.n	a10, a8, 4
4037c461:	0a0c      	movi.n	a10, 0
4037c463:	0020c0        	memw
4037c466:	52a9      	s32i.n	a10, a2, 20
4037c468:	0020c0        	memw
4037c46b:	08a8      	l32i.n	a10, a8, 0
4037c46d:	aa0b      	addi.n	a10, a10, -1
4037c46f:	0020c0        	memw
4037c472:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxTCB );
4037c474:	b288      	l32i.n	a8, a2, 44
4037c476:	e20ea1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037c479:	0020c0        	memw
4037c47c:	0aa8      	l32i.n	a10, a10, 0
4037c47e:	07ba87        	bgeu	a10, a8, 4037c489 <vTaskGenericNotifyGiveFromISR+0xe9>
4037c481:	e20ba1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94c5c <uxTopReadyPriority>)
4037c484:	0020c0        	memw
4037c487:	0a89      	s32i.n	a8, a10, 0
4037c489:	e20aa1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037c48c:	a08880        	addx4	a8, a8, a8
4037c48f:	a088a0        	addx4	a8, a8, a10
4037c492:	0020c0        	memw
4037c495:	1888      	l32i.n	a8, a8, 4
4037c497:	0020c0        	memw
4037c49a:	2289      	s32i.n	a8, a2, 8
4037c49c:	0020c0        	memw
4037c49f:	28b8      	l32i.n	a11, a8, 8
4037c4a1:	0020c0        	memw
4037c4a4:	32b9      	s32i.n	a11, a2, 12
4037c4a6:	0020c0        	memw
4037c4a9:	28b8      	l32i.n	a11, a8, 8
4037c4ab:	0020c0        	memw
4037c4ae:	1b99      	s32i.n	a9, a11, 4
4037c4b0:	0020c0        	memw
4037c4b3:	2899      	s32i.n	a9, a8, 8
4037c4b5:	b288      	l32i.n	a8, a2, 44
4037c4b7:	a09880        	addx4	a9, a8, a8
4037c4ba:	a099a0        	addx4	a9, a9, a10
4037c4bd:	0020c0        	memw
4037c4c0:	5299      	s32i.n	a9, a2, 20
4037c4c2:	0020c0        	memw
4037c4c5:	0998      	l32i.n	a9, a9, 0
4037c4c7:	991b      	addi.n	a9, a9, 1
4037c4c9:	a08880        	addx4	a8, a8, a8
4037c4cc:	a088a0        	addx4	a8, a8, a10
4037c4cf:	0020c0        	memw
4037c4d2:	0899      	s32i.n	a9, a8, 0
4037c4d4:	0010c6        	j	4037c51b <vTaskGenericNotifyGiveFromISR+0x17b>
4037c4d7:	877000        	lsi	f0, a0, 0x21c
                    listINSERT_END( &( xPendingReadyList[ xCurCoreID ] ), &( pxTCB->xEventListItem ) );
4037c4da:	0b91a0        	lsi	f10, a1, 44
4037c4dd:	8890e2        	l16si	a14, a0, 0x110
4037c4e0:	20c0a0        	or	a12, a0, a10
4037c4e3:	289200        	lsi	f0, a2, 160
4037c4e6:	20c001        	l32r	a0, 403447e8 <rom_rx_gain_force+0x33e3bc>
4037c4e9:	629200        	lsi	f0, a2, 0x188
4037c4ec:	20c007        	bnall	a0, a0, 4037c510 <vTaskGenericNotifyGiveFromISR+0x170>
4037c4ef:	29a200        	lsi	f0, a2, 164
4037c4f2:	20c002        	addi	a0, a0, 32
4037c4f5:	82a900        	mull	a10, a9, a0
4037c4f8:	0020c0        	memw
4037c4fb:	29b8      	l32i.n	a11, a9, 8
4037c4fd:	18c2a2        	addi	a10, a2, 24
4037c500:	0020c0        	memw
4037c503:	1ba9      	s32i.n	a10, a11, 4
4037c505:	0020c0        	memw
4037c508:	29a9      	s32i.n	a10, a9, 8
4037c50a:	0020c0        	memw
4037c50d:	a289      	s32i.n	a8, a2, 40
4037c50f:	0020c0        	memw
4037c512:	0898      	l32i.n	a9, a8, 0
4037c514:	991b      	addi.n	a9, a9, 1
4037c516:	0020c0        	memw
4037c519:	0899      	s32i.n	a9, a8, 0
                if( taskIS_YIELD_REQUIRED( pxTCB, pdFALSE ) == pdTRUE )
4037c51b:	0c0c      	movi.n	a12, 0
4037c51d:	b2b8      	l32i.n	a11, a2, 44
4037c51f:	02ad      	mov.n	a10, a2
4037c521:	fe54a5        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037c524:	131a66        	bnei	a10, 1, 4037c53b <vTaskGenericNotifyGiveFromISR+0x19b>
                    if( pxHigherPriorityTaskWoken != NULL )
4037c527:	248c      	beqz.n	a4, 4037c52d <vTaskGenericNotifyGiveFromISR+0x18d>
                        *pxHigherPriorityTaskWoken = pdTRUE;
4037c529:	180c      	movi.n	a8, 1
4037c52b:	0489      	s32i.n	a8, a4, 0
                    xYieldPending[ xCurCoreID ] = pdTRUE;
4037c52d:	e1ff81        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037c530:	a07780        	addx4	a7, a7, a8
4037c533:	180c      	movi.n	a8, 1
4037c535:	0020c0        	memw
4037c538:	006782        	s32i	a8, a7, 0
        prvEXIT_CRITICAL_OR_UNMASK_ISR( &xKernelLock, uxSavedInterruptStatus );
4037c53b:	e1e6a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c53e:	fdd425        	call8	4037a280 <vPortExitCritical>
    }
4037c541:	f01d      	retw.n
	...

4037c544 <xTaskIncrementTickOtherCores>:
/*----------------------------------------------------------*/

#if ( !CONFIG_FREERTOS_SMP && ( configNUM_CORES > 1 ) )

    BaseType_t xTaskIncrementTickOtherCores( void )
    {
4037c544:	004136        	entry	a1, 32
4037c547:	03eb70        	rsr.prid	a7
4037c54a:	047d70        	extui	a7, a7, 13, 1
         * execution */
        BaseType_t xCoreID = portGET_CORE_ID();
        BaseType_t xSwitchRequired = pdFALSE;

        /* This function should never be called by Core 0. */
        configASSERT( xCoreID != 0 );
4037c54d:	c7cc      	bnez.n	a7, 4037c55d <xTaskIncrementTickOtherCores+0x19>
4037c54f:	e22bd1        	l32r	a13, 40374dfc <_iram_text_start+0x9f8> (3c0248a8 <_flash_rodata_start+0x4788>)
4037c552:	e22bc1        	l32r	a12, 40374e00 <_iram_text_start+0x9fc> (3c028288 <__func__$7>)
4037c555:	bb5c      	movi.n	a11, 91
4037c557:	e22ba1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c55a:	038465        	call8	4037fda0 <__assert_func>

        /* Called by the portable layer each time a tick interrupt occurs
         * on a core other than core 0. */
        traceTASK_INCREMENT_TICK( xTickCount );

        if( uxSchedulerSuspended[ xCoreID ] == ( UBaseType_t ) 0U )
4037c55d:	e1ce81        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94c30 <uxSchedulerSuspended>)
4037c560:	a08780        	addx4	a8, a7, a8
4037c563:	0020c0        	memw
4037c566:	0888      	l32i.n	a8, a8, 0
4037c568:	049856        	bnez	a8, 4037c5b5 <xTaskIncrementTickOtherCores+0x71>
4037c56b:	ffafb2        	movi	a11, -1
4037c56e:	e1d9a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c571:	fdbbe5        	call8	4037a130 <xPortEnterCriticalTimeout>
            /* Tasks of equal priority to the currently running task will share
             * processing time (time slice) if preemption is on, and the application
             * writer has not explicitly turned time slicing off. */
            #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCBs[ xCoreID ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037c574:	e1b381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94ee0 <pxCurrentTCBs>)
4037c577:	a08780        	addx4	a8, a7, a8
4037c57a:	0020c0        	memw
4037c57d:	002882        	l32i	a8, a8, 0
4037c580:	b888      	l32i.n	a8, a8, 44
4037c582:	a08880        	addx4	a8, a8, a8
4037c585:	1198e0        	slli	a9, a8, 2
4037c588:	e1cb81        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94cec <pxReadyTasksLists>)
4037c58b:	889a      	add.n	a8, a8, a9
4037c58d:	0020c0        	memw
4037c590:	0888      	l32i.n	a8, a8, 0
4037c592:	0428f6        	bgeui	a8, 2, 4037c59a <xTaskIncrementTickOtherCores+0x56>
        BaseType_t xSwitchRequired = pdFALSE;
4037c595:	020c      	movi.n	a2, 0
4037c597:	000086        	j	4037c59d <xTaskIncrementTickOtherCores+0x59>
                {
                    xSwitchRequired = pdTRUE;
4037c59a:	01a022        	movi	a2, 1
            }
            #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */

            /* Release the previously taken kernel lock as we have finished
             * accessing the kernel data structures. */
            taskEXIT_CRITICAL_ISR( &xKernelLock );
4037c59d:	e1cda1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c5a0:	fdcde5        	call8	4037a280 <vPortExitCritical>

            #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending[ xCoreID ] != pdFALSE )
4037c5a3:	e1e281        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94c4c <xYieldPending>)
4037c5a6:	a07780        	addx4	a7, a7, a8
4037c5a9:	0020c0        	memw
4037c5ac:	002782        	l32i	a8, a7, 0
4037c5af:	007856        	bnez	a8, 4037c5ba <xTaskIncrementTickOtherCores+0x76>
4037c5b2:	000186        	j	4037c5bc <xTaskIncrementTickOtherCores+0x78>
        BaseType_t xSwitchRequired = pdFALSE;
4037c5b5:	020c      	movi.n	a2, 0
4037c5b7:	000046        	j	4037c5bc <xTaskIncrementTickOtherCores+0x78>
                {
                    xSwitchRequired = pdTRUE;
4037c5ba:	120c      	movi.n	a2, 1
            vApplicationTickHook();
        }
        #endif

        return xSwitchRequired;
    }
4037c5bc:	f01d      	retw.n
	...

4037c5c0 <xTaskCreatePinnedToCore>:
                                        const uint32_t usStackDepth,
                                        void * const pvParameters,
                                        UBaseType_t uxPriority,
                                        TaskHandle_t * const pxCreatedTask,
                                        const BaseType_t xCoreID )
    {
4037c5c0:	008136        	entry	a1, 64
4037c5c3:	066172        	s32i	a7, a1, 24
4037c5c6:	046152        	s32i	a5, a1, 16
4037c5c9:	056162        	s32i	a6, a1, 20
4037c5cc:	102152        	l32i	a5, a1, 64
        BaseType_t xReturn;

        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE || xCoreID == tskNO_AFFINITY );
4037c5cf:	180c      	movi.n	a8, 1
4037c5d1:	628850        	lsi	f5, a8, 0x188
4037c5d4:	880b      	addi.n	a8, a8, -1
4037c5d6:	608080        	neg	a8, a8
4037c5d9:	748080        	extui	a8, a8, 0, 8
4037c5dc:	e08b91        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037c5df:	c09590        	sub	a9, a5, a9
4037c5e2:	40f990        	nsau	a9, a9
4037c5e5:	419590        	srli	a9, a9, 5
4037c5e8:	208890        	or	a8, a8, a9
4037c5eb:	d8cc      	bnez.n	a8, 4037c5fc <xTaskCreatePinnedToCore+0x3c>
4037c5ed:	e206d1        	l32r	a13, 40374e08 <_iram_text_start+0xa04> (3c024900 <_flash_rodata_start+0x47e0>)
4037c5f0:	e207c1        	l32r	a12, 40374e0c <_iram_text_start+0xa08> (3c028270 <__func__$6>)
4037c5f3:	a3a0b2        	movi	a11, 163
4037c5f6:	e203a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c5f9:	037a65        	call8	4037fda0 <__assert_func>
            #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
4037c5fc:	04ad      	mov.n	a10, a4
4037c5fe:	fdf965        	call8	4037a594 <pvPortMalloc>
4037c601:	0a7d      	mov.n	a7, a10

                if( pxStack != NULL )
4037c603:	049a16        	beqz	a10, 4037c650 <xTaskCreatePinnedToCore+0x90>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
4037c606:	54a1a2        	movi	a10, 0x154
4037c609:	fdf8a5        	call8	4037a594 <pvPortMalloc>
4037c60c:	0a6d      	mov.n	a6, a10

                    if( pxNewTCB != NULL )
4037c60e:	4abc      	beqz.n	a10, 4037c646 <xTaskCreatePinnedToCore+0x86>
                    {
                        memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
4037c610:	54a1c2        	movi	a12, 0x154
4037c613:	0b0c      	movi.n	a11, 0
4037c615:	df9e81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037c618:	0008e0        	callx8	a8

                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
4037c61b:	c679      	s32i.n	a7, a6, 48
            {
                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
                {
                    /* Tasks can be created statically or dynamically, so note this
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
4037c61d:	01d682        	addmi	a8, a6, 0x100
4037c620:	090c      	movi.n	a9, 0
4037c622:	514892        	s8i	a9, a8, 81
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL, xCoreID );
4037c625:	2159      	s32i.n	a5, a1, 8
4037c627:	080c      	movi.n	a8, 0
4037c629:	1189      	s32i.n	a8, a1, 4
4037c62b:	0169      	s32i.n	a6, a1, 0
4037c62d:	61f8      	l32i.n	a15, a1, 24
4037c62f:	51e8      	l32i.n	a14, a1, 20
4037c631:	41d8      	l32i.n	a13, a1, 16
4037c633:	04cd      	mov.n	a12, a4
4037c635:	03bd      	mov.n	a11, a3
4037c637:	02ad      	mov.n	a10, a2
4037c639:	fe8c25        	call8	4037aefc <prvInitialiseNewTask>
                prvAddNewTaskToReadyList( pxNewTCB );
4037c63c:	06ad      	mov.n	a10, a6
4037c63e:	fe9c65        	call8	4037b004 <prvAddNewTaskToReadyList>
                xReturn = pdPASS;
4037c641:	120c      	movi.n	a2, 1
4037c643:	0002c6        	j	4037c652 <xTaskCreatePinnedToCore+0x92>
                        vPortFreeStack( pxStack );
4037c646:	07ad      	mov.n	a10, a7
4037c648:	fdf5e5        	call8	4037a5a8 <vPortFree>
            }
            else
            {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
4037c64b:	f27c      	movi.n	a2, -1
4037c64d:	000046        	j	4037c652 <xTaskCreatePinnedToCore+0x92>
4037c650:	f27c      	movi.n	a2, -1
            }
        }
        #endif /* CONFIG_FREERTOS_SMP */

        return xReturn;
    }
4037c652:	f01d      	retw.n

4037c654 <xTaskCreateStaticPinnedToCore>:
                                                void * const pvParameters,
                                                UBaseType_t uxPriority,
                                                StackType_t * const puxStackBuffer,
                                                StaticTask_t * const pxTaskBuffer,
                                                const BaseType_t xCoreID )
    {
4037c654:	00a136        	entry	a1, 80
4037c657:	8169      	s32i.n	a6, a1, 32
4037c659:	142162        	l32i	a6, a1, 80
        TaskHandle_t xReturn;

        configASSERT( portVALID_STACK_MEM( puxStackBuffer ) );
4037c65c:	07ad      	mov.n	a10, a7
4037c65e:	fdfb25        	call8	4037a610 <xPortcheckValidStackMem>
4037c661:	dacc      	bnez.n	a10, 4037c672 <xTaskCreateStaticPinnedToCore+0x1e>
4037c663:	e1ebd1        	l32r	a13, 40374e10 <_iram_text_start+0xa0c> (3c0249bc <_flash_rodata_start+0x489c>)
4037c666:	e1ebc1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c028238 <__func__$4>)
4037c669:	2ba1b2        	movi	a11, 0x12b
4037c66c:	e1e6a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c66f:	037325        	call8	4037fda0 <__assert_func>
        configASSERT( portVALID_TCB_MEM( pxTaskBuffer ) );
4037c672:	20a660        	or	a10, a6, a6
4037c675:	fdf3e5        	call8	4037a5b4 <xPortCheckValidTCBMem>
4037c678:	00ea56        	bnez	a10, 4037c68a <xTaskCreateStaticPinnedToCore+0x36>
4037c67b:	e1e7d1        	l32r	a13, 40374e18 <_iram_text_start+0xa14> (3c0249e4 <_flash_rodata_start+0x48c4>)
4037c67e:	e1e5c1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c028238 <__func__$4>)
4037c681:	2ca1b2        	movi	a11, 0x12c
4037c684:	e1e0a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c687:	0371a5        	call8	4037fda0 <__assert_func>
        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE || xCoreID == tskNO_AFFINITY );
4037c68a:	01a082        	movi	a8, 1
4037c68d:	152192        	l32i	a9, a1, 84
4037c690:	628890        	lsi	f9, a8, 0x188
4037c693:	ffc882        	addi	a8, a8, -1
4037c696:	608080        	neg	a8, a8
4037c699:	748080        	extui	a8, a8, 0, 8
4037c69c:	e05b91        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037c69f:	1521a2        	l32i	a10, a1, 84
4037c6a2:	c09a90        	sub	a9, a10, a9
4037c6a5:	40f990        	nsau	a9, a9
4037c6a8:	419590        	srli	a9, a9, 5
4037c6ab:	208890        	or	a8, a8, a9
4037c6ae:	00e856        	bnez	a8, 4037c6c0 <xTaskCreateStaticPinnedToCore+0x6c>
4037c6b1:	e1d5d1        	l32r	a13, 40374e08 <_iram_text_start+0xa04> (3c024900 <_flash_rodata_start+0x47e0>)
4037c6b4:	e1d8c1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c028238 <__func__$4>)
4037c6b7:	2da1b2        	movi	a11, 0x12d
4037c6ba:	e1d2a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c6bd:	036e25        	call8	4037fda0 <__assert_func>
            #if ( configASSERT_DEFINED == 1 )
            {
                /* Sanity check that the size of the structure used to declare a
                 * variable of type StaticTask_t equals the size of the real task
                 * structure. */
                volatile size_t xSize = sizeof( StaticTask_t );
4037c6c0:	54a182        	movi	a8, 0x154
4037c6c3:	0020c0        	memw
4037c6c6:	5189      	s32i.n	a8, a1, 20
                configASSERT( xSize == sizeof( TCB_t ) );
4037c6c8:	0020c0        	memw
4037c6cb:	052192        	l32i	a9, a1, 20
4037c6ce:	0e1987        	beq	a9, a8, 4037c6e0 <xTaskCreateStaticPinnedToCore+0x8c>
4037c6d1:	e1d2d1        	l32r	a13, 40374e1c <_iram_text_start+0xa18> (3c024a08 <_flash_rodata_start+0x48e8>)
4037c6d4:	e1d0c1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c028238 <__func__$4>)
4037c6d7:	57a1b2        	movi	a11, 0x157
4037c6da:	e1caa1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c6dd:	036c25        	call8	4037fda0 <__assert_func>
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
4037c6e0:	0020c0        	memw
4037c6e3:	052182        	l32i	a8, a1, 20
            }
            #endif /* configASSERT_DEFINED */

            if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
4037c6e6:	01a092        	movi	a9, 1
4037c6e9:	839660        	moveqz	a9, a6, a6
4037c6ec:	180c      	movi.n	a8, 1
4037c6ee:	838770        	moveqz	a8, a7, a7
4037c6f1:	3b0987        	bnone	a9, a8, 4037c730 <xTaskCreateStaticPinnedToCore+0xdc>
            {
                /* The memory used for the task's TCB and stack are passed into this
                 * function - use them. */
                pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
                memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
4037c6f4:	54a1c2        	movi	a12, 0x154
4037c6f7:	0b0c      	movi.n	a11, 0
4037c6f9:	20a660        	or	a10, a6, a6
4037c6fc:	df6581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037c6ff:	0008e0        	callx8	a8
                pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
4037c702:	c679      	s32i.n	a7, a6, 48

                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
                {
                    /* Tasks can be created statically or dynamically, so note this
                     * task was created statically in case the task is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
4037c704:	01d682        	addmi	a8, a6, 0x100
4037c707:	290c      	movi.n	a9, 2
4037c709:	514892        	s8i	a9, a8, 81
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL, xCoreID );
4037c70c:	152182        	l32i	a8, a1, 84
4037c70f:	2189      	s32i.n	a8, a1, 8
4037c711:	080c      	movi.n	a8, 0
4037c713:	1189      	s32i.n	a8, a1, 4
4037c715:	0169      	s32i.n	a6, a1, 0
4037c717:	10c1f2        	addi	a15, a1, 16
4037c71a:	81e8      	l32i.n	a14, a1, 32
4037c71c:	05dd      	mov.n	a13, a5
4037c71e:	04cd      	mov.n	a12, a4
4037c720:	03bd      	mov.n	a11, a3
4037c722:	02ad      	mov.n	a10, a2
4037c724:	fe7d65        	call8	4037aefc <prvInitialiseNewTask>
                prvAddNewTaskToReadyList( pxNewTCB );
4037c727:	06ad      	mov.n	a10, a6
4037c729:	fe8da5        	call8	4037b004 <prvAddNewTaskToReadyList>
4037c72c:	000106        	j	4037c734 <xTaskCreateStaticPinnedToCore+0xe0>
4037c72f:	080c00        	lsx	f0, a12, a0
            }
            else
            {
                xReturn = NULL;
4037c732:	4189      	s32i.n	a8, a1, 16
            }
        }
        #endif /* CONFIG_FREERTOS_SMP */

        return xReturn;
    }
4037c734:	4128      	l32i.n	a2, a1, 16
4037c736:	f01d      	retw.n

4037c738 <prvCreateIdleTasks>:
{
4037c738:	00a136        	entry	a1, 80
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
4037c73b:	0c1c      	movi.n	a12, 16
4037c73d:	0b0c      	movi.n	a11, 0
4037c73f:	80a1c0        	add	a10, a1, a12
4037c742:	df5381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037c745:	0008e0        	callx8	a8
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c748:	070c      	movi.n	a7, 0
    BaseType_t xReturn = pdPASS;
4037c74a:	120c      	movi.n	a2, 1
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c74c:	001a86        	j	4037c7ba <prvCreateIdleTasks+0x82>
4037c74f:	921600        	lsi	f0, a6, 0x248
            if( xReturn == pdFAIL )
4037c752:	080c06        	j	4037e786 <multi_heap_malloc+0x3a>
            for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < xCopyLen; xIdleTaskNameIndex++ )
4037c755:	0004c6        	j	4037c76c <prvCreateIdleTasks+0x34>
                cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
4037c758:	e1b291        	l32r	a9, 40374e20 <_iram_text_start+0xa1c> (3c024a24 <_flash_rodata_start+0x4904>)
4037c75b:	809980        	add	a9, a9, a8
4037c75e:	0009a2        	l8ui	a10, a9, 0
4037c761:	10c192        	addi	a9, a1, 16
4037c764:	809980        	add	a9, a9, a8
4037c767:	0049a2        	s8i	a10, a9, 0
            for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < xCopyLen; xIdleTaskNameIndex++ )
4037c76a:	881b      	addi.n	a8, a8, 1
4037c76c:	e848a6        	blti	a8, 4, 4037c758 <prvCreateIdleTasks+0x20>
            cIdleName[ xIdleTaskNameIndex ] = ( char ) ( xCoreID + '0' );
4037c76f:	30c792        	addi	a9, a7, 48
4037c772:	10c162        	addi	a6, a1, 16
4037c775:	a68a      	add.n	a10, a6, a8
4037c777:	004a92        	s8i	a9, a10, 0
            cIdleName[ xIdleTaskNameIndex + 1 ] = '\0';
4037c77a:	881b      	addi.n	a8, a8, 1
4037c77c:	868a      	add.n	a8, a6, a8
4037c77e:	090c      	movi.n	a9, 0
4037c780:	004892        	s8i	a9, a8, 0
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
4037c783:	050c      	movi.n	a5, 0
4037c785:	a159      	s32i.n	a5, a1, 40
            StackType_t * pxIdleTaskStackBuffer = NULL;
4037c787:	9159      	s32i.n	a5, a1, 36
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
4037c789:	20c1c2        	addi	a12, a1, 32
4037c78c:	24c1b2        	addi	a11, a1, 36
4037c78f:	28c1a2        	addi	a10, a1, 40
4037c792:	fded65        	call8	4037a668 <vApplicationGetIdleTaskMemory>
            xIdleTaskHandle[ xCoreID ] = xTaskCreateStaticPinnedToCore( prvIdleTask,
4037c795:	1179      	s32i.n	a7, a1, 4
4037c797:	a188      	l32i.n	a8, a1, 40
4037c799:	0189      	s32i.n	a8, a1, 0
4037c79b:	91f8      	l32i.n	a15, a1, 36
4037c79d:	05ed      	mov.n	a14, a5
4037c79f:	05dd      	mov.n	a13, a5
4037c7a1:	81c8      	l32i.n	a12, a1, 32
4037c7a3:	20b660        	or	a11, a6, a6
4037c7a6:	e19fa1        	l32r	a10, 40374e24 <_iram_text_start+0xa20> (4037aeec <prvIdleTask>)
4037c7a9:	ffeaa5        	call8	4037c654 <xTaskCreateStaticPinnedToCore>
4037c7ac:	e19f81        	l32r	a8, 40374e28 <_iram_text_start+0xa24> (3fc94c38 <xIdleTaskHandle>)
4037c7af:	a08780        	addx4	a8, a7, a8
4037c7b2:	08a9      	s32i.n	a10, a8, 0
            if( xIdleTaskHandle[ xCoreID ] != NULL )
4037c7b4:	0acc      	bnez.n	a10, 4037c7b8 <prvCreateIdleTasks+0x80>
                xReturn = pdFAIL;
4037c7b6:	052d      	mov.n	a2, a5
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c7b8:	771b      	addi.n	a7, a7, 1
4037c7ba:	9227a6        	blti	a7, 2, 4037c750 <prvCreateIdleTasks+0x18>
}
4037c7bd:	f01d      	retw.n
	...

4037c7c0 <vTaskStartScheduler>:
{
4037c7c0:	004136        	entry	a1, 32
    xReturn = prvCreateIdleTasks();
4037c7c3:	fff765        	call8	4037c738 <prvCreateIdleTasks>
        if( xReturn == pdPASS )
4037c7c6:	3b1a66        	bnei	a10, 1, 4037c805 <vTaskStartScheduler+0x45>
            xReturn = xTimerCreateTimerTask();
4037c7c9:	000a65        	call8	4037c870 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
4037c7cc:	351a66        	bnei	a10, 1, 4037c805 <vTaskStartScheduler+0x45>
        portDISABLE_INTERRUPTS();
4037c7cf:	006380        	rsil	a8, 3
4037c7d2:	fb7c      	movi.n	a11, -1
4037c7d4:	e140a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c7d7:	fd95a5        	call8	4037a130 <xPortEnterCriticalTimeout>
            xNextTaskUnblockTime = portMAX_DELAY;
4037c7da:	e13181        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94c40 <xNextTaskUnblockTime>)
4037c7dd:	f97c      	movi.n	a9, -1
4037c7df:	0020c0        	memw
4037c7e2:	0899      	s32i.n	a9, a8, 0
            xSchedulerRunning = pdTRUE;
4037c7e4:	e14a81        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94c58 <xSchedulerRunning>)
4037c7e7:	190c      	movi.n	a9, 1
4037c7e9:	0020c0        	memw
4037c7ec:	0899      	s32i.n	a9, a8, 0
            xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
4037c7ee:	e13e81        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94c60 <xTickCount>)
4037c7f1:	00a092        	movi	a9, 0
4037c7f4:	0020c0        	memw
4037c7f7:	0899      	s32i.n	a9, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037c7f9:	e136a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c7fc:	fda825        	call8	4037a280 <vPortExitCritical>
        xPortStartScheduler();
4037c7ff:	fd84a5        	call8	4037a048 <xPortStartScheduler>
4037c802:	000446        	j	4037c817 <vTaskStartScheduler+0x57>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
4037c805:	0e0a66        	bnei	a10, -1, 4037c817 <vTaskStartScheduler+0x57>
4037c808:	e189d1        	l32r	a13, 40374e2c <_iram_text_start+0xa28> (3c024a2c <_flash_rodata_start+0x490c>)
4037c80b:	e189c1        	l32r	a12, 40374e30 <_iram_text_start+0xa2c> (3c0283d0 <__func__$32>)
4037c80e:	e189b1        	l32r	a11, 40374e34 <_iram_text_start+0xa30> (98b <UserFrameTotalSize+0x88b>)
4037c811:	e126a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c814:	0358a5        	call8	4037fda0 <__assert_func>
    ( void ) uxTopUsedPriority;
4037c817:	e18881        	l32r	a8, 40374e38 <_iram_text_start+0xa34> (3c028438 <uxTopUsedPriority>)
4037c81a:	0020c0        	memw
4037c81d:	0888      	l32i.n	a8, a8, 0
}
4037c81f:	f01d      	retw.n
4037c821:	000000        	ill

4037c824 <vTaskSetThreadLocalStoragePointerAndDelCallback>:

    void vTaskSetThreadLocalStoragePointerAndDelCallback( TaskHandle_t xTaskToSet,
                                                          BaseType_t xIndex,
                                                          void * pvValue,
                                                          TlsDeleteCallbackFunction_t pvDelCallback )
    {
4037c824:	004136        	entry	a1, 32
        /* If TLSP deletion callbacks are enabled, then configNUM_THREAD_LOCAL_STORAGE_POINTERS
         * is doubled in size so that the latter half of the pvThreadLocalStoragePointers
         * stores the deletion callbacks. */
        if( xIndex < ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ) )
4037c827:	2913e6        	bgei	a3, 1, 4037c854 <vTaskSetThreadLocalStoragePointerAndDelCallback+0x30>
4037c82a:	ffafb2        	movi	a11, -1
4037c82d:	e129a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c830:	fd8fe5        	call8	4037a130 <xPortEnterCriticalTimeout>
                }
                #endif /* CONFIG_FREERTOS_SMP */
            }
            #endif /* configNUM_CORES > 1 */

            pxTCB = prvGetTCBFromHandle( xTaskToSet );
4037c833:	005256        	bnez	a2, 4037c83c <vTaskSetThreadLocalStoragePointerAndDelCallback+0x18>
4037c836:	ff05a5        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037c839:	202aa0        	or	a2, a10, a10
            /* Store the TLSP by indexing the first half of the array */
            pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
4037c83c:	14c382        	addi	a8, a3, 20
4037c83f:	a08820        	addx4	a8, a8, a2
4037c842:	016842        	s32i	a4, a8, 4

            /* Store the TLSP deletion callback by indexing the second half
             * of the array. */
            pxTCB->pvThreadLocalStoragePointers[ ( xIndex + ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ) ) ] = ( void * ) pvDelCallback;
4037c845:	15c332        	addi	a3, a3, 21
4037c848:	a02320        	addx4	a2, a3, a2
4037c84b:	016252        	s32i	a5, a2, 4
                {
                    taskEXIT_CRITICAL();
                }
                #else /* CONFIG_FREERTOS_SMP */
                {
                    taskEXIT_CRITICAL( &xKernelLock );
4037c84e:	e121a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc920f8 <xKernelLock>)
4037c851:	fda2e5        	call8	4037a280 <vPortExitCritical>
                }
                #endif /* CONFIG_FREERTOS_SMP */
            }
            #endif /* configNUM_CORES > 1 */
        }
    }
4037c854:	000090        	retw
	...

4037c858 <__getreent>:
 * - If FreeRTOS is not running, it will return the global reent struct
 *
 * @return Pointer to a the (current taks's)/(global) reent struct
 */
    struct _reent * __getreent( void )
    {
4037c858:	004136        	entry	a1, 32
        /* No lock needed because if this changes, we won't be running anymore. */
        TCB_t * pxCurTask = ( TCB_t * ) xTaskGetCurrentTaskHandle();
4037c85b:	ff0365        	call8	4037b890 <xTaskGetCurrentTaskHandle>
        struct _reent * ret;

        if( pxCurTask == NULL )
4037c85e:	7a8c      	beqz.n	a10, 4037c869 <__getreent+0x11>
            ret = _GLOBAL_REENT;
        }
        else
        {
            /* We have a currently executing task. Return its reentrant struct. */
            ret = &pxCurTask->xTLSBlock;
4037c860:	5cca22        	addi	a2, a10, 92
4037c863:	000146        	j	4037c86c <__getreent+0x14>
4037c866:	000000        	ill
            ret = _GLOBAL_REENT;
4037c869:	dfc121        	l32r	a2, 40374770 <_iram_text_start+0x36c> (3fc927c8 <_impure_data>)
        }

        return ret;
    }
4037c86c:	f01d      	retw.n
	...

4037c870 <xTimerCreateTimerTask>:
    {
4037c870:	004136        	entry	a1, 32
    }
4037c873:	120c      	movi.n	a2, 1
4037c875:	f01d      	retw.n
	...

4037c878 <s_cache_hal_init_ctx>:

static cache_hal_context_t ctx;


void s_cache_hal_init_ctx(void)
{
4037c878:	004136        	entry	a1, 32
    if (REG_GET_BIT(EXTMEM_DCACHE_AUTOLOAD_CTRL_REG, EXTMEM_DCACHE_AUTOLOAD_ENA)) {
4037c87b:	e17081        	l32r	a8, 40374e3c <_iram_text_start+0xa38> (600c404c <SYSTEM+0x404c>)
4037c87e:	0020c0        	memw
4037c881:	0888      	l32i.n	a8, a8, 0
4037c883:	05e827        	bbsi	a8, 2, 4037c88c <s_cache_hal_init_ctx+0x14>
    bool enabled = false;
4037c886:	090c      	movi.n	a9, 0
4037c888:	000086        	j	4037c88e <s_cache_hal_init_ctx+0x16>
4037c88b:	190c00        	lsi	f0, a12, 100
    ctx.l1.d_autoload_en = cache_ll_is_cache_autoload_enabled(1, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
4037c88e:	e16c81        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc94abc <ctx>)
4037c891:	014892        	s8i	a9, a8, 1
    if (REG_GET_BIT(EXTMEM_ICACHE_AUTOLOAD_CTRL_REG, EXTMEM_ICACHE_AUTOLOAD_ENA)) {
4037c894:	e16c81        	l32r	a8, 40374e44 <_iram_text_start+0xa40> (600c40a0 <SYSTEM+0x40a0>)
4037c897:	0020c0        	memw
4037c89a:	0888      	l32i.n	a8, a8, 0
4037c89c:	04e827        	bbsi	a8, 2, 4037c8a4 <s_cache_hal_init_ctx+0x2c>
    bool enabled = false;
4037c89f:	090c      	movi.n	a9, 0
4037c8a1:	000046        	j	4037c8a6 <s_cache_hal_init_ctx+0x2e>
        enabled = true;
4037c8a4:	190c      	movi.n	a9, 1
    ctx.l1.i_autoload_en = cache_ll_is_cache_autoload_enabled(1, CACHE_TYPE_INSTRUCTION, CACHE_LL_ID_ALL);
4037c8a6:	e16681        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc94abc <ctx>)
4037c8a9:	004892        	s8i	a9, a8, 0
    if (REG_GET_BIT(EXTMEM_DCACHE_AUTOLOAD_CTRL_REG, EXTMEM_DCACHE_AUTOLOAD_ENA)) {
4037c8ac:	e16481        	l32r	a8, 40374e3c <_iram_text_start+0xa38> (600c404c <SYSTEM+0x404c>)
4037c8af:	0020c0        	memw
4037c8b2:	0888      	l32i.n	a8, a8, 0
4037c8b4:	04e827        	bbsi	a8, 2, 4037c8bc <s_cache_hal_init_ctx+0x44>
    bool enabled = false;
4037c8b7:	090c      	movi.n	a9, 0
4037c8b9:	000046        	j	4037c8be <s_cache_hal_init_ctx+0x46>
        enabled = true;
4037c8bc:	190c      	movi.n	a9, 1
    ctx.l2.d_autoload_en = cache_ll_is_cache_autoload_enabled(2, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
4037c8be:	e16081        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc94abc <ctx>)
4037c8c1:	034892        	s8i	a9, a8, 3
    if (REG_GET_BIT(EXTMEM_ICACHE_AUTOLOAD_CTRL_REG, EXTMEM_ICACHE_AUTOLOAD_ENA)) {
4037c8c4:	e16081        	l32r	a8, 40374e44 <_iram_text_start+0xa40> (600c40a0 <SYSTEM+0x40a0>)
4037c8c7:	0020c0        	memw
4037c8ca:	0888      	l32i.n	a8, a8, 0
4037c8cc:	04e827        	bbsi	a8, 2, 4037c8d4 <s_cache_hal_init_ctx+0x5c>
    bool enabled = false;
4037c8cf:	090c      	movi.n	a9, 0
4037c8d1:	000046        	j	4037c8d6 <s_cache_hal_init_ctx+0x5e>
        enabled = true;
4037c8d4:	190c      	movi.n	a9, 1
    ctx.l2.i_autoload_en = cache_ll_is_cache_autoload_enabled(2, CACHE_TYPE_INSTRUCTION, CACHE_LL_ID_ALL);
4037c8d6:	e15a81        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc94abc <ctx>)
4037c8d9:	024892        	s8i	a9, a8, 2
}
4037c8dc:	f01d      	retw.n
	...

4037c8e0 <cache_hal_init>:

void cache_hal_init(void)
{
4037c8e0:	004136        	entry	a1, 32
    s_cache_hal_init_ctx();
4037c8e3:	fff965        	call8	4037c878 <s_cache_hal_init_ctx>

    if (CACHE_LL_LEVEL_EXT_MEM == 1) {
        cache_ll_enable_cache(1, CACHE_TYPE_ALL, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037c8e6:	e15681        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc94abc <ctx>)
4037c8e9:	000892        	l8ui	a9, a8, 0
4037c8ec:	010872        	l8ui	a7, a8, 1
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c8ef:	698c      	beqz.n	a9, 4037c8f9 <cache_hal_init+0x19>
4037c8f1:	4a0c      	movi.n	a10, 4
4037c8f3:	000106        	j	4037c8fb <cache_hal_init+0x1b>
4037c8f6:	000000        	ill
4037c8f9:	0a0c      	movi.n	a10, 0
4037c8fb:	e15381        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (40001878 <Cache_Enable_ICache>)
4037c8fe:	0008e0        	callx8	a8
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c901:	378c      	beqz.n	a7, 4037c908 <cache_hal_init+0x28>
4037c903:	4a0c      	movi.n	a10, 4
4037c905:	000046        	j	4037c90a <cache_hal_init+0x2a>
4037c908:	0a0c      	movi.n	a10, 0
4037c90a:	e15081        	l32r	a8, 40374e4c <_iram_text_start+0xa48> (40001890 <Cache_Enable_DCache>)
4037c90d:	0008e0        	callx8	a8
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c910:	deca91        	l32r	a9, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
4037c913:	0020c0        	memw
4037c916:	0988      	l32i.n	a8, a9, 0
4037c918:	0020c0        	memw
4037c91b:	0989      	s32i.n	a8, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c91d:	dec781        	l32r	a8, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
4037c920:	0020c0        	memw
4037c923:	08a8      	l32i.n	a10, a8, 0
4037c925:	db7c      	movi.n	a11, -3
4037c927:	10aab0        	and	a10, a10, a11
4037c92a:	0020c0        	memw
4037c92d:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c92f:	0020c0        	memw
4037c932:	09a8      	l32i.n	a10, a9, 0
4037c934:	ec7c      	movi.n	a12, -2
4037c936:	10aac0        	and	a10, a10, a12
4037c939:	0020c0        	memw
4037c93c:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c93e:	0020c0        	memw
4037c941:	08a8      	l32i.n	a10, a8, 0
4037c943:	0020c0        	memw
4037c946:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c948:	0020c0        	memw
4037c94b:	09a8      	l32i.n	a10, a9, 0
4037c94d:	0020c0        	memw
4037c950:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c952:	0020c0        	memw
4037c955:	08a8      	l32i.n	a10, a8, 0
4037c957:	10aac0        	and	a10, a10, a12
4037c95a:	0020c0        	memw
4037c95d:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c95f:	0020c0        	memw
4037c962:	09a8      	l32i.n	a10, a9, 0
4037c964:	10aab0        	and	a10, a10, a11
4037c967:	0020c0        	memw
4037c96a:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c96c:	0020c0        	memw
4037c96f:	0898      	l32i.n	a9, a8, 0
4037c971:	0020c0        	memw
4037c974:	0899      	s32i.n	a9, a8, 0
    ctx.l1.i_cache_enabled = 1;
    ctx.l1.d_cache_enabled = 1;
    ctx.l2.i_cache_enabled = 1;
    ctx.l2.d_cache_enabled = 1;
#endif
}
4037c976:	f01d      	retw.n

4037c978 <cache_hal_disable>:
    return enabled;
}
#endif  //#if CACHE_LL_ENABLE_DISABLE_STATE_SW

void cache_hal_disable(uint32_t cache_level, cache_type_t type)
{
4037c978:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c97b:	0e1226        	beqi	a2, 1, 4037c98d <cache_hal_disable+0x15>
4037c97e:	e134d1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc938d0 <__FUNCTION__$0+0x18>)
4037c981:	e134c1        	l32r	a12, 40374e54 <_iram_text_start+0xa50> (3fc942a0 <__func__$9>)
4037c984:	aca0b2        	movi	a11, 172
4037c987:	e134a1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc93904 <__FUNCTION__$0+0x4c>)
4037c98a:	034165        	call8	4037fda0 <__assert_func>
    switch (type)
4037c98d:	00b316        	beqz	a3, 4037c99c <cache_hal_disable+0x24>
4037c990:	111366        	bnei	a3, 1, 4037c9a5 <cache_hal_disable+0x2d>
    Cache_Disable_ICache();
4037c993:	def981        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
4037c996:	0008e0        	callx8	a8
}
4037c999:	000506        	j	4037c9b1 <cache_hal_disable+0x39>
    Cache_Disable_DCache();
4037c99c:	def881        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
4037c99f:	0008e0        	callx8	a8
}
4037c9a2:	0002c6        	j	4037c9b1 <cache_hal_disable+0x39>
    Cache_Disable_ICache();
4037c9a5:	def481        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
4037c9a8:	0008e0        	callx8	a8
    Cache_Disable_DCache();
4037c9ab:	def481        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
4037c9ae:	0008e0        	callx8	a8
    cache_ll_disable_cache(cache_level, type, CACHE_LL_ID_ALL);

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, false);
#endif
}
4037c9b1:	f01d      	retw.n
	...

4037c9b4 <cache_hal_enable>:

void cache_hal_enable(uint32_t cache_level, cache_type_t type)
{
4037c9b4:	004136        	entry	a1, 32
4037c9b7:	20a330        	or	a10, a3, a3
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c9ba:	0e1226        	beqi	a2, 1, 4037c9cc <cache_hal_enable+0x18>
4037c9bd:	e124d1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc938d0 <__FUNCTION__$0+0x18>)
4037c9c0:	e127c1        	l32r	a12, 40374e5c <_iram_text_start+0xa58> (3fc9428c <__func__$8>)
4037c9c3:	b7a0b2        	movi	a11, 183
4037c9c6:	e124a1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc93904 <__FUNCTION__$0+0x4c>)
4037c9c9:	033d65        	call8	4037fda0 <__assert_func>

    if (cache_level == 1) {
        cache_ll_enable_cache(1, type, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037c9cc:	e11d81        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc94abc <ctx>)
4037c9cf:	000892        	l8ui	a9, a8, 0
4037c9d2:	010832        	l8ui	a3, a8, 1
    switch (type)
4037c9d5:	017a16        	beqz	a10, 4037c9f0 <cache_hal_enable+0x3c>
4037c9d8:	211a66        	bnei	a10, 1, 4037c9fd <cache_hal_enable+0x49>
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c9db:	005916        	beqz	a9, 4037c9e4 <cache_hal_enable+0x30>
4037c9de:	4a0c      	movi.n	a10, 4
4037c9e0:	000086        	j	4037c9e6 <cache_hal_enable+0x32>
4037c9e3:	0a0c00        	add.s	f0, f12, f0
4037c9e6:	e11881        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (40001878 <Cache_Enable_ICache>)
4037c9e9:	0008e0        	callx8	a8
}
4037c9ec:	000b06        	j	4037ca1c <cache_hal_enable+0x68>
4037c9ef:	038c00        	lsi	f0, a12, 12
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c9f2:	4a0c      	movi.n	a10, 4
4037c9f4:	e11681        	l32r	a8, 40374e4c <_iram_text_start+0xa48> (40001890 <Cache_Enable_DCache>)
4037c9f7:	0008e0        	callx8	a8
}
4037c9fa:	000786        	j	4037ca1c <cache_hal_enable+0x68>
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c9fd:	398c      	beqz.n	a9, 4037ca04 <cache_hal_enable+0x50>
4037c9ff:	4a0c      	movi.n	a10, 4
4037ca01:	000046        	j	4037ca06 <cache_hal_enable+0x52>
4037ca04:	0a0c      	movi.n	a10, 0
4037ca06:	e11081        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (40001878 <Cache_Enable_ICache>)
4037ca09:	0008e0        	callx8	a8
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037ca0c:	438c      	beqz.n	a3, 4037ca14 <cache_hal_enable+0x60>
4037ca0e:	4a0c      	movi.n	a10, 4
4037ca10:	000086        	j	4037ca16 <cache_hal_enable+0x62>
4037ca13:	0a0c00        	add.s	f0, f12, f0
4037ca16:	e10d81        	l32r	a8, 40374e4c <_iram_text_start+0xa48> (40001890 <Cache_Enable_DCache>)
4037ca19:	0008e0        	callx8	a8
    }

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, true);
#endif
}
4037ca1c:	f01d      	retw.n
	...

4037ca20 <cache_hal_suspend>:

void cache_hal_suspend(uint32_t cache_level, cache_type_t type)
{
4037ca20:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037ca23:	0e1226        	beqi	a2, 1, 4037ca35 <cache_hal_suspend+0x15>
4037ca26:	e10ad1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc938d0 <__FUNCTION__$0+0x18>)
4037ca29:	e10dc1        	l32r	a12, 40374e60 <_iram_text_start+0xa5c> (3fc94278 <__func__$7>)
4037ca2c:	c6a0b2        	movi	a11, 198
4037ca2f:	e10aa1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc93904 <__FUNCTION__$0+0x4c>)
4037ca32:	0336e5        	call8	4037fda0 <__assert_func>
    switch (type)
4037ca35:	00b316        	beqz	a3, 4037ca44 <cache_hal_suspend+0x24>
4037ca38:	111366        	bnei	a3, 1, 4037ca4d <cache_hal_suspend+0x2d>
    Cache_Suspend_ICache();
4037ca3b:	fcb4a5        	call8	40379584 <Cache_Suspend_ICache>
}
4037ca3e:	000446        	j	4037ca53 <cache_hal_suspend+0x33>
4037ca41:	000000        	ill
    Cache_Suspend_DCache();
4037ca44:	fcb5a5        	call8	403795a0 <Cache_Suspend_DCache>
}
4037ca47:	000206        	j	4037ca53 <cache_hal_suspend+0x33>
4037ca4a:	000000        	ill
    Cache_Suspend_ICache();
4037ca4d:	fcb365        	call8	40379584 <Cache_Suspend_ICache>
    Cache_Suspend_DCache();
4037ca50:	fcb4e5        	call8	403795a0 <Cache_Suspend_DCache>
    cache_ll_suspend_cache(cache_level, type, CACHE_LL_ID_ALL);

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, false);
#endif
}
4037ca53:	f01d      	retw.n
4037ca55:	000000        	ill

4037ca58 <cache_hal_resume>:

void cache_hal_resume(uint32_t cache_level, cache_type_t type)
{
4037ca58:	004136        	entry	a1, 32
4037ca5b:	20a330        	or	a10, a3, a3
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037ca5e:	0e1226        	beqi	a2, 1, 4037ca70 <cache_hal_resume+0x18>
4037ca61:	e0fbd1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc938d0 <__FUNCTION__$0+0x18>)
4037ca64:	e100c1        	l32r	a12, 40374e64 <_iram_text_start+0xa60> (3fc94264 <__func__$6>)
4037ca67:	d1a0b2        	movi	a11, 209
4037ca6a:	e0fba1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc93904 <__FUNCTION__$0+0x4c>)
4037ca6d:	033325        	call8	4037fda0 <__assert_func>

    if (cache_level == 1) {
        cache_ll_resume_cache(1, type, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037ca70:	e0f481        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc94abc <ctx>)
4037ca73:	000892        	l8ui	a9, a8, 0
4037ca76:	010832        	l8ui	a3, a8, 1
    switch (type)
4037ca79:	016a16        	beqz	a10, 4037ca93 <cache_hal_resume+0x3b>
4037ca7c:	211a66        	bnei	a10, 1, 4037caa1 <cache_hal_resume+0x49>
    Cache_Resume_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037ca7f:	005916        	beqz	a9, 4037ca88 <cache_hal_resume+0x30>
4037ca82:	4a0c      	movi.n	a10, 4
4037ca84:	000086        	j	4037ca8a <cache_hal_resume+0x32>
4037ca87:	0a0c00        	add.s	f0, f12, f0
4037ca8a:	e0f781        	l32r	a8, 40374e68 <_iram_text_start+0xa64> (400018a8 <Cache_Resume_ICache>)
4037ca8d:	0008e0        	callx8	a8
}
4037ca90:	000b06        	j	4037cac0 <cache_hal_resume+0x68>
    Cache_Resume_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037ca93:	001316        	beqz	a3, 4037ca98 <cache_hal_resume+0x40>
4037ca96:	4a0c      	movi.n	a10, 4
4037ca98:	de8181        	l32r	a8, 4037449c <_iram_text_start+0x98> (400018c0 <Cache_Resume_DCache>)
4037ca9b:	0008e0        	callx8	a8
}
4037ca9e:	000786        	j	4037cac0 <cache_hal_resume+0x68>
    Cache_Resume_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037caa1:	398c      	beqz.n	a9, 4037caa8 <cache_hal_resume+0x50>
4037caa3:	4a0c      	movi.n	a10, 4
4037caa5:	000046        	j	4037caaa <cache_hal_resume+0x52>
4037caa8:	0a0c      	movi.n	a10, 0
4037caaa:	e0ef81        	l32r	a8, 40374e68 <_iram_text_start+0xa64> (400018a8 <Cache_Resume_ICache>)
4037caad:	0008e0        	callx8	a8
    Cache_Resume_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037cab0:	438c      	beqz.n	a3, 4037cab8 <cache_hal_resume+0x60>
4037cab2:	4a0c      	movi.n	a10, 4
4037cab4:	000086        	j	4037caba <cache_hal_resume+0x62>
4037cab7:	0a0c00        	add.s	f0, f12, f0
4037caba:	de7881        	l32r	a8, 4037449c <_iram_text_start+0x98> (400018c0 <Cache_Resume_DCache>)
4037cabd:	0008e0        	callx8	a8
    }

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, true);
#endif
}
4037cac0:	f01d      	retw.n
	...

4037cac4 <cache_hal_is_cache_enabled>:

bool cache_hal_is_cache_enabled(uint32_t cache_level, cache_type_t type)
{
4037cac4:	004136        	entry	a1, 32
    switch (type)
4037cac7:	538c      	beqz.n	a3, 4037cad0 <cache_hal_is_cache_enabled+0xc>
4037cac9:	131326        	beqi	a3, 1, 4037cae0 <cache_hal_is_cache_enabled+0x1c>
4037cacc:	000786        	j	4037caee <cache_hal_is_cache_enabled+0x2a>
4037cacf:	e78100        	lsi	f0, a1, 0x39c
    return REG_GET_BIT(EXTMEM_DCACHE_CTRL_REG, EXTMEM_DCACHE_ENABLE);
4037cad2:	20c0e0        	or	a12, a0, a14
4037cad5:	082800        	lsx	f2, a8, a0
4037cad8:	042020        	extui	a2, a2, 0, 1
        break;
4037cadb:	000c46        	j	4037cb10 <cache_hal_is_cache_enabled+0x4c>
4037cade:	810000        	src	a0, a0, a0
    return REG_GET_BIT(EXTMEM_ICACHE_CTRL_REG, EXTMEM_ICACHE_ENABLE);
4037cae1:	c0e0e4        	lsi	f14, a0, 0x300
4037cae4:	280020        	lsi	f2, a0, 160
4037cae7:	2008      	l32i.n	a0, a0, 8
4037cae9:	460420        	lsi	f2, a4, 0x118
        break;
4037caec:	0008      	l32i.n	a0, a0, 0
    return REG_GET_BIT(EXTMEM_DCACHE_CTRL_REG, EXTMEM_DCACHE_ENABLE);
4037caee:	e0df81        	l32r	a8, 40374e6c <_iram_text_start+0xa68> (600c4000 <SYSTEM+0x4000>)
4037caf1:	0020c0        	memw
4037caf4:	0888      	l32i.n	a8, a8, 0
        enabled = cache_ll_l1_is_dcache_enabled(0) && cache_ll_l1_is_icache_enabled(0);
4037caf6:	0f6807        	bbci	a8, 0, 4037cb09 <cache_hal_is_cache_enabled+0x45>
    return REG_GET_BIT(EXTMEM_ICACHE_CTRL_REG, EXTMEM_ICACHE_ENABLE);
4037caf9:	e0dd81        	l32r	a8, 40374e70 <_iram_text_start+0xa6c> (600c4060 <SYSTEM+0x4060>)
4037cafc:	0020c0        	memw
4037caff:	0888      	l32i.n	a8, a8, 0
        enabled = cache_ll_l1_is_dcache_enabled(0) && cache_ll_l1_is_icache_enabled(0);
4037cb01:	096807        	bbci	a8, 0, 4037cb0e <cache_hal_is_cache_enabled+0x4a>
4037cb04:	120c      	movi.n	a2, 1
4037cb06:	000186        	j	4037cb10 <cache_hal_is_cache_enabled+0x4c>
4037cb09:	020c      	movi.n	a2, 0
4037cb0b:	000046        	j	4037cb10 <cache_hal_is_cache_enabled+0x4c>
4037cb0e:	020c      	movi.n	a2, 0
    enabled = s_get_cache_state(cache_level, type);
#else
    enabled = cache_ll_is_cache_enabled(type);
#endif //CACHE_LL_ENABLE_DISABLE_STATE_SW
    return enabled;
}
4037cb10:	f01d      	retw.n
	...

4037cb14 <cache_hal_vaddr_to_cache_level_id>:

bool cache_hal_vaddr_to_cache_level_id(uint32_t vaddr_start, uint32_t len, uint32_t *out_level, uint32_t *out_id)
{
4037cb14:	004136        	entry	a1, 32
    if (!out_level || !out_id) {
4037cb17:	40f480        	nsau	a8, a4
4037cb1a:	418580        	srli	a8, a8, 5
4037cb1d:	40f590        	nsau	a9, a5
4037cb20:	419590        	srli	a9, a9, 5
4037cb23:	208890        	or	a8, a8, a9
4037cb26:	054856        	bnez	a8, 4037cb7e <cache_hal_vaddr_to_cache_level_id+0x6a>
 */
__attribute__((always_inline))
static inline bool cache_ll_vaddr_to_cache_level_id(uint32_t vaddr_start, uint32_t len, uint32_t *out_level, uint32_t *out_id)
{
    bool valid = false;
    uint32_t vaddr_end = vaddr_start + len - 1;
4037cb29:	323a      	add.n	a3, a2, a3

    valid |= (SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_end));
4037cb2b:	e02381        	l32r	a8, 40374bb8 <_iram_text_start+0x7b4> (be000000 <_rtc_reserved_end+0x5df00000>)
4037cb2e:	828a      	add.n	a8, a2, a8
4037cb30:	deb391        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cb33:	0c3987        	bltu	a9, a8, 4037cb43 <cache_hal_vaddr_to_cache_level_id+0x2f>
4037cb36:	e0cf81        	l32r	a8, 40374e74 <_iram_text_start+0xa70> (bdffffff <_rtc_reserved_end+0x5defffff>)
4037cb39:	838a      	add.n	a8, a3, a8
4037cb3b:	09b987        	bgeu	a9, a8, 4037cb48 <cache_hal_vaddr_to_cache_level_id+0x34>
4037cb3e:	080c      	movi.n	a8, 0
4037cb40:	000186        	j	4037cb4a <cache_hal_vaddr_to_cache_level_id+0x36>
4037cb43:	080c      	movi.n	a8, 0
4037cb45:	000046        	j	4037cb4a <cache_hal_vaddr_to_cache_level_id+0x36>
4037cb48:	180c      	movi.n	a8, 1
    valid |= (SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_end));
4037cb4a:	e0cb91        	l32r	a9, 40374e78 <_iram_text_start+0xa74> (c4000000 <_rtc_reserved_end+0x63f00000>)
4037cb4d:	229a      	add.n	a2, a2, a9
4037cb4f:	deab91        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cb52:	0f3927        	bltu	a9, a2, 4037cb65 <cache_hal_vaddr_to_cache_level_id+0x51>
4037cb55:	e0c991        	l32r	a9, 40374e7c <_iram_text_start+0xa78> (c3ffffff <_rtc_reserved_end+0x63efffff>)
4037cb58:	339a      	add.n	a3, a3, a9
4037cb5a:	dea891        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cb5d:	09b937        	bgeu	a9, a3, 4037cb6a <cache_hal_vaddr_to_cache_level_id+0x56>
4037cb60:	090c      	movi.n	a9, 0
4037cb62:	000186        	j	4037cb6c <cache_hal_vaddr_to_cache_level_id+0x58>
4037cb65:	090c      	movi.n	a9, 0
4037cb67:	000046        	j	4037cb6c <cache_hal_vaddr_to_cache_level_id+0x58>
4037cb6a:	190c      	movi.n	a9, 1
4037cb6c:	208890        	or	a8, a8, a9
4037cb6f:	082d      	mov.n	a2, a8

    if (valid) {
4037cb71:	b88c      	beqz.n	a8, 4037cb80 <cache_hal_vaddr_to_cache_level_id+0x6c>
        *out_level = 1;
4037cb73:	180c      	movi.n	a8, 1
4037cb75:	0489      	s32i.n	a8, a4, 0
        *out_id = 0;
4037cb77:	080c      	movi.n	a8, 0
4037cb79:	0589      	s32i.n	a8, a5, 0
4037cb7b:	000046        	j	4037cb80 <cache_hal_vaddr_to_cache_level_id+0x6c>
        return false;
4037cb7e:	020c      	movi.n	a2, 0
    }
    return cache_ll_vaddr_to_cache_level_id(vaddr_start, len, out_level, out_id);
}
4037cb80:	f01d      	retw.n
	...

4037cb84 <cache_hal_invalidate_addr>:

bool cache_hal_invalidate_addr(uint32_t vaddr, uint32_t size)
{
4037cb84:	006136        	entry	a1, 48
4037cb87:	027d      	mov.n	a7, a2
    bool valid = false;
    uint32_t cache_level = 0;
4037cb89:	080c      	movi.n	a8, 0
4037cb8b:	0189      	s32i.n	a8, a1, 0
    uint32_t cache_id = 0;
4037cb8d:	1189      	s32i.n	a8, a1, 4

    valid = cache_hal_vaddr_to_cache_level_id(vaddr, size, &cache_level, &cache_id);
4037cb8f:	d14b      	addi.n	a13, a1, 4
4037cb91:	01cd      	mov.n	a12, a1
4037cb93:	03bd      	mov.n	a11, a3
4037cb95:	02ad      	mov.n	a10, a2
4037cb97:	fff7e5        	call8	4037cb14 <cache_hal_vaddr_to_cache_level_id>
4037cb9a:	0a2d      	mov.n	a2, a10
    if (valid) {
4037cb9c:	8a8c      	beqz.n	a10, 4037cba8 <cache_hal_invalidate_addr+0x24>
    Cache_Invalidate_Addr(vaddr, size);
4037cb9e:	03bd      	mov.n	a11, a3
4037cba0:	07ad      	mov.n	a10, a7
4037cba2:	e0b781        	l32r	a8, 40374e80 <_iram_text_start+0xa7c> (400016b0 <Cache_Invalidate_Addr>)
4037cba5:	0008e0        	callx8	a8
        cache_ll_invalidate_addr(cache_level, CACHE_TYPE_ALL, cache_id, vaddr, size);
    }

    return valid;
}
4037cba8:	f01d      	retw.n
	...

4037cbac <cache_hal_freeze>:
}
#endif  //#if SOC_CACHE_WRITEBACK_SUPPORTED

#if SOC_CACHE_FREEZE_SUPPORTED
void cache_hal_freeze(uint32_t cache_level, cache_type_t type)
{
4037cbac:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037cbaf:	0e1226        	beqi	a2, 1, 4037cbc1 <cache_hal_freeze+0x15>
4037cbb2:	e0a7d1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc938d0 <__FUNCTION__$0+0x18>)
4037cbb5:	e0b3c1        	l32r	a12, 40374e84 <_iram_text_start+0xa80> (3fc94250 <__func__$3>)
4037cbb8:	12a1b2        	movi	a11, 0x112
4037cbbb:	e0a7a1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc93904 <__FUNCTION__$0+0x4c>)
4037cbbe:	031e25        	call8	4037fda0 <__assert_func>
    switch (type)
4037cbc1:	00b316        	beqz	a3, 4037cbd0 <cache_hal_freeze+0x24>
4037cbc4:	101366        	bnei	a3, 1, 4037cbd8 <cache_hal_freeze+0x2c>
    Cache_Freeze_ICache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cbc7:	00a0a2        	movi	a10, 0
4037cbca:	fc9fa5        	call8	403795c4 <Cache_Freeze_ICache_Enable>
}
4037cbcd:	0004c6        	j	4037cbe4 <cache_hal_freeze+0x38>
    Cache_Freeze_DCache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cbd0:	0a0c      	movi.n	a10, 0
4037cbd2:	fca0e5        	call8	403795e0 <Cache_Freeze_DCache_Enable>
}
4037cbd5:	0002c6        	j	4037cbe4 <cache_hal_freeze+0x38>
    Cache_Freeze_ICache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cbd8:	00a0a2        	movi	a10, 0
4037cbdb:	fc9ea5        	call8	403795c4 <Cache_Freeze_ICache_Enable>
    Cache_Freeze_DCache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cbde:	00a0a2        	movi	a10, 0
4037cbe1:	fc9fe5        	call8	403795e0 <Cache_Freeze_DCache_Enable>

    cache_ll_freeze_cache(cache_level, type, CACHE_LL_ID_ALL);
}
4037cbe4:	f01d      	retw.n
	...

4037cbe8 <cache_hal_unfreeze>:

void cache_hal_unfreeze(uint32_t cache_level, cache_type_t type)
{
4037cbe8:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037cbeb:	0e1226        	beqi	a2, 1, 4037cbfd <cache_hal_unfreeze+0x15>
4037cbee:	e098d1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc938d0 <__FUNCTION__$0+0x18>)
4037cbf1:	e0a5c1        	l32r	a12, 40374e88 <_iram_text_start+0xa84> (3fc9423c <__func__$2>)
4037cbf4:	19a1b2        	movi	a11, 0x119
4037cbf7:	e098a1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc93904 <__FUNCTION__$0+0x4c>)
4037cbfa:	031a65        	call8	4037fda0 <__assert_func>
    switch (type)
4037cbfd:	d38c      	beqz.n	a3, 4037cc0e <cache_hal_unfreeze+0x26>
4037cbff:	151366        	bnei	a3, 1, 4037cc18 <cache_hal_unfreeze+0x30>
    Cache_Freeze_ICache_Disable();
4037cc02:	e0a281        	l32r	a8, 40374e8c <_iram_text_start+0xa88> (400018f0 <Cache_Freeze_ICache_Disable>)
4037cc05:	0008e0        	callx8	a8
}
4037cc08:	000606        	j	4037cc24 <cache_hal_unfreeze+0x3c>
4037cc0b:	000000        	ill
    Cache_Freeze_DCache_Disable();
4037cc0e:	e0a081        	l32r	a8, 40374e90 <_iram_text_start+0xa8c> (40001908 <Cache_Freeze_DCache_Disable>)
4037cc11:	0008e0        	callx8	a8
}
4037cc14:	000306        	j	4037cc24 <cache_hal_unfreeze+0x3c>
4037cc17:	9d8100        	lsi	f0, a1, 0x274
    Cache_Freeze_ICache_Disable();
4037cc1a:	08e0e0        	lsx	f14, a0, a14
4037cc1d:	9c8100        	lsi	f0, a1, 0x270
    Cache_Freeze_DCache_Disable();
4037cc20:	08e0e0        	lsx	f14, a0, a14
4037cc23:	f01d00        	subx8	a1, a13, a0
	...

4037cc28 <cache_hal_get_cache_line_size>:
    cache_ll_unfreeze_cache(cache_level, type, CACHE_LL_ID_ALL);
}
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

uint32_t cache_hal_get_cache_line_size(uint32_t cache_level, cache_type_t type)
{
4037cc28:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level <= CACHE_LL_LEVEL_NUMS);
4037cc2b:	01a082        	movi	a8, 1
4037cc2e:	0eb827        	bgeu	a8, a2, 4037cc40 <cache_hal_get_cache_line_size+0x18>
4037cc31:	e098d1        	l32r	a13, 40374e94 <_iram_text_start+0xa90> (3fc93924 <__FUNCTION__$0+0x6c>)
4037cc34:	e099c1        	l32r	a12, 40374e98 <_iram_text_start+0xa94> (3fc9421c <__func__$1>)
4037cc37:	21a1b2        	movi	a11, 0x121
4037cc3a:	e087a1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc93904 <__FUNCTION__$0+0x4c>)
4037cc3d:	031625        	call8	4037fda0 <__assert_func>
    uint32_t line_size = 0;

#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE
    line_size = cache_ll_get_line_size(cache_level, type, CACHE_LL_ID_ALL);
#else
    if (cache_level == CACHE_LL_LEVEL_EXT_MEM) {
4037cc40:	2b1266        	bnei	a2, 1, 4037cc6f <cache_hal_get_cache_line_size+0x47>
    switch (type)
4037cc43:	00e316        	beqz	a3, 4037cc55 <cache_hal_get_cache_line_size+0x2d>
4037cc46:	161366        	bnei	a3, 1, 4037cc60 <cache_hal_get_cache_line_size+0x38>
    size = Cache_Get_ICache_Line_Size();
4037cc49:	e09781        	l32r	a8, 40374ea8 <_iram_text_start+0xaa4> (400015fc <Cache_Get_ICache_Line_Size>)
4037cc4c:	0008e0        	callx8	a8
4037cc4f:	202aa0        	or	a2, a10, a10
        break;
4037cc52:	0006c6        	j	4037cc71 <cache_hal_get_cache_line_size+0x49>
    size = Cache_Get_DCache_Line_Size();
4037cc55:	e09581        	l32r	a8, 40374eac <_iram_text_start+0xaa8> (40001608 <Cache_Get_DCache_Line_Size>)
4037cc58:	0008e0        	callx8	a8
4037cc5b:	0a2d      	mov.n	a2, a10
        break;
4037cc5d:	000406        	j	4037cc71 <cache_hal_get_cache_line_size+0x49>
        HAL_ASSERT(false);
4037cc60:	e08fd1        	l32r	a13, 40374e9c <_iram_text_start+0xa98> (3fc9394c <__FUNCTION__$0+0x94>)
4037cc63:	e08fc1        	l32r	a12, 40374ea0 <_iram_text_start+0xa9c> (3fc94204 <__func__$0>)
4037cc66:	1ca2b2        	movi	a11, 0x21c
4037cc69:	e08ea1        	l32r	a10, 40374ea4 <_iram_text_start+0xaa0> (3fc93954 <__FUNCTION__$0+0x9c>)
4037cc6c:	031325        	call8	4037fda0 <__assert_func>
    uint32_t line_size = 0;
4037cc6f:	020c      	movi.n	a2, 0
        line_size = cache_ll_get_line_size(cache_level, type, CACHE_LL_ID_ALL);
    }
#endif

    return line_size;
}
4037cc71:	f01d      	retw.n
	...

4037cc74 <mmu_ll_check_entry_valid>:
 * @param entry_id MMU entry ID
 *
 * @return         True for MMU entry is valid; False for invalid
 */
static inline bool mmu_ll_check_entry_valid(uint32_t mmu_id, uint32_t entry_id)
{
4037cc74:	004136        	entry	a1, 32
    (void)mmu_id;
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cc77:	ffa182        	movi	a8, 0x1ff
4037cc7a:	0eb837        	bgeu	a8, a3, 4037cc8c <mmu_ll_check_entry_valid+0x18>
4037cc7d:	e08cd1        	l32r	a13, 40374eb0 <_iram_text_start+0xaac> (3fc93f54 <__FUNCTION__$0+0x69c>)
4037cc80:	e08dc1        	l32r	a12, 40374eb4 <_iram_text_start+0xab0> (3fc94304 <__func__$3>)
4037cc83:	f0a0b2        	movi	a11, 240
4037cc86:	e08ca1        	l32r	a10, 40374eb8 <_iram_text_start+0xab4> (3fc93f74 <__FUNCTION__$0+0x6bc>)
4037cc89:	031165        	call8	4037fda0 <__assert_func>

    return (*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) & SOC_MMU_INVALID) ? false : true;
4037cc8c:	e08c81        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037cc8f:	803380        	add	a3, a3, a8
4037cc92:	1133e0        	slli	a3, a3, 2
4037cc95:	002322        	l32i	a2, a3, 0
4037cc98:	042e20        	extui	a2, a2, 14, 1
4037cc9b:	112220        	slli	a2, a2, 14
}
4037cc9e:	40f220        	nsau	a2, a2
4037cca1:	412520        	srli	a2, a2, 5
4037cca4:	000090        	retw
	...

4037cca8 <mmu_ll_get_entry_target>:
 * @param entry_id MMU entry ID
 *
 * @return         Target, see `mmu_target_t`
 */
static inline mmu_target_t mmu_ll_get_entry_target(uint32_t mmu_id, uint32_t entry_id)
{
4037cca8:	004136        	entry	a1, 32
    (void)mmu_id;
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037ccab:	ffa182        	movi	a8, 0x1ff
4037ccae:	0eb837        	bgeu	a8, a3, 4037ccc0 <mmu_ll_get_entry_target+0x18>
4037ccb1:	e07fd1        	l32r	a13, 40374eb0 <_iram_text_start+0xaac> (3fc93f54 <__FUNCTION__$0+0x69c>)
4037ccb4:	e083c1        	l32r	a12, 40374ec0 <_iram_text_start+0xabc> (3fc942ec <__func__$2>)
4037ccb7:	00a1b2        	movi	a11, 0x100
4037ccba:	e07fa1        	l32r	a10, 40374eb8 <_iram_text_start+0xab4> (3fc93f74 <__FUNCTION__$0+0x6bc>)
4037ccbd:	030e25        	call8	4037fda0 <__assert_func>

    bool target_code = (*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4)) & SOC_MMU_TYPE;
4037ccc0:	e07f81        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037ccc3:	803380        	add	a3, a3, a8
4037ccc6:	1133e0        	slli	a3, a3, 2
4037ccc9:	002382        	l32i	a8, a3, 0
    return (target_code == SOC_MMU_ACCESS_FLASH) ? MMU_TARGET_FLASH0 : MMU_TARGET_PSRAM0;
4037cccc:	05e8f7        	bbsi	a8, 15, 4037ccd5 <mmu_ll_get_entry_target+0x2d>
4037cccf:	01a022        	movi	a2, 1
4037ccd2:	000046        	j	4037ccd7 <mmu_ll_get_entry_target+0x2f>
4037ccd5:	220c      	movi.n	a2, 2
}
4037ccd7:	f01d      	retw.n
4037ccd9:	000000        	ill

4037ccdc <mmu_ll_find_entry_id_based_on_map_value>:
 * @param target   physical memory target, see `mmu_target_t`
 *
 * @return         MMU entry ID, -1 for invalid
 */
static inline int mmu_ll_find_entry_id_based_on_map_value(uint32_t mmu_id, uint32_t mmu_val, mmu_target_t target)
{
4037ccdc:	004136        	entry	a1, 32
4037ccdf:	027d      	mov.n	a7, a2
    (void)mmu_id;
    for (int i = 0; i < SOC_MMU_ENTRY_NUM; i++) {
4037cce1:	020c      	movi.n	a2, 0
4037cce3:	0009c6        	j	4037cd0e <mmu_ll_find_entry_id_based_on_map_value+0x32>
        if (mmu_ll_check_entry_valid(mmu_id, i)) {
4037cce6:	20b220        	or	a11, a2, a2
4037cce9:	20a770        	or	a10, a7, a7
4037ccec:	fff865        	call8	4037cc74 <mmu_ll_check_entry_valid>
4037ccef:	019a16        	beqz	a10, 4037cd0c <mmu_ll_find_entry_id_based_on_map_value+0x30>
            if (mmu_ll_get_entry_target(mmu_id, i) == target) {
4037ccf2:	02bd      	mov.n	a11, a2
4037ccf4:	07ad      	mov.n	a10, a7
4037ccf6:	fffb25        	call8	4037cca8 <mmu_ll_get_entry_target>
4037ccf9:	0f9a47        	bne	a10, a4, 4037cd0c <mmu_ll_find_entry_id_based_on_map_value+0x30>
                if (((*(uint32_t *)(DR_REG_MMU_TABLE + i * 4)) & SOC_MMU_VALID_VAL_MASK) == mmu_val) {
4037ccfc:	e07081        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037ccff:	828a      	add.n	a8, a2, a8
4037cd01:	1188e0        	slli	a8, a8, 2
4037cd04:	0888      	l32i.n	a8, a8, 0
4037cd06:	d48080        	extui	a8, a8, 0, 14
4037cd09:	091837        	beq	a8, a3, 4037cd16 <mmu_ll_find_entry_id_based_on_map_value+0x3a>
    for (int i = 0; i < SOC_MMU_ENTRY_NUM; i++) {
4037cd0c:	221b      	addi.n	a2, a2, 1
4037cd0e:	ffa182        	movi	a8, 0x1ff
4037cd11:	d1a827        	bge	a8, a2, 4037cce6 <mmu_ll_find_entry_id_based_on_map_value+0xa>
                }
            }
        }
    }

    return -1;
4037cd14:	f27c      	movi.n	a2, -1
}
4037cd16:	f01d      	retw.n

4037cd18 <mmu_ll_entry_id_to_paddr_base>:
{
4037cd18:	004136        	entry	a1, 32
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cd1b:	ffa182        	movi	a8, 0x1ff
4037cd1e:	0eb837        	bgeu	a8, a3, 4037cd30 <mmu_ll_entry_id_to_paddr_base+0x18>
4037cd21:	e063d1        	l32r	a13, 40374eb0 <_iram_text_start+0xaac> (3fc93f54 <__FUNCTION__$0+0x69c>)
4037cd24:	e068c1        	l32r	a12, 40374ec4 <_iram_text_start+0xac0> (3fc942cc <__func__$1>)
4037cd27:	11a1b2        	movi	a11, 0x111
4037cd2a:	e063a1        	l32r	a10, 40374eb8 <_iram_text_start+0xab4> (3fc93f74 <__FUNCTION__$0+0x6bc>)
4037cd2d:	030725        	call8	4037fda0 <__assert_func>
    return ((*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4)) & SOC_MMU_VALID_VAL_MASK) << 16;
4037cd30:	e06381        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037cd33:	803380        	add	a3, a3, a8
4037cd36:	1133e0        	slli	a3, a3, 2
4037cd39:	002322        	l32i	a2, a3, 0
4037cd3c:	112200        	slli	a2, a2, 16
}
4037cd3f:	d52020        	extui	a2, a2, 16, 14
4037cd42:	112200        	slli	a2, a2, 16
4037cd45:	000090        	retw

4037cd48 <mmu_hal_paddr_to_vaddr>:

    return true;
}

bool mmu_hal_paddr_to_vaddr(uint32_t mmu_id, uint32_t paddr, mmu_target_t target, mmu_vaddr_t type, uint32_t *out_vaddr)
{
4037cd48:	004136        	entry	a1, 32
4037cd4b:	20c440        	or	a12, a4, a4
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cd4e:	e05e81        	l32r	a8, 40374ec8 <_iram_text_start+0xac4> (3fffffff <ets_rom_layout_p+0xe0003>)
4037cd51:	0eb837        	bgeu	a8, a3, 4037cd63 <mmu_hal_paddr_to_vaddr+0x1b>
    HAL_ASSERT(mmu_ll_check_valid_paddr_region(mmu_id, paddr, 1));
4037cd54:	e05ed1        	l32r	a13, 40374ecc <_iram_text_start+0xac8> (3fc93fa8 <__FUNCTION__$0+0x6f0>)
4037cd57:	e05ec1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc> (3fc942b4 <__func__$0>)
4037cd5a:	8da0b2        	movi	a11, 141
4037cd5d:	e05da1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037cd60:	0303e5        	call8	4037fda0 <__assert_func>

    uint32_t mmu_val = mmu_ll_format_paddr(mmu_id, paddr, target);
    int entry_id = mmu_ll_find_entry_id_based_on_map_value(mmu_id, mmu_val, target);
4037cd63:	f5b030        	extui	a11, a3, 16, 16
4037cd66:	20a220        	or	a10, a2, a2
4037cd69:	fff725        	call8	4037ccdc <mmu_ll_find_entry_id_based_on_map_value>
4037cd6c:	0a7d      	mov.n	a7, a10
    if (entry_id == -1) {
4037cd6e:	2a0a26        	beqi	a10, -1, 4037cd9c <mmu_hal_paddr_to_vaddr+0x54>
        return false;
    }

    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037cd71:	1b0c      	movi.n	a11, 1
4037cd73:	02ad      	mov.n	a10, a2
4037cd75:	001fa5        	call8	4037cf70 <mmu_hal_pages_to_bytes>
    uint32_t offset = paddr % page_size_in_bytes;
4037cd78:	e233a0        	remu	a3, a3, a10
 * @param type     virtual address type, could be instruction type or data type. See `mmu_vaddr_t`
 */
static inline uint32_t mmu_ll_entry_id_to_vaddr_base(uint32_t mmu_id, uint32_t entry_id, mmu_vaddr_t type)
{
    (void)mmu_id;
    uint32_t laddr = entry_id << 16;
4037cd7b:	117700        	slli	a7, a7, 16
    if (vaddr_type == MMU_VADDR_DATA) {
4037cd7e:	0a1526        	beqi	a5, 1, 4037cd8c <mmu_hal_paddr_to_vaddr+0x44>
    return vaddr_base | laddr;
4037cd81:	e05581        	l32r	a8, 40374ed8 <_iram_text_start+0xad4> (42000000 <_coredump_iram_end+0x1c7e000>)
4037cd84:	207780        	or	a7, a7, a8
    uint32_t vaddr_base = mmu_ll_entry_id_to_vaddr_base(mmu_id, entry_id, type);
    if (vaddr_base == 0) {
4037cd87:	0001c6        	j	4037cd92 <mmu_hal_paddr_to_vaddr+0x4a>
4037cd8a:	810000        	src	a0, a0, a0
4037cd8d:	80e054        	lsi	f5, a0, 0x200
4037cd90:	702077        	blt	a0, a7, 4037ce04 <mmu_hal_map_region+0xc>
        return false;
    }
    *out_vaddr = vaddr_base | offset;
4037cd93:	392033        	lsi	f3, a0, 228
4037cd96:	120c06        	j	403815ca <spi_flash_chip_winbond_suspend_cmd_conf+0x1a>

    return true;
4037cd99:	000046        	j	4037cd9e <mmu_hal_paddr_to_vaddr+0x56>
        return false;
4037cd9c:	020c      	movi.n	a2, 0
}
4037cd9e:	f01d      	retw.n

4037cda0 <mmu_hal_check_valid_ext_vaddr_region>:

bool mmu_hal_check_valid_ext_vaddr_region(uint32_t mmu_id, uint32_t vaddr_start, uint32_t len, mmu_vaddr_t type)
{
4037cda0:	004136        	entry	a1, 32
    uint32_t vaddr_end = vaddr_start + len - 1;
4037cda3:	434a      	add.n	a4, a3, a4
    if (type & MMU_VADDR_INSTRUCTION) {
4037cda5:	216517        	bbci	a5, 1, 4037cdca <mmu_hal_check_valid_ext_vaddr_region+0x2a>
        valid |= (SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_end));
4037cda8:	df8481        	l32r	a8, 40374bb8 <_iram_text_start+0x7b4> (be000000 <_rtc_reserved_end+0x5df00000>)
4037cdab:	838a      	add.n	a8, a3, a8
4037cdad:	de1391        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cdb0:	0c3987        	bltu	a9, a8, 4037cdc0 <mmu_hal_check_valid_ext_vaddr_region+0x20>
4037cdb3:	e03081        	l32r	a8, 40374e74 <_iram_text_start+0xa70> (bdffffff <_rtc_reserved_end+0x5defffff>)
4037cdb6:	848a      	add.n	a8, a4, a8
4037cdb8:	09b987        	bgeu	a9, a8, 4037cdc5 <mmu_hal_check_valid_ext_vaddr_region+0x25>
4037cdbb:	020c      	movi.n	a2, 0
4037cdbd:	0002c6        	j	4037cdcc <mmu_hal_check_valid_ext_vaddr_region+0x2c>
4037cdc0:	020c      	movi.n	a2, 0
4037cdc2:	000186        	j	4037cdcc <mmu_hal_check_valid_ext_vaddr_region+0x2c>
4037cdc5:	120c      	movi.n	a2, 1
4037cdc7:	000046        	j	4037cdcc <mmu_hal_check_valid_ext_vaddr_region+0x2c>
    bool valid = false;
4037cdca:	020c      	movi.n	a2, 0
    if (type & MMU_VADDR_DATA) {
4037cdcc:	256507        	bbci	a5, 0, 4037cdf5 <mmu_hal_check_valid_ext_vaddr_region+0x55>
        valid |= (SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_end));
4037cdcf:	e02a81        	l32r	a8, 40374e78 <_iram_text_start+0xa74> (c4000000 <_rtc_reserved_end+0x63f00000>)
4037cdd2:	338a      	add.n	a3, a3, a8
4037cdd4:	de0a81        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cdd7:	0f3837        	bltu	a8, a3, 4037cdea <mmu_hal_check_valid_ext_vaddr_region+0x4a>
4037cdda:	e02881        	l32r	a8, 40374e7c <_iram_text_start+0xa78> (c3ffffff <_rtc_reserved_end+0x63efffff>)
4037cddd:	448a      	add.n	a4, a4, a8
4037cddf:	de0781        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cde2:	0ab847        	bgeu	a8, a4, 4037cdf0 <mmu_hal_check_valid_ext_vaddr_region+0x50>
4037cde5:	080c      	movi.n	a8, 0
4037cde7:	0001c6        	j	4037cdf2 <mmu_hal_check_valid_ext_vaddr_region+0x52>
4037cdea:	080c      	movi.n	a8, 0
4037cdec:	000086        	j	4037cdf2 <mmu_hal_check_valid_ext_vaddr_region+0x52>
4037cdef:	180c00        	lsxp	f0, a12, a0
4037cdf2:	202280        	or	a2, a2, a8
    return mmu_ll_check_valid_ext_vaddr_region(mmu_id, vaddr_start, len, type);
}
4037cdf5:	f01d      	retw.n
	...

4037cdf8 <mmu_hal_map_region>:
{
4037cdf8:	006136        	entry	a1, 48
4037cdfb:	006172        	s32i	a7, a1, 0
4037cdfe:	207660        	or	a7, a6, a6
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037ce01:	1b0c      	movi.n	a11, 1
4037ce03:	02ad      	mov.n	a10, a2
4037ce05:	0016a5        	call8	4037cf70 <mmu_hal_pages_to_bytes>
4037ce08:	0a6d      	mov.n	a6, a10
    HAL_ASSERT(vaddr % page_size_in_bytes == 0);
4037ce0a:	e284a0        	remu	a8, a4, a10
4037ce0d:	c88c      	beqz.n	a8, 4037ce1d <mmu_hal_map_region+0x25>
4037ce0f:	e034d1        	l32r	a13, 40374ee0 <_iram_text_start+0xadc> (3fc93ffc <__FUNCTION__$0+0x744>)
4037ce12:	e034c1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94350 <__func__$7>)
4037ce15:	4b5c      	movi.n	a11, 84
4037ce17:	e02fa1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037ce1a:	02f865        	call8	4037fda0 <__assert_func>
    HAL_ASSERT(paddr % page_size_in_bytes == 0);
4037ce1d:	e285a0        	remu	a8, a5, a10
4037ce20:	00e816        	beqz	a8, 4037ce32 <mmu_hal_map_region+0x3a>
4037ce23:	e031d1        	l32r	a13, 40374ee8 <_iram_text_start+0xae4> (3fc9401c <__FUNCTION__$0+0x764>)
4037ce26:	e02fc1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94350 <__func__$7>)
4037ce29:	55a0b2        	movi	a11, 85
4037ce2c:	e02aa1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037ce2f:	02f725        	call8	4037fda0 <__assert_func>
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037ce32:	e02581        	l32r	a8, 40374ec8 <_iram_text_start+0xac4> (3fffffff <ets_rom_layout_p+0xe0003>)
4037ce35:	1d3857        	bltu	a8, a5, 4037ce56 <mmu_hal_map_region+0x5e>
    return (paddr_start < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037ce38:	1a3877        	bltu	a8, a7, 4037ce56 <mmu_hal_map_region+0x5e>
           ((paddr_start + len - 1) < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM));
4037ce3b:	808570        	add	a8, a5, a7
4037ce3e:	880b      	addi.n	a8, a8, -1
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037ce40:	e02291        	l32r	a9, 40374ec8 <_iram_text_start+0xac4> (3fffffff <ets_rom_layout_p+0xe0003>)
4037ce43:	0f3987        	bltu	a9, a8, 4037ce56 <mmu_hal_map_region+0x5e>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ce46:	3d0c      	movi.n	a13, 3
4037ce48:	07cd      	mov.n	a12, a7
4037ce4a:	04bd      	mov.n	a11, a4
4037ce4c:	02ad      	mov.n	a10, a2
4037ce4e:	fff525        	call8	4037cda0 <mmu_hal_check_valid_ext_vaddr_region>
4037ce51:	dadc      	bnez.n	a10, 4037ce72 <mmu_hal_map_region+0x7a>
4037ce53:	000346        	j	4037ce64 <mmu_hal_map_region+0x6c>
    HAL_ASSERT(mmu_ll_check_valid_paddr_region(mmu_id, paddr, len));
4037ce56:	e025d1        	l32r	a13, 40374eec <_iram_text_start+0xae8> (3fc9403c <__FUNCTION__$0+0x784>)
4037ce59:	e022c1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94350 <__func__$7>)
4037ce5c:	6b5c      	movi.n	a11, 86
4037ce5e:	e01da1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037ce61:	02f3e5        	call8	4037fda0 <__assert_func>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ce64:	e023d1        	l32r	a13, 40374ef0 <_iram_text_start+0xaec> (3fc94070 <__FUNCTION__$0+0x7b8>)
4037ce67:	e01fc1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94350 <__func__$7>)
4037ce6a:	7b5c      	movi.n	a11, 87
4037ce6c:	e01aa1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037ce6f:	02f325        	call8	4037fda0 <__assert_func>
    uint32_t page_num = (len + page_size_in_bytes - 1) / page_size_in_bytes;
4037ce72:	767a      	add.n	a7, a6, a7
4037ce74:	ffc772        	addi	a7, a7, -1
4037ce77:	c27760        	quou	a7, a7, a6
    *out_len = mmu_hal_pages_to_bytes(mmu_id, page_num);
4037ce7a:	20b770        	or	a11, a7, a7
4037ce7d:	02ad      	mov.n	a10, a2
4037ce7f:	000f25        	call8	4037cf70 <mmu_hal_pages_to_bytes>
4037ce82:	0188      	l32i.n	a8, a1, 0
4037ce84:	08a9      	s32i.n	a10, a8, 0
    return paddr >> 16;
4037ce86:	f55050        	extui	a5, a5, 16, 16
    while (page_num) {
4037ce89:	000846        	j	4037ceae <mmu_hal_map_region+0xb6>
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037ce8c:	858040        	extui	a8, a4, 16, 9
    uint32_t target_code = (target == MMU_TARGET_FLASH0) ? SOC_MMU_ACCESS_FLASH : SOC_MMU_ACCESS_SPIRAM;
4037ce8f:	051366        	bnei	a3, 1, 4037ce98 <mmu_hal_map_region+0xa0>
4037ce92:	090c      	movi.n	a9, 0
4037ce94:	0000c6        	j	4037ce9b <mmu_hal_map_region+0xa3>
4037ce97:	6f9100        	f64cmph	a9, a1, a0, 6
4037ce9a:	a1dd      	lsi	f13, a1, 4
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = mmu_val | target_code | SOC_MMU_VALID;
4037ce9c:	e008      	l32i.n	a0, a0, 56
4037ce9e:	88aa      	add.n	a8, a8, a10
4037cea0:	1188e0        	slli	a8, a8, 2
4037cea3:	209590        	or	a9, a5, a9
4037cea6:	0899      	s32i.n	a9, a8, 0
        vaddr += page_size_in_bytes;
4037cea8:	446a      	add.n	a4, a4, a6
        mmu_val++;
4037ceaa:	551b      	addi.n	a5, a5, 1
        page_num--;
4037ceac:	770b      	addi.n	a7, a7, -1
    while (page_num) {
4037ceae:	fda756        	bnez	a7, 4037ce8c <mmu_hal_map_region+0x94>
}
4037ceb1:	f01d      	retw.n
	...

4037ceb4 <mmu_hal_unmap_region>:
{
4037ceb4:	004136        	entry	a1, 32
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037ceb7:	01a0b2        	movi	a11, 1
4037ceba:	20a220        	or	a10, a2, a2
4037cebd:	000b25        	call8	4037cf70 <mmu_hal_pages_to_bytes>
4037cec0:	0a7d      	mov.n	a7, a10
    HAL_ASSERT(vaddr % page_size_in_bytes == 0);
4037cec2:	e283a0        	remu	a8, a3, a10
4037cec5:	d88c      	beqz.n	a8, 4037ced6 <mmu_hal_unmap_region+0x22>
4037cec7:	e006d1        	l32r	a13, 40374ee0 <_iram_text_start+0xadc> (3fc93ffc <__FUNCTION__$0+0x744>)
4037ceca:	e00ac1        	l32r	a12, 40374ef4 <_iram_text_start+0xaf0> (3fc94338 <__func__$5>)
4037cecd:	6ca0b2        	movi	a11, 108
4037ced0:	e001a1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037ced3:	02ece5        	call8	4037fda0 <__assert_func>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ced6:	03a0d2        	movi	a13, 3
4037ced9:	20c440        	or	a12, a4, a4
4037cedc:	03bd      	mov.n	a11, a3
4037cede:	02ad      	mov.n	a10, a2
4037cee0:	ffebe5        	call8	4037cda0 <mmu_hal_check_valid_ext_vaddr_region>
4037cee3:	dacc      	bnez.n	a10, 4037cef4 <mmu_hal_unmap_region+0x40>
4037cee5:	e002d1        	l32r	a13, 40374ef0 <_iram_text_start+0xaec> (3fc94070 <__FUNCTION__$0+0x7b8>)
4037cee8:	e003c1        	l32r	a12, 40374ef4 <_iram_text_start+0xaf0> (3fc94338 <__func__$5>)
4037ceeb:	6da0b2        	movi	a11, 109
4037ceee:	dff9a1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037cef1:	02eae5        	call8	4037fda0 <__assert_func>
    uint32_t page_num = (len + page_size_in_bytes - 1) / page_size_in_bytes;
4037cef4:	974a      	add.n	a9, a7, a4
4037cef6:	990b      	addi.n	a9, a9, -1
4037cef8:	c29970        	quou	a9, a9, a7
    while (page_num) {
4037cefb:	000546        	j	4037cf14 <mmu_hal_unmap_region+0x60>
4037cefe:	300000        	xor	a0, a0, a0
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037cf01:	a18580        	lsi	f8, a5, 0x284
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = SOC_MMU_INVALID;
4037cf04:	ee          	.byte	0xee
4037cf05:	df          	.byte	0xdf
4037cf06:	88aa      	add.n	a8, a8, a10
4037cf08:	1188e0        	slli	a8, a8, 2
4037cf0b:	dd51a1        	l32r	a10, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
4037cf0e:	08a9      	s32i.n	a10, a8, 0
        vaddr += page_size_in_bytes;
4037cf10:	337a      	add.n	a3, a3, a7
        page_num--;
4037cf12:	990b      	addi.n	a9, a9, -1
    while (page_num) {
4037cf14:	fe8956        	bnez	a9, 4037cf00 <mmu_hal_unmap_region+0x4c>
}
4037cf17:	f01d      	retw.n
4037cf19:	000000        	ill

4037cf1c <mmu_hal_vaddr_to_paddr>:
{
4037cf1c:	004136        	entry	a1, 32
4037cf1f:	207220        	or	a7, a2, a2
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, 1, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037cf22:	03a0d2        	movi	a13, 3
4037cf25:	1c0c      	movi.n	a12, 1
4037cf27:	03bd      	mov.n	a11, a3
4037cf29:	20a220        	or	a10, a2, a2
4037cf2c:	ffe725        	call8	4037cda0 <mmu_hal_check_valid_ext_vaddr_region>
4037cf2f:	00ea56        	bnez	a10, 4037cf41 <mmu_hal_vaddr_to_paddr+0x25>
4037cf32:	dff1d1        	l32r	a13, 40374ef8 <_iram_text_start+0xaf4> (3fc940d4 <__FUNCTION__$0+0x81c>)
4037cf35:	dff1c1        	l32r	a12, 40374efc <_iram_text_start+0xaf8> (3fc94320 <__func__$4>)
4037cf38:	7ba0b2        	movi	a11, 123
4037cf3b:	dfe6a1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93fdc <__FUNCTION__$0+0x724>)
4037cf3e:	02e625        	call8	4037fda0 <__assert_func>
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037cf41:	856030        	extui	a6, a3, 16, 9
    if (!mmu_ll_check_entry_valid(mmu_id, entry_id)) {
4037cf44:	06bd      	mov.n	a11, a6
4037cf46:	02ad      	mov.n	a10, a2
4037cf48:	ffd2a5        	call8	4037cc74 <mmu_ll_check_entry_valid>
4037cf4b:	0a2d      	mov.n	a2, a10
4037cf4d:	da9c      	beqz.n	a10, 4037cf6e <mmu_hal_vaddr_to_paddr+0x52>
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037cf4f:	1b0c      	movi.n	a11, 1
4037cf51:	07ad      	mov.n	a10, a7
4037cf53:	0001e5        	call8	4037cf70 <mmu_hal_pages_to_bytes>
    uint32_t offset = (uint32_t)vaddr % page_size_in_bytes;
4037cf56:	e233a0        	remu	a3, a3, a10
    *out_target = mmu_ll_get_entry_target(mmu_id, entry_id);
4037cf59:	06bd      	mov.n	a11, a6
4037cf5b:	07ad      	mov.n	a10, a7
4037cf5d:	ffd4a5        	call8	4037cca8 <mmu_ll_get_entry_target>
4037cf60:	05a9      	s32i.n	a10, a5, 0
    uint32_t paddr_base = mmu_ll_entry_id_to_paddr_base(mmu_id, entry_id);
4037cf62:	06bd      	mov.n	a11, a6
4037cf64:	07ad      	mov.n	a10, a7
4037cf66:	ffdb25        	call8	4037cd18 <mmu_ll_entry_id_to_paddr_base>
    *out_paddr = paddr_base | offset;
4037cf69:	2033a0        	or	a3, a3, a10
4037cf6c:	0439      	s32i.n	a3, a4, 0
}
4037cf6e:	f01d      	retw.n

4037cf70 <mmu_hal_pages_to_bytes>:
{
4037cf70:	004136        	entry	a1, 32
}
4037cf73:	112300        	slli	a2, a3, 16
4037cf76:	f01d      	retw.n

4037cf78 <spi_flash_encrypt_ll_plaintext_save>:
 * @param buffer Buffer to store the input data.
 * @param size Buffer size.
 *
 */
static inline void spi_flash_encrypt_ll_plaintext_save(uint32_t address, const uint32_t* buffer, uint32_t size)
{
4037cf78:	004136        	entry	a1, 32
4037cf7b:	03bd      	mov.n	a11, a3
4037cf7d:	04cd      	mov.n	a12, a4
    uint32_t plaintext_offs = (address % SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX);
4037cf7f:	542020        	extui	a2, a2, 0, 6
    HAL_ASSERT(plaintext_offs + size <= SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX);
4037cf82:	824a      	add.n	a8, a2, a4
4037cf84:	40a092        	movi	a9, 64
4037cf87:	0eb987        	bgeu	a9, a8, 4037cf99 <spi_flash_encrypt_ll_plaintext_save+0x21>
4037cf8a:	dfddd1        	l32r	a13, 40374f00 <_iram_text_start+0xafc> (3fc94134 <__FUNCTION__$0+0x87c>)
4037cf8d:	dfddc1        	l32r	a12, 40374f04 <_iram_text_start+0xb00> (3fc94364 <__func__$0>)
4037cf90:	59a0b2        	movi	a11, 89
4037cf93:	dfdda1        	l32r	a10, 40374f08 <_iram_text_start+0xb04> (3fc94174 <__FUNCTION__$0+0x8bc>)
4037cf96:	02e0a5        	call8	4037fda0 <__assert_func>
    memcpy((void *)(AES_XTS_PLAIN_BASE + plaintext_offs), buffer, size);
4037cf99:	dfdca1        	l32r	a10, 40374f0c <_iram_text_start+0xb08> (600cc000 <SYSTEM+0xc000>)
4037cf9c:	a2aa      	add.n	a10, a2, a10
4037cf9e:	dd4d81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037cfa1:	0008e0        	callx8	a8
}
4037cfa4:	f01d      	retw.n
	...

4037cfa8 <spi_flash_encryption_hal_enable>:

#include "hal/spi_flash_encrypted_ll.h"
#include "soc/soc_caps.h"

void spi_flash_encryption_hal_enable(void)
{
4037cfa8:	004136        	entry	a1, 32
    REG_SET_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037cfab:	dfd991        	l32r	a9, 40374f10 <_iram_text_start+0xb0c> (600c004c <SYSTEM+0x4c>)
4037cfae:	0020c0        	memw
4037cfb1:	0988      	l32i.n	a8, a9, 0
4037cfb3:	9a0c      	movi.n	a10, 9
4037cfb5:	2088a0        	or	a8, a8, a10
4037cfb8:	0020c0        	memw
4037cfbb:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(AES_XTS_DESTINATION_REG, type);
4037cfbd:	dfd581        	l32r	a8, 40374f14 <_iram_text_start+0xb10> (600cc044 <SYSTEM+0xc044>)
4037cfc0:	090c      	movi.n	a9, 0
4037cfc2:	0020c0        	memw
4037cfc5:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_aes_accelerator_enable();
#endif //CONFIG_IDF_TARGET_ESP32S2
#if !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_type(FLASH_ENCRYPTION_MANU);
#endif // !CONFIG_IDF_TARGET_ESP32
}
4037cfc7:	f01d      	retw.n
4037cfc9:	000000        	ill

4037cfcc <spi_flash_encryption_hal_disable>:

void spi_flash_encryption_hal_disable(void)
{
4037cfcc:	004136        	entry	a1, 32
    REG_CLR_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037cfcf:	dfd091        	l32r	a9, 40374f10 <_iram_text_start+0xb0c> (600c004c <SYSTEM+0x4c>)
4037cfd2:	0020c0        	memw
4037cfd5:	0988      	l32i.n	a8, a9, 0
4037cfd7:	ea7c      	movi.n	a10, -2
4037cfd9:	1088a0        	and	a8, a8, a10
4037cfdc:	0020c0        	memw
4037cfdf:	0989      	s32i.n	a8, a9, 0
    spi_flash_encrypt_ll_disable();
}
4037cfe1:	f01d      	retw.n
	...

4037cfe4 <spi_flash_encryption_hal_prepare>:

void spi_flash_encryption_hal_prepare(uint32_t address, const uint32_t* buffer, uint32_t size)
{
4037cfe4:	004136        	entry	a1, 32
4037cfe7:	02ad      	mov.n	a10, a2
4037cfe9:	03bd      	mov.n	a11, a3
4037cfeb:	04cd      	mov.n	a12, a4
    REG_WRITE(AES_XTS_SIZE_REG, size >> 5);
4037cfed:	419540        	srli	a9, a4, 5
4037cff0:	dfca81        	l32r	a8, 40374f18 <_iram_text_start+0xb14> (600cc040 <SYSTEM+0xc040>)
4037cff3:	0020c0        	memw
4037cff6:	0899      	s32i.n	a9, a8, 0
 *
 * @param flash_addr flash address to write.
 */
static inline void spi_flash_encrypt_ll_address_save(uint32_t flash_addr)
{
    REG_WRITE(AES_XTS_PHYSICAL_ADDR_REG, flash_addr);
4037cff8:	dfc981        	l32r	a8, 40374f1c <_iram_text_start+0xb18> (600cc048 <SYSTEM+0xc048>)
4037cffb:	0020c0        	memw
4037cffe:	006822        	s32i	a2, a8, 0
#if !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_buffer_length(size);
#endif // !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_address_save(address);
    spi_flash_encrypt_ll_plaintext_save(address, buffer, size);
4037d001:	fff765        	call8	4037cf78 <spi_flash_encrypt_ll_plaintext_save>
/**
 * Start flash encryption
 */
static inline void spi_flash_encrypt_ll_calculate_start(void)
{
    REG_WRITE(AES_XTS_TRIGGER_REG, 1);
4037d004:	dfc781        	l32r	a8, 40374f20 <_iram_text_start+0xb1c> (600cc04c <SYSTEM+0xc04c>)
4037d007:	190c      	movi.n	a9, 1
4037d009:	0020c0        	memw
4037d00c:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_calculate_start();
}
4037d00e:	f01d      	retw.n

4037d010 <spi_flash_encryption_hal_done>:

void spi_flash_encryption_hal_done(void)
{
4037d010:	004136        	entry	a1, 32
/**
 * Wait for flash encryption termination
 */
static inline void spi_flash_encrypt_ll_calculate_wait_idle(void)
{
    while(REG_READ(AES_XTS_STATE_REG) == 0x1) {
4037d013:	dfc481        	l32r	a8, 40374f24 <_iram_text_start+0xb20> (600cc058 <SYSTEM+0xc058>)
4037d016:	0020c0        	memw
4037d019:	0888      	l32i.n	a8, a8, 0
4037d01b:	f41826        	beqi	a8, 1, 4037d013 <spi_flash_encryption_hal_done+0x3>
/**
 * Finish the flash encryption and make encrypted result accessible to SPI.
 */
static inline void spi_flash_encrypt_ll_done(void)
{
    REG_WRITE(AES_XTS_RELEASE_REG, 1);
4037d01e:	dfc281        	l32r	a8, 40374f28 <_iram_text_start+0xb24> (600cc050 <SYSTEM+0xc050>)
4037d021:	190c      	movi.n	a9, 1
4037d023:	0020c0        	memw
4037d026:	0899      	s32i.n	a9, a8, 0
    while(REG_READ(AES_XTS_STATE_REG) != 0x3) {
4037d028:	dfbf81        	l32r	a8, 40374f24 <_iram_text_start+0xb20> (600cc058 <SYSTEM+0xc058>)
4037d02b:	0020c0        	memw
4037d02e:	0888      	l32i.n	a8, a8, 0
4037d030:	f43866        	bnei	a8, 3, 4037d028 <spi_flash_encryption_hal_done+0x18>
    spi_flash_encrypt_ll_calculate_wait_idle();
    spi_flash_encrypt_ll_done();
}
4037d033:	f01d      	retw.n
4037d035:	000000        	ill

4037d038 <spi_flash_encryption_hal_destroy>:

void spi_flash_encryption_hal_destroy(void)
{
4037d038:	004136        	entry	a1, 32
/**
 * Set to destroy encrypted result
 */
static inline void spi_flash_encrypt_ll_destroy(void)
{
    REG_WRITE(AES_XTS_DESTROY_REG, 1);
4037d03b:	dfbc81        	l32r	a8, 40374f2c <_iram_text_start+0xb28> (600cc054 <SYSTEM+0xc054>)
4037d03e:	190c      	movi.n	a9, 1
4037d040:	0020c0        	memw
4037d043:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_destroy();
}
4037d045:	f01d      	retw.n
	...

4037d048 <spi_flash_encryption_hal_check>:

bool spi_flash_encryption_hal_check(uint32_t address, uint32_t length)
{
4037d048:	004136        	entry	a1, 32
 * @param address the address of written flash partition.
 * @param length Buffer size.
 */
static inline bool spi_flash_encrypt_ll_check(uint32_t address, uint32_t length)
{
    return ((address % length) == 0) ? true : false;
4037d04b:	e22230        	remu	a2, a2, a3
    return spi_flash_encrypt_ll_check(address, length);
}
4037d04e:	40f220        	nsau	a2, a2
4037d051:	412520        	srli	a2, a2, 5
4037d054:	f01d      	retw.n
	...

4037d058 <gpspi_flash_ll_set_read_mode>:
 *
 * @param dev Beginning address of the peripheral registers.
 * @param read_mode I/O mode to use in the following transactions.
 */
static inline void gpspi_flash_ll_set_read_mode(spi_dev_t *dev, esp_flash_io_mode_t read_mode)
{
4037d058:	006136        	entry	a1, 48
    typeof(dev->ctrl) ctrl;
    ctrl.val = dev->ctrl.val;
4037d05b:	0020c0        	memw
4037d05e:	2288      	l32i.n	a8, a2, 8
4037d060:	0020c0        	memw
4037d063:	0189      	s32i.n	a8, a1, 0
    typeof(dev->user) user;
    user.val = dev->user.val;
4037d065:	0020c0        	memw
4037d068:	4288      	l32i.n	a8, a2, 16
4037d06a:	0020c0        	memw
4037d06d:	1189      	s32i.n	a8, a1, 4

    ctrl.val &= ~(SPI_FCMD_QUAD_M | SPI_FADDR_QUAD_M | SPI_FREAD_QUAD_M | SPI_FCMD_DUAL_M | SPI_FADDR_DUAL_M | SPI_FREAD_DUAL_M);
4037d06f:	0020c0        	memw
4037d072:	0188      	l32i.n	a8, a1, 0
4037d074:	dfaf91        	l32r	a9, 40374f30 <_iram_text_start+0xb2c> (ffff3c9f <_rtc_reserved_end+0x9fef3c9f>)
4037d077:	108890        	and	a8, a8, a9
4037d07a:	0020c0        	memw
4037d07d:	0189      	s32i.n	a8, a1, 0
    user.val &= ~(SPI_FWRITE_QUAD_M | SPI_FWRITE_DUAL_M);
4037d07f:	0020c0        	memw
4037d082:	1188      	l32i.n	a8, a1, 4
4037d084:	dfac91        	l32r	a9, 40374f34 <_iram_text_start+0xb30> (ffffcfff <_rtc_reserved_end+0x9fefcfff>)
4037d087:	108890        	and	a8, a8, a9
4037d08a:	0020c0        	memw
4037d08d:	1189      	s32i.n	a8, a1, 4

    switch (read_mode) {
4037d08f:	713326        	beqi	a3, 3, 4037d104 <gpspi_flash_ll_set_read_mode+0xac>
4037d092:	0e43f6        	bgeui	a3, 4, 4037d0a4 <gpspi_flash_ll_set_read_mode+0x4c>
4037d095:	0223f6        	bgeui	a3, 2, 4037d09b <gpspi_flash_ll_set_read_mode+0x43>
4037d098:	0030c6        	j	4037d15f <gpspi_flash_ll_set_read_mode+0x107>
4037d09b:	022366        	bnei	a3, 2, 4037d0a1 <gpspi_flash_ll_set_read_mode+0x49>
4037d09e:	002586        	j	4037d138 <gpspi_flash_ll_set_read_mode+0xe0>
4037d0a1:	002dc6        	j	4037d15c <gpspi_flash_ll_set_read_mode+0x104>
4037d0a4:	384326        	beqi	a3, 4, 4037d0e0 <gpspi_flash_ll_set_read_mode+0x88>
4037d0a7:	025326        	beqi	a3, 5, 4037d0ad <gpspi_flash_ll_set_read_mode+0x55>
4037d0aa:	002b86        	j	4037d15c <gpspi_flash_ll_set_read_mode+0x104>
    case SPI_FLASH_FASTRD:
    //the default option
    case SPI_FLASH_SLOWRD:
        break;
    case SPI_FLASH_QIO:
        ctrl.fread_quad = 1;
4037d0ad:	0020c0        	memw
4037d0b0:	0188      	l32i.n	a8, a1, 0
4037d0b2:	dce891        	l32r	a9, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
4037d0b5:	208890        	or	a8, a8, a9
4037d0b8:	0020c0        	memw
4037d0bb:	0189      	s32i.n	a8, a1, 0
        ctrl.faddr_quad = 1;
4037d0bd:	0020c0        	memw
4037d0c0:	0188      	l32i.n	a8, a1, 0
4037d0c2:	094c      	movi.n	a9, 64
4037d0c4:	208890        	or	a8, a8, a9
4037d0c7:	0020c0        	memw
4037d0ca:	0189      	s32i.n	a8, a1, 0
        user.fwrite_quad = 1;
4037d0cc:	0020c0        	memw
4037d0cf:	1188      	l32i.n	a8, a1, 4
4037d0d1:	de6f91        	l32r	a9, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037d0d4:	208890        	or	a8, a8, a9
4037d0d7:	0020c0        	memw
4037d0da:	1189      	s32i.n	a8, a1, 4
        break;
4037d0dc:	001fc6        	j	4037d15f <gpspi_flash_ll_set_read_mode+0x107>
4037d0df:	20c000        	or	a12, a0, a0
    case SPI_FLASH_QOUT:
        ctrl.fread_quad = 1;
4037d0e2:	018800        	slli	a8, a8, 32
4037d0e5:	dcdb91        	l32r	a9, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
4037d0e8:	208890        	or	a8, a8, a9
4037d0eb:	0020c0        	memw
4037d0ee:	0189      	s32i.n	a8, a1, 0
        user.fwrite_quad = 1;
4037d0f0:	0020c0        	memw
4037d0f3:	1188      	l32i.n	a8, a1, 4
4037d0f5:	de6691        	l32r	a9, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037d0f8:	208890        	or	a8, a8, a9
4037d0fb:	0020c0        	memw
4037d0fe:	1189      	s32i.n	a8, a1, 4
        break;
4037d100:	0016c6        	j	4037d15f <gpspi_flash_ll_set_read_mode+0x107>
4037d103:	20c000        	or	a12, a0, a0
    case SPI_FLASH_DIO:
        ctrl.fread_dual = 1;
4037d106:	018800        	slli	a8, a8, 32
4037d109:	dcd191        	l32r	a9, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
4037d10c:	208890        	or	a8, a8, a9
4037d10f:	0020c0        	memw
4037d112:	0189      	s32i.n	a8, a1, 0
        ctrl.faddr_dual = 1;
4037d114:	0020c0        	memw
4037d117:	0188      	l32i.n	a8, a1, 0
4037d119:	092c      	movi.n	a9, 32
4037d11b:	208890        	or	a8, a8, a9
4037d11e:	0020c0        	memw
4037d121:	0189      	s32i.n	a8, a1, 0
        user.fwrite_dual = 1;
4037d123:	0020c0        	memw
4037d126:	1188      	l32i.n	a8, a1, 4
4037d128:	dd5291        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037d12b:	208890        	or	a8, a8, a9
4037d12e:	0020c0        	memw
4037d131:	1189      	s32i.n	a8, a1, 4
        break;
4037d133:	000a06        	j	4037d15f <gpspi_flash_ll_set_read_mode+0x107>
4037d136:	c00000        	sub	a0, a0, a0
    case SPI_FLASH_DOUT:
        ctrl.fread_dual = 1;
4037d139:	880020        	lsi	f2, a0, 0x220
4037d13c:	c49101        	l32r	a0, 4036e380 <rom_rx_gain_force+0x367f54>
4037d13f:	90dc      	bnez.n	a0, 4037d15c <gpspi_flash_ll_set_read_mode+0x104>
4037d141:	2088      	l32i.n	a8, a0, 8
4037d143:	0020c0        	memw
4037d146:	0189      	s32i.n	a8, a1, 0
        user.fwrite_dual = 1;
4037d148:	0020c0        	memw
4037d14b:	1188      	l32i.n	a8, a1, 4
4037d14d:	dd4891        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037d150:	208890        	or	a8, a8, a9
4037d153:	0020c0        	memw
4037d156:	1189      	s32i.n	a8, a1, 4
        break;
4037d158:	0000c6        	j	4037d15f <gpspi_flash_ll_set_read_mode+0x107>
4037d15b:	b86500        	lsi	f0, a5, 0x2e0
    default:
        abort();
4037d15e:	20c002        	addi	a0, a0, 32
    }

    dev->ctrl.val = ctrl.val;
4037d161:	218200        	srai	a8, a0, 2
4037d164:	20c000        	or	a12, a0, a0
4037d167:	628200        	lsi	f0, a2, 0x188
4037d16a:	20c002        	addi	a0, a0, 32
    dev->user.val = user.val;
4037d16d:	218200        	srai	a8, a0, 2
4037d170:	20c001        	l32r	a0, 40345470 <rom_rx_gain_force+0x33f044>
4037d173:	428900        	xorb	b8, b9, b0
}
4037d176:	f01d      	retw.n

4037d178 <gpspi_flash_ll_set_buffer_data>:
{
4037d178:	006136        	entry	a1, 48
    int num_words = (length + 3) / 4;
4037d17b:	543b      	addi.n	a5, a4, 3
4037d17d:	415250        	srli	a5, a5, 2
    for (int i = 0; i < num_words; i++) {
4037d180:	060c      	movi.n	a6, 0
4037d182:	000a86        	j	4037d1b0 <gpspi_flash_ll_set_buffer_data+0x38>
        uint32_t word = 0;
4037d185:	080c      	movi.n	a8, 0
4037d187:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037d189:	470c      	movi.n	a7, 4
4037d18b:	637470        	minu	a7, a4, a7
        memcpy(&word, buffer, word_len);
4037d18e:	07cd      	mov.n	a12, a7
4037d190:	20b330        	or	a11, a3, a3
4037d193:	20a110        	or	a10, a1, a1
4037d196:	dccf81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d199:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037d19c:	24c682        	addi	a8, a6, 36
4037d19f:	a08820        	addx4	a8, a8, a2
4037d1a2:	0198      	l32i.n	a9, a1, 0
4037d1a4:	0020c0        	memw
4037d1a7:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037d1a9:	c04470        	sub	a4, a4, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037d1ac:	337a      	add.n	a3, a3, a7
    for (int i = 0; i < num_words; i++) {
4037d1ae:	661b      	addi.n	a6, a6, 1
4037d1b0:	d12657        	blt	a6, a5, 4037d185 <gpspi_flash_ll_set_buffer_data+0xd>
}
4037d1b3:	f01d      	retw.n
4037d1b5:	000000        	ill

4037d1b8 <gpspi_flash_ll_get_buffer_data>:
{
4037d1b8:	006136        	entry	a1, 48
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037d1bb:	148030        	extui	a8, a3, 0, 2
4037d1be:	68dc      	bnez.n	a8, 4037d1d8 <gpspi_flash_ll_get_buffer_data+0x20>
4037d1c0:	148040        	extui	a8, a4, 0, 2
4037d1c3:	18dc      	bnez.n	a8, 4037d1d8 <gpspi_flash_ll_get_buffer_data+0x20>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037d1c5:	04cd      	mov.n	a12, a4
4037d1c7:	98a0b2        	movi	a11, 152
4037d1ca:	b2ba      	add.n	a11, a2, a11
4037d1cc:	03ad      	mov.n	a10, a3
4037d1ce:	dcc181        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d1d1:	0008e0        	callx8	a8
4037d1d4:	000d46        	j	4037d20d <gpspi_flash_ll_get_buffer_data+0x55>
4037d1d7:	045d00        	extui	a5, a0, 13, 1
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d1da:	060c      	movi.n	a6, 0
4037d1dc:	000946        	j	4037d205 <gpspi_flash_ll_get_buffer_data+0x4d>
4037d1df:	470c00        	lsi	f0, a12, 0x11c
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037d1e2:	637570        	minu	a7, a5, a7
            uint32_t word = dev->data_buf[i];
4037d1e5:	24c682        	addi	a8, a6, 36
4037d1e8:	a08820        	addx4	a8, a8, a2
4037d1eb:	0020c0        	memw
4037d1ee:	2888      	l32i.n	a8, a8, 8
4037d1f0:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037d1f2:	07cd      	mov.n	a12, a7
4037d1f4:	01bd      	mov.n	a11, a1
4037d1f6:	03ad      	mov.n	a10, a3
4037d1f8:	dcb781        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d1fb:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037d1fe:	337a      	add.n	a3, a3, a7
            copy_len -= word_len;
4037d200:	c05570        	sub	a5, a5, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d203:	661b      	addi.n	a6, a6, 1
4037d205:	843b      	addi.n	a8, a4, 3
4037d207:	418280        	srli	a8, a8, 2
4037d20a:	d23687        	bltu	a6, a8, 4037d1e0 <gpspi_flash_ll_get_buffer_data+0x28>
}
4037d20d:	f01d      	retw.n
	...

4037d210 <spi_flash_hal_gpspi_device_config>:
        //nop
    }
}

esp_err_t spi_flash_hal_device_config(spi_flash_host_inst_t *host)
{
4037d210:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d213:	1288      	l32i.n	a8, a2, 4
    dev->user.val = 0;
4037d215:	090c      	movi.n	a9, 0
4037d217:	0020c0        	memw
4037d21a:	4899      	s32i.n	a9, a8, 16
    dev->ctrl.val = 0;
4037d21c:	0020c0        	memw
4037d21f:	2899      	s32i.n	a9, a8, 8
    dev->clk_gate.clk_en = 1;
4037d221:	0020c0        	memw
4037d224:	3a28a2        	l32i	a10, a8, 232
4037d227:	1b0c      	movi.n	a11, 1
4037d229:	20aab0        	or	a10, a10, a11
4037d22c:	0020c0        	memw
4037d22f:	3a68a2        	s32i	a10, a8, 232
    dev->clk_gate.mst_clk_active = 1;
4037d232:	0020c0        	memw
4037d235:	3a28a2        	l32i	a10, a8, 232
4037d238:	2b0c      	movi.n	a11, 2
4037d23a:	20aab0        	or	a10, a10, a11
4037d23d:	0020c0        	memw
4037d240:	3a68a2        	s32i	a10, a8, 232
    dev->clk_gate.mst_clk_sel = 1;
4037d243:	0020c0        	memw
4037d246:	3a28a2        	l32i	a10, a8, 232
4037d249:	4b0c      	movi.n	a11, 4
4037d24b:	20aab0        	or	a10, a10, a11
4037d24e:	0020c0        	memw
4037d251:	3a68a2        	s32i	a10, a8, 232
    dev->dma_conf.val = 0;
4037d254:	0020c0        	memw
4037d257:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.tx_seg_trans_clr_en = 1;
4037d259:	0020c0        	memw
4037d25c:	c898      	l32i.n	a9, a8, 48
4037d25e:	df36a1        	l32r	a10, 40374f38 <_iram_text_start+0xb34> (100000 <UserFrameTotalSize+0xfff00>)
4037d261:	2099a0        	or	a9, a9, a10
4037d264:	0020c0        	memw
4037d267:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.rx_seg_trans_clr_en = 1;
4037d269:	0020c0        	memw
4037d26c:	c898      	l32i.n	a9, a8, 48
4037d26e:	ddc4a1        	l32r	a10, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
4037d271:	2099a0        	or	a9, a9, a10
4037d274:	0020c0        	memw
4037d277:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.dma_seg_trans_en = 0;
4037d279:	0020c0        	memw
4037d27c:	c898      	l32i.n	a9, a8, 48
4037d27e:	df2fa1        	l32r	a10, 40374f3c <_iram_text_start+0xb38> (fffbffff <_rtc_reserved_end+0x9febffff>)
4037d281:	1099a0        	and	a9, a9, a10
4037d284:	0020c0        	memw
4037d287:	c899      	s32i.n	a9, a8, 48
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    spi_dev_t *dev = get_spi_dev(host);

    spi_flash_ll_reset(dev);
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037d289:	22a8      	l32i.n	a10, a2, 8
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037d28b:	0020c0        	memw
4037d28e:	8898      	l32i.n	a9, a8, 32
4037d290:	1b0c      	movi.n	a11, 1
4037d292:	83baa0        	moveqz	a11, a10, a10
4037d295:	ec7c      	movi.n	a12, -2
4037d297:	1099c0        	and	a9, a9, a12
4037d29a:	2099b0        	or	a9, a9, a11
4037d29d:	0020c0        	memw
4037d2a0:	8899      	s32i.n	a9, a8, 32
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037d2a2:	ba0b      	addi.n	a11, a10, -1
4037d2a4:	0020c0        	memw
4037d2a7:	8898      	l32i.n	a9, a8, 32
4037d2a9:	1a0c      	movi.n	a10, 1
4037d2ab:	83abb0        	moveqz	a10, a11, a11
4037d2ae:	aaaa      	add.n	a10, a10, a10
4037d2b0:	db7c      	movi.n	a11, -3
4037d2b2:	1099b0        	and	a9, a9, a11
4037d2b5:	2099a0        	or	a9, a9, a10
4037d2b8:	0020c0        	memw
4037d2bb:	8899      	s32i.n	a9, a8, 32
 * @param dev Beginning address of the peripheral registers.
 * @param clock_val pointer to the clock value to set
 */
static inline void gpspi_flash_ll_set_clock(spi_dev_t *dev, gpspi_flash_ll_clock_reg_t *clock_val)
{
    dev->clock.val = *clock_val;
4037d2bd:	0020c0        	memw
4037d2c0:	4298      	l32i.n	a9, a2, 16
4037d2c2:	0020c0        	memw
4037d2c5:	3899      	s32i.n	a9, a8, 12
    spi_flash_ll_set_clock(dev, &ctx->clock_conf);
    int cs_hold = ctx->cs_hold;
4037d2c7:	0f0292        	l8ui	a9, a2, 15
 * @param dev Beginning address of the peripheral registers.
 * @param hold_n Cycles of clocks before CS is inactive
 */
static inline void gpspi_flash_ll_set_hold(spi_dev_t *dev, uint32_t hold_n)
{
    dev->user.cs_hold = (hold_n > 0 ? 1 : 0);
4037d2ca:	0020c0        	memw
4037d2cd:	48a8      	l32i.n	a10, a8, 16
4037d2cf:	1b0c      	movi.n	a11, 1
4037d2d1:	83b990        	moveqz	a11, a9, a9
4037d2d4:	11bba0        	slli	a11, a11, 6
4037d2d7:	bfafc2        	movi	a12, -65
4037d2da:	10aac0        	and	a10, a10, a12
4037d2dd:	20aab0        	or	a10, a10, a11
4037d2e0:	0020c0        	memw
4037d2e3:	48a9      	s32i.n	a10, a8, 16
    if (hold_n > 0) {
4037d2e5:	b99c      	beqz.n	a9, 4037d304 <spi_flash_hal_gpspi_device_config+0xf4>
        dev->user1.cs_hold_time = hold_n - 1;
4037d2e7:	990b      	addi.n	a9, a9, -1
4037d2e9:	0020c0        	memw
4037d2ec:	0528a2        	l32i	a10, a8, 20
4037d2ef:	449090        	extui	a9, a9, 0, 5
4037d2f2:	0199a0        	slli	a9, a9, 22
4037d2f5:	df12b1        	l32r	a11, 40374f40 <_iram_text_start+0xb3c> (f83fffff <_rtc_reserved_end+0x982fffff>)
4037d2f8:	10aab0        	and	a10, a10, a11
4037d2fb:	209a90        	or	a9, a10, a9
4037d2fe:	0020c0        	memw
4037d301:	056892        	s32i	a9, a8, 20
    spi_flash_ll_set_hold(dev, cs_hold);
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037d304:	0e0292        	l8ui	a9, a2, 14
 * @param dev Beginning address of the peripheral registers.
 * @param cs_setup_time Delay of SPI clocks after the CS active edge, 0 to disable the setup phase.
 */
static inline void gpspi_flash_ll_set_cs_setup(spi_dev_t *dev, uint32_t cs_setup_time)
{
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037d307:	0020c0        	memw
4037d30a:	48a8      	l32i.n	a10, a8, 16
4037d30c:	1b0c      	movi.n	a11, 1
4037d30e:	83b990        	moveqz	a11, a9, a9
4037d311:	11bb90        	slli	a11, a11, 7
4037d314:	7fafc2        	movi	a12, -129
4037d317:	10aac0        	and	a10, a10, a12
4037d31a:	20aab0        	or	a10, a10, a11
4037d31d:	0020c0        	memw
4037d320:	48a9      	s32i.n	a10, a8, 16
    if (cs_setup_time > 0) {
4037d322:	a99c      	beqz.n	a9, 4037d340 <spi_flash_hal_gpspi_device_config+0x130>
        dev->user1.cs_setup_time = cs_setup_time - 1;
4037d324:	990b      	addi.n	a9, a9, -1
4037d326:	0020c0        	memw
4037d329:	58a8      	l32i.n	a10, a8, 20
4037d32b:	449090        	extui	a9, a9, 0, 5
4037d32e:	0199f0        	slli	a9, a9, 17
4037d331:	df04b1        	l32r	a11, 40374f44 <_iram_text_start+0xb40> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
4037d334:	10aab0        	and	a10, a10, a11
4037d337:	209a90        	or	a9, a10, a9
4037d33a:	0020c0        	memw
4037d33d:	056892        	s32i	a9, a8, 20
    dev->ctrl.hold_pol = pol_val;
4037d340:	0020c0        	memw
4037d343:	2898      	l32i.n	a9, a8, 8
4037d345:	defca1        	l32r	a10, 40374f38 <_iram_text_start+0xb34> (100000 <UserFrameTotalSize+0xfff00>)
4037d348:	2099a0        	or	a9, a9, a10
4037d34b:	0020c0        	memw
4037d34e:	2899      	s32i.n	a9, a8, 8
#else
    gpspi_flash_ll_set_hold_pol(dev, 1);
#endif //GPSPI_BUILD

    return ESP_OK;
}
4037d350:	020c      	movi.n	a2, 0
4037d352:	f01d      	retw.n

4037d354 <spi_flash_hal_gpspi_configure_host_io_mode>:
    spi_flash_host_inst_t *host,
    uint32_t command,
    uint32_t addr_bitlen,
    int dummy_cyclelen_base,
    esp_flash_io_mode_t io_mode)
{
4037d354:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d357:	12a8      	l32i.n	a10, a2, 4
    spi_dev_t *dev = get_spi_dev(host);
    int host_id = spi_flash_ll_hw_get_id(dev);

    uint32_t extra_bits = io_mode & 0xFFFF0000;
    io_mode = io_mode & 0xFFFF;
4037d359:	f4b060        	extui	a11, a6, 0, 16
    dev->ctrl.dummy_out = out_en;
4037d35c:	0020c0        	memw
4037d35f:	2a88      	l32i.n	a8, a10, 8
4037d361:	056f60        	extui	a6, a6, 31, 1
4037d364:	1166d0        	slli	a6, a6, 3
4037d367:	797c      	movi.n	a9, -9
4037d369:	108890        	and	a8, a8, a9
4037d36c:	208860        	or	a8, a8, a6
4037d36f:	0020c0        	memw
4037d372:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.q_pol = out_lev;
4037d374:	0020c0        	memw
4037d377:	2a88      	l32i.n	a8, a10, 8
4037d379:	dd2191        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037d37c:	208890        	or	a8, a8, a9
4037d37f:	0020c0        	memw
4037d382:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.d_pol = out_lev;
4037d384:	0020c0        	memw
4037d387:	2a88      	l32i.n	a8, a10, 8
4037d389:	dd7d91        	l32r	a9, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
4037d38c:	208890        	or	a8, a8, a9
4037d38f:	0020c0        	memw
4037d392:	2a89      	s32i.n	a8, a10, 8
            spi_flash_ll_set_extra_address(dev, 0);
        }
    }
#endif

    if (command >= 0x100) {
4037d394:	ffa082        	movi	a8, 255
4037d397:	49b837        	bgeu	a8, a3, 4037d3e4 <spi_flash_hal_gpspi_configure_host_io_mode+0x90>
    dev->user.usr_command = 1;
4037d39a:	0020c0        	memw
4037d39d:	4a88      	l32i.n	a8, a10, 16
4037d39f:	dc5f91        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d3a2:	208890        	or	a8, a8, a9
4037d3a5:	0020c0        	memw
4037d3a8:	4a89      	s32i.n	a8, a10, 16
    typeof(dev->user2) user2 = {
4037d3aa:	080c      	movi.n	a8, 0
4037d3ac:	0020c0        	memw
4037d3af:	2189      	s32i.n	a8, a1, 8
4037d3b1:	0020c0        	memw
4037d3b4:	2188      	l32i.n	a8, a1, 8
4037d3b6:	743030        	extui	a3, a3, 0, 8
4037d3b9:	f58080        	extui	a8, a8, 16, 16
4037d3bc:	118800        	slli	a8, a8, 16
4037d3bf:	208830        	or	a8, a8, a3
4037d3c2:	0020c0        	memw
4037d3c5:	2189      	s32i.n	a8, a1, 8
4037d3c7:	0020c0        	memw
4037d3ca:	2188      	l32i.n	a8, a1, 8
4037d3cc:	dedf91        	l32r	a9, 40374f48 <_iram_text_start+0xb44> (f0000000 <_rtc_reserved_end+0x8ff00000>)
4037d3cf:	208890        	or	a8, a8, a9
4037d3d2:	0020c0        	memw
4037d3d5:	2189      	s32i.n	a8, a1, 8
    dev->user2.val = user2.val;
4037d3d7:	0020c0        	memw
4037d3da:	2188      	l32i.n	a8, a1, 8
4037d3dc:	0020c0        	memw
4037d3df:	6a89      	s32i.n	a8, a10, 24
}
4037d3e1:	001306        	j	4037d431 <spi_flash_hal_gpspi_configure_host_io_mode+0xdd>
    dev->user.usr_command = 1;
4037d3e4:	0020c0        	memw
4037d3e7:	4a88      	l32i.n	a8, a10, 16
4037d3e9:	dc4c91        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d3ec:	208890        	or	a8, a8, a9
4037d3ef:	0020c0        	memw
4037d3f2:	4a89      	s32i.n	a8, a10, 16
    typeof(dev->user2) user2 = {
4037d3f4:	080c      	movi.n	a8, 0
4037d3f6:	0020c0        	memw
4037d3f9:	1189      	s32i.n	a8, a1, 4
4037d3fb:	0020c0        	memw
4037d3fe:	1188      	l32i.n	a8, a1, 4
4037d400:	743030        	extui	a3, a3, 0, 8
4037d403:	f58080        	extui	a8, a8, 16, 16
4037d406:	118800        	slli	a8, a8, 16
4037d409:	208830        	or	a8, a8, a3
4037d40c:	0020c0        	memw
4037d40f:	1189      	s32i.n	a8, a1, 4
4037d411:	0020c0        	memw
4037d414:	1188      	l32i.n	a8, a1, 4
4037d416:	1188c0        	slli	a8, a8, 4
4037d419:	418480        	srli	a8, a8, 4
4037d41c:	dcf391        	l32r	a9, 403747e8 <_iram_text_start+0x3e4> (70000000 <_rtc_reserved_end+0xff00000>)
4037d41f:	208890        	or	a8, a8, a9
4037d422:	0020c0        	memw
4037d425:	1189      	s32i.n	a8, a1, 4
    dev->user2.val = user2.val;
4037d427:	0020c0        	memw
4037d42a:	1188      	l32i.n	a8, a1, 4
4037d42c:	0020c0        	memw
4037d42f:	6a89      	s32i.n	a8, a10, 24
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d431:	940b      	addi.n	a9, a4, -1
4037d433:	0020c0        	memw
4037d436:	5a88      	l32i.n	a8, a10, 20
4037d438:	019950        	slli	a9, a9, 27
4037d43b:	1188b0        	slli	a8, a8, 5
4037d43e:	418580        	srli	a8, a8, 5
4037d441:	208890        	or	a8, a8, a9
4037d444:	0020c0        	memw
4037d447:	5a89      	s32i.n	a8, a10, 20
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d449:	0020c0        	memw
4037d44c:	4a88      	l32i.n	a8, a10, 16
4037d44e:	190c      	movi.n	a9, 1
4037d450:	839440        	moveqz	a9, a4, a4
4037d453:	019920        	slli	a9, a9, 30
4037d456:	dce5c1        	l32r	a12, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037d459:	1088c0        	and	a8, a8, a12
4037d45c:	208890        	or	a8, a8, a9
4037d45f:	0020c0        	memw
4037d462:	4a89      	s32i.n	a8, a10, 16
    } else {
        spi_flash_ll_set_command(dev, command, 8);
    }
    spi_flash_ll_set_addr_bitlen(dev, addr_bitlen);
    // Add dummy cycles to compensate for latency of GPIO matrix and external delay, if necessary...
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037d464:	0c0282        	l8ui	a8, a2, 12
4037d467:	585a      	add.n	a5, a8, a5
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d469:	0020c0        	memw
4037d46c:	4a88      	l32i.n	a8, a10, 16
4037d46e:	190c      	movi.n	a9, 1
4037d470:	839550        	moveqz	a9, a5, a5
4037d473:	019930        	slli	a9, a9, 29
4037d476:	dcdfc1        	l32r	a12, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d479:	1088c0        	and	a8, a8, a12
4037d47c:	208890        	or	a8, a8, a9
4037d47f:	0020c0        	memw
4037d482:	4a89      	s32i.n	a8, a10, 16
    if (dummy_n > 0) {
4037d484:	b5ac      	beqz.n	a5, 4037d4b3 <spi_flash_hal_gpspi_configure_host_io_mode+0x15f>
        HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037d486:	0020c0        	memw
4037d489:	5a88      	l32i.n	a8, a10, 20
4037d48b:	0020c0        	memw
4037d48e:	0189      	s32i.n	a8, a1, 0
4037d490:	550b      	addi.n	a5, a5, -1
4037d492:	0020c0        	memw
4037d495:	0188      	l32i.n	a8, a1, 0
4037d497:	745050        	extui	a5, a5, 0, 8
4037d49a:	00af92        	movi	a9, 0xffffff00
4037d49d:	108890        	and	a8, a8, a9
4037d4a0:	208850        	or	a8, a8, a5
4037d4a3:	0020c0        	memw
4037d4a6:	0189      	s32i.n	a8, a1, 0
4037d4a8:	0020c0        	memw
4037d4ab:	0188      	l32i.n	a8, a1, 0
4037d4ad:	0020c0        	memw
4037d4b0:	056a82        	s32i	a8, a10, 20
    dev->user.usr_miso = bitlen > 0;
4037d4b3:	0020c0        	memw
4037d4b6:	4a88      	l32i.n	a8, a10, 16
4037d4b8:	dcd191        	l32r	a9, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d4bb:	108890        	and	a8, a8, a9
4037d4be:	0020c0        	memw
4037d4c1:	4a89      	s32i.n	a8, a10, 16
    dev->user.usr_mosi = bitlen > 0;
4037d4c3:	0020c0        	memw
4037d4c6:	4a88      	l32i.n	a8, a10, 16
4037d4c8:	dccc91        	l32r	a9, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037d4cb:	108890        	and	a8, a8, a9
4037d4ce:	0020c0        	memw
4037d4d1:	4a89      	s32i.n	a8, a10, 16
    //disable all data phases, enable them later if needed
    spi_flash_ll_set_miso_bitlen(dev, 0);
    spi_flash_ll_set_mosi_bitlen(dev, 0);
    spi_flash_ll_set_read_mode(dev, io_mode);
4037d4d3:	ffb865        	call8	4037d058 <gpspi_flash_ll_set_read_mode>
    if (ctx->fdummy_rin) {
        spimem_flash_ll_set_fdummy_rin((spi_mem_dev_t*)dev, ctx->fdummy_rin);
    }
#endif
    return ESP_OK;
}
4037d4d6:	020c      	movi.n	a2, 0
4037d4d8:	f01d      	retw.n
	...

4037d4dc <spi_flash_hal_gpspi_common_command>:

esp_err_t spi_flash_hal_common_command(spi_flash_host_inst_t *host, spi_flash_trans_t *trans)
{
4037d4dc:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d4df:	1278      	l32i.n	a7, a2, 4
    spi_dev_t *dev = get_spi_dev(host);
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037d4e1:	52e8      	l32i.n	a14, a2, 20
    uint16_t command;
    uint8_t dummy_bitlen;
    bool pe_ops = false;

    command = trans->command;
4037d4e3:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037d4e6:	160362        	l8ui	a6, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037d4e9:	4388      	l32i.n	a8, a3, 16
4037d4eb:	016817        	bbci	a8, 1, 4037d4f0 <spi_flash_hal_gpspi_common_command+0x14>
        io_mode = trans->io_mode;
4037d4ee:	63e8      	l32i.n	a14, a3, 24
    }

    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037d4f0:	0288      	l32i.n	a8, a2, 0
4037d4f2:	f888      	l32i.n	a8, a8, 60
4037d4f4:	06dd      	mov.n	a13, a6
4037d4f6:	0303c2        	l8ui	a12, a3, 3
4037d4f9:	02ad      	mov.n	a10, a2
4037d4fb:	0008e0        	callx8	a8

    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037d4fe:	1398      	l32i.n	a9, a3, 4
4037d500:	030382        	l8ui	a8, a3, 3
    uint32_t padding_ones = (bitlen == 32 ? 0 : UINT32_MAX >> bitlen);
4037d503:	0ac826        	beqi	a8, 32, 4037d511 <spi_flash_hal_gpspi_common_command+0x35>
4037d506:	fa7c      	movi.n	a10, -1
4037d508:	400800        	ssr	a8
4037d50b:	91a0a0        	srl	a10, a10
4037d50e:	000046        	j	4037d513 <spi_flash_hal_gpspi_common_command+0x37>
4037d511:	0a0c      	movi.n	a10, 0
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037d513:	e0c882        	addi	a8, a8, -32
4037d516:	608080        	neg	a8, a8
4037d519:	401800        	ssl	a8
4037d51c:	a18900        	sll	a8, a9
4037d51f:	2088a0        	or	a8, a8, a10
4037d522:	0020c0        	memw
4037d525:	1789      	s32i.n	a8, a7, 4
    //No extra dummy cycles for compensation if no input data
    if (trans->miso_len == 0) {
4037d527:	020382        	l8ui	a8, a3, 2
4037d52a:	048856        	bnez	a8, 4037d576 <spi_flash_hal_gpspi_common_command+0x9a>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d52d:	0020c0        	memw
4037d530:	4788      	l32i.n	a8, a7, 16
4037d532:	190c      	movi.n	a9, 1
4037d534:	839660        	moveqz	a9, a6, a6
4037d537:	019930        	slli	a9, a9, 29
4037d53a:	dcaea1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d53d:	1088a0        	and	a8, a8, a10
4037d540:	208890        	or	a8, a8, a9
4037d543:	0020c0        	memw
4037d546:	4789      	s32i.n	a8, a7, 16
    if (dummy_n > 0) {
4037d548:	a6ac      	beqz.n	a6, 4037d576 <spi_flash_hal_gpspi_common_command+0x9a>
        HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037d54a:	0020c0        	memw
4037d54d:	5788      	l32i.n	a8, a7, 20
4037d54f:	0020c0        	memw
4037d552:	0189      	s32i.n	a8, a1, 0
4037d554:	660b      	addi.n	a6, a6, -1
4037d556:	0020c0        	memw
4037d559:	0188      	l32i.n	a8, a1, 0
4037d55b:	746060        	extui	a6, a6, 0, 8
4037d55e:	00af92        	movi	a9, 0xffffff00
4037d561:	108890        	and	a8, a8, a9
4037d564:	208860        	or	a8, a8, a6
4037d567:	0020c0        	memw
4037d56a:	0189      	s32i.n	a8, a1, 0
4037d56c:	0020c0        	memw
4037d56f:	0188      	l32i.n	a8, a1, 0
4037d571:	0020c0        	memw
4037d574:	5789      	s32i.n	a8, a7, 20
        spi_flash_ll_set_dummy(dev, dummy_bitlen);
    }

    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037d576:	0103a2        	l8ui	a10, a3, 1
4037d579:	119ad0        	slli	a9, a10, 3
    dev->user.usr_mosi = bitlen > 0;
4037d57c:	0020c0        	memw
4037d57f:	4788      	l32i.n	a8, a7, 16
4037d581:	1b0c      	movi.n	a11, 1
4037d583:	83baa0        	moveqz	a11, a10, a10
4037d586:	01bb50        	slli	a11, a11, 27
4037d589:	dc9bc1        	l32r	a12, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037d58c:	1088c0        	and	a8, a8, a12
4037d58f:	2088b0        	or	a8, a8, a11
4037d592:	0020c0        	memw
4037d595:	4789      	s32i.n	a8, a7, 16
    if (bitlen) {
4037d597:	9a9c      	beqz.n	a10, 4037d5b4 <spi_flash_hal_gpspi_common_command+0xd8>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d599:	890b      	addi.n	a8, a9, -1
4037d59b:	0020c0        	memw
4037d59e:	7798      	l32i.n	a9, a7, 28
4037d5a0:	118820        	slli	a8, a8, 14
4037d5a3:	418e80        	srli	a8, a8, 14
4037d5a6:	d59290        	extui	a9, a9, 18, 14
4037d5a9:	0199e0        	slli	a9, a9, 18
4037d5ac:	209980        	or	a9, a9, a8
4037d5af:	0020c0        	memw
4037d5b2:	7799      	s32i.n	a9, a7, 28
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037d5b4:	0103c2        	l8ui	a12, a3, 1
4037d5b7:	23b8      	l32i.n	a11, a3, 8
4037d5b9:	07ad      	mov.n	a10, a7
4037d5bb:	ffbbe5        	call8	4037d178 <gpspi_flash_ll_set_buffer_data>

    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037d5be:	0203a2        	l8ui	a10, a3, 2
4037d5c1:	119ad0        	slli	a9, a10, 3
    dev->user.usr_miso = bitlen > 0;
4037d5c4:	0020c0        	memw
4037d5c7:	4788      	l32i.n	a8, a7, 16
4037d5c9:	1b0c      	movi.n	a11, 1
4037d5cb:	83baa0        	moveqz	a11, a10, a10
4037d5ce:	01bb40        	slli	a11, a11, 28
4037d5d1:	dc8ac1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d5d4:	1088c0        	and	a8, a8, a12
4037d5d7:	2088b0        	or	a8, a8, a11
4037d5da:	0020c0        	memw
4037d5dd:	4789      	s32i.n	a8, a7, 16
    if (bitlen) {
4037d5df:	9a9c      	beqz.n	a10, 4037d5fc <spi_flash_hal_gpspi_common_command+0x120>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d5e1:	890b      	addi.n	a8, a9, -1
4037d5e3:	0020c0        	memw
4037d5e6:	7798      	l32i.n	a9, a7, 28
4037d5e8:	118820        	slli	a8, a8, 14
4037d5eb:	418e80        	srli	a8, a8, 14
4037d5ee:	d59290        	extui	a9, a9, 18, 14
4037d5f1:	0199e0        	slli	a9, a9, 18
4037d5f4:	209980        	or	a9, a9, a8
4037d5f7:	0020c0        	memw
4037d5fa:	7799      	s32i.n	a9, a7, 28
    dev->cmd.update = 1;
4037d5fc:	0020c0        	memw
4037d5ff:	0788      	l32i.n	a8, a7, 0
4037d601:	dceb91        	l32r	a9, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037d604:	208890        	or	a8, a8, a9
4037d607:	0020c0        	memw
4037d60a:	0789      	s32i.n	a8, a7, 0
    while (dev->cmd.update);
4037d60c:	0020c0        	memw
4037d60f:	0788      	l32i.n	a8, a7, 0
4037d611:	f7f877        	bbsi	a8, 23, 4037d60c <spi_flash_hal_gpspi_common_command+0x130>
    dev->cmd.usr = 1;
4037d614:	0020c0        	memw
4037d617:	0788      	l32i.n	a8, a7, 0
4037d619:	dca691        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037d61c:	208890        	or	a8, a8, a9
4037d61f:	0020c0        	memw
4037d622:	0789      	s32i.n	a8, a7, 0
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_PE_CMD) != 0) {
        pe_ops = true;
    }
    spi_flash_ll_user_start(dev, pe_ops);
    host->driver->poll_cmd_done(host);
4037d624:	002282        	l32i	a8, a2, 0
4037d627:	102882        	l32i	a8, a8, 64
4037d62a:	20a220        	or	a10, a2, a2
4037d62d:	0008e0        	callx8	a8
    if (trans->miso_len > 0) {
4037d630:	0203c2        	l8ui	a12, a3, 2
4037d633:	5c8c      	beqz.n	a12, 4037d63c <spi_flash_hal_gpspi_common_command+0x160>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037d635:	33b8      	l32i.n	a11, a3, 12
4037d637:	07ad      	mov.n	a10, a7
4037d639:	ffb7e5        	call8	4037d1b8 <gpspi_flash_ll_get_buffer_data>
    }
#if SOC_SPI_MEM_SUPPORT_WB_MODE_INDEPENDENT_CONTROL
    spi_flash_ll_wb_mode_enable(dev, false);
#endif
    return ESP_OK;
}
4037d63c:	020c      	movi.n	a2, 0
4037d63e:	f01d      	retw.n

4037d640 <spi_flash_hal_gpspi_read>:

esp_err_t spi_flash_hal_read(spi_flash_host_inst_t *host, void *buffer, uint32_t address, uint32_t read_len)
{
4037d640:	004136        	entry	a1, 32
4037d643:	02ad      	mov.n	a10, a2
    return ((spi_flash_hal_context_t*)host)->spi;
4037d645:	1278      	l32i.n	a7, a2, 4
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037d647:	0020c0        	memw
4037d64a:	4788      	l32i.n	a8, a7, 16
4037d64c:	1478e7        	bbci	a8, 30, 4037d664 <spi_flash_hal_gpspi_read+0x24>
4037d64f:	0020c0        	memw
4037d652:	5788      	l32i.n	a8, a7, 20
4037d654:	458b80        	extui	a8, a8, 27, 5
4037d657:	881b      	addi.n	a8, a8, 1
    spi_dev_t *dev = get_spi_dev(host);
    int bitlen = spi_flash_ll_get_addr_bitlen(dev);
    //Only 24-bit and 32-bit address are supported. The extra length are for M7-M0, which should be
    //filled with ones by the function below
    spi_flash_ll_set_usr_address(dev, address, bitlen & (~7));
4037d659:	897c      	movi.n	a9, -8
4037d65b:	108890        	and	a8, a8, a9
    uint32_t padding_ones = (bitlen == 32 ? 0 : UINT32_MAX >> bitlen);
4037d65e:	04c866        	bnei	a8, 32, 4037d666 <spi_flash_hal_gpspi_read+0x26>
4037d661:	000306        	j	4037d671 <spi_flash_hal_gpspi_read+0x31>
4037d664:	080c      	movi.n	a8, 0
4037d666:	f97c      	movi.n	a9, -1
4037d668:	400800        	ssr	a8
4037d66b:	919090        	srl	a9, a9
4037d66e:	000046        	j	4037d673 <spi_flash_hal_gpspi_read+0x33>
4037d671:	090c      	movi.n	a9, 0
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037d673:	e0c882        	addi	a8, a8, -32
4037d676:	608080        	neg	a8, a8
4037d679:	401800        	ssl	a8
4037d67c:	a14400        	sll	a4, a4
4037d67f:	204490        	or	a4, a4, a9
4037d682:	0020c0        	memw
4037d685:	1749      	s32i.n	a4, a7, 4
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037d687:	1185d0        	slli	a8, a5, 3
    dev->user.usr_miso = bitlen > 0;
4037d68a:	0020c0        	memw
4037d68d:	4798      	l32i.n	a9, a7, 16
4037d68f:	1b0c      	movi.n	a11, 1
4037d691:	83b880        	moveqz	a11, a8, a8
4037d694:	01bb40        	slli	a11, a11, 28
4037d697:	dc59c1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d69a:	1099c0        	and	a9, a9, a12
4037d69d:	2099b0        	or	a9, a9, a11
4037d6a0:	0020c0        	memw
4037d6a3:	4799      	s32i.n	a9, a7, 16
    if (bitlen) {
4037d6a5:	b89c      	beqz.n	a8, 4037d6c4 <spi_flash_hal_gpspi_read+0x84>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d6a7:	880b      	addi.n	a8, a8, -1
4037d6a9:	0020c0        	memw
4037d6ac:	072792        	l32i	a9, a7, 28
4037d6af:	118820        	slli	a8, a8, 14
4037d6b2:	418e80        	srli	a8, a8, 14
4037d6b5:	d59290        	extui	a9, a9, 18, 14
4037d6b8:	0199e0        	slli	a9, a9, 18
4037d6bb:	209980        	or	a9, a9, a8
4037d6be:	0020c0        	memw
4037d6c1:	076792        	s32i	a9, a7, 28
    dev->cmd.update = 1;
4037d6c4:	0020c0        	memw
4037d6c7:	0788      	l32i.n	a8, a7, 0
4037d6c9:	dcb991        	l32r	a9, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037d6cc:	208890        	or	a8, a8, a9
4037d6cf:	0020c0        	memw
4037d6d2:	0789      	s32i.n	a8, a7, 0
    while (dev->cmd.update);
4037d6d4:	0020c0        	memw
4037d6d7:	002782        	l32i	a8, a7, 0
4037d6da:	f6f877        	bbsi	a8, 23, 4037d6d4 <spi_flash_hal_gpspi_read+0x94>
    dev->cmd.usr = 1;
4037d6dd:	0020c0        	memw
4037d6e0:	002782        	l32i	a8, a7, 0
4037d6e3:	dc7491        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037d6e6:	208890        	or	a8, a8, a9
4037d6e9:	0020c0        	memw
4037d6ec:	006782        	s32i	a8, a7, 0
    spi_flash_ll_user_start(dev, false);
    host->driver->poll_cmd_done(host);
4037d6ef:	0a88      	l32i.n	a8, a10, 0
4037d6f1:	102882        	l32i	a8, a8, 64
4037d6f4:	0008e0        	callx8	a8
    if (read_len > 0) {
4037d6f7:	758c      	beqz.n	a5, 4037d702 <spi_flash_hal_gpspi_read+0xc2>
        spi_flash_ll_get_buffer_data(dev, buffer, read_len);
4037d6f9:	05cd      	mov.n	a12, a5
4037d6fb:	03bd      	mov.n	a11, a3
4037d6fd:	07ad      	mov.n	a10, a7
4037d6ff:	ffaba5        	call8	4037d1b8 <gpspi_flash_ll_get_buffer_data>
    }
    return ESP_OK;
}
4037d702:	020c      	movi.n	a2, 0
4037d704:	f01d      	retw.n
	...

4037d708 <spi_flash_hal_gpspi_poll_cmd_done>:
{
4037d708:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d70b:	1288      	l32i.n	a8, a2, 4
    return (dev->cmd.usr == 0);
4037d70d:	0020c0        	memw
4037d710:	0888      	l32i.n	a8, a8, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037d712:	f5f887        	bbsi	a8, 24, 4037d70b <spi_flash_hal_gpspi_poll_cmd_done+0x3>
}
4037d715:	f01d      	retw.n
	...

4037d718 <spi_flash_hal_gpspi_supports_direct_write>:
#define spi_flash_hal_read                      spi_flash_hal_gpspi_read

#include "spi_flash_hal_common.inc"

bool spi_flash_hal_gpspi_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
4037d718:	004136        	entry	a1, 32
    return true;
}
4037d71b:	120c      	movi.n	a2, 1
4037d71d:	f01d      	retw.n
	...

4037d720 <spi_flash_hal_gpspi_supports_direct_read>:

bool spi_flash_hal_gpspi_supports_direct_read(spi_flash_host_inst_t *host, const void *p)
{
4037d720:	004136        	entry	a1, 32
    return true;
}
4037d723:	120c      	movi.n	a2, 1
4037d725:	f01d      	retw.n
	...

4037d728 <spi_flash_hal_gpspi_check_status>:

uint32_t spi_flash_hal_gpspi_check_status(spi_flash_host_inst_t *host)
{
4037d728:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d72b:	1288      	l32i.n	a8, a2, 4
    return dev->cmd.usr == 0;
4037d72d:	0020c0        	memw
4037d730:	0828      	l32i.n	a2, a8, 0
4037d732:	052820        	extui	a2, a2, 24, 1
4037d735:	180c      	movi.n	a8, 1
4037d737:	302280        	xor	a2, a2, a8
    spi_dev_t *dev = get_spi_dev(host);
    return spi_flash_ll_host_idle(dev);
}
4037d73a:	042020        	extui	a2, a2, 0, 1
4037d73d:	f01d      	retw.n
	...

4037d740 <spimem_flash_ll_set_read_mode>:
{
4037d740:	006136        	entry	a1, 48
    ctrl.val = dev->ctrl.val;
4037d743:	0020c0        	memw
4037d746:	2288      	l32i.n	a8, a2, 8
4037d748:	0020c0        	memw
4037d74b:	0189      	s32i.n	a8, a1, 0
    ctrl.val &= ~(SPI_MEM_FREAD_QIO_M | SPI_MEM_FREAD_QUAD_M | SPI_MEM_FREAD_DIO_M | SPI_MEM_FREAD_DUAL_M | SPI_MEM_FCMD_OCT | SPI_MEM_FADDR_OCT | SPI_MEM_FDIN_OCT | SPI_MEM_FDOUT_OCT);
4037d74d:	0020c0        	memw
4037d750:	0188      	l32i.n	a8, a1, 0
4037d752:	ddfe91        	l32r	a9, 40374f4c <_iram_text_start+0xb48> (fe6fbd8f <_rtc_reserved_end+0x9e5fbd8f>)
4037d755:	108890        	and	a8, a8, a9
4037d758:	0020c0        	memw
4037d75b:	0189      	s32i.n	a8, a1, 0
    dev->ddr.fmem_ddr_en = 0;
4037d75d:	0020c0        	memw
4037d760:	382282        	l32i	a8, a2, 224
4037d763:	e97c      	movi.n	a9, -2
4037d765:	108890        	and	a8, a8, a9
4037d768:	0020c0        	memw
4037d76b:	386282        	s32i	a8, a2, 224
    ctrl.val |= SPI_MEM_FASTRD_MODE_M;
4037d76e:	0020c0        	memw
4037d771:	0188      	l32i.n	a8, a1, 0
4037d773:	dcc791        	l32r	a9, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037d776:	208890        	or	a8, a8, a9
4037d779:	0020c0        	memw
4037d77c:	0189      	s32i.n	a8, a1, 0
    switch (read_mode) {
4037d77e:	424326        	beqi	a3, 4, 4037d7c4 <spimem_flash_ll_set_read_mode+0x84>
4037d781:	1b53f6        	bgeui	a3, 5, 4037d7a0 <spimem_flash_ll_set_read_mode+0x60>
4037d784:	642326        	beqi	a3, 2, 4037d7ec <spimem_flash_ll_set_read_mode+0xac>
4037d787:	0d33f6        	bgeui	a3, 3, 4037d798 <spimem_flash_ll_set_read_mode+0x58>
4037d78a:	072316        	beqz	a3, 4037d800 <spimem_flash_ll_set_read_mode+0xc0>
4037d78d:	021366        	bnei	a3, 1, 4037d793 <spimem_flash_ll_set_read_mode+0x53>
4037d790:	004506        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
4037d793:	004386        	j	4037d8a5 <spimem_flash_ll_set_read_mode+0x165>
4037d796:	260000        	lsi	f0, a0, 152
4037d799:	863c33        	lsi	f3, a12, 0x218
4037d79c:	000041        	l32r	a4, 4033d79c <rom_rx_gain_force+0x337370>
4037d79f:	b32600        	movgez	a2, a6, a0
4037d7a2:	181c70        	lsxp	f1, a12, a7
4037d7a5:	029387        	bne	a3, a8, 4037d7ab <spimem_flash_ll_set_read_mode+0x6b>
4037d7a8:	002a06        	j	4037d854 <spimem_flash_ll_set_read_mode+0x114>
4037d7ab:	025326        	beqi	a3, 5, 4037d7b1 <spimem_flash_ll_set_read_mode+0x71>
4037d7ae:	003cc6        	j	4037d8a5 <spimem_flash_ll_set_read_mode+0x165>
        ctrl.fread_qio = 1;
4037d7b1:	0020c0        	memw
4037d7b4:	0188      	l32i.n	a8, a1, 0
4037d7b6:	dc3f91        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037d7b9:	208890        	or	a8, a8, a9
4037d7bc:	0020c0        	memw
4037d7bf:	0189      	s32i.n	a8, a1, 0
        break;
4037d7c1:	0038c6        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
        ctrl.fread_quad = 1;
4037d7c4:	0020c0        	memw
4037d7c7:	0188      	l32i.n	a8, a1, 0
4037d7c9:	dddb91        	l32r	a9, 40374f38 <_iram_text_start+0xb34> (100000 <UserFrameTotalSize+0xfff00>)
4037d7cc:	208890        	or	a8, a8, a9
4037d7cf:	0020c0        	memw
4037d7d2:	0189      	s32i.n	a8, a1, 0
        break;
4037d7d4:	003406        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
4037d7d7:	20c000        	or	a12, a0, a0
        ctrl.fread_dio = 1;
4037d7da:	018800        	slli	a8, a8, 32
4037d7dd:	dc7491        	l32r	a9, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037d7e0:	208890        	or	a8, a8, a9
4037d7e3:	0020c0        	memw
4037d7e6:	0189      	s32i.n	a8, a1, 0
        break;
4037d7e8:	002f06        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
4037d7eb:	20c000        	or	a12, a0, a0
        ctrl.fread_dual = 1;
4037d7ee:	018800        	slli	a8, a8, 32
4037d7f1:	db1791        	l32r	a9, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
4037d7f4:	208890        	or	a8, a8, a9
4037d7f7:	0020c0        	memw
4037d7fa:	0189      	s32i.n	a8, a1, 0
        break;
4037d7fc:	002a06        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
4037d7ff:	20c000        	or	a12, a0, a0
        ctrl.fastrd_mode = 0;
4037d802:	018800        	slli	a8, a8, 32
4037d805:	dca391        	l32r	a9, 40374a94 <_iram_text_start+0x690> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4037d808:	108890        	and	a8, a8, a9
4037d80b:	0020c0        	memw
4037d80e:	0189      	s32i.n	a8, a1, 0
        break;
4037d810:	002506        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
4037d813:	20c000        	or	a12, a0, a0
        ctrl.faddr_oct = 1;
4037d816:	018800        	slli	a8, a8, 32
4037d819:	094c      	movi.n	a9, 64
4037d81b:	208890        	or	a8, a8, a9
4037d81e:	0020c0        	memw
4037d821:	0189      	s32i.n	a8, a1, 0
        ctrl.fcmd_oct = 1;
4037d823:	0020c0        	memw
4037d826:	0188      	l32i.n	a8, a1, 0
4037d828:	00a292        	movi	a9, 0x200
4037d82b:	208890        	or	a8, a8, a9
4037d82e:	0020c0        	memw
4037d831:	0189      	s32i.n	a8, a1, 0
        ctrl.fdin_oct = 1;
4037d833:	0020c0        	memw
4037d836:	0188      	l32i.n	a8, a1, 0
4037d838:	092c      	movi.n	a9, 32
4037d83a:	208890        	or	a8, a8, a9
4037d83d:	0020c0        	memw
4037d840:	0189      	s32i.n	a8, a1, 0
        ctrl.fdout_oct = 1;
4037d842:	0020c0        	memw
4037d845:	0188      	l32i.n	a8, a1, 0
4037d847:	091c      	movi.n	a9, 16
4037d849:	208890        	or	a8, a8, a9
4037d84c:	0020c0        	memw
4037d84f:	0189      	s32i.n	a8, a1, 0
        break;
4037d851:	0014c6        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
        ctrl.faddr_oct = 1;
4037d854:	0020c0        	memw
4037d857:	0188      	l32i.n	a8, a1, 0
4037d859:	094c      	movi.n	a9, 64
4037d85b:	208890        	or	a8, a8, a9
4037d85e:	0020c0        	memw
4037d861:	0189      	s32i.n	a8, a1, 0
        ctrl.fcmd_oct = 1;
4037d863:	0020c0        	memw
4037d866:	0188      	l32i.n	a8, a1, 0
4037d868:	00a292        	movi	a9, 0x200
4037d86b:	208890        	or	a8, a8, a9
4037d86e:	0020c0        	memw
4037d871:	0189      	s32i.n	a8, a1, 0
        ctrl.fdin_oct = 1;
4037d873:	0020c0        	memw
4037d876:	0188      	l32i.n	a8, a1, 0
4037d878:	092c      	movi.n	a9, 32
4037d87a:	208890        	or	a8, a8, a9
4037d87d:	0020c0        	memw
4037d880:	0189      	s32i.n	a8, a1, 0
        ctrl.fdout_oct = 1;
4037d882:	0020c0        	memw
4037d885:	0188      	l32i.n	a8, a1, 0
4037d887:	091c      	movi.n	a9, 16
4037d889:	208890        	or	a8, a8, a9
4037d88c:	0020c0        	memw
4037d88f:	0189      	s32i.n	a8, a1, 0
        dev->ddr.fmem_ddr_en = 1;
4037d891:	0020c0        	memw
4037d894:	382282        	l32i	a8, a2, 224
4037d897:	190c      	movi.n	a9, 1
4037d899:	208890        	or	a8, a8, a9
4037d89c:	0020c0        	memw
4037d89f:	386282        	s32i	a8, a2, 224
        break;
4037d8a2:	000086        	j	4037d8a8 <spimem_flash_ll_set_read_mode+0x168>
        abort();
4037d8a5:	0243e5        	call8	4037fce4 <abort>
    dev->ctrl.val = ctrl.val;
4037d8a8:	0020c0        	memw
4037d8ab:	002182        	l32i	a8, a1, 0
4037d8ae:	0020c0        	memw
4037d8b1:	026282        	s32i	a8, a2, 8
}
4037d8b4:	000090        	retw
	...

4037d8b8 <spimem_flash_ll_get_source_freq_mhz>:
{
4037d8b8:	004136        	entry	a1, 32
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4037d8bb:	dbd481        	l32r	a8, 4037480c <_iram_text_start+0x408> (60003000 <SPIMEM0>)
4037d8be:	0020c0        	memw
4037d8c1:	3b2882        	l32i	a8, a8, 236
4037d8c4:	148080        	extui	a8, a8, 0, 2
4037d8c7:	102826        	beqi	a8, 2, 4037d8db <spimem_flash_ll_get_source_freq_mhz+0x23>
4037d8ca:	0738f6        	bgeui	a8, 3, 4037d8d5 <spimem_flash_ll_get_source_freq_mhz+0x1d>
4037d8cd:	389c      	beqz.n	a8, 4037d8e4 <spimem_flash_ll_get_source_freq_mhz+0x2c>
4037d8cf:	161826        	beqi	a8, 1, 4037d8e9 <spimem_flash_ll_get_source_freq_mhz+0x31>
4037d8d2:	000086        	j	4037d8d8 <spimem_flash_ll_get_source_freq_mhz+0x20>
4037d8d5:	173826        	beqi	a8, 3, 4037d8f0 <spimem_flash_ll_get_source_freq_mhz+0x38>
        abort();
4037d8d8:	0240a5        	call8	4037fce4 <abort>
        clock_val = 160;
4037d8db:	a0a022        	movi	a2, 160
4037d8de:	000446        	j	4037d8f3 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4037d8e1:	000000        	ill
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4037d8e4:	025c      	movi.n	a2, 80
4037d8e6:	000246        	j	4037d8f3 <spimem_flash_ll_get_source_freq_mhz+0x3b>
        clock_val = 120;
4037d8e9:	78a022        	movi	a2, 120
4037d8ec:	0000c6        	j	4037d8f3 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4037d8ef:	a02200        	addx4	a2, a2, a0
        clock_val = 240;
4037d8f2:	f01df0        	subx8	a1, a13, a15
4037d8f5:	000000        	ill

4037d8f8 <spimem_flash_ll_program_page>:
{
4037d8f8:	006136        	entry	a1, 48
    dev->user.usr_dummy = 0;
4037d8fb:	0020c0        	memw
4037d8fe:	6288      	l32i.n	a8, a2, 24
4037d900:	dbbd91        	l32r	a9, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d903:	108890        	and	a8, a8, a9
4037d906:	0020c0        	memw
4037d909:	6289      	s32i.n	a8, a2, 24
    int num_words = (length + 3) / 4;
4037d90b:	543b      	addi.n	a5, a4, 3
4037d90d:	415250        	srli	a5, a5, 2
    for (int i = 0; i < num_words; i++) {
4037d910:	060c      	movi.n	a6, 0
4037d912:	000a86        	j	4037d940 <spimem_flash_ll_program_page+0x48>
        uint32_t word = 0;
4037d915:	080c      	movi.n	a8, 0
4037d917:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037d919:	470c      	movi.n	a7, 4
4037d91b:	637470        	minu	a7, a4, a7
        memcpy(&word, buffer, word_len);
4037d91e:	07cd      	mov.n	a12, a7
4037d920:	20b330        	or	a11, a3, a3
4037d923:	20a110        	or	a10, a1, a1
4037d926:	daeb81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d929:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037d92c:	14c682        	addi	a8, a6, 20
4037d92f:	a08820        	addx4	a8, a8, a2
4037d932:	0198      	l32i.n	a9, a1, 0
4037d934:	0020c0        	memw
4037d937:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037d939:	c04470        	sub	a4, a4, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037d93c:	373a      	add.n	a3, a7, a3
    for (int i = 0; i < num_words; i++) {
4037d93e:	661b      	addi.n	a6, a6, 1
4037d940:	d12657        	blt	a6, a5, 4037d915 <spimem_flash_ll_program_page+0x1d>
    dev->cmd.flash_pp = 1;
4037d943:	0020c0        	memw
4037d946:	0288      	l32i.n	a8, a2, 0
4037d948:	db5e91        	l32r	a9, 403746c0 <_iram_text_start+0x2bc> (2000000 <UserFrameTotalSize+0x1ffff00>)
4037d94b:	208890        	or	a8, a8, a9
4037d94e:	0020c0        	memw
4037d951:	0289      	s32i.n	a8, a2, 0
}
4037d953:	f01d      	retw.n
4037d955:	000000        	ill

4037d958 <spi_flash_hal_configure_host_io_mode>:
{
4037d958:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d95b:	12a8      	l32i.n	a10, a2, 4
    io_mode = io_mode & 0xFFFF;
4037d95d:	f4b060        	extui	a11, a6, 0, 16
    dev->ctrl.fdummy_out = out_en;
4037d960:	0020c0        	memw
4037d963:	2a88      	l32i.n	a8, a10, 8
4037d965:	056f60        	extui	a6, a6, 31, 1
4037d968:	1166d0        	slli	a6, a6, 3
4037d96b:	797c      	movi.n	a9, -9
4037d96d:	108890        	and	a8, a8, a9
4037d970:	208860        	or	a8, a8, a6
4037d973:	0020c0        	memw
4037d976:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.q_pol = out_lev;
4037d978:	0020c0        	memw
4037d97b:	2a88      	l32i.n	a8, a10, 8
4037d97d:	dba091        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037d980:	208890        	or	a8, a8, a9
4037d983:	0020c0        	memw
4037d986:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.d_pol = out_lev;
4037d988:	0020c0        	memw
4037d98b:	2a88      	l32i.n	a8, a10, 8
4037d98d:	dbfc91        	l32r	a9, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
4037d990:	208890        	or	a8, a8, a9
4037d993:	0020c0        	memw
4037d996:	2a89      	s32i.n	a8, a10, 8
    if (command >= 0x100) {
4037d998:	ffa082        	movi	a8, 255
4037d99b:	62b837        	bgeu	a8, a3, 4037da01 <spi_flash_hal_configure_host_io_mode+0xa9>
    dev->user.usr_command = 1;
4037d99e:	0020c0        	memw
4037d9a1:	6a88      	l32i.n	a8, a10, 24
4037d9a3:	dade91        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d9a6:	208890        	or	a8, a8, a9
4037d9a9:	0020c0        	memw
4037d9ac:	6a89      	s32i.n	a8, a10, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
4037d9ae:	0020c0        	memw
4037d9b1:	8a88      	l32i.n	a8, a10, 32
4037d9b3:	0020c0        	memw
4037d9b6:	3189      	s32i.n	a8, a1, 12
4037d9b8:	0020c0        	memw
4037d9bb:	3188      	l32i.n	a8, a1, 12
4037d9bd:	f43030        	extui	a3, a3, 0, 16
4037d9c0:	f58080        	extui	a8, a8, 16, 16
4037d9c3:	118800        	slli	a8, a8, 16
4037d9c6:	208830        	or	a8, a8, a3
4037d9c9:	0020c0        	memw
4037d9cc:	3189      	s32i.n	a8, a1, 12
4037d9ce:	0020c0        	memw
4037d9d1:	3188      	l32i.n	a8, a1, 12
4037d9d3:	0020c0        	memw
4037d9d6:	8a89      	s32i.n	a8, a10, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037d9d8:	0020c0        	memw
4037d9db:	8a88      	l32i.n	a8, a10, 32
4037d9dd:	0020c0        	memw
4037d9e0:	2189      	s32i.n	a8, a1, 8
4037d9e2:	0020c0        	memw
4037d9e5:	2188      	l32i.n	a8, a1, 8
4037d9e7:	dd5891        	l32r	a9, 40374f48 <_iram_text_start+0xb44> (f0000000 <_rtc_reserved_end+0x8ff00000>)
4037d9ea:	208890        	or	a8, a8, a9
4037d9ed:	0020c0        	memw
4037d9f0:	2189      	s32i.n	a8, a1, 8
4037d9f2:	0020c0        	memw
4037d9f5:	2188      	l32i.n	a8, a1, 8
4037d9f7:	0020c0        	memw
4037d9fa:	8a89      	s32i.n	a8, a10, 32
}
4037d9fc:	001946        	j	4037da65 <spi_flash_hal_configure_host_io_mode+0x10d>
4037d9ff:	c00000        	sub	a0, a0, a0
    dev->user.usr_command = 1;
4037da02:	880020        	lsi	f2, a0, 0x220
4037da05:	916a      	add.n	a9, a1, a6
4037da07:	90dac5        	call0	4030e7b4 <rom_rx_gain_force+0x308388>
4037da0a:	2088      	l32i.n	a8, a0, 8
4037da0c:	0020c0        	memw
4037da0f:	6a89      	s32i.n	a8, a10, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
4037da11:	0020c0        	memw
4037da14:	8a88      	l32i.n	a8, a10, 32
4037da16:	0020c0        	memw
4037da19:	1189      	s32i.n	a8, a1, 4
4037da1b:	0020c0        	memw
4037da1e:	1188      	l32i.n	a8, a1, 4
4037da20:	f43030        	extui	a3, a3, 0, 16
4037da23:	f58080        	extui	a8, a8, 16, 16
4037da26:	118800        	slli	a8, a8, 16
4037da29:	208830        	or	a8, a8, a3
4037da2c:	0020c0        	memw
4037da2f:	1189      	s32i.n	a8, a1, 4
4037da31:	0020c0        	memw
4037da34:	1188      	l32i.n	a8, a1, 4
4037da36:	0020c0        	memw
4037da39:	8a89      	s32i.n	a8, a10, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037da3b:	0020c0        	memw
4037da3e:	8a88      	l32i.n	a8, a10, 32
4037da40:	0020c0        	memw
4037da43:	0189      	s32i.n	a8, a1, 0
4037da45:	0020c0        	memw
4037da48:	0188      	l32i.n	a8, a1, 0
4037da4a:	1188c0        	slli	a8, a8, 4
4037da4d:	418480        	srli	a8, a8, 4
4037da50:	db6691        	l32r	a9, 403747e8 <_iram_text_start+0x3e4> (70000000 <_rtc_reserved_end+0xff00000>)
4037da53:	208890        	or	a8, a8, a9
4037da56:	0020c0        	memw
4037da59:	0189      	s32i.n	a8, a1, 0
4037da5b:	0020c0        	memw
4037da5e:	0188      	l32i.n	a8, a1, 0
4037da60:	0020c0        	memw
4037da63:	8a89      	s32i.n	a8, a10, 32
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037da65:	e0c482        	addi	a8, a4, -32
4037da68:	0020c0        	memw
4037da6b:	fa98      	l32i.n	a9, a10, 60
4037da6d:	40f880        	nsau	a8, a8
4037da70:	418580        	srli	a8, a8, 5
4037da73:	888a      	add.n	a8, a8, a8
4037da75:	dc7c      	movi.n	a12, -3
4037da77:	1099c0        	and	a9, a9, a12
4037da7a:	208980        	or	a8, a9, a8
4037da7d:	0020c0        	memw
4037da80:	fa89      	s32i.n	a8, a10, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037da82:	940b      	addi.n	a9, a4, -1
4037da84:	0020c0        	memw
4037da87:	7a88      	l32i.n	a8, a10, 28
4037da89:	019960        	slli	a9, a9, 26
4037da8c:	1188a0        	slli	a8, a8, 6
4037da8f:	418680        	srli	a8, a8, 6
4037da92:	208890        	or	a8, a8, a9
4037da95:	0020c0        	memw
4037da98:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037da9a:	0020c0        	memw
4037da9d:	6a88      	l32i.n	a8, a10, 24
4037da9f:	190c      	movi.n	a9, 1
4037daa1:	839440        	moveqz	a9, a4, a4
4037daa4:	019920        	slli	a9, a9, 30
4037daa7:	db51c1        	l32r	a12, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037daaa:	1088c0        	and	a8, a8, a12
4037daad:	208890        	or	a8, a8, a9
4037dab0:	0020c0        	memw
4037dab3:	6a89      	s32i.n	a8, a10, 24
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037dab5:	0c0282        	l8ui	a8, a2, 12
4037dab8:	585a      	add.n	a5, a8, a5
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037daba:	0020c0        	memw
4037dabd:	6a88      	l32i.n	a8, a10, 24
4037dabf:	190c      	movi.n	a9, 1
4037dac1:	839550        	moveqz	a9, a5, a5
4037dac4:	019930        	slli	a9, a9, 29
4037dac7:	db4bc1        	l32r	a12, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037daca:	1088c0        	and	a8, a8, a12
4037dacd:	208890        	or	a8, a8, a9
4037dad0:	0020c0        	memw
4037dad3:	6a89      	s32i.n	a8, a10, 24
    if (dummy_n > 0) {
4037dad5:	659c      	beqz.n	a5, 4037daef <spi_flash_hal_configure_host_io_mode+0x197>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037dad7:	550b      	addi.n	a5, a5, -1
4037dad9:	0020c0        	memw
4037dadc:	7a88      	l32i.n	a8, a10, 28
4037dade:	545050        	extui	a5, a5, 0, 6
4037dae1:	c0af92        	movi	a9, -64
4037dae4:	108890        	and	a8, a8, a9
4037dae7:	208850        	or	a8, a8, a5
4037daea:	0020c0        	memw
4037daed:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_miso = bitlen > 0;
4037daef:	0020c0        	memw
4037daf2:	6a88      	l32i.n	a8, a10, 24
4037daf4:	db4291        	l32r	a9, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037daf7:	108890        	and	a8, a8, a9
4037dafa:	0020c0        	memw
4037dafd:	6a89      	s32i.n	a8, a10, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037daff:	0020c0        	memw
4037db02:	aa88      	l32i.n	a8, a10, 40
4037db04:	00ac92        	movi	a9, 0xfffffc00
4037db07:	108890        	and	a8, a8, a9
4037db0a:	0020c0        	memw
4037db0d:	aa89      	s32i.n	a8, a10, 40
    dev->user.usr_mosi = bitlen > 0;
4037db0f:	0020c0        	memw
4037db12:	6a88      	l32i.n	a8, a10, 24
4037db14:	db39c1        	l32r	a12, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037db17:	1088c0        	and	a8, a8, a12
4037db1a:	0020c0        	memw
4037db1d:	6a89      	s32i.n	a8, a10, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037db1f:	0020c0        	memw
4037db22:	9a88      	l32i.n	a8, a10, 36
4037db24:	108890        	and	a8, a8, a9
4037db27:	0020c0        	memw
4037db2a:	096a82        	s32i	a8, a10, 36
    spi_flash_ll_set_read_mode(dev, io_mode);
4037db2d:	ffc125        	call8	4037d740 <spimem_flash_ll_set_read_mode>
}
4037db30:	020c      	movi.n	a2, 0
4037db32:	f01d      	retw.n

4037db34 <spi_flash_hal_common_command>:
{
4037db34:	008136        	entry	a1, 64
4037db37:	028d      	mov.n	a8, a2
4037db39:	5129      	s32i.n	a2, a1, 20
    return ((spi_flash_hal_context_t*)host)->spi;
4037db3b:	1228      	l32i.n	a2, a2, 4
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037db3d:	58e8      	l32i.n	a14, a8, 20
    command = trans->command;
4037db3f:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037db42:	160372        	l8ui	a7, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037db45:	4388      	l32i.n	a8, a3, 16
4037db47:	016817        	bbci	a8, 1, 4037db4c <spi_flash_hal_common_command+0x18>
        io_mode = trans->io_mode;
4037db4a:	63e8      	l32i.n	a14, a3, 24
    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037db4c:	51a8      	l32i.n	a10, a1, 20
4037db4e:	0a88      	l32i.n	a8, a10, 0
4037db50:	f888      	l32i.n	a8, a8, 60
4037db52:	07dd      	mov.n	a13, a7
4037db54:	0303c2        	l8ui	a12, a3, 3
4037db57:	0008e0        	callx8	a8
    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037db5a:	1388      	l32i.n	a8, a3, 4
    dev->addr = addr;
4037db5c:	0020c0        	memw
4037db5f:	1289      	s32i.n	a8, a2, 4
    if (trans->miso_len == 0) {
4037db61:	020382        	l8ui	a8, a3, 2
4037db64:	48fc      	bnez.n	a8, 4037db9c <spi_flash_hal_common_command+0x68>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037db66:	0020c0        	memw
4037db69:	6288      	l32i.n	a8, a2, 24
4037db6b:	190c      	movi.n	a9, 1
4037db6d:	839770        	moveqz	a9, a7, a7
4037db70:	019930        	slli	a9, a9, 29
4037db73:	db20a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037db76:	1088a0        	and	a8, a8, a10
4037db79:	208890        	or	a8, a8, a9
4037db7c:	0020c0        	memw
4037db7f:	6289      	s32i.n	a8, a2, 24
    if (dummy_n > 0) {
4037db81:	779c      	beqz.n	a7, 4037db9c <spi_flash_hal_common_command+0x68>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037db83:	770b      	addi.n	a7, a7, -1
4037db85:	0020c0        	memw
4037db88:	7288      	l32i.n	a8, a2, 28
4037db8a:	547070        	extui	a7, a7, 0, 6
4037db8d:	c0af92        	movi	a9, -64
4037db90:	108890        	and	a8, a8, a9
4037db93:	208870        	or	a8, a8, a7
4037db96:	0020c0        	memw
4037db99:	076282        	s32i	a8, a2, 28
    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037db9c:	0103a2        	l8ui	a10, a3, 1
4037db9f:	118ad0        	slli	a8, a10, 3
    dev->user.usr_mosi = bitlen > 0;
4037dba2:	0020c0        	memw
4037dba5:	6298      	l32i.n	a9, a2, 24
4037dba7:	1b0c      	movi.n	a11, 1
4037dba9:	83baa0        	moveqz	a11, a10, a10
4037dbac:	01bb50        	slli	a11, a11, 27
4037dbaf:	db12c1        	l32r	a12, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037dbb2:	1099c0        	and	a9, a9, a12
4037dbb5:	2099b0        	or	a9, a9, a11
4037dbb8:	0020c0        	memw
4037dbbb:	6299      	s32i.n	a9, a2, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037dbbd:	7a8c      	beqz.n	a10, 4037dbc8 <spi_flash_hal_common_command+0x94>
4037dbbf:	880b      	addi.n	a8, a8, -1
4037dbc1:	948080        	extui	a8, a8, 0, 10
4037dbc4:	000086        	j	4037dbca <spi_flash_hal_common_command+0x96>
4037dbc7:	080c00        	lsx	f0, a12, a0
4037dbca:	0020c0        	memw
4037dbcd:	9298      	l32i.n	a9, a2, 36
4037dbcf:	00aca2        	movi	a10, 0xfffffc00
4037dbd2:	1099a0        	and	a9, a9, a10
4037dbd5:	208890        	or	a8, a8, a9
4037dbd8:	0020c0        	memw
4037dbdb:	9289      	s32i.n	a8, a2, 36
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037dbdd:	2348      	l32i.n	a4, a3, 8
4037dbdf:	010352        	l8ui	a5, a3, 1
    int num_words = (length + 3) / 4;
4037dbe2:	853b      	addi.n	a8, a5, 3
4037dbe4:	418280        	srli	a8, a8, 2
4037dbe7:	4189      	s32i.n	a8, a1, 16
    for (int i = 0; i < num_words; i++) {
4037dbe9:	060c      	movi.n	a6, 0
4037dbeb:	000a46        	j	4037dc18 <spi_flash_hal_common_command+0xe4>
        uint32_t word = 0;
4037dbee:	080c      	movi.n	a8, 0
4037dbf0:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037dbf2:	470c      	movi.n	a7, 4
4037dbf4:	637570        	minu	a7, a5, a7
        memcpy(&word, buffer, word_len);
4037dbf7:	07cd      	mov.n	a12, a7
4037dbf9:	04bd      	mov.n	a11, a4
4037dbfb:	20a110        	or	a10, a1, a1
4037dbfe:	da3581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dc01:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037dc04:	14c682        	addi	a8, a6, 20
4037dc07:	a08820        	addx4	a8, a8, a2
4037dc0a:	0198      	l32i.n	a9, a1, 0
4037dc0c:	0020c0        	memw
4037dc0f:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037dc11:	c05570        	sub	a5, a5, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037dc14:	474a      	add.n	a4, a7, a4
    for (int i = 0; i < num_words; i++) {
4037dc16:	661b      	addi.n	a6, a6, 1
4037dc18:	4188      	l32i.n	a8, a1, 16
4037dc1a:	d02687        	blt	a6, a8, 4037dbee <spi_flash_hal_common_command+0xba>
    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037dc1d:	0203a2        	l8ui	a10, a3, 2
4037dc20:	118ad0        	slli	a8, a10, 3
    dev->user.usr_miso = bitlen > 0;
4037dc23:	0020c0        	memw
4037dc26:	6298      	l32i.n	a9, a2, 24
4037dc28:	1b0c      	movi.n	a11, 1
4037dc2a:	83baa0        	moveqz	a11, a10, a10
4037dc2d:	01bb40        	slli	a11, a11, 28
4037dc30:	daf3c1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037dc33:	1099c0        	and	a9, a9, a12
4037dc36:	2099b0        	or	a9, a9, a11
4037dc39:	0020c0        	memw
4037dc3c:	6299      	s32i.n	a9, a2, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037dc3e:	6a8c      	beqz.n	a10, 4037dc48 <spi_flash_hal_common_command+0x114>
4037dc40:	880b      	addi.n	a8, a8, -1
4037dc42:	948080        	extui	a8, a8, 0, 10
4037dc45:	000046        	j	4037dc4a <spi_flash_hal_common_command+0x116>
4037dc48:	080c      	movi.n	a8, 0
4037dc4a:	0020c0        	memw
4037dc4d:	a298      	l32i.n	a9, a2, 40
4037dc4f:	00aca2        	movi	a10, 0xfffffc00
4037dc52:	1099a0        	and	a9, a9, a10
4037dc55:	208890        	or	a8, a8, a9
4037dc58:	0020c0        	memw
4037dc5b:	a289      	s32i.n	a8, a2, 40
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_PE_CMD) != 0) {
4037dc5d:	4388      	l32i.n	a8, a3, 16
4037dc5f:	06e837        	bbsi	a8, 3, 4037dc69 <spi_flash_hal_common_command+0x135>
    uint32_t usr_pe = (pe_ops ? 0x60000 : 0x40000);
4037dc62:	dae791        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037dc65:	0000c6        	j	4037dc6c <spi_flash_hal_common_command+0x138>
4037dc68:	4a9100        	madd.s	f9, f1, f0
4037dc6b:	c0db      	addi.n	a12, a0, 13
    dev->cmd.val |= usr_pe;
4037dc6d:	880020        	lsi	f2, a0, 0x220
4037dc70:	889002        	l16si	a0, a0, 0x110
4037dc73:	20c020        	or	a12, a0, a2
4037dc76:	028900        	andb	b8, b9, b0
    host->driver->poll_cmd_done(host);
4037dc79:	51a8      	l32i.n	a10, a1, 20
4037dc7b:	002a82        	l32i	a8, a10, 0
4037dc7e:	102882        	l32i	a8, a8, 64
4037dc81:	0008e0        	callx8	a8
    if (trans->miso_len > 0) {
4037dc84:	020342        	l8ui	a4, a3, 2
4037dc87:	052416        	beqz	a4, 4037dcdd <spi_flash_hal_common_command+0x1a9>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037dc8a:	3358      	l32i.n	a5, a3, 12
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037dc8c:	148050        	extui	a8, a5, 0, 2
4037dc8f:	58dc      	bnez.n	a8, 4037dca8 <spi_flash_hal_common_command+0x174>
4037dc91:	148040        	extui	a8, a4, 0, 2
4037dc94:	08dc      	bnez.n	a8, 4037dca8 <spi_flash_hal_common_command+0x174>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037dc96:	04cd      	mov.n	a12, a4
4037dc98:	58c2b2        	addi	a11, a2, 88
4037dc9b:	20a550        	or	a10, a5, a5
4037dc9e:	da0d81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dca1:	0008e0        	callx8	a8
4037dca4:	000d46        	j	4037dcdd <spi_flash_hal_common_command+0x1a9>
4037dca7:	043d00        	extui	a3, a0, 13, 1
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dcaa:	060c      	movi.n	a6, 0
4037dcac:	000946        	j	4037dcd5 <spi_flash_hal_common_command+0x1a1>
4037dcaf:	470c00        	lsi	f0, a12, 0x11c
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037dcb2:	637370        	minu	a7, a3, a7
            uint32_t word = dev->data_buf[i];
4037dcb5:	14c682        	addi	a8, a6, 20
4037dcb8:	a08820        	addx4	a8, a8, a2
4037dcbb:	0020c0        	memw
4037dcbe:	2888      	l32i.n	a8, a8, 8
4037dcc0:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037dcc2:	07cd      	mov.n	a12, a7
4037dcc4:	01bd      	mov.n	a11, a1
4037dcc6:	05ad      	mov.n	a10, a5
4037dcc8:	da0381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dccb:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037dcce:	575a      	add.n	a5, a7, a5
            copy_len -= word_len;
4037dcd0:	c03370        	sub	a3, a3, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dcd3:	661b      	addi.n	a6, a6, 1
4037dcd5:	843b      	addi.n	a8, a4, 3
4037dcd7:	418280        	srli	a8, a8, 2
4037dcda:	d23687        	bltu	a6, a8, 4037dcb0 <spi_flash_hal_common_command+0x17c>
}
4037dcdd:	020c      	movi.n	a2, 0
4037dcdf:	f01d      	retw.n
4037dce1:	000000        	ill

4037dce4 <spi_flash_hal_read>:
{
4037dce4:	006136        	entry	a1, 48
4037dce7:	02ad      	mov.n	a10, a2
4037dce9:	052d      	mov.n	a2, a5
    return ((spi_flash_hal_context_t*)host)->spi;
4037dceb:	1a58      	l32i.n	a5, a10, 4
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037dced:	0020c0        	memw
4037dcf0:	062582        	l32i	a8, a5, 24
4037dcf3:	0578e7        	bbci	a8, 30, 4037dcfc <spi_flash_hal_read+0x18>
4037dcf6:	0020c0        	memw
4037dcf9:	072582        	l32i	a8, a5, 28
    dev->addr = addr;
4037dcfc:	0020c0        	memw
4037dcff:	1549      	s32i.n	a4, a5, 4
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037dd01:	1182d0        	slli	a8, a2, 3
    dev->user.usr_miso = bitlen > 0;
4037dd04:	0020c0        	memw
4037dd07:	6598      	l32i.n	a9, a5, 24
4037dd09:	1b0c      	movi.n	a11, 1
4037dd0b:	83b880        	moveqz	a11, a8, a8
4037dd0e:	01bb40        	slli	a11, a11, 28
4037dd11:	dabac1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037dd14:	1099c0        	and	a9, a9, a12
4037dd17:	2099b0        	or	a9, a9, a11
4037dd1a:	0020c0        	memw
4037dd1d:	6599      	s32i.n	a9, a5, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037dd1f:	688c      	beqz.n	a8, 4037dd29 <spi_flash_hal_read+0x45>
4037dd21:	880b      	addi.n	a8, a8, -1
4037dd23:	948080        	extui	a8, a8, 0, 10
4037dd26:	000046        	j	4037dd2b <spi_flash_hal_read+0x47>
4037dd29:	080c      	movi.n	a8, 0
4037dd2b:	0020c0        	memw
4037dd2e:	a598      	l32i.n	a9, a5, 40
4037dd30:	00acb2        	movi	a11, 0xfffffc00
4037dd33:	1099b0        	and	a9, a9, a11
4037dd36:	208890        	or	a8, a8, a9
4037dd39:	0020c0        	memw
4037dd3c:	a589      	s32i.n	a8, a5, 40
    dev->cmd.val |= usr_pe;
4037dd3e:	0020c0        	memw
4037dd41:	0588      	l32i.n	a8, a5, 0
4037dd43:	daaf91        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037dd46:	208890        	or	a8, a8, a9
4037dd49:	0020c0        	memw
4037dd4c:	006582        	s32i	a8, a5, 0
    host->driver->poll_cmd_done(host);
4037dd4f:	002a82        	l32i	a8, a10, 0
4037dd52:	102882        	l32i	a8, a8, 64
4037dd55:	0008e0        	callx8	a8
    if (read_len > 0) {
4037dd58:	051216        	beqz	a2, 4037ddad <spi_flash_hal_read+0xc9>
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037dd5b:	148030        	extui	a8, a3, 0, 2
4037dd5e:	68dc      	bnez.n	a8, 4037dd78 <spi_flash_hal_read+0x94>
4037dd60:	148020        	extui	a8, a2, 0, 2
4037dd63:	18dc      	bnez.n	a8, 4037dd78 <spi_flash_hal_read+0x94>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037dd65:	20c220        	or	a12, a2, a2
4037dd68:	58c5b2        	addi	a11, a5, 88
4037dd6b:	20a330        	or	a10, a3, a3
4037dd6e:	d9d981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dd71:	0008e0        	callx8	a8
4037dd74:	000d46        	j	4037ddad <spi_flash_hal_read+0xc9>
4037dd77:	024d00        	andb	b4, b13, b0
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dd7a:	060c      	movi.n	a6, 0
4037dd7c:	000946        	j	4037dda5 <spi_flash_hal_read+0xc1>
4037dd7f:	470c00        	lsi	f0, a12, 0x11c
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037dd82:	637470        	minu	a7, a4, a7
            uint32_t word = dev->data_buf[i];
4037dd85:	14c682        	addi	a8, a6, 20
4037dd88:	a08850        	addx4	a8, a8, a5
4037dd8b:	0020c0        	memw
4037dd8e:	2888      	l32i.n	a8, a8, 8
4037dd90:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037dd92:	07cd      	mov.n	a12, a7
4037dd94:	01bd      	mov.n	a11, a1
4037dd96:	03ad      	mov.n	a10, a3
4037dd98:	d9cf81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dd9b:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037dd9e:	373a      	add.n	a3, a7, a3
            copy_len -= word_len;
4037dda0:	c04470        	sub	a4, a4, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dda3:	661b      	addi.n	a6, a6, 1
4037dda5:	823b      	addi.n	a8, a2, 3
4037dda7:	418280        	srli	a8, a8, 2
4037ddaa:	d23687        	bltu	a6, a8, 4037dd80 <spi_flash_hal_read+0x9c>
}
4037ddad:	020c      	movi.n	a2, 0
4037ddaf:	f01d      	retw.n
4037ddb1:	000000        	ill

4037ddb4 <spi_flash_hal_erase_chip>:
//  - MEMSPI
//  - SPI1~3 on ESP32/S2/S3/C3/H4/C2
// The common part is in spi_flash_hal_common.inc

void spi_flash_hal_erase_chip(spi_flash_host_inst_t *host)
{
4037ddb4:	004136        	entry	a1, 32
4037ddb7:	02ad      	mov.n	a10, a2
    return ((spi_flash_hal_context_t*)host)->spi;
4037ddb9:	1298      	l32i.n	a9, a2, 4
    dev->cmd.flash_ce = 1;
4037ddbb:	0020c0        	memw
4037ddbe:	0988      	l32i.n	a8, a9, 0
4037ddc0:	dc64b1        	l32r	a11, 40374f50 <_iram_text_start+0xb4c> (400000 <UserFrameTotalSize+0x3fff00>)
4037ddc3:	2088b0        	or	a8, a8, a11
4037ddc6:	0020c0        	memw
4037ddc9:	0989      	s32i.n	a8, a9, 0
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_erase_chip(dev);
#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037ddcb:	6288      	l32i.n	a8, a2, 24
4037ddcd:	07e807        	bbsi	a8, 0, 4037ddd8 <spi_flash_hal_erase_chip+0x24>
        host->driver->poll_cmd_done(host);
4037ddd0:	0288      	l32i.n	a8, a2, 0
4037ddd2:	102882        	l32i	a8, a8, 64
4037ddd5:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037ddd8:	f01d      	retw.n
	...

4037dddc <spi_flash_hal_erase_sector>:

// Only support 24bit address
void spi_flash_hal_erase_sector(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037dddc:	004136        	entry	a1, 32
4037dddf:	02ad      	mov.n	a10, a2
4037dde1:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037dde3:	0020c0        	memw
4037dde6:	f898      	l32i.n	a9, a8, 60
4037dde8:	db7c      	movi.n	a11, -3
4037ddea:	1099b0        	and	a9, a9, a11
4037dded:	0020c0        	memw
4037ddf0:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037ddf2:	0020c0        	memw
4037ddf5:	7898      	l32i.n	a9, a8, 28
4037ddf7:	1199a0        	slli	a9, a9, 6
4037ddfa:	419690        	srli	a9, a9, 6
4037ddfd:	dc55b1        	l32r	a11, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
4037de00:	2099b0        	or	a9, a9, a11
4037de03:	0020c0        	memw
4037de06:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037de08:	0020c0        	memw
4037de0b:	6898      	l32i.n	a9, a8, 24
4037de0d:	d9f9b1        	l32r	a11, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037de10:	2099b0        	or	a9, a9, a11
4037de13:	0020c0        	memw
4037de16:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037de18:	113380        	slli	a3, a3, 8
4037de1b:	413830        	srli	a3, a3, 8
    dev->addr = addr;
4037de1e:	0020c0        	memw
4037de21:	1839      	s32i.n	a3, a8, 4
    dev->ctrl.val = 0;
4037de23:	090c      	movi.n	a9, 0
4037de25:	0020c0        	memw
4037de28:	2899      	s32i.n	a9, a8, 8
    dev->cmd.flash_se = 1;
4037de2a:	0020c0        	memw
4037de2d:	0898      	l32i.n	a9, a8, 0
4037de2f:	daa1b1        	l32r	a11, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037de32:	2099b0        	or	a9, a9, a11
4037de35:	0020c0        	memw
4037de38:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_sector(dev);

#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037de3a:	6288      	l32i.n	a8, a2, 24
4037de3c:	08e807        	bbsi	a8, 0, 4037de48 <spi_flash_hal_erase_sector+0x6c>
        host->driver->poll_cmd_done(host);
4037de3f:	002282        	l32i	a8, a2, 0
4037de42:	102882        	l32i	a8, a8, 64
4037de45:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037de48:	f01d      	retw.n
	...

4037de4c <spi_flash_hal_erase_block>:

// Only support 24bit address
void spi_flash_hal_erase_block(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037de4c:	004136        	entry	a1, 32
4037de4f:	02ad      	mov.n	a10, a2
4037de51:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037de53:	0020c0        	memw
4037de56:	f898      	l32i.n	a9, a8, 60
4037de58:	db7c      	movi.n	a11, -3
4037de5a:	1099b0        	and	a9, a9, a11
4037de5d:	0020c0        	memw
4037de60:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037de62:	0020c0        	memw
4037de65:	7898      	l32i.n	a9, a8, 28
4037de67:	1199a0        	slli	a9, a9, 6
4037de6a:	419690        	srli	a9, a9, 6
4037de6d:	dc39b1        	l32r	a11, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
4037de70:	2099b0        	or	a9, a9, a11
4037de73:	0020c0        	memw
4037de76:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037de78:	0020c0        	memw
4037de7b:	6898      	l32i.n	a9, a8, 24
4037de7d:	d9ddb1        	l32r	a11, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037de80:	2099b0        	or	a9, a9, a11
4037de83:	0020c0        	memw
4037de86:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037de88:	113380        	slli	a3, a3, 8
4037de8b:	413830        	srli	a3, a3, 8
    dev->addr = addr;
4037de8e:	0020c0        	memw
4037de91:	1839      	s32i.n	a3, a8, 4
    dev->cmd.flash_be = 1;
4037de93:	0020c0        	memw
4037de96:	0898      	l32i.n	a9, a8, 0
4037de98:	dac6b1        	l32r	a11, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037de9b:	2099b0        	or	a9, a9, a11
4037de9e:	0020c0        	memw
4037dea1:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_block(dev);
#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037dea3:	6288      	l32i.n	a8, a2, 24
4037dea5:	07e807        	bbsi	a8, 0, 4037deb0 <spi_flash_hal_erase_block+0x64>
        host->driver->poll_cmd_done(host);
4037dea8:	0288      	l32i.n	a8, a2, 0
4037deaa:	102882        	l32i	a8, a8, 64
4037dead:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037deb0:	f01d      	retw.n
	...

4037deb4 <spi_flash_hal_program_page>:

// Only support 24bit address
void spi_flash_hal_program_page(spi_flash_host_inst_t *host, const void *buffer, uint32_t address, uint32_t length)
{
4037deb4:	004136        	entry	a1, 32
4037deb7:	03bd      	mov.n	a11, a3
4037deb9:	05cd      	mov.n	a12, a5
4037debb:	12a8      	l32i.n	a10, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037debd:	0020c0        	memw
4037dec0:	fa88      	l32i.n	a8, a10, 60
4037dec2:	d97c      	movi.n	a9, -3
4037dec4:	108890        	and	a8, a8, a9
4037dec7:	0020c0        	memw
4037deca:	fa89      	s32i.n	a8, a10, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037decc:	0020c0        	memw
4037decf:	7a88      	l32i.n	a8, a10, 28
4037ded1:	1188a0        	slli	a8, a8, 6
4037ded4:	418680        	srli	a8, a8, 6
4037ded7:	dc1f91        	l32r	a9, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
4037deda:	208890        	or	a8, a8, a9
4037dedd:	0020c0        	memw
4037dee0:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037dee2:	0020c0        	memw
4037dee5:	6a88      	l32i.n	a8, a10, 24
4037dee7:	d9c391        	l32r	a9, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037deea:	208890        	or	a8, a8, a9
4037deed:	0020c0        	memw
4037def0:	6a89      	s32i.n	a8, a10, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, (address & ADDRESS_MASK_24BIT) | (length << 24));
4037def2:	114480        	slli	a4, a4, 8
4037def5:	414840        	srli	a4, a4, 8
4037def8:	018580        	slli	a8, a5, 24
4037defb:	204480        	or	a4, a4, a8
    dev->addr = addr;
4037defe:	0020c0        	memw
4037df01:	1a49      	s32i.n	a4, a10, 4
    spi_flash_ll_program_page(dev, buffer, length);
4037df03:	ff9f65        	call8	4037d8f8 <spimem_flash_ll_program_page>
    host->driver->poll_cmd_done(host);
4037df06:	0288      	l32i.n	a8, a2, 0
4037df08:	102882        	l32i	a8, a8, 64
4037df0b:	02ad      	mov.n	a10, a2
4037df0d:	0008e0        	callx8	a8
}
4037df10:	f01d      	retw.n
	...

4037df14 <spi_flash_hal_set_write_protect>:

esp_err_t spi_flash_hal_set_write_protect(spi_flash_host_inst_t *host, bool wp)
{
4037df14:	004136        	entry	a1, 32
4037df17:	02ad      	mov.n	a10, a2
4037df19:	743030        	extui	a3, a3, 0, 8
4037df1c:	1288      	l32i.n	a8, a2, 4
    if (wp) {
4037df1e:	239c      	beqz.n	a3, 4037df34 <spi_flash_hal_set_write_protect+0x20>
        dev->cmd.flash_wrdi = 1;
4037df20:	0020c0        	memw
4037df23:	0898      	l32i.n	a9, a8, 0
4037df25:	daacb1        	l32r	a11, 403749d8 <_iram_text_start+0x5d4> (20000000 <UserFrameTotalSize+0x1fffff00>)
4037df28:	2099b0        	or	a9, a9, a11
4037df2b:	0020c0        	memw
4037df2e:	0899      	s32i.n	a9, a8, 0
4037df30:	000406        	j	4037df44 <spi_flash_hal_set_write_protect+0x30>
4037df33:	20c000        	or	a12, a0, a0
        dev->cmd.flash_wren = 1;
4037df36:	089800        	lsx	f9, a8, a0
4037df39:	d9aeb1        	l32r	a11, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037df3c:	2099b0        	or	a9, a9, a11
4037df3f:	0020c0        	memw
4037df42:	0899      	s32i.n	a9, a8, 0
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_write_protect(dev, wp);
    host->driver->poll_cmd_done(host);
4037df44:	0a88      	l32i.n	a8, a10, 0
4037df46:	102882        	l32i	a8, a8, 64
4037df49:	0008e0        	callx8	a8
    return ESP_OK;
}
4037df4c:	020c      	movi.n	a2, 0
4037df4e:	f01d      	retw.n

4037df50 <spi_flash_hal_setup_read_suspend>:
    //status and sus_status should be mutual exclusion
    return (status | sus_status);
}

esp_err_t spi_flash_hal_setup_read_suspend(spi_flash_host_inst_t *host, const spi_flash_sus_cmd_conf *sus_conf)
{
4037df50:	006136        	entry	a1, 48
#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
    spi_mem_dev_t *dev = (spi_mem_dev_t *)spi_flash_ll_get_hw(SPI1_HOST);
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    memcpy(&(ctx->sus_cfg), sus_conf, sizeof(spi_flash_sus_cmd_conf));
4037df53:	8c0c      	movi.n	a12, 8
4037df55:	03bd      	mov.n	a11, a3
4037df57:	1cc2a2        	addi	a10, a2, 28
4037df5a:	d95e81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037df5d:	0008e0        	callx8	a8
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_sus_ctrl, flash_pes_command, sus_cmd);
4037df60:	da2091        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037df63:	0020c0        	memw
4037df66:	282982        	l32i	a8, a9, 160
4037df69:	0020c0        	memw
4037df6c:	0189      	s32i.n	a8, a1, 0
4037df6e:	0020c0        	memw
4037df71:	0188      	l32i.n	a8, a1, 0
4037df73:	0503a2        	l8ui	a10, a3, 5
4037df76:	11aa70        	slli	a10, a10, 9
4037df79:	dbf7b1        	l32r	a11, 40374f58 <_iram_text_start+0xb54> (fffe01ff <_rtc_reserved_end+0x9fee01ff>)
4037df7c:	1088b0        	and	a8, a8, a11
4037df7f:	2088a0        	or	a8, a8, a10
4037df82:	0020c0        	memw
4037df85:	0189      	s32i.n	a8, a1, 0
4037df87:	0020c0        	memw
4037df8a:	0188      	l32i.n	a8, a1, 0
4037df8c:	0020c0        	memw
4037df8f:	286982        	s32i	a8, a9, 160
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_sus_ctrl, flash_per_command, res_cmd);
4037df92:	0020c0        	memw
4037df95:	282982        	l32i	a8, a9, 160
4037df98:	0020c0        	memw
4037df9b:	1189      	s32i.n	a8, a1, 4
4037df9d:	0020c0        	memw
4037dfa0:	1188      	l32i.n	a8, a1, 4
4037dfa2:	0603a2        	l8ui	a10, a3, 6
4037dfa5:	aaaa      	add.n	a10, a10, a10
4037dfa7:	01aeb2        	movi	a11, 0xfffffe01
4037dfaa:	1088b0        	and	a8, a8, a11
4037dfad:	2088a0        	or	a8, a8, a10
4037dfb0:	0020c0        	memw
4037dfb3:	1189      	s32i.n	a8, a1, 4
4037dfb5:	0020c0        	memw
4037dfb8:	1188      	l32i.n	a8, a1, 4
4037dfba:	0020c0        	memw
4037dfbd:	286982        	s32i	a8, a9, 160
    spimem_flash_ll_set_read_sus_status(dev, sus_conf->sus_mask);
    spimem_flash_ll_rd_sus_cmd_setup(dev, sus_conf->cmd_rdsr);
#endif // SOC_SPI_MEM_SUPPORT_CHECK_SUS
#endif // SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
    return ESP_OK;
}
4037dfc0:	020c      	movi.n	a2, 0
4037dfc2:	f01d      	retw.n

4037dfc4 <spi_flash_hal_setup_auto_suspend_mode>:

#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
void spi_flash_hal_setup_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037dfc4:	006136        	entry	a1, 48
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    bool pes_waiti_delay = ctx->auto_waiti_pes ? false : true;
4037dfc7:	2d02a2        	l8ui	a10, a2, 45
4037dfca:	180c      	movi.n	a8, 1
4037dfcc:	30aa80        	xor	a10, a10, a8
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05);
4037dfcf:	da0481        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037dfd2:	0020c0        	memw
4037dfd5:	262892        	l32i	a9, a8, 152
4037dfd8:	0020c0        	memw
4037dfdb:	0199      	s32i.n	a9, a1, 0
4037dfdd:	0020c0        	memw
4037dfe0:	0198      	l32i.n	a9, a1, 0
4037dfe2:	03acb2        	movi	a11, 0xfffffc03
4037dfe5:	1099b0        	and	a9, a9, a11
4037dfe8:	4b1c      	movi.n	a11, 20
4037dfea:	2099b0        	or	a9, a9, a11
4037dfed:	0020c0        	memw
4037dff0:	0199      	s32i.n	a9, a1, 0
4037dff2:	0020c0        	memw
4037dff5:	0198      	l32i.n	a9, a1, 0
4037dff7:	0020c0        	memw
4037dffa:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = (per_waiti | pes_waiti);  // enable auto wait-idle function.
4037dffd:	0020c0        	memw
4037e000:	262892        	l32i	a9, a8, 152
4037e003:	1b0c      	movi.n	a11, 1
4037e005:	2099b0        	or	a9, a9, a11
4037e008:	0020c0        	memw
4037e00b:	266892        	s32i	a9, a8, 152
    dev->flash_sus_cmd.flash_per_wait_en = per_waiti;
4037e00e:	0020c0        	memw
4037e011:	272892        	l32i	a9, a8, 156
4037e014:	4b0c      	movi.n	a11, 4
4037e016:	2099b0        	or	a9, a9, a11
4037e019:	0020c0        	memw
4037e01c:	276892        	s32i	a9, a8, 156
    dev->flash_sus_cmd.flash_pes_wait_en = pes_waiti;
4037e01f:	0020c0        	memw
4037e022:	272892        	l32i	a9, a8, 156
4037e025:	04a0a0        	extui	a10, a10, 0, 1
4037e028:	11aad0        	slli	a10, a10, 3
4037e02b:	7b7c      	movi.n	a11, -9
4037e02d:	1099b0        	and	a9, a9, a11
4037e030:	2099a0        	or	a9, a9, a10
4037e033:	0020c0        	memw
4037e036:	276892        	s32i	a9, a8, 156
    spimem_flash_ll_auto_wait_idle_init(dev, true, pes_waiti_delay);
    if (ctx->freq_mhz == 120) {
4037e039:	a298      	l32i.n	a9, a2, 40
4037e03b:	78a082        	movi	a8, 120
4037e03e:	4e9987        	bne	a9, a8, 4037e090 <spi_flash_hal_setup_auto_suspend_mode+0xcc>
        spimem_flash_ll_set_wait_idle_dummy_phase(dev, ctx->extra_dummy);
4037e041:	0c0282        	l8ui	a8, a2, 12
    if (extra_dummy > 0) {
4037e044:	48bc      	beqz.n	a8, 4037e07c <spi_flash_hal_setup_auto_suspend_mode+0xb8>
        dev->flash_waiti_ctrl.waiti_dummy_cyclelen = extra_dummy - 1;
4037e046:	880b      	addi.n	a8, a8, -1
4037e048:	d9e6a1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e04b:	0020c0        	memw
4037e04e:	262a92        	l32i	a9, a10, 152
4037e051:	548080        	extui	a8, a8, 0, 6
4037e054:	118860        	slli	a8, a8, 10
4037e057:	dbc1b1        	l32r	a11, 40374f5c <_iram_text_start+0xb58> (ffff03ff <_rtc_reserved_end+0x9fef03ff>)
4037e05a:	1099b0        	and	a9, a9, a11
4037e05d:	208980        	or	a8, a9, a8
4037e060:	0020c0        	memw
4037e063:	266a82        	s32i	a8, a10, 152
        dev->flash_waiti_ctrl.waiti_dummy = 1;
4037e066:	0020c0        	memw
4037e069:	262a82        	l32i	a8, a10, 152
4037e06c:	290c      	movi.n	a9, 2
4037e06e:	208890        	or	a8, a8, a9
4037e071:	0020c0        	memw
4037e074:	266a82        	s32i	a8, a10, 152
4037e077:	000546        	j	4037e090 <spi_flash_hal_setup_auto_suspend_mode+0xcc>
4037e07a:	910000        	srl	a0, a0
        dev->flash_waiti_ctrl.waiti_dummy = 0;
4037e07d:	d9d9      	s32i.n	a13, a9, 52
4037e07f:	0020c0        	memw
4037e082:	262982        	l32i	a8, a9, 152
4037e085:	da7c      	movi.n	a10, -3
4037e087:	1088a0        	and	a8, a8, a10
4037e08a:	0020c0        	memw
4037e08d:	266982        	s32i	a8, a9, 152
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037e090:	d9d481        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e093:	0020c0        	memw
4037e096:	282892        	l32i	a9, a8, 160
4037e099:	1a0c      	movi.n	a10, 1
4037e09b:	2099a0        	or	a9, a9, a10
4037e09e:	0020c0        	memw
4037e0a1:	286892        	s32i	a9, a8, 160
    dev->flash_sus_cmd.pes_per_en = auto_sus;
4037e0a4:	0020c0        	memw
4037e0a7:	272892        	l32i	a9, a8, 156
4037e0aa:	0a1c      	movi.n	a10, 16
4037e0ac:	2099a0        	or	a9, a9, a10
4037e0af:	0020c0        	memw
4037e0b2:	276892        	s32i	a9, a8, 156
    }
    spimem_flash_ll_auto_suspend_init(dev, true);
    // tsus = ceil(ctx->tsus_val * ctx->freq_mhz / spimem_flash_ll_get_tsus_unit_in_cycles);
    uint32_t tsus = (ctx->tsus_val * ctx->freq_mhz / spimem_flash_ll_get_tsus_unit_in_cycles(dev)) + ((ctx->tsus_val * ctx->freq_mhz) % spimem_flash_ll_get_tsus_unit_in_cycles(dev) != 0);
4037e0b5:	2c0292        	l8ui	a9, a2, 44
4037e0b8:	a2a8      	l32i.n	a10, a2, 40
4037e0ba:	8299a0        	mull	a9, a9, a10
    if (dev->sus_status.flash_pes_dly_256 == 1) {
4037e0bd:	0020c0        	memw
4037e0c0:	292882        	l32i	a8, a8, 164
4037e0c3:	056867        	bbci	a8, 6, 4037e0cc <spi_flash_hal_setup_auto_suspend_mode+0x108>
        tsus_unit = 256;
4037e0c6:	00a182        	movi	a8, 0x100
4037e0c9:	000046        	j	4037e0ce <spi_flash_hal_setup_auto_suspend_mode+0x10a>
        tsus_unit = 4;
4037e0cc:	480c      	movi.n	a8, 4
4037e0ce:	c28980        	quou	a8, a9, a8
    if (dev->sus_status.flash_pes_dly_256 == 1) {
4037e0d1:	d9c3a1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e0d4:	0020c0        	memw
4037e0d7:	292aa2        	l32i	a10, a10, 164
4037e0da:	066a67        	bbci	a10, 6, 4037e0e4 <spi_flash_hal_setup_auto_suspend_mode+0x120>
        tsus_unit = 256;
4037e0dd:	00a1a2        	movi	a10, 0x100
4037e0e0:	0000c6        	j	4037e0e7 <spi_flash_hal_setup_auto_suspend_mode+0x123>
4037e0e3:	a0a200        	addx4	a10, a2, a0
        tsus_unit = 4;
4037e0e6:	99a004        	lsi	f0, a0, 0x264
4037e0e9:	a052e2        	s16i	a14, a2, 0x140
4037e0ec:	040c01        	l32r	a0, 4033f11c <rom_rx_gain_force+0x338cf0>
4037e0ef:	04ad      	mov.n	a10, a4
4037e0f1:	93a590        	movnez	a10, a5, a9
4037e0f4:	88aa      	add.n	a8, a8, a10
    dev->ctrl1.cs_hold_dly_res = dly_val;
4037e0f6:	d9baa1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e0f9:	0020c0        	memw
4037e0fc:	3a98      	l32i.n	a9, a10, 12
4037e0fe:	948080        	extui	a8, a8, 0, 10
4037e101:	1188e0        	slli	a8, a8, 2
4037e104:	db97b1        	l32r	a11, 40374f60 <_iram_text_start+0xb5c> (fffff003 <_rtc_reserved_end+0x9feff003>)
4037e107:	1099b0        	and	a9, a9, a11
4037e10a:	208980        	or	a8, a9, a8
4037e10d:	0020c0        	memw
4037e110:	3a89      	s32i.n	a8, a10, 12
    dev->sus_status.flash_per_dly_256 = 1;
4037e112:	0020c0        	memw
4037e115:	292a82        	l32i	a8, a10, 164
4037e118:	092c      	movi.n	a9, 32
4037e11a:	208890        	or	a8, a8, a9
4037e11d:	0020c0        	memw
4037e120:	296a82        	s32i	a8, a10, 164
    dev->sus_status.flash_pes_dly_256 = 1;
4037e123:	0020c0        	memw
4037e126:	292a82        	l32i	a8, a10, 164
4037e129:	094c      	movi.n	a9, 64
4037e12b:	208890        	or	a8, a8, a9
4037e12e:	0020c0        	memw
4037e131:	296a82        	s32i	a8, a10, 164
    spimem_flash_ll_set_sus_delay(dev, tsus);
    // tshsl2 = ceil(SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz() * 0.001);
    uint32_t tshsl2 = (SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz() / 1000) + ((SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz()) % 1000 != 0);
4037e134:	ff7825        	call8	4037d8b8 <spimem_flash_ll_get_source_freq_mhz>
4037e137:	118ac0        	slli	a8, a10, 4
4037e13a:	c0a8a0        	sub	a10, a8, a10
4037e13d:	aaaa      	add.n	a10, a10, a10
4037e13f:	db8971        	l32r	a7, 40374f64 <_iram_text_start+0xb60> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
4037e142:	b26a70        	mulsh	a6, a10, a7
4037e145:	216660        	srai	a6, a6, 6
4037e148:	31afa0        	srai	a10, a10, 31
4037e14b:	c066a0        	sub	a6, a6, a10
4037e14e:	ff76a5        	call8	4037d8b8 <spimem_flash_ll_get_source_freq_mhz>
4037e151:	118ac0        	slli	a8, a10, 4
4037e154:	c0a8a0        	sub	a10, a8, a10
4037e157:	aaaa      	add.n	a10, a10, a10
4037e159:	b28a70        	mulsh	a8, a10, a7
4037e15c:	218680        	srai	a8, a8, 6
4037e15f:	319fa0        	srai	a9, a10, 31
4037e162:	c08890        	sub	a8, a8, a9
4037e165:	1198b0        	slli	a9, a8, 5
4037e168:	c09980        	sub	a9, a9, a8
4037e16b:	a08980        	addx4	a8, a9, a8
4037e16e:	1188d0        	slli	a8, a8, 3
4037e171:	c08a80        	sub	a8, a10, a8
4037e174:	835480        	moveqz	a5, a4, a8
4037e177:	665a      	add.n	a6, a6, a5
    SPIMEM0.ctrl2.cs_hold_delay = cs_hold_delay;
4037e179:	d9a491        	l32r	a9, 4037480c <_iram_text_start+0x408> (60003000 <SPIMEM0>)
4037e17c:	0020c0        	memw
4037e17f:	4988      	l32i.n	a8, a9, 16
4037e181:	546060        	extui	a6, a6, 0, 6
4037e184:	016670        	slli	a6, a6, 25
4037e187:	db78a1        	l32r	a10, 40374f68 <_iram_text_start+0xb64> (81ffffff <_rtc_reserved_end+0x21efffff>)
4037e18a:	1088a0        	and	a8, a8, a10
4037e18d:	208860        	or	a8, a8, a6
4037e190:	0020c0        	memw
4037e193:	4989      	s32i.n	a8, a9, 16
    spimem_flash_ll_sus_set_spi0_lock_trans(dev, SPIMEM_FLASH_LL_SPI0_MAX_LOCK_VAL_MSPI_TICKS);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, true);
    spimem_flash_ll_res_check_sus_setup(dev, true);
#endif
}
4037e195:	f01d      	retw.n
	...

4037e198 <spi_flash_hal_setup_auto_resume_mode>:

void spi_flash_hal_setup_auto_resume_mode(spi_flash_host_inst_t *host)
{
4037e198:	004136        	entry	a1, 32
    dev->misc.auto_per = auto_res;
4037e19b:	d99191        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e19e:	0020c0        	memw
4037e1a1:	d9a8      	l32i.n	a10, a9, 52
4037e1a3:	db7281        	l32r	a8, 40374f6c <_iram_text_start+0xb68> (800 <UserFrameTotalSize+0x700>)
4037e1a6:	208a80        	or	a8, a10, a8
4037e1a9:	0020c0        	memw
4037e1ac:	d989      	s32i.n	a8, a9, 52
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spimem_flash_ll_auto_resume_init(dev, true);
}
4037e1ae:	f01d      	retw.n

4037e1b0 <spi_flash_hal_disable_auto_suspend_mode>:

void spi_flash_hal_disable_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037e1b0:	006136        	entry	a1, 48
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05);
4037e1b3:	d98b81        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e1b6:	0020c0        	memw
4037e1b9:	262892        	l32i	a9, a8, 152
4037e1bc:	0020c0        	memw
4037e1bf:	0199      	s32i.n	a9, a1, 0
4037e1c1:	0020c0        	memw
4037e1c4:	01a8      	l32i.n	a10, a1, 0
4037e1c6:	03ac92        	movi	a9, 0xfffffc03
4037e1c9:	10aa90        	and	a10, a10, a9
4037e1cc:	491c      	movi.n	a9, 20
4037e1ce:	209a90        	or	a9, a10, a9
4037e1d1:	0020c0        	memw
4037e1d4:	0199      	s32i.n	a9, a1, 0
4037e1d6:	0020c0        	memw
4037e1d9:	0198      	l32i.n	a9, a1, 0
4037e1db:	0020c0        	memw
4037e1de:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = (per_waiti | pes_waiti);  // enable auto wait-idle function.
4037e1e1:	0020c0        	memw
4037e1e4:	2628b2        	l32i	a11, a8, 152
4037e1e7:	e97c      	movi.n	a9, -2
4037e1e9:	10ab90        	and	a10, a11, a9
4037e1ec:	0020c0        	memw
4037e1ef:	2668a2        	s32i	a10, a8, 152
    dev->flash_sus_cmd.flash_per_wait_en = per_waiti;
4037e1f2:	0020c0        	memw
4037e1f5:	2728b2        	l32i	a11, a8, 156
4037e1f8:	ba7c      	movi.n	a10, -5
4037e1fa:	10aba0        	and	a10, a11, a10
4037e1fd:	0020c0        	memw
4037e200:	2768a2        	s32i	a10, a8, 156
    dev->flash_sus_cmd.flash_pes_wait_en = pes_waiti;
4037e203:	0020c0        	memw
4037e206:	2728b2        	l32i	a11, a8, 156
4037e209:	7a7c      	movi.n	a10, -9
4037e20b:	10aba0        	and	a10, a11, a10
4037e20e:	0020c0        	memw
4037e211:	2768a2        	s32i	a10, a8, 156
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037e214:	0020c0        	memw
4037e217:	2828a2        	l32i	a10, a8, 160
4037e21a:	109a90        	and	a9, a10, a9
4037e21d:	0020c0        	memw
4037e220:	286892        	s32i	a9, a8, 160
    dev->flash_sus_cmd.pes_per_en = auto_sus;
4037e223:	0020c0        	memw
4037e226:	2728a2        	l32i	a10, a8, 156
4037e229:	f96c      	movi.n	a9, -17
4037e22b:	109a90        	and	a9, a10, a9
4037e22e:	0020c0        	memw
4037e231:	276892        	s32i	a9, a8, 156
    spimem_flash_ll_auto_suspend_init(dev, false);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, false);
    spimem_flash_ll_res_check_sus_setup(dev, false);
#endif
}
4037e234:	f01d      	retw.n
	...

4037e238 <spi_flash_hal_disable_auto_resume_mode>:

void spi_flash_hal_disable_auto_resume_mode(spi_flash_host_inst_t *host)
{
4037e238:	004136        	entry	a1, 32
    dev->misc.auto_per = auto_res;
4037e23b:	d96991        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e23e:	0020c0        	memw
4037e241:	d9a8      	l32i.n	a10, a9, 52
4037e243:	d9fb81        	l32r	a8, 40374a30 <_iram_text_start+0x62c> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
4037e246:	108a80        	and	a8, a10, a8
4037e249:	0020c0        	memw
4037e24c:	d989      	s32i.n	a8, a9, 52
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spimem_flash_ll_auto_resume_init(dev, false);
}
4037e24e:	f01d      	retw.n

4037e250 <spi_flash_hal_device_config>:
{
4037e250:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e253:	1278      	l32i.n	a7, a2, 4
    dev->user.val = 0;
4037e255:	080c      	movi.n	a8, 0
4037e257:	0020c0        	memw
4037e25a:	6789      	s32i.n	a8, a7, 24
    dev->ctrl.val = 0;
4037e25c:	0020c0        	memw
4037e25f:	2789      	s32i.n	a8, a7, 8
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037e261:	2298      	l32i.n	a9, a2, 8
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037e263:	0020c0        	memw
4037e266:	d788      	l32i.n	a8, a7, 52
4037e268:	1a0c      	movi.n	a10, 1
4037e26a:	83a990        	moveqz	a10, a9, a9
4037e26d:	eb7c      	movi.n	a11, -2
4037e26f:	1088b0        	and	a8, a8, a11
4037e272:	2088a0        	or	a8, a8, a10
4037e275:	0020c0        	memw
4037e278:	d789      	s32i.n	a8, a7, 52
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037e27a:	a90b      	addi.n	a10, a9, -1
4037e27c:	0020c0        	memw
4037e27f:	d788      	l32i.n	a8, a7, 52
4037e281:	190c      	movi.n	a9, 1
4037e283:	839aa0        	moveqz	a9, a10, a10
4037e286:	999a      	add.n	a9, a9, a9
4037e288:	da7c      	movi.n	a10, -3
4037e28a:	1088a0        	and	a8, a8, a10
4037e28d:	208890        	or	a8, a8, a9
4037e290:	0020c0        	memw
4037e293:	d789      	s32i.n	a8, a7, 52
    dev->clock.val = *clock_val;
4037e295:	0020c0        	memw
4037e298:	4288      	l32i.n	a8, a2, 16
4037e29a:	0020c0        	memw
4037e29d:	5789      	s32i.n	a8, a7, 20
    int cs_hold = ctx->cs_hold;
4037e29f:	0f02a2        	l8ui	a10, a2, 15
    dev->ctrl2.cs_hold_time = hold_n - 1;
4037e2a2:	9a0b      	addi.n	a9, a10, -1
4037e2a4:	0020c0        	memw
4037e2a7:	4788      	l32i.n	a8, a7, 16
4037e2a9:	449090        	extui	a9, a9, 0, 5
4037e2ac:	1199b0        	slli	a9, a9, 5
4037e2af:	1facb2        	movi	a11, 0xfffffc1f
4037e2b2:	1088b0        	and	a8, a8, a11
4037e2b5:	208890        	or	a8, a8, a9
4037e2b8:	0020c0        	memw
4037e2bb:	4789      	s32i.n	a8, a7, 16
    dev->user.cs_hold = (hold_n > 0 ? 1 : 0);
4037e2bd:	0020c0        	memw
4037e2c0:	6788      	l32i.n	a8, a7, 24
4037e2c2:	190c      	movi.n	a9, 1
4037e2c4:	839aa0        	moveqz	a9, a10, a10
4037e2c7:	1199a0        	slli	a9, a9, 6
4037e2ca:	bfafa2        	movi	a10, -65
4037e2cd:	1088a0        	and	a8, a8, a10
4037e2d0:	208890        	or	a8, a8, a9
4037e2d3:	0020c0        	memw
4037e2d6:	6789      	s32i.n	a8, a7, 24
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037e2d8:	0e0282        	l8ui	a8, a2, 14
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037e2db:	0020c0        	memw
4037e2de:	6798      	l32i.n	a9, a7, 24
4037e2e0:	1a0c      	movi.n	a10, 1
4037e2e2:	83a880        	moveqz	a10, a8, a8
4037e2e5:	11aa90        	slli	a10, a10, 7
4037e2e8:	7fafb2        	movi	a11, -129
4037e2eb:	1099b0        	and	a9, a9, a11
4037e2ee:	2099a0        	or	a9, a9, a10
4037e2f1:	0020c0        	memw
4037e2f4:	6799      	s32i.n	a9, a7, 24
    dev->ctrl2.cs_setup_time = cs_setup_time - 1;
4037e2f6:	880b      	addi.n	a8, a8, -1
4037e2f8:	0020c0        	memw
4037e2fb:	4798      	l32i.n	a9, a7, 16
4037e2fd:	448080        	extui	a8, a8, 0, 5
4037e300:	0a6c      	movi.n	a10, -32
4037e302:	1099a0        	and	a9, a9, a10
4037e305:	208980        	or	a8, a9, a8
4037e308:	0020c0        	memw
4037e30b:	4789      	s32i.n	a8, a7, 16
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) != 0) {
4037e30d:	6288      	l32i.n	a8, a2, 24
4037e30f:	096807        	bbci	a8, 0, 4037e31c <spi_flash_hal_device_config+0xcc>
        spi_flash_hal_setup_auto_suspend_mode(host);
4037e312:	20a220        	or	a10, a2, a2
4037e315:	ffcae5        	call8	4037dfc4 <spi_flash_hal_setup_auto_suspend_mode>
4037e318:	000186        	j	4037e322 <spi_flash_hal_device_config+0xd2>
4037e31b:	a22000        	muluh	a2, a0, a0
        spi_flash_hal_disable_auto_suspend_mode(host);
4037e31e:	e92520        	lsi	f2, a5, 0x3a4
4037e321:	ff          	.byte	0xff
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME) != 0) {
4037e322:	062282        	l32i	a8, a2, 24
4037e325:	076817        	bbci	a8, 1, 4037e330 <spi_flash_hal_device_config+0xe0>
        spi_flash_hal_setup_auto_resume_mode(host);
4037e328:	02ad      	mov.n	a10, a2
4037e32a:	ffe6e5        	call8	4037e198 <spi_flash_hal_setup_auto_resume_mode>
4037e32d:	000146        	j	4037e336 <spi_flash_hal_device_config+0xe6>
        spi_flash_hal_disable_auto_resume_mode(host);
4037e330:	20a220        	or	a10, a2, a2
4037e333:	fff065        	call8	4037e238 <spi_flash_hal_disable_auto_resume_mode>
    dev->timing_cali.extra_dummy_cyclelen = extra_dummy;
4037e336:	0020c0        	memw
4037e339:	2a2782        	l32i	a8, a7, 168
4037e33c:	e3af92        	movi	a9, -29
4037e33f:	108890        	and	a8, a8, a9
4037e342:	0020c0        	memw
4037e345:	2a6782        	s32i	a8, a7, 168
}
4037e348:	00a022        	movi	a2, 0
4037e34b:	f01d      	retw.n
4037e34d:	000000        	ill

4037e350 <spi_flash_hal_poll_cmd_done>:
{
4037e350:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e353:	1288      	l32i.n	a8, a2, 4
    return (dev->cmd.val == 0);
4037e355:	0020c0        	memw
4037e358:	0888      	l32i.n	a8, a8, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037e35a:	ff5856        	bnez	a8, 4037e353 <spi_flash_hal_poll_cmd_done+0x3>
}
4037e35d:	f01d      	retw.n
	...

4037e360 <spi_flash_hal_check_status>:
{
4037e360:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e363:	1288      	l32i.n	a8, a2, 4
    return dev->cmd.val == 0;
4037e365:	0020c0        	memw
4037e368:	0828      	l32i.n	a2, a8, 0
4037e36a:	40f220        	nsau	a2, a2
4037e36d:	412520        	srli	a2, a2, 5
    return dev->sus_status.flash_sus;
4037e370:	0020c0        	memw
4037e373:	292882        	l32i	a8, a8, 164
    uint32_t sus_status = spimem_flash_ll_sus_status((spi_mem_dev_t*)dev) << 1;
4037e376:	048080        	extui	a8, a8, 0, 1
4037e379:	888a      	add.n	a8, a8, a8
}
4037e37b:	202280        	or	a2, a2, a8
4037e37e:	f01d      	retw.n

4037e380 <spi_flash_hal_resume>:
#endif // SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

void spi_flash_hal_resume(spi_flash_host_inst_t *host)
{
4037e380:	004136        	entry	a1, 32
4037e383:	02ad      	mov.n	a10, a2
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_resume((spi_mem_dev_t*)(((spi_flash_hal_context_t *)host)->spi));
4037e385:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_per = 1;
4037e387:	0020c0        	memw
4037e38a:	272982        	l32i	a8, a9, 156
4037e38d:	1b0c      	movi.n	a11, 1
4037e38f:	2088b0        	or	a8, a8, a11
4037e392:	0020c0        	memw
4037e395:	276982        	s32i	a8, a9, 156
    host->driver->poll_cmd_done(host);
4037e398:	0288      	l32i.n	a8, a2, 0
4037e39a:	102882        	l32i	a8, a8, 64
4037e39d:	0008e0        	callx8	a8
#else
    abort();
#endif
}
4037e3a0:	f01d      	retw.n
	...

4037e3a4 <spi_flash_hal_suspend>:

void spi_flash_hal_suspend(spi_flash_host_inst_t *host)
{
4037e3a4:	004136        	entry	a1, 32
4037e3a7:	02ad      	mov.n	a10, a2
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_suspend((spi_mem_dev_t *)(((spi_flash_hal_context_t *)host)->spi));
4037e3a9:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_pes = 1;
4037e3ab:	0020c0        	memw
4037e3ae:	272982        	l32i	a8, a9, 156
4037e3b1:	2b0c      	movi.n	a11, 2
4037e3b3:	2088b0        	or	a8, a8, a11
4037e3b6:	0020c0        	memw
4037e3b9:	276982        	s32i	a8, a9, 156
    host->driver->poll_cmd_done(host);
4037e3bc:	0288      	l32i.n	a8, a2, 0
4037e3be:	102882        	l32i	a8, a8, 64
4037e3c1:	0008e0        	callx8	a8
#else
    abort();
#endif
}
4037e3c4:	f01d      	retw.n
	...

4037e3c8 <systimer_hal_init>:
#include "hal/systimer_types.h"
#include "hal/assert.h"


void systimer_hal_init(systimer_hal_context_t *hal)
{
4037e3c8:	004136        	entry	a1, 32
    hal->dev = &SYSTIMER;
4037e3cb:	dae981        	l32r	a8, 40374f70 <_iram_text_start+0xb6c> (60023000 <SYSTIMER>)
4037e3ce:	0289      	s32i.n	a8, a2, 0
    dev->conf.clk_en = en;
4037e3d0:	0020c0        	memw
4037e3d3:	0898      	l32i.n	a9, a8, 0
4037e3d5:	d851a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037e3d8:	2099a0        	or	a9, a9, a10
4037e3db:	0020c0        	memw
4037e3de:	0899      	s32i.n	a9, a8, 0
    systimer_ll_enable_clock(hal->dev, true);
#if SOC_SYSTIMER_SUPPORT_ETM
    systimer_ll_enable_etm(&SYSTIMER, true);
#endif
}
4037e3e0:	f01d      	retw.n
	...

4037e3e4 <systimer_hal_get_counter_value>:
    hal->ticks_to_us = ops->ticks_to_us;
    hal->us_to_ticks = ops->us_to_ticks;
}

uint64_t systimer_hal_get_counter_value(systimer_hal_context_t *hal, uint32_t counter_id)
{
4037e3e4:	004136        	entry	a1, 32
4037e3e7:	03bd      	mov.n	a11, a3
    uint32_t lo, lo_start, hi;
    /* Set the "update" bit and wait for acknowledgment */
    systimer_ll_counter_snapshot(hal->dev, counter_id);
4037e3e9:	0288      	l32i.n	a8, a2, 0
    dev->unit_op[counter_id].timer_unit_update = 1;
4037e3eb:	a08380        	addx4	a8, a3, a8
4037e3ee:	0020c0        	memw
4037e3f1:	1898      	l32i.n	a9, a8, 4
4037e3f3:	d880a1        	l32r	a10, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037e3f6:	2099a0        	or	a9, a9, a10
4037e3f9:	0020c0        	memw
4037e3fc:	1899      	s32i.n	a9, a8, 4
    while (!systimer_ll_is_counter_value_valid(hal->dev, counter_id));
4037e3fe:	02a8      	l32i.n	a10, a2, 0
    return dev->unit_op[counter_id].timer_unit_value_valid;
4037e400:	a08ba0        	addx4	a8, a11, a10
4037e403:	0020c0        	memw
4037e406:	1888      	l32i.n	a8, a8, 4
4037e408:	f278d7        	bbci	a8, 29, 4037e3fe <systimer_hal_get_counter_value+0x1a>
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037e40b:	8b8b      	addi.n	a8, a11, 8
4037e40d:	b088a0        	addx8	a8, a8, a10
4037e410:	0020c0        	memw
4037e413:	1898      	l32i.n	a9, a8, 4
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
4037e415:	8b8b      	addi.n	a8, a11, 8
4037e417:	b088a0        	addx8	a8, a8, a10
4037e41a:	0020c0        	memw
4037e41d:	0838      	l32i.n	a3, a8, 0
4037e41f:	113340        	slli	a3, a3, 12
4037e422:	413c30        	srli	a3, a3, 12
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037e425:	092d      	mov.n	a2, a9
4037e427:	0020c0        	memw
4037e42a:	1898      	l32i.n	a9, a8, 4
    lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    do {
        lo = lo_start;
        hi = systimer_ll_get_counter_value_high(hal->dev, counter_id);
        lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    } while (lo_start != lo);
4037e42c:	e59297        	bne	a2, a9, 4037e415 <systimer_hal_get_counter_value+0x31>
        .lo = lo,
        .hi = hi
    };

    return result.val;
}
4037e42f:	f01d      	retw.n
4037e431:	000000        	ill

4037e434 <systimer_hal_set_alarm_period>:
    } while (1);
}
#endif // SOC_SYSTIMER_ALARM_MISS_COMPENSATE

void systimer_hal_set_alarm_period(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t period)
{
4037e434:	004136        	entry	a1, 32
4037e437:	04ad      	mov.n	a10, a4
    systimer_ll_enable_alarm(hal->dev, alarm_id, false);
4037e439:	0298      	l32i.n	a9, a2, 0
        dev->conf.val &= ~(1 << (24 - alarm_id));
4037e43b:	0020c0        	memw
4037e43e:	09b8      	l32i.n	a11, a9, 0
4037e440:	e8c382        	addi	a8, a3, -24
4037e443:	608080        	neg	a8, a8
4037e446:	170c      	movi.n	a7, 1
4037e448:	401800        	ssl	a8
4037e44b:	a17700        	sll	a7, a7
4037e44e:	1087b0        	and	a8, a7, a11
4037e451:	3088b0        	xor	a8, a8, a11
4037e454:	0020c0        	memw
4037e457:	0989      	s32i.n	a8, a9, 0
    systimer_ll_set_alarm_period(hal->dev, alarm_id, hal->us_to_ticks(period));
4037e459:	0268      	l32i.n	a6, a2, 0
4037e45b:	2288      	l32i.n	a8, a2, 8
4037e45d:	00a0b2        	movi	a11, 0
4037e460:	0008e0        	callx8	a8
    HAL_ASSERT(period < (1 << 26));
4037e463:	dac481        	l32r	a8, 40374f74 <_iram_text_start+0xb70> (3ffffff <UserFrameTotalSize+0x3fffeff>)
4037e466:	0eb8a7        	bgeu	a8, a10, 4037e478 <systimer_hal_set_alarm_period+0x44>
4037e469:	dac3d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3fc941b8 <__FUNCTION__$0+0x900>)
4037e46c:	dac4c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3fc94388 <__func__$0>)
4037e46f:	95a0b2        	movi	a11, 149
4037e472:	dac3a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3fc941cc <__FUNCTION__$0+0x914>)
4037e475:	0192a5        	call8	4037fda0 <__assert_func>
    dev->target_conf[alarm_id].target_period = period;
4037e478:	93cb      	addi.n	a9, a3, 12
4037e47a:	a09960        	addx4	a9, a9, a6
4037e47d:	0020c0        	memw
4037e480:	1988      	l32i.n	a8, a9, 4
4037e482:	11aaa0        	slli	a10, a10, 6
4037e485:	41a6a0        	srli	a10, a10, 6
4037e488:	558a80        	extui	a8, a8, 26, 6
4037e48b:	018860        	slli	a8, a8, 26
4037e48e:	2088a0        	or	a8, a8, a10
4037e491:	0020c0        	memw
4037e494:	1989      	s32i.n	a8, a9, 4
    systimer_ll_apply_alarm_value(hal->dev, alarm_id);
4037e496:	0288      	l32i.n	a8, a2, 0
    dev->comp_load[alarm_id].val = 0x01;
4037e498:	14c332        	addi	a3, a3, 20
4037e49b:	a03380        	addx4	a3, a3, a8
4037e49e:	180c      	movi.n	a8, 1
4037e4a0:	0020c0        	memw
4037e4a3:	0389      	s32i.n	a8, a3, 0
    systimer_ll_enable_alarm(hal->dev, alarm_id, true);
4037e4a5:	0298      	l32i.n	a9, a2, 0
        dev->conf.val |= 1 << (24 - alarm_id);
4037e4a7:	0020c0        	memw
4037e4aa:	0988      	l32i.n	a8, a9, 0
4037e4ac:	208870        	or	a8, a8, a7
4037e4af:	0020c0        	memw
4037e4b2:	0989      	s32i.n	a8, a9, 0
}
4037e4b4:	f01d      	retw.n
	...

4037e4b8 <systimer_hal_counter_value_advance>:
{
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
}

void systimer_hal_counter_value_advance(systimer_hal_context_t *hal, uint32_t counter_id, int64_t time_us)
{
4037e4b8:	004136        	entry	a1, 32
    systimer_counter_value_t new_count = {
        .val = systimer_hal_get_counter_value(hal, counter_id) + hal->us_to_ticks(time_us),
4037e4bb:	03bd      	mov.n	a11, a3
4037e4bd:	02ad      	mov.n	a10, a2
4037e4bf:	fff265        	call8	4037e3e4 <systimer_hal_get_counter_value>
4037e4c2:	0a6d      	mov.n	a6, a10
4037e4c4:	0b7d      	mov.n	a7, a11
4037e4c6:	2288      	l32i.n	a8, a2, 8
4037e4c8:	04ad      	mov.n	a10, a4
4037e4ca:	05bd      	mov.n	a11, a5
4037e4cc:	0008e0        	callx8	a8
4037e4cf:	b7ba      	add.n	a11, a7, a11
4037e4d1:	c6aa      	add.n	a12, a6, a10
4037e4d3:	01bca7        	bgeu	a12, a10, 4037e4d8 <systimer_hal_counter_value_advance+0x20>
4037e4d6:	bb1b      	addi.n	a11, a11, 1
    };
    systimer_ll_set_counter_value(hal->dev, counter_id, new_count.val);
4037e4d8:	0298      	l32i.n	a9, a2, 0
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037e4da:	b09390        	addx8	a9, a3, a9
4037e4dd:	0020c0        	memw
4037e4e0:	3988      	l32i.n	a8, a9, 12
4037e4e2:	11bb40        	slli	a11, a11, 12
4037e4e5:	41bcb0        	srli	a11, a11, 12
4037e4e8:	b58480        	extui	a8, a8, 20, 12
4037e4eb:	0188c0        	slli	a8, a8, 20
4037e4ee:	2088b0        	or	a8, a8, a11
4037e4f1:	0020c0        	memw
4037e4f4:	3989      	s32i.n	a8, a9, 12
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037e4f6:	0020c0        	memw
4037e4f9:	49c9      	s32i.n	a12, a9, 16
    systimer_ll_apply_counter_value(hal->dev, counter_id);
4037e4fb:	0288      	l32i.n	a8, a2, 0
    dev->unit_load[counter_id].val = 0x01;
4037e4fd:	14c332        	addi	a3, a3, 20
4037e500:	a03380        	addx4	a3, a3, a8
4037e503:	180c      	movi.n	a8, 1
4037e505:	0020c0        	memw
4037e508:	3389      	s32i.n	a8, a3, 12
}
4037e50a:	f01d      	retw.n

4037e50c <systimer_hal_select_alarm_mode>:
{
    systimer_ll_enable_counter(hal->dev, counter_id, true);
}

void systimer_hal_select_alarm_mode(systimer_hal_context_t *hal, uint32_t alarm_id, systimer_alarm_mode_t mode)
{
4037e50c:	004136        	entry	a1, 32
    switch (mode) {
4037e50f:	548c      	beqz.n	a4, 4037e518 <systimer_hal_select_alarm_mode+0xc>
4037e511:	1d1426        	beqi	a4, 1, 4037e532 <systimer_hal_select_alarm_mode+0x26>
4037e514:	000c46        	j	4037e549 <systimer_hal_select_alarm_mode+0x3d>
4037e517:	028800        	andb	b8, b8, b0
    dev->target_conf[alarm_id].target_period_mode = 0;
4037e51a:	33cb      	addi.n	a3, a3, 12
4037e51c:	a03380        	addx4	a3, a3, a8
4037e51f:	0020c0        	memw
4037e522:	1388      	l32i.n	a8, a3, 4
4037e524:	d8b291        	l32r	a9, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037e527:	108890        	and	a8, a8, a9
4037e52a:	0020c0        	memw
4037e52d:	1389      	s32i.n	a8, a3, 4
}
4037e52f:	000586        	j	4037e549 <systimer_hal_select_alarm_mode+0x3d>
    case SYSTIMER_ALARM_MODE_ONESHOT:
        systimer_ll_enable_alarm_oneshot(hal->dev, alarm_id);
        break;
    case SYSTIMER_ALARM_MODE_PERIOD:
        systimer_ll_enable_alarm_period(hal->dev, alarm_id);
4037e532:	0288      	l32i.n	a8, a2, 0
    dev->target_conf[alarm_id].target_period_mode = 1;
4037e534:	33cb      	addi.n	a3, a3, 12
4037e536:	a03380        	addx4	a3, a3, a8
4037e539:	0020c0        	memw
4037e53c:	1388      	l32i.n	a8, a3, 4
4037e53e:	d82d91        	l32r	a9, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037e541:	208890        	or	a8, a8, a9
4037e544:	0020c0        	memw
4037e547:	1389      	s32i.n	a8, a3, 4
        break;
    default:
        break;
    }
}
4037e549:	f01d      	retw.n
	...

4037e54c <systimer_hal_set_tick_rate_ops>:
{
4037e54c:	004136        	entry	a1, 32
    hal->ticks_to_us = ops->ticks_to_us;
4037e54f:	0388      	l32i.n	a8, a3, 0
4037e551:	1289      	s32i.n	a8, a2, 4
    hal->us_to_ticks = ops->us_to_ticks;
4037e553:	1388      	l32i.n	a8, a3, 4
4037e555:	2289      	s32i.n	a8, a2, 8
}
4037e557:	f01d      	retw.n
4037e559:	000000        	ill

4037e55c <systimer_hal_enable_alarm_int>:
{
4037e55c:	004136        	entry	a1, 32
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
4037e55f:	02a8      	l32i.n	a10, a2, 0
        dev->int_ena.val |= 1 << alarm_id;
4037e561:	0020c0        	memw
4037e564:	192a82        	l32i	a8, a10, 100
4037e567:	190c      	movi.n	a9, 1
4037e569:	401300        	ssl	a3
4037e56c:	a19900        	sll	a9, a9
4037e56f:	208890        	or	a8, a8, a9
4037e572:	0020c0        	memw
4037e575:	196a82        	s32i	a8, a10, 100
}
4037e578:	f01d      	retw.n
	...

4037e57c <systimer_hal_enable_counter>:
{
4037e57c:	004136        	entry	a1, 32
    systimer_ll_enable_counter(hal->dev, counter_id, true);
4037e57f:	02a8      	l32i.n	a10, a2, 0
        dev->conf.val |= 1 << (30 - counter_id);
4037e581:	0020c0        	memw
4037e584:	0a88      	l32i.n	a8, a10, 0
4037e586:	e2c332        	addi	a3, a3, -30
4037e589:	603030        	neg	a3, a3
4037e58c:	190c      	movi.n	a9, 1
4037e58e:	401300        	ssl	a3
4037e591:	a19900        	sll	a9, a9
4037e594:	208890        	or	a8, a8, a9
4037e597:	0020c0        	memw
4037e59a:	0a89      	s32i.n	a8, a10, 0
}
4037e59c:	f01d      	retw.n
	...

4037e5a0 <systimer_hal_connect_alarm_counter>:

void systimer_hal_connect_alarm_counter(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t counter_id)
{
4037e5a0:	004136        	entry	a1, 32
    systimer_ll_connect_alarm_counter(hal->dev, alarm_id, counter_id);
4037e5a3:	0288      	l32i.n	a8, a2, 0
    dev->target_conf[alarm_id].target_timer_unit_sel = counter_id;
4037e5a5:	33cb      	addi.n	a3, a3, 12
4037e5a7:	a03380        	addx4	a3, a3, a8
4037e5aa:	0020c0        	memw
4037e5ad:	1388      	l32i.n	a8, a3, 4
4037e5af:	014410        	slli	a4, a4, 31
4037e5b2:	888a      	add.n	a8, a8, a8
4037e5b4:	418180        	srli	a8, a8, 1
4037e5b7:	208840        	or	a8, a8, a4
4037e5ba:	0020c0        	memw
4037e5bd:	1389      	s32i.n	a8, a3, 4
}
4037e5bf:	f01d      	retw.n
4037e5c1:	000000        	ill

4037e5c4 <systimer_hal_counter_can_stall_by_cpu>:

void systimer_hal_counter_can_stall_by_cpu(systimer_hal_context_t *hal, uint32_t counter_id, uint32_t cpu_id, bool can)
{
4037e5c4:	004136        	entry	a1, 32
4037e5c7:	745050        	extui	a5, a5, 0, 8
    systimer_ll_counter_can_stall_by_cpu(hal->dev, counter_id, cpu_id, can);
4037e5ca:	0298      	l32i.n	a9, a2, 0
    if (can) {
4037e5cc:	05ac      	beqz.n	a5, 4037e5f0 <systimer_hal_counter_can_stall_by_cpu+0x2c>
        dev->conf.val |= 1 << ((28 - counter_id * 2) - cpu_id);
4037e5ce:	0020c0        	memw
4037e5d1:	0988      	l32i.n	a8, a9, 0
4037e5d3:	f2c332        	addi	a3, a3, -14
4037e5d6:	603030        	neg	a3, a3
4037e5d9:	d03340        	subx2	a3, a3, a4
4037e5dc:	1a0c      	movi.n	a10, 1
4037e5de:	401300        	ssl	a3
4037e5e1:	a1aa00        	sll	a10, a10
4037e5e4:	2088a0        	or	a8, a8, a10
4037e5e7:	0020c0        	memw
4037e5ea:	0989      	s32i.n	a8, a9, 0
4037e5ec:	000846        	j	4037e611 <systimer_hal_counter_can_stall_by_cpu+0x4d>
4037e5ef:	20c000        	or	a12, a0, a0
        dev->conf.val &= ~(1 << ((28 - counter_id * 2) - cpu_id));
4037e5f2:	09a800        	l32e	a0, a8, -24
4037e5f5:	f2c332        	addi	a3, a3, -14
4037e5f8:	603030        	neg	a3, a3
4037e5fb:	d03340        	subx2	a3, a3, a4
4037e5fe:	180c      	movi.n	a8, 1
4037e600:	401300        	ssl	a3
4037e603:	a18800        	sll	a8, a8
4037e606:	1088a0        	and	a8, a8, a10
4037e609:	3088a0        	xor	a8, a8, a10
4037e60c:	0020c0        	memw
4037e60f:	0989      	s32i.n	a8, a9, 0
}
4037e611:	f01d      	retw.n
	...

4037e614 <assert_valid_block>:

#else // CONFIG_HEAP_TLSF_USE_ROM_IMPL

/* Check a block is valid for this heap. Used to verify parameters. */
__attribute__((noinline)) NOCLONE_ATTR static void assert_valid_block(const heap_t *heap, const multi_heap_block_handle_t block)
{
4037e614:	004136        	entry	a1, 32
    pool_t pool = tlsf_get_pool(heap->heap_data);
4037e617:	42a8      	l32i.n	a10, a2, 16
4037e619:	006025        	call8	4037ec1c <tlsf_get_pool>
		tlsf_cast(unsigned char*, ptr) - block_start_offset);
}

static inline __attribute__((always_inline)) void* block_to_ptr(const block_header_t* block)
{
	return tlsf_cast(void*,
4037e61c:	338b      	addi.n	a3, a3, 8
    void *ptr = block_to_ptr(block);

    MULTI_HEAP_ASSERT((ptr >= pool) &&
4037e61e:	0733a7        	bltu	a3, a10, 4037e629 <assert_valid_block+0x15>
4037e621:	3288      	l32i.n	a8, a2, 12
4037e623:	80aa80        	add	a10, a10, a8
4037e626:	1033a7        	bltu	a3, a10, 4037e63a <assert_valid_block+0x26>
       Also, it's useful to be able to print the memory address where corruption was detected.
    */
#ifndef NDEBUG
    if(!condition) {
#ifndef CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        esp_rom_printf(format, line, address);
4037e629:	03cd      	mov.n	a12, a3
4037e62b:	74a0b2        	movi	a11, 116
4037e62e:	da55a1        	l32r	a10, 40374f84 <_iram_text_start+0xb80> (3c0229e8 <_flash_rodata_start+0x28c8>)
4037e631:	d7a081        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4037e634:	0008e0        	callx8	a8
#endif  // CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        abort();
4037e637:	016ae5        	call8	4037fce4 <abort>
                    (ptr < pool + heap->pool_size),
                    (uintptr_t)ptr);
}
4037e63a:	f01d      	retw.n

4037e63c <multi_heap_aligned_alloc_impl_offs>:

    return result;
}

void *multi_heap_aligned_alloc_impl_offs(multi_heap_handle_t heap, size_t size, size_t alignment, size_t offset)
{
4037e63c:	004136        	entry	a1, 32
4037e63f:	027d      	mov.n	a7, a2
    if(heap == NULL) {
4037e641:	043216        	beqz	a2, 4037e688 <multi_heap_aligned_alloc_impl_offs+0x4c>
        return NULL;
    }

    if(!size) {
4037e644:	044316        	beqz	a3, 4037e68c <multi_heap_aligned_alloc_impl_offs+0x50>
        return NULL;
    }

    //Alignment must be a power of two:
    if(((alignment & (alignment - 1)) != 0) ||(!alignment)) {
4037e647:	ffc482        	addi	a8, a4, -1
4037e64a:	438847        	bany	a8, a4, 4037e691 <multi_heap_aligned_alloc_impl_offs+0x55>
4037e64d:	045416        	beqz	a4, 4037e696 <multi_heap_aligned_alloc_impl_offs+0x5a>
        return NULL;
    }

    multi_heap_internal_lock(heap);
4037e650:	02ad      	mov.n	a10, a2
4037e652:	000b65        	call8	4037e708 <multi_heap_internal_lock>
    void *result = tlsf_memalign_offs(heap->heap_data, alignment, size, offset);
4037e655:	05dd      	mov.n	a13, a5
4037e657:	03cd      	mov.n	a12, a3
4037e659:	04bd      	mov.n	a11, a4
4037e65b:	42a8      	l32i.n	a10, a2, 16
4037e65d:	0099a5        	call8	4037eff8 <tlsf_memalign_offs>
4037e660:	0a2d      	mov.n	a2, a10
    if(result) {
4037e662:	01aa16        	beqz	a10, 4037e680 <multi_heap_aligned_alloc_impl_offs+0x44>
        heap->free_bytes -= tlsf_block_size(result);
4037e665:	001ba5        	call8	4037e820 <tlsf_block_size>
4037e668:	1788      	l32i.n	a8, a7, 4
4037e66a:	c088a0        	sub	a8, a8, a10
4037e66d:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_alloc_overhead();
4037e66f:	001aa5        	call8	4037e818 <tlsf_alloc_overhead>
4037e672:	1788      	l32i.n	a8, a7, 4
4037e674:	c0a8a0        	sub	a10, a8, a10
4037e677:	17a9      	s32i.n	a10, a7, 4
        if(heap->free_bytes < heap->minimum_free_bytes) {
4037e679:	2788      	l32i.n	a8, a7, 8
4037e67b:	01ba87        	bgeu	a10, a8, 4037e680 <multi_heap_aligned_alloc_impl_offs+0x44>
            heap->minimum_free_bytes = heap->free_bytes;
4037e67e:	27a9      	s32i.n	a10, a7, 8
        }
    }
    multi_heap_internal_unlock(heap);
4037e680:	07ad      	mov.n	a10, a7
4037e682:	000aa5        	call8	4037e72c <multi_heap_internal_unlock>

    return result;
4037e685:	0003c6        	j	4037e698 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e688:	000306        	j	4037e698 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e68b:	020c00        	andb	b0, b12, b0
        return NULL;
4037e68e:	000186        	j	4037e698 <multi_heap_aligned_alloc_impl_offs+0x5c>
        return NULL;
4037e691:	020c      	movi.n	a2, 0
4037e693:	000046        	j	4037e698 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e696:	020c      	movi.n	a2, 0
}
4037e698:	f01d      	retw.n
	...

4037e69c <multi_heap_aligned_alloc_offs>:
{
4037e69c:	004136        	entry	a1, 32
4037e69f:	20a220        	or	a10, a2, a2
4037e6a2:	20b330        	or	a11, a3, a3
4037e6a5:	20c440        	or	a12, a4, a4
4037e6a8:	05dd      	mov.n	a13, a5
    return multi_heap_aligned_alloc_impl_offs(heap, size, alignment, offset);
4037e6aa:	fff925        	call8	4037e63c <multi_heap_aligned_alloc_impl_offs>
}
4037e6ad:	0a2d      	mov.n	a2, a10
4037e6af:	f01d      	retw.n
4037e6b1:	000000        	ill

4037e6b4 <multi_heap_aligned_free>:
{
4037e6b4:	004136        	entry	a1, 32
    if (heap == NULL || p == NULL) {
4037e6b7:	40f280        	nsau	a8, a2
4037e6ba:	418580        	srli	a8, a8, 5
4037e6bd:	40f390        	nsau	a9, a3
4037e6c0:	419590        	srli	a9, a9, 5
4037e6c3:	208890        	or	a8, a8, a9
4037e6c6:	02e856        	bnez	a8, 4037e6f8 <multi_heap_aligned_free+0x44>
    assert_valid_block(heap, block_from_ptr(p));
4037e6c9:	f8c3b2        	addi	a11, a3, -8
4037e6cc:	20a220        	or	a10, a2, a2
4037e6cf:	fff465        	call8	4037e614 <assert_valid_block>
    multi_heap_internal_lock(heap);
4037e6d2:	20a220        	or	a10, a2, a2
4037e6d5:	000325        	call8	4037e708 <multi_heap_internal_lock>
    heap->free_bytes += tlsf_block_size(p);
4037e6d8:	03ad      	mov.n	a10, a3
4037e6da:	001465        	call8	4037e820 <tlsf_block_size>
4037e6dd:	1288      	l32i.n	a8, a2, 4
4037e6df:	88aa      	add.n	a8, a8, a10
4037e6e1:	1289      	s32i.n	a8, a2, 4
    heap->free_bytes += tlsf_alloc_overhead();
4037e6e3:	001365        	call8	4037e818 <tlsf_alloc_overhead>
4037e6e6:	1288      	l32i.n	a8, a2, 4
4037e6e8:	88aa      	add.n	a8, a8, a10
4037e6ea:	1289      	s32i.n	a8, a2, 4
    tlsf_free(heap->heap_data, p);
4037e6ec:	03bd      	mov.n	a11, a3
4037e6ee:	42a8      	l32i.n	a10, a2, 16
4037e6f0:	001465        	call8	4037e838 <tlsf_free>
    multi_heap_internal_unlock(heap);
4037e6f3:	02ad      	mov.n	a10, a2
4037e6f5:	000365        	call8	4037e72c <multi_heap_internal_unlock>
}
4037e6f8:	f01d      	retw.n
	...

4037e6fc <multi_heap_get_allocated_size>:
{
4037e6fc:	004136        	entry	a1, 32
4037e6ff:	03ad      	mov.n	a10, a3
    return tlsf_block_size(p);
4037e701:	0011e5        	call8	4037e820 <tlsf_block_size>
}
4037e704:	0a2d      	mov.n	a2, a10
4037e706:	f01d      	retw.n

4037e708 <multi_heap_internal_lock>:
{
4037e708:	004136        	entry	a1, 32
    MULTI_HEAP_LOCK(heap->lock);
4037e70b:	002272        	l32i	a7, a2, 0
4037e70e:	018716        	beqz	a7, 4037e72a <multi_heap_internal_lock+0x22>
    if (xPortInIsrContext()) {
4037e711:	fb9fa5        	call8	4037a10c <xPortInIsrContext>
4037e714:	8a8c      	beqz.n	a10, 4037e720 <multi_heap_internal_lock+0x18>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037e716:	fb7c      	movi.n	a11, -1
4037e718:	07ad      	mov.n	a10, a7
4037e71a:	fba165        	call8	4037a130 <xPortEnterCriticalTimeout>
4037e71d:	000246        	j	4037e72a <multi_heap_internal_lock+0x22>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037e720:	fb7c      	movi.n	a11, -1
4037e722:	07ad      	mov.n	a10, a7
4037e724:	201110        	or	a1, a1, a1
4037e727:	fba0a5        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037e72a:	f01d      	retw.n

4037e72c <multi_heap_internal_unlock>:
{
4037e72c:	004136        	entry	a1, 32
    MULTI_HEAP_UNLOCK(heap->lock);
4037e72f:	002272        	l32i	a7, a2, 0
4037e732:	013716        	beqz	a7, 4037e749 <multi_heap_internal_unlock+0x1d>
    if (xPortInIsrContext()) {
4037e735:	fb9d65        	call8	4037a10c <xPortInIsrContext>
4037e738:	008a16        	beqz	a10, 4037e744 <multi_heap_internal_unlock+0x18>
        portEXIT_CRITICAL_ISR(mux);
4037e73b:	07ad      	mov.n	a10, a7
4037e73d:	fbb425        	call8	4037a280 <vPortExitCritical>
4037e740:	000146        	j	4037e749 <multi_heap_internal_unlock+0x1d>
4037e743:	07ad00        	lsi	f0, a13, 28
        portEXIT_CRITICAL(mux);
4037e746:	fbb3a5        	call8	4037a280 <vPortExitCritical>
}
4037e749:	f01d      	retw.n
	...

4037e74c <multi_heap_malloc>:
{
4037e74c:	004136        	entry	a1, 32
4037e74f:	207220        	or	a7, a2, a2
    if (size == 0 || heap == NULL) {
4037e752:	40f380        	nsau	a8, a3
4037e755:	418580        	srli	a8, a8, 5
4037e758:	40f290        	nsau	a9, a2
4037e75b:	419590        	srli	a9, a9, 5
4037e75e:	208890        	or	a8, a8, a9
4037e761:	033856        	bnez	a8, 4037e798 <multi_heap_malloc+0x4c>
    multi_heap_internal_lock(heap);
4037e764:	02ad      	mov.n	a10, a2
4037e766:	fffa25        	call8	4037e708 <multi_heap_internal_lock>
    void *result = tlsf_malloc(heap->heap_data, size);
4037e769:	03bd      	mov.n	a11, a3
4037e76b:	42a8      	l32i.n	a10, a2, 16
4037e76d:	004ba5        	call8	4037ec28 <tlsf_malloc>
4037e770:	0a2d      	mov.n	a2, a10
    if(result) {
4037e772:	01aa16        	beqz	a10, 4037e790 <multi_heap_malloc+0x44>
        heap->free_bytes -= tlsf_block_size(result);
4037e775:	000aa5        	call8	4037e820 <tlsf_block_size>
4037e778:	1788      	l32i.n	a8, a7, 4
4037e77a:	c088a0        	sub	a8, a8, a10
4037e77d:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_alloc_overhead();
4037e77f:	0009a5        	call8	4037e818 <tlsf_alloc_overhead>
4037e782:	1788      	l32i.n	a8, a7, 4
4037e784:	c0a8a0        	sub	a10, a8, a10
4037e787:	17a9      	s32i.n	a10, a7, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037e789:	2788      	l32i.n	a8, a7, 8
4037e78b:	01ba87        	bgeu	a10, a8, 4037e790 <multi_heap_malloc+0x44>
            heap->minimum_free_bytes = heap->free_bytes;
4037e78e:	27a9      	s32i.n	a10, a7, 8
    multi_heap_internal_unlock(heap);
4037e790:	07ad      	mov.n	a10, a7
4037e792:	fff9a5        	call8	4037e72c <multi_heap_internal_unlock>
    return result;
4037e795:	000046        	j	4037e79a <multi_heap_malloc+0x4e>
        return NULL;
4037e798:	020c      	movi.n	a2, 0
}
4037e79a:	f01d      	retw.n

4037e79c <multi_heap_realloc>:
{
4037e79c:	004136        	entry	a1, 32
4037e79f:	027d      	mov.n	a7, a2
    assert(heap != NULL);
4037e7a1:	d2cc      	bnez.n	a2, 4037e7b2 <multi_heap_realloc+0x16>
4037e7a3:	d9f9d1        	l32r	a13, 40374f88 <_iram_text_start+0xb84> (3c022a4c <_flash_rodata_start+0x292c>)
4037e7a6:	d9f9c1        	l32r	a12, 40374f8c <_iram_text_start+0xb88> (3c027a6c <__func__$4>)
4037e7a9:	efa0b2        	movi	a11, 239
4037e7ac:	d9f9a1        	l32r	a10, 40374f90 <_iram_text_start+0xb8c> (3c022a3e <_flash_rodata_start+0x291e>)
4037e7af:	015f25        	call8	4037fda0 <__assert_func>
    if (p == NULL) {
4037e7b2:	f3cc      	bnez.n	a3, 4037e7c5 <multi_heap_realloc+0x29>
        return multi_heap_malloc_impl(heap, size);
4037e7b4:	20b440        	or	a11, a4, a4
4037e7b7:	20a220        	or	a10, a2, a2
4037e7ba:	fff925        	call8	4037e74c <multi_heap_malloc>
4037e7bd:	0a2d      	mov.n	a2, a10
4037e7bf:	001206        	j	4037e80b <multi_heap_realloc+0x6f>
4037e7c2:	000000        	ill
    assert_valid_block(heap, block_from_ptr(p));
4037e7c5:	f8c3b2        	addi	a11, a3, -8
4037e7c8:	02ad      	mov.n	a10, a2
4037e7ca:	ffe4a5        	call8	4037e614 <assert_valid_block>
    if (heap == NULL) {
4037e7cd:	03a216        	beqz	a2, 4037e80b <multi_heap_realloc+0x6f>
    multi_heap_internal_lock(heap);
4037e7d0:	02ad      	mov.n	a10, a2
4037e7d2:	fff365        	call8	4037e708 <multi_heap_internal_lock>
    size_t previous_block_size =  tlsf_block_size(p);
4037e7d5:	03ad      	mov.n	a10, a3
4037e7d7:	0004a5        	call8	4037e820 <tlsf_block_size>
4037e7da:	0a6d      	mov.n	a6, a10
    void *result = tlsf_realloc(heap->heap_data, p, size);
4037e7dc:	04cd      	mov.n	a12, a4
4037e7de:	03bd      	mov.n	a11, a3
4037e7e0:	42a8      	l32i.n	a10, a2, 16
4037e7e2:	00e665        	call8	4037f648 <tlsf_realloc>
4037e7e5:	0a2d      	mov.n	a2, a10
    if(result) {
4037e7e7:	5a9c      	beqz.n	a10, 4037e800 <multi_heap_realloc+0x64>
        heap->free_bytes += previous_block_size;
4037e7e9:	1788      	l32i.n	a8, a7, 4
4037e7eb:	886a      	add.n	a8, a8, a6
4037e7ed:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_block_size(result);
4037e7ef:	000325        	call8	4037e820 <tlsf_block_size>
4037e7f2:	1788      	l32i.n	a8, a7, 4
4037e7f4:	c0a8a0        	sub	a10, a8, a10
4037e7f7:	17a9      	s32i.n	a10, a7, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037e7f9:	2788      	l32i.n	a8, a7, 8
4037e7fb:	01ba87        	bgeu	a10, a8, 4037e800 <multi_heap_realloc+0x64>
            heap->minimum_free_bytes = heap->free_bytes;
4037e7fe:	27a9      	s32i.n	a10, a7, 8
    multi_heap_internal_unlock(heap);
4037e800:	07ad      	mov.n	a10, a7
4037e802:	fff2a5        	call8	4037e72c <multi_heap_internal_unlock>
    return result;
4037e805:	000086        	j	4037e80b <multi_heap_realloc+0x6f>
4037e808:	000000        	ill
}
4037e80b:	f01d      	retw.n
4037e80d:	000000        	ill

4037e810 <multi_heap_set_lock>:
{
4037e810:	004136        	entry	a1, 32
    heap->lock = lock;
4037e813:	0239      	s32i.n	a3, a2, 0
}
4037e815:	f01d      	retw.n
	...

4037e818 <tlsf_alloc_overhead>:
{
	return 2 * block_header_overhead;
}

size_t tlsf_alloc_overhead(void)
{
4037e818:	004136        	entry	a1, 32
	return block_header_overhead;
}
4037e81b:	420c      	movi.n	a2, 4
4037e81d:	f01d      	retw.n
	...

4037e820 <tlsf_block_size>:
{
4037e820:	004136        	entry	a1, 32
	if (ptr)
4037e823:	b28c      	beqz.n	a2, 4037e832 <tlsf_block_size+0x12>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e825:	f8c222        	addi	a2, a2, -8
4037e828:	1228      	l32i.n	a2, a2, 4
4037e82a:	c87c      	movi.n	a8, -4
4037e82c:	102280        	and	a2, a2, a8
4037e82f:	000046        	j	4037e834 <tlsf_block_size+0x14>
	size_t size = 0;
4037e832:	020c      	movi.n	a2, 0
}
4037e834:	f01d      	retw.n
	...

4037e838 <tlsf_free>:
	return tlsf_memalign_offs(tlsf, align, size, 0);
}


void tlsf_free(tlsf_t tlsf, void* ptr)
{
4037e838:	004136        	entry	a1, 32
	/* Don't attempt to free a NULL pointer. */
	if (ptr)
4037e83b:	3d9316        	beqz	a3, 4037ec18 <tlsf_free+0x3e0>
	return tlsf_cast(block_header_t*,
4037e83e:	f8c372        	addi	a7, a3, -8
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e841:	1798      	l32i.n	a9, a7, 4
	{
		control_t* control = tlsf_cast(control_t*, tlsf);
		block_header_t* block = block_from_ptr(ptr);
		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037e843:	0e6907        	bbci	a9, 0, 4037e855 <tlsf_free+0x1d>
4037e846:	d9d3d1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c023074 <_flash_rodata_start+0x2f54>)
4037e849:	d9d3c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c027af8 <__func__$6>)
4037e84c:	75a2b2        	movi	a11, 0x275
4037e84f:	d9d3a1        	l32r	a10, 40374f9c <_iram_text_start+0xb98> (3c022adb <_flash_rodata_start+0x29bb>)
4037e852:	0154e5        	call8	4037fda0 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e855:	c87c      	movi.n	a8, -4
4037e857:	108980        	and	a8, a9, a8
}

/* Return location of next existing block. */
static inline __attribute__((always_inline)) block_header_t* block_next(const block_header_t* block)
{
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e85a:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e85d:	883a      	add.n	a8, a8, a3
		block_size(block) - block_header_overhead);
	tlsf_assert(!block_is_last(block));
4037e85f:	3a0c      	movi.n	a10, 3
4037e861:	0e3a97        	bltu	a10, a9, 4037e873 <tlsf_free+0x3b>
4037e864:	d9cfd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037e867:	d9cfc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037e86a:	a1a0b2        	movi	a11, 161
4037e86d:	d9cea1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037e870:	0152e5        	call8	4037fda0 <__assert_func>

/* Link a new block with its physical neighbor, return the neighbor. */
static inline __attribute__((always_inline)) block_header_t* block_link_next(block_header_t* block)
{
	block_header_t* next = block_next(block);
	next->prev_phys_block = block;
4037e873:	0879      	s32i.n	a7, a8, 0
	block->size |= block_header_prev_free_bit;
4037e875:	1898      	l32i.n	a9, a8, 4
4037e877:	2a0c      	movi.n	a10, 2
4037e879:	2099a0        	or	a9, a9, a10
4037e87c:	1899      	s32i.n	a9, a8, 4
	block->size |= block_header_free_bit;
4037e87e:	f8c3b2        	addi	a11, a3, -8
4037e881:	1b98      	l32i.n	a9, a11, 4
4037e883:	180c      	movi.n	a8, 1
4037e885:	208980        	or	a8, a9, a8
4037e888:	1b89      	s32i.n	a8, a11, 4
}

/* Merge a just-freed block with an adjacent previous free block. */
tlsf_decl block_header_t* block_merge_prev(control_t* control, block_header_t* block)
{
	if (block_is_prev_free(block))
4037e88a:	0289a7        	bany	a9, a10, 4037e890 <tlsf_free+0x58>
4037e88d:	005506        	j	4037e9e5 <tlsf_free+0x1ad>
	return block->prev_phys_block;
4037e890:	0b68      	l32i.n	a6, a11, 0
	{
		block_header_t* prev = block_prev(block);
		tlsf_assert(prev && "prev physical block can't be null");
4037e892:	00e656        	bnez	a6, 4037e8a4 <tlsf_free+0x6c>
4037e895:	d9c5d1        	l32r	a13, 40374fac <_iram_text_start+0xba8> (3c0230ac <_flash_rodata_start+0x2f8c>)
4037e898:	d9c6c1        	l32r	a12, 40374fb0 <_iram_text_start+0xbac> (3c027ae4 <__func__$5>)
4037e89b:	08a2b2        	movi	a11, 0x208
4037e89e:	d9c5a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e8a1:	014fe5        	call8	4037fda0 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e8a4:	1688      	l32i.n	a8, a6, 4
		tlsf_assert(block_is_free(prev) && "prev block is not free though marked as such");
4037e8a6:	0ee807        	bbsi	a8, 0, 4037e8b8 <tlsf_free+0x80>
4037e8a9:	d9c3d1        	l32r	a13, 40374fb8 <_iram_text_start+0xbb4> (3c0230d8 <_flash_rodata_start+0x2fb8>)
4037e8ac:	d9c1c1        	l32r	a12, 40374fb0 <_iram_text_start+0xbac> (3c027ae4 <__func__$5>)
4037e8af:	09a2b2        	movi	a11, 0x209
4037e8b2:	d9c0a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e8b5:	014ea5        	call8	4037fda0 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e8b8:	c97c      	movi.n	a9, -4
4037e8ba:	108890        	and	a8, a8, a9
	if (size < control->small_block_size)
4037e8bd:	4298      	l32i.n	a9, a2, 16
4037e8bf:	759790        	extui	a9, a9, 23, 8
4037e8c2:	0fb897        	bgeu	a8, a9, 4037e8d5 <tlsf_free+0x9d>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e8c5:	42a8      	l32i.n	a10, a2, 16
4037e8c7:	54aea0        	extui	a10, a10, 14, 6
4037e8ca:	d299a0        	quos	a9, a9, a10
4037e8cd:	d2a890        	quos	a10, a8, a9
		fl = 0;
4037e8d0:	0b0c      	movi.n	a11, 0
4037e8d2:	000d86        	j	4037e90c <tlsf_free+0xd4>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e8d5:	d88c      	beqz.n	a8, 4037e8e6 <tlsf_free+0xae>
4037e8d7:	40f8b0        	nsau	a11, a8
4037e8da:	e0cbb2        	addi	a11, a11, -32
4037e8dd:	60b0b0        	neg	a11, a11
4037e8e0:	000146        	j	4037e8e9 <tlsf_free+0xb1>
4037e8e3:	000000        	ill
4037e8e6:	00a0b2        	movi	a11, 0
	return bit - 1;
4037e8e9:	ffcba2        	addi	a10, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e8ec:	042292        	l32i	a9, a2, 16
4037e8ef:	25c490        	extui	a12, a9, 20, 3
4037e8f2:	c0aac0        	sub	a10, a10, a12
4037e8f5:	400a00        	ssr	a10
4037e8f8:	918080        	srl	a8, a8
4037e8fb:	1a0c      	movi.n	a10, 1
4037e8fd:	401c00        	ssl	a12
4037e900:	a1aa00        	sll	a10, a10
4037e903:	30a8a0        	xor	a10, a8, a10
		fl -= (control->fl_index_shift - 1);
4037e906:	249590        	extui	a9, a9, 5, 3
4037e909:	c0bb90        	sub	a11, a11, a9
	block_header_t* prev = block->prev_free;
4037e90c:	3698      	l32i.n	a9, a6, 12
	block_header_t* next = block->next_free;
4037e90e:	26c8      	l32i.n	a12, a6, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037e910:	00e956        	bnez	a9, 4037e922 <tlsf_free+0xea>
4037e913:	d9aad1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037e916:	d9aac1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037e919:	74a1b2        	movi	a11, 0x174
4037e91c:	d9a6a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e91f:	014825        	call8	4037fda0 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037e922:	0cdc      	bnez.n	a12, 4037e936 <tlsf_free+0xfe>
4037e924:	d9a8d1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037e927:	d9a6c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037e92a:	75a1b2        	movi	a11, 0x175
4037e92d:	d9a1a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e930:	201110        	or	a1, a1, a1
4037e933:	0146e5        	call8	4037fda0 <__assert_func>
	next->prev_free = prev;
4037e936:	3c99      	s32i.n	a9, a12, 12
	prev->next_free = next;
4037e938:	29c9      	s32i.n	a12, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037e93a:	8298      	l32i.n	a9, a2, 32
4037e93c:	4288      	l32i.n	a8, a2, 16
4037e93e:	548e80        	extui	a8, a8, 14, 6
4037e941:	8288b0        	mull	a8, a8, a11
4037e944:	88aa      	add.n	a8, a8, a10
4037e946:	a08890        	addx4	a8, a8, a9
4037e949:	0898      	l32i.n	a9, a8, 0
4037e94b:	369697        	bne	a6, a9, 4037e985 <tlsf_free+0x14d>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037e94e:	08c9      	s32i.n	a12, a8, 0
		if (next == &control->block_null)
4037e950:	319c27        	bne	a12, a2, 4037e985 <tlsf_free+0x14d>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037e953:	7298      	l32i.n	a9, a2, 28
4037e955:	a09b90        	addx4	a9, a11, a9
4037e958:	09c8      	l32i.n	a12, a9, 0
4037e95a:	180c      	movi.n	a8, 1
4037e95c:	401a00        	ssl	a10
4037e95f:	a18800        	sll	a8, a8
4037e962:	1088c0        	and	a8, a8, a12
4037e965:	3088c0        	xor	a8, a8, a12
4037e968:	0989      	s32i.n	a8, a9, 0
			if (!control->sl_bitmap[fl])
4037e96a:	7288      	l32i.n	a8, a2, 28
4037e96c:	a08b80        	addx4	a8, a11, a8
4037e96f:	0888      	l32i.n	a8, a8, 0
4037e971:	08dc      	bnez.n	a8, 4037e985 <tlsf_free+0x14d>
				control->fl_bitmap &= ~(1U << fl);
4037e973:	6298      	l32i.n	a9, a2, 24
4037e975:	180c      	movi.n	a8, 1
4037e977:	401b00        	ssl	a11
4037e97a:	a18800        	sll	a8, a8
4037e97d:	108890        	and	a8, a8, a9
4037e980:	308890        	xor	a8, a8, a9
4037e983:	6289      	s32i.n	a8, a2, 24
4037e985:	1698      	l32i.n	a9, a6, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037e987:	380c      	movi.n	a8, 3
4037e989:	0e3897        	bltu	a8, a9, 4037e99b <tlsf_free+0x163>
4037e98c:	d98fd1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037e98f:	d98fc1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027ad4 <__func__$3>)
4037e992:	f5a1b2        	movi	a11, 0x1f5
4037e995:	d987a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e998:	014065        	call8	4037fda0 <__assert_func>
4037e99b:	f8c332        	addi	a3, a3, -8
4037e99e:	13a8      	l32i.n	a10, a3, 4
4037e9a0:	c87c      	movi.n	a8, -4
4037e9a2:	10aa80        	and	a10, a10, a8
	prev->size += block_size(block) + block_header_overhead;
4037e9a5:	aa4b      	addi.n	a10, a10, 4
4037e9a7:	99aa      	add.n	a9, a9, a10
4037e9a9:	1699      	s32i.n	a9, a6, 4
	return tlsf_cast(void*,
4037e9ab:	a68b      	addi.n	a10, a6, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e9ad:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e9b0:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e9b3:	88aa      	add.n	a8, a8, a10
	tlsf_assert(!block_is_last(block));
4037e9b5:	3a0c      	movi.n	a10, 3
4037e9b7:	0e3a97        	bltu	a10, a9, 4037e9c9 <tlsf_free+0x191>
4037e9ba:	d979d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037e9bd:	d979c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037e9c0:	a1a0b2        	movi	a11, 161
4037e9c3:	d979a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037e9c6:	013da5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037e9c9:	0869      	s32i.n	a6, a8, 0
	if (block_absorb_post_hook != NULL)
4037e9cb:	d98181        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037e9ce:	089c      	beqz.n	a8, 4037e9e2 <tlsf_free+0x1aa>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037e9d0:	1c0c      	movi.n	a12, 1
4037e9d2:	0b1c      	movi.n	a11, 16
4037e9d4:	07ad      	mov.n	a10, a7
4037e9d6:	d97e81        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037e9d9:	0008e0        	callx8	a8
		block_remove(control, prev);
		block = block_absorb(prev, block);
4037e9dc:	067d      	mov.n	a7, a6
4037e9de:	0000c6        	j	4037e9e5 <tlsf_free+0x1ad>
4037e9e1:	766000        	lsi	f0, a0, 0x1d8
4037e9e4:	c73220        	lsi	f2, a2, 0x31c
	return tlsf_cast(void*,
4037e9e7:	8808      	l32i.n	a0, a8, 32
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e9e9:	ca7c17        	bbci	a12, 17, 4037e9b7 <tlsf_free+0x17f>
4037e9ec:	10a8a0        	and	a10, a8, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e9ef:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e9f2:	aa3a      	add.n	a10, a10, a3
4037e9f4:	0a9d      	mov.n	a9, a10
	tlsf_assert(!block_is_last(block));
4037e9f6:	03a0b2        	movi	a11, 3
4037e9f9:	0e3b87        	bltu	a11, a8, 4037ea0b <tlsf_free+0x1d3>
4037e9fc:	d969d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037e9ff:	d969c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037ea02:	a1a0b2        	movi	a11, 161
4037ea05:	d968a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037ea08:	013965        	call8	4037fda0 <__assert_func>

/* Merge a just-freed block with an adjacent free block. */
tlsf_decl block_header_t* block_merge_next(control_t* control, block_header_t* block)
{
	block_header_t* next = block_next(block);
	tlsf_assert(next && "next physical block can't be null");
4037ea0b:	dacc      	bnez.n	a10, 4037ea1c <tlsf_free+0x1e4>
4037ea0d:	d971d1        	l32r	a13, 40374fd4 <_iram_text_start+0xbd0> (3c023158 <_flash_rodata_start+0x3038>)
4037ea10:	d972c1        	l32r	a12, 40374fd8 <_iram_text_start+0xbd4> (3c027ac0 <__func__$2>)
4037ea13:	15a2b2        	movi	a11, 0x215
4037ea16:	d967a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ea19:	013865        	call8	4037fda0 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037ea1c:	1a88      	l32i.n	a8, a10, 4

	if (block_is_free(next))
4037ea1e:	02e807        	bbsi	a8, 0, 4037ea24 <tlsf_free+0x1ec>
4037ea21:	004646        	j	4037eb3e <tlsf_free+0x306>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ea24:	cb7c      	movi.n	a11, -4
4037ea26:	10c8b0        	and	a12, a8, a11
	if (size < control->small_block_size)
4037ea29:	4288      	l32i.n	a8, a2, 16
4037ea2b:	758780        	extui	a8, a8, 23, 8
4037ea2e:	0fbc87        	bgeu	a12, a8, 4037ea41 <tlsf_free+0x209>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037ea31:	42b8      	l32i.n	a11, a2, 16
4037ea33:	54beb0        	extui	a11, a11, 14, 6
4037ea36:	d288b0        	quos	a8, a8, a11
4037ea39:	d2cc80        	quos	a12, a12, a8
		fl = 0;
4037ea3c:	0b0c      	movi.n	a11, 0
4037ea3e:	000d46        	j	4037ea77 <tlsf_free+0x23f>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ea41:	cc8c      	beqz.n	a12, 4037ea51 <tlsf_free+0x219>
4037ea43:	40fcd0        	nsau	a13, a12
4037ea46:	e0cdd2        	addi	a13, a13, -32
4037ea49:	60d0d0        	neg	a13, a13
4037ea4c:	000106        	j	4037ea54 <tlsf_free+0x21c>
4037ea4f:	d20000        	quos	a0, a0, a0
4037ea52:	8200a0        	mull	a0, a0, a10
	return bit - 1;
4037ea55:	ffcd      	lsi	f12, a15, 60
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037ea57:	0422b2        	l32i	a11, a2, 16
4037ea5a:	25e4b0        	extui	a14, a11, 20, 3
4037ea5d:	c088e0        	sub	a8, a8, a14
4037ea60:	400800        	ssr	a8
4037ea63:	9180c0        	srl	a8, a12
4037ea66:	1c0c      	movi.n	a12, 1
4037ea68:	401e00        	ssl	a14
4037ea6b:	a1cc00        	sll	a12, a12
4037ea6e:	30c8c0        	xor	a12, a8, a12
		fl -= (control->fl_index_shift - 1);
4037ea71:	24b5b0        	extui	a11, a11, 5, 3
4037ea74:	c0bdb0        	sub	a11, a13, a11
	block_header_t* prev = block->prev_free;
4037ea77:	3a88      	l32i.n	a8, a10, 12
	block_header_t* next = block->next_free;
4037ea79:	2ad8      	l32i.n	a13, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037ea7b:	00e856        	bnez	a8, 4037ea8d <tlsf_free+0x255>
4037ea7e:	d94fd1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037ea81:	d94fc1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037ea84:	74a1b2        	movi	a11, 0x174
4037ea87:	d94ba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ea8a:	013165        	call8	4037fda0 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037ea8d:	ddcc      	bnez.n	a13, 4037ea9e <tlsf_free+0x266>
4037ea8f:	d94dd1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037ea92:	d94bc1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037ea95:	75a1b2        	movi	a11, 0x175
4037ea98:	d947a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ea9b:	013065        	call8	4037fda0 <__assert_func>
	next->prev_free = prev;
4037ea9e:	3d89      	s32i.n	a8, a13, 12
	prev->next_free = next;
4037eaa0:	0268d2        	s32i	a13, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037eaa3:	82e8      	l32i.n	a14, a2, 32
4037eaa5:	4288      	l32i.n	a8, a2, 16
4037eaa7:	548e80        	extui	a8, a8, 14, 6
4037eaaa:	8288b0        	mull	a8, a8, a11
4037eaad:	88ca      	add.n	a8, a8, a12
4037eaaf:	a088e0        	addx4	a8, a8, a14
4037eab2:	08e8      	l32i.n	a14, a8, 0
4037eab4:	3699e7        	bne	a9, a14, 4037eaee <tlsf_free+0x2b6>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037eab7:	08d9      	s32i.n	a13, a8, 0
		if (next == &control->block_null)
4037eab9:	319d27        	bne	a13, a2, 4037eaee <tlsf_free+0x2b6>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037eabc:	7298      	l32i.n	a9, a2, 28
4037eabe:	a09b90        	addx4	a9, a11, a9
4037eac1:	09d8      	l32i.n	a13, a9, 0
4037eac3:	180c      	movi.n	a8, 1
4037eac5:	401c00        	ssl	a12
4037eac8:	a18800        	sll	a8, a8
4037eacb:	1088d0        	and	a8, a8, a13
4037eace:	3088d0        	xor	a8, a8, a13
4037ead1:	0989      	s32i.n	a8, a9, 0
			if (!control->sl_bitmap[fl])
4037ead3:	7288      	l32i.n	a8, a2, 28
4037ead5:	a08b80        	addx4	a8, a11, a8
4037ead8:	0888      	l32i.n	a8, a8, 0
4037eada:	08dc      	bnez.n	a8, 4037eaee <tlsf_free+0x2b6>
				control->fl_bitmap &= ~(1U << fl);
4037eadc:	6298      	l32i.n	a9, a2, 24
4037eade:	180c      	movi.n	a8, 1
4037eae0:	401b00        	ssl	a11
4037eae3:	a18800        	sll	a8, a8
4037eae6:	108890        	and	a8, a8, a9
4037eae9:	308890        	xor	a8, a8, a9
4037eaec:	6289      	s32i.n	a8, a2, 24
4037eaee:	1798      	l32i.n	a9, a7, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037eaf0:	380c      	movi.n	a8, 3
4037eaf2:	0e3897        	bltu	a8, a9, 4037eb04 <tlsf_free+0x2cc>
4037eaf5:	d934d1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037eaf8:	d935c1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027ad4 <__func__$3>)
4037eafb:	f5a1b2        	movi	a11, 0x1f5
4037eafe:	d92da1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037eb01:	0129e5        	call8	4037fda0 <__assert_func>
4037eb04:	1ab8      	l32i.n	a11, a10, 4
4037eb06:	c87c      	movi.n	a8, -4
4037eb08:	10bb80        	and	a11, a11, a8
	prev->size += block_size(block) + block_header_overhead;
4037eb0b:	bb4b      	addi.n	a11, a11, 4
4037eb0d:	99ba      	add.n	a9, a9, a11
4037eb0f:	1799      	s32i.n	a9, a7, 4
4037eb11:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037eb14:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037eb17:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037eb19:	3b0c      	movi.n	a11, 3
4037eb1b:	0e3b97        	bltu	a11, a9, 4037eb2d <tlsf_free+0x2f5>
4037eb1e:	d920d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037eb21:	d920c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037eb24:	a1a0b2        	movi	a11, 161
4037eb27:	d920a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037eb2a:	012765        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037eb2d:	0879      	s32i.n	a7, a8, 0
	if (block_absorb_post_hook != NULL)
4037eb2f:	d92881        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037eb32:	888c      	beqz.n	a8, 4037eb3e <tlsf_free+0x306>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037eb34:	1c0c      	movi.n	a12, 1
4037eb36:	0b1c      	movi.n	a11, 16
4037eb38:	d92681        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037eb3b:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037eb3e:	1798      	l32i.n	a9, a7, 4
4037eb40:	c87c      	movi.n	a8, -4
4037eb42:	109980        	and	a9, a9, a8
	if (size < control->small_block_size)
4037eb45:	4288      	l32i.n	a8, a2, 16
4037eb47:	758780        	extui	a8, a8, 23, 8
4037eb4a:	0fb987        	bgeu	a9, a8, 4037eb5d <tlsf_free+0x325>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037eb4d:	42a8      	l32i.n	a10, a2, 16
4037eb4f:	54aea0        	extui	a10, a10, 14, 6
4037eb52:	d288a0        	quos	a8, a8, a10
4037eb55:	d29980        	quos	a9, a9, a8
		fl = 0;
4037eb58:	0a0c      	movi.n	a10, 0
4037eb5a:	000d06        	j	4037eb92 <tlsf_free+0x35a>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037eb5d:	b98c      	beqz.n	a9, 4037eb6c <tlsf_free+0x334>
4037eb5f:	40f9a0        	nsau	a10, a9
4037eb62:	e0caa2        	addi	a10, a10, -32
4037eb65:	60a0a0        	neg	a10, a10
4037eb68:	0000c6        	j	4037eb6f <tlsf_free+0x337>
4037eb6b:	a0a200        	addx4	a10, a2, a0
4037eb6e:	cab200        	float.s	f11, a2, 0
	return bit - 1;
4037eb71:	ff          	.byte	0xff
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037eb72:	042282        	l32i	a8, a2, 16
4037eb75:	25c480        	extui	a12, a8, 20, 3
4037eb78:	c0bbc0        	sub	a11, a11, a12
4037eb7b:	400b00        	ssr	a11
4037eb7e:	919090        	srl	a9, a9
4037eb81:	1b0c      	movi.n	a11, 1
4037eb83:	401c00        	ssl	a12
4037eb86:	a1bb00        	sll	a11, a11
4037eb89:	3099b0        	xor	a9, a9, a11
		fl -= (control->fl_index_shift - 1);
4037eb8c:	248580        	extui	a8, a8, 5, 3
4037eb8f:	c0aa80        	sub	a10, a10, a8
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037eb92:	82b8      	l32i.n	a11, a2, 32
4037eb94:	4288      	l32i.n	a8, a2, 16
4037eb96:	548e80        	extui	a8, a8, 14, 6
4037eb99:	8288a0        	mull	a8, a8, a10
4037eb9c:	889a      	add.n	a8, a8, a9
4037eb9e:	a088b0        	addx4	a8, a8, a11
4037eba1:	0888      	l32i.n	a8, a8, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037eba3:	d8cc      	bnez.n	a8, 4037ebb4 <tlsf_free+0x37c>
4037eba5:	d90dd1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037eba8:	d90ec1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037ebab:	90a1b2        	movi	a11, 0x190
4037ebae:	d901a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ebb1:	011ee5        	call8	4037fda0 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037ebb4:	d7cc      	bnez.n	a7, 4037ebc5 <tlsf_free+0x38d>
4037ebb6:	d90bd1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037ebb9:	d909c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037ebbc:	91a1b2        	movi	a11, 0x191
4037ebbf:	d8fda1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ebc2:	011de5        	call8	4037fda0 <__assert_func>
	block->next_free = current;
4037ebc5:	2789      	s32i.n	a8, a7, 8
	block->prev_free = &control->block_null;
4037ebc7:	036722        	s32i	a2, a7, 12
	current->prev_free = block;
4037ebca:	036872        	s32i	a7, a8, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037ebcd:	833b      	addi.n	a8, a3, 3
4037ebcf:	cb7c      	movi.n	a11, -4
4037ebd1:	1088b0        	and	a8, a8, a11
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037ebd4:	0e1387        	beq	a3, a8, 4037ebe6 <tlsf_free+0x3ae>
4037ebd7:	d904d1        	l32r	a13, 40374fe8 <_iram_text_start+0xbe4> (3c022cb0 <_flash_rodata_start+0x2b90>)
4037ebda:	d901c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037ebdd:	96a1b2        	movi	a11, 0x196
4037ebe0:	d8f5a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ebe3:	011be5        	call8	4037fda0 <__assert_func>
	control->blocks[fl * control->sl_index_count + sl] = block;
4037ebe6:	82b8      	l32i.n	a11, a2, 32
4037ebe8:	4288      	l32i.n	a8, a2, 16
4037ebea:	548e80        	extui	a8, a8, 14, 6
4037ebed:	828a80        	mull	a8, a10, a8
4037ebf0:	898a      	add.n	a8, a9, a8
4037ebf2:	a088b0        	addx4	a8, a8, a11
4037ebf5:	0879      	s32i.n	a7, a8, 0
	control->fl_bitmap |= (1U << fl);
4037ebf7:	62b8      	l32i.n	a11, a2, 24
4037ebf9:	180c      	movi.n	a8, 1
4037ebfb:	401a00        	ssl	a10
4037ebfe:	a1c800        	sll	a12, a8
4037ec01:	20bbc0        	or	a11, a11, a12
4037ec04:	62b9      	s32i.n	a11, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037ec06:	72b8      	l32i.n	a11, a2, 28
4037ec08:	a0aab0        	addx4	a10, a10, a11
4037ec0b:	0ab8      	l32i.n	a11, a10, 0
4037ec0d:	401900        	ssl	a9
4037ec10:	a18800        	sll	a8, a8
4037ec13:	208b80        	or	a8, a11, a8
4037ec16:	0a89      	s32i.n	a8, a10, 0
		block_mark_as_free(block);
		block = block_merge_prev(control, block);
		block = block_merge_next(control, block);
		block_insert(control, block);
	}
}
4037ec18:	f01d      	retw.n
	...

4037ec1c <tlsf_get_pool>:
{
4037ec1c:	004136        	entry	a1, 32
	return tlsf_cast(pool_t, (char*)tlsf + tlsf_size(tlsf));
4037ec1f:	02ad      	mov.n	a10, a2
4037ec21:	00f625        	call8	4037fb84 <tlsf_size>
}
4037ec24:	22aa      	add.n	a2, a2, a10
4037ec26:	f01d      	retw.n

4037ec28 <tlsf_malloc>:
{
4037ec28:	004136        	entry	a1, 32
4037ec2b:	028d      	mov.n	a8, a2
	if (size)
4037ec2d:	3af316        	beqz	a3, 4037efe0 <tlsf_malloc+0x3b8>
	return (x + (align - 1)) & ~(align - 1);
4037ec30:	333b      	addi.n	a3, a3, 3
4037ec32:	c97c      	movi.n	a9, -4
4037ec34:	103390        	and	a3, a3, a9
	if (control == NULL)
4037ec37:	3aa216        	beqz	a2, 4037efe5 <tlsf_malloc+0x3bd>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037ec3a:	42a8      	l32i.n	a10, a2, 16
4037ec3c:	54a8a0        	extui	a10, a10, 8, 6
4037ec3f:	190c      	movi.n	a9, 1
4037ec41:	401a00        	ssl	a10
4037ec44:	a19900        	sll	a9, a9
		if (aligned < tlsf_block_size_max(control)) 
4037ec47:	023397        	bltu	a3, a9, 4037ec4d <tlsf_malloc+0x25>
4037ec4a:	00e686        	j	4037efe8 <tlsf_malloc+0x3c0>
			adjust = tlsf_max(aligned, block_size_min);
4037ec4d:	c90c      	movi.n	a9, 12
4037ec4f:	733390        	maxu	a3, a3, a9
	if (*size >= control->small_block_size)
4037ec52:	4298      	l32i.n	a9, a2, 16
4037ec54:	759790        	extui	a9, a9, 23, 8
4037ec57:	09cd      	mov.n	a12, a9
4037ec59:	373397        	bltu	a3, a9, 4037ec94 <tlsf_malloc+0x6c>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ec5c:	40f3a0        	nsau	a10, a3
	return bit - 1;
4037ec5f:	e1caa2        	addi	a10, a10, -31
4037ec62:	60a0a0        	neg	a10, a10
		const size_t round = (1 << (tlsf_fls_sizet(*size) - control->sl_index_count_log2));
4037ec65:	42b8      	l32i.n	a11, a2, 16
4037ec67:	25b4b0        	extui	a11, a11, 20, 3
4037ec6a:	c0bab0        	sub	a11, a10, a11
4037ec6d:	1a0c      	movi.n	a10, 1
4037ec6f:	401b00        	ssl	a11
4037ec72:	a1aa00        	sll	a10, a10
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037ec75:	ffcab2        	addi	a11, a10, -1
4037ec78:	0e0ab7        	bnone	a10, a11, 4037ec8a <tlsf_malloc+0x62>
4037ec7b:	d8dcd1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037ec7e:	d8dcc1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c027bbc <__func__$19>)
4037ec81:	f3a0b2        	movi	a11, 243
4037ec84:	d8cca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ec87:	0111a5        	call8	4037fda0 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037ec8a:	33aa      	add.n	a3, a3, a10
4037ec8c:	330b      	addi.n	a3, a3, -1
4037ec8e:	60a0a0        	neg	a10, a10
4037ec91:	1033a0        	and	a3, a3, a10
	if (size < control->small_block_size)
4037ec94:	10b3c7        	bgeu	a3, a12, 4037eca8 <tlsf_malloc+0x80>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037ec97:	48a8      	l32i.n	a10, a8, 16
4037ec99:	54aea0        	extui	a10, a10, 14, 6
4037ec9c:	d299a0        	quos	a9, a9, a10
4037ec9f:	d29390        	quos	a9, a3, a9
		fl = 0;
4037eca2:	0a0c      	movi.n	a10, 0
4037eca4:	000c86        	j	4037ecda <tlsf_malloc+0xb2>
4037eca7:	a38c00        	movltz	a8, a12, a0
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ecaa:	40f3a0        	nsau	a10, a3
4037ecad:	e0caa2        	addi	a10, a10, -32
4037ecb0:	60a0a0        	neg	a10, a10
4037ecb3:	000086        	j	4037ecb9 <tlsf_malloc+0x91>
4037ecb6:	00a0a2        	movi	a10, 0
	return bit - 1;
4037ecb9:	9a0b      	addi.n	a9, a10, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037ecbb:	48b8      	l32i.n	a11, a8, 16
4037ecbd:	25d4b0        	extui	a13, a11, 20, 3
4037ecc0:	c099d0        	sub	a9, a9, a13
4037ecc3:	400900        	ssr	a9
4037ecc6:	919030        	srl	a9, a3
4037ecc9:	1c0c      	movi.n	a12, 1
4037eccb:	401d00        	ssl	a13
4037ecce:	a1cc00        	sll	a12, a12
4037ecd1:	3099c0        	xor	a9, a9, a12
		fl -= (control->fl_index_shift - 1);
4037ecd4:	24b5b0        	extui	a11, a11, 5, 3
4037ecd7:	c0aab0        	sub	a10, a10, a11
		** mapping_search can futz with the size, so for excessively large sizes it can sometimes wind up 
		** with indices that are off the end of the block array.
		** So, we protect against that here, since this is the only callsite of mapping_search.
		** Note that we don't need to check sl, since it comes from a modulo operation that guarantees it's always in range.
		*/
		if (fl < control->fl_index_count)
4037ecda:	48b8      	l32i.n	a11, a8, 16
4037ecdc:	44b0b0        	extui	a11, a11, 0, 5
4037ecdf:	022ab7        	blt	a10, a11, 4037ece5 <tlsf_malloc+0xbd>
4037ece2:	00c1c6        	j	4037efed <tlsf_malloc+0x3c5>
	unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
4037ece5:	78c8      	l32i.n	a12, a8, 28
4037ece7:	a0bac0        	addx4	a11, a10, a12
4037ecea:	0bd8      	l32i.n	a13, a11, 0
4037ecec:	fb7c      	movi.n	a11, -1
4037ecee:	401900        	ssl	a9
4037ecf1:	a19b00        	sll	a9, a11
4037ecf4:	10bd90        	and	a11, a13, a9
	if (!sl_map)
4037ecf7:	3b8d97        	bany	a13, a9, 4037ed36 <tlsf_malloc+0x10e>
		const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
4037ecfa:	68b8      	l32i.n	a11, a8, 24
4037ecfc:	aa1b      	addi.n	a10, a10, 1
4037ecfe:	f97c      	movi.n	a9, -1
4037ed00:	401a00        	ssl	a10
4037ed03:	a19900        	sll	a9, a9
4037ed06:	10db90        	and	a13, a11, a9
		if (!fl_map)
4037ed09:	028b97        	bany	a11, a9, 4037ed0f <tlsf_malloc+0xe7>
4037ed0c:	00b886        	j	4037eff2 <tlsf_malloc+0x3ca>
	return __builtin_ffs(word) - 1;
4037ed0f:	60a0d0        	neg	a10, a13
4037ed12:	10aad0        	and	a10, a10, a13
4037ed15:	40faa0        	nsau	a10, a10
4037ed18:	e1caa2        	addi	a10, a10, -31
4037ed1b:	60a0a0        	neg	a10, a10
		sl_map = control->sl_bitmap[fl];
4037ed1e:	a0cac0        	addx4	a12, a10, a12
4037ed21:	002cb2        	l32i	a11, a12, 0
	tlsf_assert(sl_map && "internal error - second level bitmap is null");
4037ed24:	00eb56        	bnez	a11, 4037ed36 <tlsf_malloc+0x10e>
4037ed27:	d8b3d1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c022ea0 <_flash_rodata_start+0x2d80>)
4037ed2a:	d8b3c1        	l32r	a12, 40374ff8 <_iram_text_start+0xbf4> (3c027b48 <__func__$11>)
4037ed2d:	67a1b2        	movi	a11, 0x167
4037ed30:	d8a1a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ed33:	0106e5        	call8	4037fda0 <__assert_func>
	return __builtin_ffs(word) - 1;
4037ed36:	6090b0        	neg	a9, a11
4037ed39:	1099b0        	and	a9, a9, a11
4037ed3c:	40f990        	nsau	a9, a9
4037ed3f:	e1c9b2        	addi	a11, a9, -31
4037ed42:	60b0b0        	neg	a11, a11
	return control->blocks[fl * control->sl_index_count + sl];
4037ed45:	88c8      	l32i.n	a12, a8, 32
4037ed47:	4898      	l32i.n	a9, a8, 16
4037ed49:	549e90        	extui	a9, a9, 14, 6
4037ed4c:	8299a0        	mull	a9, a9, a10
4037ed4f:	9b9a      	add.n	a9, a11, a9
4037ed51:	a099c0        	addx4	a9, a9, a12
4037ed54:	0928      	l32i.n	a2, a9, 0
		{
			block = search_suitable_block(control, &fl, &sl);
		}
	}

	if (block)
4037ed56:	29a216        	beqz	a2, 4037eff4 <tlsf_malloc+0x3cc>
4037ed59:	1298      	l32i.n	a9, a2, 4
4037ed5b:	fcafc2        	movi	a12, -4
4037ed5e:	1099c0        	and	a9, a9, a12
	{
		tlsf_assert(block_size(block) >= *size);
4037ed61:	0eb937        	bgeu	a9, a3, 4037ed73 <tlsf_malloc+0x14b>
4037ed64:	d8a6d1        	l32r	a13, 40374ffc <_iram_text_start+0xbf8> (3c022edc <_flash_rodata_start+0x2dbc>)
4037ed67:	d8a6c1        	l32r	a12, 40375000 <_iram_text_start+0xbfc> (3c027b60 <__func__$12>)
4037ed6a:	6aa2b2        	movi	a11, 0x26a
4037ed6d:	d891a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ed70:	0102e5        	call8	4037fda0 <__assert_func>
	block_header_t* prev = block->prev_free;
4037ed73:	3298      	l32i.n	a9, a2, 12
	block_header_t* next = block->next_free;
4037ed75:	22c8      	l32i.n	a12, a2, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037ed77:	00e956        	bnez	a9, 4037ed89 <tlsf_malloc+0x161>
4037ed7a:	d890d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037ed7d:	d890c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037ed80:	74a1b2        	movi	a11, 0x174
4037ed83:	d88ca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ed86:	0101a5        	call8	4037fda0 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037ed89:	dccc      	bnez.n	a12, 4037ed9a <tlsf_malloc+0x172>
4037ed8b:	d88ed1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037ed8e:	d88cc1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037ed91:	75a1b2        	movi	a11, 0x175
4037ed94:	d888a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ed97:	0100a5        	call8	4037fda0 <__assert_func>
	next->prev_free = prev;
4037ed9a:	3c99      	s32i.n	a9, a12, 12
	prev->next_free = next;
4037ed9c:	29c9      	s32i.n	a12, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037ed9e:	88d8      	l32i.n	a13, a8, 32
4037eda0:	4898      	l32i.n	a9, a8, 16
4037eda2:	549e90        	extui	a9, a9, 14, 6
4037eda5:	829a90        	mull	a9, a10, a9
4037eda8:	9b9a      	add.n	a9, a11, a9
4037edaa:	a099d0        	addx4	a9, a9, a13
4037edad:	09d8      	l32i.n	a13, a9, 0
4037edaf:	3792d7        	bne	a2, a13, 4037edea <tlsf_malloc+0x1c2>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037edb2:	09c9      	s32i.n	a12, a9, 0
		if (next == &control->block_null)
4037edb4:	329c87        	bne	a12, a8, 4037edea <tlsf_malloc+0x1c2>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037edb7:	78c8      	l32i.n	a12, a8, 28
4037edb9:	a0cac0        	addx4	a12, a10, a12
4037edbc:	0cd8      	l32i.n	a13, a12, 0
4037edbe:	190c      	movi.n	a9, 1
4037edc0:	401b00        	ssl	a11
4037edc3:	a19900        	sll	a9, a9
4037edc6:	1099d0        	and	a9, a9, a13
4037edc9:	3099d0        	xor	a9, a9, a13
4037edcc:	0c99      	s32i.n	a9, a12, 0
			if (!control->sl_bitmap[fl])
4037edce:	7898      	l32i.n	a9, a8, 28
4037edd0:	a09a90        	addx4	a9, a10, a9
4037edd3:	0998      	l32i.n	a9, a9, 0
4037edd5:	19dc      	bnez.n	a9, 4037edea <tlsf_malloc+0x1c2>
				control->fl_bitmap &= ~(1U << fl);
4037edd7:	68b8      	l32i.n	a11, a8, 24
4037edd9:	190c      	movi.n	a9, 1
4037eddb:	401a00        	ssl	a10
4037edde:	a19900        	sll	a9, a9
4037ede1:	1099b0        	and	a9, a9, a11
4037ede4:	3099b0        	xor	a9, a9, a11
4037ede7:	066892        	s32i	a9, a8, 24
tlsf_decl void* block_prepare_used(control_t* control, block_header_t* block, size_t size)
{
	void* p = 0;
	if (block)
	{
		tlsf_assert(size && "size must be non-zero");
4037edea:	00e356        	bnez	a3, 4037edfc <tlsf_malloc+0x1d4>
4037eded:	d885d1        	l32r	a13, 40375004 <_iram_text_start+0xc00> (3c022ef8 <_flash_rodata_start+0x2dd8>)
4037edf0:	d886c1        	l32r	a12, 40375008 <_iram_text_start+0xc04> (3c027b34 <__func__$10>)
4037edf3:	76a2b2        	movi	a11, 0x276
4037edf6:	d86fa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037edf9:	00fa65        	call8	4037fda0 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037edfc:	1298      	l32i.n	a9, a2, 4
	tlsf_assert(block_is_free(block) && "block must be free");
4037edfe:	0ee907        	bbsi	a9, 0, 4037ee10 <tlsf_malloc+0x1e8>
4037ee01:	d882d1        	l32r	a13, 4037500c <_iram_text_start+0xc08> (3c022f18 <_flash_rodata_start+0x2df8>)
4037ee04:	d883c1        	l32r	a12, 40375010 <_iram_text_start+0xc0c> (3c027b24 <__func__$9>)
4037ee07:	24a2b2        	movi	a11, 0x224
4037ee0a:	d86aa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ee0d:	00f925        	call8	4037fda0 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee10:	ca7c      	movi.n	a10, -4
4037ee12:	10b9a0        	and	a11, a9, a10
	return block_size(block) >= sizeof(block_header_t) + size;
4037ee15:	10c392        	addi	a9, a3, 16
	if (block_can_split(block, size))
4037ee18:	02bb97        	bgeu	a11, a9, 4037ee1e <tlsf_malloc+0x1f6>
4037ee1b:	0061c6        	j	4037efa6 <tlsf_malloc+0x37e>
	return tlsf_cast(void*,
4037ee1e:	d28b      	addi.n	a13, a2, 8
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037ee20:	93aa      	add.n	a9, a3, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ee22:	9d9a      	add.n	a9, a13, a9
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037ee24:	c0ab30        	sub	a10, a11, a3
4037ee27:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(void*,
4037ee2a:	c98b      	addi.n	a12, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037ee2c:	e9bb      	addi.n	a14, a9, 11
4037ee2e:	cf7c      	movi.n	a15, -4
4037ee30:	10eef0        	and	a14, a14, a15
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037ee33:	0e1ce7        	beq	a12, a14, 4037ee45 <tlsf_malloc+0x21d>
4037ee36:	d877d1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037ee39:	d877c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037ee3c:	c4a1b2        	movi	a11, 0x1c4
4037ee3f:	d85da1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ee42:	00f5e5        	call8	4037fda0 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037ee45:	ea3a      	add.n	a14, a10, a3
4037ee47:	ee4b      	addi.n	a14, a14, 4
4037ee49:	0e1be7        	beq	a11, a14, 4037ee5b <tlsf_malloc+0x233>
4037ee4c:	d874d1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037ee4f:	d872c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037ee52:	c7a1b2        	movi	a11, 0x1c7
4037ee55:	d857a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ee58:	00f465        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037ee5b:	19b8      	l32i.n	a11, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037ee5d:	14b0b0        	extui	a11, a11, 0, 2
4037ee60:	20aab0        	or	a10, a10, a11
4037ee63:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee65:	cb7c      	movi.n	a11, -4
4037ee67:	10aab0        	and	a10, a10, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037ee6a:	bb0c      	movi.n	a11, 11
4037ee6c:	0e3ba7        	bltu	a11, a10, 4037ee7e <tlsf_malloc+0x256>
4037ee6f:	d86cd1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037ee72:	d869c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037ee75:	c9a1b2        	movi	a11, 0x1c9
4037ee78:	d84fa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ee7b:	00f265        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037ee7e:	12a8      	l32i.n	a10, a2, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037ee80:	14a0a0        	extui	a10, a10, 0, 2
4037ee83:	20aa30        	or	a10, a10, a3
4037ee86:	12a9      	s32i.n	a10, a2, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee88:	19b8      	l32i.n	a11, a9, 4
4037ee8a:	ca7c      	movi.n	a10, -4
4037ee8c:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037ee8f:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ee92:	acaa      	add.n	a10, a12, a10
	tlsf_assert(!block_is_last(block));
4037ee94:	3c0c      	movi.n	a12, 3
4037ee96:	0e3cb7        	bltu	a12, a11, 4037eea8 <tlsf_malloc+0x280>
4037ee99:	d841d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037ee9c:	d842c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037ee9f:	a1a0b2        	movi	a11, 161
4037eea2:	d841a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037eea5:	00efa5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037eea8:	0a99      	s32i.n	a9, a10, 0
	block->size |= block_header_prev_free_bit;
4037eeaa:	1ab8      	l32i.n	a11, a10, 4
4037eeac:	2c0c      	movi.n	a12, 2
4037eeae:	20bbc0        	or	a11, a11, a12
4037eeb1:	1ab9      	s32i.n	a11, a10, 4
	block->size |= block_header_free_bit;
4037eeb3:	19a8      	l32i.n	a10, a9, 4
4037eeb5:	1b0c      	movi.n	a11, 1
4037eeb7:	20aab0        	or	a10, a10, a11
4037eeba:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037eebc:	12b8      	l32i.n	a11, a2, 4
4037eebe:	ca7c      	movi.n	a10, -4
4037eec0:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037eec3:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037eec6:	ddaa      	add.n	a13, a13, a10
	tlsf_assert(!block_is_last(block));
4037eec8:	3a0c      	movi.n	a10, 3
4037eeca:	0e3ab7        	bltu	a10, a11, 4037eedc <tlsf_malloc+0x2b4>
4037eecd:	d834d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037eed0:	d835c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037eed3:	a1a0b2        	movi	a11, 161
4037eed6:	d834a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037eed9:	00ec65        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037eedc:	0d29      	s32i.n	a2, a13, 0
	block->size |= block_header_prev_free_bit;
4037eede:	19a8      	l32i.n	a10, a9, 4
4037eee0:	2b0c      	movi.n	a11, 2
4037eee2:	20bab0        	or	a11, a10, a11
4037eee5:	19b9      	s32i.n	a11, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
4037eee7:	cb7c      	movi.n	a11, -4
4037eee9:	10aab0        	and	a10, a10, a11
	if (size < control->small_block_size)
4037eeec:	48b8      	l32i.n	a11, a8, 16
4037eeee:	75b7b0        	extui	a11, a11, 23, 8
4037eef1:	0fbab7        	bgeu	a10, a11, 4037ef04 <tlsf_malloc+0x2dc>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037eef4:	48c8      	l32i.n	a12, a8, 16
4037eef6:	54cec0        	extui	a12, a12, 14, 6
4037eef9:	d2bbc0        	quos	a11, a11, a12
4037eefc:	d2aab0        	quos	a10, a10, a11
		fl = 0;
4037eeff:	0c0c      	movi.n	a12, 0
4037ef01:	000cc6        	j	4037ef38 <tlsf_malloc+0x310>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ef04:	aa8c      	beqz.n	a10, 4037ef12 <tlsf_malloc+0x2ea>
4037ef06:	40fac0        	nsau	a12, a10
4037ef09:	e0ccc2        	addi	a12, a12, -32
4037ef0c:	60c0c0        	neg	a12, a12
4037ef0f:	000086        	j	4037ef15 <tlsf_malloc+0x2ed>
4037ef12:	00a0c2        	movi	a12, 0
	return bit - 1;
4037ef15:	ffccd2        	addi	a13, a12, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037ef18:	0428b2        	l32i	a11, a8, 16
4037ef1b:	25e4b0        	extui	a14, a11, 20, 3
4037ef1e:	c0dde0        	sub	a13, a13, a14
4037ef21:	400d00        	ssr	a13
4037ef24:	91a0a0        	srl	a10, a10
4037ef27:	1d0c      	movi.n	a13, 1
4037ef29:	401e00        	ssl	a14
4037ef2c:	a1dd00        	sll	a13, a13
4037ef2f:	30aad0        	xor	a10, a10, a13
		fl -= (control->fl_index_shift - 1);
4037ef32:	24b5b0        	extui	a11, a11, 5, 3
4037ef35:	c0ccb0        	sub	a12, a12, a11
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037ef38:	88d8      	l32i.n	a13, a8, 32
4037ef3a:	48b8      	l32i.n	a11, a8, 16
4037ef3c:	54beb0        	extui	a11, a11, 14, 6
4037ef3f:	82bbc0        	mull	a11, a11, a12
4037ef42:	bbaa      	add.n	a11, a11, a10
4037ef44:	a0bbd0        	addx4	a11, a11, a13
4037ef47:	0bb8      	l32i.n	a11, a11, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037ef49:	dbcc      	bnez.n	a11, 4037ef5a <tlsf_malloc+0x332>
4037ef4b:	d824d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037ef4e:	d824c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037ef51:	90a1b2        	movi	a11, 0x190
4037ef54:	d818a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ef57:	00e4a5        	call8	4037fda0 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037ef5a:	09dc      	bnez.n	a9, 4037ef6e <tlsf_malloc+0x346>
4037ef5c:	d822d1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037ef5f:	d820c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037ef62:	91a1b2        	movi	a11, 0x191
4037ef65:	d813a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ef68:	201110        	or	a1, a1, a1
4037ef6b:	00e365        	call8	4037fda0 <__assert_func>
	block->next_free = current;
4037ef6e:	29b9      	s32i.n	a11, a9, 8
	block->prev_free = &control->block_null;
4037ef70:	3989      	s32i.n	a8, a9, 12
	current->prev_free = block;
4037ef72:	3b99      	s32i.n	a9, a11, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037ef74:	88d8      	l32i.n	a13, a8, 32
4037ef76:	48b8      	l32i.n	a11, a8, 16
4037ef78:	54beb0        	extui	a11, a11, 14, 6
4037ef7b:	82bcb0        	mull	a11, a12, a11
4037ef7e:	baba      	add.n	a11, a10, a11
4037ef80:	a0bbd0        	addx4	a11, a11, a13
4037ef83:	0b99      	s32i.n	a9, a11, 0
	control->fl_bitmap |= (1U << fl);
4037ef85:	68b8      	l32i.n	a11, a8, 24
4037ef87:	190c      	movi.n	a9, 1
4037ef89:	401c00        	ssl	a12
4037ef8c:	a1d900        	sll	a13, a9
4037ef8f:	20bbd0        	or	a11, a11, a13
4037ef92:	68b9      	s32i.n	a11, a8, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037ef94:	7888      	l32i.n	a8, a8, 28
4037ef96:	a0cc80        	addx4	a12, a12, a8
4037ef99:	0c88      	l32i.n	a8, a12, 0
4037ef9b:	401a00        	ssl	a10
4037ef9e:	a19900        	sll	a9, a9
4037efa1:	208890        	or	a8, a8, a9
4037efa4:	0c89      	s32i.n	a8, a12, 0
	return tlsf_cast(void*,
4037efa6:	a28b      	addi.n	a10, a2, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037efa8:	1298      	l32i.n	a9, a2, 4
4037efaa:	c87c      	movi.n	a8, -4
4037efac:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037efaf:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037efb2:	88aa      	add.n	a8, a8, a10
	tlsf_assert(!block_is_last(block));
4037efb4:	3b0c      	movi.n	a11, 3
4037efb6:	0e3b97        	bltu	a11, a9, 4037efc8 <tlsf_malloc+0x3a0>
4037efb9:	d7f9d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037efbc:	d7fac1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037efbf:	a1a0b2        	movi	a11, 161
4037efc2:	d7f9a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037efc5:	00dda5        	call8	4037fda0 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037efc8:	1898      	l32i.n	a9, a8, 4
4037efca:	db7c      	movi.n	a11, -3
4037efcc:	1099b0        	and	a9, a9, a11
4037efcf:	1899      	s32i.n	a9, a8, 4
	block->size &= ~block_header_free_bit;
4037efd1:	1288      	l32i.n	a8, a2, 4
4037efd3:	e97c      	movi.n	a9, -2
4037efd5:	108890        	and	a8, a8, a9
4037efd8:	1289      	s32i.n	a8, a2, 4
		block_trim_free(control, block, size);
		block_mark_as_used(block);
		p = block_to_ptr(block);
4037efda:	0a2d      	mov.n	a2, a10
4037efdc:	000506        	j	4037eff4 <tlsf_malloc+0x3cc>
4037efdf:	020c00        	andb	b0, b12, b0
		return NULL;
4037efe2:	000386        	j	4037eff4 <tlsf_malloc+0x3cc>
4037efe5:	0002c6        	j	4037eff4 <tlsf_malloc+0x3cc>
4037efe8:	020c      	movi.n	a2, 0
4037efea:	000186        	j	4037eff4 <tlsf_malloc+0x3cc>
	void* p = 0;
4037efed:	020c      	movi.n	a2, 0
4037efef:	000046        	j	4037eff4 <tlsf_malloc+0x3cc>
4037eff2:	020c      	movi.n	a2, 0
}
4037eff4:	f01d      	retw.n
	...

4037eff8 <tlsf_memalign_offs>:
{
4037eff8:	004136        	entry	a1, 32
4037effb:	02cd      	mov.n	a12, a2
	if (size)
4037effd:	74ac      	beqz.n	a4, 4037f028 <tlsf_memalign_offs+0x30>
	return (x + (align - 1)) & ~(align - 1);
4037efff:	443b      	addi.n	a4, a4, 3
4037f001:	c87c      	movi.n	a8, -4
4037f003:	104480        	and	a4, a4, a8
	if (control == NULL)
4037f006:	629c      	beqz.n	a2, 4037f020 <tlsf_memalign_offs+0x28>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037f008:	4298      	l32i.n	a9, a2, 16
4037f00a:	549890        	extui	a9, a9, 8, 6
4037f00d:	180c      	movi.n	a8, 1
4037f00f:	401900        	ssl	a9
4037f012:	a18800        	sll	a8, a8
		if (aligned < tlsf_block_size_max(control)) 
4037f015:	0db487        	bgeu	a4, a8, 4037f026 <tlsf_memalign_offs+0x2e>
			adjust = tlsf_max(aligned, block_size_min);
4037f018:	c80c      	movi.n	a8, 12
4037f01a:	734480        	maxu	a4, a4, a8
4037f01d:	0001c6        	j	4037f028 <tlsf_memalign_offs+0x30>
	size_t adjust = 0;
4037f020:	040c      	movi.n	a4, 0
4037f022:	000086        	j	4037f028 <tlsf_memalign_offs+0x30>
4037f025:	040c00        	extui	a0, a0, 12, 1
	return (x + (align - 1)) & ~(align - 1);
4037f028:	953b      	addi.n	a9, a5, 3
4037f02a:	c87c      	movi.n	a8, -4
4037f02c:	109980        	and	a9, a9, a8
	const size_t gap_minimum = sizeof(block_header_t) + off_adjust;
4037f02f:	10c9d2        	addi	a13, a9, 16
	const size_t size_with_gap = adjust_request_size(tlsf, adjust + align + gap_minimum - off_adjust, align);
4037f032:	a34a      	add.n	a10, a3, a4
4037f034:	aada      	add.n	a10, a10, a13
4037f036:	c08a90        	sub	a8, a10, a9
	if (size)
4037f039:	3f1a97        	beq	a10, a9, 4037f07c <tlsf_memalign_offs+0x84>
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037f03c:	a30b      	addi.n	a10, a3, -1
4037f03e:	0e03a7        	bnone	a3, a10, 4037f050 <tlsf_memalign_offs+0x58>
4037f041:	d7ead1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037f044:	d7ebc1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c027bbc <__func__$19>)
4037f047:	f3a0b2        	movi	a11, 243
4037f04a:	d7daa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f04d:	00d525        	call8	4037fda0 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037f050:	883a      	add.n	a8, a8, a3
4037f052:	880b      	addi.n	a8, a8, -1
4037f054:	60a030        	neg	a10, a3
4037f057:	1088a0        	and	a8, a8, a10
	if (control == NULL)
4037f05a:	6c9c      	beqz.n	a12, 4037f074 <tlsf_memalign_offs+0x7c>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037f05c:	4cb8      	l32i.n	a11, a12, 16
4037f05e:	54b8b0        	extui	a11, a11, 8, 6
4037f061:	1a0c      	movi.n	a10, 1
4037f063:	401b00        	ssl	a11
4037f066:	a1aa00        	sll	a10, a10
		if (aligned < tlsf_block_size_max(control)) 
4037f069:	0db8a7        	bgeu	a8, a10, 4037f07a <tlsf_memalign_offs+0x82>
			adjust = tlsf_max(aligned, block_size_min);
4037f06c:	ca0c      	movi.n	a10, 12
4037f06e:	7388a0        	maxu	a8, a8, a10
4037f071:	0001c6        	j	4037f07c <tlsf_memalign_offs+0x84>
	size_t adjust = 0;
4037f074:	080c      	movi.n	a8, 0
4037f076:	000086        	j	4037f07c <tlsf_memalign_offs+0x84>
4037f079:	080c00        	lsx	f0, a12, a0
	size_t aligned_size = (adjust && align > ALIGN_SIZE) ? size_with_gap : adjust;
4037f07c:	1e0c      	movi.n	a14, 1
4037f07e:	83e440        	moveqz	a14, a4, a4
4037f081:	4a0c      	movi.n	a10, 4
4037f083:	62aa30        	lsi	f3, a10, 0x188
4037f086:	018ea7        	bany	a14, a10, 4037f08b <tlsf_memalign_offs+0x93>
4037f089:	048d      	mov.n	a8, a4
	if (*size)
4037f08b:	3a9816        	beqz	a8, 4037f438 <tlsf_memalign_offs+0x440>
	if (*size >= control->small_block_size)
4037f08e:	4ca8      	l32i.n	a10, a12, 16
4037f090:	75a7a0        	extui	a10, a10, 23, 8
4037f093:	0a5d      	mov.n	a5, a10
4037f095:	3738a7        	bltu	a8, a10, 4037f0d0 <tlsf_memalign_offs+0xd8>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f098:	40f8b0        	nsau	a11, a8
	return bit - 1;
4037f09b:	e1cbb2        	addi	a11, a11, -31
4037f09e:	60b0b0        	neg	a11, a11
		const size_t round = (1 << (tlsf_fls_sizet(*size) - control->sl_index_count_log2));
4037f0a1:	4cf8      	l32i.n	a15, a12, 16
4037f0a3:	25f4f0        	extui	a15, a15, 20, 3
4037f0a6:	c0fbf0        	sub	a15, a11, a15
4037f0a9:	1b0c      	movi.n	a11, 1
4037f0ab:	401f00        	ssl	a15
4037f0ae:	a1bb00        	sll	a11, a11
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037f0b1:	ffcbf2        	addi	a15, a11, -1
4037f0b4:	0e0bf7        	bnone	a11, a15, 4037f0c6 <tlsf_memalign_offs+0xce>
4037f0b7:	d7cdd1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037f0ba:	d7cdc1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c027bbc <__func__$19>)
4037f0bd:	f3a0b2        	movi	a11, 243
4037f0c0:	d7bda1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f0c3:	00cde5        	call8	4037fda0 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037f0c6:	88ba      	add.n	a8, a8, a11
4037f0c8:	880b      	addi.n	a8, a8, -1
4037f0ca:	60b0b0        	neg	a11, a11
4037f0cd:	1088b0        	and	a8, a8, a11
	if (size < control->small_block_size)
4037f0d0:	10b857        	bgeu	a8, a5, 4037f0e4 <tlsf_memalign_offs+0xec>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f0d3:	4cb8      	l32i.n	a11, a12, 16
4037f0d5:	54beb0        	extui	a11, a11, 14, 6
4037f0d8:	d2aab0        	quos	a10, a10, a11
4037f0db:	d2a8a0        	quos	a10, a8, a10
		fl = 0;
4037f0de:	0b0c      	movi.n	a11, 0
4037f0e0:	000c86        	j	4037f116 <tlsf_memalign_offs+0x11e>
4037f0e3:	a88c00        	lsi	f0, a12, 0x2a0
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f0e6:	40f8b0        	nsau	a11, a8
4037f0e9:	e0cbb2        	addi	a11, a11, -32
4037f0ec:	60b0b0        	neg	a11, a11
4037f0ef:	000086        	j	4037f0f5 <tlsf_memalign_offs+0xfd>
4037f0f2:	00a0b2        	movi	a11, 0
	return bit - 1;
4037f0f5:	ab0b      	addi.n	a10, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f0f7:	4cf8      	l32i.n	a15, a12, 16
4037f0f9:	2554f0        	extui	a5, a15, 20, 3
4037f0fc:	c0aa50        	sub	a10, a10, a5
4037f0ff:	400a00        	ssr	a10
4037f102:	91a080        	srl	a10, a8
4037f105:	170c      	movi.n	a7, 1
4037f107:	401500        	ssl	a5
4037f10a:	a17700        	sll	a7, a7
4037f10d:	30aa70        	xor	a10, a10, a7
		fl -= (control->fl_index_shift - 1);
4037f110:	24f5f0        	extui	a15, a15, 5, 3
4037f113:	c0bbf0        	sub	a11, a11, a15
		if (fl < control->fl_index_count)
4037f116:	4cf8      	l32i.n	a15, a12, 16
4037f118:	44f0f0        	extui	a15, a15, 0, 5
4037f11b:	022bf7        	blt	a11, a15, 4037f121 <tlsf_memalign_offs+0x129>
4037f11e:	0145c6        	j	4037f639 <tlsf_memalign_offs+0x641>
	unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
4037f121:	7c28      	l32i.n	a2, a12, 28
4037f123:	a0fb20        	addx4	a15, a11, a2
4037f126:	0f78      	l32i.n	a7, a15, 0
4037f128:	ff7c      	movi.n	a15, -1
4037f12a:	401a00        	ssl	a10
4037f12d:	a1af00        	sll	a10, a15
4037f130:	1057a0        	and	a5, a7, a10
	if (!sl_map)
4037f133:	3b87a7        	bany	a7, a10, 4037f172 <tlsf_memalign_offs+0x17a>
		const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
4037f136:	6cf8      	l32i.n	a15, a12, 24
4037f138:	bb1b      	addi.n	a11, a11, 1
4037f13a:	ffafa2        	movi	a10, -1
4037f13d:	401b00        	ssl	a11
4037f140:	a1aa00        	sll	a10, a10
4037f143:	107fa0        	and	a7, a15, a10
		if (!fl_map)
4037f146:	028fa7        	bany	a15, a10, 4037f14c <tlsf_memalign_offs+0x154>
4037f149:	013c46        	j	4037f63e <tlsf_memalign_offs+0x646>
	return __builtin_ffs(word) - 1;
4037f14c:	60b070        	neg	a11, a7
4037f14f:	10bb70        	and	a11, a11, a7
4037f152:	40fbb0        	nsau	a11, a11
4037f155:	e1cbb2        	addi	a11, a11, -31
4037f158:	60b0b0        	neg	a11, a11
		sl_map = control->sl_bitmap[fl];
4037f15b:	a02b20        	addx4	a2, a11, a2
4037f15e:	0258      	l32i.n	a5, a2, 0
	tlsf_assert(sl_map && "internal error - second level bitmap is null");
4037f160:	00e556        	bnez	a5, 4037f172 <tlsf_memalign_offs+0x17a>
4037f163:	d7a4d1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c022ea0 <_flash_rodata_start+0x2d80>)
4037f166:	d7a4c1        	l32r	a12, 40374ff8 <_iram_text_start+0xbf4> (3c027b48 <__func__$11>)
4037f169:	67a1b2        	movi	a11, 0x167
4037f16c:	d792a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f16f:	00c325        	call8	4037fda0 <__assert_func>
	return __builtin_ffs(word) - 1;
4037f172:	60f050        	neg	a15, a5
4037f175:	10ff50        	and	a15, a15, a5
4037f178:	40fff0        	nsau	a15, a15
4037f17b:	e1cff2        	addi	a15, a15, -31
4037f17e:	60f0f0        	neg	a15, a15
	return control->blocks[fl * control->sl_index_count + sl];
4037f181:	8c78      	l32i.n	a7, a12, 32
4037f183:	4ca8      	l32i.n	a10, a12, 16
4037f185:	54aea0        	extui	a10, a10, 14, 6
4037f188:	82aab0        	mull	a10, a10, a11
4037f18b:	afaa      	add.n	a10, a15, a10
4037f18d:	a0aa70        	addx4	a10, a10, a7
4037f190:	0a28      	l32i.n	a2, a10, 0
	if (block)
4037f192:	4af216        	beqz	a2, 4037f645 <tlsf_memalign_offs+0x64d>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f195:	12a8      	l32i.n	a10, a2, 4
4037f197:	fcaf72        	movi	a7, -4
4037f19a:	10aa70        	and	a10, a10, a7
		tlsf_assert(block_size(block) >= *size);
4037f19d:	0eba87        	bgeu	a10, a8, 4037f1af <tlsf_memalign_offs+0x1b7>
4037f1a0:	d797d1        	l32r	a13, 40374ffc <_iram_text_start+0xbf8> (3c022edc <_flash_rodata_start+0x2dbc>)
4037f1a3:	d797c1        	l32r	a12, 40375000 <_iram_text_start+0xbfc> (3c027b60 <__func__$12>)
4037f1a6:	6aa2b2        	movi	a11, 0x26a
4037f1a9:	d782a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f1ac:	00bf25        	call8	4037fda0 <__assert_func>
	block_header_t* prev = block->prev_free;
4037f1af:	3288      	l32i.n	a8, a2, 12
	block_header_t* next = block->next_free;
4037f1b1:	22a8      	l32i.n	a10, a2, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f1b3:	00e856        	bnez	a8, 4037f1c5 <tlsf_memalign_offs+0x1cd>
4037f1b6:	d781d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037f1b9:	d781c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037f1bc:	74a1b2        	movi	a11, 0x174
4037f1bf:	d77da1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f1c2:	00bde5        	call8	4037fda0 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f1c5:	011a56        	bnez	a10, 4037f1da <tlsf_memalign_offs+0x1e2>
4037f1c8:	d77fd1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037f1cb:	d77dc1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037f1ce:	75a1b2        	movi	a11, 0x175
4037f1d1:	d778a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f1d4:	201110        	or	a1, a1, a1
4037f1d7:	00bca5        	call8	4037fda0 <__assert_func>
	next->prev_free = prev;
4037f1da:	3a89      	s32i.n	a8, a10, 12
	prev->next_free = next;
4037f1dc:	28a9      	s32i.n	a10, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f1de:	8c58      	l32i.n	a5, a12, 32
4037f1e0:	4c88      	l32i.n	a8, a12, 16
4037f1e2:	548e80        	extui	a8, a8, 14, 6
4037f1e5:	828b80        	mull	a8, a11, a8
4037f1e8:	8f8a      	add.n	a8, a15, a8
4037f1ea:	a08850        	addx4	a8, a8, a5
4037f1ed:	0878      	l32i.n	a7, a8, 0
4037f1ef:	369277        	bne	a2, a7, 4037f229 <tlsf_memalign_offs+0x231>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f1f2:	08a9      	s32i.n	a10, a8, 0
		if (next == &control->block_null)
4037f1f4:	319ac7        	bne	a10, a12, 4037f229 <tlsf_memalign_offs+0x231>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f1f7:	7ca8      	l32i.n	a10, a12, 28
4037f1f9:	a0aba0        	addx4	a10, a11, a10
4037f1fc:	0a78      	l32i.n	a7, a10, 0
4037f1fe:	180c      	movi.n	a8, 1
4037f200:	401f00        	ssl	a15
4037f203:	a18800        	sll	a8, a8
4037f206:	108870        	and	a8, a8, a7
4037f209:	308870        	xor	a8, a8, a7
4037f20c:	0a89      	s32i.n	a8, a10, 0
			if (!control->sl_bitmap[fl])
4037f20e:	7c88      	l32i.n	a8, a12, 28
4037f210:	a08b80        	addx4	a8, a11, a8
4037f213:	0888      	l32i.n	a8, a8, 0
4037f215:	08dc      	bnez.n	a8, 4037f229 <tlsf_memalign_offs+0x231>
				control->fl_bitmap &= ~(1U << fl);
4037f217:	6ca8      	l32i.n	a10, a12, 24
4037f219:	180c      	movi.n	a8, 1
4037f21b:	401b00        	ssl	a11
4037f21e:	a18800        	sll	a8, a8
4037f221:	1088a0        	and	a8, a8, a10
4037f224:	3088a0        	xor	a8, a8, a10
4037f227:	6c89      	s32i.n	a8, a12, 24
	return tlsf_cast(void*,
4037f229:	a28b      	addi.n	a10, a2, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f22b:	f3aa      	add.n	a15, a3, a10
4037f22d:	ff0b      	addi.n	a15, a15, -1
4037f22f:	60b030        	neg	a11, a3
4037f232:	10ffb0        	and	a15, a15, a11
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037f235:	830b      	addi.n	a8, a3, -1
4037f237:	0e0387        	bnone	a3, a8, 4037f249 <tlsf_memalign_offs+0x251>
4037f23a:	d76cd1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037f23d:	d779c1        	l32r	a12, 40375024 <_iram_text_start+0xc20> (3c027b9c <__func__$16>)
4037f240:	01a1b2        	movi	a11, 0x101
4037f243:	d75ca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f246:	00b5a5        	call8	4037fda0 <__assert_func>
		size_t gap = tlsf_cast(size_t,
4037f249:	c08fa0        	sub	a8, a15, a10
		if ((gap && gap < gap_minimum) || (!gap && off_adjust && align > ALIGN_SIZE))
4037f24c:	150c      	movi.n	a5, 1
4037f24e:	835880        	moveqz	a5, a8, a8
4037f251:	6278d0        	lsi	f13, a8, 0x188
4037f254:	108577        	bany	a5, a7, 4037f268 <tlsf_memalign_offs+0x270>
4037f257:	40f870        	nsau	a7, a8
4037f25a:	417570        	srli	a7, a7, 5
4037f25d:	150c      	movi.n	a5, 1
4037f25f:	835990        	moveqz	a5, a9, a9
4037f262:	150757        	bnone	a7, a5, 4037f27b <tlsf_memalign_offs+0x283>
4037f265:	1253b6        	bltui	a3, 5, 4037f27b <tlsf_memalign_offs+0x283>
			const size_t gap_remain = gap_minimum - gap;
4037f268:	c08d80        	sub	a8, a13, a8
			const size_t offset = tlsf_max(gap_remain, align);
4037f26b:	738380        	maxu	a8, a3, a8
			const void* next_aligned = tlsf_cast(void*,
4037f26e:	88fa      	add.n	a8, a8, a15
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f270:	883a      	add.n	a8, a8, a3
4037f272:	ffc882        	addi	a8, a8, -1
4037f275:	10bb80        	and	a11, a11, a8
			gap = tlsf_cast(size_t,
4037f278:	c08ba0        	sub	a8, a11, a10
		if (gap)
4037f27b:	1be816        	beqz	a8, 4037f43d <tlsf_memalign_offs+0x445>
			tlsf_assert(gap >= gap_minimum && "gap size too small");
4037f27e:	0eb8d7        	bgeu	a8, a13, 4037f290 <tlsf_memalign_offs+0x298>
4037f281:	d769d1        	l32r	a13, 40375028 <_iram_text_start+0xc24> (3c023048 <_flash_rodata_start+0x2f28>)
4037f284:	d76ac1        	l32r	a12, 4037502c <_iram_text_start+0xc28> (3c027b04 <__func__$7>)
4037f287:	5ba2b2        	movi	a11, 0x25b
4037f28a:	d744a1        	l32r	a10, 40374f9c <_iram_text_start+0xb98> (3c022adb <_flash_rodata_start+0x29bb>)
4037f28d:	00b125        	call8	4037fda0 <__assert_func>
			block = block_trim_free_leading(control, block, gap - off_adjust);
4037f290:	c08890        	sub	a8, a8, a9
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f293:	12b8      	l32i.n	a11, a2, 4
4037f295:	c97c      	movi.n	a9, -4
4037f297:	10bb90        	and	a11, a11, a9
	return block_size(block) >= sizeof(block_header_t) + size;
4037f29a:	10c892        	addi	a9, a8, 16
	if (block_can_split(block, size))
4037f29d:	02bb97        	bgeu	a11, a9, 4037f2a3 <tlsf_memalign_offs+0x2ab>
4037f2a0:	006806        	j	4037f444 <tlsf_memalign_offs+0x44c>
		remaining_block = block_split(block, size - block_header_overhead);
4037f2a3:	fcc8f2        	addi	a15, a8, -4
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f2a6:	f8c882        	addi	a8, a8, -8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f2a9:	8a8a      	add.n	a8, a10, a8
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f2ab:	c09bf0        	sub	a9, a11, a15
4037f2ae:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(void*,
4037f2b1:	d88b      	addi.n	a13, a8, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f2b3:	78bb      	addi.n	a7, a8, 11
4037f2b5:	c57c      	movi.n	a5, -4
4037f2b7:	107750        	and	a7, a7, a5
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f2ba:	0e1d77        	beq	a13, a7, 4037f2cc <tlsf_memalign_offs+0x2d4>
4037f2bd:	d755d1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037f2c0:	d756c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f2c3:	c4a1b2        	movi	a11, 0x1c4
4037f2c6:	d73ba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f2c9:	00ad65        	call8	4037fda0 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f2cc:	7f9a      	add.n	a7, a15, a9
4037f2ce:	04c772        	addi	a7, a7, 4
4037f2d1:	0e1b77        	beq	a11, a7, 4037f2e3 <tlsf_memalign_offs+0x2eb>
4037f2d4:	d752d1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037f2d7:	d750c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f2da:	c7a1b2        	movi	a11, 0x1c7
4037f2dd:	d735a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f2e0:	00abe5        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037f2e3:	18b8      	l32i.n	a11, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f2e5:	14b0b0        	extui	a11, a11, 0, 2
4037f2e8:	2099b0        	or	a9, a9, a11
4037f2eb:	1899      	s32i.n	a9, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f2ed:	cb7c      	movi.n	a11, -4
4037f2ef:	1099b0        	and	a9, a9, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f2f2:	bb0c      	movi.n	a11, 11
4037f2f4:	0e3b97        	bltu	a11, a9, 4037f306 <tlsf_memalign_offs+0x30e>
4037f2f7:	d74ad1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037f2fa:	d747c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f2fd:	c9a1b2        	movi	a11, 0x1c9
4037f300:	d72da1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f303:	00a9e5        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037f306:	1298      	l32i.n	a9, a2, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f308:	149090        	extui	a9, a9, 0, 2
4037f30b:	20ff90        	or	a15, a15, a9
4037f30e:	12f9      	s32i.n	a15, a2, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f310:	18b8      	l32i.n	a11, a8, 4
4037f312:	c97c      	movi.n	a9, -4
4037f314:	109b90        	and	a9, a11, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f317:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f31a:	dd9a      	add.n	a13, a13, a9
	tlsf_assert(!block_is_last(block));
4037f31c:	390c      	movi.n	a9, 3
4037f31e:	0e39b7        	bltu	a9, a11, 4037f330 <tlsf_memalign_offs+0x338>
4037f321:	d71fd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f324:	d720c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f327:	a1a0b2        	movi	a11, 161
4037f32a:	d71fa1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f32d:	00a725        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037f330:	0d89      	s32i.n	a8, a13, 0
	block->size |= block_header_prev_free_bit;
4037f332:	1d98      	l32i.n	a9, a13, 4
4037f334:	2b0c      	movi.n	a11, 2
4037f336:	2099b0        	or	a9, a9, a11
4037f339:	1d99      	s32i.n	a9, a13, 4
	block->size |= block_header_free_bit;
4037f33b:	1898      	l32i.n	a9, a8, 4
4037f33d:	1b0c      	movi.n	a11, 1
4037f33f:	20b9b0        	or	a11, a9, a11
4037f342:	18b9      	s32i.n	a11, a8, 4
	block->size |= block_header_prev_free_bit;
4037f344:	3d0c      	movi.n	a13, 3
4037f346:	2099d0        	or	a9, a9, a13
4037f349:	1899      	s32i.n	a9, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f34b:	12b8      	l32i.n	a11, a2, 4
4037f34d:	c97c      	movi.n	a9, -4
4037f34f:	109b90        	and	a9, a11, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f352:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f355:	9a9a      	add.n	a9, a10, a9
	tlsf_assert(!block_is_last(block));
4037f357:	0e3db7        	bltu	a13, a11, 4037f369 <tlsf_memalign_offs+0x371>
4037f35a:	d711d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f35d:	d711c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f360:	a1a0b2        	movi	a11, 161
4037f363:	d711a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f366:	00a3a5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037f369:	0929      	s32i.n	a2, a9, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f36b:	1298      	l32i.n	a9, a2, 4
4037f36d:	cb7c      	movi.n	a11, -4
4037f36f:	1099b0        	and	a9, a9, a11
	if (size < control->small_block_size)
4037f372:	4cb8      	l32i.n	a11, a12, 16
4037f374:	75b7b0        	extui	a11, a11, 23, 8
4037f377:	0fb9b7        	bgeu	a9, a11, 4037f38a <tlsf_memalign_offs+0x392>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f37a:	4cd8      	l32i.n	a13, a12, 16
4037f37c:	54ded0        	extui	a13, a13, 14, 6
4037f37f:	d2bbd0        	quos	a11, a11, a13
4037f382:	d299b0        	quos	a9, a9, a11
		fl = 0;
4037f385:	0d0c      	movi.n	a13, 0
4037f387:	000cc6        	j	4037f3be <tlsf_memalign_offs+0x3c6>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f38a:	a98c      	beqz.n	a9, 4037f398 <tlsf_memalign_offs+0x3a0>
4037f38c:	40f9d0        	nsau	a13, a9
4037f38f:	e0cdd2        	addi	a13, a13, -32
4037f392:	60d0d0        	neg	a13, a13
4037f395:	000086        	j	4037f39b <tlsf_memalign_offs+0x3a3>
4037f398:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f39b:	ffcdf2        	addi	a15, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f39e:	042cb2        	l32i	a11, a12, 16
4037f3a1:	2574b0        	extui	a7, a11, 20, 3
4037f3a4:	c0ff70        	sub	a15, a15, a7
4037f3a7:	400f00        	ssr	a15
4037f3aa:	919090        	srl	a9, a9
4037f3ad:	1f0c      	movi.n	a15, 1
4037f3af:	401700        	ssl	a7
4037f3b2:	a1ff00        	sll	a15, a15
4037f3b5:	3099f0        	xor	a9, a9, a15
		fl -= (control->fl_index_shift - 1);
4037f3b8:	24b5b0        	extui	a11, a11, 5, 3
4037f3bb:	c0ddb0        	sub	a13, a13, a11
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037f3be:	8cf8      	l32i.n	a15, a12, 32
4037f3c0:	4cb8      	l32i.n	a11, a12, 16
4037f3c2:	54beb0        	extui	a11, a11, 14, 6
4037f3c5:	82bbd0        	mull	a11, a11, a13
4037f3c8:	bb9a      	add.n	a11, a11, a9
4037f3ca:	a0bbf0        	addx4	a11, a11, a15
4037f3cd:	0bb8      	l32i.n	a11, a11, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037f3cf:	dbcc      	bnez.n	a11, 4037f3e0 <tlsf_memalign_offs+0x3e8>
4037f3d1:	d702d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037f3d4:	d703c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037f3d7:	90a1b2        	movi	a11, 0x190
4037f3da:	d6f6a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f3dd:	009c25        	call8	4037fda0 <__assert_func>
	block->next_free = current;
4037f3e0:	0262b2        	s32i	a11, a2, 8
	block->prev_free = &control->block_null;
4037f3e3:	0362c2        	s32i	a12, a2, 12
	current->prev_free = block;
4037f3e6:	036b22        	s32i	a2, a11, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f3e9:	ba3b      	addi.n	a11, a10, 3
4037f3eb:	cf7c      	movi.n	a15, -4
4037f3ed:	10bbf0        	and	a11, a11, a15
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037f3f0:	0e1ab7        	beq	a10, a11, 4037f402 <tlsf_memalign_offs+0x40a>
4037f3f3:	d6fdd1        	l32r	a13, 40374fe8 <_iram_text_start+0xbe4> (3c022cb0 <_flash_rodata_start+0x2b90>)
4037f3f6:	d6fac1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037f3f9:	96a1b2        	movi	a11, 0x196
4037f3fc:	d6eea1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f3ff:	009a25        	call8	4037fda0 <__assert_func>
	control->blocks[fl * control->sl_index_count + sl] = block;
4037f402:	8cb8      	l32i.n	a11, a12, 32
4037f404:	4ca8      	l32i.n	a10, a12, 16
4037f406:	54aea0        	extui	a10, a10, 14, 6
4037f409:	82ada0        	mull	a10, a13, a10
4037f40c:	a9aa      	add.n	a10, a9, a10
4037f40e:	a0aab0        	addx4	a10, a10, a11
4037f411:	0a29      	s32i.n	a2, a10, 0
	control->fl_bitmap |= (1U << fl);
4037f413:	6cb8      	l32i.n	a11, a12, 24
4037f415:	1a0c      	movi.n	a10, 1
4037f417:	401d00        	ssl	a13
4037f41a:	a1fa00        	sll	a15, a10
4037f41d:	20bbf0        	or	a11, a11, a15
4037f420:	6cb9      	s32i.n	a11, a12, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037f422:	7cb8      	l32i.n	a11, a12, 28
4037f424:	a0ddb0        	addx4	a13, a13, a11
4037f427:	0db8      	l32i.n	a11, a13, 0
4037f429:	401900        	ssl	a9
4037f42c:	a1aa00        	sll	a10, a10
4037f42f:	209ba0        	or	a9, a11, a10
4037f432:	0d99      	s32i.n	a9, a13, 0
	return remaining_block;
4037f434:	0001c6        	j	4037f43f <tlsf_memalign_offs+0x447>
4037f437:	080c00        	lsx	f0, a12, a0
	block_header_t* block = block_locate_free(control, &aligned_size);
4037f43a:	000046        	j	4037f43f <tlsf_memalign_offs+0x447>
4037f43d:	028d      	mov.n	a8, a2
	if (block)
4037f43f:	48cc      	bnez.n	a8, 4037f447 <tlsf_memalign_offs+0x44f>
4037f441:	007f86        	j	4037f643 <tlsf_memalign_offs+0x64b>
			block = block_trim_free_leading(control, block, gap - off_adjust);
4037f444:	208220        	or	a8, a2, a2
		tlsf_assert(size && "size must be non-zero");
4037f447:	decc      	bnez.n	a14, 4037f458 <tlsf_memalign_offs+0x460>
4037f449:	d6eed1        	l32r	a13, 40375004 <_iram_text_start+0xc00> (3c022ef8 <_flash_rodata_start+0x2dd8>)
4037f44c:	d6efc1        	l32r	a12, 40375008 <_iram_text_start+0xc04> (3c027b34 <__func__$10>)
4037f44f:	76a2b2        	movi	a11, 0x276
4037f452:	d6d8a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f455:	0094a5        	call8	4037fda0 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f458:	1898      	l32i.n	a9, a8, 4
	tlsf_assert(block_is_free(block) && "block must be free");
4037f45a:	0ee907        	bbsi	a9, 0, 4037f46c <tlsf_memalign_offs+0x474>
4037f45d:	d6ebd1        	l32r	a13, 4037500c <_iram_text_start+0xc08> (3c022f18 <_flash_rodata_start+0x2df8>)
4037f460:	d6ecc1        	l32r	a12, 40375010 <_iram_text_start+0xc0c> (3c027b24 <__func__$9>)
4037f463:	24a2b2        	movi	a11, 0x224
4037f466:	d6d3a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f469:	009365        	call8	4037fda0 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f46c:	ca7c      	movi.n	a10, -4
4037f46e:	10b9a0        	and	a11, a9, a10
	return block_size(block) >= sizeof(block_header_t) + size;
4037f471:	10c492        	addi	a9, a4, 16
	if (block_can_split(block, size))
4037f474:	02bb97        	bgeu	a11, a9, 4037f47a <tlsf_memalign_offs+0x482>
4037f477:	0061c6        	j	4037f602 <tlsf_memalign_offs+0x60a>
	return tlsf_cast(void*,
4037f47a:	e88b      	addi.n	a14, a8, 8
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f47c:	94aa      	add.n	a9, a4, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f47e:	9e9a      	add.n	a9, a14, a9
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f480:	c0ab40        	sub	a10, a11, a4
4037f483:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(void*,
4037f486:	d98b      	addi.n	a13, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f488:	f9bb      	addi.n	a15, a9, 11
4037f48a:	c77c      	movi.n	a7, -4
4037f48c:	10ff70        	and	a15, a15, a7
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f48f:	0e1df7        	beq	a13, a15, 4037f4a1 <tlsf_memalign_offs+0x4a9>
4037f492:	d6e0d1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037f495:	d6e0c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f498:	c4a1b2        	movi	a11, 0x1c4
4037f49b:	d6c6a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f49e:	009025        	call8	4037fda0 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f4a1:	f4aa      	add.n	a15, a4, a10
4037f4a3:	ff4b      	addi.n	a15, a15, 4
4037f4a5:	0e1bf7        	beq	a11, a15, 4037f4b7 <tlsf_memalign_offs+0x4bf>
4037f4a8:	d6ddd1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037f4ab:	d6dbc1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f4ae:	c7a1b2        	movi	a11, 0x1c7
4037f4b1:	d6c0a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f4b4:	008ea5        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037f4b7:	19b8      	l32i.n	a11, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f4b9:	14b0b0        	extui	a11, a11, 0, 2
4037f4bc:	20aab0        	or	a10, a10, a11
4037f4bf:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f4c1:	cb7c      	movi.n	a11, -4
4037f4c3:	10aab0        	and	a10, a10, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f4c6:	bb0c      	movi.n	a11, 11
4037f4c8:	0e3ba7        	bltu	a11, a10, 4037f4da <tlsf_memalign_offs+0x4e2>
4037f4cb:	d6d5d1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037f4ce:	d6d2c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f4d1:	c9a1b2        	movi	a11, 0x1c9
4037f4d4:	d6b8a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f4d7:	008ca5        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037f4da:	18a8      	l32i.n	a10, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f4dc:	14a0a0        	extui	a10, a10, 0, 2
4037f4df:	2044a0        	or	a4, a4, a10
4037f4e2:	1849      	s32i.n	a4, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f4e4:	19b8      	l32i.n	a11, a9, 4
4037f4e6:	ca7c      	movi.n	a10, -4
4037f4e8:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f4eb:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f4ee:	adaa      	add.n	a10, a13, a10
	tlsf_assert(!block_is_last(block));
4037f4f0:	3d0c      	movi.n	a13, 3
4037f4f2:	0e3db7        	bltu	a13, a11, 4037f504 <tlsf_memalign_offs+0x50c>
4037f4f5:	d6aad1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f4f8:	d6abc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f4fb:	a1a0b2        	movi	a11, 161
4037f4fe:	d6aaa1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f501:	0089e5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037f504:	0a99      	s32i.n	a9, a10, 0
	block->size |= block_header_prev_free_bit;
4037f506:	1ab8      	l32i.n	a11, a10, 4
4037f508:	2d0c      	movi.n	a13, 2
4037f50a:	20bbd0        	or	a11, a11, a13
4037f50d:	1ab9      	s32i.n	a11, a10, 4
	block->size |= block_header_free_bit;
4037f50f:	19a8      	l32i.n	a10, a9, 4
4037f511:	1b0c      	movi.n	a11, 1
4037f513:	20aab0        	or	a10, a10, a11
4037f516:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f518:	18b8      	l32i.n	a11, a8, 4
4037f51a:	ca7c      	movi.n	a10, -4
4037f51c:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f51f:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f522:	eeaa      	add.n	a14, a14, a10
	tlsf_assert(!block_is_last(block));
4037f524:	3a0c      	movi.n	a10, 3
4037f526:	0e3ab7        	bltu	a10, a11, 4037f538 <tlsf_memalign_offs+0x540>
4037f529:	d69dd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f52c:	d69ec1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f52f:	a1a0b2        	movi	a11, 161
4037f532:	d69da1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f535:	0086a5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037f538:	0e89      	s32i.n	a8, a14, 0
	block->size |= block_header_prev_free_bit;
4037f53a:	19b8      	l32i.n	a11, a9, 4
4037f53c:	2a0c      	movi.n	a10, 2
4037f53e:	20aba0        	or	a10, a11, a10
4037f541:	19a9      	s32i.n	a10, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
4037f543:	ca7c      	movi.n	a10, -4
4037f545:	10bba0        	and	a11, a11, a10
	if (size < control->small_block_size)
4037f548:	4ca8      	l32i.n	a10, a12, 16
4037f54a:	75a7a0        	extui	a10, a10, 23, 8
4037f54d:	0fbba7        	bgeu	a11, a10, 4037f560 <tlsf_memalign_offs+0x568>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f550:	4cd8      	l32i.n	a13, a12, 16
4037f552:	54ded0        	extui	a13, a13, 14, 6
4037f555:	d2aad0        	quos	a10, a10, a13
4037f558:	d2bba0        	quos	a11, a11, a10
		fl = 0;
4037f55b:	0d0c      	movi.n	a13, 0
4037f55d:	000cc6        	j	4037f594 <tlsf_memalign_offs+0x59c>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f560:	ab8c      	beqz.n	a11, 4037f56e <tlsf_memalign_offs+0x576>
4037f562:	40fbd0        	nsau	a13, a11
4037f565:	e0cdd2        	addi	a13, a13, -32
4037f568:	60d0d0        	neg	a13, a13
4037f56b:	000086        	j	4037f571 <tlsf_memalign_offs+0x579>
4037f56e:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f571:	ffcde2        	addi	a14, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f574:	042ca2        	l32i	a10, a12, 16
4037f577:	25f4a0        	extui	a15, a10, 20, 3
4037f57a:	c0eef0        	sub	a14, a14, a15
4037f57d:	400e00        	ssr	a14
4037f580:	91b0b0        	srl	a11, a11
4037f583:	1e0c      	movi.n	a14, 1
4037f585:	401f00        	ssl	a15
4037f588:	a1ee00        	sll	a14, a14
4037f58b:	30bbe0        	xor	a11, a11, a14
		fl -= (control->fl_index_shift - 1);
4037f58e:	24a5a0        	extui	a10, a10, 5, 3
4037f591:	c0dda0        	sub	a13, a13, a10
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037f594:	8ce8      	l32i.n	a14, a12, 32
4037f596:	4ca8      	l32i.n	a10, a12, 16
4037f598:	54aea0        	extui	a10, a10, 14, 6
4037f59b:	82aad0        	mull	a10, a10, a13
4037f59e:	aaba      	add.n	a10, a10, a11
4037f5a0:	a0aae0        	addx4	a10, a10, a14
4037f5a3:	0aa8      	l32i.n	a10, a10, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037f5a5:	dacc      	bnez.n	a10, 4037f5b6 <tlsf_memalign_offs+0x5be>
4037f5a7:	d68dd1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037f5aa:	d68dc1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037f5ad:	90a1b2        	movi	a11, 0x190
4037f5b0:	d681a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f5b3:	007ee5        	call8	4037fda0 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037f5b6:	09dc      	bnez.n	a9, 4037f5ca <tlsf_memalign_offs+0x5d2>
4037f5b8:	d68bd1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037f5bb:	d689c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037f5be:	91a1b2        	movi	a11, 0x191
4037f5c1:	d67ca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f5c4:	201110        	or	a1, a1, a1
4037f5c7:	007da5        	call8	4037fda0 <__assert_func>
	block->next_free = current;
4037f5ca:	29a9      	s32i.n	a10, a9, 8
	block->prev_free = &control->block_null;
4037f5cc:	39c9      	s32i.n	a12, a9, 12
	current->prev_free = block;
4037f5ce:	3a99      	s32i.n	a9, a10, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037f5d0:	8ce8      	l32i.n	a14, a12, 32
4037f5d2:	4ca8      	l32i.n	a10, a12, 16
4037f5d4:	54aea0        	extui	a10, a10, 14, 6
4037f5d7:	82ada0        	mull	a10, a13, a10
4037f5da:	abaa      	add.n	a10, a11, a10
4037f5dc:	a0aae0        	addx4	a10, a10, a14
4037f5df:	0a99      	s32i.n	a9, a10, 0
	control->fl_bitmap |= (1U << fl);
4037f5e1:	6ca8      	l32i.n	a10, a12, 24
4037f5e3:	190c      	movi.n	a9, 1
4037f5e5:	401d00        	ssl	a13
4037f5e8:	a1e900        	sll	a14, a9
4037f5eb:	20aae0        	or	a10, a10, a14
4037f5ee:	6ca9      	s32i.n	a10, a12, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037f5f0:	7ca8      	l32i.n	a10, a12, 28
4037f5f2:	a0dda0        	addx4	a13, a13, a10
4037f5f5:	0da8      	l32i.n	a10, a13, 0
4037f5f7:	401b00        	ssl	a11
4037f5fa:	a19900        	sll	a9, a9
4037f5fd:	209a90        	or	a9, a10, a9
4037f600:	0d99      	s32i.n	a9, a13, 0
	return tlsf_cast(void*,
4037f602:	288b      	addi.n	a2, a8, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f604:	18a8      	l32i.n	a10, a8, 4
4037f606:	c97c      	movi.n	a9, -4
4037f608:	109a90        	and	a9, a10, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f60b:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f60e:	992a      	add.n	a9, a9, a2
	tlsf_assert(!block_is_last(block));
4037f610:	3b0c      	movi.n	a11, 3
4037f612:	0e3ba7        	bltu	a11, a10, 4037f624 <tlsf_memalign_offs+0x62c>
4037f615:	d662d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f618:	d663c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f61b:	a1a0b2        	movi	a11, 161
4037f61e:	d662a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f621:	0077e5        	call8	4037fda0 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037f624:	19a8      	l32i.n	a10, a9, 4
4037f626:	db7c      	movi.n	a11, -3
4037f628:	10aab0        	and	a10, a10, a11
4037f62b:	19a9      	s32i.n	a10, a9, 4
	block->size &= ~block_header_free_bit;
4037f62d:	1898      	l32i.n	a9, a8, 4
4037f62f:	ea7c      	movi.n	a10, -2
4037f631:	1099a0        	and	a9, a9, a10
4037f634:	1899      	s32i.n	a9, a8, 4
		p = block_to_ptr(block);
4037f636:	0002c6        	j	4037f645 <tlsf_memalign_offs+0x64d>
	void* p = 0;
4037f639:	020c      	movi.n	a2, 0
4037f63b:	000186        	j	4037f645 <tlsf_memalign_offs+0x64d>
4037f63e:	020c      	movi.n	a2, 0
4037f640:	000046        	j	4037f645 <tlsf_memalign_offs+0x64d>
4037f643:	082d      	mov.n	a2, a8
}
4037f645:	f01d      	retw.n
	...

4037f648 <tlsf_realloc>:
**   untouched
** - an extended buffer size will leave the newly-allocated area with
**   contents undefined
*/
void* tlsf_realloc(tlsf_t tlsf, void* ptr, size_t size)
{
4037f648:	004136        	entry	a1, 32
4037f64b:	207220        	or	a7, a2, a2
	control_t* control = tlsf_cast(control_t*, tlsf);
	void* p = 0;

	/* Zero-size requests are treated as free. */
	if (ptr && size == 0)
4037f64e:	01a092        	movi	a9, 1
4037f651:	839330        	moveqz	a9, a3, a3
4037f654:	40f480        	nsau	a8, a4
4037f657:	418580        	srli	a8, a8, 5
4037f65a:	0c0987        	bnone	a9, a8, 4037f66a <tlsf_realloc+0x22>
	{
		tlsf_free(tlsf, ptr);
4037f65d:	20b330        	or	a11, a3, a3
4037f660:	02ad      	mov.n	a10, a2
4037f662:	ff1d65        	call8	4037e838 <tlsf_free>
	void* p = 0;
4037f665:	020c      	movi.n	a2, 0
4037f667:	014546        	j	4037fb80 <tlsf_realloc+0x538>
	}
	/* Requests with NULL pointers are treated as malloc. */
	else if (!ptr)
4037f66a:	00e356        	bnez	a3, 4037f67c <tlsf_realloc+0x34>
	{
		p = tlsf_malloc(tlsf, size);
4037f66d:	20b440        	or	a11, a4, a4
4037f670:	20a220        	or	a10, a2, a2
4037f673:	ff5b65        	call8	4037ec28 <tlsf_malloc>
4037f676:	0a2d      	mov.n	a2, a10
4037f678:	014106        	j	4037fb80 <tlsf_realloc+0x538>
4037f67b:	c3b200        	movf	a11, a2, b0
	return tlsf_cast(block_header_t*,
4037f67e:	92f8      	l32i.n	a15, a2, 36
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f680:	012b      	addi.n	a0, a1, 2
4037f682:	fcaf62        	movi	a6, -4
4037f685:	106960        	and	a6, a9, a6
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f688:	fcc6a2        	addi	a10, a6, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f68b:	aa3a      	add.n	a10, a10, a3
4037f68d:	0acd      	mov.n	a12, a10
	tlsf_assert(!block_is_last(block));
4037f68f:	380c      	movi.n	a8, 3
4037f691:	0e3897        	bltu	a8, a9, 4037f6a3 <tlsf_realloc+0x5b>
4037f694:	d643d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f697:	d643c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f69a:	a1a0b2        	movi	a11, 161
4037f69d:	d642a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f6a0:	006fe5        	call8	4037fda0 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f6a3:	1ae8      	l32i.n	a14, a10, 4
4037f6a5:	c87c      	movi.n	a8, -4
4037f6a7:	108e80        	and	a8, a14, a8
	{
		block_header_t* block = block_from_ptr(ptr);
		block_header_t* next = block_next(block);

		const size_t cursize = block_size(block);
		const size_t combined = cursize + block_size(next) + block_header_overhead;
4037f6aa:	d86a      	add.n	a13, a8, a6
4037f6ac:	dd4b      	addi.n	a13, a13, 4
	if (size)
4037f6ae:	4bb416        	beqz	a4, 4037fb6d <tlsf_realloc+0x525>
	return (x + (align - 1)) & ~(align - 1);
4037f6b1:	543b      	addi.n	a5, a4, 3
4037f6b3:	cf7c      	movi.n	a15, -4
4037f6b5:	1055f0        	and	a5, a5, a15
	if (control == NULL)
4037f6b8:	4b8216        	beqz	a2, 4037fb74 <tlsf_realloc+0x52c>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037f6bb:	4228      	l32i.n	a2, a2, 16
4037f6bd:	542820        	extui	a2, a2, 8, 6
4037f6c0:	1f0c      	movi.n	a15, 1
4037f6c2:	401200        	ssl	a2
4037f6c5:	a1ff00        	sll	a15, a15
		if (aligned < tlsf_block_size_max(control)) 
4037f6c8:	0235f7        	bltu	a5, a15, 4037f6ce <tlsf_realloc+0x86>
4037f6cb:	012a46        	j	4037fb78 <tlsf_realloc+0x530>
			adjust = tlsf_max(aligned, block_size_min);
4037f6ce:	cf0c      	movi.n	a15, 12
4037f6d0:	7355f0        	maxu	a5, a5, a15
		if (adjust == 0)
		{
			return p;
		}

		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037f6d3:	0e6907        	bbci	a9, 0, 4037f6e5 <tlsf_realloc+0x9d>
4037f6d6:	d62fd1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c023074 <_flash_rodata_start+0x2f54>)
4037f6d9:	d655c1        	l32r	a12, 40375030 <_iram_text_start+0xc2c> (3c027ab0 <__func__$1>)
4037f6dc:	a8a2b2        	movi	a11, 0x2a8
4037f6df:	d62fa1        	l32r	a10, 40374f9c <_iram_text_start+0xb98> (3c022adb <_flash_rodata_start+0x29bb>)
4037f6e2:	006be5        	call8	4037fda0 <__assert_func>

		/*
		** If the next block is used, or when combined with the current
		** block, does not offer enough space, we must reallocate and copy.
		*/
		if (adjust > cursize && (!block_is_free(next) || adjust > combined))
4037f6e5:	27b657        	bgeu	a6, a5, 4037f710 <tlsf_realloc+0xc8>
4037f6e8:	026e07        	bbci	a14, 0, 4037f6ee <tlsf_realloc+0xa6>
4037f6eb:	21bd57        	bgeu	a13, a5, 4037f710 <tlsf_realloc+0xc8>
		{
			p = tlsf_malloc(tlsf, size);
4037f6ee:	04bd      	mov.n	a11, a4
4037f6f0:	07ad      	mov.n	a10, a7
4037f6f2:	ff5365        	call8	4037ec28 <tlsf_malloc>
4037f6f5:	0a2d      	mov.n	a2, a10
			if (p)
4037f6f7:	485a16        	beqz	a10, 4037fb80 <tlsf_realloc+0x538>
			{
				const size_t minsize = tlsf_min(cursize, size);
				memcpy(p, ptr, minsize);
4037f6fa:	63c460        	minu	a12, a4, a6
4037f6fd:	03bd      	mov.n	a11, a3
4037f6ff:	d37581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037f702:	0008e0        	callx8	a8
				tlsf_free(tlsf, ptr);
4037f705:	03bd      	mov.n	a11, a3
4037f707:	07ad      	mov.n	a10, a7
4037f709:	ff12e5        	call8	4037e838 <tlsf_free>
4037f70c:	011c06        	j	4037fb80 <tlsf_realloc+0x538>
4037f70f:	365700        	lsi	f0, a7, 216
			}
		}
		else
		{
			/* Do we need to expand to the next block? */
			if (adjust > cursize)
4037f712:	5b0602        	l8ui	a0, a6, 91
4037f715:	ea5600        	utrunc.s	a5, f6, 0
	tlsf_assert(next && "next physical block can't be null");
4037f718:	2ed100        	f64norm	a13, a1, a0, 0
4037f71b:	2fc1d6        	bgez	a1, 4037fa1b <tlsf_realloc+0x3d3>
4037f71e:	a2b2d6        	bgez	a2, 4037f14d <tlsf_memalign_offs+0x155>
4037f721:	24a115        	call4	403a4134 <_coredump_iram_end+0x22134>
4037f724:	67a5d6        	bgez	a5, 4037fda2 <__assert_func+0x2>
4037f727:	ee0700        	f64iter	a0, a7, a0, 2, 1
	if (block_is_free(next))
4037f72a:	470602        	l8ui	a0, a6, 71
4037f72d:	279200        	lsi	f0, a2, 156
	if (size < control->small_block_size)
4037f730:	979004        	lsi	f0, a0, 0x25c
4037f733:	b89775        	call12	403380a8 <rom_rx_gain_force+0x331c7c>
4037f736:	27d210        	lsi	f1, a2, 156
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f739:	ded004        	lsi	f0, a0, 0x378
4037f73c:	99d054        	lsi	f5, a0, 0x264
4037f73f:	8890d2        	l16si	a13, a0, 0x110
4037f742:	0d0cd2        	l8ui	a13, a12, 13
		fl = 0;
4037f745:	000cc6        	j	4037f77c <tlsf_realloc+0x134>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f748:	a88c      	beqz.n	a8, 4037f756 <tlsf_realloc+0x10e>
4037f74a:	40f8d0        	nsau	a13, a8
4037f74d:	e0cdd2        	addi	a13, a13, -32
4037f750:	60d0d0        	neg	a13, a13
4037f753:	000086        	j	4037f759 <tlsf_realloc+0x111>
4037f756:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f759:	ffcde2        	addi	a14, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f75c:	042792        	l32i	a9, a7, 16
4037f75f:	25f490        	extui	a15, a9, 20, 3
4037f762:	c0eef0        	sub	a14, a14, a15
4037f765:	400e00        	ssr	a14
4037f768:	918080        	srl	a8, a8
4037f76b:	1e0c      	movi.n	a14, 1
4037f76d:	401f00        	ssl	a15
4037f770:	a1ee00        	sll	a14, a14
4037f773:	3088e0        	xor	a8, a8, a14
		fl -= (control->fl_index_shift - 1);
4037f776:	249590        	extui	a9, a9, 5, 3
4037f779:	c0dd90        	sub	a13, a13, a9
	block_header_t* prev = block->prev_free;
4037f77c:	3a98      	l32i.n	a9, a10, 12
	block_header_t* next = block->next_free;
4037f77e:	2ae8      	l32i.n	a14, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f780:	00e956        	bnez	a9, 4037f792 <tlsf_realloc+0x14a>
4037f783:	d60ed1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037f786:	d60ec1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037f789:	74a1b2        	movi	a11, 0x174
4037f78c:	d60aa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f78f:	006125        	call8	4037fda0 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f792:	0edc      	bnez.n	a14, 4037f7a6 <tlsf_realloc+0x15e>
4037f794:	d60cd1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037f797:	d60ac1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037f79a:	75a1b2        	movi	a11, 0x175
4037f79d:	d605a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f7a0:	201110        	or	a1, a1, a1
4037f7a3:	005fe5        	call8	4037fda0 <__assert_func>
	next->prev_free = prev;
4037f7a6:	3e99      	s32i.n	a9, a14, 12
	prev->next_free = next;
4037f7a8:	29e9      	s32i.n	a14, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f7aa:	87f8      	l32i.n	a15, a7, 32
4037f7ac:	4798      	l32i.n	a9, a7, 16
4037f7ae:	549e90        	extui	a9, a9, 14, 6
4037f7b1:	8299d0        	mull	a9, a9, a13
4037f7b4:	998a      	add.n	a9, a9, a8
4037f7b6:	a099f0        	addx4	a9, a9, a15
4037f7b9:	09f8      	l32i.n	a15, a9, 0
4037f7bb:	369cf7        	bne	a12, a15, 4037f7f5 <tlsf_realloc+0x1ad>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f7be:	09e9      	s32i.n	a14, a9, 0
		if (next == &control->block_null)
4037f7c0:	319e77        	bne	a14, a7, 4037f7f5 <tlsf_realloc+0x1ad>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f7c3:	77c8      	l32i.n	a12, a7, 28
4037f7c5:	a0cdc0        	addx4	a12, a13, a12
4037f7c8:	0ce8      	l32i.n	a14, a12, 0
4037f7ca:	190c      	movi.n	a9, 1
4037f7cc:	401800        	ssl	a8
4037f7cf:	a18900        	sll	a8, a9
4037f7d2:	1088e0        	and	a8, a8, a14
4037f7d5:	3088e0        	xor	a8, a8, a14
4037f7d8:	0c89      	s32i.n	a8, a12, 0
			if (!control->sl_bitmap[fl])
4037f7da:	7788      	l32i.n	a8, a7, 28
4037f7dc:	a08d80        	addx4	a8, a13, a8
4037f7df:	0888      	l32i.n	a8, a8, 0
4037f7e1:	08dc      	bnez.n	a8, 4037f7f5 <tlsf_realloc+0x1ad>
				control->fl_bitmap &= ~(1U << fl);
4037f7e3:	6798      	l32i.n	a9, a7, 24
4037f7e5:	180c      	movi.n	a8, 1
4037f7e7:	401d00        	ssl	a13
4037f7ea:	a18800        	sll	a8, a8
4037f7ed:	108890        	and	a8, a8, a9
4037f7f0:	308890        	xor	a8, a8, a9
4037f7f3:	6789      	s32i.n	a8, a7, 24
4037f7f5:	f8c382        	addi	a8, a3, -8
4037f7f8:	1898      	l32i.n	a9, a8, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037f7fa:	380c      	movi.n	a8, 3
4037f7fc:	0e3897        	bltu	a8, a9, 4037f80e <tlsf_realloc+0x1c6>
4037f7ff:	d5f2d1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037f802:	d5f2c1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027ad4 <__func__$3>)
4037f805:	f5a1b2        	movi	a11, 0x1f5
4037f808:	d5eba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f80b:	005965        	call8	4037fda0 <__assert_func>
4037f80e:	1ac8      	l32i.n	a12, a10, 4
4037f810:	c87c      	movi.n	a8, -4
4037f812:	10cc80        	and	a12, a12, a8
	prev->size += block_size(block) + block_header_overhead;
4037f815:	cc4b      	addi.n	a12, a12, 4
4037f817:	99ca      	add.n	a9, a9, a12
4037f819:	f8c3c2        	addi	a12, a3, -8
4037f81c:	1c99      	s32i.n	a9, a12, 4
4037f81e:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f821:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f824:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037f826:	3c0c      	movi.n	a12, 3
4037f828:	0e3c97        	bltu	a12, a9, 4037f83a <tlsf_realloc+0x1f2>
4037f82b:	d5ddd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f82e:	d5ddc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f831:	a1a0b2        	movi	a11, 161
4037f834:	d5dda1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f837:	0056a5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037f83a:	08b9      	s32i.n	a11, a8, 0
	if (block_absorb_post_hook != NULL)
4037f83c:	d5e581        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037f83f:	888c      	beqz.n	a8, 4037f84b <tlsf_realloc+0x203>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037f841:	1c0c      	movi.n	a12, 1
4037f843:	0b1c      	movi.n	a11, 16
4037f845:	d5e281        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037f848:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f84b:	f8c382        	addi	a8, a3, -8
4037f84e:	1898      	l32i.n	a9, a8, 4
4037f850:	c87c      	movi.n	a8, -4
4037f852:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f855:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f858:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037f85a:	3a0c      	movi.n	a10, 3
4037f85c:	0e3a97        	bltu	a10, a9, 4037f86e <tlsf_realloc+0x226>
4037f85f:	d5d0d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f862:	d5d0c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f865:	a1a0b2        	movi	a11, 161
4037f868:	d5d0a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f86b:	005365        	call8	4037fda0 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037f86e:	1898      	l32i.n	a9, a8, 4
4037f870:	da7c      	movi.n	a10, -3
4037f872:	1099a0        	and	a9, a9, a10
4037f875:	1899      	s32i.n	a9, a8, 4
	block->size &= ~block_header_free_bit;
4037f877:	f8c392        	addi	a9, a3, -8
4037f87a:	1988      	l32i.n	a8, a9, 4
4037f87c:	ea7c      	movi.n	a10, -2
4037f87e:	1088a0        	and	a8, a8, a10
4037f881:	1989      	s32i.n	a8, a9, 4
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f883:	f8c382        	addi	a8, a3, -8
4037f886:	1888      	l32i.n	a8, a8, 4
	tlsf_assert(!block_is_free(block) && "block must be used");
4037f888:	0e6807        	bbci	a8, 0, 4037f89a <tlsf_realloc+0x252>
4037f88b:	d5ead1        	l32r	a13, 40375034 <_iram_text_start+0xc30> (3c023184 <_flash_rodata_start+0x3064>)
4037f88e:	d5eac1        	l32r	a12, 40375038 <_iram_text_start+0xc34> (3c027aa0 <__func__$0>)
4037f891:	31a2b2        	movi	a11, 0x231
4037f894:	d5c8a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f897:	0050a5        	call8	4037fda0 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f89a:	c97c      	movi.n	a9, -4
4037f89c:	10a890        	and	a10, a8, a9
	return block_size(block) >= sizeof(block_header_t) + size;
4037f89f:	10c582        	addi	a8, a5, 16
	if (block_can_split(block, size))
4037f8a2:	02ba87        	bgeu	a10, a8, 4037f8a8 <tlsf_realloc+0x260>
4037f8a5:	00b546        	j	4037fb7e <tlsf_realloc+0x536>
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f8a8:	659a      	add.n	a6, a5, a9
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f8aa:	636a      	add.n	a6, a3, a6
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f8ac:	c08a50        	sub	a8, a10, a5
4037f8af:	889a      	add.n	a8, a8, a9
	return tlsf_cast(void*,
4037f8b1:	968b      	addi.n	a9, a6, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f8b3:	b6bb      	addi.n	a11, a6, 11
4037f8b5:	fcafc2        	movi	a12, -4
4037f8b8:	10bbc0        	and	a11, a11, a12
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f8bb:	0e19b7        	beq	a9, a11, 4037f8cd <tlsf_realloc+0x285>
4037f8be:	d5d5d1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037f8c1:	d5d5c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f8c4:	c4a1b2        	movi	a11, 0x1c4
4037f8c7:	d5bba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f8ca:	004d65        	call8	4037fda0 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f8cd:	80b580        	add	a11, a5, a8
4037f8d0:	04cbb2        	addi	a11, a11, 4
4037f8d3:	0e1ab7        	beq	a10, a11, 4037f8e5 <tlsf_realloc+0x29d>
4037f8d6:	d5d1d1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037f8d9:	d5cfc1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f8dc:	c7a1b2        	movi	a11, 0x1c7
4037f8df:	d5b5a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f8e2:	004be5        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037f8e5:	0126a2        	l32i	a10, a6, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f8e8:	14a0a0        	extui	a10, a10, 0, 2
4037f8eb:	2088a0        	or	a8, a8, a10
4037f8ee:	1689      	s32i.n	a8, a6, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f8f0:	ca7c      	movi.n	a10, -4
4037f8f2:	1088a0        	and	a8, a8, a10
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f8f5:	ba0c      	movi.n	a10, 11
4037f8f7:	0e3a87        	bltu	a10, a8, 4037f909 <tlsf_realloc+0x2c1>
4037f8fa:	d5c9d1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037f8fd:	d5c6c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c027b18 <__func__$8>)
4037f900:	c9a1b2        	movi	a11, 0x1c9
4037f903:	d5aca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f906:	0049a5        	call8	4037fda0 <__assert_func>
	const size_t oldsize = block->size;
4037f909:	f8c3a2        	addi	a10, a3, -8
4037f90c:	1a88      	l32i.n	a8, a10, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f90e:	148080        	extui	a8, a8, 0, 2
4037f911:	205580        	or	a5, a5, a8
4037f914:	1a59      	s32i.n	a5, a10, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f916:	16a8      	l32i.n	a10, a6, 4
4037f918:	c87c      	movi.n	a8, -4
4037f91a:	108a80        	and	a8, a10, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f91d:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f920:	898a      	add.n	a8, a9, a8
	tlsf_assert(!block_is_last(block));
4037f922:	3b0c      	movi.n	a11, 3
4037f924:	0e3ba7        	bltu	a11, a10, 4037f936 <tlsf_realloc+0x2ee>
4037f927:	d59ed1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f92a:	d59ec1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f92d:	a1a0b2        	movi	a11, 161
4037f930:	d59ea1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f933:	0046e5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037f936:	0869      	s32i.n	a6, a8, 0
	block->size |= block_header_prev_free_bit;
4037f938:	18a8      	l32i.n	a10, a8, 4
4037f93a:	2b0c      	movi.n	a11, 2
4037f93c:	20aab0        	or	a10, a10, a11
4037f93f:	18a9      	s32i.n	a10, a8, 4
	block->size |= block_header_free_bit;
4037f941:	1688      	l32i.n	a8, a6, 4
4037f943:	1a0c      	movi.n	a10, 1
4037f945:	20b8a0        	or	a11, a8, a10
4037f948:	16b9      	s32i.n	a11, a6, 4
	block->size &= ~block_header_prev_free_bit;
4037f94a:	db7c      	movi.n	a11, -3
4037f94c:	10b8b0        	and	a11, a8, a11
4037f94f:	20bba0        	or	a11, a11, a10
4037f952:	16b9      	s32i.n	a11, a6, 4
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f954:	ca7c      	movi.n	a10, -4
4037f956:	10a8a0        	and	a10, a8, a10
4037f959:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f95c:	a9aa      	add.n	a10, a9, a10
4037f95e:	0acd      	mov.n	a12, a10
	tlsf_assert(!block_is_last(block));
4037f960:	380c      	movi.n	a8, 3
4037f962:	0e38b7        	bltu	a8, a11, 4037f974 <tlsf_realloc+0x32c>
4037f965:	d58ed1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f968:	d58fc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037f96b:	a1a0b2        	movi	a11, 161
4037f96e:	d58ea1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f971:	0042e5        	call8	4037fda0 <__assert_func>
	tlsf_assert(next && "next physical block can't be null");
4037f974:	dacc      	bnez.n	a10, 4037f985 <tlsf_realloc+0x33d>
4037f976:	d597d1        	l32r	a13, 40374fd4 <_iram_text_start+0xbd0> (3c023158 <_flash_rodata_start+0x3038>)
4037f979:	d597c1        	l32r	a12, 40374fd8 <_iram_text_start+0xbd4> (3c027ac0 <__func__$2>)
4037f97c:	15a2b2        	movi	a11, 0x215
4037f97f:	d58da1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f982:	0041e5        	call8	4037fda0 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f985:	1a88      	l32i.n	a8, a10, 4
	if (block_is_free(next))
4037f987:	02e807        	bbsi	a8, 0, 4037f98d <tlsf_realloc+0x345>
4037f98a:	004606        	j	4037faa6 <tlsf_realloc+0x45e>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f98d:	cb7c      	movi.n	a11, -4
4037f98f:	10b8b0        	and	a11, a8, a11
	if (size < control->small_block_size)
4037f992:	4788      	l32i.n	a8, a7, 16
4037f994:	758780        	extui	a8, a8, 23, 8
4037f997:	0fbb87        	bgeu	a11, a8, 4037f9aa <tlsf_realloc+0x362>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f99a:	47d8      	l32i.n	a13, a7, 16
4037f99c:	54ded0        	extui	a13, a13, 14, 6
4037f99f:	d288d0        	quos	a8, a8, a13
4037f9a2:	d2bb80        	quos	a11, a11, a8
		fl = 0;
4037f9a5:	0e0c      	movi.n	a14, 0
4037f9a7:	000d06        	j	4037f9df <tlsf_realloc+0x397>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f9aa:	bb8c      	beqz.n	a11, 4037f9b9 <tlsf_realloc+0x371>
4037f9ac:	40fbe0        	nsau	a14, a11
4037f9af:	e0cee2        	addi	a14, a14, -32
4037f9b2:	60e0e0        	neg	a14, a14
4037f9b5:	0000c6        	j	4037f9bc <tlsf_realloc+0x374>
4037f9b8:	a0e200        	addx4	a14, a2, a0
4037f9bb:	ced200        	f64iter	a13, a2, a0, 0, 1
	return bit - 1;
4037f9be:	ff          	.byte	0xff
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f9bf:	042782        	l32i	a8, a7, 16
4037f9c2:	25f480        	extui	a15, a8, 20, 3
4037f9c5:	c0ddf0        	sub	a13, a13, a15
4037f9c8:	400d00        	ssr	a13
4037f9cb:	91b0b0        	srl	a11, a11
4037f9ce:	1d0c      	movi.n	a13, 1
4037f9d0:	401f00        	ssl	a15
4037f9d3:	a1dd00        	sll	a13, a13
4037f9d6:	30bbd0        	xor	a11, a11, a13
		fl -= (control->fl_index_shift - 1);
4037f9d9:	248580        	extui	a8, a8, 5, 3
4037f9dc:	c0ee80        	sub	a14, a14, a8
	block_header_t* prev = block->prev_free;
4037f9df:	3a88      	l32i.n	a8, a10, 12
	block_header_t* next = block->next_free;
4037f9e1:	2ad8      	l32i.n	a13, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f9e3:	d8cc      	bnez.n	a8, 4037f9f4 <tlsf_realloc+0x3ac>
4037f9e5:	d575d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037f9e8:	d576c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037f9eb:	74a1b2        	movi	a11, 0x174
4037f9ee:	d571a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f9f1:	003ae5        	call8	4037fda0 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f9f4:	ddcc      	bnez.n	a13, 4037fa05 <tlsf_realloc+0x3bd>
4037f9f6:	d573d1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037f9f9:	d571c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c027b88 <__func__$14>)
4037f9fc:	75a1b2        	movi	a11, 0x175
4037f9ff:	d56da1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037fa02:	0039e5        	call8	4037fda0 <__assert_func>
	next->prev_free = prev;
4037fa05:	3d89      	s32i.n	a8, a13, 12
	prev->next_free = next;
4037fa07:	0268d2        	s32i	a13, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037fa0a:	87f8      	l32i.n	a15, a7, 32
4037fa0c:	4788      	l32i.n	a8, a7, 16
4037fa0e:	548e80        	extui	a8, a8, 14, 6
4037fa11:	8288e0        	mull	a8, a8, a14
4037fa14:	88ba      	add.n	a8, a8, a11
4037fa16:	a088f0        	addx4	a8, a8, a15
4037fa19:	08f8      	l32i.n	a15, a8, 0
4037fa1b:	379cf7        	bne	a12, a15, 4037fa56 <tlsf_realloc+0x40e>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037fa1e:	08d9      	s32i.n	a13, a8, 0
		if (next == &control->block_null)
4037fa20:	329d77        	bne	a13, a7, 4037fa56 <tlsf_realloc+0x40e>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037fa23:	77c8      	l32i.n	a12, a7, 28
4037fa25:	11dee0        	slli	a13, a14, 2
4037fa28:	ccda      	add.n	a12, a12, a13
4037fa2a:	0cf8      	l32i.n	a15, a12, 0
4037fa2c:	180c      	movi.n	a8, 1
4037fa2e:	401b00        	ssl	a11
4037fa31:	a18800        	sll	a8, a8
4037fa34:	1088f0        	and	a8, a8, a15
4037fa37:	3088f0        	xor	a8, a8, a15
4037fa3a:	0c89      	s32i.n	a8, a12, 0
			if (!control->sl_bitmap[fl])
4037fa3c:	7788      	l32i.n	a8, a7, 28
4037fa3e:	88da      	add.n	a8, a8, a13
4037fa40:	0888      	l32i.n	a8, a8, 0
4037fa42:	08dc      	bnez.n	a8, 4037fa56 <tlsf_realloc+0x40e>
				control->fl_bitmap &= ~(1U << fl);
4037fa44:	67b8      	l32i.n	a11, a7, 24
4037fa46:	180c      	movi.n	a8, 1
4037fa48:	401e00        	ssl	a14
4037fa4b:	a18800        	sll	a8, a8
4037fa4e:	1088b0        	and	a8, a8, a11
4037fa51:	3088b0        	xor	a8, a8, a11
4037fa54:	6789      	s32i.n	a8, a7, 24
4037fa56:	1688      	l32i.n	a8, a6, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037fa58:	3b0c      	movi.n	a11, 3
4037fa5a:	0e3b87        	bltu	a11, a8, 4037fa6c <tlsf_realloc+0x424>
4037fa5d:	d55ad1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037fa60:	d55bc1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027ad4 <__func__$3>)
4037fa63:	f5a1b2        	movi	a11, 0x1f5
4037fa66:	d553a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037fa69:	003365        	call8	4037fda0 <__assert_func>
4037fa6c:	1ac8      	l32i.n	a12, a10, 4
4037fa6e:	cb7c      	movi.n	a11, -4
4037fa70:	10ccb0        	and	a12, a12, a11
	prev->size += block_size(block) + block_header_overhead;
4037fa73:	cc4b      	addi.n	a12, a12, 4
4037fa75:	88ca      	add.n	a8, a8, a12
4037fa77:	1689      	s32i.n	a8, a6, 4
4037fa79:	10b8b0        	and	a11, a8, a11
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037fa7c:	fccbb2        	addi	a11, a11, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037fa7f:	99ba      	add.n	a9, a9, a11
	tlsf_assert(!block_is_last(block));
4037fa81:	3b0c      	movi.n	a11, 3
4037fa83:	0e3b87        	bltu	a11, a8, 4037fa95 <tlsf_realloc+0x44d>
4037fa86:	d546d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037fa89:	d546c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c027bc8 <__func__$20>)
4037fa8c:	a1a0b2        	movi	a11, 161
4037fa8f:	d546a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037fa92:	0030e5        	call8	4037fda0 <__assert_func>
	next->prev_phys_block = block;
4037fa95:	0969      	s32i.n	a6, a9, 0
	if (block_absorb_post_hook != NULL)
4037fa97:	d54e81        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037fa9a:	888c      	beqz.n	a8, 4037faa6 <tlsf_realloc+0x45e>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037fa9c:	1c0c      	movi.n	a12, 1
4037fa9e:	0b1c      	movi.n	a11, 16
4037faa0:	d54c81        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037faa3:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037faa6:	1688      	l32i.n	a8, a6, 4
4037faa8:	c97c      	movi.n	a9, -4
4037faaa:	108890        	and	a8, a8, a9
	if (size < control->small_block_size)
4037faad:	4798      	l32i.n	a9, a7, 16
4037faaf:	759790        	extui	a9, a9, 23, 8
4037fab2:	0fb897        	bgeu	a8, a9, 4037fac5 <tlsf_realloc+0x47d>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037fab5:	47a8      	l32i.n	a10, a7, 16
4037fab7:	54aea0        	extui	a10, a10, 14, 6
4037faba:	d299a0        	quos	a9, a9, a10
4037fabd:	d28890        	quos	a8, a8, a9
		fl = 0;
4037fac0:	0a0c      	movi.n	a10, 0
4037fac2:	000d06        	j	4037fafa <tlsf_realloc+0x4b2>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037fac5:	b88c      	beqz.n	a8, 4037fad4 <tlsf_realloc+0x48c>
4037fac7:	40f8a0        	nsau	a10, a8
4037faca:	e0caa2        	addi	a10, a10, -32
4037facd:	60a0a0        	neg	a10, a10
4037fad0:	0000c6        	j	4037fad7 <tlsf_realloc+0x48f>
4037fad3:	a0a200        	addx4	a10, a2, a0
4037fad6:	cab200        	float.s	f11, a2, 0
	return bit - 1;
4037fad9:	ff          	.byte	0xff
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037fada:	042792        	l32i	a9, a7, 16
4037fadd:	25c490        	extui	a12, a9, 20, 3
4037fae0:	c0bbc0        	sub	a11, a11, a12
4037fae3:	400b00        	ssr	a11
4037fae6:	918080        	srl	a8, a8
4037fae9:	1b0c      	movi.n	a11, 1
4037faeb:	401c00        	ssl	a12
4037faee:	a1bb00        	sll	a11, a11
4037faf1:	3088b0        	xor	a8, a8, a11
		fl -= (control->fl_index_shift - 1);
4037faf4:	249590        	extui	a9, a9, 5, 3
4037faf7:	c0aa90        	sub	a10, a10, a9
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037fafa:	87b8      	l32i.n	a11, a7, 32
4037fafc:	4798      	l32i.n	a9, a7, 16
4037fafe:	549e90        	extui	a9, a9, 14, 6
4037fb01:	8299a0        	mull	a9, a9, a10
4037fb04:	998a      	add.n	a9, a9, a8
4037fb06:	a099b0        	addx4	a9, a9, a11
4037fb09:	0998      	l32i.n	a9, a9, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037fb0b:	d9cc      	bnez.n	a9, 4037fb1c <tlsf_realloc+0x4d4>
4037fb0d:	d533d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037fb10:	d534c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037fb13:	90a1b2        	movi	a11, 0x190
4037fb16:	d527a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037fb19:	002865        	call8	4037fda0 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037fb1c:	d6cc      	bnez.n	a6, 4037fb2d <tlsf_realloc+0x4e5>
4037fb1e:	d531d1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037fb21:	d52fc1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c027ba8 <__func__$17>)
4037fb24:	91a1b2        	movi	a11, 0x191
4037fb27:	d523a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037fb2a:	002765        	call8	4037fda0 <__assert_func>
	block->next_free = current;
4037fb2d:	2699      	s32i.n	a9, a6, 8
	block->prev_free = &control->block_null;
4037fb2f:	3679      	s32i.n	a7, a6, 12
	current->prev_free = block;
4037fb31:	3969      	s32i.n	a6, a9, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037fb33:	87b8      	l32i.n	a11, a7, 32
4037fb35:	4798      	l32i.n	a9, a7, 16
4037fb37:	549e90        	extui	a9, a9, 14, 6
4037fb3a:	829a90        	mull	a9, a10, a9
4037fb3d:	989a      	add.n	a9, a8, a9
4037fb3f:	a099b0        	addx4	a9, a9, a11
4037fb42:	0969      	s32i.n	a6, a9, 0
	control->fl_bitmap |= (1U << fl);
4037fb44:	67b8      	l32i.n	a11, a7, 24
4037fb46:	190c      	movi.n	a9, 1
4037fb48:	401a00        	ssl	a10
4037fb4b:	a1c900        	sll	a12, a9
4037fb4e:	20bbc0        	or	a11, a11, a12
4037fb51:	67b9      	s32i.n	a11, a7, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037fb53:	77b8      	l32i.n	a11, a7, 28
4037fb55:	a0aab0        	addx4	a10, a10, a11
4037fb58:	0ab8      	l32i.n	a11, a10, 0
4037fb5a:	401800        	ssl	a8
4037fb5d:	a19900        	sll	a9, a9
4037fb60:	208b90        	or	a8, a11, a9
4037fb63:	0a89      	s32i.n	a8, a10, 0
				block_mark_as_used(block);
			}

			/* Trim the resulting block and return the original pointer. */
			block_trim_used(control, block, adjust);
			p = ptr;
4037fb65:	032d      	mov.n	a2, a3
}
4037fb67:	000546        	j	4037fb80 <tlsf_realloc+0x538>
4037fb6a:	000000        	ill
			return p;
4037fb6d:	020c      	movi.n	a2, 0
4037fb6f:	000346        	j	4037fb80 <tlsf_realloc+0x538>
4037fb72:	060000        	lsi	f0, a0, 24
4037fb75:	000002        	l8ui	a0, a0, 0
4037fb78:	020c      	movi.n	a2, 0
4037fb7a:	000086        	j	4037fb80 <tlsf_realloc+0x538>
4037fb7d:	032d00        	lsi	f0, a13, 12
		}
	}

	return p;
}
4037fb80:	f01d      	retw.n
	...

4037fb84 <tlsf_size>:
{
4037fb84:	004136        	entry	a1, 32
	if (tlsf == NULL)
4037fb87:	328c      	beqz.n	a2, 4037fb8e <tlsf_size+0xa>
	return control->size;
4037fb89:	5228      	l32i.n	a2, a2, 20
4037fb8b:	000046        	j	4037fb90 <tlsf_size+0xc>
		return 0;
4037fb8e:	020c      	movi.n	a2, 0
}
4037fb90:	f01d      	retw.n
	...

4037fb94 <esp_log_impl_lock>:
#define MAX_MUTEX_WAIT_TICKS ((MAX_MUTEX_WAIT_MS + portTICK_PERIOD_MS - 1) / portTICK_PERIOD_MS)

static SemaphoreHandle_t s_log_mutex = NULL;

void esp_log_impl_lock(void)
{
4037fb94:	004136        	entry	a1, 32
    if (unlikely(!s_log_mutex)) {
4037fb97:	d52981        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94bcc <s_log_mutex>)
4037fb9a:	0888      	l32i.n	a8, a8, 0
4037fb9c:	98cc      	bnez.n	a8, 4037fba9 <esp_log_impl_lock+0x15>
        s_log_mutex = xSemaphoreCreateMutex();
4037fb9e:	01a0a2        	movi	a10, 1
4037fba1:	fa0ae5        	call8	40379c50 <xQueueCreateMutex>
4037fba4:	d52681        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94bcc <s_log_mutex>)
4037fba7:	08a9      	s32i.n	a10, a8, 0
    }
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fba9:	fbe9e5        	call8	4037ba48 <xTaskGetSchedulerState>
4037fbac:	091a26        	beqi	a10, 1, 4037fbb9 <esp_log_impl_lock+0x25>
        return;
    }
    xSemaphoreTake(s_log_mutex, portMAX_DELAY);
4037fbaf:	fb7c      	movi.n	a11, -1
4037fbb1:	d52281        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94bcc <s_log_mutex>)
4037fbb4:	08a8      	l32i.n	a10, a8, 0
4037fbb6:	fa1ca5        	call8	40379d80 <xQueueSemaphoreTake>
}
4037fbb9:	f01d      	retw.n
	...

4037fbbc <esp_log_impl_lock_timeout>:

bool esp_log_impl_lock_timeout(void)
{
4037fbbc:	004136        	entry	a1, 32
    if (unlikely(!s_log_mutex)) {
4037fbbf:	d51f81        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94bcc <s_log_mutex>)
4037fbc2:	0888      	l32i.n	a8, a8, 0
4037fbc4:	98cc      	bnez.n	a8, 4037fbd1 <esp_log_impl_lock_timeout+0x15>
        s_log_mutex = xSemaphoreCreateMutex();
4037fbc6:	01a0a2        	movi	a10, 1
4037fbc9:	fa0865        	call8	40379c50 <xQueueCreateMutex>
4037fbcc:	d51c81        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94bcc <s_log_mutex>)
4037fbcf:	08a9      	s32i.n	a10, a8, 0
    }
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fbd1:	fbe765        	call8	4037ba48 <xTaskGetSchedulerState>
4037fbd4:	181a26        	beqi	a10, 1, 4037fbf0 <esp_log_impl_lock_timeout+0x34>
        return true;
    }
    return xSemaphoreTake(s_log_mutex, MAX_MUTEX_WAIT_TICKS) == pdTRUE;
4037fbd7:	01a0b2        	movi	a11, 1
4037fbda:	d51881        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94bcc <s_log_mutex>)
4037fbdd:	0028a2        	l32i	a10, a8, 0
4037fbe0:	fa19e5        	call8	40379d80 <xQueueSemaphoreTake>
4037fbe3:	ffca22        	addi	a2, a10, -1
4037fbe6:	40f220        	nsau	a2, a2
4037fbe9:	412520        	srli	a2, a2, 5
4037fbec:	000086        	j	4037fbf2 <esp_log_impl_lock_timeout+0x36>
4037fbef:	120c00        	andbc	b0, b12, b0
}
4037fbf2:	f01d      	retw.n

4037fbf4 <esp_log_impl_unlock>:

void esp_log_impl_unlock(void)
{
4037fbf4:	004136        	entry	a1, 32
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fbf7:	fbe525        	call8	4037ba48 <xTaskGetSchedulerState>
4037fbfa:	0f1a26        	beqi	a10, 1, 4037fc0d <esp_log_impl_unlock+0x19>
        return;
    }
    xSemaphoreGive(s_log_mutex);
4037fbfd:	00a0d2        	movi	a13, 0
4037fc00:	20cdd0        	or	a12, a13, a13
4037fc03:	0dbd      	mov.n	a11, a13
4037fc05:	d50d81        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94bcc <s_log_mutex>)
4037fc08:	08a8      	l32i.n	a10, a8, 0
4037fc0a:	f9ece5        	call8	40379ad8 <xQueueGenericSend>
}
4037fc0d:	f01d      	retw.n
	...

4037fc10 <esp_log_early_timestamp>:
    return base + tick_count * (1000 / configTICK_RATE_HZ);
}

/* FIXME: define an API for getting the timestamp in soc/hal IDF-2351 */
uint32_t esp_log_early_timestamp(void)
{
4037fc10:	004136        	entry	a1, 32
    RSR(CCOUNT, ccount);
4037fc13:	03ea20        	rsr.ccount	a2
#if CONFIG_IDF_TARGET_ESP32
    /* ESP32 ROM stores separate clock rate values for each CPU, but we want the PRO CPU value always */
    extern uint32_t g_ticks_per_us_pro;
    return esp_cpu_get_cycle_count() / (g_ticks_per_us_pro * 1000);
#else
    return esp_cpu_get_cycle_count() / (esp_rom_get_cpu_ticks_per_us() * 1000);
4037fc16:	d2af81        	l32r	a8, 403746d4 <_iram_text_start+0x2d0> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
4037fc19:	0008e0        	callx8	a8
4037fc1c:	118ab0        	slli	a8, a10, 5
4037fc1f:	c088a0        	sub	a8, a8, a10
4037fc22:	a088a0        	addx4	a8, a8, a10
4037fc25:	1188d0        	slli	a8, a8, 3
#endif
}
4037fc28:	c22280        	quou	a2, a2, a8
4037fc2b:	f01d      	retw.n
4037fc2d:	000000        	ill

4037fc30 <esp_log_timestamp>:
{
4037fc30:	004136        	entry	a1, 32
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fc33:	fbe165        	call8	4037ba48 <xTaskGetSchedulerState>
4037fc36:	0a1a66        	bnei	a10, 1, 4037fc44 <esp_log_timestamp+0x14>
        return esp_log_early_timestamp();
4037fc39:	fffd65        	call8	4037fc10 <esp_log_early_timestamp>
4037fc3c:	0a2d      	mov.n	a2, a10
4037fc3e:	000d06        	j	4037fc76 <esp_log_timestamp+0x46>
4037fc41:	000000        	ill
    if (base == 0 && xPortGetCoreID() == 0) {
4037fc44:	d4ff81        	l32r	a8, 40375040 <_iram_text_start+0xc3c> (3fc94ac0 <base$0>)
4037fc47:	002882        	l32i	a8, a8, 0
4037fc4a:	e8cc      	bnez.n	a8, 4037fc5c <esp_log_timestamp+0x2c>
    asm volatile (
4037fc4c:	03eb80        	rsr.prid	a8
4037fc4f:	048d80        	extui	a8, a8, 13, 1
4037fc52:	68cc      	bnez.n	a8, 4037fc5c <esp_log_timestamp+0x2c>
        base = esp_log_early_timestamp();
4037fc54:	fffba5        	call8	4037fc10 <esp_log_early_timestamp>
4037fc57:	d4fa81        	l32r	a8, 40375040 <_iram_text_start+0xc3c> (3fc94ac0 <base$0>)
4037fc5a:	08a9      	s32i.n	a10, a8, 0
    TickType_t tick_count = xPortInIsrContext() ? xTaskGetTickCountFromISR() : xTaskGetTickCount();
4037fc5c:	fa4ae5        	call8	4037a10c <xPortInIsrContext>
4037fc5f:	5a8c      	beqz.n	a10, 4037fc68 <esp_log_timestamp+0x38>
4037fc61:	fb5865        	call8	4037b1e8 <xTaskGetTickCountFromISR>
4037fc64:	0000c6        	j	4037fc6b <esp_log_timestamp+0x3b>
4037fc67:	56e500        	lsi	f0, a5, 0x158
4037fc6a:	a0fb      	addi.n	a10, a0, 15
    return base + tick_count * (1000 / configTICK_RATE_HZ);
4037fc6c:	a0aa      	add.n	a10, a0, a10
4037fc6e:	d4f481        	l32r	a8, 40375040 <_iram_text_start+0xc3c> (3fc94ac0 <base$0>)
4037fc71:	0888      	l32i.n	a8, a8, 0
4037fc73:	902a80        	addx2	a2, a10, a8
}
4037fc76:	f01d      	retw.n

4037fc78 <esp_log_write>:
}

void esp_log_write(esp_log_level_t level,
                   const char *tag,
                   const char *format, ...)
{
4037fc78:	00a136        	entry	a1, 80
    va_list list;
    va_start(list, format);
4037fc7b:	7159      	s32i.n	a5, a1, 28
4037fc7d:	8169      	s32i.n	a6, a1, 32
4037fc7f:	9179      	s32i.n	a7, a1, 36
{
4037fc81:	02ad      	mov.n	a10, a2
4037fc83:	03bd      	mov.n	a11, a3
4037fc85:	04cd      	mov.n	a12, a4
    va_start(list, format);
4037fc87:	10c1e2        	addi	a14, a1, 16
4037fc8a:	11e9      	s32i.n	a14, a1, 4
4037fc8c:	30c1d2        	addi	a13, a1, 48
4037fc8f:	01d9      	s32i.n	a13, a1, 0
4037fc91:	cf0c      	movi.n	a15, 12
4037fc93:	21f9      	s32i.n	a15, a1, 8
    esp_log_writev(level, tag, format, list);
4037fc95:	000065        	call8	4037fc9c <esp_log_writev>
    va_end(list);
}
4037fc98:	f01d      	retw.n
	...

4037fc9c <esp_log_writev>:
{
4037fc9c:	006136        	entry	a1, 48
4037fc9f:	20a330        	or	a10, a3, a3
4037fca2:	006152        	s32i	a5, a1, 0
4037fca5:	016162        	s32i	a6, a1, 4
4037fca8:	2179      	s32i.n	a7, a1, 8
    esp_log_level_t level_for_tag = esp_log_level_get_timeout(tag);
4037fcaa:	000265        	call8	4037fcd0 <esp_log_level_get_timeout>
    if (ESP_LOG_NONE != level_for_tag && level <= level_for_tag) {
4037fcad:	180c      	movi.n	a8, 1
4037fcaf:	838aa0        	moveqz	a8, a10, a10
4037fcb2:	622a20        	lsi	f2, a10, 0x188
4037fcb5:	220b      	addi.n	a2, a2, -1
4037fcb7:	602020        	neg	a2, a2
4037fcba:	0f0287        	bnone	a2, a8, 4037fccd <esp_log_writev+0x31>
        (*s_log_print_func)(format, args);
4037fcbd:	d4e181        	l32r	a8, 40375044 <_iram_text_start+0xc40> (3fc92038 <s_log_print_func>)
4037fcc0:	0888      	l32i.n	a8, a8, 0
4037fcc2:	01b8      	l32i.n	a11, a1, 0
4037fcc4:	11c8      	l32i.n	a12, a1, 4
4037fcc6:	21d8      	l32i.n	a13, a1, 8
4037fcc8:	04ad      	mov.n	a10, a4
4037fcca:	0008e0        	callx8	a8
}
4037fccd:	f01d      	retw.n
	...

4037fcd0 <esp_log_level_get_timeout>:
    log_level_set(tag, level);
#endif
}

esp_log_level_t esp_log_level_get_timeout(const char *tag)
{
4037fcd0:	004136        	entry	a1, 32
4037fcd3:	02ad      	mov.n	a10, a2
#if CONFIG_LOG_TAG_LEVEL_IMPL_NONE
    (void)tag;
    return esp_log_get_default_level();
#else
    return log_level_get(tag, true);
4037fcd5:	1b0c      	movi.n	a11, 1
4037fcd7:	d4dc81        	l32r	a8, 40375048 <_iram_text_start+0xc44> (4201717c <log_level_get>)
4037fcda:	0008e0        	callx8	a8
#endif
}
4037fcdd:	0a2d      	mov.n	a2, a10
4037fcdf:	f01d      	retw.n
4037fce1:	000000        	ill

4037fce4 <abort>:
#include "esp_cpu.h"

#include "soc/soc_caps.h"

void __attribute__((noreturn)) abort(void)
{
4037fce4:	00e136        	entry	a1, 112
#define ERR_STR2  " on core "

    _Static_assert(UINTPTR_MAX == 0xffffffff, "abort() assumes 32-bit addresses");
    _Static_assert(SOC_CPU_CORES_NUM < 10, "abort() assumes number of cores is 1 to 9");

    char addr_buf[9] = { 0 };
4037fce7:	9c0c      	movi.n	a12, 9
4037fce9:	00a0b2        	movi	a11, 0
4037fcec:	01ad      	mov.n	a10, a1
4037fcee:	d1e881        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fcf1:	0008e0        	callx8	a8
    char core_buf[2] = { 0 };
4037fcf4:	719b      	addi.n	a7, a1, 9
4037fcf6:	2c0c      	movi.n	a12, 2
4037fcf8:	00a0b2        	movi	a11, 0
4037fcfb:	20a770        	or	a10, a7, a7
4037fcfe:	d1e481        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fd01:	0008e0        	callx8	a8

    char buf[sizeof(ERR_STR1) + sizeof(addr_buf) + sizeof(core_buf) + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037fd04:	2c3c      	movi.n	a12, 50
4037fd06:	0b0c      	movi.n	a11, 0
4037fd08:	0bc1a2        	addi	a10, a1, 11
4037fd0b:	d1e181        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fd0e:	0008e0        	callx8	a8

    itoa((uint32_t)(__builtin_return_address(0) - 3), addr_buf, 16);
4037fd11:	d4ce81        	l32r	a8, 4037504c <_iram_text_start+0xc48> (4037fd11 <abort+0x2d>)
4037fd14:	158e80        	extui	a8, a8, 30, 2
4037fd17:	018820        	slli	a8, a8, 30
4037fd1a:	11a0e0        	slli	a10, a0, 2
4037fd1d:	41a2a0        	srli	a10, a10, 2
4037fd20:	20aa80        	or	a10, a10, a8
4037fd23:	0c1c      	movi.n	a12, 16
4037fd25:	01bd      	mov.n	a11, a1
4037fd27:	fdcaa2        	addi	a10, a10, -3
4037fd2a:	d4cb81        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fd2d:	0008e0        	callx8	a8
4037fd30:	03eba0        	rsr.prid	a10
4037fd33:	04ada0        	extui	a10, a10, 13, 1
    itoa(esp_cpu_get_core_id(), core_buf, 10);
4037fd36:	ac0c      	movi.n	a12, 10
4037fd38:	07bd      	mov.n	a11, a7
4037fd3a:	d4c781        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fd3d:	0008e0        	callx8	a8

    const char *str[] = { ERR_STR1, addr_buf, ERR_STR2, core_buf };
4037fd40:	d4c481        	l32r	a8, 40375050 <_iram_text_start+0xc4c> (3fc93b38 <__FUNCTION__$0+0x280>)
4037fd43:	106182        	s32i	a8, a1, 64
4037fd46:	116112        	s32i	a1, a1, 68
4037fd49:	d4c281        	l32r	a8, 40375054 <_iram_text_start+0xc50> (3fc93b54 <__FUNCTION__$0+0x29c>)
4037fd4c:	126182        	s32i	a8, a1, 72
4037fd4f:	136172        	s32i	a7, a1, 76

    char *dest = buf;

    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fd52:	070c      	movi.n	a7, 0
4037fd54:	000406        	j	4037fd68 <abort+0x84>
4037fd57:	871000        	lsi	f0, a0, 0x21c
        strcat(dest, str[i]);
4037fd5a:	28b2a0        	lsi	f10, a2, 160
4037fd5d:	a1bb10        	lsi	f1, a11, 0x284
4037fd60:	d3b681        	l32r	a8, 40374c38 <_iram_text_start+0x834> (40001374 <strcat>)
4037fd63:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fd66:	771b      	addi.n	a7, a7, 1
4037fd68:	ec47b6        	bltui	a7, 4, 4037fd58 <abort+0x74>
    }

    esp_system_abort(buf);
4037fd6b:	a1bb      	addi.n	a10, a1, 11
4037fd6d:	f9a1e5        	call8	4037978c <esp_system_abort>

4037fd70 <ra_to_str>:
#elif __riscv
#define INST_LEN         4
#endif

static inline void ra_to_str(char *addr)
{
4037fd70:	004136        	entry	a1, 32
    addr[0] = '0';
4037fd73:	083c      	movi.n	a8, 48
4037fd75:	004282        	s8i	a8, a2, 0
    addr[1] = 'x';
4037fd78:	78a082        	movi	a8, 120
4037fd7b:	014282        	s8i	a8, a2, 1
    itoa((uint32_t)(__builtin_return_address(0) - INST_LEN), addr + 2, 16);
4037fd7e:	d4b781        	l32r	a8, 4037505c <_iram_text_start+0xc58> (4037fd7e <ra_to_str+0xe>)
4037fd81:	158e80        	extui	a8, a8, 30, 2
4037fd84:	018820        	slli	a8, a8, 30
4037fd87:	11a0e0        	slli	a10, a0, 2
4037fd8a:	41a2a0        	srli	a10, a10, 2
4037fd8d:	20aa80        	or	a10, a10, a8
4037fd90:	0c1c      	movi.n	a12, 16
4037fd92:	b22b      	addi.n	a11, a2, 2
4037fd94:	fdcaa2        	addi	a10, a10, -3
4037fd97:	d4b081        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fd9a:	0008e0        	callx8	a8
}
4037fd9d:	f01d      	retw.n
	...

4037fda0 <__assert_func>:

/* Overriding assert function so that whenever assert is called from critical section,
 * it does not lead to a crash of its own.
 */
void __attribute__((noreturn)) __assert_func(const char *file, int line, const char *func, const char *expr)
{
4037fda0:	024136        	entry	a1, 0x120

    ra_to_str(&buff[sizeof(ASSERT_STR) - 1]);

    esp_system_abort(buff);
#else
    char addr[11] = { 0 };
4037fda3:	bc0c      	movi.n	a12, 11
4037fda5:	0b0c      	movi.n	a11, 0
4037fda7:	01ad      	mov.n	a10, a1
4037fda9:	d1b981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fdac:	0008e0        	callx8	a8
    char buff[200];
    char lbuf[5];
    uint32_t rem_len = sizeof(buff) - 1;
    uint32_t off = 0;

    itoa(line, lbuf, 10);
4037fdaf:	ac0c      	movi.n	a12, 10
4037fdb1:	d3a0b2        	movi	a11, 211
4037fdb4:	b1ba      	add.n	a11, a1, a11
4037fdb6:	03ad      	mov.n	a10, a3
4037fdb8:	d4a881        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fdbb:	0008e0        	callx8	a8

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    if (!spi_flash_cache_enabled())
4037fdbe:	f7c9e5        	call8	40377a5c <spi_flash_cache_enabled>
4037fdc1:	048a56        	bnez	a10, 4037fe0d <__assert_func+0x6d>
    return ((intptr_t)p >= drom_start_addr && (intptr_t)p < SOC_DROM_HIGH);
4037fdc4:	d29591        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fdc7:	729920        	lsi	f2, a9, 0x1c8
4037fdca:	d29481        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd5ac3>)
4037fdcd:	728820        	lsi	f2, a8, 0x1c8
4037fdd0:	880b      	addi.n	a8, a8, -1
4037fdd2:	608080        	neg	a8, a8
#endif
    {
        if (esp_ptr_in_drom(file)) {
4037fdd5:	020897        	bnone	a8, a9, 4037fddb <__assert_func+0x3b>
            file = CACHE_DISABLED_STR;
4037fdd8:	d4a221        	l32r	a2, 40375060 <_iram_text_start+0xc5c> (3fc93b60 <__FUNCTION__$0+0x2a8>)
4037fddb:	d28f91        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fdde:	729940        	lsi	f4, a9, 0x1c8
4037fde1:	d28e81        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd5ac3>)
4037fde4:	728840        	lsi	f4, a8, 0x1c8
4037fde7:	880b      	addi.n	a8, a8, -1
4037fde9:	608080        	neg	a8, a8
        }

        if (esp_ptr_in_drom(func)) {
4037fdec:	060897        	bnone	a8, a9, 4037fdf6 <__assert_func+0x56>
            ra_to_str(addr);
4037fdef:	01ad      	mov.n	a10, a1
4037fdf1:	fff7e5        	call8	4037fd70 <ra_to_str>
            func = addr;
4037fdf4:	014d      	mov.n	a4, a1
4037fdf6:	d28891        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fdf9:	729950        	lsi	f5, a9, 0x1c8
4037fdfc:	d28881        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd5ac3>)
4037fdff:	728850        	lsi	f5, a8, 0x1c8
4037fe02:	880b      	addi.n	a8, a8, -1
4037fe04:	608080        	neg	a8, a8
        }

        if (esp_ptr_in_drom(expr)) {
4037fe07:	020897        	bnone	a8, a9, 4037fe0d <__assert_func+0x6d>
            expr = CACHE_DISABLED_STR;
4037fe0a:	d49551        	l32r	a5, 40375060 <_iram_text_start+0xc5c> (3fc93b60 <__FUNCTION__$0+0x2a8>)
        }
    }

    const char *str[] = {ASSERT_STR, func ? func : "\b", " ", file, ":", lbuf, " (", expr, ")"};
4037fe0d:	d49681        	l32r	a8, 40375068 <_iram_text_start+0xc64> (3fc93b78 <__FUNCTION__$0+0x2c0>)
4037fe10:	366182        	s32i	a8, a1, 216
4037fe13:	14cc      	bnez.n	a4, 4037fe18 <__assert_func+0x78>
4037fe15:	d49341        	l32r	a4, 40375064 <_iram_text_start+0xc60> (3fc93b74 <__FUNCTION__$0+0x2bc>)
4037fe18:	d8a082        	movi	a8, 216
4037fe1b:	818a      	add.n	a8, a1, a8
4037fe1d:	1849      	s32i.n	a4, a8, 4
4037fe1f:	d49391        	l32r	a9, 4037506c <_iram_text_start+0xc68> (3fc93b88 <__FUNCTION__$0+0x2d0>)
4037fe22:	2899      	s32i.n	a9, a8, 8
4037fe24:	3829      	s32i.n	a2, a8, 12
4037fe26:	d49291        	l32r	a9, 40375070 <_iram_text_start+0xc6c> (3fc93b8c <__FUNCTION__$0+0x2d4>)
4037fe29:	4899      	s32i.n	a9, a8, 16
4037fe2b:	d3a092        	movi	a9, 211
4037fe2e:	919a      	add.n	a9, a1, a9
4037fe30:	5899      	s32i.n	a9, a8, 20
4037fe32:	d49091        	l32r	a9, 40375074 <_iram_text_start+0xc70> (3fc93b90 <__FUNCTION__$0+0x2d8>)
4037fe35:	6899      	s32i.n	a9, a8, 24
4037fe37:	7859      	s32i.n	a5, a8, 28
4037fe39:	d48f91        	l32r	a9, 40375078 <_iram_text_start+0xc74> (3fc93fd8 <__FUNCTION__$0+0x720>)
4037fe3c:	8899      	s32i.n	a9, a8, 32

    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fe3e:	060c      	movi.n	a6, 0
    uint32_t off = 0;
4037fe40:	064d      	mov.n	a4, a6
    uint32_t rem_len = sizeof(buff) - 1;
4037fe42:	c7a052        	movi	a5, 199
    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fe45:	000b46        	j	4037fe76 <__assert_func+0xd6>
        uint32_t len = strlen(str[i]);
4037fe48:	d8a082        	movi	a8, 216
4037fe4b:	818a      	add.n	a8, a1, a8
4037fe4d:	a08680        	addx4	a8, a6, a8
4037fe50:	0838      	l32i.n	a3, a8, 0
4037fe52:	20a330        	or	a10, a3, a3
4037fe55:	d48981        	l32r	a8, 4037507c <_iram_text_start+0xc78> (40001248 <strlen>)
4037fe58:	0008e0        	callx8	a8
        uint32_t cpy_len = MIN(len, rem_len);
4037fe5b:	6375a0        	minu	a7, a5, a10
        memcpy(buff + off, str[i], cpy_len);
4037fe5e:	07cd      	mov.n	a12, a7
4037fe60:	03bd      	mov.n	a11, a3
4037fe62:	a1bb      	addi.n	a10, a1, 11
4037fe64:	aa4a      	add.n	a10, a10, a4
4037fe66:	d19b81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037fe69:	0008e0        	callx8	a8
        rem_len -= cpy_len;
4037fe6c:	c05570        	sub	a5, a5, a7
        off += cpy_len;
4037fe6f:	447a      	add.n	a4, a4, a7
        if (rem_len == 0) {
4037fe71:	758c      	beqz.n	a5, 4037fe7c <__assert_func+0xdc>
    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fe73:	01c662        	addi	a6, a6, 1
4037fe76:	08a082        	movi	a8, 8
4037fe79:	cbb867        	bgeu	a8, a6, 4037fe48 <__assert_func+0xa8>
            break;
        }
    }
    buff[off] = '\0';
4037fe7c:	a1bb      	addi.n	a10, a1, 11
4037fe7e:	4a4a      	add.n	a4, a10, a4
4037fe80:	080c      	movi.n	a8, 0
4037fe82:	004482        	s8i	a8, a4, 0
    esp_system_abort(buff);
4037fe85:	f99065        	call8	4037978c <esp_system_abort>

4037fe88 <esp_libc_include_assert_impl>:
    __assert_func(file, line, NULL, failedexpr);
}

/* No-op function, used to force linker to include these changes */
void esp_libc_include_assert_impl(void)
{
4037fe88:	004136        	entry	a1, 32
}
4037fe8b:	f01d      	retw.n
4037fe8d:	000000        	ill

4037fe90 <malloc>:
extern void *heap_caps_malloc_default(size_t size);
extern void *heap_caps_realloc_default(void *ptr, size_t size);
extern void *heap_caps_aligned_alloc_default(size_t alignment, size_t size);

void* malloc(size_t size)
{
4037fe90:	004136        	entry	a1, 32
4037fe93:	02ad      	mov.n	a10, a2
    return heap_caps_malloc_default(size);
4037fe95:	f60ce5        	call8	40375f64 <heap_caps_malloc_default>
}
4037fe98:	0a2d      	mov.n	a2, a10
4037fe9a:	f01d      	retw.n

4037fe9c <cfree>:
{
    return heap_caps_realloc_default(ptr, size);
}

void free(void *ptr)
{
4037fe9c:	004136        	entry	a1, 32
4037fe9f:	02ad      	mov.n	a10, a2
    heap_caps_free(ptr);
4037fea1:	f62d65        	call8	40376178 <heap_caps_free>
}
4037fea4:	f01d      	retw.n
	...

4037fea8 <calloc>:

ESP_COMPILER_DIAGNOSTIC_PUSH_IGNORE("-Wanalyzer-malloc-leak")
void* calloc(size_t nmemb, size_t size)
{
4037fea8:	004136        	entry	a1, 32
    void *result;
    size_t size_bytes;
    if (__builtin_mul_overflow(nmemb, size, &size_bytes)) {
4037feab:	080c      	movi.n	a8, 0
4037fead:	827230        	mull	a7, a2, a3
4037feb0:	a22230        	muluh	a2, a2, a3
4037feb3:	001216        	beqz	a2, 4037feb8 <calloc+0x10>
4037feb6:	180c      	movi.n	a8, 1
4037feb8:	48dc      	bnez.n	a8, 4037fed0 <calloc+0x28>
        return NULL;
    }

    result = heap_caps_malloc_default(size_bytes);
4037feba:	07ad      	mov.n	a10, a7
4037febc:	f60a65        	call8	40375f64 <heap_caps_malloc_default>
4037febf:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
4037fec1:	00da16        	beqz	a10, 4037fed2 <calloc+0x2a>
        bzero(result, size_bytes);
4037fec4:	07bd      	mov.n	a11, a7
4037fec6:	d46e81        	l32r	a8, 40375080 <_iram_text_start+0xc7c> (40001260 <bzero>)
4037fec9:	0008e0        	callx8	a8
4037fecc:	000086        	j	4037fed2 <calloc+0x2a>
4037fecf:	020c00        	andb	b0, b12, b0
    }
    return result;
}
4037fed2:	f01d      	retw.n

4037fed4 <_free_r>:
ESP_COMPILER_DIAGNOSTIC_POP("-Wanalyzer-malloc-leak")

#if CONFIG_LIBC_NEWLIB
void _free_r(struct _reent *r, void* ptr)
{
4037fed4:	004136        	entry	a1, 32
4037fed7:	03ad      	mov.n	a10, a3
    heap_caps_free(ptr);
4037fed9:	f629e5        	call8	40376178 <heap_caps_free>
}
4037fedc:	f01d      	retw.n
	...

4037fee0 <_realloc_r>:

void* _realloc_r(struct _reent *r, void* ptr, size_t size)
{
4037fee0:	004136        	entry	a1, 32
4037fee3:	20a330        	or	a10, a3, a3
4037fee6:	20b440        	or	a11, a4, a4
    return heap_caps_realloc_default(ptr, size);
4037fee9:	f610e5        	call8	40375ff8 <heap_caps_realloc_default>
}
4037feec:	202aa0        	or	a2, a10, a10
4037feef:	f01d      	retw.n
4037fef1:	000000        	ill

4037fef4 <_malloc_r>:

void* _malloc_r(struct _reent *r, size_t size)
{
4037fef4:	004136        	entry	a1, 32
4037fef7:	03ad      	mov.n	a10, a3
    return heap_caps_malloc_default(size);
4037fef9:	f606a5        	call8	40375f64 <heap_caps_malloc_default>
}
4037fefc:	0a2d      	mov.n	a2, a10
4037fefe:	f01d      	retw.n

4037ff00 <_calloc_r>:

void* _calloc_r(struct _reent *r, size_t nmemb, size_t size)
{
4037ff00:	004136        	entry	a1, 32
4037ff03:	20a330        	or	a10, a3, a3
4037ff06:	20b440        	or	a11, a4, a4
    return calloc(nmemb, size);
4037ff09:	fff9e5        	call8	4037fea8 <calloc>
}
4037ff0c:	202aa0        	or	a2, a10, a10
4037ff0f:	f01d      	retw.n
4037ff11:	000000        	ill

4037ff14 <esp_libc_include_heap_impl>:

/* No-op function, used to force linking this file,
   instead of the heap implementation from newlib.
 */
void esp_libc_include_heap_impl(void)
{
4037ff14:	004136        	entry	a1, 32
}
4037ff17:	f01d      	retw.n
4037ff19:	000000        	ill

4037ff1c <__atomic_fetch_or_8>:
#define _ATOMIC_HW_STUB_SYNC_LOCK_RELEASE(n, type)
#endif // CONFIG_STDATOMIC_S32C1I_SPIRAM_WORKAROUND

_Static_assert(sizeof(long long unsigned int) == 8, "atomics require a 8-bytes type");

ATOMIC_FUNCTIONS(8, long long unsigned int)
4037ff1c:	004136        	entry	a1, 32
4037ff1f:	207220        	or	a7, a2, a2
    if (xPortInIsrContext()) {
4037ff22:	fa1ea5        	call8	4037a10c <xPortInIsrContext>
4037ff25:	00ca16        	beqz	a10, 4037ff35 <__atomic_fetch_or_8+0x19>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037ff28:	ffafb2        	movi	a11, -1
4037ff2b:	d456a1        	l32r	a10, 40375084 <_iram_text_start+0xc80> (3fc927a8 <s_atomic_lock>)
4037ff2e:	fa2025        	call8	4037a130 <xPortEnterCriticalTimeout>
4037ff31:	000246        	j	4037ff3e <__atomic_fetch_or_8+0x22>
4037ff34:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037ff37:	ff          	.byte	0xff
4037ff38:	d453a1        	l32r	a10, 40375084 <_iram_text_start+0xc80> (3fc927a8 <s_atomic_lock>)
4037ff3b:	fa1f65        	call8	4037a130 <xPortEnterCriticalTimeout>
4037ff3e:	0020c0        	memw
4037ff41:	0728      	l32i.n	a2, a7, 0
4037ff43:	0020c0        	memw
4037ff46:	1738      	l32i.n	a3, a7, 4
4037ff48:	208240        	or	a8, a2, a4
4037ff4b:	209350        	or	a9, a3, a5
4037ff4e:	0020c0        	memw
4037ff51:	0789      	s32i.n	a8, a7, 0
4037ff53:	0020c0        	memw
4037ff56:	016792        	s32i	a9, a7, 4
    if (xPortInIsrContext()) {
4037ff59:	fa1b25        	call8	4037a10c <xPortInIsrContext>
4037ff5c:	8a8c      	beqz.n	a10, 4037ff68 <__atomic_fetch_or_8+0x4c>
        portEXIT_CRITICAL_ISR(mux);
4037ff5e:	d449a1        	l32r	a10, 40375084 <_iram_text_start+0xc80> (3fc927a8 <s_atomic_lock>)
4037ff61:	fa31e5        	call8	4037a280 <vPortExitCritical>
4037ff64:	000186        	j	4037ff6e <__atomic_fetch_or_8+0x52>
4037ff67:	47a100        	lsi	f0, a1, 0x11c
        portEXIT_CRITICAL(mux);
4037ff6a:	3165d4        	lsi	f13, a5, 196
4037ff6d:	1dfa      	add.n	a1, a13, a15
4037ff6f:	f0          	.byte	0xf0

4037ff70 <spi_flash_needs_reset_check>:
static bool flash_brownout_needs_reset = false;
static bool flash_erasing = false;

// This function could be called in startup
void spi_flash_needs_reset_check(void)
{
4037ff70:	004136        	entry	a1, 32
    // Currently only XMC is suggested to reset when brownout
#if CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC
    if ((g_rom_flashchip.device_id >> 16) == 0x20) {
4037ff73:	d21f81        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
4037ff76:	0888      	l32i.n	a8, a8, 0
4037ff78:	011882        	l16ui	a8, a8, 2
4037ff7b:	07c866        	bnei	a8, 32, 4037ff86 <spi_flash_needs_reset_check+0x16>
        flash_brownout_needs_reset = true;
4037ff7e:	d44281        	l32r	a8, 40375088 <_iram_text_start+0xc84> (3fc950f5 <flash_brownout_needs_reset>)
4037ff81:	190c      	movi.n	a9, 1
4037ff83:	004892        	s8i	a9, a8, 0
    }
#endif
}
4037ff86:	f01d      	retw.n

4037ff88 <spi_flash_set_erasing_flag>:

void spi_flash_set_erasing_flag(bool status)
{
4037ff88:	004136        	entry	a1, 32
    flash_erasing = status;
4037ff8b:	d44081        	l32r	a8, 4037508c <_iram_text_start+0xc88> (3fc950f4 <flash_erasing>)
4037ff8e:	004822        	s8i	a2, a8, 0
}
4037ff91:	f01d      	retw.n
	...

4037ff94 <spi_flash_brownout_need_reset>:

bool spi_flash_brownout_need_reset(void)
{
4037ff94:	004136        	entry	a1, 32
    return (flash_brownout_needs_reset && flash_erasing);
4037ff97:	d43c81        	l32r	a8, 40375088 <_iram_text_start+0xc84> (3fc950f5 <flash_brownout_needs_reset>)
4037ff9a:	000882        	l8ui	a8, a8, 0
4037ff9d:	b88c      	beqz.n	a8, 4037ffac <spi_flash_brownout_need_reset+0x18>
4037ff9f:	d43b81        	l32r	a8, 4037508c <_iram_text_start+0xc88> (3fc950f4 <flash_erasing>)
4037ffa2:	000882        	l8ui	a8, a8, 0
4037ffa5:	88cc      	bnez.n	a8, 4037ffb1 <spi_flash_brownout_need_reset+0x1d>
4037ffa7:	020c      	movi.n	a2, 0
4037ffa9:	000186        	j	4037ffb3 <spi_flash_brownout_need_reset+0x1f>
4037ffac:	020c      	movi.n	a2, 0
4037ffae:	000046        	j	4037ffb3 <spi_flash_brownout_need_reset+0x1f>
4037ffb1:	120c      	movi.n	a2, 1
}
4037ffb3:	f01d      	retw.n
4037ffb5:	000000        	ill

4037ffb8 <memspi_host_read_status_hs>:
    ESP_EARLY_LOGV(TAG, "chip_id: %X\n", *id);
    return ESP_OK;
}

esp_err_t memspi_host_read_status_hs(spi_flash_host_inst_t *host, uint8_t *out_sr)
{
4037ffb8:	008136        	entry	a1, 64
    //NOTE: we do have a read id function, however it doesn't work in high freq
    uint32_t stat_buf = 0;
4037ffbb:	0b0c      	movi.n	a11, 0
4037ffbd:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
4037ffbf:	714b      	addi.n	a7, a1, 4
4037ffc1:	cc1c      	movi.n	a12, 28
4037ffc3:	20a770        	or	a10, a7, a7
4037ffc6:	d13281        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037ffc9:	0008e0        	callx8	a8
4037ffcc:	180c      	movi.n	a8, 1
4037ffce:	064182        	s8i	a8, a1, 6
4037ffd1:	4119      	s32i.n	a1, a1, 16
4037ffd3:	580c      	movi.n	a8, 5
4037ffd5:	0c5182        	s16i	a8, a1, 24
        .command = CMD_RDSR,
        .miso_data = ((uint8_t*) &stat_buf),
        .miso_len = 1
    };
    esp_err_t err = host->driver->common_command(host, &t);
4037ffd8:	0288      	l32i.n	a8, a2, 0
4037ffda:	1888      	l32i.n	a8, a8, 4
4037ffdc:	07bd      	mov.n	a11, a7
4037ffde:	20a220        	or	a10, a2, a2
4037ffe1:	0008e0        	callx8	a8
4037ffe4:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4037ffe6:	3acc      	bnez.n	a10, 4037ffed <memspi_host_read_status_hs+0x35>
        return err;
    }
    *out_sr = stat_buf;
4037ffe8:	0188      	l32i.n	a8, a1, 0
4037ffea:	004382        	s8i	a8, a3, 0
    return ESP_OK;
}
4037ffed:	f01d      	retw.n
	...

4037fff0 <memspi_host_erase_chip>:
    }
    return ESP_OK;
}

void memspi_host_erase_chip(spi_flash_host_inst_t *host)
{
4037fff0:	008136        	entry	a1, 64
    spi_flash_trans_t t = { 0 };
4037fff3:	cc1c      	movi.n	a12, 28
4037fff5:	0b0c      	movi.n	a11, 0
4037fff7:	20a110        	or	a10, a1, a1
4037fffa:	d12581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fffd:	0008e0        	callx8	a8
    t.command = CMD_CHIP_ERASE;
40380000:	c7a082        	movi	a8, 199
40380003:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
40380006:	0288      	l32i.n	a8, a2, 0
40380008:	1888      	l32i.n	a8, a8, 4
4038000a:	01bd      	mov.n	a11, a1
4038000c:	02ad      	mov.n	a10, a2
4038000e:	0008e0        	callx8	a8
}
40380011:	f01d      	retw.n
	...

40380014 <memspi_host_set_write_protect>:
    host->driver->common_command(host, &t);
    return ESP_OK;
}

esp_err_t memspi_host_set_write_protect(spi_flash_host_inst_t *host, bool wp)
{
40380014:	008136        	entry	a1, 64
40380017:	743030        	extui	a3, a3, 0, 8
    spi_flash_trans_t t = {
4038001a:	cc1c      	movi.n	a12, 28
4038001c:	0b0c      	movi.n	a11, 0
4038001e:	01ad      	mov.n	a10, a1
40380020:	d11c81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380023:	0008e0        	callx8	a8
40380026:	338c      	beqz.n	a3, 4038002d <memspi_host_set_write_protect+0x19>
40380028:	480c      	movi.n	a8, 4
4038002a:	000046        	j	4038002f <memspi_host_set_write_protect+0x1b>
4038002d:	680c      	movi.n	a8, 6
4038002f:	0a5182        	s16i	a8, a1, 20
        .command = wp ? CMD_WRDI : CMD_WREN
    };
    host->driver->common_command(host, &t);
40380032:	0288      	l32i.n	a8, a2, 0
40380034:	1888      	l32i.n	a8, a8, 4
40380036:	01bd      	mov.n	a11, a1
40380038:	02ad      	mov.n	a10, a2
4038003a:	0008e0        	callx8	a8
    return ESP_OK;
}
4038003d:	020c      	movi.n	a2, 0
4038003f:	f01d      	retw.n
40380041:	000000        	ill

40380044 <memspi_host_read_id_hs>:
{
40380044:	008136        	entry	a1, 64
    uint32_t id_buf = 0;
40380047:	0b0c      	movi.n	a11, 0
40380049:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
4038004b:	714b      	addi.n	a7, a1, 4
4038004d:	cc1c      	movi.n	a12, 28
4038004f:	07ad      	mov.n	a10, a7
40380051:	d10f81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380054:	0008e0        	callx8	a8
40380057:	380c      	movi.n	a8, 3
40380059:	064182        	s8i	a8, a1, 6
4038005c:	4119      	s32i.n	a1, a1, 16
4038005e:	9fa082        	movi	a8, 159
40380061:	0c5182        	s16i	a8, a1, 24
    host->driver->common_command(host, &t);
40380064:	0288      	l32i.n	a8, a2, 0
40380066:	1888      	l32i.n	a8, a8, 4
40380068:	20b770        	or	a11, a7, a7
4038006b:	20a220        	or	a10, a2, a2
4038006e:	0008e0        	callx8	a8
    uint32_t raw_flash_id = id_buf;
40380071:	0198      	l32i.n	a9, a1, 0
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
40380073:	d40781        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
40380076:	c08980        	sub	a8, a9, a8
40380079:	40f880        	nsau	a8, a8
4038007c:	418580        	srli	a8, a8, 5
4038007f:	40f9a0        	nsau	a10, a9
40380082:	41a5a0        	srli	a10, a10, 5
40380085:	2088a0        	or	a8, a8, a10
40380088:	c89c      	beqz.n	a8, 403800a8 <memspi_host_read_id_hs+0x64>
4038008a:	d0f881        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
4038008d:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "no response\n");
4038008f:	f88c      	beqz.n	a8, 403800a2 <memspi_host_read_id_hs+0x5e>
40380091:	ffb9e5        	call8	4037fc30 <esp_log_timestamp>
40380094:	d400c1        	l32r	a12, 40375094 <_iram_text_start+0xc90> (3fc943f8 <TAG>)
40380097:	0abd      	mov.n	a11, a10
40380099:	d3ffa1        	l32r	a10, 40375098 <_iram_text_start+0xc94> (3fc93e44 <__FUNCTION__$0+0x58c>)
4038009c:	d10681        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4038009f:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_NO_RESPONSE;
403800a2:	08a122        	movi	a2, 0x108
403800a5:	0006c6        	j	403800c4 <memspi_host_read_id_hs+0x80>
    uint16_t flash_id = (raw_flash_id >> 16) | (raw_flash_id & 0xFF00);
403800a8:	f58090        	extui	a8, a9, 16, 16
403800ab:	00afa2        	movi	a10, 0xffffff00
403800ae:	10a9a0        	and	a10, a9, a10
403800b1:	f4a0a0        	extui	a10, a10, 0, 16
403800b4:	2088a0        	or	a8, a8, a10
    *id = ((uint32_t)mfg_id << 16) | flash_id;
403800b7:	749090        	extui	a9, a9, 0, 8
403800ba:	119900        	slli	a9, a9, 16
403800bd:	208890        	or	a8, a8, a9
403800c0:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
403800c2:	020c      	movi.n	a2, 0
}
403800c4:	f01d      	retw.n
	...

403800c8 <memspi_host_flush_cache>:
{
403800c8:	004136        	entry	a1, 32
    if ((void*)((memspi_host_inst_t*)host)->spi == (void*) spi_flash_ll_get_hw(SPI1_HOST)) {
403800cb:	012292        	l32i	a9, a2, 4
403800ce:	d1c481        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403800d1:	089987        	bne	a9, a8, 403800dd <memspi_host_flush_cache+0x15>
        spi_flash_check_and_flush_cache(addr, size);
403800d4:	20b440        	or	a11, a4, a4
403800d7:	20a330        	or	a10, a3, a3
403800da:	f79e25        	call8	40377abc <spi_flash_check_and_flush_cache>
}
403800dd:	020c      	movi.n	a2, 0
403800df:	f01d      	retw.n
403800e1:	000000        	ill

403800e4 <memspi_host_erase_sector>:
{
403800e4:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
403800e7:	d3ea81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403800ea:	0eb837        	bgeu	a8, a3, 403800fc <memspi_host_erase_sector+0x18>
403800ed:	d3ebd1        	l32r	a13, 4037509c <_iram_text_start+0xc98> (3fc93e7c <__FUNCTION__$0+0x5c4>)
403800f0:	d3ecc1        	l32r	a12, 403750a0 <_iram_text_start+0xc9c> (3fc943dc <__func__$2>)
403800f3:	96a0b2        	movi	a11, 150
403800f6:	d3eba1        	l32r	a10, 403750a4 <_iram_text_start+0xca0> (3fc93eb3 <__FUNCTION__$0+0x5fb>)
403800f9:	ffca65        	call8	4037fda0 <__assert_func>
    spi_flash_trans_t t = {
403800fc:	cc1c      	movi.n	a12, 28
403800fe:	0b0c      	movi.n	a11, 0
40380100:	01ad      	mov.n	a10, a1
40380102:	d0e381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380105:	0008e0        	callx8	a8
40380108:	881c      	movi.n	a8, 24
4038010a:	034182        	s8i	a8, a1, 3
4038010d:	1139      	s32i.n	a3, a1, 4
4038010f:	082c      	movi.n	a8, 32
40380111:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
40380114:	0288      	l32i.n	a8, a2, 0
40380116:	1888      	l32i.n	a8, a8, 4
40380118:	01bd      	mov.n	a11, a1
4038011a:	20a220        	or	a10, a2, a2
4038011d:	0008e0        	callx8	a8
}
40380120:	f01d      	retw.n
	...

40380124 <memspi_host_erase_block>:
{
40380124:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
40380127:	d3da81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
4038012a:	0eb837        	bgeu	a8, a3, 4038013c <memspi_host_erase_block+0x18>
4038012d:	d3dbd1        	l32r	a13, 4037509c <_iram_text_start+0xc98> (3fc93e7c <__FUNCTION__$0+0x5c4>)
40380130:	d3dec1        	l32r	a12, 403750a8 <_iram_text_start+0xca4> (3fc943c4 <__func__$1>)
40380133:	a2a0b2        	movi	a11, 162
40380136:	d3dba1        	l32r	a10, 403750a4 <_iram_text_start+0xca0> (3fc93eb3 <__FUNCTION__$0+0x5fb>)
40380139:	ffc665        	call8	4037fda0 <__assert_func>
    spi_flash_trans_t t = {
4038013c:	cc1c      	movi.n	a12, 28
4038013e:	0b0c      	movi.n	a11, 0
40380140:	01ad      	mov.n	a10, a1
40380142:	d0d381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380145:	0008e0        	callx8	a8
40380148:	881c      	movi.n	a8, 24
4038014a:	034182        	s8i	a8, a1, 3
4038014d:	1139      	s32i.n	a3, a1, 4
4038014f:	d8a082        	movi	a8, 216
40380152:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
40380155:	0288      	l32i.n	a8, a2, 0
40380157:	1888      	l32i.n	a8, a8, 4
40380159:	01bd      	mov.n	a11, a1
4038015b:	02ad      	mov.n	a10, a2
4038015d:	0008e0        	callx8	a8
}
40380160:	f01d      	retw.n
	...

40380164 <memspi_host_program_page>:
{
40380164:	008136        	entry	a1, 64
    assert(address + length <= 0x1000000);
40380167:	845a      	add.n	a8, a4, a5
40380169:	d1d291        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4038016c:	0eb987        	bgeu	a9, a8, 4038017e <memspi_host_program_page+0x1a>
4038016f:	d3cfd1        	l32r	a13, 403750ac <_iram_text_start+0xca8> (3fc93ec8 <__FUNCTION__$0+0x610>)
40380172:	d3cfc1        	l32r	a12, 403750b0 <_iram_text_start+0xcac> (3fc943a8 <__func__$0>)
40380175:	aea0b2        	movi	a11, 174
40380178:	d3cba1        	l32r	a10, 403750a4 <_iram_text_start+0xca0> (3fc93eb3 <__FUNCTION__$0+0x5fb>)
4038017b:	ffc265        	call8	4037fda0 <__assert_func>
    spi_flash_trans_t t = {
4038017e:	cc1c      	movi.n	a12, 28
40380180:	0b0c      	movi.n	a11, 0
40380182:	01ad      	mov.n	a10, a1
40380184:	d0c381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380187:	0008e0        	callx8	a8
4038018a:	014152        	s8i	a5, a1, 1
4038018d:	881c      	movi.n	a8, 24
4038018f:	034182        	s8i	a8, a1, 3
40380192:	1149      	s32i.n	a4, a1, 4
40380194:	2139      	s32i.n	a3, a1, 8
40380196:	280c      	movi.n	a8, 2
40380198:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
4038019b:	0288      	l32i.n	a8, a2, 0
4038019d:	1888      	l32i.n	a8, a8, 4
4038019f:	01bd      	mov.n	a11, a1
403801a1:	02ad      	mov.n	a10, a2
403801a3:	0008e0        	callx8	a8
}
403801a6:	f01d      	retw.n

403801a8 <memspi_host_init_pointers>:
{
403801a8:	004136        	entry	a1, 32
403801ab:	02ad      	mov.n	a10, a2
403801ad:	03bd      	mov.n	a11, a3
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
403801af:	d13591        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
403801b2:	929a      	add.n	a9, a2, a9
403801b4:	d2a981        	l32r	a8, 40374c58 <_iram_text_start+0x854> (757fff <UserFrameTotalSize+0x757eff>)
403801b7:	628890        	lsi	f9, a8, 0x188
403801ba:	880b      	addi.n	a8, a8, -1
403801bc:	608080        	neg	a8, a8
403801bf:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
403801c2:	d2a691        	l32r	a9, 40374c5c <_iram_text_start+0x858> (b0000000 <_rtc_reserved_end+0x4ff00000>)
403801c5:	929a      	add.n	a9, a2, a9
403801c7:	d10ac1        	l32r	a12, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403801ca:	629c90        	lsi	f9, a12, 0x188
403801cd:	990b      	addi.n	a9, a9, -1
403801cf:	609090        	neg	a9, a9
403801d2:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403801d5:	d105d1        	l32r	a13, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403801d8:	d2da      	add.n	a13, a2, a13
403801da:	62ccd0        	lsi	f13, a12, 0x188
403801dd:	cc0b      	addi.n	a12, a12, -1
403801df:	60c0c0        	neg	a12, a12
403801e2:	74c0c0        	extui	a12, a12, 0, 8
    if (!esp_ptr_internal(host) && cfg->host_id == SPI1_HOST) {
403801e5:	208890        	or	a8, a8, a9
403801e8:	48cc      	bnez.n	a8, 403801f0 <memspi_host_init_pointers+0x48>
403801ea:	2ccc      	bnez.n	a12, 403801f0 <memspi_host_init_pointers+0x48>
403801ec:	8388      	l32i.n	a8, a3, 32
403801ee:	b89c      	beqz.n	a8, 4038020d <memspi_host_init_pointers+0x65>
    if (cfg->host_id == SPI1_HOST)
403801f0:	8b88      	l32i.n	a8, a11, 32
403801f2:	78cc      	bnez.n	a8, 403801fd <memspi_host_init_pointers+0x55>
        host->inst.driver = &esp_flash_default_host;
403801f4:	d3b081        	l32r	a8, 403750b4 <_iram_text_start+0xcb0> (3fc9378c <esp_flash_default_host>)
403801f7:	0a89      	s32i.n	a8, a10, 0
403801f9:	000146        	j	40380202 <memspi_host_init_pointers+0x5a>
403801fc:	ae8100        	f64iter	a8, a1, a0, 2, 0
        host->inst.driver = &esp_flash_gpspi_host;
403801ff:	0a89d3        	lsip	f13, a9, 40
    esp_err_t err = spi_flash_hal_init(host, cfg);
40380202:	d3ae81        	l32r	a8, 403750bc <_iram_text_start+0xcb8> (4200a3d8 <spi_flash_hal_init>)
40380205:	0008e0        	callx8	a8
40380208:	0a2d      	mov.n	a2, a10
    return err;
4038020a:	000086        	j	40380210 <memspi_host_init_pointers+0x68>
        return ESP_ERR_INVALID_ARG;
4038020d:	02a122        	movi	a2, 0x102
}
40380210:	f01d      	retw.n
	...

40380214 <memspi_host_write_data_slicer>:

// When encryption is enabled, etc. the data slicer may be complicated
// This is the simple case where the hardware has no other requirements than the size and page boundary
int memspi_host_write_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
40380214:	004136        	entry	a1, 32
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
40380217:	9288      	l32i.n	a8, a2, 36
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
40380219:	186807        	bbci	a8, 0, 40380235 <memspi_host_write_data_slicer+0x21>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
4038021c:	106307        	bbci	a3, 0, 40380230 <memspi_host_write_data_slicer+0x1c>
4038021f:	066407        	bbci	a4, 0, 40380229 <memspi_host_write_data_slicer+0x15>
            align_addr -= 1;
40380222:	330b      	addi.n	a3, a3, -1
            len += 1;
40380224:	441b      	addi.n	a4, a4, 1
40380226:	0002c6        	j	40380235 <memspi_host_write_data_slicer+0x21>
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
40380229:	330b      	addi.n	a3, a3, -1
            len += 2;
4038022b:	442b      	addi.n	a4, a4, 2
4038022d:	000106        	j	40380235 <memspi_host_write_data_slicer+0x21>
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
40380230:	016407        	bbci	a4, 0, 40380235 <memspi_host_write_data_slicer+0x21>
            len += 1;
40380233:	441b      	addi.n	a4, a4, 1
        }
    }

    uint32_t end_bound = (align_addr/page_size + 1) * page_size;
    // Shouldn't program cross the page, or longer than SPI_FLASH_HAL_MAX_WRITE_BYTES
    uint32_t max_len = MIN(end_bound - align_addr, SPI_FLASH_HAL_MAX_WRITE_BYTES);
40380235:	e28360        	remu	a8, a3, a6
40380238:	c06680        	sub	a6, a6, a8
4038023b:	084c      	movi.n	a8, 64
4038023d:	636680        	minu	a6, a6, a8
    *align_address = align_addr;
40380240:	0539      	s32i.n	a3, a5, 0
    return MIN(max_len, len);
}
40380242:	632460        	minu	a2, a4, a6
40380245:	f01d      	retw.n
	...

40380248 <memspi_host_read_data_slicer>:

int memspi_host_read_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
40380248:	004136        	entry	a1, 32
    // Shouldn't read longer than SPI_FLASH_HAL_MAX_READ_BYTES
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
4038024b:	9288      	l32i.n	a8, a2, 36
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
4038024d:	186807        	bbci	a8, 0, 40380269 <memspi_host_read_data_slicer+0x21>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
40380250:	106307        	bbci	a3, 0, 40380264 <memspi_host_read_data_slicer+0x1c>
40380253:	066407        	bbci	a4, 0, 4038025d <memspi_host_read_data_slicer+0x15>
            align_addr -= 1;
40380256:	330b      	addi.n	a3, a3, -1
            len += 1;
40380258:	441b      	addi.n	a4, a4, 1
4038025a:	0002c6        	j	40380269 <memspi_host_read_data_slicer+0x21>
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
4038025d:	330b      	addi.n	a3, a3, -1
            len += 2;
4038025f:	442b      	addi.n	a4, a4, 2
40380261:	000106        	j	40380269 <memspi_host_read_data_slicer+0x21>
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
40380264:	016407        	bbci	a4, 0, 40380269 <memspi_host_read_data_slicer+0x21>
            len += 1;
40380267:	441b      	addi.n	a4, a4, 1
        }
    }
    uint32_t max_len = SPI_FLASH_HAL_MAX_READ_BYTES;
    *align_address = align_addr;
40380269:	0539      	s32i.n	a3, a5, 0
    return MIN(max_len, len);
}
4038026b:	024c      	movi.n	a2, 64
4038026d:	632420        	minu	a2, a4, a2
40380270:	f01d      	retw.n
	...

40380274 <spi_flash_chip_boya_probe>:
#include "spi_flash_chip_generic.h"
#include "spi_flash_chip_gd.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_boya_probe(esp_flash_t *chip, uint32_t flash_id)
{
40380274:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0x68;
    if (flash_id >> 16 != MFG_ID) {
40380277:	f59030        	extui	a9, a3, 16, 16
4038027a:	68a082        	movi	a8, 104
4038027d:	109987        	bne	a9, a8, 40380291 <spi_flash_chip_boya_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x4000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
40380280:	743830        	extui	a3, a3, 8, 8
40380283:	113380        	slli	a3, a3, 8
40380286:	d07281        	l32r	a8, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
40380289:	0b9387        	bne	a3, a8, 40380298 <spi_flash_chip_boya_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
4038028c:	020c      	movi.n	a2, 0
4038028e:	000246        	j	4038029b <spi_flash_chip_boya_probe+0x27>
        return ESP_ERR_NOT_FOUND;
40380291:	05a122        	movi	a2, 0x105
40380294:	0000c6        	j	4038029b <spi_flash_chip_boya_probe+0x27>
40380297:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
4038029a:	f01d05        	call0	4037046c <rom_rx_gain_force+0x36a040>
4038029d:	000000        	ill

403802a0 <spi_flash_chip_boya_get_caps>:
}

spi_flash_caps_t spi_flash_chip_boya_get_caps(esp_flash_t *chip)
{
403802a0:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
403802a3:	420c      	movi.n	a2, 4
403802a5:	f01d      	retw.n
	...

403802a8 <spi_flash_chip_gd_detect_size>:
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}

esp_err_t spi_flash_chip_gd_detect_size(esp_flash_t *chip, uint32_t *size)
{
403802a8:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
403802ab:	62c8      	l32i.n	a12, a2, 24
    *size = 0;
403802ad:	0b0c      	movi.n	a11, 0
403802af:	03b9      	s32i.n	a11, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
403802b1:	f490c0        	extui	a9, a12, 0, 16
403802b4:	180c      	movi.n	a8, 1
403802b6:	0bad      	mov.n	a10, a11
403802b8:	83a890        	moveqz	a10, a8, a9
403802bb:	d069d1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
403802be:	c099d0        	sub	a9, a9, a13
403802c1:	938b90        	movnez	a8, a11, a9
403802c4:	208a80        	or	a8, a10, a8
403802c7:	d8cc      	bnez.n	a8, 403802d8 <spi_flash_chip_gd_detect_size+0x30>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    *size = 1 << (id & 0xFF);
403802c9:	180c      	movi.n	a8, 1
403802cb:	401c00        	ssl	a12
403802ce:	a18800        	sll	a8, a8
403802d1:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
403802d3:	0b2d      	mov.n	a2, a11
403802d5:	000086        	j	403802db <spi_flash_chip_gd_detect_size+0x33>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
403802d8:	d17421        	l32r	a2, 403748a8 <_iram_text_start+0x4a4> (6005 <UserFrameTotalSize+0x5f05>)
}
403802db:	f01d      	retw.n
403802dd:	000000        	ill

403802e0 <spi_flash_chip_gd_suspend_cmd_conf>:
    return ret;
}
#endif //CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_gd_suspend_cmd_conf(esp_flash_t *chip)
{
403802e0:	006136        	entry	a1, 48
    spi_flash_sus_cmd_conf sus_conf = {
403802e3:	8c0c      	movi.n	a12, 8
403802e5:	00a0b2        	movi	a11, 0
403802e8:	01ad      	mov.n	a10, a1
403802ea:	d06981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403802ed:	0008e0        	callx8	a8
403802f0:	84a082        	movi	a8, 132
403802f3:	0189      	s32i.n	a8, a1, 0
403802f5:	583c      	movi.n	a8, 53
403802f7:	044182        	s8i	a8, a1, 4
403802fa:	75a082        	movi	a8, 117
403802fd:	054182        	s8i	a8, a1, 5
40380300:	7aa082        	movi	a8, 122
40380303:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
40380306:	02a8      	l32i.n	a10, a2, 0
40380308:	0a88      	l32i.n	a8, a10, 0
4038030a:	152882        	l32i	a8, a8, 84
4038030d:	01bd      	mov.n	a11, a1
4038030f:	0008e0        	callx8	a8
}
40380312:	0a2d      	mov.n	a2, a10
40380314:	f01d      	retw.n
	...

40380318 <spi_flash_chip_gd_set_io_mode>:
{
40380318:	004136        	entry	a1, 32
4038031b:	02ad      	mov.n	a10, a2
    if (WRSR_16B_REQUIRED(chip->chip_id)) {
4038031d:	6288      	l32i.n	a8, a2, 24
4038031f:	749880        	extui	a9, a8, 8, 8
40380322:	119980        	slli	a9, a9, 8
40380325:	d366b1        	l32r	a11, 403750c0 <_iram_text_start+0xcbc> (6000 <UserFrameTotalSize+0x5f00>)
40380328:	0819b7        	beq	a9, a11, 40380334 <spi_flash_chip_gd_set_io_mode+0x1c>
4038032b:	748080        	extui	a8, a8, 0, 8
4038032e:	15a092        	movi	a9, 21
40380331:	113987        	bltu	a9, a8, 40380346 <spi_flash_chip_gd_set_io_mode+0x2e>
        return spi_flash_common_set_io_mode(chip,
40380334:	00a2d2        	movi	a13, 0x200
40380337:	d363c1        	l32r	a12, 403750c4 <_iram_text_start+0xcc0> (4038076c <spi_flash_common_read_status_16b_rdsr_rdsr2>)
4038033a:	d363b1        	l32r	a11, 403750c8 <_iram_text_start+0xcc4> (403807a4 <spi_flash_common_write_status_16b_wrsr>)
4038033d:	00afa5        	call8	40380e38 <spi_flash_common_set_io_mode>
40380340:	0a2d      	mov.n	a2, a10
40380342:	0003c6        	j	40380355 <spi_flash_chip_gd_set_io_mode+0x3d>
40380345:	a0d200        	addx4	a13, a2, a0
        return spi_flash_common_set_io_mode(chip,
40380348:	60c102        	addi	a0, a1, 96
4038034b:	61b1d3        	lsi	f13, a1, 0x184
4038034e:	aea5d3        	lsi	f13, a5, 0x2b8
40380351:	2aa000        	mul.s	f10, f0, f0
40380354:	009020        	all4	b2, b0:b1:b2:b3
	...

40380358 <spi_flash_chip_gd_get_io_mode>:
{
40380358:	006136        	entry	a1, 48
4038035b:	20a220        	or	a10, a2, a2
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
4038035e:	20b110        	or	a11, a1, a1
40380361:	0071e5        	call8	40380a80 <spi_flash_common_read_status_8b_rdsr2>
40380364:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380367:	9acc      	bnez.n	a10, 40380374 <spi_flash_chip_gd_get_io_mode+0x1c>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380369:	0188      	l32i.n	a8, a1, 0
4038036b:	888a      	add.n	a8, a8, a8
4038036d:	490c      	movi.n	a9, 4
4038036f:	108890        	and	a8, a8, a9
40380372:	0389      	s32i.n	a8, a3, 0
}
40380374:	f01d      	retw.n
	...

40380378 <spi_flash_chip_gd_get_caps>:
{
40380378:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
4038037b:	180282        	l8ui	a8, a2, 24
4038037e:	891c      	movi.n	a9, 24
40380380:	043987        	bltu	a9, a8, 40380388 <spi_flash_chip_gd_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
40380383:	020c      	movi.n	a2, 0
40380385:	000046        	j	4038038a <spi_flash_chip_gd_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_32MB_SUPPORT;
40380388:	220c      	movi.n	a2, 2
}
4038038a:	480c      	movi.n	a8, 4
4038038c:	202280        	or	a2, a2, a8
4038038f:	f01d      	retw.n
40380391:	000000        	ill

40380394 <spi_flash_chip_gd_probe>:
{
40380394:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40380397:	f59030        	extui	a9, a3, 16, 16
4038039a:	c8a082        	movi	a8, 200
4038039d:	1f9987        	bne	a9, a8, 403803c0 <spi_flash_chip_gd_probe+0x2c>
    uint32_t product_id = flash_id & FLASH_ID_MASK;
403803a0:	743830        	extui	a3, a3, 8, 8
403803a3:	113380        	slli	a3, a3, 8
    if (product_id != GD25Q_PRODUCT_ID && product_id != GD25LQ_PRODUCT_ID) {
403803a6:	c0d382        	addmi	a8, a3, 0xffffc000
403803a9:	190c      	movi.n	a9, 1
403803ab:	839880        	moveqz	a9, a8, a8
403803ae:	a0d332        	addmi	a3, a3, 0xffffa000
403803b1:	180c      	movi.n	a8, 1
403803b3:	838330        	moveqz	a8, a3, a3
403803b6:	0e8987        	bany	a9, a8, 403803c8 <spi_flash_chip_gd_probe+0x34>
    return ESP_OK;
403803b9:	020c      	movi.n	a2, 0
403803bb:	000306        	j	403803cb <spi_flash_chip_gd_probe+0x37>
403803be:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
403803c1:	0605a1        	l32r	a10, 40341bd8 <rom_rx_gain_force+0x33b7ac>
403803c4:	000001        	l32r	a0, 403403c4 <rom_rx_gain_force+0x339f98>
403803c7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
403803ca:	f01d05        	call0	4037059c <rom_rx_gain_force+0x36a170>
403803cd:	000000        	ill

403803d0 <spi_flash_chip_generic_detect_size>:
} while(0)

static const char TAG[] = "chip_generic";

esp_err_t spi_flash_chip_generic_detect_size(esp_flash_t *chip, uint32_t *size)
{
403803d0:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
403803d3:	6288      	l32i.n	a8, a2, 24
    *size = 0;
403803d5:	0c0c      	movi.n	a12, 0
403803d7:	03c9      	s32i.n	a12, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
403803d9:	f4a080        	extui	a10, a8, 0, 16
403803dc:	190c      	movi.n	a9, 1
403803de:	0cbd      	mov.n	a11, a12
403803e0:	83b9a0        	moveqz	a11, a9, a10
403803e3:	d01fd1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
403803e6:	c0aad0        	sub	a10, a10, a13
403803e9:	939ca0        	movnez	a9, a12, a10
403803ec:	209b90        	or	a9, a11, a9
403803ef:	99dc      	bnez.n	a9, 4038040c <spi_flash_chip_generic_detect_size+0x3c>

    /* Get flash capacity from flash chip id depends on different vendors. According to majority of flash datasheets,
       Flash 256Mb to 512Mb directly from 0x19 to 0x20, instead of from 0x19 to 0x1a. So here we leave the common behavior.
       However, some other flash vendors also have their own rule, we will add them in chip specific files.
     */
    uint32_t mem_density = (id & 0xFF);
403803f1:	748080        	extui	a8, a8, 0, 8
    if (mem_density > SPI_FLASH_LINEAR_DENSITY_LAST_VALUE ) {
403803f4:	991c      	movi.n	a9, 25
403803f6:	02b987        	bgeu	a9, a8, 403803fc <spi_flash_chip_generic_detect_size+0x2c>
        mem_density -= SPI_FLASH_HEX_A_F_RANGE;
403803f9:	fac882        	addi	a8, a8, -6
    }

    *size = 1 << mem_density;
403803fc:	190c      	movi.n	a9, 1
403803fe:	401800        	ssl	a8
40380401:	a18900        	sll	a8, a9
40380404:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380406:	020c      	movi.n	a2, 0
40380408:	0000c6        	j	4038040f <spi_flash_chip_generic_detect_size+0x3f>
4038040b:	272100        	lsi	f0, a1, 156
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
4038040e:	f01dd1        	l32r	a13, 4037c484 <vTaskGenericNotifyGiveFromISR+0xe4> (890020c0 <_rtc_reserved_end+0x28f020c0>)
40380411:	000000        	ill

40380414 <spi_flash_chip_generic_reset>:
    // else has claimed it yet.
    return ESP_OK;
}

esp_err_t spi_flash_chip_generic_reset(esp_flash_t *chip)
{
40380414:	008136        	entry	a1, 64
    //this is written following the winbond spec..
    spi_flash_trans_t t;
    t = (spi_flash_trans_t) {
40380417:	cc1c      	movi.n	a12, 28
40380419:	0b0c      	movi.n	a11, 0
4038041b:	20a110        	or	a10, a1, a1
4038041e:	d01c81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380421:	0008e0        	callx8	a8
40380424:	66a082        	movi	a8, 102
40380427:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RST_EN,
    };
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4038042a:	02a8      	l32i.n	a10, a2, 0
4038042c:	0a88      	l32i.n	a8, a10, 0
4038042e:	1888      	l32i.n	a8, a8, 4
40380430:	20b110        	or	a11, a1, a1
40380433:	0008e0        	callx8	a8
    if (err != ESP_OK) {
40380436:	baec      	bnez.n	a10, 40380465 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    t = (spi_flash_trans_t) {
40380438:	cc1c      	movi.n	a12, 28
4038043a:	0b0c      	movi.n	a11, 0
4038043c:	01ad      	mov.n	a10, a1
4038043e:	d01481        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380441:	0008e0        	callx8	a8
40380444:	99a082        	movi	a8, 153
40380447:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RST_DEV,
    };
    err = chip->host->driver->common_command(chip->host, &t);
4038044a:	02a8      	l32i.n	a10, a2, 0
4038044c:	0a88      	l32i.n	a8, a10, 0
4038044e:	1888      	l32i.n	a8, a8, 4
40380450:	01bd      	mov.n	a11, a1
40380452:	0008e0        	callx8	a8
    if (err != ESP_OK) {
40380455:	cacc      	bnez.n	a10, 40380465 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380457:	1288      	l32i.n	a8, a2, 4
40380459:	152892        	l32i	a9, a8, 84
4038045c:	1888      	l32i.n	a8, a8, 4
4038045e:	08b8      	l32i.n	a11, a8, 0
40380460:	02ad      	mov.n	a10, a2
40380462:	0009e0        	callx8	a9
    return err;
}
40380465:	0a2d      	mov.n	a2, a10
40380467:	f01d      	retw.n
40380469:	000000        	ill

4038046c <spi_flash_chip_generic_config_host_io_mode>:
    }
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
}

esp_err_t spi_flash_chip_generic_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
4038046c:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    bool conf_required = false;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4038046f:	42e8      	l32i.n	a14, a2, 16
    bool addr_32bit = (flags & SPI_FLASH_CONFIG_IO_MODE_32B_ADDR);
40380471:	043030        	extui	a3, a3, 0, 1

    switch (read_mode & 0xFFFF) {
40380474:	f480e0        	extui	a8, a14, 0, 16
40380477:	6c3826        	beqi	a8, 3, 403804e7 <spi_flash_chip_generic_config_host_io_mode+0x7b>
4038047a:	1648f6        	bgeui	a8, 4, 40380494 <spi_flash_chip_generic_config_host_io_mode+0x28>
4038047d:	021866        	bnei	a8, 1, 40380483 <spi_flash_chip_generic_config_host_io_mode+0x17>
40380480:	002b06        	j	40380530 <spi_flash_chip_generic_config_host_io_mode+0xc4>
40380483:	022866        	bnei	a8, 2, 40380489 <spi_flash_chip_generic_config_host_io_mode+0x1d>
40380486:	0020c6        	j	4038050d <spi_flash_chip_generic_config_host_io_mode+0xa1>
40380489:	0c5816        	beqz	a8, 40380552 <spi_flash_chip_generic_config_host_io_mode+0xe6>
4038048c:	d10221        	l32r	a2, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
4038048f:	004c06        	j	403805c3 <spi_flash_chip_generic_config_host_io_mode+0x157>
40380492:	260000        	lsi	f0, a0, 152
40380495:	2a48      	l32i.n	a4, a10, 8
40380497:	025826        	beqi	a8, 5, 4038049d <spi_flash_chip_generic_config_host_io_mode+0x31>
4038049a:	004886        	j	403805c0 <spi_flash_chip_generic_config_host_io_mode+0x154>
    case SPI_FLASH_QIO:
        //for QIO mode, the 4 bit right after the address are used for continuous mode, should be set to 0 to avoid that.
        addr_bitlen = SPI_FLASH_QIO_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qio_dummy_bitlen : rom_flash_chip_dummy->qio_dummy_bitlen);
4038049d:	7288      	l32i.n	a8, a2, 28
4038049f:	0a6817        	bbci	a8, 1, 403804ad <spi_flash_chip_generic_config_host_io_mode+0x41>
403804a2:	d30c81        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93774 <rom_flash_chip_dummy_hpm>)
403804a5:	0888      	l32i.n	a8, a8, 0
403804a7:	0108d2        	l8ui	a13, a8, 1
403804aa:	0001c6        	j	403804b5 <spi_flash_chip_generic_config_host_io_mode+0x49>
403804ad:	d30a81        	l32r	a8, 403750d8 <_iram_text_start+0xcd4> (3fc93778 <rom_flash_chip_dummy>)
403804b0:	0888      	l32i.n	a8, a8, 0
403804b2:	0108d2        	l8ui	a13, a8, 1
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
403804b5:	0bc356        	bnez	a3, 40380575 <spi_flash_chip_generic_config_host_io_mode+0x109>
        conf_required = true;
403804b8:	130c      	movi.n	a3, 1
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
403804ba:	eba0b2        	movi	a11, 235
403804bd:	8c1c      	movi.n	a12, 24
403804bf:	003946        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_QOUT:
        addr_bitlen = SPI_FLASH_QOUT_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qout_dummy_bitlen : rom_flash_chip_dummy->qout_dummy_bitlen);
403804c2:	7288      	l32i.n	a8, a2, 28
403804c4:	0c6817        	bbci	a8, 1, 403804d4 <spi_flash_chip_generic_config_host_io_mode+0x68>
403804c7:	d30381        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93774 <rom_flash_chip_dummy_hpm>)
403804ca:	0888      	l32i.n	a8, a8, 0
403804cc:	0208d2        	l8ui	a13, a8, 2
403804cf:	000246        	j	403804dc <spi_flash_chip_generic_config_host_io_mode+0x70>
403804d2:	810000        	src	a0, a0, a0
403804d5:	88d301        	l32r	a0, 40362824 <rom_rx_gain_force+0x35c3f8>
403804d8:	d208      	l32i.n	a0, a2, 52
403804da:	0208      	l32i.n	a0, a2, 0
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
403804dc:	09d356        	bnez	a3, 4038057d <spi_flash_chip_generic_config_host_io_mode+0x111>
403804df:	6ba0b2        	movi	a11, 107
403804e2:	8c1c      	movi.n	a12, 24
403804e4:	003006        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_DIO:
        //for DIO mode, the 4 bit right after the address are used for continuous mode, should be set to 0 to avoid that.
        addr_bitlen = SPI_FLASH_DIO_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dio_dummy_bitlen : rom_flash_chip_dummy->dio_dummy_bitlen);
403804e7:	7288      	l32i.n	a8, a2, 28
403804e9:	0b6817        	bbci	a8, 1, 403804f8 <spi_flash_chip_generic_config_host_io_mode+0x8c>
403804ec:	d2fa81        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93774 <rom_flash_chip_dummy_hpm>)
403804ef:	0888      	l32i.n	a8, a8, 0
403804f1:	0008d2        	l8ui	a13, a8, 0
403804f4:	000206        	j	40380500 <spi_flash_chip_generic_config_host_io_mode+0x94>
403804f7:	f88100        	lsi	f0, a1, 0x3e0
403804fa:	0888d2        	lsi	f13, a8, 32
403804fd:	0008d2        	l8ui	a13, a8, 0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
40380500:	084356        	bnez	a3, 40380588 <spi_flash_chip_generic_config_host_io_mode+0x11c>
        conf_required = true;
40380503:	130c      	movi.n	a3, 1
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
40380505:	bba0b2        	movi	a11, 187
40380508:	8c1c      	movi.n	a12, 24
4038050a:	002686        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_DOUT:
        addr_bitlen = SPI_FLASH_DOUT_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dout_dummy_bitlen : rom_flash_chip_dummy->dout_dummy_bitlen);
4038050d:	7288      	l32i.n	a8, a2, 28
4038050f:	0a6817        	bbci	a8, 1, 4038051d <spi_flash_chip_generic_config_host_io_mode+0xb1>
40380512:	d2f081        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93774 <rom_flash_chip_dummy_hpm>)
40380515:	0888      	l32i.n	a8, a8, 0
40380517:	0308d2        	l8ui	a13, a8, 3
4038051a:	0001c6        	j	40380525 <spi_flash_chip_generic_config_host_io_mode+0xb9>
4038051d:	d2ee81        	l32r	a8, 403750d8 <_iram_text_start+0xcd4> (3fc93778 <rom_flash_chip_dummy>)
40380520:	0888      	l32i.n	a8, a8, 0
40380522:	0308d2        	l8ui	a13, a8, 3
        read_command = (addr_32bit? CMD_FASTRD_DUAL_4B: CMD_FASTRD_DUAL);
40380525:	067356        	bnez	a3, 40380590 <spi_flash_chip_generic_config_host_io_mode+0x124>
40380528:	bb3c      	movi.n	a11, 59
4038052a:	8c1c      	movi.n	a12, 24
4038052c:	001e06        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
4038052f:	728800        	lsi	f0, a8, 0x1c8
        break;
    case SPI_FLASH_FASTRD:
        addr_bitlen = SPI_FLASH_FASTRD_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->fastrd_dummy_bitlen : rom_flash_chip_dummy->fastrd_dummy_bitlen);
40380532:	0a6817        	bbci	a8, 1, 40380540 <spi_flash_chip_generic_config_host_io_mode+0xd4>
40380535:	d2e781        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93774 <rom_flash_chip_dummy_hpm>)
40380538:	0888      	l32i.n	a8, a8, 0
4038053a:	0408d2        	l8ui	a13, a8, 4
4038053d:	0001c6        	j	40380548 <spi_flash_chip_generic_config_host_io_mode+0xdc>
40380540:	d2e681        	l32r	a8, 403750d8 <_iram_text_start+0xcd4> (3fc93778 <rom_flash_chip_dummy>)
40380543:	0888      	l32i.n	a8, a8, 0
40380545:	0408d2        	l8ui	a13, a8, 4
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
40380548:	04d356        	bnez	a3, 40380599 <spi_flash_chip_generic_config_host_io_mode+0x12d>
4038054b:	bb0c      	movi.n	a11, 11
4038054d:	8c1c      	movi.n	a12, 24
4038054f:	001546        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_SLOWRD:
        addr_bitlen = SPI_FLASH_SLOWRD_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->slowrd_dummy_bitlen : rom_flash_chip_dummy->slowrd_dummy_bitlen);
40380552:	7288      	l32i.n	a8, a2, 28
40380554:	0c6817        	bbci	a8, 1, 40380564 <spi_flash_chip_generic_config_host_io_mode+0xf8>
40380557:	d2df81        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93774 <rom_flash_chip_dummy_hpm>)
4038055a:	0888      	l32i.n	a8, a8, 0
4038055c:	0508d2        	l8ui	a13, a8, 5
4038055f:	000246        	j	4038056c <spi_flash_chip_generic_config_host_io_mode+0x100>
40380562:	810000        	src	a0, a0, a0
40380565:	d2dd      	lsi	f13, a2, 8
40380567:	0888      	l32i.n	a8, a8, 0
40380569:	0508d2        	l8ui	a13, a8, 5
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
4038056c:	23fc      	bnez.n	a3, 403805a2 <spi_flash_chip_generic_config_host_io_mode+0x136>
4038056e:	3b0c      	movi.n	a11, 3
40380570:	8c1c      	movi.n	a12, 24
40380572:	000c86        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
40380575:	eca0b2        	movi	a11, 236
    default:
        return ESP_ERR_FLASH_NOT_INITIALISED;
    }
    //For W25Q256 chip, the only difference between 4-Byte address command and 3-Byte version is the command value and the address bit length.
    if (addr_32bit) {
        addr_bitlen += 8;
40380578:	0c2c      	movi.n	a12, 32
4038057a:	000a86        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
4038057d:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
4038057f:	6ca0b2        	movi	a11, 108
        addr_bitlen += 8;
40380582:	0c2c      	movi.n	a12, 32
40380584:	000806        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
40380587:	a0b200        	addx4	a11, a2, a0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
4038058a:	2cbc      	beqz.n	a12, 403805c0 <spi_flash_chip_generic_config_host_io_mode+0x154>
        addr_bitlen += 8;
4038058c:	c60c      	movi.n	a6, 12
4038058e:	0c0005        	call0	4038c590 <_coredump_iram_end+0xa590>
    bool conf_required = false;
40380591:	cb3c03        	lsi	f0, a12, 0x32c
        addr_bitlen += 8;
40380594:	0c2c      	movi.n	a12, 32
40380596:	000386        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
40380599:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
4038059b:	cb0c      	movi.n	a11, 12
        addr_bitlen += 8;
4038059d:	0c2c      	movi.n	a12, 32
4038059f:	000146        	j	403805a8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
403805a2:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
403805a4:	3b1c      	movi.n	a11, 19
        addr_bitlen += 8;
403805a6:	0c2c      	movi.n	a12, 32
    }

    if (conf_required) {
403805a8:	438c      	beqz.n	a3, 403805b0 <spi_flash_chip_generic_config_host_io_mode+0x144>
        read_mode |= SPI_FLASH_CONFIG_CONF_BITS;
403805aa:	cfdc81        	l32r	a8, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403805ad:	20ee80        	or	a14, a14, a8
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
403805b0:	02a8      	l32i.n	a10, a2, 0
403805b2:	0a88      	l32i.n	a8, a10, 0
403805b4:	f888      	l32i.n	a8, a8, 60
403805b6:	0008e0        	callx8	a8
403805b9:	0a2d      	mov.n	a2, a10
403805bb:	000106        	j	403805c3 <spi_flash_chip_generic_config_host_io_mode+0x157>
403805be:	210000        	srai	a0, a0, 0
    switch (read_mode & 0xFFFF) {
403805c1:	1dd0b5        	call12	4039e2cc <_coredump_iram_end+0x1c2cc>
}
403805c4:	0000f0        	callx12	a0
	...

403805c8 <spi_flash_chip_generic_write_encrypted>:
}
#endif // CONFIG_SPI_FLASH_ROM_IMPL

#if !CONFIG_SPI_FLASH_ROM_IMPL || ESP_ROM_HAS_ENCRYPTED_WRITES_USING_LEGACY_DRV
esp_err_t spi_flash_chip_generic_write_encrypted(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
403805c8:	004136        	entry	a1, 32
403805cb:	027d      	mov.n	a7, a2
    spi_flash_encryption_t *esp_flash_encryption = &esp_flash_encryption_default;
    esp_err_t err = ESP_OK;
    // Encryption must happen on main flash.
    if (chip != esp_flash_default_chip) {
403805cd:	d0b281        	l32r	a8, 40374898 <_iram_text_start+0x494> (3fc95108 <esp_flash_default_chip>)
403805d0:	0888      	l32i.n	a8, a8, 0
403805d2:	021827        	beq	a8, a2, 403805d8 <spi_flash_chip_generic_write_encrypted+0x10>
403805d5:	002bc6        	j	40380688 <spi_flash_chip_generic_write_encrypted+0xc0>
        return ESP_ERR_NOT_SUPPORTED;
    }

    /* Check if the buffer and length can qualify the requirements */
    if (esp_flash_encryption->flash_encryption_check(address, length) != true) {
403805d8:	d2c181        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9375c <esp_flash_encryption_default>)
403805db:	5888      	l32i.n	a8, a8, 20
403805dd:	05bd      	mov.n	a11, a5
403805df:	20a440        	or	a10, a4, a4
403805e2:	0008e0        	callx8	a8
403805e5:	0a8a16        	beqz	a10, 40380691 <spi_flash_chip_generic_write_encrypted+0xc9>
        return ESP_ERR_NOT_SUPPORTED;
    }

    const uint8_t *data_bytes = (const uint8_t *)buffer;
    esp_flash_encryption->flash_encryption_enable();
403805e8:	d2bd81        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9375c <esp_flash_encryption_default>)
403805eb:	0888      	l32i.n	a8, a8, 0
403805ed:	0008e0        	callx8	a8
    esp_err_t err = ESP_OK;
403805f0:	020c      	movi.n	a2, 0

#if SOC_FLASH_ENCRYPTION_XTS_AES_SUPPORT_PSEUDO_ROUND
    spi_flash_encryption_hal_enable_pseudo_rounds(ESP_XTS_AES_PSEUDO_ROUNDS_LOW, XTS_AES_PSEUDO_ROUNDS_BASE, XTS_AES_PSEUDO_ROUNDS_INC, XTS_AES_PSEUDO_ROUNDS_RNG_CNT);
#endif /* SOC_FLASH_ENCRYPTION_XTS_AES_SUPPORT_PSEUDO_ROUND */

    while (length > 0) {
403805f2:	002086        	j	40380678 <spi_flash_chip_generic_write_encrypted+0xb0>
        int block_size;
        /* Write the largest block if possible */
        if (address % 64 == 0 && length >= 64) {
403805f5:	548040        	extui	a8, a4, 0, 6
403805f8:	48cc      	bnez.n	a8, 40380600 <spi_flash_chip_generic_write_encrypted+0x38>
403805fa:	3fa082        	movi	a8, 63
403805fd:	0f3857        	bltu	a8, a5, 40380610 <spi_flash_chip_generic_write_encrypted+0x48>
            block_size = 64;
        } else if (address % 32 == 0 && length >= 32) {
40380600:	448040        	extui	a8, a4, 0, 5
40380603:	e8cc      	bnez.n	a8, 40380615 <spi_flash_chip_generic_write_encrypted+0x4d>
40380605:	f81c      	movi.n	a8, 31
40380607:	0f3857        	bltu	a8, a5, 4038061a <spi_flash_chip_generic_write_encrypted+0x52>
            block_size = 32;
        } else {
            block_size = 16;
4038060a:	061c      	movi.n	a6, 16
4038060c:	000306        	j	4038061c <spi_flash_chip_generic_write_encrypted+0x54>
4038060f:	064c00        	lsi	f0, a12, 24
            block_size = 64;
40380612:	000186        	j	4038061c <spi_flash_chip_generic_write_encrypted+0x54>
            block_size = 16;
40380615:	061c      	movi.n	a6, 16
40380617:	000046        	j	4038061c <spi_flash_chip_generic_write_encrypted+0x54>
            block_size = 32;
4038061a:	062c      	movi.n	a6, 32
        }
        // Prepare the flash chip (same time as AES operation, for performance)
        esp_flash_encryption->flash_encryption_data_prepare(address, (uint32_t *)data_bytes, block_size);
4038061c:	d2b081        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9375c <esp_flash_encryption_default>)
4038061f:	2888      	l32i.n	a8, a8, 8
40380621:	06cd      	mov.n	a12, a6
40380623:	03bd      	mov.n	a11, a3
40380625:	04ad      	mov.n	a10, a4
40380627:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
4038062a:	1788      	l32i.n	a8, a7, 4
4038062c:	b888      	l32i.n	a8, a8, 44
4038062e:	0b0c      	movi.n	a11, 0
40380630:	07ad      	mov.n	a10, a7
40380632:	0008e0        	callx8	a8
40380635:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380637:	059a56        	bnez	a10, 40380694 <spi_flash_chip_generic_write_encrypted+0xcc>
            return err;
        }
        // Waiting for encrypting buffer to finish and making result visible for SPI1
        esp_flash_encryption->flash_encryption_done();
4038063a:	d2a881        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9375c <esp_flash_encryption_default>)
4038063d:	3888      	l32i.n	a8, a8, 12
4038063f:	0008e0        	callx8	a8

        // Note: For encryption function, after write flash command is sent. The hardware will write the encrypted buffer
        // prepared in XTS_FLASH_ENCRYPTION register in function `flash_encryption_data_prepare`, instead of the origin
        // buffer named `data_bytes`.

        err = chip->chip_drv->write(chip, (uint32_t *)data_bytes, address, length);
40380642:	1788      	l32i.n	a8, a7, 4
40380644:	112882        	l32i	a8, a8, 68
40380647:	05dd      	mov.n	a13, a5
40380649:	04cd      	mov.n	a12, a4
4038064b:	03bd      	mov.n	a11, a3
4038064d:	07ad      	mov.n	a10, a7
4038064f:	0008e0        	callx8	a8
40380652:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380654:	cafc      	bnez.n	a10, 40380694 <spi_flash_chip_generic_write_encrypted+0xcc>
            return err;
        }
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40380656:	1788      	l32i.n	a8, a7, 4
40380658:	152892        	l32i	a9, a8, 84
4038065b:	1888      	l32i.n	a8, a8, 4
4038065d:	48b8      	l32i.n	a11, a8, 16
4038065f:	07ad      	mov.n	a10, a7
40380661:	0009e0        	callx8	a9
40380664:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380666:	aaec      	bnez.n	a10, 40380694 <spi_flash_chip_generic_write_encrypted+0xcc>

        // Note: we don't wait for idle status here, because this way
        // the AES peripheral can start encrypting the next
        // block while the SPI flash chip is busy completing the write

        esp_flash_encryption->flash_encryption_destroy();
40380668:	d29d81        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9375c <esp_flash_encryption_default>)
4038066b:	4888      	l32i.n	a8, a8, 16
4038066d:	0008e0        	callx8	a8

        length -= block_size;
40380670:	c05560        	sub	a5, a5, a6
        data_bytes += block_size;
40380673:	336a      	add.n	a3, a3, a6
        address += block_size;
40380675:	804460        	add	a4, a4, a6
    while (length > 0) {
40380678:	f79556        	bnez	a5, 403805f5 <spi_flash_chip_generic_write_encrypted+0x2d>
    }

    esp_flash_encryption->flash_encryption_disable();
4038067b:	d29881        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9375c <esp_flash_encryption_default>)
4038067e:	012882        	l32i	a8, a8, 4
40380681:	0008e0        	callx8	a8
    return err;
40380684:	000306        	j	40380694 <spi_flash_chip_generic_write_encrypted+0xcc>
40380687:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
4038068a:	014606        	j	40380ba6 <spi_flash_chip_generic_erase_chip+0x86>
4038068d:	000000        	ill
40380690:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
40380693:	f01d06        	j	4037c70b <xTaskCreateStaticPinnedToCore+0xb7>
	...

40380698 <spi_flash_chip_generic_get_caps>:
    // For flash doesn't support read unique id.
    return ESP_ERR_NOT_SUPPORTED;
}

spi_flash_caps_t spi_flash_chip_generic_get_caps(esp_flash_t *chip)
{
40380698:	008136        	entry	a1, 64
    spi_flash_caps_t caps_flags = 0;
    // 32M-bits address support

    // flash suspend support
    // XMC-D support suspend
    if (chip->chip_id >> 16 == 0x46) {
4038069b:	0d1282        	l16ui	a8, a2, 26
4038069e:	694c      	movi.n	a9, 70
403806a0:	041897        	beq	a8, a9, 403806a8 <spi_flash_chip_generic_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
403806a3:	070c      	movi.n	a7, 0
403806a5:	000046        	j	403806aa <spi_flash_chip_generic_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
403806a8:	170c      	movi.n	a7, 1
    }

    // XMC-D support suspend (some D series flash chip begin with 0x20, difference checked by SFDP)
    if (chip->chip_id >> 16 == 0x20) {
403806aa:	42c866        	bnei	a8, 32, 403806f0 <spi_flash_chip_generic_get_caps+0x58>
        uint8_t data = 0;
403806ad:	080c      	movi.n	a8, 0
403806af:	1c4182        	s8i	a8, a1, 28
        spi_flash_trans_t t = {
403806b2:	cc1c      	movi.n	a12, 28
403806b4:	0b0c      	movi.n	a11, 0
403806b6:	01ad      	mov.n	a10, a1
403806b8:	cf7681        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403806bb:	0008e0        	callx8	a8
403806be:	180c      	movi.n	a8, 1
403806c0:	024182        	s8i	a8, a1, 2
403806c3:	881c      	movi.n	a8, 24
403806c5:	034182        	s8i	a8, a1, 3
403806c8:	283c      	movi.n	a8, 50
403806ca:	1189      	s32i.n	a8, a1, 4
403806cc:	1cc182        	addi	a8, a1, 28
403806cf:	3189      	s32i.n	a8, a1, 12
403806d1:	a85c      	movi.n	a8, 90
403806d3:	0a5182        	s16i	a8, a1, 20
403806d6:	860c      	movi.n	a6, 8
403806d8:	164162        	s8i	a6, a1, 22
            .mosi_data = 0,
            .miso_len = 1,
            .miso_data = &data,
            .dummy_bitlen = 8,
        };
        chip->host->driver->common_command(chip->host, &t);
403806db:	02a8      	l32i.n	a10, a2, 0
403806dd:	0a88      	l32i.n	a8, a10, 0
403806df:	012882        	l32i	a8, a8, 4
403806e2:	20b110        	or	a11, a1, a1
403806e5:	0008e0        	callx8	a8
        if((data & 0x8) == 0x8) {
403806e8:	1c0182        	l8ui	a8, a1, 28
403806eb:	010867        	bnone	a8, a6, 403806f0 <spi_flash_chip_generic_get_caps+0x58>
            caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
403806ee:	170c      	movi.n	a7, 1
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
    }
#endif

    // FM support suspend
    if (chip->chip_id >> 16 == 0xa1) {
403806f0:	0d1292        	l16ui	a9, a2, 26
403806f3:	a1a082        	movi	a8, 161
403806f6:	049987        	bne	a9, a8, 403806fe <spi_flash_chip_generic_get_caps+0x66>
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
403806f9:	180c      	movi.n	a8, 1
403806fb:	207780        	or	a7, a7, a8
    }
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
403806fe:	420c      	movi.n	a2, 4
40380700:	202720        	or	a2, a7, a2
40380703:	f01d      	retw.n
40380705:	000000        	ill

40380708 <spi_flash_common_read_qe_sr>:
/*******************************************************************************
 * Utility functions
 ******************************************************************************/

static esp_err_t spi_flash_common_read_qe_sr(esp_flash_t *chip, uint8_t qe_rdsr_command, uint8_t qe_sr_bitwidth, uint32_t *sr)
{
40380708:	008136        	entry	a1, 64
    uint32_t sr_buf = 0;
4038070b:	0b0c      	movi.n	a11, 0
4038070d:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
4038070f:	714b      	addi.n	a7, a1, 4
40380711:	1ca0c2        	movi	a12, 28
40380714:	07ad      	mov.n	a10, a7
40380716:	cf5e81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380719:	0008e0        	callx8	a8
4038071c:	414340        	srli	a4, a4, 3
4038071f:	064142        	s8i	a4, a1, 6
40380722:	4119      	s32i.n	a1, a1, 16
40380724:	0c5132        	s16i	a3, a1, 24
        .command = qe_rdsr_command,
        .miso_data = (uint8_t*) &sr_buf,
        .miso_len = qe_sr_bitwidth / 8,
    };
    esp_err_t ret = chip->host->driver->common_command(chip->host, &t);
40380727:	02a8      	l32i.n	a10, a2, 0
40380729:	0a88      	l32i.n	a8, a10, 0
4038072b:	1888      	l32i.n	a8, a8, 4
4038072d:	07bd      	mov.n	a11, a7
4038072f:	0008e0        	callx8	a8
    *sr = sr_buf;
40380732:	0188      	l32i.n	a8, a1, 0
40380734:	0589      	s32i.n	a8, a5, 0
    return ret;
}
40380736:	0a2d      	mov.n	a2, a10
40380738:	f01d      	retw.n
	...

4038073c <spi_flash_common_write_qe_sr>:

static esp_err_t spi_flash_common_write_qe_sr(esp_flash_t *chip, uint8_t qe_wrsr_command, uint8_t qe_sr_bitwidth, uint32_t qe)
{
4038073c:	00a136        	entry	a1, 80
4038073f:	8159      	s32i.n	a5, a1, 32
    spi_flash_trans_t t = {
40380741:	cc1c      	movi.n	a12, 28
40380743:	0b0c      	movi.n	a11, 0
40380745:	01ad      	mov.n	a10, a1
40380747:	cf5281        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4038074a:	0008e0        	callx8	a8
4038074d:	414340        	srli	a4, a4, 3
40380750:	014142        	s8i	a4, a1, 1
40380753:	20c182        	addi	a8, a1, 32
40380756:	2189      	s32i.n	a8, a1, 8
40380758:	0a5132        	s16i	a3, a1, 20
        .command = qe_wrsr_command,
        .mosi_data = ((uint8_t*) &qe),
        .mosi_len = qe_sr_bitwidth / 8,
        .miso_len = 0,
    };
    return chip->host->driver->common_command(chip->host, &t);
4038075b:	02a8      	l32i.n	a10, a2, 0
4038075d:	0a88      	l32i.n	a8, a10, 0
4038075f:	1888      	l32i.n	a8, a8, 4
40380761:	01bd      	mov.n	a11, a1
40380763:	0008e0        	callx8	a8
}
40380766:	0a2d      	mov.n	a2, a10
40380768:	f01d      	retw.n
	...

4038076c <spi_flash_common_read_status_16b_rdsr_rdsr2>:

esp_err_t spi_flash_common_read_status_16b_rdsr_rdsr2(esp_flash_t* chip, uint32_t* out_sr)
{
4038076c:	006136        	entry	a1, 48
4038076f:	207220        	or	a7, a2, a2
    uint32_t sr, sr2;
    esp_err_t ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, &sr2);
40380772:	04c1d2        	addi	a13, a1, 4
40380775:	8c0c      	movi.n	a12, 8
40380777:	35a0b2        	movi	a11, 53
4038077a:	02ad      	mov.n	a10, a2
4038077c:	fff8a5        	call8	40380708 <spi_flash_common_read_qe_sr>
4038077f:	0a2d      	mov.n	a2, a10
    if (ret == ESP_OK) {
40380781:	dadc      	bnez.n	a10, 403807a2 <spi_flash_common_read_status_16b_rdsr_rdsr2+0x36>
        ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, &sr);
40380783:	01dd      	mov.n	a13, a1
40380785:	8c0c      	movi.n	a12, 8
40380787:	5b0c      	movi.n	a11, 5
40380789:	07ad      	mov.n	a10, a7
4038078b:	fff7e5        	call8	40380708 <spi_flash_common_read_qe_sr>
4038078e:	0a2d      	mov.n	a2, a10
    }
    if (ret == ESP_OK) {
40380790:	eacc      	bnez.n	a10, 403807a2 <spi_flash_common_read_status_16b_rdsr_rdsr2+0x36>
        *out_sr = (sr & 0xff) | ((sr2 & 0xff) << 8);
40380792:	000192        	l8ui	a9, a1, 0
40380795:	1188      	l32i.n	a8, a1, 4
40380797:	118880        	slli	a8, a8, 8
4038079a:	f48080        	extui	a8, a8, 0, 16
4038079d:	208980        	or	a8, a9, a8
403807a0:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
403807a2:	f01d      	retw.n

403807a4 <spi_flash_common_write_status_16b_wrsr>:
{
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, out_sr);
}

esp_err_t spi_flash_common_write_status_16b_wrsr(esp_flash_t* chip, uint32_t sr)
{
403807a4:	004136        	entry	a1, 32
403807a7:	20a220        	or	a10, a2, a2
403807aa:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 16, sr);
403807ad:	10a0c2        	movi	a12, 16
403807b0:	1b0c      	movi.n	a11, 1
403807b2:	fff8a5        	call8	4038073c <spi_flash_common_write_qe_sr>
}
403807b5:	0a2d      	mov.n	a2, a10
403807b7:	f01d      	retw.n
403807b9:	000000        	ill

403807bc <spi_flash_chip_generic_read>:
{
403807bc:	010136        	entry	a1, 128
    const uint32_t page_size = chip->chip_drv->page_size;
403807bf:	012282        	l32i	a8, a2, 4
403807c2:	132892        	l32i	a9, a8, 76
403807c5:	176192        	s32i	a9, a1, 92
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
403807c8:	1e2882        	l32i	a8, a8, 120
403807cb:	00a0b2        	movi	a11, 0
403807ce:	02ad      	mov.n	a10, a2
403807d0:	0008e0        	callx8	a8
403807d3:	1561a2        	s32i	a10, a1, 84
    if (err == ESP_ERR_NOT_SUPPORTED) {
403807d6:	06a182        	movi	a8, 0x106
403807d9:	021a87        	beq	a10, a8, 403807df <spi_flash_chip_generic_read+0x23>
403807dc:	001e06        	j	40380858 <spi_flash_chip_generic_read+0x9c>
        ESP_LOGE(TAG, "configure host io mode failed - unsupported");
403807df:	ff4525        	call8	4037fc30 <esp_log_timestamp>
403807e2:	d23fb1        	l32r	a11, 403750e0 <_iram_text_start+0xcdc> (3fc9460c <TAG>)
403807e5:	0bed      	mov.n	a14, a11
403807e7:	0add      	mov.n	a13, a10
403807e9:	d23ec1        	l32r	a12, 403750e4 <_iram_text_start+0xce0> (3fc93ca0 <__FUNCTION__$0+0x3e8>)
403807ec:	1a0c      	movi.n	a10, 1
403807ee:	ff48a5        	call8	4037fc78 <esp_log_write>
        return err;
403807f1:	001c06        	j	40380865 <spi_flash_chip_generic_read+0xa9>
403807f4:	614b00        	lsi	f0, a11, 0x184
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
403807f7:	0c4c      	movi.n	a12, 64
403807f9:	ffa0b2        	movi	a11, 255
403807fc:	06ad      	mov.n	a10, a6
403807fe:	cf2481        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380801:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
40380804:	02a8      	l32i.n	a10, a2, 0
40380806:	0a88      	l32i.n	a8, a10, 0
40380808:	d888      	l32i.n	a8, a8, 52
4038080a:	1721e2        	l32i	a14, a1, 92
4038080d:	01dd      	mov.n	a13, a1
4038080f:	05cd      	mov.n	a12, a5
40380811:	04bd      	mov.n	a11, a4
40380813:	0008e0        	callx8	a8
40380816:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
40380818:	01c8      	l32i.n	a12, a1, 0
4038081a:	c084c0        	sub	a8, a4, a12
4038081d:	166182        	s32i	a8, a1, 88
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
40380820:	754a      	add.n	a7, a5, a4
40380822:	8caa      	add.n	a8, a12, a10
40380824:	637780        	minu	a7, a7, a8
40380827:	c08740        	sub	a8, a7, a4
4038082a:	146182        	s32i	a8, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4038082d:	02a8      	l32i.n	a10, a2, 0
4038082f:	0a88      	l32i.n	a8, a10, 0
40380831:	b888      	l32i.n	a8, a8, 44
40380833:	20b660        	or	a11, a6, a6
40380836:	0008e0        	callx8	a8
40380839:	1561a2        	s32i	a10, a1, 84
        memcpy(buffer, temp_buffer + left_off, data_len);
4038083c:	1421c2        	l32i	a12, a1, 80
4038083f:	162192        	l32i	a9, a1, 88
40380842:	b69a      	add.n	a11, a6, a9
40380844:	03ad      	mov.n	a10, a3
40380846:	cf2381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40380849:	0008e0        	callx8	a8
        buffer = (void *)((intptr_t)buffer + data_len);
4038084c:	142182        	l32i	a8, a1, 80
4038084f:	338a      	add.n	a3, a3, a8
        length = length - data_len;
40380851:	c04470        	sub	a4, a4, a7
40380854:	554a      	add.n	a5, a5, a4
        address += data_len;
40380856:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
40380858:	180c      	movi.n	a8, 1
4038085a:	838550        	moveqz	a8, a5, a5
4038085d:	152192        	l32i	a9, a1, 84
40380860:	19cc      	bnez.n	a9, 40380865 <spi_flash_chip_generic_read+0xa9>
40380862:	f8f856        	bnez	a8, 403807f5 <spi_flash_chip_generic_read+0x39>
}
40380865:	152122        	l32i	a2, a1, 84
40380868:	f01d      	retw.n
	...

4038086c <spi_flash_chip_generic_write>:
{
4038086c:	010136        	entry	a1, 128
4038086f:	026d      	mov.n	a6, a2
40380871:	146132        	s32i	a3, a1, 80
    const uint32_t page_size = chip->chip_drv->page_size;
40380874:	1288      	l32i.n	a8, a2, 4
40380876:	132882        	l32i	a8, a8, 76
40380879:	156182        	s32i	a8, a1, 84
    esp_err_t err = ESP_OK;
4038087c:	0a0c      	movi.n	a10, 0
    while (err == ESP_OK && length > 0) {
4038087e:	001f06        	j	403808fe <spi_flash_chip_generic_write+0x92>
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
40380881:	214b      	addi.n	a2, a1, 4
40380883:	0c4c      	movi.n	a12, 64
40380885:	ffa0b2        	movi	a11, 255
40380888:	02ad      	mov.n	a10, a2
4038088a:	cf0181        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4038088d:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
40380890:	06a8      	l32i.n	a10, a6, 0
40380892:	0a88      	l32i.n	a8, a10, 0
40380894:	a888      	l32i.n	a8, a8, 40
40380896:	1521e2        	l32i	a14, a1, 84
40380899:	01dd      	mov.n	a13, a1
4038089b:	05cd      	mov.n	a12, a5
4038089d:	04bd      	mov.n	a11, a4
4038089f:	0008e0        	callx8	a8
403808a2:	0a9d      	mov.n	a9, a10
403808a4:	1661a2        	s32i	a10, a1, 88
        uint32_t left_off = address - align_address;
403808a7:	0188      	l32i.n	a8, a1, 0
403808a9:	c0a480        	sub	a10, a4, a8
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
403808ac:	745a      	add.n	a7, a4, a5
403808ae:	889a      	add.n	a8, a8, a9
403808b0:	637780        	minu	a7, a7, a8
403808b3:	c08740        	sub	a8, a7, a4
403808b6:	176182        	s32i	a8, a1, 92
        memcpy(temp_buffer + left_off, buffer, write_len);
403808b9:	08cd      	mov.n	a12, a8
403808bb:	1421b2        	l32i	a11, a1, 80
403808be:	a2aa      	add.n	a10, a2, a10
403808c0:	cf0581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403808c3:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
403808c6:	1688      	l32i.n	a8, a6, 4
403808c8:	b888      	l32i.n	a8, a8, 44
403808ca:	0b0c      	movi.n	a11, 0
403808cc:	06ad      	mov.n	a10, a6
403808ce:	0008e0        	callx8	a8
        if (err == ESP_OK && length > 0) {
403808d1:	40fa80        	nsau	a8, a10
403808d4:	418580        	srli	a8, a8, 5
403808d7:	230837        	bnone	a8, a3, 403808fe <spi_flash_chip_generic_write+0x92>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
403808da:	1688      	l32i.n	a8, a6, 4
403808dc:	122882        	l32i	a8, a8, 72
403808df:	1621d2        	l32i	a13, a1, 88
403808e2:	01c8      	l32i.n	a12, a1, 0
403808e4:	20b220        	or	a11, a2, a2
403808e7:	06ad      	mov.n	a10, a6
403808e9:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + write_len);
403808ec:	142182        	l32i	a8, a1, 80
403808ef:	172192        	l32i	a9, a1, 92
403808f2:	889a      	add.n	a8, a8, a9
403808f4:	146182        	s32i	a8, a1, 80
            length -= write_len;
403808f7:	c04470        	sub	a4, a4, a7
403808fa:	554a      	add.n	a5, a5, a4
            address += write_len;
403808fc:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
403808fe:	130c      	movi.n	a3, 1
40380900:	833550        	moveqz	a3, a5, a5
40380903:	1acc      	bnez.n	a10, 40380908 <spi_flash_chip_generic_write+0x9c>
40380905:	f78356        	bnez	a3, 40380881 <spi_flash_chip_generic_write+0x15>
}
40380908:	0a2d      	mov.n	a2, a10
4038090a:	f01d      	retw.n

4038090c <spi_flash_chip_generic_get_write_protect>:
{
4038090c:	006136        	entry	a1, 48
4038090f:	02ad      	mov.n	a10, a2
    assert(out_write_protect!=NULL);
40380911:	d3cc      	bnez.n	a3, 40380922 <spi_flash_chip_generic_get_write_protect+0x16>
40380913:	d1f5d1        	l32r	a13, 403750e8 <_iram_text_start+0xce4> (3fc93cdc <__FUNCTION__$0+0x424>)
40380916:	d1f5c1        	l32r	a12, 403750ec <_iram_text_start+0xce8> (3fc9455c <__func__$0>)
40380919:	4aa1b2        	movi	a11, 0x14a
4038091c:	d1f5a1        	l32r	a10, 403750f0 <_iram_text_start+0xcec> (3fc93d0f <__FUNCTION__$0+0x457>)
4038091f:	ff4825        	call8	4037fda0 <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
40380922:	1288      	l32i.n	a8, a2, 4
40380924:	192882        	l32i	a8, a8, 100
40380927:	01cd      	mov.n	a12, a1
40380929:	1b0c      	movi.n	a11, 1
4038092b:	0008e0        	callx8	a8
4038092e:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40380930:	eacc      	bnez.n	a10, 40380942 <spi_flash_chip_generic_get_write_protect+0x36>
    *out_write_protect = ((status & SR_WREN) == 0);
40380932:	280c      	movi.n	a8, 2
40380934:	0198      	l32i.n	a9, a1, 0
40380936:	108890        	and	a8, a8, a9
40380939:	40f880        	nsau	a8, a8
4038093c:	418580        	srli	a8, a8, 5
4038093f:	004382        	s8i	a8, a3, 0
}
40380942:	f01d      	retw.n

40380944 <spi_flash_chip_generic_yield>:
{
40380944:	006136        	entry	a1, 48
40380947:	027d      	mov.n	a7, a2
    uint32_t flags = wip? 1: 0; //check_yield() and yield() impls should not issue suspend/resume if this flag is zero
40380949:	1b0c      	movi.n	a11, 1
4038094b:	83b330        	moveqz	a11, a3, a3
    if (chip->os_func->check_yield) {
4038094e:	2288      	l32i.n	a8, a2, 8
40380950:	6888      	l32i.n	a8, a8, 24
40380952:	08bc      	beqz.n	a8, 40380986 <spi_flash_chip_generic_yield+0x42>
        err = chip->os_func->check_yield(chip->os_func_data, flags, &request);
40380954:	c14b      	addi.n	a12, a1, 4
40380956:	0322a2        	l32i	a10, a2, 12
40380959:	0008e0        	callx8	a8
4038095c:	0a2d      	mov.n	a2, a10
        if (err == ESP_OK) {
4038095e:	3adc      	bnez.n	a10, 40380975 <spi_flash_chip_generic_yield+0x31>
            if (err == ESP_OK && (request & SPI_FLASH_YIELD_REQ_YIELD) != 0) {
40380960:	1188      	l32i.n	a8, a1, 4
40380962:	226807        	bbci	a8, 0, 40380988 <spi_flash_chip_generic_yield+0x44>
                err = chip->os_func->yield(chip->os_func_data, &status);
40380965:	2788      	l32i.n	a8, a7, 8
40380967:	7888      	l32i.n	a8, a8, 28
40380969:	01bd      	mov.n	a11, a1
4038096b:	37a8      	l32i.n	a10, a7, 12
4038096d:	0008e0        	callx8	a8
40380970:	0a2d      	mov.n	a2, a10
40380972:	000486        	j	40380988 <spi_flash_chip_generic_yield+0x44>
        } else if (err == ESP_ERR_TIMEOUT) {
40380975:	07a182        	movi	a8, 0x107
40380978:	021a87        	beq	a10, a8, 4038097e <spi_flash_chip_generic_yield+0x3a>
            abort();
4038097b:	ff36a5        	call8	4037fce4 <abort>
            err = ESP_OK;
4038097e:	020c      	movi.n	a2, 0
40380980:	000106        	j	40380988 <spi_flash_chip_generic_yield+0x44>
40380983:	000000        	ill
    esp_err_t err = ESP_OK;
40380986:	020c      	movi.n	a2, 0
}
40380988:	f01d      	retw.n
	...

4038098c <spi_flash_chip_generic_suspend_cmd_conf>:
}

#endif // !CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_generic_suspend_cmd_conf(esp_flash_t *chip)
{
4038098c:	006136        	entry	a1, 48
    // chips which support auto-suspend
    if (chip->chip_id >> 16 != 0x20 && chip->chip_id >> 16 != 0xa1 && chip->chip_id >> 16 != 0x46) {
4038098f:	0d12a2        	l16ui	a10, a2, 26
40380992:	e0ca92        	addi	a9, a10, -32
40380995:	180c      	movi.n	a8, 1
40380997:	0b0c      	movi.n	a11, 0
40380999:	0bcd      	mov.n	a12, a11
4038099b:	93c890        	movnez	a12, a8, a9
4038099e:	5faf92        	movi	a9, -161
403809a1:	9a9a      	add.n	a9, a10, a9
403809a3:	838b90        	moveqz	a8, a11, a9
403809a6:	220c87        	bnone	a12, a8, 403809cc <spi_flash_chip_generic_suspend_cmd_conf+0x40>
403809a9:	684c      	movi.n	a8, 70
403809ab:	1d1a87        	beq	a10, a8, 403809cc <spi_flash_chip_generic_suspend_cmd_conf+0x40>
403809ae:	ceaf81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
403809b1:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "The flash you use doesn't support auto suspend, only \'XMC\' is supported");
403809b3:	f88c      	beqz.n	a8, 403809c6 <spi_flash_chip_generic_suspend_cmd_conf+0x3a>
403809b5:	ff27a5        	call8	4037fc30 <esp_log_timestamp>
403809b8:	d1cac1        	l32r	a12, 403750e0 <_iram_text_start+0xcdc> (3fc9460c <TAG>)
403809bb:	0abd      	mov.n	a11, a10
403809bd:	d1cda1        	l32r	a10, 403750f4 <_iram_text_start+0xcf0> (3fc93d28 <__FUNCTION__$0+0x470>)
403809c0:	cebd81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
403809c3:	0008e0        	callx8	a8
        return ESP_ERR_NOT_SUPPORTED;
403809c6:	06a122        	movi	a2, 0x106
403809c9:	000bc6        	j	403809fc <spi_flash_chip_generic_suspend_cmd_conf+0x70>
    }
    spi_flash_sus_cmd_conf sus_conf = {
403809cc:	8c0c      	movi.n	a12, 8
403809ce:	0b0c      	movi.n	a11, 0
403809d0:	01ad      	mov.n	a10, a1
403809d2:	ceaf81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403809d5:	0008e0        	callx8	a8
403809d8:	80a082        	movi	a8, 128
403809db:	0189      	s32i.n	a8, a1, 0
403809dd:	583c      	movi.n	a8, 53
403809df:	044182        	s8i	a8, a1, 4
403809e2:	75a082        	movi	a8, 117
403809e5:	054182        	s8i	a8, a1, 5
403809e8:	7aa082        	movi	a8, 122
403809eb:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
403809ee:	02a8      	l32i.n	a10, a2, 0
403809f0:	0a88      	l32i.n	a8, a10, 0
403809f2:	152882        	l32i	a8, a8, 84
403809f5:	01bd      	mov.n	a11, a1
403809f7:	0008e0        	callx8	a8
403809fa:	0a2d      	mov.n	a2, a10
}
403809fc:	f01d      	retw.n
	...

40380a00 <spi_flash_chip_generic_read_unique_id>:
{
40380a00:	00a136        	entry	a1, 80
    uint64_t unique_id_buf = 0;
40380a03:	080c      	movi.n	a8, 0
40380a05:	0189      	s32i.n	a8, a1, 0
40380a07:	1189      	s32i.n	a8, a1, 4
    spi_flash_trans_t transfer = {
40380a09:	718b      	addi.n	a7, a1, 8
40380a0b:	cc1c      	movi.n	a12, 28
40380a0d:	20b880        	or	a11, a8, a8
40380a10:	07ad      	mov.n	a10, a7
40380a12:	ce9f81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380a15:	0008e0        	callx8	a8
40380a18:	880c      	movi.n	a8, 8
40380a1a:	0a4182        	s8i	a8, a1, 10
40380a1d:	5119      	s32i.n	a1, a1, 20
40380a1f:	b84c      	movi.n	a8, 75
40380a21:	0e5182        	s16i	a8, a1, 28
40380a24:	082c      	movi.n	a8, 32
40380a26:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &transfer);
40380a29:	02a8      	l32i.n	a10, a2, 0
40380a2b:	0a88      	l32i.n	a8, a10, 0
40380a2d:	1888      	l32i.n	a8, a8, 4
40380a2f:	07bd      	mov.n	a11, a7
40380a31:	0008e0        	callx8	a8
40380a34:	0a2d      	mov.n	a2, a10
    if (unique_id_buf == 0 || unique_id_buf == UINT64_MAX) {
40380a36:	01a8      	l32i.n	a10, a1, 0
40380a38:	11b8      	l32i.n	a11, a1, 4
40380a3a:	fc7c      	movi.n	a12, -1
40380a3c:	8bca      	add.n	a8, a11, a12
40380a3e:	9aca      	add.n	a9, a10, a12
40380a40:	01b9c7        	bgeu	a9, a12, 40380a45 <spi_flash_chip_generic_read_unique_id+0x45>
40380a43:	0b8d      	mov.n	a8, a11
40380a45:	2b0866        	bnei	a8, -1, 40380a74 <spi_flash_chip_generic_read_unique_id+0x74>
40380a48:	d87c      	movi.n	a8, -3
40380a4a:	26b897        	bgeu	a8, a9, 40380a74 <spi_flash_chip_generic_read_unique_id+0x74>
40380a4d:	ce8781        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40380a50:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "No response from device when trying to retrieve Unique ID\n");
40380a52:	010816        	beqz	a8, 40380a66 <spi_flash_chip_generic_read_unique_id+0x66>
40380a55:	ff1da5        	call8	4037fc30 <esp_log_timestamp>
40380a58:	d1a2c1        	l32r	a12, 403750e0 <_iram_text_start+0xcdc> (3fc9460c <TAG>)
40380a5b:	0abd      	mov.n	a11, a10
40380a5d:	d1a6a1        	l32r	a10, 403750f8 <_iram_text_start+0xcf4> (3fc93d80 <__FUNCTION__$0+0x4c8>)
40380a60:	ce9581        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40380a63:	0008e0        	callx8	a8
        *flash_unique_id = unique_id_buf;
40380a66:	0188      	l32i.n	a8, a1, 0
40380a68:	1198      	l32i.n	a9, a1, 4
40380a6a:	0389      	s32i.n	a8, a3, 0
40380a6c:	1399      	s32i.n	a9, a3, 4
        return ESP_ERR_NOT_SUPPORTED;
40380a6e:	06a122        	movi	a2, 0x106
40380a71:	000246        	j	40380a7e <spi_flash_chip_generic_read_unique_id+0x7e>
    *flash_unique_id = __builtin_bswap64(unique_id_buf);
40380a74:	d1a281        	l32r	a8, 403750fc <_iram_text_start+0xcf8> (400021cc <__bswapdi2>)
40380a77:	0008e0        	callx8	a8
40380a7a:	03a9      	s32i.n	a10, a3, 0
40380a7c:	13b9      	s32i.n	a11, a3, 4
}
40380a7e:	f01d      	retw.n

40380a80 <spi_flash_common_read_status_8b_rdsr2>:
{
40380a80:	004136        	entry	a1, 32
40380a83:	20a220        	or	a10, a2, a2
40380a86:	20d330        	or	a13, a3, a3
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, out_sr);
40380a89:	08a0c2        	movi	a12, 8
40380a8c:	5b3c      	movi.n	a11, 53
40380a8e:	ffc7a5        	call8	40380708 <spi_flash_common_read_qe_sr>
}
40380a91:	0a2d      	mov.n	a2, a10
40380a93:	f01d      	retw.n
40380a95:	000000        	ill

40380a98 <spi_flash_chip_generic_get_io_mode>:
{
40380a98:	006136        	entry	a1, 48
40380a9b:	20a220        	or	a10, a2, a2
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
40380a9e:	20b110        	or	a11, a1, a1
40380aa1:	fffde5        	call8	40380a80 <spi_flash_common_read_status_8b_rdsr2>
40380aa4:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380aa7:	9acc      	bnez.n	a10, 40380ab4 <spi_flash_chip_generic_get_io_mode+0x1c>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380aa9:	0188      	l32i.n	a8, a1, 0
40380aab:	888a      	add.n	a8, a8, a8
40380aad:	490c      	movi.n	a9, 4
40380aaf:	108890        	and	a8, a8, a9
40380ab2:	0389      	s32i.n	a8, a3, 0
}
40380ab4:	f01d      	retw.n
	...

40380ab8 <spi_flash_common_read_status_8b_rdsr>:
{
40380ab8:	004136        	entry	a1, 32
40380abb:	20a220        	or	a10, a2, a2
40380abe:	20d330        	or	a13, a3, a3
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, out_sr);
40380ac1:	08a0c2        	movi	a12, 8
40380ac4:	5b0c      	movi.n	a11, 5
40380ac6:	ffc425        	call8	40380708 <spi_flash_common_read_qe_sr>
}
40380ac9:	0a2d      	mov.n	a2, a10
40380acb:	f01d      	retw.n
40380acd:	000000        	ill

40380ad0 <spi_flash_common_write_status_8b_wrsr>:
{
40380ad0:	004136        	entry	a1, 32
40380ad3:	20a220        	or	a10, a2, a2
40380ad6:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 8, sr);
40380ad9:	08a0c2        	movi	a12, 8
40380adc:	1b0c      	movi.n	a11, 1
40380ade:	ffc5e5        	call8	4038073c <spi_flash_common_write_qe_sr>
}
40380ae1:	0a2d      	mov.n	a2, a10
40380ae3:	f01d      	retw.n
40380ae5:	000000        	ill

40380ae8 <spi_flash_common_write_status_8b_wrsr2>:
{
40380ae8:	004136        	entry	a1, 32
40380aeb:	20a220        	or	a10, a2, a2
40380aee:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR2, 8, sr);
40380af1:	08a0c2        	movi	a12, 8
40380af4:	1b3c      	movi.n	a11, 49
40380af6:	ffc465        	call8	4038073c <spi_flash_common_write_qe_sr>
}
40380af9:	0a2d      	mov.n	a2, a10
40380afb:	f01d      	retw.n
40380afd:	000000        	ill

40380b00 <spi_flash_chip_generic_set_io_mode>:
{
40380b00:	004136        	entry	a1, 32
40380b03:	20a220        	or	a10, a2, a2
    return spi_flash_common_set_io_mode(chip,
40380b06:	00a2d2        	movi	a13, 0x200
40380b09:	d16ec1        	l32r	a12, 403750c4 <_iram_text_start+0xcc0> (4038076c <spi_flash_common_read_status_16b_rdsr_rdsr2>)
40380b0c:	d16fb1        	l32r	a11, 403750c8 <_iram_text_start+0xcc4> (403807a4 <spi_flash_common_write_status_16b_wrsr>)
40380b0f:	0032a5        	call8	40380e38 <spi_flash_common_set_io_mode>
}
40380b12:	202aa0        	or	a2, a10, a10
40380b15:	000090        	retw

40380b18 <spi_flash_chip_generic_probe>:
{
40380b18:	004136        	entry	a1, 32
}
40380b1b:	020c      	movi.n	a2, 0
40380b1d:	f01d      	retw.n
	...

40380b20 <spi_flash_chip_generic_erase_chip>:
{
40380b20:	004136        	entry	a1, 32
40380b23:	027d      	mov.n	a7, a2
    err = chip->chip_drv->set_chip_write_protect(chip, false);
40380b25:	1288      	l32i.n	a8, a2, 4
40380b27:	b888      	l32i.n	a8, a8, 44
40380b29:	0b0c      	movi.n	a11, 0
40380b2b:	02ad      	mov.n	a10, a2
40380b2d:	0008e0        	callx8	a8
40380b30:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380b32:	eacc      	bnez.n	a10, 40380b44 <spi_flash_chip_generic_erase_chip+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380b34:	1788      	l32i.n	a8, a7, 4
40380b36:	152892        	l32i	a9, a8, 84
40380b39:	1888      	l32i.n	a8, a8, 4
40380b3b:	08b8      	l32i.n	a11, a8, 0
40380b3d:	07ad      	mov.n	a10, a7
40380b3f:	0009e0        	callx8	a9
40380b42:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380b44:	40f290        	nsau	a9, a2
40380b47:	419590        	srli	a9, a9, 5
40380b4a:	faae82        	movi	a8, 0xfffffefa
40380b4d:	828a      	add.n	a8, a2, a8
40380b4f:	40f880        	nsau	a8, a8
40380b52:	418580        	srli	a8, a8, 5
40380b55:	209980        	or	a9, a9, a8
40380b58:	050916        	beqz	a9, 40380bac <spi_flash_chip_generic_erase_chip+0x8c>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380b5b:	2788      	l32i.n	a8, a7, 8
40380b5d:	9888      	l32i.n	a8, a8, 36
40380b5f:	388c      	beqz.n	a8, 40380b66 <spi_flash_chip_generic_erase_chip+0x46>
40380b61:	1a0c      	movi.n	a10, 1
40380b63:	0008e0        	callx8	a8
        chip->host->driver->erase_chip(chip->host);
40380b66:	07a8      	l32i.n	a10, a7, 0
40380b68:	002a82        	l32i	a8, a10, 0
40380b6b:	3888      	l32i.n	a8, a8, 12
40380b6d:	0008e0        	callx8	a8
        chip->busy = 1;
40380b70:	7788      	l32i.n	a8, a7, 28
40380b72:	190c      	movi.n	a9, 1
40380b74:	208890        	or	a8, a8, a9
40380b77:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
40380b79:	1788      	l32i.n	a8, a7, 4
40380b7b:	152892        	l32i	a9, a8, 84
40380b7e:	012882        	l32i	a8, a8, 4
40380b81:	0128b2        	l32i	a11, a8, 4
40380b84:	20a770        	or	a10, a7, a7
40380b87:	0009e0        	callx8	a9
40380b8a:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380b8c:	2788      	l32i.n	a8, a7, 8
40380b8e:	9888      	l32i.n	a8, a8, 36
40380b90:	005816        	beqz	a8, 40380b99 <spi_flash_chip_generic_erase_chip+0x79>
40380b93:	00a0a2        	movi	a10, 0
40380b96:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380b99:	06a182        	movi	a8, 0x106
40380b9c:	0c9287        	bne	a2, a8, 40380bac <spi_flash_chip_generic_erase_chip+0x8c>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380b9f:	1788      	l32i.n	a8, a7, 4
40380ba1:	b888      	l32i.n	a8, a8, 44
40380ba3:	1b0c      	movi.n	a11, 1
40380ba5:	07ad      	mov.n	a10, a7
40380ba7:	0008e0        	callx8	a8
40380baa:	0a2d      	mov.n	a2, a10
}
40380bac:	f01d      	retw.n
	...

40380bb0 <spi_flash_chip_generic_erase_sector>:
{
40380bb0:	004136        	entry	a1, 32
40380bb3:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40380bb5:	1288      	l32i.n	a8, a2, 4
40380bb7:	b888      	l32i.n	a8, a8, 44
40380bb9:	0b0c      	movi.n	a11, 0
40380bbb:	02ad      	mov.n	a10, a2
40380bbd:	0008e0        	callx8	a8
40380bc0:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380bc2:	eacc      	bnez.n	a10, 40380bd4 <spi_flash_chip_generic_erase_sector+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380bc4:	1788      	l32i.n	a8, a7, 4
40380bc6:	152892        	l32i	a9, a8, 84
40380bc9:	1888      	l32i.n	a8, a8, 4
40380bcb:	08b8      	l32i.n	a11, a8, 0
40380bcd:	07ad      	mov.n	a10, a7
40380bcf:	0009e0        	callx8	a9
40380bd2:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380bd4:	40f290        	nsau	a9, a2
40380bd7:	419590        	srli	a9, a9, 5
40380bda:	faae82        	movi	a8, 0xfffffefa
40380bdd:	828a      	add.n	a8, a2, a8
40380bdf:	40f880        	nsau	a8, a8
40380be2:	418580        	srli	a8, a8, 5
40380be5:	209980        	or	a9, a9, a8
40380be8:	04c916        	beqz	a9, 40380c38 <spi_flash_chip_generic_erase_sector+0x88>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380beb:	2788      	l32i.n	a8, a7, 8
40380bed:	9888      	l32i.n	a8, a8, 36
40380bef:	388c      	beqz.n	a8, 40380bf6 <spi_flash_chip_generic_erase_sector+0x46>
40380bf1:	1a0c      	movi.n	a10, 1
40380bf3:	0008e0        	callx8	a8
        chip->host->driver->erase_sector(chip->host, start_address);
40380bf6:	07a8      	l32i.n	a10, a7, 0
40380bf8:	0a88      	l32i.n	a8, a10, 0
40380bfa:	4888      	l32i.n	a8, a8, 16
40380bfc:	03bd      	mov.n	a11, a3
40380bfe:	0008e0        	callx8	a8
        chip->busy = 1;
40380c01:	7788      	l32i.n	a8, a7, 28
40380c03:	190c      	movi.n	a9, 1
40380c05:	208890        	or	a8, a8, a9
40380c08:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
40380c0a:	1788      	l32i.n	a8, a7, 4
40380c0c:	152892        	l32i	a9, a8, 84
40380c0f:	1888      	l32i.n	a8, a8, 4
40380c11:	38b8      	l32i.n	a11, a8, 12
40380c13:	07ad      	mov.n	a10, a7
40380c15:	0009e0        	callx8	a9
40380c18:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380c1a:	2788      	l32i.n	a8, a7, 8
40380c1c:	9888      	l32i.n	a8, a8, 36
40380c1e:	388c      	beqz.n	a8, 40380c25 <spi_flash_chip_generic_erase_sector+0x75>
40380c20:	0a0c      	movi.n	a10, 0
40380c22:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380c25:	06a182        	movi	a8, 0x106
40380c28:	0c9287        	bne	a2, a8, 40380c38 <spi_flash_chip_generic_erase_sector+0x88>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380c2b:	1788      	l32i.n	a8, a7, 4
40380c2d:	b888      	l32i.n	a8, a8, 44
40380c2f:	1b0c      	movi.n	a11, 1
40380c31:	07ad      	mov.n	a10, a7
40380c33:	0008e0        	callx8	a8
40380c36:	0a2d      	mov.n	a2, a10
}
40380c38:	f01d      	retw.n
	...

40380c3c <spi_flash_chip_generic_erase_block>:
{
40380c3c:	004136        	entry	a1, 32
40380c3f:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40380c41:	1288      	l32i.n	a8, a2, 4
40380c43:	b888      	l32i.n	a8, a8, 44
40380c45:	0b0c      	movi.n	a11, 0
40380c47:	02ad      	mov.n	a10, a2
40380c49:	0008e0        	callx8	a8
40380c4c:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380c4e:	eacc      	bnez.n	a10, 40380c60 <spi_flash_chip_generic_erase_block+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380c50:	1788      	l32i.n	a8, a7, 4
40380c52:	152892        	l32i	a9, a8, 84
40380c55:	1888      	l32i.n	a8, a8, 4
40380c57:	08b8      	l32i.n	a11, a8, 0
40380c59:	07ad      	mov.n	a10, a7
40380c5b:	0009e0        	callx8	a9
40380c5e:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380c60:	40f290        	nsau	a9, a2
40380c63:	419590        	srli	a9, a9, 5
40380c66:	faae82        	movi	a8, 0xfffffefa
40380c69:	828a      	add.n	a8, a2, a8
40380c6b:	40f880        	nsau	a8, a8
40380c6e:	418580        	srli	a8, a8, 5
40380c71:	209980        	or	a9, a9, a8
40380c74:	04c916        	beqz	a9, 40380cc4 <spi_flash_chip_generic_erase_block+0x88>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380c77:	2788      	l32i.n	a8, a7, 8
40380c79:	9888      	l32i.n	a8, a8, 36
40380c7b:	388c      	beqz.n	a8, 40380c82 <spi_flash_chip_generic_erase_block+0x46>
40380c7d:	1a0c      	movi.n	a10, 1
40380c7f:	0008e0        	callx8	a8
        chip->host->driver->erase_block(chip->host, start_address);
40380c82:	07a8      	l32i.n	a10, a7, 0
40380c84:	0a88      	l32i.n	a8, a10, 0
40380c86:	5888      	l32i.n	a8, a8, 20
40380c88:	03bd      	mov.n	a11, a3
40380c8a:	0008e0        	callx8	a8
        chip->busy = 1;
40380c8d:	7788      	l32i.n	a8, a7, 28
40380c8f:	190c      	movi.n	a9, 1
40380c91:	208890        	or	a8, a8, a9
40380c94:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
40380c96:	1788      	l32i.n	a8, a7, 4
40380c98:	152892        	l32i	a9, a8, 84
40380c9b:	1888      	l32i.n	a8, a8, 4
40380c9d:	28b8      	l32i.n	a11, a8, 8
40380c9f:	07ad      	mov.n	a10, a7
40380ca1:	0009e0        	callx8	a9
40380ca4:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380ca6:	2788      	l32i.n	a8, a7, 8
40380ca8:	9888      	l32i.n	a8, a8, 36
40380caa:	388c      	beqz.n	a8, 40380cb1 <spi_flash_chip_generic_erase_block+0x75>
40380cac:	0a0c      	movi.n	a10, 0
40380cae:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380cb1:	06a182        	movi	a8, 0x106
40380cb4:	0c9287        	bne	a2, a8, 40380cc4 <spi_flash_chip_generic_erase_block+0x88>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380cb7:	1788      	l32i.n	a8, a7, 4
40380cb9:	b888      	l32i.n	a8, a8, 44
40380cbb:	1b0c      	movi.n	a11, 1
40380cbd:	07ad      	mov.n	a10, a7
40380cbf:	0008e0        	callx8	a8
40380cc2:	0a2d      	mov.n	a2, a10
}
40380cc4:	f01d      	retw.n
	...

40380cc8 <spi_flash_chip_generic_page_program>:
{
40380cc8:	004136        	entry	a1, 32
40380ccb:	027d      	mov.n	a7, a2
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380ccd:	1288      	l32i.n	a8, a2, 4
40380ccf:	152892        	l32i	a9, a8, 84
40380cd2:	1888      	l32i.n	a8, a8, 4
40380cd4:	0028b2        	l32i	a11, a8, 0
40380cd7:	02ad      	mov.n	a10, a2
40380cd9:	0009e0        	callx8	a9
40380cdc:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380cde:	40fa90        	nsau	a9, a10
40380ce1:	419590        	srli	a9, a9, 5
40380ce4:	faae82        	movi	a8, 0xfffffefa
40380ce7:	8a8a      	add.n	a8, a10, a8
40380ce9:	40f880        	nsau	a8, a8
40380cec:	418580        	srli	a8, a8, 5
40380cef:	209980        	or	a9, a9, a8
40380cf2:	c9bc      	beqz.n	a9, 40380d32 <spi_flash_chip_generic_page_program+0x6a>
        chip->host->driver->program_page(chip->host, buffer, address, length);
40380cf4:	07a8      	l32i.n	a10, a7, 0
40380cf6:	0a88      	l32i.n	a8, a10, 0
40380cf8:	8888      	l32i.n	a8, a8, 32
40380cfa:	05dd      	mov.n	a13, a5
40380cfc:	20c440        	or	a12, a4, a4
40380cff:	03bd      	mov.n	a11, a3
40380d01:	0008e0        	callx8	a8
        chip->busy = 1;
40380d04:	7788      	l32i.n	a8, a7, 28
40380d06:	190c      	movi.n	a9, 1
40380d08:	208890        	or	a8, a8, a9
40380d0b:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40380d0d:	1788      	l32i.n	a8, a7, 4
40380d0f:	152892        	l32i	a9, a8, 84
40380d12:	1888      	l32i.n	a8, a8, 4
40380d14:	0428b2        	l32i	a11, a8, 16
40380d17:	07ad      	mov.n	a10, a7
40380d19:	0009e0        	callx8	a9
40380d1c:	0a2d      	mov.n	a2, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380d1e:	06a182        	movi	a8, 0x106
40380d21:	0d9a87        	bne	a10, a8, 40380d32 <spi_flash_chip_generic_page_program+0x6a>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380d24:	1788      	l32i.n	a8, a7, 4
40380d26:	b888      	l32i.n	a8, a8, 44
40380d28:	01a0b2        	movi	a11, 1
40380d2b:	07ad      	mov.n	a10, a7
40380d2d:	0008e0        	callx8	a8
40380d30:	0a2d      	mov.n	a2, a10
}
40380d32:	f01d      	retw.n

40380d34 <spi_flash_chip_generic_set_write_protect>:
{
40380d34:	006136        	entry	a1, 48
40380d37:	743030        	extui	a3, a3, 0, 8
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380d3a:	1288      	l32i.n	a8, a2, 4
40380d3c:	152892        	l32i	a9, a8, 84
40380d3f:	1888      	l32i.n	a8, a8, 4
40380d41:	08b8      	l32i.n	a11, a8, 0
40380d43:	02ad      	mov.n	a10, a2
40380d45:	0009e0        	callx8	a9
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380d48:	40fa90        	nsau	a9, a10
40380d4b:	419590        	srli	a9, a9, 5
40380d4e:	faae82        	movi	a8, 0xfffffefa
40380d51:	8a8a      	add.n	a8, a10, a8
40380d53:	40f880        	nsau	a8, a8
40380d56:	418580        	srli	a8, a8, 5
40380d59:	209980        	or	a9, a9, a8
40380d5c:	998c      	beqz.n	a9, 40380d69 <spi_flash_chip_generic_set_write_protect+0x35>
        chip->host->driver->set_write_protect(chip->host, write_protect);
40380d5e:	02a8      	l32i.n	a10, a2, 0
40380d60:	0a88      	l32i.n	a8, a10, 0
40380d62:	7888      	l32i.n	a8, a8, 28
40380d64:	03bd      	mov.n	a11, a3
40380d66:	0008e0        	callx8	a8
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
40380d69:	1288      	l32i.n	a8, a2, 4
40380d6b:	a888      	l32i.n	a8, a8, 40
40380d6d:	01bd      	mov.n	a11, a1
40380d6f:	02ad      	mov.n	a10, a2
40380d71:	0008e0        	callx8	a8
40380d74:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
40380d76:	7acc      	bnez.n	a10, 40380d81 <spi_flash_chip_generic_set_write_protect+0x4d>
40380d78:	000182        	l8ui	a8, a1, 0
40380d7b:	021837        	beq	a8, a3, 40380d81 <spi_flash_chip_generic_set_write_protect+0x4d>
        err = ESP_ERR_NOT_FOUND;
40380d7e:	05a122        	movi	a2, 0x105
}
40380d81:	f01d      	retw.n
	...

40380d84 <spi_flash_chip_generic_read_reg>:
{
40380d84:	004136        	entry	a1, 32
40380d87:	04bd      	mov.n	a11, a4
    return chip->host->driver->read_status(chip->host, (uint8_t*)out_reg);
40380d89:	02a8      	l32i.n	a10, a2, 0
40380d8b:	0a88      	l32i.n	a8, a10, 0
40380d8d:	6888      	l32i.n	a8, a8, 24
40380d8f:	0008e0        	callx8	a8
}
40380d92:	0a2d      	mov.n	a2, a10
40380d94:	f01d      	retw.n
	...

40380d98 <spi_flash_chip_generic_wait_idle>:
{
40380d98:	006136        	entry	a1, 48
    if (timeout_us == ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT) {
40380d9b:	040326        	beqi	a3, -1, 40380da3 <spi_flash_chip_generic_wait_idle+0xb>
40380d9e:	037d      	mov.n	a7, a3
40380da0:	000046        	j	40380da5 <spi_flash_chip_generic_wait_idle+0xd>
        timeout_us = 0;// In order to go into while
40380da3:	070c      	movi.n	a7, 0
    timeout_us++; // allow at least one pass before timeout, last one has no sleep cycle
40380da5:	771b      	addi.n	a7, a7, 1
    while (timeout_us > 0) {
40380da7:	001c86        	j	40380e1d <spi_flash_chip_generic_wait_idle+0x85>
40380daa:	000000        	ill
            if (timeout_us > 1) {
40380dad:	1327b6        	bltui	a7, 2, 40380dc4 <spi_flash_chip_generic_wait_idle+0x2c>
                int delay = MIN(HOST_DELAY_INTERVAL_US, timeout_us);
40380db0:	150c      	movi.n	a5, 1
40380db2:	635750        	minu	a5, a7, a5
                chip->os_func->delay_us(chip->os_func_data, delay);
40380db5:	2288      	l32i.n	a8, a2, 8
40380db7:	3888      	l32i.n	a8, a8, 12
40380db9:	05bd      	mov.n	a11, a5
40380dbb:	0322a2        	l32i	a10, a2, 12
40380dbe:	0008e0        	callx8	a8
                timeout_us -= delay;
40380dc1:	c07750        	sub	a7, a7, a5
        while (!chip->host->driver->host_status(chip->host) && timeout_us > 0) {
40380dc4:	02a8      	l32i.n	a10, a2, 0
40380dc6:	0a88      	l32i.n	a8, a10, 0
40380dc8:	e888      	l32i.n	a8, a8, 56
40380dca:	0008e0        	callx8	a8
40380dcd:	1acc      	bnez.n	a10, 40380dd2 <spi_flash_chip_generic_wait_idle+0x3a>
40380dcf:	fda756        	bnez	a7, 40380dad <spi_flash_chip_generic_wait_idle+0x15>
        esp_err_t err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &read);
40380dd2:	1288      	l32i.n	a8, a2, 4
40380dd4:	192882        	l32i	a8, a8, 100
40380dd7:	01cd      	mov.n	a12, a1
40380dd9:	1b0c      	movi.n	a11, 1
40380ddb:	02ad      	mov.n	a10, a2
40380ddd:	0008e0        	callx8	a8
        if (err != ESP_OK) {
40380de0:	048a56        	bnez	a10, 40380e2c <spi_flash_chip_generic_wait_idle+0x94>
        status = read;
40380de3:	0188      	l32i.n	a8, a1, 0
        if ((status & SR_WIP) == 0 && (suspend_state == false)) { // Verify write in progress is complete
40380de5:	11e807        	bbsi	a8, 0, 40380dfa <spi_flash_chip_generic_wait_idle+0x62>
            if (chip->busy == 1) {
40380de8:	7298      	l32i.n	a9, a2, 28
40380dea:	326907        	bbci	a9, 0, 40380e20 <spi_flash_chip_generic_wait_idle+0x88>
                chip->busy = 0;
40380ded:	ea7c      	movi.n	a10, -2
40380def:	1099a0        	and	a9, a9, a10
40380df2:	7299      	s32i.n	a9, a2, 28
                if ((status & SR_WREN) != 0) { // The previous command is not accepted, leaving the WEL still set.
40380df4:	286817        	bbci	a8, 1, 40380e20 <spi_flash_chip_generic_wait_idle+0x88>
40380df7:	000706        	j	40380e17 <spi_flash_chip_generic_wait_idle+0x7f>
        if (timeout_us > 0 && interval > 0) {
40380dfa:	f79c      	beqz.n	a7, 40380e1d <spi_flash_chip_generic_wait_idle+0x85>
            int delay = MIN(interval, timeout_us);
40380dfc:	451c      	movi.n	a5, 20
40380dfe:	635750        	minu	a5, a7, a5
            chip->os_func->delay_us(chip->os_func_data, delay);
40380e01:	2288      	l32i.n	a8, a2, 8
40380e03:	3888      	l32i.n	a8, a8, 12
40380e05:	05bd      	mov.n	a11, a5
40380e07:	32a8      	l32i.n	a10, a2, 12
40380e09:	0008e0        	callx8	a8
            if (timeout_en) {
40380e0c:	0d0326        	beqi	a3, -1, 40380e1d <spi_flash_chip_generic_wait_idle+0x85>
                timeout_us -= delay;
40380e0f:	c07750        	sub	a7, a7, a5
40380e12:	0001c6        	j	40380e1d <spi_flash_chip_generic_wait_idle+0x85>
40380e15:	a20000        	muluh	a0, a0, a0
                    return ESP_ERR_NOT_SUPPORTED;
40380e18:	8606a1        	l32r	a10, 40362630 <rom_rx_gain_force+0x35c204>
40380e1b:	560003        	lsi	f0, a0, 0x158
    while (timeout_us > 0) {
40380e1e:	8cfa37        	bbsi	a10, 19, 40380dae <spi_flash_chip_generic_wait_idle+0x16>
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
40380e21:	0a0c57        	bnone	a12, a5, 40380e2f <spi_flash_chip_generic_wait_idle+0x97>
40380e24:	000106        	j	40380e2c <spi_flash_chip_generic_wait_idle+0x94>
40380e27:	a20000        	muluh	a0, a0, a0
40380e2a:	2d07a1        	l32r	a10, 4034c248 <rom_rx_gain_force+0x345e1c>
}
40380e2d:	1d0a      	add.n	a1, a13, a0
40380e2f:	f0          	.byte	0xf0

40380e30 <spi_flash_chip_generic_read_unique_id_none>:
{
40380e30:	004136        	entry	a1, 32
}
40380e33:	06a122        	movi	a2, 0x106
40380e36:	f01d      	retw.n

40380e38 <spi_flash_common_set_io_mode>:
{
40380e38:	006136        	entry	a1, 48
40380e3b:	027d      	mov.n	a7, a2
40380e3d:	4288      	l32i.n	a8, a2, 16
40380e3f:	fcc882        	addi	a8, a8, -4
    if (need_check) {
40380e42:	0228b6        	bltui	a8, 2, 40380e48 <spi_flash_common_set_io_mode+0x10>
40380e45:	002146        	j	40380ece <spi_flash_common_set_io_mode+0x96>
        ret = (*rdsr_func)(chip, &sr);
40380e48:	01bd      	mov.n	a11, a1
40380e4a:	20a220        	or	a10, a2, a2
40380e4d:	0004e0        	callx8	a4
40380e50:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40380e52:	07aa56        	bnez	a10, 40380ed0 <spi_flash_common_set_io_mode+0x98>
            sr_update = sr | qe_sr_bit;
40380e55:	0188      	l32i.n	a8, a1, 0
40380e57:	206850        	or	a6, a8, a5
        if (sr != sr_update) {
40380e5a:	724857        	ball	a8, a5, 40380ed0 <spi_flash_common_set_io_mode+0x98>
        chip->chip_drv->set_chip_write_protect(chip, false);
40380e5d:	1788      	l32i.n	a8, a7, 4
40380e5f:	b888      	l32i.n	a8, a8, 44
40380e61:	0b0c      	movi.n	a11, 0
40380e63:	20a770        	or	a10, a7, a7
40380e66:	0008e0        	callx8	a8
        ret = (*wrsr_func)(chip, sr_update);
40380e69:	06bd      	mov.n	a11, a6
40380e6b:	20a770        	or	a10, a7, a7
40380e6e:	0003e0        	callx8	a3
40380e71:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40380e73:	da8c      	beqz.n	a10, 40380e84 <spi_flash_common_set_io_mode+0x4c>
            chip->chip_drv->set_chip_write_protect(chip, true);
40380e75:	1788      	l32i.n	a8, a7, 4
40380e77:	b888      	l32i.n	a8, a8, 44
40380e79:	1b0c      	movi.n	a11, 1
40380e7b:	07ad      	mov.n	a10, a7
40380e7d:	0008e0        	callx8	a8
            return ret;
40380e80:	001306        	j	40380ed0 <spi_flash_common_set_io_mode+0x98>
40380e83:	178800        	lsi	f0, a8, 92
        ret = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380e86:	152892        	l32i	a9, a8, 84
40380e89:	1888      	l32i.n	a8, a8, 4
40380e8b:	08b8      	l32i.n	a11, a8, 0
40380e8d:	07ad      	mov.n	a10, a7
40380e8f:	0009e0        	callx8	a9
40380e92:	0a2d      	mov.n	a2, a10
        if (ret == ESP_ERR_NOT_SUPPORTED) {
40380e94:	06a182        	movi	a8, 0x106
40380e97:	0a9a87        	bne	a10, a8, 40380ea5 <spi_flash_common_set_io_mode+0x6d>
            chip->chip_drv->set_chip_write_protect(chip, true);
40380e9a:	1788      	l32i.n	a8, a7, 4
40380e9c:	b888      	l32i.n	a8, a8, 44
40380e9e:	1b0c      	movi.n	a11, 1
40380ea0:	07ad      	mov.n	a10, a7
40380ea2:	0008e0        	callx8	a8
        if (ret != ESP_OK && ret != ESP_ERR_NOT_SUPPORTED) {
40380ea5:	180c      	movi.n	a8, 1
40380ea7:	838220        	moveqz	a8, a2, a2
40380eaa:	faae92        	movi	a9, 0xfffffefa
40380ead:	929a      	add.n	a9, a2, a9
40380eaf:	1a0c      	movi.n	a10, 1
40380eb1:	83a990        	moveqz	a10, a9, a9
40380eb4:	1888a7        	bany	a8, a10, 40380ed0 <spi_flash_common_set_io_mode+0x98>
        ret = (*rdsr_func)(chip, &sr);
40380eb7:	01bd      	mov.n	a11, a1
40380eb9:	07ad      	mov.n	a10, a7
40380ebb:	0004e0        	callx8	a4
40380ebe:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40380ec0:	cacc      	bnez.n	a10, 40380ed0 <spi_flash_common_set_io_mode+0x98>
        if (sr != sr_update) {
40380ec2:	0188      	l32i.n	a8, a1, 0
40380ec4:	081867        	beq	a8, a6, 40380ed0 <spi_flash_common_set_io_mode+0x98>
            ret = ESP_ERR_FLASH_NO_RESPONSE;
40380ec7:	08a122        	movi	a2, 0x108
40380eca:	000086        	j	40380ed0 <spi_flash_common_set_io_mode+0x98>
40380ecd:	020c00        	andb	b0, b12, b0
}
40380ed0:	f01d      	retw.n
	...

40380ed4 <spi_flash_chip_issi_probe>:
#include "spi_flash_defs.h"

/* Driver for ISSI flash chip, as used in ESP32 D2WD */

esp_err_t spi_flash_chip_issi_probe(esp_flash_t *chip, uint32_t flash_id)
{
40380ed4:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0x9D;
    if (flash_id >> 16 != MFG_ID) {
40380ed7:	f59030        	extui	a9, a3, 16, 16
40380eda:	9da082        	movi	a8, 157
40380edd:	109987        	bne	a9, a8, 40380ef1 <spi_flash_chip_issi_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xCF00;
    const uint16_t FLASH_ID_VALUE = 0x4000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
40380ee0:	d08881        	l32r	a8, 40375100 <_iram_text_start+0xcfc> (cf00 <UserFrameTotalSize+0xce00>)
40380ee3:	103380        	and	a3, a3, a8
40380ee6:	cd5a81        	l32r	a8, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
40380ee9:	0b9387        	bne	a3, a8, 40380ef8 <spi_flash_chip_issi_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
40380eec:	020c      	movi.n	a2, 0
40380eee:	000246        	j	40380efb <spi_flash_chip_issi_probe+0x27>
        return ESP_ERR_NOT_FOUND;
40380ef1:	05a122        	movi	a2, 0x105
40380ef4:	0000c6        	j	40380efb <spi_flash_chip_issi_probe+0x27>
40380ef7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40380efa:	f01d05        	call0	403710cc <rom_rx_gain_force+0x36aca0>
40380efd:	000000        	ill

40380f00 <spi_flash_chip_issi_set_io_mode>:
}

esp_err_t spi_flash_chip_issi_set_io_mode(esp_flash_t *chip)
{
40380f00:	004136        	entry	a1, 32
40380f03:	02ad      	mov.n	a10, a2
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    return spi_flash_common_set_io_mode(chip,
40380f05:	0d4c      	movi.n	a13, 64
40380f07:	d07fc1        	l32r	a12, 40375104 <_iram_text_start+0xd00> (40380ab8 <spi_flash_common_read_status_8b_rdsr>)
40380f0a:	d07fb1        	l32r	a11, 40375108 <_iram_text_start+0xd04> (40380ad0 <spi_flash_common_write_status_8b_wrsr>)
40380f0d:	fff2a5        	call8	40380e38 <spi_flash_common_set_io_mode>
                                        spi_flash_common_write_status_8b_wrsr,
                                        spi_flash_common_read_status_8b_rdsr,
                                        BIT_QE);
}
40380f10:	0a2d      	mov.n	a2, a10
40380f12:	f01d      	retw.n

40380f14 <spi_flash_chip_issi_get_io_mode>:

esp_err_t spi_flash_chip_issi_get_io_mode(esp_flash_t *chip, esp_flash_io_mode_t* out_io_mode)
{
40380f14:	006136        	entry	a1, 48
40380f17:	20a220        	or	a10, a2, a2
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    uint32_t sr;
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr(chip, &sr);
40380f1a:	20b110        	or	a11, a1, a1
40380f1d:	ffb9a5        	call8	40380ab8 <spi_flash_common_read_status_8b_rdsr>
40380f20:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380f23:	aacc      	bnez.n	a10, 40380f31 <spi_flash_chip_issi_get_io_mode+0x1d>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380f25:	0188      	l32i.n	a8, a1, 0
40380f27:	418480        	srli	a8, a8, 4
40380f2a:	490c      	movi.n	a9, 4
40380f2c:	108890        	and	a8, a8, a9
40380f2f:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
40380f31:	f01d      	retw.n
	...

40380f34 <spi_flash_chip_issi_get_caps>:

spi_flash_caps_t spi_flash_chip_issi_get_caps(esp_flash_t *chip)
{
40380f34:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
40380f37:	420c      	movi.n	a2, 4
40380f39:	f01d      	retw.n
	...

40380f3c <spi_flash_chip_mxic_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_detect_size(esp_flash_t *chip, uint32_t *size)
{
40380f3c:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
40380f3f:	6288      	l32i.n	a8, a2, 24
    *size = 0;
40380f41:	0c0c      	movi.n	a12, 0
40380f43:	03c9      	s32i.n	a12, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
40380f45:	f4a080        	extui	a10, a8, 0, 16
40380f48:	190c      	movi.n	a9, 1
40380f4a:	0cbd      	mov.n	a11, a12
40380f4c:	83b9a0        	moveqz	a11, a9, a10
40380f4f:	cd44d1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40380f52:	c0aad0        	sub	a10, a10, a13
40380f55:	939ca0        	movnez	a9, a12, a10
40380f58:	209b90        	or	a9, a11, a9
40380f5b:	99dc      	bnez.n	a9, 40380f78 <spi_flash_chip_mxic_detect_size+0x3c>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    uint32_t mem_density = (id & 0xFF);
40380f5d:	748080        	extui	a8, a8, 0, 8
    if (mem_density > 0x30) { // For OPI chips
40380f60:	093c      	movi.n	a9, 48
40380f62:	02b987        	bgeu	a9, a8, 40380f68 <spi_flash_chip_mxic_detect_size+0x2c>
        mem_density -= 0x20;
40380f65:	e0c882        	addi	a8, a8, -32
    }

    *size = 1 << mem_density;
40380f68:	190c      	movi.n	a9, 1
40380f6a:	401800        	ssl	a8
40380f6d:	a18900        	sll	a8, a9
40380f70:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380f72:	020c      	movi.n	a2, 0
40380f74:	0000c6        	j	40380f7b <spi_flash_chip_mxic_detect_size+0x3f>
40380f77:	4c2100        	lsi	f0, a1, 0x130
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
40380f7a:	ce          	.byte	0xce
}
40380f7b:	f01d      	retw.n
40380f7d:	000000        	ill

40380f80 <spi_flash_chip_mxic_probe>:
{
40380f80:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40380f83:	f53030        	extui	a3, a3, 16, 16
40380f86:	c2a082        	movi	a8, 194
40380f89:	0b9387        	bne	a3, a8, 40380f98 <spi_flash_chip_mxic_probe+0x18>
    if (chip->read_mode >= SPI_FLASH_OPI_FLAG) {
40380f8c:	4288      	l32i.n	a8, a2, 16
40380f8e:	f90c      	movi.n	a9, 15
40380f90:	0c3987        	bltu	a9, a8, 40380fa0 <spi_flash_chip_mxic_probe+0x20>
    return ESP_OK;
40380f93:	020c      	movi.n	a2, 0
40380f95:	000286        	j	40380fa3 <spi_flash_chip_mxic_probe+0x23>
        return ESP_ERR_NOT_FOUND;
40380f98:	05a122        	movi	a2, 0x105
40380f9b:	000106        	j	40380fa3 <spi_flash_chip_mxic_probe+0x23>
40380f9e:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
40380fa1:	1d05a1        	l32r	a10, 403483b8 <rom_rx_gain_force+0x341f8c>
}
40380fa4:	0000f0        	callx12	a0
	...

40380fa8 <spi_flash_chip_mxic_get_caps>:
#define spi_flash_chip_mxic_read_reg        spi_flash_chip_generic_read_reg

static const char chip_name[] = "mxic";

spi_flash_caps_t spi_flash_chip_mxic_get_caps(esp_flash_t *chip)
{
40380fa8:	004136        	entry	a1, 32
    spi_flash_caps_t caps_flags = 0;
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // reading unique id is not supported.
    return caps_flags;
}
40380fab:	020c      	movi.n	a2, 0
40380fad:	f01d      	retw.n
	...

40380fb0 <spi_flash_chip_mxic_opi_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_opi_detect_size(esp_flash_t *chip, uint32_t *size)
{
40380fb0:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
40380fb3:	62c8      	l32i.n	a12, a2, 24
    *size = 0;
40380fb5:	0b0c      	movi.n	a11, 0
40380fb7:	03b9      	s32i.n	a11, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
40380fb9:	f490c0        	extui	a9, a12, 0, 16
40380fbc:	180c      	movi.n	a8, 1
40380fbe:	0bad      	mov.n	a10, a11
40380fc0:	83a890        	moveqz	a10, a8, a9
40380fc3:	cd27d1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40380fc6:	c099d0        	sub	a9, a9, a13
40380fc9:	938b90        	movnez	a8, a11, a9
40380fcc:	208a80        	or	a8, a10, a8
40380fcf:	d8cc      	bnez.n	a8, 40380fe0 <spi_flash_chip_mxic_opi_detect_size+0x30>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    *size = 1 << ((id & 0xFF) - 0x20);
40380fd1:	180c      	movi.n	a8, 1
40380fd3:	401c00        	ssl	a12
40380fd6:	a18800        	sll	a8, a8
40380fd9:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380fdb:	0b2d      	mov.n	a2, a11
40380fdd:	000086        	j	40380fe3 <spi_flash_chip_mxic_opi_detect_size+0x33>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
40380fe0:	ce3221        	l32r	a2, 403748a8 <_iram_text_start+0x4a4> (6005 <UserFrameTotalSize+0x5f05>)
}
40380fe3:	f01d      	retw.n
40380fe5:	000000        	ill

40380fe8 <spi_flash_chip_mxic_opi_set_write_protect>:
    // reading unique id is not supported.
    return caps_flags;
}

esp_err_t spi_flash_chip_mxic_opi_set_write_protect(esp_flash_t *chip, bool write_protect)
{
40380fe8:	008136        	entry	a1, 64
40380feb:	743030        	extui	a3, a3, 0, 8
    esp_err_t err = ESP_OK;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380fee:	1288      	l32i.n	a8, a2, 4
40380ff0:	152892        	l32i	a9, a8, 84
40380ff3:	1888      	l32i.n	a8, a8, 4
40380ff5:	0028b2        	l32i	a11, a8, 0
40380ff8:	20a220        	or	a10, a2, a2
40380ffb:	0009e0        	callx8	a9
40380ffe:	0a7d      	mov.n	a7, a10
    spi_flash_trans_t t = {};
40381000:	cc1c      	movi.n	a12, 28
40381002:	0b0c      	movi.n	a11, 0
40381004:	01ad      	mov.n	a10, a1
40381006:	cd2281        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381009:	0008e0        	callx8	a8
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4038100c:	40f790        	nsau	a9, a7
4038100f:	419590        	srli	a9, a9, 5
40381012:	faae82        	movi	a8, 0xfffffefa
40381015:	878a      	add.n	a8, a7, a8
40381017:	40f880        	nsau	a8, a8
4038101a:	418580        	srli	a8, a8, 5
4038101d:	209980        	or	a9, a9, a8
40381020:	a99c      	beqz.n	a9, 4038103e <spi_flash_chip_mxic_opi_set_write_protect+0x56>
        if(write_protect) {
40381022:	738c      	beqz.n	a3, 4038102d <spi_flash_chip_mxic_opi_set_write_protect+0x45>
            t.command = CMD_OPI_FLASH_MXIC(CMD_WRDI);
40381024:	04ab82        	movi	a8, 0xfffffb04
40381027:	0a5182        	s16i	a8, a1, 20
4038102a:	000146        	j	40381033 <spi_flash_chip_mxic_opi_set_write_protect+0x4b>
        } else {
            t.command = CMD_OPI_FLASH_MXIC(CMD_WREN);
4038102d:	06a982        	movi	a8, 0xfffff906
40381030:	0a5182        	s16i	a8, a1, 20
        }
        err = chip->host->driver->common_command(chip->host, &t);
40381033:	02a8      	l32i.n	a10, a2, 0
40381035:	0a88      	l32i.n	a8, a10, 0
40381037:	1888      	l32i.n	a8, a8, 4
40381039:	01bd      	mov.n	a11, a1
4038103b:	0008e0        	callx8	a8
    }

    bool wp_read;
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
4038103e:	1288      	l32i.n	a8, a2, 4
40381040:	a888      	l32i.n	a8, a8, 40
40381042:	1cc1b2        	addi	a11, a1, 28
40381045:	02ad      	mov.n	a10, a2
40381047:	0008e0        	callx8	a8
4038104a:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
4038104c:	008a56        	bnez	a10, 40381058 <spi_flash_chip_mxic_opi_set_write_protect+0x70>
4038104f:	1c0182        	l8ui	a8, a1, 28
40381052:	021837        	beq	a8, a3, 40381058 <spi_flash_chip_mxic_opi_set_write_protect+0x70>
        err = ESP_ERR_NOT_FOUND;
40381055:	05a122        	movi	a2, 0x105
    }
    return err;
}
40381058:	f01d      	retw.n
	...

4038105c <spi_flash_chip_mxic_opi_erase_chip>:
    *out_write_protected = ((status & SR_WREN) == 0);
    return err;
}

esp_err_t spi_flash_chip_mxic_opi_erase_chip(esp_flash_t *chip)
{
4038105c:	008136        	entry	a1, 64
4038105f:	027d      	mov.n	a7, a2
    esp_err_t err;

    err = chip->chip_drv->set_chip_write_protect(chip, false);
40381061:	1288      	l32i.n	a8, a2, 4
40381063:	b888      	l32i.n	a8, a8, 44
40381065:	00a0b2        	movi	a11, 0
40381068:	20a220        	or	a10, a2, a2
4038106b:	0008e0        	callx8	a8
4038106e:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40381070:	0adc      	bnez.n	a10, 40381084 <spi_flash_chip_mxic_opi_erase_chip+0x28>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381072:	1788      	l32i.n	a8, a7, 4
40381074:	152892        	l32i	a9, a8, 84
40381077:	1888      	l32i.n	a8, a8, 4
40381079:	08b8      	l32i.n	a11, a8, 0
4038107b:	20a770        	or	a10, a7, a7
4038107e:	0009e0        	callx8	a9
40381081:	202aa0        	or	a2, a10, a10
    }

    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381084:	40f290        	nsau	a9, a2
40381087:	419590        	srli	a9, a9, 5
4038108a:	faae82        	movi	a8, 0xfffffefa
4038108d:	828a      	add.n	a8, a2, a8
4038108f:	40f880        	nsau	a8, a8
40381092:	418580        	srli	a8, a8, 5
40381095:	209980        	or	a9, a9, a8
40381098:	048916        	beqz	a9, 403810e4 <spi_flash_chip_mxic_opi_erase_chip+0x88>
        // Do erase chip here.
        spi_flash_trans_t t = {
4038109b:	cc1c      	movi.n	a12, 28
4038109d:	0b0c      	movi.n	a11, 0
4038109f:	20a110        	or	a10, a1, a1
403810a2:	ccfb81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403810a5:	0008e0        	callx8	a8
403810a8:	d01981        	l32r	a8, 4037510c <_iram_text_start+0xd08> (ffff9f60 <_rtc_reserved_end+0x9fef9f60>)
403810ab:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC_CHIP_ERASE,
        };
        err = chip->host->driver->common_command(chip->host, &t);
403810ae:	07a8      	l32i.n	a10, a7, 0
403810b0:	0a88      	l32i.n	a8, a10, 0
403810b2:	1888      	l32i.n	a8, a8, 4
403810b4:	20b110        	or	a11, a1, a1
403810b7:	0008e0        	callx8	a8
        chip->busy = 1;
403810ba:	7788      	l32i.n	a8, a7, 28
403810bc:	190c      	movi.n	a9, 1
403810be:	208890        	or	a8, a8, a9
403810c1:	7789      	s32i.n	a8, a7, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
403810c3:	1788      	l32i.n	a8, a7, 4
403810c5:	152892        	l32i	a9, a8, 84
403810c8:	1888      	l32i.n	a8, a8, 4
403810ca:	18b8      	l32i.n	a11, a8, 4
403810cc:	07ad      	mov.n	a10, a7
403810ce:	0009e0        	callx8	a9
403810d1:	0a2d      	mov.n	a2, a10
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
403810d3:	06a182        	movi	a8, 0x106
403810d6:	0a9a87        	bne	a10, a8, 403810e4 <spi_flash_chip_mxic_opi_erase_chip+0x88>
        chip->chip_drv->set_chip_write_protect(chip, true);
403810d9:	1788      	l32i.n	a8, a7, 4
403810db:	b888      	l32i.n	a8, a8, 44
403810dd:	1b0c      	movi.n	a11, 1
403810df:	07ad      	mov.n	a10, a7
403810e1:	0008e0        	callx8	a8
    }

    return err;

}
403810e4:	f01d      	retw.n
	...

403810e8 <spi_flash_chip_mxic_opi_erase_sector>:

esp_err_t spi_flash_chip_mxic_opi_erase_sector(esp_flash_t *chip, uint32_t start_address)
{
403810e8:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
403810eb:	1288      	l32i.n	a8, a2, 4
403810ed:	b888      	l32i.n	a8, a8, 44
403810ef:	0b0c      	movi.n	a11, 0
403810f1:	02ad      	mov.n	a10, a2
403810f3:	0008e0        	callx8	a8
    if (err == ESP_OK) {
403810f6:	eacc      	bnez.n	a10, 40381108 <spi_flash_chip_mxic_opi_erase_sector+0x20>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403810f8:	1288      	l32i.n	a8, a2, 4
403810fa:	152892        	l32i	a9, a8, 84
403810fd:	1888      	l32i.n	a8, a8, 4
403810ff:	0028b2        	l32i	a11, a8, 0
40381102:	20a220        	or	a10, a2, a2
40381105:	0009e0        	callx8	a9
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381108:	40fa90        	nsau	a9, a10
4038110b:	419590        	srli	a9, a9, 5
4038110e:	faae82        	movi	a8, 0xfffffefa
40381111:	8a8a      	add.n	a8, a10, a8
40381113:	40f880        	nsau	a8, a8
40381116:	418580        	srli	a8, a8, 5
40381119:	209980        	or	a9, a9, a8
4038111c:	04d916        	beqz	a9, 4038116d <spi_flash_chip_mxic_opi_erase_sector+0x85>
        spi_flash_trans_t t = {
4038111f:	cc1c      	movi.n	a12, 28
40381121:	0b0c      	movi.n	a11, 0
40381123:	20a110        	or	a10, a1, a1
40381126:	ccda81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381129:	0008e0        	callx8	a8
4038112c:	082c      	movi.n	a8, 32
4038112e:	034182        	s8i	a8, a1, 3
40381131:	1139      	s32i.n	a3, a1, 4
40381133:	cff781        	l32r	a8, 40375110 <_iram_text_start+0xd0c> (ffffde21 <_rtc_reserved_end+0x9fefde21>)
40381136:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC(CMD_SECTOR_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
40381139:	02a8      	l32i.n	a10, a2, 0
4038113b:	0a88      	l32i.n	a8, a10, 0
4038113d:	1888      	l32i.n	a8, a8, 4
4038113f:	20b110        	or	a11, a1, a1
40381142:	0008e0        	callx8	a8
        chip->busy = 1;
40381145:	7288      	l32i.n	a8, a2, 28
40381147:	190c      	movi.n	a9, 1
40381149:	208890        	or	a8, a8, a9
4038114c:	7289      	s32i.n	a8, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
4038114e:	1288      	l32i.n	a8, a2, 4
40381150:	152892        	l32i	a9, a8, 84
40381153:	1888      	l32i.n	a8, a8, 4
40381155:	38b8      	l32i.n	a11, a8, 12
40381157:	02ad      	mov.n	a10, a2
40381159:	0009e0        	callx8	a9
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
4038115c:	06a182        	movi	a8, 0x106
4038115f:	0a9a87        	bne	a10, a8, 4038116d <spi_flash_chip_mxic_opi_erase_sector+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381162:	1288      	l32i.n	a8, a2, 4
40381164:	b888      	l32i.n	a8, a8, 44
40381166:	1b0c      	movi.n	a11, 1
40381168:	02ad      	mov.n	a10, a2
4038116a:	0008e0        	callx8	a8
    }

    return err;
}
4038116d:	0a2d      	mov.n	a2, a10
4038116f:	f01d      	retw.n
40381171:	000000        	ill

40381174 <spi_flash_chip_mxic_opi_erase_block>:

esp_err_t spi_flash_chip_mxic_opi_erase_block(esp_flash_t *chip, uint32_t start_address)
{
40381174:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40381177:	1288      	l32i.n	a8, a2, 4
40381179:	b888      	l32i.n	a8, a8, 44
4038117b:	0b0c      	movi.n	a11, 0
4038117d:	02ad      	mov.n	a10, a2
4038117f:	0008e0        	callx8	a8
    if (err == ESP_OK) {
40381182:	eacc      	bnez.n	a10, 40381194 <spi_flash_chip_mxic_opi_erase_block+0x20>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381184:	1288      	l32i.n	a8, a2, 4
40381186:	152892        	l32i	a9, a8, 84
40381189:	1888      	l32i.n	a8, a8, 4
4038118b:	0028b2        	l32i	a11, a8, 0
4038118e:	20a220        	or	a10, a2, a2
40381191:	0009e0        	callx8	a9
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381194:	40fa90        	nsau	a9, a10
40381197:	419590        	srli	a9, a9, 5
4038119a:	faae82        	movi	a8, 0xfffffefa
4038119d:	8a8a      	add.n	a8, a10, a8
4038119f:	40f880        	nsau	a8, a8
403811a2:	418580        	srli	a8, a8, 5
403811a5:	209980        	or	a9, a9, a8
403811a8:	04d916        	beqz	a9, 403811f9 <spi_flash_chip_mxic_opi_erase_block+0x85>
        spi_flash_trans_t t = {
403811ab:	cc1c      	movi.n	a12, 28
403811ad:	0b0c      	movi.n	a11, 0
403811af:	20a110        	or	a10, a1, a1
403811b2:	ccb781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403811b5:	0008e0        	callx8	a8
403811b8:	082c      	movi.n	a8, 32
403811ba:	034182        	s8i	a8, a1, 3
403811bd:	1139      	s32i.n	a3, a1, 4
403811bf:	cfd581        	l32r	a8, 40375114 <_iram_text_start+0xd10> (23dc <UserFrameTotalSize+0x22dc>)
403811c2:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC(CMD_LARGE_BLOCK_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
403811c5:	02a8      	l32i.n	a10, a2, 0
403811c7:	0a88      	l32i.n	a8, a10, 0
403811c9:	1888      	l32i.n	a8, a8, 4
403811cb:	20b110        	or	a11, a1, a1
403811ce:	0008e0        	callx8	a8
        chip->busy = 1;
403811d1:	7288      	l32i.n	a8, a2, 28
403811d3:	190c      	movi.n	a9, 1
403811d5:	208890        	or	a8, a8, a9
403811d8:	7289      	s32i.n	a8, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
403811da:	1288      	l32i.n	a8, a2, 4
403811dc:	152892        	l32i	a9, a8, 84
403811df:	1888      	l32i.n	a8, a8, 4
403811e1:	28b8      	l32i.n	a11, a8, 8
403811e3:	02ad      	mov.n	a10, a2
403811e5:	0009e0        	callx8	a9
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
403811e8:	06a182        	movi	a8, 0x106
403811eb:	0a9a87        	bne	a10, a8, 403811f9 <spi_flash_chip_mxic_opi_erase_block+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
403811ee:	1288      	l32i.n	a8, a2, 4
403811f0:	b888      	l32i.n	a8, a8, 44
403811f2:	1b0c      	movi.n	a11, 1
403811f4:	02ad      	mov.n	a10, a2
403811f6:	0008e0        	callx8	a8
    }

    return err;
}
403811f9:	0a2d      	mov.n	a2, a10
403811fb:	f01d      	retw.n
403811fd:	000000        	ill

40381200 <spi_flash_chip_mxic_opi_page_program>:

esp_err_t spi_flash_chip_mxic_opi_page_program(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
40381200:	008136        	entry	a1, 64
40381203:	027d      	mov.n	a7, a2
    esp_err_t err;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381205:	1288      	l32i.n	a8, a2, 4
40381207:	152892        	l32i	a9, a8, 84
4038120a:	012882        	l32i	a8, a8, 4
4038120d:	0028b2        	l32i	a11, a8, 0
40381210:	20a220        	or	a10, a2, a2
40381213:	0009e0        	callx8	a9
40381216:	0a2d      	mov.n	a2, a10
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381218:	40fa90        	nsau	a9, a10
4038121b:	419590        	srli	a9, a9, 5
4038121e:	faae82        	movi	a8, 0xfffffefa
40381221:	8a8a      	add.n	a8, a10, a8
40381223:	40f880        	nsau	a8, a8
40381226:	418580        	srli	a8, a8, 5
40381229:	209980        	or	a9, a9, a8
4038122c:	056916        	beqz	a9, 40381286 <spi_flash_chip_mxic_opi_page_program+0x86>
        // Perform the actual Page Program command
        spi_flash_trans_t t = {
4038122f:	cc1c      	movi.n	a12, 28
40381231:	00a0b2        	movi	a11, 0
40381234:	20a110        	or	a10, a1, a1
40381237:	cc9681        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4038123a:	0008e0        	callx8	a8
4038123d:	014152        	s8i	a5, a1, 1
40381240:	082c      	movi.n	a8, 32
40381242:	034182        	s8i	a8, a1, 3
40381245:	1149      	s32i.n	a4, a1, 4
40381247:	2139      	s32i.n	a3, a1, 8
40381249:	cfb381        	l32r	a8, 40375118 <_iram_text_start+0xd14> (ffffed12 <_rtc_reserved_end+0x9fefed12>)
4038124c:	0a5182        	s16i	a8, a1, 20
            .address_bitlen = 32,
            .address = address,
            .mosi_len = length,
            .mosi_data = buffer,
        };
        chip->host->driver->common_command(chip->host, &t);
4038124f:	07a8      	l32i.n	a10, a7, 0
40381251:	0a88      	l32i.n	a8, a10, 0
40381253:	1888      	l32i.n	a8, a8, 4
40381255:	01bd      	mov.n	a11, a1
40381257:	0008e0        	callx8	a8
        chip->busy = 1;
4038125a:	7788      	l32i.n	a8, a7, 28
4038125c:	190c      	movi.n	a9, 1
4038125e:	208890        	or	a8, a8, a9
40381261:	7789      	s32i.n	a8, a7, 28

        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40381263:	1788      	l32i.n	a8, a7, 4
40381265:	152892        	l32i	a9, a8, 84
40381268:	1888      	l32i.n	a8, a8, 4
4038126a:	48b8      	l32i.n	a11, a8, 16
4038126c:	07ad      	mov.n	a10, a7
4038126e:	0009e0        	callx8	a9
40381271:	0a2d      	mov.n	a2, a10
    }
    // Ensure WEL is 0, even if the page program failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381273:	06a182        	movi	a8, 0x106
40381276:	0c9a87        	bne	a10, a8, 40381286 <spi_flash_chip_mxic_opi_page_program+0x86>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381279:	1788      	l32i.n	a8, a7, 4
4038127b:	b888      	l32i.n	a8, a8, 44
4038127d:	1b0c      	movi.n	a11, 1
4038127f:	07ad      	mov.n	a10, a7
40381281:	0008e0        	callx8	a8
40381284:	0a2d      	mov.n	a2, a10
    }
    return err;
}
40381286:	f01d      	retw.n

40381288 <spi_flash_chip_xmic_opi_config_host_io_mode>:
}

// This function should only be called after opi mode initialization. So, only configure for OPI-STR/OPI-DTR mode
// not support other mode in this file, return `ESP_ERR_FLASH_NOT_INITIALISED` directely.
esp_err_t spi_flash_chip_xmic_opi_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
40381288:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4038128b:	42e8      	l32i.n	a14, a2, 16

    switch (read_mode & 0xFFFF) {
4038128d:	f480e0        	extui	a8, a14, 0, 16
40381290:	0cb826        	beqi	a8, 16, 403812a0 <spi_flash_chip_xmic_opi_config_host_io_mode+0x18>
40381293:	191c      	movi.n	a9, 17
40381295:	1c9897        	bne	a8, a9, 403812b5 <spi_flash_chip_xmic_opi_config_host_io_mode+0x2d>
        read_command = CMD_OPI_FLASH_MXIC_READ_STR;
        break;
    case SPI_FLASH_OPI_DTR:
        addr_bitlen = SPI_FLASH_OPIDTR_ADDR_BITLEN;
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
        read_command = CMD_OPI_FLASH_MXIC_READ_DTR;
40381298:	cfa2b1        	l32r	a11, 40375120 <_iram_text_start+0xd1c> (11ee <UserFrameTotalSize+0x10ee>)
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
4038129b:	8d2c      	movi.n	a13, 40
4038129d:	000106        	j	403812a5 <spi_flash_chip_xmic_opi_config_host_io_mode+0x1d>
    switch (read_mode & 0xFFFF) {
403812a0:	cf9fb1        	l32r	a11, 4037511c <_iram_text_start+0xd18> (13ec <UserFrameTotalSize+0x12ec>)
403812a3:	4d1c      	movi.n	a13, 20
        break;
    default:
        return ESP_ERR_FLASH_NOT_INITIALISED;
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
403812a5:	02a8      	l32i.n	a10, a2, 0
403812a7:	0a88      	l32i.n	a8, a10, 0
403812a9:	f888      	l32i.n	a8, a8, 60
403812ab:	0c2c      	movi.n	a12, 32
403812ad:	0008e0        	callx8	a8
403812b0:	0a2d      	mov.n	a2, a10
403812b2:	000086        	j	403812b8 <spi_flash_chip_xmic_opi_config_host_io_mode+0x30>
    switch (read_mode & 0xFFFF) {
403812b5:	cd7721        	l32r	a2, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
}
403812b8:	f01d      	retw.n
	...

403812bc <spi_flash_chip_mxic_opi_get_data_length_zoom>:
{
403812bc:	004136        	entry	a1, 32
    assert((io_mode == SPI_FLASH_OPI_STR) || (io_mode == SPI_FLASH_OPI_DTR));
403812bf:	f0c282        	addi	a8, a2, -16
403812c2:	190c      	movi.n	a9, 1
403812c4:	0db987        	bgeu	a9, a8, 403812d5 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x19>
403812c7:	cf97d1        	l32r	a13, 40375124 <_iram_text_start+0xd20> (3fc93dc8 <__FUNCTION__$0+0x510>)
403812ca:	cf97c1        	l32r	a12, 40375128 <_iram_text_start+0xd24> (3fc94750 <__func__$1>)
403812cd:	db5c      	movi.n	a11, 93
403812cf:	cf97a1        	l32r	a10, 4037512c <_iram_text_start+0xd28> (3fc93e27 <__FUNCTION__$0+0x56f>)
403812d2:	feace5        	call8	4037fda0 <__assert_func>
    *length_zoom = (io_mode == SPI_FLASH_OPI_STR) ? 1 : 2;
403812d5:	07b266        	bnei	a2, 16, 403812e0 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x24>
403812d8:	180c      	movi.n	a8, 1
403812da:	000106        	j	403812e2 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x26>
403812dd:	000000        	ill
403812e0:	280c      	movi.n	a8, 2
403812e2:	0389      	s32i.n	a8, a3, 0
}
403812e4:	f01d      	retw.n
	...

403812e8 <spi_flash_chip_mxic_opi_read_id>:
{
403812e8:	00a136        	entry	a1, 80
    uint64_t id_buf = 0;
403812eb:	080c      	movi.n	a8, 0
403812ed:	0189      	s32i.n	a8, a1, 0
403812ef:	1189      	s32i.n	a8, a1, 4
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
403812f1:	b18b      	addi.n	a11, a1, 8
403812f3:	42a8      	l32i.n	a10, a2, 16
403812f5:	fffc65        	call8	403812bc <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
403812f8:	71cb      	addi.n	a7, a1, 12
403812fa:	cc1c      	movi.n	a12, 28
403812fc:	0b0c      	movi.n	a11, 0
403812fe:	07ad      	mov.n	a10, a7
40381300:	cc6481        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381303:	0008e0        	callx8	a8
40381306:	080182        	l8ui	a8, a1, 8
40381309:	909880        	addx2	a9, a8, a8
4038130c:	0e4192        	s8i	a9, a1, 14
4038130f:	092c      	movi.n	a9, 32
40381311:	0f4192        	s8i	a9, a1, 15
40381314:	6119      	s32i.n	a1, a1, 24
40381316:	cf8691        	l32r	a9, 40375130 <_iram_text_start+0xd2c> (609f <UserFrameTotalSize+0x5f9f>)
40381319:	105192        	s16i	a9, a1, 32
4038131c:	1188e0        	slli	a8, a8, 2
4038131f:	224182        	s8i	a8, a1, 34
    chip->host->driver->common_command(chip->host, &t);
40381322:	02a8      	l32i.n	a10, a2, 0
40381324:	0a88      	l32i.n	a8, a10, 0
40381326:	1888      	l32i.n	a8, a8, 4
40381328:	20b770        	or	a11, a7, a7
4038132b:	0008e0        	callx8	a8
    if(chip->read_mode == SPI_FLASH_OPI_DTR) {
4038132e:	4298      	l32i.n	a9, a2, 16
40381330:	181c      	movi.n	a8, 17
40381332:	2c9987        	bne	a9, a8, 40381362 <spi_flash_chip_mxic_opi_read_id+0x7a>
        id_buf = (id_buf & 0xff) | ((id_buf & 0xff0000) >> 8) | ((id_buf & 0xff00000000) >> 16);
40381335:	0188      	l32i.n	a8, a1, 0
40381337:	749080        	extui	a9, a8, 0, 8
4038133a:	41a880        	srli	a10, a8, 8
4038133d:	74a8a0        	extui	a10, a10, 8, 8
40381340:	11aa80        	slli	a10, a10, 8
40381343:	2099a0        	or	a9, a9, a10
40381346:	11a8      	l32i.n	a10, a1, 4
40381348:	11aa00        	slli	a10, a10, 16
4038134b:	f58080        	extui	a8, a8, 16, 16
4038134e:	208a80        	or	a8, a10, a8
40381351:	758080        	extui	a8, a8, 16, 8
40381354:	118800        	slli	a8, a8, 16
40381357:	208980        	or	a8, a9, a8
4038135a:	0189      	s32i.n	a8, a1, 0
4038135c:	00a082        	movi	a8, 0
4038135f:	016182        	s32i	a8, a1, 4
    uint32_t raw_flash_id = __builtin_bswap32(id_buf);
40381362:	0178      	l32i.n	a7, a1, 0
40381364:	07ad      	mov.n	a10, a7
40381366:	cf7581        	l32r	a8, 4037513c <_iram_text_start+0xd38> (400021d8 <__bswapsi2>)
40381369:	0008e0        	callx8	a8
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
4038136c:	01d782        	addmi	a8, a7, 0x100
4038136f:	40f880        	nsau	a8, a8
40381372:	418580        	srli	a8, a8, 5
40381375:	40f770        	nsau	a7, a7
40381378:	417570        	srli	a7, a7, 5
4038137b:	208870        	or	a8, a8, a7
4038137e:	e89c      	beqz.n	a8, 403813a0 <spi_flash_chip_mxic_opi_read_id+0xb8>
40381380:	cc3b81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40381383:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(chip_name, "no response\n");
40381385:	f88c      	beqz.n	a8, 40381398 <spi_flash_chip_mxic_opi_read_id+0xb0>
40381387:	fe8aa5        	call8	4037fc30 <esp_log_timestamp>
4038138a:	cf6ac1        	l32r	a12, 40375134 <_iram_text_start+0xd30> (3fc947fc <chip_name>)
4038138d:	0abd      	mov.n	a11, a10
4038138f:	cf6aa1        	l32r	a10, 40375138 <_iram_text_start+0xd34> (3fc93e44 <__FUNCTION__$0+0x58c>)
40381392:	cc4881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40381395:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_NO_RESPONSE;
40381398:	08a122        	movi	a2, 0x108
4038139b:	000206        	j	403813a7 <spi_flash_chip_mxic_opi_read_id+0xbf>
4038139e:	a00000        	addx4	a0, a0, a0
    *out_chip_id = (raw_flash_id >> 8);
403813a1:	41a8      	l32i.n	a10, a1, 16
403813a3:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
403813a5:	020c      	movi.n	a2, 0
}
403813a7:	f01d      	retw.n
403813a9:	000000        	ill

403813ac <spi_flash_chip_mxic_opi_read_reg>:
{
403813ac:	00a136        	entry	a1, 80
    uint32_t stat_buf = 0;
403813af:	060c      	movi.n	a6, 0
403813b1:	0169      	s32i.n	a6, a1, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
403813b3:	b14b      	addi.n	a11, a1, 4
403813b5:	42a8      	l32i.n	a10, a2, 16
403813b7:	fff065        	call8	403812bc <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
403813ba:	718b      	addi.n	a7, a1, 8
403813bc:	cc1c      	movi.n	a12, 28
403813be:	06bd      	mov.n	a11, a6
403813c0:	07ad      	mov.n	a10, a7
403813c2:	cc3381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403813c5:	0008e0        	callx8	a8
403813c8:	040182        	l8ui	a8, a1, 4
403813cb:	0a4182        	s8i	a8, a1, 10
403813ce:	092c      	movi.n	a9, 32
403813d0:	0b4192        	s8i	a9, a1, 11
403813d3:	5119      	s32i.n	a1, a1, 20
403813d5:	05aa92        	movi	a9, 0xfffffa05
403813d8:	0e5192        	s16i	a9, a1, 28
403813db:	1188e0        	slli	a8, a8, 2
403813de:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
403813e1:	02a8      	l32i.n	a10, a2, 0
403813e3:	0a88      	l32i.n	a8, a10, 0
403813e5:	1888      	l32i.n	a8, a8, 4
403813e7:	07bd      	mov.n	a11, a7
403813e9:	0008e0        	callx8	a8
403813ec:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
403813ee:	3acc      	bnez.n	a10, 403813f5 <spi_flash_chip_mxic_opi_read_reg+0x49>
    *out_reg = (stat_buf & 0xff);
403813f0:	000182        	l8ui	a8, a1, 0
403813f3:	0489      	s32i.n	a8, a4, 0
}
403813f5:	f01d      	retw.n
	...

403813f8 <spi_flash_chip_mxic_opi_get_io_mode>:
{
403813f8:	00a136        	entry	a1, 80
403813fb:	027d      	mov.n	a7, a2
    uint32_t stat_buf = 0;
403813fd:	060c      	movi.n	a6, 0
403813ff:	0169      	s32i.n	a6, a1, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
40381401:	b14b      	addi.n	a11, a1, 4
40381403:	42a8      	l32i.n	a10, a2, 16
40381405:	ffeb65        	call8	403812bc <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
40381408:	218b      	addi.n	a2, a1, 8
4038140a:	cc1c      	movi.n	a12, 28
4038140c:	20b660        	or	a11, a6, a6
4038140f:	20a220        	or	a10, a2, a2
40381412:	cc1f81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381415:	0008e0        	callx8	a8
40381418:	040182        	l8ui	a8, a1, 4
4038141b:	0a4182        	s8i	a8, a1, 10
4038141e:	092c      	movi.n	a9, 32
40381420:	0b4192        	s8i	a9, a1, 11
40381423:	5119      	s32i.n	a1, a1, 20
40381425:	cf4691        	l32r	a9, 40375140 <_iram_text_start+0xd3c> (ffff8e71 <_rtc_reserved_end+0x9fef8e71>)
40381428:	0e5192        	s16i	a9, a1, 28
4038142b:	1188e0        	slli	a8, a8, 2
4038142e:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
40381431:	07a8      	l32i.n	a10, a7, 0
40381433:	0a88      	l32i.n	a8, a10, 0
40381435:	1888      	l32i.n	a8, a8, 4
40381437:	02bd      	mov.n	a11, a2
40381439:	0008e0        	callx8	a8
4038143c:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4038143e:	8aec      	bnez.n	a10, 4038146a <spi_flash_chip_mxic_opi_get_io_mode+0x72>
    switch (stat_buf & 0xff)
40381440:	000182        	l8ui	a8, a1, 0
40381443:	051826        	beqi	a8, 1, 4038144c <spi_flash_chip_mxic_opi_get_io_mode+0x54>
40381446:	0a2826        	beqi	a8, 2, 40381454 <spi_flash_chip_mxic_opi_get_io_mode+0x5c>
40381449:	000386        	j	4038145b <spi_flash_chip_mxic_opi_get_io_mode+0x63>
        *out_io_mode = SPI_FLASH_OPI_STR;
4038144c:	081c      	movi.n	a8, 16
4038144e:	0389      	s32i.n	a8, a3, 0
        break;
40381450:	0002c6        	j	4038145f <spi_flash_chip_mxic_opi_get_io_mode+0x67>
40381453:	181c00        	lsxp	f1, a12, a0
        *out_io_mode = SPI_FLASH_OPI_DTR;
40381456:	0389      	s32i.n	a8, a3, 0
        break;
40381458:	0000c6        	j	4038145f <spi_flash_chip_mxic_opi_get_io_mode+0x67>
        *out_io_mode = 0;
4038145b:	080c      	movi.n	a8, 0
4038145d:	0389      	s32i.n	a8, a3, 0
    if (*out_io_mode != chip->read_mode) {
4038145f:	0398      	l32i.n	a9, a3, 0
40381461:	4788      	l32i.n	a8, a7, 16
40381463:	031987        	beq	a9, a8, 4038146a <spi_flash_chip_mxic_opi_get_io_mode+0x72>
        *out_io_mode = 0;
40381466:	080c      	movi.n	a8, 0
40381468:	0389      	s32i.n	a8, a3, 0
}
4038146a:	f01d      	retw.n

4038146c <spi_flash_chip_mxic_opi_get_write_protect>:
{
4038146c:	006136        	entry	a1, 48
4038146f:	02ad      	mov.n	a10, a2
    assert(out_write_protected!=NULL);
40381471:	d3cc      	bnez.n	a3, 40381482 <spi_flash_chip_mxic_opi_get_write_protect+0x16>
40381473:	cf34d1        	l32r	a13, 40375144 <_iram_text_start+0xd40> (3fc93e60 <__FUNCTION__$0+0x5a8>)
40381476:	cf34c1        	l32r	a12, 40375148 <_iram_text_start+0xd44> (3fc94724 <__func__$0>)
40381479:	9ea0b2        	movi	a11, 158
4038147c:	cf2ca1        	l32r	a10, 4037512c <_iram_text_start+0xd28> (3fc93e27 <__FUNCTION__$0+0x56f>)
4038147f:	fe9225        	call8	4037fda0 <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
40381482:	1288      	l32i.n	a8, a2, 4
40381484:	192882        	l32i	a8, a8, 100
40381487:	01cd      	mov.n	a12, a1
40381489:	1b0c      	movi.n	a11, 1
4038148b:	0008e0        	callx8	a8
4038148e:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40381490:	eacc      	bnez.n	a10, 403814a2 <spi_flash_chip_mxic_opi_get_write_protect+0x36>
    *out_write_protected = ((status & SR_WREN) == 0);
40381492:	280c      	movi.n	a8, 2
40381494:	0198      	l32i.n	a9, a1, 0
40381496:	108890        	and	a8, a8, a9
40381499:	40f880        	nsau	a8, a8
4038149c:	418580        	srli	a8, a8, 5
4038149f:	004382        	s8i	a8, a3, 0
}
403814a2:	f01d      	retw.n

403814a4 <spi_flash_chip_mxic_opi_write>:
{
403814a4:	010136        	entry	a1, 128
403814a7:	026d      	mov.n	a6, a2
403814a9:	146132        	s32i	a3, a1, 80
    const uint32_t page_size = chip->chip_drv->page_size;
403814ac:	1288      	l32i.n	a8, a2, 4
403814ae:	132882        	l32i	a8, a8, 76
403814b1:	156182        	s32i	a8, a1, 84
    esp_err_t err = ESP_OK;
403814b4:	0a0c      	movi.n	a10, 0
    while (err == ESP_OK && length > 0) {
403814b6:	001f06        	j	40381536 <spi_flash_chip_mxic_opi_write+0x92>
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
403814b9:	214b      	addi.n	a2, a1, 4
403814bb:	0c4c      	movi.n	a12, 64
403814bd:	ffa0b2        	movi	a11, 255
403814c0:	02ad      	mov.n	a10, a2
403814c2:	cbf381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403814c5:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
403814c8:	06a8      	l32i.n	a10, a6, 0
403814ca:	0a88      	l32i.n	a8, a10, 0
403814cc:	a888      	l32i.n	a8, a8, 40
403814ce:	1521e2        	l32i	a14, a1, 84
403814d1:	01dd      	mov.n	a13, a1
403814d3:	05cd      	mov.n	a12, a5
403814d5:	04bd      	mov.n	a11, a4
403814d7:	0008e0        	callx8	a8
403814da:	0a9d      	mov.n	a9, a10
403814dc:	1661a2        	s32i	a10, a1, 88
        uint32_t left_off = address - align_address;
403814df:	0188      	l32i.n	a8, a1, 0
403814e1:	c0a480        	sub	a10, a4, a8
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
403814e4:	745a      	add.n	a7, a4, a5
403814e6:	889a      	add.n	a8, a8, a9
403814e8:	637780        	minu	a7, a7, a8
403814eb:	c08740        	sub	a8, a7, a4
403814ee:	176182        	s32i	a8, a1, 92
        memcpy(temp_buffer + left_off, buffer, write_len);
403814f1:	08cd      	mov.n	a12, a8
403814f3:	1421b2        	l32i	a11, a1, 80
403814f6:	a2aa      	add.n	a10, a2, a10
403814f8:	cbf781        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403814fb:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
403814fe:	1688      	l32i.n	a8, a6, 4
40381500:	b888      	l32i.n	a8, a8, 44
40381502:	0b0c      	movi.n	a11, 0
40381504:	06ad      	mov.n	a10, a6
40381506:	0008e0        	callx8	a8
        if (err == ESP_OK && length > 0) {
40381509:	40fa80        	nsau	a8, a10
4038150c:	418580        	srli	a8, a8, 5
4038150f:	230837        	bnone	a8, a3, 40381536 <spi_flash_chip_mxic_opi_write+0x92>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
40381512:	1688      	l32i.n	a8, a6, 4
40381514:	122882        	l32i	a8, a8, 72
40381517:	1621d2        	l32i	a13, a1, 88
4038151a:	01c8      	l32i.n	a12, a1, 0
4038151c:	20b220        	or	a11, a2, a2
4038151f:	06ad      	mov.n	a10, a6
40381521:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + write_len);
40381524:	142182        	l32i	a8, a1, 80
40381527:	172192        	l32i	a9, a1, 92
4038152a:	889a      	add.n	a8, a8, a9
4038152c:	146182        	s32i	a8, a1, 80
            length -= write_len;
4038152f:	c04470        	sub	a4, a4, a7
40381532:	554a      	add.n	a5, a5, a4
            address += write_len;
40381534:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
40381536:	130c      	movi.n	a3, 1
40381538:	833550        	moveqz	a3, a5, a5
4038153b:	1acc      	bnez.n	a10, 40381540 <spi_flash_chip_mxic_opi_write+0x9c>
4038153d:	f78356        	bnez	a3, 403814b9 <spi_flash_chip_mxic_opi_write+0x15>
}
40381540:	0a2d      	mov.n	a2, a10
40381542:	f01d      	retw.n

40381544 <spi_flash_chip_mxic_opi_probe>:
{
40381544:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40381547:	f53030        	extui	a3, a3, 16, 16
4038154a:	c2a082        	movi	a8, 194
4038154d:	0b9387        	bne	a3, a8, 4038155c <spi_flash_chip_mxic_opi_probe+0x18>
    if (chip->read_mode < SPI_FLASH_OPI_FLAG) {
40381550:	4288      	l32i.n	a8, a2, 16
40381552:	f90c      	movi.n	a9, 15
40381554:	0cb987        	bgeu	a9, a8, 40381564 <spi_flash_chip_mxic_opi_probe+0x20>
    return ESP_OK;
40381557:	020c      	movi.n	a2, 0
40381559:	000286        	j	40381567 <spi_flash_chip_mxic_opi_probe+0x23>
        return ESP_ERR_NOT_FOUND;
4038155c:	05a122        	movi	a2, 0x105
4038155f:	000106        	j	40381567 <spi_flash_chip_mxic_opi_probe+0x23>
40381562:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
40381565:	1d05a1        	l32r	a10, 4034897c <rom_rx_gain_force+0x342550>
}
40381568:	0000f0        	callx12	a0
	...

4038156c <spi_flash_chip_mxic_opi_get_caps>:
{
4038156c:	004136        	entry	a1, 32
}
4038156f:	220c      	movi.n	a2, 2
40381571:	f01d      	retw.n
	...

40381574 <spi_flash_chip_xmic_opi_set_io_mode>:
{
40381574:	004136        	entry	a1, 32
}
40381577:	020c      	movi.n	a2, 0
40381579:	f01d      	retw.n
	...

4038157c <spi_flash_chip_th_probe>:
#include <stdlib.h>
#include "spi_flash_chip_generic.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_th_probe(esp_flash_t *chip, uint32_t flash_id)
{
4038157c:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0xcd;
    if (flash_id >> 16 != MFG_ID) {
4038157f:	f59030        	extui	a9, a3, 16, 16
40381582:	cda082        	movi	a8, 205
40381585:	109987        	bne	a9, a8, 40381599 <spi_flash_chip_th_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x6000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
40381588:	743830        	extui	a3, a3, 8, 8
4038158b:	113380        	slli	a3, a3, 8
4038158e:	cecc81        	l32r	a8, 403750c0 <_iram_text_start+0xcbc> (6000 <UserFrameTotalSize+0x5f00>)
40381591:	0b9387        	bne	a3, a8, 403815a0 <spi_flash_chip_th_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
40381594:	020c      	movi.n	a2, 0
40381596:	000246        	j	403815a3 <spi_flash_chip_th_probe+0x27>
        return ESP_ERR_NOT_FOUND;
40381599:	05a122        	movi	a2, 0x105
4038159c:	0000c6        	j	403815a3 <spi_flash_chip_th_probe+0x27>
4038159f:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
403815a2:	f01d05        	call0	40371774 <rom_rx_gain_force+0x36b348>
403815a5:	000000        	ill

403815a8 <spi_flash_chip_th_get_caps>:
}

spi_flash_caps_t spi_flash_chip_th_get_caps(esp_flash_t *chip)
{
403815a8:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
403815ab:	420c      	movi.n	a2, 4
403815ad:	f01d      	retw.n
	...

403815b0 <spi_flash_chip_winbond_suspend_cmd_conf>:
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}

esp_err_t spi_flash_chip_winbond_suspend_cmd_conf(esp_flash_t *chip)
{
403815b0:	006136        	entry	a1, 48
    spi_flash_sus_cmd_conf sus_conf = {
403815b3:	8c0c      	movi.n	a12, 8
403815b5:	00a0b2        	movi	a11, 0
403815b8:	01ad      	mov.n	a10, a1
403815ba:	cbb581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403815bd:	0008e0        	callx8	a8
403815c0:	80a082        	movi	a8, 128
403815c3:	0189      	s32i.n	a8, a1, 0
403815c5:	583c      	movi.n	a8, 53
403815c7:	044182        	s8i	a8, a1, 4
403815ca:	75a082        	movi	a8, 117
403815cd:	054182        	s8i	a8, a1, 5
403815d0:	7aa082        	movi	a8, 122
403815d3:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
403815d6:	02a8      	l32i.n	a10, a2, 0
403815d8:	0a88      	l32i.n	a8, a10, 0
403815da:	152882        	l32i	a8, a8, 84
403815dd:	01bd      	mov.n	a11, a1
403815df:	0008e0        	callx8	a8
}
403815e2:	0a2d      	mov.n	a2, a10
403815e4:	f01d      	retw.n
	...

403815e8 <spi_flash_command_winbond_program_4B>:
    .config_host_io_mode = spi_flash_chip_generic_config_host_io_mode,
};


static esp_err_t spi_flash_command_winbond_program_4B(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
403815e8:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(address);
    spi_flash_trans_t t = {
403815eb:	cc1c      	movi.n	a12, 28
403815ed:	0b0c      	movi.n	a11, 0
403815ef:	20a110        	or	a10, a1, a1
403815f2:	cba781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403815f5:	0008e0        	callx8	a8
403815f8:	014152        	s8i	a5, a1, 1
403815fb:	cea581        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403815fe:	04b847        	bgeu	a8, a4, 40381606 <spi_flash_command_winbond_program_4B+0x1e>
40381601:	082c      	movi.n	a8, 32
40381603:	000046        	j	40381608 <spi_flash_command_winbond_program_4B+0x20>
40381606:	881c      	movi.n	a8, 24
40381608:	034182        	s8i	a8, a1, 3
4038160b:	1149      	s32i.n	a4, a1, 4
4038160d:	2139      	s32i.n	a3, a1, 8
4038160f:	880c      	movi.n	a8, 8
40381611:	4189      	s32i.n	a8, a1, 16
40381613:	ce9f81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
40381616:	04b847        	bgeu	a8, a4, 4038161e <spi_flash_command_winbond_program_4B+0x36>
40381619:	281c      	movi.n	a8, 18
4038161b:	000046        	j	40381620 <spi_flash_command_winbond_program_4B+0x38>
4038161e:	280c      	movi.n	a8, 2
40381620:	0a5182        	s16i	a8, a1, 20
        .address = address,
        .mosi_len = length,
        .mosi_data = buffer,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
40381623:	02a8      	l32i.n	a10, a2, 0
40381625:	0a88      	l32i.n	a8, a10, 0
40381627:	1888      	l32i.n	a8, a8, 4
40381629:	01bd      	mov.n	a11, a1
4038162b:	0008e0        	callx8	a8
}
4038162e:	0a2d      	mov.n	a2, a10
40381630:	f01d      	retw.n
	...

40381634 <spi_flash_chip_winbond_page_program>:
{
40381634:	004136        	entry	a1, 32
40381637:	027d      	mov.n	a7, a2
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381639:	1288      	l32i.n	a8, a2, 4
4038163b:	152892        	l32i	a9, a8, 84
4038163e:	1888      	l32i.n	a8, a8, 4
40381640:	08b8      	l32i.n	a11, a8, 0
40381642:	02ad      	mov.n	a10, a2
40381644:	0009e0        	callx8	a9
40381647:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381649:	40fa90        	nsau	a9, a10
4038164c:	419590        	srli	a9, a9, 5
4038164f:	faae82        	movi	a8, 0xfffffefa
40381652:	8a8a      	add.n	a8, a10, a8
40381654:	40f880        	nsau	a8, a8
40381657:	418580        	srli	a8, a8, 5
4038165a:	209980        	or	a9, a9, a8
4038165d:	99bc      	beqz.n	a9, 4038169a <spi_flash_chip_winbond_page_program+0x66>
        err = spi_flash_command_winbond_program_4B(chip, buffer, address, length);
4038165f:	05dd      	mov.n	a13, a5
40381661:	04cd      	mov.n	a12, a4
40381663:	03bd      	mov.n	a11, a3
40381665:	07ad      	mov.n	a10, a7
40381667:	fff825        	call8	403815e8 <spi_flash_command_winbond_program_4B>
4038166a:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
4038166c:	aaec      	bnez.n	a10, 4038169a <spi_flash_chip_winbond_page_program+0x66>
        chip->busy = 1;
4038166e:	7788      	l32i.n	a8, a7, 28
40381670:	190c      	movi.n	a9, 1
40381672:	208890        	or	a8, a8, a9
40381675:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40381677:	1788      	l32i.n	a8, a7, 4
40381679:	152892        	l32i	a9, a8, 84
4038167c:	1888      	l32i.n	a8, a8, 4
4038167e:	48b8      	l32i.n	a11, a8, 16
40381680:	07ad      	mov.n	a10, a7
40381682:	0009e0        	callx8	a9
40381685:	0a2d      	mov.n	a2, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381687:	06a182        	movi	a8, 0x106
4038168a:	0c9a87        	bne	a10, a8, 4038169a <spi_flash_chip_winbond_page_program+0x66>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038168d:	1788      	l32i.n	a8, a7, 4
4038168f:	b888      	l32i.n	a8, a8, 44
40381691:	1b0c      	movi.n	a11, 1
40381693:	07ad      	mov.n	a10, a7
40381695:	0008e0        	callx8	a8
40381698:	0a2d      	mov.n	a2, a10
}
4038169a:	f01d      	retw.n

4038169c <spi_flash_command_winbond_erase_sector_4B>:

esp_err_t spi_flash_command_winbond_erase_sector_4B(esp_flash_t *chip, uint32_t start_address)
{
4038169c:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(start_address);
    spi_flash_trans_t t = {
4038169f:	cc1c      	movi.n	a12, 28
403816a1:	0b0c      	movi.n	a11, 0
403816a3:	20a110        	or	a10, a1, a1
403816a6:	cb7a81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403816a9:	0008e0        	callx8	a8
403816ac:	ce7981        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403816af:	05b837        	bgeu	a8, a3, 403816b8 <spi_flash_command_winbond_erase_sector_4B+0x1c>
403816b2:	082c      	movi.n	a8, 32
403816b4:	000086        	j	403816ba <spi_flash_command_winbond_erase_sector_4B+0x1e>
403816b7:	881c00        	lsi	f0, a12, 0x220
403816ba:	034182        	s8i	a8, a1, 3
403816bd:	1139      	s32i.n	a3, a1, 4
403816bf:	880c      	movi.n	a8, 8
403816c1:	4189      	s32i.n	a8, a1, 16
403816c3:	ce7381        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403816c6:	04b837        	bgeu	a8, a3, 403816ce <spi_flash_command_winbond_erase_sector_4B+0x32>
403816c9:	182c      	movi.n	a8, 33
403816cb:	000046        	j	403816d0 <spi_flash_command_winbond_erase_sector_4B+0x34>
403816ce:	082c      	movi.n	a8, 32
403816d0:	0a5182        	s16i	a8, a1, 20
        .command = (addr_4b? CMD_SECTOR_ERASE_4B: CMD_SECTOR_ERASE),
        .address_bitlen = (addr_4b? 32: 24),
        .address = start_address,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
403816d3:	02a8      	l32i.n	a10, a2, 0
403816d5:	0a88      	l32i.n	a8, a10, 0
403816d7:	1888      	l32i.n	a8, a8, 4
403816d9:	01bd      	mov.n	a11, a1
403816db:	0008e0        	callx8	a8
}
403816de:	0a2d      	mov.n	a2, a10
403816e0:	f01d      	retw.n
	...

403816e4 <spi_flash_chip_winbond_erase_sector>:
{
403816e4:	004136        	entry	a1, 32
403816e7:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
403816e9:	1288      	l32i.n	a8, a2, 4
403816eb:	b888      	l32i.n	a8, a8, 44
403816ed:	0b0c      	movi.n	a11, 0
403816ef:	02ad      	mov.n	a10, a2
403816f1:	0008e0        	callx8	a8
403816f4:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
403816f6:	eacc      	bnez.n	a10, 40381708 <spi_flash_chip_winbond_erase_sector+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403816f8:	1788      	l32i.n	a8, a7, 4
403816fa:	152892        	l32i	a9, a8, 84
403816fd:	1888      	l32i.n	a8, a8, 4
403816ff:	08b8      	l32i.n	a11, a8, 0
40381701:	07ad      	mov.n	a10, a7
40381703:	0009e0        	callx8	a9
40381706:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381708:	40f290        	nsau	a9, a2
4038170b:	419590        	srli	a9, a9, 5
4038170e:	faae82        	movi	a8, 0xfffffefa
40381711:	828a      	add.n	a8, a2, a8
40381713:	40f880        	nsau	a8, a8
40381716:	418580        	srli	a8, a8, 5
40381719:	209980        	or	a9, a9, a8
4038171c:	068916        	beqz	a9, 40381788 <spi_flash_chip_winbond_erase_sector+0xa4>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
4038171f:	2788      	l32i.n	a8, a7, 8
40381721:	9888      	l32i.n	a8, a8, 36
40381723:	388c      	beqz.n	a8, 4038172a <spi_flash_chip_winbond_erase_sector+0x46>
40381725:	1a0c      	movi.n	a10, 1
40381727:	0008e0        	callx8	a8
        err = spi_flash_command_winbond_erase_sector_4B(chip, start_address);
4038172a:	20b330        	or	a11, a3, a3
4038172d:	20a770        	or	a10, a7, a7
40381730:	fff6a5        	call8	4038169c <spi_flash_command_winbond_erase_sector_4B>
40381733:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
40381736:	04ea56        	bnez	a10, 40381788 <spi_flash_chip_winbond_erase_sector+0xa4>
        chip->busy = 1;
40381739:	7788      	l32i.n	a8, a7, 28
4038173b:	190c      	movi.n	a9, 1
4038173d:	208890        	or	a8, a8, a9
40381740:	7789      	s32i.n	a8, a7, 28
        if (chip->host->driver->flush_cache) {
40381742:	07a8      	l32i.n	a10, a7, 0
40381744:	0a88      	l32i.n	a8, a10, 0
40381746:	112882        	l32i	a8, a8, 68
40381749:	b88c      	beqz.n	a8, 40381758 <spi_flash_chip_winbond_erase_sector+0x74>
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->sector_size);
4038174b:	1798      	l32i.n	a9, a7, 4
4038174d:	89c8      	l32i.n	a12, a9, 32
4038174f:	03bd      	mov.n	a11, a3
40381751:	0008e0        	callx8	a8
40381754:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
40381756:	eaec      	bnez.n	a10, 40381788 <spi_flash_chip_winbond_erase_sector+0xa4>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
40381758:	1788      	l32i.n	a8, a7, 4
4038175a:	152892        	l32i	a9, a8, 84
4038175d:	1888      	l32i.n	a8, a8, 4
4038175f:	38b8      	l32i.n	a11, a8, 12
40381761:	07ad      	mov.n	a10, a7
40381763:	0009e0        	callx8	a9
40381766:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40381768:	2788      	l32i.n	a8, a7, 8
4038176a:	9888      	l32i.n	a8, a8, 36
4038176c:	488c      	beqz.n	a8, 40381774 <spi_flash_chip_winbond_erase_sector+0x90>
4038176e:	00a0a2        	movi	a10, 0
40381771:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381774:	06a182        	movi	a8, 0x106
40381777:	0d9287        	bne	a2, a8, 40381788 <spi_flash_chip_winbond_erase_sector+0xa4>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038177a:	1788      	l32i.n	a8, a7, 4
4038177c:	b888      	l32i.n	a8, a8, 44
4038177e:	1b0c      	movi.n	a11, 1
40381780:	20a770        	or	a10, a7, a7
40381783:	0008e0        	callx8	a8
40381786:	0a2d      	mov.n	a2, a10
}
40381788:	f01d      	retw.n
	...

4038178c <spi_flash_command_erase_block_4B>:

esp_err_t spi_flash_command_erase_block_4B(esp_flash_t *chip, uint32_t start_address)
{
4038178c:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(start_address);
    spi_flash_trans_t t = {
4038178f:	cc1c      	movi.n	a12, 28
40381791:	0b0c      	movi.n	a11, 0
40381793:	20a110        	or	a10, a1, a1
40381796:	cb3e81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381799:	0008e0        	callx8	a8
4038179c:	ce3d81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
4038179f:	05b837        	bgeu	a8, a3, 403817a8 <spi_flash_command_erase_block_4B+0x1c>
403817a2:	082c      	movi.n	a8, 32
403817a4:	000086        	j	403817aa <spi_flash_command_erase_block_4B+0x1e>
403817a7:	881c00        	lsi	f0, a12, 0x220
403817aa:	034182        	s8i	a8, a1, 3
403817ad:	1139      	s32i.n	a3, a1, 4
403817af:	880c      	movi.n	a8, 8
403817b1:	4189      	s32i.n	a8, a1, 16
403817b3:	ce3781        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403817b6:	06b837        	bgeu	a8, a3, 403817c0 <spi_flash_command_erase_block_4B+0x34>
403817b9:	dca082        	movi	a8, 220
403817bc:	0000c6        	j	403817c3 <spi_flash_command_erase_block_4B+0x37>
403817bf:	a08200        	addx4	a8, a2, a0
403817c2:	82d8      	l32i.n	a13, a2, 32
403817c4:	a80a51        	l32r	a5, 4036b7ec <rom_rx_gain_force+0x3653c0>
        .command = (addr_4b? CMD_LARGE_BLOCK_ERASE_4B: CMD_LARGE_BLOCK_ERASE),
        .address_bitlen = (addr_4b? 32: 24),
        .address = start_address,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
403817c7:	0a8802        	lsi	f0, a8, 40
403817ca:	1888      	l32i.n	a8, a8, 4
403817cc:	01bd      	mov.n	a11, a1
403817ce:	0008e0        	callx8	a8
}
403817d1:	0a2d      	mov.n	a2, a10
403817d3:	f01d      	retw.n
403817d5:	000000        	ill

403817d8 <spi_flash_chip_winbond_erase_block>:
{
403817d8:	004136        	entry	a1, 32
403817db:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
403817dd:	1288      	l32i.n	a8, a2, 4
403817df:	b888      	l32i.n	a8, a8, 44
403817e1:	0b0c      	movi.n	a11, 0
403817e3:	02ad      	mov.n	a10, a2
403817e5:	0008e0        	callx8	a8
403817e8:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
403817ea:	eacc      	bnez.n	a10, 403817fc <spi_flash_chip_winbond_erase_block+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403817ec:	1788      	l32i.n	a8, a7, 4
403817ee:	152892        	l32i	a9, a8, 84
403817f1:	1888      	l32i.n	a8, a8, 4
403817f3:	08b8      	l32i.n	a11, a8, 0
403817f5:	07ad      	mov.n	a10, a7
403817f7:	0009e0        	callx8	a9
403817fa:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403817fc:	40f290        	nsau	a9, a2
403817ff:	419590        	srli	a9, a9, 5
40381802:	faae82        	movi	a8, 0xfffffefa
40381805:	828a      	add.n	a8, a2, a8
40381807:	40f880        	nsau	a8, a8
4038180a:	418580        	srli	a8, a8, 5
4038180d:	209980        	or	a9, a9, a8
40381810:	068916        	beqz	a9, 4038187c <spi_flash_chip_winbond_erase_block+0xa4>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40381813:	2788      	l32i.n	a8, a7, 8
40381815:	9888      	l32i.n	a8, a8, 36
40381817:	388c      	beqz.n	a8, 4038181e <spi_flash_chip_winbond_erase_block+0x46>
40381819:	1a0c      	movi.n	a10, 1
4038181b:	0008e0        	callx8	a8
        err = spi_flash_command_erase_block_4B(chip, start_address);
4038181e:	20b330        	or	a11, a3, a3
40381821:	20a770        	or	a10, a7, a7
40381824:	fff665        	call8	4038178c <spi_flash_command_erase_block_4B>
40381827:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
4038182a:	04ea56        	bnez	a10, 4038187c <spi_flash_chip_winbond_erase_block+0xa4>
        chip->busy = 1;
4038182d:	7788      	l32i.n	a8, a7, 28
4038182f:	190c      	movi.n	a9, 1
40381831:	208890        	or	a8, a8, a9
40381834:	7789      	s32i.n	a8, a7, 28
        if (chip->host->driver->flush_cache) {
40381836:	07a8      	l32i.n	a10, a7, 0
40381838:	0a88      	l32i.n	a8, a10, 0
4038183a:	112882        	l32i	a8, a8, 68
4038183d:	b88c      	beqz.n	a8, 4038184c <spi_flash_chip_winbond_erase_block+0x74>
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->block_erase_size);
4038183f:	1798      	l32i.n	a9, a7, 4
40381841:	99c8      	l32i.n	a12, a9, 36
40381843:	03bd      	mov.n	a11, a3
40381845:	0008e0        	callx8	a8
40381848:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
4038184a:	eaec      	bnez.n	a10, 4038187c <spi_flash_chip_winbond_erase_block+0xa4>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
4038184c:	1788      	l32i.n	a8, a7, 4
4038184e:	152892        	l32i	a9, a8, 84
40381851:	1888      	l32i.n	a8, a8, 4
40381853:	28b8      	l32i.n	a11, a8, 8
40381855:	07ad      	mov.n	a10, a7
40381857:	0009e0        	callx8	a9
4038185a:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
4038185c:	2788      	l32i.n	a8, a7, 8
4038185e:	9888      	l32i.n	a8, a8, 36
40381860:	488c      	beqz.n	a8, 40381868 <spi_flash_chip_winbond_erase_block+0x90>
40381862:	00a0a2        	movi	a10, 0
40381865:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381868:	06a182        	movi	a8, 0x106
4038186b:	0d9287        	bne	a2, a8, 4038187c <spi_flash_chip_winbond_erase_block+0xa4>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038186e:	1788      	l32i.n	a8, a7, 4
40381870:	b888      	l32i.n	a8, a8, 44
40381872:	1b0c      	movi.n	a11, 1
40381874:	20a770        	or	a10, a7, a7
40381877:	0008e0        	callx8	a8
4038187a:	0a2d      	mov.n	a2, a10
}
4038187c:	f01d      	retw.n
	...

40381880 <spi_flash_chip_winbond_read>:
{
40381880:	010136        	entry	a1, 128
    const uint32_t page_size = chip->chip_drv->page_size;
40381883:	1288      	l32i.n	a8, a2, 4
40381885:	132892        	l32i	a9, a8, 76
40381888:	176192        	s32i	a9, a1, 92
    if (REGION_32BIT(address, length)) {
4038188b:	945a      	add.n	a9, a4, a5
4038188d:	cc09a1        	l32r	a10, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
40381890:	063a97        	bltu	a10, a9, 4038189a <spi_flash_chip_winbond_read+0x1a>
    uint32_t config_io_flags = 0;
40381893:	0b0c      	movi.n	a11, 0
40381895:	000106        	j	4038189d <spi_flash_chip_winbond_read+0x1d>
40381898:	b20000        	mulsh	a0, a0, a0
        config_io_flags |= SPI_FLASH_CONFIG_IO_MODE_32B_ADDR;
4038189b:	8201a0        	mull	a0, a1, a10
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
4038189e:	1e28      	l32i.n	a2, a14, 4
403818a0:	20a220        	or	a10, a2, a2
403818a3:	0008e0        	callx8	a8
403818a6:	1561a2        	s32i	a10, a1, 84
    if (err == ESP_ERR_NOT_SUPPORTED) {
403818a9:	06a182        	movi	a8, 0x106
403818ac:	021a87        	beq	a10, a8, 403818b2 <spi_flash_chip_winbond_read+0x32>
403818af:	001e46        	j	4038192c <spi_flash_chip_winbond_read+0xac>
        ESP_LOGE(TAG, "configure host io mode failed - unsupported");
403818b2:	fe37e5        	call8	4037fc30 <esp_log_timestamp>
403818b5:	ce25b1        	l32r	a11, 4037514c <_iram_text_start+0xd48> (3fc9490c <TAG>)
403818b8:	20ebb0        	or	a14, a11, a11
403818bb:	0add      	mov.n	a13, a10
403818bd:	ce24c1        	l32r	a12, 40375150 <_iram_text_start+0xd4c> (3fc93ca0 <__FUNCTION__$0+0x3e8>)
403818c0:	1a0c      	movi.n	a10, 1
403818c2:	fe3b65        	call8	4037fc78 <esp_log_write>
        return err;
403818c5:	001c06        	j	40381939 <spi_flash_chip_winbond_read+0xb9>
403818c8:	614b00        	lsi	f0, a11, 0x184
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
403818cb:	0c4c      	movi.n	a12, 64
403818cd:	ffa0b2        	movi	a11, 255
403818d0:	06ad      	mov.n	a10, a6
403818d2:	caef81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403818d5:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
403818d8:	02a8      	l32i.n	a10, a2, 0
403818da:	0a88      	l32i.n	a8, a10, 0
403818dc:	d888      	l32i.n	a8, a8, 52
403818de:	1721e2        	l32i	a14, a1, 92
403818e1:	01dd      	mov.n	a13, a1
403818e3:	05cd      	mov.n	a12, a5
403818e5:	04bd      	mov.n	a11, a4
403818e7:	0008e0        	callx8	a8
403818ea:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
403818ec:	01c8      	l32i.n	a12, a1, 0
403818ee:	c084c0        	sub	a8, a4, a12
403818f1:	166182        	s32i	a8, a1, 88
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
403818f4:	754a      	add.n	a7, a5, a4
403818f6:	8caa      	add.n	a8, a12, a10
403818f8:	637780        	minu	a7, a7, a8
403818fb:	c08740        	sub	a8, a7, a4
403818fe:	146182        	s32i	a8, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
40381901:	02a8      	l32i.n	a10, a2, 0
40381903:	0a88      	l32i.n	a8, a10, 0
40381905:	b888      	l32i.n	a8, a8, 44
40381907:	20b660        	or	a11, a6, a6
4038190a:	0008e0        	callx8	a8
4038190d:	1561a2        	s32i	a10, a1, 84
        memcpy(buffer, temp_buffer + left_off, data_len);
40381910:	1421c2        	l32i	a12, a1, 80
40381913:	162192        	l32i	a9, a1, 88
40381916:	b69a      	add.n	a11, a6, a9
40381918:	03ad      	mov.n	a10, a3
4038191a:	caee81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4038191d:	0008e0        	callx8	a8
        buffer = (void *)((intptr_t)buffer + data_len);
40381920:	142182        	l32i	a8, a1, 80
40381923:	338a      	add.n	a3, a3, a8
        length = length - data_len;
40381925:	c04470        	sub	a4, a4, a7
40381928:	554a      	add.n	a5, a5, a4
        address += data_len;
4038192a:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
4038192c:	180c      	movi.n	a8, 1
4038192e:	838550        	moveqz	a8, a5, a5
40381931:	152192        	l32i	a9, a1, 84
40381934:	19cc      	bnez.n	a9, 40381939 <spi_flash_chip_winbond_read+0xb9>
40381936:	f8f856        	bnez	a8, 403818c9 <spi_flash_chip_winbond_read+0x49>
}
40381939:	152122        	l32i	a2, a1, 84
4038193c:	f01d      	retw.n
	...

40381940 <spi_flash_chip_winbond_probe>:
{
40381940:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40381943:	f53030        	extui	a3, a3, 16, 16
40381946:	efa082        	movi	a8, 239
40381949:	049387        	bne	a3, a8, 40381951 <spi_flash_chip_winbond_probe+0x11>
    return ESP_OK;
4038194c:	020c      	movi.n	a2, 0
4038194e:	000086        	j	40381954 <spi_flash_chip_winbond_probe+0x14>
        return ESP_ERR_NOT_FOUND;
40381951:	05a122        	movi	a2, 0x105
}
40381954:	f01d      	retw.n
	...

40381958 <spi_flash_chip_winbond_get_caps>:
{
40381958:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
4038195b:	180282        	l8ui	a8, a2, 24
4038195e:	891c      	movi.n	a9, 24
40381960:	043987        	bltu	a9, a8, 40381968 <spi_flash_chip_winbond_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
40381963:	020c      	movi.n	a2, 0
40381965:	000046        	j	4038196a <spi_flash_chip_winbond_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_32MB_SUPPORT;
40381968:	220c      	movi.n	a2, 2
}
4038196a:	480c      	movi.n	a8, 4
4038196c:	202280        	or	a2, a2, a8
4038196f:	f01d      	retw.n
40381971:	000000        	ill

40381974 <spi_flash_enable_high_performance_mode>:
//!CONFIG_SPI_FLASH_UNDER_HIGH_FREQ

static spi_flash_hpm_dummy_conf_t s_dummy_conf;

esp_err_t spi_flash_enable_high_performance_mode(void)
{
40381974:	004136        	entry	a1, 32
    return ESP_OK;
}
40381977:	020c      	movi.n	a2, 0
40381979:	f01d      	retw.n
	...

4038197c <s_register_rom_function>:
extern const spiflash_legacy_funcs_t *rom_spiflash_legacy_funcs;
static uint32_t s_chip_id;


static void s_register_rom_function(void)
{
4038197c:	004136        	entry	a1, 32
        .write = esp_rom_opiflash_write,
        .wait_idle = esp_rom_opiflash_wait_idle,
        .wren = esp_rom_opiflash_wren,
        .erase_area = esp_rom_opiflash_erase_area,
    };
    rom_spiflash_legacy_funcs = &rom_func;
4038197f:	cdf581        	l32r	a8, 40375154 <_iram_text_start+0xd50> (3fceffe8 <rom_spiflash_legacy_funcs>)
40381982:	cdf591        	l32r	a9, 40375158 <_iram_text_start+0xd54> (3fc92730 <rom_func$0>)
40381985:	0899      	s32i.n	a9, a8, 0
}
40381987:	f01d      	retw.n
40381989:	000000        	ill

4038198c <s_set_pin_drive_capability>:
                              ESP_ROM_OPIFLASH_SEL_CS0,
                              false);
}

static void s_set_pin_drive_capability(uint8_t drv)
{
4038198c:	004136        	entry	a1, 32
    //flash clock
    REG_SET_FIELD(SPI_MEM_DATE_REG(0), SPI_MEM_SPI_FMEM_SPICLK_FUN_DRV, 3);
4038198f:	cbf191        	l32r	a9, 40374954 <_iram_text_start+0x550> (600033fc <SPIMEM0+0x3fc>)
40381992:	0020c0        	memw
40381995:	0988      	l32i.n	a8, a9, 0
40381997:	ca0c      	movi.n	a10, 12
40381999:	2088a0        	or	a8, a8, a10
4038199c:	0020c0        	memw
4038199f:	0989      	s32i.n	a8, a9, 0
    //cs0
    PIN_SET_DRV(IO_MUX_GPIO29_REG, 3);
403819a1:	cdee91        	l32r	a9, 4037515c <_iram_text_start+0xd58> (60009078 <SENS+0x878>)
403819a4:	0020c0        	memw
403819a7:	0988      	l32i.n	a8, a9, 0
403819a9:	cbeca1        	l32r	a10, 4037495c <_iram_text_start+0x558> (c00 <UserFrameTotalSize+0xb00>)
403819ac:	2088a0        	or	a8, a8, a10
403819af:	0020c0        	memw
403819b2:	0989      	s32i.n	a8, a9, 0
}
403819b4:	f01d      	retw.n
	...

403819b8 <s_probe_mxic_chip>:
{
403819b8:	004136        	entry	a1, 32
    if (chip_id >> 16 != ESP_FLASH_CHIP_MXIC_OCT) {
403819bb:	f59020        	extui	a9, a2, 16, 16
403819be:	c2a082        	movi	a8, 194
403819c1:	379987        	bne	a9, a8, 403819fc <s_probe_mxic_chip+0x44>
    if (((chip_id >> 8) & 0xf0) != 0x80) {
403819c4:	342c20        	extui	a2, a2, 12, 4
403819c7:	112240        	slli	a2, a2, 12
403819ca:	caa281        	l32r	a8, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
403819cd:	1f1287        	beq	a2, a8, 403819f0 <s_probe_mxic_chip+0x38>
403819d0:	caa781        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
403819d3:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Detected MXIC Flash, but memory type is not Octal");
403819d5:	f88c      	beqz.n	a8, 403819e8 <s_probe_mxic_chip+0x30>
403819d7:	fe25a5        	call8	4037fc30 <esp_log_timestamp>
403819da:	cde1c1        	l32r	a12, 40375160 <_iram_text_start+0xd5c> (3fc93bf0 <__FUNCTION__$0+0x338>)
403819dd:	0abd      	mov.n	a11, a10
403819df:	cde1a1        	l32r	a10, 40375164 <_iram_text_start+0xd60> (3fc93bfc <__FUNCTION__$0+0x344>)
403819e2:	cab481        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
403819e5:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
403819e8:	05a122        	movi	a2, 0x105
403819eb:	000406        	j	403819ff <s_probe_mxic_chip+0x47>
403819ee:	820000        	mull	a0, a0, a0
    *out_vendor_id = ESP_FLASH_CHIP_MXIC_OCT;
403819f1:	af          	.byte	0xaf
403819f2:	4382c2        	lsi	f12, a2, 0x10c
403819f5:	020c00        	andb	b0, b12, b0
    return ESP_OK;
403819f8:	0000c6        	j	403819ff <s_probe_mxic_chip+0x47>
403819fb:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
403819fe:	f01d05        	call0	40371bd0 <rom_rx_gain_force+0x36b7a4>
40381a01:	000000        	ill

40381a04 <s_mxic_set_required_regs>:
    esp_rom_opiflash_wait_idle();
}
#endif   // #if CONFIG_SPI_FLASH_SUPPORT_MXIC_OPI_CHIP

static void s_mxic_set_required_regs(uint32_t chip_id)
{
40381a04:	004136        	entry	a1, 32
#if CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_DTR
    is_swap = true;
#else
    //STR mode does not need to enable ddr_swap registers
#endif
    esp_rom_spi_set_dtr_swap_mode(0, is_swap, is_swap);
40381a07:	0c0c      	movi.n	a12, 0
40381a09:	0cbd      	mov.n	a11, a12
40381a0b:	20acc0        	or	a10, a12, a12
40381a0e:	cdd681        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381a11:	0008e0        	callx8	a8
    esp_rom_spi_set_dtr_swap_mode(1, is_swap, is_swap);
40381a14:	0c0c      	movi.n	a12, 0
40381a16:	0cbd      	mov.n	a11, a12
40381a18:	1a0c      	movi.n	a10, 1
40381a1a:	cdd381        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381a1d:	0008e0        	callx8	a8
}
40381a20:	f01d      	retw.n
	...

40381a24 <s_set_flash_ouput_driver_strength>:
{
40381a24:	00a136        	entry	a1, 80
    uint16_t reg_val = 0;
40381a27:	080c      	movi.n	a8, 0
40381a29:	105182        	s16i	a8, a1, 32
    uint8_t sr_reg_val = 0;
40381a2c:	224182        	s8i	a8, a1, 34
    uint8_t cr_reg_val = 0;
40381a2f:	234182        	s8i	a8, a1, 35
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381a32:	070c      	movi.n	a7, 0
40381a34:	6179      	s32i.n	a7, a1, 24
40381a36:	150c      	movi.n	a5, 1
40381a38:	5159      	s32i.n	a5, a1, 20
40381a3a:	860c      	movi.n	a6, 8
40381a3c:	4169      	s32i.n	a6, a1, 16
40381a3e:	22c182        	addi	a8, a1, 34
40381a41:	3189      	s32i.n	a8, a1, 12
40381a43:	2179      	s32i.n	a7, a1, 8
40381a45:	1179      	s32i.n	a7, a1, 4
40381a47:	0179      	s32i.n	a7, a1, 0
40381a49:	07fd      	mov.n	a15, a7
40381a4b:	07ed      	mov.n	a14, a7
40381a4d:	06dd      	mov.n	a13, a6
40381a4f:	5c0c      	movi.n	a12, 5
40381a51:	4b0c      	movi.n	a11, 4
40381a53:	20a220        	or	a10, a2, a2
40381a56:	cdc581        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381a59:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381a5c:	6179      	s32i.n	a7, a1, 24
40381a5e:	5159      	s32i.n	a5, a1, 20
40381a60:	4169      	s32i.n	a6, a1, 16
40381a62:	23c182        	addi	a8, a1, 35
40381a65:	3189      	s32i.n	a8, a1, 12
40381a67:	2179      	s32i.n	a7, a1, 8
40381a69:	1179      	s32i.n	a7, a1, 4
40381a6b:	0179      	s32i.n	a7, a1, 0
40381a6d:	07fd      	mov.n	a15, a7
40381a6f:	07ed      	mov.n	a14, a7
40381a71:	06dd      	mov.n	a13, a6
40381a73:	5c1c      	movi.n	a12, 21
40381a75:	4b0c      	movi.n	a11, 4
40381a77:	20a220        	or	a10, a2, a2
40381a7a:	cdbc81        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381a7d:	0008e0        	callx8	a8
    reg_val = (((cr_reg_val & 0xf8) | strength) << 8) | sr_reg_val;
40381a80:	230182        	l8ui	a8, a1, 35
40381a83:	897c      	movi.n	a9, -8
40381a85:	108890        	and	a8, a8, a9
40381a88:	203380        	or	a3, a3, a8
40381a8b:	401600        	ssl	a6
40381a8e:	a13300        	sll	a3, a3
40381a91:	220182        	l8ui	a8, a1, 34
40381a94:	208830        	or	a8, a8, a3
40381a97:	105182        	s16i	a8, a1, 32
    esp_rom_spiflash_write_enable(&g_rom_flashchip);
40381a9a:	cb5581        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40381a9d:	08a8      	l32i.n	a10, a8, 0
40381a9f:	cdb481        	l32r	a8, 40375170 <_iram_text_start+0xd6c> (40000a44 <SPI_write_enable>)
40381aa2:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381aa5:	6179      	s32i.n	a7, a1, 24
40381aa7:	5159      	s32i.n	a5, a1, 20
40381aa9:	4179      	s32i.n	a7, a1, 16
40381aab:	3179      	s32i.n	a7, a1, 12
40381aad:	081c      	movi.n	a8, 16
40381aaf:	2189      	s32i.n	a8, a1, 8
40381ab1:	20c182        	addi	a8, a1, 32
40381ab4:	1189      	s32i.n	a8, a1, 4
40381ab6:	0179      	s32i.n	a7, a1, 0
40381ab8:	07fd      	mov.n	a15, a7
40381aba:	07ed      	mov.n	a14, a7
40381abc:	06dd      	mov.n	a13, a6
40381abe:	05cd      	mov.n	a12, a5
40381ac0:	4b0c      	movi.n	a11, 4
40381ac2:	02ad      	mov.n	a10, a2
40381ac4:	cdaa81        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381ac7:	0008e0        	callx8	a8
}
40381aca:	f01d      	retw.n

40381acc <s_set_flash_dtr_str_opi_mode>:
{
40381acc:	00a136        	entry	a1, 80
40381acf:	204132        	s8i	a3, a1, 32
    esp_rom_spiflash_write_enable(&g_rom_flashchip);
40381ad2:	cb4781        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40381ad5:	0028a2        	l32i	a10, a8, 0
40381ad8:	cda681        	l32r	a8, 40375170 <_iram_text_start+0xd6c> (40000a44 <SPI_write_enable>)
40381adb:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381ade:	0e0c      	movi.n	a14, 0
40381ae0:	61e9      	s32i.n	a14, a1, 24
40381ae2:	180c      	movi.n	a8, 1
40381ae4:	5189      	s32i.n	a8, a1, 20
40381ae6:	41e9      	s32i.n	a14, a1, 16
40381ae8:	31e9      	s32i.n	a14, a1, 12
40381aea:	8d0c      	movi.n	a13, 8
40381aec:	21d9      	s32i.n	a13, a1, 8
40381aee:	20c182        	addi	a8, a1, 32
40381af1:	1189      	s32i.n	a8, a1, 4
40381af3:	01e9      	s32i.n	a14, a1, 0
40381af5:	0f2c      	movi.n	a15, 32
40381af7:	72a0c2        	movi	a12, 114
40381afa:	4b0c      	movi.n	a11, 4
40381afc:	02ad      	mov.n	a10, a2
40381afe:	cd9b81        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381b01:	0008e0        	callx8	a8
}
40381b04:	f01d      	retw.n
	...

40381b08 <s_flash_init_mxic>:
{
40381b08:	004136        	entry	a1, 32
    esp_rom_opiflash_legacy_driver_init(&opiflash_cmd_def_mxic);
40381b0b:	cd9aa1        	l32r	a10, 40375174 <_iram_text_start+0xd70> (3fc94914 <opiflash_cmd_def_mxic$1>)
40381b0e:	cd9b81        	l32r	a8, 4037517c <_iram_text_start+0xd78> (40000954 <esp_rom_opiflash_legacy_driver_init>)
40381b11:	0008e0        	callx8	a8
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
40381b14:	cb3771        	l32r	a7, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40381b17:	0027a2        	l32i	a10, a7, 0
40381b1a:	cd9981        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (40000960 <esp_rom_spiflash_wait_idle>)
40381b1d:	0008e0        	callx8	a8
    s_set_flash_ouput_driver_strength(1, 7);
40381b20:	7b0c      	movi.n	a11, 7
40381b22:	1a0c      	movi.n	a10, 1
40381b24:	ffefe5        	call8	40381a24 <s_set_flash_ouput_driver_strength>
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
40381b27:	07a8      	l32i.n	a10, a7, 0
40381b29:	cd9581        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (40000960 <esp_rom_spiflash_wait_idle>)
40381b2c:	0008e0        	callx8	a8
    s_set_pin_drive_capability(3);
40381b2f:	3a0c      	movi.n	a10, 3
40381b31:	ffe5a5        	call8	4038198c <s_set_pin_drive_capability>
    s_set_flash_dtr_str_opi_mode(1, 0x1);
40381b34:	1b0c      	movi.n	a11, 1
40381b36:	0bad      	mov.n	a10, a11
40381b38:	fff925        	call8	40381acc <s_set_flash_dtr_str_opi_mode>
    esp_rom_opiflash_cache_mode_config(mode, &rom_opiflash_cmd_def->cache_rd_cmd);
40381b3b:	cd8f81        	l32r	a8, 40375178 <_iram_text_start+0xd74> (3fcefff4 <rom_opiflash_cmd_def>)
40381b3e:	08b8      	l32i.n	a11, a8, 0
40381b40:	54cbb2        	addi	a11, a11, 84
40381b43:	02ad      	mov.n	a10, a2
40381b45:	f7abe5        	call8	40379604 <esp_rom_opiflash_cache_mode_config>
    esp_rom_spi_set_dtr_swap_mode(0, false, false);
40381b48:	0c0c      	movi.n	a12, 0
40381b4a:	0cbd      	mov.n	a11, a12
40381b4c:	0cad      	mov.n	a10, a12
40381b4e:	cd8681        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381b51:	0008e0        	callx8	a8
    esp_rom_spi_set_dtr_swap_mode(1, false, false);
40381b54:	0c0c      	movi.n	a12, 0
40381b56:	0cbd      	mov.n	a11, a12
40381b58:	1a0c      	movi.n	a10, 1
40381b5a:	cd8381        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381b5d:	0008e0        	callx8	a8
    esp_rom_opiflash_wait_idle();
40381b60:	cd8981        	l32r	a8, 40375184 <_iram_text_start+0xd80> (400008e8 <esp_rom_opiflash_wait_idle>)
40381b63:	0008e0        	callx8	a8
}
40381b66:	f01d      	retw.n

40381b68 <esp_opiflash_init>:

//To check which Flash chip is used
static const opi_flash_func_t **s_chip_func = NULL;

esp_err_t esp_opiflash_init(uint32_t chip_id)
{
40381b68:	006136        	entry	a1, 48
    mode = ESP_ROM_SPIFLASH_FASTRD_MODE;
#endif

    const opi_flash_func_t **chip_func = &registered_chip_funcs[0];

    uint8_t vendor_id = 0;
40381b6b:	080c      	movi.n	a8, 0
40381b6d:	004182        	s8i	a8, a1, 0
    const opi_flash_func_t **chip_func = &registered_chip_funcs[0];
40381b70:	cd8661        	l32r	a6, 40375188 <_iram_text_start+0xd84> (3fc92764 <registered_chip_funcs>)
    esp_err_t ret = ESP_FAIL;
40381b73:	f77c      	movi.n	a7, -1
    while (*chip_func) {
40381b75:	0009c6        	j	40381ba0 <esp_opiflash_init+0x38>
40381b78:	288200        	lsi	f0, a2, 160
        ret = (*chip_func)->probe(chip_id, &vendor_id);
40381b7b:	b11000        	sra	a1, a0
40381b7e:	a22020        	muluh	a2, a0, a2
40381b81:	08e020        	lsx	f14, a0, a2
40381b84:	0a7d00        	add.s	f7, f13, f0
        if (ret == ESP_OK) {
40381b87:	2adc      	bnez.n	a10, 40381b9d <esp_opiflash_init+0x35>
            // Detect this is the supported chip type
            s_chip_id = chip_id;
40381b89:	cd8081        	l32r	a8, 4037518c <_iram_text_start+0xd88> (3fc95110 <s_chip_id>)
40381b8c:	0829      	s32i.n	a2, a8, 0
            (*chip_func)->init(mode);
40381b8e:	0688      	l32i.n	a8, a6, 0
40381b90:	1888      	l32i.n	a8, a8, 4
40381b92:	6a0c      	movi.n	a10, 6
40381b94:	0008e0        	callx8	a8
            s_register_rom_function();
40381b97:	ffde65        	call8	4038197c <s_register_rom_function>
            break;
40381b9a:	000206        	j	40381ba6 <esp_opiflash_init+0x3e>
        }
        chip_func++;
40381b9d:	04c662        	addi	a6, a6, 4
    while (*chip_func) {
40381ba0:	002682        	l32i	a8, a6, 0
40381ba3:	fd2856        	bnez	a8, 40381b79 <esp_opiflash_init+0x11>
    }
    s_chip_func = chip_func;
40381ba6:	cd7a81        	l32r	a8, 40375190 <_iram_text_start+0xd8c> (3fc9510c <s_chip_func>)
40381ba9:	0869      	s32i.n	a6, a8, 0

    if (ret != ESP_OK) {
40381bab:	979c      	beqz.n	a7, 40381bc8 <esp_opiflash_init+0x60>
40381bad:	ca2f81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc9203c <esp_log_default_level>)
40381bb0:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "No detected Flash chip, please check the menuconfig to see if the chip is supported");
40381bb2:	f88c      	beqz.n	a8, 40381bc5 <esp_opiflash_init+0x5d>
40381bb4:	fe07a5        	call8	4037fc30 <esp_log_timestamp>
40381bb7:	cd6ac1        	l32r	a12, 40375160 <_iram_text_start+0xd5c> (3fc93bf0 <__FUNCTION__$0+0x338>)
40381bba:	0abd      	mov.n	a11, a10
40381bbc:	cd76a1        	l32r	a10, 40375194 <_iram_text_start+0xd90> (3fc93c3c <__FUNCTION__$0+0x384>)
40381bbf:	ca3d81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40381bc2:	0008e0        	callx8	a8
        abort();
40381bc5:	fe11e5        	call8	4037fce4 <abort>
    }

    return ESP_OK;
}
40381bc8:	020c      	movi.n	a2, 0
40381bca:	f01d      	retw.n

40381bcc <xthal_window_spill_nw>:
40381bcc:	034820        	rsr.windowbase	a2
40381bcf:	221b      	addi.n	a2, a2, 1
40381bd1:	400200        	ssr	a2
40381bd4:	034930        	rsr.windowstart	a3
40381bd7:	912030        	srl	a2, a3
40381bda:	a13300        	sll	a3, a3
40381bdd:	0bf3d6        	bgez	a3, 40381ca0 <xthal_window_spill_nw+0xd4>
40381be0:	f53030        	extui	a3, a3, 16, 16
40381be3:	202230        	or	a2, a2, a3
40381be6:	603020        	neg	a3, a2
40381be9:	103320        	and	a3, a3, a2
40381bec:	40f330        	nsau	a3, a3
40381bef:	401300        	ssl	a3
40381bf2:	912020        	srl	a2, a2
40381bf5:	134920        	wsr.windowstart	a2
40381bf8:	034820        	rsr.windowbase	a2
40381bfb:	1fc222        	addi	a2, a2, 31
40381bfe:	c03230        	sub	a3, a2, a3
40381c01:	134830        	wsr.windowbase	a3
40381c04:	002010        	rsync
40381c07:	034920        	rsr.windowstart	a2
40381c0a:	07a216        	beqz	a2, 40381c88 <xthal_window_spill_nw+0xbc>
40381c0d:	08e207        	bbsi	a2, 0, 40381c19 <xthal_window_spill_nw+0x4d>
40381c10:	19e217        	bbsi	a2, 1, 40381c2d <xthal_window_spill_nw+0x61>
40381c13:	3ae227        	bbsi	a2, 2, 40381c51 <xthal_window_spill_nw+0x85>
40381c16:	002306        	j	40381ca6 <xthal_window_spill_nw+0xda>
40381c19:	f0c932        	addi	a3, a9, -16
40381c1c:	0349      	s32i.n	a4, a3, 0
40381c1e:	1359      	s32i.n	a5, a3, 4
40381c20:	2369      	s32i.n	a6, a3, 8
40381c22:	3379      	s32i.n	a7, a3, 12
40381c24:	416120        	srli	a6, a2, 1
40381c27:	408010        	rotw	1
40381c2a:	fff706        	j	40381c0a <xthal_window_spill_nw+0x3e>
40381c2d:	f0cd32        	addi	a3, a13, -16
40381c30:	0349      	s32i.n	a4, a3, 0
40381c32:	1359      	s32i.n	a5, a3, 4
40381c34:	2369      	s32i.n	a6, a3, 8
40381c36:	3379      	s32i.n	a7, a3, 12
40381c38:	f4c532        	addi	a3, a5, -12
40381c3b:	0338      	l32i.n	a3, a3, 0
40381c3d:	e0c332        	addi	a3, a3, -32
40381c40:	0389      	s32i.n	a8, a3, 0
40381c42:	1399      	s32i.n	a9, a3, 4
40381c44:	23a9      	s32i.n	a10, a3, 8
40381c46:	33b9      	s32i.n	a11, a3, 12
40381c48:	41a220        	srli	a10, a2, 2
40381c4b:	408020        	rotw	2
40381c4e:	ffee06        	j	40381c0a <xthal_window_spill_nw+0x3e>
40381c51:	408010        	rotw	1
40381c54:	f0cdd2        	addi	a13, a13, -16
40381c57:	0d09      	s32i.n	a0, a13, 0
40381c59:	1d19      	s32i.n	a1, a13, 4
40381c5b:	2d29      	s32i.n	a2, a13, 8
40381c5d:	3d39      	s32i.n	a3, a13, 12
40381c5f:	f4c132        	addi	a3, a1, -12
40381c62:	0338      	l32i.n	a3, a3, 0
40381c64:	10cdd2        	addi	a13, a13, 16
40381c67:	d0c332        	addi	a3, a3, -48
40381c6a:	0349      	s32i.n	a4, a3, 0
40381c6c:	1359      	s32i.n	a5, a3, 4
40381c6e:	2369      	s32i.n	a6, a3, 8
40381c70:	3379      	s32i.n	a7, a3, 12
40381c72:	4389      	s32i.n	a8, a3, 16
40381c74:	5399      	s32i.n	a9, a3, 20
40381c76:	63a9      	s32i.n	a10, a3, 24
40381c78:	73b9      	s32i.n	a11, a3, 28
40381c7a:	4080f0        	rotw	-1
40381c7d:	41e320        	srli	a14, a2, 3
40381c80:	408030        	rotw	3
40381c83:	ffe0c6        	j	40381c0a <xthal_window_spill_nw+0x3e>
40381c86:	100000        	and	a0, a0, a0
40381c89:	204080        	or	a4, a0, a8
40381c8c:	0348      	l32i.n	a4, a3, 0
40381c8e:	401200        	ssl	a2
40381c91:	120c      	movi.n	a2, 1
40381c93:	a12200        	sll	a2, a2
40381c96:	134920        	wsr.windowstart	a2
40381c99:	002010        	rsync
40381c9c:	020c      	movi.n	a2, 0
40381c9e:	f00d      	ret.n
40381ca0:	120c      	movi.n	a2, 1
40381ca2:	f00d      	ret.n
40381ca4:	f00000        	subx8	a0, a0, a0
40381ca7:	1b1122        	l16ui	a2, a1, 54
40381caa:	483022        	lsi	f2, a0, 0x120
40381cad:	e2f703        	lsi	f0, a7, 0x388
40381cb0:	0b0a      	add.n	a0, a11, a0
40381cb2:	22f033        	lsi	f3, a0, 136
40381cb5:	62f711        	l32r	a1, 4035a894 <rom_rx_gain_force+0x354468>
40381cb8:	3030f7        	bltu	a0, a15, 40381cec <xthal_window_spill+0xc>
40381cbb:	130034        	lsi	f3, a0, 76
40381cbe:	320040        	orbc	b0, b0, b4
40381cc1:	223011        	l32r	a1, 4034a584 <rom_rx_gain_force+0x344158>
40381cc4:	202081        	l32r	a8, 40349d44 <rom_rx_gain_force+0x343918>
40381cc7:	4920f4        	mula.da.hl.ldinc	m2, a0, m0, a15
40381cca:	033013        	lsi	f1, a0, 12
40381ccd:	022c03        	lsi	f0, a12, 8
40381cd0:	c03230        	sub	a3, a2, a3
40381cd3:	134830        	wsr.windowbase	a3
40381cd6:	002010        	rsync
40381cd9:	220c      	movi.n	a2, 2
40381cdb:	f00d      	ret.n
40381cdd:	000000        	ill

40381ce0 <xthal_window_spill>:
40381ce0:	002136        	entry	a1, 16
40381ce3:	cbdb61        	l32r	a6, 40374c50 <_iram_text_start+0x84c> (fffbfff0 <_rtc_reserved_end+0x9febfff0>)
40381ce6:	03e650        	rsr.ps	a5
40381ce9:	004d      	mov.n	a4, a0
40381ceb:	102560        	and	a2, a5, a6
40381cee:	223b      	addi.n	a2, a2, 3
40381cf0:	13e620        	wsr.ps	a2
40381cf3:	002010        	rsync
40381cf6:	ffed45        	call0	40381bcc <xthal_window_spill_nw>
40381cf9:	040d      	mov.n	a0, a4
40381cfb:	13e650        	wsr.ps	a5
40381cfe:	002010        	rsync
40381d01:	f01d      	retw.n
	...

40381d04 <xthal_restore_extra_nw>:
40381d04:	0238      	l32i.n	a3, a2, 0
40381d06:	f3e730        	wur.threadptr	a3
40381d09:	1238      	l32i.n	a3, a2, 4
40381d0b:	131030        	wsr.acclo	a3
40381d0e:	2238      	l32i.n	a3, a2, 8
40381d10:	131130        	wsr.acchi	a3
40381d13:	3238      	l32i.n	a3, a2, 12
40381d15:	130430        	wsr.br	a3
40381d18:	4238      	l32i.n	a3, a2, 16
40381d1a:	130c30        	wsr.scompare1	a3
40381d1d:	5238      	l32i.n	a3, a2, 20
40381d1f:	132030        	wsr.m0	a3
40381d22:	6238      	l32i.n	a3, a2, 24
40381d24:	132130        	wsr.m1	a3
40381d27:	7238      	l32i.n	a3, a2, 28
40381d29:	132230        	wsr.m2	a3
40381d2c:	8238      	l32i.n	a3, a2, 32
40381d2e:	132330        	wsr.m3	a3
40381d31:	f00d      	ret.n
	...

40381d34 <xthal_save_extra_nw>:
40381d34:	e33e70        	rur.threadptr	a3
40381d37:	0239      	s32i.n	a3, a2, 0
40381d39:	031030        	rsr.acclo	a3
40381d3c:	1239      	s32i.n	a3, a2, 4
40381d3e:	031130        	rsr.acchi	a3
40381d41:	2239      	s32i.n	a3, a2, 8
40381d43:	030430        	rsr.br	a3
40381d46:	3239      	s32i.n	a3, a2, 12
40381d48:	030c30        	rsr.scompare1	a3
40381d4b:	4239      	s32i.n	a3, a2, 16
40381d4d:	032030        	rsr.m0	a3
40381d50:	5239      	s32i.n	a3, a2, 20
40381d52:	032130        	rsr.m1	a3
40381d55:	6239      	s32i.n	a3, a2, 24
40381d57:	032230        	rsr.m2	a3
40381d5a:	7239      	s32i.n	a3, a2, 28
40381d5c:	032330        	rsr.m3	a3
40381d5f:	8239      	s32i.n	a3, a2, 32
40381d61:	f00d      	ret.n
	...

40381d64 <_xt_context_save>:
    .literal_position
    .align  4

_xt_context_save:

    s32i    a2,  sp, XT_STK_A2
40381d64:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
40381d66:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
40381d68:	7149      	s32i.n	a4, a1, 28
    s32i    a5,  sp, XT_STK_A5
40381d6a:	8159      	s32i.n	a5, a1, 32
    s32i    a6,  sp, XT_STK_A6
40381d6c:	9169      	s32i.n	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
40381d6e:	a179      	s32i.n	a7, a1, 40
    s32i    a8,  sp, XT_STK_A8
40381d70:	b189      	s32i.n	a8, a1, 44
    s32i    a9,  sp, XT_STK_A9
40381d72:	c199      	s32i.n	a9, a1, 48
    s32i    a10, sp, XT_STK_A10
40381d74:	d1a9      	s32i.n	a10, a1, 52
    s32i    a11, sp, XT_STK_A11
40381d76:	e1b9      	s32i.n	a11, a1, 56
    Call0 ABI callee-saved regs a12-15 do not need to be saved here.
    a12-13 are the caller's responsibility so it can use them as scratch.
    So only need to save a14-a15 here for Windowed ABI (not Call0).
    */
    #ifndef __XTENSA_CALL0_ABI__
    s32i    a14, sp, XT_STK_A14
40381d78:	1161e2        	s32i	a14, a1, 68
    s32i    a15, sp, XT_STK_A15
40381d7b:	1261f2        	s32i	a15, a1, 72
    #endif

    rsr     a3,  SAR
40381d7e:	030330        	rsr.sar	a3
    s32i    a3,  sp, XT_STK_SAR
40381d81:	136132        	s32i	a3, a1, 76

    #if XCHAL_HAVE_LOOPS
    rsr     a3,  LBEG
40381d84:	030030        	rsr.lbeg	a3
    s32i    a3,  sp, XT_STK_LBEG
40381d87:	166132        	s32i	a3, a1, 88
    rsr     a3,  LEND
40381d8a:	030130        	rsr.lend	a3
    s32i    a3,  sp, XT_STK_LEND
40381d8d:	176132        	s32i	a3, a1, 92
    rsr     a3,  LCOUNT
40381d90:	030230        	rsr.lcount	a3
    s32i    a3,  sp, XT_STK_LCOUNT
40381d93:	186132        	s32i	a3, a1, 96
    l32i    a3,  a3, 0
    s32i    a3,  sp, XT_STK_VPRI
    #endif

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a9,  a0                     /* preserve ret addr */
40381d96:	009d      	mov.n	a9, a0
    #endif

    s32i    a12, sp, XT_STK_TMP0        /* temp. save stuff in stack frame */
40381d98:	1961c2        	s32i	a12, a1, 100
    s32i    a13, sp, XT_STK_TMP1
40381d9b:	1a61d2        	s32i	a13, a1, 104
    s32i    a9,  sp, XT_STK_TMP2
40381d9e:	1b6192        	s32i	a9, a1, 108

    l32i    a12, sp, XT_STK_A12         /* recover original a9,12,13 */
40381da1:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
40381da3:	1021d2        	l32i	a13, a1, 64
    l32i    a9,  sp, XT_STK_A9
40381da6:	c198      	l32i.n	a9, a1, 48

    #if XCHAL_EXTRA_SA_SIZE > 0
    addi    a2,  sp, XT_STK_EXTRA       /* where to save it */
40381da8:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_save_extra_nw         /* destroys a0,2,3 */
40381dab:	fff885        	call0	40381d34 <xthal_save_extra_nw>
     * may contain live windows belonging to previous frames in the call stack.
     * These frames will be spilled by SPILL_ALL_WINDOWS, and if the register was
     * used as a temporary by this code, the temporary value would get stored
     * onto the stack, instead of the real value.
     */
    rsr     a2, PS                     /* to be restored after SPILL_ALL_WINDOWS */
40381dae:	03e620        	rsr.ps	a2
    movi    a0, PS_INTLEVEL_MASK
40381db1:	f00c      	movi.n	a0, 15
    and     a3, a2, a0                 /* get the current INTLEVEL */
40381db3:	103200        	and	a3, a2, a0
    bgeui   a3, XCHAL_EXCM_LEVEL, 1f   /* calculate max(INTLEVEL, XCHAL_EXCM_LEVEL) */
40381db6:	0233f6        	bgeui	a3, 3, 40381dbc <_xt_context_save+0x58>
    movi    a3, XCHAL_EXCM_LEVEL
40381db9:	03a032        	movi	a3, 3
1:
    movi    a0, PS_UM | PS_WOE         /* clear EXCM, enable window overflow, set new INTLEVEL */
40381dbc:	ccf701        	l32r	a0, 40375198 <_iram_text_start+0xd94> (40020 <UserFrameTotalSize+0x3ff20>)
    or      a3, a3, a0
40381dbf:	203300        	or	a3, a3, a0
    wsr     a3, ps
40381dc2:	13e630        	wsr.ps	a3
    rsr     a0, EPC1                   /* to be restored after SPILL_ALL_WINDOWS */
40381dc5:	03b100        	rsr.epc1	a0

    addi    sp,  sp, XT_STK_FRMSZ      /* go back to spill register region */
40381dc8:	01d112        	addmi	a1, a1, 0x100
40381dcb:	c0c112        	addi	a1, a1, -64
    SPILL_ALL_WINDOWS                  /* place the live register windows there */
40381dce:	10ccc0        	and	a12, a12, a12
40381dd1:	408030        	rotw	3
40381dd4:	10ccc0        	and	a12, a12, a12
40381dd7:	408030        	rotw	3
40381dda:	10ccc0        	and	a12, a12, a12
40381ddd:	408030        	rotw	3
40381de0:	10ccc0        	and	a12, a12, a12
40381de3:	408030        	rotw	3
40381de6:	10ccc0        	and	a12, a12, a12
40381de9:	408040        	rotw	4
    addi    sp,  sp, -XT_STK_FRMSZ     /* return the current stack pointer and proceed with context save*/
40381dec:	ffd112        	addmi	a1, a1, 0xffffff00
40381def:	40c112        	addi	a1, a1, 64

    wsr     a2, PS                     /* restore to the value at entry */
40381df2:	13e620        	wsr.ps	a2
    rsync
40381df5:	002010        	rsync
    wsr     a0, EPC1                   /* likewise */
40381df8:	13b100        	wsr.epc1	a0

    #endif /* __XTENSA_CALL0_ABI__ */

    l32i    a12, sp, XT_STK_TMP0       /* restore the temp saved registers */
40381dfb:	1921c2        	l32i	a12, a1, 100
    l32i    a13, sp, XT_STK_TMP1       /* our return address is there */
40381dfe:	1a21d2        	l32i	a13, a1, 104
    l32i    a9,  sp, XT_STK_TMP2
40381e01:	1b2192        	l32i	a9, a1, 108

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a0, a9                      /* retrieve ret addr */
40381e04:	090d      	mov.n	a0, a9
    #endif

    ret
40381e06:	f00d      	ret.n

40381e08 <_xt_context_restore>:
    affected, but it is generally unlikely. If that ever happens,
    more registers need to be saved/restored around this macro invocation.
    Here we only assume a13 is preserved.
    Future Xtensa tools releases might limit the regs that can be affected.
    */
    mov     a13, a0                     /* preserve ret addr */
40381e08:	00dd      	mov.n	a13, a0
    addi    a2,  sp, XT_STK_EXTRA       /* where to find it */
40381e0a:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_restore_extra_nw      /* destroys a0,2,3,4,5 */
40381e0d:	ffef45        	call0	40381d04 <xthal_restore_extra_nw>
    mov     a0,  a13                    /* retrieve ret addr */
40381e10:	0d0d      	mov.n	a0, a13
    #endif

    #if XCHAL_HAVE_LOOPS
    l32i    a2,  sp, XT_STK_LBEG
40381e12:	162122        	l32i	a2, a1, 88
    l32i    a3,  sp, XT_STK_LEND
40381e15:	172132        	l32i	a3, a1, 92
    wsr     a2,  LBEG
40381e18:	130020        	wsr.lbeg	a2
    l32i    a2,  sp, XT_STK_LCOUNT
40381e1b:	182122        	l32i	a2, a1, 96
    wsr     a3,  LEND
40381e1e:	130130        	wsr.lend	a3
    wsr     a2,  LCOUNT
40381e21:	130220        	wsr.lcount	a2
    and     a4,  a4, a5
    wsr     a4,  INTENABLE              /* update INTENABLE */
    s32i    a5,  a3, 4                  /* restore _xt_vpri_mask */
    #endif

    l32i    a3,  sp, XT_STK_SAR
40381e24:	132132        	l32i	a3, a1, 76
    l32i    a2,  sp, XT_STK_A2
40381e27:	5128      	l32i.n	a2, a1, 20
    wsr     a3,  SAR
40381e29:	130330        	wsr.sar	a3
    l32i    a3,  sp, XT_STK_A3
40381e2c:	6138      	l32i.n	a3, a1, 24
    l32i    a4,  sp, XT_STK_A4
40381e2e:	7148      	l32i.n	a4, a1, 28
    l32i    a5,  sp, XT_STK_A5
40381e30:	8158      	l32i.n	a5, a1, 32
    l32i    a6,  sp, XT_STK_A6
40381e32:	9168      	l32i.n	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
40381e34:	a178      	l32i.n	a7, a1, 40
    l32i    a8,  sp, XT_STK_A8
40381e36:	b188      	l32i.n	a8, a1, 44
    l32i    a9,  sp, XT_STK_A9
40381e38:	c198      	l32i.n	a9, a1, 48
    l32i    a10, sp, XT_STK_A10
40381e3a:	d1a8      	l32i.n	a10, a1, 52
    l32i    a11, sp, XT_STK_A11
40381e3c:	e1b8      	l32i.n	a11, a1, 56
    /*
    Call0 ABI callee-saved regs a12-15 do not need to be restored here.
    However a12-13 were saved for scratch before XT_RTOS_INT_ENTER(),
    so need to be restored anyway, despite being callee-saved in Call0.
    */
    l32i    a12, sp, XT_STK_A12
40381e3e:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
40381e40:	1021d2        	l32i	a13, a1, 64
    #ifndef __XTENSA_CALL0_ABI__
    l32i    a14, sp, XT_STK_A14
40381e43:	1121e2        	l32i	a14, a1, 68
    l32i    a15, sp, XT_STK_A15
40381e46:	1221f2        	l32i	a15, a1, 72
    #endif

    ret
40381e49:	f00d      	ret.n
	...

40381e4c <_xt_coproc_init>:
    .type   _xt_coproc_init,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_init:
    ENTRY0
40381e4c:	002136        	entry	a1, 16

    /* Initialize thread co-processor ownerships to 0 (unowned). */
    movi    a2, _xt_coproc_owner_sa         /* a2 = base of owner array */
40381e4f:	ca5421        	l32r	a2, 403747a0 <_iram_text_start+0x39c> (3fc926e0 <_xt_coproc_owner_sa>)
    addi    a3, a2, (XCHAL_CP_MAX*portNUM_PROCESSORS) << 2       /* a3 = top+1 of owner array */
40381e52:	20c232        	addi	a3, a2, 32
    movi    a4, 0                           /* a4 = 0 (unowned) */
40381e55:	00a042        	movi	a4, 0
1:  s32i    a4, a2, 0
40381e58:	0249      	s32i.n	a4, a2, 0
    addi    a2, a2, 4
40381e5a:	224b      	addi.n	a2, a2, 4
    bltu    a2, a3, 1b
40381e5c:	f83237        	bltu	a2, a3, 40381e58 <_xt_coproc_init+0xc>

    RET0
40381e5f:	f01d      	retw.n
40381e61:	000000        	ill

40381e64 <_xt_coproc_release>:
    .type   _xt_coproc_release,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_release:
    ENTRY0                                  /* a2 = base of save area */
40381e64:	002136        	entry	a1, 16
                                            /* a3 = xTargetCoreID */

    movi    a4, XCHAL_CP_MAX << 2           /* a4 = size of an owner array */
40381e67:	041c      	movi.n	a4, 16
    mull    a4, a3, a4                      /* a4 = offset to the owner array of the target core */
40381e69:	824340        	mull	a4, a3, a4
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of all owner arrays */
40381e6c:	ca4d31        	l32r	a3, 403747a0 <_iram_text_start+0x39c> (3fc926e0 <_xt_coproc_owner_sa>)
    add     a3, a3, a4                      /* a3 = base of owner array of the target core */
40381e6f:	334a      	add.n	a3, a3, a4
    addi    a4, a3, XCHAL_CP_MAX << 2       /* a4 = top+1 of owner array of the target core */
40381e71:	10c342        	addi	a4, a3, 16
    movi    a5, 0                           /* a5 = 0 (unowned) */
40381e74:	050c      	movi.n	a5, 0

    rsil    a6, XCHAL_EXCM_LEVEL            /* lock interrupts */
40381e76:	006360        	rsil	a6, 3
#if portNUM_PROCESSORS > 1
    /* If multicore, we must also acquire the _xt_coproc_owner_sa_lock spinlock
     * to ensure thread safe access of _xt_coproc_owner_sa between cores. */
    spinlock_take a7 a8 _xt_coproc_owner_sa_lock
40381e79:	ca4a71        	l32r	a7, 403747a4 <_iram_text_start+0x3a0> (3fc92700 <_xt_coproc_owner_sa_lock>)
40381e7c:	080c      	movi.n	a8, 0
40381e7e:	130c80        	wsr.scompare1	a8
40381e81:	002010        	rsync
40381e84:	03eb80        	rsr.prid	a8
40381e87:	00e782        	s32c1i	a8, a7, 0
40381e8a:	fee856        	bnez	a8, 40381e7c <_xt_coproc_release+0x18>
#endif /* portNUM_PROCESSORS > 1 */

1:  l32i    a7, a3, 0                       /* a7 = owner at a3 */
40381e8d:	0378      	l32i.n	a7, a3, 0
    bne     a2, a7, 2f                      /* if (coproc_sa_base == owner) */
40381e8f:	019277        	bne	a2, a7, 40381e94 <_xt_coproc_release+0x30>
    s32i    a5, a3, 0                       /*   owner = unowned */
40381e92:	0359      	s32i.n	a5, a3, 0
2:  addi    a3, a3, 1<<2                    /* a3 = next entry in owner array */
40381e94:	334b      	addi.n	a3, a3, 4
    bltu    a3, a4, 1b                      /* repeat until end of array */
40381e96:	f33347        	bltu	a3, a4, 40381e8d <_xt_coproc_release+0x29>

#if portNUM_PROCESSORS > 1
    /* Release previously taken spinlock */
    spinlock_release a7 a8 _xt_coproc_owner_sa_lock
40381e99:	ca4271        	l32r	a7, 403747a4 <_iram_text_start+0x3a0> (3fc92700 <_xt_coproc_owner_sa_lock>)
40381e9c:	080c      	movi.n	a8, 0
40381e9e:	0789      	s32i.n	a8, a7, 0
#endif /* portNUM_PROCESSORS > 1 */
    wsr     a6, PS                          /* restore interrupts */
40381ea0:	13e660        	wsr.ps	a6

    RET0
40381ea3:	f01d      	retw.n
40381ea5:	000000        	ill

40381ea8 <_xt_coproc_savecs>:
    .align      4
_xt_coproc_savecs:

    /* At entry, CPENABLE should be showing which CPs are enabled. */

    rsr     a2, CPENABLE                /* a2 = which CPs are enabled      */
40381ea8:	03e020        	rsr.cpenable	a2
    beqz    a2, .Ldone                  /* quick exit if none              */
40381eab:	d29c      	beqz.n	a2, 40381ecc <_xt_coproc_savecs+0x24>
    mov     a14, a0                     /* save return address             */
40381ead:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
40381eaf:	f86745        	call0	4037a524 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
40381eb2:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone                 /* if none then nothing to do      */
40381eb4:	4f9c      	beqz.n	a15, 40381ecc <_xt_coproc_savecs+0x24>
    s16i    a2, a15, XT_CP_CS_ST        /* save mask of CPs being stored   */
40381eb6:	025f22        	s16i	a2, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
40381eb9:	ca3bd1        	l32r	a13, 403747a8 <_iram_text_start+0x3a4> (3c028740 <_xt_coproc_sa_offset>)
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
40381ebc:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
40381ebe:	036207        	bbci	a2, 0, 40381ec5 <_xt_coproc_savecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
40381ec1:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
40381ec3:	3efa      	add.n	a3, a14, a15
    xchal_cp2_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
40381ec5:	036237        	bbci	a2, 3, 40381ecc <_xt_coproc_savecs+0x24>
    l32i    a14, a13, 12
40381ec8:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
40381eca:	3efa      	add.n	a3, a14, a15
    xchal_cp7_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone:
    ret
40381ecc:	f00d      	ret.n
	...

40381ed0 <_xt_coproc_restorecs>:
    .align  4
    .literal_position
    .align      4
_xt_coproc_restorecs:

    mov     a14, a0                     /* save return address             */
40381ed0:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
40381ed2:	f86505        	call0	4037a524 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
40381ed5:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone2                /* if none then nothing to do      */
40381ed7:	9f9c      	beqz.n	a15, 40381ef4 <_xt_coproc_restorecs+0x24>
    l16ui   a3, a15, XT_CP_CS_ST        /* a3 = which CPs have been saved  */
40381ed9:	021f32        	l16ui	a3, a15, 4
    xor     a3, a3, a2                  /* clear the ones being restored   */
40381edc:	303320        	xor	a3, a3, a2
    s32i    a3, a15, XT_CP_CS_ST        /* update saved CP mask            */
40381edf:	1f39      	s32i.n	a3, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
40381ee1:	ca31d1        	l32r	a13, 403747a8 <_iram_text_start+0x3a4> (3c028740 <_xt_coproc_sa_offset>)
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
40381ee4:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
40381ee6:	036207        	bbci	a2, 0, 40381eed <_xt_coproc_restorecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
40381ee9:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
40381eeb:	3efa      	add.n	a3, a14, a15
    xchal_cp2_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
40381eed:	036237        	bbci	a2, 3, 40381ef4 <_xt_coproc_restorecs+0x24>
    l32i    a14, a13, 12
40381ef0:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
40381ef2:	3efa      	add.n	a3, a14, a15
    xchal_cp7_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone2:
    ret
40381ef4:	f00d      	ret.n
	...

40381ef8 <xt_ints_on>:
    .global xt_ints_on
    .type   xt_ints_on,@function

xt_ints_on:

    ENTRY0
40381ef8:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable |= mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts       */
    mov     a2, a3               /* Previous mask             */
#else
    movi    a3, 0
40381efb:	030c      	movi.n	a3, 0
    xsr     a3, INTENABLE        /* Disables all interrupts   */
40381efd:	61e430        	xsr.intenable	a3
    rsync
40381f00:	002010        	rsync
    or      a2, a3, a2           /* set bits in mask */
40381f03:	202320        	or	a2, a3, a2
    wsr     a2, INTENABLE        /* Re-enable ints */
40381f06:	13e420        	wsr.intenable	a2
    rsync
40381f09:	002010        	rsync
    mov     a2, a3               /* return prev mask */
40381f0c:	032d      	mov.n	a2, a3
#endif
#else
    movi    a2, 0                /* Return zero */
#endif
    RET0
40381f0e:	f01d      	retw.n

40381f10 <xt_ints_off>:
    .global xt_ints_off
    .type   xt_ints_off,@function

xt_ints_off:

    ENTRY0
40381f10:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable &= ~mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts        */
    mov     a2, a3               /* Previous mask              */
#else
    movi    a4, 0
40381f13:	040c      	movi.n	a4, 0
    xsr     a4, INTENABLE        /* Disables all interrupts   */
40381f15:	61e440        	xsr.intenable	a4
    rsync
40381f18:	002010        	rsync
    or      a3, a4, a2           /* set bits in mask */
40381f1b:	203420        	or	a3, a4, a2
    xor     a3, a3, a2           /* invert bits in mask set in mask, essentially clearing them */
40381f1e:	303320        	xor	a3, a3, a2
    wsr     a3, INTENABLE        /* Re-enable ints */
40381f21:	13e430        	wsr.intenable	a3
    rsync
40381f24:	002010        	rsync
    mov     a2, a4               /* return prev mask */
40381f27:	042d      	mov.n	a2, a4
#endif
#else
    movi    a2, 0                /* return zero */
#endif
    RET0
40381f29:	f01d      	retw.n

Disassembly of section .flash.text:

42000020 <_stext>:
42000020:	3fc94980 	
42000024:	3c0200b0 	
42000028:	400011f4 	
4200002c:	3fc9203c 	
42000030:	3c020120 	
42000034:	3c02012c 	
42000038:	3c020050 	
4200003c:	3c020154 	
42000040:	3c020030 	
42000044:	3c020178 	
42000048:	3c020070 	
4200004c:	3c020080 	
42000050:	3c02019c 	
42000054:	3c0201c4 	
42000058:	3c020090 	
4200005c:	3c0201ec 	
42000060:	4037fc30 	
42000064:	400005d0 	
42000068:	3c020210 	
4200006c:	3c020eb0 	
42000070:	3c020228 	
42000074:	3c020234 	
42000078:	3c02025c 	
4200007c:	51eb851f 	
42000080:	3c020288 	
42000084:	40375e10 	
42000088:	40375df8 	
4200008c:	3c027060 	
42000090:	3c0202b0 	
42000094:	4037fc78 	
42000098:	3fc9498c 	
4200009c:	4037b1a8 	
420000a0:	40375760 	
420000a4:	3c0202e4 	
420000a8:	3c0202f0 	
420000ac:	3c020318 	
420000b0:	40376440 	
420000b4:	3c020338 	
420000b8:	3c027080 	
420000bc:	3c020368 	
420000c0:	4037fda0 	
420000c4:	4037ff70 	
420000c8:	60008000 	
420000cc:	40000de0 	
420000d0:	40000e04 	
420000d4:	40000dec 	
420000d8:	40001b54 	
420000dc:	3c0202e4 	
420000e0:	3c020378 	
420000e4:	3c0203dc 	
420000e8:	600c0000 	
420000ec:	4037519c 	
420000f0:	3fc949a8 	
420000f4:	4037fce4 	
420000f8:	40378240 	
420000fc:	40000720 	
42000100:	40000600 	
42000104:	3fc949a0 	
42000108:	3c0270b8 	
4200010c:	4037550c 	
42000110:	3c0205a0 	
42000114:	3c0205a4 	
42000118:	4037870c 	
4200011c:	403787fc 	
42000120:	403792f4 	
42000124:	40378850 	
42000128:	4037890c 	
4200012c:	3c0270c0 	
42000130:	40000000 	
42000134:	4037564c 	
42000138:	4000057c 	
4200013c:	3c0205f4 	
42000140:	3c0270c4 	
42000144:	3c020651 	
42000148:	00002328 	
4200014c:	3c020658 	
42000150:	40378a9c 	
42000154:	403788f0 	
42000158:	40378a58 	
4200015c:	40378a30 	
42000160:	40002544 	
42000164:	40000e1c 	
42000168:	40000dd4 	
4200016c:	40378b44 	
42000170:	40378adc 	
42000174:	4000069c 	
42000178:	40378ea0 	
4200017c:	00003020 	
42000180:	8efb8ffc 	
42000184:	600c0018 	
42000188:	600c001c 	
4200018c:	60026014 	
42000190:	88e513f4 	
42000194:	600c0020 	
42000198:	600c0024 	
4200019c:	00fb9fcf 	
420001a0:	600c0028 	
420001a4:	600c002c 	
420001a8:	f0ffffff 	
420001ac:	01000000 	
420001b0:	600080c8 	
420001b4:	3fc949ac 	
420001b8:	600c40e4 	
420001bc:	3c027110 	
420001c0:	3fc949b8 	
420001c4:	3c027100 	
420001c8:	600c40f0 	
420001cc:	3fc949b0 	
420001d0:	600c40fc 	
420001d4:	600c4104 	
420001d8:	600c4114 	
420001dc:	3fc949b4 	
420001e0:	600c40ec 	
420001e4:	600c40f8 	
420001e8:	600c40e0 	
420001ec:	600c40dc 	
420001f0:	600c40e8 	
420001f4:	600c40f4 	
420001f8:	60026000 	
420001fc:	ffff0000 	
42000200:	00004000 	
42000204:	40376578 	
42000208:	40376568 	
4200020c:	403758a8 	
42000210:	403758c4 	
42000214:	40000630 	
42000218:	600c0000 	
4200021c:	00008000 	
42000220:	ffff7fff 	
42000224:	60020000 	
42000228:	ffffbfff 	
4200022c:	00009c40 	
42000230:	3fc949c0 	
42000234:	00002710 	
42000238:	403766cc 	
4200023c:	403766bc 	
42000240:	40000dbc 	
42000244:	40000df8 	
42000248:	403758e4 	
4200024c:	3fc949c8 	
42000250:	60038000 	
42000254:	3c027170 	
42000258:	3c027178 	
4200025c:	3fc949cc 	
42000260:	66666667 	
42000264:	10624dd3 	
42000268:	42001dac 	
4200026c:	3fc949d0 	
42000270:	3c020844 	
42000274:	3c020864 	
42000278:	3c020870 	
4200027c:	3c0208c4 	
42000280:	0010200c 	
42000284:	3c020874 	
42000288:	3c020890 	
4200028c:	3fc92008 	
42000290:	00001b58 	
42000294:	3c0208a4 	
42000298:	3c0208b8 	
4200029c:	40001248 	
420002a0:	40000e34 	
420002a4:	40375668 	
420002a8:	3c02a470 	
420002ac:	3c02a458 	
420002b0:	3c02a49c 	
420002b4:	3c0202e4 	
420002b8:	3c0208c8 	
420002bc:	3c02a53c 	
420002c0:	3fc949d4 	
420002c4:	3fc949d1 	
420002c8:	3c020904 	
420002cc:	42002324 	
420002d0:	3fc949e0 	
420002d4:	3fffffff 	
420002d8:	be000000 	
420002dc:	01ffffff 	
420002e0:	bfc90000 	
420002e4:	0006ffff 	
420002e8:	c0000000 	
420002ec:	0005ffff 	
420002f0:	9ff02000 	
420002f4:	00001fff 	
420002f8:	40374400 	
420002fc:	3fc92010 	
42000300:	400011e8 	
42000304:	403781bc 	
42000308:	403759e8 	
4200030c:	40000e10 	
42000310:	3c0208c4 	
42000314:	3fc949e8 	
42000318:	3c02090c 	
4200031c:	3c020928 	
42000320:	3c020934 	
42000324:	3c020944 	
42000328:	3c02095c 	
4200032c:	3c020974 	
42000330:	3c020984 	
42000334:	3c020994 	
42000338:	bffffffc 	
4200033c:	03ffffff 	
42000340:	3c0209a0 	
42000344:	3c0209b4 	
42000348:	3c020a18 	
4200034c:	3c0209b8 	
42000350:	3c0209cc 	
42000354:	3c0209e0 	
42000358:	3c0208c4 	
4200035c:	3c027188 	
42000360:	3c020a14 	
42000364:	3c020a1c 	
42000368:	3c020a58 	
4200036c:	3c020a2c 	
42000370:	3c020a30 	
42000374:	3c020a50 	
42000378:	3c020a60 	
4200037c:	3c020a70 	
42000380:	3c020a80 	
42000384:	40376888 	
42000388:	3c027208 	
4200038c:	3c020904 	
42000390:	3c020bb0 	
42000394:	42002408 	
42000398:	3c020bcc 	
4200039c:	3c0271e8 	
420003a0:	420023b8 	
420003a4:	4200245c 	
420003a8:	40375b50 	
420003ac:	3c020f74 	
420003b0:	3fc92998 	
420003b4:	3fc94a2c 	
420003b8:	3fc928f0 	
420003bc:	3fc94a24 	
420003c0:	3fc94a34 	
420003c4:	40375ce8 	
420003c8:	3c020f64 	
420003cc:	3c0272b4 	
420003d0:	3c020f58 	
420003d4:	40379c68 	
420003d8:	403799bc 	
420003dc:	4037c5c0 	
420003e0:	3fc94a04 	
420003e4:	3fc949f8 	
420003e8:	3fc94a00 	
420003ec:	4037ba48 	
420003f0:	403781a8 	
420003f4:	4037a10c 	
420003f8:	4037c3a0 	
420003fc:	4037b8b0 	
42000400:	4037c1cc 	
42000404:	3fc94a7c 	
42000408:	40378298 	
4200040c:	3fc9202c 	
42000410:	4037a130 	
42000414:	4037a280 	
42000418:	3fc94a3c 	
4200041c:	3c0272c4 	
42000420:	3c0272cc 	
42000424:	4037682c 	
42000428:	efffffff 	
4200042c:	ffffc00f 	
42000430:	20000000 	
42000434:	dfffffff 	
42000438:	03ff0000 	
4200043c:	fbffffff 	
42000440:	08000000 	
42000444:	bfffffff 	
42000448:	3fc94ac4 	
4200044c:	40001230 	
42000450:	3fc94ad4 	
42000454:	3fc94acc 	
42000458:	3fc94ad0 	
4200045c:	3c0227c0 	
42000460:	3c0279ac 	
42000464:	3c022843 	
42000468:	3fc94ac8 	
4200046c:	1fffffff 	
42000470:	3fc94bd4 	
42000474:	02000000 	
42000478:	3c022888 	
4200047c:	3c027a5c 	
42000480:	3c0228ba 	
42000484:	4037e810 	
42000488:	3c0228cc 	
4200048c:	3c0228d8 	
42000490:	3c02291c 	
42000494:	3c027a4c 	
42000498:	3c027cbc 	
4200049c:	3c022934 	
420004a0:	3c027a38 	
420004a4:	3c022964 	
420004a8:	b33fffff 	
420004ac:	3c022970 	
420004b0:	3c02299c 	
420004b4:	3c0229b4 	
420004b8:	00000804 	
420004bc:	3c0229d4 	
420004c0:	4037e74c 	
420004c4:	3c02a49c 	
420004c8:	3c02a474 	
420004cc:	3ff1fffc 	
420004d0:	3fcf0000 	
420004d4:	42015870 	
420004d8:	3c0231b4 	
420004dc:	3c027bd4 	
420004e0:	3c0231f7 	
420004e4:	3c023210 	
420004e8:	3c02323c 	
420004ec:	3c02324c 	
420004f0:	40001488 	
420004f4:	3c027bf0 	
420004f8:	3c027bf4 	
420004fc:	cccccccd 	
42000500:	600fffe8 	
42000504:	60008054 	
42000508:	3fc92048 	
4200050c:	3fc92044 	
42000510:	403793f0 	
42000514:	3fc94bec 	
42000518:	ffc1ffff 	
4200051c:	fffeffff 	
42000520:	40375f38 	
42000524:	3c0234a4 	
42000528:	3c027dc8 	
4200052c:	3c0234d0 	
42000530:	3c0234e0 	
42000534:	3c027db4 	
42000538:	7fffffff 	
4200053c:	3fc92050 	
42000540:	3c028b48 	
42000544:	3c02352c 	
42000548:	3c023538 	
4200054c:	3c02357c 	
42000550:	3c027d98 	
42000554:	3c0235d4 	
42000558:	40376454 	
4200055c:	3c027d80 	
42000560:	c03fffff 	
42000564:	3fc94be4 	
42000568:	4037fe9c 	
4200056c:	40001be4 	
42000570:	40376588 	
42000574:	3fc92a54 	
42000578:	3fc92a40 	
4200057c:	3fc94c1c 	
42000580:	60008040 	
42000584:	6000804c 	
42000588:	403766e4 	
4200058c:	3fc92a4c 	
42000590:	00000800 	
42000594:	3fc92a48 	
42000598:	3c02362c 	
4200059c:	3c023638 	
420005a0:	0003fffe 	
420005a4:	fc3fffff 	
420005a8:	0001ffff 	
420005ac:	40377670 	
420005b0:	3c023678 	
420005b4:	3c023680 	
420005b8:	3c023688 	
420005bc:	600080e0 	
420005c0:	3c029268 	
420005c4:	600080d8 	
420005c8:	3c028d98 	
420005cc:	600c10e0 	
420005d0:	ffff8fff 	
420005d4:	fffc7fff 	
420005d8:	3c027e8c 	
420005dc:	3c027ea8 	
420005e0:	bfc88000 	
420005e4:	00067fff 	
420005e8:	fffff1ff 	
420005ec:	600c10e4 	
420005f0:	600c10f0 	
420005f4:	600c10e8 	
420005f8:	600c10f4 	
420005fc:	600c1124 	
42000600:	600c11d0 	
42000604:	003ff800 	
42000608:	600c1148 	
4200060c:	600c11f4 	
42000610:	00000e00 	
42000614:	600c114c 	
42000618:	600c11f8 	
4200061c:	600c119c 	
42000620:	600c1248 	
42000624:	600c11a0 	
42000628:	600c124c 	
4200062c:	ff910000 	
42000630:	c0378000 	
42000634:	600c1100 	
42000638:	600c1104 	
4200063c:	600c1114 	
42000640:	600c1108 	
42000644:	600c1118 	
42000648:	0000d008 	
4200064c:	3fc92078 	
42000650:	40382000 	
42000654:	600fe000 	
42000658:	0000d001 	
4200065c:	0000d002 	
42000660:	600c10c4 	
42000664:	600c10c8 	
42000668:	600c10cc 	
4200066c:	600c10d0 	
42000670:	600c10d4 	
42000674:	600c10c0 	
42000678:	600c10d8 	
4200067c:	600c10fc 	
42000680:	3c0237a8 	
42000684:	3c023808 	
42000688:	3c023868 	
4200068c:	3c0238c8 	
42000690:	3c023928 	
42000694:	3c023988 	
42000698:	3c0239e4 	
4200069c:	3c023a40 	
420006a0:	3c023a9c 	
420006a4:	3c023af8 	
420006a8:	3c023b54 	
420006ac:	3c023bb0 	
420006b0:	3c023c0c 	
420006b4:	3c023c68 	
420006b8:	3c023cc4 	
420006bc:	3c023d20 	
420006c0:	3c023d84 	
420006c4:	3c023de8 	
420006c8:	3c023e54 	
420006cc:	3c023eb8 	
420006d0:	3c023f1c 	
420006d4:	400006d8 	
420006d8:	0000d003 	
420006dc:	0000d004 	
420006e0:	0000d005 	
420006e4:	0000d006 	
420006e8:	0000d007 	
420006ec:	3c023f88 	
420006f0:	3c027ec4 	
420006f4:	3c023ffd 	
420006f8:	3c027edc 	
420006fc:	3fc920c0 	
42000700:	600fe000 	
42000704:	3c0240b8 	
42000708:	3c0280dc 	
4200070c:	000008ca 	
42000710:	3c02407c 	
42000714:	3c024d94 	
42000718:	bb10c433 	
4200071c:	400011dc 	
42000720:	3fc94f78 	
42000724:	3c024e38 	
42000728:	3c0284c8 	
4200072c:	3c024dec 	
42000730:	3fc94f24 	
42000734:	3c024e68 	
42000738:	3fc94fd8 	
4200073c:	3fc94fd0 	
42000740:	3fc94fcc 	
42000744:	40376a1c 	
42000748:	40376a5c 	
4200074c:	000f4240 	
42000750:	4037c858 	
42000754:	3fc94fe8 	
42000758:	40376c1c 	
4200075c:	3fc94fe0 	
42000760:	60008058 	
42000764:	6000805c 	
42000768:	3fc927c8 	
4200076c:	3fceffd4 	
42000770:	3fc92108 	
42000774:	3fc927b8 	
42000778:	3fceffd0 	
4200077c:	42005e50 	
42000780:	3fc927b4 	
42000784:	4037fe90 	
42000788:	3c020d4c 	
4200078c:	3c024ea0 	
42000790:	40379aa0 	
42000794:	4037b890 	
42000798:	40379e88 	
4200079c:	40379d80 	
420007a0:	40379c50 	
420007a4:	3fc921a4 	
420007a8:	3c024efc 	
420007ac:	3c02852c 	
420007b0:	3c024ef1 	
420007b4:	40379c84 	
420007b8:	40379ad8 	
420007bc:	3fc921ac 	
420007c0:	3fc94ff0 	
420007c4:	3c024f20 	
420007c8:	3c028544 	
420007cc:	3c024f45 	
420007d0:	4037ba2c 	
420007d4:	420060ec 	
420007d8:	4037fea8 	
420007dc:	4037c824 	
420007e0:	3fc949d8 	
420007e4:	3fc94ff8 	
420007e8:	42005dfc 	
420007ec:	3c024f60 	
420007f0:	3c024f6c 	
420007f4:	40376c38 	
420007f8:	3c028574 	
420007fc:	3fc95000 	
42000800:	4037e3c8 	
42000804:	4037e54c 	
42000808:	4037e57c 	
4200080c:	4037e50c 	
42000810:	4037e5a0 	
42000814:	4037e5c4 	
42000818:	3fc95010 	
4200081c:	3fc9500c 	
42000820:	40376c50 	
42000824:	403786ec 	
42000828:	3fc921c0 	
4200082c:	0000c34f 	
42000830:	3fc921b4 	
42000834:	3fc95018 	
42000838:	00001000 	
4200083c:	3fc95014 	
42000840:	40375fcc 	
42000844:	420066fc 	
42000848:	00004002 	
4200084c:	00002000 	
42000850:	3fc921c8 	
42000854:	40376a2c 	
42000858:	40376a6c 	
4200085c:	3c024fa8 	
42000860:	3c02857c 	
42000864:	3c024ff0 	
42000868:	3fc921c4 	
4200086c:	3c028598 	
42000870:	3c025008 	
42000874:	3fc9501c 	
42000878:	40379520 	
4200087c:	403794f0 	
42000880:	3fc9502c 	
42000884:	3fc95020 	
42000888:	3c025008 	
4200088c:	3fc95024 	
42000890:	3c025018 	
42000894:	3c028604 	
42000898:	3c024d94 	
4200089c:	3fc95038 	
420008a0:	3fc95034 	
420008a4:	40001218 	
420008a8:	40001260 	
420008ac:	3c025050 	
420008b0:	3c025054 	
420008b4:	3c0286b0 	
420008b8:	3c025049 	
420008bc:	4000123c 	
420008c0:	3fc921f0 	
420008c4:	4000120c 	
420008c8:	3fc95030 	
420008cc:	40379cc4 	
420008d0:	3fc95058 	
420008d4:	3c025050 	
420008d8:	000021b6 	
420008dc:	3c0286c0 	
420008e0:	3c025094 	
420008e4:	3c0250a0 	
420008e8:	3c0250b4 	
420008ec:	3fc9505c 	
420008f0:	3c0250d8 	
420008f4:	3c0250f0 	
420008f8:	3c025134 	
420008fc:	3c02516c 	
42000900:	3c025184 	
42000904:	3c02518c 	
42000908:	3fc922d4 	
4200090c:	3fc950b0 	
42000910:	3fc94ff4 	
42000914:	42007ca0 	
42000918:	3fc922d0 	
4200091c:	3fc95098 	
42000920:	3fc922cc 	
42000924:	3fc95080 	
42000928:	3fc95078 	
4200092c:	3fc922c8 	
42000930:	3fc95060 	
42000934:	3fc922b0 	
42000938:	3c0251c0 	
4200093c:	3c0251dc 	
42000940:	40001200 	
42000944:	3c0251f4 	
42000948:	3c025208 	
4200094c:	3c025228 	
42000950:	3c025240 	
42000954:	3c02525c 	
42000958:	00001387 	
4200095c:	d1b71759 	
42000960:	3c025274 	
42000964:	3c025288 	
42000968:	3c0252a8 	
4200096c:	3c0252c8 	
42000970:	3c0252ec 	
42000974:	3c025310 	
42000978:	3c025330 	
4200097c:	3c025344 	
42000980:	3c02535c 	
42000984:	3c025370 	
42000988:	3c025384 	
4200098c:	3c02539c 	
42000990:	3c0253b4 	
42000994:	3c0253cc 	
42000998:	3c0253e4 	
4200099c:	3c025400 	
420009a0:	3c02541c 	
420009a4:	3c025438 	
420009a8:	3c025454 	
420009ac:	3c025470 	
420009b0:	3c02548c 	
420009b4:	3c0254a8 	
420009b8:	3c0254c4 	
420009bc:	3c0254e0 	
420009c0:	3c025500 	
420009c4:	3c025520 	
420009c8:	3c02553c 	
420009cc:	3c025560 	
420009d0:	3c025598 	
420009d4:	3c02559c 	
420009d8:	3c0255b8 	
420009dc:	3c0255d4 	
420009e0:	3c0255f0 	
420009e4:	3c02560c 	
420009e8:	3c025620 	
420009ec:	3c025624 	
420009f0:	3c025638 	
420009f4:	3c025654 	
420009f8:	3c025678 	
420009fc:	3c02569c 	
42000a00:	3c0256a4 	
42000a04:	3c0256cc 	
42000a08:	3c0256f4 	
42000a0c:	3c025730 	
42000a10:	3c025738 	
42000a14:	3c025758 	
42000a18:	3c02578c 	
42000a1c:	3c025798 	
42000a20:	3c0251d4 	
42000a24:	3c0257d0 	
42000a28:	400013f8 	
42000a2c:	3c028868 	
42000a30:	3c025d8c 	
42000a34:	3c025d94 	
42000a38:	3c025dac 	
42000a3c:	3c028cd4 	
42000a40:	3c02884c 	
42000a44:	3c028830 	
42000a48:	3c025dc0 	
42000a4c:	3c028814 	
42000a50:	3c0287e0 	
42000a54:	3fc9270c 	
42000a58:	3c0287c8 	
42000a5c:	3c0287b0 	
42000a60:	3c028798 	
42000a64:	3c028880 	
42000a68:	3c0287f8 	
42000a6c:	3c025ddc 	
42000a70:	3c025df4 	
42000a74:	3c028784 	
42000a78:	3c028770 	
42000a7c:	3fceffe4 	
42000a80:	403775b0 	
42000a84:	41ffffff 	
42000a88:	43ffffff 	
42000a8c:	3bffffff 	
42000a90:	3dffffff 	
42000a94:	3c024598 	
42000a98:	3c02891c 	
42000a9c:	3c020480 	
42000aa0:	4201723e 	
42000aa4:	42000020 	
42000aa8:	3c025eb0 	
42000aac:	3c028930 	
42000ab0:	3c025f60 	
42000ab4:	0000ffff 	
42000ab8:	3c02a53c 	
42000abc:	3c020020 	
42000ac0:	3c025f70 	
42000ac4:	3c028904 	
42000ac8:	3c02895c 	
42000acc:	3c026004 	
42000ad0:	3c028948 	
42000ad4:	3fc950c8 	
42000ad8:	3c026040 	
42000adc:	3fc9366c 	
42000ae0:	3c0288f8 	
42000ae4:	3c026064 	
42000ae8:	3c0260d0 	
42000aec:	3c026088 	
42000af0:	3fc950cc 	
42000af4:	3c0260ac 	
42000af8:	3c026130 	
42000afc:	3c02614c 	
42000b00:	3c026194 	
42000b04:	3c0261e0 	
42000b08:	3c0288ec 	
42000b0c:	42000000 	
42000b10:	3c000000 	
42000b14:	4037606c 	
42000b18:	4037769c 	
42000b1c:	3c0288dc 	
42000b20:	3c0261e8 	
42000b24:	3c026238 	
42000b28:	40377788 	
42000b2c:	3c0288c4 	
42000b30:	3c026274 	
42000b34:	3c0262b0 	
42000b38:	4037cda0 	
42000b3c:	403777a0 	
42000b40:	3fc950f8 	
42000b44:	3c0262d8 	
42000b48:	3c0289dc 	
42000b4c:	3c02630f 	
42000b50:	3c02646c 	
42000b54:	3c0289f0 	
42000b58:	3c02645f 	
42000b5c:	3c0264a0 	
42000b60:	3c028a04 	
42000b64:	3c0264d3 	
42000b68:	3c028a14 	
42000b6c:	40001fa4 	
42000b70:	40001f74 	
42000b74:	40377c54 	
42000b78:	60003000 	
42000b7c:	3c0266c4 	
42000b80:	3c028af0 	
42000b84:	3c0266c8 	
42000b88:	3fc93698 	
42000b8c:	3fc936b8 	
42000b90:	3c026730 	
42000b94:	3c026798 	
42000b98:	3c028ad4 	
42000b9c:	3c02681c 	
42000ba0:	3fc95108 	
42000ba4:	40378540 	
42000ba8:	403784cc 	
42000bac:	403801a8 	
42000bb0:	40377d30 	
42000bb4:	40378150 	
42000bb8:	3fc93670 	
42000bbc:	40377b14 	
42000bc0:	3c029340 	
42000bc4:	3fc93710 	
42000bc8:	3fc936e8 	
42000bcc:	3fc92794 	
42000bd0:	3fc95114 	
42000bd4:	40378028 	
42000bd8:	3fc95118 	
42000bdc:	3c0268f4 	
42000be0:	3c028b30 	
42000be4:	3c0268f8 	
42000be8:	40379760 	
42000bec:	6000704c 	
42000bf0:	60007050 	
42000bf4:	80000000 	
42000bf8:	3c026924 	
42000bfc:	3c026930 	
42000c00:	3c02696c 	
42000c04:	40001464 	
42000c08:	60002000 	
42000c0c:	60024000 	
42000c10:	60025000 	
42000c14:	04c4b400 	
42000c18:	3c02932c 	
42000c1c:	3fc927a0 	
42000c20:	4037ff1c 	
42000c24:	3fc9511c 	
42000c28:	40377680 	
42000c2c:	00009000 	
42000c30:	3c026f0c 	
42000c34:	3c026f18 	
42000c38:	3c026f48 	
42000c3c:	3fc95124 	
42000c40:	000050aa 	
42000c44:	0000ebeb 	
42000c48:	40001c5c 	
42000c4c:	40001c68 	
42000c50:	40001224 	
42000c54:	40001c74 	
42000c58:	3fc95120 	
42000c5c:	3c026f74 	
42000c60:	3c020230 	
42000c64:	3c029388 	
42000c68:	3c026fdf 	
42000c6c:	3c026fec 	
42000c70:	3c029374 	
42000c74:	00008c00 	
42000c78:	3fc95128 	
42000c7c:	4200a940 	
42000c80:	3c027000 	
42000c84:	3c02939c 	
42000c88:	3c027044 	
42000c8c:	3c027054 	
42000c90:	3fc9512c 	
42000c94:	3c0296d8 	
42000c98:	4200ac98 	
42000c9c:	3c029404 	
42000ca0:	3c029418 	
42000ca4:	4200b1f0 	
42000ca8:	3c02944c 	
42000cac:	4200b228 	
42000cb0:	3c02946c 	
42000cb4:	4200b254 	
42000cb8:	3c02948c 	
42000cbc:	3c029498 	
42000cc0:	3c0296ec 	
42000cc4:	3c0294a7 	
42000cc8:	3c0294cb 	
42000ccc:	3c029784 	
42000cd0:	3c029798 	
42000cd4:	4200adc0 	
42000cd8:	3c029738 	
42000cdc:	4200adec 	
42000ce0:	3c029770 	
42000ce4:	3fc95134 	
42000ce8:	3fc95130 	
42000cec:	3c0294f1 	
42000cf0:	3c02950b 	
42000cf4:	3c02953c 	
42000cf8:	3c02954d 	
42000cfc:	3c02955d 	
42000d00:	3c029566 	
42000d04:	400014f4 	
42000d08:	4000138c 	
42000d0c:	bcd4d500 	
42000d10:	b8b1aabc 	
42000d14:	3fc95148 	
42000d18:	3fc95144 	
42000d1c:	3fc95140 	
42000d20:	4200b12c 	
42000d24:	3fc927b0 	
42000d28:	3c0297ac 	
42000d2c:	3c0297c0 	
42000d30:	3c0297d4 	
42000d34:	3fc95150 	
42000d38:	3ffffffc 	
42000d3c:	3c029570 	
42000d40:	3fc9515c 	
42000d44:	3c029588 	
42000d48:	376ae4        	lsi	f14, a10, 220
42000d4b:	6b6840        	ole.s	b6, f8, f4
42000d4e:	d44037        	ball	a0, a3, 42000d26 <_stext+0xd06>
42000d51:	fe          	.byte	0xfe
42000d52:	b44037        	ball	a0, a3, 42000d0a <_stext+0xcea>
42000d55:	376a      	add.n	a3, a7, a6
42000d57:	000140        	lsi	f4, a1, 0
42000d5a:	4c2040        	lsi	f4, a0, 0x130
42000d5d:	4200b7        	bnone	a0, a11, 42000da3 <_stext+0xd83>
42000d60:	be98      	l32i.n	a9, a14, 44
42000d62:	d44200        	extui	a4, a0, 2, 14
42000d65:	be          	.byte	0xbe
42000d66:	104200        	and	a4, a2, a0
42000d69:	bf          	.byte	0xbf
42000d6a:	4c4200        	lsi	f0, a2, 0x130
42000d6d:	bf          	.byte	0xbf
42000d6e:	cc4200        	lsi	f0, a2, 0x330
42000d71:	3fc951        	l32r	a5, 41fd0c98 <_coredump_iram_end+0x1c4ec98>
42000d74:	c95164        	lsi	f6, a1, 0x324
42000d77:	3f          	.byte	0x3f
42000d78:	c95234        	lsi	f3, a2, 0x324
42000d7b:	3f          	.byte	0x3f
42000d7c:	376a90        	lsi	f9, a10, 220
42000d7f:	b53c40        	extui	a3, a4, 28, 12
42000d82:	9c4200        	lsi	f0, a2, 0x270
42000d85:	3fc952        	addi	a5, a9, 63
42000d88:	b83c      	movi.n	a8, 59
42000d8a:	014200        	slli	a4, a2, 32
42000d8d:	ffff00        	f64cmph	a15, a15, a0, 15
42000d90:	37fef4        	lsi	f15, a14, 220
42000d93:	b85040        	lsi	f4, a0, 0x2e0
42000d96:	884200        	lsi	f0, a2, 0x220
42000d99:	00b8      	l32i.n	a11, a0, 0
42000d9b:	b8a442        	movi	a4, 0x4b8
42000d9e:	804200        	add	a4, a2, a0
42000da1:	ff          	.byte	0xff
42000da2:	ff          	.byte	0xff
42000da3:	7f          	.byte	0x7f
42000da4:	37fee0        	lsi	f14, a14, 220
42000da7:	134440        	lsi	f4, a4, 76
42000daa:	b24000        	mulsh	a4, a0, a0
42000dad:	3c0295        	call4	4203cdd8 <_etext+0x25b9a>
42000db0:	c927c4        	lsi	f12, a7, 0x324
42000db3:	3f          	.byte	0x3f
42000db4:	6b7c      	movi.n	a11, -10
42000db6:	a04037        	ball	a0, a3, 42000d5a <_stext+0xd3a>
42000db9:	3fc952        	addi	a5, a9, 63
42000dbc:	28b8      	l32i.n	a11, a8, 8
42000dbe:	3fc9      	s32i.n	a12, a15, 12
42000dc0:	532c      	movi.n	a3, 37
42000dc2:	3fc9      	s32i.n	a12, a15, 12
42000dc4:	0298e4        	lsi	f14, a8, 8
42000dc7:	9c3c      	movi.n	a12, 57
42000dc9:	3c02a1        	l32r	a10, 41fcfdd4 <_coredump_iram_end+0x1c4ddd4>
42000dcc:	02a130        	andb	b10, b1, b3
42000dcf:	c43c      	movi.n	a4, 60
42000dd1:	3c02a0        	lsi	f10, a2, 240
42000dd4:	98e8      	l32i.n	a14, a8, 36
42000dd6:	213c02        	lsi	f0, a12, 132
42000dd9:	1208      	l32i.n	a0, a2, 4
42000ddb:	990800        	lsi	f0, a8, 0x264
42000dde:	683c02        	lsi	f0, a12, 0x1a0
42000de1:	0299      	s32i.n	a9, a2, 0
42000de3:	803c      	movi.n	a0, 56
42000de5:	0299      	s32i.n	a9, a2, 0
42000de7:	b43c      	movi.n	a4, 59
42000de9:	3c0295        	call4	4203ce14 <_etext+0x25bd6>
42000dec:	95b8      	l32i.n	a11, a5, 36
42000dee:	bc3c02        	lsi	f0, a12, 0x2f0
42000df1:	3c0295        	call4	4203ce1c <_etext+0x25bde>
42000df4:	0295c0        	andb	b9, b5, b12
42000df7:	c43c      	movi.n	a4, 60
42000df9:	3c0295        	call4	4203ce24 <_etext+0x25be6>
42000dfc:	0295d5        	call4	4200375c <esp_intr_alloc_intrstatus+0x104>
42000dff:	983c      	movi.n	a8, 57
42000e01:	0299      	s32i.n	a9, a2, 0
42000e03:	143c      	movi.n	a4, 49
42000e05:	029b      	addi.n	a0, a2, 9
42000e07:	043c      	movi.n	a4, 48
42000e09:	029b      	addi.n	a0, a2, 9
42000e0b:	e63c      	movi.n	a6, 62
42000e0d:	3c0295        	call4	4203ce38 <_etext+0x25bfa>
42000e10:	e00000        	subx4	a0, a0, a0
42000e13:	3f          	.byte	0x3f
42000e14:	ff          	.byte	0xff
42000e15:	ff          	.byte	0xff
42000e16:	ef          	.byte	0xef
42000e17:	7f          	.byte	0x7f
42000e18:	258c      	beqz.n	a5, 42000e1e <_stext+0xdfe>
42000e1a:	b84000        	lsi	f0, a0, 0x2e0
42000e1d:	400023        	lsi	f2, a0, 0x100
42000e20:	23dc      	bnez.n	a3, 42000e36 <_stext+0xe16>
42000e22:	184000        	lsxp	f4, a0, a0
42000e25:	400024        	lsi	f2, a0, 0x100
42000e28:	228c      	beqz.n	a2, 42000e2e <_stext+0xe0e>
42000e2a:	d44000        	extui	a4, a0, 0, 14
42000e2d:	400022        	l8ui	a2, a0, 64
42000e30:	002334        	lsi	f3, a3, 0
42000e33:	24fc40        	extui	a15, a4, 12, 3
42000e36:	6c4000        	lsi	f0, a0, 0x1b0
42000e39:	400024        	lsi	f2, a0, 0x100
42000e3c:	0023a0        	lsi	f10, a3, 0
42000e3f:	257440        	extui	a7, a4, 20, 3
42000e42:	244000        	extui	a4, a0, 0, 3
42000e45:	029b      	addi.n	a0, a2, 9
42000e47:	443c      	movi.n	a4, 52
42000e49:	029b      	addi.n	a0, a2, 9
42000e4b:	a43c      	movi.n	a4, 58
42000e4d:	029b      	addi.n	a0, a2, 9
42000e4f:	bc3c      	movi.n	a12, 59
42000e51:	029b      	addi.n	a0, a2, 9
42000e53:	d53c      	movi.n	a5, 61
42000e55:	3c0295        	call4	4203ce80 <_etext+0x25c42>
42000e58:	0295c4        	lsi	f12, a5, 8
42000e5b:	d43c      	movi.n	a4, 61
42000e5d:	029b      	addi.n	a0, a2, 9
42000e5f:	503c      	movi.n	a0, 53
42000e61:	029d      	mov.n	a9, a2
42000e63:	403c      	movi.n	a0, 52
42000e65:	029d      	mov.n	a9, a2
42000e67:	4c3c      	movi.n	a12, 52
42000e69:	011a      	add.n	a0, a1, a1
42000e6b:	28bc42        	l32ai	a4, a12, 160
42000e6e:	3fc9      	s32i.n	a12, a15, 12
42000e70:	ff          	.byte	0xff
42000e71:	ff          	.byte	0xff
42000e72:	0f          	.byte	0xf
42000e73:	95e880        	extui	a14, a8, 24, 10
42000e76:	f03c02        	lsi	f0, a12, 0x3c0
42000e79:	3c0295        	call4	4203cea4 <_etext+0x25c66>
42000e7c:	0295f1        	l32r	a15, 41fc18d0 <_coredump_iram_end+0x1c3f8d0>
42000e7f:	f43c      	movi.n	a4, 63
42000e81:	3c0295        	call4	4203ceac <_etext+0x25c6e>
42000e84:	0295e6        	bgei	a5, 10, 42000e8a <_stext+0xe6a>
42000e87:	f53c      	movi.n	a5, 63
42000e89:	3c0295        	call4	4203ceb4 <_etext+0x25c76>
42000e8c:	960c      	movi.n	a6, 9
42000e8e:	e73c02        	lsi	f0, a12, 0x39c
42000e91:	3c0295        	call4	4203cebc <_etext+0x25c7e>
42000e94:	f00000        	subx8	a0, a0, a0
42000e97:	3f          	.byte	0x3f
42000e98:	029dc0        	andb	b9, b13, b12
42000e9b:	603c      	movi.n	a0, 54
42000e9d:	3c0296        	bltz	a2, 42001261 <__esp_system_init_fn_init_show_app_info+0x79>
42000ea0:	9d98      	l32i.n	a9, a13, 36
42000ea2:	003c02        	lsi	f0, a12, 0
42000ea5:	402400        	ssa8l	a4
42000ea8:	140000        	extui	a0, a0, 0, 2
42000eab:	000040        	lsi	f4, a0, 0
42000eae:	401c      	movi.n	a0, 20
42000eb0:	6f4361        	l32r	a6, 41fdcbbc <_coredump_iram_end+0x1c5abbc>
42000eb3:	87a763        	lsi	f6, a7, 0x21c
42000eb6:	b33fd2        	lsi	f13, a15, 0x2cc
42000eb9:	60c8      	l32i.n	a12, a0, 24
42000ebb:	288b      	addi.n	a2, a8, 8
42000ebd:	c68a      	add.n	a12, a6, a8
42000ebf:	3f          	.byte	0x3f
42000ec0:	79fb      	addi.n	a7, a9, 15
42000ec2:	9f          	.byte	0x9f
42000ec3:	441350        	extui	a1, a5, 3, 5
42000ec6:	643fd3        	lsi	f13, a15, 0x190
42000ec9:	400023        	lsi	f2, a0, 0x100
42000ecc:	002184        	lsi	f8, a1, 0
42000ecf:	225040        	orb	b5, b0, b4
42000ed2:	f54000        	extui	a4, a0, 16, 16
42000ed5:	3c0295        	call4	4203cf00 <_etext+0x25cc2>
42000ed8:	029671        	l32r	a7, 41fc1930 <_coredump_iram_end+0x1c3f930>
42000edb:	003c      	movi.n	a0, 48
42000edd:	ff          	.byte	0xff
42000ede:	604037        	ball	a0, a3, 42000f42 <_stext+0xf22>
42000ee1:	3c0296        	bltz	a2, 420012a5 <__esp_system_init_fn_init_show_app_info+0xbd>
42000ee4:	8e39      	s32i.n	a3, a14, 32
42000ee6:	6038e3        	lsi	f14, a8, 0x180
42000ee9:	029d      	mov.n	a9, a2
42000eeb:	883c      	movi.n	a8, 56
42000eed:	9e          	.byte	0x9e
42000eee:	a83c02        	lsi	f0, a12, 0x2a0
42000ef1:	9e          	.byte	0x9e
42000ef2:	083c02        	lsi	f0, a12, 32
42000ef5:	9f          	.byte	0x9f
42000ef6:	203c02        	lsi	f0, a12, 128
42000ef9:	9f          	.byte	0x9f
42000efa:	d53c02        	lsi	f0, a12, 0x354
42000efd:	3c0295        	call4	4203cf28 <_etext+0x25cea>
42000f00:	0295c4        	lsi	f12, a5, 8
42000f03:	383c      	movi.n	a8, 51
42000f05:	9f          	.byte	0x9f
42000f06:	b43c02        	lsi	f0, a12, 0x2d0
42000f09:	3c02a0        	lsi	f10, a2, 240
42000f0c:	02a0a4        	lsi	f10, a0, 8
42000f0f:	003c      	movi.n	a0, 48
42000f11:	100000        	and	a0, a0, a0
42000f14:	800000        	add	a0, a0, a0
42000f17:	000000        	ill
42000f1a:	000004        	lsi	f0, a0, 0
42000f1d:	002000        	isync
42000f20:	020000        	andb	b0, b0, b0
42000f23:	000000        	ill
42000f26:	000010        	lsi	f1, a0, 0
42000f29:	000100        	lsi	f0, a1, 0
42000f2c:	080000        	lsx	f0, a0, a0
42000f2f:	078f00        	lsi	f0, a15, 28
42000f32:	0078      	l32i.n	a7, a0, 0
42000f34:	030000        	rsr.lbeg	a0
42000f37:	3e0800        	f64norm	a0, a8, a0, 1
42000f3a:	080000        	lsx	f0, a0, a0
42000f3d:	600c00        	lsi	f0, a12, 0x180
42000f40:	c04001        	l32r	a0, 41ff1040 <_coredump_iram_end+0x1c6f040>
42000f43:	601817        	beq	a8, a1, 42000fa7 <_stext+0xf87>
42000f46:	0c6002        	s32i	a0, a0, 48
42000f49:	600c00        	lsi	f0, a12, 0x180
42000f4c:	0235e0        	andb	b3, b5, b14
42000f4f:	e03c      	movi.n	a0, 62
42000f51:	027d      	mov.n	a7, a2
42000f53:	1c3c      	movi.n	a12, 49
42000f55:	3c0236        	entry	a2, 0x1e00
42000f58:	2058      	l32i.n	a5, a0, 8
42000f5a:	3fc9      	s32i.n	a12, a15, 12
42000f5c:	c94bf0        	lsi	f15, a11, 0x324
42000f5f:	3f          	.byte	0x3f
42000f60:	36c8      	l32i.n	a12, a6, 12
42000f62:	543c02        	lsi	f0, a12, 0x150
42000f65:	7e          	.byte	0x7e
42000f66:	093c02        	lsi	f0, a12, 36
42000f69:	3c0237        	bnone	a2, a3, 42000fa9 <_stext+0xf89>
42000f6c:	007000        	waiti	0
42000f6f:	371460        	lsi	f6, a4, 220
42000f72:	383c02        	lsi	f0, a12, 224
42000f75:	7e          	.byte	0x7e
42000f76:	593c02        	lsi	f0, a12, 0x164
42000f79:	002a      	add.n	a0, a0, a2
42000f7b:	32c700        	orbc	b12, b7, b0
42000f7e:	200000        	or	a0, a0, a0
42000f81:	7e          	.byte	0x7e
42000f82:	083c02        	lsi	f0, a12, 32
42000f85:	7e          	.byte	0x7e
42000f86:	c53c02        	lsi	f0, a12, 0x314
42000f89:	000027        	bnone	a0, a2, 42000f8d <_stext+0xf6d>
42000f8c:	c92074        	lsi	f7, a0, 0x324
42000f8f:	3f          	.byte	0x3f
42000f90:	206c      	movi.n	a0, -30
42000f92:	3fc9      	s32i.n	a12, a15, 12
42000f94:	c92070        	lsi	f7, a0, 0x324
42000f97:	3f          	.byte	0x3f
42000f98:	2068      	l32i.n	a6, a0, 8
42000f9a:	3fc9      	s32i.n	a12, a15, 12
42000f9c:	3728      	l32i.n	a2, a7, 12
42000f9e:	303c02        	lsi	f0, a12, 192
42000fa1:	3c0237        	bnone	a2, a3, 42000fe1 <_stext+0xfc1>
42000fa4:	3784a4        	lsi	f10, a4, 220
42000fa7:	8a0440        	round.s	a0, f4, 4
42000faa:	bc4037        	ball	a0, a3, 42000f6a <_stext+0xf4a>
42000fad:	403793        	lsi	f9, a7, 0x100
42000fb0:	378f10        	lsi	f1, a15, 220
42000fb3:	678440        	lsi	f4, a4, 0x19c
42000fb6:	904037        	ball	a0, a3, 42000f4a <_stext+0xf2a>
42000fb9:	600080        	neg	a0, a8
42000fbc:	ff          	.byte	0xff
42000fbd:	ff          	.byte	0xff
42000fbe:	fffd      	lsi	f15, a15, 60
42000fc0:	008094        	lsi	f9, a0, 0
42000fc3:	803460        	add	a3, a4, a6
42000fc6:	1c6000        	lsi	f0, a0, 112
42000fc9:	600080        	neg	a0, a8
42000fcc:	3f          	.byte	0x3f
42000fcd:	ffffc0        	f64cmph	a15, a15, a12, 15
42000fd0:	802c      	movi.n	a0, 40
42000fd2:	ff6000        	f64cmph	a6, a0, a0, 15
42000fd5:	ffff00        	f64cmph	a15, a15, a0, 15
42000fd8:	7df8      	l32i.n	a15, a13, 28
42000fda:	243c02        	lsi	f0, a12, 144
42000fdd:	600080        	neg	a0, a8
42000fe0:	ff          	.byte	0xff
42000fe1:	ffff01        	l32r	a0, 42000fe0 <_stext+0xfc0> (ffff01ff <_rtc_reserved_end+0x9fef01ff>)
42000fe4:	ff          	.byte	0xff
42000fe5:	ff          	.byte	0xff
42000fe6:	30fe00        	xor	a15, a14, a0
42000fe9:	600080        	neg	a0, a8
42000fec:	8028      	l32i.n	a2, a0, 32
42000fee:	206000        	or	a6, a0, a0
42000ff1:	600080        	neg	a0, a8
42000ff4:	ff          	.byte	0xff
42000ff5:	7f          	.byte	0x7f
42000ff6:	2cff00        	lsi	f0, a15, 176
42000ff9:	600c41        	l32r	a4, 41fd902c <_coredump_iram_end+0x1c5702c>
42000ffc:	60a8      	l32i.n	a10, a0, 24
42000ffe:	086002        	s32i	a0, a0, 32
42001001:	600c40        	lsi	f4, a12, 0x180
42001004:	4068      	l32i.n	a6, a0, 16
42001006:	600c      	movi.n	a0, 6
42001008:	30e8      	l32i.n	a14, a0, 12
4200100a:	e86000        	lsi	f0, a0, 0x3a0
4200100d:	600020        	neg	a0, a2
42001010:	008074        	lsi	f7, a0, 0
42001013:	800060        	add	a0, a0, a6
42001016:	ff6000        	f64cmph	a6, a0, a0, 15
42001019:	df          	.byte	0xdf
4200101a:	ff          	.byte	0xff
4200101b:	ff          	.byte	0xff
4200101c:	ff          	.byte	0xff
4200101d:	ff          	.byte	0xff
4200101e:	fffb      	addi.n	a15, a15, 15
42001020:	ff          	.byte	0xff
42001021:	fffff7        	bbsi	a15, 31, 42001024 <_stext+0x1004>
42001024:	8088      	l32i.n	a8, a0, 32
42001026:	ff6000        	f64cmph	a6, a0, a0, 15
42001029:	ff          	.byte	0xff
4200102a:	84fff7        	bbsi	a15, 31, 42000fb2 <_stext+0xf92>
4200102d:	600080        	neg	a0, a8
42001030:	0c0014        	lsi	f1, a0, 48
42001033:	ffff60        	f64cmph	a15, a15, a6, 15
42001036:	ef          	.byte	0xef
42001037:	ff          	.byte	0xff
42001038:	ff          	.byte	0xff
42001039:	ff          	.byte	0xff
4200103a:	ff          	.byte	0xff
4200103b:	cf          	.byte	0xcf
4200103c:	ff          	.byte	0xff
4200103d:	ff          	.byte	0xff
4200103e:	3f          	.byte	0x3f
4200103f:	ff          	.byte	0xff
42001040:	ff          	.byte	0xff
42001041:	ef          	.byte	0xef
42001042:	ff          	.byte	0xff
42001043:	ff          	.byte	0xff
42001044:	ff          	.byte	0xff
42001045:	ff          	.byte	0xff
42001046:	ff          	.byte	0xff
42001047:	fffff3        	lsi	f15, a15, 0x3fc
4200104a:	bf          	.byte	0xbf
4200104b:	ff          	.byte	0xff
4200104c:	ff          	.byte	0xff
4200104d:	ff          	.byte	0xff
4200104e:	ff          	.byte	0xff
4200104f:	10fc      	bnez.n	a0, 42001084 <_stext+0x1064>
42001051:	600c00        	lsi	f0, a12, 0x180
42001054:	8f1c      	movi.n	a15, 24
42001056:	004037        	ball	a0, a3, 4200105a <_stext+0x103a>
42001059:	0088      	l32i.n	a8, a0, 0
4200105b:	ffff60        	f64cmph	a15, a15, a6, 15
4200105e:	ff          	.byte	0xff
4200105f:	9f          	.byte	0x9f
42001060:	4c2c      	movi.n	a12, 36
42001062:	3fc9      	s32i.n	a12, a15, 12
42001064:	40dc      	bnez.n	a0, 4200107c <_stext+0x105c>
42001066:	e83c02        	lsi	f0, a12, 0x3a0
42001069:	3c0240        	lsi	f4, a2, 240
4200106c:	016b20        	slli	a6, a11, 30
4200106f:	410842        	l8ui	a4, a8, 65
42001072:	283c02        	lsi	f0, a12, 160
42001075:	3c0241        	l32r	a4, 41fd0080 <_coredump_iram_end+0x1c4e080>
42001078:	37ba80        	lsi	f8, a10, 220
4200107b:	220040        	orb	b0, b0, b4
4200107e:	500000        	lsi	f0, a0, 0x140
42001081:	3c0241        	l32r	a4, 41fd008c <_coredump_iram_end+0x1c4e08c>
42001084:	016b34        	lsi	f3, a11, 4
42001087:	0f6442        	s32i	a4, a4, 60
4200108a:	f83c02        	lsi	f0, a12, 0x3e0
4200108d:	3c0280        	lsi	f8, a2, 240
42001090:	024172        	s8i	a7, a1, 2
42001093:	003c      	movi.n	a0, 48
42001095:	000000        	ill
42001098:	37c7c0        	lsi	f12, a7, 220
4200109b:	4f0840        	f64cmph	a0, a8, a4, 4
4200109e:	3fc9      	s32i.n	a12, a15, 12
420010a0:	a048      	l32i.n	a4, a0, 40
420010a2:	1c4037        	ball	a0, a3, 420010c2 <_stext+0x10a2>
420010a5:	022a      	add.n	a0, a2, a2
420010a7:	843c      	movi.n	a4, 56
420010a9:	027a      	add.n	a0, a2, a7
420010ab:	3e3c      	movi.n	a14, 51
420010ad:	022a      	add.n	a0, a2, a2
420010af:	843c      	movi.n	a4, 56
420010b1:	37fb      	addi.n	a3, a7, 15
420010b3:	6d0040        	lsi	f4, a0, 0x1b4
420010b6:	084201        	l32r	a0, 41fc31c0 <_coredump_iram_end+0x1c411c0>
420010b9:	4037e7        	bltu	a7, a14, 420010fd <_stext+0x10dd>
420010bc:	ec1c      	movi.n	a12, 30
420010be:	184037        	ball	a0, a3, 420010da <_stext+0x10ba>
420010c1:	37e8      	l32i.n	a14, a7, 12
420010c3:	e72c40        	lsi	f4, a12, 0x39c
420010c6:	ff4037        	ball	a0, a3, 420010c9 <_stext+0x10a9>
420010c9:	ffffc0        	f64cmph	a15, a15, a12, 15
420010cc:	ff          	.byte	0xff
420010cd:	ff          	.byte	0xff
420010ce:	8f          	.byte	0x8f
420010cf:	ff          	.byte	0xff
420010d0:	300000        	xor	a0, a0, a0
420010d3:	000000        	ill
420010d6:	000040        	lsi	f4, a0, 0
420010d9:	005000        	syscall
420010dc:	ff          	.byte	0xff
420010dd:	3f          	.byte	0x3f
420010de:	fffff0        	f64cmph	a15, a15, a15, 15
420010e1:	ff          	.byte	0xff
420010e2:	7f          	.byte	0x7f
420010e3:	2a5c80        	mul.s	f5, f12, f8
420010e6:	743c02        	lsi	f0, a12, 0x1d0
420010e9:	027b      	addi.n	a0, a2, 7
420010eb:	db3c      	movi.n	a11, 61
420010ed:	022a      	add.n	a0, a2, a2
420010ef:	e43c      	movi.n	a4, 62
420010f1:	022a      	add.n	a0, a2, a2
420010f3:	283c      	movi.n	a8, 50
420010f5:	022b      	addi.n	a0, a2, 2
420010f7:	303c      	movi.n	a0, 51
420010f9:	022b      	addi.n	a0, a2, 2
420010fb:	383c      	movi.n	a8, 51
420010fd:	022b      	addi.n	a0, a2, 2
420010ff:	983c      	movi.n	a8, 57
42001101:	6e          	.byte	0x6e
42001102:	504201        	l32r	a0, 41fd520c <_coredump_iram_end+0x1c5320c>
42001105:	022b      	addi.n	a0, a2, 2
42001107:	c83c      	movi.n	a8, 60
42001109:	027b      	addi.n	a0, a2, 7
4200110b:	833c      	movi.n	a3, 56
4200110d:	022b      	addi.n	a0, a2, 2
4200110f:	9c3c      	movi.n	a12, 57
42001111:	022b      	addi.n	a0, a2, 2
42001113:	d03c      	movi.n	a0, 61
42001115:	022b      	addi.n	a0, a2, 2
42001117:	103c      	movi.n	a0, 49
42001119:	022c      	movi.n	a2, 32
4200111b:	a83c      	movi.n	a8, 58
4200111d:	027b      	addi.n	a0, a2, 7
4200111f:	5b3c      	movi.n	a11, 53
42001121:	022c      	movi.n	a2, 32
42001123:	743c      	movi.n	a4, 55
42001125:	022c      	movi.n	a2, 32
42001127:	b03c      	movi.n	a0, 59
42001129:	022c      	movi.n	a2, 32
4200112b:	2c3c      	movi.n	a12, 50
4200112d:	2e          	.byte	0x2e
4200112e:	bc3c02        	lsi	f0, a12, 0x2f0
42001131:	37fb      	addi.n	a3, a7, 15
42001133:	fb9440        	f64subc	a4, a4, 0, 1
42001136:	f44037        	ball	a0, a3, 4200112e <_stext+0x110e>
42001139:	37fb      	addi.n	a3, a7, 15
4200113b:	22d840        	orb	b13, b8, b4
4200113e:	3fc9      	s32i.n	a12, a15, 12
42001140:	6cbc      	beqz.n	a12, 4200117a <esp_app_format_init_elf_sha256+0x32>
42001142:	bc4037        	ball	a0, a3, 42001102 <_stext+0x10e2>
42001145:	3c0293        	lsi	f9, a2, 240

42001148 <esp_app_format_init_elf_sha256>:
 * can lead to a complete lock-up of the CPU.
 * For this reason we do a reading of esp_app_desc.app_elf_sha256 and convert to string while start up in esp_system_init_app_elf_sha256()
 * and keep it in the static app_elf_sha256_str variable.
 */
static void esp_app_format_init_elf_sha256(void)
{
42001148:	004136        	entry	a1, 32
    if (*((int *)&app_elf_sha256_str) != 0) {
4200114b:	fbb581        	l32r	a8, 42000020 <_stext> (3fc94980 <app_elf_sha256_str>)
4200114e:	0888      	l32i.n	a8, a8, 0
42001150:	04e856        	bnez	a8, 420011a2 <esp_app_format_init_elf_sha256+0x5a>
    }
    // At -O2 optimization level, GCC optimizes out the copying of the first byte of the app_elf_sha256,
    // because it is zero at compile time, and only modified afterwards by esptool.
    // Casting to volatile disables the optimization.
    const volatile char* src = (const volatile char*)esp_app_desc.app_elf_sha256;
    for (size_t i = 0; i < sizeof(app_elf_sha256_str) / 2; ++i) {
42001153:	0c0c      	movi.n	a12, 0
42001155:	000f86        	j	42001197 <esp_app_format_init_elf_sha256+0x4f>
        char c = src[i];
42001158:	fbb381        	l32r	a8, 42000024 <_stext+0x4> (3c0200b0 <esp_app_desc+0x90>)
4200115b:	8c8a      	add.n	a8, a12, a8
4200115d:	0020c0        	memw
42001160:	000882        	l8ui	a8, a8, 0
42001163:	748080        	extui	a8, a8, 0, 8
        for (size_t s = 0; s < 2; ++s) {
42001166:	090c      	movi.n	a9, 0
42001168:	000986        	j	42001192 <esp_app_format_init_elf_sha256+0x4a>
4200116b:	a48000        	extui	a8, a0, 0, 11
            char val = (c >> 4) & 0xF;
4200116e:	9b0c41        	l32r	a4, 41fe7da0 <_coredump_iram_end+0x1c65da0>
            app_elf_sha256_str[2 * i + s] = (val < 10) ? ('0' + val) : ('a' + val - 10);
42001171:	073ba7        	bltu	a11, a10, 4200117c <esp_app_format_init_elf_sha256+0x34>
42001174:	30caa2        	addi	a10, a10, 48
42001177:	000106        	j	4200117f <esp_app_format_init_elf_sha256+0x37>
4200117a:	a20000        	muluh	a0, a0, a0
4200117d:	57ca      	add.n	a5, a7, a12
4200117f:	90dc90        	addx2	a13, a12, a9
42001182:	fba7b1        	l32r	a11, 42000020 <_stext> (3fc94980 <app_elf_sha256_str>)
42001185:	bbda      	add.n	a11, a11, a13
42001187:	004ba2        	s8i	a10, a11, 0
            c <<= 4;
4200118a:	1188c0        	slli	a8, a8, 4
4200118d:	748080        	extui	a8, a8, 0, 8
        for (size_t s = 0; s < 2; ++s) {
42001190:	991b      	addi.n	a9, a9, 1
42001192:	d629b6        	bltui	a9, 2, 4200116c <esp_app_format_init_elf_sha256+0x24>
    for (size_t i = 0; i < sizeof(app_elf_sha256_str) / 2; ++i) {
42001195:	cc1b      	addi.n	a12, a12, 1
42001197:	bd5cb6        	bltui	a12, 5, 42001158 <esp_app_format_init_elf_sha256+0x10>
        }
    }
    app_elf_sha256_str[sizeof(app_elf_sha256_str) - 1] = 0;
4200119a:	fba181        	l32r	a8, 42000020 <_stext> (3fc94980 <app_elf_sha256_str>)
4200119d:	090c      	movi.n	a9, 0
4200119f:	094892        	s8i	a9, a8, 9
}
420011a2:	f01d      	retw.n

420011a4 <esp_app_get_elf_sha256>:

int esp_app_get_elf_sha256(char* dst, size_t size)
{
420011a4:	004136        	entry	a1, 32
420011a7:	027d      	mov.n	a7, a2
    if (dst == NULL || size < 2) {
420011a9:	40f290        	nsau	a9, a2
420011ac:	419590        	srli	a9, a9, 5
420011af:	180c      	movi.n	a8, 1
420011b1:	628830        	lsi	f3, a8, 0x188
420011b4:	880b      	addi.n	a8, a8, -1
420011b6:	608080        	neg	a8, a8
420011b9:	748080        	extui	a8, a8, 0, 8
420011bc:	209980        	or	a9, a9, a8
420011bf:	f9dc      	bnez.n	a9, 420011e2 <esp_app_get_elf_sha256+0x3e>
        return 0;
    }
    esp_app_format_init_elf_sha256();
420011c1:	fff865        	call8	42001148 <esp_app_format_init_elf_sha256>
    size_t n = MIN(size, sizeof(app_elf_sha256_str));
420011c4:	a80c      	movi.n	a8, 10
420011c6:	632380        	minu	a2, a3, a8
    memcpy(dst, app_elf_sha256_str, n);
420011c9:	02cd      	mov.n	a12, a2
420011cb:	fb95b1        	l32r	a11, 42000020 <_stext> (3fc94980 <app_elf_sha256_str>)
420011ce:	07ad      	mov.n	a10, a7
420011d0:	fb9681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420011d3:	0008e0        	callx8	a8
    dst[n - 1] = 0;
420011d6:	820b      	addi.n	a8, a2, -1
420011d8:	778a      	add.n	a7, a7, a8
420011da:	080c      	movi.n	a8, 0
420011dc:	004782        	s8i	a8, a7, 0
    return n;
420011df:	000046        	j	420011e4 <esp_app_get_elf_sha256+0x40>
        return 0;
420011e2:	020c      	movi.n	a2, 0
}
420011e4:	f01d      	retw.n
	...

420011e8 <__esp_system_init_fn_init_show_app_info>:

// startup function definition and execution does not exist on the Linux target
// (TODO: IDF-9950)
#if !CONFIG_IDF_TARGET_LINUX && !ESP_TEE_BUILD
ESP_SYSTEM_INIT_FN(init_show_app_info, CORE, BIT(0), 20)
{
420011e8:	008136        	entry	a1, 64
    // Load the current ELF SHA256
    esp_app_format_init_elf_sha256();
420011eb:	fff5e5        	call8	42001148 <esp_app_format_init_elf_sha256>
420011ee:	fb8f81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
420011f1:	0888      	l32i.n	a8, a8, 0

    // Display information about the current running image.
    if (LOG_LOCAL_LEVEL >= ESP_LOG_INFO) {
        ESP_EARLY_LOGI(TAG, "Application information:");
420011f3:	1338b6        	bltui	a8, 3, 4200120a <__esp_system_init_fn_init_show_app_info+0x22>
420011f6:	fb9a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420011f9:	0008e0        	callx8	a8
420011fc:	fb8dc1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
420011ff:	0abd      	mov.n	a11, a10
42001201:	fb8ca1        	l32r	a10, 42000034 <_stext+0x14> (3c02012c <_flash_rodata_start+0xc>)
42001204:	fb9881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001207:	0008e0        	callx8	a8
4200120a:	fb8881        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200120d:	0888      	l32i.n	a8, a8, 0
#ifndef CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR
        ESP_EARLY_LOGI(TAG, "Project name:     %s", esp_app_desc.project_name);
4200120f:	1638b6        	bltui	a8, 3, 42001229 <__esp_system_init_fn_init_show_app_info+0x41>
42001212:	fb9381        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42001215:	0008e0        	callx8	a8
42001218:	fb88d1        	l32r	a13, 42000038 <_stext+0x18> (3c020050 <esp_app_desc+0x30>)
4200121b:	fb85c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
4200121e:	0abd      	mov.n	a11, a10
42001220:	fb87a1        	l32r	a10, 4200003c <_stext+0x1c> (3c020154 <_flash_rodata_start+0x34>)
42001223:	fb9081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001226:	0008e0        	callx8	a8
42001229:	fb8081        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200122c:	002882        	l32i	a8, a8, 0
#endif
#ifndef CONFIG_APP_EXCLUDE_PROJECT_VER_VAR
        ESP_EARLY_LOGI(TAG, "App version:      %s", esp_app_desc.version);
4200122f:	1638b6        	bltui	a8, 3, 42001249 <__esp_system_init_fn_init_show_app_info+0x61>
42001232:	fb8b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42001235:	0008e0        	callx8	a8
42001238:	fb82d1        	l32r	a13, 42000040 <_stext+0x20> (3c020030 <esp_app_desc+0x10>)
4200123b:	fb7dc1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
4200123e:	0abd      	mov.n	a11, a10
42001240:	fb81a1        	l32r	a10, 42000044 <_stext+0x24> (3c020178 <_flash_rodata_start+0x58>)
42001243:	fb8881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001246:	0008e0        	callx8	a8
42001249:	fb7881        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200124c:	002882        	l32i	a8, a8, 0
#endif
#ifdef CONFIG_BOOTLOADER_APP_SECURE_VERSION
        ESP_EARLY_LOGI(TAG, "Secure version:   %" PRIu32, esp_app_desc.secure_version);
#endif
#ifdef CONFIG_APP_COMPILE_TIME_DATE
        ESP_EARLY_LOGI(TAG, "Compile time:     %s %s", esp_app_desc.date, esp_app_desc.time);
4200124f:	1938b6        	bltui	a8, 3, 4200126c <__esp_system_init_fn_init_show_app_info+0x84>
42001252:	fb8381        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42001255:	0008e0        	callx8	a8
42001258:	fb7ce1        	l32r	a14, 42000048 <_stext+0x28> (3c020070 <esp_app_desc+0x50>)
4200125b:	fb7cd1        	l32r	a13, 4200004c <_stext+0x2c> (3c020080 <esp_app_desc+0x60>)
4200125e:	fb74c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
42001261:	0abd      	mov.n	a11, a10
42001263:	fb7ba1        	l32r	a10, 42000050 <_stext+0x30> (3c02019c <_flash_rodata_start+0x7c>)
42001266:	fb7f81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001269:	0008e0        	callx8	a8
#endif
        char buf[17];
        esp_app_get_elf_sha256(buf, sizeof(buf));
4200126c:	1b1c      	movi.n	a11, 17
4200126e:	01ad      	mov.n	a10, a1
42001270:	fff325        	call8	420011a4 <esp_app_get_elf_sha256>
42001273:	fb6e81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42001276:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "ELF file SHA256:  %s...", buf);
42001278:	1538b6        	bltui	a8, 3, 42001291 <__esp_system_init_fn_init_show_app_info+0xa9>
4200127b:	fb7981        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200127e:	0008e0        	callx8	a8
42001281:	01dd      	mov.n	a13, a1
42001283:	fb6bc1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
42001286:	0abd      	mov.n	a11, a10
42001288:	fb73a1        	l32r	a10, 42000054 <_stext+0x34> (3c0201c4 <_flash_rodata_start+0xa4>)
4200128b:	fb7681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200128e:	0008e0        	callx8	a8
42001291:	fb6681        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42001294:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "ESP-IDF:          %s", esp_app_desc.idf_ver);
42001297:	1638b6        	bltui	a8, 3, 420012b1 <__esp_system_init_fn_init_show_app_info+0xc9>
4200129a:	fb7181        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200129d:	0008e0        	callx8	a8
420012a0:	fb6ed1        	l32r	a13, 42000058 <_stext+0x38> (3c020090 <esp_app_desc+0x70>)
420012a3:	fb63c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
420012a6:	0abd      	mov.n	a11, a10
420012a8:	fb6da1        	l32r	a10, 4200005c <_stext+0x3c> (3c0201ec <_flash_rodata_start+0xcc>)
420012ab:	fb6e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420012ae:	0008e0        	callx8	a8
    }
    return ESP_OK;
}
420012b1:	020c      	movi.n	a2, 0
420012b3:	f01d      	retw.n
420012b5:	000000        	ill

420012b8 <__esp_system_init_fn_init_efuse_check>:
#endif

static __attribute__((unused)) const char *TAG = "efuse_init";

ESP_SYSTEM_INIT_FN(init_efuse_check, CORE, BIT(0), 1)
{
420012b8:	004136        	entry	a1, 32
    // (Only for C3): We check if the efuse BLOCK0 has certain coding errors then reset the chip.
    if (esp_efuse_check_errors() != ESP_OK) {
420012bb:	000da5        	call8	42001394 <esp_efuse_check_errors>
420012be:	4a8c      	beqz.n	a10, 420012c6 <__esp_system_init_fn_init_efuse_check+0xe>
        esp_restart();
420012c0:	201110        	or	a1, a1, a1
420012c3:	001125        	call8	420013d4 <esp_restart>
    }
    return ESP_OK;
}
420012c6:	020c      	movi.n	a2, 0
420012c8:	f01d      	retw.n
	...

420012cc <__esp_system_init_fn_init_efuse_show_app_info>:

// It comes after init_show_app_info to print the consistent application information.
ESP_SYSTEM_INIT_FN(init_efuse_show_app_info, CORE, BIT(0), 21)
{
420012cc:	004136        	entry	a1, 32
420012cf:	fb5781        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
420012d2:	002882        	l32i	a8, a8, 0
    if (LOG_LOCAL_LEVEL >= ESP_LOG_INFO) {
        ESP_EARLY_LOGI(TAG, "Min chip rev:     v%d.%d", CONFIG_ESP_REV_MIN_FULL / 100, CONFIG_ESP_REV_MIN_FULL % 100);
420012d5:	1738b6        	bltui	a8, 3, 420012f0 <__esp_system_init_fn_init_efuse_show_app_info+0x24>
420012d8:	fb6281        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420012db:	0008e0        	callx8	a8
420012de:	0e0c      	movi.n	a14, 0
420012e0:	0edd      	mov.n	a13, a14
420012e2:	fb63c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
420012e5:	0abd      	mov.n	a11, a10
420012e7:	fb63a1        	l32r	a10, 42000074 <_stext+0x54> (3c020234 <_flash_rodata_start+0x114>)
420012ea:	fb5e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420012ed:	0008e0        	callx8	a8
420012f0:	fb4f81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
420012f3:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "Max chip rev:     v%d.%d %s", CONFIG_ESP_REV_MAX_FULL / 100, CONFIG_ESP_REV_MAX_FULL % 100,
420012f5:	3038b6        	bltui	a8, 3, 42001329 <__esp_system_init_fn_init_efuse_show_app_info+0x5d>
420012f8:	fb5a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420012fb:	0008e0        	callx8	a8
420012fe:	0a7d      	mov.n	a7, a10
42001300:	fb6181        	l32r	a8, 42000084 <_stext+0x64> (40375e10 <efuse_hal_get_disable_wafer_version_major>)
42001303:	0008e0        	callx8	a8
42001306:	7a8c      	beqz.n	a10, 42001311 <__esp_system_init_fn_init_efuse_show_app_info+0x45>
42001308:	fb58f1        	l32r	a15, 42000068 <_stext+0x48> (3c020210 <_flash_rodata_start+0xf0>)
4200130b:	000146        	j	42001314 <__esp_system_init_fn_init_efuse_show_app_info+0x48>
4200130e:	000000        	ill
42001311:	fb56f1        	l32r	a15, 4200006c <_stext+0x4c> (3c020eb0 <_flash_rodata_start+0xd90>)
42001314:	63a0e2        	movi	a14, 99
42001317:	00a0d2        	movi	a13, 0
4200131a:	fb55c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
4200131d:	20b770        	or	a11, a7, a7
42001320:	fb56a1        	l32r	a10, 42000078 <_stext+0x58> (3c02025c <_flash_rodata_start+0x13c>)
42001323:	fb5081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001326:	0008e0        	callx8	a8
                        efuse_hal_get_disable_wafer_version_major() ? "(constraint ignored)" : "");
        unsigned revision = efuse_hal_chip_revision();
42001329:	fb5781        	l32r	a8, 42000088 <_stext+0x68> (40375df8 <efuse_hal_chip_revision>)
4200132c:	0008e0        	callx8	a8
4200132f:	0a7d      	mov.n	a7, a10
42001331:	fb3e81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42001334:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "Chip rev:         v%d.%d", revision / 100, revision % 100);
42001337:	2938b6        	bltui	a8, 3, 42001364 <__esp_system_init_fn_init_efuse_show_app_info+0x98>
4200133a:	fb4981        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200133d:	0008e0        	callx8	a8
42001340:	fb4fd1        	l32r	a13, 4200007c <_stext+0x5c> (51eb851f <_coredump_rtc_end+0x1eb851f>)
42001343:	a2d7d0        	muluh	a13, a7, a13
42001346:	41d5d0        	srli	a13, a13, 5
42001349:	a0edd0        	addx4	a14, a13, a13
4200134c:	a0eee0        	addx4	a14, a14, a14
4200134f:	11eee0        	slli	a14, a14, 2
42001352:	c0e7e0        	sub	a14, a7, a14
42001355:	fb46c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
42001358:	20baa0        	or	a11, a10, a10
4200135b:	fb49a1        	l32r	a10, 42000080 <_stext+0x60> (3c020288 <_flash_rodata_start+0x168>)
4200135e:	fb4181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001361:	0008e0        	callx8	a8
    }
    return ESP_OK;
}
42001364:	020c      	movi.n	a2, 0
42001366:	f01d      	retw.n

42001368 <__esp_system_init_fn_init_efuse>:
    return ESP_OK;
}
#endif // ROM_LOG_MODE

ESP_SYSTEM_INIT_FN(init_efuse, CORE, BIT(0), 140)
{
42001368:	006136        	entry	a1, 48

#ifdef CONFIG_EFUSE_VIRTUAL
    init_efuse_virtual();
#endif

    error = init_efuse_secure();
4200136b:	143965        	call8	42015700 <init_efuse_secure>
4200136e:	0a2d      	mov.n	a2, a10
    ESP_RETURN_ON_ERROR(error, TAG, "Failed in secure eFuse init");
42001370:	ea9c      	beqz.n	a10, 42001392 <__esp_system_init_fn_init_efuse+0x2a>
42001372:	fb3b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42001375:	0008e0        	callx8	a8
42001378:	fb3eb1        	l32r	a11, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
4200137b:	a6a082        	movi	a8, 166
4200137e:	0189      	s32i.n	a8, a1, 0
42001380:	fb43f1        	l32r	a15, 4200008c <_stext+0x6c> (3c027060 <__FUNCTION__$0>)
42001383:	0bed      	mov.n	a14, a11
42001385:	0add      	mov.n	a13, a10
42001387:	fb42c1        	l32r	a12, 42000090 <_stext+0x70> (3c0202b0 <_flash_rodata_start+0x190>)
4200138a:	1a0c      	movi.n	a10, 1
4200138c:	fb4281        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200138f:	0008e0        	callx8	a8
#ifdef ROM_LOG_MODE
    error = init_efuse_rom_log();
#endif

    return error;
}
42001392:	f01d      	retw.n

42001394 <esp_efuse_check_errors>:
    }
    return ESP_OK;
}

esp_err_t esp_efuse_check_errors(void)
{
42001394:	004136        	entry	a1, 32
    return esp_efuse_utility_check_errors();
42001397:	1437a5        	call8	42015710 <esp_efuse_utility_check_errors>
}
4200139a:	0a2d      	mov.n	a2, a10
4200139c:	f01d      	retw.n
	...

420013a0 <esp_register_shutdown_handler>:
#define SHUTDOWN_HANDLERS_NO 5

static shutdown_handler_t shutdown_handlers[SHUTDOWN_HANDLERS_NO];

esp_err_t esp_register_shutdown_handler(shutdown_handler_t handler)
{
420013a0:	004136        	entry	a1, 32
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
420013a3:	080c      	movi.n	a8, 0
420013a5:	0006c6        	j	420013c4 <esp_register_shutdown_handler+0x24>
        if (shutdown_handlers[i] == handler) {
420013a8:	fb3c91        	l32r	a9, 42000098 <_stext+0x78> (3fc9498c <shutdown_handlers>)
420013ab:	a09890        	addx4	a9, a8, a9
420013ae:	0998      	l32i.n	a9, a9, 0
420013b0:	191927        	beq	a9, a2, 420013cd <esp_register_shutdown_handler+0x2d>
            return ESP_ERR_INVALID_STATE;
        } else if (shutdown_handlers[i] == NULL) {
420013b3:	b9cc      	bnez.n	a9, 420013c2 <esp_register_shutdown_handler+0x22>
            shutdown_handlers[i] = handler;
420013b5:	fb3891        	l32r	a9, 42000098 <_stext+0x78> (3fc9498c <shutdown_handlers>)
420013b8:	a08890        	addx4	a8, a8, a9
420013bb:	0829      	s32i.n	a2, a8, 0
            return ESP_OK;
420013bd:	020c      	movi.n	a2, 0
420013bf:	000346        	j	420013d0 <esp_register_shutdown_handler+0x30>
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
420013c2:	881b      	addi.n	a8, a8, 1
420013c4:	e058a6        	blti	a8, 5, 420013a8 <esp_register_shutdown_handler+0x8>
        }
    }
    return ESP_ERR_NO_MEM;
420013c7:	01a122        	movi	a2, 0x101
420013ca:	000086        	j	420013d0 <esp_register_shutdown_handler+0x30>
            return ESP_ERR_INVALID_STATE;
420013cd:	03a122        	movi	a2, 0x103
}
420013d0:	f01d      	retw.n
	...

420013d4 <esp_restart>:
    }
    return ESP_ERR_INVALID_STATE;
}

void esp_restart(void)
{
420013d4:	004136        	entry	a1, 32
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
420013d7:	470c      	movi.n	a7, 4
420013d9:	000386        	j	420013eb <esp_restart+0x17>
        if (shutdown_handlers[i]) {
420013dc:	fb2f81        	l32r	a8, 42000098 <_stext+0x78> (3fc9498c <shutdown_handlers>)
420013df:	a08780        	addx4	a8, a7, a8
420013e2:	0888      	l32i.n	a8, a8, 0
420013e4:	188c      	beqz.n	a8, 420013e9 <esp_restart+0x15>
            shutdown_handlers[i]();
420013e6:	0008e0        	callx8	a8
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
420013e9:	770b      	addi.n	a7, a7, -1
420013eb:	fed7d6        	bgez	a7, 420013dc <esp_restart+0x8>
#if ( ( CONFIG_FREERTOS_SMP ) && ( !CONFIG_FREERTOS_UNICORE ) )
    //Note: Scheduler suspension behavior changed in FreeRTOS SMP
    vTaskPreemptionDisable(NULL);
#else
    // Disable scheduler on this core.
    vTaskSuspendAll();
420013ee:	fb2b81        	l32r	a8, 4200009c <_stext+0x7c> (4037b1a8 <vTaskSuspendAll>)
420013f1:	0008e0        	callx8	a8
#endif // #if ( ( CONFIG_FREERTOS_SMP ) && ( !CONFIG_FREERTOS_UNICORE ) )

    esp_restart_noos();
420013f4:	fb2b81        	l32r	a8, 420000a0 <_stext+0x80> (40375760 <esp_restart_noos>)
420013f7:	0008e0        	callx8	a8
	...

420013fc <__esp_system_init_fn_init_show_cpu_freq>:
}

// [refactor-todo] Most of these init functions should be moved to the respective components.

ESP_SYSTEM_INIT_FN(init_show_cpu_freq, CORE, BIT(0), 10)
{
420013fc:	004136        	entry	a1, 32
420013ff:	fb0b81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42001402:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "Pro cpu start user code");
42001404:	1438b6        	bltui	a8, 3, 4200141c <__esp_system_init_fn_init_show_cpu_freq+0x20>
42001407:	fb1681        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200140a:	0008e0        	callx8	a8
4200140d:	fb25c1        	l32r	a12, 420000a4 <_stext+0x84> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001410:	20baa0        	or	a11, a10, a10
42001413:	fb25a1        	l32r	a10, 420000a8 <_stext+0x88> (3c0202f0 <_flash_rodata_start+0x1d0>)
42001416:	fb1381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001419:	0008e0        	callx8	a8
    int cpu_freq = esp_clk_cpu_freq();
4200141c:	fb2581        	l32r	a8, 420000b0 <_stext+0x90> (40376440 <esp_clk_cpu_freq>)
4200141f:	0008e0        	callx8	a8
42001422:	0a7d      	mov.n	a7, a10
42001424:	fb0281        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42001427:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "cpu freq: %d Hz", cpu_freq);
42001429:	1538b6        	bltui	a8, 3, 42001442 <__esp_system_init_fn_init_show_cpu_freq+0x46>
4200142c:	fb0d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200142f:	0008e0        	callx8	a8
42001432:	07dd      	mov.n	a13, a7
42001434:	fb1cc1        	l32r	a12, 420000a4 <_stext+0x84> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001437:	0abd      	mov.n	a11, a10
42001439:	fb1ca1        	l32r	a10, 420000ac <_stext+0x8c> (3c020318 <_flash_rodata_start+0x1f8>)
4200143c:	fb0a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200143f:	0008e0        	callx8	a8

    return ESP_OK;
}
42001442:	020c      	movi.n	a2, 0
42001444:	f01d      	retw.n
	...

42001448 <__esp_system_init_fn_init_brownout>:
 * It is protected from all REE accesses through memory protection mechanisms,
 * as it is a critical module for device functioning.
 */
#if !CONFIG_SECURE_ENABLE_TEE
ESP_SYSTEM_INIT_FN(init_brownout, CORE, BIT(0), 104)
{
42001448:	004136        	entry	a1, 32
    // [refactor-todo] leads to call chain rtc_is_register (driver) -> esp_intr_alloc (esp32/esp32s2) ->
    // malloc (newlib) -> heap_caps_malloc (heap), so heap must be at least initialized
#if CONFIG_ESP_BROWNOUT_DET
    esp_brownout_init();
4200144b:	001865        	call8	420015d0 <esp_brownout_init>
#if SOC_CAPS_NO_RESET_BY_ANA_BOD
    brownout_ll_ana_reset_enable(false);
#endif // SOC_CAPS_NO_RESET_BY_ANA_BOD
#endif // CONFIG_ESP_BROWNOUT_DET
    return ESP_OK;
}
4200144e:	020c      	movi.n	a2, 0
42001450:	f01d      	retw.n
	...

42001454 <__esp_system_init_fn_init_newlib_time>:
#endif

ESP_SYSTEM_INIT_FN(init_newlib_time, CORE, BIT(0), 105)
{
42001454:	004136        	entry	a1, 32
    esp_libc_time_init();
42001457:	048ee5        	call8	42005d44 <esp_libc_time_init>
    return ESP_OK;
}
4200145a:	020c      	movi.n	a2, 0
4200145c:	f01d      	retw.n
	...

42001460 <__esp_system_init_fn_init_flash>:

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
ESP_SYSTEM_INIT_FN(init_flash, CORE, BIT(0), 130)
{
42001460:	004136        	entry	a1, 32
#if CONFIG_SPI_FLASH_ROM_IMPL
    spi_flash_rom_impl_init();
#endif

    esp_flash_app_init();
42001463:	08d7a5        	call8	4200a1dc <esp_flash_app_init>
    esp_err_t flash_ret = esp_flash_init_default_chip();
42001466:	201110        	or	a1, a1, a1
42001469:	08c4a5        	call8	4200a0b4 <esp_flash_init_default_chip>
    assert(flash_ret == ESP_OK);
4200146c:	011a16        	beqz	a10, 42001481 <__esp_system_init_fn_init_flash+0x21>
4200146f:	fb11d1        	l32r	a13, 420000b4 <_stext+0x94> (3c020338 <_flash_rodata_start+0x218>)
42001472:	fb11c1        	l32r	a12, 420000b8 <_stext+0x98> (3c027080 <__func__$0>)
42001475:	69a0b2        	movi	a11, 105
42001478:	fb11a1        	l32r	a10, 420000bc <_stext+0x9c> (3c020368 <_flash_rodata_start+0x248>)
4200147b:	fb1181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4200147e:	0008e0        	callx8	a8
    (void)flash_ret;
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    spi_flash_needs_reset_check();
42001481:	fb1081        	l32r	a8, 420000c4 <_stext+0xa4> (4037ff70 <spi_flash_needs_reset_check>)
42001484:	0008e0        	callx8	a8
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET
    return ESP_OK;
}
42001487:	020c      	movi.n	a2, 0
42001489:	f01d      	retw.n
	...

4200148c <__esp_system_init_fn_init_apb_dma>:
}
#endif // CONFIG_PM_ENABLE

#if SOC_APB_BACKUP_DMA
ESP_SYSTEM_INIT_FN(init_apb_dma, SECONDARY, BIT(0), 203)
{
4200148c:	004136        	entry	a1, 32
    extern void esp_apb_backup_dma_lock_init(void);
    esp_apb_backup_dma_lock_init();
4200148f:	0073a5        	call8	42001bc8 <esp_apb_backup_dma_lock_init>
    return ESP_OK;
}
42001492:	020c      	movi.n	a2, 0
42001494:	f01d      	retw.n
	...

42001498 <__esp_system_init_fn_init_disable_rtc_wdt>:
}
#endif // CONFIG_SW_COEXIST_ENABLE || CONFIG_EXTERNAL_COEX_ENABLE

#ifndef CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE
ESP_SYSTEM_INIT_FN(init_disable_rtc_wdt, SECONDARY, BIT(0), 999)
{
42001498:	006136        	entry	a1, 48
    wdt_hal_context_t rtc_wdt_ctx = RWDT_HAL_CONTEXT_DEFAULT();
4200149b:	020c      	movi.n	a2, 0
4200149d:	0129      	s32i.n	a2, a1, 0
4200149f:	fb0a81        	l32r	a8, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
420014a2:	1189      	s32i.n	a8, a1, 4
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
420014a4:	01ad      	mov.n	a10, a1
420014a6:	fb0981        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
420014a9:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
420014ac:	01ad      	mov.n	a10, a1
420014ae:	fb0881        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
420014b1:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
420014b4:	01ad      	mov.n	a10, a1
420014b6:	fb0781        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
420014b9:	0008e0        	callx8	a8
    return ESP_OK;
}
420014bc:	f01d      	retw.n
	...

420014c0 <core_intr_matrix_clear>:
{
420014c0:	004136        	entry	a1, 32
420014c3:	03eb60        	rsr.prid	a6
420014c6:	046d60        	extui	a6, a6, 13, 1
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
420014c9:	070c      	movi.n	a7, 0
420014cb:	000346        	j	420014dc <core_intr_matrix_clear+0x1c>
        esp_rom_route_intr_matrix(core_id, i, ETS_INVALID_INUM);
420014ce:	6c0c      	movi.n	a12, 6
420014d0:	07bd      	mov.n	a11, a7
420014d2:	06ad      	mov.n	a10, a6
420014d4:	fb0181        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420014d7:	0008e0        	callx8	a8
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
420014da:	771b      	addi.n	a7, a7, 1
420014dc:	62a082        	movi	a8, 98
420014df:	eba877        	bge	a8, a7, 420014ce <core_intr_matrix_clear+0xe>
}
420014e2:	f01d      	retw.n

420014e4 <start_other_core>:
{
420014e4:	006136        	entry	a1, 48
    esp_chip_info(&chip_info);
420014e7:	01ad      	mov.n	a10, a1
420014e9:	027a25        	call8	42003c8c <esp_chip_info>
    if (!(chip_info.cores > 1)) {
420014ec:	0a0182        	l8ui	a8, a1, 10
420014ef:	3f28f6        	bgeui	a8, 2, 42001532 <start_other_core+0x4e>
420014f2:	face81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
420014f5:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Running on single core variant of a chip, but app is built with multi-core support.");
420014f8:	014816        	beqz	a8, 42001510 <start_other_core+0x2c>
420014fb:	fad981        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420014fe:	0008e0        	callx8	a8
42001501:	faf6c1        	l32r	a12, 420000dc <_stext+0xbc> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001504:	20baa0        	or	a11, a10, a10
42001507:	faf6a1        	l32r	a10, 420000e0 <_stext+0xc0> (3c020378 <_flash_rodata_start+0x258>)
4200150a:	fad681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200150d:	0008e0        	callx8	a8
42001510:	fac781        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42001513:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Check that CONFIG_FREERTOS_UNICORE is enabled in menuconfig");
42001515:	389c      	beqz.n	a8, 4200152c <start_other_core+0x48>
42001517:	fad281        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200151a:	0008e0        	callx8	a8
4200151d:	faefc1        	l32r	a12, 420000dc <_stext+0xbc> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001520:	20baa0        	or	a11, a10, a10
42001523:	faf0a1        	l32r	a10, 420000e4 <_stext+0xc4> (3c0203dc <_flash_rodata_start+0x2bc>)
42001526:	facf81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001529:	0008e0        	callx8	a8
        abort();
4200152c:	faf281        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200152f:	0008e0        	callx8	a8
    esp_cpu_unstall(1);
42001532:	1a0c      	movi.n	a10, 1
42001534:	faf181        	l32r	a8, 420000f8 <_stext+0xd8> (40378240 <esp_cpu_unstall>)
42001537:	0008e0        	callx8	a8
    if (!REG_GET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN)) {
4200153a:	faeb81        	l32r	a8, 420000e8 <_stext+0xc8> (600c0000 <SYSTEM>)
4200153d:	0020c0        	memw
42001540:	0888      	l32i.n	a8, a8, 0
42001542:	3ee817        	bbsi	a8, 1, 42001584 <start_other_core+0xa0>
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN);
42001545:	fae881        	l32r	a8, 420000e8 <_stext+0xc8> (600c0000 <SYSTEM>)
42001548:	0020c0        	memw
4200154b:	0898      	l32i.n	a9, a8, 0
4200154d:	2a0c      	movi.n	a10, 2
4200154f:	2099a0        	or	a9, a9, a10
42001552:	0020c0        	memw
42001555:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RUNSTALL);
42001557:	0020c0        	memw
4200155a:	0898      	l32i.n	a9, a8, 0
4200155c:	ea7c      	movi.n	a10, -2
4200155e:	1099a0        	and	a9, a9, a10
42001561:	0020c0        	memw
42001564:	0899      	s32i.n	a9, a8, 0
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
42001566:	0020c0        	memw
42001569:	0898      	l32i.n	a9, a8, 0
4200156b:	4a0c      	movi.n	a10, 4
4200156d:	2099a0        	or	a9, a9, a10
42001570:	0020c0        	memw
42001573:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
42001575:	0020c0        	memw
42001578:	0898      	l32i.n	a9, a8, 0
4200157a:	ba7c      	movi.n	a10, -5
4200157c:	1099a0        	and	a9, a9, a10
4200157f:	0020c0        	memw
42001582:	0899      	s32i.n	a9, a8, 0
    ets_set_appcpu_boot_addr((uint32_t)call_start_cpu1);
42001584:	fadaa1        	l32r	a10, 420000ec <_stext+0xcc> (4037519c <call_start_cpu1>)
42001587:	fadd81        	l32r	a8, 420000fc <_stext+0xdc> (40000720 <ets_set_appcpu_boot_addr>)
4200158a:	0008e0        	callx8	a8
    bool cpus_up = false;
4200158d:	070c      	movi.n	a7, 0
    while (!cpus_up) {
4200158f:	000946        	j	420015b8 <start_other_core+0xd4>
42001592:	910000        	srl	a0, a0
            cpus_up &= s_cpu_up[i];
42001595:	8afad7        	bbsi	a10, 29, 42001523 <start_other_core+0x3f>
42001598:	c099      	s32i.n	a9, a0, 48
4200159a:	920020        	lsi	f2, a0, 0x248
4200159d:	0009      	s32i.n	a0, a0, 0
4200159f:	107790        	and	a7, a7, a9
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420015a2:	881b      	addi.n	a8, a8, 1
420015a4:	000106        	j	420015ac <start_other_core+0xc8>
420015a7:	080c00        	lsx	f0, a12, a0
        cpus_up = true;
420015aa:	170c      	movi.n	a7, 1
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420015ac:	e428a6        	blti	a8, 2, 42001594 <start_other_core+0xb0>
        esp_rom_delay_us(100);
420015af:	64a0a2        	movi	a10, 100
420015b2:	fad381        	l32r	a8, 42000100 <_stext+0xe0> (40000600 <esp_rom_delay_us>)
420015b5:	0008e0        	callx8	a8
    while (!cpus_up) {
420015b8:	fec716        	beqz	a7, 420015a8 <start_other_core+0xc4>
}
420015bb:	f01d      	retw.n
420015bd:	000000        	ill

420015c0 <startup_resume_other_cores>:
{
420015c0:	004136        	entry	a1, 32
    s_resume_cores = true;
420015c3:	fad081        	l32r	a8, 42000104 <_stext+0xe4> (3fc949a0 <s_resume_cores>)
420015c6:	190c      	movi.n	a9, 1
420015c8:	0020c0        	memw
420015cb:	004892        	s8i	a9, a8, 0
}
420015ce:	f01d      	retw.n

420015d0 <esp_brownout_init>:
}
#endif // CONFIG_ESP_SYSTEM_BROWNOUT_INTR

void esp_brownout_init(void)
{
420015d0:	006136        	entry	a1, 48
#if CONFIG_ESP_SYSTEM_BROWNOUT_INTR
    brownout_hal_config_t cfg = {
420015d3:	facd81        	l32r	a8, 42000108 <_stext+0xe8> (3c0270b8 <__func__$0+0x38>)
420015d6:	002892        	l32i	a9, a8, 0
420015d9:	040882        	l8ui	a8, a8, 4
420015dc:	006192        	s32i	a9, a1, 0
420015df:	044182        	s8i	a8, a1, 4
        .reset_enabled = false,
        .flash_power_down = true,
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
420015e2:	01ad      	mov.n	a10, a1
420015e4:	013225        	call8	42002908 <brownout_hal_config>
420015e7:	fab861        	l32r	a6, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
420015ea:	0020c0        	memw
420015ed:	132692        	l32i	a9, a6, 76
420015f0:	00a272        	movi	a7, 0x200
420015f3:	208970        	or	a8, a9, a7
420015f6:	0020c0        	memw
420015f9:	136682        	s32i	a8, a6, 76
    // is not used now. An interrupt allocator is needed when lp_timer intr gets supported.
    esp_intr_alloc_intrstatus(ETS_LP_RTC_TIMER_INTR_SOURCE, ESP_INTR_FLAG_IRAM | ESP_INTR_FLAG_SHARED, (uint32_t)brownout_ll_intr_get_status_reg(), BROWNOUT_DETECTOR_LL_INTERRUPT_MASK, &rtc_brownout_isr_handler, NULL, NULL);
#elif CONFIG_IDF_TARGET_ESP32P4
    esp_intr_alloc(ETS_LP_ANAPERI_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_brownout_isr_handler, NULL, NULL);
#else
    rtc_isr_register(rtc_brownout_isr_handler, NULL, RTC_CNTL_BROWN_OUT_INT_ENA_M, RTC_INTR_FLAG_IRAM);
420015fc:	1d0c      	movi.n	a13, 1
420015fe:	07cd      	mov.n	a12, a7
42001600:	0b0c      	movi.n	a11, 0
42001602:	fac2a1        	l32r	a10, 4200010c <_stext+0xec> (4037550c <rtc_brownout_isr_handler>)
42001605:	023e65        	call8	420039ec <rtc_isr_register>
    RTCCNTL.int_ena.rtc_brown_out = enable;
42001608:	0020c0        	memw
4200160b:	102682        	l32i	a8, a6, 64
4200160e:	207870        	or	a7, a8, a7
42001611:	0020c0        	memw
42001614:	106672        	s32i	a7, a6, 64
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
#endif
}
42001617:	f01d      	retw.n
42001619:	000000        	ill

4200161c <select_rtc_slow_clk>:
{
4200161c:	004136        	entry	a1, 32
    soc_rtc_slow_clk_src_t rtc_slow_clk_src = slow_clk & RTC_CNTL_ANA_CLK_RTC_SEL_V;
4200161f:	146020        	extui	a6, a2, 0, 2
    int retry_32k_xtal = RTC_XTAL_CAL_RETRY;
42001622:	150c      	movi.n	a5, 1
        if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
42001624:	511666        	bnei	a6, 1, 42001679 <select_rtc_slow_clk+0x5d>
            if (slow_clk == SLOW_CLK_32K_XTAL) {
42001627:	0b1266        	bnei	a2, 1, 42001636 <select_rtc_slow_clk+0x1a>
                rtc_clk_32k_enable(true);
4200162a:	1a0c      	movi.n	a10, 1
4200162c:	fabb81        	l32r	a8, 42000118 <_stext+0xf8> (4037870c <rtc_clk_32k_enable>)
4200162f:	0008e0        	callx8	a8
42001632:	0002c6        	j	42001641 <select_rtc_slow_clk+0x25>
42001635:	980c00        	lsi	f0, a12, 0x260
            } else if (slow_clk == SLOW_CLK_32K_EXT_OSC) {
42001638:	059287        	bne	a2, a8, 42001641 <select_rtc_slow_clk+0x25>
                rtc_clk_32k_enable_external();
4200163b:	fab881        	l32r	a8, 4200011c <_stext+0xfc> (403787fc <rtc_clk_32k_enable_external>)
4200163e:	0008e0        	callx8	a8
                cal_val = rtc_clk_cal(RTC_CAL_32K_XTAL, SLOW_CLK_CAL_CYCLES);
42001641:	00a4b2        	movi	a11, 0x400
42001644:	02a0a2        	movi	a10, 2
42001647:	fab681        	l32r	a8, 42000120 <_stext+0x100> (403792f4 <rtc_clk_cal>)
4200164a:	0008e0        	callx8	a8
4200164d:	0a7d      	mov.n	a7, a10
                if (cal_val == 0) {
4200164f:	eafc      	bnez.n	a10, 42001691 <select_rtc_slow_clk+0x75>
                    if (retry_32k_xtal-- > 0) {
42001651:	450b      	addi.n	a4, a5, -1
42001653:	5215e6        	bgei	a5, 1, 420016a9 <select_rtc_slow_clk+0x8d>
42001656:	fa7581        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42001659:	0888      	l32i.n	a8, a8, 0
                    ESP_EARLY_LOGW(TAG, "32 kHz XTAL not found, switching to internal 150 kHz oscillator");
4200165b:	2e28b6        	bltui	a8, 2, 4200168d <select_rtc_slow_clk+0x71>
4200165e:	fa8081        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42001661:	0008e0        	callx8	a8
42001664:	faabc1        	l32r	a12, 42000110 <_stext+0xf0> (3c0205a0 <_flash_rodata_start+0x480>)
42001667:	0abd      	mov.n	a11, a10
42001669:	faaaa1        	l32r	a10, 42000114 <_stext+0xf4> (3c0205a4 <_flash_rodata_start+0x484>)
4200166c:	fa7e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200166f:	0008e0        	callx8	a8
                    if (retry_32k_xtal-- > 0) {
42001672:	045d      	mov.n	a5, a4
                    rtc_slow_clk_src = SOC_RTC_SLOW_CLK_SRC_RC_SLOW;
42001674:	076d      	mov.n	a6, a7
42001676:	0005c6        	j	42001691 <select_rtc_slow_clk+0x75>
        } else if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
42001679:	142666        	bnei	a6, 2, 42001691 <select_rtc_slow_clk+0x75>
            rtc_clk_8m_enable(true, true);
4200167c:	01a0b2        	movi	a11, 1
4200167f:	20abb0        	or	a10, a11, a11
42001682:	faa881        	l32r	a8, 42000124 <_stext+0x104> (40378850 <rtc_clk_8m_enable>)
42001685:	0008e0        	callx8	a8
42001688:	000146        	j	42001691 <select_rtc_slow_clk+0x75>
4200168b:	5d0000        	lsi	f0, a0, 0x174
                    if (retry_32k_xtal-- > 0) {
4200168e:	0a6d04        	mula.dd.lh.ldinc	m2, a13, m1, m2
        rtc_clk_slow_src_set(rtc_slow_clk_src);
42001691:	06ad      	mov.n	a10, a6
42001693:	faa581        	l32r	a8, 42000128 <_stext+0x108> (4037890c <rtc_clk_slow_src_set>)
42001696:	0008e0        	callx8	a8
            cal_val = rtc_clk_cal(RTC_CAL_RTC_MUX, SLOW_CLK_CAL_CYCLES);
42001699:	00a4b2        	movi	a11, 0x400
4200169c:	0a0c      	movi.n	a10, 0
4200169e:	faa081        	l32r	a8, 42000120 <_stext+0x100> (403792f4 <rtc_clk_cal>)
420016a1:	0008e0        	callx8	a8
420016a4:	0a7d      	mov.n	a7, a10
420016a6:	000086        	j	420016ac <select_rtc_slow_clk+0x90>
                    if (retry_32k_xtal-- > 0) {
420016a9:	205440        	or	a5, a4, a4
    } while (cal_val == 0);
420016ac:	f74716        	beqz	a7, 42001624 <select_rtc_slow_clk+0x8>
    esp_clk_slowclk_cal_set(cal_val);
420016af:	20a770        	or	a10, a7, a7
420016b2:	01c1e5        	call8	420032d0 <esp_clk_slowclk_cal_set>
}
420016b5:	000090        	retw

420016b8 <esp_rtc_init>:
{
420016b8:	004136        	entry	a1, 32
    recalib_bbpll();
420016bb:	fa9e81        	l32r	a8, 42000134 <_stext+0x114> (4037564c <recalib_bbpll>)
420016be:	0008e0        	callx8	a8
    rtc_config_t cfg = RTC_CONFIG_DEFAULT();
420016c1:	fa9a81        	l32r	a8, 4200012c <_stext+0x10c> (3c0270c0 <__func__$0+0x40>)
420016c4:	002872        	l32i	a7, a8, 0
    rst_reas = esp_rom_get_reset_reason(0);
420016c7:	00a0a2        	movi	a10, 0
420016ca:	fa9b81        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
420016cd:	0008e0        	callx8	a8
    if (rst_reas == RESET_REASON_CHIP_POWER_ON) {
420016d0:	051a66        	bnei	a10, 1, 420016d9 <esp_rtc_init+0x21>
        cfg.cali_ocode = 1;
420016d3:	fa9781        	l32r	a8, 42000130 <_stext+0x110> (40000000 <_heap_end>)
420016d6:	207780        	or	a7, a7, a8
    rtc_init(cfg);
420016d9:	07ad      	mov.n	a10, a7
420016db:	14e725        	call8	4201654c <rtc_init>
}
420016de:	f01d      	retw.n

420016e0 <esp_clk_init>:
{
420016e0:	00a136        	entry	a1, 80
    assert(rtc_clk_xtal_freq_get() == SOC_XTAL_FREQ_40M);
420016e3:	fa9b81        	l32r	a8, 42000150 <_stext+0x130> (40378a9c <rtc_clk_xtal_freq_get>)
420016e6:	0008e0        	callx8	a8
420016e9:	d8caa2        	addi	a10, a10, -40
420016ec:	010a16        	beqz	a10, 42001700 <esp_clk_init+0x20>
420016ef:	fa93d1        	l32r	a13, 4200013c <_stext+0x11c> (3c0205f4 <_flash_rodata_start+0x4d4>)
420016f2:	fa93c1        	l32r	a12, 42000140 <_stext+0x120> (3c0270c4 <__func__$0>)
420016f5:	fb4c      	movi.n	a11, 79
420016f7:	fa93a1        	l32r	a10, 42000144 <_stext+0x124> (3c020651 <_flash_rodata_start+0x531>)
420016fa:	fa7181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420016fd:	0008e0        	callx8	a8
    bool rc_fast_d256_is_enabled = rtc_clk_8md256_enabled();
42001700:	fa9581        	l32r	a8, 42000154 <_stext+0x134> (403788f0 <rtc_clk_8md256_enabled>)
42001703:	0008e0        	callx8	a8
    rtc_clk_8m_enable(true, rc_fast_d256_is_enabled);
42001706:	0abd      	mov.n	a11, a10
42001708:	1a0c      	movi.n	a10, 1
4200170a:	fa8681        	l32r	a8, 42000124 <_stext+0x104> (40378850 <rtc_clk_8m_enable>)
4200170d:	0008e0        	callx8	a8
    rtc_clk_fast_src_set(SOC_RTC_FAST_CLK_SRC_RC_FAST);
42001710:	1a0c      	movi.n	a10, 1
42001712:	fa9181        	l32r	a8, 42000158 <_stext+0x138> (40378a58 <rtc_clk_fast_src_set>)
42001715:	0008e0        	callx8	a8
    wdt_hal_context_t rtc_wdt_ctx = {.inst = WDT_RWDT, .rwdt_dev = &RTCCNTL};
42001718:	070c      	movi.n	a7, 0
4200171a:	0179      	s32i.n	a7, a1, 0
4200171c:	fa6b81        	l32r	a8, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
4200171f:	1189      	s32i.n	a8, a1, 4
    uint32_t stage_timeout_ticks = (uint32_t)(1600ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001721:	fa8e81        	l32r	a8, 4200015c <_stext+0x13c> (40378a30 <rtc_clk_slow_freq_get_hz>)
42001724:	0008e0        	callx8	a8
42001727:	40a682        	movi	a8, 0x640
4200172a:	a2b8a0        	muluh	a11, a8, a10
4200172d:	e8a3c2        	movi	a12, 0x3e8
42001730:	07dd      	mov.n	a13, a7
42001732:	82a8a0        	mull	a10, a8, a10
42001735:	fa8a81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
42001738:	0008e0        	callx8	a8
4200173b:	0a6d      	mov.n	a6, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
4200173d:	01ad      	mov.n	a10, a1
4200173f:	fa6381        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001742:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
42001745:	01ad      	mov.n	a10, a1
42001747:	fa8781        	l32r	a8, 42000164 <_stext+0x144> (40000e1c <wdt_hal_feed>)
4200174a:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
4200174d:	4d0c      	movi.n	a13, 4
4200174f:	06cd      	mov.n	a12, a6
42001751:	07bd      	mov.n	a11, a7
42001753:	01ad      	mov.n	a10, a1
42001755:	fa8481        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001758:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
4200175b:	01ad      	mov.n	a10, a1
4200175d:	fa5d81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001760:	0008e0        	callx8	a8
    select_rtc_slow_clk(SLOW_CLK_RTC);
42001763:	07ad      	mov.n	a10, a7
42001765:	ffeb65        	call8	4200161c <select_rtc_slow_clk>
    stage_timeout_ticks = (uint32_t)((uint64_t)CONFIG_BOOTLOADER_WDT_TIME_MS * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001768:	fa7d81        	l32r	a8, 4200015c <_stext+0x13c> (40378a30 <rtc_clk_slow_freq_get_hz>)
4200176b:	0008e0        	callx8	a8
4200176e:	fa7681        	l32r	a8, 42000148 <_stext+0x128> (2328 <UserFrameTotalSize+0x2228>)
42001771:	a2ba80        	muluh	a11, a10, a8
42001774:	e8a3c2        	movi	a12, 0x3e8
42001777:	07dd      	mov.n	a13, a7
42001779:	82aa80        	mull	a10, a10, a8
4200177c:	fa7981        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4200177f:	0008e0        	callx8	a8
42001782:	0a6d      	mov.n	a6, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001784:	01ad      	mov.n	a10, a1
42001786:	fa5181        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001789:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
4200178c:	01ad      	mov.n	a10, a1
4200178e:	fa7581        	l32r	a8, 42000164 <_stext+0x144> (40000e1c <wdt_hal_feed>)
42001791:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
42001794:	4d0c      	movi.n	a13, 4
42001796:	06cd      	mov.n	a12, a6
42001798:	07bd      	mov.n	a11, a7
4200179a:	01ad      	mov.n	a10, a1
4200179c:	fa7381        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
4200179f:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
420017a2:	01ad      	mov.n	a10, a1
420017a4:	fa4c81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
420017a7:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_get_config(&old_config);
420017aa:	a18b      	addi.n	a10, a1, 8
420017ac:	fa7081        	l32r	a8, 4200016c <_stext+0x14c> (40378b44 <rtc_clk_cpu_freq_get_config>)
420017af:	0008e0        	callx8	a8
    const uint32_t old_freq_mhz = old_config.freq_mhz;
420017b2:	5168      	l32i.n	a6, a1, 20
    bool res = rtc_clk_cpu_freq_mhz_to_config(new_freq_mhz, &new_config);
420017b4:	18c1b2        	addi	a11, a1, 24
420017b7:	a0a0a2        	movi	a10, 160
420017ba:	fa6d81        	l32r	a8, 42000170 <_stext+0x150> (40378adc <rtc_clk_cpu_freq_mhz_to_config>)
420017bd:	0008e0        	callx8	a8
420017c0:	0a7d      	mov.n	a7, a10
    assert(res);
420017c2:	0adc      	bnez.n	a10, 420017d6 <esp_clk_init+0xf6>
420017c4:	fa62d1        	l32r	a13, 4200014c <_stext+0x12c> (3c020658 <_flash_rodata_start+0x538>)
420017c7:	fa5ec1        	l32r	a12, 42000140 <_stext+0x120> (3c0270c4 <__func__$0>)
420017ca:	7da0b2        	movi	a11, 125
420017cd:	fa5da1        	l32r	a10, 42000144 <_stext+0x124> (3c020651 <_flash_rodata_start+0x531>)
420017d0:	fa3c81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420017d3:	0008e0        	callx8	a8
        esp_rom_output_tx_wait_idle(CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM);
420017d6:	4a0c      	movi.n	a10, 4
420017d8:	fa6781        	l32r	a8, 42000174 <_stext+0x154> (4000069c <esp_rom_output_tx_wait_idle>)
420017db:	0008e0        	callx8	a8
    if (res) {
420017de:	778c      	beqz.n	a7, 420017e9 <esp_clk_init+0x109>
        rtc_clk_cpu_freq_set_config(&new_config);
420017e0:	18c1a2        	addi	a10, a1, 24
420017e3:	fa6581        	l32r	a8, 42000178 <_stext+0x158> (40378ea0 <rtc_clk_cpu_freq_set_config>)
420017e6:	0008e0        	callx8	a8
    RSR(CCOUNT, ccount);
420017e9:	03ea80        	rsr.ccount	a8
    esp_cpu_set_cycle_count((uint64_t)esp_cpu_get_cycle_count() * new_freq_mhz / old_freq_mhz);
420017ec:	a0a0a2        	movi	a10, 160
420017ef:	a2ba80        	muluh	a11, a10, a8
420017f2:	06cd      	mov.n	a12, a6
420017f4:	00a0d2        	movi	a13, 0
420017f7:	82aa80        	mull	a10, a10, a8
420017fa:	fa5981        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
420017fd:	0008e0        	callx8	a8
    WSR(CCOUNT, ccount);
42001800:	13eaa0        	wsr.ccount	a10
}
42001803:	f01d      	retw.n
42001805:	000000        	ill

42001808 <esp_perip_clk_init>:
{
42001808:	006136        	entry	a1, 48
    rst_reas[0] = esp_rom_get_reset_reason(0);
4200180b:	00a0a2        	movi	a10, 0
4200180e:	fa4a81        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
42001811:	0008e0        	callx8	a8
42001814:	0a7d      	mov.n	a7, a10
42001816:	0061a2        	s32i	a10, a1, 0
    rst_reas[1] = esp_rom_get_reset_reason(1);
42001819:	01a0a2        	movi	a10, 1
4200181c:	fa4781        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
4200181f:	0008e0        	callx8	a8
42001822:	11a9      	s32i.n	a10, a1, 4
            rst_reas[0] == RESET_REASON_CPU0_RTC_WDT || rst_reas[0] == RESET_REASON_CPU0_MWDT1)
42001824:	f5c792        	addi	a9, a7, -11
42001827:	280c      	movi.n	a8, 2
42001829:	628890        	lsi	f9, a8, 0x188
4200182c:	880b      	addi.n	a8, a8, -1
4200182e:	608080        	neg	a8, a8
42001831:	efc772        	addi	a7, a7, -17
42001834:	40f770        	nsau	a7, a7
42001837:	417570        	srli	a7, a7, 5
4200183a:	208870        	or	a8, a8, a7
4200183d:	748080        	extui	a8, a8, 0, 8
    if ((rst_reas[0] == RESET_REASON_CPU0_MWDT0 || rst_reas[0] == RESET_REASON_CPU0_SW ||
42001840:	c8dc      	bnez.n	a8, 42001860 <esp_perip_clk_init+0x58>
                rst_reas[1] == RESET_REASON_CPU1_RTC_WDT || rst_reas[1] == RESET_REASON_CPU1_MWDT1)
42001842:	f5ca92        	addi	a9, a10, -11
42001845:	280c      	movi.n	a8, 2
42001847:	628890        	lsi	f9, a8, 0x188
4200184a:	880b      	addi.n	a8, a8, -1
4200184c:	608080        	neg	a8, a8
4200184f:	efcaa2        	addi	a10, a10, -17
42001852:	40faa0        	nsau	a10, a10
42001855:	41a5a0        	srli	a10, a10, 5
42001858:	2088a0        	or	a8, a8, a10
4200185b:	748080        	extui	a8, a8, 0, 8
            || (rst_reas[1] == RESET_REASON_CPU1_MWDT0 || rst_reas[1] == RESET_REASON_CPU1_SW ||
4200185e:	a8ac      	beqz.n	a8, 4200188c <esp_perip_clk_init+0x84>
        common_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN0_REG);
42001860:	fa4981        	l32r	a8, 42000184 <_stext+0x164> (600c0018 <SYSTEM+0x18>)
42001863:	0020c0        	memw
42001866:	0888      	l32i.n	a8, a8, 0
42001868:	f97c      	movi.n	a9, -1
4200186a:	308890        	xor	a8, a8, a9
        hwcrypto_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN1_REG);
4200186d:	fa4691        	l32r	a9, 42000188 <_stext+0x168> (600c001c <SYSTEM+0x1c>)
42001870:	0020c0        	memw
42001873:	09b8      	l32i.n	a11, a9, 0
42001875:	f97c      	movi.n	a9, -1
42001877:	30bb90        	xor	a11, a11, a9
        wifi_bt_sdio_clk = ~READ_PERI_REG(SYSTEM_WIFI_CLK_EN_REG);
4200187a:	fa4491        	l32r	a9, 4200018c <_stext+0x16c> (60026014 <SYSCON+0x14>)
4200187d:	0020c0        	memw
42001880:	0998      	l32i.n	a9, a9, 0
42001882:	fa7c      	movi.n	a10, -1
42001884:	3099a0        	xor	a9, a9, a10
42001887:	000286        	j	42001895 <esp_perip_clk_init+0x8d>
4200188a:	910000        	srl	a0, a0
        wifi_bt_sdio_clk = SYSTEM_WIFI_CLK_WIFI_EN |
4200188d:	fa3c      	movi.n	a10, 63
        hwcrypto_perip_clk = SYSTEM_CRYPTO_AES_CLK_EN |
4200188f:	0ea0b2        	movi	a11, 14
        common_perip_clk = SYSTEM_WDG_CLK_EN |
42001892:	fa3b81        	l32r	a8, 42000180 <_stext+0x160> (8efb8ffc <_rtc_reserved_end+0x2eeb8ffc>)
    common_perip_clk |= SYSTEM_I2S0_CLK_EN |
42001895:	fa3ea1        	l32r	a10, 42000190 <_stext+0x170> (88e513f4 <_rtc_reserved_end+0x28d513f4>)
42001898:	2088a0        	or	a8, a8, a10
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN0_REG, common_perip_clk);
4200189b:	fa3ac1        	l32r	a12, 42000184 <_stext+0x164> (600c0018 <SYSTEM+0x18>)
4200189e:	0020c0        	memw
420018a1:	002cd2        	l32i	a13, a12, 0
420018a4:	10a8d0        	and	a10, a8, a13
420018a7:	30aad0        	xor	a10, a10, a13
420018aa:	0020c0        	memw
420018ad:	006ca2        	s32i	a10, a12, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG, common_perip_clk);
420018b0:	fa39c1        	l32r	a12, 42000194 <_stext+0x174> (600c0020 <SYSTEM+0x20>)
420018b3:	0020c0        	memw
420018b6:	0ca8      	l32i.n	a10, a12, 0
420018b8:	208a80        	or	a8, a10, a8
420018bb:	0020c0        	memw
420018be:	0c89      	s32i.n	a8, a12, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, common_perip_clk1);
420018c0:	fa32a1        	l32r	a10, 42000188 <_stext+0x168> (600c001c <SYSTEM+0x1c>)
420018c3:	0020c0        	memw
420018c6:	0a88      	l32i.n	a8, a10, 0
420018c8:	0020c0        	memw
420018cb:	0a89      	s32i.n	a8, a10, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, common_perip_clk1);
420018cd:	fa3281        	l32r	a8, 42000198 <_stext+0x178> (600c0024 <SYSTEM+0x24>)
420018d0:	0020c0        	memw
420018d3:	08c8      	l32i.n	a12, a8, 0
420018d5:	0020c0        	memw
420018d8:	08c9      	s32i.n	a12, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, hwcrypto_perip_clk);
420018da:	0020c0        	memw
420018dd:	0ad8      	l32i.n	a13, a10, 0
420018df:	10cbd0        	and	a12, a11, a13
420018e2:	30ccd0        	xor	a12, a12, a13
420018e5:	0020c0        	memw
420018e8:	0ac9      	s32i.n	a12, a10, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, hwcrypto_perip_clk);
420018ea:	0020c0        	memw
420018ed:	08a8      	l32i.n	a10, a8, 0
420018ef:	20aab0        	or	a10, a10, a11
420018f2:	0020c0        	memw
420018f5:	08a9      	s32i.n	a10, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_PERI_BACKUP_RST);
420018f7:	0020c0        	memw
420018fa:	08a8      	l32i.n	a10, a8, 0
420018fc:	eb7c      	movi.n	a11, -2
420018fe:	10aab0        	and	a10, a10, a11
42001901:	0020c0        	memw
42001904:	08a9      	s32i.n	a10, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, wifi_bt_sdio_clk);
42001906:	fa21a1        	l32r	a10, 4200018c <_stext+0x16c> (60026014 <SYSCON+0x14>)
42001909:	0020c0        	memw
4200190c:	0ab8      	l32i.n	a11, a10, 0
4200190e:	1089b0        	and	a8, a9, a11
42001911:	3088b0        	xor	a8, a8, a11
42001914:	0020c0        	memw
42001917:	0a89      	s32i.n	a8, a10, 0
    SET_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, SYSTEM_WIFI_CLK_EN);
42001919:	0020c0        	memw
4200191c:	0a88      	l32i.n	a8, a10, 0
4200191e:	fa1f91        	l32r	a9, 4200019c <_stext+0x17c> (fb9fcf <UserFrameTotalSize+0xfb9ecf>)
42001921:	208890        	or	a8, a8, a9
42001924:	0020c0        	memw
42001927:	0a89      	s32i.n	a8, a10, 0
    REG_SET_FIELD(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 0);
42001929:	fa1d91        	l32r	a9, 420001a0 <_stext+0x180> (600c0028 <SYSTEM+0x28>)
4200192c:	0020c0        	memw
4200192f:	0988      	l32i.n	a8, a9, 0
42001931:	418c80        	srli	a8, a8, 12
42001934:	118840        	slli	a8, a8, 12
42001937:	0020c0        	memw
4200193a:	0989      	s32i.n	a8, a9, 0
    CLEAR_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_XTAL32K | SYSTEM_LPCLK_SEL_XTAL | SYSTEM_LPCLK_SEL_8M | SYSTEM_LPCLK_SEL_RTC_SLOW);
4200193c:	fa1a81        	l32r	a8, 420001a4 <_stext+0x184> (600c002c <SYSTEM+0x2c>)
4200193f:	0020c0        	memw
42001942:	0898      	l32i.n	a9, a8, 0
42001944:	fa19a1        	l32r	a10, 420001a8 <_stext+0x188> (f0ffffff <_rtc_reserved_end+0x90efffff>)
42001947:	1099a0        	and	a9, a9, a10
4200194a:	0020c0        	memw
4200194d:	0899      	s32i.n	a9, a8, 0
    SET_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_RTC_SLOW);
4200194f:	0020c0        	memw
42001952:	0898      	l32i.n	a9, a8, 0
42001954:	fa16a1        	l32r	a10, 420001ac <_stext+0x18c> (1000000 <UserFrameTotalSize+0xffff00>)
42001957:	2099a0        	or	a9, a9, a10
4200195a:	0020c0        	memw
4200195d:	0899      	s32i.n	a9, a8, 0
    periph_module_enable(PERIPH_RNG_MODULE);
4200195f:	9a1c      	movi.n	a10, 25
42001961:	1485a5        	call8	420161bc <periph_module_enable>
}
42001964:	f01d      	retw.n
	...

42001968 <esp_reset_reason_clear_hint>:
        return ESP_RST_UNKNOWN;
    }
    return (esp_reset_reason_t) low;
}
static void esp_reset_reason_clear_hint(void)
{
42001968:	004136        	entry	a1, 32
    REG_WRITE(RTC_RESET_CAUSE_REG, 0);
4200196b:	fa1181        	l32r	a8, 420001b0 <_stext+0x190> (600080c8 <RTCCNTL+0xc8>)
4200196e:	090c      	movi.n	a9, 0
42001970:	0020c0        	memw
42001973:	0899      	s32i.n	a9, a8, 0
}
42001975:	f01d      	retw.n
	...

42001978 <esp_reset_reason_get_hint>:
{
42001978:	004136        	entry	a1, 32
    uint32_t reset_reason_hint = REG_READ(RTC_RESET_CAUSE_REG);
4200197b:	fa0d81        	l32r	a8, 420001b0 <_stext+0x190> (600080c8 <RTCCNTL+0xc8>)
4200197e:	0020c0        	memw
42001981:	0888      	l32i.n	a8, a8, 0
    uint32_t high = (reset_reason_hint >> RST_REASON_SHIFT) & RST_REASON_MASK;
42001983:	e59080        	extui	a9, a8, 16, 15
    uint32_t low = reset_reason_hint & RST_REASON_MASK;
42001986:	e42080        	extui	a2, a8, 0, 15
    if ((reset_reason_hint & RST_REASON_BIT) == 0 || high != low) {
42001989:	318f80        	srai	a8, a8, 31
4200198c:	881b      	addi.n	a8, a8, 1
4200198e:	c09920        	sub	a9, a9, a2
42001991:	1a0c      	movi.n	a10, 1
42001993:	83a990        	moveqz	a10, a9, a9
42001996:	2088a0        	or	a8, a8, a10
42001999:	088c      	beqz.n	a8, 4200199d <esp_reset_reason_get_hint+0x25>
        return ESP_RST_UNKNOWN;
4200199b:	020c      	movi.n	a2, 0
}
4200199d:	f01d      	retw.n
	...

420019a0 <esp_reset_reason_init>:
{
420019a0:	004136        	entry	a1, 32
    esp_reset_reason_t hint = esp_reset_reason_get_hint();
420019a3:	fffd65        	call8	42001978 <esp_reset_reason_get_hint>
420019a6:	207aa0        	or	a7, a10, a10
    s_reset_reason = get_reset_reason(esp_rom_get_reset_reason(PRO_CPU_NUM), hint);
420019a9:	00a0a2        	movi	a10, 0
420019ac:	f9e381        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
420019af:	0008e0        	callx8	a8
420019b2:	07bd      	mov.n	a11, a7
420019b4:	13d6a5        	call8	42015720 <get_reset_reason>
420019b7:	f9ff81        	l32r	a8, 420001b4 <_stext+0x194> (3fc949ac <s_reset_reason>)
420019ba:	08a9      	s32i.n	a10, a8, 0
    if (hint != ESP_RST_UNKNOWN) {
420019bc:	178c      	beqz.n	a7, 420019c1 <esp_reset_reason_init+0x21>
        esp_reset_reason_clear_hint();
420019be:	fffaa5        	call8	42001968 <esp_reset_reason_clear_hint>
}
420019c1:	f01d      	retw.n
	...

420019c4 <esp_cache_err_get_panic_info>:
        }
    }
}

void esp_cache_err_get_panic_info(esp_cache_err_info_t *err_info)
{
420019c4:	004136        	entry	a1, 32
    if (err_info == NULL) {
420019c7:	029216        	beqz	a2, 420019f4 <esp_cache_err_get_panic_info+0x30>
 *
 * @return            Status mask
 */
static inline uint32_t cache_ll_l1_get_illegal_error_intr_status(uint32_t cache_id, uint32_t mask)
{
    return GET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_ST_REG, mask);
420019ca:	f9fb81        	l32r	a8, 420001b8 <_stext+0x198> (600c40e4 <SYSTEM+0x40e4>)
420019cd:	0020c0        	memw
420019d0:	0028a2        	l32i	a10, a8, 0
    }
    /* Read the status register EXTMEM_CACHE_ILG_INT_ST_REG. This status
     * register is not equal to 0 when a cache access error occurred. */
    const uint32_t illegal_intr_status = cache_ll_l1_get_illegal_error_intr_status(0, CACHE_LL_L1_ILG_EVENT_MASK);

    get_cache_error(illegal_intr_status, ilg_int_st_bits, DIM(ilg_int_st_bits), err_info);
420019d3:	02dd      	mov.n	a13, a2
420019d5:	06a0c2        	movi	a12, 6
420019d8:	f9f9b1        	l32r	a11, 420001bc <_stext+0x19c> (3c027110 <ilg_int_st_bits>)
420019db:	54a0a0        	extui	a10, a10, 0, 6
420019de:	13e0e5        	call8	420157ec <get_cache_error>

    // If no error reported above we check if the error came from ACS
    if (err_info->err_str == NULL) {
420019e1:	0288      	l32i.n	a8, a2, 0
420019e3:	d8cc      	bnez.n	a8, 420019f4 <esp_cache_err_get_panic_info+0x30>
        uint32_t st = access_error_intr_status;
        get_cache_error(st, acs_int_st_bits, DIM(acs_int_st_bits), err_info);
420019e5:	02dd      	mov.n	a13, a2
420019e7:	1c0c      	movi.n	a12, 1
420019e9:	f9f6b1        	l32r	a11, 420001c4 <_stext+0x1a4> (3c027100 <acs_int_st_bits>)
420019ec:	f9f581        	l32r	a8, 420001c0 <_stext+0x1a0> (3fc949b8 <access_error_intr_status>)
420019ef:	08a8      	l32i.n	a10, a8, 0
420019f1:	13dfa5        	call8	420157ec <get_cache_error>
    }
}
420019f4:	f01d      	retw.n
	...

420019f8 <esp_cache_err_acs_save_and_clr>:

void esp_cache_err_acs_save_and_clr(void)
{
420019f8:	004136        	entry	a1, 32
        return GET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ST_REG, mask);
420019fb:	f9f381        	l32r	a8, 420001c8 <_stext+0x1a8> (600c40f0 <SYSTEM+0x40f0>)
420019fe:	0020c0        	memw
42001a01:	0888      	l32i.n	a8, a8, 0
42001a03:	448080        	extui	a8, a8, 0, 5
    if (cache_ll_l1_get_access_error_intr_status(0, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
42001a06:	a88c      	beqz.n	a8, 42001a14 <esp_cache_err_acs_save_and_clr+0x1c>
        cache_err_cpu_id = PRO_CPU_NUM;
42001a08:	f9f181        	l32r	a8, 420001cc <_stext+0x1ac> (3fc949b0 <cache_err_cpu_id>)
42001a0b:	090c      	movi.n	a9, 0
42001a0d:	0899      	s32i.n	a9, a8, 0
42001a0f:	000906        	j	42001a37 <esp_cache_err_acs_save_and_clr+0x3f>
42001a12:	810000        	src	a0, a0, a0
        return GET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ST_REG, mask);
42001a15:	ef          	.byte	0xef
42001a16:	c0f9      	s32i.n	a15, a0, 48
42001a18:	880020        	lsi	f2, a0, 0x220
42001a1b:	8008      	l32i.n	a0, a0, 32
42001a1d:	8c4480        	lsi	f8, a4, 0x230
    } else if (cache_ll_l1_get_access_error_intr_status(1, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
42001a20:	8198      	l32i.n	a9, a1, 32
        cache_err_cpu_id = APP_CPU_NUM;
42001a22:	f9ea      	add.n	a15, a9, a14
42001a24:	190c      	movi.n	a9, 1
42001a26:	0899      	s32i.n	a9, a8, 0
42001a28:	0002c6        	j	42001a37 <esp_cache_err_acs_save_and_clr+0x3f>
42001a2b:	e88100        	lsi	f0, a1, 0x3a0
    } else {
        cache_err_cpu_id = -1;
42001a2e:	7cf9      	s32i.n	a15, a12, 28
42001a30:	99f9      	s32i.n	a15, a9, 36
42001a32:	c608      	l32i.n	a0, a6, 48
        return;
42001a34:	001b      	addi.n	a0, a0, 1
42001a36:	e58100        	extui	a8, a0, 17, 15

    // Certain errors needs to be cleared if the cache is to continue functioning properly.
    // E.g. for CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT errors the cache will sometimes end up in an invalid state
    // where the panic handler will then be unable to access rodata from flash
    // Store the error information before clearing, as it will be used later when reporting
    access_error_intr_status = cache_ll_l1_get_access_error_intr_status(cache_err_cpu_id, CACHE_LL_L1_ACCESS_EVENT_MASK);
42001a39:	98f9      	s32i.n	a15, a8, 36
42001a3b:	cc08      	l32i.n	a0, a12, 48
    if (cache_id == 0) {
42001a3d:	81c9      	s32i.n	a12, a1, 32
        return GET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ST_REG, mask);
42001a3f:	c0f9e2        	s32ri	a14, a9, 0x300
42001a42:	880020        	lsi	f2, a0, 0x220
42001a45:	8008      	l32i.n	a0, a0, 32
42001a47:	864480        	lsi	f8, a4, 0x218
42001a4a:	810002        	l8ui	a0, a0, 129
        return GET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ST_REG, mask);
42001a4d:	c0f9e1        	l32r	a14, 41ff1e34 <_coredump_iram_end+0x1c6fe34>
42001a50:	880020        	lsi	f2, a0, 0x220
42001a53:	8008      	l32i.n	a0, a0, 32
42001a55:	a14480        	lsi	f8, a4, 0x284
42001a58:	f9da      	add.n	a15, a9, a13
42001a5a:	0a89      	s32i.n	a8, a10, 0
    if (access_error_intr_status & CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT) {
42001a5c:	0a1c      	movi.n	a10, 16
42001a5e:	4408a7        	bnone	a8, a10, 42001aa6 <esp_cache_err_acs_save_and_clr+0xae>
 * @return vaddr that cause the acs dbus reject error
 */
__attribute__((always_inline))
static inline uint32_t cache_ll_get_acs_dbus_reject_vaddr(uint32_t cache_id)
{
    if (cache_id == 0) {
42001a61:	b9cc      	bnez.n	a9, 42001a70 <esp_cache_err_acs_save_and_clr+0x78>
        return REG_READ(EXTMEM_CORE0_DBUS_REJECT_VADDR_REG);
42001a63:	f9dc81        	l32r	a8, 420001d4 <_stext+0x1b4> (600c4104 <SYSTEM+0x4104>)
42001a66:	0020c0        	memw
42001a69:	08a8      	l32i.n	a10, a8, 0
42001a6b:	000246        	j	42001a78 <esp_cache_err_acs_save_and_clr+0x80>
42001a6e:	810000        	src	a0, a0, a0
    } else {
        return REG_READ(EXTMEM_CORE1_DBUS_REJECT_VADDR_REG);
42001a71:	f9da      	add.n	a15, a9, a13
42001a73:	0020c0        	memw
42001a76:	08a8      	l32i.n	a10, a8, 0
        acs_fault_addr = cache_ll_get_acs_dbus_reject_vaddr(cache_err_cpu_id);
42001a78:	f9d981        	l32r	a8, 420001dc <_stext+0x1bc> (3fc949b4 <acs_fault_addr>)
42001a7b:	08a9      	s32i.n	a10, a8, 0
    if (cache_id == 0) {
42001a7d:	39dc      	bnez.n	a9, 42001a94 <esp_cache_err_acs_save_and_clr+0x9c>
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_CLR_REG, mask);
42001a7f:	f9d891        	l32r	a9, 420001e0 <_stext+0x1c0> (600c40ec <SYSTEM+0x40ec>)
42001a82:	0020c0        	memw
42001a85:	0988      	l32i.n	a8, a9, 0
42001a87:	0a1c      	movi.n	a10, 16
42001a89:	2088a0        	or	a8, a8, a10
42001a8c:	0020c0        	memw
42001a8f:	0989      	s32i.n	a8, a9, 0
42001a91:	000446        	j	42001aa6 <esp_cache_err_acs_save_and_clr+0xae>
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_CLR_REG, mask);
42001a94:	f9d491        	l32r	a9, 420001e4 <_stext+0x1c4> (600c40f8 <SYSTEM+0x40f8>)
42001a97:	0020c0        	memw
42001a9a:	0988      	l32i.n	a8, a9, 0
42001a9c:	0a1c      	movi.n	a10, 16
42001a9e:	2088a0        	or	a8, a8, a10
42001aa1:	0020c0        	memw
42001aa4:	0989      	s32i.n	a8, a9, 0
        cache_ll_l1_clear_access_error_intr(cache_err_cpu_id, CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT);
    }
}
42001aa6:	f01d      	retw.n

42001aa8 <esp_cache_err_int_init>:

void esp_cache_err_int_init(void)
{
42001aa8:	004136        	entry	a1, 32
    asm volatile (
42001aab:	03eb70        	rsr.prid	a7
42001aae:	047d70        	extui	a7, a7, 13, 1
    uint32_t core_id = esp_cpu_get_core_id();
    ESP_INTR_DISABLE(ETS_CACHEERR_INUM);
42001ab1:	9a1c      	movi.n	a10, 25
42001ab3:	f9d481        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
42001ab6:	0008e0        	callx8	a8

    // We do not register a handler for the interrupt because it is interrupt
    // level 4 which is not serviceable from C. Instead, xtensa_vectors.S has
    // a call to the panic handler for this interrupt.
    esp_rom_route_intr_matrix(core_id, ETS_CACHE_IA_INTR_SOURCE, ETS_CACHEERR_INUM);
42001ab9:	9c1c      	movi.n	a12, 25
42001abb:	8b3c      	movi.n	a11, 56
42001abd:	07ad      	mov.n	a10, a7
42001abf:	f98681        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
42001ac2:	0008e0        	callx8	a8
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_CLR_REG, mask);
42001ac5:	f9c891        	l32r	a9, 420001e8 <_stext+0x1c8> (600c40e0 <SYSTEM+0x40e0>)
42001ac8:	0020c0        	memw
42001acb:	0988      	l32i.n	a8, a9, 0
42001acd:	fa3c      	movi.n	a10, 63
42001acf:	2088a0        	or	a8, a8, a10
42001ad2:	0020c0        	memw
42001ad5:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_ENA_REG, mask);
42001ad7:	f9c591        	l32r	a9, 420001ec <_stext+0x1cc> (600c40dc <SYSTEM+0x40dc>)
42001ada:	0020c0        	memw
42001add:	0988      	l32i.n	a8, a9, 0
42001adf:	2088a0        	or	a8, a8, a10
42001ae2:	0020c0        	memw
42001ae5:	0989      	s32i.n	a8, a9, 0
    ESP_DRAM_LOGV(TAG, "illegal error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ILG_EVENT_MASK);
    //illegal error intr doesn't depend on cache_id
    cache_ll_l1_clear_illegal_error_intr(0, CACHE_LL_L1_ILG_EVENT_MASK);
    cache_ll_l1_enable_illegal_error_intr(0, CACHE_LL_L1_ILG_EVENT_MASK);

    if (core_id == PRO_CPU_NUM) {
42001ae7:	f7ec      	bnez.n	a7, 42001b1a <esp_cache_err_int_init+0x72>
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE0_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
42001ae9:	9c1c      	movi.n	a12, 25
42001aeb:	eb5c      	movi.n	a11, 94
42001aed:	07ad      	mov.n	a10, a7
42001aef:	f97a81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
42001af2:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_CLR_REG, mask);
42001af5:	f9ba91        	l32r	a9, 420001e0 <_stext+0x1c0> (600c40ec <SYSTEM+0x40ec>)
42001af8:	0020c0        	memw
42001afb:	0988      	l32i.n	a8, a9, 0
42001afd:	fa1c      	movi.n	a10, 31
42001aff:	2088a0        	or	a8, a8, a10
42001b02:	0020c0        	memw
42001b05:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ENA_REG, mask);
42001b07:	f9ba91        	l32r	a9, 420001f0 <_stext+0x1d0> (600c40e8 <SYSTEM+0x40e8>)
42001b0a:	0020c0        	memw
42001b0d:	0988      	l32i.n	a8, a9, 0
42001b0f:	2088a0        	or	a8, a8, a10
42001b12:	0020c0        	memw
42001b15:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
42001b17:	000bc6        	j	42001b4a <esp_cache_err_int_init+0xa2>
         * enabling cache access error interrupts.  */
        ESP_DRAM_LOGV(TAG, "core 0 access error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_clear_access_error_intr(0, CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_enable_access_error_intr(0, CACHE_LL_L1_ACCESS_EVENT_MASK);
    } else {
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE1_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
42001b1a:	9c1c      	movi.n	a12, 25
42001b1c:	5fa0b2        	movi	a11, 95
42001b1f:	20a770        	or	a10, a7, a7
42001b22:	f96d81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
42001b25:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_CLR_REG, mask);
42001b28:	f9af91        	l32r	a9, 420001e4 <_stext+0x1c4> (600c40f8 <SYSTEM+0x40f8>)
42001b2b:	0020c0        	memw
42001b2e:	0988      	l32i.n	a8, a9, 0
42001b30:	fa1c      	movi.n	a10, 31
42001b32:	2088a0        	or	a8, a8, a10
42001b35:	0020c0        	memw
42001b38:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
42001b3a:	f9ae91        	l32r	a9, 420001f4 <_stext+0x1d4> (600c40f4 <SYSTEM+0x40f4>)
42001b3d:	0020c0        	memw
42001b40:	0988      	l32i.n	a8, a9, 0
42001b42:	2088a0        	or	a8, a8, a10
42001b45:	0020c0        	memw
42001b48:	0989      	s32i.n	a8, a9, 0
        ESP_DRAM_LOGV(TAG, "core 1 access error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_clear_access_error_intr(1, CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_enable_access_error_intr(1, CACHE_LL_L1_ACCESS_EVENT_MASK);
    }

    if (core_id == 0) {
42001b4a:	064756        	bnez	a7, 42001bb2 <esp_cache_err_int_init+0x10a>
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_addr(uint8_t spi_num, uint32_t region, uint32_t address)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_addr = address;
42001b4d:	f9aa81        	l32r	a8, 420001f8 <_stext+0x1d8> (60026000 <SYSCON>)
42001b50:	090c      	movi.n	a9, 0
42001b52:	0020c0        	memw
42001b55:	e899      	s32i.n	a9, a8, 56
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_size(uint8_t spi_num, uint32_t region, uint32_t size)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_size.flash_ace0_size = size;
42001b57:	0020c0        	memw
42001b5a:	1228b2        	l32i	a11, a8, 72
42001b5d:	f9a791        	l32r	a9, 420001fc <_stext+0x1dc> (ffff0000 <_rtc_reserved_end+0x9fef0000>)
42001b60:	10bb90        	and	a11, a11, a9
42001b63:	f9a7a1        	l32r	a10, 42000200 <_stext+0x1e0> (4000 <UserFrameTotalSize+0x3f00>)
42001b66:	20aba0        	or	a10, a11, a10
42001b69:	0020c0        	memw
42001b6c:	1268a2        	s32i	a10, a8, 72
            break;
        case 1:
            SYSCON.flash_ace1_size.flash_ace1_size = size;
42001b6f:	0020c0        	memw
42001b72:	1328b2        	l32i	a11, a8, 76
42001b75:	10ab90        	and	a10, a11, a9
42001b78:	0020c0        	memw
42001b7b:	1368a2        	s32i	a10, a8, 76
            break;
        case 2:
            SYSCON.flash_ace2_size.flash_ace2_size = size;
42001b7e:	0020c0        	memw
42001b81:	1428b2        	l32i	a11, a8, 80
42001b84:	10ab90        	and	a10, a11, a9
42001b87:	0020c0        	memw
42001b8a:	1468a2        	s32i	a10, a8, 80
            break;
        case 3:
            SYSCON.flash_ace3_size.flash_ace3_size = size;
42001b8d:	0020c0        	memw
42001b90:	1528a2        	l32i	a10, a8, 84
42001b93:	109a90        	and	a9, a10, a9
42001b96:	0020c0        	memw
42001b99:	156892        	s32i	a9, a8, 84
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_access(uint8_t spi_num, uint32_t region, mspi_ll_flash_ace_ctrl_t ctrl)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_attr.flash_ace0_attr = ctrl.val;
42001b9c:	0020c0        	memw
42001b9f:	a8a8      	l32i.n	a10, a8, 40
42001ba1:	00ae92        	movi	a9, 0xfffffe00
42001ba4:	10aa90        	and	a10, a10, a9
42001ba7:	dba092        	movi	a9, 219
42001baa:	209a90        	or	a9, a10, a9
42001bad:	0020c0        	memw
42001bb0:	a899      	s32i.n	a9, a8, 40

        mspi_ll_set_flash_protection_access(0, 0, ctrl);

    }

    ESP_INTR_ENABLE(ETS_CACHEERR_INUM);
42001bb2:	9a1c      	movi.n	a10, 25
42001bb4:	f99581        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
42001bb7:	0008e0        	callx8	a8
}
42001bba:	f01d      	retw.n

42001bbc <esp_cache_err_get_cpuid>:

int esp_cache_err_get_cpuid(void)
{
42001bbc:	004136        	entry	a1, 32
    return cache_err_cpu_id;
}
42001bbf:	f98381        	l32r	a8, 420001cc <_stext+0x1ac> (3fc949b0 <cache_err_cpu_id>)
42001bc2:	0828      	l32i.n	a2, a8, 0
42001bc4:	f01d      	retw.n
	...

42001bc8 <esp_apb_backup_dma_lock_init>:

void esp_apb_backup_dma_lock_init(void)
{
42001bc8:	004136        	entry	a1, 32
    ets_apb_backup_init_lock_func(apb_backup_dma_lock, apb_backup_dma_unlock);
42001bcb:	f990b1        	l32r	a11, 4200020c <_stext+0x1ec> (403758a8 <apb_backup_dma_unlock>)
42001bce:	f990a1        	l32r	a10, 42000210 <_stext+0x1f0> (403758c4 <apb_backup_dma_lock>)
42001bd1:	f99081        	l32r	a8, 42000214 <_stext+0x1f4> (40000630 <ets_apb_backup_init_lock_func>)
42001bd4:	0008e0        	callx8	a8
}
42001bd7:	f01d      	retw.n
42001bd9:	000000        	ill

42001bdc <esp_int_wdt_init>:

void esp_int_wdt_init(void)
{
42001bdc:	004136        	entry	a1, 32
    PERIPH_RCC_ACQUIRE_ATOMIC(IWDT_PERIPH, ref_count) {
42001bdf:	170c      	movi.n	a7, 1
42001be1:	001446        	j	42001c36 <esp_int_wdt_init+0x5a>
        SYSTEM.perip_clk_en0.timergroup1_clk_en = enable;
42001be4:	f98d81        	l32r	a8, 42000218 <_stext+0x1f8> (600c0000 <SYSTEM>)
42001be7:	0020c0        	memw
42001bea:	6898      	l32i.n	a9, a8, 24
42001bec:	f98ca1        	l32r	a10, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
42001bef:	2099a0        	or	a9, a9, a10
42001bf2:	0020c0        	memw
42001bf5:	6899      	s32i.n	a9, a8, 24
    } else {
        SYSTEM.perip_rst_en0.timergroup1_rst = 1;
42001bf7:	0020c0        	memw
42001bfa:	8898      	l32i.n	a9, a8, 32
42001bfc:	2099a0        	or	a9, a9, a10
42001bff:	0020c0        	memw
42001c02:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup1_rst = 0;
42001c04:	0020c0        	memw
42001c07:	8898      	l32i.n	a9, a8, 32
42001c09:	f985a1        	l32r	a10, 42000220 <_stext+0x200> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
42001c0c:	1099a0        	and	a9, a9, a10
42001c0f:	0020c0        	memw
42001c12:	8899      	s32i.n	a9, a8, 32
        TIMERG1.wdtconfig0.wdt_flashboot_mod_en = 0;
42001c14:	f98491        	l32r	a9, 42000224 <_stext+0x204> (60020000 <TIMERG1>)
42001c17:	0020c0        	memw
42001c1a:	122982        	l32i	a8, a9, 72
42001c1d:	f982a1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42001c20:	1088a0        	and	a8, a8, a10
42001c23:	0020c0        	memw
42001c26:	126982        	s32i	a8, a9, 72
42001c29:	ba0c      	movi.n	a10, 11
42001c2b:	f98381        	l32r	a8, 42000238 <_stext+0x218> (403766cc <periph_rcc_acquire_exit>)
42001c2e:	0008e0        	callx8	a8
42001c31:	770b      	addi.n	a7, a7, -1
42001c33:	747070        	extui	a7, a7, 0, 8
42001c36:	e78c      	beqz.n	a7, 42001c48 <esp_int_wdt_init+0x6c>
42001c38:	ba0c      	movi.n	a10, 11
42001c3a:	f98081        	l32r	a8, 4200023c <_stext+0x21c> (403766bc <periph_rcc_acquire_enter>)
42001c3d:	0008e0        	callx8	a8
42001c40:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
42001c42:	f9ea16        	beqz	a10, 42001be4 <esp_int_wdt_init+0x8>
42001c45:	fff806        	j	42001c29 <esp_int_wdt_init+0x4d>
    /*
     * Initialize the WDT timeout stages. Note that the initial timeout is set to 5 seconds as variable startup times of
     * each CPU can lead to a timeout. The tick hooks will set the WDT timers to the actual timeout.
     * Todo: Fix this
     */
    wdt_hal_init(&iwdt_context, IWDT_INSTANCE, IWDT_PRESCALER, true);
42001c48:	f97a71        	l32r	a7, 42000230 <_stext+0x210> (3fc949c0 <iwdt_context>)
42001c4b:	1d0c      	movi.n	a13, 1
42001c4d:	f977c1        	l32r	a12, 4200022c <_stext+0x20c> (9c40 <UserFrameTotalSize+0x9b40>)
42001c50:	2b0c      	movi.n	a11, 2
42001c52:	07ad      	mov.n	a10, a7
42001c54:	f97b81        	l32r	a8, 42000240 <_stext+0x220> (40000dbc <wdt_hal_init>)
42001c57:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&iwdt_context);
42001c5a:	07ad      	mov.n	a10, a7
42001c5c:	f91c81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001c5f:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);
42001c62:	f97461        	l32r	a6, 42000234 <_stext+0x214> (2710 <UserFrameTotalSize+0x2610>)
42001c65:	1d0c      	movi.n	a13, 1
42001c67:	06cd      	mov.n	a12, a6
42001c69:	00a0b2        	movi	a11, 0
42001c6c:	07ad      	mov.n	a10, a7
42001c6e:	f93e81        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001c71:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM);
42001c74:	3d0c      	movi.n	a13, 3
42001c76:	06cd      	mov.n	a12, a6
42001c78:	1b0c      	movi.n	a11, 1
42001c7a:	07ad      	mov.n	a10, a7
42001c7c:	f93b81        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001c7f:	0008e0        	callx8	a8
    wdt_hal_enable(&iwdt_context);
42001c82:	07ad      	mov.n	a10, a7
42001c84:	f97081        	l32r	a8, 42000244 <_stext+0x224> (40000df8 <wdt_hal_enable>)
42001c87:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&iwdt_context);
42001c8a:	07ad      	mov.n	a10, a7
42001c8c:	f91281        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001c8f:	0008e0        	callx8	a8
                : [ERI] "=r"(eriadrs), [REG] "+r"(scratch), [IMM] "+r"(immediate)
            );
        }
    }
#endif // (CONFIG_ESP32_ECO3_CACHE_LOCK_FIX && CONFIG_BTDM_CTRL_HLI)
}
42001c92:	f01d      	retw.n

42001c94 <esp_int_wdt_cpu_init>:

void esp_int_wdt_cpu_init(void)
{
42001c94:	004136        	entry	a1, 32
42001c97:	03ebb0        	rsr.prid	a11
42001c9a:	04bdb0        	extui	a11, a11, 13, 1
    assert((CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (portTICK_PERIOD_MS << 1)) && "Interrupt watchdog timeout needs to be at least twice the RTOS tick period!");
    // Register tick hook for current CPU to feed the INT WDT
    esp_register_freertos_tick_hook_for_cpu(tick_hook, esp_cpu_get_core_id());
42001c9d:	f96aa1        	l32r	a10, 42000248 <_stext+0x228> (403758e4 <tick_hook>)
42001ca0:	00b725        	call8	42002814 <esp_register_freertos_tick_hook_for_cpu>
    /*
     * Register INT WDT interrupt for current CPU. We do this manually as the timeout interrupt should call an assembly
     * panic handler (see riscv/vector.S and xtensa_vectors.S).
     */
    esp_intr_disable_source(ETS_INT_WDT_INUM);
42001ca3:	18a0a2        	movi	a10, 24
42001ca6:	f95781        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
42001ca9:	0008e0        	callx8	a8
42001cac:	03eba0        	rsr.prid	a10
42001caf:	04ada0        	extui	a10, a10, 13, 1
    esp_rom_route_intr_matrix(esp_cpu_get_core_id(), WDT_LEVEL_INTR_SOURCE, ETS_INT_WDT_INUM);
42001cb2:	18a0c2        	movi	a12, 24
42001cb5:	37a0b2        	movi	a11, 55
42001cb8:	f90881        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
42001cbb:	0008e0        	callx8	a8
        assert((portTICK_PERIOD_MS << 1) <= IWDT_LIVELOCK_TIMEOUT_MS);
        assert(CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (IWDT_LIVELOCK_TIMEOUT_MS * 3));
        _lx_intr_livelock_max = CONFIG_ESP_INT_WDT_TIMEOUT_MS / IWDT_LIVELOCK_TIMEOUT_MS - 1;
    }
#endif
    esp_intr_enable_source(ETS_INT_WDT_INUM);
42001cbe:	8a1c      	movi.n	a10, 24
42001cc0:	f95281        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
42001cc3:	0008e0        	callx8	a8
}
42001cc6:	f01d      	retw.n

42001cc8 <panic_print_char_usb_serial_jtag>:
{
42001cc8:	006136        	entry	a1, 48
42001ccb:	004122        	s8i	a2, a1, 0
    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
42001cce:	000446        	j	42001ce3 <panic_print_char_usb_serial_jtag+0x1b>
        esp_rom_delay_us(100);
42001cd1:	64a0a2        	movi	a10, 100
42001cd4:	f90b81        	l32r	a8, 42000100 <_stext+0xe0> (40000600 <esp_rom_delay_us>)
42001cd7:	0008e0        	callx8	a8
        s_usbserial_timeout++;
42001cda:	f95c91        	l32r	a9, 4200024c <_stext+0x22c> (3fc949c8 <s_usbserial_timeout>)
42001cdd:	0988      	l32i.n	a8, a9, 0
42001cdf:	881b      	addi.n	a8, a8, 1
42001ce1:	0989      	s32i.n	a8, a9, 0
 *
 * @return 0 if no data available, 1 if data available
 */
static inline int usb_serial_jtag_ll_txfifo_writable(void)
{
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
42001ce3:	f95b81        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42001ce6:	0020c0        	memw
42001ce9:	1888      	l32i.n	a8, a8, 4
    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
42001ceb:	0ae817        	bbsi	a8, 1, 42001cf9 <panic_print_char_usb_serial_jtag+0x31>
42001cee:	f95781        	l32r	a8, 4200024c <_stext+0x22c> (3fc949c8 <s_usbserial_timeout>)
42001cf1:	0888      	l32i.n	a8, a8, 0
42001cf3:	f3a192        	movi	a9, 0x1f3
42001cf6:	d7a987        	bge	a9, a8, 42001cd1 <panic_print_char_usb_serial_jtag+0x9>
42001cf9:	f95581        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42001cfc:	0020c0        	memw
42001cff:	1888      	l32i.n	a8, a8, 4
    if (usb_serial_jtag_ll_txfifo_writable()) {
42001d01:	20e817        	bbsi	a8, 1, 42001d25 <panic_print_char_usb_serial_jtag+0x5d>
42001d04:	000a46        	j	42001d31 <panic_print_char_usb_serial_jtag+0x69>
42001d07:	529100        	lsi	f0, a1, 0x148
        if (!USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free) break;
42001d0a:	c0f9      	s32i.n	a15, a0, 48
42001d0c:	980020        	lsi	f2, a0, 0x260
42001d0f:	1719      	s32i.n	a1, a7, 4
42001d11:	1669      	s32i.n	a6, a6, 4
        USB_SERIAL_JTAG.ep1.rdwr_byte = buf[i];
42001d13:	918a      	add.n	a9, a1, a8
42001d15:	0009a2        	l8ui	a10, a9, 0
42001d18:	f94e91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42001d1b:	0020c0        	memw
42001d1e:	09a9      	s32i.n	a10, a9, 0
    for (i = 0; i < wr_len; i++) {
42001d20:	881b      	addi.n	a8, a8, 1
42001d22:	000046        	j	42001d27 <panic_print_char_usb_serial_jtag+0x5f>
42001d25:	080c      	movi.n	a8, 0
42001d27:	fdd816        	beqz	a8, 42001d08 <panic_print_char_usb_serial_jtag+0x40>
        s_usbserial_timeout = 0;
42001d2a:	f94881        	l32r	a8, 4200024c <_stext+0x22c> (3fc949c8 <s_usbserial_timeout>)
42001d2d:	090c      	movi.n	a9, 0
42001d2f:	0899      	s32i.n	a9, a8, 0
}
42001d31:	f01d      	retw.n
	...

42001d34 <disable_all_wdts>:
{
42001d34:	006136        	entry	a1, 48
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001d37:	f94781        	l32r	a8, 42000254 <_stext+0x234> (3c027170 <ilg_int_st_bits+0x60>)
42001d3a:	0898      	l32i.n	a9, a8, 0
42001d3c:	1888      	l32i.n	a8, a8, 4
42001d3e:	0199      	s32i.n	a9, a1, 0
42001d40:	1189      	s32i.n	a8, a1, 4
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001d42:	f94581        	l32r	a8, 42000258 <_stext+0x238> (3c027178 <ilg_int_st_bits+0x68>)
42001d45:	718b      	addi.n	a7, a1, 8
42001d47:	0898      	l32i.n	a9, a8, 0
42001d49:	1888      	l32i.n	a8, a8, 4
42001d4b:	2199      	s32i.n	a9, a1, 8
42001d4d:	3189      	s32i.n	a8, a1, 12
    wdt_hal_write_protect_disable(&wdt0_context);
42001d4f:	20a110        	or	a10, a1, a1
42001d52:	f8de81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001d55:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
42001d58:	01ad      	mov.n	a10, a1
42001d5a:	f8dd81        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42001d5d:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
42001d60:	01ad      	mov.n	a10, a1
42001d62:	f8dc81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001d65:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt1_context);
42001d68:	07ad      	mov.n	a10, a7
42001d6a:	f8d881        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001d6d:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
42001d70:	07ad      	mov.n	a10, a7
42001d72:	f8d781        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42001d75:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
42001d78:	07ad      	mov.n	a10, a7
42001d7a:	f8d681        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001d7d:	0008e0        	callx8	a8
}
42001d80:	f01d      	retw.n
	...

42001d84 <panic_print_char>:
{
42001d84:	004136        	entry	a1, 32
    panic_print_char_usb_serial_jtag(c);
42001d87:	74a020        	extui	a10, a2, 0, 8
42001d8a:	fff3e5        	call8	42001cc8 <panic_print_char_usb_serial_jtag>
}
42001d8d:	f01d      	retw.n
	...

42001d90 <panic_print_str>:
{
42001d90:	004136        	entry	a1, 32
    for (int i = 0; str[i] != 0; i++) {
42001d93:	070c      	movi.n	a7, 0
42001d95:	000146        	j	42001d9e <panic_print_str+0xe>
        panic_print_char(str[i]);
42001d98:	fffea5        	call8	42001d84 <panic_print_char>
    for (int i = 0; str[i] != 0; i++) {
42001d9b:	01c772        	addi	a7, a7, 1
42001d9e:	808270        	add	a8, a2, a7
42001da1:	0008a2        	l8ui	a10, a8, 0
42001da4:	ff0a56        	bnez	a10, 42001d98 <panic_print_str+0x8>
}
42001da7:	000090        	retw
	...

42001dac <print_abort_details>:
{
42001dac:	004136        	entry	a1, 32
    panic_print_str(g_panic_abort_details);
42001daf:	f92b81        	l32r	a8, 4200025c <_stext+0x23c> (3fc949cc <g_panic_abort_details>)
42001db2:	08a8      	l32i.n	a10, a8, 0
42001db4:	fffda5        	call8	42001d90 <panic_print_str>
}
42001db7:	f01d      	retw.n
42001db9:	000000        	ill

42001dbc <panic_print_hex>:
{
42001dbc:	004136        	entry	a1, 32
    for (x = 0; x < 8; x++) {
42001dbf:	070c      	movi.n	a7, 0
42001dc1:	000786        	j	42001de3 <panic_print_hex+0x27>
        c = (h >> 28) & 0xf; // extract the leftmost byte
42001dc4:	35ac20        	extui	a10, a2, 28, 4
        if (c < 10) {
42001dc7:	980c      	movi.n	a8, 9
42001dc9:	0b28a7        	blt	a8, a10, 42001dd8 <panic_print_hex+0x1c>
            panic_print_char('0' + c);
42001dcc:	30caa2        	addi	a10, a10, 48
42001dcf:	fffb65        	call8	42001d84 <panic_print_char>
42001dd2:	000206        	j	42001dde <panic_print_hex+0x22>
42001dd5:	000000        	ill
            panic_print_char('a' + c - 10);
42001dd8:	57caa2        	addi	a10, a10, 87
42001ddb:	fffaa5        	call8	42001d84 <panic_print_char>
        h <<= 4; // move the 2nd leftmost byte to the left, to be extracted next
42001dde:	1122c0        	slli	a2, a2, 4
    for (x = 0; x < 8; x++) {
42001de1:	771b      	addi.n	a7, a7, 1
42001de3:	dd87a6        	blti	a7, 8, 42001dc4 <panic_print_hex+0x8>
}
42001de6:	f01d      	retw.n

42001de8 <panic_print_dec>:
{
42001de8:	004136        	entry	a1, 32
    n1 = d % 10; // extract ones digit
42001deb:	f91d71        	l32r	a7, 42000260 <_stext+0x240> (66666667 <_rtc_reserved_end+0x6566667>)
42001dee:	b27270        	mulsh	a7, a2, a7
42001df1:	217270        	srai	a7, a7, 2
42001df4:	318f20        	srai	a8, a2, 31
42001df7:	c07780        	sub	a7, a7, a8
42001dfa:	07ad      	mov.n	a10, a7
42001dfc:	a07770        	addx4	a7, a7, a7
42001dff:	777a      	add.n	a7, a7, a7
42001e01:	c07270        	sub	a7, a2, a7
    if (n2 == 0) {
42001e04:	008a56        	bnez	a10, 42001e10 <panic_print_dec+0x28>
        panic_print_char(' ');
42001e07:	0a2c      	movi.n	a10, 32
42001e09:	fff7a5        	call8	42001d84 <panic_print_char>
42001e0c:	000246        	j	42001e19 <panic_print_dec+0x31>
42001e0f:	caa200        	float.s	f10, a2, 0
        panic_print_char(n2 + '0');
42001e12:	a0a030        	addx4	a10, a0, a3
42001e15:	f6e574        	lsi	f7, a5, 0x3d8
42001e18:	ff          	.byte	0xff
    panic_print_char(n1 + '0');
42001e19:	30c7a2        	addi	a10, a7, 48
42001e1c:	74a0a0        	extui	a10, a10, 0, 8
42001e1f:	fff665        	call8	42001d84 <panic_print_char>
}
42001e22:	f01d      	retw.n

42001e24 <esp_panic_handler_reconfigure_wdts>:
{
42001e24:	006136        	entry	a1, 48
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001e27:	f90b81        	l32r	a8, 42000254 <_stext+0x234> (3c027170 <ilg_int_st_bits+0x60>)
42001e2a:	0898      	l32i.n	a9, a8, 0
42001e2c:	1888      	l32i.n	a8, a8, 4
42001e2e:	0199      	s32i.n	a9, a1, 0
42001e30:	1189      	s32i.n	a8, a1, 4
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001e32:	f90981        	l32r	a8, 42000258 <_stext+0x238> (3c027178 <ilg_int_st_bits+0x68>)
42001e35:	718b      	addi.n	a7, a1, 8
42001e37:	0898      	l32i.n	a9, a8, 0
42001e39:	1888      	l32i.n	a8, a8, 4
42001e3b:	2199      	s32i.n	a9, a1, 8
42001e3d:	3189      	s32i.n	a8, a1, 12
    wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT_LL_DEFAULT_CLK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
42001e3f:	0d0c      	movi.n	a13, 0
42001e41:	f8fac1        	l32r	a12, 4200022c <_stext+0x20c> (9c40 <UserFrameTotalSize+0x9b40>)
42001e44:	1b0c      	movi.n	a11, 1
42001e46:	01ad      	mov.n	a10, a1
42001e48:	f8fe81        	l32r	a8, 42000240 <_stext+0x220> (40000dbc <wdt_hal_init>)
42001e4b:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt0_context);
42001e4e:	01ad      	mov.n	a10, a1
42001e50:	f89f81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001e53:	0008e0        	callx8	a8
    wdt_hal_config_stage(&wdt0_context, 0, timeout_ms * 1000 / MWDT_DEFAULT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); //1 second before reset
42001e56:	11c2b0        	slli	a12, a2, 5
42001e59:	c0cc20        	sub	a12, a12, a2
42001e5c:	a0cc20        	addx4	a12, a12, a2
42001e5f:	11ccd0        	slli	a12, a12, 3
42001e62:	f90081        	l32r	a8, 42000264 <_stext+0x244> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
42001e65:	a2cc80        	muluh	a12, a12, a8
42001e68:	3d0c      	movi.n	a13, 3
42001e6a:	41c5c0        	srli	a12, a12, 5
42001e6d:	0b0c      	movi.n	a11, 0
42001e6f:	20a110        	or	a10, a1, a1
42001e72:	f8bd81        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001e75:	0008e0        	callx8	a8
    wdt_hal_enable(&wdt0_context);
42001e78:	01ad      	mov.n	a10, a1
42001e7a:	f8f281        	l32r	a8, 42000244 <_stext+0x224> (40000df8 <wdt_hal_enable>)
42001e7d:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
42001e80:	01ad      	mov.n	a10, a1
42001e82:	f89481        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001e85:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt1_context);
42001e88:	07ad      	mov.n	a10, a7
42001e8a:	f89081        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001e8d:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
42001e90:	07ad      	mov.n	a10, a7
42001e92:	f88f81        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42001e95:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
42001e98:	07ad      	mov.n	a10, a7
42001e9a:	f88e81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001e9d:	0008e0        	callx8	a8
}
42001ea0:	f01d      	retw.n
	...

42001ea4 <esp_panic_handler>:
{
42001ea4:	006136        	entry	a1, 48
42001ea7:	207220        	or	a7, a2, a2
    esp_panic_handler_reconfigure_wdts(1000);
42001eaa:	e8a3a2        	movi	a10, 0x3e8
42001ead:	fff765        	call8	42001e24 <esp_panic_handler_reconfigure_wdts>
    if (g_panic_abort) {
42001eb0:	f8ef81        	l32r	a8, 4200026c <_stext+0x24c> (3fc949d0 <g_panic_abort>)
42001eb3:	000882        	l8ui	a8, a8, 0
42001eb6:	01e816        	beqz	a8, 42001ed8 <esp_panic_handler+0x34>
        info->description = NULL;
42001eb9:	00a082        	movi	a8, 0
42001ebc:	3289      	s32i.n	a8, a2, 12
        info->details = g_panic_abort_details ? print_abort_details : NULL;
42001ebe:	f8e781        	l32r	a8, 4200025c <_stext+0x23c> (3fc949cc <g_panic_abort_details>)
42001ec1:	0888      	l32i.n	a8, a8, 0
42001ec3:	588c      	beqz.n	a8, 42001ecc <esp_panic_handler+0x28>
42001ec5:	f8e881        	l32r	a8, 42000268 <_stext+0x248> (42001dac <print_abort_details>)
42001ec8:	000086        	j	42001ece <esp_panic_handler+0x2a>
42001ecb:	080c00        	lsx	f0, a12, a0
42001ece:	4789      	s32i.n	a8, a7, 16
        info->reason = NULL;
42001ed0:	080c      	movi.n	a8, 0
42001ed2:	2789      	s32i.n	a8, a7, 8
        info->exception = PANIC_EXCEPTION_ABORT;
42001ed4:	380c      	movi.n	a8, 3
42001ed6:	1789      	s32i.n	a8, a7, 4
    if (info->reason) {
42001ed8:	022782        	l32i	a8, a7, 8
42001edb:	01b816        	beqz	a8, 42001efa <esp_panic_handler+0x56>
        panic_print_str("Guru Meditation Error: Core ");
42001ede:	f8e4a1        	l32r	a10, 42000270 <_stext+0x250> (3c020844 <_flash_rodata_start+0x724>)
42001ee1:	ffeae5        	call8	42001d90 <panic_print_str>
        panic_print_dec(info->core);
42001ee4:	07a8      	l32i.n	a10, a7, 0
42001ee6:	fff025        	call8	42001de8 <panic_print_dec>
        panic_print_str(" panic'ed (");
42001ee9:	f8e2a1        	l32r	a10, 42000274 <_stext+0x254> (3c020864 <_flash_rodata_start+0x744>)
42001eec:	ffea25        	call8	42001d90 <panic_print_str>
        panic_print_str(info->reason);
42001eef:	27a8      	l32i.n	a10, a7, 8
42001ef1:	ffe9e5        	call8	42001d90 <panic_print_str>
        panic_print_str("). ");
42001ef4:	f8e1a1        	l32r	a10, 42000278 <_stext+0x258> (3c020870 <_flash_rodata_start+0x750>)
42001ef7:	ffe9a5        	call8	42001d90 <panic_print_str>
    if (info->description) {
42001efa:	37a8      	l32i.n	a10, a7, 12
42001efc:	1a8c      	beqz.n	a10, 42001f01 <esp_panic_handler+0x5d>
        panic_print_str(info->description);
42001efe:	ffe925        	call8	42001d90 <panic_print_str>
    panic_print_str("\r\n");
42001f01:	f8dea1        	l32r	a10, 4200027c <_stext+0x25c> (3c0208c4 <_flash_rodata_start+0x7a4>)
42001f04:	ffe8a5        	call8	42001d90 <panic_print_str>
    PANIC_INFO_DUMP(info, details);
42001f07:	4788      	l32i.n	a8, a7, 16
42001f09:	388c      	beqz.n	a8, 42001f10 <esp_panic_handler+0x6c>
42001f0b:	77a8      	l32i.n	a10, a7, 28
42001f0d:	0008e0        	callx8	a8
    panic_print_str("\r\n");
42001f10:	f8dba1        	l32r	a10, 4200027c <_stext+0x25c> (3c0208c4 <_flash_rodata_start+0x7a4>)
42001f13:	ffe7e5        	call8	42001d90 <panic_print_str>
    RER(reg, dcr);
42001f16:	f8da81        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
42001f19:	406880        	rer	a8, a8
    if (esp_cpu_dbgr_is_attached()) {
42001f1c:	486807        	bbci	a8, 0, 42001f68 <esp_panic_handler+0xc4>
        if (info->pseudo_excause) {
42001f1f:	200782        	l8ui	a8, a7, 32
42001f22:	388c      	beqz.n	a8, 42001f29 <esp_panic_handler+0x85>
            panic_reason_str = (char *)info->reason;
42001f24:	27a8      	l32i.n	a10, a7, 8
42001f26:	000306        	j	42001f36 <esp_panic_handler+0x92>
        } else if (g_panic_abort) {
42001f29:	f8d081        	l32r	a8, 4200026c <_stext+0x24c> (3fc949d0 <g_panic_abort>)
42001f2c:	000882        	l8ui	a8, a8, 0
42001f2f:	889c      	beqz.n	a8, 42001f4b <esp_panic_handler+0xa7>
            panic_reason_str = g_panic_abort_details;
42001f31:	f8ca81        	l32r	a8, 4200025c <_stext+0x23c> (3fc949cc <g_panic_abort_details>)
42001f34:	08a8      	l32i.n	a10, a8, 0
        if (panic_reason_str) {
42001f36:	011a16        	beqz	a10, 42001f4b <esp_panic_handler+0xa7>
            long args[] = {(long)panic_reason_str, strlen(panic_reason_str)};
42001f39:	01a9      	s32i.n	a10, a1, 0
42001f3b:	f8d881        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42001f3e:	0008e0        	callx8	a8
42001f41:	11a9      	s32i.n	a10, a1, 4
 *
 * @return  return value from the host
 */
static inline long semihosting_call_noerrno(long id, long *data)
{
    register long a2 asm ("a2") = id;
42001f43:	16a122        	movi	a2, 0x116
    register long a3 asm ("a3") = (long)data;
42001f46:	013d      	mov.n	a3, a1

    __asm__ __volatile__ (
42001f48:	0041e0        	break	1, 14
        panic_print_str("Setting breakpoint at 0x");
42001f4b:	f8cea1        	l32r	a10, 42000284 <_stext+0x264> (3c020874 <_flash_rodata_start+0x754>)
42001f4e:	ffe425        	call8	42001d90 <panic_print_str>
        panic_print_hex((uint32_t)info->addr);
42001f51:	67a8      	l32i.n	a10, a7, 24
42001f53:	ffe6a5        	call8	42001dbc <panic_print_hex>
        panic_print_str(" and returning...\r\n");
42001f56:	f8cca1        	l32r	a10, 42000288 <_stext+0x268> (3c020890 <_flash_rodata_start+0x770>)
42001f59:	ffe365        	call8	42001d90 <panic_print_str>
        disable_all_wdts();
42001f5c:	ffdd65        	call8	42001d34 <disable_all_wdts>
        esp_cpu_set_breakpoint(0, info->addr); // use breakpoint 0
42001f5f:	67b8      	l32i.n	a11, a7, 24
42001f61:	0a0c      	movi.n	a10, 0
42001f63:	13c625        	call8	42015bc4 <esp_cpu_set_breakpoint>
}
42001f66:	f01d      	retw.n
    if (!wdt_hal_is_enabled(&rtc_wdt_ctx)) {
42001f68:	f8c9a1        	l32r	a10, 4200028c <_stext+0x26c> (3fc92008 <rtc_wdt_ctx>)
42001f6b:	f8cd81        	l32r	a8, 420002a0 <_stext+0x280> (40000e34 <wdt_hal_is_enabled>)
42001f6e:	0008e0        	callx8	a8
42001f71:	054a56        	bnez	a10, 42001fc9 <esp_panic_handler+0x125>
        wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
42001f74:	f8c621        	l32r	a2, 4200028c <_stext+0x26c> (3fc92008 <rtc_wdt_ctx>)
42001f77:	0d0c      	movi.n	a13, 0
42001f79:	0c0c      	movi.n	a12, 0
42001f7b:	0b0c      	movi.n	a11, 0
42001f7d:	02ad      	mov.n	a10, a2
42001f7f:	f8b081        	l32r	a8, 42000240 <_stext+0x220> (40000dbc <wdt_hal_init>)
42001f82:	0008e0        	callx8	a8
        uint32_t stage_timeout_ticks = (uint32_t)(7000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001f85:	f87581        	l32r	a8, 4200015c <_stext+0x13c> (40378a30 <rtc_clk_slow_freq_get_hz>)
42001f88:	0008e0        	callx8	a8
42001f8b:	0a8d      	mov.n	a8, a10
42001f8d:	f8c0a1        	l32r	a10, 42000290 <_stext+0x270> (1b58 <UserFrameTotalSize+0x1a58>)
42001f90:	a2b8a0        	muluh	a11, a8, a10
42001f93:	e8a3c2        	movi	a12, 0x3e8
42001f96:	0d0c      	movi.n	a13, 0
42001f98:	82a8a0        	mull	a10, a8, a10
42001f9b:	f87181        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
42001f9e:	0008e0        	callx8	a8
42001fa1:	0a3d      	mov.n	a3, a10
        wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001fa3:	02ad      	mov.n	a10, a2
42001fa5:	f84981        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001fa8:	0008e0        	callx8	a8
        wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_SYSTEM);
42001fab:	3d0c      	movi.n	a13, 3
42001fad:	03cd      	mov.n	a12, a3
42001faf:	0b0c      	movi.n	a11, 0
42001fb1:	02ad      	mov.n	a10, a2
42001fb3:	f86d81        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001fb6:	0008e0        	callx8	a8
        wdt_hal_enable(&rtc_wdt_ctx);
42001fb9:	02ad      	mov.n	a10, a2
42001fbb:	f8a281        	l32r	a8, 42000244 <_stext+0x224> (40000df8 <wdt_hal_enable>)
42001fbe:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001fc1:	02ad      	mov.n	a10, a2
42001fc3:	f84481        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001fc6:	0008e0        	callx8	a8
    esp_panic_handler_reconfigure_wdts(1000); // Restart WDT again
42001fc9:	e8a3a2        	movi	a10, 0x3e8
42001fcc:	ffe565        	call8	42001e24 <esp_panic_handler_reconfigure_wdts>
    PANIC_INFO_DUMP(info, state);
42001fcf:	5788      	l32i.n	a8, a7, 20
42001fd1:	488c      	beqz.n	a8, 42001fd9 <esp_panic_handler+0x135>
42001fd3:	0727a2        	l32i	a10, a7, 28
42001fd6:	0008e0        	callx8	a8
    panic_print_str("\r\n");
42001fd9:	f8a821        	l32r	a2, 4200027c <_stext+0x25c> (3c0208c4 <_flash_rodata_start+0x7a4>)
42001fdc:	20a220        	or	a10, a2, a2
42001fdf:	ffdb25        	call8	42001d90 <panic_print_str>
    g_panic_abort = false;
42001fe2:	f8a281        	l32r	a8, 4200026c <_stext+0x24c> (3fc949d0 <g_panic_abort>)
42001fe5:	00a092        	movi	a9, 0
42001fe8:	004892        	s8i	a9, a8, 0
    panic_print_str("\r\nELF file SHA256: ");
42001feb:	f8aaa1        	l32r	a10, 42000294 <_stext+0x274> (3c0208a4 <_flash_rodata_start+0x784>)
42001fee:	ffda25        	call8	42001d90 <panic_print_str>
    panic_print_str(esp_app_get_elf_sha256_str());
42001ff1:	f80ba1        	l32r	a10, 42000020 <_stext> (3fc94980 <app_elf_sha256_str>)
42001ff4:	ffd9a5        	call8	42001d90 <panic_print_str>
    panic_print_str("\r\n");
42001ff7:	02ad      	mov.n	a10, a2
42001ff9:	ffd965        	call8	42001d90 <panic_print_str>
    panic_print_str("\r\n");
42001ffc:	02ad      	mov.n	a10, a2
42001ffe:	ffd925        	call8	42001d90 <panic_print_str>
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42002001:	f8a221        	l32r	a2, 4200028c <_stext+0x26c> (3fc92008 <rtc_wdt_ctx>)
42002004:	02ad      	mov.n	a10, a2
42002006:	f83181        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42002009:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
4200200c:	02ad      	mov.n	a10, a2
4200200e:	f83081        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42002011:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42002014:	02ad      	mov.n	a10, a2
42002016:	f82f81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42002019:	0008e0        	callx8	a8
    if (esp_reset_reason_get_hint() == ESP_RST_UNKNOWN) {
4200201c:	ff95a5        	call8	42001978 <esp_reset_reason_get_hint>
4200201f:	9aec      	bnez.n	a10, 4200204c <esp_panic_handler+0x1a8>
        switch (info->exception) {
42002021:	1788      	l32i.n	a8, a7, 4
42002023:	051826        	beqi	a8, 1, 4200202c <esp_panic_handler+0x188>
42002026:	0e2826        	beqi	a8, 2, 42002038 <esp_panic_handler+0x194>
42002029:	0005c6        	j	42002044 <esp_panic_handler+0x1a0>
            esp_reset_reason_set_hint(ESP_RST_INT_WDT);
4200202c:	5a0c      	movi.n	a10, 5
4200202e:	f89d81        	l32r	a8, 420002a4 <_stext+0x284> (40375668 <esp_reset_reason_set_hint>)
42002031:	0008e0        	callx8	a8
            break;
42002034:	000506        	j	4200204c <esp_panic_handler+0x1a8>
42002037:	6a0c00        	maddn.s	f0, f12, f0
            esp_reset_reason_set_hint(ESP_RST_TASK_WDT);
4200203a:	f89a81        	l32r	a8, 420002a4 <_stext+0x284> (40375668 <esp_reset_reason_set_hint>)
4200203d:	0008e0        	callx8	a8
            break;
42002040:	000206        	j	4200204c <esp_panic_handler+0x1a8>
42002043:	4a0c00        	madd.s	f0, f12, f0
            esp_reset_reason_set_hint(ESP_RST_PANIC);
42002046:	f89781        	l32r	a8, 420002a4 <_stext+0x284> (40375668 <esp_reset_reason_set_hint>)
42002049:	0008e0        	callx8	a8
    panic_print_str("Rebooting...\r\n");
4200204c:	f893a1        	l32r	a10, 42000298 <_stext+0x278> (3c0208b8 <_flash_rodata_start+0x798>)
4200204f:	ffd425        	call8	42001d90 <panic_print_str>
    panic_restart();
42002052:	003165        	call8	42002368 <panic_restart>
42002055:	000000        	ill

42002058 <do_global_ctors>:
{
42002058:	004136        	entry	a1, 32
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
4200205b:	f89371        	l32r	a7, 420002a8 <_stext+0x288> (3c02a470 <__XT_EXCEPTION_DESCS_+0x18>)
4200205e:	0001c6        	j	42002069 <do_global_ctors+0x11>
        (*p)();
42002061:	0788      	l32i.n	a8, a7, 0
42002063:	0008e0        	callx8	a8
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
42002066:	fcc772        	addi	a7, a7, -4
42002069:	f89081        	l32r	a8, 420002ac <_stext+0x28c> (3c02a458 <__XT_EXCEPTION_DESCS_>)
4200206c:	f1b787        	bgeu	a7, a8, 42002061 <do_global_ctors+0x9>
}
4200206f:	f01d      	retw.n
42002071:	000000        	ill

42002074 <do_system_init_fn>:
{
42002074:	004136        	entry	a1, 32
    asm volatile (
42002077:	03eb60        	rsr.prid	a6
4200207a:	046d60        	extui	a6, a6, 13, 1
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
4200207d:	f88c71        	l32r	a7, 420002b0 <_stext+0x290> (3c02a49c <esp_system_init_fn_init_efuse_check>)
42002080:	000f06        	j	420020c0 <do_system_init_fn+0x4c>
42002083:	178200        	lsi	f0, a2, 92
        if (p->stage == stage_num && (p->cores & BIT(core_id)) != 0) {
42002086:	982703        	lsi	f0, a7, 0x260
42002089:	178233        	lsip	f3, a2, 92
4200208c:	586702        	s32i	a0, a7, 0x160
4200208f:	a82d      	lsi	f2, a8, 32
            esp_err_t err = (*(p->fn))();
42002091:	0ae007        	bbsi	a0, 0, 4200209f <do_system_init_fn+0x2b>
42002094:	0a5d00        	add.s	f5, f13, f0
            if (err != ESP_OK) {
42002097:	3aac      	beqz.n	a10, 420020be <do_system_init_fn+0x4a>
42002099:	f7e481        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200209c:	0888      	l32i.n	a8, a8, 0
                ESP_EARLY_LOGE(TAG, "init function %p has failed (0x%x), aborting", p->fn, err);
4200209e:	689c      	beqz.n	a8, 420020b8 <do_system_init_fn+0x44>
420020a0:	f7f081        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420020a3:	0008e0        	callx8	a8
420020a6:	05ed      	mov.n	a14, a5
420020a8:	07d8      	l32i.n	a13, a7, 0
420020aa:	f882c1        	l32r	a12, 420002b4 <_stext+0x294> (3c0202e4 <_flash_rodata_start+0x1c4>)
420020ad:	0abd      	mov.n	a11, a10
420020af:	f882a1        	l32r	a10, 420002b8 <_stext+0x298> (3c0208c8 <_flash_rodata_start+0x7a8>)
420020b2:	f7ec81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420020b5:	0008e0        	callx8	a8
                abort();
420020b8:	f80f81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420020bb:	0008e0        	callx8	a8
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
420020be:	778b      	addi.n	a7, a7, 8
420020c0:	f87f81        	l32r	a8, 420002bc <_stext+0x29c> (3c02a53c <_esp_system_init_fn_array_end>)
420020c3:	bd3787        	bltu	a7, a8, 42002084 <do_system_init_fn+0x10>
    s_system_inited[core_id] = true;
420020c6:	f87e81        	l32r	a8, 420002c0 <_stext+0x2a0> (3fc949d4 <s_system_inited>)
420020c9:	886a      	add.n	a8, a8, a6
420020cb:	190c      	movi.n	a9, 1
420020cd:	0020c0        	memw
420020d0:	004892        	s8i	a9, a8, 0
}
420020d3:	f01d      	retw.n
420020d5:	000000        	ill

420020d8 <do_core_init>:
}
#endif

static void do_core_init(void)
{
420020d8:	004136        	entry	a1, 32
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_CORE);
420020db:	0a0c      	movi.n	a10, 0
420020dd:	fff965        	call8	42002074 <do_system_init_fn>
}
420020e0:	f01d      	retw.n
	...

420020e4 <do_secondary_init>:

static void do_secondary_init(void)
{
420020e4:	006136        	entry	a1, 48
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // The port layer transferred control to this function with other cores 'paused',
    // resume execution so that cores might execute component initialization functions.
    startup_resume_other_cores();
420020e7:	ff4da5        	call8	420015c0 <startup_resume_other_cores>
#endif

    // Execute initialization functions esp_system_init_fn_t assigned to the main core. While
    // this is happening, all other cores are executing the initialization functions
    // assigned to them since they have been resumed already.
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_SECONDARY);
420020ea:	01a0a2        	movi	a10, 1
420020ed:	fff865        	call8	42002074 <do_system_init_fn>

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // Wait for all cores to finish secondary init.
    volatile bool system_inited = false;
420020f0:	00a082        	movi	a8, 0
420020f3:	0020c0        	memw
420020f6:	004182        	s8i	a8, a1, 0

    while (!system_inited) {
420020f9:	000dc6        	j	42002134 <do_secondary_init+0x50>
        system_inited = true;
420020fc:	180c      	movi.n	a8, 1
420020fe:	0020c0        	memw
42002101:	004182        	s8i	a8, a1, 0
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002104:	090c      	movi.n	a9, 0
42002106:	000786        	j	42002128 <do_secondary_init+0x44>
            system_inited &= s_system_inited[i];
42002109:	f86d81        	l32r	a8, 420002c0 <_stext+0x2a0> (3fc949d4 <s_system_inited>)
4200210c:	889a      	add.n	a8, a8, a9
4200210e:	0020c0        	memw
42002111:	0008a2        	l8ui	a10, a8, 0
42002114:	0020c0        	memw
42002117:	000182        	l8ui	a8, a1, 0
4200211a:	748080        	extui	a8, a8, 0, 8
4200211d:	1088a0        	and	a8, a8, a10
42002120:	0020c0        	memw
42002123:	004182        	s8i	a8, a1, 0
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002126:	991b      	addi.n	a9, a9, 1
42002128:	dd29a6        	blti	a9, 2, 42002109 <do_secondary_init+0x25>
        }
        esp_rom_delay_us(100);
4200212b:	64a0a2        	movi	a10, 100
4200212e:	f7f481        	l32r	a8, 42000100 <_stext+0xe0> (40000600 <esp_rom_delay_us>)
42002131:	0008e0        	callx8	a8
    while (!system_inited) {
42002134:	0020c0        	memw
42002137:	000182        	l8ui	a8, a1, 0
4200213a:	748080        	extui	a8, a8, 0, 8
4200213d:	fbb816        	beqz	a8, 420020fc <do_secondary_init+0x18>
    }
#endif
}
42002140:	f01d      	retw.n
	...

42002144 <start_cpu0>:

static void start_cpu0_default(void)
{
42002144:	004136        	entry	a1, 32
    // Initialize core components and services.
    do_core_init();
42002147:	fff925        	call8	420020d8 <do_core_init>

    // Execute constructors.
    do_global_ctors();
4200214a:	fff0e5        	call8	42002058 <do_global_ctors>

    // Execute init functions of other components; blocks
    // until all cores finish (when !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE).
    do_secondary_init();
4200214d:	fff965        	call8	420020e4 <do_secondary_init>

#if SOC_CPU_CORES_NUM > 1 && !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_system_full_inited = true;
42002150:	f85d81        	l32r	a8, 420002c4 <_stext+0x2a4> (3fc949d1 <s_system_full_inited>)
42002153:	190c      	movi.n	a9, 1
42002155:	0020c0        	memw
42002158:	004892        	s8i	a9, a8, 0
#endif

    esp_startup_start_app();
4200215b:	14a725        	call8	42016bcc <esp_startup_start_app>

    ESP_INFINITE_LOOP();
4200215e:	ffff06        	j	4200215e <start_cpu0+0x1a>
42002161:	000000        	ill

42002164 <frame_to_panic_info>:
{
42002164:	004136        	entry	a1, 32
42002167:	03eb80        	rsr.prid	a8
4200216a:	048d80        	extui	a8, a8, 13, 1
    info->core = esp_cpu_get_core_id();
4200216d:	0389      	s32i.n	a8, a3, 0
    info->exception = PANIC_EXCEPTION_FAULT;
4200216f:	480c      	movi.n	a8, 4
42002171:	1389      	s32i.n	a8, a3, 4
    info->details = NULL;
42002173:	080c      	movi.n	a8, 0
42002175:	4389      	s32i.n	a8, a3, 16
    info->reason = "Unknown";
42002177:	f85481        	l32r	a8, 420002c8 <_stext+0x2a8> (3c020904 <_flash_rodata_start+0x7e4>)
4200217a:	2389      	s32i.n	a8, a3, 8
    info->pseudo_excause = panic_soc_check_pseudo_cause(frame, info) | pseudo_excause;
4200217c:	03bd      	mov.n	a11, a3
4200217e:	02ad      	mov.n	a10, a2
42002180:	136a25        	call8	42015824 <panic_soc_check_pseudo_cause>
42002183:	208a40        	or	a8, a10, a4
42002186:	748080        	extui	a8, a8, 0, 8
42002189:	204382        	s8i	a8, a3, 32
    if (info->pseudo_excause) {
4200218c:	a88c      	beqz.n	a8, 4200219a <frame_to_panic_info+0x36>
        panic_soc_fill_info(frame, info);
4200218e:	03bd      	mov.n	a11, a3
42002190:	02ad      	mov.n	a10, a2
42002192:	0042a5        	call8	420025bc <panic_soc_fill_info>
42002195:	000286        	j	420021a3 <frame_to_panic_info+0x3f>
42002198:	300000        	xor	a0, a0, a0
        panic_arch_fill_info(frame, info);
4200219b:	2020b3        	lsi	f11, a0, 128
4200219e:	6520a2        	l32i	a10, a0, 0x194
420021a1:	3e          	.byte	0x3e
420021a2:	4a8100        	madd.s	f8, f1, f0
    info->state = print_state;
420021a5:	82f8      	l32i.n	a15, a2, 32
420021a7:	290563        	lsi	f6, a5, 164
    info->frame = frame;
420021aa:	f01d73        	lsi	f7, a13, 0x3c0
420021ad:	000000        	ill

420021b0 <panic_handler>:
{
420021b0:	00a136        	entry	a1, 80
    panic_info_t info = { 0 };
420021b3:	4c2c      	movi.n	a12, 36
420021b5:	0b0c      	movi.n	a11, 0
420021b7:	01ad      	mov.n	a10, a1
420021b9:	f85181        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420021bc:	0008e0        	callx8	a8
420021bf:	03eb60        	rsr.prid	a6
420021c2:	046d60        	extui	a6, a6, 13, 1
420021c5:	067d      	mov.n	a7, a6
    g_exc_frames[core_id] = frame;
420021c7:	f84281        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc949e0 <g_exc_frames>)
420021ca:	a08680        	addx4	a8, a6, a8
420021cd:	006822        	s32i	a2, a8, 0
    if (pseudo_excause) {
420021d0:	048316        	beqz	a3, 4200221c <panic_handler+0x6c>
        if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU0 && core_id == 1) {
420021d3:	02ad      	mov.n	a10, a2
420021d5:	1365e5        	call8	42015834 <panic_get_cause>
420021d8:	055a66        	bnei	a10, 5, 420021e1 <panic_handler+0x31>
420021db:	021666        	bnei	a6, 1, 420021e1 <panic_handler+0x31>
420021de:	ffff06        	j	420021de <panic_handler+0x2e>
        } else if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU1 && core_id == 0) {
420021e1:	02ad      	mov.n	a10, a2
420021e3:	136525        	call8	42015834 <panic_get_cause>
420021e6:	076a66        	bnei	a10, 6, 420021f1 <panic_handler+0x41>
420021e9:	47cc      	bnez.n	a7, 420021f1 <panic_handler+0x41>
420021eb:	ffff06        	j	420021eb <panic_handler+0x3b>
420021ee:	000000        	ill
        } else if (panic_get_cause(frame) == PANIC_RSN_CACHEERR) {
420021f1:	20a220        	or	a10, a2, a2
420021f4:	1363e5        	call8	42015834 <panic_get_cause>
420021f7:	217a66        	bnei	a10, 7, 4200221c <panic_handler+0x6c>
            if (esp_cache_err_get_cpuid() == -1) {
420021fa:	ff9c25        	call8	42001bbc <esp_cache_err_get_cpuid>
420021fd:	070a66        	bnei	a10, -1, 42002208 <panic_handler+0x58>
                if (core_id != 0) {
42002200:	018716        	beqz	a7, 4200221c <panic_handler+0x6c>
42002203:	ffff06        	j	42002203 <panic_handler+0x53>
42002206:	250000        	extui	a0, a0, 16, 3
            } else if (core_id != esp_cache_err_get_cpuid()) {
42002209:	ff9b      	addi.n	a15, a15, 9
4200220b:	0d1a77        	beq	a10, a7, 4200221c <panic_handler+0x6c>
                g_exc_frames[core_id] = NULL; // Only print the backtrace for the offending core
4200220e:	f83081        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc949e0 <g_exc_frames>)
42002211:	a08680        	addx4	a8, a6, a8
42002214:	090c      	movi.n	a9, 0
42002216:	0899      	s32i.n	a9, a8, 0
                busy_wait();
42002218:	ffff06        	j	42002218 <panic_handler+0x68>
4200221b:	a3a200        	movltz	a10, a2, a0
    esp_panic_handler_reconfigure_wdts(1000);
4200221e:	65e8      	l32i.n	a14, a5, 24
42002220:	0cffc0        	lsi	f12, a15, 48
    esp_rom_delay_us(1);
42002223:	811a      	add.n	a8, a1, a1
42002225:	e0f7b7        	bbsi	a7, 27, 42002209 <panic_handler+0x59>
42002228:	0008      	l32i.n	a0, a0, 0
    for (uint32_t i = 0; i < SOC_CPU_CORES_NUM; i++) {
4200222a:	070c      	movi.n	a7, 0
4200222c:	000406        	j	42002240 <panic_handler+0x90>
4200222f:	670000        	lsi	f0, a0, 0x19c
        if (i != core_id) {
42002232:	700817        	bnone	a8, a1, 420022a6 <panic_handler+0xf6>
            esp_cpu_stall(i);
42002235:	8120a7        	blt	a0, a10, 420021ba <panic_handler+0xa>
42002238:	e0f833        	lsi	f3, a8, 0x380
4200223b:	0008      	l32i.n	a0, a0, 0
    for (uint32_t i = 0; i < SOC_CPU_CORES_NUM; i++) {
4200223d:	01c772        	addi	a7, a7, 1
42002240:	ed27b6        	bltui	a7, 2, 42002231 <panic_handler+0x81>
    esp_ipc_isr_stall_abort();
42002243:	f83181        	l32r	a8, 42000308 <_stext+0x2e8> (403759e8 <esp_ipc_isr_stall_abort>)
42002246:	0008e0        	callx8	a8
    RER(reg, dcr);
42002249:	f80d81        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
4200224c:	406880        	rer	a8, a8
    if (esp_cpu_dbgr_is_attached()) {
4200224f:	02e807        	bbsi	a8, 0, 42002255 <panic_handler+0xa5>
42002252:	002486        	j	420022e8 <panic_handler+0x138>
        if (!(esp_ptr_executable(esp_cpu_pc_to_addr(panic_get_address(frame))) && (panic_get_address(frame) & 0xC0000000U))) {
42002255:	20a220        	or	a10, a2, a2
42002258:	135d25        	call8	4201582c <panic_get_address>
    return (void *)((pc & 0x3fffffffU) | 0x40000000U);
4200225b:	11aae0        	slli	a10, a10, 2
4200225e:	41a2a0        	srli	a10, a10, 2
42002261:	f7b381        	l32r	a8, 42000130 <_stext+0x110> (40000000 <_heap_end>)
42002264:	20aa80        	or	a10, a10, a8
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
42002267:	f81c91        	l32r	a9, 420002d8 <_stext+0x2b8> (be000000 <_rtc_reserved_end+0x5df00000>)
4200226a:	809a90        	add	a9, a10, a9
4200226d:	f81b81        	l32r	a8, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
42002270:	628890        	lsi	f9, a8, 0x188
42002273:	880b      	addi.n	a8, a8, -1
42002275:	608080        	neg	a8, a8
42002278:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
4200227b:	f819b1        	l32r	a11, 420002e0 <_stext+0x2c0> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
4200227e:	baba      	add.n	a11, a10, a11
42002280:	f81991        	l32r	a9, 420002e4 <_stext+0x2c4> (6ffff <UserFrameTotalSize+0x6feff>)
42002283:	6299b0        	lsi	f11, a9, 0x188
42002286:	990b      	addi.n	a9, a9, -1
42002288:	609090        	neg	a9, a9
4200228b:	749090        	extui	a9, a9, 0, 8
4200228e:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
42002291:	48dc      	bnez.n	a8, 420022a9 <panic_handler+0xf9>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
42002293:	f81581        	l32r	a8, 420002e8 <_stext+0x2c8> (c0000000 <_rtc_reserved_end+0x5ff00000>)
42002296:	8a8a      	add.n	a8, a10, a8
42002298:	f81591        	l32r	a9, 420002ec <_stext+0x2cc> (5ffff <UserFrameTotalSize+0x5feff>)
4200229b:	0ab987        	bgeu	a9, a8, 420022a9 <panic_handler+0xf9>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
4200229e:	f81481        	l32r	a8, 420002f0 <_stext+0x2d0> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
420022a1:	aa8a      	add.n	a10, a10, a8
420022a3:	f81481        	l32r	a8, 420002f4 <_stext+0x2d4> (1fff <UserFrameTotalSize+0x1eff>)
420022a6:	0a38a7        	bltu	a8, a10, 420022b4 <panic_handler+0x104>
420022a9:	02ad      	mov.n	a10, a2
420022ab:	135825        	call8	4201582c <panic_get_address>
420022ae:	f80981        	l32r	a8, 420002d4 <_stext+0x2b4> (3fffffff <ets_rom_layout_p+0xe0003>)
420022b1:	0738a7        	bltu	a8, a10, 420022bc <panic_handler+0x10c>
            panic_set_address(frame, (uint32_t)&_invalid_pc_placeholder);
420022b4:	f811b1        	l32r	a11, 420002f8 <_stext+0x2d8> (40374400 <_invalid_pc_placeholder>)
420022b7:	02ad      	mov.n	a10, a2
420022b9:	135825        	call8	4201583c <panic_set_address>
        if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU0
420022bc:	02ad      	mov.n	a10, a2
420022be:	135765        	call8	42015834 <panic_get_cause>
420022c1:	075a26        	beqi	a10, 5, 420022cc <panic_handler+0x11c>
                || panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU1
420022c4:	02ad      	mov.n	a10, a2
420022c6:	1356e5        	call8	42015834 <panic_get_cause>
420022c9:	1b6a66        	bnei	a10, 6, 420022e8 <panic_handler+0x138>
            wdt_hal_write_protect_disable(&wdt0_context);
420022cc:	f80c71        	l32r	a7, 420002fc <_stext+0x2dc> (3fc92010 <wdt0_context>)
420022cf:	20a770        	or	a10, a7, a7
420022d2:	f77e81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
420022d5:	0008e0        	callx8	a8
            wdt_hal_handle_intr(&wdt0_context);
420022d8:	07ad      	mov.n	a10, a7
420022da:	f80c81        	l32r	a8, 4200030c <_stext+0x2ec> (40000e10 <wdt_hal_handle_intr>)
420022dd:	0008e0        	callx8	a8
            wdt_hal_write_protect_enable(&wdt0_context);
420022e0:	07ad      	mov.n	a10, a7
420022e2:	f77c81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
420022e5:	0008e0        	callx8	a8
    frame_to_panic_info(frame, &info, pseudo_excause);
420022e8:	20c330        	or	a12, a3, a3
420022eb:	20b110        	or	a11, a1, a1
420022ee:	02ad      	mov.n	a10, a2
420022f0:	ffe725        	call8	42002164 <frame_to_panic_info>
    esp_panic_handler(&info);
420022f3:	01ad      	mov.n	a10, a1
420022f5:	ffbae5        	call8	42001ea4 <esp_panic_handler>
}
420022f8:	f01d      	retw.n
	...

420022fc <print_state_for_core>:
{
420022fc:	004136        	entry	a1, 32
    if (!g_panic_abort) {
420022ff:	f7db81        	l32r	a8, 4200026c <_stext+0x24c> (3fc949d0 <g_panic_abort>)
42002302:	000882        	l8ui	a8, a8, 0
42002305:	00d856        	bnez	a8, 42002316 <print_state_for_core+0x1a>
        panic_print_registers(f, core);
42002308:	20b330        	or	a11, a3, a3
4200230b:	02ad      	mov.n	a10, a2
4200230d:	001a25        	call8	420024b0 <panic_print_registers>
        panic_print_str("\r\n");
42002310:	f800a1        	l32r	a10, 42000310 <_stext+0x2f0> (3c0208c4 <_flash_rodata_start+0x7a4>)
42002313:	ffa7e5        	call8	42001d90 <panic_print_str>
    panic_print_backtrace(f, core);
42002316:	20b330        	or	a11, a3, a3
42002319:	20a220        	or	a10, a2, a2
4200231c:	003025        	call8	42002620 <panic_print_backtrace>
}
4200231f:	000090        	retw
	...

42002324 <print_state>:
{
42002324:	004136        	entry	a1, 32
42002327:	02ad      	mov.n	a10, a2
    int err_core = f == g_exc_frames[0] ? 0 : 1;
42002329:	f7e981        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc949e0 <g_exc_frames>)
4200232c:	0888      	l32i.n	a8, a8, 0
4200232e:	c08820        	sub	a8, a8, a2
42002331:	120c      	movi.n	a2, 1
42002333:	832880        	moveqz	a2, a8, a8
    print_state_for_core(f, err_core);
42002336:	02bd      	mov.n	a11, a2
42002338:	fffc25        	call8	420022fc <print_state_for_core>
    panic_print_str("\r\n");
4200233b:	f7f5a1        	l32r	a10, 42000310 <_stext+0x2f0> (3c0208c4 <_flash_rodata_start+0x7a4>)
4200233e:	ffa525        	call8	42001d90 <panic_print_str>
    for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002341:	070c      	movi.n	a7, 0
42002343:	000706        	j	42002363 <print_state+0x3f>
        if (err_core != i && g_exc_frames[i] != NULL) {
42002346:	171727        	beq	a7, a2, 42002361 <print_state+0x3d>
42002349:	f7e181        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc949e0 <g_exc_frames>)
4200234c:	a08780        	addx4	a8, a7, a8
4200234f:	0028a2        	l32i	a10, a8, 0
42002352:	00ba16        	beqz	a10, 42002361 <print_state+0x3d>
            print_state_for_core(g_exc_frames[i], i);
42002355:	20b770        	or	a11, a7, a7
42002358:	fffa25        	call8	420022fc <print_state_for_core>
            panic_print_str("\r\n");
4200235b:	f7eda1        	l32r	a10, 42000310 <_stext+0x2f0> (3c0208c4 <_flash_rodata_start+0x7a4>)
4200235e:	ffa325        	call8	42001d90 <panic_print_str>
    for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002361:	771b      	addi.n	a7, a7, 1
42002363:	df27a6        	blti	a7, 2, 42002346 <print_state+0x22>
}
42002366:	f01d      	retw.n

42002368 <panic_restart>:

void __attribute__((noreturn)) panic_restart(void)
{
42002368:	004136        	entry	a1, 32
    // On the ESP32, cache error status can only be cleared by system reset
    if (esp_cache_err_get_cpuid() != -1) {
        esp_restart_noos_dig();
    }
#endif
    esp_restart_noos();
4200236b:	f74d81        	l32r	a8, 420000a0 <_stext+0x80> (40375760 <esp_restart_noos>)
4200236e:	0008e0        	callx8	a8
42002371:	000000        	ill

42002374 <esp_ipc_isr_init>:
{
42002374:	004136        	entry	a1, 32
    asm volatile (
42002377:	03eb70        	rsr.prid	a7
4200237a:	047d70        	extui	a7, a7, 13, 1
    esp_ipc_isr_port_init(cpuid);
4200237d:	20a770        	or	a10, a7, a7
42002380:	000125        	call8	42002394 <esp_ipc_isr_port_init>
    if (cpuid != 0) {
42002383:	00a716        	beqz	a7, 42002391 <esp_ipc_isr_init+0x1d>
        s_stall_state = STALL_STATE_RUNNING;
42002386:	f7e381        	l32r	a8, 42000314 <_stext+0x2f4> (3fc949e8 <s_stall_state>)
42002389:	01a092        	movi	a9, 1
4200238c:	0020c0        	memw
4200238f:	0899      	s32i.n	a9, a8, 0
}
42002391:	f01d      	retw.n
	...

42002394 <esp_ipc_isr_port_init>:
#include "esp_intr_alloc.h"
#include "esp_attr.h"
#include "sdkconfig.h"

void esp_ipc_isr_port_init(const int cpuid)
{
42002394:	004136        	entry	a1, 32
    uint32_t intr_source = ETS_FROM_CPU_INTR2_SOURCE + cpuid; // ETS_FROM_CPU_INTR2_SOURCE and ETS_FROM_CPU_INTR3_SOURCE
42002397:	51c272        	addi	a7, a2, 81
    ESP_INTR_DISABLE(ETS_IPC_ISR_INUM);
4200239a:	ca1c      	movi.n	a10, 28
4200239c:	f79a81        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
4200239f:	0008e0        	callx8	a8
    esp_rom_route_intr_matrix(cpuid, intr_source, ETS_IPC_ISR_INUM);
420023a2:	cc1c      	movi.n	a12, 28
420023a4:	07bd      	mov.n	a11, a7
420023a6:	02ad      	mov.n	a10, a2
420023a8:	f74c81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420023ab:	0008e0        	callx8	a8
    ESP_INTR_ENABLE(ETS_IPC_ISR_INUM);
420023ae:	ca1c      	movi.n	a10, 28
420023b0:	f79681        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
420023b3:	0008e0        	callx8	a8
}
420023b6:	f01d      	retw.n

420023b8 <print_debug_exception_details>:
    panic_print_str(" ");
    panic_print_hex(*(pepc + 2));
}

static void print_debug_exception_details(const void *f)
{
420023b8:	004136        	entry	a1, 32
    int debug_rsn;
    asm("rsr.debugcause %0":"=r"(debug_rsn));
420023bb:	03e970        	rsr.debugcause	a7
    panic_print_str("Debug exception reason: ");
420023be:	f7d6a1        	l32r	a10, 42000318 <_stext+0x2f8> (3c02090c <_flash_rodata_start+0x7ec>)
420023c1:	ff9ce5        	call8	42001d90 <panic_print_str>
    if (debug_rsn & XCHAL_DEBUGCAUSE_ICOUNT_MASK) {
420023c4:	056707        	bbci	a7, 0, 420023cd <print_debug_exception_details+0x15>
        panic_print_str("SingleStep ");
420023c7:	f7d5a1        	l32r	a10, 4200031c <_stext+0x2fc> (3c020928 <_flash_rodata_start+0x808>)
420023ca:	ff9c65        	call8	42001d90 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_IBREAK_MASK) {
420023cd:	056717        	bbci	a7, 1, 420023d6 <print_debug_exception_details+0x1e>
        panic_print_str("HwBreakpoint ");
420023d0:	f7d4a1        	l32r	a10, 42000320 <_stext+0x300> (3c020934 <_flash_rodata_start+0x814>)
420023d3:	ff9be5        	call8	42001d90 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DBREAK_MASK) {
420023d6:	116727        	bbci	a7, 2, 420023eb <print_debug_exception_details+0x33>
        //Unlike what the ISA manual says, this core seemingly distinguishes from a DBREAK
        //reason caused by watchdog 0 and one caused by watchdog 1 by setting bit 8 of the
        //debugcause if the cause is watchpoint 1 and clearing it if it's watchpoint 0.
        if (debug_rsn & (1 << 8)) {
420023d9:	086787        	bbci	a7, 8, 420023e5 <print_debug_exception_details+0x2d>
            const char *name = pcTaskGetName(xTaskGetCurrentTaskHandleForCore(core));
            panic_print_str("Stack canary watchpoint triggered (");
            panic_print_str(name);
            panic_print_str(") ");
#else
            panic_print_str("Watchpoint 1 triggered ");
420023dc:	f7d2a1        	l32r	a10, 42000324 <_stext+0x304> (3c020944 <_flash_rodata_start+0x824>)
420023df:	ff9b25        	call8	42001d90 <panic_print_str>
420023e2:	000146        	j	420023eb <print_debug_exception_details+0x33>
#endif
        } else {
            panic_print_str("Watchpoint 0 triggered ");
420023e5:	f7d0a1        	l32r	a10, 42000328 <_stext+0x308> (3c02095c <_flash_rodata_start+0x83c>)
420023e8:	ff9a65        	call8	42001d90 <panic_print_str>
        }
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAK_MASK) {
420023eb:	056737        	bbci	a7, 3, 420023f4 <print_debug_exception_details+0x3c>
        panic_print_str("BREAK instr ");
420023ee:	f7cfa1        	l32r	a10, 4200032c <_stext+0x30c> (3c020974 <_flash_rodata_start+0x854>)
420023f1:	ff99e5        	call8	42001d90 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAKN_MASK) {
420023f4:	056747        	bbci	a7, 4, 420023fd <print_debug_exception_details+0x45>
        panic_print_str("BREAKN instr ");
420023f7:	f7cea1        	l32r	a10, 42000330 <_stext+0x310> (3c020984 <_flash_rodata_start+0x864>)
420023fa:	ff9965        	call8	42001d90 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DEBUGINT_MASK) {
420023fd:	056757        	bbci	a7, 5, 42002406 <print_debug_exception_details+0x4e>
        panic_print_str("DebugIntr ");
42002400:	f7cda1        	l32r	a10, 42000334 <_stext+0x314> (3c020994 <_flash_rodata_start+0x874>)
42002403:	ff98e5        	call8	42001d90 <panic_print_str>
    }
}
42002406:	f01d      	retw.n

42002408 <print_illegal_instruction_details>:
{
42002408:	004136        	entry	a1, 32
    uint32_t epc = frame->pc;
4200240b:	1288      	l32i.n	a8, a2, 4
    epc = (epc & ~0x3) - 4;
4200240d:	c97c      	movi.n	a9, -4
4200240f:	108890        	and	a8, a8, a9
42002412:	789a      	add.n	a7, a8, a9
    if (epc < SOC_IROM_MASK_LOW || epc >= SOC_IROM_HIGH) {
42002414:	f7c991        	l32r	a9, 42000338 <_stext+0x318> (bffffffc <_rtc_reserved_end+0x5feffffc>)
42002417:	889a      	add.n	a8, a8, a9
42002419:	f7c891        	l32r	a9, 4200033c <_stext+0x31c> (3ffffff <UserFrameTotalSize+0x3fffeff>)
4200241c:	383987        	bltu	a9, a8, 42002458 <print_illegal_instruction_details+0x50>
    panic_print_str("Memory dump at 0x");
4200241f:	f7c8a1        	l32r	a10, 42000340 <_stext+0x320> (3c0209a0 <_flash_rodata_start+0x880>)
42002422:	ff96e5        	call8	42001d90 <panic_print_str>
    panic_print_hex(epc);
42002425:	07ad      	mov.n	a10, a7
42002427:	ff9965        	call8	42001dbc <panic_print_hex>
    panic_print_str(": ");
4200242a:	f7c6a1        	l32r	a10, 42000344 <_stext+0x324> (3c0209b4 <_flash_rodata_start+0x894>)
4200242d:	ff9625        	call8	42001d90 <panic_print_str>
    panic_print_hex(*pepc);
42002430:	0020c0        	memw
42002433:	0027a2        	l32i	a10, a7, 0
42002436:	ff9865        	call8	42001dbc <panic_print_hex>
    panic_print_str(" ");
42002439:	f7c321        	l32r	a2, 42000348 <_stext+0x328> (3c020a18 <_flash_rodata_start+0x8f8>)
4200243c:	20a220        	or	a10, a2, a2
4200243f:	ff9525        	call8	42001d90 <panic_print_str>
    panic_print_hex(*(pepc + 1));
42002442:	0020c0        	memw
42002445:	0127a2        	l32i	a10, a7, 4
42002448:	ff9725        	call8	42001dbc <panic_print_hex>
    panic_print_str(" ");
4200244b:	02ad      	mov.n	a10, a2
4200244d:	ff9425        	call8	42001d90 <panic_print_str>
    panic_print_hex(*(pepc + 2));
42002450:	0020c0        	memw
42002453:	27a8      	l32i.n	a10, a7, 8
42002455:	ff9665        	call8	42001dbc <panic_print_hex>
}
42002458:	f01d      	retw.n
	...

4200245c <print_cache_err_details>:
    panic_print_str(")\r\n");
}
#endif

static inline void print_cache_err_details(const void *f)
{
4200245c:	006136        	entry	a1, 48
    esp_cache_err_info_t err = {};
4200245f:	cc0c      	movi.n	a12, 12
42002461:	00a0b2        	movi	a11, 0
42002464:	01ad      	mov.n	a10, a1
42002466:	f7a681        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42002469:	0008e0        	callx8	a8
    esp_cache_err_get_panic_info(&err);
4200246c:	01ad      	mov.n	a10, a1
4200246e:	ff5565        	call8	420019c4 <esp_cache_err_get_panic_info>

    if (err.err_str) {
42002471:	01a8      	l32i.n	a10, a1, 0
42002473:	5aac      	beqz.n	a10, 4200249c <print_cache_err_details+0x40>
        panic_print_str(err.err_str);
42002475:	ff91a5        	call8	42001d90 <panic_print_str>
        if (err.vaddr) {
42002478:	1188      	l32i.n	a8, a1, 4
4200247a:	00a816        	beqz	a8, 42002488 <print_cache_err_details+0x2c>
            panic_print_str(", error address: 0x");
4200247d:	f7b3a1        	l32r	a10, 4200034c <_stext+0x32c> (3c0209b8 <_flash_rodata_start+0x898>)
42002480:	ff90e5        	call8	42001d90 <panic_print_str>
            panic_print_hex(err.vaddr);
42002483:	11a8      	l32i.n	a10, a1, 4
42002485:	ff9365        	call8	42001dbc <panic_print_hex>
        }
        if (err.size) {
42002488:	022182        	l32i	a8, a1, 8
4200248b:	016816        	beqz	a8, 420024a5 <print_cache_err_details+0x49>
            panic_print_str(", error size: 0x");
4200248e:	f7b0a1        	l32r	a10, 42000350 <_stext+0x330> (3c0209cc <_flash_rodata_start+0x8ac>)
42002491:	ff8fe5        	call8	42001d90 <panic_print_str>
            panic_print_hex(err.size);
42002494:	21a8      	l32i.n	a10, a1, 8
42002496:	ff9265        	call8	42001dbc <panic_print_hex>
42002499:	000206        	j	420024a5 <print_cache_err_details+0x49>
        }
    } else {
        // Default to cache disabled message if no specific error is found
        panic_print_str("Cache disabled but cached memory region accessed");
4200249c:	f7aea1        	l32r	a10, 42000354 <_stext+0x334> (3c0209e0 <_flash_rodata_start+0x8c0>)
4200249f:	201110        	or	a1, a1, a1
420024a2:	ff8ee5        	call8	42001d90 <panic_print_str>
    }
    panic_print_str("\r\n");
420024a5:	f7aca1        	l32r	a10, 42000358 <_stext+0x338> (3c0208c4 <_flash_rodata_start+0x7a4>)
420024a8:	ff8e65        	call8	42001d90 <panic_print_str>
}
420024ab:	f01d      	retw.n
420024ad:	000000        	ill

420024b0 <panic_print_registers>:
{
420024b0:	010136        	entry	a1, 128
    const char *sdesc[] = {
420024b3:	60a0c2        	movi	a12, 96
420024b6:	f7a9b1        	l32r	a11, 4200035c <_stext+0x33c> (3c027188 <g_startup_fn+0x8>)
420024b9:	20a110        	or	a10, a1, a1
420024bc:	f6db81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420024bf:	0008e0        	callx8	a8
    panic_print_str("Core ");
420024c2:	f7a7a1        	l32r	a10, 42000360 <_stext+0x340> (3c020a14 <_flash_rodata_start+0x8f4>)
420024c5:	ff8ca5        	call8	42001d90 <panic_print_str>
    panic_print_dec(core);
420024c8:	03ad      	mov.n	a10, a3
420024ca:	ff91e5        	call8	42001de8 <panic_print_dec>
    panic_print_str(" register dump:");
420024cd:	f7a5a1        	l32r	a10, 42000364 <_stext+0x344> (3c020a1c <_flash_rodata_start+0x8fc>)
420024d0:	ff8be5        	call8	42001d90 <panic_print_str>
    for (int x = 0; x < 24; x += 4) {
420024d3:	050c      	movi.n	a5, 0
420024d5:	000f06        	j	42002515 <panic_print_registers+0x65>
        panic_print_str("\r\n");
420024d8:	f7a0a1        	l32r	a10, 42000358 <_stext+0x338> (3c0208c4 <_flash_rodata_start+0x7a4>)
420024db:	ff8b65        	call8	42001d90 <panic_print_str>
        for (int y = 0; y < 4; y++) {
420024de:	070c      	movi.n	a7, 0
420024e0:	000b06        	j	42002510 <panic_print_registers+0x60>
420024e3:	000000        	ill
            if (sdesc[x + y][0] != 0) {
420024e6:	657a      	add.n	a6, a5, a7
420024e8:	a08610        	addx4	a8, a6, a1
420024eb:	08a8      	l32i.n	a10, a8, 0
420024ed:	000a82        	l8ui	a8, a10, 0
420024f0:	01a816        	beqz	a8, 4200250e <panic_print_registers+0x5e>
                panic_print_str(sdesc[x + y]);
420024f3:	ff89e5        	call8	42001d90 <panic_print_str>
                panic_print_str(": 0x");
420024f6:	f79ca1        	l32r	a10, 42000368 <_stext+0x348> (3c020a58 <_flash_rodata_start+0x938>)
420024f9:	ff8965        	call8	42001d90 <panic_print_str>
                panic_print_hex(regs[x + y + 1]);
420024fc:	01c662        	addi	a6, a6, 1
420024ff:	a06620        	addx4	a6, a6, a2
42002502:	0026a2        	l32i	a10, a6, 0
42002505:	ff8b65        	call8	42001dbc <panic_print_hex>
                panic_print_str("  ");
42002508:	f799a1        	l32r	a10, 4200036c <_stext+0x34c> (3c020a2c <_flash_rodata_start+0x90c>)
4200250b:	ff8865        	call8	42001d90 <panic_print_str>
        for (int y = 0; y < 4; y++) {
4200250e:	771b      	addi.n	a7, a7, 1
42002510:	d247a6        	blti	a7, 4, 420024e6 <panic_print_registers+0x36>
    for (int x = 0; x < 24; x += 4) {
42002513:	554b      	addi.n	a5, a5, 4
42002515:	17a082        	movi	a8, 23
42002518:	bca857        	bge	a8, a5, 420024d8 <panic_print_registers+0x28>
    if (xPortInterruptedFromISRContext()
4200251b:	f79a81        	l32r	a8, 42000384 <_stext+0x364> (40376888 <xPortInterruptedFromISRContext>)
4200251e:	0008e0        	callx8	a8
42002521:	060a16        	beqz	a10, 42002585 <panic_print_registers+0xd5>
            && ((core == 0 && frame->exccause == PANIC_RSN_INTWDT_CPU0) ||
42002524:	43cc      	bnez.n	a3, 4200252c <panic_print_registers+0x7c>
42002526:	142282        	l32i	a8, a2, 80
42002529:	085826        	beqi	a8, 5, 42002535 <panic_print_registers+0x85>
4200252c:	551366        	bnei	a3, 1, 42002585 <panic_print_registers+0xd5>
                (core == 1 && frame->exccause == PANIC_RSN_INTWDT_CPU1))
4200252f:	142282        	l32i	a8, a2, 80
42002532:	4f6866        	bnei	a8, 6, 42002585 <panic_print_registers+0xd5>
        panic_print_str("\r\n");
42002535:	f788a1        	l32r	a10, 42000358 <_stext+0x338> (3c0208c4 <_flash_rodata_start+0x7a4>)
42002538:	ff8565        	call8	42001d90 <panic_print_str>
        panic_print_str("Core ");
4200253b:	f789a1        	l32r	a10, 42000360 <_stext+0x340> (3c020a14 <_flash_rodata_start+0x8f4>)
4200253e:	ff8525        	call8	42001d90 <panic_print_str>
        panic_print_dec(core);
42002541:	20a330        	or	a10, a3, a3
42002544:	ff8a25        	call8	42001de8 <panic_print_dec>
        panic_print_str(" was running in ISR context:\r\n");
42002547:	f78aa1        	l32r	a10, 42000370 <_stext+0x350> (3c020a30 <_flash_rodata_start+0x910>)
4200254a:	ff8465        	call8	42001d90 <panic_print_str>
        __asm__("rsr.epc1 %0" : "=a"(__value));
4200254d:	03b170        	rsr.epc1	a7
        panic_print_str("EPC1    : 0x");
42002550:	f789a1        	l32r	a10, 42000374 <_stext+0x354> (3c020a50 <_flash_rodata_start+0x930>)
42002553:	ff83e5        	call8	42001d90 <panic_print_str>
        panic_print_hex(__value);
42002556:	07ad      	mov.n	a10, a7
42002558:	ff8625        	call8	42001dbc <panic_print_hex>
        __asm__("rsr.epc2 %0" : "=a"(__value));
4200255b:	03b270        	rsr.epc2	a7
        panic_print_str("  EPC2    : 0x");
4200255e:	f786a1        	l32r	a10, 42000378 <_stext+0x358> (3c020a60 <_flash_rodata_start+0x940>)
42002561:	ff82e5        	call8	42001d90 <panic_print_str>
        panic_print_hex(__value);
42002564:	07ad      	mov.n	a10, a7
42002566:	ff8565        	call8	42001dbc <panic_print_hex>
        __asm__("rsr.epc3 %0" : "=a"(__value));
42002569:	03b370        	rsr.epc3	a7
        panic_print_str("  EPC3    : 0x");
4200256c:	f784a1        	l32r	a10, 4200037c <_stext+0x35c> (3c020a70 <_flash_rodata_start+0x950>)
4200256f:	ff8225        	call8	42001d90 <panic_print_str>
        panic_print_hex(__value);
42002572:	07ad      	mov.n	a10, a7
42002574:	ff8465        	call8	42001dbc <panic_print_hex>
        __asm__("rsr.epc4 %0" : "=a"(__value));
42002577:	03b470        	rsr.epc4	a7
        panic_print_str("  EPC4    : 0x");
4200257a:	f781a1        	l32r	a10, 42000380 <_stext+0x360> (3c020a80 <_flash_rodata_start+0x960>)
4200257d:	ff8125        	call8	42001d90 <panic_print_str>
        panic_print_hex(__value);
42002580:	07ad      	mov.n	a10, a7
42002582:	ff83a5        	call8	42001dbc <panic_print_hex>
}
42002585:	f01d      	retw.n
	...

42002588 <panic_arch_fill_info>:

void panic_arch_fill_info(void *f, panic_info_t *info)
{
42002588:	004136        	entry	a1, 32
        "LoadProhibited", "StoreProhibited", "res", "res",
        "Cp0Dis", "Cp1Dis", "Cp2Dis", "Cp3Dis",
        "Cp4Dis", "Cp5Dis", "Cp6Dis", "Cp7Dis"
    };

    if (frame->exccause < (sizeof(reason) / sizeof(char *))) {
4200258b:	142282        	l32i	a8, a2, 80
4200258e:	792c      	movi.n	a9, 39
42002590:	0c3987        	bltu	a9, a8, 420025a0 <panic_arch_fill_info+0x18>
        info->reason = (reason[frame->exccause]);
42002593:	f77d91        	l32r	a9, 42000388 <_stext+0x368> (3c027208 <reason$1>)
42002596:	a08890        	addx4	a8, a8, a9
42002599:	0888      	l32i.n	a8, a8, 0
4200259b:	2389      	s32i.n	a8, a3, 8
4200259d:	000106        	j	420025a5 <panic_arch_fill_info+0x1d>
    } else {
        info->reason = "Unknown";
420025a0:	f77b81        	l32r	a8, 4200038c <_stext+0x36c> (3c020904 <_flash_rodata_start+0x7e4>)
420025a3:	2389      	s32i.n	a8, a3, 8
    }

    info->description = "Exception was unhandled.";
420025a5:	f77a81        	l32r	a8, 42000390 <_stext+0x370> (3c020bb0 <_flash_rodata_start+0xa90>)
420025a8:	3389      	s32i.n	a8, a3, 12
    if (frame->exccause == EXCCAUSE_ILLEGAL) {
420025aa:	142282        	l32i	a8, a2, 80
420025ad:	38cc      	bnez.n	a8, 420025b4 <panic_arch_fill_info+0x2c>
        info->details = print_illegal_instruction_details;
420025af:	f77981        	l32r	a8, 42000394 <_stext+0x374> (42002408 <print_illegal_instruction_details>)
420025b2:	4389      	s32i.n	a8, a3, 16
    }

    info->addr = ((void *)((XtExcFrame *) frame)->pc);
420025b4:	1288      	l32i.n	a8, a2, 4
420025b6:	6389      	s32i.n	a8, a3, 24
}
420025b8:	f01d      	retw.n
	...

420025bc <panic_soc_fill_info>:
    // Currently only needed on riscv targets
    return false;
}

void panic_soc_fill_info(void *f, panic_info_t *info)
{
420025bc:	004136        	entry	a1, 32
    // [refactor-todo] this should be in the common port panic_handler.c, once
    // these special exceptions are supported in there.
    XtExcFrame *frame = (XtExcFrame *) f;
    if (frame->exccause == PANIC_RSN_INTWDT_CPU0) {
420025bf:	142282        	l32i	a8, a2, 80
420025c2:	0a5866        	bnei	a8, 5, 420025d0 <panic_soc_fill_info+0x14>
        info->core = 0;
420025c5:	080c      	movi.n	a8, 0
420025c7:	0389      	s32i.n	a8, a3, 0
        info->exception = PANIC_EXCEPTION_IWDT;
420025c9:	180c      	movi.n	a8, 1
420025cb:	1389      	s32i.n	a8, a3, 4
420025cd:	0005c6        	j	420025e8 <panic_soc_fill_info+0x2c>
    } else if (frame->exccause == PANIC_RSN_INTWDT_CPU1) {
420025d0:	096866        	bnei	a8, 6, 420025dd <panic_soc_fill_info+0x21>
        info->core = 1;
420025d3:	180c      	movi.n	a8, 1
420025d5:	0389      	s32i.n	a8, a3, 0
        info->exception = PANIC_EXCEPTION_IWDT;
420025d7:	1389      	s32i.n	a8, a3, 4
420025d9:	0002c6        	j	420025e8 <panic_soc_fill_info+0x2c>
420025dc:	786600        	lsi	f0, a6, 0x1e0
    } else if (frame->exccause == PANIC_RSN_CACHEERR) {
420025df:	111007        	beq	a0, a0, 420025f4 <panic_soc_fill_info+0x38>
        info->core =  esp_cache_err_get_cpuid();
420025e2:	5da520        	lsi	f2, a5, 0x174
420025e5:	ff          	.byte	0xff
420025e6:	03a9      	s32i.n	a10, a3, 0
        "Interrupt wdt timeout on CPU0",
        "Interrupt wdt timeout on CPU1",
        "Cache error",
    };

    info->reason = pseudo_reason[0];
420025e8:	f76c81        	l32r	a8, 42000398 <_stext+0x378> (3c020bcc <_flash_rodata_start+0xaac>)
420025eb:	2389      	s32i.n	a8, a3, 8
    info->description = NULL;
420025ed:	080c      	movi.n	a8, 0
420025ef:	3389      	s32i.n	a8, a3, 12

    if (frame->exccause <= PANIC_RSN_MAX) {
420025f1:	142282        	l32i	a8, a2, 80
420025f4:	0988e6        	bgei	a8, 8, 42002601 <panic_soc_fill_info+0x45>
        info->reason = pseudo_reason[frame->exccause];
420025f7:	f76991        	l32r	a9, 4200039c <_stext+0x37c> (3c0271e8 <pseudo_reason$0>)
420025fa:	a08890        	addx4	a8, a8, a9
420025fd:	0888      	l32i.n	a8, a8, 0
420025ff:	2389      	s32i.n	a8, a3, 8
    }

    if (frame->exccause == PANIC_RSN_DEBUGEXCEPTION) {
42002601:	142282        	l32i	a8, a2, 80
42002604:	091866        	bnei	a8, 1, 42002611 <panic_soc_fill_info+0x55>
        info->details = print_debug_exception_details;
42002607:	f76681        	l32r	a8, 420003a0 <_stext+0x380> (420023b8 <print_debug_exception_details>)
4200260a:	4389      	s32i.n	a8, a3, 16
        info->exception = PANIC_EXCEPTION_DEBUG;
4200260c:	080c      	movi.n	a8, 0
4200260e:	016382        	s32i	a8, a3, 4
    }

    //MV note: ESP32S3 PMS handling?
    if (frame->exccause == PANIC_RSN_CACHEERR) {
42002611:	142282        	l32i	a8, a2, 80
42002614:	047866        	bnei	a8, 7, 4200261c <panic_soc_fill_info+0x60>
            info->details = print_memprot_err_details;
            info->reason = "Memory protection fault";
        } else
#endif
        {
            info->details = print_cache_err_details;
42002617:	f76381        	l32r	a8, 420003a4 <_stext+0x384> (4200245c <print_cache_err_details>)
4200261a:	4389      	s32i.n	a8, a3, 16
        }
    }
}
4200261c:	f01d      	retw.n
	...

42002620 <panic_print_backtrace>:
{
    ((XtExcFrame *)f)->pc = addr;
}

void panic_print_backtrace(const void *f, int core)
{
42002620:	006136        	entry	a1, 48
    XtExcFrame *xt_frame = (XtExcFrame *) f;
    esp_backtrace_frame_t frame = {.pc = xt_frame->pc, .sp = xt_frame->a1, .next_pc = xt_frame->a0, .exc_frame = xt_frame};
42002623:	1288      	l32i.n	a8, a2, 4
42002625:	0189      	s32i.n	a8, a1, 0
42002627:	4288      	l32i.n	a8, a2, 16
42002629:	1189      	s32i.n	a8, a1, 4
4200262b:	3288      	l32i.n	a8, a2, 12
4200262d:	2189      	s32i.n	a8, a1, 8
4200262f:	3129      	s32i.n	a2, a1, 12
    esp_backtrace_print_from_frame(100, &frame, true);
42002631:	1c0c      	movi.n	a12, 1
42002633:	01bd      	mov.n	a11, a1
42002635:	64a0a2        	movi	a10, 100
42002638:	f75c81        	l32r	a8, 420003a8 <_stext+0x388> (40375b50 <esp_backtrace_print_from_frame>)
4200263b:	0008e0        	callx8	a8
}
4200263e:	f01d      	retw.n

42002640 <esp_ipc_init>:
 * esp_ipc_call_blocking.
 */
static void esp_ipc_init(void) __attribute__((constructor));

static void esp_ipc_init(void)
{
42002640:	008136        	entry	a1, 64
    char task_name[] = "ipcX"; // up to 10 ipc tasks/cores (0-9)
42002643:	f75a81        	l32r	a8, 420003ac <_stext+0x38c> (3c020f74 <_flash_rodata_start+0xe54>)
42002646:	0898      	l32i.n	a9, a8, 0
42002648:	040882        	l8ui	a8, a8, 4
4200264b:	4199      	s32i.n	a9, a1, 16
4200264d:	144182        	s8i	a8, a1, 20

    for (int i = 0; i < CONFIG_FREERTOS_NUMBER_OF_CORES; ++i) {
42002650:	070c      	movi.n	a7, 0
42002652:	001d86        	j	420026cc <esp_ipc_init+0x8c>
        task_name[3] = i + (char)'0';
42002655:	30c782        	addi	a8, a7, 48
42002658:	134182        	s8i	a8, a1, 19
        s_ipc_mutex[i] = xSemaphoreCreateMutexStatic(&s_ipc_mutex_buffer[i]);
4200265b:	905770        	addx2	a5, a7, a7
4200265e:	1145d0        	slli	a4, a5, 3
42002661:	f0b550        	subx8	a11, a5, a5
42002664:	f75381        	l32r	a8, 420003b0 <_stext+0x390> (3fc92998 <s_ipc_mutex_buffer>)
42002667:	a0bb80        	addx4	a11, a11, a8
4200266a:	1a0c      	movi.n	a10, 1
4200266c:	f75a81        	l32r	a8, 420003d4 <_stext+0x3b4> (40379c68 <xQueueCreateMutexStatic>)
4200266f:	0008e0        	callx8	a8
42002672:	1167e0        	slli	a6, a7, 2
42002675:	f74f81        	l32r	a8, 420003b4 <_stext+0x394> (3fc94a2c <s_ipc_mutex>)
42002678:	a08780        	addx4	a8, a7, a8
4200267b:	08a9      	s32i.n	a10, a8, 0
        s_ipc_ack[i] = xSemaphoreCreateBinaryStatic(&s_ipc_ack_buffer[i]);
4200267d:	c04450        	sub	a4, a4, a5
42002680:	3e0c      	movi.n	a14, 3
42002682:	f74dd1        	l32r	a13, 420003b8 <_stext+0x398> (3fc928f0 <s_ipc_ack_buffer>)
42002685:	a0d4d0        	addx4	a13, a4, a13
42002688:	0c0c      	movi.n	a12, 0
4200268a:	0cbd      	mov.n	a11, a12
4200268c:	1a0c      	movi.n	a10, 1
4200268e:	f75281        	l32r	a8, 420003d8 <_stext+0x3b8> (403799bc <xQueueGenericCreateStatic>)
42002691:	0008e0        	callx8	a8
42002694:	f74a81        	l32r	a8, 420003bc <_stext+0x39c> (3fc94a24 <s_ipc_ack>)
42002697:	886a      	add.n	a8, a8, a6
42002699:	08a9      	s32i.n	a10, a8, 0
        BaseType_t res = xTaskCreatePinnedToCore(ipc_task, task_name, IPC_STACK_SIZE, (void*) i,
4200269b:	0179      	s32i.n	a7, a1, 0
4200269d:	f748f1        	l32r	a15, 420003c0 <_stext+0x3a0> (3fc94a34 <s_ipc_task_handle>)
420026a0:	ff6a      	add.n	a15, a15, a6
420026a2:	8e1c      	movi.n	a14, 24
420026a4:	07dd      	mov.n	a13, a7
420026a6:	00a5c2        	movi	a12, 0x500
420026a9:	10c1b2        	addi	a11, a1, 16
420026ac:	f746a1        	l32r	a10, 420003c4 <_stext+0x3a4> (40375ce8 <ipc_task>)
420026af:	f74b81        	l32r	a8, 420003dc <_stext+0x3bc> (4037c5c0 <xTaskCreatePinnedToCore>)
420026b2:	0008e0        	callx8	a8
                                                 IPC_MAX_PRIORITY, &s_ipc_task_handle[i], i);
        assert(res == pdTRUE);
420026b5:	111a26        	beqi	a10, 1, 420026ca <esp_ipc_init+0x8a>
420026b8:	f744d1        	l32r	a13, 420003c8 <_stext+0x3a8> (3c020f64 <_flash_rodata_start+0xe44>)
420026bb:	f744c1        	l32r	a12, 420003cc <_stext+0x3ac> (3c0272b4 <__func__$1>)
420026be:	74a0b2        	movi	a11, 116
420026c1:	f743a1        	l32r	a10, 420003d0 <_stext+0x3b0> (3c020f58 <_flash_rodata_start+0xe38>)
420026c4:	f67f81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420026c7:	0008e0        	callx8	a8
    for (int i = 0; i < CONFIG_FREERTOS_NUMBER_OF_CORES; ++i) {
420026ca:	771b      	addi.n	a7, a7, 1
420026cc:	8527a6        	blti	a7, 2, 42002655 <esp_ipc_init+0x15>
        (void)res;
    }
}
420026cf:	f01d      	retw.n
420026d1:	000000        	ill

420026d4 <esp_ipc_call_nonblocking>:
{
    return esp_ipc_call_and_wait(cpu_id, func, arg, IPC_WAIT_FOR_END);
}

esp_err_t esp_ipc_call_nonblocking(uint32_t cpu_id, esp_ipc_func_t func, void* arg)
{
420026d4:	004136        	entry	a1, 32
    if (cpu_id >= portNUM_PROCESSORS || s_ipc_task_handle[cpu_id] == NULL) {
420026d7:	0222b6        	bltui	a2, 2, 420026dd <esp_ipc_call_nonblocking+0x9>
420026da:	0022c6        	j	42002769 <esp_ipc_call_nonblocking+0x95>
420026dd:	f73881        	l32r	a8, 420003c0 <_stext+0x3a0> (3fc94a34 <s_ipc_task_handle>)
420026e0:	a08280        	addx4	a8, a2, a8
420026e3:	002882        	l32i	a8, a8, 0
420026e6:	086816        	beqz	a8, 42002770 <esp_ipc_call_nonblocking+0x9c>
420026e9:	03eb80        	rsr.prid	a8
420026ec:	048d80        	extui	a8, a8, 13, 1
        return ESP_ERR_INVALID_ARG;
    }
    if (cpu_id == xPortGetCoreID() && xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
420026ef:	089287        	bne	a2, a8, 420026fb <esp_ipc_call_nonblocking+0x27>
420026f2:	f73e81        	l32r	a8, 420003ec <_stext+0x3cc> (4037ba48 <xTaskGetSchedulerState>)
420026f5:	0008e0        	callx8	a8
420026f8:	7c2a66        	bnei	a10, 2, 42002778 <esp_ipc_call_nonblocking+0xa4>
        return ESP_ERR_INVALID_STATE;
    }

    // Since it can be called from an interrupt or Scheduler is Suspened, it can not wait for a mutex to be released.
    if (esp_cpu_compare_and_set((volatile uint32_t *)&s_no_block_func[cpu_id], 0, (uint32_t)func)) {
420026fb:	03cd      	mov.n	a12, a3
420026fd:	00a0b2        	movi	a11, 0
42002700:	f738a1        	l32r	a10, 420003e0 <_stext+0x3c0> (3fc94a04 <s_no_block_func>)
42002703:	a0a2a0        	addx4	a10, a2, a10
42002706:	f73a81        	l32r	a8, 420003f0 <_stext+0x3d0> (403781a8 <esp_cpu_compare_and_set>)
42002709:	0008e0        	callx8	a8
4200270c:	06ea16        	beqz	a10, 4200277e <esp_ipc_call_nonblocking+0xaa>
        s_no_block_func_arg[cpu_id] = arg;
4200270f:	f73581        	l32r	a8, 420003e4 <_stext+0x3c4> (3fc949f8 <s_no_block_func_arg>)
42002712:	a08280        	addx4	a8, a2, a8
42002715:	0020c0        	memw
42002718:	0849      	s32i.n	a4, a8, 0
        s_no_block_func_and_arg_are_ready[cpu_id] = true;
4200271a:	f73381        	l32r	a8, 420003e8 <_stext+0x3c8> (3fc94a00 <s_no_block_func_and_arg_are_ready>)
4200271d:	882a      	add.n	a8, a8, a2
4200271f:	190c      	movi.n	a9, 1
42002721:	0020c0        	memw
42002724:	004892        	s8i	a9, a8, 0

        if (xPortInIsrContext()) {
42002727:	f73381        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
4200272a:	0008e0        	callx8	a8
4200272d:	3a9c      	beqz.n	a10, 42002744 <esp_ipc_call_nonblocking+0x70>
            vTaskNotifyGiveFromISR(s_ipc_task_handle[cpu_id], NULL);
4200272f:	f72481        	l32r	a8, 420003c0 <_stext+0x3a0> (3fc94a34 <s_ipc_task_handle>)
42002732:	a08280        	addx4	a8, a2, a8
42002735:	0c0c      	movi.n	a12, 0
42002737:	0cbd      	mov.n	a11, a12
42002739:	08a8      	l32i.n	a10, a8, 0
4200273b:	f72f81        	l32r	a8, 420003f8 <_stext+0x3d8> (4037c3a0 <vTaskGenericNotifyGiveFromISR>)
4200273e:	0008e0        	callx8	a8
42002741:	0007c6        	j	42002764 <esp_ipc_call_nonblocking+0x90>
        } else {
#ifdef CONFIG_ESP_IPC_USES_CALLERS_PRIORITY
            vTaskPrioritySet(s_ipc_task_handle[cpu_id], IPC_MAX_PRIORITY);
42002744:	f71f81        	l32r	a8, 420003c0 <_stext+0x3a0> (3fc94a34 <s_ipc_task_handle>)
42002747:	a02280        	addx4	a2, a2, a8
4200274a:	8b1c      	movi.n	a11, 24
4200274c:	02a8      	l32i.n	a10, a2, 0
4200274e:	f72b81        	l32r	a8, 420003fc <_stext+0x3dc> (4037b8b0 <vTaskPrioritySet>)
42002751:	0008e0        	callx8	a8
#endif
            xTaskNotifyGive(s_ipc_task_handle[cpu_id]);
42002754:	0e0c      	movi.n	a14, 0
42002756:	2d0c      	movi.n	a13, 2
42002758:	0ecd      	mov.n	a12, a14
4200275a:	0ebd      	mov.n	a11, a14
4200275c:	02a8      	l32i.n	a10, a2, 0
4200275e:	f72881        	l32r	a8, 42000400 <_stext+0x3e0> (4037c1cc <xTaskGenericNotify>)
42002761:	0008e0        	callx8	a8
        }
        return ESP_OK;
42002764:	020c      	movi.n	a2, 0
42002766:	000586        	j	42002780 <esp_ipc_call_nonblocking+0xac>
        return ESP_ERR_INVALID_ARG;
42002769:	02a122        	movi	a2, 0x102
4200276c:	000406        	j	42002780 <esp_ipc_call_nonblocking+0xac>
4200276f:	a12200        	sll	a2, a2
42002772:	024602        	s8i	a0, a6, 2
42002775:	000000        	ill
        return ESP_ERR_INVALID_STATE;
42002778:	03a122        	movi	a2, 0x103
4200277b:	000046        	j	42002780 <esp_ipc_call_nonblocking+0xac>
    }

    // the previous call was not completed
    return ESP_FAIL;
4200277e:	f27c      	movi.n	a2, -1
}
42002780:	f01d      	retw.n
	...

42002784 <esp_vApplicationIdleHook>:

void esp_vApplicationIdleHook(void)
{
42002784:	004136        	entry	a1, 32
42002787:	03eb60        	rsr.prid	a6
4200278a:	046d60        	extui	a6, a6, 13, 1
    bool can_go_idle = true;
    int core = xPortGetCoreID();
    for (int n = 0; n < MAX_HOOKS; n++) {
4200278d:	070c      	movi.n	a7, 0
    bool can_go_idle = true;
4200278f:	150c      	movi.n	a5, 1
    for (int n = 0; n < MAX_HOOKS; n++) {
42002791:	000546        	j	420027aa <esp_vApplicationIdleHook+0x26>
        if (idle_cb[core][n] != NULL && !idle_cb[core][n]()) {
42002794:	b08670        	addx8	a8, a6, a7
42002797:	f71b91        	l32r	a9, 42000404 <_stext+0x3e4> (3fc94a7c <idle_cb>)
4200279a:	a08890        	addx4	a8, a8, a9
4200279d:	08a8      	l32i.n	a10, a8, 0
4200279f:	5a8c      	beqz.n	a10, 420027a8 <esp_vApplicationIdleHook+0x24>
420027a1:	000ae0        	callx8	a10
420027a4:	0acc      	bnez.n	a10, 420027a8 <esp_vApplicationIdleHook+0x24>
            can_go_idle = false;
420027a6:	0a5d      	mov.n	a5, a10
    for (int n = 0; n < MAX_HOOKS; n++) {
420027a8:	771b      	addi.n	a7, a7, 1
420027aa:	e687a6        	blti	a7, 8, 42002794 <esp_vApplicationIdleHook+0x10>
        }
    }
    if (!can_go_idle) {
420027ad:	458c      	beqz.n	a5, 420027b5 <esp_vApplicationIdleHook+0x31>

#ifdef CONFIG_PM_ENABLE
    esp_pm_impl_idle_hook();
    esp_pm_impl_waiti();
#else
    esp_cpu_wait_for_intr();
420027af:	f71681        	l32r	a8, 42000408 <_stext+0x3e8> (40378298 <esp_cpu_wait_for_intr>)
420027b2:	0008e0        	callx8	a8
#endif

}
420027b5:	f01d      	retw.n
	...

420027b8 <esp_register_freertos_idle_hook_for_cpu>:

esp_err_t esp_register_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t new_idle_cb, UBaseType_t cpuid)
{
420027b8:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
420027bb:	4d23f6        	bgeui	a3, 2, 4200280c <esp_register_freertos_idle_hook_for_cpu+0x54>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
420027be:	fb7c      	movi.n	a11, -1
420027c0:	f713a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
420027c3:	f71381        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420027c6:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
420027c9:	090c      	movi.n	a9, 0
420027cb:	000a46        	j	420027f8 <esp_register_freertos_idle_hook_for_cpu+0x40>
420027ce:	900000        	addx2	a0, a0, a0
        if (idle_cb[cpuid][n] == NULL) {
420027d1:	a1b083        	lsi	f8, a0, 0x284
420027d4:	f70c      	movi.n	a7, 15
420027d6:	a088a0        	addx4	a8, a8, a10
420027d9:	0888      	l32i.n	a8, a8, 0
420027db:	78dc      	bnez.n	a8, 420027f6 <esp_register_freertos_idle_hook_for_cpu+0x3e>
            idle_cb[cpuid][n] = new_idle_cb;
420027dd:	b03390        	addx8	a3, a3, a9
420027e0:	a033a0        	addx4	a3, a3, a10
420027e3:	0329      	s32i.n	a2, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
420027e5:	f709a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
420027e8:	f70b81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420027eb:	0008e0        	callx8	a8
            return ESP_OK;
420027ee:	020c      	movi.n	a2, 0
420027f0:	0006c6        	j	4200280f <esp_register_freertos_idle_hook_for_cpu+0x57>
420027f3:	000000        	ill
    for (int n = 0; n < MAX_HOOKS; n++) {
420027f6:	991b      	addi.n	a9, a9, 1
420027f8:	d489a6        	blti	a9, 8, 420027d0 <esp_register_freertos_idle_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
420027fb:	f704a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
420027fe:	f70581        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42002801:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
42002804:	01a122        	movi	a2, 0x101
42002807:	000106        	j	4200280f <esp_register_freertos_idle_hook_for_cpu+0x57>
4200280a:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
4200280d:	1d02a1        	l32r	a10, 41fc9c18 <_coredump_iram_end+0x1c47c18>
}
42002810:	0000f0        	callx12	a0
	...

42002814 <esp_register_freertos_tick_hook_for_cpu>:
{
    return esp_register_freertos_idle_hook_for_cpu(new_idle_cb, xPortGetCoreID());
}

esp_err_t esp_register_freertos_tick_hook_for_cpu(esp_freertos_tick_cb_t new_tick_cb, UBaseType_t cpuid)
{
42002814:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
42002817:	4923f6        	bgeui	a3, 2, 42002864 <esp_register_freertos_tick_hook_for_cpu+0x50>
4200281a:	fb7c      	movi.n	a11, -1
4200281c:	f6fca1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
4200281f:	f6fc81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42002822:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
42002825:	090c      	movi.n	a9, 0
42002827:	000986        	j	42002851 <esp_register_freertos_tick_hook_for_cpu+0x3d>
4200282a:	900000        	addx2	a0, a0, a0
        if (tick_cb[cpuid][n] == NULL) {
4200282d:	a1b083        	lsi	f8, a0, 0x284
42002830:	f6fa      	add.n	a15, a6, a15
42002832:	a088a0        	addx4	a8, a8, a10
42002835:	0888      	l32i.n	a8, a8, 0
42002837:	48dc      	bnez.n	a8, 4200284f <esp_register_freertos_tick_hook_for_cpu+0x3b>
            tick_cb[cpuid][n] = new_tick_cb;
42002839:	b03390        	addx8	a3, a3, a9
4200283c:	a033a0        	addx4	a3, a3, a10
4200283f:	0329      	s32i.n	a2, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
42002841:	f6f2a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
42002844:	f6f481        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42002847:	0008e0        	callx8	a8
            return ESP_OK;
4200284a:	020c      	movi.n	a2, 0
4200284c:	0005c6        	j	42002867 <esp_register_freertos_tick_hook_for_cpu+0x53>
    for (int n = 0; n < MAX_HOOKS; n++) {
4200284f:	991b      	addi.n	a9, a9, 1
42002851:	d789a6        	blti	a9, 8, 4200282c <esp_register_freertos_tick_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
42002854:	f6eea1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
42002857:	f6ef81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200285a:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
4200285d:	01a122        	movi	a2, 0x101
42002860:	0000c6        	j	42002867 <esp_register_freertos_tick_hook_for_cpu+0x53>
42002863:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42002866:	f01d02        	l16ui	a0, a13, 0x1e0
42002869:	000000        	ill

4200286c <esp_register_freertos_tick_hook>:
}

esp_err_t esp_register_freertos_tick_hook(esp_freertos_tick_cb_t new_tick_cb)
{
4200286c:	004136        	entry	a1, 32
4200286f:	20a220        	or	a10, a2, a2
42002872:	03ebb0        	rsr.prid	a11
42002875:	04bdb0        	extui	a11, a11, 13, 1
    return esp_register_freertos_tick_hook_for_cpu(new_tick_cb, xPortGetCoreID());
42002878:	fff9a5        	call8	42002814 <esp_register_freertos_tick_hook_for_cpu>
}
4200287b:	202aa0        	or	a2, a10, a10
4200287e:	000090        	retw
42002881:	000000        	ill

42002884 <esp_deregister_freertos_idle_hook_for_cpu>:

void esp_deregister_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t old_idle_cb, UBaseType_t cpuid)
{
42002884:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
42002887:	3723f6        	bgeui	a3, 2, 420028c2 <esp_deregister_freertos_idle_hook_for_cpu+0x3e>
4200288a:	fb7c      	movi.n	a11, -1
4200288c:	f6e0a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
4200288f:	f6e081        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42002892:	0008e0        	callx8	a8
        return;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
42002895:	090c      	movi.n	a9, 0
42002897:	0006c6        	j	420028b6 <esp_deregister_freertos_idle_hook_for_cpu+0x32>
4200289a:	900000        	addx2	a0, a0, a0
        if (idle_cb[cpuid][n] == old_idle_cb) {
4200289d:	a1b083        	lsi	f8, a0, 0x284
420028a0:	f6d9      	s32i.n	a13, a6, 60
420028a2:	a088a0        	addx4	a8, a8, a10
420028a5:	0888      	l32i.n	a8, a8, 0
420028a7:	099827        	bne	a8, a2, 420028b4 <esp_deregister_freertos_idle_hook_for_cpu+0x30>
            idle_cb[cpuid][n] = NULL;
420028aa:	b08390        	addx8	a8, a3, a9
420028ad:	a088a0        	addx4	a8, a8, a10
420028b0:	0a0c      	movi.n	a10, 0
420028b2:	08a9      	s32i.n	a10, a8, 0
    for (int n = 0; n < MAX_HOOKS; n++) {
420028b4:	991b      	addi.n	a9, a9, 1
420028b6:	e289a6        	blti	a9, 8, 4200289c <esp_deregister_freertos_idle_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
420028b9:	f6d4a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc9202c <hooks_spinlock>)
420028bc:	f6d681        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420028bf:	0008e0        	callx8	a8
}
420028c2:	f01d      	retw.n

420028c4 <esp_err_to_name>:
#else
    "UNKNOWN ERROR";
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

const char *esp_err_to_name(esp_err_t code)
{
420028c4:	004136        	entry	a1, 32
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    size_t i;

    for (i = 0; i < sizeof(esp_err_msg_table) / sizeof(esp_err_msg_table[0]); ++i) {
420028c7:	080c      	movi.n	a8, 0
420028c9:	0005c6        	j	420028e4 <esp_err_to_name+0x20>
        if (esp_err_msg_table[i].code == code) {
420028cc:	f6d591        	l32r	a9, 42000420 <_stext+0x400> (3c0272cc <esp_err_msg_table>)
420028cf:	b09890        	addx8	a9, a8, a9
420028d2:	0998      	l32i.n	a9, a9, 0
420028d4:	0a9927        	bne	a9, a2, 420028e2 <esp_err_to_name+0x1e>
            return esp_err_msg_table[i].msg;
420028d7:	f6d291        	l32r	a9, 42000420 <_stext+0x400> (3c0272cc <esp_err_msg_table>)
420028da:	b08890        	addx8	a8, a8, a9
420028dd:	1828      	l32i.n	a2, a8, 4
420028df:	000286        	j	420028ed <esp_err_to_name+0x29>
    for (i = 0; i < sizeof(esp_err_msg_table) / sizeof(esp_err_msg_table[0]); ++i) {
420028e2:	881b      	addi.n	a8, a8, 1
420028e4:	dba092        	movi	a9, 219
420028e7:	e1b987        	bgeu	a9, a8, 420028cc <esp_err_to_name+0x8>
        }
    }
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

    return esp_unknown_msg;
420028ea:	f6cc21        	l32r	a2, 4200041c <_stext+0x3fc> (3c0272c4 <esp_unknown_msg>)
}
420028ed:	f01d      	retw.n
	...

420028f0 <brownout_ll_set_threshold>:
{
420028f0:	004136        	entry	a1, 32
420028f3:	02fd      	mov.n	a15, a2
    REGI2C_WRITE_MASK(I2C_BOD, I2C_BOD_THRESHOLD, threshold);
420028f5:	0e0c      	movi.n	a14, 0
420028f7:	2d0c      	movi.n	a13, 2
420028f9:	5c0c      	movi.n	a12, 5
420028fb:	1b0c      	movi.n	a11, 1
420028fd:	61a0a2        	movi	a10, 97
42002900:	f6c981        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42002903:	0008e0        	callx8	a8
}
42002906:	f01d      	retw.n

42002908 <brownout_hal_config>:

#include "hal/brownout_ll.h"
#include "hal/brownout_hal.h"

void brownout_hal_config(const brownout_hal_config_t *cfg)
{
42002908:	004136        	entry	a1, 32
    RTCCNTL.fib_sel.val &= ~BROWNOUT_DETECTOR_LL_FIB_ENABLE;
4200290b:	f5ef71        	l32r	a7, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
4200290e:	0020c0        	memw
42002911:	522782        	l32i	a8, a7, 0x148
42002914:	d97c      	movi.n	a9, -3
42002916:	108890        	and	a8, a8, a9
42002919:	0020c0        	memw
4200291c:	526782        	s32i	a8, a7, 0x148
    RTCCNTL.brown_out.ana_rst_en = enable;
4200291f:	0020c0        	memw
42002922:	3a2782        	l32i	a8, a7, 232
42002925:	f6c091        	l32r	a9, 42000428 <_stext+0x408> (efffffff <_rtc_reserved_end+0x8fefffff>)
42002928:	108890        	and	a8, a8, a9
4200292b:	0020c0        	memw
4200292e:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.int_wait = cycle;
42002931:	0020c0        	memw
42002934:	3a2782        	l32i	a8, a7, 232
42002937:	f6bd91        	l32r	a9, 4200042c <_stext+0x40c> (ffffc00f <_rtc_reserved_end+0x9fefc00f>)
4200293a:	108890        	and	a8, a8, a9
4200293d:	092c      	movi.n	a9, 32
4200293f:	208890        	or	a8, a8, a9
42002942:	0020c0        	memw
42002945:	3a6782        	s32i	a8, a7, 232
    // If brownout software control is enabled, hw ana reset should be disabled, because it always has the highest priority.
    brownout_ll_ana_reset_enable(false);
    brownout_ll_set_intr_wait_cycles(2);
    brownout_ll_enable_flash_suspend(cfg->flash_power_down);
42002948:	030292        	l8ui	a9, a2, 3
    RTCCNTL.brown_out.close_flash_ena = enable;
4200294b:	0020c0        	memw
4200294e:	3a2782        	l32i	a8, a7, 232
42002951:	049090        	extui	a9, a9, 0, 1
42002954:	119920        	slli	a9, a9, 14
42002957:	f634a1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
4200295a:	1088a0        	and	a8, a8, a10
4200295d:	208890        	or	a8, a8, a9
42002960:	0020c0        	memw
42002963:	3a6782        	s32i	a8, a7, 232
    brownout_ll_enable_rf_power_down(cfg->rf_power_down);
42002966:	040292        	l8ui	a9, a2, 4
    RTCCNTL.brown_out.pd_rf_ena = enable;
42002969:	0020c0        	memw
4200296c:	3a2782        	l32i	a8, a7, 232
4200296f:	049090        	extui	a9, a9, 0, 1
42002972:	119910        	slli	a9, a9, 15
42002975:	f62aa1        	l32r	a10, 42000220 <_stext+0x200> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
42002978:	1088a0        	and	a8, a8, a10
4200297b:	208890        	or	a8, a8, a9
4200297e:	0020c0        	memw
42002981:	3a6782        	s32i	a8, a7, 232
/**
 * @brief Clear BOD internal count.
 */
static inline void brownout_ll_clear_count(void)
{
    RTCCNTL.brown_out.cnt_clr = 1;
42002984:	0020c0        	memw
42002987:	3a2782        	l32i	a8, a7, 232
4200298a:	f6a991        	l32r	a9, 42000430 <_stext+0x410> (20000000 <UserFrameTotalSize+0x1fffff00>)
4200298d:	208890        	or	a8, a8, a9
42002990:	0020c0        	memw
42002993:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.cnt_clr = 0;
42002996:	0020c0        	memw
42002999:	3a2782        	l32i	a8, a7, 232
4200299c:	f6a691        	l32r	a9, 42000434 <_stext+0x414> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4200299f:	108890        	and	a8, a8, a9
420029a2:	0020c0        	memw
420029a5:	3a6782        	s32i	a8, a7, 232
    brownout_ll_clear_count();
    brownout_ll_reset_config(cfg->reset_enabled, 0x3ff, BROWNOUT_RESET_LEVEL_SYSTEM);
420029a8:	020292        	l8ui	a9, a2, 2
    RTCCNTL.brown_out.rst_wait = reset_wait;
420029ab:	0020c0        	memw
420029ae:	3a2782        	l32i	a8, a7, 232
420029b1:	f6a1a1        	l32r	a10, 42000438 <_stext+0x418> (3ff0000 <UserFrameTotalSize+0x3feff00>)
420029b4:	2088a0        	or	a8, a8, a10
420029b7:	0020c0        	memw
420029ba:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.rst_ena = reset_ena;
420029bd:	0020c0        	memw
420029c0:	3a2782        	l32i	a8, a7, 232
420029c3:	049090        	extui	a9, a9, 0, 1
420029c6:	019960        	slli	a9, a9, 26
420029c9:	f69ca1        	l32r	a10, 4200043c <_stext+0x41c> (fbffffff <_rtc_reserved_end+0x9befffff>)
420029cc:	1088a0        	and	a8, a8, a10
420029cf:	208890        	or	a8, a8, a9
420029d2:	0020c0        	memw
420029d5:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.rst_sel = reset_level;
420029d8:	0020c0        	memw
420029db:	3a2782        	l32i	a8, a7, 232
420029de:	f69891        	l32r	a9, 42000440 <_stext+0x420> (8000000 <UserFrameTotalSize+0x7ffff00>)
420029e1:	208890        	or	a8, a8, a9
420029e4:	0020c0        	memw
420029e7:	3a6782        	s32i	a8, a7, 232
    brownout_ll_set_threshold(cfg->threshold);
420029ea:	0002a2        	l8ui	a10, a2, 0
420029ed:	fff025        	call8	420028f0 <brownout_ll_set_threshold>
    brownout_ll_bod_enable(cfg->enabled);
420029f0:	010292        	l8ui	a9, a2, 1
    RTCCNTL.brown_out.ena = bod_enable;
420029f3:	0020c0        	memw
420029f6:	3a2782        	l32i	a8, a7, 232
420029f9:	049090        	extui	a9, a9, 0, 1
420029fc:	019920        	slli	a9, a9, 30
420029ff:	f691a1        	l32r	a10, 42000444 <_stext+0x424> (bfffffff <_rtc_reserved_end+0x5fefffff>)
42002a02:	1088a0        	and	a8, a8, a10
42002a05:	208890        	or	a8, a8, a9
42002a08:	0020c0        	memw
42002a0b:	3a6782        	s32i	a8, a7, 232
}
42002a0e:	f01d      	retw.n

42002a10 <esp_log_linked_list_get_level>:
}

// Getting the log level from linked list
// if tag is not found then returns false.
bool esp_log_linked_list_get_level(const char *tag, esp_log_level_t *level)
{
42002a10:	004136        	entry	a1, 32
    // Walk the linked list of all tags and see if given tag is present in the list.
    // This is slow because tags are compared as strings.
    uncached_tag_entry_t *it;
    SLIST_FOREACH(it, &s_log_tags, entries) {
42002a13:	f68d81        	l32r	a8, 42000448 <_stext+0x428> (3fc94ac4 <s_log_tags>)
42002a16:	0878      	l32i.n	a7, a8, 0
42002a18:	000606        	j	42002a34 <esp_log_linked_list_get_level+0x24>
42002a1b:	b75b00        	lsi	f0, a11, 0x2dc
        if (strcmp(tag, it->tag) == 0) {
42002a1e:	02ad      	mov.n	a10, a2
42002a20:	f68b81        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
42002a23:	0008e0        	callx8	a8
42002a26:	8acc      	bnez.n	a10, 42002a32 <esp_log_linked_list_get_level+0x22>
            *level = it->level;
42002a28:	040782        	l8ui	a8, a7, 4
42002a2b:	0389      	s32i.n	a8, a3, 0
            return true;
42002a2d:	120c      	movi.n	a2, 1
42002a2f:	000186        	j	42002a39 <esp_log_linked_list_get_level+0x29>
    SLIST_FOREACH(it, &s_log_tags, entries) {
42002a32:	0778      	l32i.n	a7, a7, 0
42002a34:	fe4756        	bnez	a7, 42002a1c <esp_log_linked_list_get_level+0xc>
        }
    }
    return false;
42002a37:	020c      	movi.n	a2, 0
}
42002a39:	f01d      	retw.n
	...

42002a3c <fix_cache_generation_overflow>:
        fix_cache_generation_overflow();
    }
}

static void fix_cache_generation_overflow(void)
{
42002a3c:	004136        	entry	a1, 32
    // Fix generation count wrap
    for (uint32_t i = 0; i < s_log_cache_entry_count; ++i) {
42002a3f:	090c      	movi.n	a9, 0
42002a41:	000506        	j	42002a59 <fix_cache_generation_overflow+0x1d>
        s_log_cache[i].generation = i;
42002a44:	11b9d0        	slli	a11, a9, 3
42002a47:	f682a1        	l32r	a10, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002a4a:	b0a9a0        	addx8	a10, a9, a10
42002a4d:	1a88      	l32i.n	a8, a10, 4
42002a4f:	248080        	extui	a8, a8, 0, 3
42002a52:	2088b0        	or	a8, a8, a11
42002a55:	1a89      	s32i.n	a8, a10, 4
    for (uint32_t i = 0; i < s_log_cache_entry_count; ++i) {
42002a57:	991b      	addi.n	a9, a9, 1
42002a59:	f67e81        	l32r	a8, 42000454 <_stext+0x434> (3fc94acc <s_log_cache_entry_count>)
42002a5c:	0888      	l32i.n	a8, a8, 0
42002a5e:	e23987        	bltu	a9, a8, 42002a44 <fix_cache_generation_overflow+0x8>
    }
    s_log_cache_max_generation = s_log_cache_entry_count;
42002a61:	f67d91        	l32r	a9, 42000458 <_stext+0x438> (3fc94ad0 <s_log_cache_max_generation>)
42002a64:	0989      	s32i.n	a8, a9, 0
}
42002a66:	f01d      	retw.n

42002a68 <heap_swap>:
        index = next;
    }
}

static inline void heap_swap(int i, int j)
{
42002a68:	006136        	entry	a1, 48
    cached_tag_entry_t tmp = s_log_cache[i];
42002a6b:	f679a1        	l32r	a10, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002a6e:	b022a0        	addx8	a2, a2, a10
42002a71:	0298      	l32i.n	a9, a2, 0
42002a73:	1288      	l32i.n	a8, a2, 4
42002a75:	0199      	s32i.n	a9, a1, 0
42002a77:	1189      	s32i.n	a8, a1, 4
    s_log_cache[i] = s_log_cache[j];
42002a79:	b033a0        	addx8	a3, a3, a10
42002a7c:	03b8      	l32i.n	a11, a3, 0
42002a7e:	13a8      	l32i.n	a10, a3, 4
42002a80:	02b9      	s32i.n	a11, a2, 0
42002a82:	12a9      	s32i.n	a10, a2, 4
    s_log_cache[j] = tmp;
42002a84:	0399      	s32i.n	a9, a3, 0
42002a86:	1389      	s32i.n	a8, a3, 4
}
42002a88:	f01d      	retw.n
	...

42002a8c <heap_bubble_down>:
{
42002a8c:	004136        	entry	a1, 32
42002a8f:	02ad      	mov.n	a10, a2
    while (index < TAG_CACHE_SIZE / 2) {
42002a91:	000a86        	j	42002abf <heap_bubble_down+0x33>
        int left_index = index * 2 + 1;
42002a94:	baaa      	add.n	a11, a10, a10
42002a96:	bb1b      	addi.n	a11, a11, 1
        int right_index = left_index + 1;
42002a98:	8a1b      	addi.n	a8, a10, 1
42002a9a:	788a      	add.n	a7, a8, a8
        int next = (s_log_cache[left_index].generation < s_log_cache[right_index].generation) ? left_index : right_index;
42002a9c:	f66d91        	l32r	a9, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002a9f:	b0cb90        	addx8	a12, a11, a9
42002aa2:	1cc8      	l32i.n	a12, a12, 4
42002aa4:	41c3c0        	srli	a12, a12, 3
42002aa7:	1188c0        	slli	a8, a8, 4
42002aaa:	998a      	add.n	a9, a9, a8
42002aac:	1988      	l32i.n	a8, a9, 4
42002aae:	418380        	srli	a8, a8, 3
42002ab1:	01bc87        	bgeu	a12, a8, 42002ab6 <heap_bubble_down+0x2a>
42002ab4:	0b7d      	mov.n	a7, a11
        heap_swap(index, next);
42002ab6:	20b770        	or	a11, a7, a7
42002ab9:	fffae5        	call8	42002a68 <heap_swap>
        index = next;
42002abc:	20a770        	or	a10, a7, a7
    while (index < TAG_CACHE_SIZE / 2) {
42002abf:	0ea082        	movi	a8, 14
42002ac2:	cea8a7        	bge	a8, a10, 42002a94 <heap_bubble_down+0x8>
}
42002ac5:	f01d      	retw.n
	...

42002ac8 <esp_log_cache_get_level>:
{
42002ac8:	004136        	entry	a1, 32
    for (i = 0; i < s_log_cache_entry_count; ++i) {
42002acb:	0a0c      	movi.n	a10, 0
42002acd:	000f06        	j	42002b0d <esp_log_cache_get_level+0x45>
42002ad0:	baac00        	ceil.s	a10, f12, 0
        assert(i == 0 || s_log_cache[(i - 1) / 2].generation < s_log_cache[i].generation);
42002ad3:	8a0b      	addi.n	a8, a10, -1
42002ad5:	418180        	srli	a8, a8, 1
42002ad8:	f65eb1        	l32r	a11, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002adb:	b088b0        	addx8	a8, a8, a11
42002ade:	18c8      	l32i.n	a12, a8, 4
42002ae0:	41c3c0        	srli	a12, a12, 3
42002ae3:	b0bab0        	addx8	a11, a10, a11
42002ae6:	1b88      	l32i.n	a8, a11, 4
42002ae8:	418380        	srli	a8, a8, 3
42002aeb:	113c87        	bltu	a12, a8, 42002b00 <esp_log_cache_get_level+0x38>
42002aee:	f65bd1        	l32r	a13, 4200045c <_stext+0x43c> (3c0227c0 <_flash_rodata_start+0x26a0>)
42002af1:	f65bc1        	l32r	a12, 42000460 <_stext+0x440> (3c0279ac <__func__$0>)
42002af4:	63a0b2        	movi	a11, 99
42002af7:	f65ba1        	l32r	a10, 42000464 <_stext+0x444> (3c022843 <_flash_rodata_start+0x2723>)
42002afa:	f57181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42002afd:	0008e0        	callx8	a8
        if (s_log_cache[i].tag == tag) {
42002b00:	f65481        	l32r	a8, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002b03:	b08a80        	addx8	a8, a10, a8
42002b06:	0888      	l32i.n	a8, a8, 0
42002b08:	091827        	beq	a8, a2, 42002b15 <esp_log_cache_get_level+0x4d>
    for (i = 0; i < s_log_cache_entry_count; ++i) {
42002b0b:	aa1b      	addi.n	a10, a10, 1
42002b0d:	f65181        	l32r	a8, 42000454 <_stext+0x434> (3fc94acc <s_log_cache_entry_count>)
42002b10:	0898      	l32i.n	a9, a8, 0
42002b12:	bb3a97        	bltu	a10, a9, 42002ad1 <esp_log_cache_get_level+0x9>
    if (i == s_log_cache_entry_count) { // Not found in cache
42002b15:	0f99a7        	bne	a9, a10, 42002b28 <esp_log_cache_get_level+0x60>
        ++s_log_cache_misses;
42002b18:	f65491        	l32r	a9, 42000468 <_stext+0x448> (3fc94ac8 <s_log_cache_misses>)
42002b1b:	0988      	l32i.n	a8, a9, 0
42002b1d:	881b      	addi.n	a8, a8, 1
42002b1f:	0989      	s32i.n	a8, a9, 0
        return false;
42002b21:	020c      	movi.n	a2, 0
42002b23:	0013c6        	j	42002b76 <esp_log_cache_get_level+0xae>
42002b26:	810000        	src	a0, a0, a0
    *level = (esp_log_level_t) s_log_cache[i].level;
42002b29:	f64a      	add.n	a15, a6, a4
42002b2b:	b08a80        	addx8	a8, a10, a8
42002b2e:	012882        	l32i	a8, a8, 4
42002b31:	248080        	extui	a8, a8, 0, 3
42002b34:	006382        	s32i	a8, a3, 0
    if (s_log_cache_entry_count == TAG_CACHE_SIZE) {
42002b37:	f81c      	movi.n	a8, 31
42002b39:	319987        	bne	a9, a8, 42002b6e <esp_log_cache_get_level+0xa6>
        s_log_cache[i].generation = s_log_cache_max_generation++;
42002b3c:	f64731        	l32r	a3, 42000458 <_stext+0x438> (3fc94ad0 <s_log_cache_max_generation>)
42002b3f:	0388      	l32i.n	a8, a3, 0
42002b41:	981b      	addi.n	a9, a8, 1
42002b43:	0399      	s32i.n	a9, a3, 0
42002b45:	f64921        	l32r	a2, 4200046c <_stext+0x44c> (1fffffff <UserFrameTotalSize+0x1ffffeff>)
42002b48:	108820        	and	a8, a8, a2
42002b4b:	f641b1        	l32r	a11, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002b4e:	b0bab0        	addx8	a11, a10, a11
42002b51:	1188d0        	slli	a8, a8, 3
42002b54:	1b98      	l32i.n	a9, a11, 4
42002b56:	249090        	extui	a9, a9, 0, 3
42002b59:	208980        	or	a8, a9, a8
42002b5c:	1b89      	s32i.n	a8, a11, 4
        heap_bubble_down(i);
42002b5e:	fff2e5        	call8	42002a8c <heap_bubble_down>
        if (s_log_cache_max_generation == MAX_GENERATION) {
42002b61:	0388      	l32i.n	a8, a3, 0
42002b63:	0d9827        	bne	a8, a2, 42002b74 <esp_log_cache_get_level+0xac>
            fix_cache_generation_overflow();
42002b66:	ffed65        	call8	42002a3c <fix_cache_generation_overflow>
    return true;
42002b69:	120c      	movi.n	a2, 1
42002b6b:	0001c6        	j	42002b76 <esp_log_cache_get_level+0xae>
42002b6e:	120c      	movi.n	a2, 1
42002b70:	000086        	j	42002b76 <esp_log_cache_get_level+0xae>
42002b73:	120c00        	andbc	b0, b12, b0
}
42002b76:	f01d      	retw.n

42002b78 <esp_log_cache_add>:
{
42002b78:	004136        	entry	a1, 32
    uint32_t generation = s_log_cache_max_generation++;
42002b7b:	f63781        	l32r	a8, 42000458 <_stext+0x438> (3fc94ad0 <s_log_cache_max_generation>)
42002b7e:	0898      	l32i.n	a9, a8, 0
42002b80:	a91b      	addi.n	a10, a9, 1
42002b82:	08a9      	s32i.n	a10, a8, 0
    if (s_log_cache_entry_count < TAG_CACHE_SIZE) {
42002b84:	f63481        	l32r	a8, 42000454 <_stext+0x434> (3fc94acc <s_log_cache_entry_count>)
42002b87:	08b8      	l32i.n	a11, a8, 0
42002b89:	e81c      	movi.n	a8, 30
42002b8b:	2e38b7        	bltu	a8, a11, 42002bbd <esp_log_cache_add+0x45>
        s_log_cache[s_log_cache_entry_count] = (cached_tag_entry_t) {
42002b8e:	f630a1        	l32r	a10, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002b91:	b0aba0        	addx8	a10, a11, a10
42002b94:	0a29      	s32i.n	a2, a10, 0
42002b96:	243030        	extui	a3, a3, 0, 3
42002b99:	1a88      	l32i.n	a8, a10, 4
42002b9b:	8c7c      	movi.n	a12, -8
42002b9d:	1088c0        	and	a8, a8, a12
42002ba0:	208830        	or	a8, a8, a3
42002ba3:	1a89      	s32i.n	a8, a10, 4
42002ba5:	1199d0        	slli	a9, a9, 3
42002ba8:	248080        	extui	a8, a8, 0, 3
42002bab:	208890        	or	a8, a8, a9
42002bae:	1a89      	s32i.n	a8, a10, 4
        ++s_log_cache_entry_count;
42002bb0:	bb1b      	addi.n	a11, a11, 1
42002bb2:	f62881        	l32r	a8, 42000454 <_stext+0x434> (3fc94acc <s_log_cache_entry_count>)
42002bb5:	08b9      	s32i.n	a11, a8, 0
42002bb7:	000a06        	j	42002be3 <esp_log_cache_add+0x6b>
42002bba:	000000        	ill
        s_log_cache[0] = (cached_tag_entry_t) {
42002bbd:	f624a1        	l32r	a10, 42000450 <_stext+0x430> (3fc94ad4 <s_log_cache>)
42002bc0:	006a22        	s32i	a2, a10, 0
42002bc3:	243030        	extui	a3, a3, 0, 3
42002bc6:	012a82        	l32i	a8, a10, 4
42002bc9:	8b7c      	movi.n	a11, -8
42002bcb:	1088b0        	and	a8, a8, a11
42002bce:	208830        	or	a8, a8, a3
42002bd1:	1a89      	s32i.n	a8, a10, 4
42002bd3:	1199d0        	slli	a9, a9, 3
42002bd6:	248080        	extui	a8, a8, 0, 3
42002bd9:	208890        	or	a8, a8, a9
42002bdc:	1a89      	s32i.n	a8, a10, 4
        heap_bubble_down(0);
42002bde:	0a0c      	movi.n	a10, 0
42002be0:	ffeaa5        	call8	42002a8c <heap_bubble_down>
    if (s_log_cache_max_generation == MAX_GENERATION) {
42002be3:	f61d81        	l32r	a8, 42000458 <_stext+0x438> (3fc94ad0 <s_log_cache_max_generation>)
42002be6:	0898      	l32i.n	a9, a8, 0
42002be8:	f62181        	l32r	a8, 4200046c <_stext+0x44c> (1fffffff <UserFrameTotalSize+0x1ffffeff>)
42002beb:	029987        	bne	a9, a8, 42002bf1 <esp_log_cache_add+0x79>
        fix_cache_generation_overflow();
42002bee:	ffe4e5        	call8	42002a3c <fix_cache_generation_overflow>
}
42002bf1:	f01d      	retw.n
	...

42002bf4 <heap_caps_get_info>:
    return ESP_OK;
}


void heap_caps_get_info( multi_heap_info_t *info, uint32_t caps )
{
42002bf4:	008136        	entry	a1, 64
    memset(info, 0, sizeof(multi_heap_info_t));
42002bf7:	cc1c      	movi.n	a12, 28
42002bf9:	0b0c      	movi.n	a11, 0
42002bfb:	20a220        	or	a10, a2, a2
42002bfe:	f5c081        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42002c01:	0008e0        	callx8	a8

    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002c04:	f61b81        	l32r	a8, 42000470 <_stext+0x450> (3fc94bd4 <registered_heaps>)
42002c07:	0878      	l32i.n	a7, a8, 0
42002c09:	001346        	j	42002c5a <heap_caps_get_info+0x66>
42002c0c:	bd0000        	lsi	f0, a0, 0x2f4
        if (heap_caps_match(heap, caps)) {
42002c0f:	07ad03        	lsi	f0, a13, 28
42002c12:	12c325        	call8	42015844 <heap_caps_match>
42002c15:	03fa16        	beqz	a10, 42002c58 <heap_caps_get_info+0x64>
            multi_heap_info_t hinfo;
            multi_heap_get_info(heap->heap, &hinfo);
42002c18:	01bd      	mov.n	a11, a1
42002c1a:	77a8      	l32i.n	a10, a7, 28
42002c1c:	1407a5        	call8	42016c98 <multi_heap_get_info>

            info->total_free_bytes += hinfo.total_free_bytes - MULTI_HEAP_BLOCK_OWNER_SIZE();
42002c1f:	0288      	l32i.n	a8, a2, 0
42002c21:	0198      	l32i.n	a9, a1, 0
42002c23:	889a      	add.n	a8, a8, a9
42002c25:	0289      	s32i.n	a8, a2, 0
            info->total_allocated_bytes += (hinfo.total_allocated_bytes -
42002c27:	1288      	l32i.n	a8, a2, 4
42002c29:	1198      	l32i.n	a9, a1, 4
42002c2b:	889a      	add.n	a8, a8, a9
42002c2d:	1289      	s32i.n	a8, a2, 4
                                           hinfo.allocated_blocks * MULTI_HEAP_BLOCK_OWNER_SIZE());
            info->largest_free_block = MAX(info->largest_free_block,
42002c2f:	2298      	l32i.n	a9, a2, 8
42002c31:	2188      	l32i.n	a8, a1, 8
42002c33:	738890        	maxu	a8, a8, a9
42002c36:	2289      	s32i.n	a8, a2, 8
                                           hinfo.largest_free_block);
            info->largest_free_block -= info->largest_free_block ? MULTI_HEAP_BLOCK_OWNER_SIZE() : 0;
            info->minimum_free_bytes += hinfo.minimum_free_bytes - MULTI_HEAP_BLOCK_OWNER_SIZE();
42002c38:	3288      	l32i.n	a8, a2, 12
42002c3a:	3198      	l32i.n	a9, a1, 12
42002c3c:	889a      	add.n	a8, a8, a9
42002c3e:	3289      	s32i.n	a8, a2, 12
            info->allocated_blocks += hinfo.allocated_blocks;
42002c40:	4288      	l32i.n	a8, a2, 16
42002c42:	4198      	l32i.n	a9, a1, 16
42002c44:	889a      	add.n	a8, a8, a9
42002c46:	4289      	s32i.n	a8, a2, 16
            info->free_blocks += hinfo.free_blocks;
42002c48:	5288      	l32i.n	a8, a2, 20
42002c4a:	5198      	l32i.n	a9, a1, 20
42002c4c:	889a      	add.n	a8, a8, a9
42002c4e:	5289      	s32i.n	a8, a2, 20
            info->total_blocks += hinfo.total_blocks;
42002c50:	6288      	l32i.n	a8, a2, 24
42002c52:	6198      	l32i.n	a9, a1, 24
42002c54:	889a      	add.n	a8, a8, a9
42002c56:	6289      	s32i.n	a8, a2, 24
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002c58:	8778      	l32i.n	a7, a7, 32
42002c5a:	fb0756        	bnez	a7, 42002c0e <heap_caps_get_info+0x1a>
        }
    }
}
42002c5d:	f01d      	retw.n
	...

42002c60 <heap_caps_get_largest_free_block>:
{
42002c60:	008136        	entry	a1, 64
42002c63:	20b220        	or	a11, a2, a2
    heap_caps_get_info(&info, caps);
42002c66:	20a110        	or	a10, a1, a1
42002c69:	fff8a5        	call8	42002bf4 <heap_caps_get_info>
}
42002c6c:	022122        	l32i	a2, a1, 8
42002c6f:	f01d      	retw.n
42002c71:	000000        	ill

42002c74 <sorted_add_to_registered_heaps>:
 *
 * @param new_heap heap to be inserted in the list of registered
 * heaps
 */
static void sorted_add_to_registered_heaps(heap_t *new_heap)
{
42002c74:	004136        	entry	a1, 32
    // if list empty, insert head and return
    if (SLIST_EMPTY(&registered_heaps)) {
42002c77:	f5fe81        	l32r	a8, 42000470 <_stext+0x450> (3fc94bd4 <registered_heaps>)
42002c7a:	08d8      	l32i.n	a13, a8, 0
42002c7c:	5dcc      	bnez.n	a13, 42002c85 <sorted_add_to_registered_heaps+0x11>
        SLIST_INSERT_HEAD(&registered_heaps, new_heap, next);
42002c7e:	82d9      	s32i.n	a13, a2, 32
42002c80:	0829      	s32i.n	a2, a8, 0
        return;
42002c82:	000ec6        	j	42002cc1 <sorted_add_to_registered_heaps+0x4d>

    // else, go through the registered heaps and add the new one
    // so the registered heaps are sorted by increasing heap size.
    heap_t *cur_heap = NULL;
    heap_t *prev_heap = NULL;
    const size_t new_heap_size = new_heap->end - new_heap->start;
42002c85:	42b8      	l32i.n	a11, a2, 16
42002c87:	3288      	l32i.n	a8, a2, 12
42002c89:	c0bb80        	sub	a11, a11, a8
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002c8c:	0d8d      	mov.n	a8, a13
    heap_t *prev_heap = NULL;
42002c8e:	0c0c      	movi.n	a12, 0
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002c90:	000906        	j	42002cb8 <sorted_add_to_registered_heaps+0x44>
42002c93:	489800        	ssx	f9, a8, a0
        const size_t cur_heap_size = cur_heap->end - cur_heap->start;
42002c96:	38a8      	l32i.n	a10, a8, 12
42002c98:	c099a0        	sub	a9, a9, a10
        if (cur_heap_size >= new_heap_size) {
42002c9b:	1539b7        	bltu	a9, a11, 42002cb4 <sorted_add_to_registered_heaps+0x40>
            if (prev_heap != NULL) {
42002c9e:	7c8c      	beqz.n	a12, 42002ca9 <sorted_add_to_registered_heaps+0x35>
                SLIST_INSERT_AFTER(prev_heap, new_heap, next);
42002ca0:	8c88      	l32i.n	a8, a12, 32
42002ca2:	8289      	s32i.n	a8, a2, 32
42002ca4:	8c29      	s32i.n	a2, a12, 32
42002ca6:	0005c6        	j	42002cc1 <sorted_add_to_registered_heaps+0x4d>
            } else {
                SLIST_INSERT_HEAD(&registered_heaps, new_heap, next);
42002ca9:	82d9      	s32i.n	a13, a2, 32
42002cab:	f5f181        	l32r	a8, 42000470 <_stext+0x450> (3fc94bd4 <registered_heaps>)
42002cae:	0829      	s32i.n	a2, a8, 0
            }
            return;
42002cb0:	000346        	j	42002cc1 <sorted_add_to_registered_heaps+0x4d>
42002cb3:	08cd00        	lsx	f12, a13, a0
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002cb6:	8888      	l32i.n	a8, a8, 32
42002cb8:	fd8856        	bnez	a8, 42002c94 <sorted_add_to_registered_heaps+0x20>
        }
        prev_heap = cur_heap;
    }

    // new heap size if the biggest so far, insert it at the end
    SLIST_INSERT_AFTER(prev_heap, new_heap, next);
42002cbb:	8c88      	l32i.n	a8, a12, 32
42002cbd:	8289      	s32i.n	a8, a2, 32
42002cbf:	8c29      	s32i.n	a2, a12, 32
}
42002cc1:	f01d      	retw.n
	...

42002cc4 <register_heap>:

static void register_heap(heap_t *region)
{
42002cc4:	004136        	entry	a1, 32
    size_t heap_size = region->end - region->start;
42002cc7:	42b8      	l32i.n	a11, a2, 16
42002cc9:	32a8      	l32i.n	a10, a2, 12
42002ccb:	c0bba0        	sub	a11, a11, a10
    assert(heap_size <= HEAP_SIZE_MAX);
42002cce:	f5e981        	l32r	a8, 42000474 <_stext+0x454> (2000000 <UserFrameTotalSize+0x1ffff00>)
42002cd1:	10b8b7        	bgeu	a8, a11, 42002ce5 <register_heap+0x21>
42002cd4:	f5e9d1        	l32r	a13, 42000478 <_stext+0x458> (3c022888 <_flash_rodata_start+0x2768>)
42002cd7:	f5e9c1        	l32r	a12, 4200047c <_stext+0x45c> (3c027a5c <__func__$3>)
42002cda:	6b4c      	movi.n	a11, 70
42002cdc:	f5e9a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002cdf:	f4f881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42002ce2:	0008e0        	callx8	a8
    region->heap = multi_heap_register((void *)region->start, heap_size);
42002ce5:	13f625        	call8	42016c48 <multi_heap_register>
42002ce8:	72a9      	s32i.n	a10, a2, 28
    if (region->heap != NULL) {
        ESP_EARLY_LOGD(TAG, "New heap initialised at %p", region->heap);
    }
}
42002cea:	f01d      	retw.n

42002cec <heap_caps_enable_nonos_stack_heaps>:

void heap_caps_enable_nonos_stack_heaps(void)
{
42002cec:	004136        	entry	a1, 32
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002cef:	f5e081        	l32r	a8, 42000470 <_stext+0x450> (3fc94bd4 <registered_heaps>)
42002cf2:	0878      	l32i.n	a7, a8, 0
42002cf4:	0006c6        	j	42002d13 <heap_caps_enable_nonos_stack_heaps+0x27>
42002cf7:	278200        	lsi	f0, a2, 156
        // Assume any not-yet-registered heap is
        // a nonos-stack heap
        if (heap->heap == NULL) {
42002cfa:	285607        	bbc	a6, a0, 42002d26 <heap_caps_init+0xe>
42002cfd:	a77001        	l32r	a0, 41fecac0 <_coredump_iram_end+0x1c6aac0>
            register_heap(heap);
42002d00:	fc2520        	lsi	f2, a5, 0x3f0
42002d03:	ff          	.byte	0xff
            if (heap->heap != NULL) {
42002d04:	77a8      	l32i.n	a10, a7, 28
42002d06:	7a8c      	beqz.n	a10, 42002d11 <heap_caps_enable_nonos_stack_heaps+0x25>
                multi_heap_set_lock(heap->heap, &heap->heap_mux);
42002d08:	14c7b2        	addi	a11, a7, 20
42002d0b:	f5de81        	l32r	a8, 42000484 <_stext+0x464> (4037e810 <multi_heap_set_lock>)
42002d0e:	0008e0        	callx8	a8
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002d11:	8778      	l32i.n	a7, a7, 32
42002d13:	fe1756        	bnez	a7, 42002cf8 <heap_caps_enable_nonos_stack_heaps+0xc>
            }
        }
    }
}
42002d16:	f01d      	retw.n

42002d18 <heap_caps_init>:

/* Initialize the heap allocator to use all of the memory not
   used by static data or reserved for other purposes
 */
void heap_caps_init(void)
{
42002d18:	00a136        	entry	a1, 80
42002d1b:	207110        	or	a7, a1, a1
    multi_heap_in_rom_init();
#endif
    /* Get the array of regions that we can use for heaps
       (with reserved memory removed already.)
     */
    size_t num_regions = soc_get_available_memory_region_max_count();
42002d1e:	003725        	call8	42003090 <soc_get_available_memory_region_max_count>
    soc_memory_region_t regions[num_regions];
42002d21:	a08aa0        	addx4	a8, a10, a10
42002d24:	1188e0        	slli	a8, a8, 2
42002d27:	0fc882        	addi	a8, a8, 15
42002d2a:	418480        	srli	a8, a8, 4
42002d2d:	1188c0        	slli	a8, a8, 4
42002d30:	c08180        	sub	a8, a1, a8
42002d33:	001810        	movsp	a1, a8
42002d36:	13c152        	addi	a5, a1, 19
42002d39:	415250        	srli	a5, a5, 2
42002d3c:	1155e0        	slli	a5, a5, 2
    num_regions = soc_get_available_memory_regions(regions);
42002d3f:	20a550        	or	a10, a5, a5
42002d42:	003625        	call8	420030a4 <soc_get_available_memory_regions>
42002d45:	0acd      	mov.n	a12, a10
42002d47:	87a9      	s32i.n	a10, a7, 32

    // the following for loop will calculate the number of possible heaps
    // based on how many regions were coalesced.
    size_t num_heaps = num_regions;
42002d49:	67a9      	s32i.n	a10, a7, 24

    //The heap allocator will treat every region given to it as separate. In order to get bigger ranges of contiguous memory,
    //it's useful to coalesce adjacent regions that have the same type.
    for (size_t i = 1; i < num_regions; i++) {
42002d4b:	180c      	movi.n	a8, 1
42002d4d:	001886        	j	42002db3 <heap_caps_init+0x9b>
42002d50:	a80b00        	lsi	f0, a11, 0x2a0
        soc_memory_region_t *a = &regions[i - 1];
        soc_memory_region_t *b = &regions[i];
        if (b->start == (intptr_t)(a->start + a->size) && b->type == a->type && b->startup_stack == a->startup_stack ) {
42002d53:	a09880        	addx4	a9, a8, a8
42002d56:	a09950        	addx4	a9, a9, a5
42002d59:	09e8      	l32i.n	a14, a9, 0
42002d5b:	a09aa0        	addx4	a9, a10, a10
42002d5e:	a09950        	addx4	a9, a9, a5
42002d61:	09b8      	l32i.n	a11, a9, 0
42002d63:	1998      	l32i.n	a9, a9, 4
42002d65:	db9a      	add.n	a13, a11, a9
42002d67:	469ed7        	bne	a14, a13, 42002db1 <heap_caps_init+0x99>
42002d6a:	a0d880        	addx4	a13, a8, a8
42002d6d:	a0dd50        	addx4	a13, a13, a5
42002d70:	2de8      	l32i.n	a14, a13, 8
42002d72:	a0daa0        	addx4	a13, a10, a10
42002d75:	a0dd50        	addx4	a13, a13, a5
42002d78:	2dd8      	l32i.n	a13, a13, 8
42002d7a:	339ed7        	bne	a14, a13, 42002db1 <heap_caps_init+0x99>
42002d7d:	a0d880        	addx4	a13, a8, a8
42002d80:	a0dd50        	addx4	a13, a13, a5
42002d83:	100de2        	l8ui	a14, a13, 16
42002d86:	a0daa0        	addx4	a13, a10, a10
42002d89:	a0dd50        	addx4	a13, a13, a5
42002d8c:	100dd2        	l8ui	a13, a13, 16
42002d8f:	1e9ed7        	bne	a14, a13, 42002db1 <heap_caps_init+0x99>
            a->type = -1;
42002d92:	a0aaa0        	addx4	a10, a10, a10
42002d95:	a0aa50        	addx4	a10, a10, a5
42002d98:	fd7c      	movi.n	a13, -1
42002d9a:	2ad9      	s32i.n	a13, a10, 8
            b->start = a->start;
42002d9c:	a0a880        	addx4	a10, a8, a8
42002d9f:	a0aa50        	addx4	a10, a10, a5
42002da2:	0ab9      	s32i.n	a11, a10, 0
            b->size += a->size;
42002da4:	1ab8      	l32i.n	a11, a10, 4
42002da6:	99ba      	add.n	a9, a9, a11
42002da8:	1a99      	s32i.n	a9, a10, 4

            // remove one heap from the number of heaps as
            // 2 regions just got coalesced.
            num_heaps--;
42002daa:	6798      	l32i.n	a9, a7, 24
42002dac:	8099d0        	add	a9, a9, a13
42002daf:	6799      	s32i.n	a9, a7, 24
    for (size_t i = 1; i < num_regions; i++) {
42002db1:	881b      	addi.n	a8, a8, 1
42002db3:	9a38c7        	bltu	a8, a12, 42002d51 <heap_caps_init+0x39>

    /* Start by allocating the registered heap data on the stack.

       Once we have a heap to copy it to, we will copy it to a heap buffer.
    */
    heap_t temp_heaps[num_heaps];
42002db6:	6788      	l32i.n	a8, a7, 24
42002db8:	b08880        	addx8	a8, a8, a8
42002dbb:	1128e0        	slli	a2, a8, 2
42002dbe:	0fc282        	addi	a8, a2, 15
42002dc1:	418480        	srli	a8, a8, 4
42002dc4:	1188c0        	slli	a8, a8, 4
42002dc7:	c08180        	sub	a8, a1, a8
42002dca:	001810        	movsp	a1, a8
42002dcd:	13c182        	addi	a8, a1, 19
42002dd0:	418280        	srli	a8, a8, 2
42002dd3:	1138e0        	slli	a3, a8, 2
42002dd6:	f49581        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42002dd9:	002882        	l32i	a8, a8, 0
    size_t heap_idx = 0;

    ESP_EARLY_LOGI(TAG, "Initializing. RAM available for dynamic allocation:");
42002ddc:	0238f6        	bgeui	a8, 3, 42002de2 <heap_caps_init+0xca>
42002ddf:	0046c6        	j	42002efe <heap_caps_init+0x1e6>
42002de2:	f49f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42002de5:	0008e0        	callx8	a8
42002de8:	f5a8c1        	l32r	a12, 42000488 <_stext+0x468> (3c0228cc <_flash_rodata_start+0x27ac>)
42002deb:	0abd      	mov.n	a11, a10
42002ded:	f5a7a1        	l32r	a10, 4200048c <_stext+0x46c> (3c0228d8 <_flash_rodata_start+0x27b8>)
42002df0:	f49d81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42002df3:	0008e0        	callx8	a8
42002df6:	004106        	j	42002efe <heap_caps_init+0x1e6>
    for (size_t i = 0; i < num_regions; i++) {
        soc_memory_region_t *region = &regions[i];
        const soc_memory_type_desc_t *type = &soc_memory_types[region->type];
42002df9:	a08440        	addx4	a8, a4, a4
42002dfc:	a08850        	addx4	a8, a8, a5
42002dff:	2828      	l32i.n	a2, a8, 8
        heap_t *heap = &temp_heaps[heap_idx];
42002e01:	b08660        	addx8	a8, a6, a6
42002e04:	a08830        	addx4	a8, a8, a3
42002e07:	7789      	s32i.n	a8, a7, 28
        if (region->type == -1) {
42002e09:	100266        	bnei	a2, -1, 42002e1d <heap_caps_init+0x105>
            memset(heap, 0, sizeof(*heap));
42002e0c:	4c2c      	movi.n	a12, 36
42002e0e:	0b0c      	movi.n	a11, 0
42002e10:	08ad      	mov.n	a10, a8
42002e12:	f53b81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42002e15:	0008e0        	callx8	a8
            continue;
42002e18:	5769      	s32i.n	a6, a7, 20
42002e1a:	003586        	j	42002ef4 <heap_caps_init+0x1dc>
        }
        heap_idx++;
42002e1d:	861b      	addi.n	a8, a6, 1
42002e1f:	5789      	s32i.n	a8, a7, 20
        assert(heap_idx <= num_heaps);
42002e21:	6798      	l32i.n	a9, a7, 24
42002e23:	11b987        	bgeu	a9, a8, 42002e38 <heap_caps_init+0x120>
42002e26:	f59ad1        	l32r	a13, 42000490 <_stext+0x470> (3c02291c <_flash_rodata_start+0x27fc>)
42002e29:	f59ac1        	l32r	a12, 42000494 <_stext+0x474> (3c027a4c <__func__$2>)
42002e2c:	91a0b2        	movi	a11, 145
42002e2f:	f594a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002e32:	f4a381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42002e35:	0008e0        	callx8	a8

        memcpy(heap->caps, type->caps, sizeof(heap->caps));
42002e38:	b08660        	addx8	a8, a6, a6
42002e3b:	a0a830        	addx4	a10, a8, a3
42002e3e:	11b2c0        	slli	a11, a2, 4
42002e41:	f59581        	l32r	a8, 42000498 <_stext+0x478> (3c027cbc <soc_memory_types>)
42002e44:	bb8a      	add.n	a11, a11, a8
42002e46:	cc0c      	movi.n	a12, 12
42002e48:	04cbb2        	addi	a11, a11, 4
42002e4b:	0467a2        	s32i	a10, a7, 16
42002e4e:	f47681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002e51:	0008e0        	callx8	a8
        heap->start = region->start;
42002e54:	a09440        	addx4	a9, a4, a4
42002e57:	a09950        	addx4	a9, a9, a5
42002e5a:	0988      	l32i.n	a8, a9, 0
42002e5c:	47a8      	l32i.n	a10, a7, 16
42002e5e:	3a89      	s32i.n	a8, a10, 12
        heap->end = region->start + region->size;
42002e60:	1998      	l32i.n	a9, a9, 4
42002e62:	889a      	add.n	a8, a8, a9
42002e64:	4a89      	s32i.n	a8, a10, 16
        MULTI_HEAP_LOCK_INIT(&heap->heap_mux);
42002e66:	1186d0        	slli	a8, a6, 3
42002e69:	886a      	add.n	a8, a8, a6
42002e6b:	1188e0        	slli	a8, a8, 2
42002e6e:	10c882        	addi	a8, a8, 16
42002e71:	838a      	add.n	a8, a3, a8
42002e73:	884b      	addi.n	a8, a8, 4
    assert(lock);
42002e75:	f8cc      	bnez.n	a8, 42002e88 <heap_caps_init+0x170>
42002e77:	f589d1        	l32r	a13, 4200049c <_stext+0x47c> (3c022934 <_flash_rodata_start+0x2814>)
42002e7a:	f589c1        	l32r	a12, 420004a0 <_stext+0x480> (3c027a38 <__func__$1>)
42002e7d:	5b3c      	movi.n	a11, 53
42002e7f:	f589a1        	l32r	a10, 420004a4 <_stext+0x484> (3c022964 <_flash_rodata_start+0x2844>)
42002e82:	f48f81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42002e85:	0008e0        	callx8	a8
    lock->owner = SPINLOCK_FREE;
42002e88:	b08660        	addx8	a8, a6, a6
42002e8b:	a08830        	addx4	a8, a8, a3
42002e8e:	f58691        	l32r	a9, 420004a8 <_stext+0x488> (b33fffff <_rtc_reserved_end+0x532fffff>)
42002e91:	5899      	s32i.n	a9, a8, 20
    lock->count = 0;
42002e93:	090c      	movi.n	a9, 0
42002e95:	6899      	s32i.n	a9, a8, 24
        if (region->startup_stack) {
42002e97:	a08440        	addx4	a8, a4, a4
42002e9a:	a08850        	addx4	a8, a8, a5
42002e9d:	100882        	l8ui	a8, a8, 16
42002ea0:	988c      	beqz.n	a8, 42002ead <heap_caps_init+0x195>
            /* Will be registered when OS scheduler starts */
            heap->heap = NULL;
42002ea2:	b08660        	addx8	a8, a6, a6
42002ea5:	a08830        	addx4	a8, a8, a3
42002ea8:	7899      	s32i.n	a9, a8, 28
42002eaa:	000146        	j	42002eb3 <heap_caps_init+0x19b>
        } else {
            register_heap(heap);
42002ead:	0727a2        	l32i	a10, a7, 28
42002eb0:	ffe125        	call8	42002cc4 <register_heap>
        }
        SLIST_NEXT(heap, next) = NULL;
42002eb3:	b06660        	addx8	a6, a6, a6
42002eb6:	a06630        	addx4	a6, a6, a3
42002eb9:	00a082        	movi	a8, 0
42002ebc:	086682        	s32i	a8, a6, 32
42002ebf:	f45b81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42002ec2:	0888      	l32i.n	a8, a8, 0

        ESP_EARLY_LOGI(TAG, "At %08X len %08X (%d KiB): %s",
42002ec4:	2c38b6        	bltui	a8, 3, 42002ef4 <heap_caps_init+0x1dc>
42002ec7:	f46681        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42002eca:	0008e0        	callx8	a8
42002ecd:	a08440        	addx4	a8, a4, a4
42002ed0:	a08850        	addx4	a8, a8, a5
42002ed3:	18e8      	l32i.n	a14, a8, 4
42002ed5:	1122c0        	slli	a2, a2, 4
42002ed8:	f57091        	l32r	a9, 42000498 <_stext+0x478> (3c027cbc <soc_memory_types>)
42002edb:	992a      	add.n	a9, a9, a2
42002edd:	0998      	l32i.n	a9, a9, 0
42002edf:	0199      	s32i.n	a9, a1, 0
42002ee1:	41fae0        	srli	a15, a14, 10
42002ee4:	08d8      	l32i.n	a13, a8, 0
42002ee6:	f568c1        	l32r	a12, 42000488 <_stext+0x468> (3c0228cc <_flash_rodata_start+0x27ac>)
42002ee9:	0abd      	mov.n	a11, a10
42002eeb:	f570a1        	l32r	a10, 420004ac <_stext+0x48c> (3c022970 <_flash_rodata_start+0x2850>)
42002eee:	f45d81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42002ef1:	0008e0        	callx8	a8
    for (size_t i = 0; i < num_regions; i++) {
42002ef4:	441b      	addi.n	a4, a4, 1
42002ef6:	5768      	l32i.n	a6, a7, 20
42002ef8:	000206        	j	42002f04 <heap_caps_init+0x1ec>
42002efb:	000000        	ill
            continue;
42002efe:	040c      	movi.n	a4, 0
42002f00:	046d      	mov.n	a6, a4
42002f02:	9729      	s32i.n	a2, a7, 36
    for (size_t i = 0; i < num_regions; i++) {
42002f04:	8788      	l32i.n	a8, a7, 32
42002f06:	02b487        	bgeu	a4, a8, 42002f0c <heap_caps_init+0x1f4>
42002f09:	ffbb06        	j	42002df9 <heap_caps_init+0xe1>
                       region->start, region->size, region->size / 1024, type->name);
    }

    assert(heap_idx == num_heaps);
42002f0c:	9728      	l32i.n	a2, a7, 36
42002f0e:	6788      	l32i.n	a8, a7, 24
42002f10:	111867        	beq	a8, a6, 42002f25 <heap_caps_init+0x20d>
42002f13:	f567d1        	l32r	a13, 420004b0 <_stext+0x490> (3c02299c <_flash_rodata_start+0x287c>)
42002f16:	f55fc1        	l32r	a12, 42000494 <_stext+0x474> (3c027a4c <__func__$2>)
42002f19:	a3a0b2        	movi	a11, 163
42002f1c:	f559a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002f1f:	f46881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42002f22:	0008e0        	callx8	a8

    /* Allocate the permanent heap data that we'll use as a linked list at runtime.

       Allocate this part of data contiguously, even though it's a linked list... */
    assert(SLIST_EMPTY(&registered_heaps));
42002f25:	f55281        	l32r	a8, 42000470 <_stext+0x450> (3fc94bd4 <registered_heaps>)
42002f28:	0888      	l32i.n	a8, a8, 0
42002f2a:	78bc      	beqz.n	a8, 42002f65 <heap_caps_init+0x24d>
42002f2c:	f562d1        	l32r	a13, 420004b4 <_stext+0x494> (3c0229b4 <_flash_rodata_start+0x2894>)
42002f2f:	f559c1        	l32r	a12, 42000494 <_stext+0x474> (3c027a4c <__func__$2>)
42002f32:	a8a0b2        	movi	a11, 168
42002f35:	f552a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002f38:	f46281        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42002f3b:	0008e0        	callx8	a8

    heap_t *heaps_array = NULL;
    for (size_t i = 0; i < num_heaps; i++) {
        if (heap_caps_match(&temp_heaps[i], MALLOC_CAP_8BIT|MALLOC_CAP_INTERNAL)) {
42002f3e:	b0a660        	addx8	a10, a6, a6
42002f41:	f55db1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42002f44:	a0aa30        	addx4	a10, a10, a3
42002f47:	128fe5        	call8	42015844 <heap_caps_match>
42002f4a:	2a9c      	beqz.n	a10, 42002f60 <heap_caps_init+0x248>
            /* use the first DRAM heap which can fit the data.
             * the allocated block won't include the block owner bytes since this operation
             * is done by the top level API heap_caps_malloc(). So we need to add it manually
             * after successful allocation. Allocate extra 4 bytes for that purpose. */
            heaps_array = multi_heap_malloc(temp_heaps[i].heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(sizeof(heap_t) * num_heaps));
42002f4c:	b08660        	addx8	a8, a6, a6
42002f4f:	a08830        	addx4	a8, a8, a3
42002f52:	02bd      	mov.n	a11, a2
42002f54:	78a8      	l32i.n	a10, a8, 28
42002f56:	f55a81        	l32r	a8, 420004c0 <_stext+0x4a0> (4037e74c <multi_heap_malloc>)
42002f59:	0008e0        	callx8	a8
42002f5c:	0a5d      	mov.n	a5, a10
            if (heaps_array != NULL) {
42002f5e:	cacc      	bnez.n	a10, 42002f6e <heap_caps_init+0x256>
    for (size_t i = 0; i < num_heaps; i++) {
42002f60:	661b      	addi.n	a6, a6, 1
42002f62:	000146        	j	42002f6b <heap_caps_init+0x253>
42002f65:	060c      	movi.n	a6, 0
    heap_t *heaps_array = NULL;
42002f67:	065d      	mov.n	a5, a6
42002f69:	6748      	l32i.n	a4, a7, 24
    for (size_t i = 0; i < num_heaps; i++) {
42002f6b:	cf3647        	bltu	a6, a4, 42002f3e <heap_caps_init+0x226>
                break;
            }
        }
    }
    assert(heaps_array != NULL); /* if NULL, there's not enough free startup heap space */
42002f6e:	05dc      	bnez.n	a5, 42002f82 <heap_caps_init+0x26a>
42002f70:	f553d1        	l32r	a13, 420004bc <_stext+0x49c> (3c0229d4 <_flash_rodata_start+0x28b4>)
42002f73:	f548c1        	l32r	a12, 42000494 <_stext+0x474> (3c027a4c <__func__$2>)
42002f76:	b7a0b2        	movi	a11, 183
42002f79:	f541a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002f7c:	f45181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42002f7f:	0008e0        	callx8	a8
    MULTI_HEAP_SET_BLOCK_OWNER(heaps_array);
    heaps_array = (heap_t *)MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(heaps_array);

    memcpy(heaps_array, temp_heaps, sizeof(heap_t)*num_heaps);
42002f82:	02cd      	mov.n	a12, a2
42002f84:	03bd      	mov.n	a11, a3
42002f86:	05ad      	mov.n	a10, a5
42002f88:	f42881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002f8b:	0008e0        	callx8	a8

    /* Iterate the heaps and set their locks, also add them to the linked list. */
    for (size_t i = 0; i < num_heaps; i++) {
42002f8e:	040c      	movi.n	a4, 0
42002f90:	6738      	l32i.n	a3, a7, 24
42002f92:	0006c6        	j	42002fb1 <heap_caps_init+0x299>
        if (heaps_array[i].heap != NULL) {
42002f95:	b06440        	addx8	a6, a4, a4
42002f98:	a06650        	addx4	a6, a6, a5
42002f9b:	76a8      	l32i.n	a10, a6, 28
42002f9d:	7a8c      	beqz.n	a10, 42002fa8 <heap_caps_init+0x290>
            multi_heap_set_lock(heaps_array[i].heap, &heaps_array[i].heap_mux);
42002f9f:	14c6b2        	addi	a11, a6, 20
42002fa2:	f53881        	l32r	a8, 42000484 <_stext+0x464> (4037e810 <multi_heap_set_lock>)
42002fa5:	0008e0        	callx8	a8
         * to tail when looking for a suitable heap when allocating memory, it is
         * best to place smaller heap first. In that way, if several heaps share
         * the same set of capabilities, the smallest heaps will be used first when
         * processing small allocation requests, leaving the bigger heaps untouched
         * until the smaller heaps are full. */
        sorted_add_to_registered_heaps(&heaps_array[i]);
42002fa8:	20a660        	or	a10, a6, a6
42002fab:	ffcca5        	call8	42002c74 <sorted_add_to_registered_heaps>
    for (size_t i = 0; i < num_heaps; i++) {
42002fae:	01c442        	addi	a4, a4, 1
42002fb1:	e03437        	bltu	a4, a3, 42002f95 <heap_caps_init+0x27d>
    }
}
42002fb4:	000090        	retw
	...

42002fb8 <__esp_system_init_fn_init_heap>:
{
42002fb8:	004136        	entry	a1, 32
    heap_caps_init();
42002fbb:	ffd5e5        	call8	42002d18 <heap_caps_init>
}
42002fbe:	020c      	movi.n	a2, 0
42002fc0:	f01d      	retw.n
	...

42002fc4 <s_get_num_reserved_regions>:
*/
extern soc_reserved_region_t soc_reserved_memory_region_start;
extern soc_reserved_region_t soc_reserved_memory_region_end;

static size_t s_get_num_reserved_regions(void)
{
42002fc4:	004136        	entry	a1, 32
    size_t result = ( &soc_reserved_memory_region_end
             - &soc_reserved_memory_region_start );
42002fc7:	f53f21        	l32r	a2, 420004c4 <_stext+0x4a4> (3c02a49c <esp_system_init_fn_init_efuse_check>)
42002fca:	f53f81        	l32r	a8, 420004c8 <_stext+0x4a8> (3c02a474 <reserved_region_rtc_reserved_data>)
42002fcd:	c02280        	sub	a2, a2, a8
42002fd0:	212320        	srai	a2, a2, 3
#if ESP_ROM_HAS_LAYOUT_TABLE
    return result + 1; // ROM table means one entry needs to be added at runtime
#else
    return result;
#endif
}
42002fd3:	221b      	addi.n	a2, a2, 1
42002fd5:	f01d      	retw.n
	...

42002fd8 <s_prepare_reserved_regions>:
/* Initialize a mutable array of reserved regions in 'reserved',
   then sort it by start address and check for overlapping
   reserved regions (illegal).
*/
static void s_prepare_reserved_regions(soc_reserved_region_t *reserved, size_t count)
{
42002fd8:	006136        	entry	a1, 48
#if ESP_ROM_HAS_LAYOUT_TABLE
    /* Get the ROM layout to find which part of DRAM is reserved */
    const ets_rom_layout_t *layout = ets_rom_layout_p;
42002fdb:	f53c81        	l32r	a8, 420004cc <_stext+0x4ac> (3ff1fffc <ets_rom_layout_p>)
42002fde:	0888      	l32i.n	a8, a8, 0
    reserved[0].start = (intptr_t)layout->dram0_rtos_reserved_start;
42002fe0:	1888      	l32i.n	a8, a8, 4
42002fe2:	0289      	s32i.n	a8, a2, 0
#ifdef SOC_DIRAM_ROM_RESERVE_HIGH
    reserved[0].end = SOC_DIRAM_ROM_RESERVE_HIGH;
#else
    reserved[0].end = SOC_DIRAM_DRAM_HIGH;
42002fe4:	f53b81        	l32r	a8, 420004d0 <_stext+0x4b0> (3fcf0000 <ets_ops_table_ptr+0x4>)
42002fe7:	1289      	s32i.n	a8, a2, 4
#endif

    memcpy(reserved + 1, &soc_reserved_memory_region_start, (count - 1) * sizeof(soc_reserved_region_t));
42002fe9:	630b      	addi.n	a6, a3, -1
42002feb:	11c6d0        	slli	a12, a6, 3
42002fee:	f536b1        	l32r	a11, 420004c8 <_stext+0x4a8> (3c02a474 <reserved_region_rtc_reserved_data>)
42002ff1:	a28b      	addi.n	a10, a2, 8
42002ff3:	f40d81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002ff6:	0008e0        	callx8	a8
#else
    memcpy(reserved, &soc_reserved_memory_region_start, count * sizeof(soc_reserved_region_t));
#endif

    /* Sort by starting address */
    qsort(reserved, count, sizeof(soc_reserved_region_t), s_compare_reserved_regions);
42002ff9:	f536d1        	l32r	a13, 420004d4 <_stext+0x4b4> (42015870 <s_compare_reserved_regions>)
42002ffc:	8c0c      	movi.n	a12, 8
42002ffe:	03bd      	mov.n	a11, a3
42003000:	02ad      	mov.n	a10, a2
42003002:	f53b81        	l32r	a8, 420004f0 <_stext+0x4d0> (40001488 <qsort>)
42003005:	0008e0        	callx8	a8
    /* Validity checks */
    ESP_EARLY_LOGV(TAG, "reserved range is %p - %p",
                   &soc_reserved_memory_region_start,
                   &soc_reserved_memory_region_end);
    ESP_EARLY_LOGD(TAG, "Checking %d reserved memory ranges:", count);
    for (size_t i = 0; i < count; i++) {
42003008:	0a0c      	movi.n	a10, 0
4200300a:	001e86        	j	42003088 <s_prepare_reserved_regions+0xb0>
        ESP_EARLY_LOGD(TAG, "Reserved memory range 0x%08x - 0x%08x",
                       reserved[i].start, reserved[i].end);
        reserved[i].start = reserved[i].start & ~3; /* expand all reserved areas to word boundaries */
4200300d:	b07a20        	addx8	a7, a10, a2
42003010:	0798      	l32i.n	a9, a7, 0
42003012:	cb7c      	movi.n	a11, -4
42003014:	1099b0        	and	a9, a9, a11
42003017:	0799      	s32i.n	a9, a7, 0
        reserved[i].end = (reserved[i].end + 3) & ~3;
42003019:	1788      	l32i.n	a8, a7, 4
4200301b:	883b      	addi.n	a8, a8, 3
4200301d:	1088b0        	and	a8, a8, a11
42003020:	016782        	s32i	a8, a7, 4
        assert(reserved[i].start <= reserved[i].end);
42003023:	11a897        	bge	a8, a9, 42003038 <s_prepare_reserved_regions+0x60>
42003026:	f52cd1        	l32r	a13, 420004d8 <_stext+0x4b8> (3c0231b4 <_flash_rodata_start+0x3094>)
42003029:	f52cc1        	l32r	a12, 420004dc <_stext+0x4bc> (3c027bd4 <__func__$0>)
4200302c:	56a0b2        	movi	a11, 86
4200302f:	f52ca1        	l32r	a10, 420004e0 <_stext+0x4c0> (3c0231f7 <_flash_rodata_start+0x30d7>)
42003032:	f42381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42003035:	0008e0        	callx8	a8
        if (i < count - 1) {
42003038:	4aba67        	bgeu	a10, a6, 42003086 <s_prepare_reserved_regions+0xae>
            assert(reserved[i + 1].start > reserved[i].start);
4200303b:	5a1b      	addi.n	a5, a10, 1
4200303d:	b05520        	addx8	a5, a5, a2
42003040:	0025b2        	l32i	a11, a5, 0
42003043:	1129b7        	blt	a9, a11, 42003058 <s_prepare_reserved_regions+0x80>
42003046:	f527d1        	l32r	a13, 420004e4 <_stext+0x4c4> (3c023210 <_flash_rodata_start+0x30f0>)
42003049:	f524c1        	l32r	a12, 420004dc <_stext+0x4bc> (3c027bd4 <__func__$0>)
4200304c:	58a0b2        	movi	a11, 88
4200304f:	f524a1        	l32r	a10, 420004e0 <_stext+0x4c0> (3c0231f7 <_flash_rodata_start+0x30d7>)
42003052:	f41b81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42003055:	0008e0        	callx8	a8
            if (reserved[i].end > reserved[i + 1].start) {
42003058:	2aab87        	bge	a11, a8, 42003086 <s_prepare_reserved_regions+0xae>
4200305b:	f3f481        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200305e:	0888      	l32i.n	a8, a8, 0
                ESP_EARLY_LOGE(TAG, "SOC_RESERVE_MEMORY_REGION region range " \
42003060:	c89c      	beqz.n	a8, 42003080 <s_prepare_reserved_regions+0xa8>
42003062:	f3ff81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42003065:	0008e0        	callx8	a8
42003068:	1588      	l32i.n	a8, a5, 4
4200306a:	0189      	s32i.n	a8, a1, 0
4200306c:	05f8      	l32i.n	a15, a5, 0
4200306e:	17e8      	l32i.n	a14, a7, 4
42003070:	07d8      	l32i.n	a13, a7, 0
42003072:	f51dc1        	l32r	a12, 420004e8 <_stext+0x4c8> (3c02323c <_flash_rodata_start+0x311c>)
42003075:	0abd      	mov.n	a11, a10
42003077:	f51da1        	l32r	a10, 420004ec <_stext+0x4cc> (3c02324c <_flash_rodata_start+0x312c>)
4200307a:	f3fa81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200307d:	0008e0        	callx8	a8
                               "0x%08x - 0x%08x overlaps with 0x%08x - 0x%08x",
                               reserved[i].start, reserved[i].end, reserved[i + 1].start,
                               reserved[i + 1].end);
                abort();
42003080:	f41d81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42003083:	0008e0        	callx8	a8
    for (size_t i = 0; i < count; i++) {
42003086:	aa1b      	addi.n	a10, a10, 1
42003088:	813a37        	bltu	a10, a3, 4200300d <s_prepare_reserved_regions+0x35>
            }
        }
    }
}
4200308b:	f01d      	retw.n
4200308d:	000000        	ill

42003090 <soc_get_available_memory_region_max_count>:
{
42003090:	004136        	entry	a1, 32
    return soc_memory_region_count + s_get_num_reserved_regions();
42003093:	fff325        	call8	42002fc4 <s_get_num_reserved_regions>
42003096:	f51781        	l32r	a8, 420004f4 <_stext+0x4d4> (3c027bf0 <soc_memory_region_count>)
42003099:	002882        	l32i	a8, a8, 0
}
4200309c:	802a80        	add	a2, a10, a8
4200309f:	000090        	retw
	...

420030a4 <soc_get_available_memory_regions>:

size_t soc_get_available_memory_regions(soc_memory_region_t *regions)
{
420030a4:	00a136        	entry	a1, 80
420030a7:	207110        	or	a7, a1, a1
420030aa:	203220        	or	a3, a2, a2
420030ad:	a729      	s32i.n	a2, a7, 40
    soc_memory_region_t *out_region = regions;
    /* make a local copy of the "input" regions so we can modify them */
    soc_memory_region_t in_regions[soc_memory_region_count];
420030af:	f51181        	l32r	a8, 420004f4 <_stext+0x4d4> (3c027bf0 <soc_memory_region_count>)
420030b2:	0888      	l32i.n	a8, a8, 0
420030b4:	a08880        	addx4	a8, a8, a8
420030b7:	1128e0        	slli	a2, a8, 2
420030ba:	82fb      	addi.n	a8, a2, 15
420030bc:	418480        	srli	a8, a8, 4
420030bf:	1188c0        	slli	a8, a8, 4
420030c2:	c08180        	sub	a8, a1, a8
420030c5:	001810        	movsp	a1, a8
420030c8:	014d      	mov.n	a4, a1
420030ca:	8719      	s32i.n	a1, a7, 32
    memcpy(in_regions, soc_memory_regions, sizeof(in_regions));
420030cc:	20c220        	or	a12, a2, a2
420030cf:	f50ab1        	l32r	a11, 420004f8 <_stext+0x4d8> (3c027bf4 <soc_memory_regions>)
420030d2:	01ad      	mov.n	a10, a1
420030d4:	f3d581        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420030d7:	0008e0        	callx8	a8
    soc_memory_region_t *in_region = in_regions;

    size_t num_reserved = s_get_num_reserved_regions();
420030da:	ffeea5        	call8	42002fc4 <s_get_num_reserved_regions>
420030dd:	0a5d      	mov.n	a5, a10
    soc_reserved_region_t reserved[num_reserved];
420030df:	118ad0        	slli	a8, a10, 3
420030e2:	88fb      	addi.n	a8, a8, 15
420030e4:	418480        	srli	a8, a8, 4
420030e7:	1188c0        	slli	a8, a8, 4
420030ea:	c08180        	sub	a8, a1, a8
420030ed:	001810        	movsp	a1, a8
420030f0:	016d      	mov.n	a6, a1

    s_prepare_reserved_regions(reserved, num_reserved);
420030f2:	0abd      	mov.n	a11, a10
420030f4:	01ad      	mov.n	a10, a1
420030f6:	ffee25        	call8	42002fd8 <s_prepare_reserved_regions>
    soc_memory_region_t *out_region = regions;
420030f9:	9739      	s32i.n	a3, a7, 36
    /* Go through the "in" regions (full regions, with no reserved
       sections removed from them) one at a time, trim off each reserved
       region, and then copy them to an out_region once trimmed
    */
    ESP_EARLY_LOGD(TAG, "Building list of available memory regions:");
    while (in_region != in_regions + soc_memory_region_count) {
420030fb:	0026c6        	j	4200319a <soc_get_available_memory_regions+0xf6>
        soc_memory_region_t in = *in_region;
420030fe:	4c1c      	movi.n	a12, 20
42003100:	04bd      	mov.n	a11, a4
42003102:	07ad      	mov.n	a10, a7
42003104:	f3c981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003107:	0008e0        	callx8	a8
        ESP_EARLY_LOGV(TAG, "Examining memory region 0x%08x - 0x%08x", in.start, in.start + in.size);
        intptr_t in_start = in.start;
4200310a:	07a8      	l32i.n	a10, a7, 0
        intptr_t in_end = in_start + in.size;
4200310c:	17c8      	l32i.n	a12, a7, 4
4200310e:	caca      	add.n	a12, a10, a12
        bool copy_in_to_out = true;
        bool move_to_next = true;

        for (size_t i = 0; i < num_reserved; i++) {
42003110:	080c      	movi.n	a8, 0
42003112:	001406        	j	42003166 <soc_get_available_memory_regions+0xc2>
            if (reserved[i].end <= in_start) {
42003115:	b09860        	addx8	a9, a8, a6
42003118:	19b8      	l32i.n	a11, a9, 4
4200311a:	46aab7        	bge	a10, a11, 42003164 <soc_get_available_memory_regions+0xc0>
                /* reserved region ends before 'in' starts */
                continue;
            } else if (reserved[i].start >= in_end) {
4200311d:	0998      	l32i.n	a9, a9, 0
4200311f:	4da9c7        	bge	a9, a12, 42003170 <soc_get_available_memory_regions+0xcc>
                /* reserved region starts after 'in' ends */
                break;
            } else if (reserved[i].start <= in_start &&
42003122:	022a97        	blt	a10, a9, 42003128 <soc_get_available_memory_regions+0x84>
42003125:	4eabc7        	bge	a11, a12, 42003177 <soc_get_available_memory_regions+0xd3>
                ESP_EARLY_LOGV(TAG, "Region 0x%08x - 0x%08x inside of reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                /* skip 'in' entirely */
                copy_in_to_out = false;
                break;
            } else if (in_start < reserved[i].start &&
42003128:	21aa97        	bge	a10, a9, 4200314d <soc_get_available_memory_regions+0xa9>
4200312b:	1eabc7        	bge	a11, a12, 4200314d <soc_get_available_memory_regions+0xa9>
                assert(in_start < reserved[i].start);
                assert(in_end > reserved[i].end);

                /* shrink this region to end where the reserved section starts */
                in_end = reserved[i].start;
                in.size = in_end - in_start;
4200312e:	c099a0        	sub	a9, a9, a10
42003131:	1799      	s32i.n	a9, a7, 4

                /* update in_region so the 'next' iteration uses the region
                   after the reserved section */
                in_region->size -= (reserved[i].end - in_region->start);
42003133:	1498      	l32i.n	a9, a4, 4
42003135:	04a8      	l32i.n	a10, a4, 0
42003137:	c0bba0        	sub	a11, a11, a10
4200313a:	c099b0        	sub	a9, a9, a11
4200313d:	1499      	s32i.n	a9, a4, 4
                in_region->start = reserved[i].end;
4200313f:	b08860        	addx8	a8, a8, a6
42003142:	1888      	l32i.n	a8, a8, 4
42003144:	0489      	s32i.n	a8, a4, 0

                /* add first region, then re-run while loop with the updated in_region */
                move_to_next = false;
42003146:	030c      	movi.n	a3, 0
        bool copy_in_to_out = true;
42003148:	1a0c      	movi.n	a10, 1
                break;
4200314a:	000b46        	j	4200317b <soc_get_available_memory_regions+0xd7>
            } else if (reserved[i].start <= in_start) { /* reserved overlaps start of 'in' */
4200314d:	0c2a97        	blt	a10, a9, 4200315d <soc_get_available_memory_regions+0xb9>
                ESP_EARLY_LOGV(TAG, "Start of region 0x%08x - 0x%08x overlaps reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                in.start = reserved[i].end;
42003150:	07b9      	s32i.n	a11, a7, 0
                in_start = in.start;
                in.size = in_end - in_start;
42003152:	c09cb0        	sub	a9, a12, a11
42003155:	1799      	s32i.n	a9, a7, 4
                in_start = in.start;
42003157:	0bad      	mov.n	a10, a11
42003159:	0001c6        	j	42003164 <soc_get_available_memory_regions+0xc0>
4200315c:	b9a000        	lsi	f0, a0, 0x2e4
            } else { /* reserved overlaps end of 'in' */
                ESP_EARLY_LOGV(TAG, "End of region 0x%08x - 0x%08x overlaps reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                in_end = reserved[i].start;
                in.size = in_end - in_start;
4200315f:	17b9c0        	lsi	f12, a9, 92
                in_end = reserved[i].start;
42003162:	09cd      	mov.n	a12, a9
        for (size_t i = 0; i < num_reserved; i++) {
42003164:	881b      	addi.n	a8, a8, 1
42003166:	ab3857        	bltu	a8, a5, 42003115 <soc_get_available_memory_regions+0x71>
        bool move_to_next = true;
42003169:	130c      	movi.n	a3, 1
        bool copy_in_to_out = true;
4200316b:	03ad      	mov.n	a10, a3
4200316d:	000286        	j	4200317b <soc_get_available_memory_regions+0xd7>
        bool move_to_next = true;
42003170:	130c      	movi.n	a3, 1
        bool copy_in_to_out = true;
42003172:	03ad      	mov.n	a10, a3
42003174:	0000c6        	j	4200317b <soc_get_available_memory_regions+0xd7>
        bool move_to_next = true;
42003177:	130c      	movi.n	a3, 1
                copy_in_to_out = false;
42003179:	0a0c      	movi.n	a10, 0
            }
        }

        /* ignore regions smaller than 16B */
        if (in.size <= 16) {
4200317b:	1788      	l32i.n	a8, a7, 4
4200317d:	091c      	movi.n	a9, 16
4200317f:	12b987        	bgeu	a9, a8, 42003195 <soc_get_available_memory_regions+0xf1>
            copy_in_to_out = false;
        }

        if (copy_in_to_out) {
42003182:	fa8c      	beqz.n	a10, 42003195 <soc_get_available_memory_regions+0xf1>
            ESP_EARLY_LOGD(TAG, "Available memory region 0x%08x - 0x%08x", in.start, in.start + in.size);
            *out_region++ = in;
42003184:	97a8      	l32i.n	a10, a7, 36
42003186:	14ca82        	addi	a8, a10, 20
42003189:	9789      	s32i.n	a8, a7, 36
4200318b:	4c1c      	movi.n	a12, 20
4200318d:	07bd      	mov.n	a11, a7
4200318f:	f3a681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003192:	0008e0        	callx8	a8
        }
        if (move_to_next) {
42003195:	138c      	beqz.n	a3, 4200319a <soc_get_available_memory_regions+0xf6>
            in_region++;
42003197:	14c442        	addi	a4, a4, 20
    while (in_region != in_regions + soc_memory_region_count) {
4200319a:	8788      	l32i.n	a8, a7, 32
4200319c:	882a      	add.n	a8, a8, a2
4200319e:	021487        	beq	a4, a8, 420031a4 <soc_get_available_memory_regions+0x100>
420031a1:	ffd646        	j	420030fe <soc_get_available_memory_regions+0x5a>
        }
    }

    return (out_region - regions); /* return number of regions */
420031a4:	9788      	l32i.n	a8, a7, 36
420031a6:	a798      	l32i.n	a9, a7, 40
420031a8:	c08890        	sub	a8, a8, a9
420031ab:	218280        	srai	a8, a8, 2
}
420031ae:	f4d321        	l32r	a2, 420004fc <_stext+0x4dc> (cccccccd <_rtc_reserved_end+0x6cbccccd>)
420031b1:	822820        	mull	a2, a8, a2
420031b4:	f01d      	retw.n
	...

420031b8 <calc_checksum>:
{
420031b8:	004136        	entry	a1, 32
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
420031bb:	080c      	movi.n	a8, 0
    uint32_t checksum = 0;
420031bd:	082d      	mov.n	a2, a8
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
420031bf:	000506        	j	420031d7 <calc_checksum+0x1f>
420031c2:	b00000        	addx8	a0, a0, a0
        checksum = ((checksum << 5) - checksum) ^ data[i];
420031c5:	201192        	l16ui	a9, a1, 64
420031c8:	c029      	s32i.n	a2, a0, 48
420031ca:	f4cd91        	l32r	a9, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
420031cd:	a09890        	addx4	a9, a8, a9
420031d0:	0998      	l32i.n	a9, a9, 0
420031d2:	302290        	xor	a2, a2, a9
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
420031d5:	881b      	addi.n	a8, a8, 1
420031d7:	e958b6        	bltui	a8, 5, 420031c4 <calc_checksum+0xc>
}
420031da:	f01d      	retw.n

420031dc <esp_clk_slowclk_cal_get>:
#endif // CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    clk_ll_rtc_slow_store_cal(new_cal);
}

uint32_t esp_clk_slowclk_cal_get(void)
{
420031dc:	004136        	entry	a1, 32
 *
 * @return The calibration value of slow clock period in microseconds, in Q13.19 fixed point format
 */
static inline __attribute__((always_inline)) uint32_t clk_ll_rtc_slow_load_cal(void)
{
    return REG_READ(RTC_SLOW_CLK_CAL_REG);
420031df:	f4c981        	l32r	a8, 42000504 <_stext+0x4e4> (60008054 <RTCCNTL+0x54>)
420031e2:	0020c0        	memw
420031e5:	0828      	l32i.n	a2, a8, 0
    return clk_ll_rtc_slow_load_cal();
}
420031e7:	f01d      	retw.n
420031e9:	000000        	ill

420031ec <esp_rtc_get_time_us>:
{
420031ec:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
420031ef:	f48181        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
420031f2:	0008e0        	callx8	a8
420031f5:	010a16        	beqz	a10, 42003209 <esp_rtc_get_time_us+0x1d>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
420031f8:	ffafb2        	movi	a11, -1
420031fb:	f4c3a1        	l32r	a10, 42000508 <_stext+0x4e8> (3fc92048 <s_esp_rtc_time_lock>)
420031fe:	f48481        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42003201:	0008e0        	callx8	a8
42003204:	000346        	j	42003215 <esp_rtc_get_time_us+0x29>
42003207:	b20000        	mulsh	a0, a0, a0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4200320a:	af          	.byte	0xaf
4200320b:	ff          	.byte	0xff
4200320c:	f4bfa1        	l32r	a10, 42000508 <_stext+0x4e8> (3fc92048 <s_esp_rtc_time_lock>)
4200320f:	f48081        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42003212:	0008e0        	callx8	a8
    const uint32_t cal = esp_clk_slowclk_cal_get();
42003215:	fffc65        	call8	420031dc <esp_clk_slowclk_cal_get>
42003218:	207aa0        	or	a7, a10, a10
    if (cal == 0 || (first_call && !IS_RETAIN_MEM_VALID())) {
4200321b:	1a9c      	beqz.n	a10, 42003230 <esp_rtc_get_time_us+0x44>
4200321d:	f4bb81        	l32r	a8, 4200050c <_stext+0x4ec> (3fc92044 <first_call$0>)
42003220:	000882        	l8ui	a8, a8, 0
42003223:	689c      	beqz.n	a8, 4200323d <esp_rtc_get_time_us+0x51>
42003225:	f4b681        	l32r	a8, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
42003228:	5838      	l32i.n	a3, a8, 20
4200322a:	fff8e5        	call8	420031b8 <calc_checksum>
4200322d:	0c13a7        	beq	a3, a10, 4200323d <esp_rtc_get_time_us+0x51>
        memset(&s_rtc_timer_retain_mem, 0, sizeof(retain_mem_t));
42003230:	8c1c      	movi.n	a12, 24
42003232:	0b0c      	movi.n	a11, 0
42003234:	f4b3a1        	l32r	a10, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
42003237:	f43281        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200323a:	0008e0        	callx8	a8
    first_call = false;
4200323d:	f4b381        	l32r	a8, 4200050c <_stext+0x4ec> (3fc92044 <first_call$0>)
42003240:	00a092        	movi	a9, 0
42003243:	004892        	s8i	a9, a8, 0
    const uint64_t rtc_this_ticks = rtc_time_get();
42003246:	f4b281        	l32r	a8, 42000510 <_stext+0x4f0> (403793f0 <rtc_time_get>)
42003249:	0008e0        	callx8	a8
    const uint64_t ticks = rtc_this_ticks - s_rtc_timer_retain_mem.rtc_last_ticks;
4200324c:	f4ad91        	l32r	a9, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
4200324f:	2988      	l32i.n	a8, a9, 8
42003251:	39d8      	l32i.n	a13, a9, 12
42003253:	c0dbd0        	sub	a13, a11, a13
42003256:	02ba87        	bgeu	a10, a8, 4200325c <esp_rtc_get_time_us+0x70>
42003259:	ffcdd2        	addi	a13, a13, -1
4200325c:	c08a80        	sub	a8, a10, a8
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
4200325f:	829780        	mull	a9, a7, a8
42003262:	a28780        	muluh	a8, a7, a8
42003265:	11c830        	slli	a12, a8, 13
42003268:	c59390        	extui	a9, a9, 19, 13
4200326b:	209c90        	or	a9, a12, a9
4200326e:	c58380        	extui	a8, a8, 19, 13
                                   ((ticks_high * cal) << (32 - RTC_CLK_CAL_FRACT));
42003271:	82c7d0        	mull	a12, a7, a13
42003274:	a277d0        	muluh	a7, a7, a13
42003277:	c5d3c0        	extui	a13, a12, 19, 13
4200327a:	117730        	slli	a7, a7, 13
4200327d:	207d70        	or	a7, a13, a7
42003280:	11cc30        	slli	a12, a12, 13
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
42003283:	887a      	add.n	a8, a8, a7
42003285:	99ca      	add.n	a9, a9, a12
42003287:	01b9c7        	bgeu	a9, a12, 4200328c <esp_rtc_get_time_us+0xa0>
4200328a:	881b      	addi.n	a8, a8, 1
    s_rtc_timer_retain_mem.rtc_time_us += delta_time_us;
4200328c:	f49dc1        	l32r	a12, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
4200328f:	0c28      	l32i.n	a2, a12, 0
42003291:	1c38      	l32i.n	a3, a12, 4
42003293:	338a      	add.n	a3, a3, a8
42003295:	229a      	add.n	a2, a2, a9
42003297:	01b297        	bgeu	a2, a9, 4200329c <esp_rtc_get_time_us+0xb0>
4200329a:	331b      	addi.n	a3, a3, 1
4200329c:	f49971        	l32r	a7, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
4200329f:	006722        	s32i	a2, a7, 0
420032a2:	016732        	s32i	a3, a7, 4
    s_rtc_timer_retain_mem.rtc_last_ticks = rtc_this_ticks;
420032a5:	0267a2        	s32i	a10, a7, 8
420032a8:	37b9      	s32i.n	a11, a7, 12
    s_rtc_timer_retain_mem.checksum = calc_checksum();
420032aa:	fff0e5        	call8	420031b8 <calc_checksum>
420032ad:	57a9      	s32i.n	a10, a7, 20
    if (xPortInIsrContext()) {
420032af:	f45181        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
420032b2:	0008e0        	callx8	a8
420032b5:	ba8c      	beqz.n	a10, 420032c4 <esp_rtc_get_time_us+0xd8>
        portEXIT_CRITICAL_ISR(mux);
420032b7:	f494a1        	l32r	a10, 42000508 <_stext+0x4e8> (3fc92048 <s_esp_rtc_time_lock>)
420032ba:	f45681        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420032bd:	0008e0        	callx8	a8
420032c0:	000246        	j	420032cd <esp_rtc_get_time_us+0xe1>
420032c3:	91a100        	lsi	f0, a1, 0x244
        portEXIT_CRITICAL(mux);
420032c6:	5381f4        	lsi	f15, a1, 0x14c
420032c9:	08e0f4        	lsi	f15, a0, 32
420032cc:	f01d00        	subx8	a1, a13, a0
	...

420032d0 <esp_clk_slowclk_cal_set>:
{
420032d0:	004136        	entry	a1, 32
    esp_rtc_get_time_us();
420032d3:	fff1a5        	call8	420031ec <esp_rtc_get_time_us>
    REG_WRITE(RTC_SLOW_CLK_CAL_REG, cal_value);
420032d6:	f48b81        	l32r	a8, 42000504 <_stext+0x4e4> (60008054 <RTCCNTL+0x54>)
420032d9:	0020c0        	memw
420032dc:	0829      	s32i.n	a2, a8, 0
}
420032de:	f01d      	retw.n

420032e0 <insert_vector_desc>:
{
420032e0:	004136        	entry	a1, 32
    vector_desc_t *vd = vector_desc_head;
420032e3:	f48c81        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94bec <vector_desc_head>)
420032e6:	08c8      	l32i.n	a12, a8, 0
420032e8:	0c8d      	mov.n	a8, a12
    vector_desc_t *prev = NULL;
420032ea:	0b0c      	movi.n	a11, 0
    while(vd != NULL) {
420032ec:	000a46        	j	42003319 <insert_vector_desc+0x39>
420032ef:	089800        	lsx	f9, a8, a0
        if (vd->cpu > to_insert->cpu) break;
420032f2:	059090        	extui	a9, a9, 16, 1
420032f5:	02a8      	l32i.n	a10, a2, 0
420032f7:	05a0a0        	extui	a10, a10, 16, 1
420032fa:	1e3a97        	bltu	a10, a9, 4200331c <insert_vector_desc+0x3c>
        if (vd->cpu == to_insert->cpu && vd->intno >= to_insert->intno) break;
420032fd:	0898      	l32i.n	a9, a8, 0
420032ff:	02a8      	l32i.n	a10, a2, 0
42003301:	3099a0        	xor	a9, a9, a10
42003304:	0df907        	bbsi	a9, 16, 42003315 <insert_vector_desc+0x35>
42003307:	08a8      	l32i.n	a10, a8, 0
42003309:	45a1a0        	extui	a10, a10, 17, 5
4200330c:	002292        	l32i	a9, a2, 0
4200330f:	459190        	extui	a9, a9, 17, 5
42003312:	06ba97        	bgeu	a10, a9, 4200331c <insert_vector_desc+0x3c>
        prev = vd;
42003315:	08bd      	mov.n	a11, a8
        vd = vd->next;
42003317:	2888      	l32i.n	a8, a8, 8
    while(vd != NULL) {
42003319:	fd3856        	bnez	a8, 420032f0 <insert_vector_desc+0x10>
    if ((vector_desc_head == NULL) || (prev == NULL)) {
4200331c:	0c8c      	beqz.n	a12, 42003320 <insert_vector_desc+0x40>
4200331e:	8bcc      	bnez.n	a11, 4200332a <insert_vector_desc+0x4a>
        to_insert->next = vd;
42003320:	2289      	s32i.n	a8, a2, 8
        vector_desc_head = to_insert;
42003322:	f47c81        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94bec <vector_desc_head>)
42003325:	0829      	s32i.n	a2, a8, 0
42003327:	0000c6        	j	4200332e <insert_vector_desc+0x4e>
        prev->next = to_insert;
4200332a:	2b29      	s32i.n	a2, a11, 8
        to_insert->next = vd;
4200332c:	2289      	s32i.n	a8, a2, 8
}
4200332e:	f01d      	retw.n

42003330 <find_desc_for_int>:
{
42003330:	004136        	entry	a1, 32
42003333:	029d      	mov.n	a9, a2
    vector_desc_t *vd = vector_desc_head;
42003335:	f47781        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94bec <vector_desc_head>)
42003338:	0828      	l32i.n	a2, a8, 0
    while(vd != NULL) {
4200333a:	000446        	j	4200334f <find_desc_for_int+0x1f>
        if (vd->cpu == cpu && vd->intno == intno) {
4200333d:	0288      	l32i.n	a8, a2, 0
4200333f:	058080        	extui	a8, a8, 16, 1
42003342:	079837        	bne	a8, a3, 4200334d <find_desc_for_int+0x1d>
42003345:	0288      	l32i.n	a8, a2, 0
42003347:	458180        	extui	a8, a8, 17, 5
4200334a:	041897        	beq	a8, a9, 42003352 <find_desc_for_int+0x22>
        vd = vd->next;
4200334d:	2228      	l32i.n	a2, a2, 8
    while(vd != NULL) {
4200334f:	fea256        	bnez	a2, 4200333d <find_desc_for_int+0xd>
}
42003352:	f01d      	retw.n

42003354 <get_desc_for_int>:
{
42003354:	004136        	entry	a1, 32
42003357:	027d      	mov.n	a7, a2
    vector_desc_t *vd = find_desc_for_int(intno, cpu);
42003359:	03bd      	mov.n	a11, a3
4200335b:	02ad      	mov.n	a10, a2
4200335d:	fffd25        	call8	42003330 <find_desc_for_int>
42003360:	202aa0        	or	a2, a10, a10
    if (vd == NULL) {
42003363:	041a56        	bnez	a10, 420033a8 <get_desc_for_int+0x54>
        vector_desc_t *newvd = heap_caps_malloc(sizeof(vector_desc_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42003366:	f454b1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42003369:	ca0c      	movi.n	a10, 12
4200336b:	f46d81        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
4200336e:	0008e0        	callx8	a8
42003371:	0a2d      	mov.n	a2, a10
        if (newvd == NULL) {
42003373:	1abc      	beqz.n	a10, 420033a8 <get_desc_for_int+0x54>
        memset(newvd, 0, sizeof(vector_desc_t));
42003375:	cc0c      	movi.n	a12, 12
42003377:	0b0c      	movi.n	a11, 0
42003379:	f3e181        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200337c:	0008e0        	callx8	a8
        newvd->intno = intno;
4200337f:	447070        	extui	a7, a7, 0, 5
42003382:	0177f0        	slli	a7, a7, 17
42003385:	0288      	l32i.n	a8, a2, 0
42003387:	f46491        	l32r	a9, 42000518 <_stext+0x4f8> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
4200338a:	108890        	and	a8, a8, a9
4200338d:	208870        	or	a8, a8, a7
42003390:	0289      	s32i.n	a8, a2, 0
        newvd->cpu = cpu;
42003392:	043030        	extui	a3, a3, 0, 1
42003395:	113300        	slli	a3, a3, 16
42003398:	f46191        	l32r	a9, 4200051c <_stext+0x4fc> (fffeffff <_rtc_reserved_end+0x9feeffff>)
4200339b:	108890        	and	a8, a8, a9
4200339e:	208830        	or	a8, a8, a3
420033a1:	0289      	s32i.n	a8, a2, 0
        insert_vector_desc(newvd);
420033a3:	02ad      	mov.n	a10, a2
420033a5:	fff3a5        	call8	420032e0 <insert_vector_desc>
}
420033a8:	f01d      	retw.n
	...

420033ac <find_desc_for_source>:
{
420033ac:	004136        	entry	a1, 32
420033af:	02ad      	mov.n	a10, a2
    vector_desc_t *vd = vector_desc_head;
420033b1:	f45881        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94bec <vector_desc_head>)
420033b4:	0828      	l32i.n	a2, a8, 0
    while(vd != NULL) {
420033b6:	0017c6        	j	42003419 <find_desc_for_source+0x6d>
        if (!(vd->flags & VECDESC_FL_SHARED)) {
420033b9:	009282        	l16si	a8, a2, 0
420033bc:	490c      	movi.n	a9, 4
420033be:	108890        	and	a8, a8, a9
420033c1:	238880        	sext	a8, a8, 15
420033c4:	48dc      	bnez.n	a8, 420033dc <find_desc_for_source+0x30>
            if (vd->source == source && cpu == vd->cpu) {
420033c6:	0288      	l32i.n	a8, a2, 0
420033c8:	1188e0        	slli	a8, a8, 2
420033cb:	318880        	srai	a8, a8, 24
420033ce:	4498a7        	bne	a8, a10, 42003416 <find_desc_for_source+0x6a>
420033d1:	0288      	l32i.n	a8, a2, 0
420033d3:	058080        	extui	a8, a8, 16, 1
420033d6:	3c9837        	bne	a8, a3, 42003416 <find_desc_for_source+0x6a>
420033d9:	000fc6        	j	4200341c <find_desc_for_source+0x70>
        } else if (vd->cpu == cpu) {
420033dc:	0288      	l32i.n	a8, a2, 0
420033de:	058080        	extui	a8, a8, 16, 1
420033e1:	319837        	bne	a8, a3, 42003416 <find_desc_for_source+0x6a>
            shared_vector_desc_t *svd = vd->shared_vec_info;
420033e4:	1298      	l32i.n	a9, a2, 4
            assert(svd != NULL);
420033e6:	09ec      	bnez.n	a9, 4200340a <find_desc_for_source+0x5e>
420033e8:	f44fd1        	l32r	a13, 42000524 <_stext+0x504> (3c0234a4 <_flash_rodata_start+0x3384>)
420033eb:	f44fc1        	l32r	a12, 42000528 <_stext+0x508> (3c027dc8 <__func__$6>)
420033ee:	b7a0b2        	movi	a11, 183
420033f1:	f44ea1        	l32r	a10, 4200052c <_stext+0x50c> (3c0234d0 <_flash_rodata_start+0x33b0>)
420033f4:	f33381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420033f7:	0008e0        	callx8	a8
                if (svd->source == source) {
420033fa:	0988      	l32i.n	a8, a9, 0
420033fc:	118890        	slli	a8, a8, 7
420033ff:	238880        	sext	a8, a8, 15
42003402:	218880        	srai	a8, a8, 8
42003405:	0918a7        	beq	a8, a10, 42003412 <find_desc_for_source+0x66>
                svd = svd->next;
42003408:	5998      	l32i.n	a9, a9, 20
            while(svd) {
4200340a:	fec956        	bnez	a9, 420033fa <find_desc_for_source+0x4e>
            bool found = false;
4200340d:	080c      	movi.n	a8, 0
4200340f:	000046        	j	42003414 <find_desc_for_source+0x68>
                    found = true;
42003412:	180c      	movi.n	a8, 1
            if (found) {
42003414:	48cc      	bnez.n	a8, 4200341c <find_desc_for_source+0x70>
        vd = vd->next;
42003416:	022222        	l32i	a2, a2, 8
    while(vd != NULL) {
42003419:	f9c256        	bnez	a2, 420033b9 <find_desc_for_source+0xd>
}
4200341c:	f01d      	retw.n
	...

42003420 <is_vect_desc_usable>:
{
42003420:	006136        	entry	a1, 48
42003423:	04ad      	mov.n	a10, a4
    int x = vd->intno;
42003425:	0278      	l32i.n	a7, a2, 0
42003427:	457170        	extui	a7, a7, 17, 5
    esp_cpu_intr_get_desc(cpu, x, &intr_desc);
4200342a:	01cd      	mov.n	a12, a1
4200342c:	07bd      	mov.n	a11, a7
4200342e:	0261a5        	call8	42005a48 <esp_cpu_intr_get_desc>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_RESVD) {
42003431:	2188      	l32i.n	a8, a1, 8
42003433:	7ae817        	bbsi	a8, 1, 420034b1 <is_vect_desc_usable+0x91>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_SPECIAL && force == -1) {
42003436:	026807        	bbci	a8, 0, 4200343c <is_vect_desc_usable+0x1c>
42003439:	790526        	beqi	a5, -1, 420034b6 <is_vect_desc_usable+0x96>
    if (!(flags & (1 << intr_desc.priority))) {
4200343c:	0188      	l32i.n	a8, a1, 0
4200343e:	7a5387        	bbc	a3, a8, 420034bc <is_vect_desc_usable+0x9c>
    if (((flags & ESP_INTR_FLAG_EDGE) && (intr_desc.type == ESP_CPU_INTR_TYPE_LEVEL)) ||
42003441:	076397        	bbci	a3, 9, 4200344c <is_vect_desc_usable+0x2c>
42003444:	1188      	l32i.n	a8, a1, 4
42003446:	78cc      	bnez.n	a8, 42003451 <is_vect_desc_usable+0x31>
42003448:	001d46        	j	420034c1 <is_vect_desc_usable+0xa1>
4200344b:	118800        	slli	a8, a8, 16
            (((!(flags & ESP_INTR_FLAG_EDGE)) && (intr_desc.type == ESP_CPU_INTR_TYPE_EDGE)))) {
4200344e:	741826        	beqi	a8, 1, 420034c6 <is_vect_desc_usable+0xa6>
    if (vd->flags & VECDESC_FL_RESERVED)  {
42003451:	009282        	l16si	a8, a2, 0
42003454:	74e807        	bbsi	a8, 0, 420034cc <is_vect_desc_usable+0xac>
    assert(!((vd->flags & VECDESC_FL_SHARED) && (vd->flags & VECDESC_FL_NONSHARED)));
42003457:	c90c      	movi.n	a9, 12
42003459:	109890        	and	a9, a8, a9
4200345c:	239980        	sext	a9, a9, 15
4200345f:	11a966        	bnei	a9, 12, 42003474 <is_vect_desc_usable+0x54>
42003462:	f433d1        	l32r	a13, 42000530 <_stext+0x510> (3c0234e0 <_flash_rodata_start+0x33c0>)
42003465:	f433c1        	l32r	a12, 42000534 <_stext+0x514> (3c027db4 <__func__$5>)
42003468:	1aa1b2        	movi	a11, 0x11a
4200346b:	f430a1        	l32r	a10, 4200052c <_stext+0x50c> (3c0234d0 <_flash_rodata_start+0x33b0>)
4200346e:	f31481        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42003471:	0008e0        	callx8	a8
    if (vd->flags & VECDESC_FL_NONSHARED) {
42003474:	890c      	movi.n	a9, 8
42003476:	109890        	and	a9, a8, a9
42003479:	239980        	sext	a9, a9, 15
4200347c:	051956        	bnez	a9, 420034d1 <is_vect_desc_usable+0xb1>
    if (vd->flags & VECDESC_FL_SHARED) {
4200347f:	490c      	movi.n	a9, 4
42003481:	109890        	and	a9, a8, a9
42003484:	239980        	sext	a9, a9, 15
42003487:	199c      	beqz.n	a9, 4200349c <is_vect_desc_usable+0x7c>
        if (flags & ESP_INTR_FLAG_SHARED) {
42003489:	496387        	bbci	a3, 8, 420034d6 <is_vect_desc_usable+0xb6>
            bool in_iram_flag = ((flags & ESP_INTR_FLAG_IRAM) != 0);
4200348c:	043a30        	extui	a3, a3, 10, 1
            bool desc_in_iram_flag = ((vd->flags & VECDESC_FL_INIRAM) != 0);
4200348f:	048180        	extui	a8, a8, 1, 1
            if ((vd->flags & VECDESC_FL_SHARED) && (desc_in_iram_flag != in_iram_flag))  {
42003492:	469387        	bne	a3, a8, 420034dc <is_vect_desc_usable+0xbc>
    return true;
42003495:	120c      	movi.n	a2, 1
42003497:	001206        	j	420034e3 <is_vect_desc_usable+0xc3>
4200349a:	b00000        	addx8	a0, a0, a0
4200349d:	03eb      	addi.n	a0, a3, 14
4200349f:	04bdb0        	extui	a11, a11, 13, 1
    has_handler = xt_int_has_handler(intr_num, esp_cpu_get_core_id());
420034a2:	20a770        	or	a10, a7, a7
420034a5:	13d1e5        	call8	420171c4 <xt_int_has_handler>
    } else if (esp_cpu_intr_has_handler(x)) {
420034a8:	035a56        	bnez	a10, 420034e1 <is_vect_desc_usable+0xc1>
    return true;
420034ab:	01a022        	movi	a2, 1
420034ae:	000c46        	j	420034e3 <is_vect_desc_usable+0xc3>
        return false;
420034b1:	020c      	movi.n	a2, 0
420034b3:	000b06        	j	420034e3 <is_vect_desc_usable+0xc3>
        return false;
420034b6:	020c      	movi.n	a2, 0
420034b8:	0009c6        	j	420034e3 <is_vect_desc_usable+0xc3>
420034bb:	020c00        	andb	b0, b12, b0
        return false;
420034be:	000846        	j	420034e3 <is_vect_desc_usable+0xc3>
        return false;
420034c1:	020c      	movi.n	a2, 0
420034c3:	000706        	j	420034e3 <is_vect_desc_usable+0xc3>
420034c6:	020c      	movi.n	a2, 0
420034c8:	0005c6        	j	420034e3 <is_vect_desc_usable+0xc3>
420034cb:	020c00        	andb	b0, b12, b0
        return false;
420034ce:	000446        	j	420034e3 <is_vect_desc_usable+0xc3>
        return false;
420034d1:	020c      	movi.n	a2, 0
420034d3:	000306        	j	420034e3 <is_vect_desc_usable+0xc3>
            return false;
420034d6:	020c      	movi.n	a2, 0
420034d8:	0001c6        	j	420034e3 <is_vect_desc_usable+0xc3>
420034db:	020c00        	andb	b0, b12, b0
                return false;
420034de:	000046        	j	420034e3 <is_vect_desc_usable+0xc3>
        return false;
420034e1:	020c      	movi.n	a2, 0
}
420034e3:	f01d      	retw.n
420034e5:	000000        	ill

420034e8 <get_available_int>:
{
420034e8:	00a136        	entry	a1, 80
    memset(&empty_vect_desc, 0, sizeof(vector_desc_t));
420034eb:	cc0c      	movi.n	a12, 12
420034ed:	00a0b2        	movi	a11, 0
420034f0:	01ad      	mov.n	a10, a1
420034f2:	f38381        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420034f5:	0008e0        	callx8	a8
    if (!(flags & ESP_INTR_FLAG_LEVELMASK)) {
420034f8:	648120        	extui	a8, a2, 1, 7
420034fb:	38cc      	bnez.n	a8, 42003502 <get_available_int+0x1a>
        flags |= ESP_INTR_FLAG_LOWMED;
420034fd:	e80c      	movi.n	a8, 14
420034ff:	202280        	or	a2, a2, a8
    vector_desc_t *vd = find_desc_for_source(source, cpu);
42003502:	03bd      	mov.n	a11, a3
42003504:	05ad      	mov.n	a10, a5
42003506:	ffea65        	call8	420033ac <find_desc_for_source>
42003509:	0a7d      	mov.n	a7, a10
    if (vd) {
4200350b:	1abc      	beqz.n	a10, 42003540 <get_available_int+0x58>
        if ( force != -1 && force != vd->intno ) {
4200350d:	070426        	beqi	a4, -1, 42003518 <get_available_int+0x30>
42003510:	0a88      	l32i.n	a8, a10, 0
42003512:	458180        	extui	a8, a8, 17, 5
42003515:	199847        	bne	a8, a4, 42003532 <get_available_int+0x4a>
        } else if (!is_vect_desc_usable(vd, flags, cpu, force)) {
42003518:	20d440        	or	a13, a4, a4
4200351b:	20c330        	or	a12, a3, a3
4200351e:	20b220        	or	a11, a2, a2
42003521:	07ad      	mov.n	a10, a7
42003523:	ffefe5        	call8	42003420 <is_vect_desc_usable>
42003526:	fa8c      	beqz.n	a10, 42003539 <get_available_int+0x51>
            best = vd->intno;
42003528:	0788      	l32i.n	a8, a7, 0
4200352a:	458180        	extui	a8, a8, 17, 5
4200352d:	8189      	s32i.n	a8, a1, 32
4200352f:	003d86        	j	42003629 <get_available_int+0x141>
    int best=-1;
42003532:	f87c      	movi.n	a8, -1
42003534:	8189      	s32i.n	a8, a1, 32
42003536:	003bc6        	j	42003629 <get_available_int+0x141>
42003539:	f87c      	movi.n	a8, -1
4200353b:	8189      	s32i.n	a8, a1, 32
        return best;
4200353d:	003a06        	j	42003629 <get_available_int+0x141>
    if (force != -1) {
42003540:	020466        	bnei	a4, -1, 42003546 <get_available_int+0x5e>
42003543:	0033c6        	j	42003616 <get_available_int+0x12e>
        vd = find_desc_for_int(force, cpu);
42003546:	03bd      	mov.n	a11, a3
42003548:	04ad      	mov.n	a10, a4
4200354a:	ffde65        	call8	42003330 <find_desc_for_int>
4200354d:	0a7d      	mov.n	a7, a10
        if (vd == NULL) {
4200354f:	3adc      	bnez.n	a10, 42003566 <get_available_int+0x7e>
            empty_vect_desc.intno = force;
42003551:	449040        	extui	a9, a4, 0, 5
42003554:	0199f0        	slli	a9, a9, 17
42003557:	0188      	l32i.n	a8, a1, 0
42003559:	f3efa1        	l32r	a10, 42000518 <_stext+0x4f8> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
4200355c:	1088a0        	and	a8, a8, a10
4200355f:	208890        	or	a8, a8, a9
42003562:	0189      	s32i.n	a8, a1, 0
            vd = &empty_vect_desc;
42003564:	017d      	mov.n	a7, a1
        if (is_vect_desc_usable(vd, flags, cpu, force)) {
42003566:	20d440        	or	a13, a4, a4
42003569:	20c330        	or	a12, a3, a3
4200356c:	20b220        	or	a11, a2, a2
4200356f:	07ad      	mov.n	a10, a7
42003571:	ffeae5        	call8	42003420 <is_vect_desc_usable>
42003574:	8a8c      	beqz.n	a10, 42003580 <get_available_int+0x98>
            best = vd->intno;
42003576:	0788      	l32i.n	a8, a7, 0
42003578:	458180        	extui	a8, a8, 17, 5
4200357b:	8189      	s32i.n	a8, a1, 32
4200357d:	002a06        	j	42003629 <get_available_int+0x141>
    int best=-1;
42003580:	f87c      	movi.n	a8, -1
42003582:	8189      	s32i.n	a8, a1, 32
        return best;
42003584:	002846        	j	42003629 <get_available_int+0x141>
42003587:	03bd00        	lsi	f0, a13, 12
        vd = find_desc_for_int(x, cpu);
4200358a:	06ad      	mov.n	a10, a6
4200358c:	ffda25        	call8	42003330 <find_desc_for_int>
4200358f:	0a7d      	mov.n	a7, a10
        if (vd == NULL) {
42003591:	3adc      	bnez.n	a10, 420035a8 <get_available_int+0xc0>
            empty_vect_desc.intno = x;
42003593:	449060        	extui	a9, a6, 0, 5
42003596:	0199f0        	slli	a9, a9, 17
42003599:	0188      	l32i.n	a8, a1, 0
4200359b:	f3dfa1        	l32r	a10, 42000518 <_stext+0x4f8> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
4200359e:	1088a0        	and	a8, a8, a10
420035a1:	208890        	or	a8, a8, a9
420035a4:	0189      	s32i.n	a8, a1, 0
            vd = &empty_vect_desc;
420035a6:	017d      	mov.n	a7, a1
        esp_cpu_intr_get_desc(cpu, x, &intr_desc);
420035a8:	c1cb      	addi.n	a12, a1, 12
420035aa:	06bd      	mov.n	a11, a6
420035ac:	03ad      	mov.n	a10, a3
420035ae:	0249a5        	call8	42005a48 <esp_cpu_intr_get_desc>
        if (!is_vect_desc_usable(vd, flags, cpu, force)) {
420035b1:	04dd      	mov.n	a13, a4
420035b3:	03cd      	mov.n	a12, a3
420035b5:	02bd      	mov.n	a11, a2
420035b7:	07ad      	mov.n	a10, a7
420035b9:	ffe665        	call8	42003420 <is_vect_desc_usable>
420035bc:	051a16        	beqz	a10, 42003611 <get_available_int+0x129>
        if (flags & ESP_INTR_FLAG_SHARED) {
420035bf:	3b6287        	bbci	a2, 8, 420035fe <get_available_int+0x116>
            if (vd->flags & VECDESC_FL_SHARED) {
420035c2:	009782        	l16si	a8, a7, 0
420035c5:	490c      	movi.n	a9, 4
420035c7:	108890        	and	a8, a8, a9
420035ca:	238880        	sext	a8, a8, 15
420035cd:	08ac      	beqz.n	a8, 420035f1 <get_available_int+0x109>
                shared_vector_desc_t *svdesc = vd->shared_vec_info;
420035cf:	1788      	l32i.n	a8, a7, 4
                int no = 0;
420035d1:	090c      	movi.n	a9, 0
                while (svdesc != NULL) {
420035d3:	0000c6        	j	420035da <get_available_int+0xf2>
                    no++;
420035d6:	991b      	addi.n	a9, a9, 1
                    svdesc = svdesc->next;
420035d8:	5888      	l32i.n	a8, a8, 20
                while (svdesc != NULL) {
420035da:	ff8856        	bnez	a8, 420035d6 <get_available_int+0xee>
                if (no<bestSharedCt || bestPriority > intr_desc.priority) {
420035dd:	9188      	l32i.n	a8, a1, 36
420035df:	052987        	blt	a9, a8, 420035e8 <get_available_int+0x100>
420035e2:	032182        	l32i	a8, a1, 12
420035e5:	28a857        	bge	a8, a5, 42003611 <get_available_int+0x129>
                    bestPriority = intr_desc.priority;
420035e8:	3158      	l32i.n	a5, a1, 12
                    bestSharedCt = no;
420035ea:	9199      	s32i.n	a9, a1, 36
                    best = x;
420035ec:	8169      	s32i.n	a6, a1, 32
420035ee:	0007c6        	j	42003611 <get_available_int+0x129>
                if (best == -1) {
420035f1:	8188      	l32i.n	a8, a1, 32
420035f3:	1a0866        	bnei	a8, -1, 42003611 <get_available_int+0x129>
                    if (bestPriority > intr_desc.priority) {
420035f6:	3188      	l32i.n	a8, a1, 12
420035f8:	0a2857        	blt	a8, a5, 42003606 <get_available_int+0x11e>
420035fb:	000486        	j	42003611 <get_available_int+0x129>
            if (bestPriority > intr_desc.priority) {
420035fe:	3188      	l32i.n	a8, a1, 12
42003600:	092857        	blt	a8, a5, 4200360d <get_available_int+0x125>
42003603:	000286        	j	42003611 <get_available_int+0x129>
                        bestPriority = intr_desc.priority;
42003606:	085d      	mov.n	a5, a8
                        best = x;
42003608:	8169      	s32i.n	a6, a1, 32
4200360a:	0000c6        	j	42003611 <get_available_int+0x129>
                bestPriority = intr_desc.priority;
4200360d:	085d      	mov.n	a5, a8
                best = x;
4200360f:	8169      	s32i.n	a6, a1, 32
    for (x = 0; x < CPU_INT_LINES_COUNT; x++) {
42003611:	661b      	addi.n	a6, a6, 1
42003613:	000286        	j	42003621 <get_available_int+0x139>
    int best=-1;
42003616:	8149      	s32i.n	a4, a1, 32
    int bestSharedCt=INT_MAX;
42003618:	f3c881        	l32r	a8, 42000538 <_stext+0x518> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4200361b:	9189      	s32i.n	a8, a1, 36
    int bestPriority=9;
4200361d:	950c      	movi.n	a5, 9
    for (x = 0; x < CPU_INT_LINES_COUNT; x++) {
4200361f:	060c      	movi.n	a6, 0
42003621:	f81c      	movi.n	a8, 31
42003623:	022867        	blt	a8, a6, 42003629 <get_available_int+0x141>
42003626:	ffd786        	j	42003588 <get_available_int+0xa0>
}
42003629:	8128      	l32i.n	a2, a1, 32
4200362b:	f01d      	retw.n
4200362d:	000000        	ill

42003630 <esp_intr_ptr_in_isr_region>:
{
42003630:	004136        	entry	a1, 32
    return ((intptr_t)p >= SOC_IRAM_LOW && (intptr_t)p < SOC_IRAM_HIGH);
42003633:	f32b81        	l32r	a8, 420002e0 <_stext+0x2c0> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
42003636:	828a      	add.n	a8, a2, a8
    return esp_ptr_in_iram(ptr) || esp_ptr_in_rtc_iram_fast(ptr) || esp_ptr_in_rom(ptr);
42003638:	f32b91        	l32r	a9, 420002e4 <_stext+0x2c4> (6ffff <UserFrameTotalSize+0x6feff>)
4200363b:	0fb987        	bgeu	a9, a8, 4200364e <esp_intr_ptr_in_isr_region+0x1e>
        (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH);
4200363e:	f32a81        	l32r	a8, 420002e8 <_stext+0x2c8> (c0000000 <_rtc_reserved_end+0x5ff00000>)
42003641:	228a      	add.n	a2, a2, a8
42003643:	f32a81        	l32r	a8, 420002ec <_stext+0x2cc> (5ffff <UserFrameTotalSize+0x5feff>)
42003646:	0ab827        	bgeu	a8, a2, 42003654 <esp_intr_ptr_in_isr_region+0x24>
42003649:	020c      	movi.n	a2, 0
4200364b:	0001c6        	j	42003656 <esp_intr_ptr_in_isr_region+0x26>
4200364e:	120c      	movi.n	a2, 1
42003650:	000086        	j	42003656 <esp_intr_ptr_in_isr_region+0x26>
42003653:	120c00        	andbc	b0, b12, b0
}
42003656:	f01d      	retw.n

42003658 <esp_intr_alloc_intrstatus>:
{
42003658:	00a136        	entry	a1, 80
4200365b:	5179      	s32i.n	a7, a1, 20
4200365d:	4159      	s32i.n	a5, a1, 16
    if ((flags & ESP_INTR_FLAG_SHARED) && (flags & ESP_INTR_FLAG_EDGE)) {
4200365f:	00a382        	movi	a8, 0x300
42003662:	02c387        	bnall	a3, a8, 42003668 <esp_intr_alloc_intrstatus+0x10>
42003665:	00b006        	j	42003929 <esp_intr_alloc_intrstatus+0x2d1>
    if ((flags & ESP_INTR_FLAG_HIGH) && (handler)) {
42003668:	348430        	extui	a8, a3, 4, 4
4200366b:	002816        	beqz	a8, 42003671 <esp_intr_alloc_intrstatus+0x19>
4200366e:	2be656        	bnez	a6, 42003930 <esp_intr_alloc_intrstatus+0x2d8>
    if ((flags & ESP_INTR_FLAG_SHARED) && (!handler || source<0)) {
42003671:	00a182        	movi	a8, 0x100
42003674:	107380        	and	a7, a3, a8
42003677:	0e0387        	bnone	a3, a8, 42003689 <esp_intr_alloc_intrstatus+0x31>
4200367a:	40f680        	nsau	a8, a6
4200367d:	418580        	srli	a8, a8, 5
42003680:	059f20        	extui	a9, a2, 31, 1
42003683:	208890        	or	a8, a8, a9
42003686:	2ae856        	bnez	a8, 42003938 <esp_intr_alloc_intrstatus+0x2e0>
    if (intrstatusreg && !intrstatusmask) {
42003689:	01a092        	movi	a9, 1
4200368c:	839440        	moveqz	a9, a4, a4
4200368f:	042182        	l32i	a8, a1, 16
42003692:	40f880        	nsau	a8, a8
42003695:	418580        	srli	a8, a8, 5
42003698:	020987        	bnone	a9, a8, 4200369e <esp_intr_alloc_intrstatus+0x46>
4200369b:	00a846        	j	42003940 <esp_intr_alloc_intrstatus+0x2e8>
    if ((flags & ESP_INTR_FLAG_IRAM) && handler && !esp_intr_ptr_in_isr_region(handler)) {
4200369e:	0a63a7        	bbci	a3, 10, 420036ac <esp_intr_alloc_intrstatus+0x54>
420036a1:	007616        	beqz	a6, 420036ac <esp_intr_alloc_intrstatus+0x54>
420036a4:	06ad      	mov.n	a10, a6
420036a6:	fff8a5        	call8	42003630 <esp_intr_ptr_in_isr_region>
420036a9:	299a16        	beqz	a10, 42003946 <esp_intr_alloc_intrstatus+0x2ee>
    if ((flags & ESP_INTR_FLAG_LEVELMASK) == 0) {
420036ac:	648130        	extui	a8, a3, 1, 7
420036af:	e8cc      	bnez.n	a8, 420036c1 <esp_intr_alloc_intrstatus+0x69>
        if (flags & ESP_INTR_FLAG_SHARED) {
420036b1:	778c      	beqz.n	a7, 420036bc <esp_intr_alloc_intrstatus+0x64>
            flags |= ESP_INTR_FLAG_LEVEL1;
420036b3:	280c      	movi.n	a8, 2
420036b5:	203380        	or	a3, a3, a8
420036b8:	000146        	j	420036c1 <esp_intr_alloc_intrstatus+0x69>
420036bb:	e80c00        	lsi	f0, a12, 0x3a0
            flags |= ESP_INTR_FLAG_LOWMED;
420036be:	203380        	or	a3, a3, a8
    if (source == ETS_INTERNAL_TIMER0_INTR_SOURCE) {
420036c1:	090226        	beqi	a2, -1, 420036ce <esp_intr_alloc_intrstatus+0x76>
    if (source == ETS_INTERNAL_TIMER1_INTR_SOURCE) {
420036c4:	e87c      	movi.n	a8, -2
420036c6:	0e1287        	beq	a2, a8, 420036d8 <esp_intr_alloc_intrstatus+0x80>
420036c9:	f77c      	movi.n	a7, -1
420036cb:	000046        	j	420036d0 <esp_intr_alloc_intrstatus+0x78>
        force = ETS_INTERNAL_TIMER0_INTR_NO;
420036ce:	670c      	movi.n	a7, 6
    if (source == ETS_INTERNAL_TIMER2_INTR_SOURCE) {
420036d0:	d87c      	movi.n	a8, -3
420036d2:	049287        	bne	a2, a8, 420036da <esp_intr_alloc_intrstatus+0x82>
420036d5:	000246        	j	420036e2 <esp_intr_alloc_intrstatus+0x8a>
        force = ETS_INTERNAL_TIMER1_INTR_NO;
420036d8:	f70c      	movi.n	a7, 15
    if (source == ETS_INTERNAL_SW0_INTR_SOURCE) {
420036da:	c87c      	movi.n	a8, -4
420036dc:	049287        	bne	a2, a8, 420036e4 <esp_intr_alloc_intrstatus+0x8c>
420036df:	000246        	j	420036ec <esp_intr_alloc_intrstatus+0x94>
        force = ETS_INTERNAL_TIMER2_INTR_NO;
420036e2:	071c      	movi.n	a7, 16
    if (source == ETS_INTERNAL_SW1_INTR_SOURCE) {
420036e4:	b87c      	movi.n	a8, -5
420036e6:	049287        	bne	a2, a8, 420036ee <esp_intr_alloc_intrstatus+0x96>
420036e9:	000246        	j	420036f6 <esp_intr_alloc_intrstatus+0x9e>
        force = ETS_INTERNAL_SW0_INTR_NO;
420036ec:	770c      	movi.n	a7, 7
    if (source == ETS_INTERNAL_PROFILING_INTR_SOURCE) {
420036ee:	a87c      	movi.n	a8, -6
420036f0:	099287        	bne	a2, a8, 420036fd <esp_intr_alloc_intrstatus+0xa5>
420036f3:	000106        	j	420036fb <esp_intr_alloc_intrstatus+0xa3>
        force = ETS_INTERNAL_SW1_INTR_NO;
420036f6:	d71c      	movi.n	a7, 29
420036f8:	000046        	j	420036fd <esp_intr_alloc_intrstatus+0xa5>
        force = ETS_INTERNAL_PROFILING_INTR_NO;
420036fb:	b70c      	movi.n	a7, 11
    ret = heap_caps_malloc(sizeof(intr_handle_data_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
420036fd:	f36eb1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42003700:	8a0c      	movi.n	a10, 8
42003702:	f38781        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42003705:	0008e0        	callx8	a8
42003708:	61a9      	s32i.n	a10, a1, 24
    if (ret == NULL) {
4200370a:	23ea16        	beqz	a10, 4200394c <esp_intr_alloc_intrstatus+0x2f4>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4200370d:	fb7c      	movi.n	a11, -1
4200370f:	f38ba1        	l32r	a10, 4200053c <_stext+0x51c> (3fc92050 <spinlock>)
42003712:	f33f81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42003715:	0008e0        	callx8	a8
42003718:	03eb80        	rsr.prid	a8
4200371b:	048d80        	extui	a8, a8, 13, 1
4200371e:	7189      	s32i.n	a8, a1, 28
    int intr = get_available_int(flags, cpu, force, source);
42003720:	02dd      	mov.n	a13, a2
42003722:	07cd      	mov.n	a12, a7
42003724:	08bd      	mov.n	a11, a8
42003726:	03ad      	mov.n	a10, a3
42003728:	ffdbe5        	call8	420034e8 <get_available_int>
4200372b:	0a5d      	mov.n	a5, a10
    if (intr == -1) {
4200372d:	390a66        	bnei	a10, -1, 4200376a <esp_intr_alloc_intrstatus+0x112>
        portEXIT_CRITICAL(&spinlock);
42003730:	f383a1        	l32r	a10, 4200053c <_stext+0x51c> (3fc92050 <spinlock>)
42003733:	f33881        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42003736:	0008e0        	callx8	a8
        free(ret);
42003739:	61a8      	l32i.n	a10, a1, 24
4200373b:	f38b81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200373e:	0008e0        	callx8	a8
        ESP_LOGE(TAG, "No free interrupt inputs for %s interrupt (flags 0x%X)", esp_isr_names[source], flags);
42003741:	f24781        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42003744:	0008e0        	callx8	a8
42003747:	f37e81        	l32r	a8, 42000540 <_stext+0x520> (3c028b48 <esp_isr_names>)
4200374a:	a08280        	addx4	a8, a2, a8
4200374d:	f37db1        	l32r	a11, 42000544 <_stext+0x524> (3c02352c <_flash_rodata_start+0x340c>)
42003750:	0139      	s32i.n	a3, a1, 0
42003752:	08f8      	l32i.n	a15, a8, 0
42003754:	0bed      	mov.n	a14, a11
42003756:	0add      	mov.n	a13, a10
42003758:	f37cc1        	l32r	a12, 42000548 <_stext+0x528> (3c023538 <_flash_rodata_start+0x3418>)
4200375b:	01a0a2        	movi	a10, 1
4200375e:	f24d81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42003761:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
42003764:	05a122        	movi	a2, 0x105
42003767:	007906        	j	4200394f <esp_intr_alloc_intrstatus+0x2f7>
    vector_desc_t *vd = get_desc_for_int(intr, cpu);
4200376a:	0721b2        	l32i	a11, a1, 28
4200376d:	ffbe65        	call8	42003354 <get_desc_for_int>
42003770:	207aa0        	or	a7, a10, a10
    if (vd == NULL) {
42003773:	019a56        	bnez	a10, 42003790 <esp_intr_alloc_intrstatus+0x138>
        portEXIT_CRITICAL(&spinlock);
42003776:	f371a1        	l32r	a10, 4200053c <_stext+0x51c> (3fc92050 <spinlock>)
42003779:	f32681        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200377c:	0008e0        	callx8	a8
        free(ret);
4200377f:	0621a2        	l32i	a10, a1, 24
42003782:	f37981        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42003785:	0008e0        	callx8	a8
        return ESP_ERR_NO_MEM;
42003788:	01a122        	movi	a2, 0x101
4200378b:	007006        	j	4200394f <esp_intr_alloc_intrstatus+0x2f7>
4200378e:	870000        	lsi	f0, a0, 0x21c
    if (flags & ESP_INTR_FLAG_SHARED) {
42003791:	4602e3        	lsi	f14, a2, 0x118
42003794:	b10024        	lsi	f2, a0, 0x2c4
        shared_vector_desc_t *sh_vec = heap_caps_malloc(sizeof(shared_vector_desc_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42003797:	f348      	l32i.n	a4, a3, 60
42003799:	8a1c      	movi.n	a10, 24
4200379b:	f36181        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
4200379e:	0008e0        	callx8	a8
420037a1:	81a9      	s32i.n	a10, a1, 32
        if (sh_vec == NULL) {
420037a3:	5adc      	bnez.n	a10, 420037bc <esp_intr_alloc_intrstatus+0x164>
            portEXIT_CRITICAL(&spinlock);
420037a5:	f365a1        	l32r	a10, 4200053c <_stext+0x51c> (3fc92050 <spinlock>)
420037a8:	f31b81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420037ab:	0008e0        	callx8	a8
            free(ret);
420037ae:	61a8      	l32i.n	a10, a1, 24
420037b0:	f36e81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
420037b3:	0008e0        	callx8	a8
            return ESP_ERR_NO_MEM;
420037b6:	01a122        	movi	a2, 0x101
420037b9:	006486        	j	4200394f <esp_intr_alloc_intrstatus+0x2f7>
        memset(sh_vec, 0, sizeof(shared_vector_desc_t));
420037bc:	8c1c      	movi.n	a12, 24
420037be:	0b0c      	movi.n	a11, 0
420037c0:	81a8      	l32i.n	a10, a1, 32
420037c2:	f2cf81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420037c5:	0008e0        	callx8	a8
        sh_vec->statusreg = (uint32_t*)intrstatusreg;
420037c8:	81b8      	l32i.n	a11, a1, 32
420037ca:	1b49      	s32i.n	a4, a11, 4
        sh_vec->statusmask = intrstatusmask;
420037cc:	4188      	l32i.n	a8, a1, 16
420037ce:	2b89      	s32i.n	a8, a11, 8
        sh_vec->isr = handler;
420037d0:	3b69      	s32i.n	a6, a11, 12
        sh_vec->arg = arg;
420037d2:	5188      	l32i.n	a8, a1, 20
420037d4:	4b89      	s32i.n	a8, a11, 16
        sh_vec->next = vd->shared_vec_info;
420037d6:	1788      	l32i.n	a8, a7, 4
420037d8:	5b89      	s32i.n	a8, a11, 20
        sh_vec->source = source;
420037da:	748020        	extui	a8, a2, 0, 8
420037dd:	988a      	add.n	a9, a8, a8
420037df:	001b82        	l16ui	a8, a11, 0
420037e2:	01aea2        	movi	a10, 0xfffffe01
420037e5:	1088a0        	and	a8, a8, a10
420037e8:	208890        	or	a8, a8, a9
420037eb:	005b82        	s16i	a8, a11, 0
        sh_vec->disabled = 0;
420037ee:	e97c      	movi.n	a9, -2
420037f0:	108890        	and	a8, a8, a9
420037f3:	005b82        	s16i	a8, a11, 0
        vd->shared_vec_info = sh_vec;
420037f6:	17b9      	s32i.n	a11, a7, 4
        vd->flags |= VECDESC_FL_SHARED;
420037f8:	009782        	l16si	a8, a7, 0
420037fb:	490c      	movi.n	a9, 4
420037fd:	208890        	or	a8, a8, a9
42003800:	005782        	s16i	a8, a7, 0
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
42003803:	f81c      	movi.n	a8, 31
42003805:	11b857        	bgeu	a8, a5, 4200381a <esp_intr_alloc_intrstatus+0x1c2>
42003808:	f351d1        	l32r	a13, 4200054c <_stext+0x52c> (3c02357c <_flash_rodata_start+0x345c>)
4200380b:	f351c1        	l32r	a12, 42000550 <_stext+0x530> (3c027d98 <__func__$3>)
4200380e:	74a1b2        	movi	a11, 0x174
42003811:	f350a1        	l32r	a10, 42000554 <_stext+0x534> (3c0235d4 <_flash_rodata_start+0x34b4>)
42003814:	f22b81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42003817:	0008e0        	callx8	a8
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
4200381a:	07cd      	mov.n	a12, a7
4200381c:	f34fb1        	l32r	a11, 42000558 <_stext+0x538> (40376454 <shared_intr_isr>)
4200381f:	05ad      	mov.n	a10, a5
42003821:	139be5        	call8	420171e0 <xt_set_interrupt_handler>
}
42003824:	0018c6        	j	4200388b <esp_intr_alloc_intrstatus+0x233>
42003827:	880c00        	lsi	f0, a12, 0x220
        vd->flags = VECDESC_FL_NONSHARED;
4200382a:	005a82        	s16i	a8, a10, 0
        if (handler) {
4200382d:	f69c      	beqz.n	a6, 42003850 <esp_intr_alloc_intrstatus+0x1f8>
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
4200382f:	f81c      	movi.n	a8, 31
42003831:	11b857        	bgeu	a8, a5, 42003846 <esp_intr_alloc_intrstatus+0x1ee>
42003834:	f346d1        	l32r	a13, 4200054c <_stext+0x52c> (3c02357c <_flash_rodata_start+0x345c>)
42003837:	f346c1        	l32r	a12, 42000550 <_stext+0x530> (3c027d98 <__func__$3>)
4200383a:	74a1b2        	movi	a11, 0x174
4200383d:	f345a1        	l32r	a10, 42000554 <_stext+0x534> (3c0235d4 <_flash_rodata_start+0x34b4>)
42003840:	f22081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42003843:	0008e0        	callx8	a8
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
42003846:	51c8      	l32i.n	a12, a1, 20
42003848:	06bd      	mov.n	a11, a6
4200384a:	20a550        	or	a10, a5, a5
4200384d:	139925        	call8	420171e0 <xt_set_interrupt_handler>
        if (flags & ESP_INTR_FLAG_EDGE) {
42003850:	246397        	bbci	a3, 9, 42003878 <esp_intr_alloc_intrstatus+0x220>
 *
 * @param intr_num Interrupt number (from 0 to 31)
 */
FORCE_INLINE_ATTR void esp_cpu_intr_edge_ack(int intr_num)
{
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
42003853:	f81c      	movi.n	a8, 31
42003855:	11b857        	bgeu	a8, a5, 4200386a <esp_intr_alloc_intrstatus+0x212>
42003858:	f33dd1        	l32r	a13, 4200054c <_stext+0x52c> (3c02357c <_flash_rodata_start+0x345c>)
4200385b:	f340c1        	l32r	a12, 4200055c <_stext+0x53c> (3c027d80 <__func__$2>)
4200385e:	c3a1b2        	movi	a11, 0x1c3
42003861:	f33ca1        	l32r	a10, 42000554 <_stext+0x534> (3c0235d4 <_flash_rodata_start+0x34b4>)
42003864:	f21781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42003867:	0008e0        	callx8	a8
#ifdef __XTENSA__
    xthal_set_intclear((unsigned) (1 << intr_num));
4200386a:	1a0c      	movi.n	a10, 1
4200386c:	401500        	ssl	a5
4200386f:	a1aa00        	sll	a10, a10
42003872:	f33e81        	l32r	a8, 4200056c <_stext+0x54c> (40001be4 <xthal_set_intclear>)
42003875:	0008e0        	callx8	a8
        vd->source = source;
42003878:	749020        	extui	a9, a2, 0, 8
4200387b:	0199a0        	slli	a9, a9, 22
4200387e:	0788      	l32i.n	a8, a7, 0
42003880:	f338a1        	l32r	a10, 42000560 <_stext+0x540> (c03fffff <_rtc_reserved_end+0x602fffff>)
42003883:	1088a0        	and	a8, a8, a10
42003886:	208890        	or	a8, a8, a9
42003889:	0789      	s32i.n	a8, a7, 0
    if (flags & ESP_INTR_FLAG_IRAM) {
4200388b:	2963a7        	bbci	a3, 10, 420038b8 <esp_intr_alloc_intrstatus+0x260>
        vd->flags |= VECDESC_FL_INIRAM;
4200388e:	009782        	l16si	a8, a7, 0
42003891:	290c      	movi.n	a9, 2
42003893:	208890        	or	a8, a8, a9
42003896:	005782        	s16i	a8, a7, 0
        non_iram_int_mask[cpu] &= ~(1<<intr);
42003899:	f33291        	l32r	a9, 42000564 <_stext+0x544> (3fc94be4 <non_iram_int_mask>)
4200389c:	7188      	l32i.n	a8, a1, 28
4200389e:	a09890        	addx4	a9, a8, a9
420038a1:	09a8      	l32i.n	a10, a9, 0
420038a3:	180c      	movi.n	a8, 1
420038a5:	401500        	ssl	a5
420038a8:	a18800        	sll	a8, a8
420038ab:	1088a0        	and	a8, a8, a10
420038ae:	3088a0        	xor	a8, a8, a10
420038b1:	0989      	s32i.n	a8, a9, 0
420038b3:	0008c6        	j	420038da <esp_intr_alloc_intrstatus+0x282>
420038b6:	820000        	mull	a0, a0, a0
        vd->flags &= ~VECDESC_FL_INIRAM;
420038b9:	7c0097        	bnone	a0, a9, 42003939 <esp_intr_alloc_intrstatus+0x2e1>
420038bc:	90d9      	s32i.n	a13, a0, 36
420038be:	1088      	l32i.n	a8, a0, 4
420038c0:	005782        	s16i	a8, a7, 0
        non_iram_int_mask[cpu] |= (1<<intr);
420038c3:	f32881        	l32r	a8, 42000564 <_stext+0x544> (3fc94be4 <non_iram_int_mask>)
420038c6:	7198      	l32i.n	a9, a1, 28
420038c8:	a08980        	addx4	a8, a9, a8
420038cb:	0898      	l32i.n	a9, a8, 0
420038cd:	1a0c      	movi.n	a10, 1
420038cf:	401500        	ssl	a5
420038d2:	a1aa00        	sll	a10, a10
420038d5:	2099a0        	or	a9, a9, a10
420038d8:	0899      	s32i.n	a9, a8, 0
    if (source>=0) {
420038da:	00b296        	bltz	a2, 420038e9 <esp_intr_alloc_intrstatus+0x291>
        esp_rom_route_intr_matrix(cpu, source, intr);
420038dd:	05cd      	mov.n	a12, a5
420038df:	02bd      	mov.n	a11, a2
420038e1:	71a8      	l32i.n	a10, a1, 28
420038e3:	f1fd81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420038e6:	0008e0        	callx8	a8
    ret->vector_desc = vd;
420038e9:	6198      	l32i.n	a9, a1, 24
420038eb:	0979      	s32i.n	a7, a9, 0
    ret->shared_vector_desc = vd->shared_vec_info;
420038ed:	1788      	l32i.n	a8, a7, 4
420038ef:	1989      	s32i.n	a8, a9, 4
    ESP_INTR_ENABLE(intr);
420038f1:	05ad      	mov.n	a10, a5
420038f3:	f24581        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
420038f6:	0008e0        	callx8	a8
    if (flags & ESP_INTR_FLAG_INTRDISABLED) {
420038f9:	0763b7        	bbci	a3, 11, 42003904 <esp_intr_alloc_intrstatus+0x2ac>
        esp_intr_disable(ret);
420038fc:	61a8      	l32i.n	a10, a1, 24
420038fe:	f31c81        	l32r	a8, 42000570 <_stext+0x550> (40376588 <esp_intr_disable>)
42003901:	0008e0        	callx8	a8
    portEXIT_CRITICAL(&spinlock);
42003904:	f30ea1        	l32r	a10, 4200053c <_stext+0x51c> (3fc92050 <spinlock>)
42003907:	f2c381        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200390a:	0008e0        	callx8	a8
    if (ret_handle != NULL) {
4200390d:	142182        	l32i	a8, a1, 80
42003910:	888c      	beqz.n	a8, 4200391c <esp_intr_alloc_intrstatus+0x2c4>
        *ret_handle = ret;
42003912:	6198      	l32i.n	a9, a1, 24
42003914:	0899      	s32i.n	a9, a8, 0
    return ESP_OK;
42003916:	020c      	movi.n	a2, 0
42003918:	000cc6        	j	4200394f <esp_intr_alloc_intrstatus+0x2f7>
4200391b:	61a800        	lsi	f0, a8, 0x184
        free(ret);
4200391e:	f31281        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42003921:	0008e0        	callx8	a8
    return ESP_OK;
42003924:	020c      	movi.n	a2, 0
42003926:	000946        	j	4200394f <esp_intr_alloc_intrstatus+0x2f7>
        return ESP_ERR_INVALID_ARG;
42003929:	02a122        	movi	a2, 0x102
4200392c:	0007c6        	j	4200394f <esp_intr_alloc_intrstatus+0x2f7>
4200392f:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42003932:	060602        	l8ui	a0, a6, 6
42003935:	000000        	ill
        return ESP_ERR_INVALID_ARG;
42003938:	02a122        	movi	a2, 0x102
4200393b:	000406        	j	4200394f <esp_intr_alloc_intrstatus+0x2f7>
4200393e:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
42003941:	0602a1        	l32r	a10, 41fc514c <_coredump_iram_end+0x1c4314c>
42003944:	220002        	l8ui	a0, a0, 34
        return ESP_ERR_INVALID_ARG;
42003947:	8602a1        	l32r	a10, 41fe5150 <_coredump_iram_end+0x1c63150>
4200394a:	220000        	orb	b0, b0, b0
        return ESP_ERR_NO_MEM;
4200394d:	1d01a1        	l32r	a10, 41fcad54 <_coredump_iram_end+0x1c48d54>
}
42003950:	0000f0        	callx12	a0
	...

42003954 <esp_intr_alloc>:
{
42003954:	006136        	entry	a1, 48
42003957:	02ad      	mov.n	a10, a2
42003959:	03bd      	mov.n	a11, a3
4200395b:	04ed      	mov.n	a14, a4
4200395d:	05fd      	mov.n	a15, a5
    return esp_intr_alloc_intrstatus(source, flags, 0, 0, handler, arg, ret_handle);
4200395f:	0169      	s32i.n	a6, a1, 0
42003961:	0d0c      	movi.n	a13, 0
42003963:	0dcd      	mov.n	a12, a13
42003965:	ffcf25        	call8	42003658 <esp_intr_alloc_intrstatus>
}
42003968:	0a2d      	mov.n	a2, a10
4200396a:	f01d      	retw.n

4200396c <s_rtc_isr_noniram_hook>:
{
4200396c:	004136        	entry	a1, 32
    rtc_intr_cache |= rtc_intr_mask;
4200396f:	f30191        	l32r	a9, 42000574 <_stext+0x554> (3fc92a54 <rtc_intr_cache>)
42003972:	0988      	l32i.n	a8, a9, 0
42003974:	208820        	or	a8, a8, a2
42003977:	0989      	s32i.n	a8, a9, 0
}
42003979:	f01d      	retw.n
	...

4200397c <s_rtc_isr_noniram_hook_relieve>:
{
4200397c:	004136        	entry	a1, 32
    rtc_intr_cache &= ~rtc_intr_mask;
4200397f:	f2fd81        	l32r	a8, 42000574 <_stext+0x554> (3fc92a54 <rtc_intr_cache>)
42003982:	0898      	l32i.n	a9, a8, 0
42003984:	102290        	and	a2, a2, a9
42003987:	302290        	xor	a2, a2, a9
4200398a:	0829      	s32i.n	a2, a8, 0
}
4200398c:	f01d      	retw.n
	...

42003990 <rtc_isr_ensure_installed>:
{
42003990:	004136        	entry	a1, 32
42003993:	ffafb2        	movi	a11, -1
42003996:	f2f8a1        	l32r	a10, 42000578 <_stext+0x558> (3fc92a40 <s_rtc_isr_handler_list_lock>)
42003999:	f29d81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200399c:	0008e0        	callx8	a8
    if (s_rtc_isr_handle) {
4200399f:	f2f781        	l32r	a8, 4200057c <_stext+0x55c> (3fc94c1c <s_rtc_isr_handle>)
420039a2:	002882        	l32i	a8, a8, 0
420039a5:	58fc      	bnez.n	a8, 420039de <rtc_isr_ensure_installed+0x4e>
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
420039a7:	0d0c      	movi.n	a13, 0
420039a9:	f2f581        	l32r	a8, 42000580 <_stext+0x560> (60008040 <RTCCNTL+0x40>)
420039ac:	0020c0        	memw
420039af:	08d9      	s32i.n	a13, a8, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
420039b1:	f2f481        	l32r	a8, 42000584 <_stext+0x564> (6000804c <RTCCNTL+0x4c>)
420039b4:	f97c      	movi.n	a9, -1
420039b6:	0020c0        	memw
420039b9:	0899      	s32i.n	a9, a8, 0
    err = esp_intr_alloc(ETS_RTC_CORE_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_isr, NULL, &s_rtc_isr_handle);
420039bb:	f2f0e1        	l32r	a14, 4200057c <_stext+0x55c> (3fc94c1c <s_rtc_isr_handle>)
420039be:	f2f2c1        	l32r	a12, 42000588 <_stext+0x568> (403766e4 <rtc_isr>)
420039c1:	00a4b2        	movi	a11, 0x400
420039c4:	7a2c      	movi.n	a10, 39
420039c6:	fff8e5        	call8	42003954 <esp_intr_alloc>
420039c9:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
420039cb:	1adc      	bnez.n	a10, 420039e0 <rtc_isr_ensure_installed+0x50>
    rtc_isr_cpu = esp_intr_get_cpu(s_rtc_isr_handle);
420039cd:	f2eb81        	l32r	a8, 4200057c <_stext+0x55c> (3fc94c1c <s_rtc_isr_handle>)
420039d0:	08a8      	l32i.n	a10, a8, 0
420039d2:	11eba5        	call8	4201588c <esp_intr_get_cpu>
420039d5:	f2ed81        	l32r	a8, 4200058c <_stext+0x56c> (3fc92a4c <rtc_isr_cpu>)
420039d8:	08a9      	s32i.n	a10, a8, 0
420039da:	000086        	j	420039e0 <rtc_isr_ensure_installed+0x50>
420039dd:	020c00        	andb	b0, b12, b0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
420039e0:	f2e6a1        	l32r	a10, 42000578 <_stext+0x558> (3fc92a40 <s_rtc_isr_handler_list_lock>)
420039e3:	f28c81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420039e6:	0008e0        	callx8	a8
}
420039e9:	f01d      	retw.n
	...

420039ec <rtc_isr_register>:
{
420039ec:	004136        	entry	a1, 32
420039ef:	027d      	mov.n	a7, a2
    esp_err_t err = rtc_isr_ensure_installed();
420039f1:	fff9e5        	call8	42003990 <rtc_isr_ensure_installed>
420039f4:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
420039f6:	04ea56        	bnez	a10, 42003a48 <rtc_isr_register+0x5c>
    rtc_isr_handler_t* item = heap_caps_malloc(sizeof(*item), MALLOC_CAP_INTERNAL);
420039f9:	f2e5b1        	l32r	a11, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
420039fc:	4a1c      	movi.n	a10, 20
420039fe:	f2c881        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42003a01:	0008e0        	callx8	a8
42003a04:	0a6d      	mov.n	a6, a10
    if (item == NULL) {
42003a06:	03ba16        	beqz	a10, 42003a45 <rtc_isr_register+0x59>
    item->handler = handler;
42003a09:	1a79      	s32i.n	a7, a10, 4
    item->handler_arg = handler_arg;
42003a0b:	2a39      	s32i.n	a3, a10, 8
    item->mask = rtc_intr_mask;
42003a0d:	0a49      	s32i.n	a4, a10, 0
    item->flags = flags;
42003a0f:	3a59      	s32i.n	a5, a10, 12
42003a11:	fb7c      	movi.n	a11, -1
42003a13:	f2d9a1        	l32r	a10, 42000578 <_stext+0x558> (3fc92a40 <s_rtc_isr_handler_list_lock>)
42003a16:	f27e81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42003a19:	0008e0        	callx8	a8
    if (flags & RTC_INTR_FLAG_IRAM) {
42003a1c:	086507        	bbci	a5, 0, 42003a28 <rtc_isr_register+0x3c>
        s_rtc_isr_noniram_hook(rtc_intr_mask);
42003a1f:	04ad      	mov.n	a10, a4
42003a21:	fff4a5        	call8	4200396c <s_rtc_isr_noniram_hook>
42003a24:	000146        	j	42003a2d <rtc_isr_register+0x41>
42003a27:	04ad00        	extui	a10, a0, 13, 1
        s_rtc_isr_noniram_hook_relieve(rtc_intr_mask);
42003a2a:	fff525        	call8	4200397c <s_rtc_isr_noniram_hook_relieve>
    SLIST_INSERT_HEAD(&s_rtc_isr_handler_list, item, next);
42003a2d:	f2d981        	l32r	a8, 42000594 <_stext+0x574> (3fc92a48 <s_rtc_isr_handler_list>)
42003a30:	0898      	l32i.n	a9, a8, 0
42003a32:	4699      	s32i.n	a9, a6, 16
42003a34:	006862        	s32i	a6, a8, 0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
42003a37:	f2d0a1        	l32r	a10, 42000578 <_stext+0x558> (3fc92a40 <s_rtc_isr_handler_list_lock>)
42003a3a:	f27681        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42003a3d:	0008e0        	callx8	a8
    return ESP_OK;
42003a40:	000106        	j	42003a48 <rtc_isr_register+0x5c>
42003a43:	220000        	orb	b0, b0, b0
        return ESP_ERR_NO_MEM;
42003a46:	1d01a1        	l32r	a10, 41fcae4c <_coredump_iram_end+0x1c48e4c>
}
42003a49:	0000f0        	callx12	a0

42003a4c <esp_sleep_config_gpio_isolate>:
    }
}
#endif

void esp_sleep_config_gpio_isolate(void)
{
42003a4c:	004136        	entry	a1, 32
42003a4f:	f17781        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42003a52:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "Configure to isolate all GPIO pins in sleep state");
42003a54:	6138b6        	bltui	a8, 3, 42003ab9 <esp_sleep_config_gpio_isolate+0x6d>
42003a57:	f18281        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42003a5a:	0008e0        	callx8	a8
42003a5d:	f2cec1        	l32r	a12, 42000598 <_stext+0x578> (3c02362c <_flash_rodata_start+0x350c>)
42003a60:	20baa0        	or	a11, a10, a10
42003a63:	f2cea1        	l32r	a10, 4200059c <_stext+0x57c> (3c023638 <_flash_rodata_start+0x3518>)
42003a66:	f17f81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42003a69:	0008e0        	callx8	a8
42003a6c:	001246        	j	42003ab9 <esp_sleep_config_gpio_isolate+0x6d>
42003a6f:	960000        	lsi	f0, a0, 0x258
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
        if (GPIO_IS_VALID_GPIO(gpio_num)) {
42003a72:	a203d7        	bnone	a3, a13, 42003a18 <rtc_isr_register+0x2c>
42003a75:	a020a0        	addx4	a2, a0, a10
42003a78:	8210a7        	beq	a0, a10, 420039fe <rtc_isr_register+0x12>
42003a7b:	af          	.byte	0xaf
42003a7c:	ff          	.byte	0xff
42003a7d:	308780        	xor	a8, a7, a8
42003a80:	f2c891        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42003a83:	401800        	ssl	a8
42003a86:	a19900        	sll	a9, a9
42003a89:	f2c681        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42003a8c:	400700        	ssr	a7
42003a8f:	918080        	srl	a8, a8
42003a92:	208980        	or	a8, a9, a8
42003a95:	f2c491        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42003a98:	400700        	ssr	a7
42003a9b:	919090        	srl	a9, a9
42003a9e:	9389a0        	movnez	a8, a9, a10
42003aa1:	0d6807        	bbci	a8, 0, 42003ab2 <esp_sleep_config_gpio_isolate+0x66>
            gpio_sleep_set_direction(gpio_num, GPIO_MODE_DISABLE);
42003aa4:	0b0c      	movi.n	a11, 0
42003aa6:	07ad      	mov.n	a10, a7
42003aa8:	058665        	call8	42009310 <gpio_sleep_set_direction>
            gpio_sleep_set_pull_mode(gpio_num, GPIO_FLOATING);
42003aab:	3b0c      	movi.n	a11, 3
42003aad:	07ad      	mov.n	a10, a7
42003aaf:	058f25        	call8	420093a0 <gpio_sleep_set_pull_mode>
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003ab2:	771b      	addi.n	a7, a7, 1
42003ab4:	000106        	j	42003abc <esp_sleep_config_gpio_isolate+0x70>
42003ab7:	720000        	lsi	f0, a0, 0x1c8
{
42003aba:	3c00a0        	lsi	f10, a0, 240
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003abd:	7708      	l32i.n	a0, a7, 28
42003abf:	afa8      	l32i.n	a10, a15, 40
        gpio_sleep_set_pull_mode(mspi_io_cs1_io_num, GPIO_PULLUP_ONLY);
    }
#endif // CONFIG_ESP_SLEEP_PSRAM_LEAKAGE_WORKAROUND && CONFIG_SPIRAM

#if CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND
    int32_t mspi_io_cs0_io_num = esp_mspi_get_io(ESP_MSPI_IO_CS0);
42003ac1:	3a0c      	movi.n	a10, 3
42003ac3:	0648a5        	call8	42009f4c <esp_mspi_get_io>
    if (GPIO_IS_VALID_GPIO(mspi_io_cs0_io_num)) {
42003ac6:	0b2c      	movi.n	a11, 32
42003ac8:	10bab0        	and	a11, a10, a11
42003acb:	f87c      	movi.n	a8, -1
42003acd:	308a80        	xor	a8, a10, a8
42003ad0:	f2b491        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42003ad3:	401800        	ssl	a8
42003ad6:	a19900        	sll	a9, a9
42003ad9:	f2b281        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42003adc:	400a00        	ssr	a10
42003adf:	918080        	srl	a8, a8
42003ae2:	208980        	or	a8, a9, a8
42003ae5:	f2b091        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42003ae8:	400a00        	ssr	a10
42003aeb:	919090        	srl	a9, a9
42003aee:	9389b0        	movnez	a8, a9, a11
42003af1:	096807        	bbci	a8, 0, 42003afe <esp_sleep_config_gpio_isolate+0xb2>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_CS0), GPIO_PULLUP_ONLY);
42003af4:	3a0c      	movi.n	a10, 3
42003af6:	064565        	call8	42009f4c <esp_mspi_get_io>
42003af9:	0b0c      	movi.n	a11, 0
42003afb:	058a65        	call8	420093a0 <gpio_sleep_set_pull_mode>
    }
#endif // CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND

#if CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_CLK), GPIO_PULLUP_ONLY);
42003afe:	0a0c      	movi.n	a10, 0
42003b00:	0644a5        	call8	42009f4c <esp_mspi_get_io>
42003b03:	0b0c      	movi.n	a11, 0
42003b05:	0589a5        	call8	420093a0 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_Q),   GPIO_PULLUP_ONLY);
42003b08:	1a0c      	movi.n	a10, 1
42003b0a:	064425        	call8	42009f4c <esp_mspi_get_io>
42003b0d:	0b0c      	movi.n	a11, 0
42003b0f:	058925        	call8	420093a0 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D),   GPIO_PULLUP_ONLY);
42003b12:	2a0c      	movi.n	a10, 2
42003b14:	064365        	call8	42009f4c <esp_mspi_get_io>
42003b17:	0b0c      	movi.n	a11, 0
42003b19:	058865        	call8	420093a0 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_HD),  GPIO_PULLUP_ONLY);
42003b1c:	4a0c      	movi.n	a10, 4
42003b1e:	0642e5        	call8	42009f4c <esp_mspi_get_io>
42003b21:	0b0c      	movi.n	a11, 0
42003b23:	0587e5        	call8	420093a0 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_WP),  GPIO_PULLUP_ONLY);
42003b26:	5a0c      	movi.n	a10, 5
42003b28:	064225        	call8	42009f4c <esp_mspi_get_io>
42003b2b:	0b0c      	movi.n	a11, 0
42003b2d:	058725        	call8	420093a0 <gpio_sleep_set_pull_mode>
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    bool octal_mspi_required = bootloader_flash_is_octal_mode_enabled();
42003b30:	f29f81        	l32r	a8, 420005ac <_stext+0x58c> (40377670 <bootloader_flash_is_octal_mode_enabled>)
42003b33:	0008e0        	callx8	a8
#if CONFIG_SPIRAM_MODE_OCT
    octal_mspi_required |= true;
#endif // CONFIG_SPIRAM_MODE_OCT
    if (octal_mspi_required) {
42003b36:	032a16        	beqz	a10, 42003b6c <esp_sleep_config_gpio_isolate+0x120>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_DQS), GPIO_PULLUP_ONLY);
42003b39:	06a0a2        	movi	a10, 6
42003b3c:	0640e5        	call8	42009f4c <esp_mspi_get_io>
42003b3f:	0b0c      	movi.n	a11, 0
42003b41:	0585e5        	call8	420093a0 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D4),  GPIO_PULLUP_ONLY);
42003b44:	7a0c      	movi.n	a10, 7
42003b46:	064065        	call8	42009f4c <esp_mspi_get_io>
42003b49:	0b0c      	movi.n	a11, 0
42003b4b:	058565        	call8	420093a0 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D5),  GPIO_PULLUP_ONLY);
42003b4e:	8a0c      	movi.n	a10, 8
42003b50:	063fa5        	call8	42009f4c <esp_mspi_get_io>
42003b53:	0b0c      	movi.n	a11, 0
42003b55:	0584a5        	call8	420093a0 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D6),  GPIO_PULLUP_ONLY);
42003b58:	9a0c      	movi.n	a10, 9
42003b5a:	063f25        	call8	42009f4c <esp_mspi_get_io>
42003b5d:	0b0c      	movi.n	a11, 0
42003b5f:	058425        	call8	420093a0 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D7),  GPIO_PULLUP_ONLY);
42003b62:	aa0c      	movi.n	a10, 10
42003b64:	063e65        	call8	42009f4c <esp_mspi_get_io>
42003b67:	0b0c      	movi.n	a11, 0
42003b69:	058365        	call8	420093a0 <gpio_sleep_set_pull_mode>
    }
#endif // SOC_SPI_MEM_SUPPORT_OPI_MODE
#endif // CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU
}
42003b6c:	f01d      	retw.n
	...

42003b70 <esp_sleep_enable_gpio_switch>:

void esp_sleep_enable_gpio_switch(bool enable)
{
42003b70:	004136        	entry	a1, 32
42003b73:	742020        	extui	a2, a2, 0, 8
42003b76:	f12d81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42003b79:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "%s automatic switching of GPIO sleep configuration", enable ? "Enable" : "Disable");
42003b7b:	7238b6        	bltui	a8, 3, 42003bf1 <esp_sleep_enable_gpio_switch+0x81>
42003b7e:	f13881        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42003b81:	0008e0        	callx8	a8
42003b84:	0abd      	mov.n	a11, a10
42003b86:	728c      	beqz.n	a2, 42003b91 <esp_sleep_enable_gpio_switch+0x21>
42003b88:	f28ad1        	l32r	a13, 420005b0 <_stext+0x590> (3c023678 <_flash_rodata_start+0x3558>)
42003b8b:	000146        	j	42003b94 <esp_sleep_enable_gpio_switch+0x24>
42003b8e:	000000        	ill
42003b91:	f288d1        	l32r	a13, 420005b4 <_stext+0x594> (3c023680 <_flash_rodata_start+0x3560>)
42003b94:	f281c1        	l32r	a12, 42000598 <_stext+0x578> (3c02362c <_flash_rodata_start+0x350c>)
42003b97:	f288a1        	l32r	a10, 420005b8 <_stext+0x598> (3c023688 <_flash_rodata_start+0x3568>)
42003b9a:	f13281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42003b9d:	0008e0        	callx8	a8
42003ba0:	001346        	j	42003bf1 <esp_sleep_enable_gpio_switch+0x81>
42003ba3:	960000        	lsi	f0, a0, 0x258
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
        if (GPIO_IS_VALID_GPIO(gpio_num)) {
42003ba6:	a20407        	bnone	a4, a0, 42003b4c <esp_sleep_config_gpio_isolate+0x100>
42003ba9:	a020a0        	addx4	a2, a0, a10
42003bac:	8210a7        	beq	a0, a10, 42003b32 <esp_sleep_config_gpio_isolate+0xe6>
42003baf:	af          	.byte	0xaf
42003bb0:	ff          	.byte	0xff
42003bb1:	308780        	xor	a8, a7, a8
42003bb4:	f27b91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42003bb7:	401800        	ssl	a8
42003bba:	a19900        	sll	a9, a9
42003bbd:	f27981        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42003bc0:	400700        	ssr	a7
42003bc3:	918080        	srl	a8, a8
42003bc6:	208980        	or	a8, a9, a8
42003bc9:	f27791        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42003bcc:	400700        	ssr	a7
42003bcf:	919090        	srl	a9, a9
42003bd2:	9389a0        	movnez	a8, a9, a10
42003bd5:	106807        	bbci	a8, 0, 42003be9 <esp_sleep_enable_gpio_switch+0x79>
            if (enable) {
42003bd8:	008216        	beqz	a2, 42003be4 <esp_sleep_enable_gpio_switch+0x74>
                gpio_sleep_sel_en(gpio_num);
42003bdb:	07ad      	mov.n	a10, a7
42003bdd:	058d25        	call8	420094b0 <gpio_sleep_sel_en>
42003be0:	000146        	j	42003be9 <esp_sleep_enable_gpio_switch+0x79>
42003be3:	07ad00        	lsi	f0, a13, 28
            } else {
                gpio_sleep_sel_dis(gpio_num);
42003be6:	0595a5        	call8	42009540 <gpio_sleep_sel_dis>
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003be9:	771b      	addi.n	a7, a7, 1
42003beb:	000106        	j	42003bf3 <esp_sleep_enable_gpio_switch+0x83>
42003bee:	000000        	ill
    ESP_EARLY_LOGI(TAG, "%s automatic switching of GPIO sleep configuration", enable ? "Enable" : "Disable");
42003bf1:	070c      	movi.n	a7, 0
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003bf3:	083c      	movi.n	a8, 48
42003bf5:	aca877        	bge	a8, a7, 42003ba5 <esp_sleep_enable_gpio_switch+0x35>
            }
        }
    }
}
42003bf8:	f01d      	retw.n
	...

42003bfc <__esp_system_init_fn_esp_sleep_startup_init>:
}
#endif

#if CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND || CONFIG_PM_SLP_DISABLE_GPIO
ESP_SYSTEM_INIT_FN(esp_sleep_startup_init, SECONDARY, BIT(0), 105)
{
42003bfc:	004136        	entry	a1, 32
/* If the TOP domain is powered off, the GPIO will also be powered off during sleep,
   and all configurations in the sleep state of GPIO will not take effect.*/
#if !CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP
    // Configure to isolate (disable the Input/Output/Pullup/Pulldown
    // function of the pin) all GPIO pins in sleep state
    esp_sleep_config_gpio_isolate();
42003bff:	ffe4e5        	call8	42003a4c <esp_sleep_config_gpio_isolate>
#endif
    // Enable automatic switching of GPIO configuration
    esp_sleep_enable_gpio_switch(true);
42003c02:	01a0a2        	movi	a10, 1
42003c05:	fff6a5        	call8	42003b70 <esp_sleep_enable_gpio_switch>
    return ESP_OK;
}
42003c08:	00a022        	movi	a2, 0
42003c0b:	f01d      	retw.n
42003c0d:	000000        	ill

42003c10 <esp_deep_sleep_wakeup_io_reset>:
{
42003c10:	004136        	entry	a1, 32
    return REG_GET_FIELD(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL);
42003c13:	f26aa1        	l32r	a10, 420005bc <_stext+0x59c> (600080e0 <RTCCNTL+0xe0>)
42003c16:	0020c0        	memw
42003c19:	0a98      	l32i.n	a9, a10, 0
42003c1b:	119960        	slli	a9, a9, 10
42003c1e:	419a90        	srli	a9, a9, 10
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL_M);
42003c21:	0020c0        	memw
42003c24:	0a88      	l32i.n	a8, a10, 0
42003c26:	958680        	extui	a8, a8, 22, 10
42003c29:	0188a0        	slli	a8, a8, 22
42003c2c:	0020c0        	memw
42003c2f:	0a89      	s32i.n	a8, a10, 0
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
42003c31:	0a0c      	movi.n	a10, 0
42003c33:	000f06        	j	42003c73 <esp_deep_sleep_wakeup_io_reset+0x63>
42003c36:	810000        	src	a0, a0, a0
        int rtcio_num = rtc_io_num_map[gpio_num];
42003c39:	80f262        	s32ri	a6, a2, 0x200
42003c3c:	a08a      	add.n	a10, a0, a8
42003c3e:	08b8      	l32i.n	a11, a8, 0
        if ((rtc_io_mask & BIT(rtcio_num)) == 0) {
42003c40:	2d59b7        	bbc	a9, a11, 42003c71 <esp_deep_sleep_wakeup_io_reset+0x61>
 * @note If disable the pad hold, the status of pad maybe changed in sleep mode.
 * @param rtcio_num The index of rtcio. 0 ~ MAX(rtcio).
 */
static inline void rtcio_ll_force_hold_disable(int rtcio_num)
{
    CLEAR_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, rtc_io_desc[rtcio_num].hold_force);
42003c43:	f260c1        	l32r	a12, 420005c4 <_stext+0x5a4> (600080d8 <RTCCNTL+0xd8>)
42003c46:	0020c0        	memw
42003c49:	0cd8      	l32i.n	a13, a12, 0
42003c4b:	f08bb0        	subx8	a8, a11, a11
42003c4e:	11e8d0        	slli	a14, a8, 3
42003c51:	f25d81        	l32r	a8, 420005c8 <_stext+0x5a8> (3c028d98 <rtc_io_desc>)
42003c54:	88ea      	add.n	a8, a8, a14
42003c56:	a888      	l32i.n	a8, a8, 40
42003c58:	1088d0        	and	a8, a8, a13
42003c5b:	3088d0        	xor	a8, a8, a13
42003c5e:	0020c0        	memw
42003c61:	0c89      	s32i.n	a8, a12, 0
        rtc_io_mask &= ~BIT(rtcio_num);
42003c63:	180c      	movi.n	a8, 1
42003c65:	401b00        	ssl	a11
42003c68:	a18800        	sll	a8, a8
42003c6b:	108890        	and	a8, a8, a9
42003c6e:	309890        	xor	a9, a8, a9
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
42003c71:	aa1b      	addi.n	a10, a10, 1
42003c73:	083c      	movi.n	a8, 48
42003c75:	7288a0        	lsi	f10, a8, 0x1c8
42003c78:	880b      	addi.n	a8, a8, -1
42003c7a:	608080        	neg	a8, a8
42003c7d:	748080        	extui	a8, a8, 0, 8
42003c80:	1b0c      	movi.n	a11, 1
42003c82:	83b990        	moveqz	a11, a9, a9
42003c85:	188c      	beqz.n	a8, 42003c8a <esp_deep_sleep_wakeup_io_reset+0x7a>
42003c87:	fadb56        	bnez	a11, 42003c38 <esp_deep_sleep_wakeup_io_reset+0x28>
}
42003c8a:	f01d      	retw.n

42003c8c <esp_chip_info>:
#include <string.h>
#include "esp_chip_info.h"
#include "hal/efuse_hal.h"

void esp_chip_info(esp_chip_info_t *out_info)
{
42003c8c:	004136        	entry	a1, 32
    memset(out_info, 0, sizeof(*out_info));
42003c8f:	0ca0c2        	movi	a12, 12
42003c92:	00a0b2        	movi	a11, 0
42003c95:	20a220        	or	a10, a2, a2
42003c98:	f19a81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42003c9b:	0008e0        	callx8	a8
    out_info->model = CHIP_ESP32S3;
42003c9e:	980c      	movi.n	a8, 9
42003ca0:	0289      	s32i.n	a8, a2, 0
    out_info->revision = efuse_hal_chip_revision();
42003ca2:	f0f981        	l32r	a8, 42000088 <_stext+0x68> (40375df8 <efuse_hal_chip_revision>)
42003ca5:	0008e0        	callx8	a8
42003ca8:	0452a2        	s16i	a10, a2, 8
    out_info->cores = 2;
42003cab:	280c      	movi.n	a8, 2
42003cad:	0a4282        	s8i	a8, a2, 10
    out_info->features = CHIP_FEATURE_WIFI_BGN | CHIP_FEATURE_BLE;
42003cb0:	281c      	movi.n	a8, 18
42003cb2:	1289      	s32i.n	a8, a2, 4
}
42003cb4:	f01d      	retw.n
	...

42003cb8 <memprot_ll_icache_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_icache_set_pms_area_0(const bool r, const bool w, const bool x)
{
42003cb8:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
42003cbb:	f24481        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003cbe:	0020c0        	memw
42003cc1:	0898      	l32i.n	a9, a8, 0
42003cc3:	f24381        	l32r	a8, 420005d0 <_stext+0x5b0> (ffff8fff <_rtc_reserved_end+0x9fef8fff>)
42003cc6:	109980        	and	a9, a9, a8
    if (r) {
42003cc9:	32cc      	bnez.n	a2, 42003cd0 <memprot_ll_icache_set_pms_area_0+0x18>
    uint32_t permissions = 0;
42003ccb:	080c      	movi.n	a8, 0
42003ccd:	000046        	j	42003cd2 <memprot_ll_icache_set_pms_area_0+0x1a>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003cd0:	180c      	movi.n	a8, 1
    if (w) {
42003cd2:	338c      	beqz.n	a3, 42003cd9 <memprot_ll_icache_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003cd4:	2a0c      	movi.n	a10, 2
42003cd6:	2088a0        	or	a8, a8, a10
    if (x) {
42003cd9:	348c      	beqz.n	a4, 42003ce0 <memprot_ll_icache_set_pms_area_0+0x28>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003cdb:	4a0c      	movi.n	a10, 4
42003cdd:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
42003ce0:	118840        	slli	a8, a8, 12
42003ce3:	248c80        	extui	a8, a8, 12, 3
42003ce6:	118840        	slli	a8, a8, 12
42003ce9:	209980        	or	a9, a9, a8
42003cec:	f23881        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003cef:	0020c0        	memw
42003cf2:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0);
    HAL_ASSERT((expected == memprot_ll_icache_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003cf4:	f01d      	retw.n
	...

42003cf8 <memprot_ll_icache_set_pms_area_1>:

static inline void memprot_ll_icache_set_pms_area_1(const bool r, const bool w, const bool x)
{
42003cf8:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003cfb:	f23481        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003cfe:	0020c0        	memw
42003d01:	0898      	l32i.n	a9, a8, 0
42003d03:	f23481        	l32r	a8, 420005d4 <_stext+0x5b4> (fffc7fff <_rtc_reserved_end+0x9fec7fff>)
42003d06:	109980        	and	a9, a9, a8
    if (r) {
42003d09:	32cc      	bnez.n	a2, 42003d10 <memprot_ll_icache_set_pms_area_1+0x18>
    uint32_t permissions = 0;
42003d0b:	080c      	movi.n	a8, 0
42003d0d:	000046        	j	42003d12 <memprot_ll_icache_set_pms_area_1+0x1a>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003d10:	180c      	movi.n	a8, 1
    if (w) {
42003d12:	338c      	beqz.n	a3, 42003d19 <memprot_ll_icache_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003d14:	2a0c      	movi.n	a10, 2
42003d16:	2088a0        	or	a8, a8, a10
    if (x) {
42003d19:	348c      	beqz.n	a4, 42003d20 <memprot_ll_icache_set_pms_area_1+0x28>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003d1b:	4a0c      	movi.n	a10, 4
42003d1d:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003d20:	118810        	slli	a8, a8, 15
42003d23:	248f80        	extui	a8, a8, 15, 3
42003d26:	118810        	slli	a8, a8, 15
42003d29:	209980        	or	a9, a9, a8
42003d2c:	f22881        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003d2f:	0020c0        	memw
42003d32:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1);
    HAL_ASSERT((expected == memprot_ll_icache_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003d34:	f01d      	retw.n
	...

42003d38 <memprot_ll_prepare_iram0_split_line_regval>:
{
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
}

static inline void memprot_ll_prepare_iram0_split_line_regval(const uint32_t addr, uint32_t* regval)
{
42003d38:	00c136        	entry	a1, 96
    //set category bits for given split line
    uint32_t cat[7] = { MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
42003d3b:	cc1c      	movi.n	a12, 28
42003d3d:	f226b1        	l32r	a11, 420005d8 <_stext+0x5b8> (3c027e8c <__func__$1+0xc>)
42003d40:	a1ca      	add.n	a10, a1, a12
42003d42:	f0b981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003d45:	0008e0        	callx8	a8
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA };
    for (size_t x=0; x<7; x++) {
42003d48:	070c      	movi.n	a7, 0
42003d4a:	0009c6        	j	42003d75 <memprot_ll_prepare_iram0_split_line_regval+0x3d>
        if (addr <= SRAM_RG3_LEVEL_HLIMITS(x)) {
42003d4d:	cc1c      	movi.n	a12, 28
42003d4f:	f223b1        	l32r	a11, 420005dc <_stext+0x5bc> (3c027ea8 <__func__$1+0x28>)
42003d52:	01ad      	mov.n	a10, a1
42003d54:	f0b581        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003d57:	0008e0        	callx8	a8
42003d5a:	a08710        	addx4	a8, a7, a1
42003d5d:	0888      	l32i.n	a8, a8, 0
42003d5f:	093827        	bltu	a8, a2, 42003d6c <memprot_ll_prepare_iram0_split_line_regval+0x34>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
42003d62:	a07710        	addx4	a7, a7, a1
42003d65:	280c      	movi.n	a8, 2
42003d67:	7789      	s32i.n	a8, a7, 28
            break;
42003d69:	0002c6        	j	42003d78 <memprot_ll_prepare_iram0_split_line_regval+0x40>
        } else {
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
42003d6c:	a08710        	addx4	a8, a7, a1
42003d6f:	090c      	movi.n	a9, 0
42003d71:	7899      	s32i.n	a9, a8, 28
    for (size_t x=0; x<7; x++) {
42003d73:	771b      	addi.n	a7, a7, 1
42003d75:	d477b6        	bltui	a7, 7, 42003d4d <memprot_ll_prepare_iram0_split_line_regval+0x15>

    //resolve split address' significant bits
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR_V);

    //write values to required configuration-register
    constrain_reg_fields_t cfg_reg_val = {
42003d78:	81a8      	l32i.n	a10, a1, 32
42003d7a:	14a0a0        	extui	a10, a10, 0, 2
42003d7d:	11aae0        	slli	a10, a10, 2
42003d80:	7188      	l32i.n	a8, a1, 28
42003d82:	148080        	extui	a8, a8, 0, 2
42003d85:	9198      	l32i.n	a9, a1, 36
42003d87:	149090        	extui	a9, a9, 0, 2
42003d8a:	1199c0        	slli	a9, a9, 4
42003d8d:	2088a0        	or	a8, a8, a10
42003d90:	a1a8      	l32i.n	a10, a1, 40
42003d92:	14a0a0        	extui	a10, a10, 0, 2
42003d95:	11aaa0        	slli	a10, a10, 6
42003d98:	208890        	or	a8, a8, a9
42003d9b:	b198      	l32i.n	a9, a1, 44
42003d9d:	149090        	extui	a9, a9, 0, 2
42003da0:	119980        	slli	a9, a9, 8
42003da3:	2088a0        	or	a8, a8, a10
42003da6:	c1a8      	l32i.n	a10, a1, 48
42003da8:	14a0a0        	extui	a10, a10, 0, 2
42003dab:	11aa60        	slli	a10, a10, 10
42003dae:	208890        	or	a8, a8, a9
42003db1:	d198      	l32i.n	a9, a1, 52
42003db3:	149090        	extui	a9, a9, 0, 2
42003db6:	119940        	slli	a9, a9, 12
42003db9:	2088a0        	or	a8, a8, a10
42003dbc:	742820        	extui	a2, a2, 8, 8
42003dbf:	112220        	slli	a2, a2, 14
42003dc2:	208890        	or	a8, a8, a9
42003dc5:	208820        	or	a8, a8, a2
            .cat6 = cat[6],
            .splitaddr = conf_add,
            .reserved = 0
    };

    *regval = cfg_reg_val.val;
42003dc8:	0389      	s32i.n	a8, a3, 0
}
42003dca:	f01d      	retw.n

42003dcc <memprot_ll_set_iram0_split_line>:

// all the split lines registers have the same layout
static inline memprot_hal_err_t memprot_ll_set_iram0_split_line(const void *line_addr, const uint32_t sensitive_reg)
{
42003dcc:	006136        	entry	a1, 48
42003dcf:	20a220        	or	a10, a2, a2
    uint32_t addr = (uint32_t)line_addr;

    //sanity check
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
42003dd2:	f20381        	l32r	a8, 420005e0 <_stext+0x5c0> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
42003dd5:	808280        	add	a8, a2, a8
42003dd8:	f20391        	l32r	a9, 420005e4 <_stext+0x5c4> (67fff <UserFrameTotalSize+0x67eff>)
42003ddb:	163987        	bltu	a9, a8, 42003df5 <memprot_ll_set_iram0_split_line+0x29>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42003dde:	748020        	extui	a8, a2, 0, 8
42003de1:	015856        	bnez	a8, 42003dfa <memprot_ll_set_iram0_split_line+0x2e>

    uint32_t regval;
    memprot_ll_prepare_iram0_split_line_regval(addr, &regval);
42003de4:	01bd      	mov.n	a11, a1
42003de6:	fff525        	call8	42003d38 <memprot_ll_prepare_iram0_split_line_regval>

    REG_WRITE(sensitive_reg, regval);
42003de9:	0188      	l32i.n	a8, a1, 0
42003deb:	0020c0        	memw
42003dee:	0389      	s32i.n	a8, a3, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((REG_READ(sensitive_reg) == regval) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
42003df0:	020c      	movi.n	a2, 0
42003df2:	000186        	j	42003dfc <memprot_ll_set_iram0_split_line+0x30>
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
42003df5:	220c      	movi.n	a2, 2
42003df7:	000046        	j	42003dfc <memprot_ll_set_iram0_split_line+0x30>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42003dfa:	320c      	movi.n	a2, 3
}
42003dfc:	f01d      	retw.n
	...

42003e00 <memprot_ll_iram0_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_iram0_set_pms_area_0(const bool r, const bool w, const bool x)
{
42003e00:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
42003e03:	f1f281        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003e06:	0020c0        	memw
42003e09:	0888      	l32i.n	a8, a8, 0
42003e0b:	897c      	movi.n	a9, -8
42003e0d:	108890        	and	a8, a8, a9
    if (r) {
42003e10:	42cc      	bnez.n	a2, 42003e18 <memprot_ll_iram0_set_pms_area_0+0x18>
    uint32_t permissions = 0;
42003e12:	090c      	movi.n	a9, 0
42003e14:	000086        	j	42003e1a <memprot_ll_iram0_set_pms_area_0+0x1a>
42003e17:	190c00        	lsi	f0, a12, 100
    if (w) {
42003e1a:	338c      	beqz.n	a3, 42003e21 <memprot_ll_iram0_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003e1c:	2a0c      	movi.n	a10, 2
42003e1e:	2099a0        	or	a9, a9, a10
    if (x) {
42003e21:	348c      	beqz.n	a4, 42003e28 <memprot_ll_iram0_set_pms_area_0+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003e23:	4a0c      	movi.n	a10, 4
42003e25:	2099a0        	or	a9, a9, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
42003e28:	249090        	extui	a9, a9, 0, 3
42003e2b:	208890        	or	a8, a8, a9
42003e2e:	f1e791        	l32r	a9, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003e31:	0020c0        	memw
42003e34:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003e36:	f01d      	retw.n

42003e38 <memprot_ll_iram0_set_pms_area_1>:

static inline void memprot_ll_iram0_set_pms_area_1(const bool r, const bool w, const bool x)
{
42003e38:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
42003e3b:	f1e481        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003e3e:	0020c0        	memw
42003e41:	0898      	l32i.n	a9, a8, 0
42003e43:	c7af82        	movi	a8, -57
42003e46:	109980        	and	a9, a9, a8
    if (r) {
42003e49:	32cc      	bnez.n	a2, 42003e50 <memprot_ll_iram0_set_pms_area_1+0x18>
    uint32_t permissions = 0;
42003e4b:	080c      	movi.n	a8, 0
42003e4d:	000046        	j	42003e52 <memprot_ll_iram0_set_pms_area_1+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003e50:	180c      	movi.n	a8, 1
    if (w) {
42003e52:	338c      	beqz.n	a3, 42003e59 <memprot_ll_iram0_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003e54:	2a0c      	movi.n	a10, 2
42003e56:	2088a0        	or	a8, a8, a10
    if (x) {
42003e59:	348c      	beqz.n	a4, 42003e60 <memprot_ll_iram0_set_pms_area_1+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003e5b:	4a0c      	movi.n	a10, 4
42003e5d:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
42003e60:	1188d0        	slli	a8, a8, 3
42003e63:	8a3c      	movi.n	a10, 56
42003e65:	1088a0        	and	a8, a8, a10
42003e68:	209980        	or	a9, a9, a8
42003e6b:	f1d881        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003e6e:	0020c0        	memw
42003e71:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003e73:	f01d      	retw.n
42003e75:	000000        	ill

42003e78 <memprot_ll_iram0_set_pms_area_2>:

static inline void memprot_ll_iram0_set_pms_area_2(const bool r, const bool w, const bool x)
{
42003e78:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
42003e7b:	f1d481        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003e7e:	0020c0        	memw
42003e81:	0898      	l32i.n	a9, a8, 0
42003e83:	3fae82        	movi	a8, 0xfffffe3f
42003e86:	109980        	and	a9, a9, a8
    if (r) {
42003e89:	32cc      	bnez.n	a2, 42003e90 <memprot_ll_iram0_set_pms_area_2+0x18>
    uint32_t permissions = 0;
42003e8b:	080c      	movi.n	a8, 0
42003e8d:	000046        	j	42003e92 <memprot_ll_iram0_set_pms_area_2+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003e90:	180c      	movi.n	a8, 1
    if (w) {
42003e92:	338c      	beqz.n	a3, 42003e99 <memprot_ll_iram0_set_pms_area_2+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003e94:	2a0c      	movi.n	a10, 2
42003e96:	2088a0        	or	a8, a8, a10
    if (x) {
42003e99:	348c      	beqz.n	a4, 42003ea0 <memprot_ll_iram0_set_pms_area_2+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003e9b:	4a0c      	movi.n	a10, 4
42003e9d:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
42003ea0:	1188a0        	slli	a8, a8, 6
42003ea3:	c0a1a2        	movi	a10, 0x1c0
42003ea6:	1088a0        	and	a8, a8, a10
42003ea9:	209980        	or	a9, a9, a8
42003eac:	f1c881        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003eaf:	0020c0        	memw
42003eb2:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003eb4:	f01d      	retw.n
	...

42003eb8 <memprot_ll_iram0_set_pms_area_3>:

static inline void memprot_ll_iram0_set_pms_area_3(const bool r, const bool w, const bool x)
{
42003eb8:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
42003ebb:	f1c481        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003ebe:	0020c0        	memw
42003ec1:	0898      	l32i.n	a9, a8, 0
42003ec3:	f1c981        	l32r	a8, 420005e8 <_stext+0x5c8> (fffff1ff <_rtc_reserved_end+0x9feff1ff>)
42003ec6:	109980        	and	a9, a9, a8
    if (r) {
42003ec9:	32cc      	bnez.n	a2, 42003ed0 <memprot_ll_iram0_set_pms_area_3+0x18>
    uint32_t permissions = 0;
42003ecb:	080c      	movi.n	a8, 0
42003ecd:	000046        	j	42003ed2 <memprot_ll_iram0_set_pms_area_3+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003ed0:	180c      	movi.n	a8, 1
    if (w) {
42003ed2:	338c      	beqz.n	a3, 42003ed9 <memprot_ll_iram0_set_pms_area_3+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003ed4:	2a0c      	movi.n	a10, 2
42003ed6:	2088a0        	or	a8, a8, a10
    if (x) {
42003ed9:	348c      	beqz.n	a4, 42003ee0 <memprot_ll_iram0_set_pms_area_3+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003edb:	4a0c      	movi.n	a10, 4
42003edd:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
42003ee0:	118870        	slli	a8, a8, 9
42003ee3:	248980        	extui	a8, a8, 9, 3
42003ee6:	118870        	slli	a8, a8, 9
42003ee9:	209980        	or	a9, a9, a8
42003eec:	f1b881        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003eef:	0020c0        	memw
42003ef2:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003ef4:	f01d      	retw.n
	...

42003ef8 <memprot_ll_iram0_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_iram0_get_monitor_lock(const int core, bool* locked)
{
42003ef8:	004136        	entry	a1, 32
    switch (core) {
42003efb:	628c      	beqz.n	a2, 42003f05 <memprot_ll_iram0_get_monitor_lock+0xd>
42003efd:	1b1226        	beqi	a2, 1, 42003f1c <memprot_ll_iram0_get_monitor_lock+0x24>
42003f00:	720c      	movi.n	a2, 7
42003f02:	000ac6        	j	42003f31 <memprot_ll_iram0_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG) == 1;
42003f05:	f1b981        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e4 <SYSTEM+0x10e4>)
42003f08:	0020c0        	memw
42003f0b:	0888      	l32i.n	a8, a8, 0
42003f0d:	880b      	addi.n	a8, a8, -1
42003f0f:	40f880        	nsau	a8, a8
42003f12:	418580        	srli	a8, a8, 5
42003f15:	004382        	s8i	a8, a3, 0
            break;
42003f18:	000546        	j	42003f31 <memprot_ll_iram0_get_monitor_lock+0x39>
42003f1b:	b58100        	extui	a8, a0, 17, 12
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG) == 1;
42003f1e:	20c0f1        	l32r	a15, 41fcc220 <_coredump_iram_end+0x1c4a220>
42003f21:	088800        	lsx	f8, a8, a0
42003f24:	880b      	addi.n	a8, a8, -1
42003f26:	40f880        	nsau	a8, a8
42003f29:	418580        	srli	a8, a8, 5
42003f2c:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003f2f:	020c      	movi.n	a2, 0
}
42003f31:	f01d      	retw.n
	...

42003f34 <memprot_ll_iram0_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_iram0_set_monitor_en(const int core, const bool enable)
{
42003f34:	004136        	entry	a1, 32
    switch (core) {
42003f37:	628c      	beqz.n	a2, 42003f41 <memprot_ll_iram0_set_monitor_en+0xd>
42003f39:	301226        	beqi	a2, 1, 42003f6d <memprot_ll_iram0_set_monitor_en+0x39>
42003f3c:	720c      	movi.n	a2, 7
42003f3e:	001606        	j	42003f9a <memprot_ll_iram0_set_monitor_en+0x66>
        case PRO_CPU_NUM:
            if (enable) {
42003f41:	339c      	beqz.n	a3, 42003f58 <memprot_ll_iram0_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003f43:	f1ac91        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003f46:	0020c0        	memw
42003f49:	0988      	l32i.n	a8, a9, 0
42003f4b:	2a0c      	movi.n	a10, 2
42003f4d:	2088a0        	or	a8, a8, a10
42003f50:	0020c0        	memw
42003f53:	0989      	s32i.n	a8, a9, 0
42003f55:	001046        	j	42003f9a <memprot_ll_iram0_set_monitor_en+0x66>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003f58:	f1a791        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003f5b:	0020c0        	memw
42003f5e:	0988      	l32i.n	a8, a9, 0
42003f60:	da7c      	movi.n	a10, -3
42003f62:	1088a0        	and	a8, a8, a10
42003f65:	0020c0        	memw
42003f68:	0989      	s32i.n	a8, a9, 0
42003f6a:	000b06        	j	42003f9a <memprot_ll_iram0_set_monitor_en+0x66>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
42003f6d:	539c      	beqz.n	a3, 42003f86 <memprot_ll_iram0_set_monitor_en+0x52>
                REG_SET_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003f6f:	f1a291        	l32r	a9, 420005f8 <_stext+0x5d8> (600c10f4 <SYSTEM+0x10f4>)
42003f72:	0020c0        	memw
42003f75:	0988      	l32i.n	a8, a9, 0
42003f77:	2a0c      	movi.n	a10, 2
42003f79:	2088a0        	or	a8, a8, a10
42003f7c:	0020c0        	memw
42003f7f:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003f81:	020c      	movi.n	a2, 0
42003f83:	0004c6        	j	42003f9a <memprot_ll_iram0_set_monitor_en+0x66>
                REG_CLR_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003f86:	f19c91        	l32r	a9, 420005f8 <_stext+0x5d8> (600c10f4 <SYSTEM+0x10f4>)
42003f89:	0020c0        	memw
42003f8c:	0988      	l32i.n	a8, a9, 0
42003f8e:	da7c      	movi.n	a10, -3
42003f90:	1088a0        	and	a8, a8, a10
42003f93:	0020c0        	memw
42003f96:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
42003f98:	020c      	movi.n	a2, 0
}
42003f9a:	f01d      	retw.n

42003f9c <memprot_ll_iram0_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_iram0_get_monitor_en(const int core, bool* enabled)
{
42003f9c:	004136        	entry	a1, 32
    switch (core) {
42003f9f:	628c      	beqz.n	a2, 42003fa9 <memprot_ll_iram0_get_monitor_en+0xd>
42003fa1:	171226        	beqi	a2, 1, 42003fbc <memprot_ll_iram0_get_monitor_en+0x20>
42003fa4:	720c      	movi.n	a2, 7
42003fa6:	000886        	j	42003fcc <memprot_ll_iram0_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
42003fa9:	f19281        	l32r	a8, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003fac:	0020c0        	memw
42003faf:	0888      	l32i.n	a8, a8, 0
42003fb1:	048180        	extui	a8, a8, 1, 1
42003fb4:	004382        	s8i	a8, a3, 0
            break;
42003fb7:	000446        	j	42003fcc <memprot_ll_iram0_get_monitor_en+0x30>
42003fba:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
42003fbd:	8f          	.byte	0x8f
42003fbe:	20c0f1        	l32r	a15, 41fcc2c0 <_coredump_iram_end+0x1c4a2c0>
42003fc1:	088800        	lsx	f8, a8, a0
42003fc4:	048180        	extui	a8, a8, 1, 1
42003fc7:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003fca:	020c      	movi.n	a2, 0
}
42003fcc:	f01d      	retw.n
	...

42003fd0 <memprot_ll_iram0_set_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_iram0_set_monitor_intrclr(const int core)
{
42003fd0:	004136        	entry	a1, 32
    switch (core) {
42003fd3:	628c      	beqz.n	a2, 42003fdd <memprot_ll_iram0_set_monitor_intrclr+0xd>
42003fd5:	1b1226        	beqi	a2, 1, 42003ff4 <memprot_ll_iram0_set_monitor_intrclr+0x24>
42003fd8:	720c      	movi.n	a2, 7
42003fda:	000a86        	j	42004008 <memprot_ll_iram0_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42003fdd:	f18591        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003fe0:	0020c0        	memw
42003fe3:	0988      	l32i.n	a8, a9, 0
42003fe5:	1a0c      	movi.n	a10, 1
42003fe7:	2088a0        	or	a8, a8, a10
42003fea:	0020c0        	memw
42003fed:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
42003fef:	000546        	j	42004008 <memprot_ll_iram0_set_monitor_intrclr+0x38>
42003ff2:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42003ff5:	c0f181        	l32r	a8, 41ff43bc <_coredump_iram_end+0x1c723bc>
42003ff8:	880020        	lsi	f2, a0, 0x220
42003ffb:	0c09      	s32i.n	a0, a12, 0
42003ffd:	a01a      	add.n	a10, a0, a1
42003fff:	2088      	l32i.n	a8, a0, 8
42004001:	0020c0        	memw
42004004:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004006:	020c      	movi.n	a2, 0
}
42004008:	f01d      	retw.n
	...

4200400c <memprot_ll_iram0_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_iram0_reset_monitor_intrclr(const int core)
{
4200400c:	004136        	entry	a1, 32
    switch (core) {
4200400f:	628c      	beqz.n	a2, 42004019 <memprot_ll_iram0_reset_monitor_intrclr+0xd>
42004011:	1b1226        	beqi	a2, 1, 42004030 <memprot_ll_iram0_reset_monitor_intrclr+0x24>
42004014:	720c      	movi.n	a2, 7
42004016:	000a86        	j	42004044 <memprot_ll_iram0_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42004019:	f17691        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
4200401c:	0020c0        	memw
4200401f:	0988      	l32i.n	a8, a9, 0
42004021:	ea7c      	movi.n	a10, -2
42004023:	1088a0        	and	a8, a8, a10
42004026:	0020c0        	memw
42004029:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
4200402b:	000546        	j	42004044 <memprot_ll_iram0_reset_monitor_intrclr+0x38>
4200402e:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42004031:	c0f172        	s32ri	a7, a1, 0x300
42004034:	880020        	lsi	f2, a0, 0x220
42004037:	7c09      	s32i.n	a0, a12, 28
42004039:	a0ea      	add.n	a10, a0, a14
4200403b:	1088      	l32i.n	a8, a0, 4
4200403d:	0020c0        	memw
42004040:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004042:	020c      	movi.n	a2, 0
}
42004044:	f01d      	retw.n
	...

42004048 <memprot_ll_get_pif_constraint_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_get_pif_constraint_lock(const int core, bool* locked)
{
42004048:	004136        	entry	a1, 32
    switch (core) {
4200404b:	628c      	beqz.n	a2, 42004055 <memprot_ll_get_pif_constraint_lock+0xd>
4200404d:	1b1226        	beqi	a2, 1, 4200406c <memprot_ll_get_pif_constraint_lock+0x24>
42004050:	720c      	movi.n	a2, 7
42004052:	000ac6        	j	42004081 <memprot_ll_get_pif_constraint_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG) == 1;
42004055:	f16981        	l32r	a8, 420005fc <_stext+0x5dc> (600c1124 <SYSTEM+0x1124>)
42004058:	0020c0        	memw
4200405b:	0888      	l32i.n	a8, a8, 0
4200405d:	880b      	addi.n	a8, a8, -1
4200405f:	40f880        	nsau	a8, a8
42004062:	418580        	srli	a8, a8, 5
42004065:	004382        	s8i	a8, a3, 0
            break;
42004068:	000546        	j	42004081 <memprot_ll_get_pif_constraint_lock+0x39>
4200406b:	658100        	extui	a8, a0, 17, 7
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG) == 1;
4200406e:	20c0f1        	l32r	a15, 41fcc370 <_coredump_iram_end+0x1c4a370>
42004071:	088800        	lsx	f8, a8, a0
42004074:	880b      	addi.n	a8, a8, -1
42004076:	40f880        	nsau	a8, a8
42004079:	418580        	srli	a8, a8, 5
4200407c:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200407f:	020c      	movi.n	a2, 0
}
42004081:	f01d      	retw.n
	...

42004084 <memprot_ll_set_rtcfast_split_line>:
/* ********************************
 * IRAM0 RTCFAST - SPLIT LINES
 */

static inline memprot_hal_err_t memprot_ll_set_rtcfast_split_line(const int core, const void *line_addr, const memprot_hal_world_t world)
{
42004084:	004136        	entry	a1, 32
    uint32_t addr = (uint32_t)line_addr;

    if (addr < SOC_RTC_IRAM_LOW || addr >= SOC_RTC_IRAM_HIGH) {
42004087:	f09a81        	l32r	a8, 420002f0 <_stext+0x2d0> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4200408a:	838a      	add.n	a8, a3, a8
4200408c:	f09a91        	l32r	a9, 420002f4 <_stext+0x2d4> (1fff <UserFrameTotalSize+0x1eff>)
4200408f:	523987        	bltu	a9, a8, 420040e5 <memprot_ll_set_rtcfast_split_line+0x61>
        return MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE;
    }

    if (addr % 0x4 != 0) {
42004092:	148030        	extui	a8, a3, 0, 2
42004095:	051856        	bnez	a8, 420040ea <memprot_ll_set_rtcfast_split_line+0x66>
        return MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED;
    }

    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42004098:	5422f6        	bgeui	a2, 2, 420040f0 <memprot_ll_set_rtcfast_split_line+0x6c>
    }

    uint32_t mask;
    uint32_t val;

    switch (world) {
4200409b:	091426        	beqi	a4, 1, 420040a8 <memprot_ll_set_rtcfast_split_line+0x24>
4200409e:	53b466        	bnei	a4, 16, 420040f5 <memprot_ll_set_rtcfast_split_line+0x71>
    case MEMP_HAL_WORLD_0:
        mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_M;
        val = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_V : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_V;
        break;
    case MEMP_HAL_WORLD_1:
        mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1_M;
420040a1:	f158a1        	l32r	a10, 42000604 <_stext+0x5e4> (3ff800 <UserFrameTotalSize+0x3ff700>)
420040a4:	0000c6        	j	420040ab <memprot_ll_set_rtcfast_split_line+0x27>
420040a7:	a7a200        	lsi	f0, a2, 0x29c
    switch (world) {
420040aa:	ff          	.byte	0xff
        break;
    default:
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_9_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_9_REG;
420040ab:	52cc      	bnez.n	a2, 420040b4 <memprot_ll_set_rtcfast_split_line+0x30>
420040ad:	f15691        	l32r	a9, 42000608 <_stext+0x5e8> (600c1148 <SYSTEM+0x1148>)
420040b0:	0000c6        	j	420040b7 <memprot_ll_set_rtcfast_split_line+0x33>
420040b3:	569100        	lsi	f0, a1, 0x158
420040b6:	20c0f1        	l32r	a15, 41fcc3b8 <_coredump_iram_end+0x1c4a3b8>

    CLEAR_PERI_REG_MASK(reg, mask);
420040b9:	09b800        	l32e	a0, a8, -20
420040bc:	108ab0        	and	a8, a10, a11
420040bf:	3088b0        	xor	a8, a8, a11
420040c2:	0020c0        	memw
420040c5:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((GET_PERI_REG_MASK(reg, mask) == 0) && "Value not stored to required register");
#endif
    REG_SET_BITS(reg, mask, (addr >> 2) & val);
420040c7:	0020c0        	memw
420040ca:	09b8      	l32i.n	a11, a9, 0
420040cc:	a43230        	extui	a3, a3, 2, 11
420040cf:	1083b0        	and	a8, a3, a11
420040d2:	3088b0        	xor	a8, a8, a11
420040d5:	1033a0        	and	a3, a3, a10
420040d8:	208830        	or	a8, a8, a3
420040db:	0020c0        	memw
420040de:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_READ(reg) & mask;
    HAL_ASSERT((expected == ((addr >> 2) & val)) && "Value not stored to required register");
#endif
    return MEMP_HAL_OK;
420040e0:	020c      	movi.n	a2, 0
420040e2:	000446        	j	420040f7 <memprot_ll_set_rtcfast_split_line+0x73>
        return MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE;
420040e5:	220c      	movi.n	a2, 2
420040e7:	000306        	j	420040f7 <memprot_ll_set_rtcfast_split_line+0x73>
        return MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED;
420040ea:	320c      	movi.n	a2, 3
420040ec:	0001c6        	j	420040f7 <memprot_ll_set_rtcfast_split_line+0x73>
420040ef:	720c00        	lsi	f0, a12, 0x1c8
        return MEMP_HAL_ERR_CORE_INVALID;
420040f2:	000046        	j	420040f7 <memprot_ll_set_rtcfast_split_line+0x73>
    switch (world) {
420040f5:	620c      	movi.n	a2, 6
}
420040f7:	f01d      	retw.n
420040f9:	000000        	ill

420040fc <memprot_ll_rtcfast_set_pms_area>:

    return permissions;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_set_pms_area(const int core, const bool r, const bool w, const bool x, const memprot_hal_world_t world, const memprot_hal_area_t area)
{
420040fc:	004136        	entry	a1, 32
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
420040ff:	0222b6        	bltui	a2, 2, 42004105 <memprot_ll_rtcfast_set_pms_area+0x9>
42004102:	003386        	j	420041d4 <memprot_ll_rtcfast_set_pms_area+0xd8>
    }

    uint32_t bits;
    uint32_t mask;

    switch (world) {
42004105:	071626        	beqi	a6, 1, 42004110 <memprot_ll_rtcfast_set_pms_area+0x14>
42004108:	48b626        	beqi	a6, 16, 42004154 <memprot_ll_rtcfast_set_pms_area+0x58>
4200410b:	620c      	movi.n	a2, 6
4200410d:	003146        	j	420041d6 <memprot_ll_rtcfast_set_pms_area+0xda>
    case MEMP_HAL_WORLD_0: {
        switch (area) {
42004110:	081726        	beqi	a7, 1, 4200411c <memprot_ll_rtcfast_set_pms_area+0x20>
42004113:	232726        	beqi	a7, 2, 4200413a <memprot_ll_rtcfast_set_pms_area+0x3e>
42004116:	520c      	movi.n	a2, 5
42004118:	002e86        	j	420041d6 <memprot_ll_rtcfast_set_pms_area+0xda>
4200411b:	43cc00        	min	a12, a12, a0
    uint32_t permissions = 0;
4200411e:	070c      	movi.n	a7, 0
42004120:	000086        	j	42004126 <memprot_ll_rtcfast_set_pms_area+0x2a>
42004123:	270c00        	lsi	f0, a12, 156
    if (w) {
42004126:	348c      	beqz.n	a4, 4200412d <memprot_ll_rtcfast_set_pms_area+0x31>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004128:	180c      	movi.n	a8, 1
4200412a:	207780        	or	a7, a7, a8
    if (x) {
4200412d:	06c516        	beqz	a5, 4200419d <memprot_ll_rtcfast_set_pms_area+0xa1>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42004130:	480c      	movi.n	a8, 4
42004132:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_LOW:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_S);
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M;
42004135:	7b0c      	movi.n	a11, 7
42004137:	001906        	j	4200419f <memprot_ll_rtcfast_set_pms_area+0xa3>
    if (r) {
4200413a:	03cc      	bnez.n	a3, 4200413e <memprot_ll_rtcfast_set_pms_area+0x42>
    uint32_t permissions = 0;
4200413c:	070c      	movi.n	a7, 0
    if (w) {
4200413e:	348c      	beqz.n	a4, 42004145 <memprot_ll_rtcfast_set_pms_area+0x49>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004140:	180c      	movi.n	a8, 1
42004142:	207780        	or	a7, a7, a8
    if (x) {
42004145:	358c      	beqz.n	a5, 4200414c <memprot_ll_rtcfast_set_pms_area+0x50>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42004147:	480c      	movi.n	a8, 4
42004149:	207780        	or	a7, a7, a8
            break;
        case MEMP_HAL_AREA_HIGH:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S);
4200414c:	1177d0        	slli	a7, a7, 3
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_M;
4200414f:	8b3c      	movi.n	a11, 56
            break;
42004151:	001286        	j	4200419f <memprot_ll_rtcfast_set_pms_area+0xa3>
        default:
            return MEMP_HAL_ERR_AREA_INVALID;
        }
    } break;
    case MEMP_HAL_WORLD_1: {
        switch (area) {
42004154:	081726        	beqi	a7, 1, 42004160 <memprot_ll_rtcfast_set_pms_area+0x64>
42004157:	262726        	beqi	a7, 2, 42004181 <memprot_ll_rtcfast_set_pms_area+0x85>
4200415a:	520c      	movi.n	a2, 5
4200415c:	001d86        	j	420041d6 <memprot_ll_rtcfast_set_pms_area+0xda>
4200415f:	43cc00        	min	a12, a12, a0
    uint32_t permissions = 0;
42004162:	070c      	movi.n	a7, 0
42004164:	000086        	j	4200416a <memprot_ll_rtcfast_set_pms_area+0x6e>
42004167:	270c00        	lsi	f0, a12, 156
    if (w) {
4200416a:	348c      	beqz.n	a4, 42004171 <memprot_ll_rtcfast_set_pms_area+0x75>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
4200416c:	180c      	movi.n	a8, 1
4200416e:	207780        	or	a7, a7, a8
    if (x) {
42004171:	358c      	beqz.n	a5, 42004178 <memprot_ll_rtcfast_set_pms_area+0x7c>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42004173:	480c      	movi.n	a8, 4
42004175:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_LOW:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_S);
42004178:	1177a0        	slli	a7, a7, 6
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_M;
4200417b:	c0a1b2        	movi	a11, 0x1c0
            break;
4200417e:	000746        	j	4200419f <memprot_ll_rtcfast_set_pms_area+0xa3>
    if (r) {
42004181:	13cc      	bnez.n	a3, 42004186 <memprot_ll_rtcfast_set_pms_area+0x8a>
    uint32_t permissions = 0;
42004183:	00a072        	movi	a7, 0
    if (w) {
42004186:	348c      	beqz.n	a4, 4200418d <memprot_ll_rtcfast_set_pms_area+0x91>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004188:	180c      	movi.n	a8, 1
4200418a:	207780        	or	a7, a7, a8
    if (x) {
4200418d:	358c      	beqz.n	a5, 42004194 <memprot_ll_rtcfast_set_pms_area+0x98>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
4200418f:	480c      	movi.n	a8, 4
42004191:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_HIGH:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_S);
42004194:	117770        	slli	a7, a7, 9
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_M;
42004197:	f11eb1        	l32r	a11, 42000610 <_stext+0x5f0> (e00 <UserFrameTotalSize+0xd00>)
            break;
4200419a:	000046        	j	4200419f <memprot_ll_rtcfast_set_pms_area+0xa3>
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M;
4200419d:	7b0c      	movi.n	a11, 7
    } break;
    default:
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG;
4200419f:	52cc      	bnez.n	a2, 420041a8 <memprot_ll_rtcfast_set_pms_area+0xac>
420041a1:	f11c81        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
420041a4:	0000c6        	j	420041ab <memprot_ll_rtcfast_set_pms_area+0xaf>
420041a7:	1c8100        	lsi	f0, a1, 112
420041aa:	20c0f1        	l32r	a15, 41fcc4ac <_coredump_iram_end+0x1c4a4ac>

    CLEAR_PERI_REG_MASK(reg, mask);
420041ad:	08a800        	lsx	f10, a8, a0
420041b0:	109ba0        	and	a9, a11, a10
420041b3:	3099a0        	xor	a9, a9, a10
420041b6:	0020c0        	memw
420041b9:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((GET_PERI_REG_MASK(reg, mask) == 0) && "Value not stored to required register");
#endif
    REG_SET_BITS(reg, bits, mask);
420041bb:	0020c0        	memw
420041be:	0898      	l32i.n	a9, a8, 0
420041c0:	307970        	xor	a7, a9, a7
420041c3:	1077b0        	and	a7, a7, a11
420041c6:	307790        	xor	a7, a7, a9
420041c9:	0020c0        	memw
420041cc:	0879      	s32i.n	a7, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_READ(reg) & mask;
    HAL_ASSERT((expected == bits) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
420041ce:	020c      	movi.n	a2, 0
420041d0:	000086        	j	420041d6 <memprot_ll_rtcfast_set_pms_area+0xda>
420041d3:	720c00        	lsi	f0, a12, 0x1c8
}
420041d6:	f01d      	retw.n

420041d8 <memprot_ll_rtcfast_get_pms_area>:
    *w = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
    *x = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_get_pms_area(const int core, bool *r, bool *w, bool *x, const memprot_hal_world_t world, const memprot_hal_area_t area)
{
420041d8:	004136        	entry	a1, 32
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
420041db:	0222b6        	bltui	a2, 2, 420041e1 <memprot_ll_rtcfast_get_pms_area+0x9>
420041de:	002d06        	j	42004296 <memprot_ll_rtcfast_get_pms_area+0xbe>
        return MEMP_HAL_ERR_CORE_INVALID;
    }

    uint32_t permissions = 0;

    switch (world) {
420041e1:	071626        	beqi	a6, 1, 420041ec <memprot_ll_rtcfast_get_pms_area+0x14>
420041e4:	50b626        	beqi	a6, 16, 42004238 <memprot_ll_rtcfast_get_pms_area+0x60>
420041e7:	620c      	movi.n	a2, 6
420041e9:	002ac6        	j	42004298 <memprot_ll_rtcfast_get_pms_area+0xc0>
    case MEMP_HAL_WORLD_0: {
        switch (area) {
420041ec:	081726        	beqi	a7, 1, 420041f8 <memprot_ll_rtcfast_get_pms_area+0x20>
420041ef:	232726        	beqi	a7, 2, 42004216 <memprot_ll_rtcfast_get_pms_area+0x3e>
420041f2:	520c      	movi.n	a2, 5
420041f4:	002806        	j	42004298 <memprot_ll_rtcfast_get_pms_area+0xc0>
420041f7:	c2cc00        	quou	a12, a12, a0
        case MEMP_HAL_AREA_LOW:
            if (core == PRO_CPU_NUM) {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L);
420041fa:	f10681        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
420041fd:	0020c0        	memw
42004200:	0888      	l32i.n	a8, a8, 0
42004202:	248080        	extui	a8, a8, 0, 3
42004205:	001d86        	j	4200427f <memprot_ll_rtcfast_get_pms_area+0xa7>
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
42004208:	f10481        	l32r	a8, 42000618 <_stext+0x5f8> (600c11f8 <SYSTEM+0x11f8>)
4200420b:	0020c0        	memw
4200420e:	0888      	l32i.n	a8, a8, 0
42004210:	248680        	extui	a8, a8, 6, 3
42004213:	001a06        	j	4200427f <memprot_ll_rtcfast_get_pms_area+0xa7>
            }
            break;
        case MEMP_HAL_AREA_HIGH:
            if (core == PRO_CPU_NUM) {
42004216:	e2cc      	bnez.n	a2, 42004228 <memprot_ll_rtcfast_get_pms_area+0x50>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
42004218:	f0ff81        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
4200421b:	0020c0        	memw
4200421e:	0888      	l32i.n	a8, a8, 0
42004220:	248380        	extui	a8, a8, 3, 3
42004223:	001606        	j	4200427f <memprot_ll_rtcfast_get_pms_area+0xa7>
42004226:	810000        	src	a0, a0, a0
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
42004229:	f0fc      	bnez.n	a0, 4200426c <memprot_ll_rtcfast_get_pms_area+0x94>
4200422b:	0020c0        	memw
4200422e:	0888      	l32i.n	a8, a8, 0
42004230:	248380        	extui	a8, a8, 3, 3
42004233:	001206        	j	4200427f <memprot_ll_rtcfast_get_pms_area+0xa7>
42004236:	260000        	lsi	f0, a0, 152
        default:
            return MEMP_HAL_ERR_AREA_INVALID;
        }
    } break;
    case MEMP_HAL_WORLD_1: {
        switch (area) {
42004239:	260717        	bnone	a7, a1, 42004263 <memprot_ll_rtcfast_get_pms_area+0x8b>
4200423c:	0c2327        	blt	a3, a2, 4200424c <memprot_ll_rtcfast_get_pms_area+0x74>
4200423f:	150652        	l8ui	a5, a6, 21
42004242:	d2cc00        	quos	a12, a12, a0
        case MEMP_HAL_AREA_LOW:
            if (core == PRO_CPU_NUM) {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
42004245:	f0f381        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
42004248:	0020c0        	memw
4200424b:	0888      	l32i.n	a8, a8, 0
4200424d:	248680        	extui	a8, a8, 6, 3
42004250:	000ac6        	j	4200427f <memprot_ll_rtcfast_get_pms_area+0xa7>
42004253:	f18100        	lsi	f0, a1, 0x3c4
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
42004256:	20c0f0        	or	a12, a0, a15
42004259:	088800        	lsx	f8, a8, a0
4200425c:	248680        	extui	a8, a8, 6, 3
4200425f:	000706        	j	4200427f <memprot_ll_rtcfast_get_pms_area+0xa7>
            }
            break;
        case MEMP_HAL_AREA_HIGH:
            if (core == PRO_CPU_NUM) {
42004262:	e2cc      	bnez.n	a2, 42004274 <memprot_ll_rtcfast_get_pms_area+0x9c>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H);
42004264:	f0ec81        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
42004267:	0020c0        	memw
4200426a:	0888      	l32i.n	a8, a8, 0
4200426c:	248980        	extui	a8, a8, 9, 3
4200426f:	000306        	j	4200427f <memprot_ll_rtcfast_get_pms_area+0xa7>
42004272:	810000        	src	a0, a0, a0
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H);
42004275:	f0e9      	s32i.n	a14, a0, 60
42004277:	0020c0        	memw
4200427a:	0888      	l32i.n	a8, a8, 0
4200427c:	248980        	extui	a8, a8, 9, 3
    *r = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_R;
4200427f:	049180        	extui	a9, a8, 1, 1
42004282:	004392        	s8i	a9, a3, 0
    *w = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004285:	049080        	extui	a9, a8, 0, 1
42004288:	004492        	s8i	a9, a4, 0
    *x = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
4200428b:	418280        	srli	a8, a8, 2
4200428e:	004582        	s8i	a8, a5, 0
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    memprot_ll_rtcfast_get_permissions(permissions, r, w, x);

    return MEMP_HAL_OK;
42004291:	020c      	movi.n	a2, 0
42004293:	000046        	j	42004298 <memprot_ll_rtcfast_get_pms_area+0xc0>
        return MEMP_HAL_ERR_CORE_INVALID;
42004296:	720c      	movi.n	a2, 7
}
42004298:	f01d      	retw.n
	...

4200429c <memprot_ll_rtcfast_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_get_monitor_lock(const int core, bool* locked)
{
4200429c:	004136        	entry	a1, 32
    switch (core) {
4200429f:	628c      	beqz.n	a2, 420042a9 <memprot_ll_rtcfast_get_monitor_lock+0xd>
420042a1:	1b1226        	beqi	a2, 1, 420042c0 <memprot_ll_rtcfast_get_monitor_lock+0x24>
420042a4:	720c      	movi.n	a2, 7
420042a6:	000ac6        	j	420042d5 <memprot_ll_rtcfast_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG) == 1;
420042a9:	f0dc81        	l32r	a8, 4200061c <_stext+0x5fc> (600c119c <SYSTEM+0x119c>)
420042ac:	0020c0        	memw
420042af:	0888      	l32i.n	a8, a8, 0
420042b1:	880b      	addi.n	a8, a8, -1
420042b3:	40f880        	nsau	a8, a8
420042b6:	418580        	srli	a8, a8, 5
420042b9:	004382        	s8i	a8, a3, 0
            break;
420042bc:	000546        	j	420042d5 <memprot_ll_rtcfast_get_monitor_lock+0x39>
420042bf:	d88100        	lsi	f0, a1, 0x360
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG) == 1;
420042c2:	20c0f0        	or	a12, a0, a15
420042c5:	088800        	lsx	f8, a8, a0
420042c8:	880b      	addi.n	a8, a8, -1
420042ca:	40f880        	nsau	a8, a8
420042cd:	418580        	srli	a8, a8, 5
420042d0:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420042d3:	020c      	movi.n	a2, 0
}
420042d5:	f01d      	retw.n
	...

420042d8 <memprot_ll_rtcfast_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_rtcfast_set_monitor_en(const int core, const bool enable)
{
420042d8:	004136        	entry	a1, 32
    switch (core) {
420042db:	628c      	beqz.n	a2, 420042e5 <memprot_ll_rtcfast_set_monitor_en+0xd>
420042dd:	301226        	beqi	a2, 1, 42004311 <memprot_ll_rtcfast_set_monitor_en+0x39>
420042e0:	720c      	movi.n	a2, 7
420042e2:	001686        	j	42004340 <memprot_ll_rtcfast_set_monitor_en+0x68>
        case PRO_CPU_NUM:
            if (enable) {
420042e5:	339c      	beqz.n	a3, 420042fc <memprot_ll_rtcfast_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN);
420042e7:	f0cf91        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
420042ea:	0020c0        	memw
420042ed:	0988      	l32i.n	a8, a9, 0
420042ef:	2a0c      	movi.n	a10, 2
420042f1:	2088a0        	or	a8, a8, a10
420042f4:	0020c0        	memw
420042f7:	0989      	s32i.n	a8, a9, 0
420042f9:	0010c6        	j	42004340 <memprot_ll_rtcfast_set_monitor_en+0x68>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN);
420042fc:	f0ca91        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
420042ff:	0020c0        	memw
42004302:	0988      	l32i.n	a8, a9, 0
42004304:	da7c      	movi.n	a10, -3
42004306:	1088a0        	and	a8, a8, a10
42004309:	0020c0        	memw
4200430c:	0989      	s32i.n	a8, a9, 0
4200430e:	000b86        	j	42004340 <memprot_ll_rtcfast_set_monitor_en+0x68>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
42004311:	739c      	beqz.n	a3, 4200432c <memprot_ll_rtcfast_set_monitor_en+0x54>
                REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
42004313:	f0c591        	l32r	a9, 42000628 <_stext+0x608> (600c124c <SYSTEM+0x124c>)
42004316:	0020c0        	memw
42004319:	0988      	l32i.n	a8, a9, 0
4200431b:	2a0c      	movi.n	a10, 2
4200431d:	2088a0        	or	a8, a8, a10
42004320:	0020c0        	memw
42004323:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004325:	020c      	movi.n	a2, 0
42004327:	000546        	j	42004340 <memprot_ll_rtcfast_set_monitor_en+0x68>
4200432a:	910000        	srl	a0, a0
                REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
4200432d:	bf          	.byte	0xbf
4200432e:	20c0f0        	or	a12, a0, a15
42004331:	098800        	l32e	a0, a8, -32
42004334:	da7c      	movi.n	a10, -3
42004336:	1088a0        	and	a8, a8, a10
42004339:	0020c0        	memw
4200433c:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
4200433e:	020c      	movi.n	a2, 0
}
42004340:	f01d      	retw.n
	...

42004344 <memprot_ll_rtcfast_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_rtcfast_get_monitor_en(const int core, bool* enabled)
{
42004344:	004136        	entry	a1, 32
    switch (core) {
42004347:	628c      	beqz.n	a2, 42004351 <memprot_ll_rtcfast_get_monitor_en+0xd>
42004349:	171226        	beqi	a2, 1, 42004364 <memprot_ll_rtcfast_get_monitor_en+0x20>
4200434c:	720c      	movi.n	a2, 7
4200434e:	000886        	j	42004374 <memprot_ll_rtcfast_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
42004351:	f0b481        	l32r	a8, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
42004354:	0020c0        	memw
42004357:	0888      	l32i.n	a8, a8, 0
42004359:	048180        	extui	a8, a8, 1, 1
4200435c:	004382        	s8i	a8, a3, 0
            break;
4200435f:	000446        	j	42004374 <memprot_ll_rtcfast_get_monitor_en+0x30>
42004362:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
42004365:	c0f0b1        	l32r	a11, 41ff4728 <_coredump_iram_end+0x1c72728>
42004368:	880020        	lsi	f2, a0, 0x220
4200436b:	8008      	l32i.n	a0, a0, 32
4200436d:	820481        	l32r	a8, 41fe4b80 <_coredump_iram_end+0x1c62b80>
42004370:	0c0043        	lsi	f4, a0, 48
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004373:	f01d02        	l16ui	a0, a13, 0x1e0
	...

42004378 <memprot_ll_rtcfast_set_monitor_intrclr>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_set_monitor_intrclr(const int core)
{
42004378:	004136        	entry	a1, 32
    switch (core) {
4200437b:	628c      	beqz.n	a2, 42004385 <memprot_ll_rtcfast_set_monitor_intrclr+0xd>
4200437d:	1b1226        	beqi	a2, 1, 4200439c <memprot_ll_rtcfast_set_monitor_intrclr+0x24>
42004380:	720c      	movi.n	a2, 7
42004382:	000a86        	j	420043b0 <memprot_ll_rtcfast_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
42004385:	f0a791        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
42004388:	0020c0        	memw
4200438b:	0988      	l32i.n	a8, a9, 0
4200438d:	1a0c      	movi.n	a10, 1
4200438f:	2088a0        	or	a8, a8, a10
42004392:	0020c0        	memw
42004395:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
42004397:	000546        	j	420043b0 <memprot_ll_rtcfast_set_monitor_intrclr+0x38>
4200439a:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
4200439d:	c0f0a3        	lsi	f10, a0, 0x300
420043a0:	880020        	lsi	f2, a0, 0x220
420043a3:	0c09      	s32i.n	a0, a12, 0
420043a5:	a01a      	add.n	a10, a0, a1
420043a7:	2088      	l32i.n	a8, a0, 8
420043a9:	0020c0        	memw
420043ac:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420043ae:	020c      	movi.n	a2, 0
}
420043b0:	f01d      	retw.n
	...

420043b4 <memprot_ll_rtcfast_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_rtcfast_reset_monitor_intrclr(const int core)
{
420043b4:	004136        	entry	a1, 32
    switch (core) {
420043b7:	628c      	beqz.n	a2, 420043c1 <memprot_ll_rtcfast_reset_monitor_intrclr+0xd>
420043b9:	1b1226        	beqi	a2, 1, 420043d8 <memprot_ll_rtcfast_reset_monitor_intrclr+0x24>
420043bc:	720c      	movi.n	a2, 7
420043be:	000a86        	j	420043ec <memprot_ll_rtcfast_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
420043c1:	f09891        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
420043c4:	0020c0        	memw
420043c7:	0988      	l32i.n	a8, a9, 0
420043c9:	ea7c      	movi.n	a10, -2
420043cb:	1088a0        	and	a8, a8, a10
420043ce:	0020c0        	memw
420043d1:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
420043d3:	000546        	j	420043ec <memprot_ll_rtcfast_reset_monitor_intrclr+0x38>
420043d6:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
420043d9:	c0f094        	lsi	f9, a0, 0x300
420043dc:	880020        	lsi	f2, a0, 0x220
420043df:	7c09      	s32i.n	a0, a12, 28
420043e1:	a0ea      	add.n	a10, a0, a14
420043e3:	1088      	l32i.n	a8, a0, 4
420043e5:	0020c0        	memw
420043e8:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420043ea:	020c      	movi.n	a2, 0
}
420043ec:	f01d      	retw.n
	...

420043f0 <memprot_ll_prepare_dram0_split_line_regval>:
{
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
}

static inline void memprot_ll_prepare_dram0_split_line_regval(const uint32_t addr, uint32_t* regval)
{
420043f0:	00c136        	entry	a1, 96
    //set category bits for given split line
    uint32_t cat[7] = { MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
420043f3:	cc1c      	movi.n	a12, 28
420043f5:	f078b1        	l32r	a11, 420005d8 <_stext+0x5b8> (3c027e8c <__func__$1+0xc>)
420043f8:	a1ca      	add.n	a10, a1, a12
420043fa:	ef0b81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420043fd:	0008e0        	callx8	a8
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA };

    for (size_t x=0; x<7; x++) {
42004400:	070c      	movi.n	a7, 0
42004402:	000b06        	j	42004432 <memprot_ll_prepare_dram0_split_line_regval+0x42>
        if (addr <= MAP_IRAM_TO_DRAM(SRAM_RG3_LEVEL_HLIMITS(x))) {
42004405:	cc1c      	movi.n	a12, 28
42004407:	f075b1        	l32r	a11, 420005dc <_stext+0x5bc> (3c027ea8 <__func__$1+0x28>)
4200440a:	01ad      	mov.n	a10, a1
4200440c:	ef0781        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200440f:	0008e0        	callx8	a8
42004412:	a08710        	addx4	a8, a7, a1
42004415:	0888      	l32i.n	a8, a8, 0
42004417:	f08591        	l32r	a9, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
4200441a:	889a      	add.n	a8, a8, a9
4200441c:	093827        	bltu	a8, a2, 42004429 <memprot_ll_prepare_dram0_split_line_regval+0x39>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
4200441f:	a07710        	addx4	a7, a7, a1
42004422:	280c      	movi.n	a8, 2
42004424:	7789      	s32i.n	a8, a7, 28
            break;
42004426:	0002c6        	j	42004435 <memprot_ll_prepare_dram0_split_line_regval+0x45>
        } else {
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
42004429:	a08710        	addx4	a8, a7, a1
4200442c:	090c      	movi.n	a9, 0
4200442e:	7899      	s32i.n	a9, a8, 28
    for (size_t x=0; x<7; x++) {
42004430:	771b      	addi.n	a7, a7, 1
42004432:	cf77b6        	bltui	a7, 7, 42004405 <memprot_ll_prepare_dram0_split_line_regval+0x15>

    //resolve split address' significant bits
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR_V);

    //write values to required configuration-register
    constrain_reg_fields_t cfg_reg_val = {
42004435:	81a8      	l32i.n	a10, a1, 32
42004437:	14a0a0        	extui	a10, a10, 0, 2
4200443a:	11aae0        	slli	a10, a10, 2
4200443d:	7188      	l32i.n	a8, a1, 28
4200443f:	148080        	extui	a8, a8, 0, 2
42004442:	9198      	l32i.n	a9, a1, 36
42004444:	149090        	extui	a9, a9, 0, 2
42004447:	1199c0        	slli	a9, a9, 4
4200444a:	2088a0        	or	a8, a8, a10
4200444d:	a1a8      	l32i.n	a10, a1, 40
4200444f:	14a0a0        	extui	a10, a10, 0, 2
42004452:	11aaa0        	slli	a10, a10, 6
42004455:	208890        	or	a8, a8, a9
42004458:	b198      	l32i.n	a9, a1, 44
4200445a:	149090        	extui	a9, a9, 0, 2
4200445d:	119980        	slli	a9, a9, 8
42004460:	2088a0        	or	a8, a8, a10
42004463:	c1a8      	l32i.n	a10, a1, 48
42004465:	14a0a0        	extui	a10, a10, 0, 2
42004468:	11aa60        	slli	a10, a10, 10
4200446b:	208890        	or	a8, a8, a9
4200446e:	d198      	l32i.n	a9, a1, 52
42004470:	149090        	extui	a9, a9, 0, 2
42004473:	119940        	slli	a9, a9, 12
42004476:	2088a0        	or	a8, a8, a10
42004479:	742820        	extui	a2, a2, 8, 8
4200447c:	112220        	slli	a2, a2, 14
4200447f:	208890        	or	a8, a8, a9
42004482:	208820        	or	a8, a8, a2
            .splitaddr = conf_add,
            .reserved = 0
    };


    *regval = cfg_reg_val.val;
42004485:	0389      	s32i.n	a8, a3, 0
}
42004487:	f01d      	retw.n
42004489:	000000        	ill

4200448c <memprot_ll_set_dram0_split_line>:

static inline memprot_hal_err_t memprot_ll_set_dram0_split_line(const void *line_addr, const uint32_t sensitive_reg)
{
4200448c:	006136        	entry	a1, 48
4200448f:	20a220        	or	a10, a2, a2
    uint32_t addr = (uint32_t)line_addr;

    //sanity check
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
42004492:	f06781        	l32r	a8, 42000630 <_stext+0x610> (c0378000 <_rtc_reserved_end+0x60278000>)
42004495:	808280        	add	a8, a2, a8
42004498:	f05391        	l32r	a9, 420005e4 <_stext+0x5c4> (67fff <UserFrameTotalSize+0x67eff>)
4200449b:	163987        	bltu	a9, a8, 420044b5 <memprot_ll_set_dram0_split_line+0x29>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
4200449e:	748020        	extui	a8, a2, 0, 8
420044a1:	015856        	bnez	a8, 420044ba <memprot_ll_set_dram0_split_line+0x2e>

    uint32_t regval;
    memprot_ll_prepare_dram0_split_line_regval(addr, &regval);
420044a4:	01bd      	mov.n	a11, a1
420044a6:	fff4a5        	call8	420043f0 <memprot_ll_prepare_dram0_split_line_regval>

    REG_WRITE(sensitive_reg, regval);
420044a9:	0188      	l32i.n	a8, a1, 0
420044ab:	0020c0        	memw
420044ae:	0389      	s32i.n	a8, a3, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((REG_READ(sensitive_reg) == regval) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
420044b0:	020c      	movi.n	a2, 0
420044b2:	000186        	j	420044bc <memprot_ll_set_dram0_split_line+0x30>
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
420044b5:	220c      	movi.n	a2, 2
420044b7:	000046        	j	420044bc <memprot_ll_set_dram0_split_line+0x30>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
420044ba:	320c      	movi.n	a2, 3
}
420044bc:	f01d      	retw.n
	...

420044c0 <memprot_ll_dram0_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_dram0_set_pms_area_0(const bool r, const bool w)
{
420044c0:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
420044c3:	f05c81        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
420044c6:	0020c0        	memw
420044c9:	0888      	l32i.n	a8, a8, 0
420044cb:	c97c      	movi.n	a9, -4
420044cd:	108890        	and	a8, a8, a9
    if (r) {
420044d0:	42cc      	bnez.n	a2, 420044d8 <memprot_ll_dram0_set_pms_area_0+0x18>
    uint32_t permissions = 0;
420044d2:	090c      	movi.n	a9, 0
420044d4:	000086        	j	420044da <memprot_ll_dram0_set_pms_area_0+0x1a>
420044d7:	190c00        	lsi	f0, a12, 100
    if (w) {
420044da:	338c      	beqz.n	a3, 420044e1 <memprot_ll_dram0_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420044dc:	2a0c      	movi.n	a10, 2
420044de:	2099a0        	or	a9, a9, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
420044e1:	149090        	extui	a9, a9, 0, 2
420044e4:	208890        	or	a8, a8, a9
420044e7:	f05391        	l32r	a9, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
420044ea:	0020c0        	memw
420044ed:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
420044ef:	f01d      	retw.n
420044f1:	000000        	ill

420044f4 <memprot_ll_dram0_set_pms_area_1>:

static inline void memprot_ll_dram0_set_pms_area_1(const bool r, const bool w)
{
420044f4:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
420044f7:	f04f81        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
420044fa:	0020c0        	memw
420044fd:	0898      	l32i.n	a9, a8, 0
420044ff:	387c      	movi.n	a8, -13
42004501:	109980        	and	a9, a9, a8
    if (r) {
42004504:	42cc      	bnez.n	a2, 4200450c <memprot_ll_dram0_set_pms_area_1+0x18>
    uint32_t permissions = 0;
42004506:	080c      	movi.n	a8, 0
42004508:	000086        	j	4200450e <memprot_ll_dram0_set_pms_area_1+0x1a>
4200450b:	180c00        	lsxp	f0, a12, a0
    if (w) {
4200450e:	338c      	beqz.n	a3, 42004515 <memprot_ll_dram0_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004510:	2a0c      	movi.n	a10, 2
42004512:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
42004515:	1188e0        	slli	a8, a8, 2
42004518:	ca0c      	movi.n	a10, 12
4200451a:	1088a0        	and	a8, a8, a10
4200451d:	209980        	or	a9, a9, a8
42004520:	f04581        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004523:	0020c0        	memw
42004526:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
42004528:	f01d      	retw.n
	...

4200452c <memprot_ll_dram0_set_pms_area_2>:

static inline void memprot_ll_dram0_set_pms_area_2(const bool r, const bool w)
{
4200452c:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
4200452f:	f04181        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004532:	0020c0        	memw
42004535:	0898      	l32i.n	a9, a8, 0
42004537:	cfaf82        	movi	a8, -49
4200453a:	109980        	and	a9, a9, a8
    if (r) {
4200453d:	32cc      	bnez.n	a2, 42004544 <memprot_ll_dram0_set_pms_area_2+0x18>
    uint32_t permissions = 0;
4200453f:	080c      	movi.n	a8, 0
42004541:	000046        	j	42004546 <memprot_ll_dram0_set_pms_area_2+0x1a>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004544:	180c      	movi.n	a8, 1
    if (w) {
42004546:	338c      	beqz.n	a3, 4200454d <memprot_ll_dram0_set_pms_area_2+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004548:	2a0c      	movi.n	a10, 2
4200454a:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
4200454d:	1188c0        	slli	a8, a8, 4
42004550:	0a3c      	movi.n	a10, 48
42004552:	1088a0        	and	a8, a8, a10
42004555:	209980        	or	a9, a9, a8
42004558:	f03781        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
4200455b:	0020c0        	memw
4200455e:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
42004560:	f01d      	retw.n
	...

42004564 <memprot_ll_dram0_set_pms_area_3>:

static inline void memprot_ll_dram0_set_pms_area_3(const bool r, const bool w)
{
42004564:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
42004567:	f03381        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
4200456a:	0020c0        	memw
4200456d:	0898      	l32i.n	a9, a8, 0
4200456f:	3faf82        	movi	a8, -193
42004572:	109980        	and	a9, a9, a8
    if (r) {
42004575:	32cc      	bnez.n	a2, 4200457c <memprot_ll_dram0_set_pms_area_3+0x18>
    uint32_t permissions = 0;
42004577:	080c      	movi.n	a8, 0
42004579:	000046        	j	4200457e <memprot_ll_dram0_set_pms_area_3+0x1a>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
4200457c:	180c      	movi.n	a8, 1
    if (w) {
4200457e:	338c      	beqz.n	a3, 42004585 <memprot_ll_dram0_set_pms_area_3+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004580:	2a0c      	movi.n	a10, 2
42004582:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
42004585:	1188a0        	slli	a8, a8, 6
42004588:	748080        	extui	a8, a8, 0, 8
4200458b:	209980        	or	a9, a9, a8
4200458e:	f02981        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004591:	0020c0        	memw
42004594:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
42004596:	f01d      	retw.n

42004598 <memprot_ll_dram0_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_dram0_get_monitor_lock(const int core, bool* locked)
{
42004598:	004136        	entry	a1, 32
    switch (core) {
4200459b:	628c      	beqz.n	a2, 420045a5 <memprot_ll_dram0_get_monitor_lock+0xd>
4200459d:	1b1226        	beqi	a2, 1, 420045bc <memprot_ll_dram0_get_monitor_lock+0x24>
420045a0:	720c      	movi.n	a2, 7
420045a2:	000ac6        	j	420045d1 <memprot_ll_dram0_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG) == 1;
420045a5:	f02481        	l32r	a8, 42000638 <_stext+0x618> (600c1104 <SYSTEM+0x1104>)
420045a8:	0020c0        	memw
420045ab:	0888      	l32i.n	a8, a8, 0
420045ad:	880b      	addi.n	a8, a8, -1
420045af:	40f880        	nsau	a8, a8
420045b2:	418580        	srli	a8, a8, 5
420045b5:	004382        	s8i	a8, a3, 0
            break;
420045b8:	000546        	j	420045d1 <memprot_ll_dram0_get_monitor_lock+0x39>
420045bb:	208100        	or	a8, a1, a0
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG) == 1;
420045be:	20c0f0        	or	a12, a0, a15
420045c1:	088800        	lsx	f8, a8, a0
420045c4:	880b      	addi.n	a8, a8, -1
420045c6:	40f880        	nsau	a8, a8
420045c9:	418580        	srli	a8, a8, 5
420045cc:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420045cf:	020c      	movi.n	a2, 0
}
420045d1:	f01d      	retw.n
	...

420045d4 <memprot_ll_dram0_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_dram0_set_monitor_en(const int core, const bool enable)
{
420045d4:	004136        	entry	a1, 32
    switch (core) {
420045d7:	628c      	beqz.n	a2, 420045e1 <memprot_ll_dram0_set_monitor_en+0xd>
420045d9:	301226        	beqi	a2, 1, 4200460d <memprot_ll_dram0_set_monitor_en+0x39>
420045dc:	720c      	movi.n	a2, 7
420045de:	001606        	j	4200463a <memprot_ll_dram0_set_monitor_en+0x66>
        case PRO_CPU_NUM:
            if (enable) {
420045e1:	339c      	beqz.n	a3, 420045f8 <memprot_ll_dram0_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN);
420045e3:	f01791        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
420045e6:	0020c0        	memw
420045e9:	0988      	l32i.n	a8, a9, 0
420045eb:	2a0c      	movi.n	a10, 2
420045ed:	2088a0        	or	a8, a8, a10
420045f0:	0020c0        	memw
420045f3:	0989      	s32i.n	a8, a9, 0
420045f5:	001046        	j	4200463a <memprot_ll_dram0_set_monitor_en+0x66>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN);
420045f8:	f01291        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
420045fb:	0020c0        	memw
420045fe:	0988      	l32i.n	a8, a9, 0
42004600:	da7c      	movi.n	a10, -3
42004602:	1088a0        	and	a8, a8, a10
42004605:	0020c0        	memw
42004608:	0989      	s32i.n	a8, a9, 0
4200460a:	000b06        	j	4200463a <memprot_ll_dram0_set_monitor_en+0x66>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
4200460d:	539c      	beqz.n	a3, 42004626 <memprot_ll_dram0_set_monitor_en+0x52>
                REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
4200460f:	f00d91        	l32r	a9, 42000644 <_stext+0x624> (600c1118 <SYSTEM+0x1118>)
42004612:	0020c0        	memw
42004615:	0988      	l32i.n	a8, a9, 0
42004617:	2a0c      	movi.n	a10, 2
42004619:	2088a0        	or	a8, a8, a10
4200461c:	0020c0        	memw
4200461f:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004621:	020c      	movi.n	a2, 0
42004623:	0004c6        	j	4200463a <memprot_ll_dram0_set_monitor_en+0x66>
                REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
42004626:	f00791        	l32r	a9, 42000644 <_stext+0x624> (600c1118 <SYSTEM+0x1118>)
42004629:	0020c0        	memw
4200462c:	0988      	l32i.n	a8, a9, 0
4200462e:	da7c      	movi.n	a10, -3
42004630:	1088a0        	and	a8, a8, a10
42004633:	0020c0        	memw
42004636:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
42004638:	020c      	movi.n	a2, 0
}
4200463a:	f01d      	retw.n

4200463c <memprot_ll_dram0_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_dram0_get_monitor_en(const int core, bool* enabled)
{
4200463c:	004136        	entry	a1, 32
    switch (core) {
4200463f:	628c      	beqz.n	a2, 42004649 <memprot_ll_dram0_get_monitor_en+0xd>
42004641:	171226        	beqi	a2, 1, 4200465c <memprot_ll_dram0_get_monitor_en+0x20>
42004644:	720c      	movi.n	a2, 7
42004646:	000886        	j	4200466c <memprot_ll_dram0_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
42004649:	effd81        	l32r	a8, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
4200464c:	0020c0        	memw
4200464f:	0888      	l32i.n	a8, a8, 0
42004651:	048180        	extui	a8, a8, 1, 1
42004654:	004382        	s8i	a8, a3, 0
            break;
42004657:	000446        	j	4200466c <memprot_ll_dram0_get_monitor_en+0x30>
4200465a:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
4200465d:	effa      	add.n	a14, a15, a15
4200465f:	0020c0        	memw
42004662:	0888      	l32i.n	a8, a8, 0
42004664:	048180        	extui	a8, a8, 1, 1
42004667:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200466a:	020c      	movi.n	a2, 0
}
4200466c:	f01d      	retw.n
	...

42004670 <memprot_ll_dram0_set_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_dram0_set_monitor_intrclr(const int core)
{
42004670:	004136        	entry	a1, 32
    switch (core) {
42004673:	628c      	beqz.n	a2, 4200467d <memprot_ll_dram0_set_monitor_intrclr+0xd>
42004675:	1b1226        	beqi	a2, 1, 42004694 <memprot_ll_dram0_set_monitor_intrclr+0x24>
42004678:	720c      	movi.n	a2, 7
4200467a:	000a86        	j	420046a8 <memprot_ll_dram0_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
4200467d:	eff091        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
42004680:	0020c0        	memw
42004683:	0988      	l32i.n	a8, a9, 0
42004685:	1a0c      	movi.n	a10, 1
42004687:	2088a0        	or	a8, a8, a10
4200468a:	0020c0        	memw
4200468d:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
4200468f:	000546        	j	420046a8 <memprot_ll_dram0_set_monitor_intrclr+0x38>
42004692:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
42004695:	efec      	bnez.n	a15, 420046c7 <memprot_ll_dram0_reset_monitor_intrclr+0x1b>
42004697:	0020c0        	memw
4200469a:	0988      	l32i.n	a8, a9, 0
4200469c:	1a0c      	movi.n	a10, 1
4200469e:	2088a0        	or	a8, a8, a10
420046a1:	0020c0        	memw
420046a4:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420046a6:	020c      	movi.n	a2, 0
}
420046a8:	f01d      	retw.n
	...

420046ac <memprot_ll_dram0_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_dram0_reset_monitor_intrclr(const int core)
{
420046ac:	004136        	entry	a1, 32
    switch (core) {
420046af:	628c      	beqz.n	a2, 420046b9 <memprot_ll_dram0_reset_monitor_intrclr+0xd>
420046b1:	1b1226        	beqi	a2, 1, 420046d0 <memprot_ll_dram0_reset_monitor_intrclr+0x24>
420046b4:	720c      	movi.n	a2, 7
420046b6:	000a86        	j	420046e4 <memprot_ll_dram0_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
420046b9:	efe191        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
420046bc:	0020c0        	memw
420046bf:	0988      	l32i.n	a8, a9, 0
420046c1:	ea7c      	movi.n	a10, -2
420046c3:	1088a0        	and	a8, a8, a10
420046c6:	0020c0        	memw
420046c9:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
420046cb:	000546        	j	420046e4 <memprot_ll_dram0_reset_monitor_intrclr+0x38>
420046ce:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
420046d1:	efdd      	lsi	f13, a15, 60
420046d3:	0020c0        	memw
420046d6:	0988      	l32i.n	a8, a9, 0
420046d8:	ea7c      	movi.n	a10, -2
420046da:	1088a0        	and	a8, a8, a10
420046dd:	0020c0        	memw
420046e0:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420046e2:	020c      	movi.n	a2, 0
}
420046e4:	f01d      	retw.n
	...

420046e8 <esp_mprot_cpuid_valid>:

//////////////////////////////////////////////////////////////////////////////
// internal helpers

static esp_err_t esp_mprot_cpuid_valid(const int core)
{
420046e8:	004136        	entry	a1, 32
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
420046eb:	090c      	movi.n	a9, 0
420046ed:	000386        	j	420046ff <esp_mprot_cpuid_valid+0x17>
        if (core == s_memp_cfg.target_cpu[x]) {
420046f0:	894b      	addi.n	a8, a9, 4
420046f2:	efd6a1        	l32r	a10, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
420046f5:	a088a0        	addx4	a8, a8, a10
420046f8:	0888      	l32i.n	a8, a8, 0
420046fa:	0f1827        	beq	a8, a2, 4200470d <esp_mprot_cpuid_valid+0x25>
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
420046fd:	991b      	addi.n	a9, a9, 1
420046ff:	efd381        	l32r	a8, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
42004702:	3888      	l32i.n	a8, a8, 12
42004704:	e83987        	bltu	a9, a8, 420046f0 <esp_mprot_cpuid_valid+0x8>
            return ESP_OK;
        }
    }

    return ESP_ERR_MEMPROT_CPUID_INVALID;
42004707:	efd021        	l32r	a2, 42000648 <_stext+0x628> (d008 <UserFrameTotalSize+0xcf08>)
4200470a:	000046        	j	4200470f <esp_mprot_cpuid_valid+0x27>
            return ESP_OK;
4200470d:	020c      	movi.n	a2, 0
}
4200470f:	f01d      	retw.n
42004711:	000000        	ill

42004714 <esp_memprot_iram0_get_def_split_addr>:

static void *esp_memprot_iram0_get_def_split_addr(void)
{
42004714:	004136        	entry	a1, 32
    return (void *)(uint32_t)&_iram_text_end;
}
42004717:	efce21        	l32r	a2, 42000650 <_stext+0x630> (40382000 <_coredump_iram_end>)
4200471a:	f01d      	retw.n

4200471c <esp_memprot_dram0_get_def_split_addr>:

static void *esp_memprot_dram0_get_def_split_addr(void)
{
4200471c:	004136        	entry	a1, 32
    return (void *)MAP_IRAM_TO_DRAM((uint32_t)&_iram_text_end);
}
4200471f:	efcc21        	l32r	a2, 42000650 <_stext+0x630> (40382000 <_coredump_iram_end>)
42004722:	efc281        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
42004725:	228a      	add.n	a2, a2, a8
42004727:	f01d      	retw.n
42004729:	000000        	ill

4200472c <esp_memprot_rtcfast_get_min_split_addr>:

static void *esp_memprot_rtcfast_get_min_split_addr(void)
{
4200472c:	004136        	entry	a1, 32
    return (void *)(uint32_t)&_rtc_text_end;
}
4200472f:	efc921        	l32r	a2, 42000654 <_stext+0x634> (600fe000 <s_sleep_sub_mode_ref_cnt>)
42004732:	f01d      	retw.n

42004734 <esp_mprot_set_intr_matrix>:

//register MEMPROT-relevant interrupts in the global matrix (to deploy panic handling)
//mapped to ETS_MEMACCESS_ERR_INUM (shared with cache-access interrupts)
static esp_err_t esp_mprot_set_intr_matrix(const esp_mprot_mem_t mem_type, const int core)
{
42004734:	004136        	entry	a1, 32
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
42004737:	19a0a2        	movi	a10, 25
4200473a:	eeb281        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
4200473d:	0008e0        	callx8	a8

    esp_err_t err;
    uint32_t intr_src_num = ETS_MAX_INTR_SOURCE;

    switch (mem_type) {
42004740:	3c2226        	beqi	a2, 2, 42004780 <esp_mprot_set_intr_matrix+0x4c>
42004743:	6d4226        	beqi	a2, 4, 420047b4 <esp_mprot_set_intr_matrix+0x80>
42004746:	021226        	beqi	a2, 1, 4200474c <esp_mprot_set_intr_matrix+0x18>
42004749:	002906        	j	420047f1 <esp_mprot_set_intr_matrix+0xbd>
    switch (core) {
4200474c:	838c      	beqz.n	a3, 42004758 <esp_mprot_set_intr_matrix+0x24>
4200474e:	0f1366        	bnei	a3, 1, 42004761 <esp_mprot_set_intr_matrix+0x2d>
            *src_num = ETS_CORE1_IRAM0_PMS_INTR_SOURCE;
42004751:	975c      	movi.n	a7, 89
    return MEMP_HAL_OK;
42004753:	0a0c      	movi.n	a10, 0
42004755:	000386        	j	42004767 <esp_mprot_set_intr_matrix+0x33>
42004758:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_IRAM0_PMS_INTR_SOURCE;
4200475a:	575c      	movi.n	a7, 85
4200475c:	0001c6        	j	42004767 <esp_mprot_set_intr_matrix+0x33>
4200475f:	720000        	lsi	f0, a0, 0x1c8
    switch (core) {
42004762:	a263a0        	muluh	a6, a3, a10
42004765:	af          	.byte	0xaf
42004766:	ff          	.byte	0xff
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_intr_source_num(core, &intr_src_num)))
42004767:	0129a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
4200476a:	202aa0        	or	a2, a10, a10
4200476d:	083a56        	bnez	a10, 420047f4 <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
42004770:	19a0c2        	movi	a12, 25
42004773:	07bd      	mov.n	a11, a7
42004775:	03ad      	mov.n	a10, a3
42004777:	ee5881        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
4200477a:	0008e0        	callx8	a8
        break;
4200477d:	0018c6        	j	420047e4 <esp_mprot_set_intr_matrix+0xb0>
    switch (core) {
42004780:	838c      	beqz.n	a3, 4200478c <esp_mprot_set_intr_matrix+0x58>
42004782:	0f1366        	bnei	a3, 1, 42004795 <esp_mprot_set_intr_matrix+0x61>
            *src_num = ETS_CORE1_DRAM0_PMS_INTR_SOURCE;
42004785:	a75c      	movi.n	a7, 90
    return MEMP_HAL_OK;
42004787:	0a0c      	movi.n	a10, 0
42004789:	000386        	j	4200479b <esp_mprot_set_intr_matrix+0x67>
4200478c:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_DRAM0_PMS_INTR_SOURCE;
4200478e:	675c      	movi.n	a7, 86
42004790:	0001c6        	j	4200479b <esp_mprot_set_intr_matrix+0x67>
42004793:	720000        	lsi	f0, a0, 0x1c8
    switch (core) {
42004796:	a263a0        	muluh	a6, a3, a10
42004799:	6507a0        	extui	a0, a10, 23, 7
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_intr_source_num(core, &intr_src_num)))
4200479c:	a00126        	beqi	a1, -1, 42004740 <esp_mprot_set_intr_matrix+0xc>
4200479f:	202a      	add.n	a2, a0, a2
420047a1:	04fa56        	bnez	a10, 420047f4 <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
420047a4:	19a0c2        	movi	a12, 25
420047a7:	07bd      	mov.n	a11, a7
420047a9:	03ad      	mov.n	a10, a3
420047ab:	ee4b81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420047ae:	0008e0        	callx8	a8
        break;
420047b1:	000bc6        	j	420047e4 <esp_mprot_set_intr_matrix+0xb0>
    switch (core) {
420047b4:	838c      	beqz.n	a3, 420047c0 <esp_mprot_set_intr_matrix+0x8c>
420047b6:	0f1366        	bnei	a3, 1, 420047c9 <esp_mprot_set_intr_matrix+0x95>
            *src_num = ETS_CORE1_PIF_PMS_INTR_SOURCE;
420047b9:	b75c      	movi.n	a7, 91
    return MEMP_HAL_OK;
420047bb:	0a0c      	movi.n	a10, 0
420047bd:	000386        	j	420047cf <esp_mprot_set_intr_matrix+0x9b>
420047c0:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_PIF_PMS_INTR_SOURCE;
420047c2:	775c      	movi.n	a7, 87
420047c4:	0001c6        	j	420047cf <esp_mprot_set_intr_matrix+0x9b>
420047c7:	720000        	lsi	f0, a0, 0x1c8
    switch (core) {
420047ca:	a263a0        	muluh	a6, a3, a10
420047cd:	2507a0        	extui	a0, a10, 23, 3
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_intr_source_num(core, &intr_src_num)))
420047d0:	a00123        	lsi	f2, a1, 0x280
420047d3:	202a      	add.n	a2, a0, a2
420047d5:	01ba56        	bnez	a10, 420047f4 <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
420047d8:	9c1c      	movi.n	a12, 25
420047da:	07bd      	mov.n	a11, a7
420047dc:	03ad      	mov.n	a10, a3
420047de:	ee3e81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420047e1:	0008e0        	callx8	a8
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    ESP_INTR_ENABLE(ETS_MEMACCESS_ERR_INUM);
420047e4:	9a1c      	movi.n	a10, 25
420047e6:	ee8881        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
420047e9:	0008e0        	callx8	a8

    return ESP_OK;
420047ec:	020c      	movi.n	a2, 0
420047ee:	000086        	j	420047f4 <esp_mprot_set_intr_matrix+0xc0>
    switch (mem_type) {
420047f1:	ef9921        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
}
420047f4:	f01d      	retw.n
	...

420047f8 <esp_mprot_set_split_addr>:
//////////////////////////////////////////////////////////////////////////////
// PMS configuration APIs (set/get/lock)
// IRAM/DRAM settings are shared by both CPUs, RTCFAST settings are separate for each core

esp_err_t esp_mprot_set_split_addr(const esp_mprot_mem_t mem_type, const esp_mprot_split_addr_t line_type, const void *line_addr, const int core __attribute__((unused)))
{
420047f8:	004136        	entry	a1, 32
    switch (mem_type) {
420047fb:	4e2226        	beqi	a2, 2, 4200484d <esp_mprot_set_split_addr+0x55>
420047fe:	024266        	bnei	a2, 4, 42004804 <esp_mprot_set_split_addr+0xc>
42004801:	001f06        	j	42004881 <esp_mprot_set_split_addr+0x89>
42004804:	021226        	beqi	a2, 1, 4200480a <esp_mprot_set_split_addr+0x12>
42004807:	002546        	j	420048a0 <esp_mprot_set_split_addr+0xa8>
    case MEMPROT_TYPE_IRAM0_SRAM:
        switch (line_type) {
4200480a:	1b2326        	beqi	a3, 2, 42004829 <esp_mprot_set_split_addr+0x31>
4200480d:	2a4326        	beqi	a3, 4, 4200483b <esp_mprot_set_split_addr+0x43>
42004810:	021326        	beqi	a3, 1, 42004816 <esp_mprot_set_split_addr+0x1e>
42004813:	002446        	j	420048a8 <esp_mprot_set_split_addr+0xb0>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
42004816:	ef92b1        	l32r	a11, 42000660 <_stext+0x640> (600c10c4 <SYSTEM+0x10c4>)
42004819:	20a440        	or	a10, a4, a4
4200481c:	ff5ae5        	call8	42003dcc <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_DRAM0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_main_I_D(line_addr));
4200481f:	011e25        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004822:	202aa0        	or	a2, a10, a10
42004825:	0022c6        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
42004828:	8eb100        	f64iter	a11, a1, a0, 0, 0
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
4200482b:	ef          	.byte	0xef
4200482c:	20a440        	or	a10, a4, a4
4200482f:	ff59e5        	call8	42003dcc <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_LINE_0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_0(line_addr));
42004832:	011ce5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004835:	202aa0        	or	a2, a10, a10
42004838:	001e06        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
4200483b:	ef8bb1        	l32r	a11, 42000668 <_stext+0x648> (600c10cc <SYSTEM+0x10cc>)
4200483e:	20a440        	or	a10, a4, a4
42004841:	ff58a5        	call8	42003dcc <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_LINE_1:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_1(line_addr));
42004844:	011ba5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004847:	202aa0        	or	a2, a10, a10
4200484a:	001986        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
        default:
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
        } break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        switch (line_type) {
4200484d:	088326        	beqi	a3, 8, 42004859 <esp_mprot_set_split_addr+0x61>
42004850:	19b326        	beqi	a3, 16, 4200486d <esp_mprot_set_split_addr+0x75>
42004853:	ef8221        	l32r	a2, 4200065c <_stext+0x63c> (d002 <UserFrameTotalSize+0xcf02>)
42004856:	001686        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
42004859:	ef84b1        	l32r	a11, 4200066c <_stext+0x64c> (600c10d0 <SYSTEM+0x10d0>)
4200485c:	20a440        	or	a10, a4, a4
4200485f:	ffc2e5        	call8	4200448c <memprot_ll_set_dram0_split_line>
        case MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_0(line_addr));
42004862:	0119e5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004865:	202aa0        	or	a2, a10, a10
42004868:	001206        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
4200486b:	b10000        	sra	a0, a0
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
4200486e:	40ef80        	nsa	a8, a15
42004871:	a520a4        	lsi	f10, a0, 0x294
42004874:	a5ffc1        	l32r	a12, 41fee070 <_coredump_iram_end+0x1c6c070>
        case MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_1:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_1(line_addr));
42004877:	0118      	l32i.n	a1, a1, 0
42004879:	202aa0        	or	a2, a10, a10
4200487c:	000d06        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
4200487f:	660000        	lsi	f0, a0, 0x198
        default:
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
        } break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        if (line_type == MEMPROT_SPLIT_ADDR_MAIN) { /* so far only WORLD_0 is supported */
42004882:	502c13        	lsi	f1, a12, 0x140
            esp_err_t err;
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004885:	2520a5        	call8	42029a90 <_etext+0x12852>
42004888:	2dffe6        	bgei	a15, 0x100, 420048b9 <esp_mprot_get_default_main_split_addr+0x1>
4200488b:	ec0a      	add.n	a14, a12, a0
4200488d:	0c4a      	add.n	a0, a12, a4
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_rtcfast_split_line(core, line_addr, MEMP_HAL_WORLD_0)))
4200488f:	bd1c      	movi.n	a13, 27
42004891:	05ad04        	lsi	f0, a13, 20
42004894:	ff7ee5        	call8	42004084 <memprot_ll_set_rtcfast_split_line>
42004897:	0116a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
4200489a:	0a2d      	mov.n	a2, a10
4200489c:	000506        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
4200489f:	6e2100        	f64rnd	a2, a1, a0, 2
    switch (mem_type) {
420048a2:	ef          	.byte	0xef
420048a3:	000346        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
420048a6:	210000        	srai	a0, a0, 0
        switch (line_type) {
420048a9:	ef6d      	lsi	f6, a15, 60
420048ab:	000146        	j	420048b4 <esp_mprot_set_split_addr+0xbc>
420048ae:	000000        	ill
            return ESP_OK;
        } else {
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
420048b1:	ef6a21        	l32r	a2, 4200065c <_stext+0x63c> (d002 <UserFrameTotalSize+0xcf02>)
        }
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }
}
420048b4:	f01d      	retw.n
	...

420048b8 <esp_mprot_get_default_main_split_addr>:

    return ESP_OK;
}

esp_err_t esp_mprot_get_default_main_split_addr(const esp_mprot_mem_t mem_type, void **def_split_addr)
{
420048b8:	004136        	entry	a1, 32
    if (def_split_addr == NULL) {
420048bb:	02e316        	beqz	a3, 420048ed <esp_mprot_get_default_main_split_addr+0x35>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
420048be:	112226        	beqi	a2, 2, 420048d3 <esp_mprot_get_default_main_split_addr+0x1b>
420048c1:	1b4226        	beqi	a2, 4, 420048e0 <esp_mprot_get_default_main_split_addr+0x28>
420048c4:	2c1266        	bnei	a2, 1, 420048f4 <esp_mprot_get_default_main_split_addr+0x3c>
    case MEMPROT_TYPE_IRAM0_SRAM:
        *def_split_addr = esp_memprot_iram0_get_def_split_addr();
420048c7:	ffe4e5        	call8	42004714 <esp_memprot_iram0_get_def_split_addr>
420048ca:	0063a2        	s32i	a10, a3, 0
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
420048cd:	00a022        	movi	a2, 0
        break;
420048d0:	0008c6        	j	420048f7 <esp_mprot_get_default_main_split_addr+0x3f>
        *def_split_addr = esp_memprot_dram0_get_def_split_addr();
420048d3:	ffe4a5        	call8	4200471c <esp_memprot_dram0_get_def_split_addr>
420048d6:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
420048d8:	020c      	movi.n	a2, 0
        break;
420048da:	000646        	j	420048f7 <esp_mprot_get_default_main_split_addr+0x3f>
420048dd:	000000        	ill
        *def_split_addr = esp_memprot_rtcfast_get_min_split_addr();
420048e0:	ffe4a5        	call8	4200472c <esp_memprot_rtcfast_get_min_split_addr>
420048e3:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
420048e5:	020c      	movi.n	a2, 0
        break;
420048e7:	000306        	j	420048f7 <esp_mprot_get_default_main_split_addr+0x3f>
420048ea:	000000        	ill
        return ESP_ERR_INVALID_ARG;
420048ed:	02a122        	movi	a2, 0x102
420048f0:	0000c6        	j	420048f7 <esp_mprot_get_default_main_split_addr+0x3f>
420048f3:	592100        	s32nb	a0, a1, 8
    switch (mem_type) {
420048f6:	ef          	.byte	0xef
}
420048f7:	f01d      	retw.n
420048f9:	000000        	ill

420048fc <esp_mprot_set_split_addr_lock>:

esp_err_t esp_mprot_set_split_addr_lock(const esp_mprot_mem_t mem_type, const int core __attribute__((unused)))
{
420048fc:	004136        	entry	a1, 32
    switch (mem_type) {
420048ff:	0932f6        	bgeui	a2, 3, 4200490c <esp_mprot_set_split_addr_lock+0x10>
42004902:	f2cc      	bnez.n	a2, 42004915 <esp_mprot_set_split_addr_lock+0x19>
42004904:	ef5521        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004907:	001446        	j	4200495c <esp_mprot_set_split_addr_lock+0x60>
4200490a:	260000        	lsi	f0, a0, 152
4200490d:	211442        	l16ui	a4, a4, 66
42004910:	86ef52        	s32c1i	a5, a15, 0x218
42004913:	810011        	l32r	a1, 41fe4d14 <_coredump_iram_end+0x1c62d14>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG, 1);
42004916:	0cef57        	bbsi	a15, 5, 42004926 <esp_mprot_set_split_addr_lock+0x2a>
42004919:	c019      	s32i.n	a1, a0, 48
4200491b:	990020        	lsi	f2, a0, 0x264
4200491e:	0c08      	l32i.n	a0, a12, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004920:	0dc602        	addi	a0, a6, 13
}
42004923:	a33000        	movltz	a3, a0, a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004926:	dc2520        	lsi	f2, a5, 0x370
42004929:	ff          	.byte	0xff
4200492a:	202aa0        	or	a2, a10, a10
4200492d:	02ba56        	bnez	a10, 4200495c <esp_mprot_set_split_addr_lock+0x60>
    switch (core) {
42004930:	838c      	beqz.n	a3, 4200493c <esp_mprot_set_split_addr_lock+0x40>
42004932:	131326        	beqi	a3, 1, 42004949 <esp_mprot_set_split_addr_lock+0x4d>
42004935:	730c      	movi.n	a3, 7
42004937:	000686        	j	42004955 <esp_mprot_set_split_addr_lock+0x59>
4200493a:	810000        	src	a0, a0, a0
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG, 1);
4200493d:	0cef30        	lsi	f3, a15, 48
42004940:	c019      	s32i.n	a1, a0, 48
42004942:	990020        	lsi	f2, a0, 0x264
42004945:	c608      	l32i.n	a0, a6, 48
            break;
42004947:	810002        	l8ui	a0, a0, 129
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
4200494a:	ef2d      	lsi	f2, a15, 60
4200494c:	190c      	movi.n	a9, 1
4200494e:	0020c0        	memw
42004951:	0899      	s32i.n	a9, a8, 0
    return MEMP_HAL_OK;
42004953:	0a3d      	mov.n	a3, a10
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_pif_constraint_lock(core)))
42004955:	03ad      	mov.n	a10, a3
42004957:	010aa5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
4200495a:	0a2d      	mov.n	a2, a10
}
4200495c:	f01d      	retw.n
	...

42004960 <esp_mprot_get_split_addr_lock>:

esp_err_t esp_mprot_get_split_addr_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core __attribute__((unused)))
{
42004960:	004136        	entry	a1, 32
    if (locked == NULL) {
42004963:	04a316        	beqz	a3, 420049b1 <esp_mprot_get_split_addr_lock+0x51>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
42004966:	0732f6        	bgeui	a2, 3, 42004971 <esp_mprot_get_split_addr_lock+0x11>
42004969:	f2cc      	bnez.n	a2, 4200497c <esp_mprot_get_split_addr_lock+0x1c>
4200496b:	ef3b21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
4200496e:	001086        	j	420049b4 <esp_mprot_get_split_addr_lock+0x54>
42004971:	214226        	beqi	a2, 4, 42004996 <esp_mprot_get_split_addr_lock+0x36>
42004974:	ef3921        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004977:	000e46        	j	420049b4 <esp_mprot_get_split_addr_lock+0x54>
4200497a:	810000        	src	a0, a0, a0
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
4200497d:	3e          	.byte	0x3e
4200497e:	ef          	.byte	0xef
4200497f:	0020c0        	memw
42004982:	0888      	l32i.n	a8, a8, 0
42004984:	880b      	addi.n	a8, a8, -1
42004986:	40f880        	nsau	a8, a8
42004989:	418580        	srli	a8, a8, 5
    case MEMPROT_TYPE_IRAM0_SRAM:
    case MEMPROT_TYPE_DRAM0_SRAM:
        *locked = memprot_ll_get_iram0_dram0_split_line_lock();
4200498c:	004382        	s8i	a8, a3, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
4200498f:	020c      	movi.n	a2, 0
        break;
42004991:	0007c6        	j	420049b4 <esp_mprot_get_split_addr_lock+0x54>
42004994:	400000        	ssr	a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004997:	e520a4        	lsi	f10, a0, 0x394
4200499a:	2dffd4        	lsi	f13, a15, 180
4200499d:	dc0a      	add.n	a13, a12, a0
4200499f:	bd2a      	add.n	a11, a13, a2
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_get_pif_constraint_lock(core, locked)))
420049a1:	04ad03        	lsi	f0, a13, 16
420049a4:	ff6a25        	call8	42004048 <memprot_ll_get_pif_constraint_lock>
420049a7:	0105a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
420049aa:	0a2d      	mov.n	a2, a10
420049ac:	000106        	j	420049b4 <esp_mprot_get_split_addr_lock+0x54>
420049af:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
420049b2:	1d02a1        	l32r	a10, 41fcbdbc <_coredump_iram_end+0x1c49dbc>
}
420049b5:	0000f0        	callx12	a0

420049b8 <esp_mprot_set_pms_lock>:

esp_err_t esp_mprot_set_pms_lock(const esp_mprot_mem_t mem_type, const int core __attribute__((unused)))
{
420049b8:	004136        	entry	a1, 32
    switch (mem_type) {
420049bb:	152226        	beqi	a2, 2, 420049d4 <esp_mprot_set_pms_lock+0x1c>
420049be:	224226        	beqi	a2, 4, 420049e4 <esp_mprot_set_pms_lock+0x2c>
420049c1:	601266        	bnei	a2, 1, 42004a25 <esp_mprot_set_pms_lock+0x6d>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG, 1);
420049c4:	ef2d81        	l32r	a8, 42000678 <_stext+0x658> (600c10d8 <SYSTEM+0x10d8>)
420049c7:	190c      	movi.n	a9, 1
420049c9:	0020c0        	memw
420049cc:	0899      	s32i.n	a9, a8, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
420049ce:	020c      	movi.n	a2, 0
}
420049d0:	001506        	j	42004a28 <esp_mprot_set_pms_lock+0x70>
420049d3:	2a8100        	mul.s	f8, f1, f0
    REG_WRITE(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG, 1);
420049d6:	ef          	.byte	0xef
420049d7:	190c      	movi.n	a9, 1
420049d9:	0020c0        	memw
420049dc:	0899      	s32i.n	a9, a8, 0
420049de:	020c      	movi.n	a2, 0
}
420049e0:	001106        	j	42004a28 <esp_mprot_set_pms_lock+0x70>
420049e3:	a33000        	movltz	a3, a0, a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
420049e6:	d02520        	subx2	a2, a5, a2
420049e9:	ff          	.byte	0xff
420049ea:	202aa0        	or	a2, a10, a10
420049ed:	037a56        	bnez	a10, 42004a28 <esp_mprot_set_pms_lock+0x70>
    switch (core) {
420049f0:	838c      	beqz.n	a3, 420049fc <esp_mprot_set_pms_lock+0x44>
420049f2:	131326        	beqi	a3, 1, 42004a09 <esp_mprot_set_pms_lock+0x51>
420049f5:	730c      	movi.n	a3, 7
420049f7:	000746        	j	42004a18 <esp_mprot_set_pms_lock+0x60>
420049fa:	810000        	src	a0, a0, a0
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG, 1);
420049fd:	0cef00        	lsi	f0, a15, 48
42004a00:	c019      	s32i.n	a1, a0, 48
42004a02:	990020        	lsi	f2, a0, 0x264
42004a05:	8608      	l32i.n	a0, a6, 32
            break;
42004a07:	810003        	lsi	f0, a0, 0x204
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
42004a0a:	eefd      	lsi	f15, a14, 56
42004a0c:	01a092        	movi	a9, 1
42004a0f:	0020c0        	memw
42004a12:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004a15:	203aa0        	or	a3, a10, a10
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_pif_constraint_lock(core)))
42004a18:	03ad      	mov.n	a10, a3
42004a1a:	00fe65        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004a1d:	0a2d      	mov.n	a2, a10
42004a1f:	000146        	j	42004a28 <esp_mprot_set_pms_lock+0x70>
42004a22:	000000        	ill
    switch (mem_type) {
42004a25:	ef0c21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
}
42004a28:	f01d      	retw.n
	...

42004a2c <esp_mprot_get_pms_lock>:

esp_err_t esp_mprot_get_pms_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core __attribute__((unused)))
{
42004a2c:	004136        	entry	a1, 32
    if (locked == NULL) {
42004a2f:	055316        	beqz	a3, 42004a88 <esp_mprot_get_pms_lock+0x5c>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
42004a32:	1d2226        	beqi	a2, 2, 42004a53 <esp_mprot_get_pms_lock+0x27>
42004a35:	354226        	beqi	a2, 4, 42004a6e <esp_mprot_get_pms_lock+0x42>
42004a38:	551266        	bnei	a2, 1, 42004a91 <esp_mprot_get_pms_lock+0x65>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG) == 1;
42004a3b:	ef0f81        	l32r	a8, 42000678 <_stext+0x658> (600c10d8 <SYSTEM+0x10d8>)
42004a3e:	0020c0        	memw
42004a41:	0888      	l32i.n	a8, a8, 0
42004a43:	880b      	addi.n	a8, a8, -1
42004a45:	40f880        	nsau	a8, a8
42004a48:	418580        	srli	a8, a8, 5
    case MEMPROT_TYPE_IRAM0_SRAM:
        *locked = memprot_ll_iram0_get_pms_lock();
42004a4b:	004382        	s8i	a8, a3, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004a4e:	020c      	movi.n	a2, 0
        break;
42004a50:	001006        	j	42004a94 <esp_mprot_get_pms_lock+0x68>
    return REG_READ(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG) == 1;
42004a53:	ef0a81        	l32r	a8, 4200067c <_stext+0x65c> (600c10fc <SYSTEM+0x10fc>)
42004a56:	0020c0        	memw
42004a59:	0888      	l32i.n	a8, a8, 0
42004a5b:	880b      	addi.n	a8, a8, -1
42004a5d:	40f880        	nsau	a8, a8
42004a60:	418580        	srli	a8, a8, 5
        *locked = memprot_ll_dram0_get_pms_lock();
42004a63:	004382        	s8i	a8, a3, 0
    return ESP_OK;
42004a66:	020c      	movi.n	a2, 0
        break;
42004a68:	000a06        	j	42004a94 <esp_mprot_get_pms_lock+0x68>
42004a6b:	000000        	ill
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004a6e:	20a440        	or	a10, a4, a4
42004a71:	ffc765        	call8	420046e8 <esp_mprot_cpuid_valid>
42004a74:	0a2d      	mov.n	a2, a10
42004a76:	aadc      	bnez.n	a10, 42004a94 <esp_mprot_get_pms_lock+0x68>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_get_pif_constraint_lock(core, locked)))
42004a78:	03bd      	mov.n	a11, a3
42004a7a:	04ad      	mov.n	a10, a4
42004a7c:	ff5ca5        	call8	42004048 <memprot_ll_get_pif_constraint_lock>
42004a7f:	00f825        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004a82:	0a2d      	mov.n	a2, a10
42004a84:	000306        	j	42004a94 <esp_mprot_get_pms_lock+0x68>
42004a87:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004a8a:	014602        	s8i	a0, a6, 1
42004a8d:	000000        	ill
42004a90:	f12100        	lsi	f0, a1, 0x3c4
    switch (mem_type) {
42004a93:	ee          	.byte	0xee
}
42004a94:	f01d      	retw.n
	...

42004a98 <esp_mprot_set_pms_area>:

esp_err_t esp_mprot_set_pms_area(const esp_mprot_pms_area_t area_type, const uint32_t flags, const int core __attribute__((unused)))
{
42004a98:	004136        	entry	a1, 32
    esp_err_t err;
    bool r = flags & MEMPROT_OP_READ;
    bool w = flags & MEMPROT_OP_WRITE;
42004a9b:	047130        	extui	a7, a3, 1, 1
    bool x = flags & MEMPROT_OP_EXEC;
42004a9e:	046230        	extui	a6, a3, 2, 1

    switch (area_type) {
42004aa1:	02d266        	bnei	a2, 64, 42004aa7 <esp_mprot_set_pms_area+0xf>
42004aa4:	003446        	j	42004b79 <esp_mprot_set_pms_area+0xe1>
42004aa7:	084c      	movi.n	a8, 64
42004aa9:	2f3827        	bltu	a8, a2, 42004adc <esp_mprot_set_pms_area+0x44>
42004aac:	028266        	bnei	a2, 8, 42004ab2 <esp_mprot_set_pms_area+0x1a>
42004aaf:	002506        	j	42004b47 <esp_mprot_set_pms_area+0xaf>
42004ab2:	880c      	movi.n	a8, 8
42004ab4:	103827        	bltu	a8, a2, 42004ac8 <esp_mprot_set_pms_area+0x30>
42004ab7:	6b2226        	beqi	a2, 2, 42004b26 <esp_mprot_set_pms_area+0x8e>
42004aba:	774226        	beqi	a2, 4, 42004b35 <esp_mprot_set_pms_area+0x9d>
42004abd:	531226        	beqi	a2, 1, 42004b14 <esp_mprot_set_pms_area+0x7c>
42004ac0:	06a122        	movi	a2, 0x106
42004ac3:	004ec6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004ac6:	660000        	lsi	f0, a0, 0x198
42004ac9:	8602b2        	l8ui	a11, a2, 134
42004acc:	660022        	l8ui	a2, a0, 102
42004acf:	0602c2        	l8ui	a12, a2, 6
42004ad2:	220025        	call8	42026ad4 <_etext+0xf896>
42004ad5:	c606a1        	l32r	a10, 41ff62f0 <_coredump_iram_end+0x1c742f0>
42004ad8:	0049      	s32i.n	a4, a0, 0
42004ada:	820000        	mull	a0, a0, a0
42004add:	8700a2        	l8ui	a10, a0, 135
42004ae0:	060292        	l8ui	a9, a2, 6
42004ae3:	270036        	entry	a0, 0x1380
42004ae6:	1338      	l32i.n	a3, a3, 4
42004ae8:	02e266        	bnei	a2, 128, 42004aee <esp_mprot_set_pms_area+0x56>
42004aeb:	002686        	j	42004b89 <esp_mprot_set_pms_area+0xf1>
42004aee:	02f266        	bnei	a2, 0x100, 42004af4 <esp_mprot_set_pms_area+0x5c>
42004af1:	002906        	j	42004b99 <esp_mprot_set_pms_area+0x101>
42004af4:	06a122        	movi	a2, 0x106
42004af7:	0041c6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004afa:	820000        	mull	a0, a0, a0
42004afd:	8700a4        	lsi	f10, a0, 0x21c
42004b00:	860292        	l8ui	a9, a2, 134
42004b03:	810037        	bnone	a0, a3, 42004a88 <esp_mprot_get_pms_lock+0x5c>
42004b06:	87eea2        	s32c1i	a10, a14, 0x21c
42004b09:	c60292        	l8ui	a9, a2, 198
42004b0c:	0039      	s32i.n	a3, a0, 0
42004b0e:	06a122        	movi	a2, 0x106
42004b11:	003b46        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
    case MEMPROT_PMS_AREA_IRAM0_0:
        memprot_ll_iram0_set_pms_area_0(r, w, x);
42004b14:	20c660        	or	a12, a6, a6
42004b17:	20b770        	or	a11, a7, a7
42004b1a:	04a030        	extui	a10, a3, 0, 1
42004b1d:	ff2e25        	call8	42003e00 <memprot_ll_iram0_set_pms_area_0>
        break;
    default:
        return ESP_ERR_NOT_SUPPORTED;
    }

    return ESP_OK;
42004b20:	00a022        	movi	a2, 0
        break;
42004b23:	0036c6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_1(r, w, x);
42004b26:	06cd      	mov.n	a12, a6
42004b28:	07bd      	mov.n	a11, a7
42004b2a:	04a030        	extui	a10, a3, 0, 1
42004b2d:	ff30a5        	call8	42003e38 <memprot_ll_iram0_set_pms_area_1>
    return ESP_OK;
42004b30:	020c      	movi.n	a2, 0
        break;
42004b32:	003306        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_2(r, w, x);
42004b35:	20c660        	or	a12, a6, a6
42004b38:	20b770        	or	a11, a7, a7
42004b3b:	04a030        	extui	a10, a3, 0, 1
42004b3e:	ff33a5        	call8	42003e78 <memprot_ll_iram0_set_pms_area_2>
    return ESP_OK;
42004b41:	00a022        	movi	a2, 0
        break;
42004b44:	002e86        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_3(r, w, x);
42004b47:	20c660        	or	a12, a6, a6
42004b4a:	20b770        	or	a11, a7, a7
42004b4d:	04a030        	extui	a10, a3, 0, 1
42004b50:	ff3665        	call8	42003eb8 <memprot_ll_iram0_set_pms_area_3>
    return ESP_OK;
42004b53:	00a022        	movi	a2, 0
        break;
42004b56:	002a06        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
        memprot_ll_dram0_set_pms_area_0(r, w);
42004b59:	07bd      	mov.n	a11, a7
42004b5b:	04a030        	extui	a10, a3, 0, 1
42004b5e:	ff9625        	call8	420044c0 <memprot_ll_dram0_set_pms_area_0>
    return ESP_OK;
42004b61:	020c      	movi.n	a2, 0
        break;
42004b63:	0026c6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004b66:	000000        	ill
        memprot_ll_dram0_set_pms_area_1(r, w);
42004b69:	07bd      	mov.n	a11, a7
42004b6b:	04a030        	extui	a10, a3, 0, 1
42004b6e:	ff9865        	call8	420044f4 <memprot_ll_dram0_set_pms_area_1>
    return ESP_OK;
42004b71:	020c      	movi.n	a2, 0
        break;
42004b73:	0022c6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004b76:	000000        	ill
        memprot_ll_dram0_set_pms_area_2(r, w);
42004b79:	07bd      	mov.n	a11, a7
42004b7b:	04a030        	extui	a10, a3, 0, 1
42004b7e:	ff9ae5        	call8	4200452c <memprot_ll_dram0_set_pms_area_2>
    return ESP_OK;
42004b81:	020c      	movi.n	a2, 0
        break;
42004b83:	001ec6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004b86:	000000        	ill
        memprot_ll_dram0_set_pms_area_3(r, w);
42004b89:	07bd      	mov.n	a11, a7
42004b8b:	04a030        	extui	a10, a3, 0, 1
42004b8e:	ff9d65        	call8	42004564 <memprot_ll_dram0_set_pms_area_3>
    return ESP_OK;
42004b91:	020c      	movi.n	a2, 0
        break;
42004b93:	001ac6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004b96:	000000        	ill
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004b99:	20a440        	or	a10, a4, a4
42004b9c:	ffb4a5        	call8	420046e8 <esp_mprot_cpuid_valid>
42004b9f:	0a2d      	mov.n	a2, a10
42004ba1:	05da56        	bnez	a10, 42004c02 <esp_mprot_set_pms_area+0x16a>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_pms_area(core, r, w, x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_LOW)))
42004ba4:	1f0c      	movi.n	a15, 1
42004ba6:	0fed      	mov.n	a14, a15
42004ba8:	06dd      	mov.n	a13, a6
42004baa:	07cd      	mov.n	a12, a7
42004bac:	10b3f0        	and	a11, a3, a15
42004baf:	04ad      	mov.n	a10, a4
42004bb1:	ff54a5        	call8	420040fc <memprot_ll_rtcfast_set_pms_area>
42004bb4:	00e4a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004bb7:	0a2d      	mov.n	a2, a10
42004bb9:	001146        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004bbc:	400000        	ssr	a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004bbf:	6520a4        	lsi	f10, a0, 0x194
42004bc2:	2dffb2        	s32ri	a11, a15, 180
42004bc5:	560a      	add.n	a5, a6, a0
42004bc7:	038a      	add.n	a0, a3, a8
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_pms_area(core, r, w, x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
42004bc9:	2f0c      	movi.n	a15, 2
42004bcb:	1e0c      	movi.n	a14, 1
42004bcd:	20d660        	or	a13, a6, a6
42004bd0:	20c770        	or	a12, a7, a7
42004bd3:	10b3e0        	and	a11, a3, a14
42004bd6:	04ad      	mov.n	a10, a4
42004bd8:	ff5225        	call8	420040fc <memprot_ll_rtcfast_set_pms_area>
42004bdb:	00e265        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004bde:	0a2d      	mov.n	a2, a10
42004be0:	000786        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
42004be3:	c66000        	lsi	f0, a0, 0x318
        memprot_ll_icache_set_pms_area_0(r, w, x);
42004be6:	b77020        	lsi	f2, a0, 0x2dc
42004be9:	a03020        	addx4	a3, a0, a2
42004bec:	0ca504        	lsi	f0, a5, 48
42004bef:	ff          	.byte	0xff
    return ESP_OK;
42004bf0:	00a022        	movi	a2, 0
        break;
42004bf3:	0002c6        	j	42004c02 <esp_mprot_set_pms_area+0x16a>
        memprot_ll_icache_set_pms_area_1(r, w, x);
42004bf6:	06cd      	mov.n	a12, a6
42004bf8:	07bd      	mov.n	a11, a7
42004bfa:	04a030        	extui	a10, a3, 0, 1
42004bfd:	ff0fa5        	call8	42003cf8 <memprot_ll_icache_set_pms_area_1>
    return ESP_OK;
42004c00:	020c      	movi.n	a2, 0
}
42004c02:	f01d      	retw.n

42004c04 <esp_mprot_get_pms_area>:

esp_err_t esp_mprot_get_pms_area(const esp_mprot_pms_area_t area_type, uint32_t *flags, const int core __attribute__((unused)))
{
42004c04:	006136        	entry	a1, 48
    if (flags == NULL) {
42004c07:	209316        	beqz	a3, 42004e14 <esp_mprot_get_pms_area+0x210>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    bool r = false;
42004c0a:	080c      	movi.n	a8, 0
42004c0c:	004182        	s8i	a8, a1, 0
    bool w = false;
42004c0f:	014182        	s8i	a8, a1, 1
    bool x = false;
42004c12:	024182        	s8i	a8, a1, 2

    switch (area_type) {
42004c15:	02d266        	bnei	a2, 64, 42004c1b <esp_mprot_get_pms_area+0x17>
42004c18:	004406        	j	42004d2c <esp_mprot_get_pms_area+0x128>
42004c1b:	084c      	movi.n	a8, 64
42004c1d:	2e3827        	bltu	a8, a2, 42004c4f <esp_mprot_get_pms_area+0x4b>
42004c20:	028266        	bnei	a2, 8, 42004c26 <esp_mprot_get_pms_area+0x22>
42004c23:	002e46        	j	42004ce0 <esp_mprot_get_pms_area+0xdc>
42004c26:	880c      	movi.n	a8, 8
42004c28:	113827        	bltu	a8, a2, 42004c3d <esp_mprot_get_pms_area+0x39>
42004c2b:	752226        	beqi	a2, 2, 42004ca4 <esp_mprot_get_pms_area+0xa0>
42004c2e:	024266        	bnei	a2, 4, 42004c34 <esp_mprot_get_pms_area+0x30>
42004c31:	002306        	j	42004cc1 <esp_mprot_get_pms_area+0xbd>
42004c34:	4d1226        	beqi	a2, 1, 42004c85 <esp_mprot_get_pms_area+0x81>
42004c37:	ee8821        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004c3a:	007786        	j	42004e1c <esp_mprot_get_pms_area+0x218>
42004c3d:	02b266        	bnei	a2, 16, 42004c43 <esp_mprot_get_pms_area+0x3f>
42004c40:	002e46        	j	42004cfd <esp_mprot_get_pms_area+0xf9>
42004c43:	02c266        	bnei	a2, 32, 42004c49 <esp_mprot_get_pms_area+0x45>
42004c46:	003286        	j	42004d14 <esp_mprot_get_pms_area+0x110>
42004c49:	ee8321        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004c4c:	007306        	j	42004e1c <esp_mprot_get_pms_area+0x218>
42004c4f:	00a282        	movi	a8, 0x200
42004c52:	029287        	bne	a2, a8, 42004c58 <esp_mprot_get_pms_area+0x54>
42004c55:	004a86        	j	42004d83 <esp_mprot_get_pms_area+0x17f>
42004c58:	113827        	bltu	a8, a2, 42004c6d <esp_mprot_get_pms_area+0x69>
42004c5b:	02e266        	bnei	a2, 128, 42004c61 <esp_mprot_get_pms_area+0x5d>
42004c5e:	003886        	j	42004d44 <esp_mprot_get_pms_area+0x140>
42004c61:	02f266        	bnei	a2, 0x100, 42004c67 <esp_mprot_get_pms_area+0x63>
42004c64:	003d86        	j	42004d5e <esp_mprot_get_pms_area+0x15a>
42004c67:	ee7c21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004c6a:	006b86        	j	42004e1c <esp_mprot_get_pms_area+0x218>
42004c6d:	00a482        	movi	a8, 0x400
42004c70:	029287        	bne	a2, a8, 42004c76 <esp_mprot_get_pms_area+0x72>
42004c73:	004c86        	j	42004da9 <esp_mprot_get_pms_area+0x1a5>
42004c76:	ee4681        	l32r	a8, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
42004c79:	029287        	bne	a2, a8, 42004c7f <esp_mprot_get_pms_area+0x7b>
42004c7c:	005206        	j	42004dc8 <esp_mprot_get_pms_area+0x1c4>
42004c7f:	ee7621        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004c82:	006586        	j	42004e1c <esp_mprot_get_pms_area+0x218>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
42004c85:	ee5181        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42004c88:	0020c0        	memw
42004c8b:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004c8d:	049080        	extui	a9, a8, 0, 1
42004c90:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004c93:	049180        	extui	a9, a8, 1, 1
42004c96:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004c99:	048280        	extui	a8, a8, 2, 1
42004c9c:	024182        	s8i	a8, a1, 2
}
42004c9f:	004fc6        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
42004ca2:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
42004ca5:	ee4a      	add.n	a14, a14, a4
42004ca7:	0020c0        	memw
42004caa:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004cac:	049380        	extui	a9, a8, 3, 1
42004caf:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004cb2:	049480        	extui	a9, a8, 4, 1
42004cb5:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004cb8:	048580        	extui	a8, a8, 5, 1
42004cbb:	024182        	s8i	a8, a1, 2
}
42004cbe:	004806        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
42004cc1:	ee4281        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42004cc4:	0020c0        	memw
42004cc7:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004cc9:	049680        	extui	a9, a8, 6, 1
42004ccc:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004ccf:	049780        	extui	a9, a8, 7, 1
42004cd2:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004cd5:	048880        	extui	a8, a8, 8, 1
42004cd8:	024182        	s8i	a8, a1, 2
}
42004cdb:	0040c6        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
42004cde:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
42004ce1:	ee3b      	addi.n	a14, a14, 3
42004ce3:	0020c0        	memw
42004ce6:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004ce8:	049980        	extui	a9, a8, 9, 1
42004ceb:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004cee:	049a80        	extui	a9, a8, 10, 1
42004cf1:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004cf4:	048b80        	extui	a8, a8, 11, 1
42004cf7:	024182        	s8i	a8, a1, 2
}
42004cfa:	003906        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
42004cfd:	ee4d81        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004d00:	0020c0        	memw
42004d03:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004d05:	049080        	extui	a9, a8, 0, 1
42004d08:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004d0b:	048180        	extui	a8, a8, 1, 1
42004d0e:	014182        	s8i	a8, a1, 1
}
42004d11:	003346        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
42004d14:	ee4881        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004d17:	0020c0        	memw
42004d1a:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004d1c:	049280        	extui	a9, a8, 2, 1
42004d1f:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004d22:	048380        	extui	a8, a8, 3, 1
42004d25:	014182        	s8i	a8, a1, 1
}
42004d28:	002d86        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
42004d2b:	428100        	xorb	b8, b1, b0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
42004d2e:	ee          	.byte	0xee
42004d2f:	0020c0        	memw
42004d32:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004d34:	049480        	extui	a9, a8, 4, 1
42004d37:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004d3a:	048580        	extui	a8, a8, 5, 1
42004d3d:	014182        	s8i	a8, a1, 1
}
42004d40:	002786        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
42004d43:	3c8100        	lsi	f0, a1, 240
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
42004d46:	ee          	.byte	0xee
42004d47:	0020c0        	memw
42004d4a:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004d4c:	049680        	extui	a9, a8, 6, 1
42004d4f:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004d52:	048780        	extui	a8, a8, 7, 1
42004d55:	014182        	s8i	a8, a1, 1
}
42004d58:	002186        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
42004d5b:	000000        	ill
        break;
    case MEMPROT_PMS_AREA_DRAM0_3:
        memprot_ll_dram0_get_pms_area_3(&r, &w);
        break;
    case MEMPROT_PMS_AREA_IRAM0_RTCFAST_LO:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004d5e:	20a440        	or	a10, a4, a4
42004d61:	ff9865        	call8	420046e8 <esp_mprot_cpuid_valid>
42004d64:	0a2d      	mov.n	a2, a10
42004d66:	0b2a56        	bnez	a10, 42004e1c <esp_mprot_get_pms_area+0x218>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_pms_area(core, &r, &w, &x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_LOW)))
42004d69:	1f0c      	movi.n	a15, 1
42004d6b:	0fed      	mov.n	a14, a15
42004d6d:	d12b      	addi.n	a13, a1, 2
42004d6f:	c1fa      	add.n	a12, a1, a15
42004d71:	01bd      	mov.n	a11, a1
42004d73:	04ad      	mov.n	a10, a4
42004d75:	ff4625        	call8	420041d8 <memprot_ll_rtcfast_get_pms_area>
42004d78:	00c865        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004d7b:	0a2d      	mov.n	a2, a10
42004d7d:	061a16        	beqz	a10, 42004de2 <esp_mprot_get_pms_area+0x1de>
42004d80:	002606        	j	42004e1c <esp_mprot_get_pms_area+0x218>
        break;
    case MEMPROT_PMS_AREA_IRAM0_RTCFAST_HI:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004d83:	20a440        	or	a10, a4, a4
42004d86:	ff9625        	call8	420046e8 <esp_mprot_cpuid_valid>
42004d89:	0a2d      	mov.n	a2, a10
42004d8b:	08da56        	bnez	a10, 42004e1c <esp_mprot_get_pms_area+0x218>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_pms_area(core, &r, &w, &x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
42004d8e:	2f0c      	movi.n	a15, 2
42004d90:	1e0c      	movi.n	a14, 1
42004d92:	d1fa      	add.n	a13, a1, a15
42004d94:	c1ea      	add.n	a12, a1, a14
42004d96:	20b110        	or	a11, a1, a1
42004d99:	20a440        	or	a10, a4, a4
42004d9c:	ff43a5        	call8	420041d8 <memprot_ll_rtcfast_get_pms_area>
42004d9f:	00c625        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004da2:	0a2d      	mov.n	a2, a10
42004da4:	aabc      	beqz.n	a10, 42004de2 <esp_mprot_get_pms_area+0x1de>
42004da6:	001c86        	j	42004e1c <esp_mprot_get_pms_area+0x218>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0);
42004da9:	ee0881        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42004dac:	0020c0        	memw
42004daf:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004db1:	049c80        	extui	a9, a8, 12, 1
42004db4:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004db7:	049d80        	extui	a9, a8, 13, 1
42004dba:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004dbd:	048e80        	extui	a8, a8, 14, 1
42004dc0:	024182        	s8i	a8, a1, 2
}
42004dc3:	0006c6        	j	42004de2 <esp_mprot_get_pms_area+0x1de>
42004dc6:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1);
42004dc9:	c0ee01        	l32r	a0, 41ff5184 <_coredump_iram_end+0x1c73184>
42004dcc:	880020        	lsi	f2, a0, 0x220
42004dcf:	8008      	l32i.n	a0, a0, 32
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004dd1:	9f          	.byte	0x9f
42004dd2:	419204        	lsi	f0, a2, 0x104
42004dd5:	908000        	addx2	a8, a0, a0
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004dd8:	419205        	call0	420466fc <_etext+0x2f4be>
42004ddb:	818001        	l32r	a0, 41fe53dc <_coredump_iram_end+0x1c633dc>
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004dde:	418205        	call0	42046600 <_etext+0x2f3c2>
42004de1:	080c02        	l8ui	a0, a12, 8
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    *flags = 0;
42004de4:	0389      	s32i.n	a8, a3, 0
    if (r) {
42004de6:	000182        	l8ui	a8, a1, 0
42004de9:	388c      	beqz.n	a8, 42004df0 <esp_mprot_get_pms_area+0x1ec>
        *flags |= MEMPROT_OP_READ;
42004deb:	01a082        	movi	a8, 1
42004dee:	0389      	s32i.n	a8, a3, 0
    }
    if (w) {
42004df0:	010182        	l8ui	a8, a1, 1
42004df3:	988c      	beqz.n	a8, 42004e00 <esp_mprot_get_pms_area+0x1fc>
        *flags |= MEMPROT_OP_WRITE;
42004df5:	0388      	l32i.n	a8, a3, 0
42004df7:	02a092        	movi	a9, 2
42004dfa:	208890        	or	a8, a8, a9
42004dfd:	006382        	s32i	a8, a3, 0
    }
    if (x) {
42004e00:	020182        	l8ui	a8, a1, 2
42004e03:	389c      	beqz.n	a8, 42004e1a <esp_mprot_get_pms_area+0x216>
        *flags |= MEMPROT_OP_EXEC;
42004e05:	0388      	l32i.n	a8, a3, 0
42004e07:	490c      	movi.n	a9, 4
42004e09:	208890        	or	a8, a8, a9
42004e0c:	0389      	s32i.n	a8, a3, 0
    }

    return ESP_OK;
42004e0e:	020c      	movi.n	a2, 0
42004e10:	000206        	j	42004e1c <esp_mprot_get_pms_area+0x218>
42004e13:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004e16:	004602        	s8i	a0, a6, 0
42004e19:	020c00        	andb	b0, b12, b0
}
42004e1c:	f01d      	retw.n
	...

42004e20 <esp_mprot_set_monitor_lock>:

esp_err_t esp_mprot_set_monitor_lock(const esp_mprot_mem_t mem_type, const int core)
{
42004e20:	004136        	entry	a1, 32
42004e23:	207220        	or	a7, a2, a2
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004e26:	20a330        	or	a10, a3, a3
42004e29:	ff8be5        	call8	420046e8 <esp_mprot_cpuid_valid>
42004e2c:	202aa0        	or	a2, a10, a10
42004e2f:	0a1a56        	bnez	a10, 42004ed4 <esp_mprot_set_monitor_lock+0xb4>

    switch (mem_type) {
42004e32:	382726        	beqi	a7, 2, 42004e6e <esp_mprot_set_monitor_lock+0x4e>
42004e35:	654726        	beqi	a7, 4, 42004e9e <esp_mprot_set_monitor_lock+0x7e>
42004e38:	021726        	beqi	a7, 1, 42004e3e <esp_mprot_set_monitor_lock+0x1e>
42004e3b:	002486        	j	42004ed1 <esp_mprot_set_monitor_lock+0xb1>
    switch (core) {
42004e3e:	638c      	beqz.n	a3, 42004e48 <esp_mprot_set_monitor_lock+0x28>
42004e40:	111326        	beqi	a3, 1, 42004e55 <esp_mprot_set_monitor_lock+0x35>
42004e43:	730c      	movi.n	a3, 7
42004e45:	0006c6        	j	42004e64 <esp_mprot_set_monitor_lock+0x44>
            REG_WRITE(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG, 1);
42004e48:	ede981        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e4 <SYSTEM+0x10e4>)
42004e4b:	190c      	movi.n	a9, 1
42004e4d:	0020c0        	memw
42004e50:	0899      	s32i.n	a9, a8, 0
            break;
42004e52:	000386        	j	42004e64 <esp_mprot_set_monitor_lock+0x44>
            REG_WRITE(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG, 1);
42004e55:	ede681        	l32r	a8, 420005f0 <_stext+0x5d0> (600c10f0 <SYSTEM+0x10f0>)
42004e58:	01a092        	movi	a9, 1
42004e5b:	0020c0        	memw
42004e5e:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004e61:	203aa0        	or	a3, a10, a10
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_lock(core)))
42004e64:	03ad      	mov.n	a10, a3
42004e66:	00b9a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004e69:	0a2d      	mov.n	a2, a10
42004e6b:	001946        	j	42004ed4 <esp_mprot_set_monitor_lock+0xb4>
    switch (core) {
42004e6e:	638c      	beqz.n	a3, 42004e78 <esp_mprot_set_monitor_lock+0x58>
42004e70:	111326        	beqi	a3, 1, 42004e85 <esp_mprot_set_monitor_lock+0x65>
42004e73:	730c      	movi.n	a3, 7
42004e75:	0006c6        	j	42004e94 <esp_mprot_set_monitor_lock+0x74>
            REG_WRITE(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG, 1);
42004e78:	edf081        	l32r	a8, 42000638 <_stext+0x618> (600c1104 <SYSTEM+0x1104>)
42004e7b:	190c      	movi.n	a9, 1
42004e7d:	0020c0        	memw
42004e80:	0899      	s32i.n	a9, a8, 0
            break;
42004e82:	000386        	j	42004e94 <esp_mprot_set_monitor_lock+0x74>
            REG_WRITE(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG, 1);
42004e85:	eded81        	l32r	a8, 4200063c <_stext+0x61c> (600c1114 <SYSTEM+0x1114>)
42004e88:	01a092        	movi	a9, 1
42004e8b:	0020c0        	memw
42004e8e:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004e91:	203aa0        	or	a3, a10, a10
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_lock(core)))
42004e94:	03ad      	mov.n	a10, a3
42004e96:	00b6a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004e99:	0a2d      	mov.n	a2, a10
42004e9b:	000d46        	j	42004ed4 <esp_mprot_set_monitor_lock+0xb4>
    switch (core) {
42004e9e:	638c      	beqz.n	a3, 42004ea8 <esp_mprot_set_monitor_lock+0x88>
42004ea0:	111326        	beqi	a3, 1, 42004eb5 <esp_mprot_set_monitor_lock+0x95>
42004ea3:	730c      	movi.n	a3, 7
42004ea5:	0006c6        	j	42004ec4 <esp_mprot_set_monitor_lock+0xa4>
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG, 1);
42004ea8:	eddd81        	l32r	a8, 4200061c <_stext+0x5fc> (600c119c <SYSTEM+0x119c>)
42004eab:	190c      	movi.n	a9, 1
42004ead:	0020c0        	memw
42004eb0:	0899      	s32i.n	a9, a8, 0
            break;
42004eb2:	000386        	j	42004ec4 <esp_mprot_set_monitor_lock+0xa4>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG, 1);
42004eb5:	edda81        	l32r	a8, 42000620 <_stext+0x600> (600c1248 <SYSTEM+0x1248>)
42004eb8:	01a092        	movi	a9, 1
42004ebb:	0020c0        	memw
42004ebe:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004ec1:	203aa0        	or	a3, a10, a10
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_lock(core)))
42004ec4:	03ad      	mov.n	a10, a3
42004ec6:	00b3a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004ec9:	0a2d      	mov.n	a2, a10
42004ecb:	000146        	j	42004ed4 <esp_mprot_set_monitor_lock+0xb4>
42004ece:	000000        	ill
    switch (mem_type) {
42004ed1:	ede121        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004ed4:	f01d      	retw.n
	...

42004ed8 <esp_mprot_get_monitor_lock>:

esp_err_t esp_mprot_get_monitor_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core)
{
42004ed8:	004136        	entry	a1, 32
42004edb:	207220        	or	a7, a2, a2
    if (locked == NULL) {
42004ede:	04a316        	beqz	a3, 42004f2c <esp_mprot_get_monitor_lock+0x54>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004ee1:	20a440        	or	a10, a4, a4
42004ee4:	ff8025        	call8	420046e8 <esp_mprot_cpuid_valid>
42004ee7:	0a2d      	mov.n	a2, a10
42004ee9:	04ba56        	bnez	a10, 42004f38 <esp_mprot_get_monitor_lock+0x60>

    switch (mem_type) {
42004eec:	162726        	beqi	a7, 2, 42004f06 <esp_mprot_get_monitor_lock+0x2e>
42004eef:	274726        	beqi	a7, 4, 42004f1a <esp_mprot_get_monitor_lock+0x42>
42004ef2:	3f1766        	bnei	a7, 1, 42004f35 <esp_mprot_get_monitor_lock+0x5d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_monitor_lock(core, locked)))
42004ef5:	03bd      	mov.n	a11, a3
42004ef7:	04ad      	mov.n	a10, a4
42004ef9:	feffe5        	call8	42003ef8 <memprot_ll_iram0_get_monitor_lock>
42004efc:	00b025        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004eff:	0a2d      	mov.n	a2, a10
42004f01:	000cc6        	j	42004f38 <esp_mprot_get_monitor_lock+0x60>
42004f04:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_monitor_lock(core, locked)))
42004f07:	4020b3        	lsi	f11, a0, 0x100
42004f0a:	a520a4        	lsi	f10, a0, 0x294
42004f0d:	ff68      	l32i.n	a6, a15, 60
42004f0f:	00af25        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004f12:	0a2d      	mov.n	a2, a10
42004f14:	000806        	j	42004f38 <esp_mprot_get_monitor_lock+0x60>
42004f17:	000000        	ill
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_lock(core, locked)))
42004f1a:	20b330        	or	a11, a3, a3
42004f1d:	20a440        	or	a10, a4, a4
42004f20:	ff37a5        	call8	4200429c <memprot_ll_rtcfast_get_monitor_lock>
42004f23:	00ade5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004f26:	0a2d      	mov.n	a2, a10
42004f28:	000306        	j	42004f38 <esp_mprot_get_monitor_lock+0x60>
42004f2b:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004f2e:	014602        	s8i	a0, a6, 1
42004f31:	000000        	ill
42004f34:	c82100        	lsi	f0, a1, 0x320
    switch (mem_type) {
42004f37:	1ded      	lsi	f14, a13, 52
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004f39:	0000f0        	callx12	a0

42004f3c <esp_mprot_set_monitor_en>:

esp_err_t esp_mprot_set_monitor_en(const esp_mprot_mem_t mem_type, const bool enable, const int core)
{
42004f3c:	004136        	entry	a1, 32
42004f3f:	207220        	or	a7, a2, a2
42004f42:	743030        	extui	a3, a3, 0, 8
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004f45:	20a440        	or	a10, a4, a4
42004f48:	ff79e5        	call8	420046e8 <esp_mprot_cpuid_valid>
42004f4b:	0a2d      	mov.n	a2, a10
42004f4d:	03fa56        	bnez	a10, 42004f90 <esp_mprot_set_monitor_en+0x54>

    switch (mem_type) {
42004f50:	162726        	beqi	a7, 2, 42004f6a <esp_mprot_set_monitor_en+0x2e>
42004f53:	244726        	beqi	a7, 4, 42004f7b <esp_mprot_set_monitor_en+0x3f>
42004f56:	331766        	bnei	a7, 1, 42004f8d <esp_mprot_set_monitor_en+0x51>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_en(core, enable)))
42004f59:	03bd      	mov.n	a11, a3
42004f5b:	04ad      	mov.n	a10, a4
42004f5d:	fefd65        	call8	42003f34 <memprot_ll_iram0_set_monitor_en>
42004f60:	00a9e5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004f63:	0a2d      	mov.n	a2, a10
42004f65:	0009c6        	j	42004f90 <esp_mprot_set_monitor_en+0x54>
42004f68:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_en(core, enable)))
42004f6b:	4020b3        	lsi	f11, a0, 0x100
42004f6e:	2520a4        	lsi	f10, a0, 148
42004f71:	e5ff66        	bnei	a15, 0x100, 42004f5a <esp_mprot_set_monitor_en+0x1e>
42004f74:	00a8      	l32i.n	a10, a0, 0
42004f76:	0a2d      	mov.n	a2, a10
42004f78:	000506        	j	42004f90 <esp_mprot_set_monitor_en+0x54>
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_en(core, enable)))
42004f7b:	20b330        	or	a11, a3, a3
42004f7e:	20a440        	or	a10, a4, a4
42004f81:	ff3565        	call8	420042d8 <memprot_ll_rtcfast_set_monitor_en>
42004f84:	00a7a5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004f87:	0a2d      	mov.n	a2, a10
42004f89:	0000c6        	j	42004f90 <esp_mprot_set_monitor_en+0x54>
42004f8c:	b22100        	mulsh	a2, a1, a0
    switch (mem_type) {
42004f8f:	1ded      	lsi	f14, a13, 52
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004f91:	0000f0        	callx12	a0

42004f94 <esp_mprot_get_monitor_en>:

esp_err_t esp_mprot_get_monitor_en(esp_mprot_mem_t mem_type, bool *enabled, const int core)
{
42004f94:	004136        	entry	a1, 32
42004f97:	207220        	or	a7, a2, a2
    if (enabled == NULL) {
42004f9a:	04a316        	beqz	a3, 42004fe8 <esp_mprot_get_monitor_en+0x54>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004f9d:	20a440        	or	a10, a4, a4
42004fa0:	ff7465        	call8	420046e8 <esp_mprot_cpuid_valid>
42004fa3:	0a2d      	mov.n	a2, a10
42004fa5:	04ba56        	bnez	a10, 42004ff4 <esp_mprot_get_monitor_en+0x60>

    switch (mem_type) {
42004fa8:	162726        	beqi	a7, 2, 42004fc2 <esp_mprot_get_monitor_en+0x2e>
42004fab:	274726        	beqi	a7, 4, 42004fd6 <esp_mprot_get_monitor_en+0x42>
42004fae:	3f1766        	bnei	a7, 1, 42004ff1 <esp_mprot_get_monitor_en+0x5d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_monitor_en(core, enabled)))
42004fb1:	03bd      	mov.n	a11, a3
42004fb3:	04ad      	mov.n	a10, a4
42004fb5:	fefe65        	call8	42003f9c <memprot_ll_iram0_get_monitor_en>
42004fb8:	00a465        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004fbb:	0a2d      	mov.n	a2, a10
42004fbd:	000cc6        	j	42004ff4 <esp_mprot_get_monitor_en+0x60>
42004fc0:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_monitor_en(core, enabled)))
42004fc3:	4020b3        	lsi	f11, a0, 0x100
42004fc6:	2520a4        	lsi	f10, a0, 148
42004fc9:	65ff67        	bbsi	a15, 22, 42005032 <esp_mprot_monitor_clear_intr+0x3a>
42004fcc:	2d00a3        	lsi	f10, a0, 180
42004fcf:	060a      	add.n	a0, a6, a0
42004fd1:	0008      	l32i.n	a0, a0, 0
42004fd3:	000000        	ill
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_en(core, enabled)))
42004fd6:	20b330        	or	a11, a3, a3
42004fd9:	20a440        	or	a10, a4, a4
42004fdc:	ff3665        	call8	42004344 <memprot_ll_rtcfast_get_monitor_en>
42004fdf:	00a225        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42004fe2:	0a2d      	mov.n	a2, a10
42004fe4:	000306        	j	42004ff4 <esp_mprot_get_monitor_en+0x60>
42004fe7:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004fea:	014602        	s8i	a0, a6, 1
42004fed:	000000        	ill
42004ff0:	992100        	lsi	f0, a1, 0x264
    switch (mem_type) {
42004ff3:	1ded      	lsi	f14, a13, 52
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004ff5:	0000f0        	callx12	a0

42004ff8 <esp_mprot_monitor_clear_intr>:

    return ESP_OK;
}

esp_err_t esp_mprot_monitor_clear_intr(esp_mprot_mem_t mem_type, const int core)
{
42004ff8:	004136        	entry	a1, 32
42004ffb:	027d      	mov.n	a7, a2
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004ffd:	03ad      	mov.n	a10, a3
42004fff:	ff6ea5        	call8	420046e8 <esp_mprot_cpuid_valid>
42005002:	0a2d      	mov.n	a2, a10
42005004:	060a56        	bnez	a10, 42005068 <esp_mprot_monitor_clear_intr+0x70>

    switch (mem_type) {
42005007:	212726        	beqi	a7, 2, 4200502c <esp_mprot_monitor_clear_intr+0x34>
4200500a:	3a4726        	beqi	a7, 4, 42005048 <esp_mprot_monitor_clear_intr+0x50>
4200500d:	541766        	bnei	a7, 1, 42005065 <esp_mprot_monitor_clear_intr+0x6d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_intrclr(core)))
42005010:	20a330        	or	a10, a3, a3
42005013:	fefbe5        	call8	42003fd0 <memprot_ll_iram0_set_monitor_intrclr>
42005016:	009ea5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42005019:	0a2d      	mov.n	a2, a10
4200501b:	049a56        	bnez	a10, 42005068 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_reset_monitor_intrclr(core)))
4200501e:	03ad      	mov.n	a10, a3
42005020:	fefea5        	call8	4200400c <memprot_ll_iram0_reset_monitor_intrclr>
42005023:	009de5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42005026:	0a2d      	mov.n	a2, a10
42005028:	000f06        	j	42005068 <esp_mprot_monitor_clear_intr+0x70>
4200502b:	03ad00        	lsi	f0, a13, 12
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_intrclr(core)))
4200502e:	ff6425        	call8	42004670 <memprot_ll_dram0_set_monitor_intrclr>
42005031:	009ce5        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42005034:	202aa0        	or	a2, a10, a10
42005037:	daec      	bnez.n	a10, 42005068 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_reset_monitor_intrclr(core)))
42005039:	20a330        	or	a10, a3, a3
4200503c:	ff66e5        	call8	420046ac <memprot_ll_dram0_reset_monitor_intrclr>
4200503f:	009c25        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42005042:	0a2d      	mov.n	a2, a10
42005044:	000806        	j	42005068 <esp_mprot_monitor_clear_intr+0x70>
42005047:	03ad00        	lsi	f0, a13, 12
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_intrclr(core)))
4200504a:	ff32e5        	call8	42004378 <memprot_ll_rtcfast_set_monitor_intrclr>
4200504d:	009b25        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
42005050:	0a2d      	mov.n	a2, a10
42005052:	012a56        	bnez	a10, 42005068 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_reset_monitor_intrclr(core)))
42005055:	20a330        	or	a10, a3, a3
42005058:	ff35a5        	call8	420043b4 <memprot_ll_rtcfast_reset_monitor_intrclr>
4200505b:	009a65        	call8	42005a00 <esp_mprot_ll_err_to_esp_err>
4200505e:	0a2d      	mov.n	a2, a10
42005060:	000106        	j	42005068 <esp_mprot_monitor_clear_intr+0x70>
42005063:	210000        	srai	a0, a0, 0
    switch (mem_type) {
42005066:	ed7c      	movi.n	a13, -2
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42005068:	f01d      	retw.n
	...

4200506c <esp_mprot_is_conf_locked_any>:

esp_err_t esp_mprot_is_conf_locked_any(bool *locked)
{
4200506c:	006136        	entry	a1, 48
4200506f:	027d      	mov.n	a7, a2
    if (locked == NULL) {
42005071:	173216        	beqz	a2, 420051e8 <esp_mprot_is_conf_locked_any+0x17c>
        return ESP_ERR_INVALID_ARG;
    }

    bool lock_on = false;
42005074:	080c      	movi.n	a8, 0
42005076:	004182        	s8i	a8, a1, 0
    esp_err_t err;

    //IRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM) {
42005079:	ed7481        	l32r	a8, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
4200507c:	2888      	l32i.n	a8, a8, 8
4200507e:	6f6807        	bbci	a8, 0, 420050f1 <esp_mprot_is_conf_locked_any+0x85>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
42005081:	fc7c      	movi.n	a12, -1
42005083:	01bd      	mov.n	a11, a1
42005085:	1a0c      	movi.n	a10, 1
42005087:	ff8da5        	call8	42004960 <esp_mprot_get_split_addr_lock>
4200508a:	0a2d      	mov.n	a2, a10
4200508c:	160a56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
4200508f:	000782        	l8ui	a8, a7, 0
42005092:	000192        	l8ui	a9, a1, 0
42005095:	208890        	or	a8, a8, a9
42005098:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
4200509b:	fc7c      	movi.n	a12, -1
4200509d:	01bd      	mov.n	a11, a1
4200509f:	1a0c      	movi.n	a10, 1
420050a1:	ff98a5        	call8	42004a2c <esp_mprot_get_pms_lock>
420050a4:	0a2d      	mov.n	a2, a10
420050a6:	146a56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
420050a9:	000782        	l8ui	a8, a7, 0
420050ac:	000192        	l8ui	a9, a1, 0
420050af:	208890        	or	a8, a8, a9
420050b2:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, PRO_CPU_NUM))
420050b5:	0c0c      	movi.n	a12, 0
420050b7:	01bd      	mov.n	a11, a1
420050b9:	1a0c      	movi.n	a10, 1
420050bb:	ffe1e5        	call8	42004ed8 <esp_mprot_get_monitor_lock>
420050be:	0a2d      	mov.n	a2, a10
420050c0:	12ca56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
420050c3:	000782        	l8ui	a8, a7, 0
420050c6:	000192        	l8ui	a9, a1, 0
420050c9:	208890        	or	a8, a8, a9
420050cc:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
420050cf:	ed5f81        	l32r	a8, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
420050d2:	3888      	l32i.n	a8, a8, 12
420050d4:	1928b6        	bltui	a8, 2, 420050f1 <esp_mprot_is_conf_locked_any+0x85>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, APP_CPU_NUM))
420050d7:	1c0c      	movi.n	a12, 1
420050d9:	01bd      	mov.n	a11, a1
420050db:	0cad      	mov.n	a10, a12
420050dd:	ffdfa5        	call8	42004ed8 <esp_mprot_get_monitor_lock>
420050e0:	0a2d      	mov.n	a2, a10
420050e2:	10aa56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
420050e5:	000782        	l8ui	a8, a7, 0
420050e8:	000192        	l8ui	a9, a1, 0
420050eb:	208890        	or	a8, a8, a9
420050ee:	004782        	s8i	a8, a7, 0
        }
    }

    //DRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM) {
420050f1:	ed5681        	l32r	a8, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
420050f4:	2888      	l32i.n	a8, a8, 8
420050f6:	706817        	bbci	a8, 1, 4200516a <esp_mprot_is_conf_locked_any+0xfe>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
420050f9:	fc7c      	movi.n	a12, -1
420050fb:	01bd      	mov.n	a11, a1
420050fd:	2a0c      	movi.n	a10, 2
420050ff:	ff8625        	call8	42004960 <esp_mprot_get_split_addr_lock>
42005102:	0a2d      	mov.n	a2, a10
42005104:	0e8a56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005107:	000782        	l8ui	a8, a7, 0
4200510a:	000192        	l8ui	a9, a1, 0
4200510d:	208890        	or	a8, a8, a9
42005110:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
42005113:	fc7c      	movi.n	a12, -1
42005115:	01bd      	mov.n	a11, a1
42005117:	2a0c      	movi.n	a10, 2
42005119:	ff9125        	call8	42004a2c <esp_mprot_get_pms_lock>
4200511c:	0a2d      	mov.n	a2, a10
4200511e:	0cea56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005121:	000782        	l8ui	a8, a7, 0
42005124:	000192        	l8ui	a9, a1, 0
42005127:	208890        	or	a8, a8, a9
4200512a:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, PRO_CPU_NUM));
4200512d:	0c0c      	movi.n	a12, 0
4200512f:	01bd      	mov.n	a11, a1
42005131:	2a0c      	movi.n	a10, 2
42005133:	ffda65        	call8	42004ed8 <esp_mprot_get_monitor_lock>
42005136:	0a2d      	mov.n	a2, a10
42005138:	0b4a56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
4200513b:	000782        	l8ui	a8, a7, 0
4200513e:	000192        	l8ui	a9, a1, 0
42005141:	208890        	or	a8, a8, a9
42005144:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
42005147:	ed4181        	l32r	a8, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
4200514a:	3888      	l32i.n	a8, a8, 12
4200514c:	1a28b6        	bltui	a8, 2, 4200516a <esp_mprot_is_conf_locked_any+0xfe>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, APP_CPU_NUM));
4200514f:	1c0c      	movi.n	a12, 1
42005151:	20b110        	or	a11, a1, a1
42005154:	2a0c      	movi.n	a10, 2
42005156:	ffd825        	call8	42004ed8 <esp_mprot_get_monitor_lock>
42005159:	0a2d      	mov.n	a2, a10
4200515b:	091a56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
4200515e:	000782        	l8ui	a8, a7, 0
42005161:	000192        	l8ui	a9, a1, 0
42005164:	208890        	or	a8, a8, a9
42005167:	004782        	s8i	a8, a7, 0
        }
    }

    //RTCFAST
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST) {
4200516a:	ed3881        	l32r	a8, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
4200516d:	2888      	l32i.n	a8, a8, 8
4200516f:	02e827        	bbsi	a8, 2, 42005175 <esp_mprot_is_conf_locked_any+0x109>
42005172:	001e06        	j	420051ee <esp_mprot_is_conf_locked_any+0x182>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM))
42005175:	0c0c      	movi.n	a12, 0
42005177:	01bd      	mov.n	a11, a1
42005179:	4a0c      	movi.n	a10, 4
4200517b:	ff8b25        	call8	42004a2c <esp_mprot_get_pms_lock>
4200517e:	0a2d      	mov.n	a2, a10
42005180:	06ca56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005183:	000782        	l8ui	a8, a7, 0
42005186:	000192        	l8ui	a9, a1, 0
42005189:	208890        	or	a8, a8, a9
4200518c:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM));
4200518f:	0c0c      	movi.n	a12, 0
42005191:	01bd      	mov.n	a11, a1
42005193:	4a0c      	movi.n	a10, 4
42005195:	ffd425        	call8	42004ed8 <esp_mprot_get_monitor_lock>
42005198:	0a2d      	mov.n	a2, a10
4200519a:	052a56        	bnez	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
4200519d:	000782        	l8ui	a8, a7, 0
420051a0:	000192        	l8ui	a9, a1, 0
420051a3:	208890        	or	a8, a8, a9
420051a6:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
420051a9:	ed2881        	l32r	a8, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
420051ac:	3888      	l32i.n	a8, a8, 12
420051ae:	3e28b6        	bltui	a8, 2, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM))
420051b1:	1c0c      	movi.n	a12, 1
420051b3:	01bd      	mov.n	a11, a1
420051b5:	04a0a2        	movi	a10, 4
420051b8:	ff8725        	call8	42004a2c <esp_mprot_get_pms_lock>
420051bb:	0a2d      	mov.n	a2, a10
420051bd:	faec      	bnez.n	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
420051bf:	000782        	l8ui	a8, a7, 0
420051c2:	000192        	l8ui	a9, a1, 0
420051c5:	208890        	or	a8, a8, a9
420051c8:	004782        	s8i	a8, a7, 0

            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM));
420051cb:	1c0c      	movi.n	a12, 1
420051cd:	01bd      	mov.n	a11, a1
420051cf:	4a0c      	movi.n	a10, 4
420051d1:	ffd065        	call8	42004ed8 <esp_mprot_get_monitor_lock>
420051d4:	0a2d      	mov.n	a2, a10
420051d6:	6adc      	bnez.n	a10, 420051f0 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
420051d8:	000782        	l8ui	a8, a7, 0
420051db:	000192        	l8ui	a9, a1, 0
420051de:	208890        	or	a8, a8, a9
420051e1:	004782        	s8i	a8, a7, 0
420051e4:	000206        	j	420051f0 <esp_mprot_is_conf_locked_any+0x184>
420051e7:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
420051ea:	004602        	s8i	a0, a6, 0
420051ed:	020c00        	andb	b0, b12, b0
        }
    }

    return ESP_OK;
}
420051f0:	f01d      	retw.n
	...

420051f4 <esp_mprot_set_prot>:
}

//////////////////////////////////////////////////////////////////////////////
// convenient "public" APIs
esp_err_t esp_mprot_set_prot(const esp_memp_config_t *memp_config)
{
420051f4:	008136        	entry	a1, 64
420051f7:	027d      	mov.n	a7, a2
    RER(reg, dcr);
420051f9:	ec2181        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
420051fc:	406880        	rer	a8, a8
    return (bool)(dcr & 0x1);
420051ff:	044080        	extui	a4, a8, 0, 1
    //debugger connected:
    // 1.check the signal repeatedly to avoid possible glitching attempt
    // 2.leave the Memprot unset to allow debug operations

    if (esp_cpu_dbgr_is_attached()) {
42005202:	5b6807        	bbci	a8, 0, 42005261 <esp_mprot_set_prot+0x6d>
    RER(reg, dcr);
42005205:	ec1e81        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
42005208:	406880        	rer	a8, a8
        ESP_FAULT_ASSERT(esp_cpu_dbgr_is_attached());
4200520b:	13e807        	bbsi	a8, 0, 42005222 <esp_mprot_set_prot+0x2e>
4200520e:	ed3181        	l32r	a8, 420006d4 <_stext+0x6b4> (400006d8 <esp_rom_software_reset_system>)
42005211:	0008e0        	callx8	a8
42005214:	f06d      	ill.n
42005216:	f06d      	ill.n
42005218:	f06d      	ill.n
4200521a:	f06d      	ill.n
4200521c:	f06d      	ill.n
4200521e:	f06d      	ill.n
42005220:	f06d      	ill.n
42005222:	ec1781        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
42005225:	406880        	rer	a8, a8
42005228:	13e807        	bbsi	a8, 0, 4200523f <esp_mprot_set_prot+0x4b>
4200522b:	ed2a81        	l32r	a8, 420006d4 <_stext+0x6b4> (400006d8 <esp_rom_software_reset_system>)
4200522e:	0008e0        	callx8	a8
42005231:	f06d      	ill.n
42005233:	f06d      	ill.n
42005235:	f06d      	ill.n
42005237:	f06d      	ill.n
42005239:	f06d      	ill.n
4200523b:	f06d      	ill.n
4200523d:	f06d      	ill.n
4200523f:	ec1081        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
42005242:	406880        	rer	a8, a8
42005245:	13e807        	bbsi	a8, 0, 4200525c <esp_mprot_set_prot+0x68>
42005248:	ed2381        	l32r	a8, 420006d4 <_stext+0x6b4> (400006d8 <esp_rom_software_reset_system>)
4200524b:	0008e0        	callx8	a8
4200524e:	f06d      	ill.n
42005250:	f06d      	ill.n
42005252:	f06d      	ill.n
42005254:	f06d      	ill.n
42005256:	f06d      	ill.n
42005258:	f06d      	ill.n
4200525a:	f06d      	ill.n
        return ESP_OK;
4200525c:	020c      	movi.n	a2, 0
4200525e:	01e686        	j	420059fc <esp_mprot_set_prot+0x808>
    }

    //sanity checks
    if (memp_config == NULL) {
42005261:	12cc      	bnez.n	a2, 42005266 <esp_mprot_set_prot+0x72>
42005263:	01e046        	j	420059e8 <esp_mprot_set_prot+0x7f4>
        return ESP_ERR_INVALID_ARG;
    }
    if (memp_config->mem_type_mask == MEMPROT_TYPE_NONE) {
42005266:	2258      	l32i.n	a5, a2, 8
42005268:	15cc      	bnez.n	a5, 4200526d <esp_mprot_set_prot+0x79>
4200526a:	01e086        	j	420059f0 <esp_mprot_set_prot+0x7fc>
        return ESP_ERR_NO_MEM;
    }
    if (memp_config->target_cpu_count < 1 || memp_config->target_cpu_count > CONFIG_FREERTOS_NUMBER_OF_CORES) {
4200526d:	3268      	l32i.n	a6, a2, 12
4200526f:	860b      	addi.n	a8, a6, -1
42005271:	0228b6        	bltui	a8, 2, 42005277 <esp_mprot_set_prot+0x83>
42005274:	01e046        	j	420059f9 <esp_mprot_set_prot+0x805>
        return ESP_ERR_MEMPROT_CPUID_INVALID;
    }

    esp_err_t ret = ESP_OK;
    size_t core_count = memp_config->target_cpu_count;
    for (size_t x = 0; x < core_count; x++) {
42005277:	043d      	mov.n	a3, a4
    esp_err_t ret = ESP_OK;
42005279:	020c      	movi.n	a2, 0
4200527b:	000486        	j	42005291 <esp_mprot_set_prot+0x9d>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_cpuid_valid(memp_config->target_cpu[x]))
4200527e:	834b      	addi.n	a8, a3, 4
42005280:	a08870        	addx4	a8, a8, a7
42005283:	08a8      	l32i.n	a10, a8, 0
42005285:	ff4625        	call8	420046e8 <esp_mprot_cpuid_valid>
42005288:	0a2d      	mov.n	a2, a10
4200528a:	1a8c      	beqz.n	a10, 4200528f <esp_mprot_set_prot+0x9b>
4200528c:	01db06        	j	420059fc <esp_mprot_set_prot+0x808>
    for (size_t x = 0; x < core_count; x++) {
4200528f:	331b      	addi.n	a3, a3, 1
42005291:	e93367        	bltu	a3, a6, 4200527e <esp_mprot_set_prot+0x8a>
    }

    bool use_iram0 = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM;
42005294:	048050        	extui	a8, a5, 0, 1
42005297:	5189      	s32i.n	a8, a1, 20
    bool use_dram0 = memp_config->mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM;
42005299:	230c      	movi.n	a3, 2
4200529b:	103530        	and	a3, a5, a3
4200529e:	180c      	movi.n	a8, 1
420052a0:	838330        	moveqz	a8, a3, a3
420052a3:	6189      	s32i.n	a8, a1, 24
    bool use_rtcfast = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST;
420052a5:	480c      	movi.n	a8, 4
420052a7:	108580        	and	a8, a5, a8
420052aa:	4189      	s32i.n	a8, a1, 16

    //disable protection (must be unlocked)
    if (use_iram0) {
420052ac:	1ae507        	bbsi	a5, 0, 420052ca <esp_mprot_set_prot+0xd6>
420052af:	000706        	j	420052cf <esp_mprot_set_prot+0xdb>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, false, memp_config->target_cpu[x]))
420052b2:	854b      	addi.n	a8, a5, 4
420052b4:	a08870        	addx4	a8, a8, a7
420052b7:	08c8      	l32i.n	a12, a8, 0
420052b9:	0b0c      	movi.n	a11, 0
420052bb:	1a0c      	movi.n	a10, 1
420052bd:	ffc7e5        	call8	42004f3c <esp_mprot_set_monitor_en>
420052c0:	0a2d      	mov.n	a2, a10
420052c2:	736a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420052c5:	551b      	addi.n	a5, a5, 1
420052c7:	000046        	j	420052cc <esp_mprot_set_prot+0xd8>
420052ca:	045d      	mov.n	a5, a4
420052cc:	e23567        	bltu	a5, a6, 420052b2 <esp_mprot_set_prot+0xbe>
        }
    }
    if (use_dram0) {
420052cf:	d3dc      	bnez.n	a3, 420052f0 <esp_mprot_set_prot+0xfc>
420052d1:	000806        	j	420052f5 <esp_mprot_set_prot+0x101>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, false, memp_config->target_cpu[x]))
420052d4:	04c582        	addi	a8, a5, 4
420052d7:	a08870        	addx4	a8, a8, a7
420052da:	0028c2        	l32i	a12, a8, 0
420052dd:	00a0b2        	movi	a11, 0
420052e0:	2a0c      	movi.n	a10, 2
420052e2:	ffc5a5        	call8	42004f3c <esp_mprot_set_monitor_en>
420052e5:	0a2d      	mov.n	a2, a10
420052e7:	711a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420052ea:	551b      	addi.n	a5, a5, 1
420052ec:	000086        	j	420052f2 <esp_mprot_set_prot+0xfe>
420052ef:	045d00        	extui	a5, a0, 13, 1
420052f2:	de3567        	bltu	a5, a6, 420052d4 <esp_mprot_set_prot+0xe0>
        }
    }
    if (use_rtcfast) {
420052f5:	4188      	l32i.n	a8, a1, 16
420052f7:	d8dc      	bnez.n	a8, 42005318 <esp_mprot_set_prot+0x124>
420052f9:	000806        	j	4200531d <esp_mprot_set_prot+0x129>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, false, memp_config->target_cpu[x]))
420052fc:	04c582        	addi	a8, a5, 4
420052ff:	a08870        	addx4	a8, a8, a7
42005302:	0028c2        	l32i	a12, a8, 0
42005305:	00a0b2        	movi	a11, 0
42005308:	4a0c      	movi.n	a10, 4
4200530a:	ffc325        	call8	42004f3c <esp_mprot_set_monitor_en>
4200530d:	0a2d      	mov.n	a2, a10
4200530f:	6e9a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
42005312:	551b      	addi.n	a5, a5, 1
42005314:	000086        	j	4200531a <esp_mprot_set_prot+0x126>
42005317:	045d00        	extui	a5, a0, 13, 1
4200531a:	de3567        	bltu	a5, a6, 420052fc <esp_mprot_set_prot+0x108>
        }
    }

    //panic handling
    if (memp_config->invoke_panic_handler) {
4200531d:	000782        	l8ui	a8, a7, 0
42005320:	06f816        	beqz	a8, 42005393 <esp_mprot_set_prot+0x19f>
        if (use_iram0) {
42005323:	5188      	l32i.n	a8, a1, 20
42005325:	b8dc      	bnez.n	a8, 42005344 <esp_mprot_set_prot+0x150>
42005327:	000786        	j	42005349 <esp_mprot_set_prot+0x155>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
4200532a:	04c582        	addi	a8, a5, 4
4200532d:	a08870        	addx4	a8, a8, a7
42005330:	0028b2        	l32i	a11, a8, 0
42005333:	01a0a2        	movi	a10, 1
42005336:	ff3fe5        	call8	42004734 <esp_mprot_set_intr_matrix>
42005339:	0a2d      	mov.n	a2, a10
4200533b:	6bda56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
4200533e:	551b      	addi.n	a5, a5, 1
42005340:	000086        	j	42005346 <esp_mprot_set_prot+0x152>
42005343:	045d00        	extui	a5, a0, 13, 1
42005346:	e03567        	bltu	a5, a6, 4200532a <esp_mprot_set_prot+0x136>
            }
        }
        if (use_dram0) {
42005349:	b3dc      	bnez.n	a3, 42005368 <esp_mprot_set_prot+0x174>
4200534b:	000786        	j	4200536d <esp_mprot_set_prot+0x179>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
4200534e:	04c582        	addi	a8, a5, 4
42005351:	a08870        	addx4	a8, a8, a7
42005354:	0028b2        	l32i	a11, a8, 0
42005357:	02a0a2        	movi	a10, 2
4200535a:	ff3da5        	call8	42004734 <esp_mprot_set_intr_matrix>
4200535d:	0a2d      	mov.n	a2, a10
4200535f:	699a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005362:	551b      	addi.n	a5, a5, 1
42005364:	000086        	j	4200536a <esp_mprot_set_prot+0x176>
42005367:	045d00        	extui	a5, a0, 13, 1
4200536a:	e03567        	bltu	a5, a6, 4200534e <esp_mprot_set_prot+0x15a>
            }
        }
        if (use_rtcfast) {
4200536d:	4188      	l32i.n	a8, a1, 16
4200536f:	b8dc      	bnez.n	a8, 4200538e <esp_mprot_set_prot+0x19a>
42005371:	000786        	j	42005393 <esp_mprot_set_prot+0x19f>
42005374:	c58200        	extui	a8, a0, 18, 13
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42005377:	887004        	lsi	f0, a0, 0x220
4200537a:	28b2a0        	lsi	f10, a2, 160
4200537d:	a0a200        	addx4	a10, a2, a0
42005380:	3b2504        	lsi	f0, a5, 236
42005383:	ff          	.byte	0xff
42005384:	0a2d      	mov.n	a2, a10
42005386:	672a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005389:	551b      	addi.n	a5, a5, 1
4200538b:	000046        	j	42005390 <esp_mprot_set_prot+0x19c>
4200538e:	045d      	mov.n	a5, a4
42005390:	e13567        	bltu	a5, a6, 42005375 <esp_mprot_set_prot+0x181>
            }
        }
    }

    //set split lines (must-have for all mem_types). This version sets only the main I/D which is then shared for all PMS regions
    void *line_addr __attribute__((unused)) = NULL;
42005393:	080c      	movi.n	a8, 0
42005395:	0189      	s32i.n	a8, a1, 0
    if (use_iram0 || use_dram0) {
42005397:	5188      	l32i.n	a8, a1, 20
42005399:	6198      	l32i.n	a9, a1, 24
4200539b:	208890        	or	a8, a8, a9
4200539e:	6189      	s32i.n	a8, a1, 24
420053a0:	0c7816        	beqz	a8, 4200546b <esp_mprot_set_prot+0x277>
        line_addr = memp_config->split_addr;
420053a3:	1788      	l32i.n	a8, a7, 4
420053a5:	0189      	s32i.n	a8, a1, 0
        if (line_addr == NULL) {
420053a7:	b8cc      	bnez.n	a8, 420053b6 <esp_mprot_set_prot+0x1c2>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_default_main_split_addr(MEMPROT_TYPE_IRAM0_SRAM, &line_addr))
420053a9:	01bd      	mov.n	a11, a1
420053ab:	1a0c      	movi.n	a10, 1
420053ad:	ff50a5        	call8	420048b8 <esp_mprot_get_default_main_split_addr>
420053b0:	202aa0        	or	a2, a10, a10
420053b3:	645a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_1, line_addr, DEFAULT_CPU_NUM))
420053b6:	fd7c      	movi.n	a13, -1
420053b8:	01c8      	l32i.n	a12, a1, 0
420053ba:	4b0c      	movi.n	a11, 4
420053bc:	1a0c      	movi.n	a10, 1
420053be:	ff43a5        	call8	420047f8 <esp_mprot_set_split_addr>
420053c1:	0a2d      	mov.n	a2, a10
420053c3:	635a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_0, line_addr, DEFAULT_CPU_NUM))
420053c6:	fd7c      	movi.n	a13, -1
420053c8:	01c8      	l32i.n	a12, a1, 0
420053ca:	2b0c      	movi.n	a11, 2
420053cc:	1a0c      	movi.n	a10, 1
420053ce:	ff42a5        	call8	420047f8 <esp_mprot_set_split_addr>
420053d1:	0a2d      	mov.n	a2, a10
420053d3:	625a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_DRAM0, line_addr, DEFAULT_CPU_NUM))
420053d6:	fd7c      	movi.n	a13, -1
420053d8:	01c8      	l32i.n	a12, a1, 0
420053da:	1b0c      	movi.n	a11, 1
420053dc:	0bad      	mov.n	a10, a11
420053de:	ff41a5        	call8	420047f8 <esp_mprot_set_split_addr>
420053e1:	0a2d      	mov.n	a2, a10
420053e3:	615a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
420053e6:	fd7c      	movi.n	a13, -1
420053e8:	01c8      	l32i.n	a12, a1, 0
420053ea:	ec9081        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
420053ed:	cc8a      	add.n	a12, a12, a8
420053ef:	8b0c      	movi.n	a11, 8
420053f1:	2a0c      	movi.n	a10, 2
420053f3:	ff4065        	call8	420047f8 <esp_mprot_set_split_addr>
420053f6:	0a2d      	mov.n	a2, a10
420053f8:	600a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_1, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
420053fb:	fd7c      	movi.n	a13, -1
420053fd:	01c8      	l32i.n	a12, a1, 0
420053ff:	ec8b81        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
42005402:	cc8a      	add.n	a12, a12, a8
42005404:	0b1c      	movi.n	a11, 16
42005406:	2a0c      	movi.n	a10, 2
42005408:	ff3ee5        	call8	420047f8 <esp_mprot_set_split_addr>
4200540b:	0a2d      	mov.n	a2, a10
4200540d:	5eba56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
    }

    //set permissions
    if (use_iram0) {
42005410:	5188      	l32i.n	a8, a1, 20
42005412:	055816        	beqz	a8, 4200546b <esp_mprot_set_prot+0x277>
        ret = ESP_OK;
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_0, MEMPROT_OP_NONE, DEFAULT_CPU_NUM));
42005415:	fc7c      	movi.n	a12, -1
42005417:	0b0c      	movi.n	a11, 0
42005419:	00a4a2        	movi	a10, 0x400
4200541c:	ff67a5        	call8	42004a98 <esp_mprot_set_pms_area>
4200541f:	0a2d      	mov.n	a2, a10
42005421:	5d7a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
#if CONFIG_ESP32S3_INSTRUCTION_CACHE_16KB
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_1, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM));
42005424:	fc7c      	movi.n	a12, -1
42005426:	5b0c      	movi.n	a11, 5
42005428:	ec5aa1        	l32r	a10, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
4200542b:	ff66e5        	call8	42004a98 <esp_mprot_set_pms_area>
4200542e:	0a2d      	mov.n	a2, a10
42005430:	5c8a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
#else
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_1, MEMPROT_OP_NONE, DEFAULT_CPU_NUM));
#endif
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_0, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
42005433:	fc7c      	movi.n	a12, -1
42005435:	5b0c      	movi.n	a11, 5
42005437:	1a0c      	movi.n	a10, 1
42005439:	ff65e5        	call8	42004a98 <esp_mprot_set_pms_area>
4200543c:	0a2d      	mov.n	a2, a10
4200543e:	5baa56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_1, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
42005441:	fc7c      	movi.n	a12, -1
42005443:	5b0c      	movi.n	a11, 5
42005445:	2a0c      	movi.n	a10, 2
42005447:	ff6525        	call8	42004a98 <esp_mprot_set_pms_area>
4200544a:	0a2d      	mov.n	a2, a10
4200544c:	5aca56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_2, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
4200544f:	fc7c      	movi.n	a12, -1
42005451:	5b0c      	movi.n	a11, 5
42005453:	4a0c      	movi.n	a10, 4
42005455:	ff6425        	call8	42004a98 <esp_mprot_set_pms_area>
42005458:	0a2d      	mov.n	a2, a10
4200545a:	59ea56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_3, MEMPROT_OP_NONE, DEFAULT_CPU_NUM))
4200545d:	fc7c      	movi.n	a12, -1
4200545f:	0b0c      	movi.n	a11, 0
42005461:	8a0c      	movi.n	a10, 8
42005463:	ff6365        	call8	42004a98 <esp_mprot_set_pms_area>
42005466:	0a2d      	mov.n	a2, a10
42005468:	590a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
    }
    if (use_dram0) {
4200546b:	03a316        	beqz	a3, 420054a9 <esp_mprot_set_prot+0x2b5>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_0, MEMPROT_OP_READ, DEFAULT_CPU_NUM))
4200546e:	fc7c      	movi.n	a12, -1
42005470:	1b0c      	movi.n	a11, 1
42005472:	0a1c      	movi.n	a10, 16
42005474:	ff6225        	call8	42004a98 <esp_mprot_set_pms_area>
42005477:	0a2d      	mov.n	a2, a10
42005479:	57fa56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_1, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
4200547c:	fc7c      	movi.n	a12, -1
4200547e:	3b0c      	movi.n	a11, 3
42005480:	0a2c      	movi.n	a10, 32
42005482:	ff6165        	call8	42004a98 <esp_mprot_set_pms_area>
42005485:	0a2d      	mov.n	a2, a10
42005487:	571a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_2, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
4200548a:	fc7c      	movi.n	a12, -1
4200548c:	3b0c      	movi.n	a11, 3
4200548e:	0a4c      	movi.n	a10, 64
42005490:	ff6065        	call8	42004a98 <esp_mprot_set_pms_area>
42005493:	0a2d      	mov.n	a2, a10
42005495:	563a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_3, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
42005498:	ffafc2        	movi	a12, -1
4200549b:	03a0b2        	movi	a11, 3
4200549e:	80a0a2        	movi	a10, 128
420054a1:	ff5f65        	call8	42004a98 <esp_mprot_set_pms_area>
420054a4:	0a2d      	mov.n	a2, a10
420054a6:	552a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
    }

    void *rtc_fast_line __attribute__((unused)) = NULL;
420054a9:	00a082        	movi	a8, 0
420054ac:	016182        	s32i	a8, a1, 4
    if (use_rtcfast) {
420054af:	042182        	l32i	a8, a1, 16
420054b2:	052816        	beqz	a8, 42005508 <esp_mprot_set_prot+0x314>
        //RTCFAST split-line cannot be set manually - always use default
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_default_main_split_addr(MEMPROT_TYPE_IRAM0_RTCFAST, &rtc_fast_line));
420054b5:	b14b      	addi.n	a11, a1, 4
420054b7:	4a0c      	movi.n	a10, 4
420054b9:	ff3fe5        	call8	420048b8 <esp_mprot_get_default_main_split_addr>
420054bc:	0a2d      	mov.n	a2, a10
420054be:	53aa56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420054c1:	045d      	mov.n	a5, a4
420054c3:	000f86        	j	42005505 <esp_mprot_set_prot+0x311>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_RTCFAST, MEMPROT_SPLIT_ADDR_MAIN, rtc_fast_line, memp_config->target_cpu[x]))
420054c6:	854b      	addi.n	a8, a5, 4
420054c8:	a08870        	addx4	a8, a8, a7
420054cb:	08d8      	l32i.n	a13, a8, 0
420054cd:	11c8      	l32i.n	a12, a1, 4
420054cf:	1b0c      	movi.n	a11, 1
420054d1:	4a0c      	movi.n	a10, 4
420054d3:	ff3265        	call8	420047f8 <esp_mprot_set_split_addr>
420054d6:	0a2d      	mov.n	a2, a10
420054d8:	520a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_LO, MEMPROT_OP_READ | MEMPROT_OP_EXEC, memp_config->target_cpu[x]))
420054db:	854b      	addi.n	a8, a5, 4
420054dd:	a08870        	addx4	a8, a8, a7
420054e0:	08c8      	l32i.n	a12, a8, 0
420054e2:	5b0c      	movi.n	a11, 5
420054e4:	00a1a2        	movi	a10, 0x100
420054e7:	ff5b25        	call8	42004a98 <esp_mprot_set_pms_area>
420054ea:	0a2d      	mov.n	a2, a10
420054ec:	50ca56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_HI, MEMPROT_OP_READ | MEMPROT_OP_WRITE, memp_config->target_cpu[x]))
420054ef:	854b      	addi.n	a8, a5, 4
420054f1:	a08870        	addx4	a8, a8, a7
420054f4:	08c8      	l32i.n	a12, a8, 0
420054f6:	3b0c      	movi.n	a11, 3
420054f8:	00a2a2        	movi	a10, 0x200
420054fb:	ff59e5        	call8	42004a98 <esp_mprot_set_pms_area>
420054fe:	0a2d      	mov.n	a2, a10
42005500:	4f8a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
42005503:	551b      	addi.n	a5, a5, 1
42005505:	bd3567        	bltu	a5, a6, 420054c6 <esp_mprot_set_prot+0x2d2>
        }
    }

    //reenable the protection
    if (use_iram0) {
42005508:	5188      	l32i.n	a8, a1, 20
4200550a:	e8ec      	bnez.n	a8, 4200553c <esp_mprot_set_prot+0x348>
4200550c:	000c46        	j	42005541 <esp_mprot_set_prot+0x34d>
4200550f:	820000        	mull	a0, a0, a0
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
42005512:	7004c5        	call0	42075560 <_etext+0x5e322>
42005515:	a088      	l32i.n	a8, a0, 40
42005517:	0028b2        	l32i	a11, a8, 0
4200551a:	1a0c      	movi.n	a10, 1
4200551c:	ffada5        	call8	42004ff8 <esp_mprot_monitor_clear_intr>
4200551f:	0a2d      	mov.n	a2, a10
42005521:	4d7a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, true, memp_config->target_cpu[x]))
42005524:	854b      	addi.n	a8, a5, 4
42005526:	a08870        	addx4	a8, a8, a7
42005529:	08c8      	l32i.n	a12, a8, 0
4200552b:	1b0c      	movi.n	a11, 1
4200552d:	0bad      	mov.n	a10, a11
4200552f:	ffa0e5        	call8	42004f3c <esp_mprot_set_monitor_en>
42005532:	0a2d      	mov.n	a2, a10
42005534:	4c4a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
42005537:	551b      	addi.n	a5, a5, 1
42005539:	000046        	j	4200553e <esp_mprot_set_prot+0x34a>
4200553c:	045d      	mov.n	a5, a4
4200553e:	cf3567        	bltu	a5, a6, 42005511 <esp_mprot_set_prot+0x31d>
        }
    }

    if (use_dram0) {
42005541:	d3ec      	bnez.n	a3, 42005572 <esp_mprot_set_prot+0x37e>
42005543:	000c06        	j	42005577 <esp_mprot_set_prot+0x383>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42005546:	04c582        	addi	a8, a5, 4
42005549:	a08870        	addx4	a8, a8, a7
4200554c:	0028b2        	l32i	a11, a8, 0
4200554f:	02a0a2        	movi	a10, 2
42005552:	ffaa65        	call8	42004ff8 <esp_mprot_monitor_clear_intr>
42005555:	0a2d      	mov.n	a2, a10
42005557:	4a1a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, true, memp_config->target_cpu[x]))
4200555a:	854b      	addi.n	a8, a5, 4
4200555c:	a08870        	addx4	a8, a8, a7
4200555f:	08c8      	l32i.n	a12, a8, 0
42005561:	1b0c      	movi.n	a11, 1
42005563:	2a0c      	movi.n	a10, 2
42005565:	ff9d65        	call8	42004f3c <esp_mprot_set_monitor_en>
42005568:	0a2d      	mov.n	a2, a10
4200556a:	48ea56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200556d:	551b      	addi.n	a5, a5, 1
4200556f:	000046        	j	42005574 <esp_mprot_set_prot+0x380>
42005572:	045d      	mov.n	a5, a4
42005574:	ce3567        	bltu	a5, a6, 42005546 <esp_mprot_set_prot+0x352>
        }
    }
    if (use_rtcfast) {
42005577:	4188      	l32i.n	a8, a1, 16
42005579:	d8ec      	bnez.n	a8, 420055aa <esp_mprot_set_prot+0x3b6>
4200557b:	000c06        	j	420055af <esp_mprot_set_prot+0x3bb>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
4200557e:	04c582        	addi	a8, a5, 4
42005581:	a08870        	addx4	a8, a8, a7
42005584:	0028b2        	l32i	a11, a8, 0
42005587:	04a0a2        	movi	a10, 4
4200558a:	ffa6e5        	call8	42004ff8 <esp_mprot_monitor_clear_intr>
4200558d:	0a2d      	mov.n	a2, a10
4200558f:	469a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, true, memp_config->target_cpu[x]))
42005592:	854b      	addi.n	a8, a5, 4
42005594:	a08870        	addx4	a8, a8, a7
42005597:	08c8      	l32i.n	a12, a8, 0
42005599:	1b0c      	movi.n	a11, 1
4200559b:	4a0c      	movi.n	a10, 4
4200559d:	ff99e5        	call8	42004f3c <esp_mprot_set_monitor_en>
420055a0:	0a2d      	mov.n	a2, a10
420055a2:	456a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420055a5:	551b      	addi.n	a5, a5, 1
420055a7:	000046        	j	420055ac <esp_mprot_set_prot+0x3b8>
420055aa:	045d      	mov.n	a5, a4
420055ac:	ce3567        	bltu	a5, a6, 4200557e <esp_mprot_set_prot+0x38a>
        }
    }

    //lock if required
    if (memp_config->lock_feature) {
420055af:	010782        	l8ui	a8, a7, 1
420055b2:	0a2816        	beqz	a8, 42005658 <esp_mprot_set_prot+0x464>
        if (use_iram0) {
420055b5:	5188      	l32i.n	a8, a1, 20
420055b7:	48bc      	beqz.n	a8, 420055ef <esp_mprot_set_prot+0x3fb>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, DEFAULT_CPU_NUM))
420055b9:	fb7c      	movi.n	a11, -1
420055bb:	1a0c      	movi.n	a10, 1
420055bd:	ff33e5        	call8	420048fc <esp_mprot_set_split_addr_lock>
420055c0:	0a2d      	mov.n	a2, a10
420055c2:	436a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, DEFAULT_CPU_NUM))
420055c5:	fb7c      	movi.n	a11, -1
420055c7:	1a0c      	movi.n	a10, 1
420055c9:	ff3ee5        	call8	420049b8 <esp_mprot_set_pms_lock>
420055cc:	0a2d      	mov.n	a2, a10
420055ce:	42aa56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
420055d1:	045d      	mov.n	a5, a4
420055d3:	000546        	j	420055ec <esp_mprot_set_prot+0x3f8>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
420055d6:	04c582        	addi	a8, a5, 4
420055d9:	a08870        	addx4	a8, a8, a7
420055dc:	08b8      	l32i.n	a11, a8, 0
420055de:	01a0a2        	movi	a10, 1
420055e1:	ff83e5        	call8	42004e20 <esp_mprot_set_monitor_lock>
420055e4:	0a2d      	mov.n	a2, a10
420055e6:	412a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
420055e9:	01c552        	addi	a5, a5, 1
420055ec:	e63567        	bltu	a5, a6, 420055d6 <esp_mprot_set_prot+0x3e2>
            }
        }
        if (use_dram0) {
420055ef:	13bc      	beqz.n	a3, 42005624 <esp_mprot_set_prot+0x430>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, DEFAULT_CPU_NUM))
420055f1:	fb7c      	movi.n	a11, -1
420055f3:	2a0c      	movi.n	a10, 2
420055f5:	ff3065        	call8	420048fc <esp_mprot_set_split_addr_lock>
420055f8:	0a2d      	mov.n	a2, a10
420055fa:	3fea56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, DEFAULT_CPU_NUM))
420055fd:	fb7c      	movi.n	a11, -1
420055ff:	2a0c      	movi.n	a10, 2
42005601:	ff3b65        	call8	420049b8 <esp_mprot_set_pms_lock>
42005604:	0a2d      	mov.n	a2, a10
42005606:	3f2a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005609:	045d      	mov.n	a5, a4
4200560b:	000486        	j	42005621 <esp_mprot_set_prot+0x42d>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
4200560e:	854b      	addi.n	a8, a5, 4
42005610:	a08870        	addx4	a8, a8, a7
42005613:	08b8      	l32i.n	a11, a8, 0
42005615:	2a0c      	movi.n	a10, 2
42005617:	ff80a5        	call8	42004e20 <esp_mprot_set_monitor_lock>
4200561a:	0a2d      	mov.n	a2, a10
4200561c:	3dca56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
4200561f:	551b      	addi.n	a5, a5, 1
42005621:	e93567        	bltu	a5, a6, 4200560e <esp_mprot_set_prot+0x41a>
            }
        }
        if (use_rtcfast) {
42005624:	4188      	l32i.n	a8, a1, 16
42005626:	b8ec      	bnez.n	a8, 42005655 <esp_mprot_set_prot+0x461>
42005628:	000b06        	j	42005658 <esp_mprot_set_prot+0x464>
4200562b:	000000        	ill
            //split address and area permissions are locked by the same PMS register
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
4200562e:	04c482        	addi	a8, a4, 4
42005631:	a08870        	addx4	a8, a8, a7
42005634:	0028b2        	l32i	a11, a8, 0
42005637:	04a0a2        	movi	a10, 4
4200563a:	ff37e5        	call8	420049b8 <esp_mprot_set_pms_lock>
4200563d:	0a2d      	mov.n	a2, a10
4200563f:	3b9a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42005642:	844b      	addi.n	a8, a4, 4
42005644:	a08870        	addx4	a8, a8, a7
42005647:	08b8      	l32i.n	a11, a8, 0
42005649:	4a0c      	movi.n	a10, 4
4200564b:	ff7d65        	call8	42004e20 <esp_mprot_set_monitor_lock>
4200564e:	0a2d      	mov.n	a2, a10
42005650:	3a8a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005653:	441b      	addi.n	a4, a4, 1
42005655:	d53467        	bltu	a4, a6, 4200562e <esp_mprot_set_prot+0x43a>
            }
        }
    }

    //sanity check (RTC FAST tbd within IDF-5208)
    if (use_iram0 || use_dram0) {
42005658:	6188      	l32i.n	a8, a1, 24
4200565a:	375816        	beqz	a8, 420059d3 <esp_mprot_set_prot+0x7df>

        uint32_t check_val;

        //IRAM0 split lines
        memprot_ll_prepare_iram0_split_line_regval((const uint32_t) line_addr, &check_val);
4200565d:	b18b      	addi.n	a11, a1, 8
4200565f:	01a8      	l32i.n	a10, a1, 0
42005661:	fe6d65        	call8	42003d38 <memprot_ll_prepare_iram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
42005664:	ebff81        	l32r	a8, 42000660 <_stext+0x640> (600c10c4 <SYSTEM+0x10c4>)
42005667:	0020c0        	memw
4200566a:	0888      	l32i.n	a8, a8, 0

        if (memprot_ll_get_iram0_split_line_main_I_D_regval() != check_val) {
4200566c:	21b8      	l32i.n	a11, a1, 8
4200566e:	161b87        	beq	a11, a8, 42005688 <esp_mprot_set_prot+0x494>
42005671:	ebfb81        	l32r	a8, 42000660 <_stext+0x640> (600c10c4 <SYSTEM+0x10c4>)
42005674:	0020c0        	memw
42005677:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
42005679:	ec01a1        	l32r	a10, 42000680 <_stext+0x660> (3c0237a8 <_flash_rodata_start+0x3688>)
4200567c:	ea7a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200567f:	0008e0        	callx8	a8
                "Fatal error: Main I/D split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_D_regval());
            abort();
42005682:	ea9c81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005685:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
42005688:	ebf781        	l32r	a8, 42000664 <_stext+0x644> (600c10c8 <SYSTEM+0x10c8>)
4200568b:	0020c0        	memw
4200568e:	0888      	l32i.n	a8, a8, 0
        }
        if (memprot_ll_get_iram0_split_line_main_I_0_regval() != check_val) {
42005690:	161b87        	beq	a11, a8, 420056aa <esp_mprot_set_prot+0x4b6>
42005693:	ebf481        	l32r	a8, 42000664 <_stext+0x644> (600c10c8 <SYSTEM+0x10c8>)
42005696:	0020c0        	memw
42005699:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
4200569b:	ebfaa1        	l32r	a10, 42000684 <_stext+0x664> (3c023808 <_flash_rodata_start+0x36e8>)
4200569e:	ea7181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420056a1:	0008e0        	callx8	a8
                "Fatal error: IRAM0 I_0 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_0_regval());
            abort();
420056a4:	ea9481        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420056a7:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
420056aa:	ebef81        	l32r	a8, 42000668 <_stext+0x648> (600c10cc <SYSTEM+0x10cc>)
420056ad:	0020c0        	memw
420056b0:	002882        	l32i	a8, a8, 0
        }
        if (memprot_ll_get_iram0_split_line_main_I_1_regval() != check_val) {
420056b3:	171b87        	beq	a11, a8, 420056ce <esp_mprot_set_prot+0x4da>
420056b6:	ebec81        	l32r	a8, 42000668 <_stext+0x648> (600c10cc <SYSTEM+0x10cc>)
420056b9:	0020c0        	memw
420056bc:	0028c2        	l32i	a12, a8, 0
            esp_rom_printf(
420056bf:	ebf2a1        	l32r	a10, 42000688 <_stext+0x668> (3c023868 <_flash_rodata_start+0x3748>)
420056c2:	ea6881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420056c5:	0008e0        	callx8	a8
                "Fatal error: IRAM0 I_1 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_1_regval());
            abort();
420056c8:	ea8b81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420056cb:	0008e0        	callx8	a8
        }

        //DRAM0 split lines
        memprot_ll_prepare_dram0_split_line_regval(MAP_IRAM_TO_DRAM((const uint32_t) line_addr), &check_val);
420056ce:	b18b      	addi.n	a11, a1, 8
420056d0:	01a8      	l32i.n	a10, a1, 0
420056d2:	ebd681        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
420056d5:	aa8a      	add.n	a10, a10, a8
420056d7:	fed1a5        	call8	420043f0 <memprot_ll_prepare_dram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
420056da:	ebe481        	l32r	a8, 4200066c <_stext+0x64c> (600c10d0 <SYSTEM+0x10d0>)
420056dd:	0020c0        	memw
420056e0:	0888      	l32i.n	a8, a8, 0

        if (memprot_ll_get_dram0_split_line_main_D_0_regval() != check_val) {
420056e2:	21b8      	l32i.n	a11, a1, 8
420056e4:	161b87        	beq	a11, a8, 420056fe <esp_mprot_set_prot+0x50a>
420056e7:	ebe181        	l32r	a8, 4200066c <_stext+0x64c> (600c10d0 <SYSTEM+0x10d0>)
420056ea:	0020c0        	memw
420056ed:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
420056ef:	ebe7a1        	l32r	a10, 4200068c <_stext+0x66c> (3c0238c8 <_flash_rodata_start+0x37a8>)
420056f2:	ea5c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420056f5:	0008e0        	callx8	a8
                "Fatal error: DRAM0 D_0 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_dram0_split_line_main_D_0_regval());
            abort();
420056f8:	ea7f81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420056fb:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
420056fe:	ebdc81        	l32r	a8, 42000670 <_stext+0x650> (600c10d4 <SYSTEM+0x10d4>)
42005701:	0020c0        	memw
42005704:	002882        	l32i	a8, a8, 0
        }
        if (memprot_ll_get_dram0_split_line_main_D_1_regval() != check_val) {
42005707:	171b87        	beq	a11, a8, 42005722 <esp_mprot_set_prot+0x52e>
4200570a:	ebd981        	l32r	a8, 42000670 <_stext+0x650> (600c10d4 <SYSTEM+0x10d4>)
4200570d:	0020c0        	memw
42005710:	0028c2        	l32i	a12, a8, 0
            esp_rom_printf(
42005713:	ebdfa1        	l32r	a10, 42000690 <_stext+0x670> (3c023928 <_flash_rodata_start+0x3808>)
42005716:	ea5381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005719:	0008e0        	callx8	a8
                "Fatal error: DRAM0 D_1 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_dram0_split_line_main_D_1_regval());
            abort();
4200571c:	ea7681        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200571f:	0008e0        	callx8	a8
        }

        //IRAM0 perms
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_0, &check_val, DEFAULT_CPU_NUM))
42005722:	fc7c      	movi.n	a12, -1
42005724:	b18b      	addi.n	a11, a1, 8
42005726:	1a0c      	movi.n	a10, 1
42005728:	ff4da5        	call8	42004c04 <esp_mprot_get_pms_area>
4200572b:	0a2d      	mov.n	a2, a10
4200572d:	2cba56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42005730:	21c8      	l32i.n	a12, a1, 8
42005732:	105c26        	beqi	a12, 5, 42005746 <esp_mprot_set_prot+0x552>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_0 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005735:	5b0c      	movi.n	a11, 5
42005737:	ebd7a1        	l32r	a10, 42000694 <_stext+0x674> (3c023988 <_flash_rodata_start+0x3868>)
4200573a:	ea4a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200573d:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
42005740:	ea6d81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005743:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_1, &check_val, DEFAULT_CPU_NUM))
42005746:	fc7c      	movi.n	a12, -1
42005748:	b18b      	addi.n	a11, a1, 8
4200574a:	2a0c      	movi.n	a10, 2
4200574c:	ff4b65        	call8	42004c04 <esp_mprot_get_pms_area>
4200574f:	0a2d      	mov.n	a2, a10
42005751:	2a7a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42005754:	21c8      	l32i.n	a12, a1, 8
42005756:	105c26        	beqi	a12, 5, 4200576a <esp_mprot_set_prot+0x576>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_1 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005759:	5b0c      	movi.n	a11, 5
4200575b:	ebcfa1        	l32r	a10, 42000698 <_stext+0x678> (3c0239e4 <_flash_rodata_start+0x38c4>)
4200575e:	ea4181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005761:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
42005764:	ea6481        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005767:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_2, &check_val, DEFAULT_CPU_NUM))
4200576a:	fc7c      	movi.n	a12, -1
4200576c:	b18b      	addi.n	a11, a1, 8
4200576e:	4a0c      	movi.n	a10, 4
42005770:	ff4925        	call8	42004c04 <esp_mprot_get_pms_area>
42005773:	0a2d      	mov.n	a2, a10
42005775:	283a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42005778:	21c8      	l32i.n	a12, a1, 8
4200577a:	105c26        	beqi	a12, 5, 4200578e <esp_mprot_set_prot+0x59a>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_2 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
4200577d:	5b0c      	movi.n	a11, 5
4200577f:	ebc7a1        	l32r	a10, 4200069c <_stext+0x67c> (3c023a40 <_flash_rodata_start+0x3920>)
42005782:	ea3881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005785:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
42005788:	ea5b81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200578b:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_3, &check_val, DEFAULT_CPU_NUM))
4200578e:	ffafc2        	movi	a12, -1
42005791:	08c1b2        	addi	a11, a1, 8
42005794:	08a0a2        	movi	a10, 8
42005797:	ff46e5        	call8	42004c04 <esp_mprot_get_pms_area>
4200579a:	0a2d      	mov.n	a2, a10
4200579c:	25ca56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != MEMPROT_OP_NONE) {
4200579f:	2158      	l32i.n	a5, a1, 8
420057a1:	159c      	beqz.n	a5, 420057b6 <esp_mprot_set_prot+0x5c2>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_3 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420057a3:	05cd      	mov.n	a12, a5
420057a5:	0b0c      	movi.n	a11, 0
420057a7:	ebbea1        	l32r	a10, 420006a0 <_stext+0x680> (3c023a9c <_flash_rodata_start+0x397c>)
420057aa:	ea2e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420057ad:	0008e0        	callx8	a8
                          (uint32_t) MEMPROT_OP_NONE, check_val);
            abort();
420057b0:	ea5181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420057b3:	0008e0        	callx8	a8
        }

        //DRAM0 perms
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_0, &check_val, DEFAULT_CPU_NUM))
420057b6:	fc7c      	movi.n	a12, -1
420057b8:	b18b      	addi.n	a11, a1, 8
420057ba:	0a1c      	movi.n	a10, 16
420057bc:	ff4465        	call8	42004c04 <esp_mprot_get_pms_area>
420057bf:	0a2d      	mov.n	a2, a10
420057c1:	237a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != MEMPROT_OP_READ) {
420057c4:	21c8      	l32i.n	a12, a1, 8
420057c6:	101c26        	beqi	a12, 1, 420057da <esp_mprot_set_prot+0x5e6>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_0 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420057c9:	1b0c      	movi.n	a11, 1
420057cb:	ebb6a1        	l32r	a10, 420006a4 <_stext+0x684> (3c023af8 <_flash_rodata_start+0x39d8>)
420057ce:	ea2581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420057d1:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ, check_val);
            abort();
420057d4:	ea4881        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420057d7:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_1, &check_val, DEFAULT_CPU_NUM))
420057da:	fc7c      	movi.n	a12, -1
420057dc:	b18b      	addi.n	a11, a1, 8
420057de:	0a2c      	movi.n	a10, 32
420057e0:	ff4225        	call8	42004c04 <esp_mprot_get_pms_area>
420057e3:	0a2d      	mov.n	a2, a10
420057e5:	213a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
420057e8:	21c8      	l32i.n	a12, a1, 8
420057ea:	103c26        	beqi	a12, 3, 420057fe <esp_mprot_set_prot+0x60a>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_1 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420057ed:	3b0c      	movi.n	a11, 3
420057ef:	ebaea1        	l32r	a10, 420006a8 <_stext+0x688> (3c023b54 <_flash_rodata_start+0x3a34>)
420057f2:	ea1c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420057f5:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
420057f8:	ea3f81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420057fb:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_2, &check_val, DEFAULT_CPU_NUM))
420057fe:	fc7c      	movi.n	a12, -1
42005800:	b18b      	addi.n	a11, a1, 8
42005802:	0a4c      	movi.n	a10, 64
42005804:	ff3fe5        	call8	42004c04 <esp_mprot_get_pms_area>
42005807:	0a2d      	mov.n	a2, a10
42005809:	1efa56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
4200580c:	21c8      	l32i.n	a12, a1, 8
4200580e:	103c26        	beqi	a12, 3, 42005822 <esp_mprot_set_prot+0x62e>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_2 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005811:	3b0c      	movi.n	a11, 3
42005813:	eba6a1        	l32r	a10, 420006ac <_stext+0x68c> (3c023bb0 <_flash_rodata_start+0x3a90>)
42005816:	ea1381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005819:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
4200581c:	ea3681        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200581f:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_3, &check_val, DEFAULT_CPU_NUM))
42005822:	fc7c      	movi.n	a12, -1
42005824:	b18b      	addi.n	a11, a1, 8
42005826:	80a0a2        	movi	a10, 128
42005829:	ff3da5        	call8	42004c04 <esp_mprot_get_pms_area>
4200582c:	0a2d      	mov.n	a2, a10
4200582e:	1caa56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42005831:	21c8      	l32i.n	a12, a1, 8
42005833:	103c26        	beqi	a12, 3, 42005847 <esp_mprot_set_prot+0x653>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_3 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005836:	3b0c      	movi.n	a11, 3
42005838:	eb9ea1        	l32r	a10, 420006b0 <_stext+0x690> (3c023c0c <_flash_rodata_start+0x3aec>)
4200583b:	ea0a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200583e:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
42005841:	ea2c81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005844:	0008e0        	callx8	a8
        }

        //memory protection enabled
        bool enabled;
        if (use_iram0) {
42005847:	5188      	l32i.n	a8, a1, 20
42005849:	68fc      	bnez.n	a8, 42005883 <esp_mprot_set_prot+0x68f>
4200584b:	000e46        	j	42005888 <esp_mprot_set_prot+0x694>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, &enabled,
4200584e:	844b      	addi.n	a8, a4, 4
42005850:	a08870        	addx4	a8, a8, a7
42005853:	08c8      	l32i.n	a12, a8, 0
42005855:	b1db      	addi.n	a11, a1, 13
42005857:	1a0c      	movi.n	a10, 1
42005859:	ff73a5        	call8	42004f94 <esp_mprot_get_monitor_en>
4200585c:	0a2d      	mov.n	a2, a10
4200585e:	19aa56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                                      memp_config->target_cpu[x]))
                if (!enabled) {
42005861:	0d0182        	l8ui	a8, a1, 13
42005864:	68dc      	bnez.n	a8, 4200587e <esp_mprot_set_prot+0x68a>
                    esp_rom_printf(
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not enabled on core %d)\n",
                        memp_config->target_cpu[x]);
42005866:	04c482        	addi	a8, a4, 4
42005869:	a08870        	addx4	a8, a8, a7
                    esp_rom_printf(
4200586c:	0028b2        	l32i	a11, a8, 0
4200586f:	eb91a1        	l32r	a10, 420006b4 <_stext+0x694> (3c023c68 <_flash_rodata_start+0x3b48>)
42005872:	e9fc81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005875:	0008e0        	callx8	a8
                    abort();
42005878:	ea1f81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200587b:	0008e0        	callx8	a8
            for (size_t x = 0; x < core_count; x++) {
4200587e:	441b      	addi.n	a4, a4, 1
42005880:	000046        	j	42005885 <esp_mprot_set_prot+0x691>
42005883:	054d      	mov.n	a4, a5
42005885:	c53467        	bltu	a4, a6, 4200584e <esp_mprot_set_prot+0x65a>
                }
            }
        }
        if (use_dram0) {
42005888:	83fc      	bnez.n	a3, 420058c4 <esp_mprot_set_prot+0x6d0>
4200588a:	000ec6        	j	420058c9 <esp_mprot_set_prot+0x6d5>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, &enabled,
4200588d:	04c482        	addi	a8, a4, 4
42005890:	a08870        	addx4	a8, a8, a7
42005893:	0028c2        	l32i	a12, a8, 0
42005896:	0dc1b2        	addi	a11, a1, 13
42005899:	2a0c      	movi.n	a10, 2
4200589b:	ff6fa5        	call8	42004f94 <esp_mprot_get_monitor_en>
4200589e:	0a2d      	mov.n	a2, a10
420058a0:	158a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                                      memp_config->target_cpu[x]))
                if (!enabled) {
420058a3:	0d0182        	l8ui	a8, a1, 13
420058a6:	48dc      	bnez.n	a8, 420058be <esp_mprot_set_prot+0x6ca>
                    esp_rom_printf(
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not enabled on core %d)\n",
                        memp_config->target_cpu[x]);
420058a8:	844b      	addi.n	a8, a4, 4
420058aa:	a08870        	addx4	a8, a8, a7
                    esp_rom_printf(
420058ad:	08b8      	l32i.n	a11, a8, 0
420058af:	eb82a1        	l32r	a10, 420006b8 <_stext+0x698> (3c023cc4 <_flash_rodata_start+0x3ba4>)
420058b2:	e9ec81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420058b5:	0008e0        	callx8	a8
                    abort();
420058b8:	ea0f81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420058bb:	0008e0        	callx8	a8
            for (size_t x = 0; x < core_count; x++) {
420058be:	441b      	addi.n	a4, a4, 1
420058c0:	000086        	j	420058c6 <esp_mprot_set_prot+0x6d2>
420058c3:	054d00        	extui	a4, a0, 29, 1
420058c6:	c33467        	bltu	a4, a6, 4200588d <esp_mprot_set_prot+0x699>
                }
            }
        }

        //locks
        if (memp_config->lock_feature) {
420058c9:	010782        	l8ui	a8, a7, 1
420058cc:	103816        	beqz	a8, 420059d3 <esp_mprot_set_prot+0x7df>

            bool locked;

            if (use_iram0) {
420058cf:	5188      	l32i.n	a8, a1, 20
420058d1:	080816        	beqz	a8, 42005955 <esp_mprot_set_prot+0x761>
                ESP_MEMPROT_ERR_CHECK(ret,
420058d4:	fc7c      	movi.n	a12, -1
420058d6:	b1cb      	addi.n	a11, a1, 12
420058d8:	1a0c      	movi.n	a10, 1
420058da:	ff0865        	call8	42004960 <esp_mprot_get_split_addr_lock>
420058dd:	0a2d      	mov.n	a2, a10
420058df:	119a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                                      esp_mprot_get_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
                if (!locked) {
420058e2:	0c0182        	l8ui	a8, a1, 12
420058e5:	d8cc      	bnez.n	a8, 420058f6 <esp_mprot_set_prot+0x702>
                    esp_rom_printf(
420058e7:	eb75a1        	l32r	a10, 420006bc <_stext+0x69c> (3c023d20 <_flash_rodata_start+0x3c00>)
420058ea:	e9de81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420058ed:	0008e0        	callx8	a8
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - split address lock)\n");
                    abort();
420058f0:	ea0181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420058f3:	0008e0        	callx8	a8
                }
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
420058f6:	ffafc2        	movi	a12, -1
420058f9:	0cc1b2        	addi	a11, a1, 12
420058fc:	01a0a2        	movi	a10, 1
420058ff:	ff12e5        	call8	42004a2c <esp_mprot_get_pms_lock>
42005902:	0a2d      	mov.n	a2, a10
42005904:	0f4a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                if (!locked) {
42005907:	0c0182        	l8ui	a8, a1, 12
4200590a:	042856        	bnez	a8, 42005950 <esp_mprot_set_prot+0x75c>
                    esp_rom_printf(
4200590d:	eb6ca1        	l32r	a10, 420006c0 <_stext+0x6a0> (3c023d84 <_flash_rodata_start+0x3c64>)
42005910:	e9d581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005913:	0008e0        	callx8	a8
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - global PMS lock)\n");
                    abort();
42005916:	e9f781        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005919:	0008e0        	callx8	a8
                }
                for (size_t x = 0; x < core_count; x++) {
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked,
4200591c:	844b      	addi.n	a8, a4, 4
4200591e:	a08870        	addx4	a8, a8, a7
42005921:	08c8      	l32i.n	a12, a8, 0
42005923:	b1cb      	addi.n	a11, a1, 12
42005925:	1a0c      	movi.n	a10, 1
42005927:	ff5b25        	call8	42004ed8 <esp_mprot_get_monitor_lock>
4200592a:	0a2d      	mov.n	a2, a10
4200592c:	0cca56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                                          memp_config->target_cpu[x]))
                    if (!locked) {
4200592f:	0c0182        	l8ui	a8, a1, 12
42005932:	48dc      	bnez.n	a8, 4200594a <esp_mprot_set_prot+0x756>
                        esp_rom_printf(
                            "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - monitor lock on core %d)\n",
                            memp_config->target_cpu[x]);
42005934:	844b      	addi.n	a8, a4, 4
42005936:	a08870        	addx4	a8, a8, a7
                        esp_rom_printf(
42005939:	08b8      	l32i.n	a11, a8, 0
4200593b:	eb62a1        	l32r	a10, 420006c4 <_stext+0x6a4> (3c023de8 <_flash_rodata_start+0x3cc8>)
4200593e:	e9c981        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005941:	0008e0        	callx8	a8
                        abort();
42005944:	e9ec81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005947:	0008e0        	callx8	a8
                for (size_t x = 0; x < core_count; x++) {
4200594a:	441b      	addi.n	a4, a4, 1
4200594c:	000086        	j	42005952 <esp_mprot_set_prot+0x75e>
4200594f:	054d00        	extui	a4, a0, 29, 1
42005952:	c63467        	bltu	a4, a6, 4200591c <esp_mprot_set_prot+0x728>
                    }
                }
            }

            if (use_dram0) {
42005955:	07a316        	beqz	a3, 420059d3 <esp_mprot_set_prot+0x7df>
                ESP_MEMPROT_ERR_CHECK(ret,
42005958:	fc7c      	movi.n	a12, -1
4200595a:	b1cb      	addi.n	a11, a1, 12
4200595c:	2a0c      	movi.n	a10, 2
4200595e:	ff0025        	call8	42004960 <esp_mprot_get_split_addr_lock>
42005961:	0a2d      	mov.n	a2, a10
42005963:	095a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                                      esp_mprot_get_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
                if (!locked) {
42005966:	0c0182        	l8ui	a8, a1, 12
42005969:	d8cc      	bnez.n	a8, 4200597a <esp_mprot_set_prot+0x786>
                    esp_rom_printf(
4200596b:	eb57a1        	l32r	a10, 420006c8 <_stext+0x6a8> (3c023e54 <_flash_rodata_start+0x3d34>)
4200596e:	e9bd81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005971:	0008e0        	callx8	a8
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - split address lock)\n");
                    abort();
42005974:	e9e081        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005977:	0008e0        	callx8	a8
                }
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
4200597a:	ffafc2        	movi	a12, -1
4200597d:	0cc1b2        	addi	a11, a1, 12
42005980:	02a0a2        	movi	a10, 2
42005983:	ff0aa5        	call8	42004a2c <esp_mprot_get_pms_lock>
42005986:	0a2d      	mov.n	a2, a10
42005988:	070a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                if (!locked) {
4200598b:	0c0182        	l8ui	a8, a1, 12
4200598e:	03e856        	bnez	a8, 420059d0 <esp_mprot_set_prot+0x7dc>
                    esp_rom_printf(
42005991:	eb4ea1        	l32r	a10, 420006cc <_stext+0x6ac> (3c023eb8 <_flash_rodata_start+0x3d98>)
42005994:	e9b481        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005997:	0008e0        	callx8	a8
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - global PMS lock)\n");
                    abort();
4200599a:	e9d681        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200599d:	0008e0        	callx8	a8
                }
                for (size_t x = 0; x < core_count; x++) {
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked,
420059a0:	854b      	addi.n	a8, a5, 4
420059a2:	a08870        	addx4	a8, a8, a7
420059a5:	08c8      	l32i.n	a12, a8, 0
420059a7:	b1cb      	addi.n	a11, a1, 12
420059a9:	2a0c      	movi.n	a10, 2
420059ab:	ff52e5        	call8	42004ed8 <esp_mprot_get_monitor_lock>
420059ae:	0a2d      	mov.n	a2, a10
420059b0:	048a56        	bnez	a10, 420059fc <esp_mprot_set_prot+0x808>
                                          memp_config->target_cpu[x]))
                    if (!locked) {
420059b3:	0c0182        	l8ui	a8, a1, 12
420059b6:	48dc      	bnez.n	a8, 420059ce <esp_mprot_set_prot+0x7da>
                        esp_rom_printf(
                            "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - monitor lock on core %d)\n",
                            memp_config->target_cpu[x]);
420059b8:	854b      	addi.n	a8, a5, 4
420059ba:	a08870        	addx4	a8, a8, a7
                        esp_rom_printf(
420059bd:	08b8      	l32i.n	a11, a8, 0
420059bf:	eb44a1        	l32r	a10, 420006d0 <_stext+0x6b0> (3c023f1c <_flash_rodata_start+0x3dfc>)
420059c2:	e9a881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420059c5:	0008e0        	callx8	a8
                        abort();
420059c8:	e9cb81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
420059cb:	0008e0        	callx8	a8
                for (size_t x = 0; x < core_count; x++) {
420059ce:	551b      	addi.n	a5, a5, 1
420059d0:	cc3567        	bltu	a5, a6, 420059a0 <esp_mprot_set_prot+0x7ac>
            }
        }
    }

    //keep current configuration copy if all went well
    if (ret == ESP_OK) {
420059d3:	52ec      	bnez.n	a2, 420059fc <esp_mprot_set_prot+0x808>
        s_memp_cfg = *memp_config;
420059d5:	18a0c2        	movi	a12, 24
420059d8:	20b770        	or	a11, a7, a7
420059db:	eb1ca1        	l32r	a10, 4200064c <_stext+0x62c> (3fc92078 <s_memp_cfg>)
420059de:	e99281        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420059e1:	0008e0        	callx8	a8
420059e4:	000506        	j	420059fc <esp_mprot_set_prot+0x808>
420059e7:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
420059ea:	034602        	s8i	a0, a6, 3
420059ed:	000000        	ill
        return ESP_ERR_NO_MEM;
420059f0:	01a122        	movi	a2, 0x101
420059f3:	000146        	j	420059fc <esp_mprot_set_prot+0x808>
420059f6:	000000        	ill
        return ESP_ERR_MEMPROT_CPUID_INVALID;
420059f9:	eb1321        	l32r	a2, 42000648 <_stext+0x628> (d008 <UserFrameTotalSize+0xcf08>)
    }

    return ret;
}
420059fc:	f01d      	retw.n
	...

42005a00 <esp_mprot_ll_err_to_esp_err>:
#include "esp_memprot_err.h"
#include "hal/memprot_types.h"
#include "esp_memprot_types.h"

esp_err_t esp_mprot_ll_err_to_esp_err(const memprot_hal_err_t err)
{
42005a00:	004136        	entry	a1, 32
    switch (err) {
42005a03:	194226        	beqi	a2, 4, 42005a20 <esp_mprot_ll_err_to_esp_err+0x20>
42005a06:	0a52e6        	bgei	a2, 5, 42005a14 <esp_mprot_ll_err_to_esp_err+0x14>
42005a09:	1b2226        	beqi	a2, 2, 42005a28 <esp_mprot_ll_err_to_esp_err+0x28>
42005a0c:	203226        	beqi	a2, 3, 42005a30 <esp_mprot_ll_err_to_esp_err+0x30>
42005a0f:	32ec      	bnez.n	a2, 42005a36 <esp_mprot_ll_err_to_esp_err+0x36>
42005a11:	000bc6        	j	42005a44 <esp_mprot_ll_err_to_esp_err+0x44>
42005a14:	245226        	beqi	a2, 5, 42005a3c <esp_mprot_ll_err_to_esp_err+0x3c>
42005a17:	276266        	bnei	a2, 6, 42005a42 <esp_mprot_ll_err_to_esp_err+0x42>
    case MEMP_HAL_OK: return ESP_OK;
    case MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE: return ESP_ERR_MEMPROT_SPLIT_ADDR_OUT_OF_RANGE;
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
    case MEMP_HAL_ERR_UNI_BLOCK_INVALID: return ESP_ERR_MEMPROT_UNIMGMT_BLOCK_INVALID;
    case MEMP_HAL_ERR_WORLD_INVALID: return ESP_ERR_MEMPROT_WORLD_INVALID;
42005a1a:	eb3221        	l32r	a2, 420006e4 <_stext+0x6c4> (d006 <UserFrameTotalSize+0xcf06>)
42005a1d:	0008c6        	j	42005a44 <esp_mprot_ll_err_to_esp_err+0x44>
    case MEMP_HAL_ERR_UNI_BLOCK_INVALID: return ESP_ERR_MEMPROT_UNIMGMT_BLOCK_INVALID;
42005a20:	eb3021        	l32r	a2, 420006e0 <_stext+0x6c0> (d005 <UserFrameTotalSize+0xcf05>)
42005a23:	000746        	j	42005a44 <esp_mprot_ll_err_to_esp_err+0x44>
42005a26:	210000        	srai	a0, a0, 0
    case MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE: return ESP_ERR_MEMPROT_SPLIT_ADDR_OUT_OF_RANGE;
42005a29:	eb2c      	movi.n	a11, 46
42005a2b:	000546        	j	42005a44 <esp_mprot_ll_err_to_esp_err+0x44>
42005a2e:	210000        	srai	a0, a0, 0
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
42005a31:	eb2b      	addi.n	a14, a11, 2
42005a33:	000346        	j	42005a44 <esp_mprot_ll_err_to_esp_err+0x44>
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
    default:
        return ESP_FAIL;
42005a36:	f27c      	movi.n	a2, -1
42005a38:	000206        	j	42005a44 <esp_mprot_ll_err_to_esp_err+0x44>
42005a3b:	2b2100        	oeq.s	b2, f1, f0
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
42005a3e:	46eb      	addi.n	a4, a6, 14
42005a40:	7c0000        	lsi	f0, a0, 0x1f0
        return ESP_FAIL;
42005a43:	f01df2        	l16ui	a15, a13, 0x1e0
	...

42005a48 <esp_cpu_intr_get_desc>:
    [31] = { 5, ESP_CPU_INTR_TYPE_LEVEL, { 0,                              0                               } },
};


void esp_cpu_intr_get_desc(int core_id, int intr_num, esp_cpu_intr_desc_t *intr_desc_ret)
{
42005a48:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM && intr_desc_ret != NULL);
42005a4b:	180c      	movi.n	a8, 1
42005a4d:	628820        	lsi	f2, a8, 0x188
42005a50:	880b      	addi.n	a8, a8, -1
42005a52:	608080        	neg	a8, a8
42005a55:	01a092        	movi	a9, 1
42005a58:	839440        	moveqz	a9, a4, a4
42005a5b:	118897        	bany	a8, a9, 42005a70 <esp_cpu_intr_get_desc+0x28>
42005a5e:	eb23d1        	l32r	a13, 420006ec <_stext+0x6cc> (3c023f88 <_flash_rodata_start+0x3e68>)
42005a61:	eb23c1        	l32r	a12, 420006f0 <_stext+0x6d0> (3c027ec4 <__func__$0>)
42005a64:	47a0b2        	movi	a11, 71
42005a67:	eb23a1        	l32r	a10, 420006f4 <_stext+0x6d4> (3c023ffd <_flash_rodata_start+0x3edd>)
42005a6a:	e99581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42005a6d:	0008e0        	callx8	a8
    intr_desc_ret->priority = intr_desc_table[intr_num].priority;
42005a70:	eb2291        	l32r	a9, 420006f8 <_stext+0x6d8> (3c027edc <intr_desc_table>)
42005a73:	1183c0        	slli	a8, a3, 4
42005a76:	898a      	add.n	a8, a9, a8
42005a78:	08a8      	l32i.n	a10, a8, 0
42005a7a:	04a9      	s32i.n	a10, a4, 0
    intr_desc_ret->type = intr_desc_table[intr_num].type;
42005a7c:	1888      	l32i.n	a8, a8, 4
42005a7e:	1489      	s32i.n	a8, a4, 4
    intr_desc_ret->flags = intr_desc_table[intr_num].flags[core_id];
42005a80:	a03320        	addx4	a3, a3, a2
42005a83:	a03390        	addx4	a3, a3, a9
42005a86:	2388      	l32i.n	a8, a3, 8
42005a88:	2489      	s32i.n	a8, a4, 8
}
42005a8a:	f01d      	retw.n

42005a8c <esp_sleep_sub_mode_config>:
    assert(refs >= 0);
    return ESP_OK;
}

esp_err_t esp_sleep_sub_mode_config(esp_sleep_sub_mode_t mode, bool activate)
{
42005a8c:	004136        	entry	a1, 32
42005a8f:	743030        	extui	a3, a3, 0, 8
    if (mode >= ESP_SLEEP_MODE_MAX) {
42005a92:	7f72f6        	bgeui	a2, 7, 42005b15 <esp_sleep_sub_mode_config+0x89>
    if (xPortInIsrContext()) {
42005a95:	ea5781        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
42005a98:	0008e0        	callx8	a8
42005a9b:	ca8c      	beqz.n	a10, 42005aab <esp_sleep_sub_mode_config+0x1f>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42005a9d:	fb7c      	movi.n	a11, -1
42005a9f:	eb17a1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc920c0 <s_config+0x30>)
42005aa2:	ea5b81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42005aa5:	0008e0        	callx8	a8
42005aa8:	000286        	j	42005ab6 <esp_sleep_sub_mode_config+0x2a>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
42005aab:	fb7c      	movi.n	a11, -1
42005aad:	eb13a1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc920c0 <s_config+0x30>)
42005ab0:	ea5881        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42005ab3:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }

    portENTER_CRITICAL_SAFE(&s_config.lock);
    if (activate) {
42005ab6:	e38c      	beqz.n	a3, 42005ac8 <esp_sleep_sub_mode_config+0x3c>
        s_sleep_sub_mode_ref_cnt[mode]++;
42005ab8:	eb1281        	l32r	a8, 42000700 <_stext+0x6e0> (600fe000 <s_sleep_sub_mode_ref_cnt>)
42005abb:	a08280        	addx4	a8, a2, a8
42005abe:	0898      	l32i.n	a9, a8, 0
42005ac0:	991b      	addi.n	a9, a9, 1
42005ac2:	0899      	s32i.n	a9, a8, 0
42005ac4:	000306        	j	42005ad4 <esp_sleep_sub_mode_config+0x48>
42005ac7:	0e8100        	lsi	f0, a1, 56
    } else {
        s_sleep_sub_mode_ref_cnt[mode]--;
42005aca:	80eb      	addi.n	a8, a0, 14
42005acc:	98a082        	movi	a8, 152
42005acf:	0b08      	l32i.n	a0, a11, 0
42005ad1:	9999      	s32i.n	a9, a9, 36
42005ad3:	8108      	l32i.n	a0, a1, 32
    }
    assert(s_sleep_sub_mode_ref_cnt[mode] >= 0);
42005ad5:	eb0b      	addi.n	a14, a11, -1
42005ad7:	a02280        	addx4	a2, a2, a8
42005ada:	0288      	l32i.n	a8, a2, 0
42005adc:	0118d6        	bgez	a8, 42005af1 <esp_sleep_sub_mode_config+0x65>
42005adf:	eb09d1        	l32r	a13, 42000704 <_stext+0x6e4> (3c0240b8 <_flash_rodata_start+0x3f98>)
42005ae2:	eb09c1        	l32r	a12, 42000708 <_stext+0x6e8> (3c0280dc <__func__$4>)
42005ae5:	eb09b1        	l32r	a11, 4200070c <_stext+0x6ec> (8ca <UserFrameTotalSize+0x7ca>)
42005ae8:	eb0aa1        	l32r	a10, 42000710 <_stext+0x6f0> (3c02407c <_flash_rodata_start+0x3f5c>)
42005aeb:	e97581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42005aee:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
42005af1:	ea4081        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
42005af4:	0008e0        	callx8	a8
42005af7:	0a2d      	mov.n	a2, a10
42005af9:	ca8c      	beqz.n	a10, 42005b09 <esp_sleep_sub_mode_config+0x7d>
        portEXIT_CRITICAL_ISR(mux);
42005afb:	eb00a1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc920c0 <s_config+0x30>)
42005afe:	ea4581        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42005b01:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&s_config.lock);
    return ESP_OK;
42005b04:	020c      	movi.n	a2, 0
42005b06:	000386        	j	42005b18 <esp_sleep_sub_mode_config+0x8c>
        portEXIT_CRITICAL(mux);
42005b09:	eafca1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc920c0 <s_config+0x30>)
42005b0c:	ea4281        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42005b0f:	0008e0        	callx8	a8
42005b12:	000086        	j	42005b18 <esp_sleep_sub_mode_config+0x8c>
        return ESP_ERR_INVALID_ARG;
42005b15:	02a122        	movi	a2, 0x102
}
42005b18:	f01d      	retw.n
	...

42005b1c <__esp_system_init_fn_init_libc>:
#include "esp_newlib.h"
#include "esp_private/startup_internal.h"
#include "esp_bit_defs.h"

ESP_SYSTEM_INIT_FN(init_libc, CORE, BIT(0), 102)
{
42005b1c:	004136        	entry	a1, 32
    esp_libc_init();
42005b1f:	0037a5        	call8	42005e98 <esp_libc_init>
    return ESP_OK;
}
42005b22:	020c      	movi.n	a2, 0
42005b24:	f01d      	retw.n
	...

42005b28 <__esp_system_init_fn_init_libc_stdio>:

ESP_SYSTEM_INIT_FN(init_libc_stdio, CORE, BIT(0), 115)
{
42005b28:	004136        	entry	a1, 32
#if CONFIG_VFS_SUPPORT_IO
    esp_libc_init_global_stdio("/dev/console");
42005b2b:	eafaa1        	l32r	a10, 42000714 <_stext+0x6f4> (3c024d94 <_flash_rodata_start+0x4c74>)
42005b2e:	003b65        	call8	42005ee4 <esp_libc_init_global_stdio>
#else
    esp_libc_init_global_stdio();
#endif
    return ESP_OK;
}
42005b31:	020c      	movi.n	a2, 0
42005b33:	f01d      	retw.n
42005b35:	000000        	ill

42005b38 <esp_libc_newlib_locks_init>:
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___dd_hash_mutex;
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___arc4random_mutex;

#if CONFIG_LIBC_NEWLIB
static void esp_libc_newlib_locks_init(void)
{
42005b38:	006136        	entry	a1, 48
     * No access to lock variables for the purpose of ECO forward compatibility,
     * however we have an API to initialize lock variables used in the ROM.
     */
    extern void esp_rom_newlib_init_common_mutexes(_LOCK_T, _LOCK_T);
    /* See notes about ROM_NEEDS_MUTEX_OVERRIDE above */
    int magic_val = ROM_MUTEX_MAGIC;
42005b3b:	eaf781        	l32r	a8, 42000718 <_stext+0x6f8> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
42005b3e:	0189      	s32i.n	a8, a1, 0
    _LOCK_T magic_mutex = (_LOCK_T) &magic_val;
    esp_rom_newlib_init_common_mutexes(magic_mutex, magic_mutex);
42005b40:	01bd      	mov.n	a11, a1
42005b42:	01ad      	mov.n	a10, a1
42005b44:	eaf681        	l32r	a8, 4200071c <_stext+0x6fc> (400011dc <esp_rom_newlib_init_common_mutexes>)
42005b47:	0008e0        	callx8	a8
#else // other target
#error Unsupported target
#endif
}
42005b4a:	f01d      	retw.n

42005b4c <esp_libc_locks_init>:
#endif // CONFIG_LIBC_NEWLIB

/* TODO IDF-11226 */
void esp_newlib_locks_init(void) __attribute__((alias("esp_libc_locks_init")));
void esp_libc_locks_init(void)
{
42005b4c:	004136        	entry	a1, 32
    /* Initialize the two mutexes used for the locks above.
     * Asserts below check our assumption that SemaphoreHandle_t will always
     * point to the corresponding StaticSemaphore_t structure.
     */
    SemaphoreHandle_t handle;
    handle = xSemaphoreCreateMutexStatic(&s_common_mutex);
42005b4f:	eaf471        	l32r	a7, 42000720 <_stext+0x700> (3fc94f78 <__lock___arc4random_mutex>)
42005b52:	07bd      	mov.n	a11, a7
42005b54:	1a0c      	movi.n	a10, 1
42005b56:	ea1f81        	l32r	a8, 420003d4 <_stext+0x3b4> (40379c68 <xQueueCreateMutexStatic>)
42005b59:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_mutex);
42005b5c:	1117a7        	beq	a7, a10, 42005b71 <esp_libc_locks_init+0x25>
42005b5f:	eaf1d1        	l32r	a13, 42000724 <_stext+0x704> (3c024e38 <_flash_rodata_start+0x4d18>)
42005b62:	eaf1c1        	l32r	a12, 42000728 <_stext+0x708> (3c0284c8 <__func__$4>)
42005b65:	a0a1b2        	movi	a11, 0x1a0
42005b68:	eaf1a1        	l32r	a10, 4200072c <_stext+0x70c> (3c024dec <_flash_rodata_start+0x4ccc>)
42005b6b:	e95581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42005b6e:	0008e0        	callx8	a8
    handle = xSemaphoreCreateRecursiveMutexStatic(&s_common_recursive_mutex);
42005b71:	eaef71        	l32r	a7, 42000730 <_stext+0x710> (3fc94f24 <__lock___atexit_recursive_mutex>)
42005b74:	20b770        	or	a11, a7, a7
42005b77:	04a0a2        	movi	a10, 4
42005b7a:	ea1681        	l32r	a8, 420003d4 <_stext+0x3b4> (40379c68 <xQueueCreateMutexStatic>)
42005b7d:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_recursive_mutex);
42005b80:	1117a7        	beq	a7, a10, 42005b95 <esp_libc_locks_init+0x49>
42005b83:	eaecd1        	l32r	a13, 42000734 <_stext+0x714> (3c024e68 <_flash_rodata_start+0x4d48>)
42005b86:	eae8c1        	l32r	a12, 42000728 <_stext+0x708> (3c0284c8 <__func__$4>)
42005b89:	a2a1b2        	movi	a11, 0x1a2
42005b8c:	eae8a1        	l32r	a10, 4200072c <_stext+0x70c> (3c024dec <_flash_rodata_start+0x4ccc>)
42005b8f:	e94c81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42005b92:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &__lock___libc_recursive_mutex);
#endif
    (void) handle;

#if CONFIG_LIBC_NEWLIB
    esp_libc_newlib_locks_init();
42005b95:	fffa25        	call8	42005b38 <esp_libc_newlib_locks_init>
#endif
}
42005b98:	f01d      	retw.n
	...

42005b9c <adjust_boot_time>:
{
42005b9c:	004136        	entry	a1, 32
    uint64_t boot_time = esp_time_impl_get_boot_time();
42005b9f:	002125        	call8	42005db0 <esp_time_impl_get_boot_time>
42005ba2:	202aa0        	or	a2, a10, a10
42005ba5:	203bb0        	or	a3, a11, a11
    if ((boot_time == 0) || (esp_time_impl_get_time_since_boot() < s_adjtime_start_us)) {
42005ba8:	208ab0        	or	a8, a10, a11
42005bab:	189c      	beqz.n	a8, 42005bc0 <adjust_boot_time+0x24>
42005bad:	001be5        	call8	42005d6c <esp_time_impl_get_time_since_boot>
42005bb0:	eae281        	l32r	a8, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005bb3:	0898      	l32i.n	a9, a8, 0
42005bb5:	1888      	l32i.n	a8, a8, 4
42005bb7:	053b87        	bltu	a11, a8, 42005bc0 <adjust_boot_time+0x24>
42005bba:	0b98b7        	bne	a8, a11, 42005bc9 <adjust_boot_time+0x2d>
42005bbd:	08ba97        	bgeu	a10, a9, 42005bc9 <adjust_boot_time+0x2d>
        s_adjtime_start_us = 0;
42005bc0:	eade81        	l32r	a8, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005bc3:	090c      	movi.n	a9, 0
42005bc5:	0899      	s32i.n	a9, a8, 0
42005bc7:	1899      	s32i.n	a9, a8, 4
    if (s_adjtime_start_us > 0) {
42005bc9:	eadb91        	l32r	a9, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005bcc:	0988      	l32i.n	a8, a9, 0
42005bce:	1998      	l32i.n	a9, a9, 4
42005bd0:	208890        	or	a8, a8, a9
42005bd3:	0d9816        	beqz	a8, 42005cb0 <adjust_boot_time+0x114>
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
42005bd6:	001965        	call8	42005d6c <esp_time_impl_get_time_since_boot>
        int64_t correction = (since_boot >> ADJTIME_CORRECTION_FACTOR) - (s_adjtime_start_us >> ADJTIME_CORRECTION_FACTOR);
42005bd9:	018b60        	slli	a8, a11, 26
42005bdc:	41d6a0        	srli	a13, a10, 6
42005bdf:	20d8d0        	or	a13, a8, a13
42005be2:	4176b0        	srli	a7, a11, 6
42005be5:	ead481        	l32r	a8, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005be8:	1898      	l32i.n	a9, a8, 4
42005bea:	01c960        	slli	a12, a9, 26
42005bed:	0888      	l32i.n	a8, a8, 0
42005bef:	418680        	srli	a8, a8, 6
42005bf2:	208c80        	or	a8, a12, a8
42005bf5:	41c690        	srli	a12, a9, 6
42005bf8:	c0e7c0        	sub	a14, a7, a12
42005bfb:	01bd87        	bgeu	a13, a8, 42005c00 <adjust_boot_time+0x64>
42005bfe:	ee0b      	addi.n	a14, a14, -1
42005c00:	c0fd80        	sub	a15, a13, a8
42005c03:	0f6d      	mov.n	a6, a15
42005c05:	0e9d      	mov.n	a9, a14
        if (correction > 0) {
42005c07:	051ee6        	bgei	a14, 1, 42005c10 <adjust_boot_time+0x74>
42005c0a:	0a2e56        	bnez	a14, 42005cb0 <adjust_boot_time+0x114>
42005c0d:	09ff16        	beqz	a15, 42005cb0 <adjust_boot_time+0x114>
            s_adjtime_start_us = since_boot;
42005c10:	eaca51        	l32r	a5, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005c13:	05a9      	s32i.n	a10, a5, 0
42005c15:	15b9      	s32i.n	a11, a5, 4
            if (s_adjtime_total_correction_us < 0) {
42005c17:	eac9b1        	l32r	a11, 4200073c <_stext+0x71c> (3fc94fd0 <s_adjtime_total_correction_us>)
42005c1a:	0ba8      	l32i.n	a10, a11, 0
42005c1c:	1bb8      	l32i.n	a11, a11, 4
42005c1e:	047bd6        	bgez	a11, 42005c69 <adjust_boot_time+0xcd>
                if ((s_adjtime_total_correction_us + correction) >= 0) {
42005c21:	eb9a      	add.n	a14, a11, a9
42005c23:	809af0        	add	a9, a10, a15
42005c26:	02b967        	bgeu	a9, a6, 42005c2c <adjust_boot_time+0x90>
42005c29:	01cee2        	addi	a14, a14, 1
42005c2c:	019e96        	bltz	a14, 42005c49 <adjust_boot_time+0xad>
                    boot_time = boot_time + s_adjtime_total_correction_us;
42005c2f:	a2aa      	add.n	a10, a2, a10
42005c31:	628a20        	lsi	f2, a10, 0x188
42005c34:	b3ba      	add.n	a11, a3, a11
42005c36:	0a2d      	mov.n	a2, a10
42005c38:	38ba      	add.n	a3, a8, a11
                    s_adjtime_start_us = 0;
42005c3a:	eabf81        	l32r	a8, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005c3d:	090c      	movi.n	a9, 0
42005c3f:	0899      	s32i.n	a9, a8, 0
42005c41:	1899      	s32i.n	a9, a8, 4
42005c43:	001886        	j	42005ca9 <adjust_boot_time+0x10d>
42005c46:	000000        	ill
                    s_adjtime_total_correction_us += correction;
42005c49:	eabca1        	l32r	a10, 4200073c <_stext+0x71c> (3fc94fd0 <s_adjtime_total_correction_us>)
42005c4c:	0a99      	s32i.n	a9, a10, 0
42005c4e:	1ae9      	s32i.n	a14, a10, 4
                    boot_time -= correction;
42005c50:	c09c70        	sub	a9, a12, a7
42005c53:	01b8d7        	bgeu	a8, a13, 42005c58 <adjust_boot_time+0xbc>
42005c56:	990b      	addi.n	a9, a9, -1
42005c58:	c088d0        	sub	a8, a8, a13
42005c5b:	828a      	add.n	a8, a2, a8
42005c5d:	62a820        	lsi	f2, a8, 0x188
42005c60:	939a      	add.n	a9, a3, a9
42005c62:	082d      	mov.n	a2, a8
42005c64:	3a9a      	add.n	a3, a10, a9
42005c66:	000fc6        	j	42005ca9 <adjust_boot_time+0x10d>
                if ((s_adjtime_total_correction_us - correction) <= 0) {
42005c69:	c09b90        	sub	a9, a11, a9
42005c6c:	01ba67        	bgeu	a10, a6, 42005c71 <adjust_boot_time+0xd5>
42005c6f:	990b      	addi.n	a9, a9, -1
42005c71:	c08af0        	sub	a8, a10, a15
42005c74:	1c19e6        	bgei	a9, 1, 42005c94 <adjust_boot_time+0xf8>
42005c77:	19cc      	bnez.n	a9, 42005c7c <adjust_boot_time+0xe0>
42005c79:	017856        	bnez	a8, 42005c94 <adjust_boot_time+0xf8>
                    boot_time = boot_time + s_adjtime_total_correction_us;
42005c7c:	a2aa      	add.n	a10, a2, a10
42005c7e:	628a20        	lsi	f2, a10, 0x188
42005c81:	b3ba      	add.n	a11, a3, a11
42005c83:	0a2d      	mov.n	a2, a10
42005c85:	38ba      	add.n	a3, a8, a11
                    s_adjtime_start_us = 0;
42005c87:	eaac81        	l32r	a8, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005c8a:	090c      	movi.n	a9, 0
42005c8c:	0899      	s32i.n	a9, a8, 0
42005c8e:	1899      	s32i.n	a9, a8, 4
42005c90:	000546        	j	42005ca9 <adjust_boot_time+0x10d>
42005c93:	aaa100        	floor.s	a10, f1, 0
                    s_adjtime_total_correction_us -= correction;
42005c96:	82ea      	add.n	a8, a2, a14
42005c98:	006a      	add.n	a0, a0, a6
42005c9a:	016a92        	s32i	a9, a10, 4
                    boot_time += correction;
42005c9d:	8092f0        	add	a9, a2, a15
42005ca0:	62a920        	lsi	f2, a9, 0x188
42005ca3:	83ea      	add.n	a8, a3, a14
42005ca5:	092d      	mov.n	a2, a9
42005ca7:	3a8a      	add.n	a3, a10, a8
            esp_time_impl_set_boot_time(boot_time);
42005ca9:	02ad      	mov.n	a10, a2
42005cab:	03bd      	mov.n	a11, a3
42005cad:	000da5        	call8	42005d88 <esp_time_impl_set_boot_time>
}
42005cb0:	f01d      	retw.n
	...

42005cb4 <get_adjusted_boot_time>:
{
42005cb4:	004136        	entry	a1, 32
    _lock_acquire(&s_time_lock);
42005cb7:	eaa2a1        	l32r	a10, 42000740 <_stext+0x720> (3fc94fcc <s_time_lock>)
42005cba:	eaa281        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005cbd:	0008e0        	callx8	a8
    uint64_t adjust_time = adjust_boot_time();
42005cc0:	ffeda5        	call8	42005b9c <adjust_boot_time>
42005cc3:	0a2d      	mov.n	a2, a10
42005cc5:	0b3d      	mov.n	a3, a11
    _lock_release(&s_time_lock);
42005cc7:	ea9ea1        	l32r	a10, 42000740 <_stext+0x720> (3fc94fcc <s_time_lock>)
42005cca:	ea9f81        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005ccd:	0008e0        	callx8	a8
}
42005cd0:	f01d      	retw.n
	...

42005cd4 <adjtime_corr_stop>:
{
42005cd4:	004136        	entry	a1, 32
    _lock_acquire(&s_time_lock);
42005cd7:	ea9aa1        	l32r	a10, 42000740 <_stext+0x720> (3fc94fcc <s_time_lock>)
42005cda:	ea9a81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005cdd:	0008e0        	callx8	a8
    if (s_adjtime_start_us != 0) {
42005ce0:	ea9681        	l32r	a8, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005ce3:	0898      	l32i.n	a9, a8, 0
42005ce5:	0128a2        	l32i	a10, a8, 4
42005ce8:	2089a0        	or	a8, a9, a10
42005ceb:	a88c      	beqz.n	a8, 42005cf9 <adjtime_corr_stop+0x25>
        adjust_boot_time();
42005ced:	ffeae5        	call8	42005b9c <adjust_boot_time>
        s_adjtime_start_us = 0;
42005cf0:	ea9281        	l32r	a8, 42000738 <_stext+0x718> (3fc94fd8 <s_adjtime_start_us>)
42005cf3:	090c      	movi.n	a9, 0
42005cf5:	0899      	s32i.n	a9, a8, 0
42005cf7:	1899      	s32i.n	a9, a8, 4
    _lock_release(&s_time_lock);
42005cf9:	ea91a1        	l32r	a10, 42000740 <_stext+0x720> (3fc94fcc <s_time_lock>)
42005cfc:	ea9381        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005cff:	0008e0        	callx8	a8
}
42005d02:	f01d      	retw.n

42005d04 <settimeofday>:

WEAK_UNLESS_TIMEFUNC_IMPL int settimeofday(const struct timeval *tv, const struct timezone *tz)
{
42005d04:	004136        	entry	a1, 32
    (void) tz;
#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
42005d07:	32bc      	beqz.n	a2, 42005d3e <settimeofday+0x3a>
        adjtime_corr_stop();
42005d09:	fffca5        	call8	42005cd4 <adjtime_corr_stop>
        uint64_t now = ((uint64_t) tv->tv_sec) * 1000000LL + tv->tv_usec;
42005d0c:	0288      	l32i.n	a8, a2, 0
42005d0e:	1278      	l32i.n	a7, a2, 4
42005d10:	ea8f91        	l32r	a9, 4200074c <_stext+0x72c> (f4240 <UserFrameTotalSize+0xf4140>)
42005d13:	827970        	mull	a7, a9, a7
42005d16:	82a980        	mull	a10, a9, a8
42005d19:	a28890        	muluh	a8, a8, a9
42005d1c:	778a      	add.n	a7, a7, a8
42005d1e:	2288      	l32i.n	a8, a2, 8
42005d20:	319f80        	srai	a9, a8, 31
42005d23:	779a      	add.n	a7, a7, a9
42005d25:	2a8a      	add.n	a2, a10, a8
42005d27:	01b287        	bgeu	a2, a8, 42005d2c <settimeofday+0x28>
42005d2a:	771b      	addi.n	a7, a7, 1
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
42005d2c:	0003e5        	call8	42005d6c <esp_time_impl_get_time_since_boot>
        esp_time_impl_set_boot_time(now - since_boot);
42005d2f:	c0b7b0        	sub	a11, a7, a11
42005d32:	02b2a7        	bgeu	a2, a10, 42005d38 <settimeofday+0x34>
42005d35:	ffcbb2        	addi	a11, a11, -1
42005d38:	c0a2a0        	sub	a10, a2, a10
42005d3b:	0004e5        	call8	42005d88 <esp_time_impl_set_boot_time>
    return 0;
#else
    errno = ENOSYS;
    return -1;
#endif
}
42005d3e:	020c      	movi.n	a2, 0
42005d40:	f01d      	retw.n
	...

42005d44 <esp_libc_time_init>:
}

/* TODO IDF-11226 */
void esp_newlib_time_init(void) __attribute__((alias("esp_libc_time_init")));
void esp_libc_time_init(void)
{
42005d44:	004136        	entry	a1, 32
    esp_set_time_from_rtc();
42005d47:	000925        	call8	42005dd8 <esp_set_time_from_rtc>
}
42005d4a:	f01d      	retw.n

42005d4c <fstat>:
{
    abort();
}

int fstat(int fd, struct stat *st)
{
42005d4c:	004136        	entry	a1, 32
    return _fstat_r(__getreent(), fd, st);
42005d4f:	ea8081        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
42005d52:	0008e0        	callx8	a8
42005d55:	03cd      	mov.n	a12, a3
42005d57:	02bd      	mov.n	a11, a2
42005d59:	015965        	call8	420072f0 <_fstat_r>
}
42005d5c:	0a2d      	mov.n	a2, a10
42005d5e:	f01d      	retw.n

42005d60 <_raise_r>:
    __errno_r(r) = ENOSYS;
    return -1;
}

static int syscall_not_implemented_aborts(void)
{
42005d60:	004136        	entry	a1, 32
    abort();
42005d63:	e8e481        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005d66:	0008e0        	callx8	a8
42005d69:	000000        	ill

42005d6c <esp_time_impl_get_time_since_boot>:

static _lock_t s_boot_time_lock;

#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) || defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
uint64_t esp_time_impl_get_time_since_boot(void)
{
42005d6c:	004136        	entry	a1, 32
    uint64_t microseconds = 0;

#ifdef CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    microseconds = s_microseconds_offset + esp_system_get_time();
42005d6f:	ea7a81        	l32r	a8, 42000758 <_stext+0x738> (40376c1c <esp_system_get_time>)
42005d72:	0008e0        	callx8	a8
42005d75:	ea7791        	l32r	a9, 42000754 <_stext+0x734> (3fc94fe8 <s_microseconds_offset>)
42005d78:	0988      	l32i.n	a8, a9, 0
42005d7a:	1998      	l32i.n	a9, a9, 4
42005d7c:	3b9a      	add.n	a3, a11, a9
42005d7e:	2a8a      	add.n	a2, a10, a8
42005d80:	01b287        	bgeu	a2, a8, 42005d85 <esp_time_impl_get_time_since_boot+0x19>
42005d83:	331b      	addi.n	a3, a3, 1
#endif // CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
#elif defined(CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER)
    microseconds = esp_rtc_get_time_us();
#endif // CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
    return microseconds;
}
42005d85:	f01d      	retw.n
	...

42005d88 <esp_time_impl_set_boot_time>:
}

#endif // defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) || defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )

void esp_time_impl_set_boot_time(uint64_t time_us)
{
42005d88:	004136        	entry	a1, 32
    _lock_acquire(&s_boot_time_lock);
42005d8b:	ea74a1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94fe0 <s_boot_time_lock>)
42005d8e:	ea6d81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005d91:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    REG_WRITE(RTC_BOOT_TIME_LOW_REG, (uint32_t)(time_us & 0xffffffff));
42005d94:	ea7381        	l32r	a8, 42000760 <_stext+0x740> (60008058 <RTCCNTL+0x58>)
42005d97:	0020c0        	memw
42005d9a:	0829      	s32i.n	a2, a8, 0
    REG_WRITE(RTC_BOOT_TIME_HIGH_REG, (uint32_t)(time_us >> 32));
42005d9c:	ea7281        	l32r	a8, 42000764 <_stext+0x744> (6000805c <RTCCNTL+0x5c>)
42005d9f:	0020c0        	memw
42005da2:	0839      	s32i.n	a3, a8, 0
#else
    s_boot_time = time_us;
#endif
    _lock_release(&s_boot_time_lock);
42005da4:	ea6ea1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94fe0 <s_boot_time_lock>)
42005da7:	ea6881        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005daa:	0008e0        	callx8	a8
}
42005dad:	f01d      	retw.n
	...

42005db0 <esp_time_impl_get_boot_time>:

uint64_t esp_time_impl_get_boot_time(void)
{
42005db0:	004136        	entry	a1, 32
    uint64_t result;
    _lock_acquire(&s_boot_time_lock);
42005db3:	ea6aa1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94fe0 <s_boot_time_lock>)
42005db6:	ea6381        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005db9:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    result = ((uint64_t) REG_READ(RTC_BOOT_TIME_LOW_REG)) + (((uint64_t) REG_READ(RTC_BOOT_TIME_HIGH_REG)) << 32);
42005dbc:	ea6981        	l32r	a8, 42000760 <_stext+0x740> (60008058 <RTCCNTL+0x58>)
42005dbf:	0020c0        	memw
42005dc2:	0828      	l32i.n	a2, a8, 0
42005dc4:	ea6881        	l32r	a8, 42000764 <_stext+0x744> (6000805c <RTCCNTL+0x5c>)
42005dc7:	0020c0        	memw
42005dca:	0838      	l32i.n	a3, a8, 0
#else
    result = s_boot_time;
#endif
    _lock_release(&s_boot_time_lock);
42005dcc:	ea64a1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94fe0 <s_boot_time_lock>)
42005dcf:	ea5e81        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005dd2:	0008e0        	callx8	a8
    return result;
}
42005dd5:	f01d      	retw.n
	...

42005dd8 <esp_set_time_from_rtc>:

void esp_set_time_from_rtc(void)
{
42005dd8:	004136        	entry	a1, 32
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    // initialize time from RTC clock
    s_microseconds_offset = esp_rtc_get_time_us() - esp_system_get_time();
42005ddb:	fd4125        	call8	420031ec <esp_rtc_get_time_us>
42005dde:	0a6d      	mov.n	a6, a10
42005de0:	0b7d      	mov.n	a7, a11
42005de2:	ea5d81        	l32r	a8, 42000758 <_stext+0x738> (40376c1c <esp_system_get_time>)
42005de5:	0008e0        	callx8	a8
42005de8:	c0b7b0        	sub	a11, a7, a11
42005deb:	01b6a7        	bgeu	a6, a10, 42005df0 <esp_set_time_from_rtc+0x18>
42005dee:	bb0b      	addi.n	a11, a11, -1
42005df0:	c066a0        	sub	a6, a6, a10
42005df3:	ea5881        	l32r	a8, 42000754 <_stext+0x734> (3fc94fe8 <s_microseconds_offset>)
42005df6:	0869      	s32i.n	a6, a8, 0
42005df8:	18b9      	s32i.n	a11, a8, 4
#endif // CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER && CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
}
42005dfa:	f01d      	retw.n

42005dfc <esp_sync_timekeeping_timers>:

void esp_sync_timekeeping_timers(void)
{
42005dfc:	006136        	entry	a1, 48
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    struct timeval tv;
    gettimeofday(&tv, NULL);
42005dff:	00a0b2        	movi	a11, 0
42005e02:	20a110        	or	a10, a1, a1
42005e05:	0662a5        	call8	4200c430 <gettimeofday>
    settimeofday(&tv, NULL);
42005e08:	0b0c      	movi.n	a11, 0
42005e0a:	01ad      	mov.n	a10, a1
42005e0c:	ffef65        	call8	42005d04 <settimeofday>
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
42005e0f:	fd3de5        	call8	420031ec <esp_rtc_get_time_us>
42005e12:	0a7d      	mov.n	a7, a10
42005e14:	0b6d      	mov.n	a6, a11
42005e16:	ea5081        	l32r	a8, 42000758 <_stext+0x738> (40376c1c <esp_system_get_time>)
42005e19:	0008e0        	callx8	a8
42005e1c:	c066b0        	sub	a6, a6, a11
42005e1f:	01b7a7        	bgeu	a7, a10, 42005e24 <esp_sync_timekeeping_timers+0x28>
42005e22:	660b      	addi.n	a6, a6, -1
42005e24:	c077a0        	sub	a7, a7, a10
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
42005e27:	fff8a5        	call8	42005db0 <esp_time_impl_get_boot_time>
42005e2a:	ea4a91        	l32r	a9, 42000754 <_stext+0x734> (3fc94fe8 <s_microseconds_offset>)
42005e2d:	002982        	l32i	a8, a9, 0
42005e30:	012992        	l32i	a9, a9, 4
42005e33:	c09960        	sub	a9, a9, a6
42005e36:	02b877        	bgeu	a8, a7, 42005e3c <esp_sync_timekeeping_timers+0x40>
42005e39:	ffc992        	addi	a9, a9, -1
42005e3c:	c08870        	sub	a8, a8, a7
42005e3f:	bb9a      	add.n	a11, a11, a9
42005e41:	aa8a      	add.n	a10, a10, a8
42005e43:	01ba87        	bgeu	a10, a8, 42005e48 <esp_sync_timekeeping_timers+0x4c>
42005e46:	bb1b      	addi.n	a11, a11, 1
42005e48:	fff3e5        	call8	42005d88 <esp_time_impl_set_boot_time>
#endif
}
42005e4b:	f01d      	retw.n
42005e4d:	000000        	ill

42005e50 <esp_cleanup_r>:
{
    _raise_r(rptr, 0);
}

static void esp_cleanup_r(struct _reent *rptr)
{
42005e50:	004136        	entry	a1, 32
    if (_REENT_STDIN(rptr) != _REENT_STDIN(_GLOBAL_REENT)) {
42005e53:	12b8      	l32i.n	a11, a2, 4
42005e55:	ea4481        	l32r	a8, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
42005e58:	1888      	l32i.n	a8, a8, 4
42005e5a:	041b87        	beq	a11, a8, 42005e62 <esp_cleanup_r+0x12>
        _fclose_r(rptr, _REENT_STDIN(rptr));
42005e5d:	02ad      	mov.n	a10, a2
42005e5f:	056de5        	call8	4200b53c <_fclose_r>
    }

    if (_REENT_STDOUT(rptr) != _REENT_STDOUT(_GLOBAL_REENT)) {
42005e62:	0222b2        	l32i	a11, a2, 8
42005e65:	ea4081        	l32r	a8, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
42005e68:	022882        	l32i	a8, a8, 8
42005e6b:	051b87        	beq	a11, a8, 42005e74 <esp_cleanup_r+0x24>
        _fclose_r(rptr, _REENT_STDOUT(rptr));
42005e6e:	20a220        	or	a10, a2, a2
42005e71:	056ca5        	call8	4200b53c <_fclose_r>
    }

    if (_REENT_STDERR(rptr) != _REENT_STDERR(_GLOBAL_REENT)) {
42005e74:	0322b2        	l32i	a11, a2, 12
42005e77:	ea3c81        	l32r	a8, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
42005e7a:	032882        	l32i	a8, a8, 12
42005e7d:	051b87        	beq	a11, a8, 42005e86 <esp_cleanup_r+0x36>
        _fclose_r(rptr, _REENT_STDERR(rptr));
42005e80:	20a220        	or	a10, a2, a2
42005e83:	056ba5        	call8	4200b53c <_fclose_r>
    }
}
42005e86:	f01d      	retw.n

42005e88 <raise_r_stub>:
{
42005e88:	004136        	entry	a1, 32
42005e8b:	20a220        	or	a10, a2, a2
    _raise_r(rptr, 0);
42005e8e:	00a0b2        	movi	a11, 0
42005e91:	ffece5        	call8	42005d60 <_raise_r>
}
42005e94:	000090        	retw
	...

42005e98 <esp_libc_init>:
};

/* TODO IDF-11226 */
void esp_newlib_init(void) __attribute__((alias("esp_libc_init")));
void esp_libc_init(void)
{
42005e98:	004136        	entry	a1, 32
#if CONFIG_IDF_TARGET_ESP32
    syscall_table_ptr_pro = syscall_table_ptr_app = &s_stub_table;
#elif CONFIG_IDF_TARGET_ESP32S2
    syscall_table_ptr_pro = &s_stub_table;
#else
    syscall_table_ptr = &s_stub_table;
42005e9b:	ea3481        	l32r	a8, 4200076c <_stext+0x74c> (3fceffd4 <syscall_table_ptr>)
42005e9e:	ea3491        	l32r	a9, 42000770 <_stext+0x750> (3fc92108 <s_stub_table>)
42005ea1:	0899      	s32i.n	a9, a8, 0
#endif

    memset(&__sglue, 0, sizeof(__sglue));
42005ea3:	cc0c      	movi.n	a12, 12
42005ea5:	0b0c      	movi.n	a11, 0
42005ea7:	ea33a1        	l32r	a10, 42000774 <_stext+0x754> (3fc927b8 <__sglue>)
42005eaa:	e91581        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42005ead:	0008e0        	callx8	a8
    _global_impure_ptr = _GLOBAL_REENT;
42005eb0:	ea2e81        	l32r	a8, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
42005eb3:	ea3191        	l32r	a9, 42000778 <_stext+0x758> (3fceffd0 <_global_impure_ptr>)
42005eb6:	0989      	s32i.n	a8, a9, 0

    /* Ensure that the initialization of sfp is prevented until esp_newlib_init_global_stdio() is explicitly invoked. */
    _GLOBAL_REENT->__cleanup = esp_cleanup_r;
42005eb8:	ea3191        	l32r	a9, 4200077c <_stext+0x75c> (42005e50 <esp_cleanup_r>)
42005ebb:	a899      	s32i.n	a9, a8, 40
    _REENT_SDIDINIT(_GLOBAL_REENT) = 1;
42005ebd:	190c      	movi.n	a9, 1
42005ebf:	6899      	s32i.n	a9, a8, 24

    environ = malloc(sizeof(char*));
42005ec1:	4a0c      	movi.n	a10, 4
42005ec3:	ea3081        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
42005ec6:	0008e0        	callx8	a8
42005ec9:	ea2d81        	l32r	a8, 42000780 <_stext+0x760> (3fc927b4 <environ>)
42005ecc:	08a9      	s32i.n	a10, a8, 0
    if (environ == 0) {
42005ece:	4acc      	bnez.n	a10, 42005ed6 <esp_libc_init+0x3e>
        // if allocation fails this early in startup process, there's nothing else other than to panic.
        abort();
42005ed0:	e88981        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42005ed3:	0008e0        	callx8	a8
    }
    environ[0] = NULL;
42005ed6:	00a082        	movi	a8, 0
42005ed9:	006a82        	s32i	a8, a10, 0

    esp_libc_locks_init();
42005edc:	ffc6e5        	call8	42005b4c <esp_libc_locks_init>
}
42005edf:	000090        	retw
	...

42005ee4 <esp_libc_init_global_stdio>:
 * Called from startup code and FreeRTOS, not intended to be called from
 * application code.
 */
#if CONFIG_VFS_SUPPORT_IO
void esp_libc_init_global_stdio(const char *stdio_dev)
{
42005ee4:	004136        	entry	a1, 32
    _REENT_STDIN(_GLOBAL_REENT) = fopen(stdio_dev, "r");
42005ee7:	ea28b1        	l32r	a11, 42000788 <_stext+0x768> (3c020d4c <_flash_rodata_start+0xc2c>)
42005eea:	02ad      	mov.n	a10, a2
42005eec:	05bce5        	call8	4200babc <fopen>
42005eef:	ea1e71        	l32r	a7, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
42005ef2:	17a9      	s32i.n	a10, a7, 4
    _REENT_STDOUT(_GLOBAL_REENT) = fopen(stdio_dev, "w");
42005ef4:	ea26b1        	l32r	a11, 4200078c <_stext+0x76c> (3c024ea0 <_flash_rodata_start+0x4d80>)
42005ef7:	02ad      	mov.n	a10, a2
42005ef9:	05bc25        	call8	4200babc <fopen>
42005efc:	27a9      	s32i.n	a10, a7, 8
    _REENT_STDERR(_GLOBAL_REENT) = fopen(stdio_dev, "w");
42005efe:	ea23b1        	l32r	a11, 4200078c <_stext+0x76c> (3c024ea0 <_flash_rodata_start+0x4d80>)
42005f01:	20a220        	or	a10, a2, a2
42005f04:	05bb65        	call8	4200babc <fopen>
42005f07:	37a9      	s32i.n	a10, a7, 12
    - Thus, we call the toolchain version of __swsetup_r() now (before any printf calls are made) to setup all of the
      file pointers. Thus, the ROM newlib code will never call the ROM version of __swsetup_r().
    - See IDFGH-7728 for more details
    */
    extern int __swsetup_r(struct _reent *, FILE *);
    __swsetup_r(_GLOBAL_REENT, _REENT_STDIN(_GLOBAL_REENT));
42005f09:	17b8      	l32i.n	a11, a7, 4
42005f0b:	07ad      	mov.n	a10, a7
42005f0d:	060925        	call8	4200bfa0 <__swsetup_r>
    __swsetup_r(_GLOBAL_REENT, _REENT_STDOUT(_GLOBAL_REENT));
42005f10:	27b8      	l32i.n	a11, a7, 8
42005f12:	07ad      	mov.n	a10, a7
42005f14:	0608a5        	call8	4200bfa0 <__swsetup_r>
    __swsetup_r(_GLOBAL_REENT, _REENT_STDERR(_GLOBAL_REENT));
42005f17:	37b8      	l32i.n	a11, a7, 12
42005f19:	07ad      	mov.n	a10, a7
42005f1b:	060865        	call8	4200bfa0 <__swsetup_r>
#endif /* ESP_ROM_NEEDS_SWSETUP_WORKAROUND */
}
42005f1e:	f01d      	retw.n

42005f20 <pthread_mutex_lock_internal>:

    return 0;
}

static int pthread_mutex_lock_internal(esp_pthread_mutex_t *mux, TickType_t tmo)
{
42005f20:	004136        	entry	a1, 32
    if (!mux) {
42005f23:	045216        	beqz	a2, 42005f6c <pthread_mutex_lock_internal+0x4c>
        return EINVAL;
    }

    if ((mux->type == PTHREAD_MUTEX_ERRORCHECK) &&
42005f26:	012282        	l32i	a8, a2, 4
42005f29:	132866        	bnei	a8, 2, 42005f40 <pthread_mutex_lock_internal+0x20>
            (xSemaphoreGetMutexHolder(mux->sem) == xTaskGetCurrentTaskHandle())) {
42005f2c:	0022a2        	l32i	a10, a2, 0
42005f2f:	ea1881        	l32r	a8, 42000790 <_stext+0x770> (40379aa0 <xQueueGetMutexHolder>)
42005f32:	0008e0        	callx8	a8
42005f35:	0a7d      	mov.n	a7, a10
42005f37:	ea1781        	l32r	a8, 42000794 <_stext+0x774> (4037b890 <xTaskGetCurrentTaskHandle>)
42005f3a:	0008e0        	callx8	a8
    if ((mux->type == PTHREAD_MUTEX_ERRORCHECK) &&
42005f3d:	3017a7        	beq	a7, a10, 42005f71 <pthread_mutex_lock_internal+0x51>
        return EDEADLK;
    }

    if (mux->type == PTHREAD_MUTEX_RECURSIVE) {
42005f40:	1288      	l32i.n	a8, a2, 4
42005f42:	141866        	bnei	a8, 1, 42005f5a <pthread_mutex_lock_internal+0x3a>
        if (xSemaphoreTakeRecursive(mux->sem, tmo) != pdTRUE) {
42005f45:	03bd      	mov.n	a11, a3
42005f47:	0022a2        	l32i	a10, a2, 0
42005f4a:	ea1381        	l32r	a8, 42000798 <_stext+0x778> (40379e88 <xQueueTakeMutexRecursive>)
42005f4d:	0008e0        	callx8	a8
42005f50:	221a66        	bnei	a10, 1, 42005f76 <pthread_mutex_lock_internal+0x56>
        if (xSemaphoreTake(mux->sem, tmo) != pdTRUE) {
            return EBUSY;
        }
    }

    return 0;
42005f53:	020c      	movi.n	a2, 0
42005f55:	000906        	j	42005f7d <pthread_mutex_lock_internal+0x5d>
42005f58:	bd0000        	lsi	f0, a0, 0x2f4
        if (xSemaphoreTake(mux->sem, tmo) != pdTRUE) {
42005f5b:	02a803        	lsi	f0, a8, 8
42005f5e:	ea0f81        	l32r	a8, 4200079c <_stext+0x77c> (40379d80 <xQueueSemaphoreTake>)
42005f61:	0008e0        	callx8	a8
42005f64:	131a66        	bnei	a10, 1, 42005f7b <pthread_mutex_lock_internal+0x5b>
    return 0;
42005f67:	020c      	movi.n	a2, 0
42005f69:	000406        	j	42005f7d <pthread_mutex_lock_internal+0x5d>
        return EINVAL;
42005f6c:	621c      	movi.n	a2, 22
42005f6e:	0002c6        	j	42005f7d <pthread_mutex_lock_internal+0x5d>
        return EDEADLK;
42005f71:	d22c      	movi.n	a2, 45
42005f73:	000186        	j	42005f7d <pthread_mutex_lock_internal+0x5d>
            return EBUSY;
42005f76:	021c      	movi.n	a2, 16
42005f78:	000046        	j	42005f7d <pthread_mutex_lock_internal+0x5d>
            return EBUSY;
42005f7b:	021c      	movi.n	a2, 16
}
42005f7d:	f01d      	retw.n
	...

42005f80 <pthread_mutex_init>:
{
42005f80:	004136        	entry	a1, 32
42005f83:	027d      	mov.n	a7, a2
    if (!mutex) {
42005f85:	057216        	beqz	a2, 42005fe0 <pthread_mutex_init+0x60>
    if (attr) {
42005f88:	239c      	beqz.n	a3, 42005f9e <pthread_mutex_init+0x1e>
        if (!attr->is_initialized) {
42005f8a:	0388      	l32i.n	a8, a3, 0
42005f8c:	055816        	beqz	a8, 42005fe5 <pthread_mutex_init+0x65>
        int res = mutexattr_check(attr);
42005f8f:	03ad      	mov.n	a10, a3
42005f91:	0f94a5        	call8	420158dc <mutexattr_check>
42005f94:	0a2d      	mov.n	a2, a10
        if (res) {
42005f96:	052a56        	bnez	a10, 42005fec <pthread_mutex_init+0x6c>
        type = attr->type;
42005f99:	1328      	l32i.n	a2, a3, 4
42005f9b:	000046        	j	42005fa0 <pthread_mutex_init+0x20>
    int type = PTHREAD_MUTEX_NORMAL;
42005f9e:	020c      	movi.n	a2, 0
    esp_pthread_mutex_t *mux = (esp_pthread_mutex_t *)malloc(sizeof(esp_pthread_mutex_t));
42005fa0:	8a0c      	movi.n	a10, 8
42005fa2:	e9f881        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
42005fa5:	0008e0        	callx8	a8
42005fa8:	0a3d      	mov.n	a3, a10
    if (!mux) {
42005faa:	cabc      	beqz.n	a10, 42005fea <pthread_mutex_init+0x6a>
    mux->type = type;
42005fac:	1a29      	s32i.n	a2, a10, 4
    if (mux->type == PTHREAD_MUTEX_RECURSIVE) {
42005fae:	0c1266        	bnei	a2, 1, 42005fbe <pthread_mutex_init+0x3e>
        mux->sem = xSemaphoreCreateRecursiveMutex();
42005fb1:	4a0c      	movi.n	a10, 4
42005fb3:	e9fb81        	l32r	a8, 420007a0 <_stext+0x780> (40379c50 <xQueueCreateMutex>)
42005fb6:	0008e0        	callx8	a8
42005fb9:	03a9      	s32i.n	a10, a3, 0
42005fbb:	000246        	j	42005fc8 <pthread_mutex_init+0x48>
        mux->sem = xSemaphoreCreateMutex();
42005fbe:	1a0c      	movi.n	a10, 1
42005fc0:	e9f881        	l32r	a8, 420007a0 <_stext+0x780> (40379c50 <xQueueCreateMutex>)
42005fc3:	0008e0        	callx8	a8
42005fc6:	03a9      	s32i.n	a10, a3, 0
    if (!mux->sem) {
42005fc8:	0388      	l32i.n	a8, a3, 0
42005fca:	b8cc      	bnez.n	a8, 42005fd9 <pthread_mutex_init+0x59>
        free(mux);
42005fcc:	03ad      	mov.n	a10, a3
42005fce:	e96681        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42005fd1:	0008e0        	callx8	a8
        return EAGAIN;
42005fd4:	b20c      	movi.n	a2, 11
42005fd6:	000486        	j	42005fec <pthread_mutex_init+0x6c>
    *mutex = (pthread_mutex_t)mux; // pointer value fit into pthread_mutex_t (uint32_t)
42005fd9:	0739      	s32i.n	a3, a7, 0
    return 0;
42005fdb:	020c      	movi.n	a2, 0
42005fdd:	0002c6        	j	42005fec <pthread_mutex_init+0x6c>
        return EINVAL;
42005fe0:	621c      	movi.n	a2, 22
42005fe2:	000186        	j	42005fec <pthread_mutex_init+0x6c>
            return EINVAL;
42005fe5:	621c      	movi.n	a2, 22
42005fe7:	000046        	j	42005fec <pthread_mutex_init+0x6c>
        return ENOMEM;
42005fea:	c20c      	movi.n	a2, 12
}
42005fec:	f01d      	retw.n
	...

42005ff0 <pthread_mutex_init_if_static>:

static int pthread_mutex_init_if_static(pthread_mutex_t *mutex)
{
42005ff0:	004136        	entry	a1, 32
    int res = 0;
    if ((intptr_t) *mutex == PTHREAD_MUTEX_INITIALIZER) {
42005ff3:	0288      	l32i.n	a8, a2, 0
42005ff5:	2a0866        	bnei	a8, -1, 42006023 <pthread_mutex_init_if_static+0x33>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
42005ff8:	ffafb2        	movi	a11, -1
42005ffb:	e9eaa1        	l32r	a10, 420007a4 <_stext+0x784> (3fc921a4 <pthread_lazy_init_lock>)
42005ffe:	e90481        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42006001:	0008e0        	callx8	a8
        portENTER_CRITICAL(&pthread_lazy_init_lock);
        if ((intptr_t) *mutex == PTHREAD_MUTEX_INITIALIZER) {
42006004:	0288      	l32i.n	a8, a2, 0
42006006:	0b0866        	bnei	a8, -1, 42006015 <pthread_mutex_init_if_static+0x25>
            res = pthread_mutex_init(mutex, NULL);
42006009:	0b0c      	movi.n	a11, 0
4200600b:	02ad      	mov.n	a10, a2
4200600d:	fff725        	call8	42005f80 <pthread_mutex_init>
42006010:	0a2d      	mov.n	a2, a10
42006012:	000046        	j	42006017 <pthread_mutex_init_if_static+0x27>
    int res = 0;
42006015:	020c      	movi.n	a2, 0
        }
        portEXIT_CRITICAL(&pthread_lazy_init_lock);
42006017:	e9e3a1        	l32r	a10, 420007a4 <_stext+0x784> (3fc921a4 <pthread_lazy_init_lock>)
4200601a:	e8fe81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200601d:	0008e0        	callx8	a8
42006020:	000046        	j	42006025 <pthread_mutex_init_if_static+0x35>
    int res = 0;
42006023:	020c      	movi.n	a2, 0
    }
    return res;
}
42006025:	f01d      	retw.n
	...

42006028 <pthread_mutex_lock>:

int pthread_mutex_lock(pthread_mutex_t *mutex)
{
42006028:	004136        	entry	a1, 32
4200602b:	207220        	or	a7, a2, a2
    if (!mutex) {
4200602e:	016216        	beqz	a2, 42006048 <pthread_mutex_lock+0x20>
        return EINVAL;
    }
    int res = pthread_mutex_init_if_static(mutex);
42006031:	20a220        	or	a10, a2, a2
42006034:	fffba5        	call8	42005ff0 <pthread_mutex_init_if_static>
42006037:	0a2d      	mov.n	a2, a10
    if (res != 0) {
42006039:	dacc      	bnez.n	a10, 4200604a <pthread_mutex_lock+0x22>
        return res;
    }
    return pthread_mutex_lock_internal((esp_pthread_mutex_t *)*mutex, portMAX_DELAY);
4200603b:	fb7c      	movi.n	a11, -1
4200603d:	07a8      	l32i.n	a10, a7, 0
4200603f:	ffee25        	call8	42005f20 <pthread_mutex_lock_internal>
42006042:	0a2d      	mov.n	a2, a10
42006044:	000086        	j	4200604a <pthread_mutex_lock+0x22>
42006047:	621c00        	lsi	f0, a12, 0x188
}
4200604a:	f01d      	retw.n

4200604c <pthread_mutex_unlock>:
    }
    return pthread_mutex_lock_internal((esp_pthread_mutex_t *)*mutex, 0);
}

int pthread_mutex_unlock(pthread_mutex_t *mutex)
{
4200604c:	004136        	entry	a1, 32
    esp_pthread_mutex_t *mux;

    if (!mutex) {
4200604f:	052216        	beqz	a2, 420060a5 <pthread_mutex_unlock+0x59>
        return EINVAL;
    }
    mux = (esp_pthread_mutex_t *)*mutex;
42006052:	0228      	l32i.n	a2, a2, 0
    if (!mux) {
42006054:	052216        	beqz	a2, 420060aa <pthread_mutex_unlock+0x5e>
        return EINVAL;
    }

    if (((mux->type == PTHREAD_MUTEX_RECURSIVE) ||
42006057:	1288      	l32i.n	a8, a2, 4
42006059:	880b      	addi.n	a8, a8, -1
4200605b:	1228f6        	bgeui	a8, 2, 42006071 <pthread_mutex_unlock+0x25>
            (mux->type == PTHREAD_MUTEX_ERRORCHECK)) &&
            (xSemaphoreGetMutexHolder(mux->sem) != xTaskGetCurrentTaskHandle())) {
4200605e:	02a8      	l32i.n	a10, a2, 0
42006060:	e9cc81        	l32r	a8, 42000790 <_stext+0x770> (40379aa0 <xQueueGetMutexHolder>)
42006063:	0008e0        	callx8	a8
42006066:	0a7d      	mov.n	a7, a10
42006068:	e9cb81        	l32r	a8, 42000794 <_stext+0x774> (4037b890 <xTaskGetCurrentTaskHandle>)
4200606b:	0008e0        	callx8	a8
            (mux->type == PTHREAD_MUTEX_ERRORCHECK)) &&
4200606e:	3e97a7        	bne	a7, a10, 420060b0 <pthread_mutex_unlock+0x64>
        return EPERM;
    }

    int ret;
    if (mux->type == PTHREAD_MUTEX_RECURSIVE) {
42006071:	1288      	l32i.n	a8, a2, 4
42006073:	0b1866        	bnei	a8, 1, 42006082 <pthread_mutex_unlock+0x36>
        ret = xSemaphoreGiveRecursive(mux->sem);
42006076:	02a8      	l32i.n	a10, a2, 0
42006078:	e9cf81        	l32r	a8, 420007b4 <_stext+0x794> (40379c84 <xQueueGiveMutexRecursive>)
4200607b:	0008e0        	callx8	a8
4200607e:	000386        	j	42006090 <pthread_mutex_unlock+0x44>
42006081:	0d0c00        	lsi	f0, a12, 52
    } else {
        ret = xSemaphoreGive(mux->sem);
42006084:	0dcd      	mov.n	a12, a13
42006086:	0dbd      	mov.n	a11, a13
42006088:	02a8      	l32i.n	a10, a2, 0
4200608a:	e9cb81        	l32r	a8, 420007b8 <_stext+0x798> (40379ad8 <xQueueGenericSend>)
4200608d:	0008e0        	callx8	a8
    }
    if (ret != pdTRUE) {
42006090:	211a26        	beqi	a10, 1, 420060b5 <pthread_mutex_unlock+0x69>
        assert(false && "Failed to unlock mutex!");
42006093:	e9c5d1        	l32r	a13, 420007a8 <_stext+0x788> (3c024efc <_flash_rodata_start+0x4ddc>)
42006096:	e9c5c1        	l32r	a12, 420007ac <_stext+0x78c> (3c02852c <__func__$0>)
42006099:	28a3b2        	movi	a11, 0x328
4200609c:	e9c5a1        	l32r	a10, 420007b0 <_stext+0x790> (3c024ef1 <_flash_rodata_start+0x4dd1>)
4200609f:	e80881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420060a2:	0008e0        	callx8	a8
        return EINVAL;
420060a5:	621c      	movi.n	a2, 22
420060a7:	000306        	j	420060b7 <pthread_mutex_unlock+0x6b>
        return EINVAL;
420060aa:	621c      	movi.n	a2, 22
420060ac:	0001c6        	j	420060b7 <pthread_mutex_unlock+0x6b>
420060af:	120c00        	andbc	b0, b12, b0
        return EPERM;
420060b2:	000046        	j	420060b7 <pthread_mutex_unlock+0x6b>
    }
    return 0;
420060b5:	020c      	movi.n	a2, 0
}
420060b7:	f01d      	retw.n
420060b9:	000000        	ill

420060bc <find_key>:
    portEXIT_CRITICAL(&s_keys_lock);
    return 0;
}

static key_entry_t *find_key(pthread_key_t key)
{
420060bc:	004136        	entry	a1, 32
420060bf:	027d      	mov.n	a7, a2
420060c1:	fb7c      	movi.n	a11, -1
420060c3:	e9bea1        	l32r	a10, 420007bc <_stext+0x79c> (3fc921ac <s_keys_lock>)
420060c6:	e8d281        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420060c9:	0008e0        	callx8	a8
    portENTER_CRITICAL(&s_keys_lock);
    key_entry_t *result = NULL;;
    SLIST_FOREACH(result, &s_keys, next) {
420060cc:	e9bd81        	l32r	a8, 420007c0 <_stext+0x7a0> (3fc94ff0 <s_keys>)
420060cf:	0828      	l32i.n	a2, a8, 0
420060d1:	000206        	j	420060dd <find_key+0x21>
420060d4:	880000        	lsi	f0, a0, 0x220
        if (result->key == key) {
420060d7:	187702        	lsi	f0, a7, 96
420060da:	222804        	lsi	f0, a8, 136
    SLIST_FOREACH(result, &s_keys, next) {
420060dd:	ff5256        	bnez	a2, 420060d6 <find_key+0x1a>
            break;
        }
    }
    portEXIT_CRITICAL(&s_keys_lock);
420060e0:	e9b7a1        	l32r	a10, 420007bc <_stext+0x79c> (3fc921ac <s_keys_lock>)
420060e3:	e8cc81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420060e6:	0008e0        	callx8	a8
    return result;
}
420060e9:	f01d      	retw.n
	...

420060ec <pthread_cleanup_thread_specific_data_callback>:

   - The destructor is always called in the context of the thread itself - which is important if the task then calls
     pthread_getspecific() or pthread_setspecific() to update the state further, as allowed for in the spec.
*/
static void pthread_cleanup_thread_specific_data_callback(int index, void *v_tls)
{
420060ec:	004136        	entry	a1, 32
    values_list_t *tls = (values_list_t *)v_tls;
    assert(tls != NULL);
420060ef:	011356        	bnez	a3, 42006104 <pthread_cleanup_thread_specific_data_callback+0x18>
420060f2:	e9b4d1        	l32r	a13, 420007c4 <_stext+0x7a4> (3c024f20 <_flash_rodata_start+0x4e00>)
420060f5:	e9b4c1        	l32r	a12, 420007c8 <_stext+0x7a8> (3c028544 <__func__$0>)
420060f8:	80a0b2        	movi	a11, 128
420060fb:	e9b4a1        	l32r	a10, 420007cc <_stext+0x7ac> (3c024f45 <_flash_rodata_start+0x4e25>)
420060fe:	e7f081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42006101:	0008e0        	callx8	a8

    /* Walk the list, freeing all entries and calling destructors if they are registered */
    while (1) {
        value_entry_t *entry = SLIST_FIRST(tls);
42006104:	0378      	l32i.n	a7, a3, 0
        if (entry == NULL) {
42006106:	e79c      	beqz.n	a7, 42006128 <pthread_cleanup_thread_specific_data_callback+0x3c>
            break;
        }
        SLIST_REMOVE_HEAD(tls, next);
42006108:	2788      	l32i.n	a8, a7, 8
4200610a:	0389      	s32i.n	a8, a3, 0

        // This is a little slow, walking the linked list of keys once per value,
        // but assumes that the thread's value list will have less entries
        // than the keys list
        key_entry_t *key = find_key(entry->key);
4200610c:	07a8      	l32i.n	a10, a7, 0
4200610e:	fffae5        	call8	420060bc <find_key>
        if (key != NULL && key->destructor != NULL) {
42006111:	7a8c      	beqz.n	a10, 4200611c <pthread_cleanup_thread_specific_data_callback+0x30>
42006113:	1a88      	l32i.n	a8, a10, 4
42006115:	388c      	beqz.n	a8, 4200611c <pthread_cleanup_thread_specific_data_callback+0x30>
            key->destructor(entry->value);
42006117:	17a8      	l32i.n	a10, a7, 4
42006119:	0008e0        	callx8	a8
        }
        free(entry);
4200611c:	07ad      	mov.n	a10, a7
4200611e:	e91281        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006121:	0008e0        	callx8	a8
    while (1) {
42006124:	fff706        	j	42006104 <pthread_cleanup_thread_specific_data_callback+0x18>
42006127:	03ad00        	lsi	f0, a13, 12
    }
    free(tls);
4200612a:	e90f81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200612d:	0008e0        	callx8	a8
}
42006130:	f01d      	retw.n
	...

42006134 <pthread_key_create>:
{
42006134:	004136        	entry	a1, 32
    key_entry_t *new_key = malloc(sizeof(key_entry_t));
42006137:	0ca0a2        	movi	a10, 12
4200613a:	e99281        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200613d:	0008e0        	callx8	a8
42006140:	0a7d      	mov.n	a7, a10
    if (new_key == NULL) {
42006142:	7abc      	beqz.n	a10, 4200617d <pthread_key_create+0x49>
42006144:	ffafb2        	movi	a11, -1
42006147:	e99da1        	l32r	a10, 420007bc <_stext+0x79c> (3fc921ac <s_keys_lock>)
4200614a:	e8b181        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200614d:	0008e0        	callx8	a8
    const key_entry_t *head = SLIST_FIRST(&s_keys);
42006150:	e99c81        	l32r	a8, 420007c0 <_stext+0x7a0> (3fc94ff0 <s_keys>)
42006153:	0888      	l32i.n	a8, a8, 0
    new_key->key = (head == NULL) ? 1 : (head->key + 1);
42006155:	588c      	beqz.n	a8, 4200615e <pthread_key_create+0x2a>
42006157:	0888      	l32i.n	a8, a8, 0
42006159:	881b      	addi.n	a8, a8, 1
4200615b:	000046        	j	42006160 <pthread_key_create+0x2c>
4200615e:	180c      	movi.n	a8, 1
42006160:	0789      	s32i.n	a8, a7, 0
    new_key->destructor = destructor;
42006162:	1739      	s32i.n	a3, a7, 4
    *key = new_key->key;
42006164:	0289      	s32i.n	a8, a2, 0
    SLIST_INSERT_HEAD(&s_keys, new_key, next);
42006166:	e99681        	l32r	a8, 420007c0 <_stext+0x7a0> (3fc94ff0 <s_keys>)
42006169:	0898      	l32i.n	a9, a8, 0
4200616b:	2799      	s32i.n	a9, a7, 8
4200616d:	0879      	s32i.n	a7, a8, 0
    portEXIT_CRITICAL(&s_keys_lock);
4200616f:	e993a1        	l32r	a10, 420007bc <_stext+0x79c> (3fc921ac <s_keys_lock>)
42006172:	e8a881        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42006175:	0008e0        	callx8	a8
    return 0;
42006178:	020c      	movi.n	a2, 0
4200617a:	000046        	j	4200617f <pthread_key_create+0x4b>
        return ENOMEM;
4200617d:	c20c      	movi.n	a2, 12
}
4200617f:	f01d      	retw.n
42006181:	000000        	ill

42006184 <pthread_getspecific>:
    }
    return result;
}

void *pthread_getspecific(pthread_key_t key)
{
42006184:	004136        	entry	a1, 32
    values_list_t *tls = (values_list_t *) pvTaskGetThreadLocalStoragePointer(NULL, PTHREAD_TLS_INDEX);
42006187:	0b0c      	movi.n	a11, 0
42006189:	0bad      	mov.n	a10, a11
4200618b:	e99181        	l32r	a8, 420007d0 <_stext+0x7b0> (4037ba2c <pvTaskGetThreadLocalStoragePointer>)
4200618e:	0008e0        	callx8	a8
    if (tls == NULL) {
42006191:	7a8c      	beqz.n	a10, 4200619c <pthread_getspecific+0x18>
        return NULL;
    }

    value_entry_t *entry = find_value(tls, key);
42006193:	02bd      	mov.n	a11, a2
42006195:	0f76a5        	call8	42015900 <find_value>
    if (entry != NULL) {
42006198:	0a8c      	beqz.n	a10, 4200619c <pthread_getspecific+0x18>
        return entry->value;
4200619a:	1aa8      	l32i.n	a10, a10, 4
    }
    return NULL;
}
4200619c:	0a2d      	mov.n	a2, a10
4200619e:	f01d      	retw.n

420061a0 <pthread_setspecific>:

int pthread_setspecific(pthread_key_t key, const void *value)
{
420061a0:	004136        	entry	a1, 32
    key_entry_t *key_entry = find_key(key);
420061a3:	02ad      	mov.n	a10, a2
420061a5:	fff165        	call8	420060bc <find_key>
    if (key_entry == NULL) {
420061a8:	0a0a16        	beqz	a10, 4200624c <pthread_setspecific+0xac>
        return ENOENT; // this situation is undefined by pthreads standard
    }

    values_list_t *tls = pvTaskGetThreadLocalStoragePointer(NULL, PTHREAD_TLS_INDEX);
420061ab:	0b0c      	movi.n	a11, 0
420061ad:	20abb0        	or	a10, a11, a11
420061b0:	e98881        	l32r	a8, 420007d0 <_stext+0x7b0> (4037ba2c <pvTaskGetThreadLocalStoragePointer>)
420061b3:	0008e0        	callx8	a8
420061b6:	0a6d      	mov.n	a6, a10
    if (tls == NULL) {
420061b8:	cadc      	bnez.n	a10, 420061d8 <pthread_setspecific+0x38>
        tls = calloc(1, sizeof(values_list_t));
420061ba:	4b0c      	movi.n	a11, 4
420061bc:	1a0c      	movi.n	a10, 1
420061be:	e98681        	l32r	a8, 420007d8 <_stext+0x7b8> (4037fea8 <calloc>)
420061c1:	0008e0        	callx8	a8
420061c4:	0a6d      	mov.n	a6, a10
        if (tls == NULL) {
420061c6:	087a16        	beqz	a10, 42006251 <pthread_setspecific+0xb1>
            return ENOMEM;
        }
#if !defined(CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS)
        vTaskSetThreadLocalStoragePointer(NULL, PTHREAD_TLS_INDEX, tls);
#else
        vTaskSetThreadLocalStoragePointerAndDelCallback(NULL,
420061c9:	e982d1        	l32r	a13, 420007d4 <_stext+0x7b4> (420060ec <pthread_cleanup_thread_specific_data_callback>)
420061cc:	0acd      	mov.n	a12, a10
420061ce:	0b0c      	movi.n	a11, 0
420061d0:	0bad      	mov.n	a10, a11
420061d2:	e98281        	l32r	a8, 420007dc <_stext+0x7bc> (4037c824 <vTaskSetThreadLocalStoragePointerAndDelCallback>)
420061d5:	0008e0        	callx8	a8
                                                        tls,
                                                        pthread_cleanup_thread_specific_data_callback);
#endif /* CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS */
    }

    value_entry_t *entry = find_value(tls, key);
420061d8:	20b220        	or	a11, a2, a2
420061db:	20a660        	or	a10, a6, a6
420061de:	0f7225        	call8	42015900 <find_value>
420061e1:	207aa0        	or	a7, a10, a10
    if (entry != NULL) {
420061e4:	eaac      	beqz.n	a10, 42006216 <pthread_setspecific+0x76>
        if (value != NULL) {
420061e6:	638c      	beqz.n	a3, 420061f0 <pthread_setspecific+0x50>
            // cast on next line is necessary as pthreads API uses
            // 'const void *' here but elsewhere uses 'void *'
            entry->value = (void *) value;
420061e8:	1a39      	s32i.n	a3, a10, 4
        } else {
            SLIST_INSERT_AFTER(last_entry, entry, next);
        }
    }

    return 0;
420061ea:	020c      	movi.n	a2, 0
420061ec:	001b46        	j	4200625d <pthread_setspecific+0xbd>
420061ef:	068800        	lsi	f0, a8, 24
            SLIST_REMOVE(tls, entry, value_entry_t_, next);
420061f2:	0798a7        	bne	a8, a10, 420061fd <pthread_setspecific+0x5d>
420061f5:	2888      	l32i.n	a8, a8, 8
420061f7:	0689      	s32i.n	a8, a6, 0
420061f9:	0002c6        	j	42006208 <pthread_setspecific+0x68>
420061fc:	089d00        	lsx	f9, a13, a0
420061ff:	2888      	l32i.n	a8, a8, 8
42006201:	f89877        	bne	a8, a7, 420061fd <pthread_setspecific+0x5d>
42006204:	2888      	l32i.n	a8, a8, 8
42006206:	2989      	s32i.n	a8, a9, 8
            free(entry);
42006208:	07ad      	mov.n	a10, a7
4200620a:	e8d781        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200620d:	0008e0        	callx8	a8
    return 0;
42006210:	020c      	movi.n	a2, 0
42006212:	0011c6        	j	4200625d <pthread_setspecific+0xbd>
42006215:	c3bc00        	movf	a11, a12, b0
        entry = malloc(sizeof(value_entry_t));
42006218:	ca0c      	movi.n	a10, 12
4200621a:	e95a81        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200621d:	0008e0        	callx8	a8
        if (entry == NULL) {
42006220:	7abc      	beqz.n	a10, 4200625b <pthread_setspecific+0xbb>
        entry->key = key;
42006222:	0a29      	s32i.n	a2, a10, 0
        entry->value = (void *) value; // see note above about cast
42006224:	1a39      	s32i.n	a3, a10, 4
        SLIST_FOREACH(it, tls, next) {
42006226:	0698      	l32i.n	a9, a6, 0
42006228:	098d      	mov.n	a8, a9
4200622a:	0000c6        	j	42006231 <pthread_setspecific+0x91>
            last_entry = it;
4200622d:	087d      	mov.n	a7, a8
        SLIST_FOREACH(it, tls, next) {
4200622f:	2888      	l32i.n	a8, a8, 8
42006231:	ff8856        	bnez	a8, 4200622d <pthread_setspecific+0x8d>
        if (last_entry == NULL) {
42006234:	87cc      	bnez.n	a7, 42006240 <pthread_setspecific+0xa0>
            SLIST_INSERT_HEAD(tls, entry, next);
42006236:	2a99      	s32i.n	a9, a10, 8
42006238:	06a9      	s32i.n	a10, a6, 0
    return 0;
4200623a:	020c      	movi.n	a2, 0
4200623c:	000746        	j	4200625d <pthread_setspecific+0xbd>
4200623f:	278800        	lsi	f0, a8, 156
            SLIST_INSERT_AFTER(last_entry, entry, next);
42006242:	2a89      	s32i.n	a8, a10, 8
42006244:	27a9      	s32i.n	a10, a7, 8
    return 0;
42006246:	020c      	movi.n	a2, 0
42006248:	000446        	j	4200625d <pthread_setspecific+0xbd>
4200624b:	220c00        	orb	b0, b12, b0
        return ENOENT; // this situation is undefined by pthreads standard
4200624e:	0002c6        	j	4200625d <pthread_setspecific+0xbd>
            return ENOMEM;
42006251:	c20c      	movi.n	a2, 12
42006253:	000186        	j	4200625d <pthread_setspecific+0xbd>
    return 0;
42006256:	020c      	movi.n	a2, 0
42006258:	000046        	j	4200625d <pthread_setspecific+0xbd>
            return ENOMEM;
4200625b:	c20c      	movi.n	a2, 12
}
4200625d:	f01d      	retw.n
	...

42006260 <esp_timer_early_init>:
#include "esp_private/startup_internal.h"
#include "esp_timer_impl.h"
#include "sdkconfig.h"

esp_err_t esp_timer_early_init(void)
{
42006260:	004136        	entry	a1, 32
    esp_timer_impl_early_init();
42006263:	000765        	call8	420062d8 <esp_timer_impl_early_init>
#if CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
    esp_timer_impl_init_system_time();
42006266:	000165        	call8	4200627c <esp_timer_impl_init_system_time>
#endif
    return ESP_OK;
}
42006269:	00a022        	movi	a2, 0
4200626c:	000090        	retw
	...

42006270 <__esp_system_init_fn_esp_timer_init_nonos>:
 *
 * Another initialization function, esp_timer_init_nonos (which initializes ISR and task),
 * is called only if other code calls the esp_timer API.
 */
ESP_SYSTEM_INIT_FN(esp_timer_init_nonos, CORE, BIT(0), 101)
{
42006270:	004136        	entry	a1, 32
    return esp_timer_early_init();
42006273:	fffee5        	call8	42006260 <esp_timer_early_init>
}
42006276:	0a2d      	mov.n	a2, a10
42006278:	f01d      	retw.n
	...

4200627c <esp_timer_impl_init_system_time>:
{
4200627c:	004136        	entry	a1, 32
    s_correction_us = esp_rtc_get_time_us() - g_startup_time - esp_timer_impl_get_time();
4200627f:	fcf6e5        	call8	420031ec <esp_rtc_get_time_us>
42006282:	e95791        	l32r	a9, 420007e0 <_stext+0x7c0> (3fc949d8 <g_startup_time>)
42006285:	002982        	l32i	a8, a9, 0
42006288:	012992        	l32i	a9, a9, 4
4200628b:	c06b90        	sub	a6, a11, a9
4200628e:	02ba87        	bgeu	a10, a8, 42006294 <esp_timer_impl_init_system_time+0x18>
42006291:	ffc662        	addi	a6, a6, -1
42006294:	c07a80        	sub	a7, a10, a8
42006297:	e95781        	l32r	a8, 420007f4 <_stext+0x7d4> (40376c38 <esp_timer_get_time>)
4200629a:	0008e0        	callx8	a8
4200629d:	c066b0        	sub	a6, a6, a11
420062a0:	01b7a7        	bgeu	a7, a10, 420062a5 <esp_timer_impl_init_system_time+0x29>
420062a3:	660b      	addi.n	a6, a6, -1
420062a5:	c077a0        	sub	a7, a7, a10
420062a8:	e94f81        	l32r	a8, 420007e4 <_stext+0x7c4> (3fc94ff8 <s_correction_us>)
420062ab:	0879      	s32i.n	a7, a8, 0
420062ad:	016862        	s32i	a6, a8, 4
    esp_err_t err = esp_register_shutdown_handler(esp_sync_timekeeping_timers);
420062b0:	e94ea1        	l32r	a10, 420007e8 <_stext+0x7c8> (42005dfc <esp_sync_timekeeping_timers>)
420062b3:	fb0ee5        	call8	420013a0 <esp_register_shutdown_handler>
420062b6:	0a7d      	mov.n	a7, a10
    if (err != ESP_OK) {
420062b8:	8a9c      	beqz.n	a10, 420062d4 <esp_timer_impl_init_system_time+0x58>
        ESP_LOGW(TAG, "Register shutdown handler failed, err = 0x%x", err);
420062ba:	e76981        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420062bd:	0008e0        	callx8	a8
420062c0:	e94bb1        	l32r	a11, 420007ec <_stext+0x7cc> (3c024f60 <_flash_rodata_start+0x4e40>)
420062c3:	07fd      	mov.n	a15, a7
420062c5:	0bed      	mov.n	a14, a11
420062c7:	0add      	mov.n	a13, a10
420062c9:	e949c1        	l32r	a12, 420007f0 <_stext+0x7d0> (3c024f6c <_flash_rodata_start+0x4e4c>)
420062cc:	2a0c      	movi.n	a10, 2
420062ce:	e77181        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420062d1:	0008e0        	callx8	a8
}
420062d4:	f01d      	retw.n
	...

420062d8 <esp_timer_impl_early_init>:
    systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER, time_diff_us);
    portEXIT_CRITICAL_SAFE(&s_time_update_lock);
}

esp_err_t esp_timer_impl_early_init(void)
{
420062d8:	006136        	entry	a1, 48
    PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_SYSTIMER_MODULE, ref_count) {
420062db:	170c      	movi.n	a7, 1
420062dd:	000f46        	j	4200631e <esp_timer_impl_early_init+0x46>
    SYSTEM.perip_clk_en0.systimer_clk_en = enable;
420062e0:	e7ce81        	l32r	a8, 42000218 <_stext+0x1f8> (600c0000 <SYSTEM>)
420062e3:	0020c0        	memw
420062e6:	6898      	l32i.n	a9, a8, 24
420062e8:	e852a1        	l32r	a10, 42000430 <_stext+0x410> (20000000 <UserFrameTotalSize+0x1fffff00>)
420062eb:	2099a0        	or	a9, a9, a10
420062ee:	0020c0        	memw
420062f1:	6899      	s32i.n	a9, a8, 24
    SYSTEM.perip_rst_en0.systimer_rst = 1;
420062f3:	0020c0        	memw
420062f6:	8898      	l32i.n	a9, a8, 32
420062f8:	2099a0        	or	a9, a9, a10
420062fb:	0020c0        	memw
420062fe:	8899      	s32i.n	a9, a8, 32
    SYSTEM.perip_rst_en0.systimer_rst = 0;
42006300:	0020c0        	memw
42006303:	8898      	l32i.n	a9, a8, 32
42006305:	e84ba1        	l32r	a10, 42000434 <_stext+0x414> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42006308:	1099a0        	and	a9, a9, a10
4200630b:	0020c0        	memw
4200630e:	8899      	s32i.n	a9, a8, 32
42006310:	24a0a2        	movi	a10, 36
42006313:	e7c981        	l32r	a8, 42000238 <_stext+0x218> (403766cc <periph_rcc_acquire_exit>)
42006316:	0008e0        	callx8	a8
42006319:	770b      	addi.n	a7, a7, -1
4200631b:	747070        	extui	a7, a7, 0, 8
4200631e:	e78c      	beqz.n	a7, 42006330 <esp_timer_impl_early_init+0x58>
42006320:	4a2c      	movi.n	a10, 36
42006322:	e7c681        	l32r	a8, 4200023c <_stext+0x21c> (403766bc <periph_rcc_acquire_enter>)
42006325:	0008e0        	callx8	a8
42006328:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
4200632a:	fb2a16        	beqz	a10, 420062e0 <esp_timer_impl_early_init+0x8>
4200632d:	fff7c6        	j	42006310 <esp_timer_impl_early_init+0x38>
            systimer_ll_enable_bus_clock(true);
            systimer_ll_reset_register();
        }
    }
    systimer_hal_tick_rate_ops_t ops = {
42006330:	e93281        	l32r	a8, 420007f8 <_stext+0x7d8> (3c028574 <__func__$0+0x30>)
42006333:	0898      	l32i.n	a9, a8, 0
42006335:	1888      	l32i.n	a8, a8, 4
42006337:	0199      	s32i.n	a9, a1, 0
42006339:	1189      	s32i.n	a8, a1, 4
        .ticks_to_us = systimer_ticks_to_us,
        .us_to_ticks = systimer_us_to_ticks,
    };
    systimer_hal_init(&systimer_hal);
4200633b:	e93071        	l32r	a7, 420007fc <_stext+0x7dc> (3fc95000 <systimer_hal>)
4200633e:	07ad      	mov.n	a10, a7
42006340:	e93081        	l32r	a8, 42000800 <_stext+0x7e0> (4037e3c8 <systimer_hal_init>)
42006343:	0008e0        	callx8	a8
    systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
42006346:	01bd      	mov.n	a11, a1
42006348:	07ad      	mov.n	a10, a7
4200634a:	e92e81        	l32r	a8, 42000804 <_stext+0x7e4> (4037e54c <systimer_hal_set_tick_rate_ops>)
4200634d:	0008e0        	callx8	a8
           "update the step for xtal to support other XTAL:APB frequency ratios");
    systimer_hal_set_steps_per_tick(&systimer_hal, 0, 2); // for xtal
    systimer_hal_set_steps_per_tick(&systimer_hal, 1, 1); // for pll
#endif

    systimer_hal_enable_counter(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER);
42006350:	0b0c      	movi.n	a11, 0
42006352:	07ad      	mov.n	a10, a7
42006354:	e92d81        	l32r	a8, 42000808 <_stext+0x7e8> (4037e57c <systimer_hal_enable_counter>)
42006357:	0008e0        	callx8	a8
    systimer_hal_select_alarm_mode(&systimer_hal, SYSTIMER_ALARM_ESPTIMER, SYSTIMER_ALARM_MODE_ONESHOT);
4200635a:	0c0c      	movi.n	a12, 0
4200635c:	2b0c      	movi.n	a11, 2
4200635e:	07ad      	mov.n	a10, a7
42006360:	e92b81        	l32r	a8, 4200080c <_stext+0x7ec> (4037e50c <systimer_hal_select_alarm_mode>)
42006363:	0008e0        	callx8	a8
    systimer_hal_connect_alarm_counter(&systimer_hal, SYSTIMER_ALARM_ESPTIMER, SYSTIMER_COUNTER_ESPTIMER);
42006366:	0c0c      	movi.n	a12, 0
42006368:	2b0c      	movi.n	a11, 2
4200636a:	07ad      	mov.n	a10, a7
4200636c:	e92981        	l32r	a8, 42000810 <_stext+0x7f0> (4037e5a0 <systimer_hal_connect_alarm_counter>)
4200636f:	0008e0        	callx8	a8

    for (unsigned cpuid = 0; cpuid < SOC_CPU_CORES_NUM; ++cpuid) {
42006372:	070c      	movi.n	a7, 0
42006374:	000486        	j	4200638a <esp_timer_impl_early_init+0xb2>
42006377:	0c0000        	lsi	f0, a0, 48
        bool can_stall = (cpuid < portNUM_PROCESSORS);
        systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER, cpuid, can_stall);
4200637a:	cd1d      	lsi	f1, a13, 52
4200637c:	0b0c07        	bnone	a12, a0, 4200638b <esp_timer_impl_early_init+0xb3>
4200637f:	e91fa1        	l32r	a10, 420007fc <_stext+0x7dc> (3fc95000 <systimer_hal>)
42006382:	e92481        	l32r	a8, 42000814 <_stext+0x7f4> (4037e5c4 <systimer_hal_counter_can_stall_by_cpu>)
42006385:	0008e0        	callx8	a8
    for (unsigned cpuid = 0; cpuid < SOC_CPU_CORES_NUM; ++cpuid) {
42006388:	771b      	addi.n	a7, a7, 1
4200638a:	eb27b6        	bltui	a7, 2, 42006379 <esp_timer_impl_early_init+0xa1>
    }

    return ESP_OK;
}
4200638d:	020c      	movi.n	a2, 0
4200638f:	f01d      	retw.n
42006391:	000000        	ill

42006394 <__esp_system_init_fn_usb_serial_jtag_conn_status_init>:

ESP_SYSTEM_INIT_FN(usb_serial_jtag_conn_status_init, SECONDARY, BIT(0), 230)
{
42006394:	004136        	entry	a1, 32
    // We always assume it is connected at first, so acquires the lock to avoid auto light sleep
    esp_pm_lock_acquire(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
// TODO: esp32p4 USJ rely on SPLL, if it will also be disabled during sleep, we need to call spll_add_consumer? IDF-9947
    rtc_clk_bbpll_add_consumer();
42006397:	e92381        	l32r	a8, 42000824 <_stext+0x804> (403786ec <rtc_clk_bbpll_add_consumer>)
4200639a:	0008e0        	callx8	a8
#endif
    s_usb_serial_jtag_conn_status = true;
4200639d:	e91e81        	l32r	a8, 42000818 <_stext+0x7f8> (3fc95010 <s_usb_serial_jtag_conn_status>)
420063a0:	01a092        	movi	a9, 1
420063a3:	0020c0        	memw
420063a6:	004892        	s8i	a9, a8, 0
    remaining_allowed_no_sof_ticks = ALLOWED_NO_SOF_TICKS;
420063a9:	e91c81        	l32r	a8, 4200081c <_stext+0x7fc> (3fc9500c <remaining_allowed_no_sof_ticks>)
420063ac:	00a092        	movi	a9, 0
420063af:	006892        	s32i	a9, a8, 0

    return esp_register_freertos_tick_hook(usb_serial_jtag_sof_tick_hook);
420063b2:	e91ba1        	l32r	a10, 42000820 <_stext+0x800> (40376c50 <usb_serial_jtag_sof_tick_hook>)
420063b5:	fc4b65        	call8	4200286c <esp_register_freertos_tick_hook>
}
420063b8:	0a2d      	mov.n	a2, a10
420063ba:	f01d      	retw.n

420063bc <usb_serial_jtag_open>:
static esp_err_t usb_serial_jtag_end_select(void *end_select_args);

#endif // CONFIG_VFS_SUPPORT_SELECT

static int usb_serial_jtag_open(const char * path, int flags, int mode)
{
420063bc:	004136        	entry	a1, 32
    s_ctx.non_blocking = ((flags & O_NONBLOCK) == O_NONBLOCK);
420063bf:	043e30        	extui	a3, a3, 14, 1
420063c2:	e91981        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
420063c5:	0c4832        	s8i	a3, a8, 12
    return USJ_LOCAL_FD;
}
420063c8:	020c      	movi.n	a2, 0
420063ca:	f01d      	retw.n

420063cc <usb_serial_jtag_rx_char_no_driver>:
    } while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US);

}

static int usb_serial_jtag_rx_char_no_driver(int fd)
{
420063cc:	006136        	entry	a1, 48
    for (i = 0; i < rd_len; i++) {
420063cf:	080c      	movi.n	a8, 0
420063d1:	000646        	j	420063ee <usb_serial_jtag_rx_char_no_driver+0x22>
        if (!USB_SERIAL_JTAG.ep1_conf.serial_out_ep_data_avail) break;
420063d4:	e79f91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420063d7:	0020c0        	memw
420063da:	1998      	l32i.n	a9, a9, 4
420063dc:	116927        	bbci	a9, 2, 420063f1 <usb_serial_jtag_rx_char_no_driver+0x25>
        buf[i] = USB_SERIAL_JTAG.ep1.rdwr_byte;
420063df:	e79c91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420063e2:	0020c0        	memw
420063e5:	09a8      	l32i.n	a10, a9, 0
420063e7:	918a      	add.n	a9, a1, a8
420063e9:	0049a2        	s8i	a10, a9, 0
    for (i = 0; i < rd_len; i++) {
420063ec:	881b      	addi.n	a8, a8, 1
420063ee:	fe2816        	beqz	a8, 420063d4 <usb_serial_jtag_rx_char_no_driver+0x8>
    uint8_t c;
    int l = usb_serial_jtag_ll_read_rxfifo(&c, 1);
    if (l == 0) {
420063f1:	488c      	beqz.n	a8, 420063f9 <usb_serial_jtag_rx_char_no_driver+0x2d>
        return NONE;
    }
    return c;
420063f3:	000122        	l8ui	a2, a1, 0
420063f6:	000046        	j	420063fb <usb_serial_jtag_rx_char_no_driver+0x2f>
        return NONE;
420063f9:	f27c      	movi.n	a2, -1
}
420063fb:	f01d      	retw.n
420063fd:	000000        	ill

42006400 <usb_serial_jtag_read_char>:
/* Helper function which returns a previous character or reads a new one from
 * the port. Previous character can be returned ("pushed back") using
 * usb_serial_jtag_return_char function.
 */
static int usb_serial_jtag_read_char(int fd)
{
42006400:	004136        	entry	a1, 32
42006403:	02ad      	mov.n	a10, a2
    /* return character from peek buffer, if it is there */
    if (s_ctx.peek_char != NONE) {
42006405:	e90881        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006408:	0828      	l32i.n	a2, a8, 0
4200640a:	060226        	beqi	a2, -1, 42006414 <usb_serial_jtag_read_char+0x14>
        int c = s_ctx.peek_char;
        s_ctx.peek_char = NONE;
4200640d:	f97c      	movi.n	a9, -1
4200640f:	0899      	s32i.n	a9, a8, 0
        return c;
42006411:	000246        	j	4200641e <usb_serial_jtag_read_char+0x1e>
    }
    return s_ctx.rx_func(fd);
42006414:	e90581        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006417:	7888      	l32i.n	a8, a8, 28
42006419:	0008e0        	callx8	a8
4200641c:	0a2d      	mov.n	a2, a10
}
4200641e:	f01d      	retw.n

42006420 <usb_serial_jtag_wait_tx_done_no_driver>:
    }
    return result;
}

static int usb_serial_jtag_wait_tx_done_no_driver(int fd)
{
42006420:	004136        	entry	a1, 32
 *
 * @return na
 */
static inline void usb_serial_jtag_ll_txfifo_flush(void)
{
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
42006423:	e78b91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42006426:	0020c0        	memw
42006429:	1988      	l32i.n	a8, a9, 4
4200642b:	1a0c      	movi.n	a10, 1
4200642d:	2088a0        	or	a8, a8, a10
42006430:	0020c0        	memw
42006433:	1989      	s32i.n	a8, a9, 4
}
42006435:	000bc6        	j	42006468 <usb_serial_jtag_wait_tx_done_no_driver+0x48>
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
42006438:	e78681        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
4200643b:	0020c0        	memw
4200643e:	1888      	l32i.n	a8, a8, 4
    usb_serial_jtag_ll_txfifo_flush();
    //Wait for the host to have picked up the buffer, but honour the timeout in
    //case the host is not listening.
    while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US) {
        if (usb_serial_jtag_ll_txfifo_writable()) {
42006440:	246817        	bbci	a8, 1, 42006468 <usb_serial_jtag_wait_tx_done_no_driver+0x48>
            s_ctx.last_tx_ts = esp_timer_get_time();
42006443:	e8ec81        	l32r	a8, 420007f4 <_stext+0x7d4> (40376c38 <esp_timer_get_time>)
42006446:	0008e0        	callx8	a8
42006449:	e8f781        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
4200644c:	a8a9      	s32i.n	a10, a8, 40
4200644e:	b8b9      	s32i.n	a11, a8, 44
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
42006450:	e78091        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42006453:	0020c0        	memw
42006456:	1988      	l32i.n	a8, a9, 4
42006458:	1a0c      	movi.n	a10, 1
4200645a:	2088a0        	or	a8, a8, a10
4200645d:	0020c0        	memw
42006460:	1989      	s32i.n	a8, a9, 4
            //The last transfer may have been a 64-byte one. Flush again in order to
            //send a 0-byte packet to indicate the end of the USB transfer, otherwise
            //those 64 bytes will get stuck in the hosts buffer.
            usb_serial_jtag_ll_txfifo_flush();
            return 0;
42006462:	020c      	movi.n	a2, 0
42006464:	000986        	j	4200648e <usb_serial_jtag_wait_tx_done_no_driver+0x6e>
42006467:	e38100        	lsi	f0, a1, 0x38c
    while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US) {
4200646a:	e0e8      	l32i.n	a14, a0, 56
4200646c:	0008      	l32i.n	a0, a0, 0
4200646e:	e8ee91        	l32r	a9, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006471:	a988      	l32i.n	a8, a9, 40
42006473:	b998      	l32i.n	a9, a9, 44
42006475:	c0bb90        	sub	a11, a11, a9
42006478:	01ba87        	bgeu	a10, a8, 4200647d <usb_serial_jtag_wait_tx_done_no_driver+0x5d>
4200647b:	bb0b      	addi.n	a11, a11, -1
4200647d:	c0aa80        	sub	a10, a10, a8
42006480:	081be6        	bgei	a11, 1, 4200648c <usb_serial_jtag_wait_tx_done_no_driver+0x6c>
42006483:	fb1b56        	bnez	a11, 42006438 <usb_serial_jtag_wait_tx_done_no_driver+0x18>
42006486:	e8e981        	l32r	a8, 4200082c <_stext+0x80c> (c34f <UserFrameTotalSize+0xc24f>)
42006489:	abb8a7        	bgeu	a8, a10, 42006438 <usb_serial_jtag_wait_tx_done_no_driver+0x18>
        }
    }
    //Timeout. Host probably isn't listening.
    return EIO;
4200648c:	520c      	movi.n	a2, 5
}
4200648e:	f01d      	retw.n

42006490 <usb_serial_jtag_tx_char_no_driver>:
{
42006490:	006136        	entry	a1, 48
    uint8_t cc = (uint8_t)c;
42006493:	004132        	s8i	a3, a1, 0
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
42006496:	e76e81        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42006499:	0020c0        	memw
4200649c:	1888      	l32i.n	a8, a8, 4
        if (usb_serial_jtag_ll_txfifo_writable()) {
4200649e:	4b6817        	bbci	a8, 1, 420064ed <usb_serial_jtag_tx_char_no_driver+0x5d>
420064a1:	000786        	j	420064c3 <usb_serial_jtag_tx_char_no_driver+0x33>
        if (!USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free) break;
420064a4:	e76b91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420064a7:	0020c0        	memw
420064aa:	1998      	l32i.n	a9, a9, 4
420064ac:	186917        	bbci	a9, 1, 420064c8 <usb_serial_jtag_tx_char_no_driver+0x38>
        USB_SERIAL_JTAG.ep1.rdwr_byte = buf[i];
420064af:	918a      	add.n	a9, a1, a8
420064b1:	0009a2        	l8ui	a10, a9, 0
420064b4:	e76791        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420064b7:	0020c0        	memw
420064ba:	09a9      	s32i.n	a10, a9, 0
    for (i = 0; i < wr_len; i++) {
420064bc:	881b      	addi.n	a8, a8, 1
420064be:	0000c6        	j	420064c5 <usb_serial_jtag_tx_char_no_driver+0x35>
420064c1:	0c0000        	lsi	f0, a0, 48
420064c4:	1608      	l32i.n	a0, a6, 4
420064c6:	fdb8      	l32i.n	a11, a13, 60
            if (c == '\n') {
420064c8:	119366        	bnei	a3, 10, 420064dd <usb_serial_jtag_tx_char_no_driver+0x4d>
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
420064cb:	e76191        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420064ce:	0020c0        	memw
420064d1:	1988      	l32i.n	a8, a9, 4
420064d3:	1a0c      	movi.n	a10, 1
420064d5:	2088a0        	or	a8, a8, a10
420064d8:	0020c0        	memw
420064db:	1989      	s32i.n	a8, a9, 4
            s_ctx.last_tx_ts = esp_timer_get_time();
420064dd:	e8c581        	l32r	a8, 420007f4 <_stext+0x7d4> (40376c38 <esp_timer_get_time>)
420064e0:	0008e0        	callx8	a8
420064e3:	e8d181        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
420064e6:	a8a9      	s32i.n	a10, a8, 40
420064e8:	b8b9      	s32i.n	a11, a8, 44
            break;
420064ea:	000986        	j	42006514 <usb_serial_jtag_tx_char_no_driver+0x84>
    } while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US);
420064ed:	e8c181        	l32r	a8, 420007f4 <_stext+0x7d4> (40376c38 <esp_timer_get_time>)
420064f0:	0008e0        	callx8	a8
420064f3:	e8cd91        	l32r	a9, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
420064f6:	0a2982        	l32i	a8, a9, 40
420064f9:	0b2992        	l32i	a9, a9, 44
420064fc:	c0bb90        	sub	a11, a11, a9
420064ff:	02ba87        	bgeu	a10, a8, 42006505 <usb_serial_jtag_tx_char_no_driver+0x75>
42006502:	ffcbb2        	addi	a11, a11, -1
42006505:	c0aa80        	sub	a10, a10, a8
42006508:	081be6        	bgei	a11, 1, 42006514 <usb_serial_jtag_tx_char_no_driver+0x84>
4200650b:	f87b56        	bnez	a11, 42006496 <usb_serial_jtag_tx_char_no_driver+0x6>
4200650e:	e8c781        	l32r	a8, 4200082c <_stext+0x80c> (c34f <UserFrameTotalSize+0xc24f>)
42006511:	81b8a7        	bgeu	a8, a10, 42006496 <usb_serial_jtag_tx_char_no_driver+0x6>
}
42006514:	f01d      	retw.n
	...

42006518 <unregister_select>:

    return ret;
}

static esp_err_t unregister_select(usb_serial_jtag_select_args_t *args)
{
42006518:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    if (args) {
4200651b:	069216        	beqz	a2, 42006588 <unregister_select+0x70>
4200651e:	fb7c      	movi.n	a11, -1
42006520:	e8c4a1        	l32r	a10, 42000830 <_stext+0x810> (3fc921b4 <s_registered_select_lock>)
42006523:	e7bb81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42006526:	0008e0        	callx8	a8
        ret = ESP_ERR_INVALID_STATE;
        portENTER_CRITICAL(&s_registered_select_lock);
        for (int i = 0; i < s_registered_select_num; ++i) {
42006529:	080c      	movi.n	a8, 0
4200652b:	000ec6        	j	4200656a <unregister_select+0x52>
4200652e:	a10000        	sll	a0, a0
            if (s_registered_selects[i] == args) {
42006531:	a8e8c1        	l32r	a12, 41ff08d4 <_coredump_iram_end+0x1c6e8d4>
42006534:	a00a      	add.n	a10, a0, a0
42006536:	a0b8      	l32i.n	a11, a0, 40
42006538:	0bc8      	l32i.n	a12, a11, 0
4200653a:	2a9c27        	bne	a12, a2, 42006568 <unregister_select+0x50>
                const int new_size = s_registered_select_num - 1;
4200653d:	290b      	addi.n	a2, a9, -1
                // The item is removed by overwriting it with the last item. The subsequent rellocation will drop the
                // last item.
                s_registered_selects[i] = s_registered_selects[new_size];
4200653f:	a082a0        	addx4	a8, a2, a10
42006542:	0888      	l32i.n	a8, a8, 0
42006544:	006b82        	s32i	a8, a11, 0
                s_registered_selects = heap_caps_realloc(s_registered_selects, new_size * sizeof(usb_serial_jtag_select_args_t *), USJ_VFS_MALLOC_FLAGS);
42006547:	e8bcc1        	l32r	a12, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
4200654a:	11b2e0        	slli	a11, a2, 2
4200654d:	e8bc81        	l32r	a8, 42000840 <_stext+0x820> (40375fcc <heap_caps_realloc>)
42006550:	0008e0        	callx8	a8
42006553:	e8b881        	l32r	a8, 42000834 <_stext+0x814> (3fc95018 <s_registered_selects>)
42006556:	08a9      	s32i.n	a10, a8, 0
                // Shrinking a buffer with realloc is guaranteed to succeed.
                s_registered_select_num = new_size;
42006558:	e8b981        	l32r	a8, 4200083c <_stext+0x81c> (3fc95014 <s_registered_select_num>)
4200655b:	0829      	s32i.n	a2, a8, 0

                /* when the last select is unregistered, also unregister the callback  */
                if (s_registered_select_num == 0) {
4200655d:	82dc      	bnez.n	a2, 42006579 <unregister_select+0x61>
                    usb_serial_jtag_set_select_notif_callback(NULL);
4200655f:	0a0c      	movi.n	a10, 0
42006561:	004de5        	call8	42006a40 <usb_serial_jtag_set_select_notif_callback>
42006564:	0004c6        	j	4200657b <unregister_select+0x63>
42006567:	881b00        	lsi	f0, a11, 0x220
        for (int i = 0; i < s_registered_select_num; ++i) {
4200656a:	e8b491        	l32r	a9, 4200083c <_stext+0x81c> (3fc95014 <s_registered_select_num>)
4200656d:	0998      	l32i.n	a9, a9, 0
4200656f:	bd2897        	blt	a8, a9, 42006530 <unregister_select+0x18>
        ret = ESP_ERR_INVALID_STATE;
42006572:	03a122        	movi	a2, 0x103
42006575:	000086        	j	4200657b <unregister_select+0x63>
42006578:	020c00        	andb	b0, b12, b0

                ret = ESP_OK;
                break;
            }
        }
        portEXIT_CRITICAL(&s_registered_select_lock);
4200657b:	e8ada1        	l32r	a10, 42000830 <_stext+0x810> (3fc921b4 <s_registered_select_lock>)
4200657e:	e7a581        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42006581:	0008e0        	callx8	a8
42006584:	000086        	j	4200658a <unregister_select+0x72>
42006587:	020c00        	andb	b0, b12, b0
    }
    return ret;
}
4200658a:	f01d      	retw.n

4200658c <usb_serial_jtag_end_select>:
    *end_select_args = args;
    return ESP_OK;
}

static esp_err_t usb_serial_jtag_end_select(void *end_select_args)
{
4200658c:	004136        	entry	a1, 32
4200658f:	207220        	or	a7, a2, a2
    usb_serial_jtag_select_args_t *args = end_select_args;
    esp_err_t ret = unregister_select(args);
42006592:	20a220        	or	a10, a2, a2
42006595:	fff825        	call8	42006518 <unregister_select>
42006598:	202aa0        	or	a2, a10, a10
    if (args) {
4200659b:	678c      	beqz.n	a7, 420065a5 <usb_serial_jtag_end_select+0x19>
        free(args);
4200659d:	07ad      	mov.n	a10, a7
4200659f:	e7f281        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
420065a2:	0008e0        	callx8	a8
    }

    return ret;
}
420065a5:	f01d      	retw.n
	...

420065a8 <register_select>:
{
420065a8:	004136        	entry	a1, 32
    if (args) {
420065ab:	05c216        	beqz	a2, 4200660b <register_select+0x63>
420065ae:	ffafb2        	movi	a11, -1
420065b1:	e89fa1        	l32r	a10, 42000830 <_stext+0x810> (3fc921b4 <s_registered_select_lock>)
420065b4:	e79781        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420065b7:	0008e0        	callx8	a8
        const int new_size = s_registered_select_num + 1;
420065ba:	e8a081        	l32r	a8, 4200083c <_stext+0x81c> (3fc95014 <s_registered_select_num>)
420065bd:	002862        	l32i	a6, a8, 0
420065c0:	01c662        	addi	a6, a6, 1
        if ((new_selects = heap_caps_realloc(s_registered_selects, new_size * sizeof(usb_serial_jtag_select_args_t *), USJ_VFS_MALLOC_FLAGS)) == NULL) {
420065c3:	e89dc1        	l32r	a12, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
420065c6:	11b6e0        	slli	a11, a6, 2
420065c9:	e89a81        	l32r	a8, 42000834 <_stext+0x814> (3fc95018 <s_registered_selects>)
420065cc:	08a8      	l32i.n	a10, a8, 0
420065ce:	e89c81        	l32r	a8, 42000840 <_stext+0x820> (40375fcc <heap_caps_realloc>)
420065d1:	0008e0        	callx8	a8
420065d4:	0a7d      	mov.n	a7, a10
420065d6:	2aac      	beqz.n	a10, 420065fc <register_select+0x54>
            if (s_registered_select_num == 0) {
420065d8:	e89981        	l32r	a8, 4200083c <_stext+0x81c> (3fc95014 <s_registered_select_num>)
420065db:	0888      	l32i.n	a8, a8, 0
420065dd:	48cc      	bnez.n	a8, 420065e5 <register_select+0x3d>
                usb_serial_jtag_set_select_notif_callback(select_notif_callback_isr);
420065df:	e899a1        	l32r	a10, 42000844 <_stext+0x824> (420066fc <select_notif_callback_isr>)
420065e2:	0045e5        	call8	42006a40 <usb_serial_jtag_set_select_notif_callback>
            s_registered_selects = new_selects;
420065e5:	e89381        	l32r	a8, 42000834 <_stext+0x814> (3fc95018 <s_registered_selects>)
420065e8:	0879      	s32i.n	a7, a8, 0
            s_registered_selects[s_registered_select_num] = args;
420065ea:	e89491        	l32r	a9, 4200083c <_stext+0x81c> (3fc95014 <s_registered_select_num>)
420065ed:	0988      	l32i.n	a8, a9, 0
420065ef:	a08870        	addx4	a8, a8, a7
420065f2:	0829      	s32i.n	a2, a8, 0
            s_registered_select_num = new_size;
420065f4:	0969      	s32i.n	a6, a9, 0
            ret = ESP_OK;
420065f6:	020c      	movi.n	a2, 0
420065f8:	0000c6        	j	420065ff <register_select+0x57>
420065fb:	a12200        	sll	a2, a2
            ret = ESP_ERR_NO_MEM;
420065fe:	8ca101        	l32r	a0, 41fe9884 <_coredump_iram_end+0x1c67884>
        portEXIT_CRITICAL(&s_registered_select_lock);
42006601:	81e8      	l32i.n	a14, a1, 32
42006603:	e0e784        	lsi	f8, a7, 0x380
42006606:	0008      	l32i.n	a0, a0, 0
42006608:	000086        	j	4200660e <register_select+0x66>
    esp_err_t ret = ESP_ERR_INVALID_ARG;
4200660b:	02a122        	movi	a2, 0x102
}
4200660e:	f01d      	retw.n

42006610 <usb_serial_jtag_start_select>:
{
42006610:	006136        	entry	a1, 48
42006613:	0169      	s32i.n	a6, a1, 0
42006615:	1179      	s32i.n	a7, a1, 4
42006617:	c168      	l32i.n	a6, a1, 48
    *end_select_args = NULL;
42006619:	080c      	movi.n	a8, 0
4200661b:	0689      	s32i.n	a8, a6, 0
    if (!usb_serial_jtag_is_driver_installed()) {
4200661d:	004125        	call8	42006a30 <usb_serial_jtag_is_driver_installed>
42006620:	0c9a16        	beqz	a10, 420066ed <usb_serial_jtag_start_select+0xdd>
    usb_serial_jtag_select_args_t *args = heap_caps_malloc(sizeof(usb_serial_jtag_select_args_t), USJ_VFS_MALLOC_FLAGS);
42006623:	e885b1        	l32r	a11, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
42006626:	ca2c      	movi.n	a10, 44
42006628:	e7be81        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
4200662b:	0008e0        	callx8	a8
4200662e:	0a7d      	mov.n	a7, a10
    if (args == NULL) {
42006630:	0c0a16        	beqz	a10, 420066f4 <usb_serial_jtag_start_select+0xe4>
    args->select_sem = select_sem;
42006633:	0188      	l32i.n	a8, a1, 0
42006635:	0a89      	s32i.n	a8, a10, 0
42006637:	1188      	l32i.n	a8, a1, 4
42006639:	1a89      	s32i.n	a8, a10, 4
    args->readfds = readfds;
4200663b:	2a39      	s32i.n	a3, a10, 8
    args->writefds = writefds;
4200663d:	3a49      	s32i.n	a4, a10, 12
    args->errorfds = exceptfds;
4200663f:	4a59      	s32i.n	a5, a10, 16
    args->readfds_orig = *readfds; // store the original values because they will be set to zero
42006641:	0398      	l32i.n	a9, a3, 0
42006643:	1388      	l32i.n	a8, a3, 4
42006645:	5a99      	s32i.n	a9, a10, 20
42006647:	6a89      	s32i.n	a8, a10, 24
    args->writefds_orig = *writefds;
42006649:	0498      	l32i.n	a9, a4, 0
4200664b:	1488      	l32i.n	a8, a4, 4
4200664d:	7a99      	s32i.n	a9, a10, 28
4200664f:	8a89      	s32i.n	a8, a10, 32
    args->errorfds_orig = *exceptfds;
42006651:	0598      	l32i.n	a9, a5, 0
42006653:	1588      	l32i.n	a8, a5, 4
42006655:	9a99      	s32i.n	a9, a10, 36
42006657:	aa89      	s32i.n	a8, a10, 40
    FD_ZERO(readfds);
42006659:	280c      	movi.n	a8, 2
4200665b:	000206        	j	42006667 <usb_serial_jtag_start_select+0x57>
4200665e:	880b      	addi.n	a8, a8, -1
42006660:	a09830        	addx4	a9, a8, a3
42006663:	0a0c      	movi.n	a10, 0
42006665:	09a9      	s32i.n	a10, a9, 0
42006667:	ff3856        	bnez	a8, 4200665e <usb_serial_jtag_start_select+0x4e>
    FD_ZERO(writefds);
4200666a:	280c      	movi.n	a8, 2
4200666c:	000246        	j	42006679 <usb_serial_jtag_start_select+0x69>
4200666f:	880b00        	lsi	f0, a11, 0x220
42006672:	a09840        	addx4	a9, a8, a4
42006675:	0a0c      	movi.n	a10, 0
42006677:	09a9      	s32i.n	a10, a9, 0
42006679:	ff3856        	bnez	a8, 42006670 <usb_serial_jtag_start_select+0x60>
    FD_ZERO(exceptfds);
4200667c:	280c      	movi.n	a8, 2
4200667e:	0002c6        	j	4200668d <usb_serial_jtag_start_select+0x7d>
42006681:	ffc882        	addi	a8, a8, -1
42006684:	a09850        	addx4	a9, a8, a5
42006687:	00a0a2        	movi	a10, 0
4200668a:	0069a2        	s32i	a10, a9, 0
4200668d:	ff0856        	bnez	a8, 42006681 <usb_serial_jtag_start_select+0x71>
    esp_err_t ret = register_select(args);
42006690:	07ad      	mov.n	a10, a7
42006692:	fff165        	call8	420065a8 <register_select>
42006695:	0a2d      	mov.n	a2, a10
    if (ret != ESP_OK) {
42006697:	aa8c      	beqz.n	a10, 420066a5 <usb_serial_jtag_start_select+0x95>
        free(args);
42006699:	07ad      	mov.n	a10, a7
4200669b:	e7b381        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200669e:	0008e0        	callx8	a8
        return ret;
420066a1:	001486        	j	420066f7 <usb_serial_jtag_start_select+0xe7>
420066a4:	278200        	lsi	f0, a2, 156
    if (FD_ISSET(USJ_LOCAL_FD, &args->readfds_orig) && usb_serial_jtag_read_ready()) {
420066a7:	680705        	call0	4206e718 <_etext+0x574da>
420066aa:	3aa514        	lsi	f1, a5, 232
420066ad:	5aa000        	msub.s	f10, f0, f0
420066b0:	da1620        	ufloat.s	f1, a6, 2
420066b3:	038800        	lsi	f0, a8, 12
        FD_SET(USJ_LOCAL_FD, readfds);
420066b6:	190c      	movi.n	a9, 1
420066b8:	208890        	or	a8, a8, a9
420066bb:	0389      	s32i.n	a8, a3, 0
        trigger_select = true;
420066bd:	000046        	j	420066c2 <usb_serial_jtag_start_select+0xb2>
    bool trigger_select = false;
420066c0:	050c      	movi.n	a5, 0
    if (FD_ISSET(USJ_LOCAL_FD, &args->writefds_orig) && usb_serial_jtag_write_ready()) {
420066c2:	072782        	l32i	a8, a7, 28
420066c5:	136807        	bbci	a8, 0, 420066dc <usb_serial_jtag_start_select+0xcc>
420066c8:	003b25        	call8	42006a7c <usb_serial_jtag_write_ready>
420066cb:	00da16        	beqz	a10, 420066dc <usb_serial_jtag_start_select+0xcc>
        FD_SET(USJ_LOCAL_FD, writefds);
420066ce:	002482        	l32i	a8, a4, 0
420066d1:	190c      	movi.n	a9, 1
420066d3:	208890        	or	a8, a8, a9
420066d6:	0489      	s32i.n	a8, a4, 0
    if (trigger_select) {
420066d8:	0000c6        	j	420066df <usb_serial_jtag_start_select+0xcf>
420066db:	851600        	extui	a1, a0, 22, 9
420066de:	27a200        	lsi	f0, a2, 156
        esp_vfs_select_triggered(args->select_sem);
420066e1:	27b200        	lsi	f0, a2, 156
420066e4:	f5e501        	l32r	a0, 42003e78 <memprot_ll_iram0_set_pms_area_2> (81004136 <_rtc_reserved_end+0x20f04136>)
420066e7:	067900        	lsi	f0, a9, 24
    return ESP_OK;
420066ea:	000246        	j	420066f7 <usb_serial_jtag_start_select+0xe7>
        return ESP_ERR_INVALID_STATE;
420066ed:	03a122        	movi	a2, 0x103
420066f0:	0000c6        	j	420066f7 <usb_serial_jtag_start_select+0xe7>
420066f3:	a12200        	sll	a2, a2
        return ESP_ERR_NO_MEM;
420066f6:	f01d01        	l32r	a0, 4200276c <esp_ipc_call_nonblocking+0x98> (406 <UserFrameTotalSize+0x306>)
420066f9:	000000        	ill

420066fc <select_notif_callback_isr>:
{
420066fc:	004136        	entry	a1, 32
420066ff:	fb7c      	movi.n	a11, -1
42006701:	e84ba1        	l32r	a10, 42000830 <_stext+0x810> (3fc921b4 <s_registered_select_lock>)
42006704:	e74381        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42006707:	0008e0        	callx8	a8
    for (int i = 0; i < s_registered_select_num; ++i) {
4200670a:	070c      	movi.n	a7, 0
4200670c:	001bc6        	j	4200677f <select_notif_callback_isr+0x83>
        usb_serial_jtag_select_args_t *args = s_registered_selects[i];
4200670f:	e84981        	l32r	a8, 42000834 <_stext+0x814> (3fc95018 <s_registered_selects>)
42006712:	002882        	l32i	a8, a8, 0
42006715:	a08780        	addx4	a8, a7, a8
42006718:	002882        	l32i	a8, a8, 0
        if (args) {
4200671b:	05e816        	beqz	a8, 4200677d <select_notif_callback_isr+0x81>
            switch (usj_select_notif) {
4200671e:	221226        	beqi	a2, 1, 42006744 <select_notif_callback_isr+0x48>
42006721:	3f2226        	beqi	a2, 2, 42006764 <select_notif_callback_isr+0x68>
42006724:	055256        	bnez	a2, 4200677d <select_notif_callback_isr+0x81>
                if (FD_ISSET(USJ_LOCAL_FD, &args->readfds_orig)) {
42006727:	052892        	l32i	a9, a8, 20
4200672a:	4f6907        	bbci	a9, 0, 4200677d <select_notif_callback_isr+0x81>
                    FD_SET(USJ_LOCAL_FD, args->readfds);
4200672d:	28a8      	l32i.n	a10, a8, 8
4200672f:	0a98      	l32i.n	a9, a10, 0
42006731:	1b0c      	movi.n	a11, 1
42006733:	2099b0        	or	a9, a9, a11
42006736:	0a99      	s32i.n	a9, a10, 0
                    esp_vfs_select_triggered_isr(args->select_sem, task_woken);
42006738:	03cd      	mov.n	a12, a3
4200673a:	08a8      	l32i.n	a10, a8, 0
4200673c:	18b8      	l32i.n	a11, a8, 4
4200673e:	00f565        	call8	42007694 <esp_vfs_select_triggered_isr>
42006741:	000e06        	j	4200677d <select_notif_callback_isr+0x81>
                if (FD_ISSET(USJ_LOCAL_FD, &args->writefds_orig)) {
42006744:	072892        	l32i	a9, a8, 28
42006747:	326907        	bbci	a9, 0, 4200677d <select_notif_callback_isr+0x81>
                    FD_SET(USJ_LOCAL_FD, args->writefds);
4200674a:	0328a2        	l32i	a10, a8, 12
4200674d:	002a92        	l32i	a9, a10, 0
42006750:	1b0c      	movi.n	a11, 1
42006752:	2099b0        	or	a9, a9, a11
42006755:	0a99      	s32i.n	a9, a10, 0
                    esp_vfs_select_triggered_isr(args->select_sem, task_woken);
42006757:	03cd      	mov.n	a12, a3
42006759:	08a8      	l32i.n	a10, a8, 0
4200675b:	18b8      	l32i.n	a11, a8, 4
4200675d:	00f365        	call8	42007694 <esp_vfs_select_triggered_isr>
42006760:	000646        	j	4200677d <select_notif_callback_isr+0x81>
42006763:	989800        	lsi	f0, a8, 0x260
                if (FD_ISSET(USJ_LOCAL_FD, &args->errorfds_orig)) {
42006766:	136907        	bbci	a9, 0, 4200677d <select_notif_callback_isr+0x81>
                    FD_SET(USJ_LOCAL_FD, args->errorfds);
42006769:	48a8      	l32i.n	a10, a8, 16
4200676b:	0a98      	l32i.n	a9, a10, 0
4200676d:	1b0c      	movi.n	a11, 1
4200676f:	2099b0        	or	a9, a9, a11
42006772:	0a99      	s32i.n	a9, a10, 0
                    esp_vfs_select_triggered_isr(args->select_sem, task_woken);
42006774:	03cd      	mov.n	a12, a3
42006776:	08a8      	l32i.n	a10, a8, 0
42006778:	18b8      	l32i.n	a11, a8, 4
4200677a:	00f1a5        	call8	42007694 <esp_vfs_select_triggered_isr>
    for (int i = 0; i < s_registered_select_num; ++i) {
4200677d:	771b      	addi.n	a7, a7, 1
4200677f:	e82f81        	l32r	a8, 4200083c <_stext+0x81c> (3fc95014 <s_registered_select_num>)
42006782:	0888      	l32i.n	a8, a8, 0
42006784:	872787        	blt	a7, a8, 4200670f <select_notif_callback_isr+0x13>
    portEXIT_CRITICAL_ISR(&s_registered_select_lock);
42006787:	e82aa1        	l32r	a10, 42000830 <_stext+0x810> (3fc921b4 <s_registered_select_lock>)
4200678a:	e72281        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200678d:	0008e0        	callx8	a8
}
42006790:	f01d      	retw.n
	...

42006794 <usb_serial_jtag_tcflush>:
    usb_serial_jtag_fsync(fd);
    return 0;
}

static int usb_serial_jtag_tcflush(int fd, int select)
{
42006794:	004136        	entry	a1, 32
    //Flushing is not supported.
    errno = EINVAL;
42006797:	05c565        	call8	4200c3ec <__errno>
4200679a:	16a082        	movi	a8, 22
4200679d:	006a82        	s32i	a8, a10, 0
    return -1;
}
420067a0:	ffaf22        	movi	a2, -1
420067a3:	f01d      	retw.n
420067a5:	000000        	ill

420067a8 <usb_serial_jtag_fcntl>:
{
420067a8:	004136        	entry	a1, 32
    if (cmd == F_GETFL) {
420067ab:	0d3366        	bnei	a3, 3, 420067bc <usb_serial_jtag_fcntl+0x14>
        if (s_ctx.non_blocking) {
420067ae:	e81e81        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
420067b1:	0c0882        	l8ui	a8, a8, 12
420067b4:	48ec      	bnez.n	a8, 420067dc <usb_serial_jtag_fcntl+0x34>
        result |= O_RDWR;
420067b6:	220c      	movi.n	a2, 2
420067b8:	0008c6        	j	420067df <usb_serial_jtag_fcntl+0x37>
420067bb:	436600        	min	a6, a6, a0
    } else if (cmd == F_SETFL) {
420067be:	400d      	lsi	f0, a0, 0
        s_ctx.non_blocking = (arg & O_NONBLOCK) != 0;
420067c0:	4e          	.byte	0x4e
420067c1:	198104        	lsi	f0, a1, 100
420067c4:	42e8      	l32i.n	a14, a2, 16
420067c6:	0c48      	l32i.n	a4, a12, 0
    int result = 0;
420067c8:	020c      	movi.n	a2, 0
420067ca:	000446        	j	420067df <usb_serial_jtag_fcntl+0x37>
        errno = ENOSYS;
420067cd:	05c1e5        	call8	4200c3ec <__errno>
420067d0:	58a082        	movi	a8, 88
420067d3:	006a82        	s32i	a8, a10, 0
        result = -1;
420067d6:	ffaf22        	movi	a2, -1
420067d9:	000086        	j	420067df <usb_serial_jtag_fcntl+0x37>
            result |= O_NONBLOCK;
420067dc:	e81b21        	l32r	a2, 42000848 <_stext+0x828> (4002 <UserFrameTotalSize+0x3f02>)
}
420067df:	f01d      	retw.n
420067e1:	000000        	ill

420067e4 <usb_serial_jtag_tcgetattr>:
{
420067e4:	004136        	entry	a1, 32
    if (p == NULL) {
420067e7:	00e356        	bnez	a3, 420067f9 <usb_serial_jtag_tcgetattr+0x15>
        errno = EINVAL;
420067ea:	05c025        	call8	4200c3ec <__errno>
420067ed:	16a082        	movi	a8, 22
420067f0:	006a82        	s32i	a8, a10, 0
        return -1;
420067f3:	ffaf22        	movi	a2, -1
420067f6:	001346        	j	42006847 <usb_serial_jtag_tcgetattr+0x63>
    memset(p, 0, sizeof(struct termios));
420067f9:	cc1c      	movi.n	a12, 28
420067fb:	0b0c      	movi.n	a11, 0
420067fd:	03ad      	mov.n	a10, a3
420067ff:	e6c081        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42006802:	0008e0        	callx8	a8
    if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CRLF) {
42006805:	e80881        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006808:	5888      	l32i.n	a8, a8, 20
4200680a:	e8cc      	bnez.n	a8, 4200681c <usb_serial_jtag_tcgetattr+0x38>
        p->c_iflag |= IGNCR;
4200680c:	001382        	l16ui	a8, a3, 0
4200680f:	890c      	movi.n	a9, 8
42006811:	208890        	or	a8, a8, a9
42006814:	005382        	s16i	a8, a3, 0
42006817:	0003c6        	j	4200682a <usb_serial_jtag_tcgetattr+0x46>
4200681a:	660000        	lsi	f0, a0, 0x198
    } else if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CR) {
4200681d:	0a18      	l32i.n	a1, a10, 0
        p->c_iflag |= ICRNL;
4200681f:	001382        	l16ui	a8, a3, 0
42006822:	290c      	movi.n	a9, 2
42006824:	208890        	or	a8, a8, a9
42006827:	005382        	s16i	a8, a3, 0
    p->c_cflag &= (~CSIZE);
4200682a:	021382        	l16ui	a8, a3, 4
4200682d:	d49280        	extui	a9, a8, 2, 14
42006830:	1199e0        	slli	a9, a9, 2
42006833:	025392        	s16i	a9, a3, 4
    p->c_cflag |= CS8;
42006836:	390c      	movi.n	a9, 3
42006838:	208890        	or	a8, a8, a9
4200683b:	025382        	s16i	a8, a3, 4
    p->c_ispeed = p->c_ospeed = 1000000;
4200683e:	e7c381        	l32r	a8, 4200074c <_stext+0x72c> (f4240 <UserFrameTotalSize+0xf4140>)
42006841:	6389      	s32i.n	a8, a3, 24
42006843:	5389      	s32i.n	a8, a3, 20
    return 0;
42006845:	020c      	movi.n	a2, 0
}
42006847:	f01d      	retw.n
42006849:	000000        	ill

4200684c <usb_serial_jtag_fstat>:
{
4200684c:	004136        	entry	a1, 32
    memset(st, 0, sizeof(*st));
4200684f:	8c5c      	movi.n	a12, 88
42006851:	0b0c      	movi.n	a11, 0
42006853:	20a330        	or	a10, a3, a3
42006856:	e6aa81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42006859:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR;
4200685c:	e7fc81        	l32r	a8, 4200084c <_stext+0x82c> (2000 <UserFrameTotalSize+0x1f00>)
4200685f:	1389      	s32i.n	a8, a3, 4
}
42006861:	020c      	movi.n	a2, 0
42006863:	f01d      	retw.n
42006865:	000000        	ill

42006868 <usb_serial_jtag_fsync>:
{
42006868:	004136        	entry	a1, 32
    _lock_acquire_recursive(&s_ctx.write_lock);
4200686b:	e7f9a1        	l32r	a10, 42000850 <_stext+0x830> (3fc921c8 <s_ctx+0x8>)
4200686e:	e7f981        	l32r	a8, 42000854 <_stext+0x834> (40376a2c <_lock_acquire_recursive>)
42006871:	0008e0        	callx8	a8
    int r = s_ctx.fsync_func(fd);
42006874:	e7ed81        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006877:	082882        	l32i	a8, a8, 32
4200687a:	20a220        	or	a10, a2, a2
4200687d:	0008e0        	callx8	a8
42006880:	202aa0        	or	a2, a10, a10
    _lock_release_recursive(&s_ctx.write_lock);
42006883:	e7f3a1        	l32r	a10, 42000850 <_stext+0x830> (3fc921c8 <s_ctx+0x8>)
42006886:	e7f481        	l32r	a8, 42000858 <_stext+0x838> (40376a6c <_lock_release_recursive>)
42006889:	0008e0        	callx8	a8
    if (r == 0) {
4200688c:	528c      	beqz.n	a2, 42006895 <usb_serial_jtag_fsync+0x2d>
        errno = r;
4200688e:	05b5e5        	call8	4200c3ec <__errno>
42006891:	0a29      	s32i.n	a2, a10, 0
        return -1;
42006893:	f27c      	movi.n	a2, -1
}
42006895:	f01d      	retw.n
	...

42006898 <usb_serial_jtag_tcdrain>:
{
42006898:	004136        	entry	a1, 32
4200689b:	02ad      	mov.n	a10, a2
    usb_serial_jtag_fsync(fd);
4200689d:	fffca5        	call8	42006868 <usb_serial_jtag_fsync>
}
420068a0:	020c      	movi.n	a2, 0
420068a2:	f01d      	retw.n

420068a4 <usb_serial_jtag_tcsetattr>:
{
420068a4:	004136        	entry	a1, 32
    if (p == NULL) {
420068a7:	00e456        	bnez	a4, 420068b9 <usb_serial_jtag_tcsetattr+0x15>
        errno = EINVAL;
420068aa:	05b425        	call8	4200c3ec <__errno>
420068ad:	16a082        	movi	a8, 22
420068b0:	006a82        	s32i	a8, a10, 0
        return -1;
420068b3:	ffaf22        	movi	a2, -1
420068b6:	0012c6        	j	42006905 <usb_serial_jtag_tcsetattr+0x61>
    switch (optional_actions) {
420068b9:	071326        	beqi	a3, 1, 420068c4 <usb_serial_jtag_tcsetattr+0x20>
420068bc:	1c2326        	beqi	a3, 2, 420068dc <usb_serial_jtag_tcsetattr+0x38>
420068bf:	93cc      	bnez.n	a3, 420068cc <usb_serial_jtag_tcsetattr+0x28>
420068c1:	0005c6        	j	420068dc <usb_serial_jtag_tcsetattr+0x38>
        usb_serial_jtag_fsync(fd);
420068c4:	02ad      	mov.n	a10, a2
420068c6:	fffa25        	call8	42006868 <usb_serial_jtag_fsync>
        break;
420068c9:	0003c6        	j	420068dc <usb_serial_jtag_tcsetattr+0x38>
        errno = EINVAL;
420068cc:	05b1e5        	call8	4200c3ec <__errno>
420068cf:	16a082        	movi	a8, 22
420068d2:	006a82        	s32i	a8, a10, 0
        return -1;
420068d5:	ffaf22        	movi	a2, -1
420068d8:	000a46        	j	42006905 <usb_serial_jtag_tcsetattr+0x61>
420068db:	148200        	extui	a8, a0, 2, 2
    if (p->c_iflag & IGNCR) {
420068de:	683700        	lsi	f0, a7, 0x1a0
420068e1:	0c09      	s32i.n	a0, a12, 0
        s_ctx.rx_mode = ESP_LINE_ENDINGS_CRLF;
420068e3:	d18102        	lsi	f0, a1, 0x344
420068e6:	5829e7        	blt	a9, a14, 42006942 <usb_serial_jtag_write+0x3a>
420068e9:	000606        	j	42006905 <usb_serial_jtag_tcsetattr+0x61>
    } else if (p->c_iflag & ICRNL) {
420068ec:	0c6817        	bbci	a8, 1, 420068fc <usb_serial_jtag_tcsetattr+0x58>
        s_ctx.rx_mode = ESP_LINE_ENDINGS_CR;
420068ef:	e7ce81        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
420068f2:	190c      	movi.n	a9, 1
420068f4:	5899      	s32i.n	a9, a8, 20
    return 0;
420068f6:	020c      	movi.n	a2, 0
420068f8:	000246        	j	42006905 <usb_serial_jtag_tcsetattr+0x61>
420068fb:	cb8100        	movf.s	f8, f1, b0
        s_ctx.rx_mode = ESP_LINE_ENDINGS_LF;
420068fe:	290ce7        	bnone	a12, a14, 4200692b <usb_serial_jtag_write+0x23>
42006901:	5899      	s32i.n	a9, a8, 20
    return 0;
42006903:	020c      	movi.n	a2, 0
}
42006905:	f01d      	retw.n
	...

42006908 <usb_serial_jtag_write>:
{
42006908:	004136        	entry	a1, 32
4200690b:	025d      	mov.n	a5, a2
4200690d:	042d      	mov.n	a2, a4
    _lock_acquire_recursive(&s_ctx.write_lock);
4200690f:	e7d0a1        	l32r	a10, 42000850 <_stext+0x830> (3fc921c8 <s_ctx+0x8>)
42006912:	e7d081        	l32r	a8, 42000854 <_stext+0x834> (40376a2c <_lock_acquire_recursive>)
42006915:	0008e0        	callx8	a8
    for (size_t i = 0; i < size; i++) {
42006918:	070c      	movi.n	a7, 0
4200691a:	000b86        	j	4200694c <usb_serial_jtag_write+0x44>
        int c = data_c[i];
4200691d:	837a      	add.n	a8, a3, a7
4200691f:	000862        	l8ui	a6, a8, 0
        if (c == '\n' && s_ctx.tx_mode != ESP_LINE_ENDINGS_LF) {
42006922:	189666        	bnei	a6, 10, 4200693e <usb_serial_jtag_write+0x36>
42006925:	e7c081        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006928:	4888      	l32i.n	a8, a8, 16
4200692a:	102826        	beqi	a8, 2, 4200693e <usb_serial_jtag_write+0x36>
            s_ctx.tx_func(fd, '\r');
4200692d:	e7be41        	l32r	a4, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006930:	6488      	l32i.n	a8, a4, 24
42006932:	db0c      	movi.n	a11, 13
42006934:	05ad      	mov.n	a10, a5
42006936:	0008e0        	callx8	a8
            if (s_ctx.tx_mode == ESP_LINE_ENDINGS_CR) {
42006939:	4488      	l32i.n	a8, a4, 16
4200693b:	0b1826        	beqi	a8, 1, 4200694a <usb_serial_jtag_write+0x42>
        s_ctx.tx_func(fd, c);
4200693e:	e7ba81        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006941:	6888      	l32i.n	a8, a8, 24
42006943:	06bd      	mov.n	a11, a6
42006945:	05ad      	mov.n	a10, a5
42006947:	0008e0        	callx8	a8
    for (size_t i = 0; i < size; i++) {
4200694a:	771b      	addi.n	a7, a7, 1
4200694c:	cd3727        	bltu	a7, a2, 4200691d <usb_serial_jtag_write+0x15>
    _lock_release_recursive(&s_ctx.write_lock);
4200694f:	e7c0a1        	l32r	a10, 42000850 <_stext+0x830> (3fc921c8 <s_ctx+0x8>)
42006952:	e7c181        	l32r	a8, 42000858 <_stext+0x838> (40376a6c <_lock_release_recursive>)
42006955:	0008e0        	callx8	a8
}
42006958:	f01d      	retw.n
	...

4200695c <usb_serial_jtag_return_char>:
{
4200695c:	004136        	entry	a1, 32
    assert(s_ctx.peek_char == NONE);
4200695f:	e7b281        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
42006962:	0888      	l32i.n	a8, a8, 0
42006964:	110826        	beqi	a8, -1, 42006979 <usb_serial_jtag_return_char+0x1d>
42006967:	e7bdd1        	l32r	a13, 4200085c <_stext+0x83c> (3c024fa8 <_flash_rodata_start+0x4e88>)
4200696a:	e7bdc1        	l32r	a12, 42000860 <_stext+0x840> (3c02857c <__func__$0>)
4200696d:	dfa0b2        	movi	a11, 223
42006970:	e7bda1        	l32r	a10, 42000864 <_stext+0x844> (3c024ff0 <_flash_rodata_start+0x4ed0>)
42006973:	e5d381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42006976:	0008e0        	callx8	a8
    s_ctx.peek_char = c;
42006979:	e7ab81        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
4200697c:	0839      	s32i.n	a3, a8, 0
}
4200697e:	f01d      	retw.n

42006980 <usb_serial_jtag_read>:
{
42006980:	004136        	entry	a1, 32
42006983:	026d      	mov.n	a6, a2
    _lock_acquire_recursive(&s_ctx.read_lock);
42006985:	e7b8a1        	l32r	a10, 42000868 <_stext+0x848> (3fc921c4 <s_ctx+0x4>)
42006988:	e7b381        	l32r	a8, 42000854 <_stext+0x834> (40376a2c <_lock_acquire_recursive>)
4200698b:	0008e0        	callx8	a8
    size_t received = 0;
4200698e:	020c      	movi.n	a2, 0
    while (received < size) {
42006990:	001586        	j	420069ea <usb_serial_jtag_read+0x6a>
42006993:	a66000        	lsi	f0, a0, 0x298
        int c = usb_serial_jtag_read_char(fd);
42006996:	a6a520        	lsi	f2, a5, 0x298
42006999:	ff          	.byte	0xff
4200699a:	0a7d      	mov.n	a7, a10
        if (c == '\r') {
4200699c:	d80c      	movi.n	a8, 13
4200699e:	2e9a87        	bne	a10, a8, 420069d0 <usb_serial_jtag_read+0x50>
            if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CR) {
420069a1:	e7a181        	l32r	a8, 42000828 <_stext+0x808> (3fc921c0 <s_ctx>)
420069a4:	5888      	l32i.n	a8, a8, 20
420069a6:	2c1826        	beqi	a8, 1, 420069d6 <usb_serial_jtag_read+0x56>
            } else if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CRLF) {
420069a9:	38fc      	bnez.n	a8, 420069e0 <usb_serial_jtag_read+0x60>
                int c2 = usb_serial_jtag_read_char(fd);
420069ab:	06ad      	mov.n	a10, a6
420069ad:	ffa525        	call8	42006400 <usb_serial_jtag_read_char>
                if (c2 == NONE) {
420069b0:	0c0a66        	bnei	a10, -1, 420069c0 <usb_serial_jtag_read+0x40>
                    usb_serial_jtag_return_char(fd, c);
420069b3:	20b770        	or	a11, a7, a7
420069b6:	20a660        	or	a10, a6, a6
420069b9:	fffa25        	call8	4200695c <usb_serial_jtag_return_char>
                    break;
420069bc:	000b46        	j	420069ed <usb_serial_jtag_read+0x6d>
420069bf:	9a2600        	trunc.s	a2, f6, 0
                if (c2 == '\n') {
420069c2:	bd1a      	add.n	a11, a13, a1
                    usb_serial_jtag_return_char(fd, c2);
420069c4:	ad0a      	add.n	a10, a13, a0
420069c6:	f96506        	j	42004f5e <esp_mprot_set_monitor_en+0x22>
420069c9:	ff          	.byte	0xff
420069ca:	000486        	j	420069e0 <usb_serial_jtag_read+0x60>
420069cd:	000000        	ill
        } else if (c == NONE) {
420069d0:	0c0a66        	bnei	a10, -1, 420069e0 <usb_serial_jtag_read+0x60>
420069d3:	000586        	j	420069ed <usb_serial_jtag_read+0x6d>
                c = '\n';
420069d6:	a70c      	movi.n	a7, 10
420069d8:	000106        	j	420069e0 <usb_serial_jtag_read+0x60>
420069db:	000000        	ill
                    c = '\n';
420069de:	0a7d      	mov.n	a7, a10
        data_c[received] = (char) c;
420069e0:	832a      	add.n	a8, a3, a2
420069e2:	004872        	s8i	a7, a8, 0
        ++received;
420069e5:	221b      	addi.n	a2, a2, 1
        if (c == '\n') {
420069e7:	029726        	beqi	a7, 10, 420069ed <usb_serial_jtag_read+0x6d>
    while (received < size) {
420069ea:	a63247        	bltu	a2, a4, 42006994 <usb_serial_jtag_read+0x14>
    _lock_release_recursive(&s_ctx.read_lock);
420069ed:	e79ea1        	l32r	a10, 42000868 <_stext+0x848> (3fc921c4 <s_ctx+0x4>)
420069f0:	e79a81        	l32r	a8, 42000858 <_stext+0x838> (40376a6c <_lock_release_recursive>)
420069f3:	0008e0        	callx8	a8
    if (received > 0) {
420069f6:	00a256        	bnez	a2, 42006a04 <usb_serial_jtag_read+0x84>
    errno = EWOULDBLOCK;
420069f9:	059f25        	call8	4200c3ec <__errno>
420069fc:	0ba082        	movi	a8, 11
420069ff:	006a82        	s32i	a8, a10, 0
    return -1;
42006a02:	f27c      	movi.n	a2, -1
}
42006a04:	f01d      	retw.n
	...

42006a08 <esp_vfs_usb_serial_jtag_get_vfs>:
    .termios = &s_vfs_jtag_termios,
#endif // CONFIG_VFS_SUPPORT_TERMIOS
};

const esp_vfs_fs_ops_t* esp_vfs_usb_serial_jtag_get_vfs(void)
{
42006a08:	004136        	entry	a1, 32
    return &s_vfs_jtag;
}
42006a0b:	e79821        	l32r	a2, 4200086c <_stext+0x84c> (3c028598 <s_vfs_jtag>)
42006a0e:	f01d      	retw.n

42006a10 <esp_vfs_dev_usb_serial_jtag_register>:

esp_err_t usb_serial_jtag_vfs_register(void)
{
42006a10:	004136        	entry	a1, 32
    // "/dev/usb_serial_jtag" unfortunately is too long for vfs
    return esp_vfs_register_fs("/dev/usbserjtag", &s_vfs_jtag, ESP_VFS_FLAG_STATIC, NULL);
42006a13:	0d0c      	movi.n	a13, 0
42006a15:	8c0c      	movi.n	a12, 8
42006a17:	e795b1        	l32r	a11, 4200086c <_stext+0x84c> (3c028598 <s_vfs_jtag>)
42006a1a:	e795a1        	l32r	a10, 42000870 <_stext+0x850> (3c025008 <_flash_rodata_start+0x4ee8>)
42006a1d:	004a25        	call8	42006ec0 <esp_vfs_register_fs>
}
42006a20:	0a2d      	mov.n	a2, a10
42006a22:	f01d      	retw.n

42006a24 <__esp_system_init_fn_init_vfs_usj>:

#if CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
ESP_SYSTEM_INIT_FN(init_vfs_usj, CORE, BIT(0), 111)
{
42006a24:	004136        	entry	a1, 32
    usb_serial_jtag_vfs_register();
42006a27:	fffea5        	call8	42006a10 <esp_vfs_dev_usb_serial_jtag_register>
    return ESP_OK;
}
42006a2a:	020c      	movi.n	a2, 0
42006a2c:	f01d      	retw.n
	...

42006a30 <usb_serial_jtag_is_driver_installed>:
    p_usb_serial_jtag_obj = NULL;
    return ESP_OK;
}

bool usb_serial_jtag_is_driver_installed(void)
{
42006a30:	004136        	entry	a1, 32
    return (p_usb_serial_jtag_obj != NULL);
42006a33:	e79081        	l32r	a8, 42000874 <_stext+0x854> (3fc9501c <p_usb_serial_jtag_obj>)
42006a36:	0828      	l32i.n	a2, a8, 0
}
42006a38:	180c      	movi.n	a8, 1
42006a3a:	932820        	movnez	a2, a8, a2
42006a3d:	f01d      	retw.n
	...

42006a40 <usb_serial_jtag_set_select_notif_callback>:

void usb_serial_jtag_set_select_notif_callback(usj_select_notif_callback_t usj_select_notif_callback)
{
42006a40:	004136        	entry	a1, 32
    if (usb_serial_jtag_is_driver_installed()) {
42006a43:	fffee5        	call8	42006a30 <usb_serial_jtag_is_driver_installed>
42006a46:	6a8c      	beqz.n	a10, 42006a50 <usb_serial_jtag_set_select_notif_callback+0x10>
        p_usb_serial_jtag_obj->usj_select_notif_callback = usj_select_notif_callback;
42006a48:	e78b81        	l32r	a8, 42000874 <_stext+0x854> (3fc9501c <p_usb_serial_jtag_obj>)
42006a4b:	0888      	l32i.n	a8, a8, 0
42006a4d:	166822        	s32i	a2, a8, 88
    }
}
42006a50:	f01d      	retw.n
	...

42006a54 <usb_serial_jtag_read_ready>:

bool usb_serial_jtag_read_ready(void)
{
42006a54:	006136        	entry	a1, 48
    // sign the the driver is read ready is that data is waiting in the RX ringbuffer
    UBaseType_t items_waiting = 0;
42006a57:	0b0c      	movi.n	a11, 0
42006a59:	01b9      	s32i.n	a11, a1, 0
    vRingbufferGetInfo(p_usb_serial_jtag_obj->rx_ring_buf, NULL, NULL, NULL, NULL, &items_waiting);
42006a5b:	e78681        	l32r	a8, 42000874 <_stext+0x854> (3fc9501c <p_usb_serial_jtag_obj>)
42006a5e:	0888      	l32i.n	a8, a8, 0
42006a60:	01fd      	mov.n	a15, a1
42006a62:	0bed      	mov.n	a14, a11
42006a64:	0bdd      	mov.n	a13, a11
42006a66:	0bcd      	mov.n	a12, a11
42006a68:	18a8      	l32i.n	a10, a8, 4
42006a6a:	e78381        	l32r	a8, 42000878 <_stext+0x858> (40379520 <vRingbufferGetInfo>)
42006a6d:	0008e0        	callx8	a8
    return items_waiting != 0;
}
42006a70:	0128      	l32i.n	a2, a1, 0
42006a72:	180c      	movi.n	a8, 1
42006a74:	932820        	movnez	a2, a8, a2
42006a77:	f01d      	retw.n
42006a79:	000000        	ill

42006a7c <usb_serial_jtag_write_ready>:

bool usb_serial_jtag_write_ready(void)
{
42006a7c:	004136        	entry	a1, 32
    // sign that the driver is write ready is that the TX ring buffer is not full
    return (xRingbufferGetCurFreeSize(p_usb_serial_jtag_obj->tx_ring_buf) > 0);
42006a7f:	e77d81        	l32r	a8, 42000874 <_stext+0x854> (3fc9501c <p_usb_serial_jtag_obj>)
42006a82:	0888      	l32i.n	a8, a8, 0
42006a84:	28a8      	l32i.n	a10, a8, 8
42006a86:	e77d81        	l32r	a8, 4200087c <_stext+0x85c> (403794f0 <xRingbufferGetCurFreeSize>)
42006a89:	0008e0        	callx8	a8
}
42006a8c:	120c      	movi.n	a2, 1
42006a8e:	832aa0        	moveqz	a2, a10, a10
42006a91:	f01d      	retw.n
	...

42006a94 <console_start_select>:
#endif // CONFIG_VFS_SUPPORT_DIR

#ifdef CONFIG_VFS_SUPPORT_SELECT
static esp_err_t console_start_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
                                      esp_vfs_select_sem_t select_sem, void **end_select_args)
{
42006a94:	008136        	entry	a1, 64
42006a97:	02ad      	mov.n	a10, a2
42006a99:	03bd      	mov.n	a11, a3
42006a9b:	04cd      	mov.n	a12, a4
42006a9d:	05dd      	mov.n	a13, a5
42006a9f:	4169      	s32i.n	a6, a1, 16
42006aa1:	5179      	s32i.n	a7, a1, 20
    // start_select is not guaranteed be implemented even though CONFIG_VFS_SUPPORT_SELECT is enabled in sdkconfig
    if (primary_vfs->select->start_select) {
42006aa3:	e77781        	l32r	a8, 42000880 <_stext+0x860> (3fc9502c <primary_vfs>)
42006aa6:	0888      	l32i.n	a8, a8, 0
42006aa8:	d888      	l32i.n	a8, a8, 52
42006aaa:	0888      	l32i.n	a8, a8, 0
42006aac:	089c      	beqz.n	a8, 42006ac0 <console_start_select+0x2c>
        return primary_vfs->select->start_select(nfds, readfds, writefds, exceptfds, select_sem, end_select_args);
42006aae:	102192        	l32i	a9, a1, 64
42006ab1:	0199      	s32i.n	a9, a1, 0
42006ab3:	06ed      	mov.n	a14, a6
42006ab5:	07fd      	mov.n	a15, a7
42006ab7:	0008e0        	callx8	a8
42006aba:	0a2d      	mov.n	a2, a10
42006abc:	0000c6        	j	42006ac3 <console_start_select+0x2f>
42006abf:	a12200        	sll	a2, a2
    }

    return ESP_ERR_NOT_SUPPORTED;
42006ac2:	f01d06        	j	42002b3a <esp_log_cache_get_level+0x72>
42006ac5:	000000        	ill

42006ac8 <console_end_select>:
}

esp_err_t console_end_select(void *end_select_args)
{
42006ac8:	004136        	entry	a1, 32
42006acb:	02ad      	mov.n	a10, a2
    // end_select is not guaranteed be implemented even though CONFIG_VFS_SUPPORT_SELECT is enabled in sdkconfig
    if (primary_vfs->select->end_select) {
42006acd:	e76c81        	l32r	a8, 42000880 <_stext+0x860> (3fc9502c <primary_vfs>)
42006ad0:	0888      	l32i.n	a8, a8, 0
42006ad2:	d888      	l32i.n	a8, a8, 52
42006ad4:	5888      	l32i.n	a8, a8, 20
42006ad6:	007816        	beqz	a8, 42006ae1 <console_end_select+0x19>
        return primary_vfs->select->end_select(end_select_args);
42006ad9:	0008e0        	callx8	a8
42006adc:	0a2d      	mov.n	a2, a10
42006ade:	000086        	j	42006ae4 <console_end_select+0x1c>
    }

    return ESP_ERR_NOT_SUPPORTED;
42006ae1:	06a122        	movi	a2, 0x106
}
42006ae4:	f01d      	retw.n
	...

42006ae8 <console_open>:
{
42006ae8:	004136        	entry	a1, 32
    if (s_open_count > 0) {
42006aeb:	e76681        	l32r	a8, 42000884 <_stext+0x864> (3fc95020 <s_open_count>)
42006aee:	0888      	l32i.n	a8, a8, 0
42006af0:	888c      	beqz.n	a8, 42006afc <console_open+0x14>
        s_open_count++;
42006af2:	881b      	addi.n	a8, a8, 1
42006af4:	e76491        	l32r	a9, 42000884 <_stext+0x864> (3fc95020 <s_open_count>)
42006af7:	0989      	s32i.n	a8, a9, 0
        return 0;
42006af9:	000686        	j	42006b17 <console_open+0x2f>
    vfs_console.fd_primary = open("/dev/usbserjtag", flags, mode);
42006afc:	20c440        	or	a12, a4, a4
42006aff:	20b330        	or	a11, a3, a3
42006b02:	e761a1        	l32r	a10, 42000888 <_stext+0x868> (3c025008 <_flash_rodata_start+0x4ee8>)
42006b05:	059425        	call8	4200c448 <open>
42006b08:	e76181        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006b0b:	0068a2        	s32i	a10, a8, 0
    s_open_count++;
42006b0e:	e75d91        	l32r	a9, 42000884 <_stext+0x864> (3fc95020 <s_open_count>)
42006b11:	0988      	l32i.n	a8, a9, 0
42006b13:	881b      	addi.n	a8, a8, 1
42006b15:	0989      	s32i.n	a8, a9, 0
}
42006b17:	020c      	movi.n	a2, 0
42006b19:	f01d      	retw.n
	...

42006b1c <console_write>:
{
42006b1c:	004136        	entry	a1, 32
42006b1f:	20b330        	or	a11, a3, a3
42006b22:	202440        	or	a2, a4, a4
    write(vfs_console.fd_primary, data, size);
42006b25:	20c440        	or	a12, a4, a4
42006b28:	e75981        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006b2b:	08a8      	l32i.n	a10, a8, 0
42006b2d:	059825        	call8	4200c4b0 <write>
}
42006b30:	f01d      	retw.n
	...

42006b34 <console_fstat>:
{
42006b34:	004136        	entry	a1, 32
42006b37:	20b330        	or	a11, a3, a3
    return fstat(vfs_console.fd_primary, st);
42006b3a:	e75481        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006b3d:	0028a2        	l32i	a10, a8, 0
42006b40:	ff20a5        	call8	42005d4c <fstat>
}
42006b43:	202aa0        	or	a2, a10, a10
42006b46:	f01d      	retw.n

42006b48 <console_close>:
{
42006b48:	004136        	entry	a1, 32
    if (s_open_count == 0) {
42006b4b:	e74e81        	l32r	a8, 42000884 <_stext+0x864> (3fc95020 <s_open_count>)
42006b4e:	002882        	l32i	a8, a8, 0
42006b51:	00c856        	bnez	a8, 42006b61 <console_close+0x19>
        errno = EBADF;
42006b54:	058965        	call8	4200c3ec <__errno>
42006b57:	09a082        	movi	a8, 9
42006b5a:	0a89      	s32i.n	a8, a10, 0
        return -1;
42006b5c:	f27c      	movi.n	a2, -1
42006b5e:	000686        	j	42006b7c <console_close+0x34>
    s_open_count--;
42006b61:	ffc882        	addi	a8, a8, -1
42006b64:	e74891        	l32r	a9, 42000884 <_stext+0x864> (3fc95020 <s_open_count>)
42006b67:	006982        	s32i	a8, a9, 0
    if (s_open_count > 0) {
42006b6a:	00c856        	bnez	a8, 42006b7a <console_close+0x32>
    close(vfs_console.fd_primary);
42006b6d:	e74781        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006b70:	08a8      	l32i.n	a10, a8, 0
42006b72:	0588a5        	call8	4200c3fc <close>
    return 0;
42006b75:	020c      	movi.n	a2, 0
42006b77:	000046        	j	42006b7c <console_close+0x34>
        return 0;
42006b7a:	020c      	movi.n	a2, 0
}
42006b7c:	f01d      	retw.n
	...

42006b80 <console_read>:
{
42006b80:	004136        	entry	a1, 32
42006b83:	20b330        	or	a11, a3, a3
42006b86:	20c440        	or	a12, a4, a4
    return read(vfs_console.fd_primary, dst, size);
42006b89:	e74081        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006b8c:	0028a2        	l32i	a10, a8, 0
42006b8f:	059065        	call8	4200c494 <read>
}
42006b92:	0a2d      	mov.n	a2, a10
42006b94:	f01d      	retw.n
	...

42006b98 <console_fcntl>:
{
42006b98:	004136        	entry	a1, 32
42006b9b:	20b330        	or	a11, a3, a3
42006b9e:	20c440        	or	a12, a4, a4
    return fcntl(vfs_console.fd_primary, cmd, arg);
42006ba1:	e73a81        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006ba4:	0028a2        	l32i	a10, a8, 0
42006ba7:	0586e5        	call8	4200c414 <fcntl>
}
42006baa:	0a2d      	mov.n	a2, a10
42006bac:	f01d      	retw.n
	...

42006bb0 <console_fsync>:
{
42006bb0:	004136        	entry	a1, 32
    const int ret_val = fsync(vfs_console.fd_primary);
42006bb3:	e73681        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006bb6:	0028a2        	l32i	a10, a8, 0
42006bb9:	008125        	call8	420073cc <esp_vfs_fsync>
}
42006bbc:	202aa0        	or	a2, a10, a10
42006bbf:	000090        	retw
	...

42006bc4 <console_access>:
{
42006bc4:	004136        	entry	a1, 32
42006bc7:	20b330        	or	a11, a3, a3
    return access("/dev/uart/"STRINGIFY(CONFIG_ESP_CONSOLE_UART_NUM), amode);
42006bca:	e731a1        	l32r	a10, 42000890 <_stext+0x870> (3c025018 <_flash_rodata_start+0x4ef8>)
42006bcd:	00a1a5        	call8	420075e8 <access>
}
42006bd0:	202aa0        	or	a2, a10, a10
42006bd3:	000090        	retw
	...

42006bd8 <console_tcsetattr>:
#endif // CONFIG_VFS_SUPPORT_SELECT

#ifdef CONFIG_VFS_SUPPORT_TERMIOS

int console_tcsetattr(int fd, int optional_actions, const struct termios *p)
{
42006bd8:	004136        	entry	a1, 32
42006bdb:	20b330        	or	a11, a3, a3
42006bde:	20c440        	or	a12, a4, a4
    return tcsetattr(vfs_console.fd_primary, optional_actions, p);
42006be1:	e72a81        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006be4:	0028a2        	l32i	a10, a8, 0
42006be7:	00b725        	call8	42007758 <tcsetattr>
}
42006bea:	0a2d      	mov.n	a2, a10
42006bec:	f01d      	retw.n
	...

42006bf0 <console_tcgetattr>:

int console_tcgetattr(int fd, struct termios *p)
{
42006bf0:	004136        	entry	a1, 32
42006bf3:	20b330        	or	a11, a3, a3
    return tcgetattr(vfs_console.fd_primary, p);
42006bf6:	e72581        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006bf9:	0028a2        	l32i	a10, a8, 0
42006bfc:	00ae25        	call8	420076e0 <tcgetattr>
}
42006bff:	202aa0        	or	a2, a10, a10
42006c02:	f01d      	retw.n

42006c04 <console_tcdrain>:

int console_tcdrain(int fd)
{
42006c04:	004136        	entry	a1, 32
    return tcdrain(vfs_console.fd_primary);
42006c07:	e72181        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006c0a:	0028a2        	l32i	a10, a8, 0
42006c0d:	00bc65        	call8	420077d4 <tcdrain>
}
42006c10:	202aa0        	or	a2, a10, a10
42006c13:	000090        	retw
	...

42006c18 <console_tcflush>:

int console_tcflush(int fd, int select)
{
42006c18:	004136        	entry	a1, 32
42006c1b:	20b330        	or	a11, a3, a3
    return tcflush(vfs_console.fd_primary, select);
42006c1e:	e71b81        	l32r	a8, 4200088c <_stext+0x86c> (3fc95024 <vfs_console>)
42006c21:	0028a2        	l32i	a10, a8, 0
42006c24:	00c225        	call8	42007848 <tcflush>
}
42006c27:	202aa0        	or	a2, a10, a10
42006c2a:	f01d      	retw.n

42006c2c <esp_vfs_dev_console_register>:
    .termios = &s_vfs_console_termios,
#endif // CONFIG_VFS_SUPPORT_TERMIOS
};

static esp_err_t esp_vfs_dev_console_register(void)
{
42006c2c:	004136        	entry	a1, 32
    return esp_vfs_register_fs(ESP_VFS_DEV_CONSOLE, &s_vfs_console, ESP_VFS_FLAG_STATIC, NULL);
42006c2f:	0d0c      	movi.n	a13, 0
42006c31:	8c0c      	movi.n	a12, 8
42006c33:	e718b1        	l32r	a11, 42000894 <_stext+0x874> (3c028604 <s_vfs_console>)
42006c36:	e718a1        	l32r	a10, 42000898 <_stext+0x878> (3c024d94 <_flash_rodata_start+0x4c74>)
42006c39:	002865        	call8	42006ec0 <esp_vfs_register_fs>
}
42006c3c:	0a2d      	mov.n	a2, a10
42006c3e:	f01d      	retw.n

42006c40 <esp_vfs_console_register>:

esp_err_t esp_vfs_console_register(void)
{
42006c40:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
// Primary vfs part.
#if CONFIG_ESP_CONSOLE_UART
    primary_vfs = esp_vfs_uart_get_vfs();
#elif CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
    primary_vfs = esp_vfs_usb_serial_jtag_get_vfs();
42006c43:	ffdc65        	call8	42006a08 <esp_vfs_usb_serial_jtag_get_vfs>
42006c46:	e70e81        	l32r	a8, 42000880 <_stext+0x860> (3fc9502c <primary_vfs>)
42006c49:	0068a2        	s32i	a10, a8, 0

// Secondary vfs part.
#if CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG
    secondary_vfs = esp_vfs_usb_serial_jtag_get_vfs();
#endif
    err = esp_vfs_dev_console_register();
42006c4c:	fffde5        	call8	42006c2c <esp_vfs_dev_console_register>
    return err;
}
42006c4f:	202aa0        	or	a2, a10, a10
42006c52:	f01d      	retw.n

42006c54 <__esp_system_init_fn_init_vfs_console>:

ESP_SYSTEM_INIT_FN(init_vfs_console, CORE, BIT(0), 114)
{
42006c54:	004136        	entry	a1, 32
    return esp_vfs_console_register();
42006c57:	fffea5        	call8	42006c40 <esp_vfs_console_register>
}
42006c5a:	0a2d      	mov.n	a2, a10
42006c5c:	f01d      	retw.n
	...

42006c60 <esp_get_free_index>:
static size_t s_vfs_count = 0;

static fd_table_t s_fd_table[MAX_FDS] = { [0 ... MAX_FDS-1] = FD_TABLE_ENTRY_UNUSED };
static _lock_t s_fd_table_lock;

static ssize_t esp_get_free_index(void) {
42006c60:	004136        	entry	a1, 32
    for (ssize_t i = 0; i < VFS_MAX_COUNT; i++) {
42006c63:	020c      	movi.n	a2, 0
42006c65:	0002c6        	j	42006c74 <esp_get_free_index+0x14>
        if (s_vfs[i] == NULL) {
42006c68:	e70d81        	l32r	a8, 4200089c <_stext+0x87c> (3fc95038 <s_vfs>)
42006c6b:	a08280        	addx4	a8, a2, a8
42006c6e:	0888      	l32i.n	a8, a8, 0
42006c70:	588c      	beqz.n	a8, 42006c79 <esp_get_free_index+0x19>
    for (ssize_t i = 0; i < VFS_MAX_COUNT; i++) {
42006c72:	221b      	addi.n	a2, a2, 1
42006c74:	f082a6        	blti	a2, 8, 42006c68 <esp_get_free_index+0x8>
            return i;
        }
    }
    return -1;
42006c77:	f27c      	movi.n	a2, -1
}
42006c79:	f01d      	retw.n
	...

42006c7c <free_proxy_members>:
#ifdef CONFIG_VFS_SUPPORT_SELECT
    esp_vfs_select_ops_t *select;
#endif
} vfs_component_proxy_t;

static void free_proxy_members(vfs_component_proxy_t *proxy) {
42006c7c:	004136        	entry	a1, 32
#ifdef CONFIG_VFS_SUPPORT_DIR
    free(proxy->dir);
42006c7f:	0022a2        	l32i	a10, a2, 0
42006c82:	e63981        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006c85:	0008e0        	callx8	a8
#endif
#ifdef CONFIG_VFS_SUPPORT_TERMIOS
    free(proxy->termios);
42006c88:	12a8      	l32i.n	a10, a2, 4
42006c8a:	e63781        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006c8d:	0008e0        	callx8	a8
#endif
#ifdef CONFIG_VFS_SUPPORT_SELECT
    free(proxy->select);
42006c90:	22a8      	l32i.n	a10, a2, 8
42006c92:	e63581        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006c95:	0008e0        	callx8	a8
#endif
}
42006c98:	f01d      	retw.n
	...

42006c9c <esp_vfs_duplicate_fs_ops>:

    return out;
}


static esp_vfs_fs_ops_t* esp_vfs_duplicate_fs_ops(const esp_vfs_fs_ops_t *orig) {
42006c9c:	00e136        	entry	a1, 112
    vfs_component_proxy_t proxy = {};
42006c9f:	0ca0c2        	movi	a12, 12
42006ca2:	00a0b2        	movi	a11, 0
42006ca5:	20a110        	or	a10, a1, a1
42006ca8:	e59681        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42006cab:	0008e0        	callx8	a8

#ifdef CONFIG_VFS_SUPPORT_DIR
    if (orig->dir != NULL) {
42006cae:	b288      	l32i.n	a8, a2, 44
42006cb0:	a89c      	beqz.n	a8, 42006cce <esp_vfs_duplicate_fs_ops+0x32>
        proxy.dir = (esp_vfs_dir_ops_t*) heap_caps_malloc(sizeof(esp_vfs_dir_ops_t), VFS_MALLOC_FLAGS);
42006cb2:	e6e1b1        	l32r	a11, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
42006cb5:	40a0a2        	movi	a10, 64
42006cb8:	e61a81        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006cbb:	0008e0        	callx8	a8
42006cbe:	01a9      	s32i.n	a10, a1, 0
        if (proxy.dir == NULL) {
42006cc0:	09fa16        	beqz	a10, 42006d63 <esp_vfs_duplicate_fs_ops+0xc7>
            goto fail;
        }
        memcpy(proxy.dir, orig->dir, sizeof(esp_vfs_dir_ops_t));
42006cc3:	0c4c      	movi.n	a12, 64
42006cc5:	0b22b2        	l32i	a11, a2, 44
42006cc8:	e4d881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42006ccb:	0008e0        	callx8	a8
    }
#endif

#ifdef CONFIG_VFS_SUPPORT_TERMIOS
    if (orig->termios != NULL) {
42006cce:	c288      	l32i.n	a8, a2, 48
42006cd0:	a89c      	beqz.n	a8, 42006cee <esp_vfs_duplicate_fs_ops+0x52>
        proxy.termios = (esp_vfs_termios_ops_t*) heap_caps_malloc(sizeof(esp_vfs_termios_ops_t), VFS_MALLOC_FLAGS);
42006cd2:	e6d9b1        	l32r	a11, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
42006cd5:	1ca0a2        	movi	a10, 28
42006cd8:	e61281        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006cdb:	0008e0        	callx8	a8
42006cde:	11a9      	s32i.n	a10, a1, 4
        if (proxy.termios == NULL) {
42006ce0:	07fa16        	beqz	a10, 42006d63 <esp_vfs_duplicate_fs_ops+0xc7>
            goto fail;
        }
        memcpy(proxy.termios, orig->termios, sizeof(esp_vfs_termios_ops_t));
42006ce3:	cc1c      	movi.n	a12, 28
42006ce5:	0c22b2        	l32i	a11, a2, 48
42006ce8:	e4d081        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42006ceb:	0008e0        	callx8	a8
    }
#endif

#ifdef CONFIG_VFS_SUPPORT_SELECT
    if (orig->select != NULL) {
42006cee:	d288      	l32i.n	a8, a2, 52
42006cf0:	889c      	beqz.n	a8, 42006d0c <esp_vfs_duplicate_fs_ops+0x70>
        proxy.select = (esp_vfs_select_ops_t*) heap_caps_malloc(sizeof(esp_vfs_select_ops_t), VFS_MALLOC_FLAGS);
42006cf2:	e6d1b1        	l32r	a11, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
42006cf5:	8a1c      	movi.n	a10, 24
42006cf7:	e60a81        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006cfa:	0008e0        	callx8	a8
42006cfd:	21a9      	s32i.n	a10, a1, 8
        if (proxy.select == NULL) {
42006cff:	060a16        	beqz	a10, 42006d63 <esp_vfs_duplicate_fs_ops+0xc7>
            goto fail;
        }
        memcpy(proxy.select, orig->select, sizeof(esp_vfs_select_ops_t));
42006d02:	8c1c      	movi.n	a12, 24
42006d04:	d2b8      	l32i.n	a11, a2, 52
42006d06:	e4c881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42006d09:	0008e0        	callx8	a8
    }
#endif

    // This tediousness is required because of const members
    esp_vfs_fs_ops_t tmp = {
        .write = orig->write,
42006d0c:	0288      	l32i.n	a8, a2, 0
    esp_vfs_fs_ops_t tmp = {
42006d0e:	3189      	s32i.n	a8, a1, 12
        .lseek = orig->lseek,
42006d10:	1288      	l32i.n	a8, a2, 4
    esp_vfs_fs_ops_t tmp = {
42006d12:	4189      	s32i.n	a8, a1, 16
        .read = orig->read,
42006d14:	2288      	l32i.n	a8, a2, 8
    esp_vfs_fs_ops_t tmp = {
42006d16:	5189      	s32i.n	a8, a1, 20
        .pread = orig->pread,
42006d18:	3288      	l32i.n	a8, a2, 12
    esp_vfs_fs_ops_t tmp = {
42006d1a:	6189      	s32i.n	a8, a1, 24
        .pwrite = orig->pwrite,
42006d1c:	4288      	l32i.n	a8, a2, 16
    esp_vfs_fs_ops_t tmp = {
42006d1e:	7189      	s32i.n	a8, a1, 28
        .open = orig->open,
42006d20:	5288      	l32i.n	a8, a2, 20
    esp_vfs_fs_ops_t tmp = {
42006d22:	8189      	s32i.n	a8, a1, 32
        .close = orig->close,
42006d24:	6288      	l32i.n	a8, a2, 24
    esp_vfs_fs_ops_t tmp = {
42006d26:	9189      	s32i.n	a8, a1, 36
        .fstat = orig->fstat,
42006d28:	7288      	l32i.n	a8, a2, 28
    esp_vfs_fs_ops_t tmp = {
42006d2a:	a189      	s32i.n	a8, a1, 40
        .fcntl = orig->fcntl,
42006d2c:	8288      	l32i.n	a8, a2, 32
    esp_vfs_fs_ops_t tmp = {
42006d2e:	b189      	s32i.n	a8, a1, 44
        .ioctl = orig->ioctl,
42006d30:	9288      	l32i.n	a8, a2, 36
    esp_vfs_fs_ops_t tmp = {
42006d32:	c189      	s32i.n	a8, a1, 48
        .fsync = orig->fsync,
42006d34:	a288      	l32i.n	a8, a2, 40
    esp_vfs_fs_ops_t tmp = {
42006d36:	d189      	s32i.n	a8, a1, 52
#ifdef CONFIG_VFS_SUPPORT_DIR
        .dir = proxy.dir,
42006d38:	0188      	l32i.n	a8, a1, 0
    esp_vfs_fs_ops_t tmp = {
42006d3a:	e189      	s32i.n	a8, a1, 56
#endif
#ifdef CONFIG_VFS_SUPPORT_TERMIOS
        .termios = proxy.termios,
42006d3c:	1188      	l32i.n	a8, a1, 4
    esp_vfs_fs_ops_t tmp = {
42006d3e:	f189      	s32i.n	a8, a1, 60
#endif
#ifdef CONFIG_VFS_SUPPORT_SELECT
        .select = proxy.select,
42006d40:	022182        	l32i	a8, a1, 8
    esp_vfs_fs_ops_t tmp = {
42006d43:	106182        	s32i	a8, a1, 64
#endif
    };

    esp_vfs_fs_ops_t *out = heap_caps_malloc(sizeof(esp_vfs_fs_ops_t), VFS_MALLOC_FLAGS);
42006d46:	e6bcb1        	l32r	a11, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
42006d49:	38a0a2        	movi	a10, 56
42006d4c:	e5f581        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006d4f:	0008e0        	callx8	a8
42006d52:	0a2d      	mov.n	a2, a10
    if (out == NULL) {
42006d54:	ba8c      	beqz.n	a10, 42006d63 <esp_vfs_duplicate_fs_ops+0xc7>
        goto fail;
    }

    memcpy(out, &tmp, sizeof(esp_vfs_fs_ops_t));
42006d56:	8c3c      	movi.n	a12, 56
42006d58:	b1cb      	addi.n	a11, a1, 12
42006d5a:	e4b381        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42006d5d:	0008e0        	callx8	a8

    return out;
42006d60:	000206        	j	42006d6c <esp_vfs_duplicate_fs_ops+0xd0>

fail:
    free_proxy_members(&proxy);
42006d63:	20a110        	or	a10, a1, a1
42006d66:	fff165        	call8	42006c7c <free_proxy_members>
    return NULL;
42006d69:	00a022        	movi	a2, 0
}
42006d6c:	000090        	retw
	...

42006d70 <esp_vfs_free_fs_ops>:
static void esp_vfs_free_fs_ops(esp_vfs_fs_ops_t *vfs) {
42006d70:	004136        	entry	a1, 32
    free((void*)vfs->termios);
42006d73:	0c22a2        	l32i	a10, a2, 48
42006d76:	e5fc81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006d79:	0008e0        	callx8	a8
    free((void*)vfs->dir);
42006d7c:	b2a8      	l32i.n	a10, a2, 44
42006d7e:	e5fa81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006d81:	0008e0        	callx8	a8
    free((void*)vfs->select);
42006d84:	d2a8      	l32i.n	a10, a2, 52
42006d86:	e5f881        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006d89:	0008e0        	callx8	a8
    free(vfs);
42006d8c:	02ad      	mov.n	a10, a2
42006d8e:	e5f681        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42006d91:	0008e0        	callx8	a8
}
42006d94:	f01d      	retw.n
	...

42006d98 <esp_vfs_register_fs_common>:
    free_proxy_members(&proxy);
    return ESP_ERR_NO_MEM;
}

static esp_err_t esp_vfs_register_fs_common(const char* base_path, size_t len, const esp_vfs_fs_ops_t* vfs, int flags, void* ctx, int *vfs_index)
{
42006d98:	006136        	entry	a1, 48
42006d9b:	0159      	s32i.n	a5, a1, 0
42006d9d:	1169      	s32i.n	a6, a1, 4
42006d9f:	2179      	s32i.n	a7, a1, 8
    if (vfs == NULL) {
42006da1:	0a7416        	beqz	a4, 42006e4c <esp_vfs_register_fs_common+0xb4>
        ESP_LOGE(TAG, "VFS is NULL");
        return ESP_ERR_INVALID_ARG;
    }

    if (len != LEN_PATH_PREFIX_IGNORED) {
42006da4:	300326        	beqi	a3, -1, 42006dd8 <esp_vfs_register_fs_common+0x40>
        /* empty prefix is allowed, "/" is not allowed */
        if ((len == 1) || (len > ESP_VFS_PATH_MAX)) {
42006da7:	830b      	addi.n	a8, a3, -1
42006da9:	40f880        	nsau	a8, a8
42006dac:	418580        	srli	a8, a8, 5
42006daf:	f90c      	movi.n	a9, 15
42006db1:	629930        	lsi	f3, a9, 0x188
42006db4:	208890        	or	a8, a8, a9
42006db7:	099856        	bnez	a8, 42006e54 <esp_vfs_register_fs_common+0xbc>
            return ESP_ERR_INVALID_ARG;
        }
        /* prefix has to start with "/" and not end with "/" */
        if (len >= 2 && ((base_path[0] != '/') || (base_path[len - 1] == '/'))) {
42006dba:	1a23b6        	bltui	a3, 2, 42006dd8 <esp_vfs_register_fs_common+0x40>
42006dbd:	000292        	l8ui	a9, a2, 0
42006dc0:	f82c      	movi.n	a8, 47
42006dc2:	021987        	beq	a9, a8, 42006dc8 <esp_vfs_register_fs_common+0x30>
42006dc5:	0024c6        	j	42006e5c <esp_vfs_register_fs_common+0xc4>
42006dc8:	823a      	add.n	a8, a2, a3
42006dca:	ffc882        	addi	a8, a8, -1
42006dcd:	000892        	l8ui	a9, a8, 0
42006dd0:	f82c      	movi.n	a8, 47
42006dd2:	029987        	bne	a9, a8, 42006dd8 <esp_vfs_register_fs_common+0x40>
42006dd5:	0022c6        	j	42006e64 <esp_vfs_register_fs_common+0xcc>
            return ESP_ERR_INVALID_ARG;
        }
    }

    ssize_t index = esp_get_free_index();
42006dd8:	ffe865        	call8	42006c60 <esp_get_free_index>
42006ddb:	206aa0        	or	a6, a10, a10
    if (index < 0) {
42006dde:	08aa96        	bltz	a10, 42006e6c <esp_vfs_register_fs_common+0xd4>
        return ESP_ERR_NO_MEM;
    }

    if (s_vfs[index] != NULL) {
42006de1:	e6ae81        	l32r	a8, 4200089c <_stext+0x87c> (3fc95038 <s_vfs>)
42006de4:	a08a80        	addx4	a8, a10, a8
42006de7:	002882        	l32i	a8, a8, 0
42006dea:	086856        	bnez	a8, 42006e74 <esp_vfs_register_fs_common+0xdc>
        return ESP_ERR_INVALID_STATE;
    }

    if (index == s_vfs_count) {
42006ded:	e6ac81        	l32r	a8, 420008a0 <_stext+0x880> (3fc95034 <s_vfs_count>)
42006df0:	002882        	l32i	a8, a8, 0
42006df3:	069a87        	bne	a10, a8, 42006dfd <esp_vfs_register_fs_common+0x65>
        s_vfs_count++;
42006df6:	881b      	addi.n	a8, a8, 1
42006df8:	e6aa91        	l32r	a9, 420008a0 <_stext+0x880> (3fc95034 <s_vfs_count>)
42006dfb:	0989      	s32i.n	a8, a9, 0
    }

    vfs_entry_t *entry = (vfs_entry_t*) heap_caps_malloc(sizeof(vfs_entry_t), VFS_MALLOC_FLAGS);
42006dfd:	e68eb1        	l32r	a11, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
42006e00:	4a2c      	movi.n	a10, 36
42006e02:	e5c781        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006e05:	0008e0        	callx8	a8
42006e08:	0a5d      	mov.n	a5, a10
    if (entry == NULL) {
42006e0a:	06ca16        	beqz	a10, 42006e7a <esp_vfs_register_fs_common+0xe2>
        return ESP_ERR_NO_MEM;
    }

    s_vfs[index] = entry;
42006e0d:	e6a381        	l32r	a8, 4200089c <_stext+0x87c> (3fc95038 <s_vfs>)
42006e10:	a08680        	addx4	a8, a6, a8
42006e13:	08a9      	s32i.n	a10, a8, 0
    if (len != LEN_PATH_PREFIX_IGNORED) {
42006e15:	0f0326        	beqi	a3, -1, 42006e28 <esp_vfs_register_fs_common+0x90>
        strcpy(entry->path_prefix, base_path); // we have already verified argument length
42006e18:	20b220        	or	a11, a2, a2
42006e1b:	08caa2        	addi	a10, a10, 8
42006e1e:	e6a181        	l32r	a8, 420008a4 <_stext+0x884> (40001218 <strcpy>)
42006e21:	0008e0        	callx8	a8
42006e24:	000286        	j	42006e32 <esp_vfs_register_fs_common+0x9a>
42006e27:	fb0c00        	f64addc	a0, a12, 0, 0
    } else {
        bzero(entry->path_prefix, sizeof(entry->path_prefix));
42006e2a:	aa8b      	addi.n	a10, a10, 8
42006e2c:	e69f81        	l32r	a8, 420008a8 <_stext+0x888> (40001260 <bzero>)
42006e2f:	0008e0        	callx8	a8
    }
    entry->path_prefix_len = len;
42006e32:	6539      	s32i.n	a3, a5, 24
    entry->vfs = vfs;
42006e34:	1549      	s32i.n	a4, a5, 4
    entry->ctx = ctx;
42006e36:	1188      	l32i.n	a8, a1, 4
42006e38:	7589      	s32i.n	a8, a5, 28
    entry->offset = index;
42006e3a:	8569      	s32i.n	a6, a5, 32
    entry->flags = flags;
42006e3c:	0188      	l32i.n	a8, a1, 0
42006e3e:	0589      	s32i.n	a8, a5, 0

    if (vfs_index) {
42006e40:	2188      	l32i.n	a8, a1, 8
42006e42:	a8bc      	beqz.n	a8, 42006e80 <esp_vfs_register_fs_common+0xe8>
        *vfs_index = index;
42006e44:	0769      	s32i.n	a6, a7, 0
    }

    return ESP_OK;
42006e46:	020c      	movi.n	a2, 0
42006e48:	000d86        	j	42006e82 <esp_vfs_register_fs_common+0xea>
42006e4b:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42006e4e:	0bc602        	addi	a0, a6, 11
42006e51:	000000        	ill
            return ESP_ERR_INVALID_ARG;
42006e54:	02a122        	movi	a2, 0x102
42006e57:	0009c6        	j	42006e82 <esp_vfs_register_fs_common+0xea>
42006e5a:	220000        	orb	b0, b0, b0
            return ESP_ERR_INVALID_ARG;
42006e5d:	c602a1        	l32r	a10, 41ff8668 <_coredump_iram_end+0x1c76668>
42006e60:	000007        	bnone	a0, a0, 42006e64 <esp_vfs_register_fs_common+0xcc>
42006e63:	a12200        	sll	a2, a2
42006e66:	05c602        	addi	a0, a6, 5
42006e69:	000000        	ill
        return ESP_ERR_NO_MEM;
42006e6c:	01a122        	movi	a2, 0x101
42006e6f:	0003c6        	j	42006e82 <esp_vfs_register_fs_common+0xea>
42006e72:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_STATE;
42006e75:	c603a1        	l32r	a10, 41ff8684 <_coredump_iram_end+0x1c76684>
42006e78:	220001        	l32r	a0, 41fcf678 <_coredump_iram_end+0x1c4d678>
        return ESP_ERR_NO_MEM;
42006e7b:	4601a1        	l32r	a10, 41fd8680 <_coredump_iram_end+0x1c56680>
42006e7e:	0c0000        	lsi	f0, a0, 48
    return ESP_OK;
42006e81:	f01d02        	l16ui	a0, a13, 0x1e0

42006e84 <translate_path>:

    return local_fd;
}

static const char* translate_path(const vfs_entry_t* vfs, const char* src_path)
{
42006e84:	004136        	entry	a1, 32
    assert(strncmp(src_path, vfs->path_prefix, vfs->path_prefix_len) == 0);
42006e87:	6278      	l32i.n	a7, a2, 24
42006e89:	07cd      	mov.n	a12, a7
42006e8b:	b28b      	addi.n	a11, a2, 8
42006e8d:	03ad      	mov.n	a10, a3
42006e8f:	e68b81        	l32r	a8, 420008bc <_stext+0x89c> (4000123c <strncmp>)
42006e92:	0008e0        	callx8	a8
42006e95:	0a9c      	beqz.n	a10, 42006ea9 <translate_path+0x25>
42006e97:	e686d1        	l32r	a13, 420008b0 <_stext+0x890> (3c025054 <_flash_rodata_start+0x4f34>)
42006e9a:	e686c1        	l32r	a12, 420008b4 <_stext+0x894> (3c0286b0 <__func__$1>)
42006e9d:	fca2b2        	movi	a11, 0x2fc
42006ea0:	e686a1        	l32r	a10, 420008b8 <_stext+0x898> (3c025049 <_flash_rodata_start+0x4f29>)
42006ea3:	e48781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42006ea6:	0008e0        	callx8	a8
    if (strlen(src_path) == vfs->path_prefix_len) {
42006ea9:	03ad      	mov.n	a10, a3
42006eab:	e4fc81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006eae:	0008e0        	callx8	a8
42006eb1:	0417a7        	beq	a7, a10, 42006eb9 <translate_path+0x35>
        // special case when src_path matches the path prefix exactly
        return "/";
    }
    return src_path + vfs->path_prefix_len;
42006eb4:	237a      	add.n	a2, a3, a7
42006eb6:	000086        	j	42006ebc <translate_path+0x38>
        return "/";
42006eb9:	e67c21        	l32r	a2, 420008ac <_stext+0x88c> (3c025050 <_flash_rodata_start+0x4f30>)
}
42006ebc:	f01d      	retw.n
	...

42006ec0 <esp_vfs_register_fs>:
{
42006ec0:	004136        	entry	a1, 32
    if (vfs == NULL) {
42006ec3:	04c316        	beqz	a3, 42006f13 <esp_vfs_register_fs+0x53>
    if ((flags & ESP_VFS_FLAG_STATIC)) {
42006ec6:	1c6437        	bbci	a4, 3, 42006ee6 <esp_vfs_register_fs+0x26>
        return esp_vfs_register_fs_common(base_path, strlen(base_path), vfs, flags, ctx, NULL);
42006ec9:	02ad      	mov.n	a10, a2
42006ecb:	e4f481        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006ece:	0008e0        	callx8	a8
42006ed1:	0f0c      	movi.n	a15, 0
42006ed3:	05ed      	mov.n	a14, a5
42006ed5:	04dd      	mov.n	a13, a4
42006ed7:	03cd      	mov.n	a12, a3
42006ed9:	0abd      	mov.n	a11, a10
42006edb:	02ad      	mov.n	a10, a2
42006edd:	ffeba5        	call8	42006d98 <esp_vfs_register_fs_common>
42006ee0:	0a2d      	mov.n	a2, a10
42006ee2:	000d86        	j	42006f1c <esp_vfs_register_fs+0x5c>
42006ee5:	a33000        	movltz	a3, a0, a0
    esp_vfs_fs_ops_t *_vfs = esp_vfs_duplicate_fs_ops(vfs);
42006ee8:	db2520        	movt.s	f2, f5, b2
42006eeb:	ff          	.byte	0xff
42006eec:	0a3d      	mov.n	a3, a10
    if (_vfs == NULL) {
42006eee:	7aac      	beqz.n	a10, 42006f19 <esp_vfs_register_fs+0x59>
    esp_err_t ret = esp_vfs_register_fs_common(base_path, strlen(base_path), _vfs, flags, ctx, NULL);
42006ef0:	02ad      	mov.n	a10, a2
42006ef2:	e4ea81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006ef5:	0008e0        	callx8	a8
42006ef8:	0f0c      	movi.n	a15, 0
42006efa:	05ed      	mov.n	a14, a5
42006efc:	04dd      	mov.n	a13, a4
42006efe:	03cd      	mov.n	a12, a3
42006f00:	0abd      	mov.n	a11, a10
42006f02:	02ad      	mov.n	a10, a2
42006f04:	ffe925        	call8	42006d98 <esp_vfs_register_fs_common>
42006f07:	0a2d      	mov.n	a2, a10
    if (ret != ESP_OK) {
42006f09:	fa8c      	beqz.n	a10, 42006f1c <esp_vfs_register_fs+0x5c>
        esp_vfs_free_fs_ops(_vfs);
42006f0b:	03ad      	mov.n	a10, a3
42006f0d:	ffe625        	call8	42006d70 <esp_vfs_free_fs_ops>
        return ret;
42006f10:	000206        	j	42006f1c <esp_vfs_register_fs+0x5c>
        return ESP_ERR_INVALID_ARG;
42006f13:	02a122        	movi	a2, 0x102
42006f16:	000086        	j	42006f1c <esp_vfs_register_fs+0x5c>
        return ESP_ERR_NO_MEM;
42006f19:	01a122        	movi	a2, 0x101
}
42006f1c:	f01d      	retw.n
	...

42006f20 <get_vfs_for_index>:
{
42006f20:	004136        	entry	a1, 32
    if (index < 0 || index >= s_vfs_count) {
42006f23:	012296        	bltz	a2, 42006f39 <get_vfs_for_index+0x19>
42006f26:	e65e81        	l32r	a8, 420008a0 <_stext+0x880> (3fc95034 <s_vfs_count>)
42006f29:	0888      	l32i.n	a8, a8, 0
42006f2b:	0fb287        	bgeu	a2, a8, 42006f3e <get_vfs_for_index+0x1e>
        return s_vfs[index];
42006f2e:	e65b81        	l32r	a8, 4200089c <_stext+0x87c> (3fc95038 <s_vfs>)
42006f31:	a02280        	addx4	a2, a2, a8
42006f34:	0228      	l32i.n	a2, a2, 0
42006f36:	000186        	j	42006f40 <get_vfs_for_index+0x20>
        return NULL;
42006f39:	020c      	movi.n	a2, 0
42006f3b:	000046        	j	42006f40 <get_vfs_for_index+0x20>
42006f3e:	020c      	movi.n	a2, 0
}
42006f40:	f01d      	retw.n
	...

42006f44 <get_vfs_for_fd>:
{
42006f44:	004136        	entry	a1, 32
    if (fd_valid(fd)) {
42006f47:	3fa082        	movi	a8, 63
42006f4a:	173827        	bltu	a8, a2, 42006f65 <get_vfs_for_fd+0x21>
        const int index = s_fd_table[fd].vfs_index; // single read -> no locking is required
42006f4d:	902220        	addx2	a2, a2, a2
42006f50:	e65c81        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
42006f53:	808820        	add	a8, a8, a2
42006f56:	0108a2        	l8ui	a10, a8, 1
        vfs = get_vfs_for_index(index);
42006f59:	23aa00        	sext	a10, a10, 7
42006f5c:	fffc25        	call8	42006f20 <get_vfs_for_index>
42006f5f:	202aa0        	or	a2, a10, a10
42006f62:	000046        	j	42006f67 <get_vfs_for_fd+0x23>
    const vfs_entry_t *vfs = NULL;
42006f65:	020c      	movi.n	a2, 0
}
42006f67:	f01d      	retw.n
42006f69:	000000        	ill

42006f6c <get_vfs_for_path>:

const vfs_entry_t* get_vfs_for_path(const char* path)
{
42006f6c:	006136        	entry	a1, 48
42006f6f:	023d      	mov.n	a3, a2
    const vfs_entry_t* best_match = NULL;
    ssize_t best_match_prefix_len = -1;
    size_t len = strlen(path);
42006f71:	02ad      	mov.n	a10, a2
42006f73:	e4ca81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006f76:	0008e0        	callx8	a8
42006f79:	0a4d      	mov.n	a4, a10
    for (size_t i = 0; i < s_vfs_count; ++i) {
42006f7b:	070c      	movi.n	a7, 0
    ssize_t best_match_prefix_len = -1;
42006f7d:	f87c      	movi.n	a8, -1
42006f7f:	0189      	s32i.n	a8, a1, 0
    const vfs_entry_t* best_match = NULL;
42006f81:	072d      	mov.n	a2, a7
    for (size_t i = 0; i < s_vfs_count; ++i) {
42006f83:	001146        	j	42006fcc <get_vfs_for_path+0x60>
42006f86:	810000        	src	a0, a0, a0
        const vfs_entry_t* vfs = s_vfs[i];
42006f89:	80e645        	call0	41f87df0 <_coredump_iram_end+0x1c05df0>
42006f8c:	58a087        	bge	a0, a8, 42006fe8 <_open_r+0x10>
42006f8f:	bc08      	l32i.n	a0, a12, 44
        if (vfs == NULL || vfs->path_prefix_len == LEN_PATH_PREFIX_IGNORED) {
42006f91:	656865        	call8	4206c618 <_etext+0x553da>
42006f94:	320626        	beqi	a6, -1, 42006fca <get_vfs_for_path+0x5e>
            continue;
        }
        // match path prefix
        if (len < vfs->path_prefix_len ||
42006f97:	2f3467        	bltu	a4, a6, 42006fca <get_vfs_for_path+0x5e>
            memcmp(path, vfs->path_prefix, vfs->path_prefix_len) != 0) {
42006f9a:	06cd      	mov.n	a12, a6
42006f9c:	b58b      	addi.n	a11, a5, 8
42006f9e:	03ad      	mov.n	a10, a3
42006fa0:	e64981        	l32r	a8, 420008c4 <_stext+0x8a4> (4000120c <memcmp>)
42006fa3:	0008e0        	callx8	a8
        if (len < vfs->path_prefix_len ||
42006fa6:	0aec      	bnez.n	a10, 42006fca <get_vfs_for_path+0x5e>
            continue;
        }
        // this is the default VFS and we don't have a better match yet.
        if (vfs->path_prefix_len == 0 && !best_match) {
42006fa8:	06cc      	bnez.n	a6, 42006fac <get_vfs_for_path+0x40>
42006faa:	329c      	beqz.n	a2, 42006fc1 <get_vfs_for_path+0x55>
            best_match = vfs;
            continue;
        }
        // if path is not equal to the prefix, expect to see a path separator
        // i.e. don't match "/data" prefix for "/data1/foo.txt" path
        if (len > vfs->path_prefix_len &&
42006fac:	09b647        	bgeu	a6, a4, 42006fb9 <get_vfs_for_path+0x4d>
                path[vfs->path_prefix_len] != '/') {
42006faf:	836a      	add.n	a8, a3, a6
42006fb1:	000892        	l8ui	a9, a8, 0
        if (len > vfs->path_prefix_len &&
42006fb4:	f82c      	movi.n	a8, 47
42006fb6:	109987        	bne	a9, a8, 42006fca <get_vfs_for_path+0x5e>
        // i.e. if "/dev" and "/dev/uart" both match, for "/dev/uart/1" path,
        // choose "/dev/uart",
        // This causes all s_vfs_count VFS entries to be scanned when opening
        // a file by name. This can be optimized by introducing a table for
        // FS search order, sorted so that longer prefixes are checked first.
        if (best_match_prefix_len < (ssize_t) vfs->path_prefix_len) {
42006fb9:	0188      	l32i.n	a8, a1, 0
42006fbb:	072867        	blt	a8, a6, 42006fc6 <get_vfs_for_path+0x5a>
42006fbe:	000206        	j	42006fca <get_vfs_for_path+0x5e>
            best_match = vfs;
42006fc1:	052d      	mov.n	a2, a5
42006fc3:	0000c6        	j	42006fca <get_vfs_for_path+0x5e>
            best_match_prefix_len = (ssize_t) vfs->path_prefix_len;
42006fc6:	0169      	s32i.n	a6, a1, 0
            best_match = vfs;
42006fc8:	052d      	mov.n	a2, a5
    for (size_t i = 0; i < s_vfs_count; ++i) {
42006fca:	771b      	addi.n	a7, a7, 1
42006fcc:	e63581        	l32r	a8, 420008a0 <_stext+0x880> (3fc95034 <s_vfs_count>)
42006fcf:	0888      	l32i.n	a8, a8, 0
42006fd1:	b33787        	bltu	a7, a8, 42006f88 <get_vfs_for_path+0x1c>
        }
    }
    return best_match;
}
42006fd4:	f01d      	retw.n
	...

42006fd8 <_open_r>:
        __errno_r(r) = EROFS; \
        return -1; \
    }

int esp_vfs_open(struct _reent *r, const char * path, int flags, int mode)
{
42006fd8:	004136        	entry	a1, 32
42006fdb:	207220        	or	a7, a2, a2
    const vfs_entry_t *vfs = get_vfs_for_path(path);
42006fde:	20a330        	or	a10, a3, a3
42006fe1:	fff8a5        	call8	42006f6c <get_vfs_for_path>
42006fe4:	206aa0        	or	a6, a10, a10
    if (vfs == NULL) {
42006fe7:	9acc      	bnez.n	a10, 42006ff4 <_open_r+0x1c>
        __errno_r(r) = ENOENT;
42006fe9:	280c      	movi.n	a8, 2
42006feb:	0289      	s32i.n	a8, a2, 0
        return -1;
42006fed:	f27c      	movi.n	a2, -1
42006fef:	003946        	j	420070d8 <_open_r+0x100>
42006ff2:	400000        	ssr	a0
    }

    int acc_mode = flags & O_ACCMODE;
42006ff5:	281480        	lsi	f8, a4, 160
    int ro_filesystem = vfs->flags & ESP_VFS_FLAG_READONLY_FS;
42006ff8:	0c0a      	add.n	a0, a12, a0
    if (acc_mode != O_RDONLY && ro_filesystem) {
42006ffa:	8019      	s32i.n	a1, a0, 32
42006ffc:	8398      	l32i.n	a9, a3, 32
42006ffe:	048220        	extui	a8, a2, 2, 1
42007001:	080987        	bnone	a9, a8, 4200700d <_open_r+0x35>
        __errno_r(r) = EROFS;
42007004:	e81c      	movi.n	a8, 30
42007006:	0789      	s32i.n	a8, a7, 0
        return -1;
42007008:	f27c      	movi.n	a2, -1
4200700a:	003286        	j	420070d8 <_open_r+0x100>
    }

    const char *path_within_vfs = translate_path(vfs, path);
4200700d:	20b330        	or	a11, a3, a3
42007010:	ffe725        	call8	42006e84 <translate_path>
    int fd_within_vfs;
    CHECK_AND_CALL(fd_within_vfs, r, vfs, open, path_within_vfs, flags, mode);
42007013:	012682        	l32i	a8, a6, 4
42007016:	052882        	l32i	a8, a8, 20
42007019:	78cc      	bnez.n	a8, 42007024 <_open_r+0x4c>
4200701b:	885c      	movi.n	a8, 88
4200701d:	0789      	s32i.n	a8, a7, 0
4200701f:	f27c      	movi.n	a2, -1
42007021:	002cc6        	j	420070d8 <_open_r+0x100>
42007024:	116217        	bbci	a2, 1, 42007039 <_open_r+0x61>
42007027:	05dd      	mov.n	a13, a5
42007029:	04cd      	mov.n	a12, a4
4200702b:	0abd      	mov.n	a11, a10
4200702d:	76a8      	l32i.n	a10, a6, 28
4200702f:	0008e0        	callx8	a8
42007032:	0a5d      	mov.n	a5, a10
42007034:	000286        	j	42007042 <_open_r+0x6a>
42007037:	cd0000        	lsi	f0, a0, 0x334
4200703a:	04bd05        	call0	4200bc0c <__sfvwrite_r+0x108>
4200703d:	0008e0        	callx8	a8
42007040:	0a5d      	mov.n	a5, a10
    if (fd_within_vfs >= 0) {
42007042:	086596        	bltz	a5, 420070cc <_open_r+0xf4>
        _lock_acquire(&s_fd_table_lock);
42007045:	e620a1        	l32r	a10, 420008c8 <_stext+0x8a8> (3fc95030 <s_fd_table_lock>)
42007048:	e5bf81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
4200704b:	0008e0        	callx8	a8
        for (int i = 0; i < MAX_FDS; ++i) {
4200704e:	020c      	movi.n	a2, 0
42007050:	000e86        	j	4200708e <_open_r+0xb6>
42007053:	922000        	lsi	f0, a0, 0x248
            if (s_fd_table[i].vfs_index == -1) {
42007056:	1a8190        	sub.s	f8, f1, f9
42007059:	889ae6        	bgei	a10, 10, 42006fe5 <_open_r+0xd>
4200705c:	010882        	l8ui	a8, a8, 1
4200705f:	238800        	sext	a8, a8, 7
42007062:	260866        	bnei	a8, -1, 4200708c <_open_r+0xb4>
                s_fd_table[i].permanent = false;
42007065:	e61681        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
42007068:	889a      	add.n	a8, a8, a9
4200706a:	000892        	l8ui	a9, a8, 0
4200706d:	feafa2        	movi	a10, -2
42007070:	1099a0        	and	a9, a9, a10
42007073:	004892        	s8i	a9, a8, 0
                s_fd_table[i].vfs_index = vfs->offset;
42007076:	082692        	l32i	a9, a6, 32
42007079:	014892        	s8i	a9, a8, 1
                s_fd_table[i].local_fd = fd_within_vfs;
4200707c:	024852        	s8i	a5, a8, 2
                _lock_release(&s_fd_table_lock);
4200707f:	e612a1        	l32r	a10, 420008c8 <_stext+0x8a8> (3fc95030 <s_fd_table_lock>)
42007082:	e5b181        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42007085:	0008e0        	callx8	a8
                return i;
42007088:	001306        	j	420070d8 <_open_r+0x100>
4200708b:	221b00        	orb	b1, b11, b0
        for (int i = 0; i < MAX_FDS; ++i) {
4200708e:	f83c      	movi.n	a8, 63
42007090:	c0a827        	bge	a8, a2, 42007054 <_open_r+0x7c>
            }
        }
        _lock_release(&s_fd_table_lock);
42007093:	e60da1        	l32r	a10, 420008c8 <_stext+0x8a8> (3fc95030 <s_fd_table_lock>)
42007096:	e5ac81        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42007099:	0008e0        	callx8	a8
        int ret;
        CHECK_AND_CALL(ret, r, vfs, close, fd_within_vfs);
4200709c:	1688      	l32i.n	a8, a6, 4
4200709e:	6888      	l32i.n	a8, a8, 24
420070a0:	78cc      	bnez.n	a8, 420070ab <_open_r+0xd3>
420070a2:	885c      	movi.n	a8, 88
420070a4:	0789      	s32i.n	a8, a7, 0
420070a6:	f27c      	movi.n	a2, -1
420070a8:	000b06        	j	420070d8 <_open_r+0x100>
420070ab:	0698      	l32i.n	a9, a6, 0
420070ad:	0b6917        	bbci	a9, 1, 420070bc <_open_r+0xe4>
420070b0:	05bd      	mov.n	a11, a5
420070b2:	0726a2        	l32i	a10, a6, 28
420070b5:	0008e0        	callx8	a8
420070b8:	000146        	j	420070c1 <_open_r+0xe9>
420070bb:	05ad00        	extui	a10, a0, 29, 1
420070be:	0008e0        	callx8	a8
        (void) ret; // remove "set but not used" warning
        __errno_r(r) = ENOMEM;
420070c1:	c80c      	movi.n	a8, 12
420070c3:	0789      	s32i.n	a8, a7, 0
        return -1;
420070c5:	f27c      	movi.n	a2, -1
420070c7:	000346        	j	420070d8 <_open_r+0x100>
420070ca:	e50000        	extui	a0, a0, 16, 15
    }
    __errno_r(r) = errno;
420070cd:	820531        	l32r	a3, 41fe78e4 <_coredump_iram_end+0x1c658e4>
420070d0:	002a      	add.n	a0, a0, a2
420070d2:	006782        	s32i	a8, a7, 0
    return -1;
420070d5:	ffaf22        	movi	a2, -1
}
420070d8:	f01d      	retw.n
	...

420070dc <_write_r>:

ssize_t esp_vfs_write(struct _reent *r, int fd, const void * data, size_t size)
{
420070dc:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420070df:	03ad      	mov.n	a10, a3
420070e1:	ffe625        	call8	42006f44 <get_vfs_for_fd>
420070e4:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
420070e6:	2a9c      	beqz.n	a10, 420070fc <_write_r+0x20>
420070e8:	f93c      	movi.n	a9, 63
420070ea:	133937        	bltu	a9, a3, 42007101 <_write_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420070ed:	903330        	addx2	a3, a3, a3
420070f0:	e5f491        	l32r	a9, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420070f3:	993a      	add.n	a9, a9, a3
420070f5:	0209a2        	l8ui	a10, a9, 2
420070f8:	0001c6        	j	42007103 <_write_r+0x27>
420070fb:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
420070fe:	000046        	j	42007103 <_write_r+0x27>
42007101:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42007103:	40f890        	nsau	a9, a8
42007106:	419590        	srli	a9, a9, 5
42007109:	05bfa0        	extui	a11, a10, 31, 1
4200710c:	2099b0        	or	a9, a9, a11
4200710f:	798c      	beqz.n	a9, 4200711a <_write_r+0x3e>
        __errno_r(r) = EBADF;
42007111:	980c      	movi.n	a8, 9
42007113:	0289      	s32i.n	a8, a2, 0
        return -1;
42007115:	f27c      	movi.n	a2, -1
42007117:	000b06        	j	42007147 <_write_r+0x6b>
    }
    ssize_t ret;
    CHECK_AND_CALL(ret, r, vfs, write, local_fd, data, size);
4200711a:	1898      	l32i.n	a9, a8, 4
4200711c:	0998      	l32i.n	a9, a9, 0
4200711e:	79cc      	bnez.n	a9, 42007129 <_write_r+0x4d>
42007120:	885c      	movi.n	a8, 88
42007122:	0289      	s32i.n	a8, a2, 0
42007124:	f27c      	movi.n	a2, -1
42007126:	000746        	j	42007147 <_write_r+0x6b>
42007129:	08b8      	l32i.n	a11, a8, 0
4200712b:	0f6b17        	bbci	a11, 1, 4200713e <_write_r+0x62>
4200712e:	05dd      	mov.n	a13, a5
42007130:	04cd      	mov.n	a12, a4
42007132:	0abd      	mov.n	a11, a10
42007134:	78a8      	l32i.n	a10, a8, 28
42007136:	0009e0        	callx8	a9
42007139:	0a2d      	mov.n	a2, a10
4200713b:	000206        	j	42007147 <_write_r+0x6b>
4200713e:	05cd      	mov.n	a12, a5
42007140:	04bd      	mov.n	a11, a4
42007142:	0009e0        	callx8	a9
42007145:	0a2d      	mov.n	a2, a10
    return ret;
}
42007147:	f01d      	retw.n
42007149:	000000        	ill

4200714c <_lseek_r>:

off_t esp_vfs_lseek(struct _reent *r, int fd, off_t size, int mode)
{
4200714c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
4200714f:	03ad      	mov.n	a10, a3
42007151:	ffdf25        	call8	42006f44 <get_vfs_for_fd>
42007154:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42007156:	2a9c      	beqz.n	a10, 4200716c <_lseek_r+0x20>
42007158:	f93c      	movi.n	a9, 63
4200715a:	133937        	bltu	a9, a3, 42007171 <_lseek_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
4200715d:	903330        	addx2	a3, a3, a3
42007160:	e5d891        	l32r	a9, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
42007163:	993a      	add.n	a9, a9, a3
42007165:	0209a2        	l8ui	a10, a9, 2
42007168:	0001c6        	j	42007173 <_lseek_r+0x27>
4200716b:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
4200716e:	000046        	j	42007173 <_lseek_r+0x27>
42007171:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42007173:	40f890        	nsau	a9, a8
42007176:	419590        	srli	a9, a9, 5
42007179:	05bfa0        	extui	a11, a10, 31, 1
4200717c:	2099b0        	or	a9, a9, a11
4200717f:	798c      	beqz.n	a9, 4200718a <_lseek_r+0x3e>
        __errno_r(r) = EBADF;
42007181:	980c      	movi.n	a8, 9
42007183:	0289      	s32i.n	a8, a2, 0
        return -1;
42007185:	f27c      	movi.n	a2, -1
42007187:	000b06        	j	420071b7 <_lseek_r+0x6b>
    }
    off_t ret;
    CHECK_AND_CALL(ret, r, vfs, lseek, local_fd, size, mode);
4200718a:	1898      	l32i.n	a9, a8, 4
4200718c:	1998      	l32i.n	a9, a9, 4
4200718e:	79cc      	bnez.n	a9, 42007199 <_lseek_r+0x4d>
42007190:	885c      	movi.n	a8, 88
42007192:	0289      	s32i.n	a8, a2, 0
42007194:	f27c      	movi.n	a2, -1
42007196:	000746        	j	420071b7 <_lseek_r+0x6b>
42007199:	08b8      	l32i.n	a11, a8, 0
4200719b:	0f6b17        	bbci	a11, 1, 420071ae <_lseek_r+0x62>
4200719e:	05dd      	mov.n	a13, a5
420071a0:	04cd      	mov.n	a12, a4
420071a2:	0abd      	mov.n	a11, a10
420071a4:	78a8      	l32i.n	a10, a8, 28
420071a6:	0009e0        	callx8	a9
420071a9:	0a2d      	mov.n	a2, a10
420071ab:	000206        	j	420071b7 <_lseek_r+0x6b>
420071ae:	05cd      	mov.n	a12, a5
420071b0:	04bd      	mov.n	a11, a4
420071b2:	0009e0        	callx8	a9
420071b5:	0a2d      	mov.n	a2, a10
    return ret;
}
420071b7:	f01d      	retw.n
420071b9:	000000        	ill

420071bc <_read_r>:

ssize_t esp_vfs_read(struct _reent *r, int fd, void * dst, size_t size)
{
420071bc:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420071bf:	03ad      	mov.n	a10, a3
420071c1:	ffd825        	call8	42006f44 <get_vfs_for_fd>
420071c4:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
420071c6:	2a9c      	beqz.n	a10, 420071dc <_read_r+0x20>
420071c8:	f93c      	movi.n	a9, 63
420071ca:	133937        	bltu	a9, a3, 420071e1 <_read_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420071cd:	903330        	addx2	a3, a3, a3
420071d0:	e5bc91        	l32r	a9, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420071d3:	993a      	add.n	a9, a9, a3
420071d5:	0209a2        	l8ui	a10, a9, 2
420071d8:	0001c6        	j	420071e3 <_read_r+0x27>
420071db:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
420071de:	000046        	j	420071e3 <_read_r+0x27>
420071e1:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
420071e3:	40f890        	nsau	a9, a8
420071e6:	419590        	srli	a9, a9, 5
420071e9:	05bfa0        	extui	a11, a10, 31, 1
420071ec:	2099b0        	or	a9, a9, a11
420071ef:	798c      	beqz.n	a9, 420071fa <_read_r+0x3e>
        __errno_r(r) = EBADF;
420071f1:	980c      	movi.n	a8, 9
420071f3:	0289      	s32i.n	a8, a2, 0
        return -1;
420071f5:	f27c      	movi.n	a2, -1
420071f7:	000b06        	j	42007227 <_read_r+0x6b>
    }
    ssize_t ret;
    CHECK_AND_CALL(ret, r, vfs, read, local_fd, dst, size);
420071fa:	1898      	l32i.n	a9, a8, 4
420071fc:	2998      	l32i.n	a9, a9, 8
420071fe:	79cc      	bnez.n	a9, 42007209 <_read_r+0x4d>
42007200:	885c      	movi.n	a8, 88
42007202:	0289      	s32i.n	a8, a2, 0
42007204:	f27c      	movi.n	a2, -1
42007206:	000746        	j	42007227 <_read_r+0x6b>
42007209:	08b8      	l32i.n	a11, a8, 0
4200720b:	0f6b17        	bbci	a11, 1, 4200721e <_read_r+0x62>
4200720e:	05dd      	mov.n	a13, a5
42007210:	04cd      	mov.n	a12, a4
42007212:	0abd      	mov.n	a11, a10
42007214:	78a8      	l32i.n	a10, a8, 28
42007216:	0009e0        	callx8	a9
42007219:	0a2d      	mov.n	a2, a10
4200721b:	000206        	j	42007227 <_read_r+0x6b>
4200721e:	05cd      	mov.n	a12, a5
42007220:	04bd      	mov.n	a11, a4
42007222:	0009e0        	callx8	a9
42007225:	0a2d      	mov.n	a2, a10
    return ret;
}
42007227:	f01d      	retw.n
42007229:	000000        	ill

4200722c <_close_r>:
    CHECK_AND_CALL(ret, r, vfs, pwrite, local_fd, src, size, offset);
    return ret;
}

int esp_vfs_close(struct _reent *r, int fd)
{
4200722c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
4200722f:	03ad      	mov.n	a10, a3
42007231:	ffd125        	call8	42006f44 <get_vfs_for_fd>
42007234:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42007236:	2a9c      	beqz.n	a10, 4200724c <_close_r+0x20>
42007238:	f93c      	movi.n	a9, 63
4200723a:	133937        	bltu	a9, a3, 42007251 <_close_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
4200723d:	90a330        	addx2	a10, a3, a3
42007240:	e5a091        	l32r	a9, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
42007243:	99aa      	add.n	a9, a9, a10
42007245:	0209a2        	l8ui	a10, a9, 2
42007248:	0001c6        	j	42007253 <_close_r+0x27>
4200724b:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
4200724e:	000046        	j	42007253 <_close_r+0x27>
42007251:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42007253:	40f890        	nsau	a9, a8
42007256:	419590        	srli	a9, a9, 5
42007259:	05bfa0        	extui	a11, a10, 31, 1
4200725c:	2099b0        	or	a9, a9, a11
4200725f:	798c      	beqz.n	a9, 4200726a <_close_r+0x3e>
        __errno_r(r) = EBADF;
42007261:	980c      	movi.n	a8, 9
42007263:	0289      	s32i.n	a8, a2, 0
        return -1;
42007265:	f27c      	movi.n	a2, -1
42007267:	002086        	j	420072ed <_close_r+0xc1>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, close, local_fd);
4200726a:	1898      	l32i.n	a9, a8, 4
4200726c:	6998      	l32i.n	a9, a9, 24
4200726e:	79cc      	bnez.n	a9, 42007279 <_close_r+0x4d>
42007270:	885c      	movi.n	a8, 88
42007272:	0289      	s32i.n	a8, a2, 0
42007274:	f27c      	movi.n	a2, -1
42007276:	001cc6        	j	420072ed <_close_r+0xc1>
42007279:	08b8      	l32i.n	a11, a8, 0
4200727b:	0e6b17        	bbci	a11, 1, 4200728d <_close_r+0x61>
4200727e:	0abd      	mov.n	a11, a10
42007280:	78a8      	l32i.n	a10, a8, 28
42007282:	0009e0        	callx8	a9
42007285:	0a2d      	mov.n	a2, a10
42007287:	000206        	j	42007293 <_close_r+0x67>
4200728a:	000000        	ill
4200728d:	0009e0        	callx8	a9
42007290:	202aa0        	or	a2, a10, a10

    _lock_acquire(&s_fd_table_lock);
42007293:	e58da1        	l32r	a10, 420008c8 <_stext+0x8a8> (3fc95030 <s_fd_table_lock>)
42007296:	e52b81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42007299:	0008e0        	callx8	a8
    if (!s_fd_table[fd].permanent) {
4200729c:	909330        	addx2	a9, a3, a3
4200729f:	e58881        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420072a2:	889a      	add.n	a8, a8, a9
420072a4:	000882        	l8ui	a8, a8, 0
420072a7:	39e807        	bbsi	a8, 0, 420072e4 <_close_r+0xb8>
        if (s_fd_table[fd].has_pending_select) {
420072aa:	e58581        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420072ad:	889a      	add.n	a8, a8, a9
420072af:	000882        	l8ui	a8, a8, 0
420072b2:	126827        	bbci	a8, 2, 420072c8 <_close_r+0x9c>
            s_fd_table[fd].has_pending_close = true;
420072b5:	e58281        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420072b8:	389a      	add.n	a3, a8, a9
420072ba:	000382        	l8ui	a8, a3, 0
420072bd:	290c      	movi.n	a9, 2
420072bf:	208890        	or	a8, a8, a9
420072c2:	004382        	s8i	a8, a3, 0
420072c5:	0006c6        	j	420072e4 <_close_r+0xb8>
        } else {
            s_fd_table[fd] = FD_TABLE_ENTRY_UNUSED;
420072c8:	903330        	addx2	a3, a3, a3
420072cb:	e57d81        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420072ce:	383a      	add.n	a3, a8, a3
420072d0:	3c0c      	movi.n	a12, 3
420072d2:	0b0c      	movi.n	a11, 0
420072d4:	03ad      	mov.n	a10, a3
420072d6:	e40a81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420072d9:	0008e0        	callx8	a8
420072dc:	f87c      	movi.n	a8, -1
420072de:	014382        	s8i	a8, a3, 1
420072e1:	024382        	s8i	a8, a3, 2
        }
    }
    _lock_release(&s_fd_table_lock);
420072e4:	e579a1        	l32r	a10, 420008c8 <_stext+0x8a8> (3fc95030 <s_fd_table_lock>)
420072e7:	e51881        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
420072ea:	0008e0        	callx8	a8
    return ret;
}
420072ed:	f01d      	retw.n
	...

420072f0 <_fstat_r>:

int esp_vfs_fstat(struct _reent *r, int fd, struct stat * st)
{
420072f0:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420072f3:	03ad      	mov.n	a10, a3
420072f5:	ffc4e5        	call8	42006f44 <get_vfs_for_fd>
420072f8:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
420072fa:	2a9c      	beqz.n	a10, 42007310 <_fstat_r+0x20>
420072fc:	f93c      	movi.n	a9, 63
420072fe:	133937        	bltu	a9, a3, 42007315 <_fstat_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42007301:	903330        	addx2	a3, a3, a3
42007304:	e56f91        	l32r	a9, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
42007307:	993a      	add.n	a9, a9, a3
42007309:	0209a2        	l8ui	a10, a9, 2
4200730c:	0001c6        	j	42007317 <_fstat_r+0x27>
4200730f:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
42007312:	000046        	j	42007317 <_fstat_r+0x27>
42007315:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42007317:	40f890        	nsau	a9, a8
4200731a:	419590        	srli	a9, a9, 5
4200731d:	05bfa0        	extui	a11, a10, 31, 1
42007320:	2099b0        	or	a9, a9, a11
42007323:	798c      	beqz.n	a9, 4200732e <_fstat_r+0x3e>
        __errno_r(r) = EBADF;
42007325:	980c      	movi.n	a8, 9
42007327:	0289      	s32i.n	a8, a2, 0
        return -1;
42007329:	f27c      	movi.n	a2, -1
4200732b:	000a46        	j	42007358 <_fstat_r+0x68>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, fstat, local_fd, st);
4200732e:	1898      	l32i.n	a9, a8, 4
42007330:	7998      	l32i.n	a9, a9, 28
42007332:	79cc      	bnez.n	a9, 4200733d <_fstat_r+0x4d>
42007334:	885c      	movi.n	a8, 88
42007336:	0289      	s32i.n	a8, a2, 0
42007338:	f27c      	movi.n	a2, -1
4200733a:	000686        	j	42007358 <_fstat_r+0x68>
4200733d:	08b8      	l32i.n	a11, a8, 0
4200733f:	0e6b17        	bbci	a11, 1, 42007351 <_fstat_r+0x61>
42007342:	04cd      	mov.n	a12, a4
42007344:	0abd      	mov.n	a11, a10
42007346:	0728a2        	l32i	a10, a8, 28
42007349:	0009e0        	callx8	a9
4200734c:	0a2d      	mov.n	a2, a10
4200734e:	000186        	j	42007358 <_fstat_r+0x68>
42007351:	04bd      	mov.n	a11, a4
42007353:	0009e0        	callx8	a9
42007356:	0a2d      	mov.n	a2, a10
    return ret;
}
42007358:	f01d      	retw.n
	...

4200735c <_fcntl_r>:

int esp_vfs_fcntl_r(struct _reent *r, int fd, int cmd, int arg)
{
4200735c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
4200735f:	03ad      	mov.n	a10, a3
42007361:	ffbe25        	call8	42006f44 <get_vfs_for_fd>
42007364:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42007366:	2a9c      	beqz.n	a10, 4200737c <_fcntl_r+0x20>
42007368:	f93c      	movi.n	a9, 63
4200736a:	133937        	bltu	a9, a3, 42007381 <_fcntl_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
4200736d:	903330        	addx2	a3, a3, a3
42007370:	e55491        	l32r	a9, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
42007373:	993a      	add.n	a9, a9, a3
42007375:	0209a2        	l8ui	a10, a9, 2
42007378:	0001c6        	j	42007383 <_fcntl_r+0x27>
4200737b:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
4200737e:	000046        	j	42007383 <_fcntl_r+0x27>
42007381:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42007383:	40f890        	nsau	a9, a8
42007386:	419590        	srli	a9, a9, 5
42007389:	05bfa0        	extui	a11, a10, 31, 1
4200738c:	2099b0        	or	a9, a9, a11
4200738f:	798c      	beqz.n	a9, 4200739a <_fcntl_r+0x3e>
        __errno_r(r) = EBADF;
42007391:	980c      	movi.n	a8, 9
42007393:	0289      	s32i.n	a8, a2, 0
        return -1;
42007395:	f27c      	movi.n	a2, -1
42007397:	000b06        	j	420073c7 <_fcntl_r+0x6b>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, fcntl, local_fd, cmd, arg);
4200739a:	1898      	l32i.n	a9, a8, 4
4200739c:	8998      	l32i.n	a9, a9, 32
4200739e:	79cc      	bnez.n	a9, 420073a9 <_fcntl_r+0x4d>
420073a0:	885c      	movi.n	a8, 88
420073a2:	0289      	s32i.n	a8, a2, 0
420073a4:	f27c      	movi.n	a2, -1
420073a6:	000746        	j	420073c7 <_fcntl_r+0x6b>
420073a9:	08b8      	l32i.n	a11, a8, 0
420073ab:	0f6b17        	bbci	a11, 1, 420073be <_fcntl_r+0x62>
420073ae:	05dd      	mov.n	a13, a5
420073b0:	04cd      	mov.n	a12, a4
420073b2:	0abd      	mov.n	a11, a10
420073b4:	78a8      	l32i.n	a10, a8, 28
420073b6:	0009e0        	callx8	a9
420073b9:	0a2d      	mov.n	a2, a10
420073bb:	000206        	j	420073c7 <_fcntl_r+0x6b>
420073be:	05cd      	mov.n	a12, a5
420073c0:	04bd      	mov.n	a11, a4
420073c2:	0009e0        	callx8	a9
420073c5:	0a2d      	mov.n	a2, a10
    return ret;
}
420073c7:	f01d      	retw.n
420073c9:	000000        	ill

420073cc <esp_vfs_fsync>:
    va_end(args);
    return ret;
}

int esp_vfs_fsync(int fd)
{
420073cc:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420073cf:	02ad      	mov.n	a10, a2
420073d1:	ffb725        	call8	42006f44 <get_vfs_for_fd>
420073d4:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
420073d6:	2a9c      	beqz.n	a10, 420073ec <esp_vfs_fsync+0x20>
420073d8:	f83c      	movi.n	a8, 63
420073da:	133827        	bltu	a8, a2, 420073f1 <esp_vfs_fsync+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420073dd:	902220        	addx2	a2, a2, a2
420073e0:	e53881        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420073e3:	882a      	add.n	a8, a8, a2
420073e5:	020822        	l8ui	a2, a8, 2
420073e8:	0001c6        	j	420073f3 <esp_vfs_fsync+0x27>
420073eb:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
420073ee:	000046        	j	420073f3 <esp_vfs_fsync+0x27>
420073f1:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
420073f3:	e4d781        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
420073f6:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
420073f9:	40f780        	nsau	a8, a7
420073fc:	418580        	srli	a8, a8, 5
420073ff:	059f20        	extui	a9, a2, 31, 1
42007402:	208890        	or	a8, a8, a9
42007405:	788c      	beqz.n	a8, 42007410 <esp_vfs_fsync+0x44>
        __errno_r(r) = EBADF;
42007407:	980c      	movi.n	a8, 9
42007409:	0a89      	s32i.n	a8, a10, 0
        return -1;
4200740b:	f27c      	movi.n	a2, -1
4200740d:	0009c6        	j	42007438 <esp_vfs_fsync+0x6c>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, fsync, local_fd);
42007410:	1788      	l32i.n	a8, a7, 4
42007412:	a888      	l32i.n	a8, a8, 40
42007414:	88cc      	bnez.n	a8, 42007420 <esp_vfs_fsync+0x54>
42007416:	885c      	movi.n	a8, 88
42007418:	0a89      	s32i.n	a8, a10, 0
4200741a:	f27c      	movi.n	a2, -1
4200741c:	000606        	j	42007438 <esp_vfs_fsync+0x6c>
4200741f:	079800        	lsi	f0, a8, 28
42007422:	0b6917        	bbci	a9, 1, 42007431 <esp_vfs_fsync+0x65>
42007425:	02bd      	mov.n	a11, a2
42007427:	77a8      	l32i.n	a10, a7, 28
42007429:	0008e0        	callx8	a8
4200742c:	0a2d      	mov.n	a2, a10
4200742e:	000186        	j	42007438 <esp_vfs_fsync+0x6c>
42007431:	02ad      	mov.n	a10, a2
42007433:	0008e0        	callx8	a8
42007436:	0a2d      	mov.n	a2, a10
    return ret;
}
42007438:	f01d      	retw.n
	...

4200743c <_stat_r>:

#ifdef CONFIG_VFS_SUPPORT_DIR

int esp_vfs_stat(struct _reent *r, const char * path, struct stat * st)
{
4200743c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(path);
4200743f:	03ad      	mov.n	a10, a3
42007441:	ffb2a5        	call8	42006f6c <get_vfs_for_path>
42007444:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
42007446:	8acc      	bnez.n	a10, 42007452 <_stat_r+0x16>
        __errno_r(r) = ENOENT;
42007448:	280c      	movi.n	a8, 2
4200744a:	0289      	s32i.n	a8, a2, 0
        return -1;
4200744c:	f27c      	movi.n	a2, -1
4200744e:	000d86        	j	42007488 <_stat_r+0x4c>
42007451:	b33000        	movgez	a3, a0, a0
    }
    const char* path_within_vfs = translate_path(vfs, path);
42007454:	a2e520        	muluh	a14, a5, a2
42007457:	ff          	.byte	0xff
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, stat, path_within_vfs, st);
42007458:	012782        	l32i	a8, a7, 4
4200745b:	0b2882        	l32i	a8, a8, 44
4200745e:	288c      	beqz.n	a8, 42007464 <_stat_r+0x28>
42007460:	0888      	l32i.n	a8, a8, 0
42007462:	78cc      	bnez.n	a8, 4200746d <_stat_r+0x31>
42007464:	885c      	movi.n	a8, 88
42007466:	0289      	s32i.n	a8, a2, 0
42007468:	f27c      	movi.n	a2, -1
4200746a:	000686        	j	42007488 <_stat_r+0x4c>
4200746d:	0798      	l32i.n	a9, a7, 0
4200746f:	0e6917        	bbci	a9, 1, 42007481 <_stat_r+0x45>
42007472:	04cd      	mov.n	a12, a4
42007474:	0abd      	mov.n	a11, a10
42007476:	0727a2        	l32i	a10, a7, 28
42007479:	0008e0        	callx8	a8
4200747c:	0a2d      	mov.n	a2, a10
4200747e:	000186        	j	42007488 <_stat_r+0x4c>
42007481:	04bd      	mov.n	a11, a4
42007483:	0008e0        	callx8	a8
42007486:	0a2d      	mov.n	a2, a10
    return ret;
}
42007488:	f01d      	retw.n
	...

4200748c <_link_r>:
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, utime, path_within_vfs, times);
    return ret;
}

int esp_vfs_link(struct _reent *r, const char* n1, const char* n2)
{
4200748c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(n1);
4200748f:	03ad      	mov.n	a10, a3
42007491:	ffada5        	call8	42006f6c <get_vfs_for_path>
42007494:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
42007496:	7acc      	bnez.n	a10, 420074a1 <_link_r+0x15>
        __errno_r(r) = ENOENT;
42007498:	280c      	movi.n	a8, 2
4200749a:	0289      	s32i.n	a8, a2, 0
        return -1;
4200749c:	f27c      	movi.n	a2, -1
4200749e:	001906        	j	42007506 <_link_r+0x7a>
    }
    const vfs_entry_t* vfs2 = get_vfs_for_path(n2);
420074a1:	20a440        	or	a10, a4, a4
420074a4:	ffac65        	call8	42006f6c <get_vfs_for_path>
    if (vfs != vfs2) {
420074a7:	0a17a7        	beq	a7, a10, 420074b5 <_link_r+0x29>
        __errno_r(r) = EXDEV;
420074aa:	12a082        	movi	a8, 18
420074ad:	006282        	s32i	a8, a2, 0
        return -1;
420074b0:	f27c      	movi.n	a2, -1
420074b2:	001406        	j	42007506 <_link_r+0x7a>
    }

    CHECK_VFS_READONLY_FLAG(vfs2->flags);
420074b5:	0a88      	l32i.n	a8, a10, 0
420074b7:	096827        	bbci	a8, 2, 420074c4 <_link_r+0x38>
420074ba:	e81c      	movi.n	a8, 30
420074bc:	0289      	s32i.n	a8, a2, 0
420074be:	f27c      	movi.n	a2, -1
420074c0:	001086        	j	42007506 <_link_r+0x7a>
420074c3:	b33000        	movgez	a3, a0, a0

    const char* path1_within_vfs = translate_path(vfs, n1);
420074c6:	a77020        	lsi	f2, a0, 0x29c
420074c9:	9ba520        	movnez.s	f10, f5, a2
420074cc:	ff          	.byte	0xff
420074cd:	0a3d      	mov.n	a3, a10
    const char* path2_within_vfs = translate_path(vfs, n2);
420074cf:	04bd      	mov.n	a11, a4
420074d1:	07ad      	mov.n	a10, a7
420074d3:	ff9b25        	call8	42006e84 <translate_path>
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, link, path1_within_vfs, path2_within_vfs);
420074d6:	1788      	l32i.n	a8, a7, 4
420074d8:	b888      	l32i.n	a8, a8, 44
420074da:	288c      	beqz.n	a8, 420074e0 <_link_r+0x54>
420074dc:	1888      	l32i.n	a8, a8, 4
420074de:	88cc      	bnez.n	a8, 420074ea <_link_r+0x5e>
420074e0:	885c      	movi.n	a8, 88
420074e2:	0289      	s32i.n	a8, a2, 0
420074e4:	f27c      	movi.n	a2, -1
420074e6:	000706        	j	42007506 <_link_r+0x7a>
420074e9:	079800        	lsi	f0, a8, 28
420074ec:	0d6917        	bbci	a9, 1, 420074fd <_link_r+0x71>
420074ef:	0acd      	mov.n	a12, a10
420074f1:	03bd      	mov.n	a11, a3
420074f3:	77a8      	l32i.n	a10, a7, 28
420074f5:	0008e0        	callx8	a8
420074f8:	0a2d      	mov.n	a2, a10
420074fa:	000206        	j	42007506 <_link_r+0x7a>
420074fd:	0abd      	mov.n	a11, a10
420074ff:	03ad      	mov.n	a10, a3
42007501:	0008e0        	callx8	a8
42007504:	0a2d      	mov.n	a2, a10
    return ret;
}
42007506:	f01d      	retw.n

42007508 <_unlink_r>:

int esp_vfs_unlink(struct _reent *r, const char *path)
{
42007508:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(path);
4200750b:	03ad      	mov.n	a10, a3
4200750d:	ffa5e5        	call8	42006f6c <get_vfs_for_path>
42007510:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
42007512:	7acc      	bnez.n	a10, 4200751d <_unlink_r+0x15>
        __errno_r(r) = ENOENT;
42007514:	280c      	movi.n	a8, 2
42007516:	0289      	s32i.n	a8, a2, 0
        return -1;
42007518:	f27c      	movi.n	a2, -1
4200751a:	001006        	j	4200755e <_unlink_r+0x56>
    }

    CHECK_VFS_READONLY_FLAG(vfs->flags);
4200751d:	0a68      	l32i.n	a6, a10, 0
4200751f:	096627        	bbci	a6, 2, 4200752c <_unlink_r+0x24>
42007522:	e81c      	movi.n	a8, 30
42007524:	0289      	s32i.n	a8, a2, 0
42007526:	f27c      	movi.n	a2, -1
42007528:	000c86        	j	4200755e <_unlink_r+0x56>
4200752b:	b33000        	movgez	a3, a0, a0

    const char* path_within_vfs = translate_path(vfs, path);
4200752e:	956520        	extui	a6, a2, 21, 10
42007531:	ff          	.byte	0xff
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, unlink, path_within_vfs);
42007532:	012782        	l32i	a8, a7, 4
42007535:	0b2882        	l32i	a8, a8, 44
42007538:	288c      	beqz.n	a8, 4200753e <_unlink_r+0x36>
4200753a:	2888      	l32i.n	a8, a8, 8
4200753c:	88cc      	bnez.n	a8, 42007548 <_unlink_r+0x40>
4200753e:	885c      	movi.n	a8, 88
42007540:	0289      	s32i.n	a8, a2, 0
42007542:	f27c      	movi.n	a2, -1
42007544:	000586        	j	4200755e <_unlink_r+0x56>
42007547:	661700        	lsi	f0, a7, 0x198
4200754a:	bd0d      	lsi	f0, a13, 52
4200754c:	a80a      	add.n	a10, a8, a0
4200754e:	08e077        	bbsi	a0, 7, 4200755a <_unlink_r+0x52>
42007551:	0a2d00        	add.s	f2, f13, f0
42007554:	000186        	j	4200755e <_unlink_r+0x56>
42007557:	e00000        	subx4	a0, a0, a0
4200755a:	0008      	l32i.n	a0, a0, 0
4200755c:	0a2d      	mov.n	a2, a10
    return ret;
}
4200755e:	f01d      	retw.n

42007560 <_rename_r>:

int esp_vfs_rename(struct _reent *r, const char *src, const char *dst)
{
42007560:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(src);
42007563:	03ad      	mov.n	a10, a3
42007565:	ffa065        	call8	42006f6c <get_vfs_for_path>
42007568:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
4200756a:	7acc      	bnez.n	a10, 42007575 <_rename_r+0x15>
        __errno_r(r) = ENOENT;
4200756c:	280c      	movi.n	a8, 2
4200756e:	0289      	s32i.n	a8, a2, 0
        return -1;
42007570:	f27c      	movi.n	a2, -1
42007572:	001c06        	j	420075e6 <_rename_r+0x86>
    }

    CHECK_VFS_READONLY_FLAG(vfs->flags);
42007575:	0a68      	l32i.n	a6, a10, 0
42007577:	096627        	bbci	a6, 2, 42007584 <_rename_r+0x24>
4200757a:	e81c      	movi.n	a8, 30
4200757c:	0289      	s32i.n	a8, a2, 0
4200757e:	f27c      	movi.n	a2, -1
42007580:	001886        	j	420075e6 <_rename_r+0x86>
42007583:	a44000        	extui	a4, a0, 0, 11

    const vfs_entry_t* vfs_dst = get_vfs_for_path(dst);
42007586:	9e6520        	f64iter	a6, a5, a2, 1, 0
42007589:	ff          	.byte	0xff
    if (vfs != vfs_dst) {
4200758a:	0a17a7        	beq	a7, a10, 42007598 <_rename_r+0x38>
        __errno_r(r) = EXDEV;
4200758d:	12a082        	movi	a8, 18
42007590:	006282        	s32i	a8, a2, 0
        return -1;
42007593:	f27c      	movi.n	a2, -1
42007595:	001346        	j	420075e6 <_rename_r+0x86>
    }

    CHECK_VFS_READONLY_FLAG(vfs_dst->flags);
42007598:	0a88      	l32i.n	a8, a10, 0
4200759a:	086827        	bbci	a8, 2, 420075a6 <_rename_r+0x46>
4200759d:	e81c      	movi.n	a8, 30
4200759f:	0289      	s32i.n	a8, a2, 0
420075a1:	f27c      	movi.n	a2, -1
420075a3:	000fc6        	j	420075e6 <_rename_r+0x86>

    const char* src_within_vfs = translate_path(vfs, src);
420075a6:	20b330        	or	a11, a3, a3
420075a9:	20a770        	or	a10, a7, a7
420075ac:	ff8d65        	call8	42006e84 <translate_path>
420075af:	0a3d      	mov.n	a3, a10
    const char* dst_within_vfs = translate_path(vfs, dst);
420075b1:	04bd      	mov.n	a11, a4
420075b3:	07ad      	mov.n	a10, a7
420075b5:	ff8ce5        	call8	42006e84 <translate_path>
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, rename, src_within_vfs, dst_within_vfs);
420075b8:	1788      	l32i.n	a8, a7, 4
420075ba:	b888      	l32i.n	a8, a8, 44
420075bc:	288c      	beqz.n	a8, 420075c2 <_rename_r+0x62>
420075be:	3888      	l32i.n	a8, a8, 12
420075c0:	78cc      	bnez.n	a8, 420075cb <_rename_r+0x6b>
420075c2:	885c      	movi.n	a8, 88
420075c4:	0289      	s32i.n	a8, a2, 0
420075c6:	f27c      	movi.n	a2, -1
420075c8:	000686        	j	420075e6 <_rename_r+0x86>
420075cb:	0e6617        	bbci	a6, 1, 420075dd <_rename_r+0x7d>
420075ce:	0acd      	mov.n	a12, a10
420075d0:	03bd      	mov.n	a11, a3
420075d2:	0727a2        	l32i	a10, a7, 28
420075d5:	0008e0        	callx8	a8
420075d8:	0a2d      	mov.n	a2, a10
420075da:	000206        	j	420075e6 <_rename_r+0x86>
420075dd:	0abd      	mov.n	a11, a10
420075df:	03ad      	mov.n	a10, a3
420075e1:	0008e0        	callx8	a8
420075e4:	0a2d      	mov.n	a2, a10
    return ret;
}
420075e6:	f01d      	retw.n

420075e8 <access>:
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, rmdir, path_within_vfs);
    return ret;
}

int esp_vfs_access(const char *path, int amode)
{
420075e8:	004136        	entry	a1, 32
    int ret;
    const vfs_entry_t* vfs = get_vfs_for_path(path);
420075eb:	02ad      	mov.n	a10, a2
420075ed:	ff97e5        	call8	42006f6c <get_vfs_for_path>
420075f0:	0a7d      	mov.n	a7, a10
    [[maybe_unused]] struct _reent* r = __getreent();
420075f2:	e45781        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
420075f5:	0008e0        	callx8	a8
420075f8:	0a6d      	mov.n	a6, a10
    if (vfs == NULL) {
420075fa:	87cc      	bnez.n	a7, 42007606 <access+0x1e>
        __errno_r(r) = ENOENT;
420075fc:	280c      	movi.n	a8, 2
420075fe:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007600:	f27c      	movi.n	a2, -1
42007602:	000e46        	j	4200763f <access+0x57>
42007605:	b22000        	mulsh	a2, a0, a0
    }
    const char* path_within_vfs = translate_path(vfs, path);
42007608:	a77020        	lsi	f2, a0, 0x29c
4200760b:	876520        	lsi	f2, a5, 0x21c
4200760e:	ff          	.byte	0xff
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, access, path_within_vfs, amode);
4200760f:	012782        	l32i	a8, a7, 4
42007612:	b888      	l32i.n	a8, a8, 44
42007614:	288c      	beqz.n	a8, 4200761a <access+0x32>
42007616:	c888      	l32i.n	a8, a8, 48
42007618:	88cc      	bnez.n	a8, 42007624 <access+0x3c>
4200761a:	885c      	movi.n	a8, 88
4200761c:	0689      	s32i.n	a8, a6, 0
4200761e:	f27c      	movi.n	a2, -1
42007620:	0006c6        	j	4200763f <access+0x57>
42007623:	079800        	lsi	f0, a8, 28
42007626:	0e6917        	bbci	a9, 1, 42007638 <access+0x50>
42007629:	03cd      	mov.n	a12, a3
4200762b:	0abd      	mov.n	a11, a10
4200762d:	77a8      	l32i.n	a10, a7, 28
4200762f:	0008e0        	callx8	a8
42007632:	0a2d      	mov.n	a2, a10
42007634:	0001c6        	j	4200763f <access+0x57>
42007637:	03bd00        	lsi	f0, a13, 12
4200763a:	0008e0        	callx8	a8
4200763d:	0a2d      	mov.n	a2, a10
    return ret;
}
4200763f:	f01d      	retw.n
42007641:	000000        	ill

42007644 <esp_vfs_select_triggered>:
    esp_vfs_log_fd_set("errorfds", errorfds);
    return ret;
}

void esp_vfs_select_triggered(esp_vfs_select_sem_t sem)
{
42007644:	006136        	entry	a1, 48
42007647:	0129      	s32i.n	a2, a1, 0
42007649:	1139      	s32i.n	a3, a1, 4
    if (sem.is_sem_local) {
4200764b:	000182        	l8ui	a8, a1, 0
4200764e:	38bc      	beqz.n	a8, 42007685 <esp_vfs_select_triggered+0x41>
        xSemaphoreGive(sem.sem);
42007650:	0d0c      	movi.n	a13, 0
42007652:	0dcd      	mov.n	a12, a13
42007654:	20bdd0        	or	a11, a13, a13
42007657:	20a330        	or	a10, a3, a3
4200765a:	e45781        	l32r	a8, 420007b8 <_stext+0x798> (40379ad8 <xQueueGenericSend>)
4200765d:	0008e0        	callx8	a8
42007660:	000ac6        	j	4200768f <esp_vfs_select_triggered+0x4b>
42007663:	8e9100        	f64iter	a9, a1, a0, 0, 0
        // which has a permanent FD. But in order to avoid to lock
        // s_fd_table_lock we go through the VFS table.
        for (int i = 0; i < s_vfs_count; ++i) {
            // Note: s_vfs_count could have changed since the start of vfs_select() call. However, that change doesn't
            // matter here stop_socket_select() will be called for only valid VFS drivers.
            const vfs_entry_t *vfs = s_vfs[i];
42007666:	9890e4        	lsi	f14, a0, 0x260
42007669:	0998a0        	l32e	a10, a8, -28
            if (vfs != NULL
4200766c:	099c      	beqz.n	a9, 42007680 <esp_vfs_select_triggered+0x3c>
                && vfs->vfs->select != NULL
4200766e:	1998      	l32i.n	a9, a9, 4
42007670:	d998      	l32i.n	a9, a9, 52
42007672:	a98c      	beqz.n	a9, 42007680 <esp_vfs_select_triggered+0x3c>
                && vfs->vfs->select->stop_socket_select != NULL
42007674:	2998      	l32i.n	a9, a9, 8
42007676:	698c      	beqz.n	a9, 42007680 <esp_vfs_select_triggered+0x3c>
            ) {
                vfs->vfs->select->stop_socket_select(sem.sem);
42007678:	11a8      	l32i.n	a10, a1, 4
4200767a:	0009e0        	callx8	a9
                break;
4200767d:	000386        	j	4200768f <esp_vfs_select_triggered+0x4b>
        for (int i = 0; i < s_vfs_count; ++i) {
42007680:	881b      	addi.n	a8, a8, 1
42007682:	000046        	j	42007687 <esp_vfs_select_triggered+0x43>
42007685:	080c      	movi.n	a8, 0
42007687:	e48691        	l32r	a9, 420008a0 <_stext+0x880> (3fc95034 <s_vfs_count>)
4200768a:	0998      	l32i.n	a9, a9, 0
4200768c:	d43897        	bltu	a8, a9, 42007664 <esp_vfs_select_triggered+0x20>
            }
        }
    }
}
4200768f:	f01d      	retw.n
42007691:	000000        	ill

42007694 <esp_vfs_select_triggered_isr>:

void esp_vfs_select_triggered_isr(esp_vfs_select_sem_t sem, BaseType_t *woken)
{
42007694:	006136        	entry	a1, 48
42007697:	0129      	s32i.n	a2, a1, 0
42007699:	1139      	s32i.n	a3, a1, 4
4200769b:	20b440        	or	a11, a4, a4
    if (sem.is_sem_local) {
4200769e:	000182        	l8ui	a8, a1, 0
420076a1:	c8ac      	beqz.n	a8, 420076d1 <esp_vfs_select_triggered_isr+0x3d>
        xSemaphoreGiveFromISR(sem.sem, woken);
420076a3:	20a330        	or	a10, a3, a3
420076a6:	e48981        	l32r	a8, 420008cc <_stext+0x8ac> (40379cc4 <xQueueGiveFromISR>)
420076a9:	0008e0        	callx8	a8
420076ac:	000ac6        	j	420076db <esp_vfs_select_triggered_isr+0x47>
        // which has a permanent FD. But in order to avoid to lock
        // s_fd_table_lock we go through the VFS table.
        for (int i = 0; i < s_vfs_count; ++i) {
            // Note: s_vfs_count could have changed since the start of vfs_select() call. However, that change doesn't
            // matter here stop_socket_select() will be called for only valid VFS drivers.
            const vfs_entry_t *vfs = s_vfs[i];
420076af:	e47b91        	l32r	a9, 4200089c <_stext+0x87c> (3fc95038 <s_vfs>)
420076b2:	a09890        	addx4	a9, a8, a9
420076b5:	0998      	l32i.n	a9, a9, 0
            if (vfs != NULL
420076b7:	199c      	beqz.n	a9, 420076cc <esp_vfs_select_triggered_isr+0x38>
                && vfs->vfs->select != NULL
420076b9:	1998      	l32i.n	a9, a9, 4
420076bb:	d998      	l32i.n	a9, a9, 52
420076bd:	b98c      	beqz.n	a9, 420076cc <esp_vfs_select_triggered_isr+0x38>
                && vfs->vfs->select->stop_socket_select_isr != NULL
420076bf:	3998      	l32i.n	a9, a9, 12
420076c1:	798c      	beqz.n	a9, 420076cc <esp_vfs_select_triggered_isr+0x38>
            ) {
                // Note: If the UART ISR resides in IRAM, the function referenced by stop_socket_select_isr should also be placed in IRAM.
                vfs->vfs->select->stop_socket_select_isr(sem.sem, woken);
420076c3:	11a8      	l32i.n	a10, a1, 4
420076c5:	0009e0        	callx8	a9
                break;
420076c8:	0003c6        	j	420076db <esp_vfs_select_triggered_isr+0x47>
420076cb:	881b00        	lsi	f0, a11, 0x220
        for (int i = 0; i < s_vfs_count; ++i) {
420076ce:	000046        	j	420076d3 <esp_vfs_select_triggered_isr+0x3f>
420076d1:	080c      	movi.n	a8, 0
420076d3:	e47391        	l32r	a9, 420008a0 <_stext+0x880> (3fc95034 <s_vfs_count>)
420076d6:	0998      	l32i.n	a9, a9, 0
420076d8:	d33897        	bltu	a8, a9, 420076af <esp_vfs_select_triggered_isr+0x1b>
            }
        }
    }
}
420076db:	f01d      	retw.n
420076dd:	000000        	ill

420076e0 <tcgetattr>:
#endif // CONFIG_VFS_SUPPORT_SELECT

#ifdef CONFIG_VFS_SUPPORT_TERMIOS

int tcgetattr(int fd, struct termios *p)
{
420076e0:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420076e3:	02ad      	mov.n	a10, a2
420076e5:	ff85e5        	call8	42006f44 <get_vfs_for_fd>
420076e8:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
420076ea:	2a9c      	beqz.n	a10, 42007700 <tcgetattr+0x20>
420076ec:	f83c      	movi.n	a8, 63
420076ee:	133827        	bltu	a8, a2, 42007705 <tcgetattr+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420076f1:	902220        	addx2	a2, a2, a2
420076f4:	e47381        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420076f7:	882a      	add.n	a8, a8, a2
420076f9:	020822        	l8ui	a2, a8, 2
420076fc:	0001c6        	j	42007707 <tcgetattr+0x27>
420076ff:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
42007702:	000046        	j	42007707 <tcgetattr+0x27>
42007705:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
42007707:	e41281        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200770a:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
4200770d:	40f780        	nsau	a8, a7
42007710:	418580        	srli	a8, a8, 5
42007713:	059f20        	extui	a9, a2, 31, 1
42007716:	208890        	or	a8, a8, a9
42007719:	788c      	beqz.n	a8, 42007724 <tcgetattr+0x44>
        __errno_r(r) = EBADF;
4200771b:	980c      	movi.n	a8, 9
4200771d:	0a89      	s32i.n	a8, a10, 0
        return -1;
4200771f:	f27c      	movi.n	a2, -1
42007721:	000c46        	j	42007756 <tcgetattr+0x76>
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcgetattr, local_fd, p);
42007724:	1788      	l32i.n	a8, a7, 4
42007726:	c888      	l32i.n	a8, a8, 48
42007728:	288c      	beqz.n	a8, 4200772e <tcgetattr+0x4e>
4200772a:	1888      	l32i.n	a8, a8, 4
4200772c:	88cc      	bnez.n	a8, 42007738 <tcgetattr+0x58>
4200772e:	885c      	movi.n	a8, 88
42007730:	0a89      	s32i.n	a8, a10, 0
42007732:	f27c      	movi.n	a2, -1
42007734:	000786        	j	42007756 <tcgetattr+0x76>
42007737:	079800        	lsi	f0, a8, 28
4200773a:	0f6917        	bbci	a9, 1, 4200774d <tcgetattr+0x6d>
4200773d:	03cd      	mov.n	a12, a3
4200773f:	02bd      	mov.n	a11, a2
42007741:	77a8      	l32i.n	a10, a7, 28
42007743:	0008e0        	callx8	a8
42007746:	0a2d      	mov.n	a2, a10
42007748:	000286        	j	42007756 <tcgetattr+0x76>
4200774b:	bd0000        	lsi	f0, a0, 0x2f4
4200774e:	02ad03        	lsi	f0, a13, 8
42007751:	0008e0        	callx8	a8
42007754:	0a2d      	mov.n	a2, a10
    return ret;
}
42007756:	f01d      	retw.n

42007758 <tcsetattr>:

int tcsetattr(int fd, int optional_actions, const struct termios *p)
{
42007758:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
4200775b:	02ad      	mov.n	a10, a2
4200775d:	ff7e65        	call8	42006f44 <get_vfs_for_fd>
42007760:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
42007762:	2a9c      	beqz.n	a10, 42007778 <tcsetattr+0x20>
42007764:	f83c      	movi.n	a8, 63
42007766:	133827        	bltu	a8, a2, 4200777d <tcsetattr+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42007769:	902220        	addx2	a2, a2, a2
4200776c:	e45581        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
4200776f:	882a      	add.n	a8, a8, a2
42007771:	020822        	l8ui	a2, a8, 2
42007774:	0001c6        	j	4200777f <tcsetattr+0x27>
42007777:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
4200777a:	000046        	j	4200777f <tcsetattr+0x27>
4200777d:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
4200777f:	e3f481        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
42007782:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
42007785:	40f780        	nsau	a8, a7
42007788:	418580        	srli	a8, a8, 5
4200778b:	059f20        	extui	a9, a2, 31, 1
4200778e:	208890        	or	a8, a8, a9
42007791:	788c      	beqz.n	a8, 4200779c <tcsetattr+0x44>
        __errno_r(r) = EBADF;
42007793:	980c      	movi.n	a8, 9
42007795:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007797:	f27c      	movi.n	a2, -1
42007799:	000cc6        	j	420077d0 <tcsetattr+0x78>
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcsetattr, local_fd, optional_actions, p);
4200779c:	1788      	l32i.n	a8, a7, 4
4200779e:	c888      	l32i.n	a8, a8, 48
420077a0:	288c      	beqz.n	a8, 420077a6 <tcsetattr+0x4e>
420077a2:	0888      	l32i.n	a8, a8, 0
420077a4:	88cc      	bnez.n	a8, 420077b0 <tcsetattr+0x58>
420077a6:	885c      	movi.n	a8, 88
420077a8:	0a89      	s32i.n	a8, a10, 0
420077aa:	f27c      	movi.n	a2, -1
420077ac:	000806        	j	420077d0 <tcsetattr+0x78>
420077af:	079800        	lsi	f0, a8, 28
420077b2:	0f6917        	bbci	a9, 1, 420077c5 <tcsetattr+0x6d>
420077b5:	04dd      	mov.n	a13, a4
420077b7:	03cd      	mov.n	a12, a3
420077b9:	02bd      	mov.n	a11, a2
420077bb:	77a8      	l32i.n	a10, a7, 28
420077bd:	0008e0        	callx8	a8
420077c0:	0a2d      	mov.n	a2, a10
420077c2:	000286        	j	420077d0 <tcsetattr+0x78>
420077c5:	04cd      	mov.n	a12, a4
420077c7:	03bd      	mov.n	a11, a3
420077c9:	02ad      	mov.n	a10, a2
420077cb:	0008e0        	callx8	a8
420077ce:	0a2d      	mov.n	a2, a10
    return ret;
}
420077d0:	f01d      	retw.n
	...

420077d4 <tcdrain>:

int tcdrain(int fd)
{
420077d4:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420077d7:	02ad      	mov.n	a10, a2
420077d9:	ff76a5        	call8	42006f44 <get_vfs_for_fd>
420077dc:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
420077de:	2a9c      	beqz.n	a10, 420077f4 <tcdrain+0x20>
420077e0:	f83c      	movi.n	a8, 63
420077e2:	133827        	bltu	a8, a2, 420077f9 <tcdrain+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420077e5:	902220        	addx2	a2, a2, a2
420077e8:	e43681        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
420077eb:	882a      	add.n	a8, a8, a2
420077ed:	020822        	l8ui	a2, a8, 2
420077f0:	0001c6        	j	420077fb <tcdrain+0x27>
420077f3:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
420077f6:	000046        	j	420077fb <tcdrain+0x27>
420077f9:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
420077fb:	e3d581        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
420077fe:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
42007801:	40f780        	nsau	a8, a7
42007804:	418580        	srli	a8, a8, 5
42007807:	059f20        	extui	a9, a2, 31, 1
4200780a:	208890        	or	a8, a8, a9
4200780d:	788c      	beqz.n	a8, 42007818 <tcdrain+0x44>
        __errno_r(r) = EBADF;
4200780f:	980c      	movi.n	a8, 9
42007811:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007813:	f27c      	movi.n	a2, -1
42007815:	000ac6        	j	42007844 <tcdrain+0x70>
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcdrain, local_fd);
42007818:	1788      	l32i.n	a8, a7, 4
4200781a:	c888      	l32i.n	a8, a8, 48
4200781c:	288c      	beqz.n	a8, 42007822 <tcdrain+0x4e>
4200781e:	2888      	l32i.n	a8, a8, 8
42007820:	88cc      	bnez.n	a8, 4200782c <tcdrain+0x58>
42007822:	885c      	movi.n	a8, 88
42007824:	0a89      	s32i.n	a8, a10, 0
42007826:	f27c      	movi.n	a2, -1
42007828:	000606        	j	42007844 <tcdrain+0x70>
4200782b:	079800        	lsi	f0, a8, 28
4200782e:	0b6917        	bbci	a9, 1, 4200783d <tcdrain+0x69>
42007831:	02bd      	mov.n	a11, a2
42007833:	77a8      	l32i.n	a10, a7, 28
42007835:	0008e0        	callx8	a8
42007838:	0a2d      	mov.n	a2, a10
4200783a:	000186        	j	42007844 <tcdrain+0x70>
4200783d:	02ad      	mov.n	a10, a2
4200783f:	0008e0        	callx8	a8
42007842:	0a2d      	mov.n	a2, a10
    return ret;
}
42007844:	f01d      	retw.n
	...

42007848 <tcflush>:

int tcflush(int fd, int select)
{
42007848:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
4200784b:	02ad      	mov.n	a10, a2
4200784d:	ff6f65        	call8	42006f44 <get_vfs_for_fd>
42007850:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
42007852:	1a9c      	beqz.n	a10, 42007867 <tcflush+0x1f>
42007854:	f83c      	movi.n	a8, 63
42007856:	123827        	bltu	a8, a2, 4200786c <tcflush+0x24>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42007859:	902220        	addx2	a2, a2, a2
4200785c:	e41981        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc921f0 <s_fd_table>)
4200785f:	882a      	add.n	a8, a8, a2
42007861:	020822        	l8ui	a2, a8, 2
42007864:	000186        	j	4200786e <tcflush+0x26>
    int local_fd = -1;
42007867:	f27c      	movi.n	a2, -1
42007869:	000046        	j	4200786e <tcflush+0x26>
4200786c:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
4200786e:	e3b881        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
42007871:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
42007874:	40f780        	nsau	a8, a7
42007877:	418580        	srli	a8, a8, 5
4200787a:	059f20        	extui	a9, a2, 31, 1
4200787d:	208890        	or	a8, a8, a9
42007880:	888c      	beqz.n	a8, 4200788c <tcflush+0x44>
        __errno_r(r) = EBADF;
42007882:	980c      	movi.n	a8, 9
42007884:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007886:	f27c      	movi.n	a2, -1
42007888:	000c86        	j	420078be <tcflush+0x76>
4200788b:	178800        	lsi	f0, a8, 92
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcflush, local_fd, select);
4200788e:	c888      	l32i.n	a8, a8, 48
42007890:	288c      	beqz.n	a8, 42007896 <tcflush+0x4e>
42007892:	3888      	l32i.n	a8, a8, 12
42007894:	88cc      	bnez.n	a8, 420078a0 <tcflush+0x58>
42007896:	885c      	movi.n	a8, 88
42007898:	0a89      	s32i.n	a8, a10, 0
4200789a:	f27c      	movi.n	a2, -1
4200789c:	000786        	j	420078be <tcflush+0x76>
4200789f:	079800        	lsi	f0, a8, 28
420078a2:	0f6917        	bbci	a9, 1, 420078b5 <tcflush+0x6d>
420078a5:	03cd      	mov.n	a12, a3
420078a7:	02bd      	mov.n	a11, a2
420078a9:	77a8      	l32i.n	a10, a7, 28
420078ab:	0008e0        	callx8	a8
420078ae:	0a2d      	mov.n	a2, a10
420078b0:	000286        	j	420078be <tcflush+0x76>
420078b3:	bd0000        	lsi	f0, a0, 0x2f4
420078b6:	02ad03        	lsi	f0, a13, 8
420078b9:	0008e0        	callx8	a8
420078bc:	0a2d      	mov.n	a2, a10
    return ret;
}
420078be:	f01d      	retw.n

420078c0 <vfs_null_get_empty_fd>:

    return size;
}

static int vfs_null_get_empty_fd(void)
{
420078c0:	004136        	entry	a1, 32
    for (int i = 0; i < VFS_NULL_MAX_FDS; i++) {
420078c3:	020c      	movi.n	a2, 0
420078c5:	000506        	j	420078dd <vfs_null_get_empty_fd+0x1d>
420078c8:	922a00        	lsi	f0, a10, 0x248
        if (GET_FLAGS(g_fds, i) == VFS_NULL_CLOSED) {
420078cb:	e40181        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
420078ce:	0888      	l32i.n	a8, a8, 0
420078d0:	400900        	ssr	a9
420078d3:	918080        	srl	a8, a8
420078d6:	148080        	extui	a8, a8, 0, 2
420078d9:	788c      	beqz.n	a8, 420078e4 <vfs_null_get_empty_fd+0x24>
    for (int i = 0; i < VFS_NULL_MAX_FDS; i++) {
420078db:	221b      	addi.n	a2, a2, 1
420078dd:	f80c      	movi.n	a8, 15
420078df:	e6b827        	bgeu	a8, a2, 420078c9 <vfs_null_get_empty_fd+0x9>
            return i;
        }
    }

    return -1;
420078e2:	f27c      	movi.n	a2, -1
}
420078e4:	f01d      	retw.n
	...

420078e8 <vfs_null_fsync>:
        return -1;
    }
}

static int vfs_null_fsync(int fd)
{
420078e8:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
420078eb:	0fa082        	movi	a8, 15
420078ee:	0eb827        	bgeu	a8, a2, 42007900 <vfs_null_fsync+0x18>
        errno = EBADF;
420078f1:	04afa5        	call8	4200c3ec <__errno>
420078f4:	09a082        	movi	a8, 9
420078f7:	006a82        	s32i	a8, a10, 0
        return -1;
420078fa:	f27c      	movi.n	a2, -1
420078fc:	000086        	j	42007902 <vfs_null_fsync+0x1a>
420078ff:	020c00        	andb	b0, b12, b0
    }

    return 0;
}
42007902:	f01d      	retw.n

42007904 <vfs_null_ioctl>:
{
42007904:	006136        	entry	a1, 48
42007907:	006142        	s32i	a4, a1, 0
4200790a:	016152        	s32i	a5, a1, 4
4200790d:	026162        	s32i	a6, a1, 8
    if (!FD_IN_RANGE(fd)) {
42007910:	f80c      	movi.n	a8, 15
42007912:	0ab827        	bgeu	a8, a2, 42007920 <vfs_null_ioctl+0x1c>
        errno = EBADF;
42007915:	04ad65        	call8	4200c3ec <__errno>
42007918:	980c      	movi.n	a8, 9
4200791a:	0a89      	s32i.n	a8, a10, 0
        return -1;
4200791c:	000246        	j	42007929 <vfs_null_ioctl+0x25>
4200791f:	aca500        	lsi	f0, a5, 0x2b0
        errno = ENOSYS;
42007922:	a08204        	lsi	f0, a2, 0x280
42007925:	8258      	l32i.n	a5, a2, 32
42007927:	006a      	add.n	a0, a0, a6
}
42007929:	ffaf22        	movi	a2, -1
4200792c:	f01d      	retw.n
	...

42007930 <vfs_null_fcntl>:
{
42007930:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
42007933:	0fa082        	movi	a8, 15
42007936:	0bb827        	bgeu	a8, a2, 42007945 <vfs_null_fcntl+0x15>
        errno = EBADF;
42007939:	04ab25        	call8	4200c3ec <__errno>
4200793c:	09a082        	movi	a8, 9
4200793f:	006a82        	s32i	a8, a10, 0
        return -1;
42007942:	000206        	j	4200794e <vfs_null_fcntl+0x1e>
        errno = ENOSYS;
42007945:	04aa65        	call8	4200c3ec <__errno>
42007948:	58a082        	movi	a8, 88
4200794b:	006a82        	s32i	a8, a10, 0
}
4200794e:	ffaf22        	movi	a2, -1
42007951:	f01d      	retw.n
	...

42007954 <vfs_null_close>:
{
42007954:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
42007957:	0fa082        	movi	a8, 15
4200795a:	0eb827        	bgeu	a8, a2, 4200796c <vfs_null_close+0x18>
        errno = EBADF;
4200795d:	04a8e5        	call8	4200c3ec <__errno>
42007960:	09a082        	movi	a8, 9
42007963:	006a82        	s32i	a8, a10, 0
        return -1;
42007966:	f27c      	movi.n	a2, -1
42007968:	000086        	j	4200796e <vfs_null_close+0x1a>
4200796b:	020c00        	andb	b0, b12, b0
}
4200796e:	f01d      	retw.n

42007970 <vfs_null_open>:
{
42007970:	004136        	entry	a1, 32
42007973:	20a220        	or	a10, a2, a2
    if (strcmp(path, "/") != 0) {
42007976:	e3d7b1        	l32r	a11, 420008d4 <_stext+0x8b4> (3c025050 <_flash_rodata_start+0x4f30>)
42007979:	e2b481        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
4200797c:	0008e0        	callx8	a8
4200797f:	00ca16        	beqz	a10, 4200798f <vfs_null_open+0x1f>
        errno = ENOENT;
42007982:	04a6a5        	call8	4200c3ec <__errno>
42007985:	02a082        	movi	a8, 2
42007988:	0a89      	s32i.n	a8, a10, 0
        return -1;
4200798a:	f27c      	movi.n	a2, -1
4200798c:	002006        	j	42007a10 <vfs_null_open+0xa0>
    int fd = vfs_null_get_empty_fd();
4200798f:	fff325        	call8	420078c0 <vfs_null_get_empty_fd>
42007992:	202aa0        	or	a2, a10, a10
    if (fd == -1) {
42007995:	0b0a66        	bnei	a10, -1, 420079a4 <vfs_null_open+0x34>
        errno = EMFILE;
42007998:	04a525        	call8	4200c3ec <__errno>
4200799b:	18a082        	movi	a8, 24
4200799e:	0a89      	s32i.n	a8, a10, 0
        return -1;
420079a0:	001b06        	j	42007a10 <vfs_null_open+0xa0>
420079a3:	303000        	xor	a3, a0, a0
    int acc_mode = flags & O_ACCMODE;
420079a6:	236614        	lsi	f1, a6, 140
    if (acc_mode == O_RDWR) {
420079a9:	baaa25        	call8	41fc244c <_coredump_iram_end+0x1c4044c>
        SET_READABLE(g_fds, fd);
420079ac:	180c      	movi.n	a8, 1
420079ae:	401b00        	ssl	a11
420079b1:	a18800        	sll	a8, a8
420079b4:	e3c791        	l32r	a9, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
420079b7:	09a8      	l32i.n	a10, a9, 0
420079b9:	2088a0        	or	a8, a8, a10
420079bc:	0989      	s32i.n	a8, a9, 0
        SET_WRITABLE(g_fds, fd);
420079be:	2a0c      	movi.n	a10, 2
420079c0:	401b00        	ssl	a11
420079c3:	a1aa00        	sll	a10, a10
420079c6:	2088a0        	or	a8, a8, a10
420079c9:	0989      	s32i.n	a8, a9, 0
420079cb:	001046        	j	42007a10 <vfs_null_open+0xa0>
420079ce:	660000        	lsi	f0, a0, 0x198
    } else if (acc_mode == O_WRONLY) {
420079d1:	aa1613        	lsi	f1, a6, 0x2a8
        SET_WRITABLE(g_fds, fd);
420079d4:	0c8a      	add.n	a0, a12, a8
420079d6:	0029      	s32i.n	a2, a0, 0
420079d8:	4018      	l32i.n	a1, a0, 16
420079da:	a19900        	sll	a9, a9
420079dd:	e3bca1        	l32r	a10, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
420079e0:	0a88      	l32i.n	a8, a10, 0
420079e2:	208890        	or	a8, a8, a9
420079e5:	0a89      	s32i.n	a8, a10, 0
420079e7:	000946        	j	42007a10 <vfs_null_open+0xa0>
    } else if (acc_mode == O_RDONLY) {
420079ea:	63dc      	bnez.n	a3, 42007a04 <vfs_null_open+0x94>
        SET_READABLE(g_fds, fd);
420079ec:	8aaa      	add.n	a8, a10, a10
420079ee:	190c      	movi.n	a9, 1
420079f0:	401800        	ssl	a8
420079f3:	a19900        	sll	a9, a9
420079f6:	e3b6a1        	l32r	a10, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
420079f9:	0a88      	l32i.n	a8, a10, 0
420079fb:	208890        	or	a8, a8, a9
420079fe:	0a89      	s32i.n	a8, a10, 0
42007a00:	000306        	j	42007a10 <vfs_null_open+0xa0>
42007a03:	9e6500        	f64iter	a6, a5, a0, 1, 0
        errno = EINVAL;
42007a06:	a08204        	lsi	f0, a2, 0x280
42007a09:	6a8216        	beqz	a2, 420080b5 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj+0x15>
42007a0c:	af2200        	f64cmph	a2, a2, a0, 10
        return -1;
42007a0f:	ff          	.byte	0xff
}
42007a10:	f01d      	retw.n
	...

42007a14 <vfs_null_pwrite>:
{
42007a14:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd) || !WRITABLE(g_fds, fd)) {
42007a17:	f90c      	movi.n	a9, 15
42007a19:	0f3927        	bltu	a9, a2, 42007a2c <vfs_null_pwrite+0x18>
42007a1c:	822a      	add.n	a8, a2, a2
42007a1e:	e3ac91        	l32r	a9, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
42007a21:	0998      	l32i.n	a9, a9, 0
42007a23:	400800        	ssr	a8
42007a26:	918090        	srl	a8, a9
42007a29:	0fe817        	bbsi	a8, 1, 42007a3c <vfs_null_pwrite+0x28>
        errno = EBADF;
42007a2c:	049be5        	call8	4200c3ec <__errno>
42007a2f:	09a082        	movi	a8, 9
42007a32:	006a82        	s32i	a8, a10, 0
        return -1;
42007a35:	ffaf22        	movi	a2, -1
42007a38:	000086        	j	42007a3e <vfs_null_pwrite+0x2a>
42007a3b:	042d00        	extui	a2, a0, 13, 1
}
42007a3e:	f01d      	retw.n

42007a40 <vfs_null_pread>:
{
42007a40:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd) || !READABLE(g_fds, fd)) {
42007a43:	f80c      	movi.n	a8, 15
42007a45:	0b3827        	bltu	a8, a2, 42007a54 <vfs_null_pread+0x14>
42007a48:	802220        	add	a2, a2, a2
42007a4b:	e3a181        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
42007a4e:	002882        	l32i	a8, a8, 0
42007a51:	0fd827        	bbs	a8, a2, 42007a64 <vfs_null_pread+0x24>
        errno = EBADF;
42007a54:	049965        	call8	4200c3ec <__errno>
42007a57:	09a082        	movi	a8, 9
42007a5a:	006a82        	s32i	a8, a10, 0
        return -1;
42007a5d:	ffaf22        	movi	a2, -1
42007a60:	000086        	j	42007a66 <vfs_null_pread+0x26>
42007a63:	020c00        	andb	b0, b12, b0
}
42007a66:	f01d      	retw.n

42007a68 <vfs_null_read>:
{
42007a68:	004136        	entry	a1, 32
    if (FD_IN_RANGE(fd) && READABLE(g_fds, fd)) {
42007a6b:	f80c      	movi.n	a8, 15
42007a6d:	0b3827        	bltu	a8, a2, 42007a7c <vfs_null_read+0x14>
42007a70:	802220        	add	a2, a2, a2
42007a73:	e39781        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
42007a76:	002882        	l32i	a8, a8, 0
42007a79:	0fd827        	bbs	a8, a2, 42007a8c <vfs_null_read+0x24>
    errno = EBADF;
42007a7c:	0496e5        	call8	4200c3ec <__errno>
42007a7f:	09a082        	movi	a8, 9
42007a82:	006a82        	s32i	a8, a10, 0
    return -1;
42007a85:	ffaf22        	movi	a2, -1
42007a88:	000086        	j	42007a8e <vfs_null_read+0x26>
42007a8b:	020c00        	andb	b0, b12, b0
}
42007a8e:	f01d      	retw.n

42007a90 <vfs_null_lseek>:
{
42007a90:	004136        	entry	a1, 32
    if (!IS_FD_VALID(fd)) {
42007a93:	f80c      	movi.n	a8, 15
42007a95:	133827        	bltu	a8, a2, 42007aac <vfs_null_lseek+0x1c>
42007a98:	222a      	add.n	a2, a2, a2
42007a9a:	e38d81        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
42007a9d:	002882        	l32i	a8, a8, 0
42007aa0:	400200        	ssr	a2
42007aa3:	918080        	srl	a8, a8
42007aa6:	148080        	extui	a8, a8, 0, 2
42007aa9:	00f856        	bnez	a8, 42007abc <vfs_null_lseek+0x2c>
        errno = EBADF;
42007aac:	0493e5        	call8	4200c3ec <__errno>
42007aaf:	09a082        	movi	a8, 9
42007ab2:	006a82        	s32i	a8, a10, 0
        return -1;
42007ab5:	ffaf22        	movi	a2, -1
42007ab8:	000506        	j	42007ad0 <vfs_null_lseek+0x40>
42007abb:	34b600        	extui	a11, a0, 6, 4
    switch (whence) {
42007abe:	0e          	.byte	0xe
        errno = EINVAL;
42007abf:	0492e5        	call8	4200c3ec <__errno>
42007ac2:	16a082        	movi	a8, 22
42007ac5:	006a82        	s32i	a8, a10, 0
        return -1;
42007ac8:	ffaf22        	movi	a2, -1
42007acb:	000046        	j	42007ad0 <vfs_null_lseek+0x40>
        return 0;
42007ace:	020c      	movi.n	a2, 0
}
42007ad0:	f01d      	retw.n
	...

42007ad4 <vfs_null_write>:
{
42007ad4:	004136        	entry	a1, 32
    if (FD_IN_RANGE(fd) && WRITABLE(g_fds, fd)) {
42007ad7:	f90c      	movi.n	a9, 15
42007ad9:	143927        	bltu	a9, a2, 42007af1 <vfs_null_write+0x1d>
42007adc:	822a      	add.n	a8, a2, a2
42007ade:	e37c91        	l32r	a9, 420008d0 <_stext+0x8b0> (3fc95058 <g_fds>)
42007ae1:	0998      	l32i.n	a9, a9, 0
42007ae3:	400800        	ssr	a8
42007ae6:	918090        	srl	a8, a9
42007ae9:	046817        	bbci	a8, 1, 42007af1 <vfs_null_write+0x1d>
        return size;
42007aec:	042d      	mov.n	a2, a4
42007aee:	0002c6        	j	42007afd <vfs_null_write+0x29>
    errno = EBADF;
42007af1:	048fa5        	call8	4200c3ec <__errno>
42007af4:	09a082        	movi	a8, 9
42007af7:	006a82        	s32i	a8, a10, 0
    return -1;
42007afa:	ffaf22        	movi	a2, -1
}
42007afd:	f01d      	retw.n
	...

42007b00 <vfs_null_stat>:
{
42007b00:	004136        	entry	a1, 32
42007b03:	20a220        	or	a10, a2, a2
    if (strcmp(path, "/") != 0) {
42007b06:	e373b1        	l32r	a11, 420008d4 <_stext+0x8b4> (3c025050 <_flash_rodata_start+0x4f30>)
42007b09:	e25081        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
42007b0c:	0008e0        	callx8	a8
42007b0f:	202aa0        	or	a2, a10, a10
42007b12:	00ba16        	beqz	a10, 42007b21 <vfs_null_stat+0x21>
        errno = ENOENT;
42007b15:	048d65        	call8	4200c3ec <__errno>
42007b18:	280c      	movi.n	a8, 2
42007b1a:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007b1c:	f27c      	movi.n	a2, -1
42007b1e:	000846        	j	42007b43 <vfs_null_stat+0x43>
    memset(st, 0, sizeof(struct stat));
42007b21:	8c5c      	movi.n	a12, 88
42007b23:	0b0c      	movi.n	a11, 0
42007b25:	03ad      	mov.n	a10, a3
42007b27:	e1f681        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007b2a:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR | 0666; // Special character device with read/write permissions for everyone
42007b2d:	e36a81        	l32r	a8, 420008d8 <_stext+0x8b8> (21b6 <UserFrameTotalSize+0x20b6>)
42007b30:	1389      	s32i.n	a8, a3, 4
    st->st_nlink = 1;
42007b32:	180c      	movi.n	a8, 1
42007b34:	045382        	s16i	a8, a3, 8
    st->st_uid = 0;
42007b37:	080c      	movi.n	a8, 0
42007b39:	055382        	s16i	a8, a3, 10
    st->st_gid = 0;
42007b3c:	065382        	s16i	a8, a3, 12
    st->st_size = 0;
42007b3f:	080c      	movi.n	a8, 0
42007b41:	4389      	s32i.n	a8, a3, 16
}
42007b43:	f01d      	retw.n
42007b45:	000000        	ill

42007b48 <vfs_null_fstat>:
{
42007b48:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
42007b4b:	0fa082        	movi	a8, 15
42007b4e:	0eb827        	bgeu	a8, a2, 42007b60 <vfs_null_fstat+0x18>
        errno = EBADF;
42007b51:	0489a5        	call8	4200c3ec <__errno>
42007b54:	09a082        	movi	a8, 9
42007b57:	006a82        	s32i	a8, a10, 0
        return -1;
42007b5a:	f27c      	movi.n	a2, -1
42007b5c:	000886        	j	42007b82 <vfs_null_fstat+0x3a>
42007b5f:	8c5c00        	lsi	f0, a12, 0x230
    memset(st, 0, sizeof(struct stat));
42007b62:	0b0c      	movi.n	a11, 0
42007b64:	03ad      	mov.n	a10, a3
42007b66:	e1e681        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007b69:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR | 0666; // Special character device with read/write permissions for everyone
42007b6c:	e35b81        	l32r	a8, 420008d8 <_stext+0x8b8> (21b6 <UserFrameTotalSize+0x20b6>)
42007b6f:	1389      	s32i.n	a8, a3, 4
    st->st_nlink = 1;
42007b71:	180c      	movi.n	a8, 1
42007b73:	045382        	s16i	a8, a3, 8
    st->st_uid = 0;
42007b76:	080c      	movi.n	a8, 0
42007b78:	055382        	s16i	a8, a3, 10
    st->st_gid = 0;
42007b7b:	065382        	s16i	a8, a3, 12
    st->st_size = 0;
42007b7e:	020c      	movi.n	a2, 0
42007b80:	4329      	s32i.n	a2, a3, 16
}
42007b82:	f01d      	retw.n

42007b84 <esp_vfs_null_register>:
{
42007b84:	004136        	entry	a1, 32
    return esp_vfs_register_fs("/dev/null", &s_vfs_null, ESP_VFS_FLAG_STATIC, NULL);
42007b87:	0d0c      	movi.n	a13, 0
42007b89:	8c0c      	movi.n	a12, 8
42007b8b:	e354b1        	l32r	a11, 420008dc <_stext+0x8bc> (3c0286c0 <s_vfs_null>)
42007b8e:	e354a1        	l32r	a10, 420008e0 <_stext+0x8c0> (3c025094 <_flash_rodata_start+0x4f74>)
42007b91:	ff32e5        	call8	42006ec0 <esp_vfs_register_fs>
}
42007b94:	0a2d      	mov.n	a2, a10
42007b96:	f01d      	retw.n

42007b98 <__esp_system_init_fn_init_vfs_nullfs>:

#if defined(CONFIG_VFS_INITIALIZE_DEV_NULL) || defined(CONFIG_ESP_CONSOLE_NONE)
ESP_SYSTEM_INIT_FN(init_vfs_nullfs, CORE, BIT(0), 113)
{
42007b98:	004136        	entry	a1, 32
    return esp_vfs_null_register();
42007b9b:	fffea5        	call8	42007b84 <esp_vfs_null_register>
}
42007b9e:	0a2d      	mov.n	a2, a10
42007ba0:	f01d      	retw.n
	...

42007ba4 <app_main>:
#endif

int32_t cycles{0};

extern "C" void app_main(void)
{
42007ba4:	004136        	entry	a1, 32
    #if USE_ETL
        printf("Using ETL...\n");
    #else
        printf("Using libstdc++...\n"); 
42007ba7:	e34fa1        	l32r	a10, 420008e4 <_stext+0x8c4> (3c0250a0 <_flash_rodata_start+0x4f80>)
42007baa:	042da5        	call8	4200be84 <puts>
    #endif

    #if USE_STRING
        printf("Benchmarking string operations...\n"); 
42007bad:	e34ea1        	l32r	a10, 420008e8 <_stext+0x8c8> (3c0250b4 <_flash_rodata_start+0x4f94>)
42007bb0:	042d25        	call8	4200be84 <puts>
        string_benchmark(cycles);
42007bb3:	e34e81        	l32r	a8, 420008ec <_stext+0x8cc> (3fc9505c <cycles>)
42007bb6:	0028a2        	l32i	a10, a8, 0
42007bb9:	007865        	call8	42008340 <_Z16string_benchmarkm>
        set_benchmark(cycles); 
    #elif USE_DEQUE     
        printf("Benchmarking deque operations...\n"); 
        deque_benchmark(cycles); 
    #endif
}
42007bbc:	f01d      	retw.n
	...

42007bc0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj>:
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _GLIBCXX20_CONSTEXPR
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
42007bc0:	004136        	entry	a1, 32
    _M_create(size_type& __capacity, size_type __old_capacity)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 83.  String::npos vs. string::max_size()
      if (__capacity > max_size())
42007bc3:	0388      	l32i.n	a8, a3, 0
42007bc5:	0088d6        	bgez	a8, 42007bd1 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x11>
	std::__throw_length_error(__N("basic_string::_M_create"));
42007bc8:	e34aa1        	l32r	a10, 420008f0 <_stext+0x8d0> (3c0250d8 <_flash_rodata_start+0x4fb8>)
42007bcb:	201110        	or	a1, a1, a1
42007bce:	02fd65        	call8	4200aba4 <_ZSt20__throw_length_errorPKc>

      // The below implements an exponential growth policy, necessary to
      // meet amortized linear time requirements of the library: see
      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
42007bd1:	10b487        	bgeu	a4, a8, 42007be5 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x25>
42007bd4:	804440        	add	a4, a4, a4
42007bd7:	0ab847        	bgeu	a8, a4, 42007be5 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x25>
	{
	  __capacity = 2 * __old_capacity;
42007bda:	006342        	s32i	a4, a3, 0
	  // Never allocate a string bigger than max_size.
	  if (__capacity > max_size())
42007bdd:	0044d6        	bgez	a4, 42007be5 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x25>
	    __capacity = max_size();
42007be0:	e25681        	l32r	a8, 42000538 <_stext+0x518> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42007be3:	0389      	s32i.n	a8, a3, 0
	}

      // NB: Need an array of char_type[__capacity], plus a terminating
      // null char_type() element.
      return _S_allocate(_M_get_allocator(), __capacity + 1);
42007be5:	0023a2        	l32i	a10, a3, 0
42007be8:	01caa2        	addi	a10, a10, 1
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 3308. std::allocator<void>().allocate(n)
	static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
#endif

	if (__builtin_expect(__n > this->_M_max_size(), false))
42007beb:	002ad6        	bgez	a10, 42007bf1 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj+0x31>
	  {
	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
	    // 3190. allocator::allocate sometimes returns too little storage
	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
	      std::__throw_bad_array_new_length();
	    std::__throw_bad_alloc();
42007bee:	02f5e5        	call8	4200ab4c <_ZSt17__throw_bad_allocv>
	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
	    return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp),
							   __al));
	  }
#endif
	return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp)));
42007bf1:	02dee5        	call8	4200a9e0 <_Znwj>
    }
42007bf4:	0a2d      	mov.n	a2, a10
42007bf6:	f01d      	retw.n

42007bf8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE2atEj>:
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */
      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      reference
      at(size_type __n)
42007bf8:	004136        	entry	a1, 32
      { return _M_string_length; }
42007bfb:	12c8      	l32i.n	a12, a2, 4
      {
	if (__n >= size())
42007bfd:	0733c7        	bltu	a3, a12, 42007c08 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE2atEj+0x10>
	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
42007c00:	03bd      	mov.n	a11, a3
42007c02:	e33ca1        	l32r	a10, 420008f4 <_stext+0x8d4> (3c0250f0 <_flash_rodata_start+0x4fd0>)
42007c05:	0300e5        	call8	4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>
      { return _M_dataplus._M_p; }
42007c08:	0228      	l32i.n	a2, a2, 0
				       "(which is %zu) >= this->size() "
				       "(which is %zu)"),
				   __n, this->size());
	return _M_data()[__n];
      }
42007c0a:	223a      	add.n	a2, a2, a3
42007c0c:	f01d      	retw.n
	...

42007c10 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_checkEjPKc>:
      _M_check(size_type __pos, const char* __s) const
42007c10:	004136        	entry	a1, 32
      { return _M_string_length; }
42007c13:	0122d2        	l32i	a13, a2, 4
	if (__pos > this->size())
42007c16:	0bbd37        	bgeu	a13, a3, 42007c25 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_checkEjPKc+0x15>
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
42007c19:	20c330        	or	a12, a3, a3
42007c1c:	20b440        	or	a11, a4, a4
42007c1f:	e336a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025134 <_flash_rodata_start+0x5014>)
42007c22:	02ff25        	call8	4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>
      }
42007c25:	032d      	mov.n	a2, a3
42007c27:	f01d      	retw.n
42007c29:	000000        	ill

42007c2c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcjc>:
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
42007c2c:	004136        	entry	a1, 32
42007c2f:	74b040        	extui	a11, a4, 0, 8
	if (__n == 1)
42007c32:	061366        	bnei	a3, 1, 42007c3c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcjc+0x10>
#if __cpp_constexpr_dynamic_alloc
	if (std::__is_constant_evaluated())
	  std::construct_at(__builtin_addressof(__c1), __c2);
	else
#endif
	__c1 = __c2;
42007c35:	0042b2        	s8i	a11, a2, 0
      }
42007c38:	000306        	j	42007c48 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcjc+0x1c>
42007c3b:	00          	.byte	00
      }

      static _GLIBCXX20_CONSTEXPR char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
	if (__n == 0)
42007c3c:	838c      	beqz.n	a3, 42007c48 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcjc+0x1c>
	  return __s;
#if __cplusplus >= 202002L
	if (std::__is_constant_evaluated())
	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
#endif
	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
42007c3e:	03cd      	mov.n	a12, a3
42007c40:	02ad      	mov.n	a10, a2
42007c42:	e1af81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007c45:	0008e0        	callx8	a8
      }
42007c48:	f01d      	retw.n
	...

42007c4c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructEjc>:
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _GLIBCXX20_CONSTEXPR
    void
    basic_string<_CharT, _Traits, _Alloc>::
42007c4c:	006136        	entry	a1, 48
42007c4f:	006132        	s32i	a3, a1, 0
42007c52:	744040        	extui	a4, a4, 0, 8
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
42007c55:	0fa092        	movi	a9, 15
42007c58:	0fb937        	bgeu	a9, a3, 42007c6b <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructEjc+0x1f>
	{
	  _M_data(_M_create(__n, size_type(0)));
42007c5b:	0c0c      	movi.n	a12, 0
42007c5d:	01bd      	mov.n	a11, a1
42007c5f:	20a220        	or	a10, a2, a2
42007c62:	fff5e5        	call8	42007bc0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj>
      { _M_dataplus._M_p = __p; }
42007c65:	02a9      	s32i.n	a10, a2, 0
	  _M_capacity(__n);
42007c67:	0188      	l32i.n	a8, a1, 0
      { _M_allocated_capacity = __capacity; }
42007c69:	2289      	s32i.n	a8, a2, 8
	}
      else
	_M_init_local_buf();

      if (__n)
42007c6b:	01b8      	l32i.n	a11, a1, 0
42007c6d:	5b8c      	beqz.n	a11, 42007c76 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructEjc+0x2a>
	this->_S_assign(_M_data(), __n, __c);
42007c6f:	04cd      	mov.n	a12, a4
42007c71:	02a8      	l32i.n	a10, a2, 0
42007c73:	fffba5        	call8	42007c2c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcjc>

      _M_set_length(__n);
42007c76:	0198      	l32i.n	a9, a1, 0
      { _M_string_length = __length; }
42007c78:	1299      	s32i.n	a9, a2, 4
      { return _M_dataplus._M_p; }
42007c7a:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
42007c7c:	889a      	add.n	a8, a8, a9
	__c1 = __c2;
42007c7e:	090c      	movi.n	a9, 0
42007c80:	004892        	s8i	a9, a8, 0
    }
42007c83:	f01d      	retw.n
42007c85:	000000        	ill

42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>:
      _M_dispose()
42007c88:	004136        	entry	a1, 32
      { return _M_dataplus._M_p; }
42007c8b:	0022a2        	l32i	a10, a2, 0
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
42007c8e:	08c282        	addi	a8, a2, 8
	if (_M_data() == _M_local_data())
42007c91:	071a87        	beq	a10, a8, 42007c9c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv+0x14>
	  _M_destroy(_M_allocated_capacity);
42007c94:	0222b2        	l32i	a11, a2, 8
	    _GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n),
				     std::align_val_t(alignof(_Tp)));
	    return;
	  }
#endif
	_GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n));
42007c97:	bb1b      	addi.n	a11, a11, 1
42007c99:	02d265        	call8	4200a9c0 <_ZdlPvj>
      }
42007c9c:	f01d      	retw.n
	...

42007ca0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev>:
      ~basic_string()
42007ca0:	004136        	entry	a1, 32
42007ca3:	02ad      	mov.n	a10, a2
      { _M_dispose(); }
42007ca5:	fffe25        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
42007ca8:	f01d      	retw.n
	...

42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>:
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
42007cac:	004136        	entry	a1, 32
	if (__n == 1)
42007caf:	081466        	bnei	a4, 1, 42007cbb <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj+0xf>
42007cb2:	000382        	l8ui	a8, a3, 0
42007cb5:	004282        	s8i	a8, a2, 0
      }
42007cb8:	000346        	j	42007cc9 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj+0x1d>
	if (__n == 0)
42007cbb:	a48c      	beqz.n	a4, 42007cc9 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj+0x1d>
	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
42007cbd:	04cd      	mov.n	a12, a4
42007cbf:	03bd      	mov.n	a11, a3
42007cc1:	02ad      	mov.n	a10, a2
42007cc3:	e0d981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42007cc6:	0008e0        	callx8	a8
      }
42007cc9:	f01d      	retw.n
	...

42007ccc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj>:
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _GLIBCXX20_CONSTEXPR
    void
    basic_string<_CharT, _Traits, _Alloc>::
42007ccc:	008136        	entry	a1, 64
42007ccf:	4159      	s32i.n	a5, a1, 16
      { return _M_string_length; }
42007cd1:	1288      	l32i.n	a8, a2, 4
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
	      size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;
42007cd3:	c05830        	sub	a5, a8, a3
42007cd6:	c05540        	sub	a5, a5, a4

      size_type __new_capacity = length() + __len2 - __len1;
42007cd9:	868a      	add.n	a8, a6, a8
42007cdb:	c08840        	sub	a8, a8, a4
42007cde:	0189      	s32i.n	a8, a1, 0
      { return _M_dataplus._M_p; }
42007ce0:	0288      	l32i.n	a8, a2, 0
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
42007ce2:	928b      	addi.n	a9, a2, 8
	if (_M_data() == _M_local_data())
42007ce4:	041987        	beq	a9, a8, 42007cec <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj+0x20>
	return _M_is_local() ? size_type(_S_local_capacity)
42007ce7:	22c8      	l32i.n	a12, a2, 8
42007ce9:	000086        	j	42007cef <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj+0x23>
42007cec:	0fa0c2        	movi	a12, 15
      pointer __r = _M_create(__new_capacity, capacity());
42007cef:	20b110        	or	a11, a1, a1
42007cf2:	02ad      	mov.n	a10, a2
42007cf4:	ffeca5        	call8	42007bc0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj>
42007cf7:	0a7d      	mov.n	a7, a10

      if (__pos)
42007cf9:	538c      	beqz.n	a3, 42007d02 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj+0x36>
	this->_S_copy(__r, _M_data(), __pos);
42007cfb:	03cd      	mov.n	a12, a3
42007cfd:	02b8      	l32i.n	a11, a2, 0
42007cff:	fffae5        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
      if (__s && __len2)
42007d02:	042192        	l32i	a9, a1, 16
42007d05:	01a082        	movi	a8, 1
42007d08:	838990        	moveqz	a8, a9, a9
42007d0b:	01a092        	movi	a9, 1
42007d0e:	839660        	moveqz	a9, a6, a6
42007d11:	080897        	bnone	a8, a9, 42007d1d <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj+0x51>
	this->_S_copy(__r + __pos, __s, __len2);
42007d14:	06cd      	mov.n	a12, a6
42007d16:	41b8      	l32i.n	a11, a1, 16
42007d18:	a73a      	add.n	a10, a7, a3
42007d1a:	fff925        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
      if (__how_much)
42007d1d:	010516        	beqz	a5, 42007d31 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj+0x65>
	this->_S_copy(__r + __pos + __len2,
42007d20:	80a360        	add	a10, a3, a6
      { return _M_dataplus._M_p; }
42007d23:	0022b2        	l32i	a11, a2, 0
		      _M_data() + __pos + __len1, __how_much);
42007d26:	334a      	add.n	a3, a3, a4
	this->_S_copy(__r + __pos + __len2,
42007d28:	05cd      	mov.n	a12, a5
42007d2a:	bb3a      	add.n	a11, a11, a3
42007d2c:	a7aa      	add.n	a10, a7, a10
42007d2e:	fff7e5        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>

      _M_dispose();
42007d31:	20a220        	or	a10, a2, a2
42007d34:	fff525        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
      { _M_dataplus._M_p = __p; }
42007d37:	006272        	s32i	a7, a2, 0
      _M_data(__r);
      _M_capacity(__new_capacity);
42007d3a:	002182        	l32i	a8, a1, 0
      { _M_allocated_capacity = __capacity; }
42007d3d:	2289      	s32i.n	a8, a2, 8
    }
42007d3f:	f01d      	retw.n
42007d41:	000000        	ill

42007d44 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc>:
       *  @brief  Append a single character.
       *  @param __c  Character to append.
       */
      _GLIBCXX20_CONSTEXPR
      void
      push_back(_CharT __c)
42007d44:	004136        	entry	a1, 32
42007d47:	743030        	extui	a3, a3, 0, 8
      { return _M_string_length; }
42007d4a:	1268      	l32i.n	a6, a2, 4
      {
	const size_type __size = this->size();
	if (__size + 1 > this->capacity())
42007d4c:	761b      	addi.n	a7, a6, 1
      { return _M_dataplus._M_p; }
42007d4e:	0288      	l32i.n	a8, a2, 0
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
42007d50:	928b      	addi.n	a9, a2, 8
	if (_M_data() == _M_local_data())
42007d52:	041987        	beq	a9, a8, 42007d5a <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc+0x16>
	return _M_is_local() ? size_type(_S_local_capacity)
42007d55:	2288      	l32i.n	a8, a2, 8
42007d57:	000046        	j	42007d5c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc+0x18>
42007d5a:	f80c      	movi.n	a8, 15
	if (__size + 1 > this->capacity())
42007d5c:	0cb877        	bgeu	a8, a7, 42007d6c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc+0x28>
	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
42007d5f:	1e0c      	movi.n	a14, 1
42007d61:	0d0c      	movi.n	a13, 0
42007d63:	0dcd      	mov.n	a12, a13
42007d65:	06bd      	mov.n	a11, a6
42007d67:	02ad      	mov.n	a10, a2
42007d69:	fff625        	call8	42007ccc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj>
      { return _M_dataplus._M_p; }
42007d6c:	02b8      	l32i.n	a11, a2, 0
	traits_type::assign(this->_M_data()[__size], __c);
42007d6e:	bb6a      	add.n	a11, a11, a6
	__c1 = __c2;
42007d70:	004b32        	s8i	a3, a11, 0
      { _M_string_length = __length; }
42007d73:	1279      	s32i.n	a7, a2, 4
      { return _M_dataplus._M_p; }
42007d75:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
42007d77:	887a      	add.n	a8, a8, a7
42007d79:	090c      	movi.n	a9, 0
42007d7b:	004892        	s8i	a9, a8, 0
	this->_M_set_length(__size + 1);
      }
42007d7e:	f01d      	retw.n

42007d80 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj>:
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _GLIBCXX20_CONSTEXPR
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
42007d80:	004136        	entry	a1, 32
42007d83:	04ed      	mov.n	a14, a4
      { return _M_string_length; }
42007d85:	1288      	l32i.n	a8, a2, 4
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();
42007d87:	448a      	add.n	a4, a4, a8
      { return _M_dataplus._M_p; }
42007d89:	02a8      	l32i.n	a10, a2, 0
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
42007d8b:	928b      	addi.n	a9, a2, 8
	if (_M_data() == _M_local_data())
42007d8d:	041a97        	beq	a10, a9, 42007d95 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj+0x15>
	return _M_is_local() ? size_type(_S_local_capacity)
42007d90:	2298      	l32i.n	a9, a2, 8
42007d92:	000086        	j	42007d98 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj+0x18>
42007d95:	0fa092        	movi	a9, 15

      if (__len <= this->capacity())
42007d98:	103947        	bltu	a9, a4, 42007dac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj+0x2c>
	{
	  if (__n)
42007d9b:	01be16        	beqz	a14, 42007dba <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj+0x3a>
	    this->_S_copy(this->_M_data() + this->size(), __s, __n);
42007d9e:	20cee0        	or	a12, a14, a14
42007da1:	03bd      	mov.n	a11, a3
42007da3:	aa8a      	add.n	a10, a10, a8
42007da5:	fff065        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
42007da8:	000386        	j	42007dba <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj+0x3a>
42007dab:	00          	.byte	00
	}
      else
	this->_M_mutate(this->size(), size_type(0), __s, __n);
42007dac:	20d330        	or	a13, a3, a3
42007daf:	00a0c2        	movi	a12, 0
42007db2:	20b880        	or	a11, a8, a8
42007db5:	02ad      	mov.n	a10, a2
42007db7:	fff165        	call8	42007ccc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj>
      { _M_string_length = __length; }
42007dba:	1249      	s32i.n	a4, a2, 4
      { return _M_dataplus._M_p; }
42007dbc:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
42007dbe:	884a      	add.n	a8, a8, a4
42007dc0:	090c      	movi.n	a9, 0
42007dc2:	004892        	s8i	a9, a8, 0

      this->_M_set_length(__len);
      return *this;
    }
42007dc5:	f01d      	retw.n
	...

42007dc8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKc>:
      append(const _CharT* __s)
42007dc8:	004136        	entry	a1, 32
	return __builtin_strlen(__s);
42007dcb:	20a330        	or	a10, a3, a3
42007dce:	e13381        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42007dd1:	0008e0        	callx8	a8
42007dd4:	20caa0        	or	a12, a10, a10
      { return _M_string_length; }
42007dd7:	012292        	l32i	a9, a2, 4
	if (this->max_size() - (this->size() - __n1) < __n2)
42007dda:	e1d781        	l32r	a8, 42000538 <_stext+0x518> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42007ddd:	c08890        	sub	a8, a8, a9
42007de0:	05b8a7        	bgeu	a8, a10, 42007de9 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKc+0x21>
	  __throw_length_error(__N(__s));
42007de3:	e2c6a1        	l32r	a10, 420008fc <_stext+0x8dc> (3c02516c <_flash_rodata_start+0x504c>)
42007de6:	02dbe5        	call8	4200aba4 <_ZSt20__throw_length_errorPKc>
	return _M_append(__s, __n);
42007de9:	03bd      	mov.n	a11, a3
42007deb:	02ad      	mov.n	a10, a2
42007ded:	fff925        	call8	42007d80 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj>
      }
42007df0:	0a2d      	mov.n	a2, a10
42007df2:	f01d      	retw.n

42007df4 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEj>:
    basic_string<_CharT, _Traits, _Alloc>::
42007df4:	006136        	entry	a1, 48
42007df7:	0139      	s32i.n	a3, a1, 0
      { return _M_dataplus._M_p; }
42007df9:	0288      	l32i.n	a8, a2, 0
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
42007dfb:	928b      	addi.n	a9, a2, 8
	if (_M_data() == _M_local_data())
42007dfd:	041987        	beq	a9, a8, 42007e05 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEj+0x11>
	return _M_is_local() ? size_type(_S_local_capacity)
42007e00:	22c8      	l32i.n	a12, a2, 8
42007e02:	000086        	j	42007e08 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEj+0x14>
42007e05:	0fa0c2        	movi	a12, 15
      if (__res <= __capacity)
42007e08:	0188      	l32i.n	a8, a1, 0
42007e0a:	1cbc87        	bgeu	a12, a8, 42007e2a <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEj+0x36>
      pointer __tmp = _M_create(__res, __capacity);
42007e0d:	01bd      	mov.n	a11, a1
42007e0f:	02ad      	mov.n	a10, a2
42007e11:	ffdae5        	call8	42007bc0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj>
42007e14:	0a7d      	mov.n	a7, a10
      { return _M_string_length; }
42007e16:	12c8      	l32i.n	a12, a2, 4
      this->_S_copy(__tmp, _M_data(), length() + 1);
42007e18:	cc1b      	addi.n	a12, a12, 1
42007e1a:	02b8      	l32i.n	a11, a2, 0
42007e1c:	ffe8e5        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
      _M_dispose();
42007e1f:	02ad      	mov.n	a10, a2
42007e21:	ffe665        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
      { _M_dataplus._M_p = __p; }
42007e24:	0279      	s32i.n	a7, a2, 0
      _M_capacity(__res);
42007e26:	0188      	l32i.n	a8, a1, 0
      { _M_allocated_capacity = __capacity; }
42007e28:	2289      	s32i.n	a8, a2, 8
    }
42007e2a:	f01d      	retw.n

42007e2c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE_EEvjT_>:

#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
  template<typename _Operation>
    _GLIBCXX20_CONSTEXPR void
    basic_string<_CharT, _Traits, _Alloc>::
42007e2c:	006136        	entry	a1, 48
42007e2f:	03bd      	mov.n	a11, a3
    resize_and_overwrite(const size_type __n, _Operation __op)
#else
    __resize_and_overwrite(const size_type __n, _Operation __op)
#endif
    {
      reserve(__n);
42007e31:	02ad      	mov.n	a10, a2
42007e33:	fffc25        	call8	42007df4 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEj>
      { return _M_dataplus._M_p; }
42007e36:	0278      	l32i.n	a7, a2, 0
      struct _Terminator {
	_GLIBCXX20_CONSTEXPR ~_Terminator() { _M_this->_M_set_length(_M_r); }
	basic_string* _M_this;
	size_type _M_r;
      };
      _Terminator __term{this, 0};
42007e38:	8c0c      	movi.n	a12, 8
42007e3a:	0b0c      	movi.n	a11, 0
42007e3c:	20a110        	or	a10, a1, a1
42007e3f:	e13081        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007e42:	0008e0        	callx8	a8
42007e45:	0129      	s32i.n	a2, a1, 0
        "string: _str_tiny.resize(MAX_STRLN)"
    );

    _str_tiny.resize(2); /** undo resize above */

    CYCLE_GET_COUNT(
42007e47:	5c0c      	movi.n	a12, 5
42007e49:	e2adb1        	l32r	a11, 42000900 <_stext+0x8e0> (3c025184 <_flash_rodata_start+0x5064>)
42007e4c:	07ad      	mov.n	a10, a7
42007e4e:	e07681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42007e51:	0008e0        	callx8	a8
#else
      static_assert(__gnu_cxx::__is_integer_nonstrict<decltype(__r)>::__value,
		    "resize_and_overwrite operation must return an integer");
#endif
      _GLIBCXX_DEBUG_ASSERT(__r >= 0 && __r <= __n);
      __term._M_r = size_type(__r);
42007e54:	580c      	movi.n	a8, 5
42007e56:	1189      	s32i.n	a8, a1, 4
      { _M_string_length = __length; }
42007e58:	1289      	s32i.n	a8, a2, 4
      { return _M_dataplus._M_p; }
42007e5a:	0288      	l32i.n	a8, a2, 0
	__c1 = __c2;
42007e5c:	090c      	movi.n	a9, 0
42007e5e:	054892        	s8i	a9, a8, 5
      if (__term._M_r > __n)
	__builtin_unreachable();
    }
42007e61:	f01d      	retw.n
	...

42007e64 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE0_EEvjT_>:
    basic_string<_CharT, _Traits, _Alloc>::
42007e64:	006136        	entry	a1, 48
42007e67:	03bd      	mov.n	a11, a3
      reserve(__n);
42007e69:	02ad      	mov.n	a10, a2
42007e6b:	fff8a5        	call8	42007df4 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEj>
42007e6e:	0278      	l32i.n	a7, a2, 0
      _Terminator __term{this, 0};
42007e70:	8c0c      	movi.n	a12, 8
42007e72:	0b0c      	movi.n	a11, 0
42007e74:	20a110        	or	a10, a1, a1
42007e77:	e12281        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007e7a:	0008e0        	callx8	a8
42007e7d:	0129      	s32i.n	a2, a1, 0
42007e7f:	5c0c      	movi.n	a12, 5
42007e81:	e29fb1        	l32r	a11, 42000900 <_stext+0x8e0> (3c025184 <_flash_rodata_start+0x5064>)
42007e84:	07ad      	mov.n	a10, a7
42007e86:	e06881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42007e89:	0008e0        	callx8	a8
      __term._M_r = size_type(__r);
42007e8c:	580c      	movi.n	a8, 5
42007e8e:	1189      	s32i.n	a8, a1, 4
      { _M_string_length = __length; }
42007e90:	1289      	s32i.n	a8, a2, 4
      { return _M_dataplus._M_p; }
42007e92:	0288      	l32i.n	a8, a2, 0
42007e94:	090c      	movi.n	a9, 0
42007e96:	054892        	s8i	a9, a8, 5
    }
42007e99:	f01d      	retw.n
	...

42007e9c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag>:
      basic_string<_CharT, _Traits, _Alloc>::
42007e9c:	006136        	entry	a1, 48
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
42007e9f:	c04430        	sub	a4, a4, a3
	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
42007ea2:	006142        	s32i	a4, a1, 0
	if (__dnew > size_type(_S_local_capacity))
42007ea5:	0fa082        	movi	a8, 15
42007ea8:	0fb847        	bgeu	a8, a4, 42007ebb <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag+0x1f>
	    _M_data(_M_create(__dnew, size_type(0)));
42007eab:	0c0c      	movi.n	a12, 0
42007ead:	01bd      	mov.n	a11, a1
42007eaf:	20a220        	or	a10, a2, a2
42007eb2:	ffd0e5        	call8	42007bc0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj>
      { _M_dataplus._M_p = __p; }
42007eb5:	02a9      	s32i.n	a10, a2, 0
	    _M_capacity(__dnew);
42007eb7:	0188      	l32i.n	a8, a1, 0
      { _M_allocated_capacity = __capacity; }
42007eb9:	2289      	s32i.n	a8, a2, 8
	  explicit _Guard(basic_string* __s) : _M_guarded(__s) { }
42007ebb:	1129      	s32i.n	a2, a1, 4
      { _S_copy(__p, __k1, __k2 - __k1); }
42007ebd:	04cd      	mov.n	a12, a4
42007ebf:	03bd      	mov.n	a11, a3
42007ec1:	02a8      	l32i.n	a10, a2, 0
42007ec3:	ffdea5        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
	__guard._M_guarded = 0;
42007ec6:	090c      	movi.n	a9, 0
42007ec8:	1199      	s32i.n	a9, a1, 4
	_M_set_length(__dnew);
42007eca:	01a8      	l32i.n	a10, a1, 0
      { _M_string_length = __length; }
42007ecc:	12a9      	s32i.n	a10, a2, 4
      { return _M_dataplus._M_p; }
42007ece:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
42007ed0:	88aa      	add.n	a8, a8, a10
42007ed2:	004892        	s8i	a9, a8, 0
      }
42007ed5:	f01d      	retw.n
	...

42007ed8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcjRKS3_>:
      basic_string(const _CharT* __s, size_type __n,
42007ed8:	004136        	entry	a1, 32
42007edb:	20a220        	or	a10, a2, a2
42007ede:	20b330        	or	a11, a3, a3
	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
42007ee1:	08c282        	addi	a8, a2, 8
	: allocator_type(__a), _M_p(__dat) { }
42007ee4:	0289      	s32i.n	a8, a2, 0
	if (__s == 0 && __n > 0)
42007ee6:	40f380        	nsau	a8, a3
42007ee9:	418580        	srli	a8, a8, 5
42007eec:	190c      	movi.n	a9, 1
42007eee:	839440        	moveqz	a9, a4, a4
42007ef1:	050897        	bnone	a8, a9, 42007efa <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcjRKS3_+0x22>
	  std::__throw_logic_error(__N("basic_string: "
42007ef4:	e284a1        	l32r	a10, 42000904 <_stext+0x8e4> (3c02518c <_flash_rodata_start+0x506c>)
42007ef7:	02c765        	call8	4200ab6c <_ZSt19__throw_logic_errorPKc>
	_M_construct(__s, __s + __n, std::forward_iterator_tag());
42007efa:	00a0d2        	movi	a13, 0
42007efd:	80c340        	add	a12, a3, a4
42007f00:	fff9a5        	call8	42007e9c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag>
      }
42007f03:	000090        	retw
	...

42007f08 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ISt17basic_string_viewIcS2_EvEERKT_RKS3_>:
	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
42007f08:	008136        	entry	a1, 64
42007f0b:	20a220        	or	a10, a2, a2
42007f0e:	20d440        	or	a13, a4, a4
42007f11:	002392        	l32i	a9, a3, 0
42007f14:	1388      	l32i.n	a8, a3, 4
42007f16:	6199      	s32i.n	a9, a1, 24
42007f18:	7189      	s32i.n	a8, a1, 28
      { return __svt; }
42007f1a:	0199      	s32i.n	a9, a1, 0
42007f1c:	1189      	s32i.n	a8, a1, 4
42007f1e:	2199      	s32i.n	a9, a1, 8
42007f20:	3189      	s32i.n	a8, a1, 12
	__sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
42007f22:	4199      	s32i.n	a9, a1, 16
42007f24:	5189      	s32i.n	a8, a1, 20
      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
42007f26:	09cd      	mov.n	a12, a9
42007f28:	08bd      	mov.n	a11, a8
42007f2a:	fffae5        	call8	42007ed8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcjRKS3_>
	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
42007f2d:	f01d      	retw.n
	...

42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>:
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
42007f30:	004136        	entry	a1, 32
	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
42007f33:	08c282        	addi	a8, a2, 8
	: allocator_type(__a), _M_p(__dat) { }
42007f36:	006282        	s32i	a8, a2, 0
	if (__s == 0)
42007f39:	43cc      	bnez.n	a3, 42007f41 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_+0x11>
	  std::__throw_logic_error(__N("basic_string: "
42007f3b:	e272a1        	l32r	a10, 42000904 <_stext+0x8e4> (3c02518c <_flash_rodata_start+0x506c>)
42007f3e:	02c2e5        	call8	4200ab6c <_ZSt19__throw_logic_errorPKc>
	return __builtin_strlen(__s);
42007f41:	03ad      	mov.n	a10, a3
42007f43:	e0d681        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42007f46:	0008e0        	callx8	a8
	_M_construct(__s, __end, forward_iterator_tag());
42007f49:	0d0c      	movi.n	a13, 0
42007f4b:	c3aa      	add.n	a12, a3, a10
42007f4d:	03bd      	mov.n	a11, a3
42007f4f:	02ad      	mov.n	a10, a2
42007f51:	fff4a5        	call8	42007e9c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag>
      }
42007f54:	f01d      	retw.n
	...

42007f58 <_Z41__static_initialization_and_destruction_0v>:
        "string: _str_jumbo.replace(middle_pos, \"hello again\")"
    );
    
    ESP_LOGI(tag, "DONE\n");    

}
42007f58:	006136        	entry	a1, 48
_string _str_tiny{c_str_tiny};
42007f5b:	e26c51        	l32r	a5, 4200090c <_stext+0x8ec> (3fc950b0 <_Z9_str_tinyB5cxx11>)
42007f5e:	c13b      	addi.n	a12, a1, 3
42007f60:	e26a81        	l32r	a8, 42000908 <_stext+0x8e8> (3fc922d4 <c_str_tiny>)
42007f63:	08b8      	l32i.n	a11, a8, 0
42007f65:	05ad      	mov.n	a10, a5
42007f67:	fffca5        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
42007f6a:	e26961        	l32r	a6, 42000910 <_stext+0x8f0> (3fc94ff4 <__dso_handle>)
42007f6d:	e26971        	l32r	a7, 42000914 <_stext+0x8f4> (42007ca0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev>)
42007f70:	06cd      	mov.n	a12, a6
42007f72:	05bd      	mov.n	a11, a5
42007f74:	07ad      	mov.n	a10, a7
42007f76:	035ae5        	call8	4200b524 <__cxa_atexit>
_string _str_medium{c_str_medium};
42007f79:	e26851        	l32r	a5, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42007f7c:	c12b      	addi.n	a12, a1, 2
42007f7e:	e26681        	l32r	a8, 42000918 <_stext+0x8f8> (3fc922d0 <c_str_medium>)
42007f81:	08b8      	l32i.n	a11, a8, 0
42007f83:	05ad      	mov.n	a10, a5
42007f85:	fffaa5        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
_string _str_tiny{c_str_tiny};
42007f88:	06cd      	mov.n	a12, a6
42007f8a:	05bd      	mov.n	a11, a5
42007f8c:	07ad      	mov.n	a10, a7
42007f8e:	035965        	call8	4200b524 <__cxa_atexit>
_string _str_large{c_str_large};
42007f91:	e26351        	l32r	a5, 42000920 <_stext+0x900> (3fc922cc <c_str_large>)
42007f94:	c11b      	addi.n	a12, a1, 1
42007f96:	05b8      	l32i.n	a11, a5, 0
42007f98:	e263a1        	l32r	a10, 42000924 <_stext+0x904> (3fc95080 <_Z10_str_largeB5cxx11>)
42007f9b:	fff965        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
_string _str_tiny{c_str_tiny};
42007f9e:	06cd      	mov.n	a12, a6
42007fa0:	e261b1        	l32r	a11, 42000924 <_stext+0x904> (3fc95080 <_Z10_str_largeB5cxx11>)
42007fa3:	07ad      	mov.n	a10, a7
42007fa5:	0357e5        	call8	4200b524 <__cxa_atexit>
const _string_view _str_vu{c_str_large};
42007fa8:	0558      	l32i.n	a5, a5, 0
42007faa:	05ad      	mov.n	a10, a5
42007fac:	e0bc81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42007faf:	0008e0        	callx8	a8
      constexpr basic_string_view(const basic_string_view&) noexcept = default;

      [[__gnu__::__nonnull__]]
      constexpr
      basic_string_view(const _CharT* __str) noexcept
      : _M_len{traits_type::length(__str)},
42007fb2:	e25d81        	l32r	a8, 42000928 <_stext+0x908> (3fc95078 <_str_vu>)
42007fb5:	08a9      	s32i.n	a10, a8, 0
	_M_str{__str}
42007fb7:	1859      	s32i.n	a5, a8, 4
    _string _str_jumbo{c_str_jumbo};
42007fb9:	01cd      	mov.n	a12, a1
42007fbb:	e25c81        	l32r	a8, 4200092c <_stext+0x90c> (3fc922c8 <c_str_jumbo>)
42007fbe:	08b8      	l32i.n	a11, a8, 0
42007fc0:	e25ca1        	l32r	a10, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42007fc3:	fff6e5        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
_string _str_tiny{c_str_tiny};
42007fc6:	06cd      	mov.n	a12, a6
42007fc8:	e25ab1        	l32r	a11, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42007fcb:	07ad      	mov.n	a10, a7
42007fcd:	035565        	call8	4200b524 <__cxa_atexit>
42007fd0:	06cd      	mov.n	a12, a6
42007fd2:	e258b1        	l32r	a11, 42000934 <_stext+0x914> (3fc922b0 <_Z11_str_jumbo2B5cxx11>)
42007fd5:	07ad      	mov.n	a10, a7
42007fd7:	0354e5        	call8	4200b524 <__cxa_atexit>
}
42007fda:	f01d      	retw.n

42007fdc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ERKS4_jj>:
      basic_string(const basic_string& __str, size_type __pos,
42007fdc:	004136        	entry	a1, 32
42007fdf:	20a220        	or	a10, a2, a2
	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
42007fe2:	08c282        	addi	a8, a2, 8
	: allocator_type(std::move(__a)), _M_p(__dat) { }
42007fe5:	0289      	s32i.n	a8, a2, 0
      { return _M_dataplus._M_p; }
42007fe7:	03b8      	l32i.n	a11, a3, 0
      { return _M_string_length; }
42007fe9:	13c8      	l32i.n	a12, a3, 4
	if (__pos > this->size())
42007feb:	0cbc47        	bgeu	a12, a4, 42007ffb <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ERKS4_jj+0x1f>
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
42007fee:	0cdd      	mov.n	a13, a12
42007ff0:	04cd      	mov.n	a12, a4
42007ff2:	e251b1        	l32r	a11, 42000938 <_stext+0x918> (3c0251c0 <_flash_rodata_start+0x50a0>)
42007ff5:	e240a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025134 <_flash_rodata_start+0x5014>)
42007ff8:	02c1a5        	call8	4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>
	const _CharT* __start = __str._M_data()
42007ffb:	bb4a      	add.n	a11, a11, a4
	const bool __testoff =  __off < this->size() - __pos;
42007ffd:	c0cc40        	sub	a12, a12, a4
	return __testoff ? __off : this->size() - __pos;
42008000:	01b5c7        	bgeu	a5, a12, 42008005 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ERKS4_jj+0x29>
42008003:	05cd      	mov.n	a12, a5
	_M_construct(__start, __start + __str._M_limit(__pos, __n),
42008005:	0d0c      	movi.n	a13, 0
42008007:	cbca      	add.n	a12, a11, a12
42008009:	ffe925        	call8	42007e9c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag>
      }
4200800c:	f01d      	retw.n
	...

42008010 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6substrEjj>:
       *  short, use the remainder of the characters.  If @a __pos is
       *  beyond the end of the string, out_of_range is thrown.
      */
      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
42008010:	004136        	entry	a1, 32
42008013:	20b330        	or	a11, a3, a3
42008016:	20c440        	or	a12, a4, a4
42008019:	05dd      	mov.n	a13, a5
      { return _M_string_length; }
4200801b:	1388      	l32i.n	a8, a3, 4
	if (__pos > this->size())
4200801d:	0ab847        	bgeu	a8, a4, 4200802b <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6substrEjj+0x1b>
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
42008020:	08dd      	mov.n	a13, a8
42008022:	e246b1        	l32r	a11, 4200093c <_stext+0x91c> (3c0251dc <_flash_rodata_start+0x50bc>)
42008025:	e234a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025134 <_flash_rodata_start+0x5014>)
42008028:	02bea5        	call8	4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }
4200802b:	02ad      	mov.n	a10, a2
4200802d:	fffae5        	call8	42007fdc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ERKS4_jj>
42008030:	f01d      	retw.n
	...

42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>:
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
42008034:	004136        	entry	a1, 32
	if (__n == 1)
42008037:	091466        	bnei	a4, 1, 42008044 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj+0x10>
	__c1 = __c2;
4200803a:	000382        	l8ui	a8, a3, 0
4200803d:	004282        	s8i	a8, a2, 0
      }
42008040:	000386        	j	42008052 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj+0x1e>
42008043:	00          	.byte	00
	if (__n == 0)
42008044:	a48c      	beqz.n	a4, 42008052 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj+0x1e>
	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
42008046:	04cd      	mov.n	a12, a4
42008048:	03bd      	mov.n	a11, a3
4200804a:	02ad      	mov.n	a10, a2
4200804c:	e23d81        	l32r	a8, 42000940 <_stext+0x920> (40001200 <memmove>)
4200804f:	0008e0        	callx8	a8
      }
42008052:	f01d      	retw.n

42008054 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_eraseEjj>:
    basic_string<_CharT, _Traits, _Alloc>::
42008054:	004136        	entry	a1, 32
      { return _M_string_length; }
42008057:	0122c2        	l32i	a12, a2, 4
      const size_type __how_much = length() - __pos - __n;
4200805a:	c0cc30        	sub	a12, a12, a3
4200805d:	c0cc40        	sub	a12, a12, a4
      if (__how_much && __n)
42008060:	01a092        	movi	a9, 1
42008063:	839cc0        	moveqz	a9, a12, a12
42008066:	01a082        	movi	a8, 1
42008069:	838440        	moveqz	a8, a4, a4
4200806c:	0a0987        	bnone	a9, a8, 4200807a <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_eraseEjj+0x26>
      { return _M_dataplus._M_p; }
4200806f:	02a8      	l32i.n	a10, a2, 0
	this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
42008071:	b34a      	add.n	a11, a3, a4
42008073:	baba      	add.n	a11, a10, a11
42008075:	aa3a      	add.n	a10, a10, a3
42008077:	fffbe5        	call8	42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>
      { return _M_string_length; }
4200807a:	1288      	l32i.n	a8, a2, 4
      _M_set_length(length() - __n);
4200807c:	c08840        	sub	a8, a8, a4
      { _M_string_length = __length; }
4200807f:	1289      	s32i.n	a8, a2, 4
      { return _M_dataplus._M_p; }
42008081:	0298      	l32i.n	a9, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
42008083:	898a      	add.n	a8, a9, a8
	__c1 = __c2;
42008085:	090c      	movi.n	a9, 0
42008087:	004892        	s8i	a9, a8, 0
    }
4200808a:	f01d      	retw.n

4200808c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8pop_backEv>:
      pop_back() noexcept
4200808c:	004136        	entry	a1, 32
4200808f:	20a220        	or	a10, a2, a2
      { return _M_string_length; }
42008092:	0122b2        	l32i	a11, a2, 4
	_M_erase(size() - 1, 1);
42008095:	01a0c2        	movi	a12, 1
42008098:	bb0b      	addi.n	a11, a11, -1
4200809a:	fffba5        	call8	42008054 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_eraseEjj>
      }
4200809d:	f01d      	retw.n
	...

420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>:
      erase(size_type __pos = 0, size_type __n = npos)
420080a0:	004136        	entry	a1, 32
	_M_check(__pos, "basic_string::erase");
420080a3:	e228c1        	l32r	a12, 42000944 <_stext+0x924> (3c0251f4 <_flash_rodata_start+0x50d4>)
420080a6:	20b330        	or	a11, a3, a3
420080a9:	20a220        	or	a10, a2, a2
420080ac:	ffb625        	call8	42007c10 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_checkEjPKc>
	if (__n == npos)
420080af:	0f0466        	bnei	a4, -1, 420080c2 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj+0x22>
      { _M_string_length = __length; }
420080b2:	016232        	s32i	a3, a2, 4
      { return _M_dataplus._M_p; }
420080b5:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
420080b7:	883a      	add.n	a8, a8, a3
420080b9:	090c      	movi.n	a9, 0
420080bb:	004892        	s8i	a9, a8, 0
      }
420080be:	000586        	j	420080d8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj+0x38>
420080c1:	00          	.byte	00
	else if (__n != 0)
420080c2:	012416        	beqz	a4, 420080d8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj+0x38>
      { return _M_string_length; }
420080c5:	0122c2        	l32i	a12, a2, 4
	const bool __testoff =  __off < this->size() - __pos;
420080c8:	c0cc30        	sub	a12, a12, a3
	return __testoff ? __off : this->size() - __pos;
420080cb:	02b4c7        	bgeu	a4, a12, 420080d1 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj+0x31>
420080ce:	20c440        	or	a12, a4, a4
	  this->_M_erase(__pos, _M_limit(__pos, __n));
420080d1:	03bd      	mov.n	a11, a3
420080d3:	02ad      	mov.n	a10, a2
420080d5:	fff7e5        	call8	42008054 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_eraseEjj>
      }
420080d8:	f01d      	retw.n
	...

420080dc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEN9__gnu_cxx17__normal_iteratorIPKcS4_EE>:
      erase(__const_iterator __position)
420080dc:	004136        	entry	a1, 32
      { return _M_dataplus._M_p; }
420080df:	002282        	l32i	a8, a2, 0
#else
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
	      const __normal_iterator<_IteratorR, _Container>& __rhs)
#endif
    { return __lhs.base() - __rhs.base(); }
420080e2:	c03380        	sub	a3, a3, a8
	this->_M_erase(__pos, size_type(1));
420080e5:	01a0c2        	movi	a12, 1
420080e8:	20b330        	or	a11, a3, a3
420080eb:	02ad      	mov.n	a10, a2
420080ed:	fff665        	call8	42008054 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_eraseEjj>
      { return _M_dataplus._M_p; }
420080f0:	0228      	l32i.n	a2, a2, 0
      }
420080f2:	223a      	add.n	a2, a2, a3
420080f4:	f01d      	retw.n
	...

420080f8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc>:
    basic_string<_CharT, _Traits, _Alloc>::
420080f8:	004136        	entry	a1, 32
420080fb:	746060        	extui	a6, a6, 0, 8
      { return _M_string_length; }
420080fe:	0122c2        	l32i	a12, a2, 4
	if (this->max_size() - (this->size() - __n1) < __n2)
42008101:	c084c0        	sub	a8, a4, a12
42008104:	e10d91        	l32r	a9, 42000538 <_stext+0x518> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42008107:	808890        	add	a8, a8, a9
4200810a:	05b857        	bgeu	a8, a5, 42008113 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc+0x1b>
	  __throw_length_error(__N(__s));
4200810d:	e20ea1        	l32r	a10, 42000948 <_stext+0x928> (3c025208 <_flash_rodata_start+0x50e8>)
42008110:	02a925        	call8	4200aba4 <_ZSt20__throw_length_errorPKc>
      const size_type __new_size = __old_size + __n2 - __n1;
42008113:	8075c0        	add	a7, a5, a12
42008116:	c07740        	sub	a7, a7, a4
      { return _M_dataplus._M_p; }
42008119:	02a8      	l32i.n	a10, a2, 0
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
4200811b:	828b      	addi.n	a8, a2, 8
	if (_M_data() == _M_local_data())
4200811d:	0418a7        	beq	a8, a10, 42008125 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc+0x2d>
	return _M_is_local() ? size_type(_S_local_capacity)
42008120:	2288      	l32i.n	a8, a2, 8
42008122:	000086        	j	42008128 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc+0x30>
42008125:	0fa082        	movi	a8, 15
      if (__new_size <= this->capacity())
42008128:	243877        	bltu	a8, a7, 42008150 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc+0x58>
	  pointer __p = this->_M_data() + __pos1;
4200812b:	80aa30        	add	a10, a10, a3
	  const size_type __how_much = __old_size - __pos1 - __n1;
4200812e:	c0cc30        	sub	a12, a12, a3
42008131:	c0cc40        	sub	a12, a12, a4
	  if (__how_much && __n1 != __n2)
42008134:	01a092        	movi	a9, 1
42008137:	839cc0        	moveqz	a9, a12, a12
4200813a:	c0b450        	sub	a11, a4, a5
4200813d:	180c      	movi.n	a8, 1
4200813f:	838bb0        	moveqz	a8, a11, a11
42008142:	190987        	bnone	a9, a8, 4200815f <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc+0x67>
	    this->_S_move(__p + __n2, __p + __n1, __how_much);
42008145:	ba4a      	add.n	a11, a10, a4
42008147:	aa5a      	add.n	a10, a10, a5
42008149:	ffeea5        	call8	42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>
4200814c:	0003c6        	j	4200815f <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc+0x67>
4200814f:	00          	.byte	00
	this->_M_mutate(__pos1, __n1, 0, __n2);
42008150:	20e550        	or	a14, a5, a5
42008153:	00a0d2        	movi	a13, 0
42008156:	04cd      	mov.n	a12, a4
42008158:	03bd      	mov.n	a11, a3
4200815a:	02ad      	mov.n	a10, a2
4200815c:	ffb6e5        	call8	42007ccc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj>
      if (__n2)
4200815f:	958c      	beqz.n	a5, 4200816c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc+0x74>
      { return _M_dataplus._M_p; }
42008161:	02a8      	l32i.n	a10, a2, 0
	this->_S_assign(this->_M_data() + __pos1, __n2, __c);
42008163:	06cd      	mov.n	a12, a6
42008165:	05bd      	mov.n	a11, a5
42008167:	aa3a      	add.n	a10, a10, a3
42008169:	ffac25        	call8	42007c2c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcjc>
      { _M_string_length = __length; }
4200816c:	1279      	s32i.n	a7, a2, 4
      { return _M_dataplus._M_p; }
4200816e:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
42008170:	887a      	add.n	a8, a8, a7
42008172:	090c      	movi.n	a9, 0
42008174:	004892        	s8i	a9, a8, 0
    }
42008177:	f01d      	retw.n
42008179:	000000        	ill

4200817c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjjc>:
      insert(size_type __pos, size_type __n, _CharT __c)
4200817c:	004136        	entry	a1, 32
4200817f:	20a220        	or	a10, a2, a2
42008182:	20b330        	or	a11, a3, a3
42008185:	04dd      	mov.n	a13, a4
42008187:	74e050        	extui	a14, a5, 0, 8
      { return _M_string_length; }
4200818a:	1288      	l32i.n	a8, a2, 4
	if (__pos > this->size())
4200818c:	0cb837        	bgeu	a8, a3, 4200819c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjjc+0x20>
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
4200818f:	08dd      	mov.n	a13, a8
42008191:	03cd      	mov.n	a12, a3
42008193:	e1eeb1        	l32r	a11, 4200094c <_stext+0x92c> (3c025228 <_flash_rodata_start+0x5108>)
42008196:	e1d8a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025134 <_flash_rodata_start+0x5014>)
42008199:	02a7a5        	call8	4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
4200819c:	0c0c      	movi.n	a12, 0
4200819e:	fff5a5        	call8	420080f8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc>
			      size_type(0), __n, __c); }
420081a1:	0a2d      	mov.n	a2, a10
420081a3:	f01d      	retw.n
420081a5:	000000        	ill

420081a8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEc>:
      insert(__const_iterator __p, _CharT __c)
420081a8:	004136        	entry	a1, 32
      { return _M_dataplus._M_p; }
420081ab:	002282        	l32i	a8, a2, 0
420081ae:	c03380        	sub	a3, a3, a8
	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
420081b1:	74e040        	extui	a14, a4, 0, 8
420081b4:	01a0d2        	movi	a13, 1
420081b7:	00a0c2        	movi	a12, 0
420081ba:	03bd      	mov.n	a11, a3
420081bc:	02ad      	mov.n	a10, a2
420081be:	fff3a5        	call8	420080f8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc>
      { return _M_dataplus._M_p; }
420081c1:	0228      	l32i.n	a2, a2, 0
      }
420081c3:	223a      	add.n	a2, a2, a3
420081c5:	f01d      	retw.n
	...

420081c8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj>:
    basic_string<_CharT, _Traits, _Alloc>::
420081c8:	004136        	entry	a1, 32
420081cb:	03bd      	mov.n	a11, a3
      { return _M_string_length; }
420081cd:	1298      	l32i.n	a9, a2, 4
	if (this->max_size() - (this->size() - __n1) < __n2)
420081cf:	c08490        	sub	a8, a4, a9
420081d2:	e0d9a1        	l32r	a10, 42000538 <_stext+0x518> (7fffffff <_rtc_reserved_end+0x1fefffff>)
420081d5:	88aa      	add.n	a8, a8, a10
420081d7:	05b867        	bgeu	a8, a6, 420081e0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x18>
	  __throw_length_error(__N(__s));
420081da:	e1dda1        	l32r	a10, 42000950 <_stext+0x930> (3c025240 <_flash_rodata_start+0x5120>)
420081dd:	029c65        	call8	4200aba4 <_ZSt20__throw_length_errorPKc>
      const size_type __new_size = __old_size + __len2 - __len1;
420081e0:	769a      	add.n	a7, a6, a9
420081e2:	c07740        	sub	a7, a7, a4
      { return _M_dataplus._M_p; }
420081e5:	0288      	l32i.n	a8, a2, 0
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
420081e7:	a28b      	addi.n	a10, a2, 8
	if (_M_data() == _M_local_data())
420081e9:	041a87        	beq	a10, a8, 420081f1 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x29>
	return _M_is_local() ? size_type(_S_local_capacity)
420081ec:	22a8      	l32i.n	a10, a2, 8
420081ee:	000086        	j	420081f4 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x2c>
420081f1:	0fa0a2        	movi	a10, 15
      if (__new_size <= this->capacity())
420081f4:	503a77        	bltu	a10, a7, 42008248 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x80>
	  pointer __p = this->_M_data() + __pos;
420081f7:	8038b0        	add	a3, a8, a11
	  const size_type __how_much = __old_size - __pos - __len1;
420081fa:	c0b9b0        	sub	a11, a9, a11
420081fd:	c0cb40        	sub	a12, a11, a4
		|| less<const _CharT*>()(_M_data() + this->size(), __s));
42008200:	183587        	bltu	a5, a8, 4200821c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x54>
42008203:	808890        	add	a8, a8, a9
42008206:	123857        	bltu	a8, a5, 4200821c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x54>
	    _M_replace_cold(__p, __len1, __s, __len2, __how_much);
42008209:	0cfd      	mov.n	a15, a12
4200820b:	06ed      	mov.n	a14, a6
4200820d:	05dd      	mov.n	a13, a5
4200820f:	04cd      	mov.n	a12, a4
42008211:	03bd      	mov.n	a11, a3
42008213:	02ad      	mov.n	a10, a2
42008215:	02a0a5        	call8	4200ac20 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj>
42008218:	000e86        	j	42008256 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x8e>
4200821b:	00          	.byte	00
	      if (__how_much && __len1 != __len2)
4200821c:	01a082        	movi	a8, 1
4200821f:	838cc0        	moveqz	a8, a12, a12
42008222:	c0a460        	sub	a10, a4, a6
42008225:	01a092        	movi	a9, 1
42008228:	839aa0        	moveqz	a9, a10, a10
4200822b:	070897        	bnone	a8, a9, 42008236 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x6e>
		this->_S_move(__p + __len2, __p + __len1, __how_much);
4200822e:	80b340        	add	a11, a3, a4
42008231:	a36a      	add.n	a10, a3, a6
42008233:	ffe025        	call8	42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>
	      if (__len2)
42008236:	01c616        	beqz	a6, 42008256 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x8e>
		this->_S_copy(__p, __s, __len2);
42008239:	20c660        	or	a12, a6, a6
4200823c:	20b550        	or	a11, a5, a5
4200823f:	03ad      	mov.n	a10, a3
42008241:	ffa6a5        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
42008244:	000386        	j	42008256 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj+0x8e>
42008247:	00          	.byte	00
	this->_M_mutate(__pos, __len1, __s, __len2);
42008248:	20e660        	or	a14, a6, a6
4200824b:	20d550        	or	a13, a5, a5
4200824e:	20c440        	or	a12, a4, a4
42008251:	02ad      	mov.n	a10, a2
42008253:	ffa7a5        	call8	42007ccc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj>
      { _M_string_length = __length; }
42008256:	1279      	s32i.n	a7, a2, 4
      { return _M_dataplus._M_p; }
42008258:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
4200825a:	887a      	add.n	a8, a8, a7
4200825c:	090c      	movi.n	a9, 0
4200825e:	004892        	s8i	a9, a8, 0
    }
42008261:	f01d      	retw.n
	...

42008264 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKcj>:
      replace(size_type __pos, size_type __n1, const _CharT* __s,
42008264:	004136        	entry	a1, 32
42008267:	20a220        	or	a10, a2, a2
4200826a:	20b330        	or	a11, a3, a3
4200826d:	05dd      	mov.n	a13, a5
4200826f:	06ed      	mov.n	a14, a6
      { return _M_string_length; }
42008271:	12c8      	l32i.n	a12, a2, 4
	if (__pos > this->size())
42008273:	0cbc37        	bgeu	a12, a3, 42008283 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKcj+0x1f>
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
42008276:	0cdd      	mov.n	a13, a12
42008278:	03cd      	mov.n	a12, a3
4200827a:	e1b6b1        	l32r	a11, 42000954 <_stext+0x934> (3c02525c <_flash_rodata_start+0x513c>)
4200827d:	e19ea1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025134 <_flash_rodata_start+0x5014>)
42008280:	029925        	call8	4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>
	const bool __testoff =  __off < this->size() - __pos;
42008283:	c0cc30        	sub	a12, a12, a3
	return __testoff ? __off : this->size() - __pos;
42008286:	01b4c7        	bgeu	a4, a12, 4200828b <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKcj+0x27>
42008289:	04cd      	mov.n	a12, a4
	return _M_replace(_M_check(__pos, "basic_string::replace"),
4200828b:	fff3e5        	call8	420081c8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj>
      }
4200828e:	0a2d      	mov.n	a2, a10
42008290:	f01d      	retw.n
	...

42008294 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjPKc>:
      insert(size_type __pos, const _CharT* __s)
42008294:	004136        	entry	a1, 32
	return __builtin_strlen(__s);
42008297:	04ad      	mov.n	a10, a4
42008299:	e00081        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200829c:	0008e0        	callx8	a8
	return this->replace(__pos, size_type(0), __s,
4200829f:	0aed      	mov.n	a14, a10
420082a1:	04dd      	mov.n	a13, a4
420082a3:	0c0c      	movi.n	a12, 0
420082a5:	03bd      	mov.n	a11, a3
420082a7:	02ad      	mov.n	a10, a2
420082a9:	fffba5        	call8	42008264 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKcj>
      }
420082ac:	0a2d      	mov.n	a2, a10
420082ae:	f01d      	retw.n

420082b0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKc>:
      replace(size_type __pos, size_type __n1, const _CharT* __s)
420082b0:	004136        	entry	a1, 32
420082b3:	05ad      	mov.n	a10, a5
420082b5:	dff981        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
420082b8:	0008e0        	callx8	a8
	return this->replace(__pos, __n1, __s, traits_type::length(__s));
420082bb:	0aed      	mov.n	a14, a10
420082bd:	05dd      	mov.n	a13, a5
420082bf:	04cd      	mov.n	a12, a4
420082c1:	03bd      	mov.n	a11, a3
420082c3:	02ad      	mov.n	a10, a2
420082c5:	fff9e5        	call8	42008264 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKcj>
      }
420082c8:	0a2d      	mov.n	a2, a10
420082ca:	f01d      	retw.n

420082cc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignEPKc>:
      assign(const _CharT* __s)
420082cc:	004136        	entry	a1, 32
      { return _M_string_length; }
420082cf:	012272        	l32i	a7, a2, 4
420082d2:	20a330        	or	a10, a3, a3
420082d5:	dff181        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
420082d8:	0008e0        	callx8	a8
	return _M_replace(size_type(0), this->size(), __s,
420082db:	20eaa0        	or	a14, a10, a10
420082de:	03dd      	mov.n	a13, a3
420082e0:	07cd      	mov.n	a12, a7
420082e2:	0b0c      	movi.n	a11, 0
420082e4:	02ad      	mov.n	a10, a2
420082e6:	ffee25        	call8	420081c8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj>
      }
420082e9:	0a2d      	mov.n	a2, a10
420082eb:	f01d      	retw.n
420082ed:	000000        	ill

420082f0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEjc>:
      append(size_type __n, _CharT __c)
420082f0:	004136        	entry	a1, 32
420082f3:	20a220        	or	a10, a2, a2
420082f6:	20d330        	or	a13, a3, a3
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
420082f9:	74e040        	extui	a14, a4, 0, 8
420082fc:	00a0c2        	movi	a12, 0
420082ff:	12b8      	l32i.n	a11, a2, 4
42008301:	ffdf65        	call8	420080f8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc>
42008304:	0a2d      	mov.n	a2, a10
42008306:	f01d      	retw.n

42008308 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6resizeEjc>:
    basic_string<_CharT, _Traits, _Alloc>::
42008308:	004136        	entry	a1, 32
4200830b:	74c040        	extui	a12, a4, 0, 8
      { return _M_string_length; }
4200830e:	12b8      	l32i.n	a11, a2, 4
      if (__size < __n)
42008310:	0cbb37        	bgeu	a11, a3, 42008320 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6resizeEjc+0x18>
	this->append(__n - __size, __c);
42008313:	c0b3b0        	sub	a11, a3, a11
42008316:	20a220        	or	a10, a2, a2
42008319:	fffd65        	call8	420082f0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEjc>
4200831c:	000386        	j	4200832e <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6resizeEjc+0x26>
4200831f:	00          	.byte	00
      else if (__n < __size)
42008320:	0ab3b7        	bgeu	a3, a11, 4200832e <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6resizeEjc+0x26>
      { _M_string_length = __length; }
42008323:	1239      	s32i.n	a3, a2, 4
      { return _M_dataplus._M_p; }
42008325:	0288      	l32i.n	a8, a2, 0
	traits_type::assign(_M_data()[__n], _CharT());
42008327:	883a      	add.n	a8, a8, a3
	__c1 = __c2;
42008329:	090c      	movi.n	a9, 0
4200832b:	004892        	s8i	a9, a8, 0
    }
4200832e:	f01d      	retw.n

42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>:
#else
    #include <algorithm>
#endif

template <typename Iter>
inline void _reverse(Iter first, Iter last) 
42008330:	004136        	entry	a1, 32
42008333:	02ad      	mov.n	a10, a2
42008335:	03bd      	mov.n	a11, a3
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      std::__reverse(__first, __last, std::__iterator_category(__first));
42008337:	0c0c      	movi.n	a12, 0
42008339:	0d66e5        	call8	420159a8 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag>
    #if USE_ETL
        etl::reverse(first, last);
    #else
        std::reverse(first, last);
    #endif
}
4200833c:	f01d      	retw.n
	...

42008340 <_Z16string_benchmarkm>:
{
42008340:	018136        	entry	a1, 192
	: allocator_type(std::move(__a)), _M_p(__dat) { }
42008343:	40c182        	addi	a8, a1, 64
42008346:	0e6182        	s32i	a8, a1, 56
      { _M_string_length = __length; }
42008349:	00a072        	movi	a7, 0
4200834c:	0f6172        	s32i	a7, a1, 60
4200834f:	404172        	s8i	a7, a1, 64
      { _M_dispose(); }
42008352:	38c1a2        	addi	a10, a1, 56
42008355:	ff9325        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
    RSR(CCOUNT, ccount);
42008358:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
4200835b:	0005c6        	j	42008376 <_Z16string_benchmarkm+0x36>
4200835e:	000000        	ill
	: allocator_type(std::move(__a)), _M_p(__dat) { }
42008361:	28c182        	addi	a8, a1, 40
42008364:	086182        	s32i	a8, a1, 32
      { _M_string_length = __length; }
42008367:	080c      	movi.n	a8, 0
42008369:	9189      	s32i.n	a8, a1, 36
4200836b:	284182        	s8i	a8, a1, 40
      { _M_dispose(); }
4200836e:	20c1a2        	addi	a10, a1, 32
42008371:	ff9165        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
42008374:	771b      	addi.n	a7, a7, 1
42008376:	e17881        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008379:	e4a877        	bge	a8, a7, 42008361 <_Z16string_benchmarkm+0x21>
4200837c:	03ea70        	rsr.ccount	a7
4200837f:	c07760        	sub	a7, a7, a6
42008382:	e176c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008385:	a2c7c0        	muluh	a12, a7, a12
42008388:	41ccc0        	srli	a12, a12, 12
4200838b:	e175b1        	l32r	a11, 42000960 <_stext+0x940> (3c025274 <_flash_rodata_start+0x5154>)
4200838e:	e175a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008391:	03a4a5        	call8	4200bddc <printf>
    CYCLE_GET_COUNT(
42008394:	1dc1c2        	addi	a12, a1, 29
42008397:	e16281        	l32r	a8, 42000920 <_stext+0x900> (3fc922cc <c_str_large>)
4200839a:	08b8      	l32i.n	a11, a8, 0
4200839c:	80a0a2        	movi	a10, 128
4200839f:	a1aa      	add.n	a10, a1, a10
420083a1:	ffb8e5        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
420083a4:	03ea50        	rsr.ccount	a5
420083a7:	070c      	movi.n	a7, 0
420083a9:	0005c6        	j	420083c4 <_Z16string_benchmarkm+0x84>
420083ac:	c16200        	mul16u	a6, a2, a0
420083af:	c268      	l32i.n	a6, a2, 48
420083b1:	811cc1        	l32r	a12, 41fe8824 <_coredump_iram_end+0x1c66824>
420083b4:	e15b      	addi.n	a14, a1, 5
420083b6:	08b8      	l32i.n	a11, a8, 0
420083b8:	06ad      	mov.n	a10, a6
420083ba:	ffb765        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
420083bd:	06ad      	mov.n	a10, a6
420083bf:	ff8ca5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
420083c2:	771b      	addi.n	a7, a7, 1
420083c4:	e16581        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420083c7:	e2a877        	bge	a8, a7, 420083ad <_Z16string_benchmarkm+0x6d>
420083ca:	03ea70        	rsr.ccount	a7
420083cd:	c07750        	sub	a7, a7, a5
420083d0:	e163c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420083d3:	a2c7c0        	muluh	a12, a7, a12
420083d6:	41ccc0        	srli	a12, a12, 12
420083d9:	e163b1        	l32r	a11, 42000968 <_stext+0x948> (3c0252a8 <_flash_rodata_start+0x5188>)
420083dc:	e162a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420083df:	039fe5        	call8	4200bddc <printf>
420083e2:	80a072        	movi	a7, 128
420083e5:	717a      	add.n	a7, a1, a7
420083e7:	07ad      	mov.n	a10, a7
420083e9:	ff89e5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
    size_t c_str_large_len = strnlen(c_str_large, MAX_STRLN); 
420083ec:	e14d81        	l32r	a8, 42000920 <_stext+0x900> (3fc922cc <c_str_large>)
420083ef:	0868      	l32i.n	a6, a8, 0
420083f1:	00a1b2        	movi	a11, 0x100
420083f4:	06ad      	mov.n	a10, a6
420083f6:	e18c81        	l32r	a8, 42000a28 <_stext+0xa08> (400013f8 <strnlen>)
420083f9:	0008e0        	callx8	a8
420083fc:	0a5d      	mov.n	a5, a10
    CYCLE_GET_COUNT(
420083fe:	1bc1d2        	addi	a13, a1, 27
42008401:	0acd      	mov.n	a12, a10
42008403:	20b660        	or	a11, a6, a6
42008406:	20a770        	or	a10, a7, a7
42008409:	fface5        	call8	42007ed8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcjRKS3_>
4200840c:	03ea40        	rsr.ccount	a4
4200840f:	070c      	movi.n	a7, 0
42008411:	0006c6        	j	42008430 <_Z16string_benchmarkm+0xf0>
42008414:	68c162        	addi	a6, a1, 104
42008417:	1ac1d2        	addi	a13, a1, 26
4200841a:	20c550        	or	a12, a5, a5
4200841d:	e14081        	l32r	a8, 42000920 <_stext+0x900> (3fc922cc <c_str_large>)
42008420:	0028b2        	l32i	a11, a8, 0
42008423:	20a660        	or	a10, a6, a6
42008426:	ffab25        	call8	42007ed8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcjRKS3_>
42008429:	06ad      	mov.n	a10, a6
4200842b:	ff85e5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
4200842e:	771b      	addi.n	a7, a7, 1
42008430:	e14a81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008433:	dda877        	bge	a8, a7, 42008414 <_Z16string_benchmarkm+0xd4>
42008436:	03ea70        	rsr.ccount	a7
42008439:	c07740        	sub	a7, a7, a4
4200843c:	e148c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200843f:	a2c7c0        	muluh	a12, a7, a12
42008442:	41ccc0        	srli	a12, a12, 12
42008445:	e149b1        	l32r	a11, 4200096c <_stext+0x94c> (3c0252c8 <_flash_rodata_start+0x51a8>)
42008448:	e147a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200844b:	039925        	call8	4200bddc <printf>
4200844e:	80a072        	movi	a7, 128
42008451:	717a      	add.n	a7, a1, a7
42008453:	07ad      	mov.n	a10, a7
42008455:	ff8325        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
	: allocator_type(__a), _M_p(__dat) { }
42008458:	878b      	addi.n	a8, a7, 8
4200845a:	206182        	s32i	a8, a1, 128
      { _M_construct(__n, __c); }
4200845d:	61a0c2        	movi	a12, 97
42008460:	00a1b2        	movi	a11, 0x100
42008463:	07ad      	mov.n	a10, a7
42008465:	ff7e65        	call8	42007c4c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructEjc>
42008468:	03ea50        	rsr.ccount	a5
    CYCLE_GET_COUNT(
4200846b:	070c      	movi.n	a7, 0
4200846d:	0006c6        	j	4200848c <_Z16string_benchmarkm+0x14c>
42008470:	c16200        	mul16u	a6, a2, a0
	: allocator_type(__a), _M_p(__dat) { }
42008473:	8268      	l32i.n	a6, a2, 32
42008475:	8270c1        	l32r	a12, 41fe8e38 <_coredump_iram_end+0x1c66e38>
42008478:	c21a61        	l32r	a6, 41ff8ce0 <_coredump_iram_end+0x1c76ce0>
      { _M_construct(__n, __c); }
4200847b:	b261a0        	mulsh	a6, a1, a10
4200847e:	ad00a1        	l32r	a10, 41ff3880 <_coredump_iram_end+0x1c71880>
42008481:	7ca506        	j	42027719 <_etext+0x104db>
42008484:	ff          	.byte	0xff
      { _M_dispose(); }
42008485:	06ad      	mov.n	a10, a6
42008487:	ff8025        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
4200848a:	771b      	addi.n	a7, a7, 1
4200848c:	e13381        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
4200848f:	dea877        	bge	a8, a7, 42008471 <_Z16string_benchmarkm+0x131>
42008492:	03ea70        	rsr.ccount	a7
42008495:	c07750        	sub	a7, a7, a5
42008498:	e131c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200849b:	a2c7c0        	muluh	a12, a7, a12
4200849e:	41ccc0        	srli	a12, a12, 12
420084a1:	e133b1        	l32r	a11, 42000970 <_stext+0x950> (3c0252ec <_flash_rodata_start+0x51cc>)
420084a4:	e130a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420084a7:	039365        	call8	4200bddc <printf>
420084aa:	80a072        	movi	a7, 128
420084ad:	717a      	add.n	a7, a1, a7
420084af:	07ad      	mov.n	a10, a7
420084b1:	ff7d65        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
    CYCLE_GET_COUNT(
420084b4:	19c1c2        	addi	a12, a1, 25
420084b7:	e11cb1        	l32r	a11, 42000928 <_stext+0x908> (3fc95078 <_str_vu>)
420084ba:	20a770        	or	a10, a7, a7
420084bd:	ffa4a5        	call8	42007f08 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ISt17basic_string_viewIcS2_EvEERKT_RKS3_>
420084c0:	03ea50        	rsr.ccount	a5
420084c3:	070c      	movi.n	a7, 0
420084c5:	0005c6        	j	420084e0 <_Z16string_benchmarkm+0x1a0>
420084c8:	68c162        	addi	a6, a1, 104
420084cb:	18c1c2        	addi	a12, a1, 24
420084ce:	e116b1        	l32r	a11, 42000928 <_stext+0x908> (3fc95078 <_str_vu>)
420084d1:	20a660        	or	a10, a6, a6
420084d4:	ffa325        	call8	42007f08 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ISt17basic_string_viewIcS2_EvEERKT_RKS3_>
420084d7:	20a660        	or	a10, a6, a6
420084da:	ff7ae5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
420084dd:	01c772        	addi	a7, a7, 1
420084e0:	e11e81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420084e3:	e1a877        	bge	a8, a7, 420084c8 <_Z16string_benchmarkm+0x188>
420084e6:	03ea70        	rsr.ccount	a7
420084e9:	c07750        	sub	a7, a7, a5
420084ec:	e11cc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420084ef:	a2c7c0        	muluh	a12, a7, a12
420084f2:	41ccc0        	srli	a12, a12, 12
420084f5:	e11fb1        	l32r	a11, 42000974 <_stext+0x954> (3c025310 <_flash_rodata_start+0x51f0>)
420084f8:	e11ba1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420084fb:	038e25        	call8	4200bddc <printf>
420084fe:	80a072        	movi	a7, 128
42008501:	717a      	add.n	a7, a1, a7
42008503:	07ad      	mov.n	a10, a7
42008505:	ff7825        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
    CYCLE_GET_COUNT(
42008508:	17c1c2        	addi	a12, a1, 23
4200850b:	e0ff81        	l32r	a8, 42000908 <_stext+0x8e8> (3fc922d4 <c_str_tiny>)
4200850e:	08b8      	l32i.n	a11, a8, 0
42008510:	07ad      	mov.n	a10, a7
42008512:	ffa1e5        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
42008515:	03ea50        	rsr.ccount	a5
42008518:	070c      	movi.n	a7, 0
4200851a:	000586        	j	42008534 <_Z16string_benchmarkm+0x1f4>
4200851d:	68c162        	addi	a6, a1, 104
42008520:	16c1c2        	addi	a12, a1, 22
42008523:	e0f981        	l32r	a8, 42000908 <_stext+0x8e8> (3fc922d4 <c_str_tiny>)
42008526:	08b8      	l32i.n	a11, a8, 0
42008528:	06ad      	mov.n	a10, a6
4200852a:	ffa065        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
4200852d:	06ad      	mov.n	a10, a6
4200852f:	ff75a5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
42008532:	771b      	addi.n	a7, a7, 1
42008534:	e10981        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008537:	e2a877        	bge	a8, a7, 4200851d <_Z16string_benchmarkm+0x1dd>
4200853a:	03ea70        	rsr.ccount	a7
4200853d:	c07750        	sub	a7, a7, a5
42008540:	e107c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008543:	a2c7c0        	muluh	a12, a7, a12
42008546:	41ccc0        	srli	a12, a12, 12
42008549:	e10bb1        	l32r	a11, 42000978 <_stext+0x958> (3c025330 <_flash_rodata_start+0x5210>)
4200854c:	e106a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200854f:	0388e5        	call8	4200bddc <printf>
42008552:	80a072        	movi	a7, 128
42008555:	717a      	add.n	a7, a1, a7
42008557:	07ad      	mov.n	a10, a7
42008559:	ff72e5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
    CYCLE_GET_COUNT(
4200855c:	15c1c2        	addi	a12, a1, 21
4200855f:	e0ee81        	l32r	a8, 42000918 <_stext+0x8f8> (3fc922d0 <c_str_medium>)
42008562:	08b8      	l32i.n	a11, a8, 0
42008564:	07ad      	mov.n	a10, a7
42008566:	ff9ca5        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
42008569:	03ea50        	rsr.ccount	a5
4200856c:	070c      	movi.n	a7, 0
4200856e:	000586        	j	42008588 <_Z16string_benchmarkm+0x248>
42008571:	68c162        	addi	a6, a1, 104
42008574:	14c1c2        	addi	a12, a1, 20
42008577:	e0e881        	l32r	a8, 42000918 <_stext+0x8f8> (3fc922d0 <c_str_medium>)
4200857a:	08b8      	l32i.n	a11, a8, 0
4200857c:	06ad      	mov.n	a10, a6
4200857e:	ff9b25        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
42008581:	06ad      	mov.n	a10, a6
42008583:	ff7065        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
42008586:	771b      	addi.n	a7, a7, 1
42008588:	e0f481        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
4200858b:	e2a877        	bge	a8, a7, 42008571 <_Z16string_benchmarkm+0x231>
4200858e:	03ea70        	rsr.ccount	a7
42008591:	c07750        	sub	a7, a7, a5
42008594:	e0f2c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008597:	a2c7c0        	muluh	a12, a7, a12
4200859a:	41ccc0        	srli	a12, a12, 12
4200859d:	e0f7b1        	l32r	a11, 4200097c <_stext+0x95c> (3c025344 <_flash_rodata_start+0x5224>)
420085a0:	e0f1a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420085a3:	0383a5        	call8	4200bddc <printf>
420085a6:	80a072        	movi	a7, 128
420085a9:	717a      	add.n	a7, a1, a7
420085ab:	07ad      	mov.n	a10, a7
420085ad:	ff6da5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
    CYCLE_GET_COUNT(
420085b0:	13c1c2        	addi	a12, a1, 19
420085b3:	e0db81        	l32r	a8, 42000920 <_stext+0x900> (3fc922cc <c_str_large>)
420085b6:	08b8      	l32i.n	a11, a8, 0
420085b8:	07ad      	mov.n	a10, a7
420085ba:	ff9765        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
420085bd:	03ea50        	rsr.ccount	a5
420085c0:	070c      	movi.n	a7, 0
420085c2:	000586        	j	420085dc <_Z16string_benchmarkm+0x29c>
420085c5:	68c162        	addi	a6, a1, 104
420085c8:	12c1c2        	addi	a12, a1, 18
420085cb:	e0d581        	l32r	a8, 42000920 <_stext+0x900> (3fc922cc <c_str_large>)
420085ce:	08b8      	l32i.n	a11, a8, 0
420085d0:	06ad      	mov.n	a10, a6
420085d2:	ff95e5        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
420085d5:	06ad      	mov.n	a10, a6
420085d7:	ff6b25        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
420085da:	771b      	addi.n	a7, a7, 1
420085dc:	e0df81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420085df:	e2a877        	bge	a8, a7, 420085c5 <_Z16string_benchmarkm+0x285>
420085e2:	03ea70        	rsr.ccount	a7
420085e5:	c07750        	sub	a7, a7, a5
420085e8:	e0ddc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420085eb:	a2c7c0        	muluh	a12, a7, a12
420085ee:	41ccc0        	srli	a12, a12, 12
420085f1:	e0e3b1        	l32r	a11, 42000980 <_stext+0x960> (3c02535c <_flash_rodata_start+0x523c>)
420085f4:	e0dca1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420085f7:	037e65        	call8	4200bddc <printf>
420085fa:	80a072        	movi	a7, 128
420085fd:	717a      	add.n	a7, a1, a7
420085ff:	07ad      	mov.n	a10, a7
42008601:	ff6865        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
    CYCLE_GET_COUNT(
42008604:	11c1c2        	addi	a12, a1, 17
42008607:	e0c981        	l32r	a8, 4200092c <_stext+0x90c> (3fc922c8 <c_str_jumbo>)
4200860a:	08b8      	l32i.n	a11, a8, 0
4200860c:	07ad      	mov.n	a10, a7
4200860e:	ff9225        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
42008611:	03ea50        	rsr.ccount	a5
42008614:	070c      	movi.n	a7, 0
42008616:	000606        	j	42008632 <_Z16string_benchmarkm+0x2f2>
42008619:	68c162        	addi	a6, a1, 104
4200861c:	10c1c2        	addi	a12, a1, 16
4200861f:	e0c381        	l32r	a8, 4200092c <_stext+0x90c> (3fc922c8 <c_str_jumbo>)
42008622:	0028b2        	l32i	a11, a8, 0
42008625:	20a660        	or	a10, a6, a6
42008628:	ff9065        	call8	42007f30 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
4200862b:	06ad      	mov.n	a10, a6
4200862d:	ff65a5        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
42008630:	771b      	addi.n	a7, a7, 1
42008632:	e0c981        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008635:	e0a877        	bge	a8, a7, 42008619 <_Z16string_benchmarkm+0x2d9>
42008638:	03ea70        	rsr.ccount	a7
4200863b:	c07750        	sub	a7, a7, a5
4200863e:	e0c7c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008641:	a2c7c0        	muluh	a12, a7, a12
42008644:	41ccc0        	srli	a12, a12, 12
42008647:	e0cfb1        	l32r	a11, 42000984 <_stext+0x964> (3c025370 <_flash_rodata_start+0x5250>)
4200864a:	e0c6a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200864d:	0378e5        	call8	4200bddc <printf>
42008650:	80a0a2        	movi	a10, 128
42008653:	a1aa      	add.n	a10, a1, a10
42008655:	ff6325        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
42008658:	03eaa0        	rsr.ccount	a10
     CYCLE_GET_COUNT_RETURN(
4200865b:	080c      	movi.n	a8, 0
4200865d:	000086        	j	42008663 <_Z16string_benchmarkm+0x323>
42008660:	881b00        	lsi	f0, a11, 0x220
42008663:	e0bd91        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008666:	f7a987        	bge	a9, a8, 42008661 <_Z16string_benchmarkm+0x321>
42008669:	03ea70        	rsr.ccount	a7
4200866c:	c077a0        	sub	a7, a7, a10
4200866f:	e0bbc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008672:	a2c7c0        	muluh	a12, a7, a12
42008675:	41ccc0        	srli	a12, a12, 12
42008678:	e0c4b1        	l32r	a11, 42000988 <_stext+0x968> (3c025384 <_flash_rodata_start+0x5264>)
4200867b:	e0baa1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200867e:	0375e5        	call8	4200bddc <printf>
42008681:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008684:	080c      	movi.n	a8, 0
42008686:	000046        	j	4200868b <_Z16string_benchmarkm+0x34b>
42008689:	881b      	addi.n	a8, a8, 1
4200868b:	e0b391        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
4200868e:	f7a987        	bge	a9, a8, 42008689 <_Z16string_benchmarkm+0x349>
42008691:	03ea70        	rsr.ccount	a7
42008694:	c077a0        	sub	a7, a7, a10
42008697:	e0b1c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200869a:	a2c7c0        	muluh	a12, a7, a12
4200869d:	41ccc0        	srli	a12, a12, 12
420086a0:	e0bbb1        	l32r	a11, 4200098c <_stext+0x96c> (3c02539c <_flash_rodata_start+0x527c>)
420086a3:	e0b0a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420086a6:	037365        	call8	4200bddc <printf>
420086a9:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420086ac:	080c      	movi.n	a8, 0
420086ae:	000046        	j	420086b3 <_Z16string_benchmarkm+0x373>
420086b1:	881b      	addi.n	a8, a8, 1
420086b3:	e0a991        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420086b6:	f7a987        	bge	a9, a8, 420086b1 <_Z16string_benchmarkm+0x371>
420086b9:	03ea70        	rsr.ccount	a7
420086bc:	c077a0        	sub	a7, a7, a10
420086bf:	e0a7c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420086c2:	a2c7c0        	muluh	a12, a7, a12
420086c5:	41ccc0        	srli	a12, a12, 12
420086c8:	e0b2b1        	l32r	a11, 42000990 <_stext+0x970> (3c0253b4 <_flash_rodata_start+0x5294>)
420086cb:	e0a6a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420086ce:	0370e5        	call8	4200bddc <printf>
420086d1:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420086d4:	080c      	movi.n	a8, 0
420086d6:	0000c6        	j	420086dd <_Z16string_benchmarkm+0x39d>
420086d9:	c88200        	lsi	f0, a2, 0x320
420086dc:	9e9101        	l32r	a0, 41ff0120 <_coredump_iram_end+0x1c6e120>
420086df:	a987e0        	lsi	f14, a7, 0x2a4
420086e2:	ea70f6        	bgeui	a0, 7, 420086d0 <_Z16string_benchmarkm+0x390>
420086e5:	77a003        	lsi	f0, a0, 0x1dc
420086e8:	9cc1c0        	lsi	f12, a1, 0x270
420086eb:	c7c0e0        	lsi	f14, a0, 0x31c
420086ee:	ccc0a2        	addi	a10, a0, -52
420086f1:	a8b141        	l32r	a4, 41ff29b8 <_coredump_iram_end+0x1c709b8>
420086f4:	9ba1e0        	movnez.s	f10, f1, a14
420086f7:	6e25e0        	f64rnd	a2, a5, a14, 2
420086fa:	a0b203        	lsi	f0, a2, 0x280
    CYCLE_GET_COUNT_RETURN(
420086fd:	a158      	l32i.n	a5, a1, 40
420086ff:	e089      	s32i.n	a8, a0, 56
42008701:	ff4f65        	call8	42007bf8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE2atEj>
42008704:	03ea60        	rsr.ccount	a6
42008707:	070c      	movi.n	a7, 0
42008709:	000346        	j	4200871a <_Z16string_benchmarkm+0x3da>
4200870c:	b20000        	mulsh	a0, a0, a0
4200870f:	a158a0        	lsi	f10, a8, 0x284
42008712:	25e084        	lsi	f8, a0, 148
42008715:	4e          	.byte	0x4e
42008716:	ff          	.byte	0xff
42008717:	01c772        	addi	a7, a7, 1
4200871a:	e08f81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
4200871d:	eda877        	bge	a8, a7, 4200870e <_Z16string_benchmarkm+0x3ce>
42008720:	03ea70        	rsr.ccount	a7
42008723:	c07760        	sub	a7, a7, a6
42008726:	e08dc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008729:	a2c7c0        	muluh	a12, a7, a12
4200872c:	41ccc0        	srli	a12, a12, 12
4200872f:	e09ab1        	l32r	a11, 42000998 <_stext+0x978> (3c0253e4 <_flash_rodata_start+0x52c4>)
42008732:	e08ca1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008735:	036a65        	call8	4200bddc <printf>
42008738:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
4200873b:	080c      	movi.n	a8, 0
4200873d:	000086        	j	42008743 <_Z16string_benchmarkm+0x403>
42008740:	881b00        	lsi	f0, a11, 0x220
42008743:	e08591        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008746:	f7a987        	bge	a9, a8, 42008741 <_Z16string_benchmarkm+0x401>
42008749:	03ea70        	rsr.ccount	a7
4200874c:	c077a0        	sub	a7, a7, a10
4200874f:	e083c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008752:	a2c7c0        	muluh	a12, a7, a12
42008755:	41ccc0        	srli	a12, a12, 12
42008758:	e091b1        	l32r	a11, 4200099c <_stext+0x97c> (3c025400 <_flash_rodata_start+0x52e0>)
4200875b:	e082a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200875e:	0367e5        	call8	4200bddc <printf>
42008761:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008764:	080c      	movi.n	a8, 0
42008766:	000046        	j	4200876b <_Z16string_benchmarkm+0x42b>
42008769:	881b      	addi.n	a8, a8, 1
4200876b:	e07b91        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
4200876e:	f7a987        	bge	a9, a8, 42008769 <_Z16string_benchmarkm+0x429>
42008771:	03ea70        	rsr.ccount	a7
42008774:	c077a0        	sub	a7, a7, a10
42008777:	e079c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200877a:	a2c7c0        	muluh	a12, a7, a12
4200877d:	41ccc0        	srli	a12, a12, 12
42008780:	e088b1        	l32r	a11, 420009a0 <_stext+0x980> (3c02541c <_flash_rodata_start+0x52fc>)
42008783:	e078a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008786:	036565        	call8	4200bddc <printf>
42008789:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
4200878c:	080c      	movi.n	a8, 0
4200878e:	000046        	j	42008793 <_Z16string_benchmarkm+0x453>
42008791:	881b      	addi.n	a8, a8, 1
42008793:	e07191        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008796:	f7a987        	bge	a9, a8, 42008791 <_Z16string_benchmarkm+0x451>
42008799:	03ea70        	rsr.ccount	a7
4200879c:	c077a0        	sub	a7, a7, a10
4200879f:	e06fc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420087a2:	a2c7c0        	muluh	a12, a7, a12
420087a5:	41ccc0        	srli	a12, a12, 12
420087a8:	e07fb1        	l32r	a11, 420009a4 <_stext+0x984> (3c025438 <_flash_rodata_start+0x5318>)
420087ab:	e06ea1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420087ae:	0362e5        	call8	4200bddc <printf>
420087b1:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420087b4:	080c      	movi.n	a8, 0
420087b6:	000146        	j	420087bf <_Z16string_benchmarkm+0x47f>
420087b9:	000000        	ill
420087bc:	01c882        	addi	a8, a8, 1
420087bf:	e06691        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420087c2:	f6a987        	bge	a9, a8, 420087bc <_Z16string_benchmarkm+0x47c>
420087c5:	03ea70        	rsr.ccount	a7
420087c8:	c077a0        	sub	a7, a7, a10
420087cb:	e064c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420087ce:	a2c7c0        	muluh	a12, a7, a12
420087d1:	41ccc0        	srli	a12, a12, 12
420087d4:	e075b1        	l32r	a11, 420009a8 <_stext+0x988> (3c025454 <_flash_rodata_start+0x5334>)
420087d7:	e063a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420087da:	036025        	call8	4200bddc <printf>
    CYCLE_GET_COUNT_RETURN(
420087dd:	e051b1        	l32r	a11, 42000924 <_stext+0x904> (3fc95080 <_Z10_str_largeB5cxx11>)
420087e0:	0cc1a2        	addi	a10, a1, 12
420087e3:	0d1aa5        	call8	4201598c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6rbeginEv>
420087e6:	03ea60        	rsr.ccount	a6
420087e9:	070c      	movi.n	a7, 0
420087eb:	000386        	j	420087fd <_Z16string_benchmarkm+0x4bd>
420087ee:	000000        	ill
420087f1:	e04cb1        	l32r	a11, 42000924 <_stext+0x904> (3fc95080 <_Z10_str_largeB5cxx11>)
420087f4:	08c1a2        	addi	a10, a1, 8
420087f7:	0d1965        	call8	4201598c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6rbeginEv>
420087fa:	01c772        	addi	a7, a7, 1
420087fd:	e05681        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008800:	eda877        	bge	a8, a7, 420087f1 <_Z16string_benchmarkm+0x4b1>
42008803:	03ea70        	rsr.ccount	a7
42008806:	c07760        	sub	a7, a7, a6
42008809:	e054c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200880c:	a2c7c0        	muluh	a12, a7, a12
4200880f:	41ccc0        	srli	a12, a12, 12
42008812:	e066b1        	l32r	a11, 420009ac <_stext+0x98c> (3c025470 <_flash_rodata_start+0x5350>)
42008815:	e053a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008818:	035c25        	call8	4200bddc <printf>
    CYCLE_GET_COUNT_RETURN(
4200881b:	e042b1        	l32r	a11, 42000924 <_stext+0x904> (3fc95080 <_Z10_str_largeB5cxx11>)
4200881e:	04c1a2        	addi	a10, a1, 4
42008821:	0d17a5        	call8	4201599c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4rendEv>
42008824:	03ea60        	rsr.ccount	a6
42008827:	070c      	movi.n	a7, 0
42008829:	000306        	j	42008839 <_Z16string_benchmarkm+0x4f9>
4200882c:	3db100        	lsi	f0, a1, 244
4200882f:	a110e0        	lsi	f14, a0, 0x284
42008832:	16a520        	lsi	f2, a5, 88
42008835:	720d      	lsi	f0, a2, 8
42008837:	8101c7        	bnone	a1, a12, 420087bc <_Z16string_benchmarkm+0x47c>
4200883a:	77e047        	bbsi	a0, 4, 420088b5 <_Z16string_benchmarkm+0x575>
4200883d:	eda8      	l32i.n	a10, a13, 56
4200883f:	03ea70        	rsr.ccount	a7
42008842:	c07760        	sub	a7, a7, a6
42008845:	e045c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008848:	a2c7c0        	muluh	a12, a7, a12
4200884b:	41ccc0        	srli	a12, a12, 12
4200884e:	e058b1        	l32r	a11, 420009b0 <_stext+0x990> (3c02548c <_flash_rodata_start+0x536c>)
42008851:	e044a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008854:	035865        	call8	4200bddc <printf>
42008857:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
4200885a:	00a082        	movi	a8, 0
4200885d:	000086        	j	42008863 <_Z16string_benchmarkm+0x523>
42008860:	881b00        	lsi	f0, a11, 0x220
42008863:	e03d91        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008866:	f7a987        	bge	a9, a8, 42008861 <_Z16string_benchmarkm+0x521>
42008869:	03ea70        	rsr.ccount	a7
4200886c:	c077a0        	sub	a7, a7, a10
4200886f:	e03bc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008872:	a2c7c0        	muluh	a12, a7, a12
42008875:	41ccc0        	srli	a12, a12, 12
42008878:	e04fb1        	l32r	a11, 420009b4 <_stext+0x994> (3c0254a8 <_flash_rodata_start+0x5388>)
4200887b:	e03aa1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200887e:	0355e5        	call8	4200bddc <printf>
42008881:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008884:	080c      	movi.n	a8, 0
42008886:	000046        	j	4200888b <_Z16string_benchmarkm+0x54b>
42008889:	881b      	addi.n	a8, a8, 1
4200888b:	e03391        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
4200888e:	f7a987        	bge	a9, a8, 42008889 <_Z16string_benchmarkm+0x549>
42008891:	03ea70        	rsr.ccount	a7
42008894:	c077a0        	sub	a7, a7, a10
42008897:	e031c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200889a:	a2c7c0        	muluh	a12, a7, a12
4200889d:	41ccc0        	srli	a12, a12, 12
420088a0:	e046b1        	l32r	a11, 420009b8 <_stext+0x998> (3c0254c4 <_flash_rodata_start+0x53a4>)
420088a3:	e030a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420088a6:	035365        	call8	4200bddc <printf>
420088a9:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420088ac:	080c      	movi.n	a8, 0
420088ae:	000046        	j	420088b3 <_Z16string_benchmarkm+0x573>
420088b1:	881b      	addi.n	a8, a8, 1
420088b3:	e02991        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420088b6:	f7a987        	bge	a9, a8, 420088b1 <_Z16string_benchmarkm+0x571>
420088b9:	03ea70        	rsr.ccount	a7
420088bc:	c077a0        	sub	a7, a7, a10
420088bf:	e027c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420088c2:	a2c7c0        	muluh	a12, a7, a12
420088c5:	41ccc0        	srli	a12, a12, 12
420088c8:	e03db1        	l32r	a11, 420009bc <_stext+0x99c> (3c0254e0 <_flash_rodata_start+0x53c0>)
420088cb:	e026a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420088ce:	0350e5        	call8	4200bddc <printf>
420088d1:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420088d4:	080c      	movi.n	a8, 0
420088d6:	000046        	j	420088db <_Z16string_benchmarkm+0x59b>
420088d9:	881b      	addi.n	a8, a8, 1
420088db:	e01f91        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420088de:	f7a987        	bge	a9, a8, 420088d9 <_Z16string_benchmarkm+0x599>
420088e1:	03ea70        	rsr.ccount	a7
420088e4:	c077a0        	sub	a7, a7, a10
420088e7:	e01dc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420088ea:	a2c7c0        	muluh	a12, a7, a12
420088ed:	41ccc0        	srli	a12, a12, 12
420088f0:	e034b1        	l32r	a11, 420009c0 <_stext+0x9a0> (3c025500 <_flash_rodata_start+0x53e0>)
420088f3:	e01ca1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420088f6:	034e65        	call8	4200bddc <printf>
420088f9:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420088fc:	080c      	movi.n	a8, 0
420088fe:	000086        	j	42008904 <_Z16string_benchmarkm+0x5c4>
42008901:	01c882        	addi	a8, a8, 1
42008904:	e01591        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008907:	f6a987        	bge	a9, a8, 42008901 <_Z16string_benchmarkm+0x5c1>
4200890a:	03ea70        	rsr.ccount	a7
4200890d:	c077a0        	sub	a7, a7, a10
42008910:	e013c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008913:	a2c7c0        	muluh	a12, a7, a12
42008916:	41ccc0        	srli	a12, a12, 12
42008919:	e02ab1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025520 <_flash_rodata_start+0x5400>)
4200891c:	e012a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200891f:	034be5        	call8	4200bddc <printf>
      { this->resize(__n, _CharT()); }
42008922:	00a0c2        	movi	a12, 0
42008925:	00a1b2        	movi	a11, 0x100
42008928:	dff9a1        	l32r	a10, 4200090c <_stext+0x8ec> (3fc950b0 <_Z9_str_tinyB5cxx11>)
4200892b:	ff9de5        	call8	42008308 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6resizeEjc>
4200892e:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
42008931:	070c      	movi.n	a7, 0
42008933:	000346        	j	42008944 <_Z16string_benchmarkm+0x604>
42008936:	0c0c      	movi.n	a12, 0
42008938:	00a1b2        	movi	a11, 0x100
4200893b:	dff4a1        	l32r	a10, 4200090c <_stext+0x8ec> (3fc950b0 <_Z9_str_tinyB5cxx11>)
4200893e:	ff9ca5        	call8	42008308 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6resizeEjc>
42008941:	01c772        	addi	a7, a7, 1
42008944:	e00581        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008947:	eba877        	bge	a8, a7, 42008936 <_Z16string_benchmarkm+0x5f6>
4200894a:	03ea70        	rsr.ccount	a7
4200894d:	c07760        	sub	a7, a7, a6
42008950:	e003c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008953:	a2c7c0        	muluh	a12, a7, a12
42008956:	41ccc0        	srli	a12, a12, 12
42008959:	e01bb1        	l32r	a11, 420009c8 <_stext+0x9a8> (3c02553c <_flash_rodata_start+0x541c>)
4200895c:	e002a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
4200895f:	0347e5        	call8	4200bddc <printf>
42008962:	dfea71        	l32r	a7, 4200090c <_stext+0x8ec> (3fc950b0 <_Z9_str_tinyB5cxx11>)
42008965:	0c0c      	movi.n	a12, 0
42008967:	2b0c      	movi.n	a11, 2
42008969:	20a770        	or	a10, a7, a7
4200896c:	ff99a5        	call8	42008308 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6resizeEjc>
    CYCLE_GET_COUNT(
4200896f:	0c0c      	movi.n	a12, 0
42008971:	ab0c      	movi.n	a11, 10
42008973:	07ad      	mov.n	a10, a7
42008975:	ff4b65        	call8	42007e2c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE_EEvjT_>
42008978:	03ea60        	rsr.ccount	a6
4200897b:	070c      	movi.n	a7, 0
4200897d:	0002c6        	j	4200898c <_Z16string_benchmarkm+0x64c>
42008980:	0c0c      	movi.n	a12, 0
42008982:	ab0c      	movi.n	a11, 10
42008984:	dfe2a1        	l32r	a10, 4200090c <_stext+0x8ec> (3fc950b0 <_Z9_str_tinyB5cxx11>)
42008987:	ff4de5        	call8	42007e64 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE0_EEvjT_>
4200898a:	771b      	addi.n	a7, a7, 1
4200898c:	dff381        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
4200898f:	eda877        	bge	a8, a7, 42008980 <_Z16string_benchmarkm+0x640>
42008992:	03ea70        	rsr.ccount	a7
42008995:	c07760        	sub	a7, a7, a6
42008998:	dff1c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200899b:	a2c7c0        	muluh	a12, a7, a12
4200899e:	41ccc0        	srli	a12, a12, 12
420089a1:	e00ab1        	l32r	a11, 420009cc <_stext+0x9ac> (3c025560 <_flash_rodata_start+0x5440>)
420089a4:	dff0a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420089a7:	034365        	call8	4200bddc <printf>
      { return this->assign(__s); }
420089aa:	dfd871        	l32r	a7, 4200090c <_stext+0x8ec> (3fc950b0 <_Z9_str_tinyB5cxx11>)
420089ad:	e008b1        	l32r	a11, 420009d0 <_stext+0x9b0> (3c025598 <_flash_rodata_start+0x5478>)
420089b0:	07ad      	mov.n	a10, a7
420089b2:	ff91a5        	call8	420082cc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignEPKc>
      { return _M_dataplus._M_p; }
420089b5:	07a8      	l32i.n	a10, a7, 0
      { return _M_string_length; }
420089b7:	0127b2        	l32i	a11, a7, 4
    CYCLE_GET_COUNT(
420089ba:	80bab0        	add	a11, a10, a11
420089bd:	ff9725        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
420089c0:	03ea60        	rsr.ccount	a6
420089c3:	070c      	movi.n	a7, 0
420089c5:	000446        	j	420089da <_Z16string_benchmarkm+0x69a>
420089c8:	d08100        	subx2	a8, a1, a0
      { return _M_dataplus._M_p; }
420089cb:	df          	.byte	0xdf
420089cc:	0028a2        	l32i	a10, a8, 0
      { return _M_string_length; }
420089cf:	0128b2        	l32i	a11, a8, 4
420089d2:	80bab0        	add	a11, a10, a11
420089d5:	ff95a5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
420089d8:	771b      	addi.n	a7, a7, 1
420089da:	dfdf81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
420089dd:	e8a877        	bge	a8, a7, 420089c9 <_Z16string_benchmarkm+0x689>
420089e0:	03ea70        	rsr.ccount	a7
420089e3:	c07760        	sub	a7, a7, a6
420089e6:	dfddc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420089e9:	a2c7c0        	muluh	a12, a7, a12
420089ec:	41ccc0        	srli	a12, a12, 12
420089ef:	dff9b1        	l32r	a11, 420009d4 <_stext+0x9b4> (3c02559c <_flash_rodata_start+0x547c>)
420089f2:	dfdca1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
420089f5:	033e65        	call8	4200bddc <printf>
      { return _M_dataplus._M_p; }
420089f8:	dfc981        	l32r	a8, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
420089fb:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
420089fd:	18b8      	l32i.n	a11, a8, 4
    CYCLE_GET_COUNT(
420089ff:	baba      	add.n	a11, a10, a11
42008a01:	ff92e5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
42008a04:	03ea60        	rsr.ccount	a6
42008a07:	070c      	movi.n	a7, 0
42008a09:	000346        	j	42008a1a <_Z16string_benchmarkm+0x6da>
      { return _M_dataplus._M_p; }
42008a0c:	dfc481        	l32r	a8, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008a0f:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
42008a11:	18b8      	l32i.n	a11, a8, 4
42008a13:	baba      	add.n	a11, a10, a11
42008a15:	ff91a5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
42008a18:	771b      	addi.n	a7, a7, 1
42008a1a:	dfcf81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008a1d:	eba877        	bge	a8, a7, 42008a0c <_Z16string_benchmarkm+0x6cc>
42008a20:	03ea70        	rsr.ccount	a7
42008a23:	c07760        	sub	a7, a7, a6
42008a26:	dfcdc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008a29:	a2c7c0        	muluh	a12, a7, a12
42008a2c:	41ccc0        	srli	a12, a12, 12
42008a2f:	dfeab1        	l32r	a11, 420009d8 <_stext+0x9b8> (3c0255b8 <_flash_rodata_start+0x5498>)
42008a32:	dfcca1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008a35:	033a65        	call8	4200bddc <printf>
      { return _M_dataplus._M_p; }
42008a38:	dfbb81        	l32r	a8, 42000924 <_stext+0x904> (3fc95080 <_Z10_str_largeB5cxx11>)
42008a3b:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
42008a3d:	18b8      	l32i.n	a11, a8, 4
    CYCLE_GET_COUNT(
42008a3f:	baba      	add.n	a11, a10, a11
42008a41:	ff8ee5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
42008a44:	03ea60        	rsr.ccount	a6
42008a47:	070c      	movi.n	a7, 0
42008a49:	000446        	j	42008a5e <_Z16string_benchmarkm+0x71e>
42008a4c:	b58100        	extui	a8, a0, 17, 12
      { return _M_dataplus._M_p; }
42008a4f:	df          	.byte	0xdf
42008a50:	0028a2        	l32i	a10, a8, 0
      { return _M_string_length; }
42008a53:	0128b2        	l32i	a11, a8, 4
42008a56:	80bab0        	add	a11, a10, a11
42008a59:	ff8d65        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
42008a5c:	771b      	addi.n	a7, a7, 1
42008a5e:	dfbe81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008a61:	e8a877        	bge	a8, a7, 42008a4d <_Z16string_benchmarkm+0x70d>
42008a64:	03ea70        	rsr.ccount	a7
42008a67:	c07760        	sub	a7, a7, a6
42008a6a:	dfbcc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008a6d:	a2c7c0        	muluh	a12, a7, a12
42008a70:	41ccc0        	srli	a12, a12, 12
42008a73:	dfdab1        	l32r	a11, 420009dc <_stext+0x9bc> (3c0255d4 <_flash_rodata_start+0x54b4>)
42008a76:	dfbba1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008a79:	033625        	call8	4200bddc <printf>
      { return _M_dataplus._M_p; }
42008a7c:	dfad81        	l32r	a8, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008a7f:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
42008a81:	18b8      	l32i.n	a11, a8, 4
    CYCLE_GET_COUNT(
42008a83:	baba      	add.n	a11, a10, a11
42008a85:	ff8aa5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
42008a88:	03ea60        	rsr.ccount	a6
42008a8b:	070c      	movi.n	a7, 0
42008a8d:	000386        	j	42008a9f <_Z16string_benchmarkm+0x75f>
42008a90:	a78100        	lsi	f0, a1, 0x29c
      { return _M_dataplus._M_p; }
42008a93:	df          	.byte	0xdf
42008a94:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
42008a96:	18b8      	l32i.n	a11, a8, 4
42008a98:	baba      	add.n	a11, a10, a11
42008a9a:	ff8965        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
42008a9d:	771b      	addi.n	a7, a7, 1
42008a9f:	dfae81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008aa2:	eba877        	bge	a8, a7, 42008a91 <_Z16string_benchmarkm+0x751>
42008aa5:	03ea70        	rsr.ccount	a7
42008aa8:	c07760        	sub	a7, a7, a6
42008aab:	dfacc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008aae:	a2c7c0        	muluh	a12, a7, a12
42008ab1:	41ccc0        	srli	a12, a12, 12
42008ab4:	dfcbb1        	l32r	a11, 420009e0 <_stext+0x9c0> (3c0255f0 <_flash_rodata_start+0x54d0>)
42008ab7:	dfaba1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008aba:	033225        	call8	4200bddc <printf>
      { return _M_dataplus._M_p; }
42008abd:	df9381        	l32r	a8, 4200090c <_stext+0x8ec> (3fc950b0 <_Z9_str_tinyB5cxx11>)
42008ac0:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
42008ac2:	18b8      	l32i.n	a11, a8, 4
    _reverse(_str_tiny.begin(), _str_tiny.end());
42008ac4:	80bab0        	add	a11, a10, a11
42008ac7:	ff86a5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
      { return _M_dataplus._M_p; }
42008aca:	df9481        	l32r	a8, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008acd:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
42008acf:	18b8      	l32i.n	a11, a8, 4
    _reverse(_str_medium.begin(), _str_medium.end());
42008ad1:	80bab0        	add	a11, a10, a11
42008ad4:	ff85a5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
      { return _M_dataplus._M_p; }
42008ad7:	df9381        	l32r	a8, 42000924 <_stext+0x904> (3fc95080 <_Z10_str_largeB5cxx11>)
42008ada:	08a8      	l32i.n	a10, a8, 0
      { return _M_string_length; }
42008adc:	18b8      	l32i.n	a11, a8, 4
    _reverse(_str_large.begin(), _str_large.end());
42008ade:	80bab0        	add	a11, a10, a11
42008ae1:	ff84e5        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
      { return _M_dataplus._M_p; }
42008ae4:	df9371        	l32r	a7, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008ae7:	07a8      	l32i.n	a10, a7, 0
      { return _M_string_length; }
42008ae9:	17b8      	l32i.n	a11, a7, 4
    _reverse(_str_jumbo.begin(), _str_jumbo.end());
42008aeb:	baba      	add.n	a11, a10, a11
42008aed:	ff8425        	call8	42008330 <_Z8_reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_>
      { _M_string_length = __length; }
42008af0:	080c      	movi.n	a8, 0
42008af2:	1789      	s32i.n	a8, a7, 4
      { return _M_dataplus._M_p; }
42008af4:	0798      	l32i.n	a9, a7, 0
42008af6:	004982        	s8i	a8, a9, 0
42008af9:	03eab0        	rsr.ccount	a11
    CYCLE_GET_COUNT(
42008afc:	000406        	j	42008b10 <_Z16string_benchmarkm+0x7d0>
42008aff:	a10000        	sll	a0, a0
      { _M_string_length = __length; }
42008b02:	df8b      	addi.n	a13, a15, 8
42008b04:	00a092        	movi	a9, 0
42008b07:	1a99      	s32i.n	a9, a10, 4
      { return _M_dataplus._M_p; }
42008b09:	0aa8      	l32i.n	a10, a10, 0
42008b0b:	004a92        	s8i	a9, a10, 0
42008b0e:	881b      	addi.n	a8, a8, 1
42008b10:	df9291        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008b13:	eaa987        	bge	a9, a8, 42008b01 <_Z16string_benchmarkm+0x7c1>
42008b16:	03ea70        	rsr.ccount	a7
42008b19:	c077b0        	sub	a7, a7, a11
42008b1c:	df90c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008b1f:	a2c7c0        	muluh	a12, a7, a12
42008b22:	41ccc0        	srli	a12, a12, 12
42008b25:	dfafb1        	l32r	a11, 420009e4 <_stext+0x9c4> (3c02560c <_flash_rodata_start+0x54ec>)
42008b28:	df8fa1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008b2b:	032b25        	call8	4200bddc <printf>
      { return this->append(__s); }
42008b2e:	df8071        	l32r	a7, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008b31:	dfadb1        	l32r	a11, 420009e8 <_stext+0x9c8> (3c025620 <_flash_rodata_start+0x5500>)
42008b34:	07ad      	mov.n	a10, a7
42008b36:	ff2925        	call8	42007dc8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKc>
    CYCLE_GET_COUNT_MUTATE(
42008b39:	07ad      	mov.n	a10, a7
42008b3b:	ff5525        	call8	4200808c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8pop_backEv>
42008b3e:	060c      	movi.n	a6, 0
42008b40:	067d      	mov.n	a7, a6
42008b42:	000746        	j	42008b63 <_Z16string_benchmarkm+0x823>
42008b45:	03ea40        	rsr.ccount	a4
42008b48:	df7a51        	l32r	a5, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008b4b:	dfa7b1        	l32r	a11, 420009e8 <_stext+0x9c8> (3c025620 <_flash_rodata_start+0x5500>)
42008b4e:	05ad      	mov.n	a10, a5
42008b50:	ff2765        	call8	42007dc8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKc>
42008b53:	03ea80        	rsr.ccount	a8
42008b56:	c08840        	sub	a8, a8, a4
42008b59:	778a      	add.n	a7, a7, a8
42008b5b:	20a550        	or	a10, a5, a5
42008b5e:	ff52e5        	call8	4200808c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8pop_backEv>
42008b61:	661b      	addi.n	a6, a6, 1
42008b63:	df7d81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008b66:	dba867        	bge	a8, a6, 42008b45 <_Z16string_benchmarkm+0x805>
42008b69:	df7cc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008b6c:	a2c7c0        	muluh	a12, a7, a12
42008b6f:	41ccc0        	srli	a12, a12, 12
42008b72:	df9eb1        	l32r	a11, 420009ec <_stext+0x9cc> (3c025624 <_flash_rodata_start+0x5504>)
42008b75:	df7ba1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008b78:	032625        	call8	4200bddc <printf>
    CYCLE_GET_COUNT_MUTATE(
42008b7b:	df6c61        	l32r	a6, 4200092c <_stext+0x90c> (3fc922c8 <c_str_jumbo>)
42008b7e:	df6c71        	l32r	a7, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008b81:	06b8      	l32i.n	a11, a6, 0
42008b83:	20a770        	or	a10, a7, a7
42008b86:	ff2425        	call8	42007dc8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKc>
      { return _M_string_length; }
42008b89:	1758      	l32i.n	a5, a7, 4
42008b8b:	06a8      	l32i.n	a10, a6, 0
42008b8d:	ddc381        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42008b90:	0008e0        	callx8	a8
42008b93:	fc7c      	movi.n	a12, -1
42008b95:	c0b5a0        	sub	a11, a5, a10
42008b98:	07ad      	mov.n	a10, a7
42008b9a:	ff5065        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008b9d:	070c      	movi.n	a7, 0
42008b9f:	075d      	mov.n	a5, a7
42008ba1:	000c06        	j	42008bd5 <_Z16string_benchmarkm+0x895>
42008ba4:	ea3000        	utrunc.s	a3, f0, 0
42008ba7:	614103        	ssi	f0, a1, 0x184
42008baa:	df          	.byte	0xdf
42008bab:	df6161        	l32r	a6, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008bae:	0024b2        	l32i	a11, a4, 0
42008bb1:	06ad      	mov.n	a10, a6
42008bb3:	ff2165        	call8	42007dc8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKc>
42008bb6:	03ea80        	rsr.ccount	a8
42008bb9:	c08830        	sub	a8, a8, a3
42008bbc:	778a      	add.n	a7, a7, a8
42008bbe:	1638      	l32i.n	a3, a6, 4
42008bc0:	04a8      	l32i.n	a10, a4, 0
42008bc2:	ddb681        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42008bc5:	0008e0        	callx8	a8
42008bc8:	fc7c      	movi.n	a12, -1
42008bca:	c0b3a0        	sub	a11, a3, a10
42008bcd:	20a660        	or	a10, a6, a6
42008bd0:	ff4ce5        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008bd3:	551b      	addi.n	a5, a5, 1
42008bd5:	df6081        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008bd8:	c9a857        	bge	a8, a5, 42008ba5 <_Z16string_benchmarkm+0x865>
42008bdb:	df60c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008bde:	a2c7c0        	muluh	a12, a7, a12
42008be1:	41ccc0        	srli	a12, a12, 12
42008be4:	df83b1        	l32r	a11, 420009f0 <_stext+0x9d0> (3c025638 <_flash_rodata_start+0x5518>)
42008be7:	df5fa1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008bea:	031f25        	call8	4200bddc <printf>
42008bed:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008bf0:	080c      	movi.n	a8, 0
42008bf2:	000086        	j	42008bf8 <_Z16string_benchmarkm+0x8b8>
42008bf5:	01c882        	addi	a8, a8, 1
42008bf8:	df5891        	l32r	a9, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008bfb:	f6a987        	bge	a9, a8, 42008bf5 <_Z16string_benchmarkm+0x8b5>
42008bfe:	03ea70        	rsr.ccount	a7
42008c01:	c077a0        	sub	a7, a7, a10
42008c04:	df56c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008c07:	a2c7c0        	muluh	a12, a7, a12
42008c0a:	41ccc0        	srli	a12, a12, 12
42008c0d:	df79b1        	l32r	a11, 420009f4 <_stext+0x9d4> (3c025654 <_flash_rodata_start+0x5534>)
42008c10:	df55a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008c13:	031ca5        	call8	4200bddc <printf>
    CYCLE_GET_COUNT_MUTATE(
42008c16:	df4171        	l32r	a7, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008c19:	61a0b2        	movi	a11, 97
42008c1c:	07ad      	mov.n	a10, a7
42008c1e:	ff1265        	call8	42007d44 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc>
42008c21:	07ad      	mov.n	a10, a7
42008c23:	ff46a5        	call8	4200808c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8pop_backEv>
42008c26:	060c      	movi.n	a6, 0
42008c28:	067d      	mov.n	a7, a6
42008c2a:	000746        	j	42008c4b <_Z16string_benchmarkm+0x90b>
42008c2d:	03ea40        	rsr.ccount	a4
42008c30:	df3b51        	l32r	a5, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008c33:	61a0b2        	movi	a11, 97
42008c36:	05ad      	mov.n	a10, a5
42008c38:	ff10a5        	call8	42007d44 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc>
42008c3b:	03ea80        	rsr.ccount	a8
42008c3e:	c08840        	sub	a8, a8, a4
42008c41:	778a      	add.n	a7, a7, a8
42008c43:	20a550        	or	a10, a5, a5
42008c46:	ff4465        	call8	4200808c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8pop_backEv>
42008c49:	661b      	addi.n	a6, a6, 1
42008c4b:	df4381        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008c4e:	dba867        	bge	a8, a6, 42008c2d <_Z16string_benchmarkm+0x8ed>
42008c51:	df42c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008c54:	a2c7c0        	muluh	a12, a7, a12
42008c57:	41ccc0        	srli	a12, a12, 12
42008c5a:	df67b1        	l32r	a11, 420009f8 <_stext+0x9d8> (3c025678 <_flash_rodata_start+0x5558>)
42008c5d:	df41a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008c60:	0317a5        	call8	4200bddc <printf>
    CYCLE_GET_COUNT_MUTATE(
42008c63:	df2e71        	l32r	a7, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008c66:	df65c1        	l32r	a12, 420009fc <_stext+0x9dc> (3c02569c <_flash_rodata_start+0x557c>)
42008c69:	3b0c      	movi.n	a11, 3
42008c6b:	07ad      	mov.n	a10, a7
42008c6d:	ff6265        	call8	42008294 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjPKc>
42008c70:	5c0c      	movi.n	a12, 5
42008c72:	3b0c      	movi.n	a11, 3
42008c74:	07ad      	mov.n	a10, a7
42008c76:	ff42a5        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008c79:	070c      	movi.n	a7, 0
42008c7b:	076d      	mov.n	a6, a7
42008c7d:	0008c6        	j	42008ca4 <_Z16string_benchmarkm+0x964>
42008c80:	ea4000        	utrunc.s	a4, f0, 0
42008c83:	265103        	lsi	f0, a1, 152
42008c86:	df          	.byte	0xdf
42008c87:	df5dc1        	l32r	a12, 420009fc <_stext+0x9dc> (3c02569c <_flash_rodata_start+0x557c>)
42008c8a:	3b0c      	movi.n	a11, 3
42008c8c:	05ad      	mov.n	a10, a5
42008c8e:	ff6065        	call8	42008294 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjPKc>
42008c91:	03ea80        	rsr.ccount	a8
42008c94:	c08840        	sub	a8, a8, a4
42008c97:	778a      	add.n	a7, a7, a8
42008c99:	5c0c      	movi.n	a12, 5
42008c9b:	3b0c      	movi.n	a11, 3
42008c9d:	05ad      	mov.n	a10, a5
42008c9f:	ff4025        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008ca2:	661b      	addi.n	a6, a6, 1
42008ca4:	df2d81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008ca7:	d6a867        	bge	a8, a6, 42008c81 <_Z16string_benchmarkm+0x941>
42008caa:	df2cc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008cad:	a2c7c0        	muluh	a12, a7, a12
42008cb0:	41ccc0        	srli	a12, a12, 12
42008cb3:	df53b1        	l32r	a11, 42000a00 <_stext+0x9e0> (3c0256a4 <_flash_rodata_start+0x5584>)
42008cb6:	df2ba1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008cb9:	031225        	call8	4200bddc <printf>
    CYCLE_GET_COUNT_MUTATE (
42008cbc:	df1871        	l32r	a7, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008cbf:	61a0d2        	movi	a13, 97
42008cc2:	5c0c      	movi.n	a12, 5
42008cc4:	3b0c      	movi.n	a11, 3
42008cc6:	07ad      	mov.n	a10, a7
42008cc8:	ff4b25        	call8	4200817c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjjc>
42008ccb:	5c0c      	movi.n	a12, 5
42008ccd:	3b0c      	movi.n	a11, 3
42008ccf:	07ad      	mov.n	a10, a7
42008cd1:	ff3ce5        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008cd4:	070c      	movi.n	a7, 0
42008cd6:	076d      	mov.n	a6, a7
42008cd8:	000a06        	j	42008d04 <_Z16string_benchmarkm+0x9c4>
42008cdb:	ea4000        	utrunc.s	a4, f0, 0
42008cde:	0f5103        	lsi	f0, a1, 60
42008ce1:	df          	.byte	0xdf
42008ce2:	61a0d2        	movi	a13, 97
42008ce5:	05a0c2        	movi	a12, 5
42008ce8:	03a0b2        	movi	a11, 3
42008ceb:	20a550        	or	a10, a5, a5
42008cee:	ff48e5        	call8	4200817c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjjc>
42008cf1:	03ea80        	rsr.ccount	a8
42008cf4:	c08840        	sub	a8, a8, a4
42008cf7:	778a      	add.n	a7, a7, a8
42008cf9:	5c0c      	movi.n	a12, 5
42008cfb:	3b0c      	movi.n	a11, 3
42008cfd:	05ad      	mov.n	a10, a5
42008cff:	ff3a25        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008d02:	661b      	addi.n	a6, a6, 1
42008d04:	df1581        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008d07:	d1a867        	bge	a8, a6, 42008cdc <_Z16string_benchmarkm+0x99c>
42008d0a:	df14c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008d0d:	a2c7c0        	muluh	a12, a7, a12
42008d10:	41ccc0        	srli	a12, a12, 12
42008d13:	df3cb1        	l32r	a11, 42000a04 <_stext+0x9e4> (3c0256cc <_flash_rodata_start+0x55ac>)
42008d16:	df13a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008d19:	030c25        	call8	4200bddc <printf>
      { return _M_dataplus._M_p; }
42008d1c:	df0071        	l32r	a7, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008d1f:	07b8      	l32i.n	a11, a7, 0
    CYCLE_GET_COUNT_MUTATE (
42008d21:	61a0c2        	movi	a12, 97
42008d24:	bb3b      	addi.n	a11, a11, 3
42008d26:	07ad      	mov.n	a10, a7
42008d28:	ff47e5        	call8	420081a8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEc>
42008d2b:	07b8      	l32i.n	a11, a7, 0
42008d2d:	bb3b      	addi.n	a11, a11, 3
42008d2f:	07ad      	mov.n	a10, a7
42008d31:	ff3aa5        	call8	420080dc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEN9__gnu_cxx17__normal_iteratorIPKcS4_EE>
42008d34:	070c      	movi.n	a7, 0
42008d36:	075d      	mov.n	a5, a7
42008d38:	000a06        	j	42008d64 <_Z16string_benchmarkm+0xa24>
42008d3b:	ea4000        	utrunc.s	a4, f0, 0
42008d3e:	f76103        	lsi	f0, a1, 0x3dc
42008d41:	de          	.byte	0xde
42008d42:	0026b2        	l32i	a11, a6, 0
42008d45:	61a0c2        	movi	a12, 97
42008d48:	03cbb2        	addi	a11, a11, 3
42008d4b:	20a660        	or	a10, a6, a6
42008d4e:	ff45a5        	call8	420081a8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEc>
42008d51:	03ea80        	rsr.ccount	a8
42008d54:	c08840        	sub	a8, a8, a4
42008d57:	778a      	add.n	a7, a7, a8
42008d59:	06b8      	l32i.n	a11, a6, 0
42008d5b:	bb3b      	addi.n	a11, a11, 3
42008d5d:	06ad      	mov.n	a10, a6
42008d5f:	ff37e5        	call8	420080dc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEN9__gnu_cxx17__normal_iteratorIPKcS4_EE>
42008d62:	551b      	addi.n	a5, a5, 1
42008d64:	defd81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008d67:	d1a857        	bge	a8, a5, 42008d3c <_Z16string_benchmarkm+0x9fc>
42008d6a:	defcc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008d6d:	a2c7c0        	muluh	a12, a7, a12
42008d70:	41ccc0        	srli	a12, a12, 12
42008d73:	df25b1        	l32r	a11, 42000a08 <_stext+0x9e8> (3c0256f4 <_flash_rodata_start+0x55d4>)
42008d76:	defba1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008d79:	030625        	call8	4200bddc <printf>
    CYCLE_GET_COUNT_MUTATE(
42008d7c:	dee871        	l32r	a7, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008d7f:	5c0c      	movi.n	a12, 5
42008d81:	3b0c      	movi.n	a11, 3
42008d83:	07ad      	mov.n	a10, a7
42008d85:	ff31a5        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008d88:	df21c1        	l32r	a12, 42000a0c <_stext+0x9ec> (3c025730 <_flash_rodata_start+0x5610>)
42008d8b:	3b0c      	movi.n	a11, 3
42008d8d:	07ad      	mov.n	a10, a7
42008d8f:	ff5065        	call8	42008294 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjPKc>
42008d92:	070c      	movi.n	a7, 0
42008d94:	076d      	mov.n	a6, a7
42008d96:	000886        	j	42008dbc <_Z16string_benchmarkm+0xa7c>
42008d99:	03ea40        	rsr.ccount	a4
42008d9c:	dee051        	l32r	a5, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008d9f:	5c0c      	movi.n	a12, 5
42008da1:	3b0c      	movi.n	a11, 3
42008da3:	05ad      	mov.n	a10, a5
42008da5:	ff2fa5        	call8	420080a0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEjj>
42008da8:	03ea80        	rsr.ccount	a8
42008dab:	c08840        	sub	a8, a8, a4
42008dae:	778a      	add.n	a7, a7, a8
42008db0:	df17c1        	l32r	a12, 42000a0c <_stext+0x9ec> (3c025730 <_flash_rodata_start+0x5610>)
42008db3:	3b0c      	movi.n	a11, 3
42008db5:	05ad      	mov.n	a10, a5
42008db7:	ff4de5        	call8	42008294 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEjPKc>
42008dba:	661b      	addi.n	a6, a6, 1
42008dbc:	dee781        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008dbf:	d6a867        	bge	a8, a6, 42008d99 <_Z16string_benchmarkm+0xa59>
42008dc2:	dee6c1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008dc5:	a2c7c0        	muluh	a12, a7, a12
42008dc8:	41ccc0        	srli	a12, a12, 12
42008dcb:	df11b1        	l32r	a11, 42000a10 <_stext+0x9f0> (3c025738 <_flash_rodata_start+0x5618>)
42008dce:	dee5a1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008dd1:	0300a5        	call8	4200bddc <printf>
42008dd4:	ded271        	l32r	a7, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008dd7:	07b8      	l32i.n	a11, a7, 0
    CYCLE_GET_COUNT_MUTATE (
42008dd9:	bb3b      	addi.n	a11, a11, 3
42008ddb:	07ad      	mov.n	a10, a7
42008ddd:	ff2fe5        	call8	420080dc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEN9__gnu_cxx17__normal_iteratorIPKcS4_EE>
42008de0:	07b8      	l32i.n	a11, a7, 0
42008de2:	6ca0c2        	movi	a12, 108
42008de5:	bb3b      	addi.n	a11, a11, 3
42008de7:	07ad      	mov.n	a10, a7
42008de9:	ff3be5        	call8	420081a8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEc>
42008dec:	070c      	movi.n	a7, 0
42008dee:	075d      	mov.n	a5, a7
42008df0:	000986        	j	42008e1a <_Z16string_benchmarkm+0xada>
42008df3:	400000        	ssr	a0
42008df6:	03ea      	add.n	a0, a3, a14
42008df8:	dec961        	l32r	a6, 4200091c <_stext+0x8fc> (3fc95098 <_Z11_str_mediumB5cxx11>)
42008dfb:	06b8      	l32i.n	a11, a6, 0
42008dfd:	bb3b      	addi.n	a11, a11, 3
42008dff:	06ad      	mov.n	a10, a6
42008e01:	ff2da5        	call8	420080dc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5eraseEN9__gnu_cxx17__normal_iteratorIPKcS4_EE>
42008e04:	03ea80        	rsr.ccount	a8
42008e07:	c08840        	sub	a8, a8, a4
42008e0a:	778a      	add.n	a7, a7, a8
42008e0c:	06b8      	l32i.n	a11, a6, 0
42008e0e:	6ca0c2        	movi	a12, 108
42008e11:	bb3b      	addi.n	a11, a11, 3
42008e13:	06ad      	mov.n	a10, a6
42008e15:	ff3925        	call8	420081a8 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEc>
42008e18:	551b      	addi.n	a5, a5, 1
42008e1a:	decf81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008e1d:	d4a857        	bge	a8, a5, 42008df5 <_Z16string_benchmarkm+0xab5>
42008e20:	decfc1        	l32r	a12, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008e23:	a2c7c0        	muluh	a12, a7, a12
42008e26:	41ccc0        	srli	a12, a12, 12
42008e29:	defab1        	l32r	a11, 42000a14 <_stext+0x9f4> (3c025758 <_flash_rodata_start+0x5638>)
42008e2c:	decea1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008e2f:	02fae5        	call8	4200bddc <printf>
      { return _M_string_length; }
42008e32:	debf71        	l32r	a7, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008e35:	1748      	l32i.n	a4, a7, 4
    size_t half_jumbo = _str_jumbo.size() / 2;
42008e37:	414140        	srli	a4, a4, 1
    auto substr = _str_jumbo.substr(half_jumbo, temp_len);
42008e3a:	bd0c      	movi.n	a13, 11
42008e3c:	04cd      	mov.n	a12, a4
42008e3e:	07bd      	mov.n	a11, a7
42008e40:	50c1a2        	addi	a10, a1, 80
42008e43:	ff1ce5        	call8	42008010 <_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6substrEjj>
      { return this->assign(__s); }
42008e46:	deb981        	l32r	a8, 4200092c <_stext+0x90c> (3fc922c8 <c_str_jumbo>)
42008e49:	0028b2        	l32i	a11, a8, 0
42008e4c:	20a770        	or	a10, a7, a7
42008e4f:	ff47e5        	call8	420082cc <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignEPKc>
    CYCLE_GET_COUNT_MUTATE (
42008e52:	def1d1        	l32r	a13, 42000a18 <_stext+0x9f8> (3c02578c <_flash_rodata_start+0x566c>)
42008e55:	bc0c      	movi.n	a12, 11
42008e57:	20b440        	or	a11, a4, a4
42008e5a:	07ad      	mov.n	a10, a7
42008e5c:	ff4525        	call8	420082b0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKc>
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
42008e5f:	1521e2        	l32i	a14, a1, 84
42008e62:	1421d2        	l32i	a13, a1, 80
42008e65:	bc0c      	movi.n	a12, 11
42008e67:	04bd      	mov.n	a11, a4
42008e69:	07ad      	mov.n	a10, a7
42008e6b:	ff3fa5        	call8	42008264 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKcj>
42008e6e:	070c      	movi.n	a7, 0
42008e70:	076d      	mov.n	a6, a7
42008e72:	000a86        	j	42008ea0 <_Z16string_benchmarkm+0xb60>
42008e75:	03ea30        	rsr.ccount	a3
42008e78:	deae51        	l32r	a5, 42000930 <_stext+0x910> (3fc95060 <_Z10_str_jumboB5cxx11>)
42008e7b:	dee7d1        	l32r	a13, 42000a18 <_stext+0x9f8> (3c02578c <_flash_rodata_start+0x566c>)
42008e7e:	bc0c      	movi.n	a12, 11
42008e80:	04bd      	mov.n	a11, a4
42008e82:	05ad      	mov.n	a10, a5
42008e84:	ff42a5        	call8	420082b0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKc>
42008e87:	03ea80        	rsr.ccount	a8
42008e8a:	c08830        	sub	a8, a8, a3
42008e8d:	778a      	add.n	a7, a7, a8
42008e8f:	1521e2        	l32i	a14, a1, 84
42008e92:	1421d2        	l32i	a13, a1, 80
42008e95:	bc0c      	movi.n	a12, 11
42008e97:	04bd      	mov.n	a11, a4
42008e99:	05ad      	mov.n	a10, a5
42008e9b:	ff3ca5        	call8	42008264 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7replaceEjjPKcj>
42008e9e:	661b      	addi.n	a6, a6, 1
42008ea0:	deae81        	l32r	a8, 42000958 <_stext+0x938> (1387 <UserFrameTotalSize+0x1287>)
42008ea3:	cea867        	bge	a8, a6, 42008e75 <_Z16string_benchmarkm+0xb35>
42008ea6:	dead81        	l32r	a8, 4200095c <_stext+0x93c> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008ea9:	a2c780        	muluh	a12, a7, a8
42008eac:	41ccc0        	srli	a12, a12, 12
42008eaf:	dedbb1        	l32r	a11, 42000a1c <_stext+0x9fc> (3c025798 <_flash_rodata_start+0x5678>)
42008eb2:	deaca1        	l32r	a10, 42000964 <_stext+0x944> (3c025288 <_flash_rodata_start+0x5168>)
42008eb5:	02f265        	call8	4200bddc <printf>
    ESP_LOGI(tag, "DONE\n");    
42008eb8:	dc6a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42008ebb:	0008e0        	callx8	a8
42008ebe:	ded8b1        	l32r	a11, 42000a20 <_stext+0xa00> (3c0251d4 <_flash_rodata_start+0x50b4>)
42008ec1:	0bed      	mov.n	a14, a11
42008ec3:	0add      	mov.n	a13, a10
42008ec5:	ded7c1        	l32r	a12, 42000a24 <_stext+0xa04> (3c0257d0 <_flash_rodata_start+0x56b0>)
42008ec8:	3a0c      	movi.n	a10, 3
42008eca:	dc7281        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42008ecd:	0008e0        	callx8	a8
      { _M_dispose(); }
42008ed0:	50c1a2        	addi	a10, a1, 80
42008ed3:	fedb65        	call8	42007c88 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_disposeEv>
}
42008ed6:	f01d      	retw.n

42008ed8 <_GLOBAL__sub_I_c_str_tiny>:
42008ed8:	004136        	entry	a1, 32
42008edb:	ff07e5        	call8	42007f58 <_Z41__static_initialization_and_destruction_0v>
42008ede:	f01d      	retw.n

42008ee0 <gpio_sleep_input_enable>:
    gpio_hal_sleep_input_disable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
}

static esp_err_t gpio_sleep_input_enable(gpio_num_t gpio_num)
{
42008ee0:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008ee3:	02d296        	bltz	a2, 42008f14 <gpio_sleep_input_enable+0x34>
42008ee6:	0a2c      	movi.n	a10, 32
42008ee8:	10a2a0        	and	a10, a2, a10
42008eeb:	f87c      	movi.n	a8, -1
42008eed:	308280        	xor	a8, a2, a8
42008ef0:	ddac91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008ef3:	401800        	ssl	a8
42008ef6:	a19900        	sll	a9, a9
42008ef9:	ddaa81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008efc:	400200        	ssr	a2
42008eff:	918080        	srl	a8, a8
42008f02:	208980        	or	a8, a9, a8
42008f05:	dda891        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008f08:	400200        	ssr	a2
42008f0b:	919090        	srl	a9, a9
42008f0e:	9389a0        	movnez	a8, a9, a10
42008f11:	2be807        	bbsi	a8, 0, 42008f40 <gpio_sleep_input_enable+0x60>
42008f14:	dc5381        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42008f17:	0008e0        	callx8	a8
42008f1a:	dec5b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
42008f1d:	dec681        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
42008f20:	1189      	s32i.n	a8, a1, 4
42008f22:	5da382        	movi	a8, 0x35d
42008f25:	0189      	s32i.n	a8, a1, 0
42008f27:	dec1f1        	l32r	a15, 42000a2c <_stext+0xa0c> (3c028868 <__FUNCTION__$13>)
42008f2a:	0bed      	mov.n	a14, a11
42008f2c:	0add      	mov.n	a13, a10
42008f2e:	dec1c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42008f31:	1a0c      	movi.n	a10, 1
42008f33:	dc5881        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42008f36:	0008e0        	callx8	a8
42008f39:	02a122        	movi	a2, 0x102
42008f3c:	000646        	j	42008f59 <gpio_sleep_input_enable+0x79>
42008f3f:	bf8100        	f64cmph	a8, a1, a0, 11
  * @param gpio_num GPIO number
  */
__attribute__((always_inline))
static inline void gpio_ll_sleep_input_enable(gpio_dev_t *hw, uint32_t gpio_num)
{
    PIN_SLP_INPUT_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008f42:	de          	.byte	0xde
42008f43:	a02280        	addx4	a2, a2, a8
42008f46:	0298      	l32i.n	a9, a2, 0
42008f48:	0020c0        	memw
42008f4b:	0988      	l32i.n	a8, a9, 0
42008f4d:	0a1c      	movi.n	a10, 16
42008f4f:	2088a0        	or	a8, a8, a10
42008f52:	0020c0        	memw
42008f55:	0989      	s32i.n	a8, a9, 0
    gpio_hal_sleep_input_enable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
42008f57:	020c      	movi.n	a2, 0
}
42008f59:	f01d      	retw.n
	...

42008f5c <gpio_sleep_input_disable>:
{
42008f5c:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008f5f:	02d296        	bltz	a2, 42008f90 <gpio_sleep_input_disable+0x34>
42008f62:	0a2c      	movi.n	a10, 32
42008f64:	10a2a0        	and	a10, a2, a10
42008f67:	f87c      	movi.n	a8, -1
42008f69:	308280        	xor	a8, a2, a8
42008f6c:	dd8d91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008f6f:	401800        	ssl	a8
42008f72:	a19900        	sll	a9, a9
42008f75:	dd8b81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008f78:	400200        	ssr	a2
42008f7b:	918080        	srl	a8, a8
42008f7e:	208980        	or	a8, a9, a8
42008f81:	dd8991        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008f84:	400200        	ssr	a2
42008f87:	919090        	srl	a9, a9
42008f8a:	9389a0        	movnez	a8, a9, a10
42008f8d:	2be807        	bbsi	a8, 0, 42008fbc <gpio_sleep_input_disable+0x60>
42008f90:	dc3481        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42008f93:	0008e0        	callx8	a8
42008f96:	dea6b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
42008f99:	dea781        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
42008f9c:	1189      	s32i.n	a8, a1, 4
42008f9e:	56a382        	movi	a8, 0x356
42008fa1:	0189      	s32i.n	a8, a1, 0
42008fa3:	dea7f1        	l32r	a15, 42000a40 <_stext+0xa20> (3c02884c <__FUNCTION__$12>)
42008fa6:	0bed      	mov.n	a14, a11
42008fa8:	0add      	mov.n	a13, a10
42008faa:	dea2c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42008fad:	1a0c      	movi.n	a10, 1
42008faf:	dc3981        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42008fb2:	0008e0        	callx8	a8
42008fb5:	02a122        	movi	a2, 0x102
42008fb8:	000646        	j	42008fd5 <gpio_sleep_input_disable+0x79>
42008fbb:	a08100        	addx4	a8, a1, a0
    PIN_SLP_INPUT_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008fbe:	de          	.byte	0xde
42008fbf:	a02280        	addx4	a2, a2, a8
42008fc2:	0298      	l32i.n	a9, a2, 0
42008fc4:	0020c0        	memw
42008fc7:	0988      	l32i.n	a8, a9, 0
42008fc9:	fa6c      	movi.n	a10, -17
42008fcb:	1088a0        	and	a8, a8, a10
42008fce:	0020c0        	memw
42008fd1:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
42008fd3:	020c      	movi.n	a2, 0
}
42008fd5:	f01d      	retw.n
	...

42008fd8 <gpio_sleep_output_enable>:
    gpio_hal_sleep_output_disable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
}

static esp_err_t gpio_sleep_output_enable(gpio_num_t gpio_num)
{
42008fd8:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_OUTPUT_GPIO(gpio_num), "GPIO output gpio_num error", ESP_ERR_INVALID_ARG);
42008fdb:	02d296        	bltz	a2, 4200900c <gpio_sleep_output_enable+0x34>
42008fde:	0a2c      	movi.n	a10, 32
42008fe0:	10a2a0        	and	a10, a2, a10
42008fe3:	f87c      	movi.n	a8, -1
42008fe5:	308280        	xor	a8, a2, a8
42008fe8:	dd6e91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008feb:	401800        	ssl	a8
42008fee:	a19900        	sll	a9, a9
42008ff1:	dd6c81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008ff4:	400200        	ssr	a2
42008ff7:	918080        	srl	a8, a8
42008ffa:	208980        	or	a8, a9, a8
42008ffd:	dd6a91        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42009000:	400200        	ssr	a2
42009003:	919090        	srl	a9, a9
42009006:	9389a0        	movnez	a8, a9, a10
42009009:	2be807        	bbsi	a8, 0, 42009038 <gpio_sleep_output_enable+0x60>
4200900c:	dc1581        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200900f:	0008e0        	callx8	a8
42009012:	de87b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
42009015:	de8c81        	l32r	a8, 42000a48 <_stext+0xa28> (3c025dc0 <_flash_rodata_start+0x5ca0>)
42009018:	1189      	s32i.n	a8, a1, 4
4200901a:	6ba382        	movi	a8, 0x36b
4200901d:	0189      	s32i.n	a8, a1, 0
4200901f:	de89f1        	l32r	a15, 42000a44 <_stext+0xa24> (3c028830 <__FUNCTION__$11>)
42009022:	0bed      	mov.n	a14, a11
42009024:	0add      	mov.n	a13, a10
42009026:	de83c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42009029:	1a0c      	movi.n	a10, 1
4200902b:	dc1a81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200902e:	0008e0        	callx8	a8
42009031:	02a122        	movi	a2, 0x102
42009034:	000646        	j	42009051 <gpio_sleep_output_enable+0x79>
42009037:	818100        	src	a8, a1, a0
  * @param gpio_num GPIO number
  */
__attribute__((always_inline))
static inline void gpio_ll_sleep_output_enable(gpio_dev_t *hw, uint32_t gpio_num)
{
    PIN_SLP_OUTPUT_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200903a:	de          	.byte	0xde
4200903b:	a02280        	addx4	a2, a2, a8
4200903e:	0298      	l32i.n	a9, a2, 0
42009040:	0020c0        	memw
42009043:	0988      	l32i.n	a8, a9, 0
42009045:	1a0c      	movi.n	a10, 1
42009047:	2088a0        	or	a8, a8, a10
4200904a:	0020c0        	memw
4200904d:	0989      	s32i.n	a8, a9, 0
    gpio_hal_sleep_output_enable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
4200904f:	020c      	movi.n	a2, 0
}
42009051:	f01d      	retw.n
	...

42009054 <gpio_sleep_output_disable>:
{
42009054:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42009057:	02d296        	bltz	a2, 42009088 <gpio_sleep_output_disable+0x34>
4200905a:	0a2c      	movi.n	a10, 32
4200905c:	10a2a0        	and	a10, a2, a10
4200905f:	f87c      	movi.n	a8, -1
42009061:	308280        	xor	a8, a2, a8
42009064:	dd4f91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42009067:	401800        	ssl	a8
4200906a:	a19900        	sll	a9, a9
4200906d:	dd4d81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42009070:	400200        	ssr	a2
42009073:	918080        	srl	a8, a8
42009076:	208980        	or	a8, a9, a8
42009079:	dd4b91        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
4200907c:	400200        	ssr	a2
4200907f:	919090        	srl	a9, a9
42009082:	9389a0        	movnez	a8, a9, a10
42009085:	2be807        	bbsi	a8, 0, 420090b4 <gpio_sleep_output_disable+0x60>
42009088:	dbf681        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200908b:	0008e0        	callx8	a8
4200908e:	de68b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
42009091:	de6981        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
42009094:	1189      	s32i.n	a8, a1, 4
42009096:	64a382        	movi	a8, 0x364
42009099:	0189      	s32i.n	a8, a1, 0
4200909b:	de6cf1        	l32r	a15, 42000a4c <_stext+0xa2c> (3c028814 <__FUNCTION__$10>)
4200909e:	0bed      	mov.n	a14, a11
420090a0:	0add      	mov.n	a13, a10
420090a2:	de64c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
420090a5:	1a0c      	movi.n	a10, 1
420090a7:	dbfb81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420090aa:	0008e0        	callx8	a8
420090ad:	02a122        	movi	a2, 0x102
420090b0:	000646        	j	420090cd <gpio_sleep_output_disable+0x79>
420090b3:	628100        	lsi	f0, a1, 0x188
    PIN_SLP_OUTPUT_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
420090b6:	de          	.byte	0xde
420090b7:	a02280        	addx4	a2, a2, a8
420090ba:	0298      	l32i.n	a9, a2, 0
420090bc:	0020c0        	memw
420090bf:	0988      	l32i.n	a8, a9, 0
420090c1:	ea7c      	movi.n	a10, -2
420090c3:	1088a0        	and	a8, a8, a10
420090c6:	0020c0        	memw
420090c9:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
420090cb:	020c      	movi.n	a2, 0
}
420090cd:	f01d      	retw.n
	...

420090d0 <gpio_sleep_pulldown_en>:
{
420090d0:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420090d3:	02d296        	bltz	a2, 42009104 <gpio_sleep_pulldown_en+0x34>
420090d6:	0a2c      	movi.n	a10, 32
420090d8:	10a2a0        	and	a10, a2, a10
420090db:	f87c      	movi.n	a8, -1
420090dd:	308280        	xor	a8, a2, a8
420090e0:	dd3091        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
420090e3:	401800        	ssl	a8
420090e6:	a19900        	sll	a9, a9
420090e9:	dd2e81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
420090ec:	400200        	ssr	a2
420090ef:	918080        	srl	a8, a8
420090f2:	208980        	or	a8, a9, a8
420090f5:	dd2c91        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
420090f8:	400200        	ssr	a2
420090fb:	919090        	srl	a9, a9
420090fe:	9389a0        	movnez	a8, a9, a10
42009101:	2ce807        	bbsi	a8, 0, 42009131 <gpio_sleep_pulldown_en+0x61>
42009104:	dbd781        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009107:	0008e0        	callx8	a8
4200910a:	de49b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
4200910d:	de4a81        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
42009110:	1189      	s32i.n	a8, a1, 4
42009112:	40a382        	movi	a8, 0x340
42009115:	0189      	s32i.n	a8, a1, 0
42009117:	de4ef1        	l32r	a15, 42000a50 <_stext+0xa30> (3c0287e0 <__FUNCTION__$8>)
4200911a:	0bed      	mov.n	a14, a11
4200911c:	0add      	mov.n	a13, a10
4200911e:	de45c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42009121:	1a0c      	movi.n	a10, 1
42009123:	dbdc81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009126:	0008e0        	callx8	a8
42009129:	02a122        	movi	a2, 0x102
4200912c:	000b86        	j	4200915e <gpio_sleep_pulldown_en+0x8e>
4200912f:	7c0000        	lsi	f0, a0, 0x1f0
42009132:	a1fb      	addi.n	a10, a1, 15
42009134:	de48      	l32i.n	a4, a14, 52
42009136:	dcb681        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42009139:	0008e0        	callx8	a8
    PIN_SLP_PULLDOWN_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200913c:	de4081        	l32r	a8, 42000a3c <_stext+0xa1c> (3c028cd4 <GPIO_PIN_MUX_REG>)
4200913f:	a02280        	addx4	a2, a2, a8
42009142:	0298      	l32i.n	a9, a2, 0
42009144:	0020c0        	memw
42009147:	0988      	l32i.n	a8, a9, 0
42009149:	4a0c      	movi.n	a10, 4
4200914b:	2088a0        	or	a8, a8, a10
4200914e:	0020c0        	memw
42009151:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42009153:	de40a1        	l32r	a10, 42000a54 <_stext+0xa34> (3fc9270c <gpio_context+0x4>)
42009156:	dcaf81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42009159:	0008e0        	callx8	a8
    return ESP_OK;
4200915c:	020c      	movi.n	a2, 0
}
4200915e:	f01d      	retw.n

42009160 <gpio_sleep_pullup_en>:
{
42009160:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42009163:	02d296        	bltz	a2, 42009194 <gpio_sleep_pullup_en+0x34>
42009166:	0a2c      	movi.n	a10, 32
42009168:	10a2a0        	and	a10, a2, a10
4200916b:	f87c      	movi.n	a8, -1
4200916d:	308280        	xor	a8, a2, a8
42009170:	dd0c91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42009173:	401800        	ssl	a8
42009176:	a19900        	sll	a9, a9
42009179:	dd0a81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200917c:	400200        	ssr	a2
4200917f:	918080        	srl	a8, a8
42009182:	208980        	or	a8, a9, a8
42009185:	dd0891        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42009188:	400200        	ssr	a2
4200918b:	919090        	srl	a9, a9
4200918e:	9389a0        	movnez	a8, a9, a10
42009191:	2ce807        	bbsi	a8, 0, 420091c1 <gpio_sleep_pullup_en+0x61>
42009194:	dbb381        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009197:	0008e0        	callx8	a8
4200919a:	de25b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
4200919d:	de2681        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
420091a0:	1189      	s32i.n	a8, a1, 4
420091a2:	2aa382        	movi	a8, 0x32a
420091a5:	0189      	s32i.n	a8, a1, 0
420091a7:	de2cf1        	l32r	a15, 42000a58 <_stext+0xa38> (3c0287c8 <__FUNCTION__$7>)
420091aa:	0bed      	mov.n	a14, a11
420091ac:	0add      	mov.n	a13, a10
420091ae:	de21c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
420091b1:	1a0c      	movi.n	a10, 1
420091b3:	dbb881        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420091b6:	0008e0        	callx8	a8
420091b9:	02a122        	movi	a2, 0x102
420091bc:	000b86        	j	420091ee <gpio_sleep_pullup_en+0x8e>
420091bf:	7c0000        	lsi	f0, a0, 0x1f0
420091c2:	a1fb      	addi.n	a10, a1, 15
420091c4:	81de24        	lsi	f2, a14, 0x204
420091c7:	e0dc92        	addmi	a9, a12, 0xffffe000
420091ca:	0008      	l32i.n	a0, a0, 0
    PIN_SLP_PULLUP_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
420091cc:	de1c81        	l32r	a8, 42000a3c <_stext+0xa1c> (3c028cd4 <GPIO_PIN_MUX_REG>)
420091cf:	a02280        	addx4	a2, a2, a8
420091d2:	0298      	l32i.n	a9, a2, 0
420091d4:	0020c0        	memw
420091d7:	0988      	l32i.n	a8, a9, 0
420091d9:	8a0c      	movi.n	a10, 8
420091db:	2088a0        	or	a8, a8, a10
420091de:	0020c0        	memw
420091e1:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
420091e3:	de1ca1        	l32r	a10, 42000a54 <_stext+0xa34> (3fc9270c <gpio_context+0x4>)
420091e6:	dc8b81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420091e9:	0008e0        	callx8	a8
    return ESP_OK;
420091ec:	020c      	movi.n	a2, 0
}
420091ee:	f01d      	retw.n

420091f0 <gpio_sleep_pulldown_dis>:
{
420091f0:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420091f3:	02d296        	bltz	a2, 42009224 <gpio_sleep_pulldown_dis+0x34>
420091f6:	0a2c      	movi.n	a10, 32
420091f8:	10a2a0        	and	a10, a2, a10
420091fb:	f87c      	movi.n	a8, -1
420091fd:	308280        	xor	a8, a2, a8
42009200:	dce891        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42009203:	401800        	ssl	a8
42009206:	a19900        	sll	a9, a9
42009209:	dce681        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200920c:	400200        	ssr	a2
4200920f:	918080        	srl	a8, a8
42009212:	208980        	or	a8, a9, a8
42009215:	dce491        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42009218:	400200        	ssr	a2
4200921b:	919090        	srl	a9, a9
4200921e:	9389a0        	movnez	a8, a9, a10
42009221:	2ae807        	bbsi	a8, 0, 4200924f <gpio_sleep_pulldown_dis+0x5f>
42009224:	db8f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009227:	0008e0        	callx8	a8
4200922a:	de01b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
4200922d:	de0281        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
42009230:	1189      	s32i.n	a8, a1, 4
42009232:	4ba382        	movi	a8, 0x34b
42009235:	0189      	s32i.n	a8, a1, 0
42009237:	de09f1        	l32r	a15, 42000a5c <_stext+0xa3c> (3c0287b0 <__FUNCTION__$6>)
4200923a:	0bed      	mov.n	a14, a11
4200923c:	0add      	mov.n	a13, a10
4200923e:	ddfdc1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42009241:	1a0c      	movi.n	a10, 1
42009243:	db9481        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009246:	0008e0        	callx8	a8
42009249:	02a122        	movi	a2, 0x102
4200924c:	000b06        	j	4200927c <gpio_sleep_pulldown_dis+0x8c>
4200924f:	fb7c      	movi.n	a11, -1
42009251:	de00a1        	l32r	a10, 42000a54 <_stext+0xa34> (3fc9270c <gpio_context+0x4>)
42009254:	dc6f81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42009257:	0008e0        	callx8	a8
    PIN_SLP_PULLDOWN_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200925a:	ddf881        	l32r	a8, 42000a3c <_stext+0xa1c> (3c028cd4 <GPIO_PIN_MUX_REG>)
4200925d:	a02280        	addx4	a2, a2, a8
42009260:	0298      	l32i.n	a9, a2, 0
42009262:	0020c0        	memw
42009265:	0988      	l32i.n	a8, a9, 0
42009267:	ba7c      	movi.n	a10, -5
42009269:	1088a0        	and	a8, a8, a10
4200926c:	0020c0        	memw
4200926f:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42009271:	ddf8a1        	l32r	a10, 42000a54 <_stext+0xa34> (3fc9270c <gpio_context+0x4>)
42009274:	dc6881        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42009277:	0008e0        	callx8	a8
    return ESP_OK;
4200927a:	020c      	movi.n	a2, 0
}
4200927c:	f01d      	retw.n
	...

42009280 <gpio_sleep_pullup_dis>:
{
42009280:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42009283:	02d296        	bltz	a2, 420092b4 <gpio_sleep_pullup_dis+0x34>
42009286:	0a2c      	movi.n	a10, 32
42009288:	10a2a0        	and	a10, a2, a10
4200928b:	f87c      	movi.n	a8, -1
4200928d:	308280        	xor	a8, a2, a8
42009290:	dcc491        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42009293:	401800        	ssl	a8
42009296:	a19900        	sll	a9, a9
42009299:	dcc281        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200929c:	400200        	ssr	a2
4200929f:	918080        	srl	a8, a8
420092a2:	208980        	or	a8, a9, a8
420092a5:	dcc091        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
420092a8:	400200        	ssr	a2
420092ab:	919090        	srl	a9, a9
420092ae:	9389a0        	movnez	a8, a9, a10
420092b1:	2ce807        	bbsi	a8, 0, 420092e1 <gpio_sleep_pullup_dis+0x61>
420092b4:	db6b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420092b7:	0008e0        	callx8	a8
420092ba:	ddddb1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
420092bd:	ddde81        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
420092c0:	1189      	s32i.n	a8, a1, 4
420092c2:	35a382        	movi	a8, 0x335
420092c5:	0189      	s32i.n	a8, a1, 0
420092c7:	dde6f1        	l32r	a15, 42000a60 <_stext+0xa40> (3c028798 <__FUNCTION__$5>)
420092ca:	0bed      	mov.n	a14, a11
420092cc:	0add      	mov.n	a13, a10
420092ce:	ddd9c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
420092d1:	1a0c      	movi.n	a10, 1
420092d3:	db7081        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420092d6:	0008e0        	callx8	a8
420092d9:	02a122        	movi	a2, 0x102
420092dc:	000b86        	j	4200930e <gpio_sleep_pullup_dis+0x8e>
420092df:	7c0000        	lsi	f0, a0, 0x1f0
420092e2:	a1fb      	addi.n	a10, a1, 15
420092e4:	dddc      	bnez.n	a13, 42009305 <gpio_sleep_pullup_dis+0x85>
420092e6:	dc4a81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420092e9:	0008e0        	callx8	a8
    PIN_SLP_PULLUP_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
420092ec:	ddd481        	l32r	a8, 42000a3c <_stext+0xa1c> (3c028cd4 <GPIO_PIN_MUX_REG>)
420092ef:	a02280        	addx4	a2, a2, a8
420092f2:	0298      	l32i.n	a9, a2, 0
420092f4:	0020c0        	memw
420092f7:	0988      	l32i.n	a8, a9, 0
420092f9:	7a7c      	movi.n	a10, -9
420092fb:	1088a0        	and	a8, a8, a10
420092fe:	0020c0        	memw
42009301:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42009303:	ddd4a1        	l32r	a10, 42000a54 <_stext+0xa34> (3fc9270c <gpio_context+0x4>)
42009306:	dc4381        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42009309:	0008e0        	callx8	a8
    return ESP_OK;
4200930c:	020c      	movi.n	a2, 0
}
4200930e:	f01d      	retw.n

42009310 <gpio_sleep_set_direction>:

esp_err_t gpio_sleep_set_direction(gpio_num_t gpio_num, gpio_mode_t mode)
{
42009310:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42009313:	02d296        	bltz	a2, 42009344 <gpio_sleep_set_direction+0x34>
42009316:	0a2c      	movi.n	a10, 32
42009318:	10a2a0        	and	a10, a2, a10
4200931b:	f87c      	movi.n	a8, -1
4200931d:	308280        	xor	a8, a2, a8
42009320:	dca091        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42009323:	401800        	ssl	a8
42009326:	a19900        	sll	a9, a9
42009329:	dc9e81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200932c:	400200        	ssr	a2
4200932f:	918080        	srl	a8, a8
42009332:	208980        	or	a8, a9, a8
42009335:	dc9c91        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42009338:	400200        	ssr	a2
4200933b:	919090        	srl	a9, a9
4200933e:	9389a0        	movnez	a8, a9, a10
42009341:	2ce807        	bbsi	a8, 0, 42009371 <gpio_sleep_set_direction+0x61>
42009344:	db4781        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009347:	0008e0        	callx8	a8
4200934a:	ddb9b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
4200934d:	ddba81        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
42009350:	1189      	s32i.n	a8, a1, 4
42009352:	72a382        	movi	a8, 0x372
42009355:	0189      	s32i.n	a8, a1, 0
42009357:	ddc3f1        	l32r	a15, 42000a64 <_stext+0xa44> (3c028880 <__FUNCTION__$14>)
4200935a:	0bed      	mov.n	a14, a11
4200935c:	0add      	mov.n	a13, a10
4200935e:	ddb5c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42009361:	1a0c      	movi.n	a10, 1
42009363:	db4c81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009366:	0008e0        	callx8	a8
42009369:	02a122        	movi	a2, 0x102
4200936c:	000a86        	j	4200939a <gpio_sleep_set_direction+0x8a>
4200936f:	070000        	lsi	f0, a0, 28
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t ret = ESP_OK;

    if (mode & GPIO_MODE_DEF_INPUT) {
42009372:	ad0863        	lsi	f6, a8, 0x2b4
        gpio_sleep_input_enable(gpio_num);
42009375:	b6a502        	movi	a0, 0x5b6
42009378:	ff          	.byte	0xff
42009379:	000186        	j	42009383 <gpio_sleep_set_direction+0x73>
4200937c:	a22000        	muluh	a2, a0, a0
    } else {
        gpio_sleep_input_disable(gpio_num);
4200937f:	bda520        	lsi	f2, a5, 0x2f4
42009382:	ff          	.byte	0xff
    }

    if (mode & GPIO_MODE_DEF_OUTPUT) {
42009383:	0a6317        	bbci	a3, 1, 42009391 <gpio_sleep_set_direction+0x81>
        gpio_sleep_output_enable(gpio_num);
42009386:	20a220        	or	a10, a2, a2
42009389:	ffc4e5        	call8	42008fd8 <gpio_sleep_output_enable>
    } else {
        gpio_sleep_output_disable(gpio_num);
    }

    return ret;
4200938c:	020c      	movi.n	a2, 0
4200938e:	000206        	j	4200939a <gpio_sleep_set_direction+0x8a>
        gpio_sleep_output_disable(gpio_num);
42009391:	20a220        	or	a10, a2, a2
42009394:	ffcbe5        	call8	42009054 <gpio_sleep_output_disable>
    return ret;
42009397:	00a022        	movi	a2, 0
}
4200939a:	000090        	retw
4200939d:	000000        	ill

420093a0 <gpio_sleep_set_pull_mode>:

esp_err_t gpio_sleep_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
420093a0:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420093a3:	02d296        	bltz	a2, 420093d4 <gpio_sleep_set_pull_mode+0x34>
420093a6:	0a2c      	movi.n	a10, 32
420093a8:	10a2a0        	and	a10, a2, a10
420093ab:	f87c      	movi.n	a8, -1
420093ad:	308280        	xor	a8, a2, a8
420093b0:	dc7c91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
420093b3:	401800        	ssl	a8
420093b6:	a19900        	sll	a9, a9
420093b9:	dc7a81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
420093bc:	400200        	ssr	a2
420093bf:	918080        	srl	a8, a8
420093c2:	208980        	or	a8, a9, a8
420093c5:	dc7891        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
420093c8:	400200        	ssr	a2
420093cb:	919090        	srl	a9, a9
420093ce:	9389a0        	movnez	a8, a9, a10
420093d1:	2be807        	bbsi	a8, 0, 42009400 <gpio_sleep_set_pull_mode+0x60>
420093d4:	db2381        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420093d7:	0008e0        	callx8	a8
420093da:	dd95b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
420093dd:	dd9681        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
420093e0:	1189      	s32i.n	a8, a1, 4
420093e2:	8ca382        	movi	a8, 0x38c
420093e5:	0189      	s32i.n	a8, a1, 0
420093e7:	dda0f1        	l32r	a15, 42000a68 <_stext+0xa48> (3c0287f8 <__FUNCTION__$9>)
420093ea:	0bed      	mov.n	a14, a11
420093ec:	0add      	mov.n	a13, a10
420093ee:	dd91c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
420093f1:	1a0c      	movi.n	a10, 1
420093f3:	db2881        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420093f6:	0008e0        	callx8	a8
420093f9:	02a122        	movi	a2, 0x102
420093fc:	002ac6        	j	420094ab <gpio_sleep_set_pull_mode+0x10b>
420093ff:	43b600        	min	a11, a6, a0
    GPIO_CHECK(pull <= GPIO_FLOATING, "GPIO pull mode error", ESP_ERR_INVALID_ARG);
42009402:	812c      	movi.n	a1, 40
42009404:	e0db17        	bbs	a11, a1, 420093e8 <gpio_sleep_set_pull_mode+0x48>
42009407:	0008      	l32i.n	a0, a0, 0
42009409:	dd89b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
4200940c:	dd9881        	l32r	a8, 42000a6c <_stext+0xa4c> (3c025ddc <_flash_rodata_start+0x5cbc>)
4200940f:	1189      	s32i.n	a8, a1, 4
42009411:	8da382        	movi	a8, 0x38d
42009414:	0189      	s32i.n	a8, a1, 0
42009416:	dd94f1        	l32r	a15, 42000a68 <_stext+0xa48> (3c0287f8 <__FUNCTION__$9>)
42009419:	0bed      	mov.n	a14, a11
4200941b:	0add      	mov.n	a13, a10
4200941d:	dd85c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42009420:	1a0c      	movi.n	a10, 1
42009422:	db1c81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009425:	0008e0        	callx8	a8
42009428:	02a122        	movi	a2, 0x102
4200942b:	001f06        	j	420094ab <gpio_sleep_set_pull_mode+0x10b>
4200942e:	260000        	lsi	f0, a0, 152
    esp_err_t ret = ESP_OK;

    switch (pull) {
42009431:	f63523        	lsi	f2, a5, 0x3d8
42009434:	8c0933        	lsi	f3, a9, 0x230
42009437:	1326c3        	lsi	f12, a6, 76
4200943a:	061c      	movi.n	a6, 16
4200943c:	000013        	lsi	f1, a0, 0
4200943f:	332600        	clamps	a2, a6, 7
42009442:	110636        	entry	a6, 0x880
42009445:	a22000        	muluh	a2, a0, a0
    case GPIO_PULLUP_ONLY:
        gpio_sleep_pulldown_dis(gpio_num);
42009448:	da6520        	ufloat.s	f6, a5, 2
4200944b:	ff          	.byte	0xff
        gpio_sleep_pullup_en(gpio_num);
4200944c:	20a220        	or	a10, a2, a2
4200944f:	ffd125        	call8	42009160 <gpio_sleep_pullup_en>
    esp_err_t ret = ESP_OK;
42009452:	020c      	movi.n	a2, 0
        break;
42009454:	0014c6        	j	420094ab <gpio_sleep_set_pull_mode+0x10b>
42009457:	a22000        	muluh	a2, a0, a0

    case GPIO_PULLDOWN_ONLY:
        gpio_sleep_pulldown_en(gpio_num);
4200945a:	c76520        	lsi	f2, a5, 0x31c
4200945d:	ff          	.byte	0xff
        gpio_sleep_pullup_dis(gpio_num);
4200945e:	20a220        	or	a10, a2, a2
42009461:	ffe1e5        	call8	42009280 <gpio_sleep_pullup_dis>
    esp_err_t ret = ESP_OK;
42009464:	020c      	movi.n	a2, 0
        break;
42009466:	001046        	j	420094ab <gpio_sleep_set_pull_mode+0x10b>

    case GPIO_PULLUP_PULLDOWN:
        gpio_sleep_pulldown_en(gpio_num);
42009469:	20a220        	or	a10, a2, a2
4200946c:	ffc625        	call8	420090d0 <gpio_sleep_pulldown_en>
        gpio_sleep_pullup_en(gpio_num);
4200946f:	20a220        	or	a10, a2, a2
42009472:	ffcee5        	call8	42009160 <gpio_sleep_pullup_en>
    esp_err_t ret = ESP_OK;
42009475:	020c      	movi.n	a2, 0
        break;
42009477:	000c06        	j	420094ab <gpio_sleep_set_pull_mode+0x10b>

    case GPIO_FLOATING:
        gpio_sleep_pulldown_dis(gpio_num);
4200947a:	20a220        	or	a10, a2, a2
4200947d:	ffd725        	call8	420091f0 <gpio_sleep_pulldown_dis>
        gpio_sleep_pullup_dis(gpio_num);
42009480:	20a220        	or	a10, a2, a2
42009483:	ffdfe5        	call8	42009280 <gpio_sleep_pullup_dis>
    esp_err_t ret = ESP_OK;
42009486:	020c      	movi.n	a2, 0
        break;
42009488:	0007c6        	j	420094ab <gpio_sleep_set_pull_mode+0x10b>

    default:
        ESP_LOGE(GPIO_TAG, "Unknown pull up/down mode,gpio_num=%u,pull=%u", gpio_num, pull);
4200948b:	daf581        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200948e:	0008e0        	callx8	a8
42009491:	dd67b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
42009494:	0139      	s32i.n	a3, a1, 0
42009496:	02fd      	mov.n	a15, a2
42009498:	0bed      	mov.n	a14, a11
4200949a:	0add      	mov.n	a13, a10
4200949c:	dd75c1        	l32r	a12, 42000a70 <_stext+0xa50> (3c025df4 <_flash_rodata_start+0x5cd4>)
4200949f:	01a0a2        	movi	a10, 1
420094a2:	dafc81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420094a5:	0008e0        	callx8	a8
        ret = ESP_ERR_INVALID_ARG;
420094a8:	02a122        	movi	a2, 0x102
        break;
    }

    return ret;
}
420094ab:	f01d      	retw.n
420094ad:	000000        	ill

420094b0 <gpio_sleep_sel_en>:

esp_err_t gpio_sleep_sel_en(gpio_num_t gpio_num)
{
420094b0:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420094b3:	02d296        	bltz	a2, 420094e4 <gpio_sleep_sel_en+0x34>
420094b6:	0a2c      	movi.n	a10, 32
420094b8:	10a2a0        	and	a10, a2, a10
420094bb:	f87c      	movi.n	a8, -1
420094bd:	308280        	xor	a8, a2, a8
420094c0:	dc3891        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
420094c3:	401800        	ssl	a8
420094c6:	a19900        	sll	a9, a9
420094c9:	dc3681        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
420094cc:	400200        	ssr	a2
420094cf:	918080        	srl	a8, a8
420094d2:	208980        	or	a8, a9, a8
420094d5:	dc3491        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
420094d8:	400200        	ssr	a2
420094db:	919090        	srl	a9, a9
420094de:	9389a0        	movnez	a8, a9, a10
420094e1:	2ce807        	bbsi	a8, 0, 42009511 <gpio_sleep_sel_en+0x61>
420094e4:	dadf81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420094e7:	0008e0        	callx8	a8
420094ea:	dd51b1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
420094ed:	dd5281        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
420094f0:	1189      	s32i.n	a8, a1, 4
420094f2:	b0a382        	movi	a8, 0x3b0
420094f5:	0189      	s32i.n	a8, a1, 0
420094f7:	dd5ff1        	l32r	a15, 42000a74 <_stext+0xa54> (3c028784 <__FUNCTION__$4>)
420094fa:	0bed      	mov.n	a14, a11
420094fc:	0add      	mov.n	a13, a10
420094fe:	dd4dc1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42009501:	1a0c      	movi.n	a10, 1
42009503:	dae481        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009506:	0008e0        	callx8	a8
42009509:	02a122        	movi	a2, 0x102
4200950c:	000b86        	j	4200953e <gpio_sleep_sel_en+0x8e>
4200950f:	7c0000        	lsi	f0, a0, 0x1f0
42009512:	a1fb      	addi.n	a10, a1, 15
42009514:	81dd50        	src	a13, a13, a5
42009517:	be          	.byte	0xbe
42009518:	e0db      	addi.n	a14, a0, 13
4200951a:	0008      	l32i.n	a0, a0, 0
    PIN_SLP_SEL_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200951c:	dd4881        	l32r	a8, 42000a3c <_stext+0xa1c> (3c028cd4 <GPIO_PIN_MUX_REG>)
4200951f:	a02280        	addx4	a2, a2, a8
42009522:	0298      	l32i.n	a9, a2, 0
42009524:	0020c0        	memw
42009527:	0988      	l32i.n	a8, a9, 0
42009529:	2a0c      	movi.n	a10, 2
4200952b:	2088a0        	or	a8, a8, a10
4200952e:	0020c0        	memw
42009531:	0989      	s32i.n	a8, a9, 0

    portENTER_CRITICAL(&gpio_context.gpio_spinlock);
    gpio_hal_sleep_sel_en(gpio_context.gpio_hal, gpio_num);
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42009533:	dd48a1        	l32r	a10, 42000a54 <_stext+0xa34> (3fc9270c <gpio_context+0x4>)
42009536:	dbb781        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42009539:	0008e0        	callx8	a8

    return ESP_OK;
4200953c:	020c      	movi.n	a2, 0
}
4200953e:	f01d      	retw.n

42009540 <gpio_sleep_sel_dis>:

esp_err_t gpio_sleep_sel_dis(gpio_num_t gpio_num)
{
42009540:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42009543:	02d296        	bltz	a2, 42009574 <gpio_sleep_sel_dis+0x34>
42009546:	0a2c      	movi.n	a10, 32
42009548:	10a2a0        	and	a10, a2, a10
4200954b:	f87c      	movi.n	a8, -1
4200954d:	308280        	xor	a8, a2, a8
42009550:	dc1491        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42009553:	401800        	ssl	a8
42009556:	a19900        	sll	a9, a9
42009559:	dc1281        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200955c:	400200        	ssr	a2
4200955f:	918080        	srl	a8, a8
42009562:	208980        	or	a8, a9, a8
42009565:	dc1091        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42009568:	400200        	ssr	a2
4200956b:	919090        	srl	a9, a9
4200956e:	9389a0        	movnez	a8, a9, a10
42009571:	2ce807        	bbsi	a8, 0, 420095a1 <gpio_sleep_sel_dis+0x61>
42009574:	dabb81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009577:	0008e0        	callx8	a8
4200957a:	dd2db1        	l32r	a11, 42000a30 <_stext+0xa10> (3c025d8c <_flash_rodata_start+0x5c6c>)
4200957d:	dd2e81        	l32r	a8, 42000a38 <_stext+0xa18> (3c025dac <_flash_rodata_start+0x5c8c>)
42009580:	1189      	s32i.n	a8, a1, 4
42009582:	bba382        	movi	a8, 0x3bb
42009585:	0189      	s32i.n	a8, a1, 0
42009587:	dd3cf1        	l32r	a15, 42000a78 <_stext+0xa58> (3c028770 <__FUNCTION__$3>)
4200958a:	0bed      	mov.n	a14, a11
4200958c:	0add      	mov.n	a13, a10
4200958e:	dd29c1        	l32r	a12, 42000a34 <_stext+0xa14> (3c025d94 <_flash_rodata_start+0x5c74>)
42009591:	1a0c      	movi.n	a10, 1
42009593:	dac081        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009596:	0008e0        	callx8	a8
42009599:	02a122        	movi	a2, 0x102
4200959c:	000b86        	j	420095ce <gpio_sleep_sel_dis+0x8e>
4200959f:	7c0000        	lsi	f0, a0, 0x1f0
420095a2:	a1fb      	addi.n	a10, a1, 15
420095a4:	dd2c      	movi.n	a13, 45
420095a6:	db9a81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420095a9:	0008e0        	callx8	a8
    PIN_SLP_SEL_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
420095ac:	dd2481        	l32r	a8, 42000a3c <_stext+0xa1c> (3c028cd4 <GPIO_PIN_MUX_REG>)
420095af:	a02280        	addx4	a2, a2, a8
420095b2:	0298      	l32i.n	a9, a2, 0
420095b4:	0020c0        	memw
420095b7:	0988      	l32i.n	a8, a9, 0
420095b9:	da7c      	movi.n	a10, -3
420095bb:	1088a0        	and	a8, a8, a10
420095be:	0020c0        	memw
420095c1:	0989      	s32i.n	a8, a9, 0

    portENTER_CRITICAL(&gpio_context.gpio_spinlock);
    gpio_hal_sleep_sel_dis(gpio_context.gpio_hal, gpio_num);
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
420095c3:	dd24a1        	l32r	a10, 42000a54 <_stext+0xa34> (3fc9270c <gpio_context+0x4>)
420095c6:	db9381        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420095c9:	0008e0        	callx8	a8

    return ESP_OK;
420095cc:	020c      	movi.n	a2, 0
}
420095ce:	f01d      	retw.n

420095d0 <bootloader_init_mem>:
#if SOC_APM_SUPPORTED
#include "hal/apm_hal.h"
#endif

void bootloader_init_mem(void)
{
420095d0:	004136        	entry	a1, 32
#endif
#endif

#ifdef CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE
    // protect memory region
    esp_cpu_configure_region_protection();
420095d3:	00f565        	call8	4200a528 <esp_cpu_configure_region_protection>
#endif
}
420095d6:	f01d      	retw.n

420095d8 <bootloader_flash_update_id>:
#define FLASH_CS_SETUP_TIME 3
#define FLASH_CS_HOLD_TIME  3
#define FLASH_CS_HOLD_DELAY 2

void bootloader_flash_update_id()
{
420095d8:	004136        	entry	a1, 32
    esp_rom_spiflash_chip_t *chip = &rom_spiflash_legacy_data->chip;
420095db:	dd2881        	l32r	a8, 42000a7c <_stext+0xa5c> (3fceffe4 <rom_spiflash_legacy_data>)
420095de:	0878      	l32i.n	a7, a8, 0
    chip->device_id = bootloader_read_flash_id();
420095e0:	dd2881        	l32r	a8, 42000a80 <_stext+0xa60> (403775b0 <bootloader_read_flash_id>)
420095e3:	0008e0        	callx8	a8
420095e6:	07a9      	s32i.n	a10, a7, 0
}
420095e8:	f01d      	retw.n
	...

420095ec <s_get_bus_mask>:
{
420095ec:	004136        	entry	a1, 32
    uint32_t vaddr_end = vaddr_start + len - 1;
420095ef:	323a      	add.n	a3, a2, a3
420095f1:	330b      	addi.n	a3, a3, -1
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
420095f3:	dd2491        	l32r	a9, 42000a84 <_stext+0xa64> (41ffffff <_coredump_iram_end+0x1c7dfff>)
420095f6:	629920        	lsi	f2, a9, 0x188
420095f9:	dd2381        	l32r	a8, 42000a88 <_stext+0xa68> (43ffffff <_etext+0x1fe8dc1>)
420095fc:	628830        	lsi	f3, a8, 0x188
420095ff:	880b      	addi.n	a8, a8, -1
42009601:	608080        	neg	a8, a8
42009604:	258897        	bany	a8, a9, 4200962d <s_get_bus_mask+0x41>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
42009607:	dd2191        	l32r	a9, 42000a8c <_stext+0xa6c> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4200960a:	629920        	lsi	f2, a9, 0x188
4200960d:	dd2081        	l32r	a8, 42000a90 <_stext+0xa70> (3dffffff <_esp_system_init_fn_array_end+0x1fd5ac3>)
42009610:	628830        	lsi	f3, a8, 0x188
42009613:	880b      	addi.n	a8, a8, -1
42009615:	608080        	neg	a8, a8
42009618:	168897        	bany	a8, a9, 42009632 <s_get_bus_mask+0x46>
        HAL_ASSERT(0);      //Out of region
4200961b:	dd1ed1        	l32r	a13, 42000a94 <_stext+0xa74> (3c024598 <_flash_rodata_start+0x4478>)
4200961e:	dd1ec1        	l32r	a12, 42000a98 <_stext+0xa78> (3c02891c <__func__$9>)
42009621:	3aa2b2        	movi	a11, 0x23a
42009624:	dd1ea1        	l32r	a10, 42000a9c <_stext+0xa7c> (3c020480 <_flash_rodata_start+0x360>)
42009627:	daa681        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4200962a:	0008e0        	callx8	a8
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_IBUS0);    //Both cores have their own IBUS0
4200962d:	120c      	movi.n	a2, 1
4200962f:	000046        	j	42009634 <s_get_bus_mask+0x48>
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_DBUS0);    //Both cores have their own DBUS0
42009632:	820c      	movi.n	a2, 8
}
42009634:	f01d      	retw.n
	...

42009638 <s_reserve_irom_region>:
{
42009638:	004136        	entry	a1, 32
    size_t irom_len_to_reserve = (uint32_t)&_instruction_reserved_end - (uint32_t)&_instruction_reserved_start;
4200963b:	dd1981        	l32r	a8, 42000aa0 <_stext+0xa80> (4201723e <_etext>)
4200963e:	dd19a1        	l32r	a10, 42000aa4 <_stext+0xa84> (42000020 <_stext>)
42009641:	c0b8a0        	sub	a11, a8, a10
    return vaddr & SOC_MMU_LINEAR_ADDR_MASK;
42009644:	db2691        	l32r	a9, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
42009647:	108890        	and	a8, a8, a9
4200964a:	109a90        	and	a9, a10, a9
    assert((mmu_ll_vaddr_to_laddr((uint32_t)&_instruction_reserved_end) - mmu_ll_vaddr_to_laddr((uint32_t)&_instruction_reserved_start)) == irom_len_to_reserve);
4200964d:	c08890        	sub	a8, a8, a9
42009650:	1118b7        	beq	a8, a11, 42009665 <s_reserve_irom_region+0x2d>
42009653:	dd15d1        	l32r	a13, 42000aa8 <_stext+0xa88> (3c025eb0 <_flash_rodata_start+0x5d90>)
42009656:	dd15c1        	l32r	a12, 42000aac <_stext+0xa8c> (3c028930 <__func__$10>)
42009659:	8ca0b2        	movi	a11, 140
4200965c:	dd15a1        	l32r	a10, 42000ab0 <_stext+0xa90> (3c025f60 <_flash_rodata_start+0x5e40>)
4200965f:	da9881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42009662:	0008e0        	callx8	a8
    irom_len_to_reserve += (uint32_t)&_instruction_reserved_start - ALIGN_DOWN_BY((uint32_t)&_instruction_reserved_start, CONFIG_MMU_PAGE_SIZE);
42009665:	f470a0        	extui	a7, a10, 0, 16
42009668:	8077b0        	add	a7, a7, a11
    irom_len_to_reserve = ALIGN_UP_BY(irom_len_to_reserve, CONFIG_MMU_PAGE_SIZE);
4200966b:	dd1281        	l32r	a8, 42000ab4 <_stext+0xa94> (ffff <UserFrameTotalSize+0xfeff>)
4200966e:	807780        	add	a7, a7, a8
42009671:	f57070        	extui	a7, a7, 16, 16
42009674:	117700        	slli	a7, a7, 16
    cache_bus_mask_t bus_mask = s_get_bus_mask((uint32_t)&_instruction_reserved_start, irom_len_to_reserve);
42009677:	20b770        	or	a11, a7, a7
4200967a:	fff725        	call8	420095ec <s_get_bus_mask>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200967d:	080c      	movi.n	a8, 0
4200967f:	000bc6        	j	420096b2 <s_reserve_irom_region+0x7a>
42009682:	800000        	add	a0, a0, a0
        if (bus_mask & hw_mem_regions[i].bus_id) {
42009685:	a098      	l32i.n	a9, a0, 40
42009687:	b09920        	addx8	a9, a9, a2
4200968a:	09b8      	l32i.n	a11, a9, 0
4200968c:	200ba7        	bnone	a11, a10, 420096b0 <s_reserve_irom_region+0x78>
            if (hw_mem_regions[i].region_size <= irom_len_to_reserve) {
4200968f:	39b8      	l32i.n	a11, a9, 12
42009691:	0d37b7        	bltu	a7, a11, 420096a2 <s_reserve_irom_region+0x6a>
                hw_mem_regions[i].free_head = hw_mem_regions[i].end;
42009694:	29c8      	l32i.n	a12, a9, 8
42009696:	49c9      	s32i.n	a12, a9, 16
                hw_mem_regions[i].max_slot_size = 0;
42009698:	0c0c      	movi.n	a12, 0
4200969a:	59c9      	s32i.n	a12, a9, 20
                irom_len_to_reserve -= hw_mem_regions[i].region_size;
4200969c:	c077b0        	sub	a7, a7, a11
4200969f:	000346        	j	420096b0 <s_reserve_irom_region+0x78>
                hw_mem_regions[i].free_head = hw_mem_regions[i].free_head + irom_len_to_reserve;
420096a2:	49b8      	l32i.n	a11, a9, 16
420096a4:	bb7a      	add.n	a11, a11, a7
420096a6:	49b9      	s32i.n	a11, a9, 16
                hw_mem_regions[i].max_slot_size -= irom_len_to_reserve;
420096a8:	59b8      	l32i.n	a11, a9, 20
420096aa:	c0bb70        	sub	a11, a11, a7
420096ad:	0569b2        	s32i	a11, a9, 20
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420096b0:	881b      	addi.n	a8, a8, 1
420096b2:	fce816        	beqz	a8, 42009684 <s_reserve_irom_region+0x4c>
}
420096b5:	f01d      	retw.n
	...

420096b8 <s_reserve_drom_region>:
{
420096b8:	004136        	entry	a1, 32
    size_t drom_len_to_reserve = (uint32_t)&_rodata_reserved_end - (uint32_t)&_rodata_reserved_start;
420096bb:	dcff81        	l32r	a8, 42000ab8 <_stext+0xa98> (3c02a53c <_esp_system_init_fn_array_end>)
420096be:	dcffa1        	l32r	a10, 42000abc <_stext+0xa9c> (3c020020 <esp_app_desc>)
420096c1:	c0b8a0        	sub	a11, a8, a10
420096c4:	db0691        	l32r	a9, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
420096c7:	108890        	and	a8, a8, a9
420096ca:	109a90        	and	a9, a10, a9
    assert((mmu_ll_vaddr_to_laddr((uint32_t)&_rodata_reserved_end) - mmu_ll_vaddr_to_laddr((uint32_t)&_rodata_reserved_start)) == drom_len_to_reserve);
420096cd:	c08890        	sub	a8, a8, a9
420096d0:	1118b7        	beq	a8, a11, 420096e5 <s_reserve_drom_region+0x2d>
420096d3:	dcfbd1        	l32r	a13, 42000ac0 <_stext+0xaa0> (3c025f70 <_flash_rodata_start+0x5e50>)
420096d6:	dcfbc1        	l32r	a12, 42000ac4 <_stext+0xaa4> (3c028904 <__func__$8>)
420096d9:	a8a0b2        	movi	a11, 168
420096dc:	dcf5a1        	l32r	a10, 42000ab0 <_stext+0xa90> (3c025f60 <_flash_rodata_start+0x5e40>)
420096df:	da7881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420096e2:	0008e0        	callx8	a8
    drom_len_to_reserve += (uint32_t)&_rodata_reserved_start - ALIGN_DOWN_BY((uint32_t)&_rodata_reserved_start, CONFIG_MMU_PAGE_SIZE);
420096e5:	f470a0        	extui	a7, a10, 0, 16
420096e8:	8077b0        	add	a7, a7, a11
    drom_len_to_reserve = ALIGN_UP_BY(drom_len_to_reserve, CONFIG_MMU_PAGE_SIZE);
420096eb:	dcf281        	l32r	a8, 42000ab4 <_stext+0xa94> (ffff <UserFrameTotalSize+0xfeff>)
420096ee:	807780        	add	a7, a7, a8
420096f1:	f57070        	extui	a7, a7, 16, 16
420096f4:	117700        	slli	a7, a7, 16
    cache_bus_mask_t bus_mask = s_get_bus_mask((uint32_t)&_rodata_reserved_start, drom_len_to_reserve);
420096f7:	20b770        	or	a11, a7, a7
420096fa:	ffef25        	call8	420095ec <s_get_bus_mask>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420096fd:	080c      	movi.n	a8, 0
420096ff:	000bc6        	j	42009732 <s_reserve_drom_region+0x7a>
42009702:	800000        	add	a0, a0, a0
        if (bus_mask & hw_mem_regions[i].bus_id) {
42009705:	a098      	l32i.n	a9, a0, 40
42009707:	b09920        	addx8	a9, a9, a2
4200970a:	09b8      	l32i.n	a11, a9, 0
4200970c:	200ba7        	bnone	a11, a10, 42009730 <s_reserve_drom_region+0x78>
            if (hw_mem_regions[i].region_size <= drom_len_to_reserve) {
4200970f:	39b8      	l32i.n	a11, a9, 12
42009711:	0d37b7        	bltu	a7, a11, 42009722 <s_reserve_drom_region+0x6a>
                hw_mem_regions[i].free_head = hw_mem_regions[i].end;
42009714:	29c8      	l32i.n	a12, a9, 8
42009716:	49c9      	s32i.n	a12, a9, 16
                hw_mem_regions[i].max_slot_size = 0;
42009718:	0c0c      	movi.n	a12, 0
4200971a:	59c9      	s32i.n	a12, a9, 20
                drom_len_to_reserve -= hw_mem_regions[i].region_size;
4200971c:	c077b0        	sub	a7, a7, a11
4200971f:	000346        	j	42009730 <s_reserve_drom_region+0x78>
                hw_mem_regions[i].free_head = hw_mem_regions[i].free_head + drom_len_to_reserve;
42009722:	49b8      	l32i.n	a11, a9, 16
42009724:	bb7a      	add.n	a11, a11, a7
42009726:	49b9      	s32i.n	a11, a9, 16
                hw_mem_regions[i].max_slot_size -= drom_len_to_reserve;
42009728:	59b8      	l32i.n	a11, a9, 20
4200972a:	c0bb70        	sub	a11, a11, a7
4200972d:	0569b2        	s32i	a11, a9, 20
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009730:	881b      	addi.n	a8, a8, 1
42009732:	fce816        	beqz	a8, 42009704 <s_reserve_drom_region+0x4c>
}
42009735:	f01d      	retw.n
	...

42009738 <esp_mmu_map_init>:
{
42009738:	00a136        	entry	a1, 80
    mem_region_t hw_mem_regions[SOC_MMU_LINEAR_ADDRESS_REGION_NUM] = {};
4200973b:	8c2c      	movi.n	a12, 40
4200973d:	0b0c      	movi.n	a11, 0
4200973f:	20a110        	or	a10, a1, a1
42009742:	daef81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42009745:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009748:	0a0c      	movi.n	a10, 0
4200974a:	001286        	j	42009798 <esp_mmu_map_init+0x60>
        hw_mem_regions[i].start = g_mmu_mem_regions[i].start;
4200974d:	909aa0        	addx2	a9, a10, a10
42009750:	1189d0        	slli	a8, a9, 3
42009753:	dcdd91        	l32r	a9, 42000ac8 <_stext+0xaa8> (3c02895c <g_mmu_mem_regions>)
42009756:	998a      	add.n	a9, a9, a8
42009758:	09c8      	l32i.n	a12, a9, 0
4200975a:	a0baa0        	addx4	a11, a10, a10
4200975d:	118bd0        	slli	a8, a11, 3
42009760:	818a      	add.n	a8, a1, a8
42009762:	18c9      	s32i.n	a12, a8, 4
        hw_mem_regions[i].end = g_mmu_mem_regions[i].end;
42009764:	19b8      	l32i.n	a11, a9, 4
42009766:	28b9      	s32i.n	a11, a8, 8
        hw_mem_regions[i].region_size = g_mmu_mem_regions[i].size;
42009768:	29b8      	l32i.n	a11, a9, 8
4200976a:	38b9      	s32i.n	a11, a8, 12
        hw_mem_regions[i].max_slot_size = g_mmu_mem_regions[i].size;
4200976c:	58b9      	s32i.n	a11, a8, 20
        hw_mem_regions[i].free_head = g_mmu_mem_regions[i].start;
4200976e:	48c9      	s32i.n	a12, a8, 16
        hw_mem_regions[i].bus_id = g_mmu_mem_regions[i].bus_id;
42009770:	39c8      	l32i.n	a12, a9, 12
42009772:	08c9      	s32i.n	a12, a8, 0
        hw_mem_regions[i].caps = g_mmu_mem_regions[i].caps;
42009774:	59c8      	l32i.n	a12, a9, 20
42009776:	68c9      	s32i.n	a12, a8, 24
        hw_mem_regions[i].targets = g_mmu_mem_regions[i].targets;
42009778:	4998      	l32i.n	a9, a9, 16
4200977a:	076892        	s32i	a9, a8, 28
        assert(hw_mem_regions[i].region_size % CONFIG_MMU_PAGE_SIZE == 0);
4200977d:	f4b0b0        	extui	a11, a11, 0, 16
42009780:	011b16        	beqz	a11, 42009795 <esp_mmu_map_init+0x5d>
42009783:	dcd2d1        	l32r	a13, 42000acc <_stext+0xaac> (3c026004 <_flash_rodata_start+0x5ee4>)
42009786:	dcd2c1        	l32r	a12, 42000ad0 <_stext+0xab0> (3c028948 <__func__$11>)
42009789:	d4a0b2        	movi	a11, 212
4200978c:	dcc9a1        	l32r	a10, 42000ab0 <_stext+0xa90> (3c025f60 <_flash_rodata_start+0x5e40>)
4200978f:	da4c81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42009792:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009795:	01caa2        	addi	a10, a10, 1
42009798:	fb1a16        	beqz	a10, 4200974d <esp_mmu_map_init+0x15>
    s_reserve_irom_region(hw_mem_regions, SOC_MMU_LINEAR_ADDRESS_REGION_NUM);
4200979b:	01a0b2        	movi	a11, 1
4200979e:	01ad      	mov.n	a10, a1
420097a0:	ffe965        	call8	42009638 <s_reserve_irom_region>
    s_reserve_drom_region(hw_mem_regions, SOC_MMU_LINEAR_ADDRESS_REGION_NUM);
420097a3:	1b0c      	movi.n	a11, 1
420097a5:	01ad      	mov.n	a10, a1
420097a7:	fff125        	call8	420096b8 <s_reserve_drom_region>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420097aa:	080c      	movi.n	a8, 0
    uint32_t region_num = 0;
420097ac:	085d      	mov.n	a5, a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420097ae:	000406        	j	420097c2 <esp_mmu_map_init+0x8a>
        if (hw_mem_regions[i].caps != MEM_REGION_MERGED) {
420097b1:	a0a880        	addx4	a10, a8, a8
420097b4:	119ad0        	slli	a9, a10, 3
420097b7:	919a      	add.n	a9, a1, a9
420097b9:	6998      	l32i.n	a9, a9, 24
420097bb:	010926        	beqi	a9, -1, 420097c0 <esp_mmu_map_init+0x88>
            region_num++;
420097be:	551b      	addi.n	a5, a5, 1
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420097c0:	881b      	addi.n	a8, a8, 1
420097c2:	feb816        	beqz	a8, 420097b1 <esp_mmu_map_init+0x79>
    s_mmu_ctx.num_regions = region_num;
420097c5:	dcc381        	l32r	a8, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
420097c8:	0859      	s32i.n	a5, a8, 0
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420097ca:	070c      	movi.n	a7, 0
    uint32_t available_region_idx = 0;
420097cc:	076d      	mov.n	a6, a7
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420097ce:	000a86        	j	420097fc <esp_mmu_map_init+0xc4>
        if (hw_mem_regions[i].caps == MEM_REGION_MERGED) {
420097d1:	a09770        	addx4	a9, a7, a7
420097d4:	1189d0        	slli	a8, a9, 3
420097d7:	818a      	add.n	a8, a1, a8
420097d9:	6888      	l32i.n	a8, a8, 24
420097db:	1b0826        	beqi	a8, -1, 420097fa <esp_mmu_map_init+0xc2>
        memcpy(&s_mmu_ctx.mem_regions[available_region_idx], &hw_mem_regions[i], sizeof(mem_region_t));
420097de:	a08660        	addx4	a8, a6, a6
420097e1:	11a8d0        	slli	a10, a8, 3
420097e4:	dcbc81        	l32r	a8, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
420097e7:	aa8a      	add.n	a10, a10, a8
420097e9:	11b9d0        	slli	a11, a9, 3
420097ec:	8c2c      	movi.n	a12, 40
420097ee:	b1ba      	add.n	a11, a1, a11
420097f0:	aa4b      	addi.n	a10, a10, 4
420097f2:	da0d81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420097f5:	0008e0        	callx8	a8
        available_region_idx++;
420097f8:	661b      	addi.n	a6, a6, 1
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420097fa:	771b      	addi.n	a7, a7, 1
420097fc:	fd1716        	beqz	a7, 420097d1 <esp_mmu_map_init+0x99>
    for (int i = 0; i < available_region_idx; i++) {
420097ff:	080c      	movi.n	a8, 0
42009801:	0007c6        	j	42009824 <esp_mmu_map_init+0xec>
        TAILQ_INIT(&s_mmu_ctx.mem_regions[i].mem_block_head);
42009804:	dcb4b1        	l32r	a11, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
42009807:	a09880        	addx4	a9, a8, a8
4200980a:	11a9d0        	slli	a10, a9, 3
4200980d:	abaa      	add.n	a10, a11, a10
4200980f:	090c      	movi.n	a9, 0
42009811:	9a99      	s32i.n	a9, a10, 36
42009813:	a0c880        	addx4	a12, a8, a8
42009816:	119cd0        	slli	a9, a12, 3
42009819:	20c992        	addi	a9, a9, 32
4200981c:	99ba      	add.n	a9, a9, a11
4200981e:	994b      	addi.n	a9, a9, 4
42009820:	aa99      	s32i.n	a9, a10, 40
    for (int i = 0; i < available_region_idx; i++) {
42009822:	881b      	addi.n	a8, a8, 1
42009824:	dc3867        	bltu	a8, a6, 42009804 <esp_mmu_map_init+0xcc>
    assert(available_region_idx == region_num);
42009827:	111567        	beq	a5, a6, 4200983c <esp_mmu_map_init+0x104>
4200982a:	dcabd1        	l32r	a13, 42000ad8 <_stext+0xab8> (3c026040 <_flash_rodata_start+0x5f20>)
4200982d:	dca8c1        	l32r	a12, 42000ad0 <_stext+0xab0> (3c028948 <__func__$11>)
42009830:	06a1b2        	movi	a11, 0x106
42009833:	dc9fa1        	l32r	a10, 42000ab0 <_stext+0xa90> (3c025f60 <_flash_rodata_start+0x5e40>)
42009836:	da2281        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42009839:	0008e0        	callx8	a8
}
4200983c:	f01d      	retw.n
	...

42009840 <esp_mmu_map>:
{
42009840:	00c136        	entry	a1, 96
42009843:	7179      	s32i.n	a7, a1, 28
42009845:	4129      	s32i.n	a2, a1, 16
42009847:	056152        	s32i	a5, a1, 20
    ESP_RETURN_ON_FALSE(out_ptr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
4200984a:	c7ec      	bnez.n	a7, 4200987a <esp_mmu_map+0x3a>
4200984c:	dca471        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
4200984f:	002762        	l32i	a6, a7, 0
42009852:	da0381        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009855:	0008e0        	callx8	a8
42009858:	bea182        	movi	a8, 0x1be
4200985b:	0189      	s32i.n	a8, a1, 0
4200985d:	dca0f1        	l32r	a15, 42000ae0 <_stext+0xac0> (3c0288f8 <__FUNCTION__$5>)
42009860:	07e8      	l32i.n	a14, a7, 0
42009862:	0add      	mov.n	a13, a10
42009864:	dca0c1        	l32r	a12, 42000ae4 <_stext+0xac4> (3c026064 <_flash_rodata_start+0x5f44>)
42009867:	06bd      	mov.n	a11, a6
42009869:	1a0c      	movi.n	a10, 1
4200986b:	da0a81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200986e:	0008e0        	callx8	a8
42009871:	02a182        	movi	a8, 0x102
42009874:	6189      	s32i.n	a8, a1, 24
42009876:	00e4c6        	j	42009c0d <esp_mmu_map+0x3cd>
42009879:	418800        	srli	a8, a0, 8
    ESP_RETURN_ON_FALSE((paddr_start % CONFIG_MMU_PAGE_SIZE == 0), ESP_ERR_INVALID_ARG, TAG, "paddr must be rounded up to the nearest multiple of CONFIG_MMU_PAGE_SIZE");
4200987c:	f45080        	extui	a5, a8, 0, 16
4200987f:	a5ac      	beqz.n	a5, 420098ad <esp_mmu_map+0x6d>
42009881:	dc9671        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009884:	0768      	l32i.n	a6, a7, 0
42009886:	d9f681        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009889:	0008e0        	callx8	a8
4200988c:	c2a182        	movi	a8, 0x1c2
4200988f:	0189      	s32i.n	a8, a1, 0
42009891:	dc93f1        	l32r	a15, 42000ae0 <_stext+0xac0> (3c0288f8 <__FUNCTION__$5>)
42009894:	07e8      	l32i.n	a14, a7, 0
42009896:	0add      	mov.n	a13, a10
42009898:	dc94c1        	l32r	a12, 42000ae8 <_stext+0xac8> (3c0260d0 <_flash_rodata_start+0x5fb0>)
4200989b:	06bd      	mov.n	a11, a6
4200989d:	1a0c      	movi.n	a10, 1
4200989f:	d9fd81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420098a2:	0008e0        	callx8	a8
420098a5:	02a182        	movi	a8, 0x102
420098a8:	6189      	s32i.n	a8, a1, 24
420098aa:	00d7c6        	j	42009c0d <esp_mmu_map+0x3cd>
    ESP_RETURN_ON_ERROR(s_mem_caps_check(caps), TAG, "invalid caps");
420098ad:	0521a2        	l32i	a10, a1, 20
420098b0:	0c12a5        	call8	420159dc <s_mem_caps_check>
420098b3:	0661a2        	s32i	a10, a1, 24
420098b6:	026a16        	beqz	a10, 420098e0 <esp_mmu_map+0xa0>
420098b9:	dc8871        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
420098bc:	0768      	l32i.n	a6, a7, 0
420098be:	d9e881        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420098c1:	0008e0        	callx8	a8
420098c4:	c3a182        	movi	a8, 0x1c3
420098c7:	0189      	s32i.n	a8, a1, 0
420098c9:	dc85f1        	l32r	a15, 42000ae0 <_stext+0xac0> (3c0288f8 <__FUNCTION__$5>)
420098cc:	07e8      	l32i.n	a14, a7, 0
420098ce:	0add      	mov.n	a13, a10
420098d0:	dc87c1        	l32r	a12, 42000aec <_stext+0xacc> (3c026088 <_flash_rodata_start+0x5f68>)
420098d3:	06bd      	mov.n	a11, a6
420098d5:	1a0c      	movi.n	a10, 1
420098d7:	d9ef81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420098da:	0008e0        	callx8	a8
420098dd:	00cb06        	j	42009c0d <esp_mmu_map+0x3cd>
    size_t aligned_size = ALIGN_UP_BY(size, CONFIG_MMU_PAGE_SIZE);
420098e0:	dc7581        	l32r	a8, 42000ab4 <_stext+0xa94> (ffff <UserFrameTotalSize+0xfeff>)
420098e3:	338a      	add.n	a3, a3, a8
420098e5:	f53030        	extui	a3, a3, 16, 16
420098e8:	113300        	slli	a3, a3, 16
    int32_t found_region_id = s_find_available_region(s_mmu_ctx.mem_regions, s_mmu_ctx.num_regions, aligned_size, caps, target);
420098eb:	04ed      	mov.n	a14, a4
420098ed:	51d8      	l32i.n	a13, a1, 20
420098ef:	20c330        	or	a12, a3, a3
420098f2:	dc7881        	l32r	a8, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
420098f5:	0028b2        	l32i	a11, a8, 0
420098f8:	dc7ea1        	l32r	a10, 42000af0 <_stext+0xad0> (3fc950cc <s_mmu_ctx+0x4>)
420098fb:	0c0fe5        	call8	420159f8 <s_find_available_region>
420098fe:	0a2d      	mov.n	a2, a10
    if (found_region_id == -1) {
42009900:	250a66        	bnei	a10, -1, 42009929 <esp_mmu_map+0xe9>
42009903:	d9ca81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42009906:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "no such vaddr range");
42009908:	489c      	beqz.n	a8, 42009920 <esp_mmu_map+0xe0>
4200990a:	d9d581        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200990d:	0008e0        	callx8	a8
42009910:	dc7381        	l32r	a8, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009913:	08c8      	l32i.n	a12, a8, 0
42009915:	0abd      	mov.n	a11, a10
42009917:	dc77a1        	l32r	a10, 42000af4 <_stext+0xad4> (3c0260ac <_flash_rodata_start+0x5f8c>)
4200991a:	d9d281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200991d:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
42009920:	05a182        	movi	a8, 0x105
42009923:	6189      	s32i.n	a8, a1, 24
42009925:	00b906        	j	42009c0d <esp_mmu_map+0x3cd>
42009928:	8aa000        	round.s	a10, f0, 0
    if (TAILQ_EMPTY(&found_region->mem_block_head)) {
4200992b:	6a91a0        	maddn.s	f9, f1, f10
4200992e:	90dc      	bnez.n	a0, 4200994b <esp_mmu_map+0x10b>
42009930:	b088      	l32i.n	a8, a0, 44
42009932:	9888      	l32i.n	a8, a8, 36
42009934:	0f1856        	bnez	a8, 42009a29 <esp_mmu_map+0x1e9>
        dummy_head = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42009937:	dae0c1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
4200993a:	cb2c      	movi.n	a11, 44
4200993c:	01a0a2        	movi	a10, 1
4200993f:	dc7581        	l32r	a8, 42000b14 <_stext+0xaf4> (4037606c <heap_caps_calloc>)
42009942:	0008e0        	callx8	a8
42009945:	b1a9      	s32i.n	a10, a1, 44
        ESP_GOTO_ON_FALSE(dummy_head, ESP_ERR_NO_MEM, err, TAG, "no mem");
42009947:	5aec      	bnez.n	a10, 42009970 <esp_mmu_map+0x130>
42009949:	dc6471        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
4200994c:	0768      	l32i.n	a6, a7, 0
4200994e:	d9c481        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009951:	0008e0        	callx8	a8
42009954:	d4a182        	movi	a8, 0x1d4
42009957:	0189      	s32i.n	a8, a1, 0
42009959:	dc61f1        	l32r	a15, 42000ae0 <_stext+0xac0> (3c0288f8 <__FUNCTION__$5>)
4200995c:	07e8      	l32i.n	a14, a7, 0
4200995e:	0add      	mov.n	a13, a10
42009960:	dc66c1        	l32r	a12, 42000af8 <_stext+0xad8> (3c026130 <_flash_rodata_start+0x6010>)
42009963:	06bd      	mov.n	a11, a6
42009965:	1a0c      	movi.n	a10, 1
42009967:	d9cb81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200996a:	0008e0        	callx8	a8
    if (dummy_tail) {
4200996d:	00a146        	j	42009bf6 <esp_mmu_map+0x3b6>
        dummy_head->laddr_start = found_region->free_head;
42009970:	a08220        	addx4	a8, a2, a2
42009973:	dc5891        	l32r	a9, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
42009976:	b08890        	addx8	a8, a8, a9
42009979:	5898      	l32i.n	a9, a8, 20
4200997b:	b1a8      	l32i.n	a10, a1, 44
4200997d:	0a99      	s32i.n	a9, a10, 0
        dummy_head->laddr_end = found_region->free_head;
4200997f:	1a99      	s32i.n	a9, a10, 4
        dummy_head->size = 0;
42009981:	090c      	movi.n	a9, 0
42009983:	4a99      	s32i.n	a9, a10, 16
        dummy_head->caps = caps;
42009985:	0a9d      	mov.n	a9, a10
42009987:	51a8      	l32i.n	a10, a1, 20
42009989:	59a9      	s32i.n	a10, a9, 20
        TAILQ_INSERT_HEAD(&found_region->mem_block_head, dummy_head, entries);
4200998b:	9888      	l32i.n	a8, a8, 36
4200998d:	9989      	s32i.n	a8, a9, 36
4200998f:	688c      	beqz.n	a8, 42009999 <esp_mmu_map+0x159>
42009991:	24c992        	addi	a9, a9, 36
42009994:	a899      	s32i.n	a9, a8, 40
42009996:	0003c6        	j	420099a9 <esp_mmu_map+0x169>
42009999:	b188      	l32i.n	a8, a1, 44
4200999b:	24c892        	addi	a9, a8, 36
4200999e:	a08220        	addx4	a8, a2, a2
420099a1:	dc4ca1        	l32r	a10, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
420099a4:	b088a0        	addx8	a8, a8, a10
420099a7:	a899      	s32i.n	a9, a8, 40
420099a9:	dc4a91        	l32r	a9, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
420099ac:	a08220        	addx4	a8, a2, a2
420099af:	b08890        	addx8	a8, a8, a9
420099b2:	b1a8      	l32i.n	a10, a1, 44
420099b4:	98a9      	s32i.n	a10, a8, 36
420099b6:	a08220        	addx4	a8, a2, a2
420099b9:	1188d0        	slli	a8, a8, 3
420099bc:	20c882        	addi	a8, a8, 32
420099bf:	889a      	add.n	a8, a8, a9
420099c1:	884b      	addi.n	a8, a8, 4
420099c3:	aa89      	s32i.n	a8, a10, 40
        dummy_tail = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
420099c5:	dabcc1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
420099c8:	cb2c      	movi.n	a11, 44
420099ca:	1a0c      	movi.n	a10, 1
420099cc:	dc5281        	l32r	a8, 42000b14 <_stext+0xaf4> (4037606c <heap_caps_calloc>)
420099cf:	0008e0        	callx8	a8
420099d2:	c1a9      	s32i.n	a10, a1, 48
        ESP_GOTO_ON_FALSE(dummy_tail, ESP_ERR_NO_MEM, err, TAG, "no mem");
420099d4:	8aec      	bnez.n	a10, 42009a00 <esp_mmu_map+0x1c0>
420099d6:	dc4171        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
420099d9:	0768      	l32i.n	a6, a7, 0
420099db:	d9a181        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
420099de:	0008e0        	callx8	a8
420099e1:	dea182        	movi	a8, 0x1de
420099e4:	0189      	s32i.n	a8, a1, 0
420099e6:	dc3ef1        	l32r	a15, 42000ae0 <_stext+0xac0> (3c0288f8 <__FUNCTION__$5>)
420099e9:	07e8      	l32i.n	a14, a7, 0
420099eb:	0add      	mov.n	a13, a10
420099ed:	dc42c1        	l32r	a12, 42000af8 <_stext+0xad8> (3c026130 <_flash_rodata_start+0x6010>)
420099f0:	20b660        	or	a11, a6, a6
420099f3:	01a0a2        	movi	a10, 1
420099f6:	d9a781        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
420099f9:	0008e0        	callx8	a8
420099fc:	007a86        	j	42009bea <esp_mmu_map+0x3aa>
420099ff:	822000        	mull	a2, a0, a0
        dummy_tail->laddr_start = found_region->end;
42009a02:	3491a0        	extui	a9, a10, 1, 4
42009a05:	90dc      	bnez.n	a0, 42009a22 <esp_mmu_map+0x1e2>
42009a07:	b088      	l32i.n	a8, a0, 44
42009a09:	3898      	l32i.n	a9, a8, 12
42009a0b:	c1a8      	l32i.n	a10, a1, 48
42009a0d:	0a99      	s32i.n	a9, a10, 0
        dummy_tail->laddr_end = found_region->end;
42009a0f:	1a99      	s32i.n	a9, a10, 4
        dummy_tail->size = 0;
42009a11:	090c      	movi.n	a9, 0
42009a13:	4a99      	s32i.n	a9, a10, 16
        dummy_tail->caps = caps;
42009a15:	51b8      	l32i.n	a11, a1, 20
42009a17:	5ab9      	s32i.n	a11, a10, 20
        TAILQ_INSERT_TAIL(&found_region->mem_block_head, dummy_tail, entries);
42009a19:	9a99      	s32i.n	a9, a10, 36
42009a1b:	a898      	l32i.n	a9, a8, 40
42009a1d:	aa99      	s32i.n	a9, a10, 40
42009a1f:	09a9      	s32i.n	a10, a9, 0
42009a21:	24ca92        	addi	a9, a10, 36
42009a24:	a899      	s32i.n	a9, a8, 40
42009a26:	000146        	j	42009a2f <esp_mmu_map+0x1ef>
    mem_block_t *dummy_tail = NULL;
42009a29:	080c      	movi.n	a8, 0
42009a2b:	c189      	s32i.n	a8, a1, 48
    mem_block_t *dummy_head = NULL;
42009a2d:	b189      	s32i.n	a8, a1, 44
    bool allow_overlap = flags & ESP_MMU_MMAP_FLAG_PADDR_SHARED;
42009a2f:	04a060        	extui	a10, a6, 0, 1
42009a32:	a1a9      	s32i.n	a10, a1, 40
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
42009a34:	a08220        	addx4	a8, a2, a2
42009a37:	dc2791        	l32r	a9, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
42009a3a:	b08890        	addx8	a8, a8, a9
42009a3d:	9878      	l32i.n	a7, a8, 36
42009a3f:	8129      	s32i.n	a2, a1, 32
42009a41:	9159      	s32i.n	a5, a1, 36
42009a43:	0a5d      	mov.n	a5, a10
42009a45:	000ac6        	j	42009a74 <esp_mmu_map+0x234>
42009a48:	820000        	mull	a0, a0, a0
        if (target == mem_block->target) {
42009a4b:	470827        	bnone	a8, a2, 42009a96 <esp_mmu_map+0x256>
42009a4e:	2198      	l32i.n	a9, a1, 8
            if ((s_is_enclosed(mem_block->paddr_start, mem_block->paddr_end, paddr_start, aligned_size))) {
42009a50:	062762        	l32i	a6, a7, 24
42009a53:	7728      	l32i.n	a2, a7, 28
42009a55:	03dd      	mov.n	a13, a3
42009a57:	41c8      	l32i.n	a12, a1, 16
42009a59:	02bd      	mov.n	a11, a2
42009a5b:	20a660        	or	a10, a6, a6
42009a5e:	0bfc65        	call8	42015a24 <s_is_enclosed>
42009a61:	dadc      	bnez.n	a10, 42009a82 <esp_mmu_map+0x242>
            if (!allow_overlap && (s_is_overlapped(mem_block->paddr_start, mem_block->paddr_end, paddr_start, aligned_size))) {
42009a63:	b5cc      	bnez.n	a5, 42009a72 <esp_mmu_map+0x232>
42009a65:	03dd      	mov.n	a13, a3
42009a67:	41c8      	l32i.n	a12, a1, 16
42009a69:	02bd      	mov.n	a11, a2
42009a6b:	06ad      	mov.n	a10, a6
42009a6d:	0bfd65        	call8	42015a44 <s_is_overlapped>
42009a70:	8adc      	bnez.n	a10, 42009a8c <esp_mmu_map+0x24c>
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
42009a72:	9778      	l32i.n	a7, a7, 36
42009a74:	fd2756        	bnez	a7, 42009a4a <esp_mmu_map+0x20a>
    bool is_overlapped = false;
42009a77:	8128      	l32i.n	a2, a1, 32
42009a79:	9158      	l32i.n	a5, a1, 36
42009a7b:	080c      	movi.n	a8, 0
    bool is_enclosed = false;
42009a7d:	08ad      	mov.n	a10, a8
42009a7f:	000446        	j	42009a94 <esp_mmu_map+0x254>
    bool is_overlapped = false;
42009a82:	8128      	l32i.n	a2, a1, 32
42009a84:	9158      	l32i.n	a5, a1, 36
42009a86:	080c      	movi.n	a8, 0
42009a88:	000206        	j	42009a94 <esp_mmu_map+0x254>
42009a8b:	0a8d00        	add.s	f8, f13, f0
    bool is_enclosed = false;
42009a8e:	8128      	l32i.n	a2, a1, 32
42009a90:	9158      	l32i.n	a5, a1, 36
42009a92:	a1a8      	l32i.n	a10, a1, 40
    if (is_enclosed) {
42009a94:	9abc      	beqz.n	a10, 42009ad1 <esp_mmu_map+0x291>
        ESP_LOGW(TAG, "paddr block is mapped already, vaddr_start: %p, size: 0x%x", (void *)mem_block->vaddr_start, mem_block->size);
42009a96:	dc1161        	l32r	a6, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009a99:	0658      	l32i.n	a5, a6, 0
42009a9b:	d97181        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009a9e:	0008e0        	callx8	a8
42009aa1:	27f8      	l32i.n	a15, a7, 8
42009aa3:	4788      	l32i.n	a8, a7, 16
42009aa5:	0189      	s32i.n	a8, a1, 0
42009aa7:	06e8      	l32i.n	a14, a6, 0
42009aa9:	0add      	mov.n	a13, a10
42009aab:	dc14c1        	l32r	a12, 42000afc <_stext+0xadc> (3c02614c <_flash_rodata_start+0x602c>)
42009aae:	05bd      	mov.n	a11, a5
42009ab0:	2a0c      	movi.n	a10, 2
42009ab2:	d97881        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009ab5:	0008e0        	callx8	a8
        const uint32_t new_paddr_offset = paddr_start - mem_block->paddr_start;
42009ab8:	6798      	l32i.n	a9, a7, 24
42009aba:	4188      	l32i.n	a8, a1, 16
42009abc:	c09890        	sub	a9, a8, a9
        *out_ptr = (void *)mem_block->vaddr_start + new_paddr_offset;
42009abf:	2788      	l32i.n	a8, a7, 8
42009ac1:	889a      	add.n	a8, a8, a9
42009ac3:	7198      	l32i.n	a9, a1, 28
42009ac5:	0989      	s32i.n	a8, a9, 0
        return ESP_ERR_INVALID_STATE;
42009ac7:	03a182        	movi	a8, 0x103
42009aca:	6189      	s32i.n	a8, a1, 24
42009acc:	004f46        	j	42009c0d <esp_mmu_map+0x3cd>
42009acf:	0c0000        	lsi	f0, a0, 48
    if (!allow_overlap && is_overlapped) {
42009ad2:	a819      	s32i.n	a1, a8, 40
42009ad4:	9a90a1        	l32r	a10, 41ff0514 <_coredump_iram_end+0x1c6e514>
42009ad7:	909030        	addx2	a9, a0, a3
42009ada:	698074        	lsi	f7, a0, 0x1a4
42009add:	098710        	l32e	a1, a7, -32
42009ae0:	fe7123        	lsi	f2, a1, 0x3f8
        ESP_LOGE(TAG, "paddr block is overlapped with an already mapped paddr block");
42009ae3:	68db      	addi.n	a6, a8, 13
42009ae5:	5e8107        	bany	a1, a0, 42009b47 <esp_mmu_map+0x307>
42009ae8:	e0d9      	s32i.n	a13, a0, 56
42009aea:	0008      	l32i.n	a0, a0, 0
42009aec:	07e8      	l32i.n	a14, a7, 0
42009aee:	0add      	mov.n	a13, a10
42009af0:	dc04c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c026194 <_flash_rodata_start+0x6074>)
42009af3:	06bd      	mov.n	a11, a6
42009af5:	1a0c      	movi.n	a10, 1
42009af7:	d96781        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009afa:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
42009afd:	02a182        	movi	a8, 0x102
42009b00:	6189      	s32i.n	a8, a1, 24
42009b02:	0041c6        	j	42009c0d <esp_mmu_map+0x3cd>
    new_block = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42009b05:	da6cc1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42009b08:	cb2c      	movi.n	a11, 44
42009b0a:	1a0c      	movi.n	a10, 1
42009b0c:	dc0281        	l32r	a8, 42000b14 <_stext+0xaf4> (4037606c <heap_caps_calloc>)
42009b0f:	0008e0        	callx8	a8
42009b12:	0a7d      	mov.n	a7, a10
    ESP_GOTO_ON_FALSE(new_block, ESP_ERR_NO_MEM, err, TAG, "no mem");
42009b14:	7aec      	bnez.n	a10, 42009b3f <esp_mmu_map+0x2ff>
42009b16:	dbf171        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009b19:	0768      	l32i.n	a6, a7, 0
42009b1b:	d95181        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009b1e:	0008e0        	callx8	a8
42009b21:	14a282        	movi	a8, 0x214
42009b24:	0189      	s32i.n	a8, a1, 0
42009b26:	dbeef1        	l32r	a15, 42000ae0 <_stext+0xac0> (3c0288f8 <__FUNCTION__$5>)
42009b29:	07e8      	l32i.n	a14, a7, 0
42009b2b:	0add      	mov.n	a13, a10
42009b2d:	dbf2c1        	l32r	a12, 42000af8 <_stext+0xad8> (3c026130 <_flash_rodata_start+0x6010>)
42009b30:	20b660        	or	a11, a6, a6
42009b33:	01a0a2        	movi	a10, 1
42009b36:	d95781        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009b39:	0008e0        	callx8	a8
42009b3c:	002a86        	j	42009bea <esp_mmu_map+0x3aa>
    uint32_t last_end = TAILQ_FIRST(&found_region->mem_block_head)->laddr_end;
42009b3f:	a08220        	addx4	a8, a2, a2
42009b42:	dbe491        	l32r	a9, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
42009b45:	b08890        	addx8	a8, a8, a9
42009b48:	9888      	l32i.n	a8, a8, 36
42009b4a:	18a8      	l32i.n	a10, a8, 4
    mem_block_t *found_block = NULL;  //This stands for the block we found, whose slot between its prior block is where we will insert the new block to
42009b4c:	0b0c      	movi.n	a11, 0
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
42009b4e:	000646        	j	42009b6b <esp_mmu_map+0x32b>
        slot_len = mem_block->laddr_start - last_end;
42009b51:	0898      	l32i.n	a9, a8, 0
42009b53:	c099a0        	sub	a9, a9, a10
        if (!found) {
42009b56:	a6cc      	bnez.n	a6, 42009b64 <esp_mmu_map+0x324>
            if (slot_len >= aligned_size) {
42009b58:	083937        	bltu	a9, a3, 42009b64 <esp_mmu_map+0x324>
                slot_len -= aligned_size;
42009b5b:	c09930        	sub	a9, a9, a3
                new_block->laddr_start = last_end;
42009b5e:	07a9      	s32i.n	a10, a7, 0
                found_block = mem_block;
42009b60:	08bd      	mov.n	a11, a8
                found = true;
42009b62:	160c      	movi.n	a6, 1
        max_slot_len = (slot_len > max_slot_len) ? slot_len : max_slot_len;
42009b64:	735590        	maxu	a5, a5, a9
        last_end = mem_block->laddr_end;
42009b67:	18a8      	l32i.n	a10, a8, 4
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
42009b69:	9888      	l32i.n	a8, a8, 36
42009b6b:	fe2856        	bnez	a8, 42009b51 <esp_mmu_map+0x311>
    assert(found);
42009b6e:	06dc      	bnez.n	a6, 42009b82 <esp_mmu_map+0x342>
42009b70:	dbe5d1        	l32r	a13, 42000b04 <_stext+0xae4> (3c0261e0 <_flash_rodata_start+0x60c0>)
42009b73:	dbe5c1        	l32r	a12, 42000b08 <_stext+0xae8> (3c0288ec <__func__$4>)
42009b76:	2fa2b2        	movi	a11, 0x22f
42009b79:	dbcda1        	l32r	a10, 42000ab0 <_stext+0xa90> (3c025f60 <_flash_rodata_start+0x5e40>)
42009b7c:	d95181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42009b7f:	0008e0        	callx8	a8
    TAILQ_INSERT_BEFORE(found_block, new_block, entries);
42009b82:	ab88      	l32i.n	a8, a11, 40
42009b84:	a789      	s32i.n	a8, a7, 40
42009b86:	97b9      	s32i.n	a11, a7, 36
42009b88:	ab88      	l32i.n	a8, a11, 40
42009b8a:	0879      	s32i.n	a7, a8, 0
42009b8c:	24c782        	addi	a8, a7, 36
42009b8f:	ab89      	s32i.n	a8, a11, 40
    found_region->max_slot_size = max_slot_len;
42009b91:	a02220        	addx4	a2, a2, a2
42009b94:	dbd081        	l32r	a8, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
42009b97:	b02280        	addx8	a2, a2, a8
42009b9a:	6259      	s32i.n	a5, a2, 24
    new_block->laddr_end = new_block->laddr_start + aligned_size;
42009b9c:	0798      	l32i.n	a9, a7, 0
42009b9e:	839a      	add.n	a8, a3, a9
42009ba0:	1789      	s32i.n	a8, a7, 4
    new_block->size = aligned_size;
42009ba2:	4739      	s32i.n	a3, a7, 16
    new_block->caps = caps;
42009ba4:	51b8      	l32i.n	a11, a1, 20
42009ba6:	57b9      	s32i.n	a11, a7, 20
    new_block->paddr_start = paddr_start;
42009ba8:	41a8      	l32i.n	a10, a1, 16
42009baa:	67a9      	s32i.n	a10, a7, 24
    new_block->paddr_end = paddr_start + aligned_size;
42009bac:	a3aa      	add.n	a10, a3, a10
42009bae:	77a9      	s32i.n	a10, a7, 28
    new_block->target = target;
42009bb0:	8749      	s32i.n	a4, a7, 32
    if (caps & MMU_MEM_CAP_EXEC) {
42009bb2:	0f6b07        	bbci	a11, 0, 42009bc5 <esp_mmu_map+0x385>
    return vaddr_base | laddr;
42009bb5:	dbd5a1        	l32r	a10, 42000b0c <_stext+0xaec> (42000000 <_coredump_iram_end+0x1c7e000>)
42009bb8:	2099a0        	or	a9, a9, a10
        new_block->vaddr_start = mmu_ll_laddr_to_vaddr(new_block->laddr_start, MMU_VADDR_INSTRUCTION, target);
42009bbb:	2799      	s32i.n	a9, a7, 8
42009bbd:	2088a0        	or	a8, a8, a10
        new_block->vaddr_end = mmu_ll_laddr_to_vaddr(new_block->laddr_end, MMU_VADDR_INSTRUCTION, target);
42009bc0:	3789      	s32i.n	a8, a7, 12
42009bc2:	000306        	j	42009bd2 <esp_mmu_map+0x392>
42009bc5:	dbd2a1        	l32r	a10, 42000b10 <_stext+0xaf0> (3c000000 <UserFrameTotalSize+0x3bffff00>)
42009bc8:	2099a0        	or	a9, a9, a10
        new_block->vaddr_start = mmu_ll_laddr_to_vaddr(new_block->laddr_start, MMU_VADDR_DATA, target);
42009bcb:	2799      	s32i.n	a9, a7, 8
42009bcd:	2088a0        	or	a8, a8, a10
        new_block->vaddr_end = mmu_ll_laddr_to_vaddr(new_block->laddr_end, MMU_VADDR_DATA, target);
42009bd0:	3789      	s32i.n	a8, a7, 12
    s_do_mapping(target, new_block->vaddr_start, paddr_start, aligned_size);
42009bd2:	03dd      	mov.n	a13, a3
42009bd4:	41c8      	l32i.n	a12, a1, 16
42009bd6:	27b8      	l32i.n	a11, a7, 8
42009bd8:	04ad      	mov.n	a10, a4
42009bda:	dbcf81        	l32r	a8, 42000b18 <_stext+0xaf8> (4037769c <s_do_mapping>)
42009bdd:	0008e0        	callx8	a8
    *out_ptr = (void *)new_block->vaddr_start;
42009be0:	2788      	l32i.n	a8, a7, 8
42009be2:	7198      	l32i.n	a9, a1, 28
42009be4:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
42009be6:	0008c6        	j	42009c0d <esp_mmu_map+0x3cd>
42009be9:	c18800        	mul16u	a8, a8, a0
    if (dummy_tail) {
42009bec:	688c      	beqz.n	a8, 42009bf6 <esp_mmu_map+0x3b6>
        free(dummy_tail);
42009bee:	08ad      	mov.n	a10, a8
42009bf0:	da5e81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42009bf3:	0008e0        	callx8	a8
    if (dummy_head) {
42009bf6:	b1a8      	l32i.n	a10, a1, 44
42009bf8:	ca8c      	beqz.n	a10, 42009c08 <esp_mmu_map+0x3c8>
        free(dummy_head);
42009bfa:	da5b81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42009bfd:	0008e0        	callx8	a8
    return ret;
42009c00:	01a182        	movi	a8, 0x101
42009c03:	6189      	s32i.n	a8, a1, 24
42009c05:	000106        	j	42009c0d <esp_mmu_map+0x3cd>
42009c08:	01a182        	movi	a8, 0x101
42009c0b:	6189      	s32i.n	a8, a1, 24
}
42009c0d:	6128      	l32i.n	a2, a1, 24
42009c0f:	f01d      	retw.n
42009c11:	000000        	ill

42009c14 <esp_mmu_unmap>:
{
42009c14:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(ptr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
42009c17:	92ec      	bnez.n	a2, 42009c44 <esp_mmu_unmap+0x30>
42009c19:	dbb071        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009c1c:	0768      	l32i.n	a6, a7, 0
42009c1e:	d91081        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009c21:	0008e0        	callx8	a8
42009c24:	7aa282        	movi	a8, 0x27a
42009c27:	0189      	s32i.n	a8, a1, 0
42009c29:	dbbcf1        	l32r	a15, 42000b1c <_stext+0xafc> (3c0288dc <__FUNCTION__$2>)
42009c2c:	07e8      	l32i.n	a14, a7, 0
42009c2e:	0add      	mov.n	a13, a10
42009c30:	dbadc1        	l32r	a12, 42000ae4 <_stext+0xac4> (3c026064 <_flash_rodata_start+0x5f44>)
42009c33:	06bd      	mov.n	a11, a6
42009c35:	1a0c      	movi.n	a10, 1
42009c37:	d91781        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009c3a:	0008e0        	callx8	a8
42009c3d:	02a122        	movi	a2, 0x102
42009c40:	003c86        	j	42009d36 <esp_mmu_unmap+0x122>
42009c43:	829000        	mull	a9, a0, a0
    return vaddr & SOC_MMU_LINEAR_ADDR_MASK;
42009c46:	878011        	l32r	a1, 41feba48 <_coredump_iram_end+0x1c69a48>
42009c49:	090c41        	l32r	a4, 41fcc07c <_coredump_iram_end+0x1c4a07c>
    mem_region_t *region = NULL;
42009c4c:	096d      	mov.n	a6, a9
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
42009c4e:	000886        	j	42009c74 <esp_mmu_unmap+0x60>
        if (ptr_laddr >= s_mmu_ctx.mem_regions[i].free_head && ptr_laddr < s_mmu_ctx.mem_regions[i].end) {
42009c51:	a0a990        	addx4	a10, a9, a9
42009c54:	dba0b1        	l32r	a11, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
42009c57:	b0aab0        	addx8	a10, a10, a11
42009c5a:	5aa8      	l32i.n	a10, a10, 20
42009c5c:	1238a7        	bltu	a8, a10, 42009c72 <esp_mmu_unmap+0x5e>
42009c5f:	a0a990        	addx4	a10, a9, a9
42009c62:	b0aab0        	addx8	a10, a10, a11
42009c65:	3aa8      	l32i.n	a10, a10, 12
42009c67:	07b8a7        	bgeu	a8, a10, 42009c72 <esp_mmu_unmap+0x5e>
            region = &s_mmu_ctx.mem_regions[i];
42009c6a:	a06990        	addx4	a6, a9, a9
42009c6d:	b066b0        	addx8	a6, a6, a11
42009c70:	664b      	addi.n	a6, a6, 4
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
42009c72:	991b      	addi.n	a9, a9, 1
42009c74:	db98a1        	l32r	a10, 42000ad4 <_stext+0xab4> (3fc950c8 <s_mmu_ctx>)
42009c77:	0aa8      	l32i.n	a10, a10, 0
42009c79:	d439a7        	bltu	a9, a10, 42009c51 <esp_mmu_unmap+0x3d>
    ESP_RETURN_ON_FALSE(region, ESP_ERR_NOT_FOUND, TAG, "munmap target pointer is outside external memory regions");
42009c7c:	a6ec      	bnez.n	a6, 42009caa <esp_mmu_unmap+0x96>
42009c7e:	db9771        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009c81:	0768      	l32i.n	a6, a7, 0
42009c83:	d8f781        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009c86:	0008e0        	callx8	a8
42009c89:	88a282        	movi	a8, 0x288
42009c8c:	0189      	s32i.n	a8, a1, 0
42009c8e:	dba3f1        	l32r	a15, 42000b1c <_stext+0xafc> (3c0288dc <__FUNCTION__$2>)
42009c91:	07e8      	l32i.n	a14, a7, 0
42009c93:	0add      	mov.n	a13, a10
42009c95:	dba2c1        	l32r	a12, 42000b20 <_stext+0xb00> (3c0261e8 <_flash_rodata_start+0x60c8>)
42009c98:	20b660        	or	a11, a6, a6
42009c9b:	01a0a2        	movi	a10, 1
42009c9e:	d8fd81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009ca1:	0008e0        	callx8	a8
42009ca4:	05a122        	movi	a2, 0x105
42009ca7:	0022c6        	j	42009d36 <esp_mmu_unmap+0x122>
    TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
42009caa:	86a8      	l32i.n	a10, a6, 32
42009cac:	0a7d      	mov.n	a7, a10
42009cae:	000e46        	j	42009ceb <esp_mmu_unmap+0xd7>
        if (mem_block == TAILQ_FIRST(&region->mem_block_head) || mem_block == TAILQ_LAST(&region->mem_block_head, mem_block_head_)) {
42009cb1:	341a77        	beq	a10, a7, 42009ce9 <esp_mmu_unmap+0xd5>
42009cb4:	9698      	l32i.n	a9, a6, 36
42009cb6:	1998      	l32i.n	a9, a9, 4
42009cb8:	0998      	l32i.n	a9, a9, 0
42009cba:	2b1977        	beq	a9, a7, 42009ce9 <esp_mmu_unmap+0xd5>
        if (mem_block->laddr_start == ptr_laddr) {
42009cbd:	0798      	l32i.n	a9, a7, 0
42009cbf:	269897        	bne	a8, a9, 42009ce9 <esp_mmu_unmap+0xd5>
            slot_len = TAILQ_NEXT(mem_block, entries)->laddr_start - TAILQ_PREV(mem_block, mem_block_head_, entries)->laddr_end;
42009cc2:	9788      	l32i.n	a8, a7, 36
42009cc4:	0888      	l32i.n	a8, a8, 0
42009cc6:	a798      	l32i.n	a9, a7, 40
42009cc8:	1998      	l32i.n	a9, a9, 4
42009cca:	0998      	l32i.n	a9, a9, 0
42009ccc:	1998      	l32i.n	a9, a9, 4
42009cce:	c08890        	sub	a8, a8, a9
            region->max_slot_size = (slot_len > region->max_slot_size) ? slot_len : region->max_slot_size;
42009cd1:	5698      	l32i.n	a9, a6, 20
42009cd3:	738890        	maxu	a8, a8, a9
42009cd6:	5689      	s32i.n	a8, a6, 20
    s_do_unmapping(mem_block->vaddr_start, mem_block->size);
42009cd8:	47b8      	l32i.n	a11, a7, 16
42009cda:	27a8      	l32i.n	a10, a7, 8
42009cdc:	db9381        	l32r	a8, 42000b28 <_stext+0xb08> (40377788 <s_do_unmapping>)
42009cdf:	0008e0        	callx8	a8
    TAILQ_REMOVE(&region->mem_block_head, found_block, entries);
42009ce2:	9788      	l32i.n	a8, a7, 36
42009ce4:	28fc      	bnez.n	a8, 42009d1a <esp_mmu_unmap+0x106>
42009ce6:	000dc6        	j	42009d21 <esp_mmu_unmap+0x10d>
    TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
42009ce9:	9778      	l32i.n	a7, a7, 36
42009ceb:	fc2756        	bnez	a7, 42009cb1 <esp_mmu_unmap+0x9d>
    ESP_RETURN_ON_FALSE(found, ESP_ERR_NOT_FOUND, TAG, "munmap target pointer isn't mapped yet");
42009cee:	db7b71        	l32r	a7, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009cf1:	0768      	l32i.n	a6, a7, 0
42009cf3:	d8db81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009cf6:	0008e0        	callx8	a8
42009cf9:	9da282        	movi	a8, 0x29d
42009cfc:	0189      	s32i.n	a8, a1, 0
42009cfe:	db87f1        	l32r	a15, 42000b1c <_stext+0xafc> (3c0288dc <__FUNCTION__$2>)
42009d01:	07e8      	l32i.n	a14, a7, 0
42009d03:	0add      	mov.n	a13, a10
42009d05:	db87c1        	l32r	a12, 42000b24 <_stext+0xb04> (3c026238 <_flash_rodata_start+0x6118>)
42009d08:	20b660        	or	a11, a6, a6
42009d0b:	01a0a2        	movi	a10, 1
42009d0e:	d8e181        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009d11:	0008e0        	callx8	a8
42009d14:	05a122        	movi	a2, 0x105
42009d17:	0006c6        	j	42009d36 <esp_mmu_unmap+0x122>
    TAILQ_REMOVE(&region->mem_block_head, found_block, entries);
42009d1a:	a798      	l32i.n	a9, a7, 40
42009d1c:	a899      	s32i.n	a9, a8, 40
42009d1e:	0000c6        	j	42009d25 <esp_mmu_unmap+0x111>
42009d21:	a788      	l32i.n	a8, a7, 40
42009d23:	9689      	s32i.n	a8, a6, 36
42009d25:	a788      	l32i.n	a8, a7, 40
42009d27:	9798      	l32i.n	a9, a7, 36
42009d29:	0899      	s32i.n	a9, a8, 0
    free(found_block);
42009d2b:	20a770        	or	a10, a7, a7
42009d2e:	da0e81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42009d31:	0008e0        	callx8	a8
    return ESP_OK;
42009d34:	020c      	movi.n	a2, 0
}
42009d36:	f01d      	retw.n

42009d38 <esp_mmu_vaddr_to_paddr>:

esp_err_t esp_mmu_vaddr_to_paddr(void *vaddr, esp_paddr_t *out_paddr, mmu_target_t *out_target)
{
42009d38:	008136        	entry	a1, 64
    ESP_RETURN_ON_FALSE(vaddr && out_paddr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
42009d3b:	40f280        	nsau	a8, a2
42009d3e:	418580        	srli	a8, a8, 5
42009d41:	40f390        	nsau	a9, a3
42009d44:	419590        	srli	a9, a9, 5
42009d47:	208890        	or	a8, a8, a9
42009d4a:	a8ac      	beqz.n	a8, 42009d78 <esp_mmu_vaddr_to_paddr+0x40>
42009d4c:	db6441        	l32r	a4, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009d4f:	002432        	l32i	a3, a4, 0
42009d52:	d8c381        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009d55:	0008e0        	callx8	a8
42009d58:	03a382        	movi	a8, 0x303
42009d5b:	0189      	s32i.n	a8, a1, 0
42009d5d:	db73f1        	l32r	a15, 42000b2c <_stext+0xb0c> (3c0288c4 <__FUNCTION__$1>)
42009d60:	04e8      	l32i.n	a14, a4, 0
42009d62:	0add      	mov.n	a13, a10
42009d64:	db60c1        	l32r	a12, 42000ae4 <_stext+0xac4> (3c026064 <_flash_rodata_start+0x5f44>)
42009d67:	03bd      	mov.n	a11, a3
42009d69:	1a0c      	movi.n	a10, 1
42009d6b:	d8ca81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009d6e:	0008e0        	callx8	a8
42009d71:	02a122        	movi	a2, 0x102
42009d74:	002206        	j	42009e00 <esp_mmu_vaddr_to_paddr+0xc8>
42009d77:	3d0c00        	lsi	f0, a12, 244
    ESP_RETURN_ON_FALSE(mmu_hal_check_valid_ext_vaddr_region(0, (uint32_t)vaddr, 1, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION), ESP_ERR_INVALID_ARG, TAG, "not a valid external virtual address");
42009d7a:	1c0c      	movi.n	a12, 1
42009d7c:	02bd      	mov.n	a11, a2
42009d7e:	0a0c      	movi.n	a10, 0
42009d80:	db6e81        	l32r	a8, 42000b38 <_stext+0xb18> (4037cda0 <mmu_hal_check_valid_ext_vaddr_region>)
42009d83:	0008e0        	callx8	a8
42009d86:	aaec      	bnez.n	a10, 42009db4 <esp_mmu_vaddr_to_paddr+0x7c>
42009d88:	db5541        	l32r	a4, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009d8b:	002432        	l32i	a3, a4, 0
42009d8e:	d8b481        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009d91:	0008e0        	callx8	a8
42009d94:	04a382        	movi	a8, 0x304
42009d97:	0189      	s32i.n	a8, a1, 0
42009d99:	db64f1        	l32r	a15, 42000b2c <_stext+0xb0c> (3c0288c4 <__FUNCTION__$1>)
42009d9c:	04e8      	l32i.n	a14, a4, 0
42009d9e:	0add      	mov.n	a13, a10
42009da0:	db64c1        	l32r	a12, 42000b30 <_stext+0xb10> (3c026274 <_flash_rodata_start+0x6154>)
42009da3:	03bd      	mov.n	a11, a3
42009da5:	1a0c      	movi.n	a10, 1
42009da7:	d8bb81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009daa:	0008e0        	callx8	a8
42009dad:	02a122        	movi	a2, 0x102
42009db0:	001306        	j	42009e00 <esp_mmu_vaddr_to_paddr+0xc8>
42009db3:	080c00        	lsx	f0, a12, a0

    esp_paddr_t paddr = 0;
42009db6:	4189      	s32i.n	a8, a1, 16
    mmu_target_t target = 0;
42009db8:	5189      	s32i.n	a8, a1, 20

    bool is_mapped = s_vaddr_to_paddr((uint32_t)vaddr, &paddr, &target);
42009dba:	14c1c2        	addi	a12, a1, 20
42009dbd:	10c1b2        	addi	a11, a1, 16
42009dc0:	02ad      	mov.n	a10, a2
42009dc2:	db5e81        	l32r	a8, 42000b3c <_stext+0xb1c> (403777a0 <s_vaddr_to_paddr>)
42009dc5:	0008e0        	callx8	a8
    ESP_RETURN_ON_FALSE(is_mapped, ESP_ERR_NOT_FOUND, TAG, "vaddr isn't mapped");
42009dc8:	aaec      	bnez.n	a10, 42009df6 <esp_mmu_vaddr_to_paddr+0xbe>
42009dca:	db4441        	l32r	a4, 42000adc <_stext+0xabc> (3fc9366c <TAG>)
42009dcd:	0438      	l32i.n	a3, a4, 0
42009dcf:	d8a481        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42009dd2:	0008e0        	callx8	a8
42009dd5:	0aa382        	movi	a8, 0x30a
42009dd8:	0189      	s32i.n	a8, a1, 0
42009dda:	db54f1        	l32r	a15, 42000b2c <_stext+0xb0c> (3c0288c4 <__FUNCTION__$1>)
42009ddd:	04e8      	l32i.n	a14, a4, 0
42009ddf:	0add      	mov.n	a13, a10
42009de1:	db54c1        	l32r	a12, 42000b34 <_stext+0xb14> (3c0262b0 <_flash_rodata_start+0x6190>)
42009de4:	20b330        	or	a11, a3, a3
42009de7:	01a0a2        	movi	a10, 1
42009dea:	d8aa81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42009ded:	0008e0        	callx8	a8
42009df0:	05a122        	movi	a2, 0x105
42009df3:	000246        	j	42009e00 <esp_mmu_vaddr_to_paddr+0xc8>

    *out_paddr = paddr;
42009df6:	4188      	l32i.n	a8, a1, 16
42009df8:	0389      	s32i.n	a8, a3, 0
    *out_target = target;
42009dfa:	5188      	l32i.n	a8, a1, 20
42009dfc:	0489      	s32i.n	a8, a4, 0

    return ESP_OK;
42009dfe:	020c      	movi.n	a2, 0
}
42009e00:	f01d      	retw.n
	...

42009e04 <spi_flash_init_lock>:
{
42009e04:	004136        	entry	a1, 32
    s_flash_op_mutex = xSemaphoreCreateRecursiveMutex();
42009e07:	04a0a2        	movi	a10, 4
42009e0a:	da6581        	l32r	a8, 420007a0 <_stext+0x780> (40379c50 <xQueueCreateMutex>)
42009e0d:	0008e0        	callx8	a8
42009e10:	db4c81        	l32r	a8, 42000b40 <_stext+0xb20> (3fc950f8 <s_flash_op_mutex>)
42009e13:	08a9      	s32i.n	a10, a8, 0
    assert(s_flash_op_mutex != NULL);
42009e15:	facc      	bnez.n	a10, 42009e28 <spi_flash_init_lock+0x24>
42009e17:	db4bd1        	l32r	a13, 42000b44 <_stext+0xb24> (3c0262d8 <_flash_rodata_start+0x61b8>)
42009e1a:	db4bc1        	l32r	a12, 42000b48 <_stext+0xb28> (3c0289dc <__func__$2>)
42009e1d:	db4c      	movi.n	a11, 77
42009e1f:	db4ba1        	l32r	a10, 42000b4c <_stext+0xb2c> (3c02630f <_flash_rodata_start+0x61ef>)
42009e22:	d8a781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42009e25:	0008e0        	callx8	a8
}
42009e28:	f01d      	retw.n
	...

42009e2c <spi_flash_op_lock>:
{
42009e2c:	004136        	entry	a1, 32
    xSemaphoreTakeRecursive(s_flash_op_mutex, portMAX_DELAY);
42009e2f:	fb7c      	movi.n	a11, -1
42009e31:	db4381        	l32r	a8, 42000b40 <_stext+0xb20> (3fc950f8 <s_flash_op_mutex>)
42009e34:	08a8      	l32i.n	a10, a8, 0
42009e36:	da5881        	l32r	a8, 42000798 <_stext+0x778> (40379e88 <xQueueTakeMutexRecursive>)
42009e39:	0008e0        	callx8	a8
}
42009e3c:	f01d      	retw.n
	...

42009e40 <spi_flash_op_unlock>:
{
42009e40:	004136        	entry	a1, 32
    xSemaphoreGiveRecursive(s_flash_op_mutex);
42009e43:	db3f81        	l32r	a8, 42000b40 <_stext+0xb20> (3fc950f8 <s_flash_op_mutex>)
42009e46:	08a8      	l32i.n	a10, a8, 0
42009e48:	da5b81        	l32r	a8, 420007b4 <_stext+0x794> (40379c84 <xQueueGiveMutexRecursive>)
42009e4b:	0008e0        	callx8	a8
}
42009e4e:	f01d      	retw.n

42009e50 <spi_flash_mmap>:
{
42009e50:	008136        	entry	a1, 64
42009e53:	4169      	s32i.n	a6, a1, 16
    void *ptr = NULL;
42009e55:	080c      	movi.n	a8, 0
42009e57:	0189      	s32i.n	a8, a1, 0
    block = heap_caps_calloc(1, sizeof(mmap_block_t), MALLOC_CAP_INTERNAL);
42009e59:	d9cdc1        	l32r	a12, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
42009e5c:	8b0c      	movi.n	a11, 8
42009e5e:	1a0c      	movi.n	a10, 1
42009e60:	db2d81        	l32r	a8, 42000b14 <_stext+0xaf4> (4037606c <heap_caps_calloc>)
42009e63:	0008e0        	callx8	a8
42009e66:	0a7d      	mov.n	a7, a10
    if (!block) {
42009e68:	061a16        	beqz	a10, 42009ecd <spi_flash_mmap+0x7d>
    vaddr_list = heap_caps_calloc(1, 1 * sizeof(uint32_t), MALLOC_CAP_INTERNAL);
42009e6b:	d9c9c1        	l32r	a12, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
42009e6e:	4b0c      	movi.n	a11, 4
42009e70:	1a0c      	movi.n	a10, 1
42009e72:	db2881        	l32r	a8, 42000b14 <_stext+0xaf4> (4037606c <heap_caps_calloc>)
42009e75:	0008e0        	callx8	a8
42009e78:	0a6d      	mov.n	a6, a10
    if (!vaddr_list) {
42009e7a:	056a16        	beqz	a10, 42009ed4 <spi_flash_mmap+0x84>
    block->vaddr_list = vaddr_list;
42009e7d:	07a9      	s32i.n	a10, a7, 0
    if (memory == SPI_FLASH_MMAP_INST) {
42009e7f:	041466        	bnei	a4, 1, 42009e87 <spi_flash_mmap+0x37>
        caps = MMU_MEM_CAP_EXEC | MMU_MEM_CAP_32BIT;
42009e82:	9d0c      	movi.n	a13, 9
42009e84:	000086        	j	42009e8a <spi_flash_mmap+0x3a>
        caps = MMU_MEM_CAP_READ | MMU_MEM_CAP_8BIT;
42009e87:	12a0d2        	movi	a13, 18
    ret = esp_mmu_map(src_addr, size, MMU_TARGET_FLASH0, caps, ESP_MMU_MMAP_FLAG_PADDR_SHARED, &ptr);
42009e8a:	20f110        	or	a15, a1, a1
42009e8d:	01a0e2        	movi	a14, 1
42009e90:	0ecd      	mov.n	a12, a14
42009e92:	03bd      	mov.n	a11, a3
42009e94:	02ad      	mov.n	a10, a2
42009e96:	ff9aa5        	call8	42009840 <esp_mmu_map>
42009e99:	0a2d      	mov.n	a2, a10
    if (ret == ESP_OK) {
42009e9b:	9acc      	bnez.n	a10, 42009ea8 <spi_flash_mmap+0x58>
        vaddr_list[0] = (uint32_t)ptr;
42009e9d:	0188      	l32i.n	a8, a1, 0
42009e9f:	0689      	s32i.n	a8, a6, 0
        block->list_num = 1;
42009ea1:	180c      	movi.n	a8, 1
42009ea3:	1789      	s32i.n	a8, a7, 4
42009ea5:	0005c6        	j	42009ec0 <spi_flash_mmap+0x70>
    } else if (ret == ESP_ERR_INVALID_STATE) {
42009ea8:	03a182        	movi	a8, 0x103
42009eab:	069a87        	bne	a10, a8, 42009eb5 <spi_flash_mmap+0x65>
        block->list_num = 0;
42009eae:	080c      	movi.n	a8, 0
42009eb0:	1789      	s32i.n	a8, a7, 4
42009eb2:	000286        	j	42009ec0 <spi_flash_mmap+0x70>
        free(vaddr_list);
42009eb5:	06ad      	mov.n	a10, a6
42009eb7:	d9ac81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42009eba:	0008e0        	callx8	a8
42009ebd:	000586        	j	42009ed7 <spi_flash_mmap+0x87>
    *out_ptr = ptr;
42009ec0:	0188      	l32i.n	a8, a1, 0
42009ec2:	0589      	s32i.n	a8, a5, 0
    *out_handle = (uint32_t)block;
42009ec4:	4188      	l32i.n	a8, a1, 16
42009ec6:	0879      	s32i.n	a7, a8, 0
    return ESP_OK;
42009ec8:	020c      	movi.n	a2, 0
42009eca:	0004c6        	j	42009ee1 <spi_flash_mmap+0x91>
        ret = ESP_ERR_NO_MEM;
42009ecd:	01a122        	movi	a2, 0x101
42009ed0:	0000c6        	j	42009ed7 <spi_flash_mmap+0x87>
42009ed3:	a12200        	sll	a2, a2
        ret = ESP_ERR_NO_MEM;
42009ed6:	678c01        	l32r	a0, 41fe3d08 <_coredump_iram_end+0x1c61d08>
        free(block);
42009ed9:	07ad      	mov.n	a10, a7
42009edb:	d9a381        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42009ede:	0008e0        	callx8	a8
}
42009ee1:	f01d      	retw.n
	...

42009ee4 <spi_flash_munmap>:
{
42009ee4:	004136        	entry	a1, 32
    for (int i = 0; i < block->list_num; i++) {
42009ee7:	070c      	movi.n	a7, 0
42009ee9:	0008c6        	j	42009f10 <spi_flash_munmap+0x2c>
        ret = esp_mmu_unmap((void *)block->vaddr_list[i]);
42009eec:	0288      	l32i.n	a8, a2, 0
42009eee:	a08780        	addx4	a8, a7, a8
42009ef1:	08a8      	l32i.n	a10, a8, 0
42009ef3:	ffd225        	call8	42009c14 <esp_mmu_unmap>
        if (ret == ESP_ERR_NOT_FOUND) {
42009ef6:	05a182        	movi	a8, 0x105
42009ef9:	119a87        	bne	a10, a8, 42009f0e <spi_flash_munmap+0x2a>
            assert(0 && "invalid handle, or handle already unmapped");
42009efc:	db15d1        	l32r	a13, 42000b50 <_stext+0xb30> (3c02646c <_flash_rodata_start+0x634c>)
42009eff:	db15c1        	l32r	a12, 42000b54 <_stext+0xb34> (3c0289f0 <__func__$1>)
42009f02:	f4a0b2        	movi	a11, 244
42009f05:	db14a1        	l32r	a10, 42000b58 <_stext+0xb38> (3c02645f <_flash_rodata_start+0x633f>)
42009f08:	d86e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42009f0b:	0008e0        	callx8	a8
    for (int i = 0; i < block->list_num; i++) {
42009f0e:	771b      	addi.n	a7, a7, 1
42009f10:	1288      	l32i.n	a8, a2, 4
42009f12:	d62787        	blt	a7, a8, 42009eec <spi_flash_munmap+0x8>
    free(block->vaddr_list);
42009f15:	02a8      	l32i.n	a10, a2, 0
42009f17:	d99481        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42009f1a:	0008e0        	callx8	a8
    free(block);
42009f1d:	02ad      	mov.n	a10, a2
42009f1f:	d99281        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
42009f22:	0008e0        	callx8	a8
}
42009f25:	f01d      	retw.n
	...

42009f28 <spi_flash_cache2phys>:

#if !CONFIG_SPI_FLASH_ROM_IMPL || CONFIG_SPIRAM_FETCH_INSTRUCTIONS || CONFIG_SPIRAM_RODATA
//The ROM implementation returns physical address of the PSRAM when the .text or .rodata is in the PSRAM.
//Always patch it when SPIRAM_FETCH_INSTRUCTIONS or SPIRAM_RODATA is set.
size_t spi_flash_cache2phys(const void *cached)
{
42009f28:	006136        	entry	a1, 48
42009f2b:	02ad      	mov.n	a10, a2
    if (cached == NULL) {
42009f2d:	229c      	beqz.n	a2, 42009f43 <spi_flash_cache2phys+0x1b>
        return SPI_FLASH_CACHE2PHYS_FAIL;
    }

    esp_err_t ret = ESP_FAIL;
    uint32_t paddr = 0;
42009f2f:	080c      	movi.n	a8, 0
42009f31:	0189      	s32i.n	a8, a1, 0
    mmu_target_t target = 0;
42009f33:	1189      	s32i.n	a8, a1, 4
    if (paddr != SPI_FLASH_CACHE2PHYS_FAIL) {
        return paddr;
    }
#endif

    ret = esp_mmu_vaddr_to_paddr((void *)cached, &paddr, &target);
42009f35:	c14b      	addi.n	a12, a1, 4
42009f37:	01bd      	mov.n	a11, a1
42009f39:	ffdfe5        	call8	42009d38 <esp_mmu_vaddr_to_paddr>
    if (ret != ESP_OK) {
42009f3c:	8acc      	bnez.n	a10, 42009f48 <spi_flash_cache2phys+0x20>
        offset = instruction_flash2spiram_offset();
    }
#endif
#endif  //#if !CONFIG_SPIRAM_FLASH_LOAD_TO_PSRAM

    return paddr + offset * CONFIG_MMU_PAGE_SIZE;
42009f3e:	0128      	l32i.n	a2, a1, 0
42009f40:	000186        	j	42009f4a <spi_flash_cache2phys+0x22>
        return SPI_FLASH_CACHE2PHYS_FAIL;
42009f43:	f27c      	movi.n	a2, -1
42009f45:	000046        	j	42009f4a <spi_flash_cache2phys+0x22>
        return SPI_FLASH_CACHE2PHYS_FAIL;
42009f48:	f27c      	movi.n	a2, -1
}
42009f4a:	f01d      	retw.n

42009f4c <esp_mspi_get_io>:
{
42009f4c:	004136        	entry	a1, 32
    assert(io <= ESP_MSPI_IO_D7);
42009f4f:	a80c      	movi.n	a8, 10
42009f51:	11b827        	bgeu	a8, a2, 42009f66 <esp_mspi_get_io+0x1a>
42009f54:	db02d1        	l32r	a13, 42000b5c <_stext+0xb3c> (3c0264a0 <_flash_rodata_start+0x6380>)
42009f57:	db02c1        	l32r	a12, 42000b60 <_stext+0xb40> (3c028a04 <__func__$0>)
42009f5a:	f5a0b2        	movi	a11, 245
42009f5d:	db01a1        	l32r	a10, 42000b64 <_stext+0xb44> (3c0264d3 <_flash_rodata_start+0x63b3>)
42009f60:	d85881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42009f63:	0008e0        	callx8	a8
    if (io == ESP_MSPI_IO_WP) {
42009f66:	1e5266        	bnei	a2, 5, 42009f88 <esp_mspi_get_io+0x3c>
        spiconfig = esp_rom_efuse_get_flash_wp_gpio();
42009f69:	db0081        	l32r	a8, 42000b6c <_stext+0xb4c> (40001fa4 <esp_rom_efuse_get_flash_wp_gpio>)
42009f6c:	0008e0        	callx8	a8
        return (spiconfig == 0x3f) ? s_mspi_io_num_default[io] : spiconfig & 0x3f;
42009f6f:	f83c      	movi.n	a8, 63
42009f71:	0b9a87        	bne	a10, a8, 42009f80 <esp_mspi_get_io+0x34>
42009f74:	dafd81        	l32r	a8, 42000b68 <_stext+0xb48> (3c028a14 <s_mspi_io_num_default>)
42009f77:	882a      	add.n	a8, a8, a2
42009f79:	000822        	l8ui	a2, a8, 0
42009f7c:	001246        	j	42009fc9 <esp_mspi_get_io+0x7d>
42009f7f:	20a000        	or	a10, a0, a0
42009f82:	108654        	lsi	f5, a6, 64
42009f85:	000000        	ill
    spiconfig = (io < ESP_MSPI_IO_WP) ? esp_rom_efuse_get_flash_gpio_info() : esp_rom_efuse_get_opiconfig();
42009f88:	0852f6        	bgeui	a2, 5, 42009f94 <esp_mspi_get_io+0x48>
42009f8b:	daf981        	l32r	a8, 42000b70 <_stext+0xb50> (40001f74 <esp_rom_efuse_get_flash_gpio_info>)
42009f8e:	0008e0        	callx8	a8
42009f91:	000086        	j	42009f97 <esp_mspi_get_io+0x4b>
42009f94:	002fe5        	call8	4200a294 <esp_rom_efuse_get_opiconfig>
    if (spiconfig == ESP_ROM_EFUSE_FLASH_DEFAULT_SPI) {
42009f97:	9acc      	bnez.n	a10, 42009fa4 <esp_mspi_get_io+0x58>
        mspi_io = s_mspi_io_num_default[io];
42009f99:	daf381        	l32r	a8, 42000b68 <_stext+0xb48> (3c028a14 <s_mspi_io_num_default>)
42009f9c:	882a      	add.n	a8, a8, a2
42009f9e:	000822        	l8ui	a2, a8, 0
42009fa1:	000906        	j	42009fc9 <esp_mspi_get_io+0x7d>
    } else if (io < ESP_MSPI_IO_WP) {
42009fa4:	1052f6        	bgeui	a2, 5, 42009fb8 <esp_mspi_get_io+0x6c>
        mspi_io = (spiconfig >> io * 6) & 0x3f;
42009fa7:	902220        	addx2	a2, a2, a2
42009faa:	222a      	add.n	a2, a2, a2
42009fac:	400200        	ssr	a2
42009faf:	91a0a0        	srl	a10, a10
42009fb2:	5420a0        	extui	a2, a10, 0, 6
42009fb5:	000406        	j	42009fc9 <esp_mspi_get_io+0x7d>
        mspi_io = (spiconfig >> (io - ESP_MSPI_IO_DQS) * 6) & 0x3f;
42009fb8:	902220        	addx2	a2, a2, a2
42009fbb:	222a      	add.n	a2, a2, a2
42009fbd:	dcc222        	addi	a2, a2, -36
42009fc0:	400200        	ssr	a2
42009fc3:	91a0a0        	srl	a10, a10
42009fc6:	5420a0        	extui	a2, a10, 0, 6
}
42009fc9:	f01d      	retw.n
	...

42009fcc <esp_mspi_pin_reserve>:
{
42009fcc:	004136        	entry	a1, 32
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
42009fcf:	070c      	movi.n	a7, 0
    uint64_t reserve_pin_mask = 0;
42009fd1:	075d      	mov.n	a5, a7
42009fd3:	076d      	mov.n	a6, a7
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
42009fd5:	000e86        	j	4200a013 <esp_mspi_pin_reserve+0x47>
        if (!bootloader_flash_is_octal_mode_enabled()
42009fd8:	d97581        	l32r	a8, 420005ac <_stext+0x58c> (40377670 <bootloader_flash_is_octal_mode_enabled>)
42009fdb:	0008e0        	callx8	a8
42009fde:	4acc      	bnez.n	a10, 42009fe6 <esp_mspi_pin_reserve+0x1a>
            && i >=  ESP_MSPI_IO_DQS && i <= ESP_MSPI_IO_D7) {
42009fe0:	fac782        	addi	a8, a7, -6
42009fe3:	2958b6        	bltui	a8, 5, 4200a010 <esp_mspi_pin_reserve+0x44>
        mspi_io = esp_mspi_get_io(i);
42009fe6:	20a770        	or	a10, a7, a7
42009fe9:	fff625        	call8	42009f4c <esp_mspi_get_io>
        if (mspi_io < 64) {     // 'reserve_pin_mask' have 64 bits length
42009fec:	3fa082        	movi	a8, 63
42009fef:	1d38a7        	bltu	a8, a10, 4200a010 <esp_mspi_pin_reserve+0x44>
            reserve_pin_mask |= BIT64(mspi_io);
42009ff2:	20a092        	movi	a9, 32
42009ff5:	109a90        	and	a9, a10, a9
42009ff8:	0b0c      	movi.n	a11, 0
42009ffa:	180c      	movi.n	a8, 1
42009ffc:	401a00        	ssl	a10
42009fff:	a18800        	sll	a8, a8
4200a002:	08ad      	mov.n	a10, a8
4200a004:	83ab90        	moveqz	a10, a11, a9
4200a007:	938b90        	movnez	a8, a11, a9
4200a00a:	205580        	or	a5, a5, a8
4200a00d:	2066a0        	or	a6, a6, a10
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
4200a010:	01c772        	addi	a7, a7, 1
4200a013:	0aa082        	movi	a8, 10
4200a016:	beb877        	bgeu	a8, a7, 42009fd8 <esp_mspi_pin_reserve+0xc>
    esp_gpio_reserve(reserve_pin_mask);
4200a019:	20a550        	or	a10, a5, a5
4200a01c:	06bd      	mov.n	a11, a6
4200a01e:	0053a5        	call8	4200a558 <esp_gpio_reserve>
}
4200a021:	f01d      	retw.n
	...

4200a024 <esp_flash_read_chip_id>:
{
4200a024:	004136        	entry	a1, 32
4200a027:	02ad      	mov.n	a10, a2
4200a029:	03bd      	mov.n	a11, a3
    return read_id_core(chip, out_id, true);
4200a02b:	01a0c2        	movi	a12, 1
4200a02e:	dad181        	l32r	a8, 42000b74 <_stext+0xb54> (40377c54 <read_id_core>)
4200a031:	0008e0        	callx8	a8
}
4200a034:	0a2d      	mov.n	a2, a10
4200a036:	f01d      	retw.n

4200a038 <spimem_flash_ll_get_source_freq_mhz>:
{
4200a038:	004136        	entry	a1, 32
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4200a03b:	dacf81        	l32r	a8, 42000b78 <_stext+0xb58> (60003000 <SPIMEM0>)
4200a03e:	0020c0        	memw
4200a041:	3b2882        	l32i	a8, a8, 236
4200a044:	148080        	extui	a8, a8, 0, 2
4200a047:	132826        	beqi	a8, 2, 4200a05e <spimem_flash_ll_get_source_freq_mhz+0x26>
4200a04a:	0738f6        	bgeui	a8, 3, 4200a055 <spimem_flash_ll_get_source_freq_mhz+0x1d>
4200a04d:	389c      	beqz.n	a8, 4200a064 <spimem_flash_ll_get_source_freq_mhz+0x2c>
4200a04f:	161826        	beqi	a8, 1, 4200a069 <spimem_flash_ll_get_source_freq_mhz+0x31>
4200a052:	000086        	j	4200a058 <spimem_flash_ll_get_source_freq_mhz+0x20>
4200a055:	173826        	beqi	a8, 3, 4200a070 <spimem_flash_ll_get_source_freq_mhz+0x38>
        abort();
4200a058:	d82781        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200a05b:	0008e0        	callx8	a8
        clock_val = 160;
4200a05e:	a0a022        	movi	a2, 160
4200a061:	000386        	j	4200a073 <spimem_flash_ll_get_source_freq_mhz+0x3b>
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4200a064:	025c      	movi.n	a2, 80
4200a066:	000246        	j	4200a073 <spimem_flash_ll_get_source_freq_mhz+0x3b>
        clock_val = 120;
4200a069:	78a022        	movi	a2, 120
4200a06c:	0000c6        	j	4200a073 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4200a06f:	a02200        	addx4	a2, a2, a0
        clock_val = 240;
4200a072:	f01df0        	subx8	a1, a13, a15
4200a075:	000000        	ill

4200a078 <s_esp_flash_choose_correct_mode>:
};

#if CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT
/* This function is used to correct flash mode if config option is not consistent with efuse information */
static void s_esp_flash_choose_correct_mode(memspi_host_config_t *cfg)
{
4200a078:	004136        	entry	a1, 32
    static const char *mode = FLASH_MODE_STRING;
    if (bootloader_flash_is_octal_mode_enabled()) {
4200a07b:	d94c81        	l32r	a8, 420005ac <_stext+0x58c> (40377670 <bootloader_flash_is_octal_mode_enabled>)
4200a07e:	0008e0        	callx8	a8
4200a081:	baac      	beqz.n	a10, 4200a0b0 <s_esp_flash_choose_correct_mode+0x38>
4200a083:	d7ea81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200a086:	0888      	l32i.n	a8, a8, 0
    #if !CONFIG_ESPTOOLPY_FLASHMODE_OPI
        ESP_EARLY_LOGW(TAG, "Octal flash chip is using but %s mode is selected, will automatically switch to Octal mode", mode);
4200a088:	1628b6        	bltui	a8, 2, 4200a0a2 <s_esp_flash_choose_correct_mode+0x2a>
4200a08b:	d7f581        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a08e:	0008e0        	callx8	a8
4200a091:	dabad1        	l32r	a13, 42000b7c <_stext+0xb5c> (3c0266c4 <_flash_rodata_start+0x65a4>)
4200a094:	dabbc1        	l32r	a12, 42000b80 <_stext+0xb60> (3c028af0 <TAG>)
4200a097:	0abd      	mov.n	a11, a10
4200a099:	dabaa1        	l32r	a10, 42000b84 <_stext+0xb64> (3c0266c8 <_flash_rodata_start+0x65a8>)
4200a09c:	d7f281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200a09f:	0008e0        	callx8	a8
        cfg->octal_mode_en = 1;
4200a0a2:	180c      	movi.n	a8, 1
4200a0a4:	294282        	s8i	a8, a2, 41
        cfg->default_io_mode = SPI_FLASH_OPI_STR;
4200a0a7:	081c      	movi.n	a8, 16
4200a0a9:	b289      	s32i.n	a8, a2, 44
        default_chip.read_mode = SPI_FLASH_OPI_STR;
4200a0ab:	dab791        	l32r	a9, 42000b88 <_stext+0xb68> (3fc93698 <default_chip>)
4200a0ae:	4989      	s32i.n	a8, a9, 16
        cfg->octal_mode_en = 0;
        cfg->default_io_mode = SPI_FLASH_DIO;
        default_chip.read_mode = SPI_FLASH_DIO;
    #endif
    }
}
4200a0b0:	f01d      	retw.n
	...

4200a0b4 <esp_flash_init_default_chip>:
#endif // CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT

extern esp_err_t esp_flash_suspend_cmd_init(esp_flash_t* chip);
esp_err_t esp_flash_init_default_chip(void)
{
4200a0b4:	00c136        	entry	a1, 96
    const esp_rom_spiflash_chip_t *legacy_chip = &g_rom_flashchip;
4200a0b7:	da7181        	l32r	a8, 42000a7c <_stext+0xa5c> (3fceffe4 <rom_spiflash_legacy_data>)
4200a0ba:	0878      	l32i.n	a7, a8, 0
    memspi_host_config_t cfg = ESP_FLASH_HOST_CONFIG_DEFAULT();
4200a0bc:	cc3c      	movi.n	a12, 60
4200a0be:	0b0c      	movi.n	a11, 0
4200a0c0:	20a110        	or	a10, a1, a1
4200a0c3:	d88f81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200a0c6:	0008e0        	callx8	a8
4200a0c9:	180c      	movi.n	a8, 1
4200a0cb:	0c4182        	s8i	a8, a1, 12
4200a0ce:	144182        	s8i	a8, a1, 20
4200a0d1:	085c      	movi.n	a8, 80
4200a0d3:	c189      	s32i.n	a8, a1, 48

    #if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C3
    // Only these chips have efuses for spi pin configuration.
    cfg.iomux = esp_rom_efuse_get_flash_gpio_info() == 0 ?  true : false;
4200a0d5:	daa681        	l32r	a8, 42000b70 <_stext+0xb50> (40001f74 <esp_rom_efuse_get_flash_gpio_info>)
4200a0d8:	0008e0        	callx8	a8
4200a0db:	40faa0        	nsau	a10, a10
4200a0de:	41a5a0        	srli	a10, a10, 5
4200a0e1:	1441a2        	s8i	a10, a1, 20
    cfg.default_io_mode = DEFAULT_FLASH_MODE;
    #endif

    #if CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT
    // Automatically detect flash mode in run time
    s_esp_flash_choose_correct_mode(&cfg);
4200a0e4:	01ad      	mov.n	a10, a1
4200a0e6:	fff925        	call8	4200a078 <s_esp_flash_choose_correct_mode>
    #endif


    // For chips need time tuning, get value directly from system here.
    #if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    if (spi_flash_timing_is_tuned()) {
4200a0e9:	daae81        	l32r	a8, 42000ba4 <_stext+0xb84> (40378540 <spi_flash_timing_is_tuned>)
4200a0ec:	0008e0        	callx8	a8
4200a0ef:	ba8c      	beqz.n	a10, 4200a0fe <esp_flash_init_default_chip+0x4a>
        cfg.using_timing_tuning = 1;
4200a0f1:	180c      	movi.n	a8, 1
4200a0f3:	2a4182        	s8i	a8, a1, 42
        spi_timing_get_flash_timing_param(&cfg.timing_reg);
4200a0f6:	01ad      	mov.n	a10, a1
4200a0f8:	daac81        	l32r	a8, 42000ba8 <_stext+0xb88> (403784cc <spi_timing_get_flash_timing_param>)
4200a0fb:	0008e0        	callx8	a8
    }
    #endif // SOC_SPI_MEM_SUPPORT_TIMING_TUNING

    cfg.clock_src_freq = spi_flash_ll_get_source_clock_freq_mhz(cfg.host_id);
4200a0fe:	8188      	l32i.n	a8, a1, 32
4200a100:	58cc      	bnez.n	a8, 4200a109 <esp_flash_init_default_chip+0x55>
4200a102:	fff365        	call8	4200a038 <spimem_flash_ll_get_source_freq_mhz>
4200a105:	000086        	j	4200a10b <esp_flash_init_default_chip+0x57>
4200a108:	0a5c00        	add.s	f5, f12, f0
4200a10b:	d1a9      	s32i.n	a10, a1, 52
    #if CONFIG_SPI_FLASH_AUTO_CHECK_SUSPEND_STATUS
    cfg.auto_waiti_pes = true;
    #endif

    //the host is already initialized, only do init for the data and load it to the host
    esp_err_t err = memspi_host_init_pointers(&esp_flash_default_host, &cfg);
4200a10d:	01bd      	mov.n	a11, a1
4200a10f:	da9fa1        	l32r	a10, 42000b8c <_stext+0xb6c> (3fc936b8 <esp_flash_default_host>)
4200a112:	daa681        	l32r	a8, 42000bac <_stext+0xb8c> (403801a8 <memspi_host_init_pointers>)
4200a115:	0008e0        	callx8	a8
4200a118:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4200a11a:	0bba56        	bnez	a10, 4200a1d9 <esp_flash_init_default_chip+0x125>
        return err;
    }

    // ROM TODO: account for non-standard default pins in efuse
    // ROM TODO: to account for chips which are slow to power on, maybe keep probing in a loop here
    err = esp_flash_init_main(&default_chip);
4200a11d:	da9aa1        	l32r	a10, 42000b88 <_stext+0xb68> (3fc93698 <default_chip>)
4200a120:	daa481        	l32r	a8, 42000bb0 <_stext+0xb90> (40377d30 <esp_flash_init_main>)
4200a123:	0008e0        	callx8	a8
4200a126:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4200a128:	0ada56        	bnez	a10, 4200a1d9 <esp_flash_init_default_chip+0x125>
        return err;
    }
    if (default_chip.size < legacy_chip->chip_size) {
4200a12b:	da9781        	l32r	a8, 42000b88 <_stext+0xb68> (3fc93698 <default_chip>)
4200a12e:	5888      	l32i.n	a8, a8, 20
4200a130:	012792        	l32i	a9, a7, 4
4200a133:	31b897        	bgeu	a8, a9, 4200a168 <esp_flash_init_default_chip+0xb4>
4200a136:	d7bd81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200a139:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Detected size(%dk) smaller than the size in the binary image header(%dk). Probe failed.", default_chip.size/1024, legacy_chip->chip_size/1024);
4200a13c:	020816        	beqz	a8, 4200a160 <esp_flash_init_default_chip+0xac>
4200a13f:	d7c881        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a142:	0008e0        	callx8	a8
4200a145:	da9081        	l32r	a8, 42000b88 <_stext+0xb68> (3fc93698 <default_chip>)
4200a148:	58d8      	l32i.n	a13, a8, 20
4200a14a:	17e8      	l32i.n	a14, a7, 4
4200a14c:	41eae0        	srli	a14, a14, 10
4200a14f:	41dad0        	srli	a13, a13, 10
4200a152:	da8bc1        	l32r	a12, 42000b80 <_stext+0xb60> (3c028af0 <TAG>)
4200a155:	0abd      	mov.n	a11, a10
4200a157:	da8ea1        	l32r	a10, 42000b90 <_stext+0xb70> (3c026730 <_flash_rodata_start+0x6610>)
4200a15a:	d7c281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200a15d:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_SIZE_NOT_MATCH;
4200a160:	04a122        	movi	a2, 0x104
4200a163:	001c86        	j	4200a1d9 <esp_flash_init_default_chip+0x125>
4200a166:	870000        	lsi	f0, a0, 0x21c
    }

    if (default_chip.size > legacy_chip->chip_size) {
4200a169:	28b9      	s32i.n	a11, a8, 8
4200a16b:	d7b081        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200a16e:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGW(TAG, "Detected size(%dk) larger than the size in the binary image header(%dk). Using the size in the binary image header.", default_chip.size/1024, legacy_chip->chip_size/1024);
4200a170:	2028b6        	bltui	a8, 2, 4200a194 <esp_flash_init_default_chip+0xe0>
4200a173:	d7bb81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a176:	0008e0        	callx8	a8
4200a179:	da8381        	l32r	a8, 42000b88 <_stext+0xb68> (3fc93698 <default_chip>)
4200a17c:	58d8      	l32i.n	a13, a8, 20
4200a17e:	17e8      	l32i.n	a14, a7, 4
4200a180:	41eae0        	srli	a14, a14, 10
4200a183:	41dad0        	srli	a13, a13, 10
4200a186:	da7ec1        	l32r	a12, 42000b80 <_stext+0xb60> (3c028af0 <TAG>)
4200a189:	0abd      	mov.n	a11, a10
4200a18b:	da82a1        	l32r	a10, 42000b94 <_stext+0xb74> (3c026798 <_flash_rodata_start+0x6678>)
4200a18e:	d7b581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200a191:	0008e0        	callx8	a8
    }
#if !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM // IDF-10019
    if (legacy_chip->chip_size > 16 * 1024 * 1024) {
4200a194:	1788      	l32i.n	a8, a7, 4
4200a196:	d80591        	l32r	a9, 420001ac <_stext+0x18c> (1000000 <UserFrameTotalSize+0xffff00>)
4200a199:	30b987        	bgeu	a9, a8, 4200a1cd <esp_flash_init_default_chip+0x119>
        ESP_RETURN_ON_ERROR_ISR(esp_mspi_32bit_address_flash_feature_check(), TAG, "32bit address feature check failed");
4200a19c:	da8681        	l32r	a8, 42000bb4 <_stext+0xb94> (40378150 <esp_mspi_32bit_address_flash_feature_check>)
4200a19f:	0008e0        	callx8	a8
4200a1a2:	0a6d      	mov.n	a6, a10
4200a1a4:	5aac      	beqz.n	a10, 4200a1cd <esp_flash_init_default_chip+0x119>
4200a1a6:	d7a181        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4200a1a9:	0888      	l32i.n	a8, a8, 0
4200a1ab:	019816        	beqz	a8, 4200a1c8 <esp_flash_init_default_chip+0x114>
4200a1ae:	d7ac81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a1b1:	0008e0        	callx8	a8
4200a1b4:	9fa1e2        	movi	a14, 0x19f
4200a1b7:	da78d1        	l32r	a13, 42000b98 <_stext+0xb78> (3c028ad4 <__FUNCTION__$1>)
4200a1ba:	da71c1        	l32r	a12, 42000b80 <_stext+0xb60> (3c028af0 <TAG>)
4200a1bd:	0abd      	mov.n	a11, a10
4200a1bf:	da77a1        	l32r	a10, 42000b9c <_stext+0xb7c> (3c02681c <_flash_rodata_start+0x66fc>)
4200a1c2:	d7a881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200a1c5:	0008e0        	callx8	a8
4200a1c8:	062d      	mov.n	a2, a6
4200a1ca:	0002c6        	j	4200a1d9 <esp_flash_init_default_chip+0x125>
    }
#endif // !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM
    // Set chip->size equal to ROM flash size(also equal to the size in binary image header), which means the available size that can be used
    default_chip.size = legacy_chip->chip_size;
4200a1cd:	1798      	l32i.n	a9, a7, 4
4200a1cf:	da6e81        	l32r	a8, 42000b88 <_stext+0xb68> (3fc93698 <default_chip>)
4200a1d2:	5899      	s32i.n	a9, a8, 20

    esp_flash_default_chip = &default_chip;
4200a1d4:	da7391        	l32r	a9, 42000ba0 <_stext+0xb80> (3fc95108 <esp_flash_default_chip>)
4200a1d7:	0989      	s32i.n	a8, a9, 0
        default_chip.hpm_dummy_ena = 1;
    }
#endif

    return ESP_OK;
}
4200a1d9:	f01d      	retw.n
	...

4200a1dc <esp_flash_app_init>:

esp_err_t esp_flash_app_init(void)
{
4200a1dc:	004136        	entry	a1, 32
    };
    err = esp_ldo_acquire_channel(&ldo_config, &s_ldo_chan);
    if (err != ESP_OK) return err;
#endif // CONFIG_ESP_LDO_RESERVE_SPI_NOR_FLASH

    spi_flash_init_lock();
4200a1df:	ffc265        	call8	42009e04 <spi_flash_init_lock>
    spi_flash_guard_set(&g_flash_guard_default_ops);
4200a1e2:	da75a1        	l32r	a10, 42000bb8 <_stext+0xb98> (3fc93670 <g_flash_guard_default_ops>)
4200a1e5:	da7581        	l32r	a8, 42000bbc <_stext+0xb9c> (40377b14 <spi_flash_guard_set>)
4200a1e8:	0008e0        	callx8	a8
#endif
#if CONFIG_SPI_FLASH_SHARE_SPI1_BUS
    err = esp_flash_init_main_bus_lock();
    if (err != ESP_OK) return err;
#endif
    err = esp_flash_app_enable_os_functions(&default_chip);
4200a1eb:	da67a1        	l32r	a10, 42000b88 <_stext+0xb68> (3fc93698 <default_chip>)
4200a1ee:	0000a5        	call8	4200a1f8 <esp_flash_app_enable_os_functions>
    return err;
}
4200a1f1:	202aa0        	or	a2, a10, a10
4200a1f4:	000090        	retw
	...

4200a1f8 <esp_flash_app_enable_os_functions>:
{
4200a1f8:	004136        	entry	a1, 32
    main_flash_arg = (app_func_arg_t) {
4200a1fb:	da7181        	l32r	a8, 42000bc0 <_stext+0xba0> (3c029340 <g_spi_lock_main_flash_dev>)
4200a1fe:	0868      	l32i.n	a6, a8, 0
4200a200:	da7171        	l32r	a7, 42000bc4 <_stext+0xba4> (3fc93710 <main_flash_arg>)
4200a203:	0c1c      	movi.n	a12, 16
4200a205:	0b0c      	movi.n	a11, 0
4200a207:	20a770        	or	a10, a7, a7
4200a20a:	d83d81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200a20d:	0008e0        	callx8	a8
4200a210:	0769      	s32i.n	a6, a7, 0
    chip->os_func = &esp_flash_spi1_default_os_functions;
4200a212:	da6d81        	l32r	a8, 42000bc8 <_stext+0xba8> (3fc936e8 <esp_flash_spi1_default_os_functions>)
4200a215:	2289      	s32i.n	a8, a2, 8
    chip->os_func_data = &main_flash_arg;
4200a217:	3279      	s32i.n	a7, a2, 12
}
4200a219:	020c      	movi.n	a2, 0
4200a21b:	f01d      	retw.n
4200a21d:	000000        	ill

4200a220 <esp_crosscore_int_init>:
{
4200a220:	004136        	entry	a1, 32
4200a223:	fb7c      	movi.n	a11, -1
4200a225:	da69a1        	l32r	a10, 42000bcc <_stext+0xbac> (3fc92794 <reason_spinlock>)
4200a228:	d87a81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200a22b:	0008e0        	callx8	a8
    asm volatile (
4200a22e:	03eb80        	rsr.prid	a8
4200a231:	048d80        	extui	a8, a8, 13, 1
    reason[esp_cpu_get_core_id()] = 0;
4200a234:	da6791        	l32r	a9, 42000bd0 <_stext+0xbb0> (3fc95114 <reason>)
4200a237:	a08890        	addx4	a8, a8, a9
4200a23a:	090c      	movi.n	a9, 0
4200a23c:	0020c0        	memw
4200a23f:	006892        	s32i	a9, a8, 0
    portEXIT_CRITICAL(&reason_spinlock);
4200a242:	da62a1        	l32r	a10, 42000bcc <_stext+0xbac> (3fc92794 <reason_spinlock>)
4200a245:	d87381        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200a248:	0008e0        	callx8	a8
4200a24b:	03eb80        	rsr.prid	a8
4200a24e:	048d80        	extui	a8, a8, 13, 1
    if (esp_cpu_get_core_id() == 0) {
4200a251:	48dc      	bnez.n	a8, 4200a269 <esp_crosscore_int_init+0x49>
        err = esp_intr_alloc(ETS_FROM_CPU_INTR0_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[0], NULL);
4200a253:	0e0c      	movi.n	a14, 0
4200a255:	da5ed1        	l32r	a13, 42000bd0 <_stext+0xbb0> (3fc95114 <reason>)
4200a258:	da5fc1        	l32r	a12, 42000bd4 <_stext+0xbb4> (40378028 <esp_crosscore_isr>)
4200a25b:	00a4b2        	movi	a11, 0x400
4200a25e:	4fa0a2        	movi	a10, 79
4200a261:	f96f25        	call8	42003954 <esp_intr_alloc>
4200a264:	0004c6        	j	4200a27b <esp_crosscore_int_init+0x5b>
4200a267:	e20000        	remu	a0, a0, a0
        err = esp_intr_alloc(ETS_FROM_CPU_INTR1_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[1], NULL);
4200a26a:	d100a0        	mul16s	a0, a0, a10
4200a26d:	da5b      	addi.n	a13, a10, 5
4200a26f:	da59c1        	l32r	a12, 42000bd4 <_stext+0xbb4> (40378028 <esp_crosscore_isr>)
4200a272:	00a4b2        	movi	a11, 0x400
4200a275:	50a0a2        	movi	a10, 80
4200a278:	f96da5        	call8	42003954 <esp_intr_alloc>
    ESP_ERROR_CHECK(err);
4200a27b:	011a16        	beqz	a10, 4200a290 <esp_crosscore_int_init+0x70>
4200a27e:	da57e1        	l32r	a14, 42000bdc <_stext+0xbbc> (3c0268f4 <_flash_rodata_start+0x67d4>)
4200a281:	da57d1        	l32r	a13, 42000be0 <_stext+0xbc0> (3c028b30 <__func__$1>)
4200a284:	6ca0c2        	movi	a12, 108
4200a287:	da57b1        	l32r	a11, 42000be4 <_stext+0xbc4> (3c0268f8 <_flash_rodata_start+0x67d8>)
4200a28a:	da5781        	l32r	a8, 42000be8 <_stext+0xbc8> (40379760 <_esp_error_check_failed>)
4200a28d:	0008e0        	callx8	a8
}
4200a290:	f01d      	retw.n
	...

4200a294 <esp_rom_efuse_get_opiconfig>:
/**
 * Since rom of esp32s3 does not export function ets_efuse_get_opiconfig,
 * patch this function here.
 */
uint32_t esp_rom_efuse_get_opiconfig(void)
{
4200a294:	004136        	entry	a1, 32
    uint64_t spiconfig1 = REG_GET_FIELD(EFUSE_RD_MAC_SPI_SYS_2_REG, EFUSE_SPI_PAD_CONF_1);
4200a297:	da5581        	l32r	a8, 42000bec <_stext+0xbcc> (6000704c <EFUSE+0x4c>)
4200a29a:	0020c0        	memw
4200a29d:	0898      	l32i.n	a9, a8, 0
    uint64_t spiconfig2 = REG_GET_FIELD(EFUSE_RD_MAC_SPI_SYS_3_REG, EFUSE_SPI_PAD_CONF_2);
4200a29f:	da5481        	l32r	a8, 42000bf0 <_stext+0xbd0> (60007050 <EFUSE+0x50>)
4200a2a2:	0020c0        	memw
4200a2a5:	0888      	l32i.n	a8, a8, 0
4200a2a7:	118820        	slli	a8, a8, 14
4200a2aa:	418e80        	srli	a8, a8, 14
    uint64_t opiconfig = (spiconfig2 << 12) | (spiconfig1 >> 20);
4200a2ad:	118840        	slli	a8, a8, 12
4200a2b0:	b59490        	extui	a9, a9, 20, 12
4200a2b3:	202890        	or	a2, a8, a9
    if (opiconfig == 0 || opiconfig == 0x3fffffffllu) {
4200a2b6:	40f280        	nsau	a8, a2
4200a2b9:	418580        	srli	a8, a8, 5
4200a2bc:	d80691        	l32r	a9, 420002d4 <_stext+0x2b4> (3fffffff <ets_rom_layout_p+0xe0003>)
4200a2bf:	309290        	xor	a9, a2, a9
4200a2c2:	40f990        	nsau	a9, a9
4200a2c5:	419590        	srli	a9, a9, 5
4200a2c8:	208890        	or	a8, a8, a9
4200a2cb:	188c      	beqz.n	a8, 4200a2d0 <esp_rom_efuse_get_opiconfig+0x3c>
        return 0;
4200a2cd:	00a022        	movi	a2, 0
    // [42:47] -- D4
    // [48:53] -- D5
    // [54:59] -- D6
    // [60:65] -- D7
    return opiconfig & 0x3fffffff;
}
4200a2d0:	f01d      	retw.n
	...

4200a2d4 <gpspi_flash_ll_calculate_clock_reg>:
 * @param clkdiv frequency division factor
 *
 * @return Register setting for the given clock division factor.
 */
static inline uint32_t gpspi_flash_ll_calculate_clock_reg(uint8_t clkdiv)
{
4200a2d4:	004136        	entry	a1, 32
    uint32_t div_parameter;
    // See comments of `clock` in `spi_struct.h`
    if (clkdiv == 1) {
4200a2d7:	211226        	beqi	a2, 1, 4200a2fc <gpspi_flash_ll_calculate_clock_reg+0x28>
        div_parameter = (1 << 31);
    } else {
        div_parameter = ((clkdiv - 1) | (((clkdiv / 2 - 1) & 0xff) << 6) | (((clkdiv - 1) & 0xff) << 12));
4200a2da:	820b      	addi.n	a8, a2, -1
4200a2dc:	412120        	srli	a2, a2, 1
4200a2df:	220b      	addi.n	a2, a2, -1
4200a2e1:	1122a0        	slli	a2, a2, 6
4200a2e4:	742620        	extui	a2, a2, 6, 8
4200a2e7:	1122a0        	slli	a2, a2, 6
4200a2ea:	202820        	or	a2, a8, a2
4200a2ed:	118840        	slli	a8, a8, 12
4200a2f0:	748c80        	extui	a8, a8, 12, 8
4200a2f3:	118840        	slli	a8, a8, 12
4200a2f6:	202280        	or	a2, a2, a8
4200a2f9:	000086        	j	4200a2ff <gpspi_flash_ll_calculate_clock_reg+0x2b>
        div_parameter = (1 << 31);
4200a2fc:	da3e21        	l32r	a2, 42000bf4 <_stext+0xbd4> (80000000 <_rtc_reserved_end+0x1ff00000>)
    }
    return div_parameter;
}
4200a2ff:	f01d      	retw.n
4200a301:	000000        	ill

4200a304 <spimem_flash_ll_calculate_clock_reg>:
{
4200a304:	004136        	entry	a1, 32
    if (clkdiv == 1) {
4200a307:	211226        	beqi	a2, 1, 4200a32c <spimem_flash_ll_calculate_clock_reg+0x28>
        div_parameter = ((clkdiv - 1) | (((clkdiv - 1) / 2 & 0xff) << 8) | (((clkdiv - 1) & 0xff) << 16));
4200a30a:	220b      	addi.n	a2, a2, -1
4200a30c:	058f20        	extui	a8, a2, 31, 1
4200a30f:	882a      	add.n	a8, a8, a2
4200a311:	218180        	srai	a8, a8, 1
4200a314:	118880        	slli	a8, a8, 8
4200a317:	f48080        	extui	a8, a8, 0, 16
4200a31a:	208280        	or	a8, a2, a8
4200a31d:	112200        	slli	a2, a2, 16
4200a320:	752020        	extui	a2, a2, 16, 8
4200a323:	112200        	slli	a2, a2, 16
4200a326:	202820        	or	a2, a8, a2
4200a329:	000086        	j	4200a32f <spimem_flash_ll_calculate_clock_reg+0x2b>
        div_parameter = (1 << 31);
4200a32c:	da3221        	l32r	a2, 42000bf4 <_stext+0xbd4> (80000000 <_rtc_reserved_end+0x1ff00000>)
}
4200a32f:	f01d      	retw.n
4200a331:	000000        	ill

4200a334 <extra_dummy_under_timing_tuning>:
    return apb_period_n / apbclk_n;
}

#if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
static inline int extra_dummy_under_timing_tuning(const spi_flash_hal_config_t *cfg)
{
4200a334:	004136        	entry	a1, 32
    bool main_flash = (cfg->host_id == SPI1_HOST && cfg->cs_num == 0);
4200a337:	8288      	l32i.n	a8, a2, 32
4200a339:	38cc      	bnez.n	a8, 4200a340 <extra_dummy_under_timing_tuning+0xc>
4200a33b:	092282        	l32i	a8, a2, 36
4200a33e:	488c      	beqz.n	a8, 4200a346 <extra_dummy_under_timing_tuning+0x12>
         * Instead, for both Quad and Octal Flash, we use `usr_dummy` and set the whole dummy length (usr_dummy + extra_dummy) to this register.
         */
        extra_dummy = cfg->extra_dummy;
    } else {
        // TODO: for other flash chips, dummy get logic implement here. Currently, still calculate extra dummy by itself.
        abort();
4200a340:	d76d81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200a343:	0008e0        	callx8	a8
        extra_dummy = cfg->extra_dummy;
4200a346:	0228      	l32i.n	a2, a2, 0
    }

    return extra_dummy;
}
4200a348:	f01d      	retw.n
	...

4200a34c <get_flash_clock_divider>:
{
4200a34c:	006136        	entry	a1, 48
    const int clk_source   = cfg->clock_src_freq;
4200a34f:	d2a8      	l32i.n	a10, a2, 52
    const int clk_freq_mhz = cfg->freq_mhz;
4200a351:	c278      	l32i.n	a7, a2, 48
    if (clk_source < clk_freq_mhz) {
4200a353:	1faa77        	bge	a10, a7, 4200a376 <get_flash_clock_divider+0x2a>
        HAL_LOGE(TAG, "Target frequency %dMHz higher than supported.", clk_freq_mhz);
4200a356:	d74281        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a359:	0008e0        	callx8	a8
4200a35c:	da27b1        	l32r	a11, 42000bf8 <_stext+0xbd8> (3c026924 <_flash_rodata_start+0x6804>)
4200a35f:	07fd      	mov.n	a15, a7
4200a361:	0bed      	mov.n	a14, a11
4200a363:	0add      	mov.n	a13, a10
4200a365:	da25c1        	l32r	a12, 42000bfc <_stext+0xbdc> (3c026930 <_flash_rodata_start+0x6810>)
4200a368:	1a0c      	movi.n	a10, 1
4200a36a:	d74a81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200a36d:	0008e0        	callx8	a8
        abort();
4200a370:	d76181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200a373:	0008e0        	callx8	a8
        best_div = (clk_source + clk_freq_mhz - 1) / clk_freq_mhz;
4200a376:	27aa      	add.n	a2, a7, a10
4200a378:	220b      	addi.n	a2, a2, -1
4200a37a:	d22270        	quos	a2, a2, a7
        const div_t res = div(clk_source, clk_freq_mhz);
4200a37d:	20b770        	or	a11, a7, a7
4200a380:	da2181        	l32r	a8, 42000c04 <_stext+0xbe4> (40001464 <div>)
4200a383:	0008e0        	callx8	a8
4200a386:	01a9      	s32i.n	a10, a1, 0
4200a388:	11b9      	s32i.n	a11, a1, 4
        if (res.rem != 0) {
4200a38a:	1188      	l32i.n	a8, a1, 4
4200a38c:	889c      	beqz.n	a8, 4200a3a8 <get_flash_clock_divider+0x5c>
            HAL_LOGW(TAG, "Flash clock frequency round down to %d", res.quot);
4200a38e:	d73481        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a391:	0008e0        	callx8	a8
4200a394:	da19b1        	l32r	a11, 42000bf8 <_stext+0xbd8> (3c026924 <_flash_rodata_start+0x6804>)
4200a397:	01f8      	l32i.n	a15, a1, 0
4200a399:	0bed      	mov.n	a14, a11
4200a39b:	0add      	mov.n	a13, a10
4200a39d:	da18c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c02696c <_flash_rodata_start+0x684c>)
4200a3a0:	2a0c      	movi.n	a10, 2
4200a3a2:	d73c81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200a3a5:	0008e0        	callx8	a8
}
4200a3a8:	f01d      	retw.n
	...

4200a3ac <spi_flash_cal_clock>:
{
4200a3ac:	004136        	entry	a1, 32
4200a3af:	20a220        	or	a10, a2, a2
    uint32_t div_parameter = spi_flash_ll_calculate_clock_reg(cfg->host_id, get_flash_clock_divider(cfg));
4200a3b2:	082282        	l32i	a8, a2, 32
4200a3b5:	010856        	bnez	a8, 4200a3c9 <spi_flash_cal_clock+0x1d>
4200a3b8:	fff925        	call8	4200a34c <get_flash_clock_divider>
4200a3bb:	74a0a0        	extui	a10, a10, 0, 8
4200a3be:	fff465        	call8	4200a304 <spimem_flash_ll_calculate_clock_reg>
4200a3c1:	0a2d      	mov.n	a2, a10
4200a3c3:	000386        	j	4200a3d5 <spi_flash_cal_clock+0x29>
4200a3c6:	000000        	ill
4200a3c9:	fff825        	call8	4200a34c <get_flash_clock_divider>
4200a3cc:	74a0a0        	extui	a10, a10, 0, 8
4200a3cf:	fff065        	call8	4200a2d4 <gpspi_flash_ll_calculate_clock_reg>
4200a3d2:	202aa0        	or	a2, a10, a10
}
4200a3d5:	000090        	retw

4200a3d8 <spi_flash_hal_init>:
#endif //SOC_SPI_MEM_SUPPORT_TIMING_TUNING

esp_err_t spi_flash_hal_init(spi_flash_hal_context_t *data_out, const spi_flash_hal_config_t *cfg)
{
4200a3d8:	006136        	entry	a1, 48
    if (cfg->cs_num >= SOC_SPI_PERIPH_CS_NUM(cfg->host_id)) {
4200a3db:	9378      	l32i.n	a7, a3, 36
4200a3dd:	8388      	l32i.n	a8, a3, 32
4200a3df:	688c      	beqz.n	a8, 4200a3e9 <spi_flash_hal_init+0x11>
4200a3e1:	091866        	bnei	a8, 1, 4200a3ee <spi_flash_hal_init+0x16>
4200a3e4:	690c      	movi.n	a9, 6
4200a3e6:	000186        	j	4200a3f0 <spi_flash_hal_init+0x18>
4200a3e9:	290c      	movi.n	a9, 2
4200a3eb:	000046        	j	4200a3f0 <spi_flash_hal_init+0x18>
4200a3ee:	390c      	movi.n	a9, 3
4200a3f0:	022797        	blt	a7, a9, 4200a3f6 <spi_flash_hal_init+0x1e>
4200a3f3:	003f46        	j	4200a4f4 <spi_flash_hal_init+0x11c>
        return ESP_ERR_INVALID_ARG;
    }

    *data_out = (spi_flash_hal_context_t) {
        .inst = data_out->inst, // Keeps the function pointer table
4200a3f6:	0248      	l32i.n	a4, a2, 0
4200a3f8:	0a1826        	beqi	a8, 1, 4200a406 <spi_flash_hal_init+0x2e>
4200a3fb:	0f2826        	beqi	a8, 2, 4200a40e <spi_flash_hal_init+0x36>
4200a3fe:	689c      	beqz.n	a8, 4200a418 <spi_flash_hal_init+0x40>
        .spi = spi_flash_ll_get_hw(cfg->host_id),
4200a400:	d73d81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200a403:	0008e0        	callx8	a8
        .inst = data_out->inst, // Keeps the function pointer table
4200a406:	da0181        	l32r	a8, 42000c0c <_stext+0xbec> (60024000 <GPSPI2>)
4200a409:	2189      	s32i.n	a8, a1, 8
4200a40b:	0003c6        	j	4200a41e <spi_flash_hal_init+0x46>
4200a40e:	da0081        	l32r	a8, 42000c10 <_stext+0xbf0> (60025000 <GPSPI3>)
4200a411:	2189      	s32i.n	a8, a1, 8
4200a413:	0001c6        	j	4200a41e <spi_flash_hal_init+0x46>
4200a416:	810000        	src	a0, a0, a0
4200a419:	d9fc      	bnez.n	a9, 4200a45a <spi_flash_hal_init+0x82>
4200a41b:	026182        	s32i	a8, a1, 8
        .cs_num = cfg->cs_num,
        .cs_hold = cfg->cs_hold,
        .cs_setup = cfg->cs_setup,
4200a41e:	0c0352        	l8ui	a5, a3, 12
        .cs_hold = cfg->cs_hold,
4200a421:	022362        	l32i	a6, a3, 8
        .base_io_mode = cfg->default_io_mode,
4200a424:	0b2382        	l32i	a8, a3, 44
4200a427:	0189      	s32i.n	a8, a1, 0
        .freq_mhz = cfg->freq_mhz,
4200a429:	c398      	l32i.n	a9, a3, 48
4200a42b:	1199      	s32i.n	a9, a1, 4
    *data_out = (spi_flash_hal_context_t) {
4200a42d:	0c3c      	movi.n	a12, 48
4200a42f:	0b0c      	movi.n	a11, 0
4200a431:	02ad      	mov.n	a10, a2
4200a433:	d7b381        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200a436:	0008e0        	callx8	a8
4200a439:	0249      	s32i.n	a4, a2, 0
4200a43b:	21a8      	l32i.n	a10, a1, 8
4200a43d:	12a9      	s32i.n	a10, a2, 4
4200a43f:	2279      	s32i.n	a7, a2, 8
4200a441:	0e4252        	s8i	a5, a2, 14
4200a444:	0f4262        	s8i	a6, a2, 15
4200a447:	0188      	l32i.n	a8, a1, 0
4200a449:	5289      	s32i.n	a8, a2, 20
4200a44b:	1198      	l32i.n	a9, a1, 4
4200a44d:	a299      	s32i.n	a9, a2, 40
    };
#if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    if (cfg->using_timing_tuning) {
4200a44f:	2a0382        	l8ui	a8, a3, 42
4200a452:	489c      	beqz.n	a8, 4200a46a <spi_flash_hal_init+0x92>
        data_out->extra_dummy = extra_dummy_under_timing_tuning(cfg);
4200a454:	03ad      	mov.n	a10, a3
4200a456:	ffede5        	call8	4200a334 <extra_dummy_under_timing_tuning>
4200a459:	0c42a2        	s8i	a10, a2, 12
        data_out->fdummy_rin = cfg->fdummy_rin;
4200a45c:	1388      	l32i.n	a8, a3, 4
4200a45e:	0d4282        	s8i	a8, a2, 13
        data_out->clock_conf = cfg->clock_config;
4200a461:	4388      	l32i.n	a8, a3, 16
4200a463:	4289      	s32i.n	a8, a2, 16
4200a465:	001146        	j	4200a4ae <spi_flash_hal_init+0xd6>
4200a468:	720000        	lsi	f0, a0, 0x1c8
    } else
#endif // SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    {
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
4200a46b:	300623        	lsi	f2, a6, 192
4200a46e:	a520a3        	lsi	f10, a0, 0x294
4200a471:	ffed      	lsi	f14, a15, 60
4200a473:	d9e881        	l32r	a8, 42000c14 <_stext+0xbf4> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
4200a476:	c2a8a0        	quou	a10, a8, a10
    const int apbclk_n = APB_CLK_FREQ / eff_clk;
4200a479:	d2a8a0        	quos	a10, a8, a10
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
4200a47c:	01c782        	addi	a8, a7, 1
4200a47f:	a08880        	addx4	a8, a8, a8
4200a482:	1188c0        	slli	a8, a8, 4
4200a485:	d77791        	l32r	a9, 42000264 <_stext+0x244> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
4200a488:	b29890        	mulsh	a9, a8, a9
4200a48b:	219690        	srai	a9, a9, 6
4200a48e:	31bf80        	srai	a11, a8, 31
4200a491:	c099b0        	sub	a9, a9, a11
    if (apb_period_n < 0) {
4200a494:	19acb2        	movi	a11, 0xfffffc19
4200a497:	01a8b7        	bge	a8, a11, 4200a49c <spi_flash_hal_init+0xc4>
        apb_period_n = 0;
4200a49a:	090c      	movi.n	a9, 0
    return apb_period_n / apbclk_n;
4200a49c:	d299a0        	quos	a9, a9, a10
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
4200a49f:	0c4292        	s8i	a9, a2, 12
        data_out->clock_conf = (spi_flash_ll_clock_reg_t)spi_flash_cal_clock(cfg);
4200a4a2:	20a330        	or	a10, a3, a3
4200a4a5:	fff065        	call8	4200a3ac <spi_flash_cal_clock>
4200a4a8:	0020c0        	memw
4200a4ab:	0462a2        	s32i	a10, a2, 16
    }


    if (cfg->auto_sus_en) {
4200a4ae:	280382        	l8ui	a8, a3, 40
4200a4b1:	01b816        	beqz	a8, 4200a4d0 <spi_flash_hal_init+0xf8>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND;
4200a4b4:	6288      	l32i.n	a8, a2, 24
4200a4b6:	190c      	movi.n	a9, 1
4200a4b8:	209890        	or	a9, a8, a9
4200a4bb:	6299      	s32i.n	a9, a2, 24
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME;
4200a4bd:	390c      	movi.n	a9, 3
4200a4bf:	208890        	or	a8, a8, a9
4200a4c2:	6289      	s32i.n	a8, a2, 24
        data_out->tsus_val = cfg->tsus_val;
4200a4c4:	380382        	l8ui	a8, a3, 56
4200a4c7:	2c4282        	s8i	a8, a2, 44
        data_out->auto_waiti_pes = cfg->auto_waiti_pes;
4200a4ca:	390382        	l8ui	a8, a3, 57
4200a4cd:	2d4282        	s8i	a8, a2, 45
#if CONFIG_SPI_FLASH_SOFTWARE_RESUME
    data_out->flags &= ~SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME;
#endif

#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    if (cfg->octal_mode_en) {
4200a4d0:	290382        	l8ui	a8, a3, 41
4200a4d3:	788c      	beqz.n	a8, 4200a4de <spi_flash_hal_init+0x106>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_OCTAL_MODE;
4200a4d5:	6288      	l32i.n	a8, a2, 24
4200a4d7:	490c      	movi.n	a9, 4
4200a4d9:	208890        	or	a8, a8, a9
4200a4dc:	6289      	s32i.n	a8, a2, 24
    }

    if (cfg->default_io_mode == SPI_FLASH_OPI_DTR) {
4200a4de:	b398      	l32i.n	a9, a3, 44
4200a4e0:	181c      	movi.n	a8, 17
4200a4e2:	149987        	bne	a9, a8, 4200a4fa <spi_flash_hal_init+0x122>
        data_out->slicer_flags |= SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR;
4200a4e5:	9288      	l32i.n	a8, a2, 36
4200a4e7:	190c      	movi.n	a9, 1
4200a4e9:	208890        	or	a8, a8, a9
4200a4ec:	9289      	s32i.n	a8, a2, 36
    }
#endif

    return ESP_OK;
4200a4ee:	020c      	movi.n	a2, 0
4200a4f0:	000206        	j	4200a4fc <spi_flash_hal_init+0x124>
4200a4f3:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4200a4f6:	004602        	s8i	a0, a6, 0
4200a4f9:	020c00        	andb	b0, b12, b0
}
4200a4fc:	f01d      	retw.n
	...

4200a500 <spi_flash_hal_supports_direct_write>:

bool spi_flash_hal_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
4200a500:	004136        	entry	a1, 32
    (void)p;
    bool direct_write = (((spi_flash_hal_context_t *)host)->spi != spi_flash_ll_get_hw(SPI1_HOST));
4200a503:	1228      	l32i.n	a2, a2, 4
4200a505:	d9c081        	l32r	a8, 42000c08 <_stext+0xbe8> (60002000 <SPIMEM1>)
4200a508:	c02280        	sub	a2, a2, a8
    return direct_write;
}
4200a50b:	180c      	movi.n	a8, 1
4200a50d:	932820        	movnez	a2, a8, a2
4200a510:	f01d      	retw.n
	...

4200a514 <spi_flash_hal_supports_direct_read>:


bool spi_flash_hal_supports_direct_read(spi_flash_host_inst_t *host, const void *p)
{
4200a514:	004136        	entry	a1, 32
    (void)p;
    //currently the host doesn't support to read through dma, no word-aligned requirements
    bool direct_read = ( ((spi_flash_hal_context_t *)host)->spi != spi_flash_ll_get_hw(SPI1_HOST));
4200a517:	1228      	l32i.n	a2, a2, 4
4200a519:	d9bb81        	l32r	a8, 42000c08 <_stext+0xbe8> (60002000 <SPIMEM1>)
4200a51c:	c02280        	sub	a2, a2, a8
    return direct_read;
}
4200a51f:	180c      	movi.n	a8, 1
4200a521:	932820        	movnez	a2, a8, a2
4200a524:	f01d      	retw.n
	...

4200a528 <esp_cpu_configure_region_protection>:

#include <stdint.h>
#include "hal/mpu_hal.h"

void esp_cpu_configure_region_protection(void)
{
4200a528:	008136        	entry	a1, 64
    /* Note: currently this is configured the same on all Xtensa targets
     *
     * Both chips have the address space divided into 8 regions, 512MB each.
     */
    const int illegal_regions[] = {0, 4, 5, 6, 7}; // 0x00000000, 0x80000000, 0xa0000000, 0xc0000000, 0xe0000000
4200a52b:	4c1c      	movi.n	a12, 20
4200a52d:	d9bab1        	l32r	a11, 42000c18 <_stext+0xbf8> (3c02932c <rtc_io_num_map+0xc4>)
4200a530:	01ad      	mov.n	a10, a1
4200a532:	d6bd81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200a535:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
4200a538:	070c      	movi.n	a7, 0
4200a53a:	000346        	j	4200a54b <esp_cpu_configure_region_protection+0x23>
        mpu_hal_set_region_access(illegal_regions[i], MPU_REGION_ILLEGAL);
4200a53d:	a08710        	addx4	a8, a7, a1
4200a540:	00a0b2        	movi	a11, 0
4200a543:	0028a2        	l32i	a10, a8, 0
4200a546:	0b51a5        	call8	42015a60 <mpu_hal_set_region_access>
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
4200a549:	771b      	addi.n	a7, a7, 1
4200a54b:	ee57b6        	bltui	a7, 5, 4200a53d <esp_cpu_configure_region_protection+0x15>
    }

    mpu_hal_set_region_access(1, MPU_REGION_RW); // 0x20000000
4200a54e:	1b0c      	movi.n	a11, 1
4200a550:	0bad      	mov.n	a10, a11
4200a552:	0b50e5        	call8	42015a60 <mpu_hal_set_region_access>
}
4200a555:	f01d      	retw.n
	...

4200a558 <esp_gpio_reserve>:
#include "esp_private/esp_gpio_reserve.h"

static _Atomic uint64_t s_reserved_pin_mask = ATOMIC_VAR_INIT(~(SOC_GPIO_VALID_GPIO_MASK));

uint64_t esp_gpio_reserve(uint64_t gpio_mask)
{
4200a558:	004136        	entry	a1, 32
4200a55b:	02cd      	mov.n	a12, a2
4200a55d:	03dd      	mov.n	a13, a3
    return atomic_fetch_or(&s_reserved_pin_mask, gpio_mask);
4200a55f:	5e0c      	movi.n	a14, 5
4200a561:	d9aea1        	l32r	a10, 42000c1c <_stext+0xbfc> (3fc927a0 <s_reserved_pin_mask>)
4200a564:	d9af81        	l32r	a8, 42000c20 <_stext+0xc00> (4037ff1c <__atomic_fetch_or_8>)
4200a567:	0008e0        	callx8	a8
}
4200a56a:	0a2d      	mov.n	a2, a10
4200a56c:	0b3d      	mov.n	a3, a11
4200a56e:	f01d      	retw.n

4200a570 <_Z41__static_initialization_and_destruction_0v>:
        break;
    }
    return ESP_OK;
}

} // namespace nvs
4200a570:	004136        	entry	a1, 32
const uint32_t nvs::Page::SEC_SIZE = esp_partition_get_main_flash_sector_size();
4200a573:	003c65        	call8	4200a938 <esp_partition_get_main_flash_sector_size>
4200a576:	d9ab81        	l32r	a8, 42000c24 <_stext+0xc04> (3fc9511c <_ZN3nvs4Page8SEC_SIZEE>)
4200a579:	08a9      	s32i.n	a10, a8, 0
} // namespace nvs
4200a57b:	f01d      	retw.n
4200a57d:	000000        	ill

4200a580 <_GLOBAL__sub_I__ZN3nvs4PageC2Ev>:
4200a580:	004136        	entry	a1, 32
4200a583:	fffee5        	call8	4200a570 <_Z41__static_initialization_and_destruction_0v>
4200a586:	f01d      	retw.n

4200a588 <is_partition_encrypted>:
static _lock_t s_partition_list_lock;

static const char *TAG = "partition";

static bool is_partition_encrypted(bool encryption_config, esp_partition_type_t type, esp_partition_subtype_t subtype)
{
4200a588:	004136        	entry	a1, 32
4200a58b:	207220        	or	a7, a2, a2
    (void) subtype;
    (void) encryption_config;
    return false;
#else
    bool ret_encrypted = encryption_config;
    if (!esp_flash_encryption_enabled()) {
4200a58e:	d9a681        	l32r	a8, 42000c28 <_stext+0xc08> (40377680 <esp_flash_encryption_enabled>)
4200a591:	0008e0        	callx8	a8
4200a594:	0a2d      	mov.n	a2, a10
4200a596:	4abc      	beqz.n	a10, 4200a5ce <is_partition_encrypted+0x46>
        /* If flash encryption is not turned on, no partitions should be treated as encrypted */
        ret_encrypted = false;
    } else if (type == ESP_PARTITION_TYPE_APP
4200a598:	40f380        	nsau	a8, a3
4200a59b:	418580        	srli	a8, a8, 5
                || (type == ESP_PARTITION_TYPE_BOOTLOADER)
4200a59e:	fec392        	addi	a9, a3, -2
4200a5a1:	40f990        	nsau	a9, a9
4200a5a4:	419590        	srli	a9, a9, 5
4200a5a7:	208890        	or	a8, a8, a9
    } else if (type == ESP_PARTITION_TYPE_APP
4200a5aa:	08ec      	bnez.n	a8, 4200a5ce <is_partition_encrypted+0x46>
                || (type == ESP_PARTITION_TYPE_PARTITION_TABLE)
4200a5ac:	1e3326        	beqi	a3, 3, 4200a5ce <is_partition_encrypted+0x46>
                || (type == ESP_PARTITION_TYPE_DATA && subtype == ESP_PARTITION_SUBTYPE_DATA_OTA)
4200a5af:	330b      	addi.n	a3, a3, -1
4200a5b1:	40f330        	nsau	a3, a3
4200a5b4:	413530        	srli	a3, a3, 5
4200a5b7:	40f480        	nsau	a8, a4
4200a5ba:	418580        	srli	a8, a8, 5
4200a5bd:	0d8387        	bany	a3, a8, 4200a5ce <is_partition_encrypted+0x46>
                || (type == ESP_PARTITION_TYPE_DATA && subtype == ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS)) {
4200a5c0:	fcc442        	addi	a4, a4, -4
4200a5c3:	40f440        	nsau	a4, a4
4200a5c6:	414540        	srli	a4, a4, 5
4200a5c9:	018347        	bany	a3, a4, 4200a5ce <is_partition_encrypted+0x46>
    bool ret_encrypted = encryption_config;
4200a5cc:	072d      	mov.n	a2, a7
    // FE can be enabled in virt eFuses but not in real eFuses.
    ret_encrypted &= efuse_hal_flash_encryption_enabled();
#endif
    return ret_encrypted;
#endif
}
4200a5ce:	f01d      	retw.n

4200a5d0 <load_partitions>:

// Create linked list of partition_list_item_t structures.
// This function is called only once, with s_partition_list_lock taken.
static esp_err_t load_partitions(void)
{
4200a5d0:	016136        	entry	a1, 176
#if !CONFIG_IDF_TARGET_LINUX
    spi_flash_mmap_handle_t handle;
#endif

    // Temporary list of loaded partitions, if valid then we copy this to s_partition_list
    typeof(s_partition_list) new_partitions_list = SLIST_HEAD_INITIALIZER(s_partition_list);
4200a5d3:	040c      	movi.n	a4, 0
    const uint8_t *md5_part = NULL;
    const uint8_t *stored_md5;
    uint8_t calc_md5[ESP_ROM_MD5_DIGEST_LEN];
    md5_context_t context;

    esp_rom_md5_init(&context);
4200a5d5:	18c1a2        	addi	a10, a1, 24
4200a5d8:	d99c81        	l32r	a8, 42000c48 <_stext+0xc28> (40001c5c <MD5Init>)
4200a5db:	0008e0        	callx8	a8

#if CONFIG_IDF_TARGET_LINUX
    esp_err_t err = esp_partition_file_mmap(&p_start);
    size_t mapped_size = ESP_PARTITION_EMULATED_SECTOR_SIZE;
#else
    esp_err_t err = spi_flash_mmap(partition_align_pg_size,
4200a5de:	e14b      	addi.n	a14, a1, 4
4200a5e0:	01dd      	mov.n	a13, a1
4200a5e2:	04cd      	mov.n	a12, a4
4200a5e4:	d895b1        	l32r	a11, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
4200a5e7:	04ad      	mov.n	a10, a4
4200a5e9:	ff8665        	call8	42009e50 <spi_flash_mmap>
4200a5ec:	0a2d      	mov.n	a2, a10
                                   SPI_FLASH_SEC_SIZE, SPI_FLASH_MMAP_DATA, (const void **)&p_start, &handle);
    size_t mapped_size = SPI_FLASH_SEC_SIZE;
#endif

    if (err != ESP_OK) {
4200a5ee:	14ca56        	bnez	a10, 4200a73e <load_partitions+0x16e>
        return err;
    }

    // calculate partition address within mmap-ed region
    p_start += partition_pad;
4200a5f1:	0138      	l32i.n	a3, a1, 0
4200a5f3:	d70a61        	l32r	a6, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
4200a5f6:	636a      	add.n	a6, a3, a6
4200a5f8:	0169      	s32i.n	a6, a1, 0
    p_end = p_start + mapped_size;
4200a5fa:	d98c81        	l32r	a8, 42000c2c <_stext+0xc0c> (9000 <UserFrameTotalSize+0x8f00>)
4200a5fd:	338a      	add.n	a3, a3, a8
    partition_list_item_t *last = NULL;
4200a5ff:	045d      	mov.n	a5, a4

    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200a601:	002b06        	j	4200a6b1 <load_partitions+0xe1>
        esp_partition_info_t entry;
        // copying to RAM instead of using pointer to flash to avoid any chance of TOCTOU due to cache miss
        // when flash encryption is used
        memcpy(&entry, p_entry, sizeof(entry));
4200a604:	0c2c      	movi.n	a12, 32
4200a606:	06bd      	mov.n	a11, a6
4200a608:	70c1a2        	addi	a10, a1, 112
4200a60b:	d68781        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200a60e:	0008e0        	callx8	a8

#if CONFIG_PARTITION_TABLE_MD5
        if (entry.magic == ESP_PARTITION_MAGIC_MD5) {
4200a611:	381182        	l16ui	a8, a1, 112
4200a614:	d98c91        	l32r	a9, 42000c44 <_stext+0xc24> (ebeb <UserFrameTotalSize+0xeaeb>)
4200a617:	029897        	bne	a8, a9, 4200a61d <load_partitions+0x4d>
4200a61a:	0026c6        	j	4200a6b9 <load_partitions+0xe9>
            md5_part = p_entry;
            break;
        }
#endif
        if (entry.magic != ESP_PARTITION_MAGIC) {
4200a61d:	d98891        	l32r	a9, 42000c40 <_stext+0xc20> (50aa <UserFrameTotalSize+0x4faa>)
4200a620:	021897        	beq	a8, a9, 4200a626 <load_partitions+0x56>
4200a623:	001f46        	j	4200a6a4 <load_partitions+0xd4>
            break;
        }

#if CONFIG_PARTITION_TABLE_MD5
        esp_rom_md5_update(&context, &entry, sizeof(entry));
4200a626:	0c2c      	movi.n	a12, 32
4200a628:	70c1b2        	addi	a11, a1, 112
4200a62b:	18c1a2        	addi	a10, a1, 24
4200a62e:	d98781        	l32r	a8, 42000c4c <_stext+0xc2c> (40001c68 <MD5Update>)
4200a631:	0008e0        	callx8	a8
#endif

        // allocate new linked list item and populate it with data from partition table
        partition_list_item_t *item = (partition_list_item_t *) calloc(1, sizeof(partition_list_item_t));
4200a634:	4b3c      	movi.n	a11, 52
4200a636:	1a0c      	movi.n	a10, 1
4200a638:	d86881        	l32r	a8, 420007d8 <_stext+0x7b8> (4037fea8 <calloc>)
4200a63b:	0008e0        	callx8	a8
4200a63e:	0a7d      	mov.n	a7, a10
        if (item == NULL) {
4200a640:	065a16        	beqz	a10, 4200a6a9 <load_partitions+0xd9>
            break;
        }
#if CONFIG_IDF_TARGET_LINUX
        item->info.flash_chip = NULL;
#else
        item->info.flash_chip = esp_flash_default_chip;
4200a643:	d95781        	l32r	a8, 42000ba0 <_stext+0xb80> (3fc95108 <esp_flash_default_chip>)
4200a646:	0888      	l32i.n	a8, a8, 0
4200a648:	0a89      	s32i.n	a8, a10, 0
#endif
        item->info.address = entry.pos.offset;
4200a64a:	1d2182        	l32i	a8, a1, 116
4200a64d:	3a89      	s32i.n	a8, a10, 12
        item->info.size = entry.pos.size;
4200a64f:	1e2182        	l32i	a8, a1, 120
4200a652:	4a89      	s32i.n	a8, a10, 16
#if CONFIG_IDF_TARGET_LINUX
        item->info.erase_size = ESP_PARTITION_EMULATED_SECTOR_SIZE;
#else
        item->info.erase_size = SPI_FLASH_SEC_SIZE;
4200a654:	d87981        	l32r	a8, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
4200a657:	5a89      	s32i.n	a8, a10, 20
#endif
        item->info.type = entry.type;
4200a659:	7201b2        	l8ui	a11, a1, 114
4200a65c:	1ab9      	s32i.n	a11, a10, 4
        item->info.subtype = entry.subtype;
4200a65e:	7301c2        	l8ui	a12, a1, 115
4200a661:	026ac2        	s32i	a12, a10, 8
        item->info.encrypted = is_partition_encrypted(entry.flags & PART_FLAG_ENCRYPTED, entry.type, entry.subtype);
4200a664:	2321a2        	l32i	a10, a1, 140
4200a667:	04a0a0        	extui	a10, a10, 0, 1
4200a66a:	fff1e5        	call8	4200a588 <is_partition_encrypted>
4200a66d:	2947a2        	s8i	a10, a7, 41
        item->info.readonly = entry.flags & PART_FLAG_READONLY;
4200a670:	232182        	l32i	a8, a1, 140
4200a673:	048180        	extui	a8, a8, 1, 1
4200a676:	2a4782        	s8i	a8, a7, 42
        item->user_registered = false;
4200a679:	080c      	movi.n	a8, 0
4200a67b:	2c4782        	s8i	a8, a7, 44
            ESP_LOGI(TAG, "Ignoring encrypted flag for \"%s\" partition", entry.label);
            item->info.encrypted = false;
        }
#endif
        // item->info.label is initialized by calloc, so resulting string will be null terminated
        strncpy(item->info.label, (const char *) entry.label, sizeof(item->info.label) - 1);
4200a67e:	0c1c      	movi.n	a12, 16
4200a680:	7cc1b2        	addi	a11, a1, 124
4200a683:	18c7a2        	addi	a10, a7, 24
4200a686:	d97281        	l32r	a8, 42000c50 <_stext+0xc30> (40001224 <strncpy>)
4200a689:	0008e0        	callx8	a8

        // add it to the list
        if (last == NULL) {
4200a68c:	55cc      	bnez.n	a5, 4200a695 <load_partitions+0xc5>
            SLIST_INSERT_HEAD(&new_partitions_list, item, next);
4200a68e:	c749      	s32i.n	a4, a7, 48
4200a690:	074d      	mov.n	a4, a7
4200a692:	000146        	j	4200a69b <load_partitions+0xcb>
        } else {
            SLIST_INSERT_AFTER(last, item, next);
4200a695:	c588      	l32i.n	a8, a5, 48
4200a697:	c789      	s32i.n	a8, a7, 48
4200a699:	c579      	s32i.n	a7, a5, 48
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200a69b:	20c662        	addi	a6, a6, 32
        }
        last = item;
4200a69e:	075d      	mov.n	a5, a7
4200a6a0:	000346        	j	4200a6b1 <load_partitions+0xe1>
4200a6a3:	060c00        	lsi	f0, a12, 24
    const uint8_t *md5_part = NULL;
4200a6a6:	0003c6        	j	4200a6b9 <load_partitions+0xe9>
4200a6a9:	0a6d      	mov.n	a6, a10
            err = ESP_ERR_NO_MEM;
4200a6ab:	01a122        	movi	a2, 0x101
4200a6ae:	0001c6        	j	4200a6b9 <load_partitions+0xe9>
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200a6b1:	02b637        	bgeu	a6, a3, 4200a6b7 <load_partitions+0xe7>
4200a6b4:	ffd306        	j	4200a604 <load_partitions+0x34>
    const uint8_t *md5_part = NULL;
4200a6b7:	060c      	movi.n	a6, 0
    }

#if CONFIG_PARTITION_TABLE_MD5
    if (md5_part == NULL) {
4200a6b9:	f6dc      	bnez.n	a6, 4200a6dc <load_partitions+0x10c>
        ESP_LOGE(TAG, "No MD5 found in partition table");
4200a6bb:	d66981        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a6be:	0008e0        	callx8	a8
4200a6c1:	d95bb1        	l32r	a11, 42000c30 <_stext+0xc10> (3c026f0c <_flash_rodata_start+0x6dec>)
4200a6c4:	0bed      	mov.n	a14, a11
4200a6c6:	0add      	mov.n	a13, a10
4200a6c8:	d95bc1        	l32r	a12, 42000c34 <_stext+0xc14> (3c026f18 <_flash_rodata_start+0x6df8>)
4200a6cb:	01a0a2        	movi	a10, 1
4200a6ce:	d67181        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200a6d1:	0008e0        	callx8	a8
        err = ESP_ERR_NOT_FOUND;
4200a6d4:	05a122        	movi	a2, 0x105
4200a6d7:	001246        	j	4200a724 <load_partitions+0x154>
4200a6da:	620000        	lsi	f0, a0, 0x188
    } else {
        stored_md5 = md5_part + ESP_PARTITION_MD5_OFFSET;
4200a6dd:	8b10c6        	j	41fed324 <_coredump_iram_end+0x1c6b324>
        esp_rom_md5_final(calc_md5, &context);
4200a6e0:	c1b271        	l32r	a7, 41ffada8 <_coredump_iram_end+0x1c78da8>
4200a6e3:	ad18      	l32i.n	a1, a13, 40
4200a6e5:	5b8107        	bany	a1, a0, 4200a744 <ensure_partitions_loaded+0x4>
4200a6e8:	e0d9      	s32i.n	a13, a0, 56
4200a6ea:	0008      	l32i.n	a0, a0, 0
#if !CONFIG_IDF_TARGET_LINUX
        ESP_LOG_BUFFER_HEXDUMP("calculated md5", calc_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
        ESP_LOG_BUFFER_HEXDUMP("stored md5", stored_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
#endif

        if (memcmp(calc_md5, stored_md5, ESP_ROM_MD5_DIGEST_LEN) != 0) {
4200a6ec:	0c1c      	movi.n	a12, 16
4200a6ee:	06bd      	mov.n	a11, a6
4200a6f0:	07ad      	mov.n	a10, a7
4200a6f2:	d87481        	l32r	a8, 420008c4 <_stext+0x8a4> (4000120c <memcmp>)
4200a6f5:	0008e0        	callx8	a8
4200a6f8:	ea9c      	beqz.n	a10, 4200a71a <load_partitions+0x14a>
            ESP_LOGE(TAG, "Partition table MD5 mismatch");
4200a6fa:	d65981        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a6fd:	0008e0        	callx8	a8
4200a700:	d94cb1        	l32r	a11, 42000c30 <_stext+0xc10> (3c026f0c <_flash_rodata_start+0x6dec>)
4200a703:	0bed      	mov.n	a14, a11
4200a705:	20daa0        	or	a13, a10, a10
4200a708:	d94cc1        	l32r	a12, 42000c38 <_stext+0xc18> (3c026f48 <_flash_rodata_start+0x6e28>)
4200a70b:	01a0a2        	movi	a10, 1
4200a70e:	d66181        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200a711:	0008e0        	callx8	a8
            err = ESP_ERR_INVALID_STATE;
4200a714:	03a122        	movi	a2, 0x103
4200a717:	000246        	j	4200a724 <load_partitions+0x154>
            ESP_LOGV(TAG, "Partition table MD5 verified");
        }
    }
#endif

    if (err == ESP_OK) {
4200a71a:	62cc      	bnez.n	a2, 4200a724 <load_partitions+0x154>
        /* Don't copy the list to the static variable unless it's verified */
        s_partition_list = new_partitions_list;
4200a71c:	d94881        	l32r	a8, 42000c3c <_stext+0xc1c> (3fc95124 <s_partition_list>)
4200a71f:	0849      	s32i.n	a4, a8, 0
4200a721:	0004c6        	j	4200a738 <load_partitions+0x168>
    } else {
        /* Otherwise, free all the memory we just allocated */
        partition_list_item_t *it = new_partitions_list.slh_first;
4200a724:	04ad      	mov.n	a10, a4
        while (it) {
4200a726:	0002c6        	j	4200a735 <load_partitions+0x165>
            partition_list_item_t *next = it->next.sle_next;
4200a729:	0c2a72        	l32i	a7, a10, 48
            free(it);
4200a72c:	d78f81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200a72f:	0008e0        	callx8	a8
            it = next;
4200a732:	20a770        	or	a10, a7, a7
        while (it) {
4200a735:	ff0a56        	bnez	a10, 4200a729 <load_partitions+0x159>
        }
    }

#if !CONFIG_IDF_TARGET_LINUX
    spi_flash_munmap(handle);
4200a738:	0121a2        	l32i	a10, a1, 4
4200a73b:	ff7aa5        	call8	42009ee4 <spi_flash_munmap>
#endif

    return err;
}
4200a73e:	f01d      	retw.n

4200a740 <ensure_partitions_loaded>:

    assert(SLIST_EMPTY(&s_partition_list));
}

static esp_err_t ensure_partitions_loaded(void)
{
4200a740:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
    if (SLIST_EMPTY(&s_partition_list)) {
4200a743:	d93e81        	l32r	a8, 42000c3c <_stext+0xc1c> (3fc95124 <s_partition_list>)
4200a746:	0888      	l32i.n	a8, a8, 0
4200a748:	044856        	bnez	a8, 4200a790 <ensure_partitions_loaded+0x50>
        // only lock if list is empty (and check again after acquiring lock)
        _lock_acquire(&s_partition_list_lock);
4200a74b:	d943a1        	l32r	a10, 42000c58 <_stext+0xc38> (3fc95120 <s_partition_list_lock>)
4200a74e:	d7fd81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
4200a751:	0008e0        	callx8	a8
        if (SLIST_EMPTY(&s_partition_list)) {
4200a754:	d93a81        	l32r	a8, 42000c3c <_stext+0xc1c> (3fc95124 <s_partition_list>)
4200a757:	0888      	l32i.n	a8, a8, 0
4200a759:	58ec      	bnez.n	a8, 4200a782 <ensure_partitions_loaded+0x42>
            ESP_LOGV(TAG, "Loading the partition table");
            err = load_partitions();
4200a75b:	ffe765        	call8	4200a5d0 <load_partitions>
4200a75e:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
4200a760:	0aac      	beqz.n	a10, 4200a784 <ensure_partitions_loaded+0x44>
                ESP_LOGE(TAG, "load_partitions returned 0x%x", err);
4200a762:	d63f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
4200a765:	0008e0        	callx8	a8
4200a768:	d932b1        	l32r	a11, 42000c30 <_stext+0xc10> (3c026f0c <_flash_rodata_start+0x6dec>)
4200a76b:	02fd      	mov.n	a15, a2
4200a76d:	0bed      	mov.n	a14, a11
4200a76f:	0add      	mov.n	a13, a10
4200a771:	d93ac1        	l32r	a12, 42000c5c <_stext+0xc3c> (3c026f74 <_flash_rodata_start+0x6e54>)
4200a774:	1a0c      	movi.n	a10, 1
4200a776:	d64781        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
4200a779:	0008e0        	callx8	a8
4200a77c:	000106        	j	4200a784 <ensure_partitions_loaded+0x44>
4200a77f:	000000        	ill
    esp_err_t err = ESP_OK;
4200a782:	020c      	movi.n	a2, 0
            }
        }
        _lock_release(&s_partition_list_lock);
4200a784:	d935a1        	l32r	a10, 42000c58 <_stext+0xc38> (3fc95120 <s_partition_list_lock>)
4200a787:	d7f081        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
4200a78a:	0008e0        	callx8	a8
4200a78d:	000046        	j	4200a792 <ensure_partitions_loaded+0x52>
    esp_err_t err = ESP_OK;
4200a790:	020c      	movi.n	a2, 0
    }
    return err;
}
4200a792:	f01d      	retw.n

4200a794 <iterator_create>:

static esp_partition_iterator_opaque_t *iterator_create(esp_partition_type_t type,
        esp_partition_subtype_t subtype, const char *label)
{
4200a794:	004136        	entry	a1, 32
4200a797:	027d      	mov.n	a7, a2
    esp_partition_iterator_opaque_t *it =
        (esp_partition_iterator_opaque_t *) malloc(sizeof(esp_partition_iterator_opaque_t));
4200a799:	4a1c      	movi.n	a10, 20
4200a79b:	d7fa81        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200a79e:	0008e0        	callx8	a8
4200a7a1:	0a2d      	mov.n	a2, a10
    if (it == NULL) {
4200a7a3:	fa8c      	beqz.n	a10, 4200a7b6 <iterator_create+0x22>
        return NULL;
    }
    it->type = type;
4200a7a5:	0a79      	s32i.n	a7, a10, 0
    it->subtype = subtype;
4200a7a7:	1a39      	s32i.n	a3, a10, 4
    it->label = label;
4200a7a9:	2a49      	s32i.n	a4, a10, 8
    it->next_item = SLIST_FIRST(&s_partition_list);
4200a7ab:	d92481        	l32r	a8, 42000c3c <_stext+0xc1c> (3fc95124 <s_partition_list>)
4200a7ae:	0888      	l32i.n	a8, a8, 0
4200a7b0:	3a89      	s32i.n	a8, a10, 12
    it->info = NULL;
4200a7b2:	080c      	movi.n	a8, 0
4200a7b4:	4a89      	s32i.n	a8, a10, 16
    return it;
}
4200a7b6:	f01d      	retw.n

4200a7b8 <esp_partition_iterator_release>:
    esp_partition_iterator_release(it);
    return res;
}

void esp_partition_iterator_release(esp_partition_iterator_t iterator)
{
4200a7b8:	004136        	entry	a1, 32
4200a7bb:	20a220        	or	a10, a2, a2
    // iterator == NULL is okay
    free(iterator);
4200a7be:	d76a81        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200a7c1:	0008e0        	callx8	a8
}
4200a7c4:	f01d      	retw.n
	...

4200a7c8 <esp_partition_next>:
{
4200a7c8:	004136        	entry	a1, 32
4200a7cb:	027d      	mov.n	a7, a2
    assert(it);
4200a7cd:	02dc      	bnez.n	a2, 4200a7e1 <esp_partition_next+0x19>
4200a7cf:	d924d1        	l32r	a13, 42000c60 <_stext+0xc40> (3c020230 <_flash_rodata_start+0x110>)
4200a7d2:	d924c1        	l32r	a12, 42000c64 <_stext+0xc44> (3c029388 <__func__$3>)
4200a7d5:	47a1b2        	movi	a11, 0x147
4200a7d8:	d924a1        	l32r	a10, 42000c68 <_stext+0xc48> (3c026fdf <_flash_rodata_start+0x6ebf>)
4200a7db:	d63981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4200a7de:	0008e0        	callx8	a8
    if (it->next_item == NULL) {
4200a7e1:	032222        	l32i	a2, a2, 12
4200a7e4:	008256        	bnez	a2, 4200a7f0 <esp_partition_next+0x28>
        esp_partition_iterator_release(it);
4200a7e7:	20a770        	or	a10, a7, a7
4200a7ea:	fffce5        	call8	4200a7b8 <esp_partition_iterator_release>
        return NULL;
4200a7ed:	0017c6        	j	4200a850 <esp_partition_next+0x88>
    _lock_acquire(&s_partition_list_lock);
4200a7f0:	d91aa1        	l32r	a10, 42000c58 <_stext+0xc38> (3fc95120 <s_partition_list_lock>)
4200a7f3:	d7d481        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
4200a7f6:	0008e0        	callx8	a8
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
4200a7f9:	000b46        	j	4200a82a <esp_partition_next+0x62>
        if (it->type != ESP_PARTITION_TYPE_ANY && it->type != p->type) {
4200a7fc:	0788      	l32i.n	a8, a7, 0
4200a7fe:	ffa092        	movi	a9, 255
4200a801:	041897        	beq	a8, a9, 4200a809 <esp_partition_next+0x41>
4200a804:	1698      	l32i.n	a9, a6, 4
4200a806:	1c9897        	bne	a8, a9, 4200a826 <esp_partition_next+0x5e>
        if (it->subtype != ESP_PARTITION_SUBTYPE_ANY && it->subtype != p->subtype) {
4200a809:	1788      	l32i.n	a8, a7, 4
4200a80b:	ffa092        	movi	a9, 255
4200a80e:	041897        	beq	a8, a9, 4200a816 <esp_partition_next+0x4e>
4200a811:	2698      	l32i.n	a9, a6, 8
4200a813:	0f9897        	bne	a8, a9, 4200a826 <esp_partition_next+0x5e>
        if (it->label != NULL && strcmp(it->label, p->label) != 0) {
4200a816:	27a8      	l32i.n	a10, a7, 8
4200a818:	014a16        	beqz	a10, 4200a830 <esp_partition_next+0x68>
4200a81b:	18c6b2        	addi	a11, a6, 24
4200a81e:	d70b81        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
4200a821:	0008e0        	callx8	a8
4200a824:	8a8c      	beqz.n	a10, 4200a830 <esp_partition_next+0x68>
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
4200a826:	c688      	l32i.n	a8, a6, 48
4200a828:	3789      	s32i.n	a8, a7, 12
4200a82a:	032762        	l32i	a6, a7, 12
4200a82d:	fcb656        	bnez	a6, 4200a7fc <esp_partition_next+0x34>
    _lock_release(&s_partition_list_lock);
4200a830:	d90aa1        	l32r	a10, 42000c58 <_stext+0xc38> (3fc95120 <s_partition_list_lock>)
4200a833:	d7c581        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
4200a836:	0008e0        	callx8	a8
    if (it->next_item == NULL) {
4200a839:	032722        	l32i	a2, a7, 12
4200a83c:	008256        	bnez	a2, 4200a848 <esp_partition_next+0x80>
        esp_partition_iterator_release(it);
4200a83f:	20a770        	or	a10, a7, a7
4200a842:	fff765        	call8	4200a7b8 <esp_partition_iterator_release>
        return NULL;
4200a845:	0001c6        	j	4200a850 <esp_partition_next+0x88>
    it->info = &it->next_item->info;
4200a848:	4729      	s32i.n	a2, a7, 16
    it->next_item = SLIST_NEXT(it->next_item, next);
4200a84a:	c288      	l32i.n	a8, a2, 48
4200a84c:	3789      	s32i.n	a8, a7, 12
    return it;
4200a84e:	072d      	mov.n	a2, a7
}
4200a850:	f01d      	retw.n
	...

4200a854 <esp_partition_find>:
{
4200a854:	004136        	entry	a1, 32
    if (ensure_partitions_loaded() != ESP_OK) {
4200a857:	ffeea5        	call8	4200a740 <ensure_partitions_loaded>
4200a85a:	026a56        	bnez	a10, 4200a884 <esp_partition_find+0x30>
    if (type == ESP_PARTITION_TYPE_ANY && subtype != ESP_PARTITION_SUBTYPE_ANY) {
4200a85d:	01af92        	movi	a9, -255
4200a860:	829a      	add.n	a8, a2, a9
4200a862:	40f880        	nsau	a8, a8
4200a865:	418580        	srli	a8, a8, 5
4200a868:	939a      	add.n	a9, a3, a9
4200a86a:	1a0c      	movi.n	a10, 1
4200a86c:	83a990        	moveqz	a10, a9, a9
4200a86f:	1788a7        	bany	a8, a10, 4200a88a <esp_partition_find+0x36>
    esp_partition_iterator_t it = iterator_create(type, subtype, label);
4200a872:	04cd      	mov.n	a12, a4
4200a874:	03bd      	mov.n	a11, a3
4200a876:	02ad      	mov.n	a10, a2
4200a878:	fff1a5        	call8	4200a794 <iterator_create>
    if (it == NULL) {
4200a87b:	da8c      	beqz.n	a10, 4200a88c <esp_partition_find+0x38>
    it = esp_partition_next(it);
4200a87d:	fff4a5        	call8	4200a7c8 <esp_partition_next>
    return it;
4200a880:	000206        	j	4200a88c <esp_partition_find+0x38>
4200a883:	0a0c00        	add.s	f0, f12, f0
        return NULL;
4200a886:	000086        	j	4200a88c <esp_partition_find+0x38>
4200a889:	0a0c00        	add.s	f0, f12, f0
}
4200a88c:	0a2d      	mov.n	a2, a10
4200a88e:	f01d      	retw.n

4200a890 <esp_partition_get>:

const esp_partition_t *esp_partition_get(esp_partition_iterator_t iterator)
{
4200a890:	004136        	entry	a1, 32
    assert(iterator != NULL);
4200a893:	011256        	bnez	a2, 4200a8a8 <esp_partition_get+0x18>
4200a896:	d8f5d1        	l32r	a13, 42000c6c <_stext+0xc4c> (3c026fec <_flash_rodata_start+0x6ecc>)
4200a899:	d8f5c1        	l32r	a12, 42000c70 <_stext+0xc50> (3c029374 <__func__$2>)
4200a89c:	7aa1b2        	movi	a11, 0x17a
4200a89f:	d8f2a1        	l32r	a10, 42000c68 <_stext+0xc48> (3c026fdf <_flash_rodata_start+0x6ebf>)
4200a8a2:	d60781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4200a8a5:	0008e0        	callx8	a8
    return iterator->info;
}
4200a8a8:	4228      	l32i.n	a2, a2, 16
4200a8aa:	f01d      	retw.n

4200a8ac <esp_partition_is_flash_region_writable>:
    }
    return false;
}

bool esp_partition_is_flash_region_writable(size_t addr, size_t size)
{
4200a8ac:	004136        	entry	a1, 32
    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_ANY, ESP_PARTITION_SUBTYPE_ANY, NULL);
4200a8af:	00a0c2        	movi	a12, 0
4200a8b2:	ffa0b2        	movi	a11, 255
4200a8b5:	20abb0        	or	a10, a11, a11
4200a8b8:	fff9a5        	call8	4200a854 <esp_partition_find>
4200a8bb:	207aa0        	or	a7, a10, a10
    for (; it != NULL; it = esp_partition_next(it)) {
4200a8be:	000a06        	j	4200a8ea <esp_partition_is_flash_region_writable+0x3e>
        const esp_partition_t *p = esp_partition_get(it);
4200a8c1:	07ad      	mov.n	a10, a7
4200a8c3:	fffce5        	call8	4200a890 <esp_partition_get>
        if (p->readonly) {
4200a8c6:	2a0a82        	l8ui	a8, a10, 42
4200a8c9:	489c      	beqz.n	a8, 4200a8e1 <esp_partition_is_flash_region_writable+0x35>
            if (addr >= p->address && addr < p->address + p->size) {
4200a8cb:	3a88      	l32i.n	a8, a10, 12
4200a8cd:	073287        	bltu	a2, a8, 4200a8d8 <esp_partition_is_flash_region_writable+0x2c>
4200a8d0:	4a98      	l32i.n	a9, a10, 16
4200a8d2:	809890        	add	a9, a8, a9
4200a8d5:	193297        	bltu	a2, a9, 4200a8f2 <esp_partition_is_flash_region_writable+0x46>
                return false;
            }
            if (addr < p->address && addr + size > p->address) {
4200a8d8:	05b287        	bgeu	a2, a8, 4200a8e1 <esp_partition_is_flash_region_writable+0x35>
4200a8db:	809230        	add	a9, a2, a3
4200a8de:	163897        	bltu	a8, a9, 4200a8f8 <esp_partition_is_flash_region_writable+0x4c>
    for (; it != NULL; it = esp_partition_next(it)) {
4200a8e1:	20a770        	or	a10, a7, a7
4200a8e4:	ffee25        	call8	4200a7c8 <esp_partition_next>
4200a8e7:	207aa0        	or	a7, a10, a10
4200a8ea:	fd3756        	bnez	a7, 4200a8c1 <esp_partition_is_flash_region_writable+0x15>
                return false;
            }
        }
    }
    return true;
4200a8ed:	120c      	movi.n	a2, 1
4200a8ef:	0001c6        	j	4200a8fa <esp_partition_is_flash_region_writable+0x4e>
                return false;
4200a8f2:	020c      	movi.n	a2, 0
4200a8f4:	000086        	j	4200a8fa <esp_partition_is_flash_region_writable+0x4e>
4200a8f7:	020c00        	andb	b0, b12, b0
}
4200a8fa:	f01d      	retw.n

4200a8fc <esp_partition_main_flash_region_safe>:

bool esp_partition_main_flash_region_safe(size_t addr, size_t size)
{
4200a8fc:	004136        	entry	a1, 32
    if (addr <= ESP_PARTITION_TABLE_OFFSET + ESP_PARTITION_TABLE_MAX_LEN) {
4200a8ff:	d8dd81        	l32r	a8, 42000c74 <_stext+0xc54> (8c00 <UserFrameTotalSize+0x8b00>)
4200a902:	1bb827        	bgeu	a8, a2, 4200a921 <esp_partition_main_flash_region_safe+0x25>
        return false;
    }
    const esp_partition_t *p = esp_ota_get_running_partition();
4200a905:	0003a5        	call8	4200a940 <esp_ota_get_running_partition>
    if (addr >= p->address && addr < p->address + p->size) {
4200a908:	3a88      	l32i.n	a8, a10, 12
4200a90a:	063287        	bltu	a2, a8, 4200a914 <esp_partition_main_flash_region_safe+0x18>
4200a90d:	4a98      	l32i.n	a9, a10, 16
4200a90f:	989a      	add.n	a9, a8, a9
4200a911:	113297        	bltu	a2, a9, 4200a926 <esp_partition_main_flash_region_safe+0x2a>
        return false;
    }
    if (addr < p->address && addr + size > p->address) {
4200a914:	14b287        	bgeu	a2, a8, 4200a92c <esp_partition_main_flash_region_safe+0x30>
4200a917:	323a      	add.n	a3, a2, a3
4200a919:	143837        	bltu	a8, a3, 4200a931 <esp_partition_main_flash_region_safe+0x35>
        return false;
    }
    return true;
4200a91c:	120c      	movi.n	a2, 1
4200a91e:	000446        	j	4200a933 <esp_partition_main_flash_region_safe+0x37>
        return false;
4200a921:	020c      	movi.n	a2, 0
4200a923:	000306        	j	4200a933 <esp_partition_main_flash_region_safe+0x37>
        return false;
4200a926:	020c      	movi.n	a2, 0
4200a928:	0001c6        	j	4200a933 <esp_partition_main_flash_region_safe+0x37>
4200a92b:	120c00        	andbc	b0, b12, b0
    return true;
4200a92e:	000046        	j	4200a933 <esp_partition_main_flash_region_safe+0x37>
        return false;
4200a931:	020c      	movi.n	a2, 0
}
4200a933:	f01d      	retw.n
4200a935:	000000        	ill

4200a938 <esp_partition_get_main_flash_sector_size>:

uint32_t esp_partition_get_main_flash_sector_size(void)
{
4200a938:	004136        	entry	a1, 32
    return SPI_FLASH_SEC_SIZE;
}
4200a93b:	d7bf21        	l32r	a2, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
4200a93e:	f01d      	retw.n

4200a940 <esp_ota_get_running_partition>:
    }
}


const esp_partition_t* esp_ota_get_running_partition(void)
{
4200a940:	004136        	entry	a1, 32

    /*
     * Currently running partition is unlikely to change across reset cycle,
     * so it can be cached here, and avoid lookup on every flash write operation.
     */
    if (curr_partition != NULL) {
4200a943:	d8cd81        	l32r	a8, 42000c78 <_stext+0xc58> (3fc95128 <curr_partition$2>)
4200a946:	0828      	l32i.n	a2, a8, 0
4200a948:	072256        	bnez	a2, 4200a9be <esp_ota_get_running_partition+0x7e>
        return curr_partition;
    }

    /* Find the flash address of this exact function. By definition that is part
       of the currently running firmware. Then find the enclosing partition. */
    size_t phys_offs = spi_flash_cache2phys(esp_ota_get_running_partition);
4200a94b:	d8cca1        	l32r	a10, 42000c7c <_stext+0xc5c> (4200a940 <esp_ota_get_running_partition>)
4200a94e:	ff5da5        	call8	42009f28 <spi_flash_cache2phys>
4200a951:	206aa0        	or	a6, a10, a10

    assert (phys_offs != SPI_FLASH_CACHE2PHYS_FAIL); /* indicates cache2phys lookup is buggy */
4200a954:	110a66        	bnei	a10, -1, 4200a969 <esp_ota_get_running_partition+0x29>
4200a957:	d8cad1        	l32r	a13, 42000c80 <_stext+0xc60> (3c027000 <_flash_rodata_start+0x6ee0>)
4200a95a:	d8cac1        	l32r	a12, 42000c84 <_stext+0xc64> (3c02939c <__func__$1>)
4200a95d:	8ba2b2        	movi	a11, 0x28b
4200a960:	d8caa1        	l32r	a10, 42000c88 <_stext+0xc68> (3c027044 <_flash_rodata_start+0x6f24>)
4200a963:	d5d781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4200a966:	0008e0        	callx8	a8

    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP,
4200a969:	0c0c      	movi.n	a12, 0
4200a96b:	ffa0b2        	movi	a11, 255
4200a96e:	0cad      	mov.n	a10, a12
4200a970:	ffee25        	call8	4200a854 <esp_partition_find>
4200a973:	0a7d      	mov.n	a7, a10
                                                     ESP_PARTITION_SUBTYPE_ANY,
                                                     NULL);
    assert(it != NULL); /* has to be at least one app partition */
4200a975:	03ca56        	bnez	a10, 4200a9b5 <esp_ota_get_running_partition+0x75>
4200a978:	d8c5d1        	l32r	a13, 42000c8c <_stext+0xc6c> (3c027054 <_flash_rodata_start+0x6f34>)
4200a97b:	d8c2c1        	l32r	a12, 42000c84 <_stext+0xc64> (3c02939c <__func__$1>)
4200a97e:	90a2b2        	movi	a11, 0x290
4200a981:	d8c1a1        	l32r	a10, 42000c88 <_stext+0xc68> (3c027044 <_flash_rodata_start+0x6f24>)
4200a984:	d5cf81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4200a987:	0008e0        	callx8	a8

    while (it != NULL) {
        const esp_partition_t *p = esp_partition_get(it);
4200a98a:	20a770        	or	a10, a7, a7
4200a98d:	fff025        	call8	4200a890 <esp_partition_get>
4200a990:	202aa0        	or	a2, a10, a10
        if (p->address <= phys_offs && p->address + p->size > phys_offs) {
4200a993:	3a88      	l32i.n	a8, a10, 12
4200a995:	153687        	bltu	a6, a8, 4200a9ae <esp_ota_get_running_partition+0x6e>
4200a998:	4a98      	l32i.n	a9, a10, 16
4200a99a:	889a      	add.n	a8, a8, a9
4200a99c:	0eb687        	bgeu	a6, a8, 4200a9ae <esp_ota_get_running_partition+0x6e>
            esp_partition_iterator_release(it);
4200a99f:	07ad      	mov.n	a10, a7
4200a9a1:	ffe165        	call8	4200a7b8 <esp_partition_iterator_release>
            curr_partition = p;
4200a9a4:	d8b581        	l32r	a8, 42000c78 <_stext+0xc58> (3fc95128 <curr_partition$2>)
4200a9a7:	0829      	s32i.n	a2, a8, 0
            return p;
4200a9a9:	000446        	j	4200a9be <esp_ota_get_running_partition+0x7e>
4200a9ac:	ad0000        	lsi	f0, a0, 0x2b4
        }
        it = esp_partition_next(it);
4200a9af:	e16507        	bbci	a5, 0, 4200a994 <esp_ota_get_running_partition+0x54>
4200a9b2:	ff          	.byte	0xff
4200a9b3:	0a7d      	mov.n	a7, a10
    while (it != NULL) {
4200a9b5:	fd1756        	bnez	a7, 4200a98a <esp_ota_get_running_partition+0x4a>
    }

    abort(); /* Partition table is invalid or corrupt */
4200a9b8:	d5cf81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200a9bb:	0008e0        	callx8	a8
}
4200a9be:	f01d      	retw.n

4200a9c0 <_ZdlPvj>:
4200a9c0:	004136        	entry	a1, 32
4200a9c3:	20a220        	or	a10, a2, a2
4200a9c6:	201110        	or	a1, a1, a1
4200a9c9:	003d65        	call8	4200ada0 <_ZdlPv>
4200a9cc:	f01d      	retw.n
	...

4200a9d0 <_ZSt15get_new_handlerv>:
4200a9d0:	004136        	entry	a1, 32
4200a9d3:	d8af81        	l32r	a8, 42000c90 <_stext+0xc70> (3fc9512c <_ZN12_GLOBAL__N_113__new_handlerE>)
4200a9d6:	0020c0        	memw
4200a9d9:	0828      	l32i.n	a2, a8, 0
4200a9db:	0020c0        	memw
4200a9de:	f01d      	retw.n

4200a9e0 <_Znwj>:
4200a9e0:	004136        	entry	a1, 32
4200a9e3:	180c      	movi.n	a8, 1
4200a9e5:	737280        	maxu	a7, a2, a8
4200a9e8:	000906        	j	4200aa10 <_Znwj+0x30>
4200a9eb:	111000        	slli	a1, a0, 16
4200a9ee:	fe2520        	f64iter	a2, a5, a2, 3, 1
4200a9f1:	ff          	.byte	0xff
4200a9f2:	7adc      	bnez.n	a10, 4200aa0d <_Znwj+0x2d>
4200a9f4:	4a0c      	movi.n	a10, 4
4200a9f6:	201110        	or	a1, a1, a1
4200a9f9:	00a565        	call8	4200b450 <__wrap___cxa_allocate_exception>
4200a9fc:	d8a681        	l32r	a8, 42000c94 <_stext+0xc74> (3c0296d8 <_ZTVSt9bad_alloc+0x8>)
4200a9ff:	d8a6c1        	l32r	a12, 42000c98 <_stext+0xc78> (4200ac98 <_ZNSt9bad_allocD1Ev>)
4200aa02:	d8a6b1        	l32r	a11, 42000c9c <_stext+0xc7c> (3c029404 <_ZTISt9bad_alloc>)
4200aa05:	0a89      	s32i.n	a8, a10, 0
4200aa07:	201110        	or	a1, a1, a1
4200aa0a:	00a525        	call8	4200b45c <__wrap___cxa_throw>
4200aa0d:	000ae0        	callx8	a10
4200aa10:	07ad      	mov.n	a10, a7
4200aa12:	d75c81        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200aa15:	0008e0        	callx8	a8
4200aa18:	0a2d      	mov.n	a2, a10
4200aa1a:	fcea16        	beqz	a10, 4200a9ec <_Znwj+0xc>
4200aa1d:	f01d      	retw.n
	...

4200aa20 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>:
4200aa20:	004136        	entry	a1, 32
4200aa23:	d89f81        	l32r	a8, 42000ca0 <_stext+0xc80> (3c029418 <_ZTVN10__cxxabiv120__si_class_type_infoE+0x8>)
4200aa26:	02ad      	mov.n	a10, a2
4200aa28:	0289      	s32i.n	a8, a2, 0
4200aa2a:	201110        	or	a1, a1, a1
4200aa2d:	002965        	call8	4200acc4 <_ZN10__cxxabiv117__class_type_infoD1Ev>
4200aa30:	f01d      	retw.n
	...

4200aa34 <_ZN10__cxxabiv120__si_class_type_infoD0Ev>:
4200aa34:	004136        	entry	a1, 32
4200aa37:	20a220        	or	a10, a2, a2
4200aa3a:	201110        	or	a1, a1, a1
4200aa3d:	fffe25        	call8	4200aa20 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>
4200aa40:	cb0c      	movi.n	a11, 12
4200aa42:	02ad      	mov.n	a10, a2
4200aa44:	201110        	or	a1, a1, a1
4200aa47:	fff7a5        	call8	4200a9c0 <_ZdlPvj>
4200aa4a:	f01d      	retw.n

4200aa4c <_ZNKSt9type_infoeqERKS_$isra$0>:
4200aa4c:	004136        	entry	a1, 32
4200aa4f:	02ad      	mov.n	a10, a2
4200aa51:	03bd      	mov.n	a11, a3
4200aa53:	120c      	movi.n	a2, 1
4200aa55:	1f1a37        	beq	a10, a3, 4200aa78 <_ZNKSt9type_infoeqERKS_$isra$0+0x2c>
4200aa58:	000a92        	l8ui	a9, a10, 0
4200aa5b:	a82c      	movi.n	a8, 42
4200aa5d:	00a022        	movi	a2, 0
4200aa60:	141987        	beq	a9, a8, 4200aa78 <_ZNKSt9type_infoeqERKS_$isra$0+0x2c>
4200aa63:	000392        	l8ui	a9, a3, 0
4200aa66:	029987        	bne	a9, a8, 4200aa6c <_ZNKSt9type_infoeqERKS_$isra$0+0x20>
4200aa69:	01c3b2        	addi	a11, a3, 1
4200aa6c:	d67881        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
4200aa6f:	0008e0        	callx8	a8
4200aa72:	40fa20        	nsau	a2, a10
4200aa75:	412520        	srli	a2, a2, 5
4200aa78:	f01d      	retw.n
	...

4200aa7c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE>:
4200aa7c:	008136        	entry	a1, 64
4200aa7f:	1298      	l32i.n	a9, a2, 4
4200aa81:	15b8      	l32i.n	a11, a5, 4
4200aa83:	09ad      	mov.n	a10, a9
4200aa85:	4179      	s32i.n	a7, a1, 16
4200aa87:	056192        	s32i	a9, a1, 20
4200aa8a:	201110        	or	a1, a1, a1
4200aa8d:	fffbe5        	call8	4200aa4c <_ZNKSt9type_infoeqERKS_$isra$0>
4200aa90:	112172        	l32i	a7, a1, 68
4200aa93:	5198      	l32i.n	a9, a1, 20
4200aa95:	0aac      	beqz.n	a10, 4200aab9 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x3d>
4200aa97:	0769      	s32i.n	a6, a7, 0
4200aa99:	1749      	s32i.n	a4, a7, 4
4200aa9b:	00e396        	bltz	a3, 4200aaad <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x31>
4200aa9e:	102182        	l32i	a8, a1, 64
4200aaa1:	e63a      	add.n	a14, a6, a3
4200aaa3:	190c      	movi.n	a9, 1
4200aaa5:	0b98e7        	bne	a8, a14, 4200aab4 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x38>
4200aaa8:	690c      	movi.n	a9, 6
4200aaaa:	000186        	j	4200aab4 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x38>
4200aaad:	e97c      	movi.n	a9, -2
4200aaaf:	1d9397        	bne	a3, a9, 4200aad0 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x54>
4200aab2:	190c      	movi.n	a9, 1
4200aab4:	3799      	s32i.n	a9, a7, 12
4200aab6:	000586        	j	4200aad0 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x54>
4200aab9:	102182        	l32i	a8, a1, 64
4200aabc:	169687        	bne	a6, a8, 4200aad6 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x5a>
4200aabf:	4188      	l32i.n	a8, a1, 16
4200aac1:	09ad      	mov.n	a10, a9
4200aac3:	0128b2        	l32i	a11, a8, 4
4200aac6:	201110        	or	a1, a1, a1
4200aac9:	fff825        	call8	4200aa4c <_ZNKSt9type_infoeqERKS_$isra$0>
4200aacc:	6a8c      	beqz.n	a10, 4200aad6 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x5a>
4200aace:	2749      	s32i.n	a4, a7, 8
4200aad0:	020c      	movi.n	a2, 0
4200aad2:	000706        	j	4200aaf2 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x76>
4200aad5:	22a800        	orb	b10, b8, b0
4200aad8:	102182        	l32i	a8, a1, 64
4200aadb:	0a98      	l32i.n	a9, a10, 0
4200aadd:	1179      	s32i.n	a7, a1, 4
4200aadf:	0189      	s32i.n	a8, a1, 0
4200aae1:	7988      	l32i.n	a8, a9, 28
4200aae3:	41f8      	l32i.n	a15, a1, 16
4200aae5:	06ed      	mov.n	a14, a6
4200aae7:	05dd      	mov.n	a13, a5
4200aae9:	04cd      	mov.n	a12, a4
4200aaeb:	03bd      	mov.n	a11, a3
4200aaed:	0008e0        	callx8	a8
4200aaf0:	0a2d      	mov.n	a2, a10
4200aaf2:	f01d      	retw.n

4200aaf4 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_>:
4200aaf4:	004136        	entry	a1, 32
4200aaf7:	027d      	mov.n	a7, a2
4200aaf9:	0d9647        	bne	a6, a4, 4200ab0a <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x16>
4200aafc:	12a8      	l32i.n	a10, a2, 4
4200aafe:	15b8      	l32i.n	a11, a5, 4
4200ab00:	620c      	movi.n	a2, 6
4200ab02:	201110        	or	a1, a1, a1
4200ab05:	fff465        	call8	4200aa4c <_ZNKSt9type_infoeqERKS_$isra$0>
4200ab08:	2adc      	bnez.n	a10, 4200ab1e <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x2a>
4200ab0a:	27a8      	l32i.n	a10, a7, 8
4200ab0c:	06ed      	mov.n	a14, a6
4200ab0e:	0a88      	l32i.n	a8, a10, 0
4200ab10:	05dd      	mov.n	a13, a5
4200ab12:	8888      	l32i.n	a8, a8, 32
4200ab14:	20c440        	or	a12, a4, a4
4200ab17:	03bd      	mov.n	a11, a3
4200ab19:	0008e0        	callx8	a8
4200ab1c:	0a2d      	mov.n	a2, a10
4200ab1e:	f01d      	retw.n

4200ab20 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE>:
4200ab20:	004136        	entry	a1, 32
4200ab23:	02ad      	mov.n	a10, a2
4200ab25:	05dd      	mov.n	a13, a5
4200ab27:	04cd      	mov.n	a12, a4
4200ab29:	03bd      	mov.n	a11, a3
4200ab2b:	201110        	or	a1, a1, a1
4200ab2e:	001f25        	call8	4200ad20 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>
4200ab31:	027d      	mov.n	a7, a2
4200ab33:	0a2d      	mov.n	a2, a10
4200ab35:	facc      	bnez.n	a10, 4200ab48 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x28>
4200ab37:	27a8      	l32i.n	a10, a7, 8
4200ab39:	05dd      	mov.n	a13, a5
4200ab3b:	0a88      	l32i.n	a8, a10, 0
4200ab3d:	04cd      	mov.n	a12, a4
4200ab3f:	6888      	l32i.n	a8, a8, 24
4200ab41:	03bd      	mov.n	a11, a3
4200ab43:	0008e0        	callx8	a8
4200ab46:	0a2d      	mov.n	a2, a10
4200ab48:	f01d      	retw.n
	...

4200ab4c <_ZSt17__throw_bad_allocv>:
4200ab4c:	004136        	entry	a1, 32
4200ab4f:	04a0a2        	movi	a10, 4
4200ab52:	201110        	or	a1, a1, a1
4200ab55:	008fa5        	call8	4200b450 <__wrap___cxa_allocate_exception>
4200ab58:	d84f81        	l32r	a8, 42000c94 <_stext+0xc74> (3c0296d8 <_ZTVSt9bad_alloc+0x8>)
4200ab5b:	d84fc1        	l32r	a12, 42000c98 <_stext+0xc78> (4200ac98 <_ZNSt9bad_allocD1Ev>)
4200ab5e:	d84fb1        	l32r	a11, 42000c9c <_stext+0xc7c> (3c029404 <_ZTISt9bad_alloc>)
4200ab61:	0a89      	s32i.n	a8, a10, 0
4200ab63:	201110        	or	a1, a1, a1
4200ab66:	008f65        	call8	4200b45c <__wrap___cxa_throw>
4200ab69:	000000        	ill

4200ab6c <_ZSt19__throw_logic_errorPKc>:
4200ab6c:	004136        	entry	a1, 32
4200ab6f:	08a0a2        	movi	a10, 8
4200ab72:	201110        	or	a1, a1, a1
4200ab75:	008da5        	call8	4200b450 <__wrap___cxa_allocate_exception>
4200ab78:	20b220        	or	a11, a2, a2
4200ab7b:	207aa0        	or	a7, a10, a10
4200ab7e:	201110        	or	a1, a1, a1
4200ab81:	006fe5        	call8	4200b280 <_ZNSt11logic_errorC1EPKc>
4200ab84:	d848c1        	l32r	a12, 42000ca4 <_stext+0xc84> (4200b1f0 <_ZNSt11logic_errorD1Ev>)
4200ab87:	d848b1        	l32r	a11, 42000ca8 <_stext+0xc88> (3c02944c <_ZTISt11logic_error>)
4200ab8a:	07ad      	mov.n	a10, a7
4200ab8c:	201110        	or	a1, a1, a1
4200ab8f:	008ce5        	call8	4200b45c <__wrap___cxa_throw>
4200ab92:	07ad      	mov.n	a10, a7
4200ab94:	201110        	or	a1, a1, a1
4200ab97:	003de5        	call8	4200af74 <__cxa_free_exception>
4200ab9a:	02ad      	mov.n	a10, a2
4200ab9c:	201110        	or	a1, a1, a1
4200ab9f:	008925        	call8	4200b430 <__wrap__Unwind_Resume>
	...

4200aba4 <_ZSt20__throw_length_errorPKc>:
4200aba4:	004136        	entry	a1, 32
4200aba7:	08a0a2        	movi	a10, 8
4200abaa:	201110        	or	a1, a1, a1
4200abad:	008a25        	call8	4200b450 <__wrap___cxa_allocate_exception>
4200abb0:	20b220        	or	a11, a2, a2
4200abb3:	207aa0        	or	a7, a10, a10
4200abb6:	201110        	or	a1, a1, a1
4200abb9:	006f65        	call8	4200b2b0 <_ZNSt12length_errorC1EPKc>
4200abbc:	d83cc1        	l32r	a12, 42000cac <_stext+0xc8c> (4200b228 <_ZNSt12length_errorD1Ev>)
4200abbf:	d83cb1        	l32r	a11, 42000cb0 <_stext+0xc90> (3c02946c <_ZTISt12length_error>)
4200abc2:	07ad      	mov.n	a10, a7
4200abc4:	201110        	or	a1, a1, a1
4200abc7:	008965        	call8	4200b45c <__wrap___cxa_throw>
4200abca:	07ad      	mov.n	a10, a7
4200abcc:	201110        	or	a1, a1, a1
4200abcf:	003a65        	call8	4200af74 <__cxa_free_exception>
4200abd2:	02ad      	mov.n	a10, a2
4200abd4:	201110        	or	a1, a1, a1
4200abd7:	0085a5        	call8	4200b430 <__wrap__Unwind_Resume>
	...

4200abdc <_ZSt20__throw_out_of_rangePKc>:
4200abdc:	004136        	entry	a1, 32
4200abdf:	08a0a2        	movi	a10, 8
4200abe2:	201110        	or	a1, a1, a1
4200abe5:	0086a5        	call8	4200b450 <__wrap___cxa_allocate_exception>
4200abe8:	20b220        	or	a11, a2, a2
4200abeb:	207aa0        	or	a7, a10, a10
4200abee:	201110        	or	a1, a1, a1
4200abf1:	006d25        	call8	4200b2c4 <_ZNSt12out_of_rangeC1EPKc>
4200abf4:	d830c1        	l32r	a12, 42000cb4 <_stext+0xc94> (4200b254 <_ZNSt12out_of_rangeD1Ev>)
4200abf7:	d830b1        	l32r	a11, 42000cb8 <_stext+0xc98> (3c02948c <_ZTISt12out_of_range>)
4200abfa:	07ad      	mov.n	a10, a7
4200abfc:	201110        	or	a1, a1, a1
4200abff:	0085e5        	call8	4200b45c <__wrap___cxa_throw>
4200ac02:	07ad      	mov.n	a10, a7
4200ac04:	201110        	or	a1, a1, a1
4200ac07:	0036e5        	call8	4200af74 <__cxa_free_exception>
4200ac0a:	02ad      	mov.n	a10, a2
4200ac0c:	201110        	or	a1, a1, a1
4200ac0f:	008225        	call8	4200b430 <__wrap__Unwind_Resume>
	...

4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>:
4200ac14:	004136        	entry	a1, 32
4200ac17:	20a220        	or	a10, a2, a2
4200ac1a:	201110        	or	a1, a1, a1
4200ac1d:	fffbe5        	call8	4200abdc <_ZSt20__throw_out_of_rangePKc>

4200ac20 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj>:
4200ac20:	004136        	entry	a1, 32
4200ac23:	860b      	addi.n	a8, a6, -1
4200ac25:	0bb847        	bgeu	a8, a4, 4200ac34 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x14>
4200ac28:	06cd      	mov.n	a12, a6
4200ac2a:	05bd      	mov.n	a11, a5
4200ac2c:	03ad      	mov.n	a10, a3
4200ac2e:	201110        	or	a1, a1, a1
4200ac31:	fd4025        	call8	42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>
4200ac34:	d78c      	beqz.n	a7, 4200ac45 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x25>
4200ac36:	0b1647        	beq	a6, a4, 4200ac45 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x25>
4200ac39:	07cd      	mov.n	a12, a7
4200ac3b:	b34a      	add.n	a11, a3, a4
4200ac3d:	a36a      	add.n	a10, a3, a6
4200ac3f:	201110        	or	a1, a1, a1
4200ac42:	fd3f25        	call8	42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>
4200ac45:	44b467        	bgeu	a4, a6, 4200ac8d <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x6d>
4200ac48:	834a      	add.n	a8, a3, a4
4200ac4a:	956a      	add.n	a9, a5, a6
4200ac4c:	103897        	bltu	a8, a9, 4200ac60 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x40>
4200ac4f:	06cd      	mov.n	a12, a6
4200ac51:	05bd      	mov.n	a11, a5
4200ac53:	20a330        	or	a10, a3, a3
4200ac56:	201110        	or	a1, a1, a1
4200ac59:	fd3da5        	call8	42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>
4200ac5c:	000b46        	j	4200ac8d <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x6d>
4200ac5f:	00          	.byte	00
4200ac60:	0b3587        	bltu	a5, a8, 4200ac6f <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x4f>
4200ac63:	c04640        	sub	a4, a6, a4
4200ac66:	06cd      	mov.n	a12, a6
4200ac68:	b54a      	add.n	a11, a5, a4
4200ac6a:	03ad      	mov.n	a10, a3
4200ac6c:	0005c6        	j	4200ac87 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE15_M_replace_coldEPcjPKcjj+0x67>
4200ac6f:	c04850        	sub	a4, a8, a5
4200ac72:	20c440        	or	a12, a4, a4
4200ac75:	05bd      	mov.n	a11, a5
4200ac77:	20a330        	or	a10, a3, a3
4200ac7a:	201110        	or	a1, a1, a1
4200ac7d:	fd3b65        	call8	42008034 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_moveEPcPKcj>
4200ac80:	c0c640        	sub	a12, a6, a4
4200ac83:	b36a      	add.n	a11, a3, a6
4200ac85:	a34a      	add.n	a10, a3, a4
4200ac87:	201110        	or	a1, a1, a1
4200ac8a:	fd0225        	call8	42007cac <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7_S_copyEPcPKcj>
4200ac8d:	f01d      	retw.n
	...

4200ac90 <_ZNKSt9bad_alloc4whatEv>:
4200ac90:	004136        	entry	a1, 32
4200ac93:	d80a21        	l32r	a2, 42000cbc <_stext+0xc9c> (3c029498 <_ZTISt12out_of_range+0xc>)
4200ac96:	f01d      	retw.n

4200ac98 <_ZNSt9bad_allocD1Ev>:
4200ac98:	004136        	entry	a1, 32
4200ac9b:	d7fe81        	l32r	a8, 42000c94 <_stext+0xc74> (3c0296d8 <_ZTVSt9bad_alloc+0x8>)
4200ac9e:	02ad      	mov.n	a10, a2
4200aca0:	0289      	s32i.n	a8, a2, 0
4200aca2:	201110        	or	a1, a1, a1
4200aca5:	0ae525        	call8	42015af8 <_ZNSt9exceptionD1Ev>
4200aca8:	f01d      	retw.n
	...

4200acac <_ZNSt9bad_allocD0Ev>:
4200acac:	004136        	entry	a1, 32
4200acaf:	20a220        	or	a10, a2, a2
4200acb2:	201110        	or	a1, a1, a1
4200acb5:	fffe25        	call8	4200ac98 <_ZNSt9bad_allocD1Ev>
4200acb8:	4b0c      	movi.n	a11, 4
4200acba:	02ad      	mov.n	a10, a2
4200acbc:	201110        	or	a1, a1, a1
4200acbf:	ffd025        	call8	4200a9c0 <_ZdlPvj>
4200acc2:	f01d      	retw.n

4200acc4 <_ZN10__cxxabiv117__class_type_infoD1Ev>:
4200acc4:	004136        	entry	a1, 32
4200acc7:	d7fe81        	l32r	a8, 42000cc0 <_stext+0xca0> (3c0296ec <_ZTVN10__cxxabiv117__class_type_infoE+0x8>)
4200acca:	02ad      	mov.n	a10, a2
4200accc:	0289      	s32i.n	a8, a2, 0
4200acce:	201110        	or	a1, a1, a1
4200acd1:	0adda5        	call8	42015aac <_ZNSt9type_infoD1Ev>
4200acd4:	f01d      	retw.n
	...

4200acd8 <_ZN10__cxxabiv117__class_type_infoD0Ev>:
4200acd8:	004136        	entry	a1, 32
4200acdb:	20a220        	or	a10, a2, a2
4200acde:	201110        	or	a1, a1, a1
4200ace1:	fffe25        	call8	4200acc4 <_ZN10__cxxabiv117__class_type_infoD1Ev>
4200ace4:	8b0c      	movi.n	a11, 8
4200ace6:	02ad      	mov.n	a10, a2
4200ace8:	201110        	or	a1, a1, a1
4200aceb:	ffcd65        	call8	4200a9c0 <_ZdlPvj>
4200acee:	f01d      	retw.n

4200acf0 <_ZNKSt9type_infoeqERKS_$isra$0>:
4200acf0:	004136        	entry	a1, 32
4200acf3:	02ad      	mov.n	a10, a2
4200acf5:	03bd      	mov.n	a11, a3
4200acf7:	120c      	movi.n	a2, 1
4200acf9:	1f1a37        	beq	a10, a3, 4200ad1c <_ZNKSt9type_infoeqERKS_$isra$0+0x2c>
4200acfc:	000a92        	l8ui	a9, a10, 0
4200acff:	a82c      	movi.n	a8, 42
4200ad01:	00a022        	movi	a2, 0
4200ad04:	141987        	beq	a9, a8, 4200ad1c <_ZNKSt9type_infoeqERKS_$isra$0+0x2c>
4200ad07:	000392        	l8ui	a9, a3, 0
4200ad0a:	029987        	bne	a9, a8, 4200ad10 <_ZNKSt9type_infoeqERKS_$isra$0+0x20>
4200ad0d:	01c3b2        	addi	a11, a3, 1
4200ad10:	d5cf81        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
4200ad13:	0008e0        	callx8	a8
4200ad16:	40fa20        	nsau	a2, a10
4200ad19:	412520        	srli	a2, a2, 5
4200ad1c:	f01d      	retw.n
	...

4200ad20 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>:
4200ad20:	004136        	entry	a1, 32
4200ad23:	12a8      	l32i.n	a10, a2, 4
4200ad25:	0123b2        	l32i	a11, a3, 4
4200ad28:	201110        	or	a1, a1, a1
4200ad2b:	fffc65        	call8	4200acf0 <_ZNKSt9type_infoeqERKS_$isra$0>
4200ad2e:	0a2d      	mov.n	a2, a10
4200ad30:	8a8c      	beqz.n	a10, 4200ad3c <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE+0x1c>
4200ad32:	880c      	movi.n	a8, 8
4200ad34:	3589      	s32i.n	a8, a5, 12
4200ad36:	680c      	movi.n	a8, 6
4200ad38:	0549      	s32i.n	a4, a5, 0
4200ad3a:	1589      	s32i.n	a8, a5, 4
4200ad3c:	f01d      	retw.n
	...

4200ad40 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE>:
4200ad40:	004136        	entry	a1, 32
4200ad43:	8188      	l32i.n	a8, a1, 32
4200ad45:	9138      	l32i.n	a3, a1, 36
4200ad47:	1228      	l32i.n	a2, a2, 4
4200ad49:	119687        	bne	a6, a8, 4200ad5e <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x1e>
4200ad4c:	17b8      	l32i.n	a11, a7, 4
4200ad4e:	02ad      	mov.n	a10, a2
4200ad50:	201110        	or	a1, a1, a1
4200ad53:	fff9e5        	call8	4200acf0 <_ZNKSt9type_infoeqERKS_$isra$0>
4200ad56:	4a8c      	beqz.n	a10, 4200ad5e <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x1e>
4200ad58:	2349      	s32i.n	a4, a3, 8
4200ad5a:	000506        	j	4200ad72 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x32>
4200ad5d:	15b800        	extui	a11, a0, 24, 2
4200ad60:	02ad      	mov.n	a10, a2
4200ad62:	201110        	or	a1, a1, a1
4200ad65:	fff8a5        	call8	4200acf0 <_ZNKSt9type_infoeqERKS_$isra$0>
4200ad68:	6a8c      	beqz.n	a10, 4200ad72 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x32>
4200ad6a:	180c      	movi.n	a8, 1
4200ad6c:	0369      	s32i.n	a6, a3, 0
4200ad6e:	1349      	s32i.n	a4, a3, 4
4200ad70:	3389      	s32i.n	a8, a3, 12
4200ad72:	020c      	movi.n	a2, 0
4200ad74:	f01d      	retw.n
	...

4200ad78 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj>:
4200ad78:	004136        	entry	a1, 32
4200ad7b:	12a8      	l32i.n	a10, a2, 4
4200ad7d:	0123b2        	l32i	a11, a3, 4
4200ad80:	027d      	mov.n	a7, a2
4200ad82:	201110        	or	a1, a1, a1
4200ad85:	fff6a5        	call8	4200acf0 <_ZNKSt9type_infoeqERKS_$isra$0>
4200ad88:	0a2d      	mov.n	a2, a10
4200ad8a:	0adc      	bnez.n	a10, 4200ad9e <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
4200ad8c:	0e45f6        	bgeui	a5, 4, 4200ad9e <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
4200ad8f:	0388      	l32i.n	a8, a3, 0
4200ad91:	04cd      	mov.n	a12, a4
4200ad93:	5888      	l32i.n	a8, a8, 20
4200ad95:	07bd      	mov.n	a11, a7
4200ad97:	03ad      	mov.n	a10, a3
4200ad99:	0008e0        	callx8	a8
4200ad9c:	0a2d      	mov.n	a2, a10
4200ad9e:	f01d      	retw.n

4200ada0 <_ZdlPv>:
4200ada0:	004136        	entry	a1, 32
4200ada3:	20a220        	or	a10, a2, a2
4200ada6:	d5f081        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200ada9:	0008e0        	callx8	a8
4200adac:	f01d      	retw.n
	...

4200adb0 <_ZNK9__gnu_cxx24__concurrence_lock_error4whatEv>:
4200adb0:	004136        	entry	a1, 32
4200adb3:	d7c421        	l32r	a2, 42000cc4 <_stext+0xca4> (3c0294a7 <_ZTISt12out_of_range+0x1b>)
4200adb6:	f01d      	retw.n

4200adb8 <_ZNK9__gnu_cxx26__concurrence_unlock_error4whatEv>:
4200adb8:	004136        	entry	a1, 32
4200adbb:	d7c321        	l32r	a2, 42000cc8 <_stext+0xca8> (3c0294cb <_ZTISt12out_of_range+0x3f>)
4200adbe:	f01d      	retw.n

4200adc0 <_ZN9__gnu_cxx24__concurrence_lock_errorD1Ev>:
4200adc0:	004136        	entry	a1, 32
4200adc3:	d7c281        	l32r	a8, 42000ccc <_stext+0xcac> (3c029784 <_ZTVN9__gnu_cxx24__concurrence_lock_errorE+0x8>)
4200adc6:	02ad      	mov.n	a10, a2
4200adc8:	0289      	s32i.n	a8, a2, 0
4200adca:	201110        	or	a1, a1, a1
4200adcd:	0ad2a5        	call8	42015af8 <_ZNSt9exceptionD1Ev>
4200add0:	f01d      	retw.n
	...

4200add4 <_ZN9__gnu_cxx24__concurrence_lock_errorD0Ev>:
4200add4:	004136        	entry	a1, 32
4200add7:	20a220        	or	a10, a2, a2
4200adda:	201110        	or	a1, a1, a1
4200addd:	fffe25        	call8	4200adc0 <_ZN9__gnu_cxx24__concurrence_lock_errorD1Ev>
4200ade0:	4b0c      	movi.n	a11, 4
4200ade2:	02ad      	mov.n	a10, a2
4200ade4:	201110        	or	a1, a1, a1
4200ade7:	ffbda5        	call8	4200a9c0 <_ZdlPvj>
4200adea:	f01d      	retw.n

4200adec <_ZN9__gnu_cxx26__concurrence_unlock_errorD1Ev>:
4200adec:	004136        	entry	a1, 32
4200adef:	d7b881        	l32r	a8, 42000cd0 <_stext+0xcb0> (3c029798 <_ZTVN9__gnu_cxx26__concurrence_unlock_errorE+0x8>)
4200adf2:	02ad      	mov.n	a10, a2
4200adf4:	0289      	s32i.n	a8, a2, 0
4200adf6:	201110        	or	a1, a1, a1
4200adf9:	0acfe5        	call8	42015af8 <_ZNSt9exceptionD1Ev>
4200adfc:	f01d      	retw.n
	...

4200ae00 <_ZN9__gnu_cxx26__concurrence_unlock_errorD0Ev>:
4200ae00:	004136        	entry	a1, 32
4200ae03:	20a220        	or	a10, a2, a2
4200ae06:	201110        	or	a1, a1, a1
4200ae09:	fffe25        	call8	4200adec <_ZN9__gnu_cxx26__concurrence_unlock_errorD1Ev>
4200ae0c:	4b0c      	movi.n	a11, 4
4200ae0e:	02ad      	mov.n	a10, a2
4200ae10:	201110        	or	a1, a1, a1
4200ae13:	ffbae5        	call8	4200a9c0 <_ZdlPvj>
4200ae16:	f01d      	retw.n

4200ae18 <_ZN9__gnu_cxx7__mutex4lockEv>:
4200ae18:	004136        	entry	a1, 32
4200ae1b:	20a220        	or	a10, a2, a2
4200ae1e:	201110        	or	a1, a1, a1
4200ae21:	fb2065        	call8	42006028 <pthread_mutex_lock>
4200ae24:	019a16        	beqz	a10, 4200ae41 <_ZN9__gnu_cxx7__mutex4lockEv+0x29>
4200ae27:	04a0a2        	movi	a10, 4
4200ae2a:	201110        	or	a1, a1, a1
4200ae2d:	0010e5        	call8	4200af3c <__cxa_allocate_exception>
4200ae30:	d7a781        	l32r	a8, 42000ccc <_stext+0xcac> (3c029784 <_ZTVN9__gnu_cxx24__concurrence_lock_errorE+0x8>)
4200ae33:	d7a8c1        	l32r	a12, 42000cd4 <_stext+0xcb4> (4200adc0 <_ZN9__gnu_cxx24__concurrence_lock_errorD1Ev>)
4200ae36:	d7a8b1        	l32r	a11, 42000cd8 <_stext+0xcb8> (3c029738 <_ZTIN9__gnu_cxx24__concurrence_lock_errorE>)
4200ae39:	0a89      	s32i.n	a8, a10, 0
4200ae3b:	201110        	or	a1, a1, a1
4200ae3e:	0061e5        	call8	4200b45c <__wrap___cxa_throw>
4200ae41:	f01d      	retw.n
	...

4200ae44 <_ZN9__gnu_cxx7__mutex6unlockEv>:
4200ae44:	004136        	entry	a1, 32
4200ae47:	20a220        	or	a10, a2, a2
4200ae4a:	201110        	or	a1, a1, a1
4200ae4d:	fb1fe5        	call8	4200604c <pthread_mutex_unlock>
4200ae50:	019a16        	beqz	a10, 4200ae6d <_ZN9__gnu_cxx7__mutex6unlockEv+0x29>
4200ae53:	04a0a2        	movi	a10, 4
4200ae56:	201110        	or	a1, a1, a1
4200ae59:	000e25        	call8	4200af3c <__cxa_allocate_exception>
4200ae5c:	d79d81        	l32r	a8, 42000cd0 <_stext+0xcb0> (3c029798 <_ZTVN9__gnu_cxx26__concurrence_unlock_errorE+0x8>)
4200ae5f:	d79fc1        	l32r	a12, 42000cdc <_stext+0xcbc> (4200adec <_ZN9__gnu_cxx26__concurrence_unlock_errorD1Ev>)
4200ae62:	d79fb1        	l32r	a11, 42000ce0 <_stext+0xcc0> (3c029770 <_ZTIN9__gnu_cxx26__concurrence_unlock_errorE>)
4200ae65:	0a89      	s32i.n	a8, a10, 0
4200ae67:	201110        	or	a1, a1, a1
4200ae6a:	005f25        	call8	4200b45c <__wrap___cxa_throw>
4200ae6d:	f01d      	retw.n
	...

4200ae70 <_ZN12_GLOBAL__N_14pool8allocateEj$constprop$0>:
4200ae70:	004136        	entry	a1, 32
4200ae73:	d79d71        	l32r	a7, 42000ce8 <_stext+0xcc8> (3fc95130 <_ZN12_GLOBAL__N_114emergency_poolE>)
4200ae76:	10c222        	addi	a2, a2, 16
4200ae79:	07ad      	mov.n	a10, a7
4200ae7b:	201110        	or	a1, a1, a1
4200ae7e:	fff9a5        	call8	4200ae18 <_ZN9__gnu_cxx7__mutex4lockEv>
4200ae81:	880c      	movi.n	a8, 8
4200ae83:	732280        	maxu	a2, a2, a8
4200ae86:	82fb      	addi.n	a8, a2, 15
4200ae88:	097c      	movi.n	a9, -16
4200ae8a:	108890        	and	a8, a8, a9
4200ae8d:	1728      	l32i.n	a2, a7, 4
4200ae8f:	d79591        	l32r	a9, 42000ce4 <_stext+0xcc4> (3fc95134 <_ZN12_GLOBAL__N_114emergency_poolE+0x4>)
4200ae92:	0000c6        	j	4200ae99 <_ZN12_GLOBAL__N_14pool8allocateEj$constprop$0+0x29>
4200ae95:	924b      	addi.n	a9, a2, 4
4200ae97:	1228      	l32i.n	a2, a2, 4
4200ae99:	42ac      	beqz.n	a2, 4200aec1 <_ZN12_GLOBAL__N_14pool8allocateEj$constprop$0+0x51>
4200ae9b:	0928      	l32i.n	a2, a9, 0
4200ae9d:	02b8      	l32i.n	a11, a2, 0
4200ae9f:	f23b87        	bltu	a11, a8, 4200ae95 <_ZN12_GLOBAL__N_14pool8allocateEj$constprop$0+0x25>
4200aea2:	c0db80        	sub	a13, a11, a8
4200aea5:	12c8      	l32i.n	a12, a2, 4
4200aea7:	0d8db6        	bltui	a13, 8, 4200aeb8 <_ZN12_GLOBAL__N_14pool8allocateEj$constprop$0+0x48>
4200aeaa:	a28a      	add.n	a10, a2, a8
4200aeac:	1ac9      	s32i.n	a12, a10, 4
4200aeae:	0928      	l32i.n	a2, a9, 0
4200aeb0:	0ad9      	s32i.n	a13, a10, 0
4200aeb2:	0289      	s32i.n	a8, a2, 0
4200aeb4:	000106        	j	4200aebc <_ZN12_GLOBAL__N_14pool8allocateEj$constprop$0+0x4c>
4200aeb7:	0cad00        	lsi	f0, a13, 48
4200aeba:	02b9      	s32i.n	a11, a2, 0
4200aebc:	09a9      	s32i.n	a10, a9, 0
4200aebe:	10c222        	addi	a2, a2, 16
4200aec1:	07ad      	mov.n	a10, a7
4200aec3:	201110        	or	a1, a1, a1
4200aec6:	fff7e5        	call8	4200ae44 <_ZN9__gnu_cxx7__mutex6unlockEv>
4200aec9:	f01d      	retw.n
	...

4200aecc <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0>:
4200aecc:	004136        	entry	a1, 32
4200aecf:	d78671        	l32r	a7, 42000ce8 <_stext+0xcc8> (3fc95130 <_ZN12_GLOBAL__N_114emergency_poolE>)
4200aed2:	f0c222        	addi	a2, a2, -16
4200aed5:	07ad      	mov.n	a10, a7
4200aed7:	201110        	or	a1, a1, a1
4200aeda:	fff3e5        	call8	4200ae18 <_ZN9__gnu_cxx7__mutex4lockEv>
4200aedd:	1788      	l32i.n	a8, a7, 4
4200aedf:	588c      	beqz.n	a8, 4200aee8 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x1c>
4200aee1:	0298      	l32i.n	a9, a2, 0
4200aee3:	b29a      	add.n	a11, a2, a9
4200aee5:	04bb87        	bgeu	a11, a8, 4200aeed <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x21>
4200aee8:	1289      	s32i.n	a8, a2, 4
4200aeea:	0003c6        	j	4200aefd <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x31>
4200aeed:	d77dd1        	l32r	a13, 42000ce4 <_stext+0xcc4> (3fc95134 <_ZN12_GLOBAL__N_114emergency_poolE+0x4>)
4200aef0:	1298b7        	bne	a8, a11, 4200af06 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x3a>
4200aef3:	18a8      	l32i.n	a10, a8, 4
4200aef5:	0888      	l32i.n	a8, a8, 0
4200aef7:	12a9      	s32i.n	a10, a2, 4
4200aef9:	889a      	add.n	a8, a8, a9
4200aefb:	0289      	s32i.n	a8, a2, 0
4200aefd:	1729      	s32i.n	a2, a7, 4
4200aeff:	000bc6        	j	4200af32 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x66>
4200af02:	d84b      	addi.n	a13, a8, 4
4200af04:	0c8d      	mov.n	a8, a12
4200af06:	18c8      	l32i.n	a12, a8, 4
4200af08:	cc8c      	beqz.n	a12, 4200af18 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x4c>
4200af0a:	f43cb7        	bltu	a12, a11, 4200af02 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x36>
4200af0d:	079bc7        	bne	a11, a12, 4200af18 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x4c>
4200af10:	0ba8      	l32i.n	a10, a11, 0
4200af12:	99aa      	add.n	a9, a9, a10
4200af14:	1ba8      	l32i.n	a10, a11, 4
4200af16:	18a9      	s32i.n	a10, a8, 4
4200af18:	0d88      	l32i.n	a8, a13, 0
4200af1a:	08b8      	l32i.n	a11, a8, 0
4200af1c:	a8ba      	add.n	a10, a8, a11
4200af1e:	0692a7        	bne	a2, a10, 4200af28 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x5c>
4200af21:	bb9a      	add.n	a11, a11, a9
4200af23:	08b9      	s32i.n	a11, a8, 0
4200af25:	000246        	j	4200af32 <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0+0x66>
4200af28:	1888      	l32i.n	a8, a8, 4
4200af2a:	0299      	s32i.n	a9, a2, 0
4200af2c:	1289      	s32i.n	a8, a2, 4
4200af2e:	0d88      	l32i.n	a8, a13, 0
4200af30:	1829      	s32i.n	a2, a8, 4
4200af32:	07ad      	mov.n	a10, a7
4200af34:	201110        	or	a1, a1, a1
4200af37:	fff0e5        	call8	4200ae44 <_ZN9__gnu_cxx7__mutex6unlockEv>
4200af3a:	f01d      	retw.n

4200af3c <__cxa_allocate_exception>:
4200af3c:	004136        	entry	a1, 32
4200af3f:	60c272        	addi	a7, a2, 96
4200af42:	07ad      	mov.n	a10, a7
4200af44:	d61081        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200af47:	0008e0        	callx8	a8
4200af4a:	0a2d      	mov.n	a2, a10
4200af4c:	0adc      	bnez.n	a10, 4200af60 <__cxa_allocate_exception+0x24>
4200af4e:	07ad      	mov.n	a10, a7
4200af50:	201110        	or	a1, a1, a1
4200af53:	fff1e5        	call8	4200ae70 <_ZN12_GLOBAL__N_14pool8allocateEj$constprop$0>
4200af56:	0a2d      	mov.n	a2, a10
4200af58:	4acc      	bnez.n	a10, 4200af60 <__cxa_allocate_exception+0x24>
4200af5a:	201110        	or	a1, a1, a1
4200af5d:	002825        	call8	4200b1e0 <_ZSt9terminatev>
4200af60:	60a0c2        	movi	a12, 96
4200af63:	0b0c      	movi.n	a11, 0
4200af65:	02ad      	mov.n	a10, a2
4200af67:	d4e681        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200af6a:	0008e0        	callx8	a8
4200af6d:	60c222        	addi	a2, a2, 96
4200af70:	f01d      	retw.n
	...

4200af74 <__cxa_free_exception>:
4200af74:	004136        	entry	a1, 32
4200af77:	d75c81        	l32r	a8, 42000ce8 <_stext+0xcc8> (3fc95130 <_ZN12_GLOBAL__N_114emergency_poolE>)
4200af7a:	a0c2a2        	addi	a10, a2, -96
4200af7d:	2898      	l32i.n	a9, a8, 8
4200af7f:	3888      	l32i.n	a8, a8, 12
4200af81:	808980        	add	a8, a9, a8
4200af84:	0cba87        	bgeu	a10, a8, 4200af94 <__cxa_free_exception+0x20>
4200af87:	09b9a7        	bgeu	a9, a10, 4200af94 <__cxa_free_exception+0x20>
4200af8a:	201110        	or	a1, a1, a1
4200af8d:	fff3e5        	call8	4200aecc <_ZN12_GLOBAL__N_14pool4freeEPv$constprop$0>
4200af90:	000186        	j	4200af9a <__cxa_free_exception+0x26>
4200af93:	758100        	extui	a8, a0, 17, 8
4200af96:	08e0d5        	call4	42013da4 <_svfiprintf_r+0x3cc>
4200af99:	f01d00        	subx8	a1, a13, a0

4200af9c <_ZNKSt17basic_string_viewIcSt11char_traitsIcEE7compareEjjPKcj>:
4200af9c:	004136        	entry	a1, 32
4200af9f:	02d8      	l32i.n	a13, a2, 0
4200afa1:	05bd      	mov.n	a11, a5
4200afa3:	0dbd37        	bgeu	a13, a3, 4200afb4 <_ZNKSt17basic_string_viewIcSt11char_traitsIcEE7compareEjjPKcj+0x18>
4200afa6:	d751b1        	l32r	a11, 42000cec <_stext+0xccc> (3c0294f1 <_ZTISt12out_of_range+0x65>)
4200afa9:	d751a1        	l32r	a10, 42000cf0 <_stext+0xcd0> (3c02950b <_ZTISt12out_of_range+0x7f>)
4200afac:	03cd      	mov.n	a12, a3
4200afae:	201110        	or	a1, a1, a1
4200afb1:	ffc625        	call8	4200ac14 <_ZSt24__throw_out_of_range_fmtPKcz>
4200afb4:	c0dd30        	sub	a13, a13, a3
4200afb7:	634d40        	minu	a4, a13, a4
4200afba:	63c640        	minu	a12, a6, a4
4200afbd:	cc8c      	beqz.n	a12, 4200afcd <_ZNKSt17basic_string_viewIcSt11char_traitsIcEE7compareEjjPKcj+0x31>
4200afbf:	12a8      	l32i.n	a10, a2, 4
4200afc1:	aa3a      	add.n	a10, a10, a3
4200afc3:	d64081        	l32r	a8, 420008c4 <_stext+0x8a4> (4000120c <memcmp>)
4200afc6:	0008e0        	callx8	a8
4200afc9:	0a2d      	mov.n	a2, a10
4200afcb:	1acc      	bnez.n	a10, 4200afd0 <_ZNKSt17basic_string_viewIcSt11char_traitsIcEE7compareEjjPKcj+0x34>
4200afcd:	c02460        	sub	a2, a4, a6
4200afd0:	f01d      	retw.n
	...

4200afd4 <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv>:
4200afd4:	00a136        	entry	a1, 80
4200afd7:	d74461        	l32r	a6, 42000ce8 <_stext+0xcc8> (3fc95130 <_ZN12_GLOBAL__N_114emergency_poolE>)
4200afda:	0b0c      	movi.n	a11, 0
4200afdc:	06ad      	mov.n	a10, a6
4200afde:	201110        	or	a1, a1, a1
4200afe1:	faf9e5        	call8	42005f80 <pthread_mutex_init>
4200afe4:	050c      	movi.n	a5, 0
4200afe6:	d743a1        	l32r	a10, 42000cf4 <_stext+0xcd4> (3c02953c <_ZTISt12out_of_range+0xb0>)
4200afe9:	1659      	s32i.n	a5, a6, 4
4200afeb:	2659      	s32i.n	a5, a6, 8
4200afed:	3659      	s32i.n	a5, a6, 12
4200afef:	201110        	or	a1, a1, a1
4200aff2:	0048e5        	call8	4200b480 <getenv>
4200aff5:	f80c      	movi.n	a8, 15
4200aff7:	6189      	s32i.n	a8, a1, 24
4200aff9:	d73f81        	l32r	a8, 42000cf8 <_stext+0xcd8> (3c02954d <_ZTISt12out_of_range+0xc1>)
4200affc:	0a7d      	mov.n	a7, a10
4200affe:	7189      	s32i.n	a8, a1, 28
4200b000:	880c      	movi.n	a8, 8
4200b002:	0189      	s32i.n	a8, a1, 0
4200b004:	d73e81        	l32r	a8, 42000cfc <_stext+0xcdc> (3c02955d <_ZTISt12out_of_range+0xd1>)
4200b007:	2159      	s32i.n	a5, a1, 8
4200b009:	1189      	s32i.n	a8, a1, 4
4200b00b:	980c      	movi.n	a8, 9
4200b00d:	3189      	s32i.n	a8, a1, 12
4200b00f:	d73c81        	l32r	a8, 42000d00 <_stext+0xce0> (3c029566 <_ZTISt12out_of_range+0xda>)
4200b012:	18c132        	addi	a3, a1, 24
4200b015:	4189      	s32i.n	a8, a1, 16
4200b017:	084c      	movi.n	a8, 64
4200b019:	5189      	s32i.n	a8, a1, 20
4200b01b:	002306        	j	4200b0ab <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xd7>
4200b01e:	920000        	lsi	f0, a0, 0x248
4200b021:	3c0007        	bnone	a0, a0, 4200b061 <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0x8d>
4200b024:	87a8      	l32i.n	a10, a7, 32
4200b026:	0199      	s32i.n	a9, a1, 0
4200b028:	771b      	addi.n	a7, a7, 1
4200b02a:	fe0c      	movi.n	a14, 15
4200b02c:	07dd      	mov.n	a13, a7
4200b02e:	fc0c      	movi.n	a12, 15
4200b030:	00a0b2        	movi	a11, 0
4200b033:	20a330        	or	a10, a3, a3
4200b036:	201110        	or	a1, a1, a1
4200b039:	fff625        	call8	4200af9c <_ZNKSt17basic_string_viewIcSt11char_traitsIcEE7compareEjjPKcj>
4200b03c:	05ea56        	bnez	a10, 4200b09e <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xca>
4200b03f:	0f0792        	l8ui	a9, a7, 15
4200b042:	e82c      	movi.n	a8, 46
4200b044:	569987        	bne	a9, a8, 4200b09e <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xca>
4200b047:	10c772        	addi	a7, a7, 16
4200b04a:	015d      	mov.n	a5, a1
4200b04c:	0548      	l32i.n	a4, a5, 0
4200b04e:	07dd      	mov.n	a13, a7
4200b050:	04ed      	mov.n	a14, a4
4200b052:	04cd      	mov.n	a12, a4
4200b054:	0b0c      	movi.n	a11, 0
4200b056:	05ad      	mov.n	a10, a5
4200b058:	201110        	or	a1, a1, a1
4200b05b:	fff425        	call8	4200af9c <_ZNKSt17basic_string_viewIcSt11char_traitsIcEE7compareEjjPKcj>
4200b05e:	8acc      	bnez.n	a10, 4200b06a <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0x96>
4200b060:	874a      	add.n	a8, a7, a4
4200b062:	000892        	l8ui	a9, a8, 0
4200b065:	d83c      	movi.n	a8, 61
4200b067:	071987        	beq	a9, a8, 4200b072 <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0x9e>
4200b06a:	55cb      	addi.n	a5, a5, 12
4200b06c:	2e1537        	beq	a5, a3, 4200b09e <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xca>
4200b06f:	fff646        	j	4200b04c <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0x78>
4200b072:	a41b      	addi.n	a10, a4, 1
4200b074:	20c1b2        	addi	a11, a1, 32
4200b077:	a7aa      	add.n	a10, a7, a10
4200b079:	0c0c      	movi.n	a12, 0
4200b07b:	d72281        	l32r	a8, 42000d04 <_stext+0xce4> (400014f4 <strtoul>)
4200b07e:	0008e0        	callx8	a8
4200b081:	8178      	l32i.n	a7, a1, 32
4200b083:	0007b2        	l8ui	a11, a7, 0
4200b086:	c6cb82        	addi	a8, a11, -58
4200b089:	40f890        	nsau	a9, a8
4200b08c:	419590        	srli	a9, a9, 5
4200b08f:	688c      	beqz.n	a8, 4200b099 <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xc5>
4200b091:	180c      	movi.n	a8, 1
4200b093:	9389b0        	movnez	a8, a9, a11
4200b096:	004816        	beqz	a8, 4200b09e <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xca>
4200b099:	001a96        	bltz	a10, 4200b09e <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xca>
4200b09c:	25a9      	s32i.n	a10, a5, 8
4200b09e:	07ad      	mov.n	a10, a7
4200b0a0:	3aa0b2        	movi	a11, 58
4200b0a3:	d71981        	l32r	a8, 42000d08 <_stext+0xce8> (4000138c <strchr>)
4200b0a6:	0008e0        	callx8	a8
4200b0a9:	0a7d      	mov.n	a7, a10
4200b0ab:	f71756        	bnez	a7, 4200b020 <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0x4c>
4200b0ae:	201110        	or	a1, a1, a1
4200b0b1:	0a8825        	call8	42015934 <__cxx_eh_arena_size_get>
4200b0b4:	36a9      	s32i.n	a10, a6, 12
4200b0b6:	0a5d      	mov.n	a5, a10
4200b0b8:	4a9c      	beqz.n	a10, 4200b0d0 <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xfc>
4200b0ba:	d5b281        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200b0bd:	0008e0        	callx8	a8
4200b0c0:	26a9      	s32i.n	a10, a6, 8
4200b0c2:	4acc      	bnez.n	a10, 4200b0ca <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xf6>
4200b0c4:	3679      	s32i.n	a7, a6, 12
4200b0c6:	000186        	j	4200b0d0 <_GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv+0xfc>
4200b0c9:	16a900        	lsi	f0, a9, 88
4200b0cc:	0a59      	s32i.n	a5, a10, 0
4200b0ce:	1a79      	s32i.n	a7, a10, 4
4200b0d0:	f01d      	retw.n
	...

4200b0d4 <__cxa_begin_catch>:
4200b0d4:	004136        	entry	a1, 32
4200b0d7:	201110        	or	a1, a1, a1
4200b0da:	000765        	call8	4200b150 <__cxa_get_globals>
4200b0dd:	027d      	mov.n	a7, a2
4200b0df:	d70bc1        	l32r	a12, 42000d0c <_stext+0xcec> (bcd4d500 <_rtc_reserved_end+0x5cc4d500>)
4200b0e2:	07b8      	l32i.n	a11, a7, 0
4200b0e4:	d70bd1        	l32r	a13, 42000d10 <_stext+0xcf0> (b8b1aabc <_rtc_reserved_end+0x58a1aabc>)
4200b0e7:	1798      	l32i.n	a9, a7, 4
4200b0e9:	bbca      	add.n	a11, a11, a12
4200b0eb:	d0c782        	addi	a8, a7, -48
4200b0ee:	0a28      	l32i.n	a2, a10, 0
4200b0f0:	99da      	add.n	a9, a9, a13
4200b0f2:	02bbc7        	bgeu	a11, a12, 4200b0f8 <__cxa_begin_catch+0x24>
4200b0f5:	01c992        	addi	a9, a9, 1
4200b0f8:	19cc      	bnez.n	a9, 4200b0fd <__cxa_begin_catch+0x29>
4200b0fa:	0c2bb6        	bltui	a11, 2, 4200b10a <__cxa_begin_catch+0x36>
4200b0fd:	428c      	beqz.n	a2, 4200b105 <__cxa_begin_catch+0x31>
4200b0ff:	201110        	or	a1, a1, a1
4200b102:	000de5        	call8	4200b1e0 <_ZSt9terminatev>
4200b105:	0a89      	s32i.n	a8, a10, 0
4200b107:	000706        	j	4200b127 <__cxa_begin_catch+0x53>
4200b10a:	58b8      	l32i.n	a11, a8, 20
4200b10c:	9b1b      	addi.n	a9, a11, 1
4200b10e:	004bd6        	bgez	a11, 4200b116 <__cxa_begin_catch+0x42>
4200b111:	9b0b      	addi.n	a9, a11, -1
4200b113:	609090        	neg	a9, a9
4200b116:	5899      	s32i.n	a9, a8, 20
4200b118:	1a98      	l32i.n	a9, a10, 4
4200b11a:	990b      	addi.n	a9, a9, -1
4200b11c:	1a99      	s32i.n	a9, a10, 4
4200b11e:	031287        	beq	a2, a8, 4200b125 <__cxa_begin_catch+0x51>
4200b121:	4829      	s32i.n	a2, a8, 16
4200b123:	0a89      	s32i.n	a8, a10, 0
4200b125:	a828      	l32i.n	a2, a8, 40
4200b127:	f01d      	retw.n
4200b129:	000000        	ill

4200b12c <_ZL15eh_globals_dtorPv>:
4200b12c:	004136        	entry	a1, 32
4200b12f:	b29c      	beqz.n	a2, 4200b14e <_ZL15eh_globals_dtorPv+0x22>
4200b131:	02a8      	l32i.n	a10, a2, 0
4200b133:	000306        	j	4200b143 <_ZL15eh_globals_dtorPv+0x17>
4200b136:	4a78      	l32i.n	a7, a10, 16
4200b138:	30caa2        	addi	a10, a10, 48
4200b13b:	201110        	or	a1, a1, a1
4200b13e:	002fe5        	call8	4200b43c <__wrap__Unwind_DeleteException>
4200b141:	07ad      	mov.n	a10, a7
4200b143:	fefa56        	bnez	a10, 4200b136 <_ZL15eh_globals_dtorPv+0xa>
4200b146:	02ad      	mov.n	a10, a2
4200b148:	d50881        	l32r	a8, 42000568 <_stext+0x548> (4037fe9c <cfree>)
4200b14b:	0008e0        	callx8	a8
4200b14e:	f01d      	retw.n

4200b150 <__cxa_get_globals>:
4200b150:	004136        	entry	a1, 32
4200b153:	d6f181        	l32r	a8, 42000d18 <_stext+0xcf8> (3fc95144 <_ZN17__eh_globals_init7_S_initE>)
4200b156:	d6ef21        	l32r	a2, 42000d14 <_stext+0xcf4> (3fc95148 <_ZN12_GLOBAL__N_110eh_globalsE>)
4200b159:	000882        	l8ui	a8, a8, 0
4200b15c:	08bc      	beqz.n	a8, 4200b190 <__cxa_get_globals+0x40>
4200b15e:	d6ef71        	l32r	a7, 42000d1c <_stext+0xcfc> (3fc95140 <_ZL4init>)
4200b161:	07a8      	l32i.n	a10, a7, 0
4200b163:	201110        	or	a1, a1, a1
4200b166:	fb01e5        	call8	42006184 <pthread_getspecific>
4200b169:	0a2d      	mov.n	a2, a10
4200b16b:	1aec      	bnez.n	a10, 4200b190 <__cxa_get_globals+0x40>
4200b16d:	8a0c      	movi.n	a10, 8
4200b16f:	d58581        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200b172:	0008e0        	callx8	a8
4200b175:	0a2d      	mov.n	a2, a10
4200b177:	4acc      	bnez.n	a10, 4200b17f <__cxa_get_globals+0x2f>
4200b179:	201110        	or	a1, a1, a1
4200b17c:	000625        	call8	4200b1e0 <_ZSt9terminatev>
4200b17f:	0abd      	mov.n	a11, a10
4200b181:	07a8      	l32i.n	a10, a7, 0
4200b183:	201110        	or	a1, a1, a1
4200b186:	fb01a5        	call8	420061a0 <pthread_setspecific>
4200b189:	feca56        	bnez	a10, 4200b179 <__cxa_get_globals+0x29>
4200b18c:	02a9      	s32i.n	a10, a2, 0
4200b18e:	12a9      	s32i.n	a10, a2, 4
4200b190:	f01d      	retw.n
	...

4200b194 <_GLOBAL__sub_I__ZN17__eh_globals_init7_S_initE>:
4200b194:	004136        	entry	a1, 32
4200b197:	d6e2b1        	l32r	a11, 42000d20 <_stext+0xd00> (4200b12c <_ZL15eh_globals_dtorPv>)
4200b19a:	d6e0a1        	l32r	a10, 42000d1c <_stext+0xcfc> (3fc95140 <_ZL4init>)
4200b19d:	201110        	or	a1, a1, a1
4200b1a0:	faf925        	call8	42006134 <pthread_key_create>
4200b1a3:	d6dd81        	l32r	a8, 42000d18 <_stext+0xcf8> (3fc95144 <_ZN17__eh_globals_init7_S_initE>)
4200b1a6:	40faa0        	nsau	a10, a10
4200b1a9:	41a5a0        	srli	a10, a10, 5
4200b1ac:	0048a2        	s8i	a10, a8, 0
4200b1af:	f01d      	retw.n
4200b1b1:	000000        	ill

4200b1b4 <_ZN10__cxxabiv111__terminateEPFvvE>:
4200b1b4:	004136        	entry	a1, 32
4200b1b7:	0002e0        	callx8	a2
4200b1ba:	d3ce81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200b1bd:	0008e0        	callx8	a8
4200b1c0:	02ad      	mov.n	a10, a2
4200b1c2:	201110        	or	a1, a1, a1
4200b1c5:	fff0e5        	call8	4200b0d4 <__cxa_begin_catch>
4200b1c8:	d3cb81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200b1cb:	0008e0        	callx8	a8
	...

4200b1d0 <_ZSt13get_terminatev>:
4200b1d0:	004136        	entry	a1, 32
4200b1d3:	d6d481        	l32r	a8, 42000d24 <_stext+0xd04> (3fc927b0 <_ZN10__cxxabiv119__terminate_handlerE>)
4200b1d6:	0020c0        	memw
4200b1d9:	0828      	l32i.n	a2, a8, 0
4200b1db:	0020c0        	memw
4200b1de:	f01d      	retw.n

4200b1e0 <_ZSt9terminatev>:
4200b1e0:	004136        	entry	a1, 32
4200b1e3:	201110        	or	a1, a1, a1
4200b1e6:	fffea5        	call8	4200b1d0 <_ZSt13get_terminatev>
4200b1e9:	201110        	or	a1, a1, a1
4200b1ec:	fffc65        	call8	4200b1b4 <_ZN10__cxxabiv111__terminateEPFvvE>
	...

4200b1f0 <_ZNSt11logic_errorD1Ev>:
4200b1f0:	006136        	entry	a1, 48
4200b1f3:	d6cd81        	l32r	a8, 42000d28 <_stext+0xd08> (3c0297ac <_ZTVSt11logic_error+0x8>)
4200b1f6:	12a8      	l32i.n	a10, a2, 4
4200b1f8:	0289      	s32i.n	a8, a2, 0
4200b1fa:	01bd      	mov.n	a11, a1
4200b1fc:	f4caa2        	addi	a10, a10, -12
4200b1ff:	201110        	or	a1, a1, a1
4200b202:	0018a5        	call8	4200b38c <_ZNSs4_Rep10_M_disposeERKSaIcE>
4200b205:	02ad      	mov.n	a10, a2
4200b207:	201110        	or	a1, a1, a1
4200b20a:	0a8ee5        	call8	42015af8 <_ZNSt9exceptionD1Ev>
4200b20d:	f01d      	retw.n
	...

4200b210 <_ZNSt11logic_errorD0Ev>:
4200b210:	004136        	entry	a1, 32
4200b213:	20a220        	or	a10, a2, a2
4200b216:	201110        	or	a1, a1, a1
4200b219:	fffd65        	call8	4200b1f0 <_ZNSt11logic_errorD1Ev>
4200b21c:	02ad      	mov.n	a10, a2
4200b21e:	201110        	or	a1, a1, a1
4200b221:	ffb7e5        	call8	4200ada0 <_ZdlPv>
4200b224:	f01d      	retw.n
	...

4200b228 <_ZNSt12length_errorD1Ev>:
4200b228:	004136        	entry	a1, 32
4200b22b:	d6c081        	l32r	a8, 42000d2c <_stext+0xd0c> (3c0297c0 <_ZTVSt12length_error+0x8>)
4200b22e:	02ad      	mov.n	a10, a2
4200b230:	0289      	s32i.n	a8, a2, 0
4200b232:	201110        	or	a1, a1, a1
4200b235:	fffba5        	call8	4200b1f0 <_ZNSt11logic_errorD1Ev>
4200b238:	f01d      	retw.n
	...

4200b23c <_ZNSt12length_errorD0Ev>:
4200b23c:	004136        	entry	a1, 32
4200b23f:	20a220        	or	a10, a2, a2
4200b242:	201110        	or	a1, a1, a1
4200b245:	fffe25        	call8	4200b228 <_ZNSt12length_errorD1Ev>
4200b248:	02ad      	mov.n	a10, a2
4200b24a:	201110        	or	a1, a1, a1
4200b24d:	ffb525        	call8	4200ada0 <_ZdlPv>
4200b250:	f01d      	retw.n
	...

4200b254 <_ZNSt12out_of_rangeD1Ev>:
4200b254:	004136        	entry	a1, 32
4200b257:	d6b681        	l32r	a8, 42000d30 <_stext+0xd10> (3c0297d4 <_ZTVSt12out_of_range+0x8>)
4200b25a:	02ad      	mov.n	a10, a2
4200b25c:	0289      	s32i.n	a8, a2, 0
4200b25e:	201110        	or	a1, a1, a1
4200b261:	fff8e5        	call8	4200b1f0 <_ZNSt11logic_errorD1Ev>
4200b264:	f01d      	retw.n
	...

4200b268 <_ZNSt12out_of_rangeD0Ev>:
4200b268:	004136        	entry	a1, 32
4200b26b:	20a220        	or	a10, a2, a2
4200b26e:	201110        	or	a1, a1, a1
4200b271:	fffe25        	call8	4200b254 <_ZNSt12out_of_rangeD1Ev>
4200b274:	02ad      	mov.n	a10, a2
4200b276:	201110        	or	a1, a1, a1
4200b279:	ffb265        	call8	4200ada0 <_ZdlPv>
4200b27c:	f01d      	retw.n
	...

4200b280 <_ZNSt11logic_errorC1EPKc>:
4200b280:	006136        	entry	a1, 48
4200b283:	d6a981        	l32r	a8, 42000d28 <_stext+0xd08> (3c0297ac <_ZTVSt11logic_error+0x8>)
4200b286:	03bd      	mov.n	a11, a3
4200b288:	0289      	s32i.n	a8, a2, 0
4200b28a:	01cd      	mov.n	a12, a1
4200b28c:	04c2a2        	addi	a10, a2, 4
4200b28f:	207220        	or	a7, a2, a2
4200b292:	201110        	or	a1, a1, a1
4200b295:	0016a5        	call8	4200b400 <_ZNSsC1EPKcRKSaIcE>
4200b298:	000406        	j	4200b2ac <_ZNSt11logic_errorC1EPKc+0x2c>
4200b29b:	07ad00        	lsi	f0, a13, 28
4200b29e:	201110        	or	a1, a1, a1
4200b2a1:	0a8565        	call8	42015af8 <_ZNSt9exceptionD1Ev>
4200b2a4:	02ad      	mov.n	a10, a2
4200b2a6:	201110        	or	a1, a1, a1
4200b2a9:	001865        	call8	4200b430 <__wrap__Unwind_Resume>
4200b2ac:	f01d      	retw.n
	...

4200b2b0 <_ZNSt12length_errorC1EPKc>:
4200b2b0:	004136        	entry	a1, 32
4200b2b3:	03bd      	mov.n	a11, a3
4200b2b5:	02ad      	mov.n	a10, a2
4200b2b7:	201110        	or	a1, a1, a1
4200b2ba:	fffc65        	call8	4200b280 <_ZNSt11logic_errorC1EPKc>
4200b2bd:	d69b81        	l32r	a8, 42000d2c <_stext+0xd0c> (3c0297c0 <_ZTVSt12length_error+0x8>)
4200b2c0:	0289      	s32i.n	a8, a2, 0
4200b2c2:	f01d      	retw.n

4200b2c4 <_ZNSt12out_of_rangeC1EPKc>:
4200b2c4:	004136        	entry	a1, 32
4200b2c7:	03bd      	mov.n	a11, a3
4200b2c9:	02ad      	mov.n	a10, a2
4200b2cb:	201110        	or	a1, a1, a1
4200b2ce:	fffb25        	call8	4200b280 <_ZNSt11logic_errorC1EPKc>
4200b2d1:	d69781        	l32r	a8, 42000d30 <_stext+0xd10> (3c0297d4 <_ZTVSt12out_of_range+0x8>)
4200b2d4:	0289      	s32i.n	a8, a2, 0
4200b2d6:	f01d      	retw.n

4200b2d8 <_ZNSs7_M_copyEPcPKcj>:
4200b2d8:	004136        	entry	a1, 32
4200b2db:	02ad      	mov.n	a10, a2
4200b2dd:	03bd      	mov.n	a11, a3
4200b2df:	04cd      	mov.n	a12, a4
4200b2e1:	081466        	bnei	a4, 1, 4200b2ed <_ZNSs7_M_copyEPcPKcj+0x15>
4200b2e4:	000382        	l8ui	a8, a3, 0
4200b2e7:	004282        	s8i	a8, a2, 0
4200b2ea:	0001c6        	j	4200b2f5 <_ZNSs7_M_copyEPcPKcj+0x1d>
4200b2ed:	448c      	beqz.n	a4, 4200b2f5 <_ZNSs7_M_copyEPcPKcj+0x1d>
4200b2ef:	d34e81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200b2f2:	0008e0        	callx8	a8
4200b2f5:	f01d      	retw.n
	...

4200b2f8 <_ZNSs13_S_copy_charsEPcPKcS1_>:
4200b2f8:	004136        	entry	a1, 32
4200b2fb:	02ad      	mov.n	a10, a2
4200b2fd:	03bd      	mov.n	a11, a3
4200b2ff:	c0c430        	sub	a12, a4, a3
4200b302:	201110        	or	a1, a1, a1
4200b305:	fffd25        	call8	4200b2d8 <_ZNSs7_M_copyEPcPKcj>
4200b308:	f01d      	retw.n
	...

4200b30c <_ZNSs4_Rep26_M_set_length_and_sharableEj>:
4200b30c:	004136        	entry	a1, 32
4200b30f:	d68981        	l32r	a8, 42000d34 <_stext+0xd14> (3fc95150 <_ZNSs4_Rep20_S_empty_rep_storageE>)
4200b312:	0a1287        	beq	a2, a8, 4200b320 <_ZNSs4_Rep26_M_set_length_and_sharableEj+0x14>
4200b315:	080c      	movi.n	a8, 0
4200b317:	2289      	s32i.n	a8, a2, 8
4200b319:	0239      	s32i.n	a3, a2, 0
4200b31b:	223a      	add.n	a2, a2, a3
4200b31d:	0c4282        	s8i	a8, a2, 12
4200b320:	f01d      	retw.n
	...

4200b324 <_ZNSs4_Rep9_S_createEjjRKSaIcE>:
4200b324:	004136        	entry	a1, 32
4200b327:	d68491        	l32r	a9, 42000d38 <_stext+0xd18> (3ffffffc <ets_rom_layout_p+0xe0000>)
4200b32a:	027d      	mov.n	a7, a2
4200b32c:	08b927        	bgeu	a9, a2, 4200b338 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x14>
4200b32f:	d683a1        	l32r	a10, 42000d3c <_stext+0xd1c> (3c029570 <_ZTISt12out_of_range+0xe4>)
4200b332:	201110        	or	a1, a1, a1
4200b335:	ff86e5        	call8	4200aba4 <_ZSt20__throw_length_errorPKc>
4200b338:	04b327        	bgeu	a3, a2, 4200b340 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x1c>
4200b33b:	833a      	add.n	a8, a3, a3
4200b33d:	737280        	maxu	a7, a2, a8
4200b340:	1a0c      	movi.n	a10, 1
4200b342:	1dc782        	addi	a8, a7, 29
4200b345:	11aa40        	slli	a10, a10, 12
4200b348:	15ba87        	bgeu	a10, a8, 4200b361 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x3d>
4200b34b:	12b377        	bgeu	a3, a7, 4200b361 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x3d>
4200b34e:	10d772        	addmi	a7, a7, 0x1000
4200b351:	b48080        	extui	a8, a8, 0, 12
4200b354:	c07780        	sub	a7, a7, a8
4200b357:	637790        	minu	a7, a7, a9
4200b35a:	a7db      	addi.n	a10, a7, 13
4200b35c:	000306        	j	4200b36c <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x48>
4200b35f:	00          	.byte	00
4200b360:	00          	.byte	00
4200b361:	a7db      	addi.n	a10, a7, 13
4200b363:	005ad6        	bgez	a10, 4200b36c <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x48>
4200b366:	201110        	or	a1, a1, a1
4200b369:	ff7e25        	call8	4200ab4c <_ZSt17__throw_bad_allocv>
4200b36c:	201110        	or	a1, a1, a1
4200b36f:	ff6725        	call8	4200a9e0 <_Znwj>
4200b372:	080c      	movi.n	a8, 0
4200b374:	0a2d      	mov.n	a2, a10
4200b376:	1a79      	s32i.n	a7, a10, 4
4200b378:	2a89      	s32i.n	a8, a10, 8
4200b37a:	f01d      	retw.n

4200b37c <_ZNSs4_Rep10_M_destroyERKSaIcE>:
4200b37c:	004136        	entry	a1, 32
4200b37f:	20a220        	or	a10, a2, a2
4200b382:	201110        	or	a1, a1, a1
4200b385:	ffa1a5        	call8	4200ada0 <_ZdlPv>
4200b388:	f01d      	retw.n
	...

4200b38c <_ZNSs4_Rep10_M_disposeERKSaIcE>:
4200b38c:	004136        	entry	a1, 32
4200b38f:	d66981        	l32r	a8, 42000d34 <_stext+0xd14> (3fc95150 <_ZNSs4_Rep20_S_empty_rep_storageE>)
4200b392:	02ad      	mov.n	a10, a2
4200b394:	03bd      	mov.n	a11, a3
4200b396:	1c1287        	beq	a2, a8, 4200b3b6 <_ZNSs4_Rep10_M_disposeERKSaIcE+0x2a>
4200b399:	0020c0        	memw
4200b39c:	2288      	l32i.n	a8, a2, 8
4200b39e:	089d      	mov.n	a9, a8
4200b3a0:	c80b      	addi.n	a12, a8, -1
4200b3a2:	130c80        	wsr.scompare1	a8
4200b3a5:	02eac2        	s32c1i	a12, a10, 8
4200b3a8:	0c8d      	mov.n	a8, a12
4200b3aa:	f09c97        	bne	a12, a9, 4200b39e <_ZNSs4_Rep10_M_disposeERKSaIcE+0x12>
4200b3ad:	0519e6        	bgei	a9, 1, 4200b3b6 <_ZNSs4_Rep10_M_disposeERKSaIcE+0x2a>
4200b3b0:	201110        	or	a1, a1, a1
4200b3b3:	fffca5        	call8	4200b37c <_ZNSs4_Rep10_M_destroyERKSaIcE>
4200b3b6:	f01d      	retw.n

4200b3b8 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag>:
4200b3b8:	004136        	entry	a1, 32
4200b3bb:	027d      	mov.n	a7, a2
4200b3bd:	04cd      	mov.n	a12, a4
4200b3bf:	361237        	beq	a2, a3, 4200b3f9 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x41>
4200b3c2:	a2ac      	beqz.n	a2, 4200b3f0 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x38>
4200b3c4:	c04320        	sub	a4, a3, a2
4200b3c7:	0b0c      	movi.n	a11, 0
4200b3c9:	04ad      	mov.n	a10, a4
4200b3cb:	201110        	or	a1, a1, a1
4200b3ce:	fff565        	call8	4200b324 <_ZNSs4_Rep9_S_createEjjRKSaIcE>
4200b3d1:	2acb      	addi.n	a2, a10, 12
4200b3d3:	0a6d      	mov.n	a6, a10
4200b3d5:	07bd      	mov.n	a11, a7
4200b3d7:	02ad      	mov.n	a10, a2
4200b3d9:	20c330        	or	a12, a3, a3
4200b3dc:	201110        	or	a1, a1, a1
4200b3df:	fff1a5        	call8	4200b2f8 <_ZNSs13_S_copy_charsEPcPKcS1_>
4200b3e2:	04bd      	mov.n	a11, a4
4200b3e4:	06ad      	mov.n	a10, a6
4200b3e6:	201110        	or	a1, a1, a1
4200b3e9:	fff225        	call8	4200b30c <_ZNSs4_Rep26_M_set_length_and_sharableEj>
4200b3ec:	000306        	j	4200b3fc <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x44>
4200b3ef:	00          	.byte	00
4200b3f0:	d655a1        	l32r	a10, 42000d44 <_stext+0xd24> (3c029588 <_ZTISt12out_of_range+0xfc>)
4200b3f3:	201110        	or	a1, a1, a1
4200b3f6:	ff7765        	call8	4200ab6c <_ZSt19__throw_logic_errorPKc>
4200b3f9:	d65121        	l32r	a2, 42000d40 <_stext+0xd20> (3fc9515c <_ZNSs4_Rep20_S_empty_rep_storageE+0xc>)
4200b3fc:	f01d      	retw.n
	...

4200b400 <_ZNSsC1EPKcRKSaIcE>:
4200b400:	004136        	entry	a1, 32
4200b403:	fb7c      	movi.n	a11, -1
4200b405:	009316        	beqz	a3, 4200b412 <_ZNSsC1EPKcRKSaIcE+0x12>
4200b408:	03ad      	mov.n	a10, a3
4200b40a:	d3a481        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200b40d:	0008e0        	callx8	a8
4200b410:	b3aa      	add.n	a11, a3, a10
4200b412:	0d0c      	movi.n	a13, 0
4200b414:	04cd      	mov.n	a12, a4
4200b416:	03ad      	mov.n	a10, a3
4200b418:	201110        	or	a1, a1, a1
4200b41b:	fff9e5        	call8	4200b3b8 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag>
4200b41e:	02a9      	s32i.n	a10, a2, 0
4200b420:	f01d      	retw.n
	...

4200b424 <_Z12abort_returnIiET_v>:
{
    return abort_expect_void_and_return((void*) context);
}

template<typename T>
static T abort_return()
4200b424:	004136        	entry	a1, 32
{
    abort();
4200b427:	d33381        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200b42a:	0008e0        	callx8	a8
4200b42d:	000000        	ill

4200b430 <__wrap__Unwind_Resume>:
typedef int _Unwind_Exception_Class;
typedef int* _Unwind_Trace_Fn;
typedef int* _Unwind_Stop_Fn;

extern "C" void __wrap__Unwind_Resume(struct _Unwind_Exception *exc)
{
4200b430:	004136        	entry	a1, 32
    abort();
4200b433:	d33081        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200b436:	0008e0        	callx8	a8
4200b439:	000000        	ill

4200b43c <__wrap__Unwind_DeleteException>:
}

extern "C" void __wrap__Unwind_DeleteException(struct _Unwind_Exception *exc)
{
4200b43c:	004136        	entry	a1, 32
    abort();
4200b43f:	d32d81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200b442:	0008e0        	callx8	a8
4200b445:	000000        	ill

4200b448 <__wrap___gxx_personality_v0>:
extern "C" _Unwind_Reason_Code __wrap___gxx_personality_v0(int version,
                                                           _Unwind_Action actions,
                                                           _Unwind_Exception_Class exception_class,
                                                           struct _Unwind_Exception *ue_header,
                                                           struct _Unwind_Context *context)
{
4200b448:	004136        	entry	a1, 32
    return abort_return<_Unwind_Reason_Code>();
4200b44b:	fffda5        	call8	4200b424 <_Z12abort_returnIiET_v>
	...

4200b450 <__wrap___cxa_allocate_exception>:
}

// Reduces binary size since the linker will drop some code due to --gc-sections.
extern "C" void __wrap___cxa_allocate_exception(void)
{
4200b450:	004136        	entry	a1, 32
    abort();
4200b453:	d32881        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200b456:	0008e0        	callx8	a8
4200b459:	000000        	ill

4200b45c <__wrap___cxa_throw>:
}

// Reduces binary size since the linker will drop some code due to --gc-sections.
extern "C" void __wrap___cxa_throw(void)
{
4200b45c:	004136        	entry	a1, 32
    abort();
4200b45f:	d32581        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
4200b462:	0008e0        	callx8	a8
4200b465:	000000        	ill

4200b468 <_findenv>:
4200b468:	004136        	entry	a1, 32
4200b46b:	d4b981        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200b46e:	0008e0        	callx8	a8
4200b471:	02bd      	mov.n	a11, a2
4200b473:	20c330        	or	a12, a3, a3
4200b476:	201110        	or	a1, a1, a1
4200b479:	0001e5        	call8	4200b498 <_findenv_r>
4200b47c:	0a2d      	mov.n	a2, a10
4200b47e:	f01d      	retw.n

4200b480 <getenv>:
4200b480:	006136        	entry	a1, 48
4200b483:	d4b381        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200b486:	0008e0        	callx8	a8
4200b489:	02bd      	mov.n	a11, a2
4200b48b:	20c110        	or	a12, a1, a1
4200b48e:	201110        	or	a1, a1, a1
4200b491:	000065        	call8	4200b498 <_findenv_r>
4200b494:	0a2d      	mov.n	a2, a10
4200b496:	f01d      	retw.n

4200b498 <_findenv_r>:
4200b498:	004136        	entry	a1, 32
4200b49b:	20a220        	or	a10, a2, a2
4200b49e:	201110        	or	a1, a1, a1
4200b4a1:	010ce5        	call8	4200c570 <__env_lock>
4200b4a4:	d4b781        	l32r	a8, 42000780 <_stext+0x760> (3fc927b4 <environ>)
4200b4a7:	03cd      	mov.n	a12, a3
4200b4a9:	0868      	l32i.n	a6, a8, 0
4200b4ab:	d6cc      	bnez.n	a6, 4200b4bc <_findenv_r+0x24>
4200b4ad:	02ad      	mov.n	a10, a2
4200b4af:	201110        	or	a1, a1, a1
4200b4b2:	010ce5        	call8	4200c580 <__env_unlock>
4200b4b5:	020c      	movi.n	a2, 0
4200b4b7:	0015c6        	j	4200b512 <_findenv_r+0x7a>
4200b4ba:	cc1b      	addi.n	a12, a12, 1
4200b4bc:	000c82        	l8ui	a8, a12, 0
4200b4bf:	005816        	beqz	a8, 4200b4c8 <_findenv_r+0x30>
4200b4c2:	c3c8a2        	addi	a10, a8, -61
4200b4c5:	ff1a56        	bnez	a10, 4200b4ba <_findenv_r+0x22>
4200b4c8:	da3c      	movi.n	a10, 61
4200b4ca:	c05c30        	sub	a5, a12, a3
4200b4cd:	3998a7        	bne	a8, a10, 4200b50a <_findenv_r+0x72>
4200b4d0:	fff646        	j	4200b4ad <_findenv_r+0x15>
4200b4d3:	05cd00        	extui	a12, a0, 29, 1
4200b4d6:	03bd      	mov.n	a11, a3
4200b4d8:	d4f981        	l32r	a8, 420008bc <_stext+0x89c> (4000123c <strncmp>)
4200b4db:	0008e0        	callx8	a8
4200b4de:	dd3c      	movi.n	a13, 61
4200b4e0:	4aec      	bnez.n	a10, 4200b508 <_findenv_r+0x70>
4200b4e2:	0678      	l32i.n	a7, a6, 0
4200b4e4:	775a      	add.n	a7, a7, a5
4200b4e6:	000782        	l8ui	a8, a7, 0
4200b4e9:	1b98d7        	bne	a8, a13, 4200b508 <_findenv_r+0x70>
4200b4ec:	d4a581        	l32r	a8, 42000780 <_stext+0x760> (3fc927b4 <environ>)
4200b4ef:	02ad      	mov.n	a10, a2
4200b4f1:	0888      	l32i.n	a8, a8, 0
4200b4f3:	271b      	addi.n	a2, a7, 1
4200b4f5:	c08680        	sub	a8, a6, a8
4200b4f8:	218280        	srai	a8, a8, 2
4200b4fb:	006482        	s32i	a8, a4, 0
4200b4fe:	201110        	or	a1, a1, a1
4200b501:	0107e5        	call8	4200c580 <__env_unlock>
4200b504:	000286        	j	4200b512 <_findenv_r+0x7a>
4200b507:	664b00        	lsi	f0, a11, 0x198
4200b50a:	06a8      	l32i.n	a10, a6, 0
4200b50c:	fc4a56        	bnez	a10, 4200b4d4 <_findenv_r+0x3c>
4200b50f:	ffe686        	j	4200b4ad <_findenv_r+0x15>
4200b512:	f01d      	retw.n

4200b514 <_getenv_r>:
4200b514:	006136        	entry	a1, 48
4200b517:	02ad      	mov.n	a10, a2
4200b519:	03bd      	mov.n	a11, a3
4200b51b:	01cd      	mov.n	a12, a1
4200b51d:	fff7a5        	call8	4200b498 <_findenv_r>
4200b520:	0a2d      	mov.n	a2, a10
4200b522:	f01d      	retw.n

4200b524 <__cxa_atexit>:
4200b524:	004136        	entry	a1, 32
4200b527:	02bd      	mov.n	a11, a2
4200b529:	03cd      	mov.n	a12, a3
4200b52b:	04dd      	mov.n	a13, a4
4200b52d:	2a0c      	movi.n	a10, 2
4200b52f:	201110        	or	a1, a1, a1
4200b532:	00f9a5        	call8	4200c4cc <__register_exitproc>
4200b535:	0a2d      	mov.n	a2, a10
4200b537:	f01d      	retw.n
4200b539:	000000        	ill

4200b53c <_fclose_r>:
4200b53c:	004136        	entry	a1, 32
4200b53f:	027d      	mov.n	a7, a2
4200b541:	53bc      	beqz.n	a3, 4200b57a <_fclose_r+0x3e>
4200b543:	a28c      	beqz.n	a2, 4200b551 <_fclose_r+0x15>
4200b545:	a288      	l32i.n	a8, a2, 40
4200b547:	68cc      	bnez.n	a8, 4200b551 <_fclose_r+0x15>
4200b549:	02ad      	mov.n	a10, a2
4200b54b:	201110        	or	a1, a1, a1
4200b54e:	004665        	call8	4200b9b4 <__sinit>
4200b551:	192382        	l32i	a8, a3, 100
4200b554:	0ee807        	bbsi	a8, 0, 4200b566 <_fclose_r+0x2a>
4200b557:	061382        	l16ui	a8, a3, 12
4200b55a:	22e897        	bbsi	a8, 9, 4200b580 <_fclose_r+0x44>
4200b55d:	1623a2        	l32i	a10, a3, 88
4200b560:	d5fa81        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200b563:	0008e0        	callx8	a8
4200b566:	069382        	l16si	a8, a3, 12
4200b569:	38dc      	bnez.n	a8, 4200b580 <_fclose_r+0x44>
4200b56b:	192382        	l32i	a8, a3, 100
4200b56e:	08e807        	bbsi	a8, 0, 4200b57a <_fclose_r+0x3e>
4200b571:	1623a2        	l32i	a10, a3, 88
4200b574:	d5f681        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200b577:	0008e0        	callx8	a8
4200b57a:	020c      	movi.n	a2, 0
4200b57c:	001fc6        	j	4200b5ff <_fclose_r+0xc3>
4200b57f:	03bd00        	lsi	f0, a13, 12
4200b582:	07ad      	mov.n	a10, a7
4200b584:	201110        	or	a1, a1, a1
4200b587:	000925        	call8	4200b618 <__sflush_r>
4200b58a:	c388      	l32i.n	a8, a3, 48
4200b58c:	0a2d      	mov.n	a2, a10
4200b58e:	00c816        	beqz	a8, 4200b59e <_fclose_r+0x62>
4200b591:	0823b2        	l32i	a11, a3, 32
4200b594:	07ad      	mov.n	a10, a7
4200b596:	0008e0        	callx8	a8
4200b599:	f87c      	movi.n	a8, -1
4200b59b:	a328a0        	movltz	a2, a8, a10
4200b59e:	061382        	l16ui	a8, a3, 12
4200b5a1:	096877        	bbci	a8, 7, 4200b5ae <_fclose_r+0x72>
4200b5a4:	43b8      	l32i.n	a11, a3, 16
4200b5a6:	07ad      	mov.n	a10, a7
4200b5a8:	d5ea81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200b5ab:	0008e0        	callx8	a8
4200b5ae:	d3b8      	l32i.n	a11, a3, 52
4200b5b0:	0b9c      	beqz.n	a11, 4200b5c4 <_fclose_r+0x88>
4200b5b2:	44c382        	addi	a8, a3, 68
4200b5b5:	071b87        	beq	a11, a8, 4200b5c0 <_fclose_r+0x84>
4200b5b8:	07ad      	mov.n	a10, a7
4200b5ba:	d5e581        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200b5bd:	0008e0        	callx8	a8
4200b5c0:	080c      	movi.n	a8, 0
4200b5c2:	d389      	s32i.n	a8, a3, 52
4200b5c4:	1223b2        	l32i	a11, a3, 72
4200b5c7:	bb8c      	beqz.n	a11, 4200b5d6 <_fclose_r+0x9a>
4200b5c9:	07ad      	mov.n	a10, a7
4200b5cb:	d5e181        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200b5ce:	0008e0        	callx8	a8
4200b5d1:	080c      	movi.n	a8, 0
4200b5d3:	126382        	s32i	a8, a3, 72
4200b5d6:	201110        	or	a1, a1, a1
4200b5d9:	003125        	call8	4200b8ec <__sfp_lock_acquire>
4200b5dc:	080c      	movi.n	a8, 0
4200b5de:	065382        	s16i	a8, a3, 12
4200b5e1:	192382        	l32i	a8, a3, 100
4200b5e4:	08e807        	bbsi	a8, 0, 4200b5f0 <_fclose_r+0xb4>
4200b5e7:	1623a2        	l32i	a10, a3, 88
4200b5ea:	d5d881        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200b5ed:	0008e0        	callx8	a8
4200b5f0:	1623a2        	l32i	a10, a3, 88
4200b5f3:	d5d881        	l32r	a8, 42000d54 <_stext+0xd34> (40376ab4 <__retarget_lock_close_recursive>)
4200b5f6:	0008e0        	callx8	a8
4200b5f9:	201110        	or	a1, a1, a1
4200b5fc:	002fe5        	call8	4200b8fc <__sfp_lock_release>
4200b5ff:	f01d      	retw.n
4200b601:	000000        	ill

4200b604 <fclose>:
4200b604:	004136        	entry	a1, 32
4200b607:	d45281        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200b60a:	0008e0        	callx8	a8
4200b60d:	02bd      	mov.n	a11, a2
4200b60f:	fff2e5        	call8	4200b53c <_fclose_r>
4200b612:	0a2d      	mov.n	a2, a10
4200b614:	f01d      	retw.n
	...

4200b618 <__sflush_r>:
4200b618:	004136        	entry	a1, 32
4200b61b:	069382        	l16si	a8, a3, 12
4200b61e:	026837        	bbci	a8, 3, 4200b624 <__sflush_r+0xc>
4200b621:	003ac6        	j	4200b710 <__sflush_r+0xf8>
4200b624:	190c      	movi.n	a9, 1
4200b626:	119950        	slli	a9, a9, 11
4200b629:	209890        	or	a9, a8, a9
4200b62c:	065392        	s16i	a9, a3, 12
4200b62f:	1398      	l32i.n	a9, a3, 4
4200b631:	0819e6        	bgei	a9, 1, 4200b63d <__sflush_r+0x25>
4200b634:	102392        	l32i	a9, a3, 64
4200b637:	0219e6        	bgei	a9, 1, 4200b63d <__sflush_r+0x25>
4200b63a:	004206        	j	4200b746 <__sflush_r+0x12e>
4200b63d:	b398      	l32i.n	a9, a3, 44
4200b63f:	103916        	beqz	a9, 4200b746 <__sflush_r+0x12e>
4200b642:	0a0c      	movi.n	a10, 0
4200b644:	048c80        	extui	a8, a8, 12, 1
4200b647:	0278      	l32i.n	a7, a2, 0
4200b649:	118840        	slli	a8, a8, 12
4200b64c:	02a9      	s32i.n	a10, a2, 0
4200b64e:	488c      	beqz.n	a8, 4200b656 <__sflush_r+0x3e>
4200b650:	1523c2        	l32i	a12, a3, 84
4200b653:	001086        	j	4200b699 <__sflush_r+0x81>
4200b656:	83b8      	l32i.n	a11, a3, 32
4200b658:	0c0c      	movi.n	a12, 0
4200b65a:	1d0c      	movi.n	a13, 1
4200b65c:	20a220        	or	a10, a2, a2
4200b65f:	0009e0        	callx8	a9
4200b662:	0acd      	mov.n	a12, a10
4200b664:	310a66        	bnei	a10, -1, 4200b699 <__sflush_r+0x81>
4200b667:	0288      	l32i.n	a8, a2, 0
4200b669:	c8ac      	beqz.n	a8, 4200b699 <__sflush_r+0x81>
4200b66b:	e3c892        	addi	a9, a8, -29
4200b66e:	40f9a0        	nsau	a10, a9
4200b671:	41a5a0        	srli	a10, a10, 5
4200b674:	898c      	beqz.n	a9, 4200b680 <__sflush_r+0x68>
4200b676:	eac882        	addi	a8, a8, -22
4200b679:	190c      	movi.n	a9, 1
4200b67b:	939a80        	movnez	a9, a10, a8
4200b67e:	398c      	beqz.n	a9, 4200b685 <__sflush_r+0x6d>
4200b680:	0279      	s32i.n	a7, a2, 0
4200b682:	003006        	j	4200b746 <__sflush_r+0x12e>
4200b685:	061382        	l16ui	a8, a3, 12
4200b688:	094c      	movi.n	a9, 64
4200b68a:	208890        	or	a8, a8, a9
4200b68d:	238880        	sext	a8, a8, 15
4200b690:	065382        	s16i	a8, a3, 12
4200b693:	f27c      	movi.n	a2, -1
4200b695:	002bc6        	j	4200b748 <__sflush_r+0x130>
4200b698:	138200        	lsi	f0, a2, 76
4200b69b:	682706        	j	4202573b <_etext+0xe4fd>
4200b69e:	0e          	.byte	0xe
4200b69f:	1388      	l32i.n	a8, a3, 4
4200b6a1:	c0cc80        	sub	a12, a12, a8
4200b6a4:	d388      	l32i.n	a8, a3, 52
4200b6a6:	488c      	beqz.n	a8, 4200b6ae <__sflush_r+0x96>
4200b6a8:	102382        	l32i	a8, a3, 64
4200b6ab:	c0cc80        	sub	a12, a12, a8
4200b6ae:	b388      	l32i.n	a8, a3, 44
4200b6b0:	83b8      	l32i.n	a11, a3, 32
4200b6b2:	0d0c      	movi.n	a13, 0
4200b6b4:	02ad      	mov.n	a10, a2
4200b6b6:	0008e0        	callx8	a8
4200b6b9:	069382        	l16si	a8, a3, 12
4200b6bc:	0c0a66        	bnei	a10, -1, 4200b6cc <__sflush_r+0xb4>
4200b6bf:	0298      	l32i.n	a9, a2, 0
4200b6c1:	db1c      	movi.n	a11, 29
4200b6c3:	413b97        	bltu	a11, a9, 4200b708 <__sflush_r+0xf0>
4200b6c6:	d5a4b1        	l32r	a11, 42000d58 <_stext+0xd38> (20400001 <UserFrameTotalSize+0x203fff01>)
4200b6c9:	3b5b97        	bbc	a11, a9, 4200b708 <__sflush_r+0xf0>
4200b6cc:	f97c      	movi.n	a9, -1
4200b6ce:	f8d992        	addmi	a9, a9, 0xfffff800
4200b6d1:	109890        	and	a9, a8, a9
4200b6d4:	065392        	s16i	a9, a3, 12
4200b6d7:	090c      	movi.n	a9, 0
4200b6d9:	1399      	s32i.n	a9, a3, 4
4200b6db:	4398      	l32i.n	a9, a3, 16
4200b6dd:	0399      	s32i.n	a9, a3, 0
4200b6df:	0968c7        	bbci	a8, 12, 4200b6ec <__sflush_r+0xd4>
4200b6e2:	030a66        	bnei	a10, -1, 4200b6e9 <__sflush_r+0xd1>
4200b6e5:	0288      	l32i.n	a8, a2, 0
4200b6e7:	18cc      	bnez.n	a8, 4200b6ec <__sflush_r+0xd4>
4200b6e9:	1563a2        	s32i	a10, a3, 84
4200b6ec:	d3b8      	l32i.n	a11, a3, 52
4200b6ee:	0279      	s32i.n	a7, a2, 0
4200b6f0:	052b16        	beqz	a11, 4200b746 <__sflush_r+0x12e>
4200b6f3:	44c382        	addi	a8, a3, 68
4200b6f6:	071b87        	beq	a11, a8, 4200b701 <__sflush_r+0xe9>
4200b6f9:	02ad      	mov.n	a10, a2
4200b6fb:	d59581        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200b6fe:	0008e0        	callx8	a8
4200b701:	080c      	movi.n	a8, 0
4200b703:	d389      	s32i.n	a8, a3, 52
4200b705:	000f46        	j	4200b746 <__sflush_r+0x12e>
4200b708:	094c      	movi.n	a9, 64
4200b70a:	208890        	or	a8, a8, a9
4200b70d:	ffdfc6        	j	4200b690 <__sflush_r+0x78>
4200b710:	4368      	l32i.n	a6, a3, 16
4200b712:	06bc      	beqz.n	a6, 4200b746 <__sflush_r+0x12e>
4200b714:	0378      	l32i.n	a7, a3, 0
4200b716:	148080        	extui	a8, a8, 0, 2
4200b719:	0369      	s32i.n	a6, a3, 0
4200b71b:	c07760        	sub	a7, a7, a6
4200b71e:	090c      	movi.n	a9, 0
4200b720:	08cc      	bnez.n	a8, 4200b724 <__sflush_r+0x10c>
4200b722:	5398      	l32i.n	a9, a3, 20
4200b724:	2399      	s32i.n	a9, a3, 8
4200b726:	000646        	j	4200b743 <__sflush_r+0x12b>
4200b729:	a388      	l32i.n	a8, a3, 40
4200b72b:	83b8      	l32i.n	a11, a3, 32
4200b72d:	07dd      	mov.n	a13, a7
4200b72f:	20c660        	or	a12, a6, a6
4200b732:	20a220        	or	a10, a2, a2
4200b735:	0008e0        	callx8	a8
4200b738:	021ae6        	bgei	a10, 1, 4200b73e <__sflush_r+0x126>
4200b73b:	ffd186        	j	4200b685 <__sflush_r+0x6d>
4200b73e:	66aa      	add.n	a6, a6, a10
4200b740:	c077a0        	sub	a7, a7, a10
4200b743:	e217e6        	bgei	a7, 1, 4200b729 <__sflush_r+0x111>
4200b746:	020c      	movi.n	a2, 0
4200b748:	f01d      	retw.n
	...

4200b74c <_fflush_r>:
4200b74c:	004136        	entry	a1, 32
4200b74f:	4388      	l32i.n	a8, a3, 16
4200b751:	005856        	bnez	a8, 4200b75a <_fflush_r+0xe>
4200b754:	020c      	movi.n	a2, 0
4200b756:	001186        	j	4200b7a0 <_fflush_r+0x54>
4200b759:	b28c00        	mulsh	a8, a12, a0
4200b75c:	a288      	l32i.n	a8, a2, 40
4200b75e:	78cc      	bnez.n	a8, 4200b769 <_fflush_r+0x1d>
4200b760:	20a220        	or	a10, a2, a2
4200b763:	201110        	or	a1, a1, a1
4200b766:	0024e5        	call8	4200b9b4 <__sinit>
4200b769:	069382        	l16si	a8, a3, 12
4200b76c:	fe4816        	beqz	a8, 4200b754 <_fflush_r+0x8>
4200b76f:	192392        	l32i	a9, a3, 100
4200b772:	0be907        	bbsi	a9, 0, 4200b781 <_fflush_r+0x35>
4200b775:	08e897        	bbsi	a8, 9, 4200b781 <_fflush_r+0x35>
4200b778:	1623a2        	l32i	a10, a3, 88
4200b77b:	d57381        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200b77e:	0008e0        	callx8	a8
4200b781:	02ad      	mov.n	a10, a2
4200b783:	20b330        	or	a11, a3, a3
4200b786:	ffe925        	call8	4200b618 <__sflush_r>
4200b789:	192382        	l32i	a8, a3, 100
4200b78c:	0a2d      	mov.n	a2, a10
4200b78e:	0ee807        	bbsi	a8, 0, 4200b7a0 <_fflush_r+0x54>
4200b791:	061382        	l16ui	a8, a3, 12
4200b794:	08e897        	bbsi	a8, 9, 4200b7a0 <_fflush_r+0x54>
4200b797:	1623a2        	l32i	a10, a3, 88
4200b79a:	d56c81        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200b79d:	0008e0        	callx8	a8
4200b7a0:	f01d      	retw.n
	...

4200b7a4 <fflush>:
4200b7a4:	004136        	entry	a1, 32
4200b7a7:	02dc      	bnez.n	a2, 4200b7bb <fflush+0x17>
4200b7a9:	d3f2c1        	l32r	a12, 42000774 <_stext+0x754> (3fc927b8 <__sglue>)
4200b7ac:	d56cb1        	l32r	a11, 42000d5c <_stext+0xd3c> (4200b74c <_fflush_r>)
4200b7af:	d3eea1        	l32r	a10, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
4200b7b2:	201110        	or	a1, a1, a1
4200b7b5:	0a3525        	call8	42015b08 <_fwalk_sglue>
4200b7b8:	000286        	j	4200b7c6 <fflush+0x22>
4200b7bb:	d3e581        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200b7be:	0008e0        	callx8	a8
4200b7c1:	02bd      	mov.n	a11, a2
4200b7c3:	fff8a5        	call8	4200b74c <_fflush_r>
4200b7c6:	0a2d      	mov.n	a2, a10
4200b7c8:	f01d      	retw.n
	...

4200b7cc <std>:
4200b7cc:	004136        	entry	a1, 32
4200b7cf:	070c      	movi.n	a7, 0
4200b7d1:	0279      	s32i.n	a7, a2, 0
4200b7d3:	1279      	s32i.n	a7, a2, 4
4200b7d5:	2279      	s32i.n	a7, a2, 8
4200b7d7:	196272        	s32i	a7, a2, 100
4200b7da:	4279      	s32i.n	a7, a2, 16
4200b7dc:	5279      	s32i.n	a7, a2, 20
4200b7de:	6279      	s32i.n	a7, a2, 24
4200b7e0:	065232        	s16i	a3, a2, 12
4200b7e3:	075242        	s16i	a4, a2, 14
4200b7e6:	8c0c      	movi.n	a12, 8
4200b7e8:	00a0b2        	movi	a11, 0
4200b7eb:	5cc2a2        	addi	a10, a2, 92
4200b7ee:	d2c481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200b7f1:	0008e0        	callx8	a8
4200b7f4:	d55b81        	l32r	a8, 42000d60 <_stext+0xd40> (4200be98 <__sread>)
4200b7f7:	d55ea1        	l32r	a10, 42000d70 <_stext+0xd50> (3fc951cc <__sf+0x68>)
4200b7fa:	9289      	s32i.n	a8, a2, 36
4200b7fc:	d55a81        	l32r	a8, 42000d64 <_stext+0xd44> (4200bed4 <__swrite>)
4200b7ff:	c0a2a0        	sub	a10, a2, a10
4200b802:	a289      	s32i.n	a8, a2, 40
4200b804:	d55981        	l32r	a8, 42000d68 <_stext+0xd48> (4200bf10 <__sseek>)
4200b807:	079d      	mov.n	a9, a7
4200b809:	b289      	s32i.n	a8, a2, 44
4200b80b:	d55881        	l32r	a8, 42000d6c <_stext+0xd4c> (4200bf4c <__sclose>)
4200b80e:	8229      	s32i.n	a2, a2, 32
4200b810:	c289      	s32i.n	a8, a2, 48
4200b812:	180c      	movi.n	a8, 1
4200b814:	8398a0        	moveqz	a9, a8, a10
4200b817:	d557a1        	l32r	a10, 42000d74 <_stext+0xd54> (3fc95164 <__sf>)
4200b81a:	c0a2a0        	sub	a10, a2, a10
4200b81d:	8378a0        	moveqz	a7, a8, a10
4200b820:	209970        	or	a9, a9, a7
4200b823:	99cc      	bnez.n	a9, 4200b830 <std+0x64>
4200b825:	d554a1        	l32r	a10, 42000d78 <_stext+0xd58> (3fc95234 <__sf+0xd0>)
4200b828:	c0a2a0        	sub	a10, a2, a10
4200b82b:	9389a0        	movnez	a8, a9, a10
4200b82e:	788c      	beqz.n	a8, 4200b839 <std+0x6d>
4200b830:	58c2a2        	addi	a10, a2, 88
4200b833:	d55281        	l32r	a8, 42000d7c <_stext+0xd5c> (40376a90 <__retarget_lock_init_recursive>)
4200b836:	0008e0        	callx8	a8
4200b839:	f01d      	retw.n
	...

4200b83c <stdio_exit_handler>:
4200b83c:	004136        	entry	a1, 32
4200b83f:	d3cdc1        	l32r	a12, 42000774 <_stext+0x754> (3fc927b8 <__sglue>)
4200b842:	d54fb1        	l32r	a11, 42000d80 <_stext+0xd60> (4200b53c <_fclose_r>)
4200b845:	d3c8a1        	l32r	a10, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
4200b848:	201110        	or	a1, a1, a1
4200b84b:	0a2be5        	call8	42015b08 <_fwalk_sglue>
4200b84e:	f01d      	retw.n

4200b850 <cleanup_stdio>:
4200b850:	004136        	entry	a1, 32
4200b853:	12b8      	l32i.n	a11, a2, 4
4200b855:	d54781        	l32r	a8, 42000d74 <_stext+0xd54> (3fc95164 <__sf>)
4200b858:	081b87        	beq	a11, a8, 4200b864 <cleanup_stdio+0x14>
4200b85b:	20a220        	or	a10, a2, a2
4200b85e:	201110        	or	a1, a1, a1
4200b861:	ffcda5        	call8	4200b53c <_fclose_r>
4200b864:	22b8      	l32i.n	a11, a2, 8
4200b866:	d54281        	l32r	a8, 42000d70 <_stext+0xd50> (3fc951cc <__sf+0x68>)
4200b869:	071b87        	beq	a11, a8, 4200b874 <cleanup_stdio+0x24>
4200b86c:	02ad      	mov.n	a10, a2
4200b86e:	201110        	or	a1, a1, a1
4200b871:	ffcca5        	call8	4200b53c <_fclose_r>
4200b874:	32b8      	l32i.n	a11, a2, 12
4200b876:	d54081        	l32r	a8, 42000d78 <_stext+0xd58> (3fc95234 <__sf+0xd0>)
4200b879:	071b87        	beq	a11, a8, 4200b884 <cleanup_stdio+0x34>
4200b87c:	02ad      	mov.n	a10, a2
4200b87e:	201110        	or	a1, a1, a1
4200b881:	ffcba5        	call8	4200b53c <_fclose_r>
4200b884:	f01d      	retw.n
	...

4200b888 <__fp_lock>:
4200b888:	004136        	entry	a1, 32
4200b88b:	192382        	l32i	a8, a3, 100
4200b88e:	0ee807        	bbsi	a8, 0, 4200b8a0 <__fp_lock+0x18>
4200b891:	061382        	l16ui	a8, a3, 12
4200b894:	08e897        	bbsi	a8, 9, 4200b8a0 <__fp_lock+0x18>
4200b897:	1623a2        	l32i	a10, a3, 88
4200b89a:	d52b81        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200b89d:	0008e0        	callx8	a8
4200b8a0:	020c      	movi.n	a2, 0
4200b8a2:	f01d      	retw.n

4200b8a4 <__fp_unlock>:
4200b8a4:	004136        	entry	a1, 32
4200b8a7:	192382        	l32i	a8, a3, 100
4200b8aa:	0ee807        	bbsi	a8, 0, 4200b8bc <__fp_unlock+0x18>
4200b8ad:	061382        	l16ui	a8, a3, 12
4200b8b0:	08e897        	bbsi	a8, 9, 4200b8bc <__fp_unlock+0x18>
4200b8b3:	1623a2        	l32i	a10, a3, 88
4200b8b6:	d52581        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200b8b9:	0008e0        	callx8	a8
4200b8bc:	020c      	movi.n	a2, 0
4200b8be:	f01d      	retw.n

4200b8c0 <global_stdio_init$part$0>:
4200b8c0:	004136        	entry	a1, 32
4200b8c3:	d53081        	l32r	a8, 42000d84 <_stext+0xd64> (3fc9529c <__stdio_exit_handler>)
4200b8c6:	d53091        	l32r	a9, 42000d88 <_stext+0xd68> (4200b83c <stdio_exit_handler>)
4200b8c9:	d52aa1        	l32r	a10, 42000d74 <_stext+0xd54> (3fc95164 <__sf>)
4200b8cc:	0899      	s32i.n	a9, a8, 0
4200b8ce:	0c0c      	movi.n	a12, 0
4200b8d0:	4b0c      	movi.n	a11, 4
4200b8d2:	ffefa5        	call8	4200b7cc <std>
4200b8d5:	d526a1        	l32r	a10, 42000d70 <_stext+0xd50> (3fc951cc <__sf+0x68>)
4200b8d8:	01a0c2        	movi	a12, 1
4200b8db:	8b0c      	movi.n	a11, 8
4200b8dd:	ffeee5        	call8	4200b7cc <std>
4200b8e0:	d526a1        	l32r	a10, 42000d78 <_stext+0xd58> (3fc95234 <__sf+0xd0>)
4200b8e3:	2c0c      	movi.n	a12, 2
4200b8e5:	2b1c      	movi.n	a11, 18
4200b8e7:	ffee65        	call8	4200b7cc <std>
4200b8ea:	f01d      	retw.n

4200b8ec <__sfp_lock_acquire>:
4200b8ec:	004136        	entry	a1, 32
4200b8ef:	d390a1        	l32r	a10, 42000730 <_stext+0x710> (3fc94f24 <__lock___atexit_recursive_mutex>)
4200b8f2:	d51581        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200b8f5:	0008e0        	callx8	a8
4200b8f8:	f01d      	retw.n
	...

4200b8fc <__sfp_lock_release>:
4200b8fc:	004136        	entry	a1, 32
4200b8ff:	d38ca1        	l32r	a10, 42000730 <_stext+0x710> (3fc94f24 <__lock___atexit_recursive_mutex>)
4200b902:	d51281        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200b905:	0008e0        	callx8	a8
4200b908:	f01d      	retw.n
	...

4200b90c <__sfp>:
4200b90c:	004136        	entry	a1, 32
4200b90f:	fffde5        	call8	4200b8ec <__sfp_lock_acquire>
4200b912:	d51c81        	l32r	a8, 42000d84 <_stext+0xd64> (3fc9529c <__stdio_exit_handler>)
4200b915:	025d      	mov.n	a5, a2
4200b917:	002882        	l32i	a8, a8, 0
4200b91a:	002856        	bnez	a8, 4200b920 <__sfp+0x14>
4200b91d:	fffa25        	call8	4200b8c0 <global_stdio_init$part$0>
4200b920:	d39561        	l32r	a6, 42000774 <_stext+0x754> (3fc927b8 <__sglue>)
4200b923:	2628      	l32i.n	a2, a6, 8
4200b925:	1688      	l32i.n	a8, a6, 4
4200b927:	001146        	j	4200b970 <__sfp+0x64>
4200b92a:	720000        	lsi	f0, a0, 0x1c8
4200b92d:	fc0692        	l8ui	a9, a6, 252
4200b930:	1681a7        	bany	a1, a10, 4200b94a <__sfp+0x3e>
4200b933:	c2a2d5        	call4	41fce360 <_coredump_iram_end+0x1c4c360>
4200b936:	8958      	l32i.n	a5, a9, 32
4200b938:	627232        	lsi	f3, a2, 0x188
4200b93b:	8119      	s32i.n	a1, a1, 32
4200b93d:	e0d510        	subx4	a13, a5, a1
4200b940:	0008      	l32i.n	a0, a0, 0
4200b942:	fffba5        	call8	4200b8fc <__sfp_lock_release>
4200b945:	8c0c      	movi.n	a12, 8
4200b947:	0279      	s32i.n	a7, a2, 0
4200b949:	2279      	s32i.n	a7, a2, 8
4200b94b:	1279      	s32i.n	a7, a2, 4
4200b94d:	4279      	s32i.n	a7, a2, 16
4200b94f:	5279      	s32i.n	a7, a2, 20
4200b951:	6279      	s32i.n	a7, a2, 24
4200b953:	0b0c      	movi.n	a11, 0
4200b955:	5cc2a2        	addi	a10, a2, 92
4200b958:	d26a81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200b95b:	0008e0        	callx8	a8
4200b95e:	d279      	s32i.n	a7, a2, 52
4200b960:	e279      	s32i.n	a7, a2, 56
4200b962:	126272        	s32i	a7, a2, 72
4200b965:	136272        	s32i	a7, a2, 76
4200b968:	001186        	j	4200b9b2 <__sfp+0xa6>
4200b96b:	220000        	orb	b0, b0, b0
4200b96e:	0b68c2        	s32i	a12, a8, 44
4200b971:	d688      	l32i.n	a8, a6, 52
4200b973:	fb68      	l32i.n	a6, a11, 60
4200b975:	0678      	l32i.n	a7, a6, 0
4200b977:	27fc      	bnez.n	a7, 4200b9ad <__sfp+0xa1>
4200b979:	aca1b2        	movi	a11, 0x1ac
4200b97c:	05ad      	mov.n	a10, a5
4200b97e:	d50481        	l32r	a8, 42000d90 <_stext+0xd70> (4037fef4 <_malloc_r>)
4200b981:	0008e0        	callx8	a8
4200b984:	0a2d      	mov.n	a2, a10
4200b986:	aacc      	bnez.n	a10, 4200b994 <__sfp+0x88>
4200b988:	06a9      	s32i.n	a10, a6, 0
4200b98a:	fff725        	call8	4200b8fc <__sfp_lock_release>
4200b98d:	c80c      	movi.n	a8, 12
4200b98f:	0589      	s32i.n	a8, a5, 0
4200b991:	000746        	j	4200b9b2 <__sfp+0xa6>
4200b994:	480c      	movi.n	a8, 4
4200b996:	0a79      	s32i.n	a7, a10, 0
4200b998:	1a89      	s32i.n	a8, a10, 4
4200b99a:	aacb      	addi.n	a10, a10, 12
4200b99c:	22a9      	s32i.n	a10, a2, 8
4200b99e:	a0a1c2        	movi	a12, 0x1a0
4200b9a1:	0b0c      	movi.n	a11, 0
4200b9a3:	d25781        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200b9a6:	0008e0        	callx8	a8
4200b9a9:	027d      	mov.n	a7, a2
4200b9ab:	0629      	s32i.n	a2, a6, 0
4200b9ad:	076d      	mov.n	a6, a7
4200b9af:	ffdc06        	j	4200b923 <__sfp+0x17>
4200b9b2:	f01d      	retw.n

4200b9b4 <__sinit>:
4200b9b4:	004136        	entry	a1, 32
4200b9b7:	fff365        	call8	4200b8ec <__sfp_lock_acquire>
4200b9ba:	0a2282        	l32i	a8, a2, 40
4200b9bd:	004816        	beqz	a8, 4200b9c5 <__sinit+0x11>
4200b9c0:	fff3a5        	call8	4200b8fc <__sfp_lock_release>
4200b9c3:	f01d      	retw.n
4200b9c5:	d4f381        	l32r	a8, 42000d94 <_stext+0xd74> (4200b850 <cleanup_stdio>)
4200b9c8:	a289      	s32i.n	a8, a2, 40
4200b9ca:	d4ee81        	l32r	a8, 42000d84 <_stext+0xd64> (3fc9529c <__stdio_exit_handler>)
4200b9cd:	0888      	l32i.n	a8, a8, 0
4200b9cf:	fed856        	bnez	a8, 4200b9c0 <__sinit+0xc>
4200b9d2:	ffeee5        	call8	4200b8c0 <global_stdio_init$part$0>
4200b9d5:	fff9c6        	j	4200b9c0 <__sinit+0xc>

4200b9d8 <__fp_lock_all>:
4200b9d8:	004136        	entry	a1, 32
4200b9db:	fff125        	call8	4200b8ec <__sfp_lock_acquire>
4200b9de:	d365c1        	l32r	a12, 42000774 <_stext+0x754> (3fc927b8 <__sglue>)
4200b9e1:	d4edb1        	l32r	a11, 42000d98 <_stext+0xd78> (4200b888 <__fp_lock>)
4200b9e4:	0a0c      	movi.n	a10, 0
4200b9e6:	201110        	or	a1, a1, a1
4200b9e9:	0a11e5        	call8	42015b08 <_fwalk_sglue>
4200b9ec:	f01d      	retw.n
	...

4200b9f0 <__fp_unlock_all>:
4200b9f0:	004136        	entry	a1, 32
4200b9f3:	d360c1        	l32r	a12, 42000774 <_stext+0x754> (3fc927b8 <__sglue>)
4200b9f6:	d4e9b1        	l32r	a11, 42000d9c <_stext+0xd7c> (4200b8a4 <__fp_unlock>)
4200b9f9:	0a0c      	movi.n	a10, 0
4200b9fb:	0a10e5        	call8	42015b08 <_fwalk_sglue>
4200b9fe:	ffefe5        	call8	4200b8fc <__sfp_lock_release>
4200ba01:	f01d      	retw.n
	...

4200ba04 <_fopen_r>:
4200ba04:	006136        	entry	a1, 48
4200ba07:	20b440        	or	a11, a4, a4
4200ba0a:	20c110        	or	a12, a1, a1
4200ba0d:	20a220        	or	a10, a2, a2
4200ba10:	201110        	or	a1, a1, a1
4200ba13:	0a12e5        	call8	42015b40 <__sflags>
4200ba16:	026d      	mov.n	a6, a2
4200ba18:	207aa0        	or	a7, a10, a10
4200ba1b:	9abc      	beqz.n	a10, 4200ba58 <_fopen_r+0x54>
4200ba1d:	20a220        	or	a10, a2, a2
4200ba20:	201110        	or	a1, a1, a1
4200ba23:	ffeea5        	call8	4200b90c <__sfp>
4200ba26:	0a2d      	mov.n	a2, a10
4200ba28:	caac      	beqz.n	a10, 4200ba58 <_fopen_r+0x54>
4200ba2a:	01c8      	l32i.n	a12, a1, 0
4200ba2c:	b6a1d2        	movi	a13, 0x1b6
4200ba2f:	03bd      	mov.n	a11, a3
4200ba31:	06ad      	mov.n	a10, a6
4200ba33:	201110        	or	a1, a1, a1
4200ba36:	fb5a25        	call8	42006fd8 <_open_r>
4200ba39:	0a5d      	mov.n	a5, a10
4200ba3b:	01ead6        	bgez	a10, 4200ba5d <_fopen_r+0x59>
4200ba3e:	201110        	or	a1, a1, a1
4200ba41:	ffeaa5        	call8	4200b8ec <__sfp_lock_acquire>
4200ba44:	080c      	movi.n	a8, 0
4200ba46:	1622a2        	l32i	a10, a2, 88
4200ba49:	065282        	s16i	a8, a2, 12
4200ba4c:	d4c281        	l32r	a8, 42000d54 <_stext+0xd34> (40376ab4 <__retarget_lock_close_recursive>)
4200ba4f:	0008e0        	callx8	a8
4200ba52:	201110        	or	a1, a1, a1
4200ba55:	ffea65        	call8	4200b8fc <__sfp_lock_release>
4200ba58:	020c      	movi.n	a2, 0
4200ba5a:	0016c6        	j	4200bab9 <_fopen_r+0xb5>
4200ba5d:	192282        	l32i	a8, a2, 100
4200ba60:	0ee807        	bbsi	a8, 0, 4200ba72 <_fopen_r+0x6e>
4200ba63:	061282        	l16ui	a8, a2, 12
4200ba66:	08e897        	bbsi	a8, 9, 4200ba72 <_fopen_r+0x6e>
4200ba69:	1622a2        	l32i	a10, a2, 88
4200ba6c:	d4b781        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200ba6f:	0008e0        	callx8	a8
4200ba72:	d4bb81        	l32r	a8, 42000d60 <_stext+0xd40> (4200be98 <__sread>)
4200ba75:	237780        	sext	a7, a7, 15
4200ba78:	9289      	s32i.n	a8, a2, 36
4200ba7a:	d4ba81        	l32r	a8, 42000d64 <_stext+0xd44> (4200bed4 <__swrite>)
4200ba7d:	075252        	s16i	a5, a2, 14
4200ba80:	a289      	s32i.n	a8, a2, 40
4200ba82:	d4b981        	l32r	a8, 42000d68 <_stext+0xd48> (4200bf10 <__sseek>)
4200ba85:	065272        	s16i	a7, a2, 12
4200ba88:	b289      	s32i.n	a8, a2, 44
4200ba8a:	d4b881        	l32r	a8, 42000d6c <_stext+0xd4c> (4200bf4c <__sclose>)
4200ba8d:	8229      	s32i.n	a2, a2, 32
4200ba8f:	c289      	s32i.n	a8, a2, 48
4200ba91:	0f6787        	bbci	a7, 8, 4200baa4 <_fopen_r+0xa0>
4200ba94:	2d0c      	movi.n	a13, 2
4200ba96:	00a0c2        	movi	a12, 0
4200ba99:	02bd      	mov.n	a11, a2
4200ba9b:	20a660        	or	a10, a6, a6
4200ba9e:	201110        	or	a1, a1, a1
4200baa1:	0002e5        	call8	4200bad0 <_fseek_r>
4200baa4:	192282        	l32i	a8, a2, 100
4200baa7:	0ee807        	bbsi	a8, 0, 4200bab9 <_fopen_r+0xb5>
4200baaa:	061282        	l16ui	a8, a2, 12
4200baad:	08e897        	bbsi	a8, 9, 4200bab9 <_fopen_r+0xb5>
4200bab0:	1622a2        	l32i	a10, a2, 88
4200bab3:	d4a681        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200bab6:	0008e0        	callx8	a8
4200bab9:	f01d      	retw.n
	...

4200babc <fopen>:
4200babc:	004136        	entry	a1, 32
4200babf:	d32481        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200bac2:	0008e0        	callx8	a8
4200bac5:	02bd      	mov.n	a11, a2
4200bac7:	03cd      	mov.n	a12, a3
4200bac9:	fff3a5        	call8	4200ba04 <_fopen_r>
4200bacc:	0a2d      	mov.n	a2, a10
4200bace:	f01d      	retw.n

4200bad0 <_fseek_r>:
4200bad0:	004136        	entry	a1, 32
4200bad3:	02ad      	mov.n	a10, a2
4200bad5:	03bd      	mov.n	a11, a3
4200bad7:	04cd      	mov.n	a12, a4
4200bad9:	05dd      	mov.n	a13, a5
4200badb:	201110        	or	a1, a1, a1
4200bade:	005665        	call8	4200c044 <_fseeko_r>
4200bae1:	0a2d      	mov.n	a2, a10
4200bae3:	f01d      	retw.n
4200bae5:	000000        	ill

4200bae8 <fseek>:
4200bae8:	004136        	entry	a1, 32
4200baeb:	d31981        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200baee:	0008e0        	callx8	a8
4200baf1:	02bd      	mov.n	a11, a2
4200baf3:	04dd      	mov.n	a13, a4
4200baf5:	03cd      	mov.n	a12, a3
4200baf7:	201110        	or	a1, a1, a1
4200bafa:	0054a5        	call8	4200c044 <_fseeko_r>
4200bafd:	0a2d      	mov.n	a2, a10
4200baff:	f01d      	retw.n
4200bb01:	000000        	ill

4200bb04 <__sfvwrite_r>:
4200bb04:	006136        	entry	a1, 48
4200bb07:	2498      	l32i.n	a9, a4, 8
4200bb09:	0129      	s32i.n	a2, a1, 0
4200bb0b:	032d      	mov.n	a2, a3
4200bb0d:	39cc      	bnez.n	a9, 4200bb14 <__sfvwrite_r+0x10>
4200bb0f:	020c      	movi.n	a2, 0
4200bb11:	00a606        	j	4200bdad <__sfvwrite_r+0x2a9>
4200bb14:	061392        	l16ui	a9, a3, 12
4200bb17:	136937        	bbci	a9, 3, 4200bb2e <__sfvwrite_r+0x2a>
4200bb1a:	042392        	l32i	a9, a3, 16
4200bb1d:	00d916        	beqz	a9, 4200bb2e <__sfvwrite_r+0x2a>
4200bb20:	069292        	l16si	a9, a2, 12
4200bb23:	0478      	l32i.n	a7, a4, 0
4200bb25:	20e917        	bbsi	a9, 1, 4200bb49 <__sfvwrite_r+0x45>
4200bb28:	001346        	j	4200bb79 <__sfvwrite_r+0x75>
4200bb2b:	000000        	ill
4200bb2e:	01a8      	l32i.n	a10, a1, 0
4200bb30:	02bd      	mov.n	a11, a2
4200bb32:	201110        	or	a1, a1, a1
4200bb35:	0046a5        	call8	4200bfa0 <__swsetup_r>
4200bb38:	fe4a16        	beqz	a10, 4200bb20 <__sfvwrite_r+0x1c>
4200bb3b:	009b06        	j	4200bdab <__sfvwrite_r+0x2a7>
4200bb3e:	0738      	l32i.n	a3, a7, 0
4200bb40:	1768      	l32i.n	a6, a7, 4
4200bb42:	778b      	addi.n	a7, a7, 8
4200bb44:	000206        	j	4200bb50 <__sfvwrite_r+0x4c>
4200bb47:	510000        	lsi	f0, a0, 0x144
4200bb4a:	0cd495        	call4	42018894 <_etext+0x1656>
4200bb4d:	060c03        	lsi	f0, a12, 24
4200bb50:	fea616        	beqz	a6, 4200bb3e <__sfvwrite_r+0x3a>
4200bb53:	a298      	l32i.n	a9, a2, 40
4200bb55:	82b8      	l32i.n	a11, a2, 32
4200bb57:	01a8      	l32i.n	a10, a1, 0
4200bb59:	63d650        	minu	a13, a6, a5
4200bb5c:	03cd      	mov.n	a12, a3
4200bb5e:	0009e0        	callx8	a9
4200bb61:	021ae6        	bgei	a10, 1, 4200bb67 <__sfvwrite_r+0x63>
4200bb64:	008e06        	j	4200bda0 <__sfvwrite_r+0x29c>
4200bb67:	2498      	l32i.n	a9, a4, 8
4200bb69:	33aa      	add.n	a3, a3, a10
4200bb6b:	c099a0        	sub	a9, a9, a10
4200bb6e:	2499      	s32i.n	a9, a4, 8
4200bb70:	c066a0        	sub	a6, a6, a10
4200bb73:	fd9956        	bnez	a9, 4200bb50 <__sfvwrite_r+0x4c>
4200bb76:	ffe546        	j	4200bb0f <__sfvwrite_r+0xb>
4200bb79:	146907        	bbci	a9, 0, 4200bb91 <__sfvwrite_r+0x8d>
4200bb7c:	030c      	movi.n	a3, 0
4200bb7e:	0a0c      	movi.n	a10, 0
4200bb80:	060c      	movi.n	a6, 0
4200bb82:	050c      	movi.n	a5, 0
4200bb84:	005a06        	j	4200bcf0 <__sfvwrite_r+0x1ec>
4200bb87:	075800        	lsi	f0, a8, 28
4200bb8a:	1738      	l32i.n	a3, a7, 4
4200bb8c:	778b      	addi.n	a7, a7, 8
4200bb8e:	0000c6        	j	4200bb95 <__sfvwrite_r+0x91>
4200bb91:	050c      	movi.n	a5, 0
4200bb93:	030c      	movi.n	a3, 0
4200bb95:	fef316        	beqz	a3, 4200bb88 <__sfvwrite_r+0x84>
4200bb98:	0692f2        	l16si	a15, a2, 12
4200bb9b:	02a8      	l32i.n	a10, a2, 0
4200bb9d:	22e8      	l32i.n	a14, a2, 8
4200bb9f:	02ef97        	bbsi	a15, 9, 4200bba5 <__sfvwrite_r+0xa1>
4200bba2:	003606        	j	4200bc7e <__sfvwrite_r+0x17a>
4200bba5:	0ecd      	mov.n	a12, a14
4200bba7:	05b3e7        	bgeu	a3, a14, 4200bbb0 <__sfvwrite_r+0xac>
4200bbaa:	03ed      	mov.n	a14, a3
4200bbac:	002886        	j	4200bc52 <__sfvwrite_r+0x14e>
4200bbaf:	a4b200        	extui	a11, a0, 2, 11
4200bbb2:	8fb780        	f64cmph	a11, a7, a8, 8
4200bbb5:	27c602        	addi	a0, a6, 39
4200bbb8:	42b800        	xorb	b11, b8, b0
4200bbbb:	c08ab0        	sub	a8, a10, a11
4200bbbe:	52a8      	l32i.n	a10, a2, 20
4200bbc0:	1189      	s32i.n	a8, a1, 4
4200bbc2:	90aaa0        	addx2	a10, a10, a10
4200bbc5:	05dfa0        	extui	a13, a10, 31, 1
4200bbc8:	ddaa      	add.n	a13, a13, a10
4200bbca:	a81b      	addi.n	a10, a8, 1
4200bbcc:	2161d0        	srai	a6, a13, 1
4200bbcf:	aa3a      	add.n	a10, a10, a3
4200bbd1:	20c660        	or	a12, a6, a6
4200bbd4:	04b6a7        	bgeu	a6, a10, 4200bbdc <__sfvwrite_r+0xd8>
4200bbd7:	0a6d      	mov.n	a6, a10
4200bbd9:	20caa0        	or	a12, a10, a10
4200bbdc:	366fa7        	bbci	a15, 10, 4200bc16 <__sfvwrite_r+0x112>
4200bbdf:	01a8      	l32i.n	a10, a1, 0
4200bbe1:	0cbd      	mov.n	a11, a12
4200bbe3:	d46b81        	l32r	a8, 42000d90 <_stext+0xd70> (4037fef4 <_malloc_r>)
4200bbe6:	0008e0        	callx8	a8
4200bbe9:	1acc      	bnez.n	a10, 4200bbee <__sfvwrite_r+0xea>
4200bbeb:	001246        	j	4200bc38 <__sfvwrite_r+0x134>
4200bbee:	42b8      	l32i.n	a11, a2, 16
4200bbf0:	0121c2        	l32i	a12, a1, 4
4200bbf3:	0261a2        	s32i	a10, a1, 8
4200bbf6:	d10c81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200bbf9:	0008e0        	callx8	a8
4200bbfc:	0612a2        	l16ui	a10, a2, 12
4200bbff:	7fabb2        	movi	a11, 0xfffffb7f
4200bc02:	10aab0        	and	a10, a10, a11
4200bc05:	80a0b2        	movi	a11, 128
4200bc08:	20aab0        	or	a10, a10, a11
4200bc0b:	21e8      	l32i.n	a14, a1, 8
4200bc0d:	0652a2        	s16i	a10, a2, 12
4200bc10:	000b46        	j	4200bc41 <__sfvwrite_r+0x13d>
4200bc13:	000000        	ill
4200bc16:	01a8      	l32i.n	a10, a1, 0
4200bc18:	d46381        	l32r	a8, 42000da4 <_stext+0xd84> (4037fee0 <_realloc_r>)
4200bc1b:	0008e0        	callx8	a8
4200bc1e:	0aed      	mov.n	a14, a10
4200bc20:	dadc      	bnez.n	a10, 4200bc41 <__sfvwrite_r+0x13d>
4200bc22:	01a8      	l32i.n	a10, a1, 0
4200bc24:	42b8      	l32i.n	a11, a2, 16
4200bc26:	d44a81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200bc29:	0008e0        	callx8	a8
4200bc2c:	061292        	l16ui	a9, a2, 12
4200bc2f:	7fafa2        	movi	a10, -129
4200bc32:	1099a0        	and	a9, a9, a10
4200bc35:	065292        	s16i	a9, a2, 12
4200bc38:	0188      	l32i.n	a8, a1, 0
4200bc3a:	c90c      	movi.n	a9, 12
4200bc3c:	0899      	s32i.n	a9, a8, 0
4200bc3e:	005786        	j	4200bda0 <__sfvwrite_r+0x29c>
4200bc41:	1188      	l32i.n	a8, a1, 4
4200bc43:	42e9      	s32i.n	a14, a2, 16
4200bc45:	c0d680        	sub	a13, a6, a8
4200bc48:	ee8a      	add.n	a14, a14, a8
4200bc4a:	02e9      	s32i.n	a14, a2, 0
4200bc4c:	5269      	s32i.n	a6, a2, 20
4200bc4e:	03ed      	mov.n	a14, a3
4200bc50:	22d9      	s32i.n	a13, a2, 8
4200bc52:	036d      	mov.n	a6, a3
4200bc54:	03cd      	mov.n	a12, a3
4200bc56:	000046        	j	4200bc5b <__sfvwrite_r+0x157>
4200bc59:	036d      	mov.n	a6, a3
4200bc5b:	02a8      	l32i.n	a10, a2, 0
4200bc5d:	05bd      	mov.n	a11, a5
4200bc5f:	21e9      	s32i.n	a14, a1, 8
4200bc61:	11c9      	s32i.n	a12, a1, 4
4200bc63:	d33781        	l32r	a8, 42000940 <_stext+0x920> (40001200 <memmove>)
4200bc66:	0008e0        	callx8	a8
4200bc69:	22a8      	l32i.n	a10, a2, 8
4200bc6b:	21e8      	l32i.n	a14, a1, 8
4200bc6d:	11c8      	l32i.n	a12, a1, 4
4200bc6f:	c0aae0        	sub	a10, a10, a14
4200bc72:	22a9      	s32i.n	a10, a2, 8
4200bc74:	02a8      	l32i.n	a10, a2, 0
4200bc76:	aaca      	add.n	a10, a10, a12
4200bc78:	02a9      	s32i.n	a10, a2, 0
4200bc7a:	0015c6        	j	4200bcd5 <__sfvwrite_r+0x1d1>
4200bc7d:	42b800        	xorb	b11, b8, b0
4200bc80:	043ba7        	bltu	a11, a10, 4200bc88 <__sfvwrite_r+0x184>
4200bc83:	52b8      	l32i.n	a11, a2, 20
4200bc85:	2bb3b7        	bgeu	a3, a11, 4200bcb4 <__sfvwrite_r+0x1b0>
4200bc88:	636e30        	minu	a6, a14, a3
4200bc8b:	05bd      	mov.n	a11, a5
4200bc8d:	06cd      	mov.n	a12, a6
4200bc8f:	d32c81        	l32r	a8, 42000940 <_stext+0x920> (40001200 <memmove>)
4200bc92:	0008e0        	callx8	a8
4200bc95:	22a8      	l32i.n	a10, a2, 8
4200bc97:	02b8      	l32i.n	a11, a2, 0
4200bc99:	c0aa60        	sub	a10, a10, a6
4200bc9c:	bb6a      	add.n	a11, a11, a6
4200bc9e:	22a9      	s32i.n	a10, a2, 8
4200bca0:	02b9      	s32i.n	a11, a2, 0
4200bca2:	faec      	bnez.n	a10, 4200bcd5 <__sfvwrite_r+0x1d1>
4200bca4:	01a8      	l32i.n	a10, a1, 0
4200bca6:	02bd      	mov.n	a11, a2
4200bca8:	201110        	or	a1, a1, a1
4200bcab:	ffaa25        	call8	4200b74c <_fflush_r>
4200bcae:	3aac      	beqz.n	a10, 4200bcd5 <__sfvwrite_r+0x1d1>
4200bcb0:	003b06        	j	4200bda0 <__sfvwrite_r+0x29c>
4200bcb3:	f87c00        	lsi	f0, a12, 0x3e0
4200bcb6:	418180        	srli	a8, a8, 1
4200bcb9:	63d380        	minu	a13, a3, a8
4200bcbc:	f2bdb0        	rems	a11, a13, a11
4200bcbf:	c0ddb0        	sub	a13, a13, a11
4200bcc2:	a2e8      	l32i.n	a14, a2, 40
4200bcc4:	82b8      	l32i.n	a11, a2, 32
4200bcc6:	01a8      	l32i.n	a10, a1, 0
4200bcc8:	05cd      	mov.n	a12, a5
4200bcca:	000ee0        	callx8	a14
4200bccd:	0a6d      	mov.n	a6, a10
4200bccf:	021ae6        	bgei	a10, 1, 4200bcd5 <__sfvwrite_r+0x1d1>
4200bcd2:	003286        	j	4200bda0 <__sfvwrite_r+0x29c>
4200bcd5:	24a8      	l32i.n	a10, a4, 8
4200bcd7:	556a      	add.n	a5, a5, a6
4200bcd9:	c0aa60        	sub	a10, a10, a6
4200bcdc:	24a9      	s32i.n	a10, a4, 8
4200bcde:	c03360        	sub	a3, a3, a6
4200bce1:	eb0a56        	bnez	a10, 4200bb95 <__sfvwrite_r+0x91>
4200bce4:	ff89c6        	j	4200bb0f <__sfvwrite_r+0xb>
4200bce7:	076800        	lsi	f0, a8, 28
4200bcea:	1758      	l32i.n	a5, a7, 4
4200bcec:	0a0c      	movi.n	a10, 0
4200bcee:	778b      	addi.n	a7, a7, 8
4200bcf0:	ff4516        	beqz	a5, 4200bce8 <__sfvwrite_r+0x1e4>
4200bcf3:	3adc      	bnez.n	a10, 4200bd0a <__sfvwrite_r+0x206>
4200bcf5:	05cd      	mov.n	a12, a5
4200bcf7:	ab0c      	movi.n	a11, 10
4200bcf9:	06ad      	mov.n	a10, a6
4200bcfb:	d42b81        	l32r	a8, 42000da8 <_stext+0xd88> (40001344 <memchr>)
4200bcfe:	0008e0        	callx8	a8
4200bd01:	351b      	addi.n	a3, a5, 1
4200bd03:	3a8c      	beqz.n	a10, 4200bd0a <__sfvwrite_r+0x206>
4200bd05:	aa1b      	addi.n	a10, a10, 1
4200bd07:	c03a60        	sub	a3, a10, a6
4200bd0a:	52d8      	l32i.n	a13, a2, 20
4200bd0c:	22c8      	l32i.n	a12, a2, 8
4200bd0e:	02a8      	l32i.n	a10, a2, 0
4200bd10:	42b8      	l32i.n	a11, a2, 16
4200bd12:	639350        	minu	a9, a3, a5
4200bd15:	cdca      	add.n	a12, a13, a12
4200bd17:	26bba7        	bgeu	a11, a10, 4200bd41 <__sfvwrite_r+0x23d>
4200bd1a:	23ac97        	bge	a12, a9, 4200bd41 <__sfvwrite_r+0x23d>
4200bd1d:	20b660        	or	a11, a6, a6
4200bd20:	11c9      	s32i.n	a12, a1, 4
4200bd22:	d30781        	l32r	a8, 42000940 <_stext+0x920> (40001200 <memmove>)
4200bd25:	0008e0        	callx8	a8
4200bd28:	0298      	l32i.n	a9, a2, 0
4200bd2a:	11c8      	l32i.n	a12, a1, 4
4200bd2c:	01a8      	l32i.n	a10, a1, 0
4200bd2e:	99ca      	add.n	a9, a9, a12
4200bd30:	0299      	s32i.n	a9, a2, 0
4200bd32:	02bd      	mov.n	a11, a2
4200bd34:	201110        	or	a1, a1, a1
4200bd37:	ffa165        	call8	4200b74c <_fflush_r>
4200bd3a:	11c8      	l32i.n	a12, a1, 4
4200bd3c:	5abc      	beqz.n	a10, 4200bd75 <__sfvwrite_r+0x271>
4200bd3e:	001786        	j	4200bda0 <__sfvwrite_r+0x29c>
4200bd41:	1329d7        	blt	a9, a13, 4200bd58 <__sfvwrite_r+0x254>
4200bd44:	a298      	l32i.n	a9, a2, 40
4200bd46:	82b8      	l32i.n	a11, a2, 32
4200bd48:	01a8      	l32i.n	a10, a1, 0
4200bd4a:	20c660        	or	a12, a6, a6
4200bd4d:	0009e0        	callx8	a9
4200bd50:	0acd      	mov.n	a12, a10
4200bd52:	1f1ae6        	bgei	a10, 1, 4200bd75 <__sfvwrite_r+0x271>
4200bd55:	0011c6        	j	4200bda0 <__sfvwrite_r+0x29c>
4200bd58:	09cd      	mov.n	a12, a9
4200bd5a:	06bd      	mov.n	a11, a6
4200bd5c:	1199      	s32i.n	a9, a1, 4
4200bd5e:	d2f881        	l32r	a8, 42000940 <_stext+0x920> (40001200 <memmove>)
4200bd61:	0008e0        	callx8	a8
4200bd64:	1198      	l32i.n	a9, a1, 4
4200bd66:	22a8      	l32i.n	a10, a2, 8
4200bd68:	09cd      	mov.n	a12, a9
4200bd6a:	c0aa90        	sub	a10, a10, a9
4200bd6d:	22a9      	s32i.n	a10, a2, 8
4200bd6f:	02a8      	l32i.n	a10, a2, 0
4200bd71:	aa9a      	add.n	a10, a10, a9
4200bd73:	02a9      	s32i.n	a10, a2, 0
4200bd75:	c033c0        	sub	a3, a3, a12
4200bd78:	1a0c      	movi.n	a10, 1
4200bd7a:	e3cc      	bnez.n	a3, 4200bd8c <__sfvwrite_r+0x288>
4200bd7c:	01a8      	l32i.n	a10, a1, 0
4200bd7e:	02bd      	mov.n	a11, a2
4200bd80:	11c9      	s32i.n	a12, a1, 4
4200bd82:	201110        	or	a1, a1, a1
4200bd85:	ff9c65        	call8	4200b74c <_fflush_r>
4200bd88:	11c8      	l32i.n	a12, a1, 4
4200bd8a:	2adc      	bnez.n	a10, 4200bda0 <__sfvwrite_r+0x29c>
4200bd8c:	2498      	l32i.n	a9, a4, 8
4200bd8e:	66ca      	add.n	a6, a6, a12
4200bd90:	c099c0        	sub	a9, a9, a12
4200bd93:	2499      	s32i.n	a9, a4, 8
4200bd95:	c055c0        	sub	a5, a5, a12
4200bd98:	f54956        	bnez	a9, 4200bcf0 <__sfvwrite_r+0x1ec>
4200bd9b:	ff5c06        	j	4200bb0f <__sfvwrite_r+0xb>
4200bd9e:	920000        	lsi	f0, a0, 0x248
4200bda1:	4c0612        	l8ui	a1, a6, 76
4200bda4:	a00a      	add.n	a10, a0, a0
4200bda6:	2099      	s32i.n	a9, a0, 8
4200bda8:	065292        	s16i	a9, a2, 12
4200bdab:	f27c      	movi.n	a2, -1
4200bdad:	f01d      	retw.n
	...

4200bdb0 <_printf_r>:
4200bdb0:	00a136        	entry	a1, 80
4200bdb3:	6149      	s32i.n	a4, a1, 24
4200bdb5:	7159      	s32i.n	a5, a1, 28
4200bdb7:	8169      	s32i.n	a6, a1, 32
4200bdb9:	9179      	s32i.n	a7, a1, 36
4200bdbb:	22b8      	l32i.n	a11, a2, 8
4200bdbd:	10c1e2        	addi	a14, a1, 16
4200bdc0:	30c1d2        	addi	a13, a1, 48
4200bdc3:	880c      	movi.n	a8, 8
4200bdc5:	02ad      	mov.n	a10, a2
4200bdc7:	03cd      	mov.n	a12, a3
4200bdc9:	8f0c      	movi.n	a15, 8
4200bdcb:	11e9      	s32i.n	a14, a1, 4
4200bdcd:	01d9      	s32i.n	a13, a1, 0
4200bdcf:	026182        	s32i	a8, a1, 8
4200bdd2:	201110        	or	a1, a1, a1
4200bdd5:	00c8a5        	call8	4200ca60 <_vfprintf_r>
4200bdd8:	0a2d      	mov.n	a2, a10
4200bdda:	f01d      	retw.n

4200bddc <printf>:
4200bddc:	00a136        	entry	a1, 80
4200bddf:	5139      	s32i.n	a3, a1, 20
4200bde1:	6149      	s32i.n	a4, a1, 24
4200bde3:	7159      	s32i.n	a5, a1, 28
4200bde5:	086162        	s32i	a6, a1, 32
4200bde8:	9179      	s32i.n	a7, a1, 36
4200bdea:	d25981        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200bded:	0008e0        	callx8	a8
4200bdf0:	2ab8      	l32i.n	a11, a10, 8
4200bdf2:	10c1e2        	addi	a14, a1, 16
4200bdf5:	30c1d2        	addi	a13, a1, 48
4200bdf8:	480c      	movi.n	a8, 4
4200bdfa:	02cd      	mov.n	a12, a2
4200bdfc:	4f0c      	movi.n	a15, 4
4200bdfe:	11e9      	s32i.n	a14, a1, 4
4200be00:	01d9      	s32i.n	a13, a1, 0
4200be02:	2189      	s32i.n	a8, a1, 8
4200be04:	201110        	or	a1, a1, a1
4200be07:	00c5a5        	call8	4200ca60 <_vfprintf_r>
4200be0a:	0a2d      	mov.n	a2, a10
4200be0c:	f01d      	retw.n
	...

4200be10 <_puts_r>:
4200be10:	008136        	entry	a1, 64
4200be13:	20a330        	or	a10, a3, a3
4200be16:	d12181        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200be19:	0008e0        	callx8	a8
4200be1c:	d3e481        	l32r	a8, 42000dac <_stext+0xd8c> (3c0295b2 <_ZTISt12out_of_range+0x126>)
4200be1f:	11a9      	s32i.n	a10, a1, 4
4200be21:	2189      	s32i.n	a8, a1, 8
4200be23:	180c      	movi.n	a8, 1
4200be25:	3189      	s32i.n	a8, a1, 12
4200be27:	280c      	movi.n	a8, 2
4200be29:	aa1b      	addi.n	a10, a10, 1
4200be2b:	5189      	s32i.n	a8, a1, 20
4200be2d:	a288      	l32i.n	a8, a2, 40
4200be2f:	0139      	s32i.n	a3, a1, 0
4200be31:	61a9      	s32i.n	a10, a1, 24
4200be33:	4119      	s32i.n	a1, a1, 16
4200be35:	2278      	l32i.n	a7, a2, 8
4200be37:	68cc      	bnez.n	a8, 4200be41 <_puts_r+0x31>
4200be39:	02ad      	mov.n	a10, a2
4200be3b:	201110        	or	a1, a1, a1
4200be3e:	ffb765        	call8	4200b9b4 <__sinit>
4200be41:	192782        	l32i	a8, a7, 100
4200be44:	0ee807        	bbsi	a8, 0, 4200be56 <_puts_r+0x46>
4200be47:	061782        	l16ui	a8, a7, 12
4200be4a:	08e897        	bbsi	a8, 9, 4200be56 <_puts_r+0x46>
4200be4d:	1627a2        	l32i	a10, a7, 88
4200be50:	d3be81        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200be53:	0008e0        	callx8	a8
4200be56:	02ad      	mov.n	a10, a2
4200be58:	10c1c2        	addi	a12, a1, 16
4200be5b:	20b770        	or	a11, a7, a7
4200be5e:	201110        	or	a1, a1, a1
4200be61:	ffca25        	call8	4200bb04 <__sfvwrite_r>
4200be64:	f87c      	movi.n	a8, -1
4200be66:	a20c      	movi.n	a2, 10
4200be68:	9328a0        	movnez	a2, a8, a10
4200be6b:	192782        	l32i	a8, a7, 100
4200be6e:	0ee807        	bbsi	a8, 0, 4200be80 <_puts_r+0x70>
4200be71:	061782        	l16ui	a8, a7, 12
4200be74:	08e897        	bbsi	a8, 9, 4200be80 <_puts_r+0x70>
4200be77:	1627a2        	l32i	a10, a7, 88
4200be7a:	d3b481        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200be7d:	0008e0        	callx8	a8
4200be80:	f01d      	retw.n
	...

4200be84 <puts>:
4200be84:	004136        	entry	a1, 32
4200be87:	d23281        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200be8a:	0008e0        	callx8	a8
4200be8d:	02bd      	mov.n	a11, a2
4200be8f:	fff825        	call8	4200be10 <_puts_r>
4200be92:	0a2d      	mov.n	a2, a10
4200be94:	f01d      	retw.n
	...

4200be98 <__sread>:
4200be98:	004136        	entry	a1, 32
4200be9b:	0793b2        	l16si	a11, a3, 14
4200be9e:	02ad      	mov.n	a10, a2
4200bea0:	04cd      	mov.n	a12, a4
4200bea2:	05dd      	mov.n	a13, a5
4200bea4:	201110        	or	a1, a1, a1
4200bea7:	fb3165        	call8	420071bc <_read_r>
4200beaa:	0a2d      	mov.n	a2, a10
4200beac:	00ca96        	bltz	a10, 4200bebc <__sread+0x24>
4200beaf:	152382        	l32i	a8, a3, 84
4200beb2:	88aa      	add.n	a8, a8, a10
4200beb4:	156382        	s32i	a8, a3, 84
4200beb7:	0003c6        	j	4200beca <__sread+0x32>
4200beba:	820000        	mull	a0, a0, a0
4200bebd:	7c0613        	lsi	f1, a6, 0x1f0
4200bec0:	92f9      	s32i.n	a15, a2, 36
4200bec2:	f0d9      	s32i.n	a13, a0, 60
4200bec4:	108890        	and	a8, a8, a9
4200bec7:	065382        	s16i	a8, a3, 12
4200beca:	f01d      	retw.n

4200becc <__seofread>:
4200becc:	004136        	entry	a1, 32
4200becf:	020c      	movi.n	a2, 0
4200bed1:	f01d      	retw.n
	...

4200bed4 <__swrite>:
4200bed4:	004136        	entry	a1, 32
4200bed7:	061382        	l16ui	a8, a3, 12
4200beda:	0e6887        	bbci	a8, 8, 4200beec <__swrite+0x18>
4200bedd:	0793b2        	l16si	a11, a3, 14
4200bee0:	2d0c      	movi.n	a13, 2
4200bee2:	0c0c      	movi.n	a12, 0
4200bee4:	02ad      	mov.n	a10, a2
4200bee6:	201110        	or	a1, a1, a1
4200bee9:	fb2625        	call8	4200714c <_lseek_r>
4200beec:	061382        	l16ui	a8, a3, 12
4200beef:	f97c      	movi.n	a9, -1
4200bef1:	f0d992        	addmi	a9, a9, 0xfffff000
4200bef4:	108890        	and	a8, a8, a9
4200bef7:	0793b2        	l16si	a11, a3, 14
4200befa:	065382        	s16i	a8, a3, 12
4200befd:	05dd      	mov.n	a13, a5
4200beff:	04cd      	mov.n	a12, a4
4200bf01:	02ad      	mov.n	a10, a2
4200bf03:	201110        	or	a1, a1, a1
4200bf06:	fb1d65        	call8	420070dc <_write_r>
4200bf09:	0a2d      	mov.n	a2, a10
4200bf0b:	f01d      	retw.n
4200bf0d:	000000        	ill

4200bf10 <__sseek>:
4200bf10:	004136        	entry	a1, 32
4200bf13:	0793b2        	l16si	a11, a3, 14
4200bf16:	02ad      	mov.n	a10, a2
4200bf18:	20c440        	or	a12, a4, a4
4200bf1b:	20d550        	or	a13, a5, a5
4200bf1e:	201110        	or	a1, a1, a1
4200bf21:	fb22a5        	call8	4200714c <_lseek_r>
4200bf24:	069382        	l16si	a8, a3, 12
4200bf27:	0a2d      	mov.n	a2, a10
4200bf29:	0d0a66        	bnei	a10, -1, 4200bf3a <__sseek+0x2a>
4200bf2c:	f97c      	movi.n	a9, -1
4200bf2e:	f0d992        	addmi	a9, a9, 0xfffff000
4200bf31:	108890        	and	a8, a8, a9
4200bf34:	065382        	s16i	a8, a3, 12
4200bf37:	000346        	j	4200bf48 <__sseek+0x38>
4200bf3a:	190c      	movi.n	a9, 1
4200bf3c:	119940        	slli	a9, a9, 12
4200bf3f:	208890        	or	a8, a8, a9
4200bf42:	065382        	s16i	a8, a3, 12
4200bf45:	1563a2        	s32i	a10, a3, 84
4200bf48:	f01d      	retw.n
	...

4200bf4c <__sclose>:
4200bf4c:	004136        	entry	a1, 32
4200bf4f:	0793b2        	l16si	a11, a3, 14
4200bf52:	02ad      	mov.n	a10, a2
4200bf54:	201110        	or	a1, a1, a1
4200bf57:	fb2d65        	call8	4200722c <_close_r>
4200bf5a:	0a2d      	mov.n	a2, a10
4200bf5c:	f01d      	retw.n
	...

4200bf60 <vprintf>:
4200bf60:	006136        	entry	a1, 48
4200bf63:	0139      	s32i.n	a3, a1, 0
4200bf65:	1149      	s32i.n	a4, a1, 4
4200bf67:	026152        	s32i	a5, a1, 8
4200bf6a:	d1f981        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200bf6d:	0008e0        	callx8	a8
4200bf70:	01d8      	l32i.n	a13, a1, 0
4200bf72:	11e8      	l32i.n	a14, a1, 4
4200bf74:	21f8      	l32i.n	a15, a1, 8
4200bf76:	2ab8      	l32i.n	a11, a10, 8
4200bf78:	02cd      	mov.n	a12, a2
4200bf7a:	201110        	or	a1, a1, a1
4200bf7d:	00ae25        	call8	4200ca60 <_vfprintf_r>
4200bf80:	0a2d      	mov.n	a2, a10
4200bf82:	f01d      	retw.n

4200bf84 <_vprintf_r>:
4200bf84:	006136        	entry	a1, 48
4200bf87:	22b8      	l32i.n	a11, a2, 8
4200bf89:	02ad      	mov.n	a10, a2
4200bf8b:	03cd      	mov.n	a12, a3
4200bf8d:	04dd      	mov.n	a13, a4
4200bf8f:	05ed      	mov.n	a14, a5
4200bf91:	06fd      	mov.n	a15, a6
4200bf93:	201110        	or	a1, a1, a1
4200bf96:	00aca5        	call8	4200ca60 <_vfprintf_r>
4200bf99:	0a2d      	mov.n	a2, a10
4200bf9b:	f01d      	retw.n
4200bf9d:	000000        	ill

4200bfa0 <__swsetup_r>:
4200bfa0:	004136        	entry	a1, 32
4200bfa3:	d1eb81        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200bfa6:	0008e0        	callx8	a8
4200bfa9:	8a8c      	beqz.n	a10, 4200bfb5 <__swsetup_r+0x15>
4200bfab:	aa88      	l32i.n	a8, a10, 40
4200bfad:	48cc      	bnez.n	a8, 4200bfb5 <__swsetup_r+0x15>
4200bfaf:	201110        	or	a1, a1, a1
4200bfb2:	ffa025        	call8	4200b9b4 <__sinit>
4200bfb5:	069382        	l16si	a8, a3, 12
4200bfb8:	3ee837        	bbsi	a8, 3, 4200bffa <__swsetup_r+0x5a>
4200bfbb:	06e847        	bbsi	a8, 4, 4200bfc5 <__swsetup_r+0x25>
4200bfbe:	990c      	movi.n	a9, 9
4200bfc0:	0299      	s32i.n	a9, a2, 0
4200bfc2:	001c86        	j	4200c038 <__swsetup_r+0x98>
4200bfc5:	296827        	bbci	a8, 2, 4200bff2 <__swsetup_r+0x52>
4200bfc8:	d3b8      	l32i.n	a11, a3, 52
4200bfca:	0b9c      	beqz.n	a11, 4200bfde <__swsetup_r+0x3e>
4200bfcc:	44c382        	addi	a8, a3, 68
4200bfcf:	071b87        	beq	a11, a8, 4200bfda <__swsetup_r+0x3a>
4200bfd2:	02ad      	mov.n	a10, a2
4200bfd4:	d35f81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200bfd7:	0008e0        	callx8	a8
4200bfda:	080c      	movi.n	a8, 0
4200bfdc:	d389      	s32i.n	a8, a3, 52
4200bfde:	061382        	l16ui	a8, a3, 12
4200bfe1:	dbaf92        	movi	a9, -37
4200bfe4:	108890        	and	a8, a8, a9
4200bfe7:	090c      	movi.n	a9, 0
4200bfe9:	1399      	s32i.n	a9, a3, 4
4200bfeb:	4398      	l32i.n	a9, a3, 16
4200bfed:	238880        	sext	a8, a8, 15
4200bff0:	0399      	s32i.n	a9, a3, 0
4200bff2:	890c      	movi.n	a9, 8
4200bff4:	208890        	or	a8, a8, a9
4200bff7:	065382        	s16i	a8, a3, 12
4200bffa:	4398      	l32i.n	a9, a3, 16
4200bffc:	49dc      	bnez.n	a9, 4200c014 <__swsetup_r+0x74>
4200bffe:	80a292        	movi	a9, 0x280
4200c001:	108890        	and	a8, a8, a9
4200c004:	00a292        	movi	a9, 0x200
4200c007:	091897        	beq	a8, a9, 4200c014 <__swsetup_r+0x74>
4200c00a:	03bd      	mov.n	a11, a3
4200c00c:	02ad      	mov.n	a10, a2
4200c00e:	201110        	or	a1, a1, a1
4200c011:	059b25        	call8	420119c4 <__smakebuf_r>
4200c014:	069382        	l16si	a8, a3, 12
4200c017:	090c      	movi.n	a9, 0
4200c019:	0b6807        	bbci	a8, 0, 4200c028 <__swsetup_r+0x88>
4200c01c:	2399      	s32i.n	a9, a3, 8
4200c01e:	5398      	l32i.n	a9, a3, 20
4200c020:	609090        	neg	a9, a9
4200c023:	6399      	s32i.n	a9, a3, 24
4200c025:	000186        	j	4200c02f <__swsetup_r+0x8f>
4200c028:	01e817        	bbsi	a8, 1, 4200c02d <__swsetup_r+0x8d>
4200c02b:	5398      	l32i.n	a9, a3, 20
4200c02d:	2399      	s32i.n	a9, a3, 8
4200c02f:	4398      	l32i.n	a9, a3, 16
4200c031:	020c      	movi.n	a2, 0
4200c033:	b9cc      	bnez.n	a9, 4200c042 <__swsetup_r+0xa2>
4200c035:	096877        	bbci	a8, 7, 4200c042 <__swsetup_r+0xa2>
4200c038:	094c      	movi.n	a9, 64
4200c03a:	208890        	or	a8, a8, a9
4200c03d:	065382        	s16i	a8, a3, 12
4200c040:	f27c      	movi.n	a2, -1
4200c042:	f01d      	retw.n

4200c044 <_fseeko_r>:
4200c044:	012136        	entry	a1, 144
4200c047:	a28c      	beqz.n	a2, 4200c055 <_fseeko_r+0x11>
4200c049:	a288      	l32i.n	a8, a2, 40
4200c04b:	68cc      	bnez.n	a8, 4200c055 <_fseeko_r+0x11>
4200c04d:	02ad      	mov.n	a10, a2
4200c04f:	201110        	or	a1, a1, a1
4200c052:	ff9625        	call8	4200b9b4 <__sinit>
4200c055:	192382        	l32i	a8, a3, 100
4200c058:	0ee807        	bbsi	a8, 0, 4200c06a <_fseeko_r+0x26>
4200c05b:	061382        	l16ui	a8, a3, 12
4200c05e:	08e897        	bbsi	a8, 9, 4200c06a <_fseeko_r+0x26>
4200c061:	1623a2        	l32i	a10, a3, 88
4200c064:	d33981        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200c067:	0008e0        	callx8	a8
4200c06a:	061392        	l16ui	a9, a3, 12
4200c06d:	08a182        	movi	a8, 0x108
4200c070:	09c987        	bnall	a9, a8, 4200c07d <_fseeko_r+0x39>
4200c073:	03bd      	mov.n	a11, a3
4200c075:	02ad      	mov.n	a10, a2
4200c077:	201110        	or	a1, a1, a1
4200c07a:	ff6d25        	call8	4200b74c <_fflush_r>
4200c07d:	b378      	l32i.n	a7, a3, 44
4200c07f:	d81c      	movi.n	a8, 29
4200c081:	085716        	beqz	a7, 4200c10a <_fseeko_r+0xc6>
4200c084:	0e1526        	beqi	a5, 1, 4200c096 <_fseeko_r+0x52>
4200c087:	d87c      	movi.n	a8, -3
4200c089:	106580        	and	a6, a5, a8
4200c08c:	681c      	movi.n	a8, 22
4200c08e:	078656        	bnez	a6, 4200c10a <_fseeko_r+0xc6>
4200c091:	001e86        	j	4200c10f <_fseeko_r+0xcb>
4200c094:	bd0000        	lsi	f0, a0, 0x2f4
4200c097:	02ad03        	lsi	f0, a13, 8
4200c09a:	201110        	or	a1, a1, a1
4200c09d:	ff6ae5        	call8	4200b74c <_fflush_r>
4200c0a0:	061382        	l16ui	a8, a3, 12
4200c0a3:	0668c7        	bbci	a8, 12, 4200c0ad <_fseeko_r+0x69>
4200c0a6:	152362        	l32i	a6, a3, 84
4200c0a9:	000ac6        	j	4200c0d8 <_fseeko_r+0x94>
4200c0ac:	83b800        	moveqz	a11, a8, a0
4200c0af:	1d0c      	movi.n	a13, 1
4200c0b1:	0c0c      	movi.n	a12, 0
4200c0b3:	02ad      	mov.n	a10, a2
4200c0b5:	0007e0        	callx8	a7
4200c0b8:	0a6d      	mov.n	a6, a10
4200c0ba:	1a0a66        	bnei	a10, -1, 4200c0d8 <_fseeko_r+0x94>
4200c0bd:	192382        	l32i	a8, a3, 100
4200c0c0:	0ee807        	bbsi	a8, 0, 4200c0d2 <_fseeko_r+0x8e>
4200c0c3:	061382        	l16ui	a8, a3, 12
4200c0c6:	08e897        	bbsi	a8, 9, 4200c0d2 <_fseeko_r+0x8e>
4200c0c9:	1623a2        	l32i	a10, a3, 88
4200c0cc:	d32081        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200c0cf:	0008e0        	callx8	a8
4200c0d2:	f27c      	movi.n	a2, -1
4200c0d4:	008d06        	j	4200c30c <_fseeko_r+0x2c8>
4200c0d7:	939200        	movnez	a9, a2, a0
4200c0da:	692706        	j	4202657a <_etext+0xf33c>
4200c0dd:	139811        	l32r	a1, 41fd0f40 <_coredump_iram_end+0x1c4ef40>
4200c0e0:	c06690        	sub	a6, a6, a9
4200c0e3:	d398      	l32i.n	a9, a3, 52
4200c0e5:	599c      	beqz.n	a9, 4200c0fe <_fseeko_r+0xba>
4200c0e7:	102392        	l32i	a9, a3, 64
4200c0ea:	c06690        	sub	a6, a6, a9
4200c0ed:	000346        	j	4200c0fe <_fseeko_r+0xba>
4200c0f0:	0a6937        	bbci	a9, 3, 4200c0fe <_fseeko_r+0xba>
4200c0f3:	0398      	l32i.n	a9, a3, 0
4200c0f5:	598c      	beqz.n	a9, 4200c0fe <_fseeko_r+0xba>
4200c0f7:	43a8      	l32i.n	a10, a3, 16
4200c0f9:	c099a0        	sub	a9, a9, a10
4200c0fc:	669a      	add.n	a6, a6, a9
4200c0fe:	180c      	movi.n	a8, 1
4200c100:	446a      	add.n	a4, a4, a6
4200c102:	186182        	s32i	a8, a1, 96
4200c105:	050c      	movi.n	a5, 0
4200c107:	000246        	j	4200c114 <_fseeko_r+0xd0>
4200c10a:	0289      	s32i.n	a8, a2, 0
4200c10c:	ffeb46        	j	4200c0bd <_fseeko_r+0x79>
4200c10f:	080c      	movi.n	a8, 0
4200c111:	186182        	s32i	a8, a1, 96
4200c114:	4398      	l32i.n	a9, a3, 16
4200c116:	89cc      	bnez.n	a9, 4200c122 <_fseeko_r+0xde>
4200c118:	03bd      	mov.n	a11, a3
4200c11a:	02ad      	mov.n	a10, a2
4200c11c:	201110        	or	a1, a1, a1
4200c11f:	058a65        	call8	420119c4 <__smakebuf_r>
4200c122:	aa1c      	movi.n	a10, 26
4200c124:	069392        	l16si	a9, a3, 12
4200c127:	08daa2        	addmi	a10, a10, 0x800
4200c12a:	0209a7        	bnone	a9, a10, 4200c130 <_fseeko_r+0xec>
4200c12d:	005a06        	j	4200c299 <_fseeko_r+0x255>
4200c130:	4de9a7        	bbsi	a9, 10, 4200c181 <_fseeko_r+0x13d>
4200c133:	d30d91        	l32r	a9, 42000d68 <_stext+0xd48> (4200bf10 <__sseek>)
4200c136:	121797        	beq	a7, a9, 4200c14c <_fseeko_r+0x108>
4200c139:	061382        	l16ui	a8, a3, 12
4200c13c:	190c      	movi.n	a9, 1
4200c13e:	119950        	slli	a9, a9, 11
4200c141:	208890        	or	a8, a8, a9
4200c144:	065382        	s16i	a8, a3, 12
4200c147:	005386        	j	4200c299 <_fseeko_r+0x255>
4200c14a:	b20000        	mulsh	a0, a0, a0
4200c14d:	960793        	lsi	f9, a7, 0x258
4200c150:	fe6b      	addi.n	a15, a14, 6
4200c152:	01cd      	mov.n	a12, a1
4200c154:	02ad      	mov.n	a10, a2
4200c156:	201110        	or	a1, a1, a1
4200c159:	fb1965        	call8	420072f0 <_fstat_r>
4200c15c:	fd9a56        	bnez	a10, 4200c139 <_fseeko_r+0xf5>
4200c15f:	1198      	l32i.n	a9, a1, 4
4200c161:	1a0c      	movi.n	a10, 1
4200c163:	349c90        	extui	a9, a9, 12, 4
4200c166:	119940        	slli	a9, a9, 12
4200c169:	11aa10        	slli	a10, a10, 15
4200c16c:	c999a7        	bne	a9, a10, 4200c139 <_fseeko_r+0xf5>
4200c16f:	1221a2        	l32i	a10, a1, 72
4200c172:	069392        	l16si	a9, a3, 12
4200c175:	1463a2        	s32i	a10, a3, 80
4200c178:	00a4a2        	movi	a10, 0x400
4200c17b:	2099a0        	or	a9, a9, a10
4200c17e:	065392        	s16i	a9, a3, 12
4200c181:	049d      	mov.n	a9, a4
4200c183:	015516        	beqz	a5, 4200c19c <_fseeko_r+0x158>
4200c186:	0793b2        	l16si	a11, a3, 14
4200c189:	20c110        	or	a12, a1, a1
4200c18c:	20a220        	or	a10, a2, a2
4200c18f:	201110        	or	a1, a1, a1
4200c192:	fb15e5        	call8	420072f0 <_fstat_r>
4200c195:	100a56        	bnez	a10, 4200c299 <_fseeko_r+0x255>
4200c198:	4198      	l32i.n	a9, a1, 16
4200c19a:	949a      	add.n	a9, a4, a9
4200c19c:	182182        	l32i	a8, a1, 96
4200c19f:	18fc      	bnez.n	a8, 4200c1d4 <_fseeko_r+0x190>
4200c1a1:	061382        	l16ui	a8, a3, 12
4200c1a4:	0668c7        	bbci	a8, 12, 4200c1ae <_fseeko_r+0x16a>
4200c1a7:	1523a2        	l32i	a10, a3, 84
4200c1aa:	0005c6        	j	4200c1c5 <_fseeko_r+0x181>
4200c1ad:	83b800        	moveqz	a11, a8, a0
4200c1b0:	1d0c      	movi.n	a13, 1
4200c1b2:	0c0c      	movi.n	a12, 0
4200c1b4:	02ad      	mov.n	a10, a2
4200c1b6:	186192        	s32i	a9, a1, 96
4200c1b9:	0007e0        	callx8	a7
4200c1bc:	182192        	l32i	a9, a1, 96
4200c1bf:	020a66        	bnei	a10, -1, 4200c1c5 <_fseeko_r+0x181>
4200c1c2:	0034c6        	j	4200c299 <_fseeko_r+0x255>
4200c1c5:	1388      	l32i.n	a8, a3, 4
4200c1c7:	c06a80        	sub	a6, a10, a8
4200c1ca:	d3a8      	l32i.n	a10, a3, 52
4200c1cc:	4a8c      	beqz.n	a10, 4200c1d4 <_fseeko_r+0x190>
4200c1ce:	1023a2        	l32i	a10, a3, 64
4200c1d1:	c066a0        	sub	a6, a6, a10
4200c1d4:	d3b8      	l32i.n	a11, a3, 52
4200c1d6:	43c8      	l32i.n	a12, a3, 16
4200c1d8:	13a8      	l32i.n	a10, a3, 4
4200c1da:	eb8c      	beqz.n	a11, 4200c1ec <_fseeko_r+0x1a8>
4200c1dc:	f3d8      	l32i.n	a13, a3, 60
4200c1de:	86aa      	add.n	a8, a6, a10
4200c1e0:	c0ddc0        	sub	a13, a13, a12
4200c1e3:	1023a2        	l32i	a10, a3, 64
4200c1e6:	c088d0        	sub	a8, a8, a13
4200c1e9:	0001c6        	j	4200c1f4 <_fseeko_r+0x1b0>
4200c1ec:	03d8      	l32i.n	a13, a3, 0
4200c1ee:	c0ddc0        	sub	a13, a13, a12
4200c1f1:	c086d0        	sub	a8, a6, a13
4200c1f4:	aada      	add.n	a10, a10, a13
4200c1f6:	2f2987        	blt	a9, a8, 4200c229 <_fseeko_r+0x1e5>
4200c1f9:	d8aa      	add.n	a13, a8, a10
4200c1fb:	2ab9d7        	bgeu	a9, a13, 4200c229 <_fseeko_r+0x1e5>
4200c1fe:	c08980        	sub	a8, a9, a8
4200c201:	cc8a      	add.n	a12, a12, a8
4200c203:	c0aa80        	sub	a10, a10, a8
4200c206:	03c9      	s32i.n	a12, a3, 0
4200c208:	13a9      	s32i.n	a10, a3, 4
4200c20a:	0b9c      	beqz.n	a11, 4200c21e <_fseeko_r+0x1da>
4200c20c:	44c382        	addi	a8, a3, 68
4200c20f:	071b87        	beq	a11, a8, 4200c21a <_fseeko_r+0x1d6>
4200c212:	02ad      	mov.n	a10, a2
4200c214:	d2cf81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c217:	0008e0        	callx8	a8
4200c21a:	080c      	movi.n	a8, 0
4200c21c:	d389      	s32i.n	a8, a3, 52
4200c21e:	061382        	l16ui	a8, a3, 12
4200c221:	dfaf92        	movi	a9, -33
4200c224:	002e86        	j	4200c2e2 <_fseeko_r+0x29e>
4200c227:	620000        	lsi	f0, a0, 0x188
4200c22a:	b81423        	lsi	f2, a4, 0x2e0
4200c22d:	606083        	lsi	f8, a0, 0x180
4200c230:	669060        	lsi	f6, a0, 0x198
4200c233:	0d0c10        	lsi	f1, a12, 52
4200c236:	06cd      	mov.n	a12, a6
4200c238:	02ad      	mov.n	a10, a2
4200c23a:	186192        	s32i	a9, a1, 96
4200c23d:	0007e0        	callx8	a7
4200c240:	550a26        	beqi	a10, -1, 4200c299 <_fseeko_r+0x255>
4200c243:	080c      	movi.n	a8, 0
4200c245:	1389      	s32i.n	a8, a3, 4
4200c247:	4388      	l32i.n	a8, a3, 16
4200c249:	d3b8      	l32i.n	a11, a3, 52
4200c24b:	0389      	s32i.n	a8, a3, 0
4200c24d:	182192        	l32i	a9, a1, 96
4200c250:	4b9c      	beqz.n	a11, 4200c268 <_fseeko_r+0x224>
4200c252:	44c382        	addi	a8, a3, 68
4200c255:	0b1b87        	beq	a11, a8, 4200c264 <_fseeko_r+0x220>
4200c258:	20a220        	or	a10, a2, a2
4200c25b:	d2bd81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c25e:	0008e0        	callx8	a8
4200c261:	182192        	l32i	a9, a1, 96
4200c264:	080c      	movi.n	a8, 0
4200c266:	d389      	s32i.n	a8, a3, 52
4200c268:	061382        	l16ui	a8, a3, 12
4200c26b:	dfafa2        	movi	a10, -33
4200c26e:	1088a0        	and	a8, a8, a10
4200c271:	065382        	s16i	a8, a3, 12
4200c274:	c06960        	sub	a6, a9, a6
4200c277:	06d616        	beqz	a6, 4200c2e8 <_fseeko_r+0x2a4>
4200c27a:	03bd      	mov.n	a11, a3
4200c27c:	02ad      	mov.n	a10, a2
4200c27e:	201110        	or	a1, a1, a1
4200c281:	057ea5        	call8	42011a6c <__srefill_r>
4200c284:	1adc      	bnez.n	a10, 4200c299 <_fseeko_r+0x255>
4200c286:	1388      	l32i.n	a8, a3, 4
4200c288:	0d3867        	bltu	a8, a6, 4200c299 <_fseeko_r+0x255>
4200c28b:	0398      	l32i.n	a9, a3, 0
4200c28d:	c08860        	sub	a8, a8, a6
4200c290:	996a      	add.n	a9, a9, a6
4200c292:	0399      	s32i.n	a9, a3, 0
4200c294:	1389      	s32i.n	a8, a3, 4
4200c296:	001386        	j	4200c2e8 <_fseeko_r+0x2a4>
4200c299:	03bd      	mov.n	a11, a3
4200c29b:	20a220        	or	a10, a2, a2
4200c29e:	201110        	or	a1, a1, a1
4200c2a1:	ff4aa5        	call8	4200b74c <_fflush_r>
4200c2a4:	1a8c      	beqz.n	a10, 4200c2a9 <_fseeko_r+0x265>
4200c2a6:	ff84c6        	j	4200c0bd <_fseeko_r+0x79>
4200c2a9:	83b8      	l32i.n	a11, a3, 32
4200c2ab:	05dd      	mov.n	a13, a5
4200c2ad:	04cd      	mov.n	a12, a4
4200c2af:	02ad      	mov.n	a10, a2
4200c2b1:	0007e0        	callx8	a7
4200c2b4:	020a66        	bnei	a10, -1, 4200c2ba <_fseeko_r+0x276>
4200c2b7:	ff8086        	j	4200c0bd <_fseeko_r+0x79>
4200c2ba:	d3b8      	l32i.n	a11, a3, 52
4200c2bc:	1b9c      	beqz.n	a11, 4200c2d1 <_fseeko_r+0x28d>
4200c2be:	44c382        	addi	a8, a3, 68
4200c2c1:	081b87        	beq	a11, a8, 4200c2cd <_fseeko_r+0x289>
4200c2c4:	20a220        	or	a10, a2, a2
4200c2c7:	d2a281        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c2ca:	0008e0        	callx8	a8
4200c2cd:	080c      	movi.n	a8, 0
4200c2cf:	d389      	s32i.n	a8, a3, 52
4200c2d1:	4388      	l32i.n	a8, a3, 16
4200c2d3:	dfa092        	movi	a9, 223
4200c2d6:	0389      	s32i.n	a8, a3, 0
4200c2d8:	080c      	movi.n	a8, 0
4200c2da:	1389      	s32i.n	a8, a3, 4
4200c2dc:	061382        	l16ui	a8, a3, 12
4200c2df:	f7d992        	addmi	a9, a9, 0xfffff700
4200c2e2:	108890        	and	a8, a8, a9
4200c2e5:	065382        	s16i	a8, a3, 12
4200c2e8:	8c0c      	movi.n	a12, 8
4200c2ea:	0b0c      	movi.n	a11, 0
4200c2ec:	5cc3a2        	addi	a10, a3, 92
4200c2ef:	d00481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200c2f2:	0008e0        	callx8	a8
4200c2f5:	192382        	l32i	a8, a3, 100
4200c2f8:	0ee807        	bbsi	a8, 0, 4200c30a <_fseeko_r+0x2c6>
4200c2fb:	061382        	l16ui	a8, a3, 12
4200c2fe:	08e897        	bbsi	a8, 9, 4200c30a <_fseeko_r+0x2c6>
4200c301:	1623a2        	l32i	a10, a3, 88
4200c304:	d29281        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200c307:	0008e0        	callx8	a8
4200c30a:	020c      	movi.n	a2, 0
4200c30c:	f01d      	retw.n
	...

4200c310 <fseeko>:
4200c310:	004136        	entry	a1, 32
4200c313:	d10f81        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c316:	0008e0        	callx8	a8
4200c319:	02bd      	mov.n	a11, a2
4200c31b:	04dd      	mov.n	a13, a4
4200c31d:	03cd      	mov.n	a12, a3
4200c31f:	ffd265        	call8	4200c044 <_fseeko_r>
4200c322:	0a2d      	mov.n	a2, a10
4200c324:	f01d      	retw.n
	...

4200c328 <_reclaim_reent>:
4200c328:	004136        	entry	a1, 32
4200c32b:	d2a181        	l32r	a8, 42000db0 <_stext+0xd90> (3fc927c4 <_impure_ptr>)
4200c32e:	0888      	l32i.n	a8, a8, 0
4200c330:	029827        	bne	a8, a2, 4200c336 <_reclaim_reent+0xe>
4200c333:	002cc6        	j	4200c3ea <_reclaim_reent+0xc2>
4200c336:	9288      	l32i.n	a8, a2, 36
4200c338:	e8bc      	beqz.n	a8, 4200c37a <_reclaim_reent+0x52>
4200c33a:	3888      	l32i.n	a8, a8, 12
4200c33c:	c8ac      	beqz.n	a8, 4200c36c <_reclaim_reent+0x44>
4200c33e:	070c      	movi.n	a7, 0
4200c340:	9288      	l32i.n	a8, a2, 36
4200c342:	3888      	l32i.n	a8, a8, 12
4200c344:	887a      	add.n	a8, a8, a7
4200c346:	08b8      	l32i.n	a11, a8, 0
4200c348:	000306        	j	4200c358 <_reclaim_reent+0x30>
4200c34b:	0b6800        	lsi	f0, a8, 44
4200c34e:	02ad      	mov.n	a10, a2
4200c350:	d28081        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c353:	0008e0        	callx8	a8
4200c356:	06bd      	mov.n	a11, a6
4200c358:	ff0b56        	bnez	a11, 4200c34c <_reclaim_reent+0x24>
4200c35b:	774b      	addi.n	a7, a7, 4
4200c35d:	dfe766        	bnei	a7, 128, 4200c340 <_reclaim_reent+0x18>
4200c360:	9288      	l32i.n	a8, a2, 36
4200c362:	02ad      	mov.n	a10, a2
4200c364:	38b8      	l32i.n	a11, a8, 12
4200c366:	d27a81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c369:	0008e0        	callx8	a8
4200c36c:	9288      	l32i.n	a8, a2, 36
4200c36e:	08b8      	l32i.n	a11, a8, 0
4200c370:	6b8c      	beqz.n	a11, 4200c37a <_reclaim_reent+0x52>
4200c372:	02ad      	mov.n	a10, a2
4200c374:	d27781        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c377:	0008e0        	callx8	a8
4200c37a:	52b8      	l32i.n	a11, a2, 20
4200c37c:	6b8c      	beqz.n	a11, 4200c386 <_reclaim_reent+0x5e>
4200c37e:	02ad      	mov.n	a10, a2
4200c380:	d27481        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c383:	0008e0        	callx8	a8
4200c386:	92b8      	l32i.n	a11, a2, 36
4200c388:	6b8c      	beqz.n	a11, 4200c392 <_reclaim_reent+0x6a>
4200c38a:	02ad      	mov.n	a10, a2
4200c38c:	d27181        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c38f:	0008e0        	callx8	a8
4200c392:	e2b8      	l32i.n	a11, a2, 56
4200c394:	6b8c      	beqz.n	a11, 4200c39e <_reclaim_reent+0x76>
4200c396:	02ad      	mov.n	a10, a2
4200c398:	d26e81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c39b:	0008e0        	callx8	a8
4200c39e:	f2b8      	l32i.n	a11, a2, 60
4200c3a0:	008b16        	beqz	a11, 4200c3ac <_reclaim_reent+0x84>
4200c3a3:	20a220        	or	a10, a2, a2
4200c3a6:	d26a81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c3a9:	0008e0        	callx8	a8
4200c3ac:	1022b2        	l32i	a11, a2, 64
4200c3af:	6b8c      	beqz.n	a11, 4200c3b9 <_reclaim_reent+0x91>
4200c3b1:	02ad      	mov.n	a10, a2
4200c3b3:	d26781        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c3b6:	0008e0        	callx8	a8
4200c3b9:	3b22b2        	l32i	a11, a2, 236
4200c3bc:	008b16        	beqz	a11, 4200c3c8 <_reclaim_reent+0xa0>
4200c3bf:	20a220        	or	a10, a2, a2
4200c3c2:	d26381        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c3c5:	0008e0        	callx8	a8
4200c3c8:	3a22b2        	l32i	a11, a2, 232
4200c3cb:	6b8c      	beqz.n	a11, 4200c3d5 <_reclaim_reent+0xad>
4200c3cd:	02ad      	mov.n	a10, a2
4200c3cf:	d26081        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c3d2:	0008e0        	callx8	a8
4200c3d5:	d2b8      	l32i.n	a11, a2, 52
4200c3d7:	6b8c      	beqz.n	a11, 4200c3e1 <_reclaim_reent+0xb9>
4200c3d9:	02ad      	mov.n	a10, a2
4200c3db:	d25d81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
4200c3de:	0008e0        	callx8	a8
4200c3e1:	a288      	l32i.n	a8, a2, 40
4200c3e3:	388c      	beqz.n	a8, 4200c3ea <_reclaim_reent+0xc2>
4200c3e5:	02ad      	mov.n	a10, a2
4200c3e7:	0008e0        	callx8	a8
4200c3ea:	f01d      	retw.n

4200c3ec <__errno>:
4200c3ec:	004136        	entry	a1, 32
4200c3ef:	d0d881        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c3f2:	0008e0        	callx8	a8
4200c3f5:	0a2d      	mov.n	a2, a10
4200c3f7:	f01d      	retw.n
4200c3f9:	000000        	ill

4200c3fc <close>:
4200c3fc:	004136        	entry	a1, 32
4200c3ff:	d0d481        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c402:	0008e0        	callx8	a8
4200c405:	02bd      	mov.n	a11, a2
4200c407:	201110        	or	a1, a1, a1
4200c40a:	fae225        	call8	4200722c <_close_r>
4200c40d:	0a2d      	mov.n	a2, a10
4200c40f:	f01d      	retw.n
4200c411:	000000        	ill

4200c414 <fcntl>:
4200c414:	004136        	entry	a1, 32
4200c417:	d0ce81        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c41a:	0008e0        	callx8	a8
4200c41d:	02bd      	mov.n	a11, a2
4200c41f:	04dd      	mov.n	a13, a4
4200c421:	03cd      	mov.n	a12, a3
4200c423:	201110        	or	a1, a1, a1
4200c426:	faf365        	call8	4200735c <_fcntl_r>
4200c429:	0a2d      	mov.n	a2, a10
4200c42b:	f01d      	retw.n
4200c42d:	000000        	ill

4200c430 <gettimeofday>:
4200c430:	004136        	entry	a1, 32
4200c433:	d0c781        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c436:	0008e0        	callx8	a8
4200c439:	02bd      	mov.n	a11, a2
4200c43b:	20c330        	or	a12, a3, a3
4200c43e:	d25d81        	l32r	a8, 42000db4 <_stext+0xd94> (40376b7c <_gettimeofday_r>)
4200c441:	0008e0        	callx8	a8
4200c444:	0a2d      	mov.n	a2, a10
4200c446:	f01d      	retw.n

4200c448 <open>:
4200c448:	00a136        	entry	a1, 80
4200c44b:	10c182        	addi	a8, a1, 16
4200c44e:	1189      	s32i.n	a8, a1, 4
4200c450:	30c182        	addi	a8, a1, 48
4200c453:	0189      	s32i.n	a8, a1, 0
4200c455:	6149      	s32i.n	a4, a1, 24
4200c457:	880c      	movi.n	a8, 8
4200c459:	7159      	s32i.n	a5, a1, 28
4200c45b:	8169      	s32i.n	a6, a1, 32
4200c45d:	9179      	s32i.n	a7, a1, 36
4200c45f:	026182        	s32i	a8, a1, 8
4200c462:	d0bb81        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c465:	0008e0        	callx8	a8
4200c468:	2188      	l32i.n	a8, a1, 8
4200c46a:	8b1c      	movi.n	a11, 24
4200c46c:	984b      	addi.n	a9, a8, 4
4200c46e:	062b97        	blt	a11, a9, 4200c478 <open+0x30>
4200c471:	1188      	l32i.n	a8, a1, 4
4200c473:	000206        	j	4200c47f <open+0x37>
4200c476:	870000        	lsi	f0, a0, 0x21c
4200c479:	012b      	addi.n	a0, a1, 2
4200c47b:	492c      	movi.n	a9, 36
4200c47d:	0188      	l32i.n	a8, a1, 0
4200c47f:	889a      	add.n	a8, a8, a9
4200c481:	fcc882        	addi	a8, a8, -4
4200c484:	08d8      	l32i.n	a13, a8, 0
4200c486:	02bd      	mov.n	a11, a2
4200c488:	03cd      	mov.n	a12, a3
4200c48a:	201110        	or	a1, a1, a1
4200c48d:	fab4a5        	call8	42006fd8 <_open_r>
4200c490:	0a2d      	mov.n	a2, a10
4200c492:	f01d      	retw.n

4200c494 <read>:
4200c494:	004136        	entry	a1, 32
4200c497:	d0ae81        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c49a:	0008e0        	callx8	a8
4200c49d:	02bd      	mov.n	a11, a2
4200c49f:	04dd      	mov.n	a13, a4
4200c4a1:	03cd      	mov.n	a12, a3
4200c4a3:	201110        	or	a1, a1, a1
4200c4a6:	fad165        	call8	420071bc <_read_r>
4200c4a9:	0a2d      	mov.n	a2, a10
4200c4ab:	f01d      	retw.n
4200c4ad:	000000        	ill

4200c4b0 <write>:
4200c4b0:	004136        	entry	a1, 32
4200c4b3:	d0a781        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200c4b6:	0008e0        	callx8	a8
4200c4b9:	02bd      	mov.n	a11, a2
4200c4bb:	04dd      	mov.n	a13, a4
4200c4bd:	03cd      	mov.n	a12, a3
4200c4bf:	201110        	or	a1, a1, a1
4200c4c2:	fac1a5        	call8	420070dc <_write_r>
4200c4c5:	0a2d      	mov.n	a2, a10
4200c4c7:	f01d      	retw.n
4200c4c9:	000000        	ill

4200c4cc <__register_exitproc>:
4200c4cc:	004136        	entry	a1, 32
4200c4cf:	d23b71        	l32r	a7, 42000dbc <_stext+0xd9c> (3fc928b8 <__atexit_recursive_mutex>)
4200c4d2:	07a8      	l32i.n	a10, a7, 0
4200c4d4:	d21d81        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200c4d7:	0008e0        	callx8	a8
4200c4da:	d23981        	l32r	a8, 42000dc0 <_stext+0xda0> (3fc9532c <__atexit>)
4200c4dd:	0868      	l32i.n	a6, a8, 0
4200c4df:	d6cc      	bnez.n	a6, 4200c4f0 <__register_exitproc+0x24>
4200c4e1:	d23561        	l32r	a6, 42000db8 <_stext+0xd98> (3fc952a0 <__atexit0>)
4200c4e4:	0869      	s32i.n	a6, a8, 0
4200c4e6:	d23781        	l32r	a8, 42000dc4 <_stext+0xda4> (3c0298e4 <__on_exit_args>)
4200c4e9:	388c      	beqz.n	a8, 4200c4f0 <__register_exitproc+0x24>
4200c4eb:	0888      	l32i.n	a8, a8, 0
4200c4ed:	226682        	s32i	a8, a6, 136
4200c4f0:	1688      	l32i.n	a8, a6, 4
4200c4f2:	f91c      	movi.n	a9, 31
4200c4f4:	05a987        	bge	a9, a8, 4200c4fd <__register_exitproc+0x31>
4200c4f7:	0003c6        	j	4200c50a <__register_exitproc+0x3e>
4200c4fa:	000000        	ill
4200c4fd:	057216        	beqz	a2, 4200c558 <__register_exitproc+0x8c>
4200c500:	2226a2        	l32i	a10, a6, 136
4200c503:	9aec      	bnez.n	a10, 4200c530 <__register_exitproc+0x64>
4200c505:	d09f81        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
4200c508:	c8cc      	bnez.n	a8, 4200c518 <__register_exitproc+0x4c>
4200c50a:	07a8      	l32i.n	a10, a7, 0
4200c50c:	f27c      	movi.n	a2, -1
4200c50e:	d20f81        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200c511:	0008e0        	callx8	a8
4200c514:	0014c6        	j	4200c56b <__register_exitproc+0x9f>
4200c517:	a1a200        	sll	a10, a2
4200c51a:	8108      	l32i.n	a0, a1, 32
4200c51c:	d09a      	add.n	a13, a0, a9
4200c51e:	0008e0        	callx8	a8
4200c521:	fe5a16        	beqz	a10, 4200c50a <__register_exitproc+0x3e>
4200c524:	00a082        	movi	a8, 0
4200c527:	406a82        	s32i	a8, a10, 0x100
4200c52a:	416a82        	s32i	a8, a10, 0x104
4200c52d:	2266a2        	s32i	a10, a6, 136
4200c530:	1688      	l32i.n	a8, a6, 4
4200c532:	190c      	movi.n	a9, 1
4200c534:	a0c8a0        	addx4	a12, a8, a10
4200c537:	006c42        	s32i	a4, a12, 0
4200c53a:	402ab2        	l32i	a11, a10, 0x100
4200c53d:	401800        	ssl	a8
4200c540:	a19900        	sll	a9, a9
4200c543:	20bb90        	or	a11, a11, a9
4200c546:	406ab2        	s32i	a11, a10, 0x100
4200c549:	206c52        	s32i	a5, a12, 128
4200c54c:	082266        	bnei	a2, 2, 4200c558 <__register_exitproc+0x8c>
4200c54f:	412ab2        	l32i	a11, a10, 0x104
4200c552:	209b90        	or	a9, a11, a9
4200c555:	416a92        	s32i	a9, a10, 0x104
4200c558:	981b      	addi.n	a9, a8, 1
4200c55a:	1699      	s32i.n	a9, a6, 4
4200c55c:	a08860        	addx4	a8, a8, a6
4200c55f:	07a8      	l32i.n	a10, a7, 0
4200c561:	2839      	s32i.n	a3, a8, 8
4200c563:	d1fa81        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200c566:	0008e0        	callx8	a8
4200c569:	020c      	movi.n	a2, 0
4200c56b:	f01d      	retw.n
4200c56d:	000000        	ill

4200c570 <__env_lock>:
4200c570:	004136        	entry	a1, 32
4200c573:	d06fa1        	l32r	a10, 42000730 <_stext+0x710> (3fc94f24 <__lock___atexit_recursive_mutex>)
4200c576:	d1f481        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200c579:	0008e0        	callx8	a8
4200c57c:	f01d      	retw.n
	...

4200c580 <__env_unlock>:
4200c580:	004136        	entry	a1, 32
4200c583:	d06ba1        	l32r	a10, 42000730 <_stext+0x710> (3fc94f24 <__lock___atexit_recursive_mutex>)
4200c586:	d1f181        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200c589:	0008e0        	callx8	a8
4200c58c:	f01d      	retw.n
	...

4200c590 <get_arg$isra$0>:
4200c590:	008136        	entry	a1, 64
4200c593:	102182        	l32i	a8, a1, 64
4200c596:	1179      	s32i.n	a7, a1, 4
4200c598:	0878      	l32i.n	a7, a8, 0
4200c59a:	2129      	s32i.n	a2, a1, 8
4200c59c:	21e8      	l32i.n	a14, a1, 8
4200c59e:	0528      	l32i.n	a2, a5, 0
4200c5a0:	4159      	s32i.n	a5, a1, 16
4200c5a2:	0169      	s32i.n	a6, a1, 0
4200c5a4:	837370        	moveqz	a7, a3, a7
4200c5a7:	00e306        	j	4200c937 <get_arg$isra$0+0x3a7>
4200c5aa:	771b      	addi.n	a7, a7, 1
4200c5ac:	000782        	l8ui	a8, a7, 0
4200c5af:	42f816        	beqz	a8, 4200c9e2 <get_arg$isra$0+0x452>
4200c5b2:	dbc8a2        	addi	a10, a8, -37
4200c5b5:	ff1a56        	bnez	a10, 4200c5aa <get_arg$isra$0+0x1a>
4200c5b8:	426816        	beqz	a8, 4200c9e2 <get_arg$isra$0+0x452>
4200c5bb:	080c      	movi.n	a8, 0
4200c5bd:	a71b      	addi.n	a10, a7, 1
4200c5bf:	050c      	movi.n	a5, 0
4200c5c1:	0d0c      	movi.n	a13, 0
4200c5c3:	f37c      	movi.n	a3, -1
4200c5c5:	060c      	movi.n	a6, 0
4200c5c7:	3189      	s32i.n	a8, a1, 12
4200c5c9:	000046        	j	4200c5ce <get_arg$isra$0+0x3e>
4200c5cc:	07ad      	mov.n	a10, a7
4200c5ce:	d1fe91        	l32r	a9, 42000dc8 <_stext+0xda8> (3c02a19c <__chclass>)
4200c5d1:	000a82        	l8ui	a8, a10, 0
4200c5d4:	7a1b      	addi.n	a7, a10, 1
4200c5d6:	b98a      	add.n	a11, a9, a8
4200c5d8:	3198      	l32i.n	a9, a1, 12
4200c5da:	000bc2        	l8ui	a12, a11, 0
4200c5dd:	d1fbb1        	l32r	a11, 42000dcc <_stext+0xdac> (3c02a130 <__state_table>)
4200c5e0:	b0f990        	addx8	a15, a9, a9
4200c5e3:	bbfa      	add.n	a11, a11, a15
4200c5e5:	bbca      	add.n	a11, a11, a12
4200c5e7:	000b92        	l8ui	a9, a11, 0
4200c5ea:	d1f9b1        	l32r	a11, 42000dd0 <_stext+0xdb0> (3c02a0c4 <__action_table>)
4200c5ed:	3199      	s32i.n	a9, a1, 12
4200c5ef:	bbfa      	add.n	a11, a11, a15
4200c5f1:	bbca      	add.n	a11, a11, a12
4200c5f3:	000bb2        	l8ui	a11, a11, 0
4200c5f6:	bb0b      	addi.n	a11, a11, -1
4200c5f8:	74b0b0        	extui	a11, a11, 0, 8
4200c5fb:	028bb6        	bltui	a11, 8, 4200c601 <get_arg$isra$0+0x71>
4200c5fe:	00cac6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c601:	d1f4c1        	l32r	a12, 42000dd4 <_stext+0xdb4> (3c0298e8 <__on_exit_args+0x4>)
4200c604:	a0bbc0        	addx4	a11, a11, a12
4200c607:	0bb8      	l32i.n	a11, a11, 0
4200c609:	000ba0        	jx	a11
4200c60c:	0c0000        	lsi	f0, a0, 48
4200c60f:	069a      	add.n	a0, a6, a9
4200c611:	ad00c2        	l8ui	a12, a0, 173
4200c614:	ac4607        	ball	a6, a0, 4200c5c4 <get_arg$isra$0+0x34>
4200c617:	a0b200        	addx4	a11, a2, a0
4200c61a:	b76a      	add.n	a11, a7, a6
4200c61c:	3318      	l32i.n	a1, a3, 12
4200c61e:	0a3b87        	bltu	a11, a8, 4200c62c <get_arg$isra$0+0x9c>
4200c621:	cb4c      	movi.n	a11, 76
4200c623:	2618b7        	beq	a8, a11, 4200c64d <get_arg$isra$0+0xbd>
4200c626:	68a0b2        	movi	a11, 104
4200c629:	0005c6        	j	4200c644 <get_arg$isra$0+0xb4>
4200c62c:	71a0b2        	movi	a11, 113
4200c62f:	1f18b7        	beq	a8, a11, 4200c652 <get_arg$isra$0+0xc2>
4200c632:	70a0b2        	movi	a11, 112
4200c635:	23bb87        	bgeu	a11, a8, 4200c65c <get_arg$isra$0+0xcc>
4200c638:	74a0b2        	movi	a11, 116
4200c63b:	0298b7        	bne	a8, a11, 4200c641 <get_arg$isra$0+0xb1>
4200c63e:	00bac6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c641:	7aa0b2        	movi	a11, 122
4200c644:	0298b7        	bne	a8, a11, 4200c64a <get_arg$isra$0+0xba>
4200c647:	00b886        	j	4200c92d <get_arg$isra$0+0x39d>
4200c64a:	000386        	j	4200c65c <get_arg$isra$0+0xcc>
4200c64d:	880c      	movi.n	a8, 8
4200c64f:	000046        	j	4200c654 <get_arg$isra$0+0xc4>
4200c652:	082c      	movi.n	a8, 32
4200c654:	206680        	or	a6, a6, a8
4200c657:	00b486        	j	4200c92d <get_arg$isra$0+0x39d>
4200c65a:	b20000        	mulsh	a0, a0, a0
4200c65d:	010a      	add.n	a0, a1, a0
4200c65f:	6ca082        	movi	a8, 108
4200c662:	0a9b87        	bne	a11, a8, 4200c670 <get_arg$isra$0+0xe0>
4200c665:	082c      	movi.n	a8, 32
4200c667:	206680        	or	a6, a6, a8
4200c66a:	7a2b      	addi.n	a7, a10, 2
4200c66c:	00af46        	j	4200c92d <get_arg$isra$0+0x39d>
4200c66f:	081c00        	lsx	f1, a12, a0
4200c672:	fff786        	j	4200c654 <get_arg$isra$0+0xc4>
4200c675:	61a0b2        	movi	a11, 97
4200c678:	44a020        	extui	a10, a2, 0, 5
4200c67b:	0298b7        	bne	a8, a11, 4200c681 <get_arg$isra$0+0xf1>
4200c67e:	00e506        	j	4200ca16 <get_arg$isra$0+0x486>
4200c681:	3b3b87        	bltu	a11, a8, 4200c6c0 <get_arg$isra$0+0x130>
4200c684:	bfc882        	addi	a8, a8, -65
4200c687:	748080        	extui	a8, a8, 0, 8
4200c68a:	7b1c      	movi.n	a11, 23
4200c68c:	24bb87        	bgeu	a11, a8, 4200c6b4 <get_arg$isra$0+0x124>
4200c68f:	001686        	j	4200c6ed <get_arg$isra$0+0x15d>
4200c692:	180c      	movi.n	a8, 1
4200c694:	401b00        	ssl	a11
4200c697:	a18800        	sll	a8, a8
4200c69a:	d1cfb1        	l32r	a11, 42000dd8 <_stext+0xdb8> (120821 <UserFrameTotalSize+0x120721>)
4200c69d:	3388b7        	bany	a8, a11, 4200c6d4 <get_arg$isra$0+0x144>
4200c6a0:	5b2c      	movi.n	a11, 37
4200c6a2:	11bb60        	slli	a11, a11, 10
4200c6a5:	0208b7        	bnone	a8, a11, 4200c6ab <get_arg$isra$0+0x11b>
4200c6a8:	00dd46        	j	4200ca21 <get_arg$isra$0+0x491>
4200c6ab:	248180        	extui	a8, a8, 1, 3
4200c6ae:	364856        	bnez	a8, 4200ca16 <get_arg$isra$0+0x486>
4200c6b1:	000e06        	j	4200c6ed <get_arg$isra$0+0x15d>
4200c6b4:	d1cab1        	l32r	a11, 42000ddc <_stext+0xdbc> (3c029908 <__on_exit_args+0x24>)
4200c6b7:	a088b0        	addx4	a8, a8, a11
4200c6ba:	0888      	l32i.n	a8, a8, 0
4200c6bc:	0008a0        	jx	a8
4200c6bf:	a0b200        	addx4	a11, a2, a0
4200c6c2:	18b763        	lsi	f6, a7, 96
4200c6c5:	8219      	s32i.n	a1, a2, 32
4200c6c7:	9cc8      	l32i.n	a12, a12, 36
4200c6c9:	74b080        	extui	a11, a8, 0, 8
4200c6cc:	481c      	movi.n	a8, 20
4200c6ce:	c0b8b7        	bgeu	a8, a11, 4200c692 <get_arg$isra$0+0x102>
4200c6d1:	000606        	j	4200c6ed <get_arg$isra$0+0x15d>
4200c6d4:	045560        	extui	a5, a6, 5, 1
4200c6d7:	555a      	add.n	a5, a5, a5
4200c6d9:	106647        	bbci	a6, 4, 4200c6ed <get_arg$isra$0+0x15d>
4200c6dc:	00d806        	j	4200ca40 <get_arg$isra$0+0x4b0>
4200c6df:	051c00        	extui	a1, a0, 28, 1
4200c6e2:	105650        	and	a5, a6, a5
4200c6e5:	34c556        	bnez	a5, 4200ca35 <get_arg$isra$0+0x4a5>
4200c6e8:	00d006        	j	4200ca2c <get_arg$isra$0+0x49c>
4200c6eb:	260000        	lsi	f0, a0, 152
4200c6ee:	880b03        	lsi	f0, a11, 0x220
4200c6f1:	0a2d11        	l32r	a1, 41fcefa8 <_coredump_iram_end+0x1c4cfa8>
4200c6f4:	a08380        	addx4	a8, a3, a8
4200c6f7:	0859      	s32i.n	a5, a8, 0
4200c6f9:	008c06        	j	4200c92d <get_arg$isra$0+0x39d>
4200c6fc:	b50b      	addi.n	a11, a5, -1
4200c6fe:	2488      	l32i.n	a8, a4, 8
4200c700:	2a1b      	addi.n	a2, a10, 1
4200c702:	026bb6        	bltui	a11, 6, 4200c708 <get_arg$isra$0+0x178>
4200c705:	002806        	j	4200c7a9 <get_arg$isra$0+0x219>
4200c708:	d1b6c1        	l32r	a12, 42000de0 <_stext+0xdc0> (3c029968 <__on_exit_args+0x84>)
4200c70b:	a0bbc0        	addx4	a11, a11, a12
4200c70e:	0bc8      	l32i.n	a12, a11, 0
4200c710:	f4b0a0        	extui	a11, a10, 0, 16
4200c713:	000ca0        	jx	a12
4200c716:	0188      	l32i.n	a8, a1, 0
4200c718:	24b8      	l32i.n	a11, a4, 8
4200c71a:	2a1b      	addi.n	a2, a10, 1
4200c71c:	b0aa80        	addx8	a10, a10, a8
4200c71f:	8b4b      	addi.n	a8, a11, 4
4200c721:	2489      	s32i.n	a8, a4, 8
4200c723:	8c1c      	movi.n	a12, 24
4200c725:	042c87        	blt	a12, a8, 4200c72d <get_arg$isra$0+0x19d>
4200c728:	14b8      	l32i.n	a11, a4, 4
4200c72a:	000206        	j	4200c736 <get_arg$isra$0+0x1a6>
4200c72d:	012cb7        	blt	a12, a11, 4200c732 <get_arg$isra$0+0x1a2>
4200c730:	482c      	movi.n	a8, 36
4200c732:	04b8      	l32i.n	a11, a4, 0
4200c734:	2489      	s32i.n	a8, a4, 8
4200c736:	bb8a      	add.n	a11, a11, a8
4200c738:	fccbb2        	addi	a11, a11, -4
4200c73b:	0b88      	l32i.n	a8, a11, 0
4200c73d:	f37c      	movi.n	a3, -1
4200c73f:	0a89      	s32i.n	a8, a10, 0
4200c741:	150c      	movi.n	a5, 1
4200c743:	007986        	j	4200c92d <get_arg$isra$0+0x39d>
4200c746:	8a7c      	movi.n	a10, -8
4200c748:	887b      	addi.n	a8, a8, 7
4200c74a:	1088a0        	and	a8, a8, a10
4200c74d:	0198      	l32i.n	a9, a1, 0
4200c74f:	a88b      	addi.n	a10, a8, 8
4200c751:	24a9      	s32i.n	a10, a4, 8
4200c753:	8c1c      	movi.n	a12, 24
4200c755:	b0bb90        	addx8	a11, a11, a9
4200c758:	042ca7        	blt	a12, a10, 4200c760 <get_arg$isra$0+0x1d0>
4200c75b:	1488      	l32i.n	a8, a4, 4
4200c75d:	000206        	j	4200c769 <get_arg$isra$0+0x1d9>
4200c760:	012c87        	blt	a12, a8, 4200c765 <get_arg$isra$0+0x1d5>
4200c763:	8a2c      	movi.n	a10, 40
4200c765:	0488      	l32i.n	a8, a4, 0
4200c767:	24a9      	s32i.n	a10, a4, 8
4200c769:	88aa      	add.n	a8, a8, a10
4200c76b:	f8c882        	addi	a8, a8, -8
4200c76e:	1898      	l32i.n	a9, a8, 4
4200c770:	0888      	l32i.n	a8, a8, 0
4200c772:	1b99      	s32i.n	a9, a11, 4
4200c774:	0b89      	s32i.n	a8, a11, 0
4200c776:	006cc6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c779:	0188      	l32i.n	a8, a1, 0
4200c77b:	24b8      	l32i.n	a11, a4, 8
4200c77d:	2a1b      	addi.n	a2, a10, 1
4200c77f:	b0aa80        	addx8	a10, a10, a8
4200c782:	8b4b      	addi.n	a8, a11, 4
4200c784:	2489      	s32i.n	a8, a4, 8
4200c786:	8c1c      	movi.n	a12, 24
4200c788:	042c87        	blt	a12, a8, 4200c790 <get_arg$isra$0+0x200>
4200c78b:	14b8      	l32i.n	a11, a4, 4
4200c78d:	000206        	j	4200c799 <get_arg$isra$0+0x209>
4200c790:	012cb7        	blt	a12, a11, 4200c795 <get_arg$isra$0+0x205>
4200c793:	482c      	movi.n	a8, 36
4200c795:	04b8      	l32i.n	a11, a4, 0
4200c797:	2489      	s32i.n	a8, a4, 8
4200c799:	bb8a      	add.n	a11, a11, a8
4200c79b:	fccbb2        	addi	a11, a11, -4
4200c79e:	0b88      	l32i.n	a8, a11, 0
4200c7a0:	f37c      	movi.n	a3, -1
4200c7a2:	0a89      	s32i.n	a8, a10, 0
4200c7a4:	650c      	movi.n	a5, 6
4200c7a6:	0060c6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c7a9:	0188      	l32i.n	a8, a1, 0
4200c7ab:	24b8      	l32i.n	a11, a4, 8
4200c7ad:	2a1b      	addi.n	a2, a10, 1
4200c7af:	b0aa80        	addx8	a10, a10, a8
4200c7b2:	8b4b      	addi.n	a8, a11, 4
4200c7b4:	2489      	s32i.n	a8, a4, 8
4200c7b6:	8c1c      	movi.n	a12, 24
4200c7b8:	042c87        	blt	a12, a8, 4200c7c0 <get_arg$isra$0+0x230>
4200c7bb:	14b8      	l32i.n	a11, a4, 4
4200c7bd:	000206        	j	4200c7c9 <get_arg$isra$0+0x239>
4200c7c0:	012cb7        	blt	a12, a11, 4200c7c5 <get_arg$isra$0+0x235>
4200c7c3:	482c      	movi.n	a8, 36
4200c7c5:	04b8      	l32i.n	a11, a4, 0
4200c7c7:	2489      	s32i.n	a8, a4, 8
4200c7c9:	bb8a      	add.n	a11, a11, a8
4200c7cb:	fccbb2        	addi	a11, a11, -4
4200c7ce:	0b88      	l32i.n	a8, a11, 0
4200c7d0:	f37c      	movi.n	a3, -1
4200c7d2:	0a89      	s32i.n	a8, a10, 0
4200c7d4:	050c      	movi.n	a5, 0
4200c7d6:	0054c6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c7d9:	0188      	l32i.n	a8, a1, 0
4200c7db:	24b8      	l32i.n	a11, a4, 8
4200c7dd:	2a1b      	addi.n	a2, a10, 1
4200c7df:	b0aa80        	addx8	a10, a10, a8
4200c7e2:	8b4b      	addi.n	a8, a11, 4
4200c7e4:	2489      	s32i.n	a8, a4, 8
4200c7e6:	8c1c      	movi.n	a12, 24
4200c7e8:	042c87        	blt	a12, a8, 4200c7f0 <get_arg$isra$0+0x260>
4200c7eb:	14b8      	l32i.n	a11, a4, 4
4200c7ed:	000206        	j	4200c7f9 <get_arg$isra$0+0x269>
4200c7f0:	012cb7        	blt	a12, a11, 4200c7f5 <get_arg$isra$0+0x265>
4200c7f3:	482c      	movi.n	a8, 36
4200c7f5:	04b8      	l32i.n	a11, a4, 0
4200c7f7:	2489      	s32i.n	a8, a4, 8
4200c7f9:	bb8a      	add.n	a11, a11, a8
4200c7fb:	fccbb2        	addi	a11, a11, -4
4200c7fe:	0b88      	l32i.n	a8, a11, 0
4200c800:	f37c      	movi.n	a3, -1
4200c802:	0a89      	s32i.n	a8, a10, 0
4200c804:	350c      	movi.n	a5, 3
4200c806:	0048c6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c809:	0188      	l32i.n	a8, a1, 0
4200c80b:	2a1b      	addi.n	a2, a10, 1
4200c80d:	b0aa80        	addx8	a10, a10, a8
4200c810:	2488      	l32i.n	a8, a4, 8
4200c812:	8b7c      	movi.n	a11, -8
4200c814:	887b      	addi.n	a8, a8, 7
4200c816:	1088b0        	and	a8, a8, a11
4200c819:	b88b      	addi.n	a11, a8, 8
4200c81b:	24b9      	s32i.n	a11, a4, 8
4200c81d:	8c1c      	movi.n	a12, 24
4200c81f:	052cb7        	blt	a12, a11, 4200c828 <get_arg$isra$0+0x298>
4200c822:	1488      	l32i.n	a8, a4, 4
4200c824:	000246        	j	4200c831 <get_arg$isra$0+0x2a1>
4200c827:	2c8700        	lsi	f0, a7, 176
4200c82a:	8b2c01        	l32r	a0, 41fef4dc <_coredump_iram_end+0x1c6d4dc>
4200c82d:	0488      	l32i.n	a8, a4, 0
4200c82f:	24b9      	s32i.n	a11, a4, 8
4200c831:	88ba      	add.n	a8, a8, a11
4200c833:	f8c882        	addi	a8, a8, -8
4200c836:	1898      	l32i.n	a9, a8, 4
4200c838:	0888      	l32i.n	a8, a8, 0
4200c83a:	f37c      	movi.n	a3, -1
4200c83c:	0a89      	s32i.n	a8, a10, 0
4200c83e:	1a99      	s32i.n	a9, a10, 4
4200c840:	450c      	movi.n	a5, 4
4200c842:	0039c6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c845:	8a7c      	movi.n	a10, -8
4200c847:	887b      	addi.n	a8, a8, 7
4200c849:	1088a0        	and	a8, a8, a10
4200c84c:	0198      	l32i.n	a9, a1, 0
4200c84e:	a88b      	addi.n	a10, a8, 8
4200c850:	24a9      	s32i.n	a10, a4, 8
4200c852:	8c1c      	movi.n	a12, 24
4200c854:	b0bb90        	addx8	a11, a11, a9
4200c857:	052ca7        	blt	a12, a10, 4200c860 <get_arg$isra$0+0x2d0>
4200c85a:	1488      	l32i.n	a8, a4, 4
4200c85c:	000246        	j	4200c869 <get_arg$isra$0+0x2d9>
4200c85f:	2c8700        	lsi	f0, a7, 176
4200c862:	8a2c01        	l32r	a0, 41fef114 <_coredump_iram_end+0x1c6d114>
4200c865:	0488      	l32i.n	a8, a4, 0
4200c867:	24a9      	s32i.n	a10, a4, 8
4200c869:	88aa      	add.n	a8, a8, a10
4200c86b:	f8c882        	addi	a8, a8, -8
4200c86e:	1898      	l32i.n	a9, a8, 4
4200c870:	0888      	l32i.n	a8, a8, 0
4200c872:	1b99      	s32i.n	a9, a11, 4
4200c874:	0b89      	s32i.n	a8, a11, 0
4200c876:	002cc6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c879:	1188      	l32i.n	a8, a1, 4
4200c87b:	0888      	l32i.n	a8, a8, 0
4200c87d:	140866        	bnei	a8, -1, 4200c895 <get_arg$isra$0+0x305>
4200c880:	11a8      	l32i.n	a10, a1, 4
4200c882:	80a0c2        	movi	a12, 128
4200c885:	0b0c      	movi.n	a11, 0
4200c887:	61d9      	s32i.n	a13, a1, 24
4200c889:	51e9      	s32i.n	a14, a1, 20
4200c88b:	ce9d81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200c88e:	0008e0        	callx8	a8
4200c891:	61d8      	l32i.n	a13, a1, 24
4200c893:	51e8      	l32i.n	a14, a1, 20
4200c895:	3d0b      	addi.n	a3, a13, -1
4200c897:	53ee30        	max	a14, a14, a3
4200c89a:	0023c6        	j	4200c92d <get_arg$isra$0+0x39d>
4200c89d:	1188      	l32i.n	a8, a1, 4
4200c89f:	0888      	l32i.n	a8, a8, 0
4200c8a1:	140866        	bnei	a8, -1, 4200c8b9 <get_arg$isra$0+0x329>
4200c8a4:	11a8      	l32i.n	a10, a1, 4
4200c8a6:	80a0c2        	movi	a12, 128
4200c8a9:	0b0c      	movi.n	a11, 0
4200c8ab:	61d9      	s32i.n	a13, a1, 24
4200c8ad:	51e9      	s32i.n	a14, a1, 20
4200c8af:	ce9481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200c8b2:	0008e0        	callx8	a8
4200c8b5:	61d8      	l32i.n	a13, a1, 24
4200c8b7:	51e8      	l32i.n	a14, a1, 20
4200c8b9:	1188      	l32i.n	a8, a1, 4
4200c8bb:	dd0b      	addi.n	a13, a13, -1
4200c8bd:	a08d80        	addx4	a8, a13, a8
4200c8c0:	0a0c      	movi.n	a10, 0
4200c8c2:	08a9      	s32i.n	a10, a8, 0
4200c8c4:	53eed0        	max	a14, a14, a13
4200c8c7:	001886        	j	4200c92d <get_arg$isra$0+0x39d>
4200c8ca:	0188      	l32i.n	a8, a1, 0
4200c8cc:	24b8      	l32i.n	a11, a4, 8
4200c8ce:	f21b      	addi.n	a15, a2, 1
4200c8d0:	b02280        	addx8	a2, a2, a8
4200c8d3:	8b4b      	addi.n	a8, a11, 4
4200c8d5:	2489      	s32i.n	a8, a4, 8
4200c8d7:	8c1c      	movi.n	a12, 24
4200c8d9:	042c87        	blt	a12, a8, 4200c8e1 <get_arg$isra$0+0x351>
4200c8dc:	14b8      	l32i.n	a11, a4, 4
4200c8de:	000206        	j	4200c8ea <get_arg$isra$0+0x35a>
4200c8e1:	012cb7        	blt	a12, a11, 4200c8e6 <get_arg$isra$0+0x356>
4200c8e4:	482c      	movi.n	a8, 36
4200c8e6:	04b8      	l32i.n	a11, a4, 0
4200c8e8:	2489      	s32i.n	a8, a4, 8
4200c8ea:	bb8a      	add.n	a11, a11, a8
4200c8ec:	fccbb2        	addi	a11, a11, -4
4200c8ef:	0b88      	l32i.n	a8, a11, 0
4200c8f1:	0a7d      	mov.n	a7, a10
4200c8f3:	0289      	s32i.n	a8, a2, 0
4200c8f5:	0f2d      	mov.n	a2, a15
4200c8f7:	000c86        	j	4200c92d <get_arg$isra$0+0x39d>
4200c8fa:	d20000        	quos	a0, a0, a0
4200c8fd:	d0c8      	l32i.n	a12, a0, 52
4200c8ff:	9a0c      	movi.n	a10, 9
4200c901:	0001c6        	j	4200c90c <get_arg$isra$0+0x37c>
4200c904:	a0ddd0        	addx4	a13, a13, a13
4200c907:	90dd80        	addx2	a13, a13, a8
4200c90a:	771b      	addi.n	a7, a7, 1
4200c90c:	000782        	l8ui	a8, a7, 0
4200c90f:	a89c      	beqz.n	a8, 4200c92d <get_arg$isra$0+0x39d>
4200c911:	d0c882        	addi	a8, a8, -48
4200c914:	ecba87        	bgeu	a10, a8, 4200c904 <get_arg$isra$0+0x374>
4200c917:	000486        	j	4200c92d <get_arg$isra$0+0x39d>
4200c91a:	820000        	mull	a0, a0, a0
4200c91d:	820007        	bnone	a0, a0, 4200c8a3 <get_arg$isra$0+0x313>
4200c920:	d0c8      	l32i.n	a12, a0, 52
4200c922:	748080        	extui	a8, a8, 0, 8
4200c925:	043a87        	bltu	a10, a8, 4200c92d <get_arg$isra$0+0x39d>
4200c928:	771b      	addi.n	a7, a7, 1
4200c92a:	fffb86        	j	4200c91c <get_arg$isra$0+0x38c>
4200c92d:	3198      	l32i.n	a9, a1, 12
4200c92f:	b80c      	movi.n	a8, 11
4200c931:	021987        	beq	a9, a8, 4200c937 <get_arg$isra$0+0x3a7>
4200c934:	ff2506        	j	4200c5cc <get_arg$isra$0+0x3c>
4200c937:	0007a2        	l8ui	a10, a7, 0
4200c93a:	ea8c      	beqz.n	a10, 4200c94c <get_arg$isra$0+0x3bc>
4200c93c:	2188      	l32i.n	a8, a1, 8
4200c93e:	728820        	lsi	f2, a8, 0x1c8
4200c941:	880b      	addi.n	a8, a8, -1
4200c943:	608080        	neg	a8, a8
4200c946:	748080        	extui	a8, a8, 0, 8
4200c949:	c5f856        	bnez	a8, 4200c5ac <get_arg$isra$0+0x1c>
4200c94c:	2188      	l32i.n	a8, a1, 8
4200c94e:	93e8a0        	movnez	a14, a8, a10
4200c951:	002346        	j	4200c9e2 <get_arg$isra$0+0x452>
4200c954:	1188      	l32i.n	a8, a1, 4
4200c956:	a08d80        	addx4	a8, a13, a8
4200c959:	08c8      	l32i.n	a12, a8, 0
4200c95b:	dd1b      	addi.n	a13, a13, 1
4200c95d:	cc0b      	addi.n	a12, a12, -1
4200c95f:	2488      	l32i.n	a8, a4, 8
4200c961:	5c6cf6        	bgeui	a12, 6, 4200c9c1 <get_arg$isra$0+0x431>
4200c964:	a0cc60        	addx4	a12, a12, a6
4200c967:	0cc8      	l32i.n	a12, a12, 0
4200c969:	000ca0        	jx	a12
4200c96c:	887b      	addi.n	a8, a8, 7
4200c96e:	1088f0        	and	a8, a8, a15
4200c971:	c88b      	addi.n	a12, a8, 8
4200c973:	24c9      	s32i.n	a12, a4, 8
4200c975:	042ac7        	blt	a10, a12, 4200c97d <get_arg$isra$0+0x3ed>
4200c978:	1488      	l32i.n	a8, a4, 4
4200c97a:	000206        	j	4200c986 <get_arg$isra$0+0x3f6>
4200c97d:	012a87        	blt	a10, a8, 4200c982 <get_arg$isra$0+0x3f2>
4200c980:	8c2c      	movi.n	a12, 40
4200c982:	0488      	l32i.n	a8, a4, 0
4200c984:	24c9      	s32i.n	a12, a4, 8
4200c986:	88ca      	add.n	a8, a8, a12
4200c988:	f8c882        	addi	a8, a8, -8
4200c98b:	1898      	l32i.n	a9, a8, 4
4200c98d:	0888      	l32i.n	a8, a8, 0
4200c98f:	1b99      	s32i.n	a9, a11, 4
4200c991:	0b89      	s32i.n	a8, a11, 0
4200c993:	001706        	j	4200c9f3 <get_arg$isra$0+0x463>
4200c996:	887b      	addi.n	a8, a8, 7
4200c998:	1088f0        	and	a8, a8, a15
4200c99b:	c88b      	addi.n	a12, a8, 8
4200c99d:	24c9      	s32i.n	a12, a4, 8
4200c99f:	052ac7        	blt	a10, a12, 4200c9a8 <get_arg$isra$0+0x418>
4200c9a2:	1488      	l32i.n	a8, a4, 4
4200c9a4:	000246        	j	4200c9b1 <get_arg$isra$0+0x421>
4200c9a7:	2a8700        	mul.s	f8, f7, f0
4200c9aa:	8c2c01        	l32r	a0, 41fefa5c <_coredump_iram_end+0x1c6da5c>
4200c9ad:	0488      	l32i.n	a8, a4, 0
4200c9af:	24c9      	s32i.n	a12, a4, 8
4200c9b1:	88ca      	add.n	a8, a8, a12
4200c9b3:	f8c882        	addi	a8, a8, -8
4200c9b6:	1898      	l32i.n	a9, a8, 4
4200c9b8:	0888      	l32i.n	a8, a8, 0
4200c9ba:	1b99      	s32i.n	a9, a11, 4
4200c9bc:	0b89      	s32i.n	a8, a11, 0
4200c9be:	000c46        	j	4200c9f3 <get_arg$isra$0+0x463>
4200c9c1:	c84b      	addi.n	a12, a8, 4
4200c9c3:	24c9      	s32i.n	a12, a4, 8
4200c9c5:	042ac7        	blt	a10, a12, 4200c9cd <get_arg$isra$0+0x43d>
4200c9c8:	1488      	l32i.n	a8, a4, 4
4200c9ca:	000206        	j	4200c9d6 <get_arg$isra$0+0x446>
4200c9cd:	012a87        	blt	a10, a8, 4200c9d2 <get_arg$isra$0+0x442>
4200c9d0:	4c2c      	movi.n	a12, 36
4200c9d2:	0488      	l32i.n	a8, a4, 0
4200c9d4:	24c9      	s32i.n	a12, a4, 8
4200c9d6:	88ca      	add.n	a8, a8, a12
4200c9d8:	fcc882        	addi	a8, a8, -4
4200c9db:	0888      	l32i.n	a8, a8, 0
4200c9dd:	0b89      	s32i.n	a8, a11, 0
4200c9df:	000406        	j	4200c9f3 <get_arg$isra$0+0x463>
4200c9e2:	0188      	l32i.n	a8, a1, 0
4200c9e4:	d10061        	l32r	a6, 42000de4 <_stext+0xdc4> (3c029980 <__on_exit_args+0x9c>)
4200c9e7:	b0b280        	addx8	a11, a2, a8
4200c9ea:	02dd      	mov.n	a13, a2
4200c9ec:	8a1c      	movi.n	a10, 24
4200c9ee:	8f7c      	movi.n	a15, -8
4200c9f0:	000046        	j	4200c9f5 <get_arg$isra$0+0x465>
4200c9f3:	bb8b      	addi.n	a11, a11, 8
4200c9f5:	022ed7        	blt	a14, a13, 4200c9fb <get_arg$isra$0+0x46b>
4200c9f8:	ffd606        	j	4200c954 <get_arg$isra$0+0x3c4>
4200c9fb:	8e1b      	addi.n	a8, a14, 1
4200c9fd:	728820        	lsi	f2, a8, 0x1c8
4200ca00:	880b      	addi.n	a8, a8, -1
4200ca02:	608080        	neg	a8, a8
4200ca05:	748080        	extui	a8, a8, 0, 8
4200ca08:	0a0c      	movi.n	a10, 0
4200ca0a:	d8bc      	beqz.n	a8, 4200ca4b <get_arg$isra$0+0x4bb>
4200ca0c:	820b      	addi.n	a8, a2, -1
4200ca0e:	608080        	neg	a8, a8
4200ca11:	a8ea      	add.n	a10, a8, a14
4200ca13:	000d06        	j	4200ca4b <get_arg$isra$0+0x4bb>
4200ca16:	450c      	movi.n	a5, 4
4200ca18:	020326        	beqi	a3, -1, 4200ca1e <get_arg$isra$0+0x48e>
4200ca1b:	ff3446        	j	4200c6f0 <get_arg$isra$0+0x160>
4200ca1e:	ff79c6        	j	4200c809 <get_arg$isra$0+0x279>
4200ca21:	350c      	movi.n	a5, 3
4200ca23:	020326        	beqi	a3, -1, 4200ca29 <get_arg$isra$0+0x499>
4200ca26:	ff3186        	j	4200c6f0 <get_arg$isra$0+0x160>
4200ca29:	ff6b06        	j	4200c7d9 <get_arg$isra$0+0x249>
4200ca2c:	020326        	beqi	a3, -1, 4200ca32 <get_arg$isra$0+0x4a2>
4200ca2f:	ff2f46        	j	4200c6f0 <get_arg$isra$0+0x160>
4200ca32:	ff5cc6        	j	4200c7a9 <get_arg$isra$0+0x219>
4200ca35:	650c      	movi.n	a5, 6
4200ca37:	020326        	beqi	a3, -1, 4200ca3d <get_arg$isra$0+0x4ad>
4200ca3a:	ff2c86        	j	4200c6f0 <get_arg$isra$0+0x160>
4200ca3d:	ff4e06        	j	4200c779 <get_arg$isra$0+0x1e9>
4200ca40:	150c      	movi.n	a5, 1
4200ca42:	020326        	beqi	a3, -1, 4200ca48 <get_arg$isra$0+0x4b8>
4200ca45:	ff29c6        	j	4200c6f0 <get_arg$isra$0+0x160>
4200ca48:	ff3286        	j	4200c716 <get_arg$isra$0+0x186>
4200ca4b:	4198      	l32i.n	a9, a1, 16
4200ca4d:	8a2a      	add.n	a8, a10, a2
4200ca4f:	0989      	s32i.n	a8, a9, 0
4200ca51:	102182        	l32i	a8, a1, 64
4200ca54:	0198      	l32i.n	a9, a1, 0
4200ca56:	0879      	s32i.n	a7, a8, 0
4200ca58:	2188      	l32i.n	a8, a1, 8
4200ca5a:	b02890        	addx8	a2, a8, a9
4200ca5d:	f01d      	retw.n
	...

4200ca60 <_vfprintf_r>:
4200ca60:	064136        	entry	a1, 0x320
4200ca63:	9f6142        	s32i	a4, a1, 0x27c
4200ca66:	02ad      	mov.n	a10, a2
4200ca68:	9c6152        	s32i	a5, a1, 0x270
4200ca6b:	9d6162        	s32i	a6, a1, 0x274
4200ca6e:	9e6172        	s32i	a7, a1, 0x278
4200ca71:	a16122        	s32i	a2, a1, 0x284
4200ca74:	a06132        	s32i	a3, a1, 0x280
4200ca77:	201110        	or	a1, a1, a1
4200ca7a:	050f25        	call8	42011b6c <_localeconv_r>
4200ca7d:	0a88      	l32i.n	a8, a10, 0
4200ca7f:	10c142        	addi	a4, a1, 16
4200ca82:	08ad      	mov.n	a10, a8
4200ca84:	b16182        	s32i	a8, a1, 0x2c4
4200ca87:	ce0581        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200ca8a:	0008e0        	callx8	a8
4200ca8d:	a12182        	l32i	a8, a1, 0x284
4200ca90:	ad61a2        	s32i	a10, a1, 0x2b4
4200ca93:	00d816        	beqz	a8, 4200caa4 <_vfprintf_r+0x44>
4200ca96:	0a2882        	l32i	a8, a8, 40
4200ca99:	78cc      	bnez.n	a8, 4200caa4 <_vfprintf_r+0x44>
4200ca9b:	a121a2        	l32i	a10, a1, 0x284
4200ca9e:	201110        	or	a1, a1, a1
4200caa1:	fef125        	call8	4200b9b4 <__sinit>
4200caa4:	a02182        	l32i	a8, a1, 0x280
4200caa7:	192882        	l32i	a8, a8, 100
4200caaa:	14e807        	bbsi	a8, 0, 4200cac2 <_vfprintf_r+0x62>
4200caad:	a02182        	l32i	a8, a1, 0x280
4200cab0:	061882        	l16ui	a8, a8, 12
4200cab3:	0be897        	bbsi	a8, 9, 4200cac2 <_vfprintf_r+0x62>
4200cab6:	a02182        	l32i	a8, a1, 0x280
4200cab9:	1628a2        	l32i	a10, a8, 88
4200cabc:	d0a381        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200cabf:	0008e0        	callx8	a8
4200cac2:	a02182        	l32i	a8, a1, 0x280
4200cac5:	061882        	l16ui	a8, a8, 12
4200cac8:	066837        	bbci	a8, 3, 4200cad2 <_vfprintf_r+0x72>
4200cacb:	a02182        	l32i	a8, a1, 0x280
4200cace:	4888      	l32i.n	a8, a8, 16
4200cad0:	58fc      	bnez.n	a8, 4200cb09 <_vfprintf_r+0xa9>
4200cad2:	a021b2        	l32i	a11, a1, 0x280
4200cad5:	a121a2        	l32i	a10, a1, 0x284
4200cad8:	201110        	or	a1, a1, a1
4200cadb:	ff4c65        	call8	4200bfa0 <__swsetup_r>
4200cade:	7aac      	beqz.n	a10, 4200cb09 <_vfprintf_r+0xa9>
4200cae0:	a02182        	l32i	a8, a1, 0x280
4200cae3:	192882        	l32i	a8, a8, 100
4200cae6:	076807        	bbci	a8, 0, 4200caf1 <_vfprintf_r+0x91>
4200cae9:	f87c      	movi.n	a8, -1
4200caeb:	ae6182        	s32i	a8, a1, 0x2b8
4200caee:	0ae586        	j	4200f688 <_vfprintf_r+0x2c28>
4200caf1:	a02182        	l32i	a8, a1, 0x280
4200caf4:	061882        	l16ui	a8, a8, 12
4200caf7:	eee897        	bbsi	a8, 9, 4200cae9 <_vfprintf_r+0x89>
4200cafa:	a02182        	l32i	a8, a1, 0x280
4200cafd:	1628a2        	l32i	a10, a8, 88
4200cb00:	d09381        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200cb03:	0008e0        	callx8	a8
4200cb06:	fff7c6        	j	4200cae9 <_vfprintf_r+0x89>
4200cb09:	a02182        	l32i	a8, a1, 0x280
4200cb0c:	069892        	l16si	a9, a8, 12
4200cb0f:	1aa082        	movi	a8, 26
4200cb12:	108980        	and	a8, a9, a8
4200cb15:	439866        	bnei	a8, 10, 4200cb5c <_vfprintf_r+0xfc>
4200cb18:	a02182        	l32i	a8, a1, 0x280
4200cb1b:	079882        	l16si	a8, a8, 14
4200cb1e:	03a896        	bltz	a8, 4200cb5c <_vfprintf_r+0xfc>
4200cb21:	a02182        	l32i	a8, a1, 0x280
4200cb24:	192882        	l32i	a8, a8, 100
4200cb27:	0ee807        	bbsi	a8, 0, 4200cb39 <_vfprintf_r+0xd9>
4200cb2a:	0be997        	bbsi	a9, 9, 4200cb39 <_vfprintf_r+0xd9>
4200cb2d:	a02182        	l32i	a8, a1, 0x280
4200cb30:	1628a2        	l32i	a10, a8, 88
4200cb33:	d08681        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200cb36:	0008e0        	callx8	a8
4200cb39:	9824d2        	l32i	a13, a4, 0x260
4200cb3c:	9924e2        	l32i	a14, a4, 0x264
4200cb3f:	9a24f2        	l32i	a15, a4, 0x268
4200cb42:	9f21c2        	l32i	a12, a1, 0x27c
4200cb45:	a021b2        	l32i	a11, a1, 0x280
4200cb48:	a121a2        	l32i	a10, a1, 0x284
4200cb4b:	02d442        	addmi	a4, a4, 0x200
4200cb4e:	201110        	or	a1, a1, a1
4200cb51:	02b625        	call8	4200f6b4 <__sbprintf>
4200cb54:	ae61a2        	s32i	a10, a1, 0x2b8
4200cb57:	0acb46        	j	4200f688 <_vfprintf_r+0x2c28>
4200cb5a:	820000        	mull	a0, a0, a0
4200cb5d:	8ae4a1        	l32r	a10, 41fef6f0 <_coredump_iram_end+0x1c6d6f0>
4200cb60:	090c84        	lsi	f8, a12, 36
4200cb63:	896482        	s32i	a8, a4, 0x224
4200cb66:	082d      	mov.n	a2, a8
4200cb68:	080c      	movi.n	a8, 0
4200cb6a:	fa7c      	movi.n	a10, -1
4200cb6c:	8b6492        	s32i	a9, a4, 0x22c
4200cb6f:	8a6492        	s32i	a9, a4, 0x228
4200cb72:	966192        	s32i	a9, a1, 0x258
4200cb75:	976192        	s32i	a9, a1, 0x25c
4200cb78:	a46192        	s32i	a9, a1, 0x290
4200cb7b:	b86182        	s32i	a8, a1, 0x2e0
4200cb7e:	b76182        	s32i	a8, a1, 0x2dc
4200cb81:	aa6182        	s32i	a8, a1, 0x2a8
4200cb84:	b06182        	s32i	a8, a1, 0x2c0
4200cb87:	b66182        	s32i	a8, a1, 0x2d8
4200cb8a:	ae6182        	s32i	a8, a1, 0x2b8
4200cb8d:	10c192        	addi	a9, a1, 16
4200cb90:	e4a182        	movi	a8, 0x1e4
4200cb93:	4064a2        	s32i	a10, a4, 0x100
4200cb96:	0b0c      	movi.n	a11, 0
4200cb98:	0a0c      	movi.n	a10, 0
4200cb9a:	898a      	add.n	a8, a9, a8
4200cb9c:	a661a2        	s32i	a10, a1, 0x298
4200cb9f:	a761b2        	s32i	a11, a1, 0x29c
4200cba2:	070c      	movi.n	a7, 0
4200cba4:	bb6182        	s32i	a8, a1, 0x2ec
4200cba7:	000346        	j	4200cbb8 <_vfprintf_r+0x158>
4200cbaa:	e4a182        	movi	a8, 0x1e4
4200cbad:	10c192        	addi	a9, a1, 16
4200cbb0:	298a      	add.n	a2, a9, a8
4200cbb2:	a82182        	l32i	a8, a1, 0x2a0
4200cbb5:	9f6182        	s32i	a8, a1, 0x27c
4200cbb8:	9f2152        	l32i	a5, a1, 0x27c
4200cbbb:	000046        	j	4200cbc0 <_vfprintf_r+0x160>
4200cbbe:	551b      	addi.n	a5, a5, 1
4200cbc0:	000582        	l8ui	a8, a5, 0
4200cbc3:	005816        	beqz	a8, 4200cbcc <_vfprintf_r+0x16c>
4200cbc6:	dbc882        	addi	a8, a8, -37
4200cbc9:	ff1856        	bnez	a8, 4200cbbe <_vfprintf_r+0x15e>
4200cbcc:	9f2182        	l32i	a8, a1, 0x27c
4200cbcf:	c06580        	sub	a6, a5, a8
4200cbd2:	044616        	beqz	a6, 4200cc1a <_vfprintf_r+0x1ba>
4200cbd5:	0289      	s32i.n	a8, a2, 0
4200cbd7:	10c182        	addi	a8, a1, 16
4200cbda:	02d892        	addmi	a9, a8, 0x200
4200cbdd:	8f2182        	l32i	a8, a1, 0x23c
4200cbe0:	1269      	s32i.n	a6, a2, 4
4200cbe2:	886a      	add.n	a8, a8, a6
4200cbe4:	b989      	s32i.n	a8, a9, 44
4200cbe6:	a988      	l32i.n	a8, a9, 40
4200cbe8:	228b      	addi.n	a2, a2, 8
4200cbea:	881b      	addi.n	a8, a8, 1
4200cbec:	a989      	s32i.n	a8, a9, 40
4200cbee:	2088a6        	blti	a8, 8, 4200cc12 <_vfprintf_r+0x1b2>
4200cbf1:	24a2c2        	movi	a12, 0x224
4200cbf4:	10c182        	addi	a8, a1, 16
4200cbf7:	a021b2        	l32i	a11, a1, 0x280
4200cbfa:	a121a2        	l32i	a10, a1, 0x284
4200cbfd:	c8ca      	add.n	a12, a8, a12
4200cbff:	201110        	or	a1, a1, a1
4200cc02:	030165        	call8	4200fc18 <__sprint_r>
4200cc05:	1a8c      	beqz.n	a10, 4200cc0a <_vfprintf_r+0x1aa>
4200cc07:	0a9046        	j	4200f64c <_vfprintf_r+0x2bec>
4200cc0a:	e4a182        	movi	a8, 0x1e4
4200cc0d:	10c192        	addi	a9, a1, 16
4200cc10:	298a      	add.n	a2, a9, a8
4200cc12:	ae2182        	l32i	a8, a1, 0x2b8
4200cc15:	886a      	add.n	a8, a8, a6
4200cc17:	ae6182        	s32i	a8, a1, 0x2b8
4200cc1a:	000582        	l8ui	a8, a5, 0
4200cc1d:	18cc      	bnez.n	a8, 4200cc22 <_vfprintf_r+0x1c2>
4200cc1f:	0a7b46        	j	4200f610 <_vfprintf_r+0x2bb0>
4200cc22:	10c192        	addi	a9, a1, 16
4200cc25:	02d992        	addmi	a9, a9, 0x200
4200cc28:	0a0c      	movi.n	a10, 0
4200cc2a:	5249a2        	s8i	a10, a9, 82
4200cc2d:	f97c      	movi.n	a9, -1
4200cc2f:	a26192        	s32i	a9, a1, 0x288
4200cc32:	090c      	movi.n	a9, 0
4200cc34:	851b      	addi.n	a8, a5, 1
4200cc36:	076d      	mov.n	a6, a7
4200cc38:	ac6192        	s32i	a9, a1, 0x2b0
4200cc3b:	040c      	movi.n	a4, 0
4200cc3d:	030c      	movi.n	a3, 0
4200cc3f:	000286        	j	4200cc4d <_vfprintf_r+0x1ed>
4200cc42:	000000        	ill
4200cc45:	a86192        	s32i	a9, a1, 0x2a0
4200cc48:	040c      	movi.n	a4, 0
4200cc4a:	a82182        	l32i	a8, a1, 0x2a0
4200cc4d:	981b      	addi.n	a9, a8, 1
4200cc4f:	000882        	l8ui	a8, a8, 0
4200cc52:	a86192        	s32i	a9, a1, 0x2a0
4200cc55:	a36182        	s32i	a8, a1, 0x28c
4200cc58:	aa5c      	movi.n	a10, 90
4200cc5a:	000086        	j	4200cc60 <_vfprintf_r+0x200>
4200cc5d:	ac6182        	s32i	a8, a1, 0x2b0
4200cc60:	a32182        	l32i	a8, a1, 0x28c
4200cc63:	e0c882        	addi	a8, a8, -32
4200cc66:	02ba87        	bgeu	a10, a8, 4200cc6c <_vfprintf_r+0x20c>
4200cc69:	07a8c6        	j	4200eb10 <_vfprintf_r+0x20b0>
4200cc6c:	d06591        	l32r	a9, 42000e00 <_stext+0xde0> (3c029998 <__on_exit_args+0xb4>)
4200cc6f:	a08890        	addx4	a8, a8, a9
4200cc72:	0888      	l32i.n	a8, a8, 0
4200cc74:	0008a0        	jx	a8
4200cc77:	d06081        	l32r	a8, 42000df8 <_stext+0xdd8> (3c0295c4 <_ZTISt12out_of_range+0x138>)
4200cc7a:	066846        	j	4200e61f <_vfprintf_r+0x1bbf>
4200cc7d:	a121a2        	l32i	a10, a1, 0x284
4200cc80:	201110        	or	a1, a1, a1
4200cc83:	04eea5        	call8	42011b6c <_localeconv_r>
4200cc86:	1a88      	l32i.n	a8, a10, 4
4200cc88:	20a880        	or	a10, a8, a8
4200cc8b:	b66182        	s32i	a8, a1, 0x2d8
4200cc8e:	cd8381        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200cc91:	0008e0        	callx8	a8
4200cc94:	b061a2        	s32i	a10, a1, 0x2c0
4200cc97:	a121a2        	l32i	a10, a1, 0x284
4200cc9a:	201110        	or	a1, a1, a1
4200cc9d:	04ece5        	call8	42011b6c <_localeconv_r>
4200cca0:	2a88      	l32i.n	a8, a10, 8
4200cca2:	aa6182        	s32i	a8, a1, 0x2a8
4200cca5:	b02182        	l32i	a8, a1, 0x2c0
4200cca8:	f9e816        	beqz	a8, 4200cc4a <_vfprintf_r+0x1ea>
4200ccab:	aa2182        	l32i	a8, a1, 0x2a8
4200ccae:	f98816        	beqz	a8, 4200cc4a <_vfprintf_r+0x1ea>
4200ccb1:	000882        	l8ui	a8, a8, 0
4200ccb4:	f92816        	beqz	a8, 4200cc4a <_vfprintf_r+0x1ea>
4200ccb7:	00a482        	movi	a8, 0x400
4200ccba:	00c946        	j	4200cfe3 <_vfprintf_r+0x583>
4200ccbd:	10c182        	addi	a8, a1, 16
4200ccc0:	02d882        	addmi	a8, a8, 0x200
4200ccc3:	520892        	l8ui	a9, a8, 82
4200ccc6:	f80956        	bnez	a9, 4200cc4a <_vfprintf_r+0x1ea>
4200ccc9:	092c      	movi.n	a9, 32
4200cccb:	004ac6        	j	4200cdfa <_vfprintf_r+0x39a>
4200ccce:	180c      	movi.n	a8, 1
4200ccd0:	00c3c6        	j	4200cfe3 <_vfprintf_r+0x583>
4200ccd3:	a82182        	l32i	a8, a1, 0x2a0
4200ccd6:	9a0c      	movi.n	a10, 9
4200ccd8:	000882        	l8ui	a8, a8, 0
4200ccdb:	d0c892        	addi	a9, a8, -48
4200ccde:	463a97        	bltu	a10, a9, 4200cd28 <_vfprintf_r+0x2c8>
4200cce1:	a82192        	l32i	a9, a1, 0x2a0
4200cce4:	0a0c      	movi.n	a10, 0
4200cce6:	991b      	addi.n	a9, a9, 1
4200cce8:	a36192        	s32i	a9, a1, 0x28c
4200cceb:	9b0c      	movi.n	a11, 9
4200cced:	d0c882        	addi	a8, a8, -48
4200ccf0:	a0aaa0        	addx4	a10, a10, a10
4200ccf3:	90aa80        	addx2	a10, a10, a8
4200ccf6:	a32182        	l32i	a8, a1, 0x28c
4200ccf9:	a32192        	l32i	a9, a1, 0x28c
4200ccfc:	000882        	l8ui	a8, a8, 0
4200ccff:	991b      	addi.n	a9, a9, 1
4200cd01:	a36192        	s32i	a9, a1, 0x28c
4200cd04:	d0c892        	addi	a9, a8, -48
4200cd07:	e2bb97        	bgeu	a11, a9, 4200cced <_vfprintf_r+0x28d>
4200cd0a:	492c      	movi.n	a9, 36
4200cd0c:	021897        	beq	a8, a9, 4200cd12 <_vfprintf_r+0x2b2>
4200cd0f:	ffcd46        	j	4200cc48 <_vfprintf_r+0x1e8>
4200cd12:	082c      	movi.n	a8, 32
4200cd14:	02a8a7        	bge	a8, a10, 4200cd1a <_vfprintf_r+0x2ba>
4200cd17:	0a4c46        	j	4200f64c <_vfprintf_r+0x2bec>
4200cd1a:	972182        	l32i	a8, a1, 0x25c
4200cd1d:	aa0b      	addi.n	a10, a10, -1
4200cd1f:	10c1e2        	addi	a14, a1, 16
4200cd22:	122a87        	blt	a10, a8, 4200cd38 <_vfprintf_r+0x2d8>
4200cd25:	0005c6        	j	4200cd40 <_vfprintf_r+0x2e0>
4200cd28:	9721b2        	l32i	a11, a1, 0x25c
4200cd2b:	a71b      	addi.n	a10, a7, 1
4200cd2d:	10c192        	addi	a9, a1, 16
4200cd30:	3527b7        	blt	a7, a11, 4200cd69 <_vfprintf_r+0x309>
4200cd33:	000e06        	j	4200cd6f <_vfprintf_r+0x30f>
4200cd36:	e00000        	subx4	a0, a0, a0
4200cd39:	b0ea      	add.n	a11, a0, a14
4200cd3b:	0e88      	l32i.n	a8, a14, 0
4200cd3d:	000686        	j	4200cd5b <_vfprintf_r+0x2fb>
4200cd40:	48a282        	movi	a8, 0x248
4200cd43:	8e8a      	add.n	a8, a14, a8
4200cd45:	4ca2d2        	movi	a13, 0x24c
4200cd48:	60a2c2        	movi	a12, 0x260
4200cd4b:	0189      	s32i.n	a8, a1, 0
4200cd4d:	01def2        	addmi	a15, a14, 0x100
4200cd50:	deda      	add.n	a13, a14, a13
4200cd52:	ceca      	add.n	a12, a14, a12
4200cd54:	05bd      	mov.n	a11, a5
4200cd56:	ff83a5        	call8	4200c590 <get_arg$isra$0>
4200cd59:	0a88      	l32i.n	a8, a10, 0
4200cd5b:	ac6182        	s32i	a8, a1, 0x2b0
4200cd5e:	a32182        	l32i	a8, a1, 0x28c
4200cd61:	07ad      	mov.n	a10, a7
4200cd63:	a86182        	s32i	a8, a1, 0x2a0
4200cd66:	001d46        	j	4200cddf <_vfprintf_r+0x37f>
4200cd69:	b09690        	addx8	a9, a6, a9
4200cd6c:	001a86        	j	4200cdda <_vfprintf_r+0x37a>
4200cd6f:	9a29c2        	l32i	a12, a9, 0x268
4200cd72:	fd1c      	movi.n	a13, 31
4200cd74:	02d992        	addmi	a9, a9, 0x200
4200cd77:	8c4b      	addi.n	a8, a12, 4
4200cd79:	372db7        	blt	a13, a11, 4200cdb4 <_vfprintf_r+0x354>
4200cd7c:	db1b      	addi.n	a13, a11, 1
4200cd7e:	9761d2        	s32i	a13, a1, 0x25c
4200cd81:	1a6982        	s32i	a8, a9, 104
4200cd84:	8d1c      	movi.n	a13, 24
4200cd86:	062d87        	blt	a13, a8, 4200cd90 <_vfprintf_r+0x330>
4200cd89:	192992        	l32i	a9, a9, 100
4200cd8c:	000446        	j	4200cda1 <_vfprintf_r+0x341>
4200cd8f:	2dc700        	lsi	f0, a7, 180
4200cd92:	482c01        	l32r	a0, 41fdee44 <_coredump_iram_end+0x1c5ce44>
4200cd95:	10c192        	addi	a9, a1, 16
4200cd98:	02d992        	addmi	a9, a9, 0x200
4200cd9b:	182992        	l32i	a9, a9, 96
4200cd9e:	9e6182        	s32i	a8, a1, 0x278
4200cda1:	998a      	add.n	a9, a9, a8
4200cda3:	fcc992        	addi	a9, a9, -4
4200cda6:	0988      	l32i.n	a8, a9, 0
4200cda8:	b0bb10        	addx8	a11, a11, a1
4200cdab:	ac6182        	s32i	a8, a1, 0x2b0
4200cdae:	4b89      	s32i.n	a8, a11, 16
4200cdb0:	000ac6        	j	4200cddf <_vfprintf_r+0x37f>
4200cdb3:	698200        	lsi	f0, a2, 0x1a4
4200cdb6:	1c1a      	add.n	a1, a12, a1
4200cdb8:	878b      	addi.n	a8, a7, 8
4200cdba:	072b      	addi.n	a0, a7, 2
4200cdbc:	192992        	l32i	a9, a9, 100
4200cdbf:	000486        	j	4200cdd5 <_vfprintf_r+0x375>
4200cdc2:	c70000        	lsi	f0, a0, 0x31c
4200cdc5:	012b      	addi.n	a0, a1, 2
4200cdc7:	482c      	movi.n	a8, 36
4200cdc9:	10c192        	addi	a9, a1, 16
4200cdcc:	02d992        	addmi	a9, a9, 0x200
4200cdcf:	182992        	l32i	a9, a9, 96
4200cdd2:	9e6182        	s32i	a8, a1, 0x278
4200cdd5:	998a      	add.n	a9, a9, a8
4200cdd7:	fcc992        	addi	a9, a9, -4
4200cdda:	0988      	l32i.n	a8, a9, 0
4200cddc:	ac6182        	s32i	a8, a1, 0x2b0
4200cddf:	ac2182        	l32i	a8, a1, 0x2b0
4200cde2:	0a7d      	mov.n	a7, a10
4200cde4:	e628d6        	bgez	a8, 4200cc4a <_vfprintf_r+0x1ea>
4200cde7:	608080        	neg	a8, a8
4200cdea:	ac6182        	s32i	a8, a1, 0x2b0
4200cded:	480c      	movi.n	a8, 4
4200cdef:	007c06        	j	4200cfe3 <_vfprintf_r+0x583>
4200cdf2:	10c182        	addi	a8, a1, 16
4200cdf5:	02d882        	addmi	a8, a8, 0x200
4200cdf8:	b92c      	movi.n	a9, 43
4200cdfa:	524892        	s8i	a9, a8, 82
4200cdfd:	ff9246        	j	4200cc4a <_vfprintf_r+0x1ea>
4200ce00:	a82182        	l32i	a8, a1, 0x2a0
4200ce03:	981b      	addi.n	a9, a8, 1
4200ce05:	000882        	l8ui	a8, a8, 0
4200ce08:	a36182        	s32i	a8, a1, 0x28c
4200ce0b:	a321b2        	l32i	a11, a1, 0x28c
4200ce0e:	a82c      	movi.n	a8, 42
4200ce10:	081b87        	beq	a11, a8, 4200ce1c <_vfprintf_r+0x3bc>
4200ce13:	080c      	movi.n	a8, 0
4200ce15:	9c0c      	movi.n	a12, 9
4200ce17:	0047c6        	j	4200cf3a <_vfprintf_r+0x4da>
4200ce1a:	820000        	mull	a0, a0, a0
4200ce1d:	0ca821        	l32r	a2, 41fd00c0 <_coredump_iram_end+0x1c4e0c0>
4200ce20:	829b      	addi.n	a8, a2, 9
4200ce22:	0108      	l32i.n	a0, a1, 0
4200ce24:	d0c8a2        	addi	a10, a8, -48
4200ce27:	453ba7        	bltu	a11, a10, 4200ce70 <_vfprintf_r+0x410>
4200ce2a:	a821a2        	l32i	a10, a1, 0x2a0
4200ce2d:	aa2b      	addi.n	a10, a10, 2
4200ce2f:	a361a2        	s32i	a10, a1, 0x28c
4200ce32:	0a0c      	movi.n	a10, 0
4200ce34:	d0c882        	addi	a8, a8, -48
4200ce37:	a0aaa0        	addx4	a10, a10, a10
4200ce3a:	90aa80        	addx2	a10, a10, a8
4200ce3d:	a32182        	l32i	a8, a1, 0x28c
4200ce40:	a321c2        	l32i	a12, a1, 0x28c
4200ce43:	000882        	l8ui	a8, a8, 0
4200ce46:	cc1b      	addi.n	a12, a12, 1
4200ce48:	a361c2        	s32i	a12, a1, 0x28c
4200ce4b:	d0c8c2        	addi	a12, a8, -48
4200ce4e:	e2bbc7        	bgeu	a11, a12, 4200ce34 <_vfprintf_r+0x3d4>
4200ce51:	4b2c      	movi.n	a11, 36
4200ce53:	0218b7        	beq	a8, a11, 4200ce59 <_vfprintf_r+0x3f9>
4200ce56:	ff7ac6        	j	4200cc45 <_vfprintf_r+0x1e5>
4200ce59:	082c      	movi.n	a8, 32
4200ce5b:	02a8a7        	bge	a8, a10, 4200ce61 <_vfprintf_r+0x401>
4200ce5e:	09fa86        	j	4200f64c <_vfprintf_r+0x2bec>
4200ce61:	972182        	l32i	a8, a1, 0x25c
4200ce64:	aa0b      	addi.n	a10, a10, -1
4200ce66:	10c1e2        	addi	a14, a1, 16
4200ce69:	132a87        	blt	a10, a8, 4200ce80 <_vfprintf_r+0x420>
4200ce6c:	000606        	j	4200ce88 <_vfprintf_r+0x428>
4200ce6f:	21a200        	srai	a10, a0, 2
4200ce72:	c71b97        	beq	a11, a9, 4200ce3d <_vfprintf_r+0x3dd>
4200ce75:	10c182        	addi	a8, a1, 16
4200ce78:	3027a7        	blt	a7, a10, 4200ceac <_vfprintf_r+0x44c>
4200ce7b:	000cc6        	j	4200ceb2 <_vfprintf_r+0x452>
4200ce7e:	e00000        	subx4	a0, a0, a0
4200ce81:	b0ea      	add.n	a11, a0, a14
4200ce83:	0e88      	l32i.n	a8, a14, 0
4200ce85:	000686        	j	4200cea3 <_vfprintf_r+0x443>
4200ce88:	48a282        	movi	a8, 0x248
4200ce8b:	8e8a      	add.n	a8, a14, a8
4200ce8d:	4ca2d2        	movi	a13, 0x24c
4200ce90:	60a2c2        	movi	a12, 0x260
4200ce93:	0189      	s32i.n	a8, a1, 0
4200ce95:	01def2        	addmi	a15, a14, 0x100
4200ce98:	deda      	add.n	a13, a14, a13
4200ce9a:	ceca      	add.n	a12, a14, a12
4200ce9c:	05bd      	mov.n	a11, a5
4200ce9e:	ff6f25        	call8	4200c590 <get_arg$isra$0>
4200cea1:	0a88      	l32i.n	a8, a10, 0
4200cea3:	a32192        	l32i	a9, a1, 0x28c
4200cea6:	07cd      	mov.n	a12, a7
4200cea8:	001c06        	j	4200cf1c <_vfprintf_r+0x4bc>
4200ceab:	868000        	lsi	f0, a0, 0x218
4200ceae:	19c6b0        	lsi	f11, a6, 100
4200ceb1:	fb1c00        	f64addc	a0, a12, 0, 1
4200ceb4:	352ba7        	blt	a11, a10, 4200ceed <_vfprintf_r+0x48d>
4200ceb7:	9a28e2        	l32i	a14, a8, 0x268
4200ceba:	ba1b      	addi.n	a11, a10, 1
4200cebc:	9761b2        	s32i	a11, a1, 0x25c
4200cebf:	be4b      	addi.n	a11, a14, 4
4200cec1:	9a68b2        	s32i	a11, a8, 0x268
4200cec4:	8f1c      	movi.n	a15, 24
4200cec6:	062fb7        	blt	a15, a11, 4200ced0 <_vfprintf_r+0x470>
4200cec9:	992882        	l32i	a8, a8, 0x264
4200cecc:	000386        	j	4200cede <_vfprintf_r+0x47e>
4200cecf:	2fe700        	f64cmph	a14, a7, a0, 2
4200ced2:	4b2c01        	l32r	a0, 41fdfb84 <_coredump_iram_end+0x1c5db84>
4200ced5:	9a68b2        	s32i	a11, a8, 0x268
4200ced8:	02d882        	addmi	a8, a8, 0x200
4200cedb:	182882        	l32i	a8, a8, 96
4200cede:	88ba      	add.n	a8, a8, a11
4200cee0:	fcc882        	addi	a8, a8, -4
4200cee3:	0888      	l32i.n	a8, a8, 0
4200cee5:	b0aa10        	addx8	a10, a10, a1
4200cee8:	4a89      	s32i.n	a8, a10, 16
4200ceea:	000b86        	j	4200cf1c <_vfprintf_r+0x4bc>
4200ceed:	9a28b2        	l32i	a11, a8, 0x268
4200cef0:	8d1c      	movi.n	a13, 24
4200cef2:	ab4b      	addi.n	a10, a11, 4
4200cef4:	9a68a2        	s32i	a10, a8, 0x268
4200cef7:	02d882        	addmi	a8, a8, 0x200
4200cefa:	062da7        	blt	a13, a10, 4200cf04 <_vfprintf_r+0x4a4>
4200cefd:	192882        	l32i	a8, a8, 100
4200cf00:	000446        	j	4200cf15 <_vfprintf_r+0x4b5>
4200cf03:	2db700        	lsi	f0, a7, 180
4200cf06:	4a2c01        	l32r	a0, 41fdf7b8 <_coredump_iram_end+0x1c5d7b8>
4200cf09:	10c182        	addi	a8, a1, 16
4200cf0c:	02d882        	addmi	a8, a8, 0x200
4200cf0f:	182882        	l32i	a8, a8, 96
4200cf12:	9e61a2        	s32i	a10, a1, 0x278
4200cf15:	88aa      	add.n	a8, a8, a10
4200cf17:	fcc882        	addi	a8, a8, -4
4200cf1a:	0888      	l32i.n	a8, a8, 0
4200cf1c:	fa7c      	movi.n	a10, -1
4200cf1e:	5388a0        	max	a8, a8, a10
4200cf21:	a26182        	s32i	a8, a1, 0x288
4200cf24:	0c7d      	mov.n	a7, a12
4200cf26:	a86192        	s32i	a9, a1, 0x2a0
4200cf29:	ff4746        	j	4200cc4a <_vfprintf_r+0x1ea>
4200cf2c:	a08880        	addx4	a8, a8, a8
4200cf2f:	9088b0        	addx2	a8, a8, a11
4200cf32:	0009b2        	l8ui	a11, a9, 0
4200cf35:	991b      	addi.n	a9, a9, 1
4200cf37:	a361b2        	s32i	a11, a1, 0x28c
4200cf3a:	a321b2        	l32i	a11, a1, 0x28c
4200cf3d:	a86192        	s32i	a9, a1, 0x2a0
4200cf40:	d0cbb2        	addi	a11, a11, -48
4200cf43:	e5bcb7        	bgeu	a12, a11, 4200cf2c <_vfprintf_r+0x4cc>
4200cf46:	f97c      	movi.n	a9, -1
4200cf48:	538890        	max	a8, a8, a9
4200cf4b:	a26182        	s32i	a8, a1, 0x288
4200cf4e:	ac2182        	l32i	a8, a1, 0x2b0
4200cf51:	ff4206        	j	4200cc5d <_vfprintf_r+0x1fd>
4200cf54:	820000        	mull	a0, a0, a0
4200cf57:	8680a0        	lsi	f10, a0, 0x218
4200cf5a:	0c0021        	l32r	a2, 41fcff5c <_coredump_iram_end+0x1c4df5c>
4200cf5d:	0c08      	l32i.n	a0, a12, 0
4200cf5f:	929b      	addi.n	a9, a2, 9
4200cf61:	80a321        	l32r	a2, 41fed1f0 <_coredump_iram_end+0x1c6b1f0>
4200cf64:	a088      	l32i.n	a8, a0, 40
4200cf66:	d0c992        	addi	a9, a9, -48
4200cf69:	908890        	addx2	a8, a8, a9
4200cf6c:	a82192        	l32i	a9, a1, 0x2a0
4200cf6f:	000992        	l8ui	a9, a9, 0
4200cf72:	a36192        	s32i	a9, a1, 0x28c
4200cf75:	a82192        	l32i	a9, a1, 0x2a0
4200cf78:	991b      	addi.n	a9, a9, 1
4200cf7a:	a86192        	s32i	a9, a1, 0x2a0
4200cf7d:	a32192        	l32i	a9, a1, 0x28c
4200cf80:	d0c992        	addi	a9, a9, -48
4200cf83:	d9bb97        	bgeu	a11, a9, 4200cf60 <_vfprintf_r+0x500>
4200cf86:	a321b2        	l32i	a11, a1, 0x28c
4200cf89:	492c      	movi.n	a9, 36
4200cf8b:	021b97        	beq	a11, a9, 4200cf91 <_vfprintf_r+0x531>
4200cf8e:	ff32c6        	j	4200cc5d <_vfprintf_r+0x1fd>
4200cf91:	092c      	movi.n	a9, 32
4200cf93:	02a987        	bge	a9, a8, 4200cf99 <_vfprintf_r+0x539>
4200cf96:	09ac86        	j	4200f64c <_vfprintf_r+0x2bec>
4200cf99:	680b      	addi.n	a6, a8, -1
4200cf9b:	140c      	movi.n	a4, 1
4200cf9d:	ff2a46        	j	4200cc4a <_vfprintf_r+0x1ea>
4200cfa0:	880c00        	lsi	f0, a12, 0x220
4200cfa3:	000f06        	j	4200cfe3 <_vfprintf_r+0x583>
4200cfa6:	a82182        	l32i	a8, a1, 0x2a0
4200cfa9:	000892        	l8ui	a9, a8, 0
4200cfac:	68a082        	movi	a8, 104
4200cfaf:	0d9987        	bne	a9, a8, 4200cfc0 <_vfprintf_r+0x560>
4200cfb2:	a82182        	l32i	a8, a1, 0x2a0
4200cfb5:	881b      	addi.n	a8, a8, 1
4200cfb7:	a86182        	s32i	a8, a1, 0x2a0
4200cfba:	00a282        	movi	a8, 0x200
4200cfbd:	000886        	j	4200cfe3 <_vfprintf_r+0x583>
4200cfc0:	084c      	movi.n	a8, 64
4200cfc2:	000746        	j	4200cfe3 <_vfprintf_r+0x583>
4200cfc5:	a82182        	l32i	a8, a1, 0x2a0
4200cfc8:	000892        	l8ui	a9, a8, 0
4200cfcb:	6ca082        	movi	a8, 108
4200cfce:	0a9987        	bne	a9, a8, 4200cfdc <_vfprintf_r+0x57c>
4200cfd1:	a82182        	l32i	a8, a1, 0x2a0
4200cfd4:	881b      	addi.n	a8, a8, 1
4200cfd6:	a86182        	s32i	a8, a1, 0x2a0
4200cfd9:	000106        	j	4200cfe1 <_vfprintf_r+0x581>
4200cfdc:	081c      	movi.n	a8, 16
4200cfde:	000046        	j	4200cfe3 <_vfprintf_r+0x583>
4200cfe1:	082c      	movi.n	a8, 32
4200cfe3:	203380        	or	a3, a3, a8
4200cfe6:	ff1806        	j	4200cc4a <_vfprintf_r+0x1ea>
4200cfe9:	972192        	l32i	a9, a1, 0x25c
4200cfec:	10c1e2        	addi	a14, a1, 16
4200cfef:	d4ac      	beqz.n	a4, 4200d020 <_vfprintf_r+0x5c0>
4200cff1:	08a697        	bge	a6, a9, 4200cffd <_vfprintf_r+0x59d>
4200cff4:	b0e6e0        	addx8	a14, a6, a14
4200cff7:	000e82        	l8ui	a8, a14, 0
4200cffa:	000746        	j	4200d01b <_vfprintf_r+0x5bb>
4200cffd:	48a282        	movi	a8, 0x248
4200d000:	8e8a      	add.n	a8, a14, a8
4200d002:	4ca2d2        	movi	a13, 0x24c
4200d005:	60a2c2        	movi	a12, 0x260
4200d008:	0189      	s32i.n	a8, a1, 0
4200d00a:	01def2        	addmi	a15, a14, 0x100
4200d00d:	deda      	add.n	a13, a14, a13
4200d00f:	ceca      	add.n	a12, a14, a12
4200d011:	05bd      	mov.n	a11, a5
4200d013:	06ad      	mov.n	a10, a6
4200d015:	ff57a5        	call8	4200c590 <get_arg$isra$0>
4200d018:	000a82        	l8ui	a8, a10, 0
4200d01b:	07ad      	mov.n	a10, a7
4200d01d:	001f06        	j	4200d09d <_vfprintf_r+0x63d>
4200d020:	a71b      	addi.n	a10, a7, 1
4200d022:	0aa797        	bge	a7, a9, 4200d030 <_vfprintf_r+0x5d0>
4200d025:	b0e6e0        	addx8	a14, a6, a14
4200d028:	000e82        	l8ui	a8, a14, 0
4200d02b:	001b86        	j	4200d09d <_vfprintf_r+0x63d>
4200d02e:	b20000        	mulsh	a0, a0, a0
4200d031:	2e          	.byte	0x2e
4200d032:	1c9a      	add.n	a1, a12, a9
4200d034:	e2fc      	bnez.n	a2, 4200d076 <_vfprintf_r+0x616>
4200d036:	de          	.byte	0xde
4200d037:	8b4b02        	s8i	a0, a11, 139
4200d03a:	362c97        	blt	a12, a9, 4200d074 <_vfprintf_r+0x614>
4200d03d:	c91b      	addi.n	a12, a9, 1
4200d03f:	9761c2        	s32i	a12, a1, 0x25c
4200d042:	1a6e82        	s32i	a8, a14, 104
4200d045:	8c1c      	movi.n	a12, 24
4200d047:	052c87        	blt	a12, a8, 4200d050 <_vfprintf_r+0x5f0>
4200d04a:	192eb2        	l32i	a11, a14, 100
4200d04d:	000406        	j	4200d061 <_vfprintf_r+0x601>
4200d050:	012cb7        	blt	a12, a11, 4200d055 <_vfprintf_r+0x5f5>
4200d053:	482c      	movi.n	a8, 36
4200d055:	10c1b2        	addi	a11, a1, 16
4200d058:	02dbb2        	addmi	a11, a11, 0x200
4200d05b:	182bb2        	l32i	a11, a11, 96
4200d05e:	9e6182        	s32i	a8, a1, 0x278
4200d061:	bb8a      	add.n	a11, a11, a8
4200d063:	fccbb2        	addi	a11, a11, -4
4200d066:	0b88      	l32i.n	a8, a11, 0
4200d068:	b09910        	addx8	a9, a9, a1
4200d06b:	4989      	s32i.n	a8, a9, 16
4200d06d:	748080        	extui	a8, a8, 0, 8
4200d070:	000a46        	j	4200d09d <_vfprintf_r+0x63d>
4200d073:	6e8200        	f64rnd	a8, a2, a0, 2
4200d076:	1c1a      	add.n	a1, a12, a1
4200d078:	8789      	s32i.n	a8, a7, 32
4200d07a:	0729      	s32i.n	a2, a7, 0
4200d07c:	192e92        	l32i	a9, a14, 100
4200d07f:	000486        	j	4200d095 <_vfprintf_r+0x635>
4200d082:	b70000        	lsi	f0, a0, 0x2dc
4200d085:	0129      	s32i.n	a2, a1, 0
4200d087:	482c      	movi.n	a8, 36
4200d089:	10c192        	addi	a9, a1, 16
4200d08c:	02d992        	addmi	a9, a9, 0x200
4200d08f:	182992        	l32i	a9, a9, 96
4200d092:	9e6182        	s32i	a8, a1, 0x278
4200d095:	998a      	add.n	a9, a9, a8
4200d097:	fcc992        	addi	a9, a9, -4
4200d09a:	000982        	l8ui	a8, a9, 0
4200d09d:	10c192        	addi	a9, a1, 16
4200d0a0:	01d9b2        	addmi	a11, a9, 0x100
4200d0a3:	804b82        	s8i	a8, a11, 128
4200d0a6:	02d982        	addmi	a8, a9, 0x200
4200d0a9:	0b0c      	movi.n	a11, 0
4200d0ab:	5248b2        	s8i	a11, a8, 82
4200d0ae:	080c      	movi.n	a8, 0
4200d0b0:	a96182        	s32i	a8, a1, 0x2a4
4200d0b3:	180c      	movi.n	a8, 1
4200d0b5:	a26182        	s32i	a8, a1, 0x288
4200d0b8:	080c      	movi.n	a8, 0
4200d0ba:	ab6182        	s32i	a8, a1, 0x2ac
4200d0bd:	0a7d      	mov.n	a7, a10
4200d0bf:	040c      	movi.n	a4, 0
4200d0c1:	050c      	movi.n	a5, 0
4200d0c3:	060c      	movi.n	a6, 0
4200d0c5:	80a182        	movi	a8, 0x180
4200d0c8:	069e06        	j	4200eb44 <_vfprintf_r+0x20e4>
4200d0cb:	1c0000        	lsi	f0, a0, 112
4200d0ce:	8008      	l32i.n	a0, a0, 32
4200d0d0:	822033        	lsi	f3, a0, 0x208
4200d0d3:	e29721        	l32r	a2, 42005b30 <__esp_system_init_fn_init_libc_stdio+0x8> (1d020c00 <UserFrameTotalSize+0x1d020b00>)
4200d0d6:	5710c1        	l32r	a12, 41fe2d18 <_coredump_iram_end+0x1c60d18>
4200d0d9:	4602e3        	lsi	f14, a2, 0x118
4200d0dc:	2f          	.byte	0x2f
4200d0dd:	f4ac00        	extui	a10, a0, 12, 16
4200d0e0:	09a687        	bge	a6, a8, 4200d0ed <_vfprintf_r+0x68d>
4200d0e3:	b0e6e0        	addx8	a14, a6, a14
4200d0e6:	0e58      	l32i.n	a5, a14, 0
4200d0e8:	1e48      	l32i.n	a4, a14, 4
4200d0ea:	000786        	j	4200d10c <_vfprintf_r+0x6ac>
4200d0ed:	48a282        	movi	a8, 0x248
4200d0f0:	8e8a      	add.n	a8, a14, a8
4200d0f2:	4ca2d2        	movi	a13, 0x24c
4200d0f5:	60a2c2        	movi	a12, 0x260
4200d0f8:	05bd      	mov.n	a11, a5
4200d0fa:	0189      	s32i.n	a8, a1, 0
4200d0fc:	01def2        	addmi	a15, a14, 0x100
4200d0ff:	deda      	add.n	a13, a14, a13
4200d101:	ceca      	add.n	a12, a14, a12
4200d103:	06ad      	mov.n	a10, a6
4200d105:	ff48a5        	call8	4200c590 <get_arg$isra$0>
4200d108:	0a58      	l32i.n	a5, a10, 0
4200d10a:	1a48      	l32i.n	a4, a10, 4
4200d10c:	07ad      	mov.n	a10, a7
4200d10e:	00ab46        	j	4200d3bf <_vfprintf_r+0x95f>
4200d111:	a71b      	addi.n	a10, a7, 1
4200d113:	09a787        	bge	a7, a8, 4200d120 <_vfprintf_r+0x6c0>
4200d116:	b0e6e0        	addx8	a14, a6, a14
4200d119:	0e58      	l32i.n	a5, a14, 0
4200d11b:	1e48      	l32i.n	a4, a14, 4
4200d11d:	00a786        	j	4200d3bf <_vfprintf_r+0x95f>
4200d120:	9a2eb2        	l32i	a11, a14, 0x268
4200d123:	897c      	movi.n	a9, -8
4200d125:	bb7b      	addi.n	a11, a11, 7
4200d127:	10bb90        	and	a11, a11, a9
4200d12a:	fc1c      	movi.n	a12, 31
4200d12c:	02dee2        	addmi	a14, a14, 0x200
4200d12f:	9b8b      	addi.n	a9, a11, 8
4200d131:	3b2c87        	blt	a12, a8, 4200d170 <_vfprintf_r+0x710>
4200d134:	c81b      	addi.n	a12, a8, 1
4200d136:	9761c2        	s32i	a12, a1, 0x25c
4200d139:	1a6e92        	s32i	a9, a14, 104
4200d13c:	8c1c      	movi.n	a12, 24
4200d13e:	062c97        	blt	a12, a9, 4200d148 <_vfprintf_r+0x6e8>
4200d141:	192eb2        	l32i	a11, a14, 100
4200d144:	000446        	j	4200d159 <_vfprintf_r+0x6f9>
4200d147:	2cb700        	lsi	f0, a7, 176
4200d14a:	892c01        	l32r	a0, 41fef5fc <_coredump_iram_end+0x1c6d5fc>
4200d14d:	10c1b2        	addi	a11, a1, 16
4200d150:	02dbb2        	addmi	a11, a11, 0x200
4200d153:	182bb2        	l32i	a11, a11, 96
4200d156:	9e6192        	s32i	a9, a1, 0x278
4200d159:	9b9a      	add.n	a9, a11, a9
4200d15b:	f8c992        	addi	a9, a9, -8
4200d15e:	0958      	l32i.n	a5, a9, 0
4200d160:	1948      	l32i.n	a4, a9, 4
4200d162:	10c192        	addi	a9, a1, 16
4200d165:	b08890        	addx8	a8, a8, a9
4200d168:	0859      	s32i.n	a5, a8, 0
4200d16a:	1849      	s32i.n	a4, a8, 4
4200d16c:	0093c6        	j	4200d3bf <_vfprintf_r+0x95f>
4200d16f:	6e9200        	f64rnd	a9, a2, a0, 2
4200d172:	1c1a      	add.n	a1, a12, a1
4200d174:	9788      	l32i.n	a8, a7, 36
4200d176:	0528      	l32i.n	a2, a5, 0
4200d178:	192e82        	l32i	a8, a14, 100
4200d17b:	000446        	j	4200d190 <_vfprintf_r+0x730>
4200d17e:	0228b7        	blt	a8, a11, 4200d184 <_vfprintf_r+0x724>
4200d181:	28a092        	movi	a9, 40
4200d184:	10c182        	addi	a8, a1, 16
4200d187:	02d882        	addmi	a8, a8, 0x200
4200d18a:	182882        	l32i	a8, a8, 96
4200d18d:	9e6192        	s32i	a9, a1, 0x278
4200d190:	889a      	add.n	a8, a8, a9
4200d192:	f8c882        	addi	a8, a8, -8
4200d195:	0858      	l32i.n	a5, a8, 0
4200d197:	1848      	l32i.n	a4, a8, 4
4200d199:	008886        	j	4200d3bf <_vfprintf_r+0x95f>
4200d19c:	02e347        	bbsi	a3, 4, 4200d1a2 <_vfprintf_r+0x742>
4200d19f:	002a46        	j	4200d24c <_vfprintf_r+0x7ec>
4200d1a2:	b4ac      	beqz.n	a4, 4200d1d1 <_vfprintf_r+0x771>
4200d1a4:	09a687        	bge	a6, a8, 4200d1b1 <_vfprintf_r+0x751>
4200d1a7:	b0e6e0        	addx8	a14, a6, a14
4200d1aa:	0e58      	l32i.n	a5, a14, 0
4200d1ac:	0033c6        	j	4200d27f <_vfprintf_r+0x81f>
4200d1af:	820000        	mull	a0, a0, a0
4200d1b2:	8a48a2        	s8i	a10, a8, 138
4200d1b5:	8e          	.byte	0x8e
4200d1b6:	4ca2d2        	movi	a13, 0x24c
4200d1b9:	60a2c2        	movi	a12, 0x260
4200d1bc:	05bd      	mov.n	a11, a5
4200d1be:	0189      	s32i.n	a8, a1, 0
4200d1c0:	01def2        	addmi	a15, a14, 0x100
4200d1c3:	deda      	add.n	a13, a14, a13
4200d1c5:	ceca      	add.n	a12, a14, a12
4200d1c7:	06ad      	mov.n	a10, a6
4200d1c9:	ff3c65        	call8	4200c590 <get_arg$isra$0>
4200d1cc:	0a58      	l32i.n	a5, a10, 0
4200d1ce:	002b46        	j	4200d27f <_vfprintf_r+0x81f>
4200d1d1:	a71b      	addi.n	a10, a7, 1
4200d1d3:	09a787        	bge	a7, a8, 4200d1e0 <_vfprintf_r+0x780>
4200d1d6:	b0e6e0        	addx8	a14, a6, a14
4200d1d9:	0e58      	l32i.n	a5, a14, 0
4200d1db:	007746        	j	4200d3bc <_vfprintf_r+0x95c>
4200d1de:	b20000        	mulsh	a0, a0, a0
4200d1e1:	2e          	.byte	0x2e
4200d1e2:	1c9a      	add.n	a1, a12, a9
4200d1e4:	e2fc      	bnez.n	a2, 4200d226 <_vfprintf_r+0x7c6>
4200d1e6:	de          	.byte	0xde
4200d1e7:	9b4b02        	s8i	a0, a11, 155
4200d1ea:	322c87        	blt	a12, a8, 4200d220 <_vfprintf_r+0x7c0>
4200d1ed:	c81b      	addi.n	a12, a8, 1
4200d1ef:	9761c2        	s32i	a12, a1, 0x25c
4200d1f2:	1a6e92        	s32i	a9, a14, 104
4200d1f5:	8c1c      	movi.n	a12, 24
4200d1f7:	052c97        	blt	a12, a9, 4200d200 <_vfprintf_r+0x7a0>
4200d1fa:	192eb2        	l32i	a11, a14, 100
4200d1fd:	000406        	j	4200d211 <_vfprintf_r+0x7b1>
4200d200:	012cb7        	blt	a12, a11, 4200d205 <_vfprintf_r+0x7a5>
4200d203:	492c      	movi.n	a9, 36
4200d205:	10c1b2        	addi	a11, a1, 16
4200d208:	02dbb2        	addmi	a11, a11, 0x200
4200d20b:	182bb2        	l32i	a11, a11, 96
4200d20e:	9e6192        	s32i	a9, a1, 0x278
4200d211:	bb9a      	add.n	a11, a11, a9
4200d213:	fccbb2        	addi	a11, a11, -4
4200d216:	0b58      	l32i.n	a5, a11, 0
4200d218:	b08810        	addx8	a8, a8, a1
4200d21b:	4859      	s32i.n	a5, a8, 16
4200d21d:	0066c6        	j	4200d3bc <_vfprintf_r+0x95c>
4200d220:	1a6e92        	s32i	a9, a14, 104
4200d223:	881c      	movi.n	a8, 24
4200d225:	072897        	blt	a8, a9, 4200d230 <_vfprintf_r+0x7d0>
4200d228:	192e82        	l32i	a8, a14, 100
4200d22b:	000486        	j	4200d241 <_vfprintf_r+0x7e1>
4200d22e:	b70000        	lsi	f0, a0, 0x2dc
4200d231:	0128      	l32i.n	a2, a1, 0
4200d233:	492c      	movi.n	a9, 36
4200d235:	10c182        	addi	a8, a1, 16
4200d238:	02d882        	addmi	a8, a8, 0x200
4200d23b:	182882        	l32i	a8, a8, 96
4200d23e:	9e6192        	s32i	a9, a1, 0x278
4200d241:	889a      	add.n	a8, a8, a9
4200d243:	fcc882        	addi	a8, a8, -4
4200d246:	0858      	l32i.n	a5, a8, 0
4200d248:	005c06        	j	4200d3bc <_vfprintf_r+0x95c>
4200d24b:	e36700        	lsi	f0, a7, 0x38c
4200d24e:	2c4602        	s8i	a0, a6, 44
4200d251:	e4ac00        	extui	a10, a0, 12, 15
4200d254:	09a687        	bge	a6, a8, 4200d261 <_vfprintf_r+0x801>
4200d257:	b0e6e0        	addx8	a14, a6, a14
4200d25a:	009e52        	l16si	a5, a14, 0
4200d25d:	000786        	j	4200d27f <_vfprintf_r+0x81f>
4200d260:	a28200        	muluh	a8, a2, a0
4200d263:	8a48      	l32i.n	a4, a10, 32
4200d265:	8e          	.byte	0x8e
4200d266:	4ca2d2        	movi	a13, 0x24c
4200d269:	60a2c2        	movi	a12, 0x260
4200d26c:	05bd      	mov.n	a11, a5
4200d26e:	0189      	s32i.n	a8, a1, 0
4200d270:	01def2        	addmi	a15, a14, 0x100
4200d273:	deda      	add.n	a13, a14, a13
4200d275:	ceca      	add.n	a12, a14, a12
4200d277:	06ad      	mov.n	a10, a6
4200d279:	ff3165        	call8	4200c590 <get_arg$isra$0>
4200d27c:	009a52        	l16si	a5, a10, 0
4200d27f:	07ad      	mov.n	a10, a7
4200d281:	004dc6        	j	4200d3bc <_vfprintf_r+0x95c>
4200d284:	a71b      	addi.n	a10, a7, 1
4200d286:	08a787        	bge	a7, a8, 4200d292 <_vfprintf_r+0x832>
4200d289:	b0e6e0        	addx8	a14, a6, a14
4200d28c:	009e52        	l16si	a5, a14, 0
4200d28f:	004a46        	j	4200d3bc <_vfprintf_r+0x95c>
4200d292:	9a2eb2        	l32i	a11, a14, 0x268
4200d295:	fc1c      	movi.n	a12, 31
4200d297:	02dee2        	addmi	a14, a14, 0x200
4200d29a:	9b4b      	addi.n	a9, a11, 4
4200d29c:	382c87        	blt	a12, a8, 4200d2d8 <_vfprintf_r+0x878>
4200d29f:	c81b      	addi.n	a12, a8, 1
4200d2a1:	9761c2        	s32i	a12, a1, 0x25c
4200d2a4:	1a6e92        	s32i	a9, a14, 104
4200d2a7:	8c1c      	movi.n	a12, 24
4200d2a9:	072c97        	blt	a12, a9, 4200d2b4 <_vfprintf_r+0x854>
4200d2ac:	192eb2        	l32i	a11, a14, 100
4200d2af:	000486        	j	4200d2c5 <_vfprintf_r+0x865>
4200d2b2:	b70000        	lsi	f0, a0, 0x2dc
4200d2b5:	012c      	movi.n	a1, 32
4200d2b7:	492c      	movi.n	a9, 36
4200d2b9:	10c1b2        	addi	a11, a1, 16
4200d2bc:	02dbb2        	addmi	a11, a11, 0x200
4200d2bf:	182bb2        	l32i	a11, a11, 96
4200d2c2:	9e6192        	s32i	a9, a1, 0x278
4200d2c5:	bb9a      	add.n	a11, a11, a9
4200d2c7:	fccbb2        	addi	a11, a11, -4
4200d2ca:	0b58      	l32i.n	a5, a11, 0
4200d2cc:	b08810        	addx8	a8, a8, a1
4200d2cf:	4859      	s32i.n	a5, a8, 16
4200d2d1:	235580        	sext	a5, a5, 15
4200d2d4:	003906        	j	4200d3bc <_vfprintf_r+0x95c>
4200d2d7:	6e9200        	f64rnd	a9, a2, a0, 2
4200d2da:	1c1a      	add.n	a1, a12, a1
4200d2dc:	9788      	l32i.n	a8, a7, 36
4200d2de:	0728      	l32i.n	a2, a7, 0
4200d2e0:	192e82        	l32i	a8, a14, 100
4200d2e3:	000486        	j	4200d2f9 <_vfprintf_r+0x899>
4200d2e6:	b70000        	lsi	f0, a0, 0x2dc
4200d2e9:	0128      	l32i.n	a2, a1, 0
4200d2eb:	492c      	movi.n	a9, 36
4200d2ed:	10c182        	addi	a8, a1, 16
4200d2f0:	02d882        	addmi	a8, a8, 0x200
4200d2f3:	182882        	l32i	a8, a8, 96
4200d2f6:	9e6192        	s32i	a9, a1, 0x278
4200d2f9:	889a      	add.n	a8, a8, a9
4200d2fb:	fcc882        	addi	a8, a8, -4
4200d2fe:	009852        	l16si	a5, a8, 0
4200d301:	002dc6        	j	4200d3bc <_vfprintf_r+0x95c>
4200d304:	02e397        	bbsi	a3, 9, 4200d30a <_vfprintf_r+0x8aa>
4200d307:	002e46        	j	4200d3c4 <_vfprintf_r+0x964>
4200d30a:	e4ac      	beqz.n	a4, 4200d33c <_vfprintf_r+0x8dc>
4200d30c:	09a687        	bge	a6, a8, 4200d319 <_vfprintf_r+0x8b9>
4200d30f:	b0e6e0        	addx8	a14, a6, a14
4200d312:	000e52        	l8ui	a5, a14, 0
4200d315:	000786        	j	4200d337 <_vfprintf_r+0x8d7>
4200d318:	a28200        	muluh	a8, a2, a0
4200d31b:	8a48      	l32i.n	a4, a10, 32
4200d31d:	8e          	.byte	0x8e
4200d31e:	4ca2d2        	movi	a13, 0x24c
4200d321:	60a2c2        	movi	a12, 0x260
4200d324:	05bd      	mov.n	a11, a5
4200d326:	0189      	s32i.n	a8, a1, 0
4200d328:	01def2        	addmi	a15, a14, 0x100
4200d32b:	deda      	add.n	a13, a14, a13
4200d32d:	ceca      	add.n	a12, a14, a12
4200d32f:	06ad      	mov.n	a10, a6
4200d331:	ff25e5        	call8	4200c590 <get_arg$isra$0>
4200d334:	000a52        	l8ui	a5, a10, 0
4200d337:	07ad      	mov.n	a10, a7
4200d339:	001f06        	j	4200d3b9 <_vfprintf_r+0x959>
4200d33c:	a71b      	addi.n	a10, a7, 1
4200d33e:	0aa787        	bge	a7, a8, 4200d34c <_vfprintf_r+0x8ec>
4200d341:	b0e6e0        	addx8	a14, a6, a14
4200d344:	000e52        	l8ui	a5, a14, 0
4200d347:	001b86        	j	4200d3b9 <_vfprintf_r+0x959>
4200d34a:	b20000        	mulsh	a0, a0, a0
4200d34d:	2e          	.byte	0x2e
4200d34e:	1c9a      	add.n	a1, a12, a9
4200d350:	e2fc      	bnez.n	a2, 4200d392 <_vfprintf_r+0x932>
4200d352:	de          	.byte	0xde
4200d353:	9b4b02        	s8i	a0, a11, 155
4200d356:	362c87        	blt	a12, a8, 4200d390 <_vfprintf_r+0x930>
4200d359:	c81b      	addi.n	a12, a8, 1
4200d35b:	9761c2        	s32i	a12, a1, 0x25c
4200d35e:	1a6e92        	s32i	a9, a14, 104
4200d361:	8c1c      	movi.n	a12, 24
4200d363:	052c97        	blt	a12, a9, 4200d36c <_vfprintf_r+0x90c>
4200d366:	192eb2        	l32i	a11, a14, 100
4200d369:	000406        	j	4200d37d <_vfprintf_r+0x91d>
4200d36c:	012cb7        	blt	a12, a11, 4200d371 <_vfprintf_r+0x911>
4200d36f:	492c      	movi.n	a9, 36
4200d371:	10c1b2        	addi	a11, a1, 16
4200d374:	02dbb2        	addmi	a11, a11, 0x200
4200d377:	182bb2        	l32i	a11, a11, 96
4200d37a:	9e6192        	s32i	a9, a1, 0x278
4200d37d:	bb9a      	add.n	a11, a11, a9
4200d37f:	fccbb2        	addi	a11, a11, -4
4200d382:	0b58      	l32i.n	a5, a11, 0
4200d384:	b08810        	addx8	a8, a8, a1
4200d387:	4859      	s32i.n	a5, a8, 16
4200d389:	745050        	extui	a5, a5, 0, 8
4200d38c:	000a46        	j	4200d3b9 <_vfprintf_r+0x959>
4200d38f:	6e9200        	f64rnd	a9, a2, a0, 2
4200d392:	1c1a      	add.n	a1, a12, a1
4200d394:	9788      	l32i.n	a8, a7, 36
4200d396:	0728      	l32i.n	a2, a7, 0
4200d398:	192e82        	l32i	a8, a14, 100
4200d39b:	000486        	j	4200d3b1 <_vfprintf_r+0x951>
4200d39e:	b70000        	lsi	f0, a0, 0x2dc
4200d3a1:	0128      	l32i.n	a2, a1, 0
4200d3a3:	492c      	movi.n	a9, 36
4200d3a5:	10c182        	addi	a8, a1, 16
4200d3a8:	02d882        	addmi	a8, a8, 0x200
4200d3ab:	182882        	l32i	a8, a8, 96
4200d3ae:	9e6192        	s32i	a9, a1, 0x278
4200d3b1:	889a      	add.n	a8, a8, a9
4200d3b3:	fcc882        	addi	a8, a8, -4
4200d3b6:	000852        	l8ui	a5, a8, 0
4200d3b9:	235500        	sext	a5, a5, 7
4200d3bc:	314f50        	srai	a4, a5, 31
4200d3bf:	0a7d      	mov.n	a7, a10
4200d3c1:	002a06        	j	4200d46d <_vfprintf_r+0xa0d>
4200d3c4:	c4ac      	beqz.n	a4, 4200d3f4 <_vfprintf_r+0x994>
4200d3c6:	07a687        	bge	a6, a8, 4200d3d1 <_vfprintf_r+0x971>
4200d3c9:	b0e6e0        	addx8	a14, a6, a14
4200d3cc:	0e58      	l32i.n	a5, a14, 0
4200d3ce:	000706        	j	4200d3ee <_vfprintf_r+0x98e>
4200d3d1:	48a282        	movi	a8, 0x248
4200d3d4:	8e8a      	add.n	a8, a14, a8
4200d3d6:	4ca2d2        	movi	a13, 0x24c
4200d3d9:	60a2c2        	movi	a12, 0x260
4200d3dc:	05bd      	mov.n	a11, a5
4200d3de:	0189      	s32i.n	a8, a1, 0
4200d3e0:	01def2        	addmi	a15, a14, 0x100
4200d3e3:	deda      	add.n	a13, a14, a13
4200d3e5:	ceca      	add.n	a12, a14, a12
4200d3e7:	06ad      	mov.n	a10, a6
4200d3e9:	ff1a65        	call8	4200c590 <get_arg$isra$0>
4200d3ec:	0a58      	l32i.n	a5, a10, 0
4200d3ee:	079d      	mov.n	a9, a7
4200d3f0:	001d06        	j	4200d468 <_vfprintf_r+0xa08>
4200d3f3:	971b00        	lsi	f0, a11, 0x25c
4200d3f6:	07a787        	bge	a7, a8, 4200d401 <_vfprintf_r+0x9a1>
4200d3f9:	b0e6e0        	addx8	a14, a6, a14
4200d3fc:	0e58      	l32i.n	a5, a14, 0
4200d3fe:	001986        	j	4200d468 <_vfprintf_r+0xa08>
4200d401:	9a2eb2        	l32i	a11, a14, 0x268
4200d404:	fc1c      	movi.n	a12, 31
4200d406:	02dee2        	addmi	a14, a14, 0x200
4200d409:	ab4b      	addi.n	a10, a11, 4
4200d40b:	322c87        	blt	a12, a8, 4200d441 <_vfprintf_r+0x9e1>
4200d40e:	c81b      	addi.n	a12, a8, 1
4200d410:	9761c2        	s32i	a12, a1, 0x25c
4200d413:	1a6ea2        	s32i	a10, a14, 104
4200d416:	8c1c      	movi.n	a12, 24
4200d418:	052ca7        	blt	a12, a10, 4200d421 <_vfprintf_r+0x9c1>
4200d41b:	192eb2        	l32i	a11, a14, 100
4200d41e:	000406        	j	4200d432 <_vfprintf_r+0x9d2>
4200d421:	012cb7        	blt	a12, a11, 4200d426 <_vfprintf_r+0x9c6>
4200d424:	4a2c      	movi.n	a10, 36
4200d426:	10c1b2        	addi	a11, a1, 16
4200d429:	02dbb2        	addmi	a11, a11, 0x200
4200d42c:	182bb2        	l32i	a11, a11, 96
4200d42f:	9e61a2        	s32i	a10, a1, 0x278
4200d432:	bbaa      	add.n	a11, a11, a10
4200d434:	fccbb2        	addi	a11, a11, -4
4200d437:	0b58      	l32i.n	a5, a11, 0
4200d439:	b08810        	addx8	a8, a8, a1
4200d43c:	4859      	s32i.n	a5, a8, 16
4200d43e:	000986        	j	4200d468 <_vfprintf_r+0xa08>
4200d441:	1a6ea2        	s32i	a10, a14, 104
4200d444:	881c      	movi.n	a8, 24
4200d446:	0628a7        	blt	a8, a10, 4200d450 <_vfprintf_r+0x9f0>
4200d449:	192e82        	l32i	a8, a14, 100
4200d44c:	000446        	j	4200d461 <_vfprintf_r+0xa01>
4200d44f:	28b700        	lsi	f0, a7, 160
4200d452:	4a2c01        	l32r	a0, 41fdfd04 <_coredump_iram_end+0x1c5dd04>
4200d455:	10c182        	addi	a8, a1, 16
4200d458:	02d882        	addmi	a8, a8, 0x200
4200d45b:	182882        	l32i	a8, a8, 96
4200d45e:	9e61a2        	s32i	a10, a1, 0x278
4200d461:	88aa      	add.n	a8, a8, a10
4200d463:	fcc882        	addi	a8, a8, -4
4200d466:	0858      	l32i.n	a5, a8, 0
4200d468:	314f50        	srai	a4, a5, 31
4200d46b:	097d      	mov.n	a7, a9
4200d46d:	002496        	bltz	a4, 4200d473 <_vfprintf_r+0xa13>
4200d470:	088106        	j	4200f678 <_vfprintf_r+0x2c18>
4200d473:	604040        	neg	a4, a4
4200d476:	002516        	beqz	a5, 4200d47c <_vfprintf_r+0xa1c>
4200d479:	ffc442        	addi	a4, a4, -1
4200d47c:	605050        	neg	a5, a5
4200d47f:	d82c      	movi.n	a8, 45
4200d481:	190c      	movi.n	a9, 1
4200d483:	052d46        	j	4200e93c <_vfprintf_r+0x1edc>
4200d486:	972182        	l32i	a8, a1, 0x25c
4200d489:	10c1e2        	addi	a14, a1, 16
4200d48c:	44bc      	beqz.n	a4, 4200d4c4 <_vfprintf_r+0xa64>
4200d48e:	0fa687        	bge	a6, a8, 4200d4a1 <_vfprintf_r+0xa41>
4200d491:	b0e6e0        	addx8	a14, a6, a14
4200d494:	0e88      	l32i.n	a8, a14, 0
4200d496:	1e98      	l32i.n	a9, a14, 4
4200d498:	a66182        	s32i	a8, a1, 0x298
4200d49b:	a76192        	s32i	a9, a1, 0x29c
4200d49e:	002d06        	j	4200d556 <_vfprintf_r+0xaf6>
4200d4a1:	48a282        	movi	a8, 0x248
4200d4a4:	8e8a      	add.n	a8, a14, a8
4200d4a6:	4ca2d2        	movi	a13, 0x24c
4200d4a9:	60a2c2        	movi	a12, 0x260
4200d4ac:	0189      	s32i.n	a8, a1, 0
4200d4ae:	01def2        	addmi	a15, a14, 0x100
4200d4b1:	deda      	add.n	a13, a14, a13
4200d4b3:	ceca      	add.n	a12, a14, a12
4200d4b5:	05bd      	mov.n	a11, a5
4200d4b7:	06ad      	mov.n	a10, a6
4200d4b9:	ff0d65        	call8	4200c590 <get_arg$isra$0>
4200d4bc:	0a88      	l32i.n	a8, a10, 0
4200d4be:	1a98      	l32i.n	a9, a10, 4
4200d4c0:	fff506        	j	4200d498 <_vfprintf_r+0xa38>
4200d4c3:	b71b00        	lsi	f0, a11, 0x2dc
4200d4c6:	0aa787        	bge	a7, a8, 4200d4d4 <_vfprintf_r+0xa74>
4200d4c9:	b0e6e0        	addx8	a14, a6, a14
4200d4cc:	0e88      	l32i.n	a8, a14, 0
4200d4ce:	1e98      	l32i.n	a9, a14, 4
4200d4d0:	001e86        	j	4200d54e <_vfprintf_r+0xaee>
4200d4d3:	2ea200        	f64norm	a10, a2, a0, 0
4200d4d6:	7c9a      	add.n	a7, a12, a9
4200d4d8:	7b89      	s32i.n	a8, a11, 28
4200d4da:	90aa      	add.n	a9, a0, a10
4200d4dc:	10aa      	add.n	a1, a0, a10
4200d4de:	fc1c      	movi.n	a12, 31
4200d4e0:	02dee2        	addmi	a14, a14, 0x200
4200d4e3:	9a8b      	addi.n	a9, a10, 8
4200d4e5:	3c2c87        	blt	a12, a8, 4200d525 <_vfprintf_r+0xac5>
4200d4e8:	c81b      	addi.n	a12, a8, 1
4200d4ea:	9761c2        	s32i	a12, a1, 0x25c
4200d4ed:	1a6e92        	s32i	a9, a14, 104
4200d4f0:	8c1c      	movi.n	a12, 24
4200d4f2:	052c97        	blt	a12, a9, 4200d4fb <_vfprintf_r+0xa9b>
4200d4f5:	192ea2        	l32i	a10, a14, 100
4200d4f8:	000406        	j	4200d50c <_vfprintf_r+0xaac>
4200d4fb:	012ca7        	blt	a12, a10, 4200d500 <_vfprintf_r+0xaa0>
4200d4fe:	892c      	movi.n	a9, 40
4200d500:	10c1a2        	addi	a10, a1, 16
4200d503:	02daa2        	addmi	a10, a10, 0x200
4200d506:	182aa2        	l32i	a10, a10, 96
4200d509:	9e6192        	s32i	a9, a1, 0x278
4200d50c:	aa9a      	add.n	a10, a10, a9
4200d50e:	f8caa2        	addi	a10, a10, -8
4200d511:	0ac8      	l32i.n	a12, a10, 0
4200d513:	1ad8      	l32i.n	a13, a10, 4
4200d515:	b08810        	addx8	a8, a8, a1
4200d518:	a661c2        	s32i	a12, a1, 0x298
4200d51b:	a761d2        	s32i	a13, a1, 0x29c
4200d51e:	48c9      	s32i.n	a12, a8, 16
4200d520:	58d9      	s32i.n	a13, a8, 20
4200d522:	000b86        	j	4200d554 <_vfprintf_r+0xaf4>
4200d525:	1a6e92        	s32i	a9, a14, 104
4200d528:	881c      	movi.n	a8, 24
4200d52a:	062897        	blt	a8, a9, 4200d534 <_vfprintf_r+0xad4>
4200d52d:	192e82        	l32i	a8, a14, 100
4200d530:	000446        	j	4200d545 <_vfprintf_r+0xae5>
4200d533:	28a700        	lsi	f0, a7, 160
4200d536:	892c01        	l32r	a0, 41fef9e8 <_coredump_iram_end+0x1c6d9e8>
4200d539:	10c182        	addi	a8, a1, 16
4200d53c:	02d882        	addmi	a8, a8, 0x200
4200d53f:	182882        	l32i	a8, a8, 96
4200d542:	9e6192        	s32i	a9, a1, 0x278
4200d545:	889a      	add.n	a8, a8, a9
4200d547:	f8c882        	addi	a8, a8, -8
4200d54a:	1898      	l32i.n	a9, a8, 4
4200d54c:	0888      	l32i.n	a8, a8, 0
4200d54e:	a66182        	s32i	a8, a1, 0x298
4200d551:	a76192        	s32i	a9, a1, 0x29c
4200d554:	0b7d      	mov.n	a7, a11
4200d556:	a62182        	l32i	a8, a1, 0x298
4200d559:	ce2ed1        	l32r	a13, 42000e14 <_stext+0xdf4> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
4200d55c:	b46182        	s32i	a8, a1, 0x2d0
4200d55f:	a72182        	l32i	a8, a1, 0x29c
4200d562:	fc7c      	movi.n	a12, -1
4200d564:	888a      	add.n	a8, a8, a8
4200d566:	418180        	srli	a8, a8, 1
4200d569:	b56182        	s32i	a8, a1, 0x2d4
4200d56c:	d0a282        	movi	a8, 0x2d0
4200d56f:	881a      	add.n	a8, a8, a1
4200d571:	0028a2        	l32i	a10, a8, 0
4200d574:	18b8      	l32i.n	a11, a8, 4
4200d576:	ce2881        	l32r	a8, 42000e18 <_stext+0xdf8> (4000258c <__unorddf2>)
4200d579:	0008e0        	callx8	a8
4200d57c:	8adc      	bnez.n	a10, 4200d598 <_vfprintf_r+0xb38>
4200d57e:	d0a282        	movi	a8, 0x2d0
4200d581:	881a      	add.n	a8, a8, a1
4200d583:	ce24d1        	l32r	a13, 42000e14 <_stext+0xdf4> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
4200d586:	0028a2        	l32i	a10, a8, 0
4200d589:	0128b2        	l32i	a11, a8, 4
4200d58c:	ffafc2        	movi	a12, -1
4200d58f:	ce2381        	l32r	a8, 42000e1c <_stext+0xdfc> (400023b8 <__ledf2>)
4200d592:	0008e0        	callx8	a8
4200d595:	1c1ae6        	bgei	a10, 1, 4200d5b5 <_vfprintf_r+0xb55>
4200d598:	98a282        	movi	a8, 0x298
4200d59b:	881a      	add.n	a8, a8, a1
4200d59d:	08c8      	l32i.n	a12, a8, 0
4200d59f:	18d8      	l32i.n	a13, a8, 4
4200d5a1:	0cad      	mov.n	a10, a12
4200d5a3:	20bdd0        	or	a11, a13, a13
4200d5a6:	ce1c81        	l32r	a8, 42000e18 <_stext+0xdf8> (4000258c <__unorddf2>)
4200d5a9:	0008e0        	callx8	a8
4200d5ac:	075a16        	beqz	a10, 4200d625 <_vfprintf_r+0xbc5>
4200d5af:	000e06        	j	4200d5eb <_vfprintf_r+0xb8b>
4200d5b2:	000000        	ill
4200d5b5:	98a282        	movi	a8, 0x298
4200d5b8:	881a      	add.n	a8, a8, a1
4200d5ba:	08a8      	l32i.n	a10, a8, 0
4200d5bc:	18b8      	l32i.n	a11, a8, 4
4200d5be:	0c0c      	movi.n	a12, 0
4200d5c0:	0d0c      	movi.n	a13, 0
4200d5c2:	ce1781        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
4200d5c5:	0008e0        	callx8	a8
4200d5c8:	00aad6        	bgez	a10, 4200d5d6 <_vfprintf_r+0xb76>
4200d5cb:	10c182        	addi	a8, a1, 16
4200d5ce:	02d882        	addmi	a8, a8, 0x200
4200d5d1:	d92c      	movi.n	a9, 45
4200d5d3:	524892        	s8i	a9, a8, 82
4200d5d6:	ce0591        	l32r	a9, 42000dec <_stext+0xdcc> (3c0295b8 <_ZTISt12out_of_range+0x12c>)
4200d5d9:	784c      	movi.n	a8, 71
4200d5db:	9f6192        	s32i	a9, a1, 0x27c
4200d5de:	a32192        	l32i	a9, a1, 0x28c
4200d5e1:	2b2897        	blt	a8, a9, 4200d610 <_vfprintf_r+0xbb0>
4200d5e4:	ce0181        	l32r	a8, 42000de8 <_stext+0xdc8> (3c0295b4 <_ZTISt12out_of_range+0x128>)
4200d5e7:	000886        	j	4200d60d <_vfprintf_r+0xbad>
4200d5ea:	218200        	srai	a8, a0, 2
4200d5ed:	a8d6a7        	bbs	a6, a10, 4200d599 <_vfprintf_r+0xb39>
4200d5f0:	c18200        	mul16u	a8, a2, a0
4200d5f3:	d88210        	lsi	f1, a2, 0x360
4200d5f6:	d92c02        	l32i	a0, a12, 0x364
4200d5f9:	524892        	s8i	a9, a8, 82
4200d5fc:	cdfe91        	l32r	a9, 42000df4 <_stext+0xdd4> (3c0295c0 <_ZTISt12out_of_range+0x134>)
4200d5ff:	784c      	movi.n	a8, 71
4200d601:	9f6192        	s32i	a9, a1, 0x27c
4200d604:	a32192        	l32i	a9, a1, 0x28c
4200d607:	052897        	blt	a8, a9, 4200d610 <_vfprintf_r+0xbb0>
4200d60a:	cdf981        	l32r	a8, 42000df0 <_stext+0xdd0> (3c0295bc <_ZTISt12out_of_range+0x130>)
4200d60d:	9f6182        	s32i	a8, a1, 0x27c
4200d610:	7faf82        	movi	a8, -129
4200d613:	103380        	and	a3, a3, a8
4200d616:	080c      	movi.n	a8, 0
4200d618:	a96182        	s32i	a8, a1, 0x2a4
4200d61b:	380c      	movi.n	a8, 3
4200d61d:	a26182        	s32i	a8, a1, 0x288
4200d620:	054a86        	j	4200eb4e <_vfprintf_r+0x20ee>
4200d623:	920000        	lsi	f0, a0, 0x248
4200d626:	82a321        	l32r	a2, 41fee0b4 <_coredump_iram_end+0x1c6c0b4>
4200d629:	af          	.byte	0xaf
4200d62a:	df          	.byte	0xdf
4200d62b:	104980        	and	a4, a9, a8
4200d62e:	184c      	movi.n	a8, 65
4200d630:	5d9487        	bne	a4, a8, 4200d691 <_vfprintf_r+0xc31>
4200d633:	10c182        	addi	a8, a1, 16
4200d636:	02d892        	addmi	a9, a8, 0x200
4200d639:	0a3c      	movi.n	a10, 48
4200d63b:	a321b2        	l32i	a11, a1, 0x28c
4200d63e:	5049a2        	s8i	a10, a9, 80
4200d641:	61a0a2        	movi	a10, 97
4200d644:	895c      	movi.n	a9, 88
4200d646:	029ba7        	bne	a11, a10, 4200d64c <_vfprintf_r+0xbec>
4200d649:	78a092        	movi	a9, 120
4200d64c:	02d8a2        	addmi	a10, a8, 0x200
4200d64f:	514a92        	s8i	a9, a10, 81
4200d652:	0a0c      	movi.n	a10, 0
4200d654:	a961a2        	s32i	a10, a1, 0x2a4
4200d657:	80a1a2        	movi	a10, 0x180
4200d65a:	88aa      	add.n	a8, a8, a10
4200d65c:	290c      	movi.n	a9, 2
4200d65e:	9f6182        	s32i	a8, a1, 0x27c
4200d661:	a22182        	l32i	a8, a1, 0x288
4200d664:	203390        	or	a3, a3, a9
4200d667:	63a092        	movi	a9, 99
4200d66a:	53a987        	bge	a9, a8, 4200d6c1 <_vfprintf_r+0xc61>
4200d66d:	a121a2        	l32i	a10, a1, 0x284
4200d670:	b81b      	addi.n	a11, a8, 1
4200d672:	cdc781        	l32r	a8, 42000d90 <_stext+0xd70> (4037fef4 <_malloc_r>)
4200d675:	0008e0        	callx8	a8
4200d678:	9f61a2        	s32i	a10, a1, 0x27c
4200d67b:	9aec      	bnez.n	a10, 4200d6a8 <_vfprintf_r+0xc48>
4200d67d:	a02182        	l32i	a8, a1, 0x280
4200d680:	094c      	movi.n	a9, 64
4200d682:	061882        	l16ui	a8, a8, 12
4200d685:	208890        	or	a8, a8, a9
4200d688:	a02192        	l32i	a9, a1, 0x280
4200d68b:	065982        	s16i	a8, a9, 12
4200d68e:	07ee86        	j	4200f64c <_vfprintf_r+0x2bec>
4200d691:	a22182        	l32i	a8, a1, 0x288
4200d694:	160826        	beqi	a8, -1, 4200d6ae <_vfprintf_r+0xc4e>
4200d697:	18ec      	bnez.n	a8, 4200d6bc <_vfprintf_r+0xc5c>
4200d699:	b9c482        	addi	a8, a4, -71
4200d69c:	c8dc      	bnez.n	a8, 4200d6bc <_vfprintf_r+0xc5c>
4200d69e:	a96182        	s32i	a8, a1, 0x2a4
4200d6a1:	180c      	movi.n	a8, 1
4200d6a3:	000386        	j	4200d6b5 <_vfprintf_r+0xc55>
4200d6a6:	820000        	mull	a0, a0, a0
4200d6a9:	c69f21        	l32r	a2, 41fff128 <_coredump_iram_end+0x1c7d128>
4200d6ac:	0c0003        	lsi	f0, a0, 48
4200d6af:	8208      	l32i.n	a0, a2, 32
4200d6b1:	0ca961        	l32r	a6, 41fd0958 <_coredump_iram_end+0x1c4e958>
4200d6b4:	8268      	l32i.n	a6, a2, 32
4200d6b6:	46a261        	l32r	a6, 41fdf140 <_coredump_iram_end+0x1c5d140>
4200d6b9:	000001        	l32r	a0, 41fcd6bc <_coredump_iram_end+0x1c4b6bc>
4200d6bc:	080c      	movi.n	a8, 0
4200d6be:	a96182        	s32i	a8, a1, 0x2a4
4200d6c1:	00a182        	movi	a8, 0x100
4200d6c4:	208380        	or	a8, a3, a8
4200d6c7:	af6182        	s32i	a8, a1, 0x2bc
4200d6ca:	a72182        	l32i	a8, a1, 0x29c
4200d6cd:	0188d6        	bgez	a8, 4200d6e9 <_vfprintf_r+0xc89>
4200d6d0:	a62182        	l32i	a8, a1, 0x298
4200d6d3:	a72192        	l32i	a9, a1, 0x29c
4200d6d6:	b26182        	s32i	a8, a1, 0x2c8
4200d6d9:	f87c      	movi.n	a8, -1
4200d6db:	018810        	slli	a8, a8, 31
4200d6de:	308980        	xor	a8, a9, a8
4200d6e1:	b36182        	s32i	a8, a1, 0x2cc
4200d6e4:	d82c      	movi.n	a8, 45
4200d6e6:	000406        	j	4200d6fa <_vfprintf_r+0xc9a>
4200d6e9:	98a282        	movi	a8, 0x298
4200d6ec:	881a      	add.n	a8, a8, a1
4200d6ee:	1898      	l32i.n	a9, a8, 4
4200d6f0:	0888      	l32i.n	a8, a8, 0
4200d6f2:	b36192        	s32i	a9, a1, 0x2cc
4200d6f5:	b26182        	s32i	a8, a1, 0x2c8
4200d6f8:	080c      	movi.n	a8, 0
4200d6fa:	b96182        	s32i	a8, a1, 0x2e4
4200d6fd:	184c      	movi.n	a8, 65
4200d6ff:	021487        	beq	a4, a8, 4200d705 <_vfprintf_r+0xca5>
4200d702:	005e06        	j	4200d87e <_vfprintf_r+0xe1e>
4200d705:	c8a282        	movi	a8, 0x2c8
4200d708:	881a      	add.n	a8, a8, a1
4200d70a:	08a8      	l32i.n	a10, a8, 0
4200d70c:	18b8      	l32i.n	a11, a8, 4
4200d70e:	54a2c2        	movi	a12, 0x254
4200d711:	c1ca      	add.n	a12, a1, a12
4200d713:	201110        	or	a1, a1, a1
4200d716:	044765        	call8	42011b8c <frexp>
4200d719:	ffa0d2        	movi	a13, 255
4200d71c:	00a0c2        	movi	a12, 0
4200d71f:	01dda0        	slli	a13, a13, 22
4200d722:	cdc081        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
4200d725:	0008e0        	callx8	a8
4200d728:	a461a2        	s32i	a10, a1, 0x290
4200d72b:	a561b2        	s32i	a11, a1, 0x294
4200d72e:	0c0c      	movi.n	a12, 0
4200d730:	00a0d2        	movi	a13, 0
4200d733:	cdbd81        	l32r	a8, 42000e28 <_stext+0xe08> (4000228c <__eqdf2>)
4200d736:	0008e0        	callx8	a8
4200d739:	3acc      	bnez.n	a10, 4200d740 <_vfprintf_r+0xce0>
4200d73b:	180c      	movi.n	a8, 1
4200d73d:	956182        	s32i	a8, a1, 0x254
4200d740:	cdaf91        	l32r	a9, 42000dfc <_stext+0xddc> (3c0295d5 <_ZTISt12out_of_range+0x149>)
4200d743:	61a082        	movi	a8, 97
4200d746:	ab6192        	s32i	a9, a1, 0x2ac
4200d749:	a32192        	l32i	a9, a1, 0x28c
4200d74c:	059987        	bne	a9, a8, 4200d755 <_vfprintf_r+0xcf5>
4200d74f:	cdaa81        	l32r	a8, 42000df8 <_stext+0xdd8> (3c0295c4 <_ZTISt12out_of_range+0x138>)
4200d752:	ab6182        	s32i	a8, a1, 0x2ac
4200d755:	a22182        	l32i	a8, a1, 0x288
4200d758:	9f2162        	l32i	a6, a1, 0x27c
4200d75b:	880b      	addi.n	a8, a8, -1
4200d75d:	000046        	j	4200d762 <_vfprintf_r+0xd02>
4200d760:	058d      	mov.n	a8, a5
4200d762:	ba6182        	s32i	a8, a1, 0x2e8
4200d765:	90a282        	movi	a8, 0x290
4200d768:	881a      	add.n	a8, a8, a1
4200d76a:	08a8      	l32i.n	a10, a8, 0
4200d76c:	18b8      	l32i.n	a11, a8, 4
4200d76e:	03a4d2        	movi	a13, 0x403
4200d771:	00a0c2        	movi	a12, 0
4200d774:	01ddc0        	slli	a13, a13, 20
4200d777:	cdab81        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
4200d77a:	0008e0        	callx8	a8
4200d77d:	a561b2        	s32i	a11, a1, 0x294
4200d780:	a461a2        	s32i	a10, a1, 0x290
4200d783:	cdaa81        	l32r	a8, 42000e2c <_stext+0xe0c> (400022d4 <__fixdfsi>)
4200d786:	0008e0        	callx8	a8
4200d789:	0a5d      	mov.n	a5, a10
4200d78b:	cda981        	l32r	a8, 42000e30 <_stext+0xe10> (40002334 <__floatsidf>)
4200d78e:	0008e0        	callx8	a8
4200d791:	90a282        	movi	a8, 0x290
4200d794:	881a      	add.n	a8, a8, a1
4200d796:	0acd      	mov.n	a12, a10
4200d798:	0bdd      	mov.n	a13, a11
4200d79a:	08a8      	l32i.n	a10, a8, 0
4200d79c:	18b8      	l32i.n	a11, a8, 4
4200d79e:	cda581        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
4200d7a1:	0008e0        	callx8	a8
4200d7a4:	ab2182        	l32i	a8, a1, 0x2ac
4200d7a7:	a461a2        	s32i	a10, a1, 0x290
4200d7aa:	a85a      	add.n	a10, a8, a5
4200d7ac:	000aa2        	l8ui	a10, a10, 0
4200d7af:	ba2182        	l32i	a8, a1, 0x2e8
4200d7b2:	0046a2        	s8i	a10, a6, 0
4200d7b5:	a561b2        	s32i	a11, a1, 0x294
4200d7b8:	661b      	addi.n	a6, a6, 1
4200d7ba:	1f0826        	beqi	a8, -1, 4200d7dd <_vfprintf_r+0xd7d>
4200d7bd:	580b      	addi.n	a5, a8, -1
4200d7bf:	90a282        	movi	a8, 0x290
4200d7c2:	881a      	add.n	a8, a8, a1
4200d7c4:	08a8      	l32i.n	a10, a8, 0
4200d7c6:	18b8      	l32i.n	a11, a8, 4
4200d7c8:	00a0c2        	movi	a12, 0
4200d7cb:	00a0d2        	movi	a13, 0
4200d7ce:	cd9a81        	l32r	a8, 42000e38 <_stext+0xe18> (4000246c <__nedf2>)
4200d7d1:	0008e0        	callx8	a8
4200d7d4:	ba2182        	l32i	a8, a1, 0x2e8
4200d7d7:	f85a56        	bnez	a10, 4200d760 <_vfprintf_r+0xd00>
4200d7da:	001c06        	j	4200d84e <_vfprintf_r+0xdee>
4200d7dd:	90a282        	movi	a8, 0x290
4200d7e0:	881a      	add.n	a8, a8, a1
4200d7e2:	cd8bd1        	l32r	a13, 42000e10 <_stext+0xdf0> (3fe00000 <ets_ops_table_ptr+0x110004>)
4200d7e5:	08a8      	l32i.n	a10, a8, 0
4200d7e7:	18b8      	l32i.n	a11, a8, 4
4200d7e9:	0c0c      	movi.n	a12, 0
4200d7eb:	cd9481        	l32r	a8, 42000e3c <_stext+0xe1c> (400023a0 <__gtdf2>)
4200d7ee:	0008e0        	callx8	a8
4200d7f1:	191ae6        	bgei	a10, 1, 4200d80e <_vfprintf_r+0xdae>
4200d7f4:	90a282        	movi	a8, 0x290
4200d7f7:	881a      	add.n	a8, a8, a1
4200d7f9:	cd85d1        	l32r	a13, 42000e10 <_stext+0xdf0> (3fe00000 <ets_ops_table_ptr+0x110004>)
4200d7fc:	08a8      	l32i.n	a10, a8, 0
4200d7fe:	18b8      	l32i.n	a11, a8, 4
4200d800:	0c0c      	movi.n	a12, 0
4200d802:	cd8981        	l32r	a8, 42000e28 <_stext+0xe08> (4000228c <__eqdf2>)
4200d805:	0008e0        	callx8	a8
4200d808:	040a56        	bnez	a10, 4200d84c <_vfprintf_r+0xdec>
4200d80b:	3d6507        	bbci	a5, 0, 4200d84c <_vfprintf_r+0xdec>
4200d80e:	ab2182        	l32i	a8, a1, 0x2ac
4200d811:	906162        	s32i	a6, a1, 0x240
4200d814:	0f0882        	l8ui	a8, a8, 15
4200d817:	0b3c      	movi.n	a11, 48
4200d819:	000086        	j	4200d81f <_vfprintf_r+0xdbf>
4200d81c:	0049b2        	s8i	a11, a9, 0
4200d81f:	902192        	l32i	a9, a1, 0x240
4200d822:	990b      	addi.n	a9, a9, -1
4200d824:	906192        	s32i	a9, a1, 0x240
4200d827:	0009a2        	l8ui	a10, a9, 0
4200d82a:	ee1a87        	beq	a10, a8, 4200d81c <_vfprintf_r+0xdbc>
4200d82d:	8a1b      	addi.n	a8, a10, 1
4200d82f:	9b3c      	movi.n	a11, 57
4200d831:	748080        	extui	a8, a8, 0, 8
4200d834:	059ab7        	bne	a10, a11, 4200d83d <_vfprintf_r+0xddd>
4200d837:	ab2182        	l32i	a8, a1, 0x2ac
4200d83a:	0a0882        	l8ui	a8, a8, 10
4200d83d:	004982        	s8i	a8, a9, 0
4200d840:	000ac6        	j	4200d86f <_vfprintf_r+0xe0f>
4200d843:	49c200        	s32e	a0, a2, -16
4200d846:	991b00        	lsi	f0, a11, 0x264
4200d849:	0001c6        	j	4200d854 <_vfprintf_r+0xdf4>
4200d84c:	f87c      	movi.n	a8, -1
4200d84e:	069d      	mov.n	a9, a6
4200d850:	b68a      	add.n	a11, a6, a8
4200d852:	0c3c      	movi.n	a12, 48
4200d854:	c0ab90        	sub	a10, a11, a9
4200d857:	fe9ad6        	bgez	a10, 4200d844 <_vfprintf_r+0xde4>
4200d85a:	f97c      	movi.n	a9, -1
4200d85c:	729890        	lsi	f9, a8, 0x1c8
4200d85f:	990b      	addi.n	a9, a9, -1
4200d861:	609090        	neg	a9, a9
4200d864:	749090        	extui	a9, a9, 0, 8
4200d867:	0a0c      	movi.n	a10, 0
4200d869:	098c      	beqz.n	a9, 4200d86d <_vfprintf_r+0xe0d>
4200d86b:	a81b      	addi.n	a10, a8, 1
4200d86d:	66aa      	add.n	a6, a6, a10
4200d86f:	9f2182        	l32i	a8, a1, 0x27c
4200d872:	c08680        	sub	a8, a6, a8
4200d875:	a46182        	s32i	a8, a1, 0x290
4200d878:	952162        	l32i	a6, a1, 0x254
4200d87b:	003e46        	j	4200d978 <_vfprintf_r+0xf18>
4200d87e:	684c      	movi.n	a8, 70
4200d880:	a22162        	l32i	a6, a1, 0x288
4200d883:	3e0c      	movi.n	a14, 3
4200d885:	0f1487        	beq	a4, a8, 4200d898 <_vfprintf_r+0xe38>
4200d888:	bbc462        	addi	a6, a4, -69
4200d88b:	a22182        	l32i	a8, a1, 0x288
4200d88e:	40f660        	nsau	a6, a6
4200d891:	416560        	srli	a6, a6, 5
4200d894:	668a      	add.n	a6, a6, a8
4200d896:	2e0c      	movi.n	a14, 2
4200d898:	10c182        	addi	a8, a1, 16
4200d89b:	30a292        	movi	a9, 0x230
4200d89e:	989a      	add.n	a9, a8, a9
4200d8a0:	2199      	s32i.n	a9, a1, 8
4200d8a2:	40a292        	movi	a9, 0x240
4200d8a5:	989a      	add.n	a9, a8, a9
4200d8a7:	1199      	s32i.n	a9, a1, 4
4200d8a9:	44a292        	movi	a9, 0x244
4200d8ac:	889a      	add.n	a8, a8, a9
4200d8ae:	0189      	s32i.n	a8, a1, 0
4200d8b0:	c8a282        	movi	a8, 0x2c8
4200d8b3:	881a      	add.n	a8, a8, a1
4200d8b5:	08c8      	l32i.n	a12, a8, 0
4200d8b7:	18d8      	l32i.n	a13, a8, 4
4200d8b9:	a121a2        	l32i	a10, a1, 0x284
4200d8bc:	06fd      	mov.n	a15, a6
4200d8be:	201110        	or	a1, a1, a1
4200d8c1:	044625        	call8	42011d24 <_dtoa_r>
4200d8c4:	9f61a2        	s32i	a10, a1, 0x27c
4200d8c7:	784c      	movi.n	a8, 71
4200d8c9:	239487        	bne	a4, a8, 4200d8f0 <_vfprintf_r+0xe90>
4200d8cc:	18e307        	bbsi	a3, 0, 4200d8e8 <_vfprintf_r+0xe88>
4200d8cf:	902182        	l32i	a8, a1, 0x240
4200d8d2:	9f2192        	l32i	a9, a1, 0x27c
4200d8d5:	952162        	l32i	a6, a1, 0x254
4200d8d8:	c08890        	sub	a8, a8, a9
4200d8db:	a46182        	s32i	a8, a1, 0x290
4200d8de:	784c      	movi.n	a8, 71
4200d8e0:	7a1487        	beq	a4, a8, 4200d95e <_vfprintf_r+0xefe>
4200d8e3:	002446        	j	4200d978 <_vfprintf_r+0xf18>
4200d8e6:	820000        	mull	a0, a0, a0
4200d8e9:	6a9f21        	l32r	a2, 41fe8368 <_coredump_iram_end+0x1c66368>
4200d8ec:	0658      	l32i.n	a5, a6, 0
4200d8ee:	0e          	.byte	0xe
4200d8ef:	218200        	srai	a8, a0, 2
4200d8f2:	9f          	.byte	0x9f
4200d8f3:	586a      	add.n	a5, a8, a6
4200d8f5:	684c      	movi.n	a8, 70
4200d8f7:	2e9487        	bne	a4, a8, 4200d929 <_vfprintf_r+0xec9>
4200d8fa:	9f2182        	l32i	a8, a1, 0x27c
4200d8fd:	000882        	l8ui	a8, a8, 0
4200d900:	d0c882        	addi	a8, a8, -48
4200d903:	d8dc      	bnez.n	a8, 4200d924 <_vfprintf_r+0xec4>
4200d905:	c8a282        	movi	a8, 0x2c8
4200d908:	881a      	add.n	a8, a8, a1
4200d90a:	08a8      	l32i.n	a10, a8, 0
4200d90c:	18b8      	l32i.n	a11, a8, 4
4200d90e:	00a0c2        	movi	a12, 0
4200d911:	00a0d2        	movi	a13, 0
4200d914:	cd4981        	l32r	a8, 42000e38 <_stext+0xe18> (4000246c <__nedf2>)
4200d917:	0008e0        	callx8	a8
4200d91a:	6a8c      	beqz.n	a10, 4200d924 <_vfprintf_r+0xec4>
4200d91c:	660b      	addi.n	a6, a6, -1
4200d91e:	606060        	neg	a6, a6
4200d921:	956162        	s32i	a6, a1, 0x254
4200d924:	952182        	l32i	a8, a1, 0x254
4200d927:	558a      	add.n	a5, a5, a8
4200d929:	c8a282        	movi	a8, 0x2c8
4200d92c:	881a      	add.n	a8, a8, a1
4200d92e:	08a8      	l32i.n	a10, a8, 0
4200d930:	18b8      	l32i.n	a11, a8, 4
4200d932:	0c0c      	movi.n	a12, 0
4200d934:	0d0c      	movi.n	a13, 0
4200d936:	cd3c81        	l32r	a8, 42000e28 <_stext+0xe08> (4000228c <__eqdf2>)
4200d939:	0008e0        	callx8	a8
4200d93c:	0adc      	bnez.n	a10, 4200d950 <_vfprintf_r+0xef0>
4200d93e:	906152        	s32i	a5, a1, 0x240
4200d941:	0002c6        	j	4200d950 <_vfprintf_r+0xef0>
4200d944:	a81b      	addi.n	a10, a8, 1
4200d946:	9061a2        	s32i	a10, a1, 0x240
4200d949:	004892        	s8i	a9, a8, 0
4200d94c:	000086        	j	4200d952 <_vfprintf_r+0xef2>
4200d94f:	093c00        	l32e	a0, a12, -52
4200d952:	902182        	l32i	a8, a1, 0x240
4200d955:	eb3857        	bltu	a8, a5, 4200d944 <_vfprintf_r+0xee4>
4200d958:	ffdcc6        	j	4200d8cf <_vfprintf_r+0xe6f>
4200d95b:	000000        	ill
4200d95e:	d87c      	movi.n	a8, -3
4200d960:	082687        	blt	a6, a8, 4200d96c <_vfprintf_r+0xf0c>
4200d963:	a22182        	l32i	a8, a1, 0x288
4200d966:	022867        	blt	a8, a6, 4200d96c <_vfprintf_r+0xf0c>
4200d969:	0048c6        	j	4200da90 <_vfprintf_r+0x1030>
4200d96c:	a32182        	l32i	a8, a1, 0x28c
4200d96f:	fec882        	addi	a8, a8, -2
4200d972:	a36182        	s32i	a8, a1, 0x28c
4200d975:	0001c6        	j	4200d980 <_vfprintf_r+0xf20>
4200d978:	684c      	movi.n	a8, 70
4200d97a:	029487        	bne	a4, a8, 4200d980 <_vfprintf_r+0xf20>
4200d97d:	004606        	j	4200da99 <_vfprintf_r+0x1039>
4200d980:	a32192        	l32i	a9, a1, 0x28c
4200d983:	dfafb2        	movi	a11, -33
4200d986:	10b9b0        	and	a11, a9, a11
4200d989:	8ca292        	movi	a9, 0x28c
4200d98c:	991a      	add.n	a9, a9, a1
4200d98e:	860b      	addi.n	a8, a6, -1
4200d990:	0009a2        	l8ui	a10, a9, 0
4200d993:	956182        	s32i	a8, a1, 0x254
4200d996:	194c      	movi.n	a9, 65
4200d998:	049b97        	bne	a11, a9, 4200d9a0 <_vfprintf_r+0xf40>
4200d99b:	aafb      	addi.n	a10, a10, 15
4200d99d:	74a0a0        	extui	a10, a10, 0, 8
4200d9a0:	10c192        	addi	a9, a1, 16
4200d9a3:	02d9c2        	addmi	a12, a9, 0x200
4200d9a6:	374ca2        	s8i	a10, a12, 55
4200d9a9:	ba2c      	movi.n	a10, 43
4200d9ab:	0068d6        	bgez	a8, 4200d9b5 <_vfprintf_r+0xf55>
4200d9ae:	860b      	addi.n	a8, a6, -1
4200d9b0:	608080        	neg	a8, a8
4200d9b3:	da2c      	movi.n	a10, 45
4200d9b5:	02d9c2        	addmi	a12, a9, 0x200
4200d9b8:	384ca2        	s8i	a10, a12, 56
4200d9bb:	9a0c      	movi.n	a10, 9
4200d9bd:	70aa87        	bge	a10, a8, 4200da31 <_vfprintf_r+0xfd1>
4200d9c0:	37a2a2        	movi	a10, 0x237
4200d9c3:	cacee1        	l32r	a14, 420004fc <_stext+0x4dc> (cccccccd <_rtc_reserved_end+0x6cbccccd>)
4200d9c6:	8099a0        	add	a9, a9, a10
4200d9c9:	63a0d2        	movi	a13, 99
4200d9cc:	a2b8e0        	muluh	a11, a8, a14
4200d9cf:	09cd      	mov.n	a12, a9
4200d9d1:	41b3b0        	srli	a11, a11, 3
4200d9d4:	a0abb0        	addx4	a10, a11, a11
4200d9d7:	aaaa      	add.n	a10, a10, a10
4200d9d9:	c0a8a0        	sub	a10, a8, a10
4200d9dc:	30caa2        	addi	a10, a10, 48
4200d9df:	990b      	addi.n	a9, a9, -1
4200d9e1:	0049a2        	s8i	a10, a9, 0
4200d9e4:	08ad      	mov.n	a10, a8
4200d9e6:	0b8d      	mov.n	a8, a11
4200d9e8:	e02da7        	blt	a13, a10, 4200d9cc <_vfprintf_r+0xf6c>
4200d9eb:	30cb82        	addi	a8, a11, 48
4200d9ee:	fecc92        	addi	a9, a12, -2
4200d9f1:	10c1a2        	addi	a10, a1, 16
4200d9f4:	004982        	s8i	a8, a9, 0
4200d9f7:	39a2b2        	movi	a11, 0x239
4200d9fa:	30a282        	movi	a8, 0x230
4200d9fd:	baba      	add.n	a11, a10, a11
4200d9ff:	aa8a      	add.n	a10, a10, a8
4200da01:	0bdd      	mov.n	a13, a11
4200da03:	8a7b      	addi.n	a8, a10, 7
4200da05:	000246        	j	4200da12 <_vfprintf_r+0xfb2>
4200da08:	0009e2        	l8ui	a14, a9, 0
4200da0b:	991b      	addi.n	a9, a9, 1
4200da0d:	004de2        	s8i	a14, a13, 0
4200da10:	dd1b      	addi.n	a13, a13, 1
4200da12:	f23987        	bltu	a9, a8, 4200da08 <_vfprintf_r+0xfa8>
4200da15:	fecc92        	addi	a9, a12, -2
4200da18:	628890        	lsi	f9, a8, 0x188
4200da1b:	880b      	addi.n	a8, a8, -1
4200da1d:	608080        	neg	a8, a8
4200da20:	748080        	extui	a8, a8, 0, 8
4200da23:	090c      	movi.n	a9, 0
4200da25:	388c      	beqz.n	a8, 4200da2c <_vfprintf_r+0xfcc>
4200da27:	aa9b      	addi.n	a10, a10, 9
4200da29:	c09ac0        	sub	a9, a10, a12
4200da2c:	99ba      	add.n	a9, a9, a11
4200da2e:	000706        	j	4200da4e <_vfprintf_r+0xfee>
4200da31:	39a2a2        	movi	a10, 0x239
4200da34:	1d4c      	movi.n	a13, 65
4200da36:	a9aa      	add.n	a10, a9, a10
4200da38:	091bd7        	beq	a11, a13, 4200da45 <_vfprintf_r+0xfe5>
4200da3b:	0a3c      	movi.n	a10, 48
4200da3d:	394ca2        	s8i	a10, a12, 57
4200da40:	3aa2a2        	movi	a10, 0x23a
4200da43:	a9aa      	add.n	a10, a9, a10
4200da45:	30c882        	addi	a8, a8, 48
4200da48:	01ca92        	addi	a9, a10, 1
4200da4b:	004a82        	s8i	a8, a10, 0
4200da4e:	47a282        	movi	a8, 0x247
4200da51:	808180        	add	a8, a1, a8
4200da54:	c08980        	sub	a8, a9, a8
4200da57:	a42192        	l32i	a9, a1, 0x290
4200da5a:	b76182        	s32i	a8, a1, 0x2dc
4200da5d:	808890        	add	a8, a8, a9
4200da60:	a26182        	s32i	a8, a1, 0x288
4200da63:	0229e6        	bgei	a9, 2, 4200da69 <_vfprintf_r+0x1009>
4200da66:	0a6307        	bbci	a3, 0, 4200da74 <_vfprintf_r+0x1014>
4200da69:	a22182        	l32i	a8, a1, 0x288
4200da6c:	ad2192        	l32i	a9, a1, 0x2b4
4200da6f:	889a      	add.n	a8, a8, a9
4200da71:	a26182        	s32i	a8, a1, 0x288
4200da74:	ffab82        	movi	a8, 0xfffffbff
4200da77:	108380        	and	a8, a3, a8
4200da7a:	00a192        	movi	a9, 0x100
4200da7d:	208890        	or	a8, a8, a9
4200da80:	af6182        	s32i	a8, a1, 0x2bc
4200da83:	080c      	movi.n	a8, 0
4200da85:	ab6182        	s32i	a8, a1, 0x2ac
4200da88:	050c      	movi.n	a5, 0
4200da8a:	060c      	movi.n	a6, 0
4200da8c:	003806        	j	4200db70 <_vfprintf_r+0x1110>
4200da8f:	218200        	srai	a8, a0, 2
4200da92:	a687a4        	lsi	f10, a7, 0x298
4200da95:	862d      	lsi	f2, a6, 24
4200da97:	0f          	.byte	0xf
4200da98:	219200        	srai	a9, a0, 2
4200da9b:	8030a2        	lsi	f10, a0, 0x200
4200da9e:	889004        	lsi	f0, a0, 0x220
4200daa1:	16a620        	lsi	f2, a6, 88
4200daa4:	160a      	add.n	a1, a6, a0
4200daa6:	0508      	l32i.n	a0, a5, 0
4200daa8:	ad2182        	l32i	a8, a1, 0x2b4
4200daab:	868a      	add.n	a8, a6, a8
4200daad:	000286        	j	4200dabb <_vfprintf_r+0x105b>
4200dab0:	051816        	beqz	a8, 4200db05 <_vfprintf_r+0x10a5>
4200dab3:	ad2182        	l32i	a8, a1, 0x2b4
4200dab6:	a22192        	l32i	a9, a1, 0x288
4200dab9:	881b      	addi.n	a8, a8, 1
4200dabb:	898a      	add.n	a8, a9, a8
4200dabd:	a26182        	s32i	a8, a1, 0x288
4200dac0:	000e06        	j	4200dafc <_vfprintf_r+0x109c>
4200dac3:	a08200        	addx4	a8, a2, a0
4200dac6:	618267        	bany	a2, a6, 4200db2b <_vfprintf_r+0x10cb>
4200dac9:	6162a3        	lsi	f10, a2, 0x184
4200dacc:	2192a2        	l16si	a10, a2, 66
4200dacf:	8dad      	lsi	f10, a13, 52
4200dad1:	e30706        	j	420066f1 <usb_serial_jtag_start_select+0xe1>
4200dad4:	1e          	.byte	0x1e
4200dad5:	000dc6        	j	4200db10 <_vfprintf_r+0x10b0>
4200dad8:	a42182        	l32i	a8, a1, 0x290
4200dadb:	ad2192        	l32i	a9, a1, 0x2b4
4200dade:	889a      	add.n	a8, a8, a9
4200dae0:	a26182        	s32i	a8, a1, 0x288
4200dae3:	67a082        	movi	a8, 103
4200dae6:	a36182        	s32i	a8, a1, 0x28c
4200dae9:	2316e6        	bgei	a6, 1, 4200db10 <_vfprintf_r+0x10b0>
4200daec:	860b      	addi.n	a8, a6, -1
4200daee:	a22192        	l32i	a9, a1, 0x288
4200daf1:	608080        	neg	a8, a8
4200daf4:	898a      	add.n	a8, a9, a8
4200daf6:	0004c6        	j	4200db0d <_vfprintf_r+0x10ad>
4200daf9:	a26162        	s32i	a6, a1, 0x288
4200dafc:	66a082        	movi	a8, 102
4200daff:	a36182        	s32i	a8, a1, 0x28c
4200db02:	000286        	j	4200db10 <_vfprintf_r+0x10b0>
4200db05:	66a082        	movi	a8, 102
4200db08:	a36182        	s32i	a8, a1, 0x28c
4200db0b:	180c      	movi.n	a8, 1
4200db0d:	a26182        	s32i	a8, a1, 0x288
4200db10:	00a452        	movi	a5, 0x400
4200db13:	080c      	movi.n	a8, 0
4200db15:	105350        	and	a5, a3, a5
4200db18:	ab6182        	s32i	a8, a1, 0x2ac
4200db1b:	051516        	beqz	a5, 4200db70 <_vfprintf_r+0x1110>
4200db1e:	050c      	movi.n	a5, 0
4200db20:	2d16e6        	bgei	a6, 1, 4200db51 <_vfprintf_r+0x10f1>
4200db23:	001246        	j	4200db70 <_vfprintf_r+0x1110>
4200db26:	670000        	lsi	f0, a0, 0x19c
4200db29:	31a8      	l32i.n	a10, a1, 12
4200db2b:	c06680        	sub	a6, a6, a8
4200db2e:	aa2182        	l32i	a8, a1, 0x2a8
4200db31:	010882        	l8ui	a8, a8, 1
4200db34:	b88c      	beqz.n	a8, 4200db43 <_vfprintf_r+0x10e3>
4200db36:	aa2182        	l32i	a8, a1, 0x2a8
4200db39:	551b      	addi.n	a5, a5, 1
4200db3b:	881b      	addi.n	a8, a8, 1
4200db3d:	aa6182        	s32i	a8, a1, 0x2a8
4200db40:	000406        	j	4200db54 <_vfprintf_r+0x10f4>
4200db43:	ab2182        	l32i	a8, a1, 0x2ac
4200db46:	881b      	addi.n	a8, a8, 1
4200db48:	ab6182        	s32i	a8, a1, 0x2ac
4200db4b:	000146        	j	4200db54 <_vfprintf_r+0x10f4>
4200db4e:	000000        	ill
4200db51:	ffa092        	movi	a9, 255
4200db54:	aa2182        	l32i	a8, a1, 0x2a8
4200db57:	000882        	l8ui	a8, a8, 0
4200db5a:	ca9897        	bne	a8, a9, 4200db28 <_vfprintf_r+0x10c8>
4200db5d:	ab2182        	l32i	a8, a1, 0x2ac
4200db60:	b02192        	l32i	a9, a1, 0x2c0
4200db63:	858a      	add.n	a8, a5, a8
4200db65:	828890        	mull	a8, a8, a9
4200db68:	a22192        	l32i	a9, a1, 0x288
4200db6b:	889a      	add.n	a8, a8, a9
4200db6d:	a26182        	s32i	a8, a1, 0x288
4200db70:	b92182        	l32i	a8, a1, 0x2e4
4200db73:	68cc      	bnez.n	a8, 4200db7d <_vfprintf_r+0x111d>
4200db75:	af2132        	l32i	a3, a1, 0x2bc
4200db78:	040c      	movi.n	a4, 0
4200db7a:	03f6c6        	j	4200eb59 <_vfprintf_r+0x20f9>
4200db7d:	10c182        	addi	a8, a1, 16
4200db80:	02d882        	addmi	a8, a8, 0x200
4200db83:	d92c      	movi.n	a9, 45
4200db85:	524892        	s8i	a9, a8, 82
4200db88:	fffa46        	j	4200db75 <_vfprintf_r+0x1115>
4200db8b:	218200        	srai	a8, a0, 2
4200db8e:	c1e297        	bbsi	a2, 9, 4200db53 <_vfprintf_r+0x10f3>
4200db91:	e35710        	lsi	f1, a7, 0x38c
4200db94:	2c0602        	l8ui	a0, a6, 44
4200db97:	c4ac00        	extui	a10, a0, 12, 13
4200db9a:	07a687        	bge	a6, a8, 4200dba5 <_vfprintf_r+0x1145>
4200db9d:	b0e6e0        	addx8	a14, a6, a14
4200dba0:	0e98      	l32i.n	a9, a14, 0
4200dba2:	000706        	j	4200dbc2 <_vfprintf_r+0x1162>
4200dba5:	48a282        	movi	a8, 0x248
4200dba8:	8e8a      	add.n	a8, a14, a8
4200dbaa:	4ca2d2        	movi	a13, 0x24c
4200dbad:	60a2c2        	movi	a12, 0x260
4200dbb0:	0189      	s32i.n	a8, a1, 0
4200dbb2:	01def2        	addmi	a15, a14, 0x100
4200dbb5:	deda      	add.n	a13, a14, a13
4200dbb7:	ceca      	add.n	a12, a14, a12
4200dbb9:	05bd      	mov.n	a11, a5
4200dbbb:	06ad      	mov.n	a10, a6
4200dbbd:	fe9d25        	call8	4200c590 <get_arg$isra$0>
4200dbc0:	0a98      	l32i.n	a9, a10, 0
4200dbc2:	07ad      	mov.n	a10, a7
4200dbc4:	001d06        	j	4200dc3c <_vfprintf_r+0x11dc>
4200dbc7:	a71b00        	lsi	f0, a11, 0x29c
4200dbca:	07a787        	bge	a7, a8, 4200dbd5 <_vfprintf_r+0x1175>
4200dbcd:	b0e6e0        	addx8	a14, a6, a14
4200dbd0:	0e98      	l32i.n	a9, a14, 0
4200dbd2:	001986        	j	4200dc3c <_vfprintf_r+0x11dc>
4200dbd5:	9a2eb2        	l32i	a11, a14, 0x268
4200dbd8:	fc1c      	movi.n	a12, 31
4200dbda:	02dee2        	addmi	a14, a14, 0x200
4200dbdd:	9b4b      	addi.n	a9, a11, 4
4200dbdf:	322c87        	blt	a12, a8, 4200dc15 <_vfprintf_r+0x11b5>
4200dbe2:	c81b      	addi.n	a12, a8, 1
4200dbe4:	9761c2        	s32i	a12, a1, 0x25c
4200dbe7:	1a6e92        	s32i	a9, a14, 104
4200dbea:	8c1c      	movi.n	a12, 24
4200dbec:	052c97        	blt	a12, a9, 4200dbf5 <_vfprintf_r+0x1195>
4200dbef:	192eb2        	l32i	a11, a14, 100
4200dbf2:	000406        	j	4200dc06 <_vfprintf_r+0x11a6>
4200dbf5:	012cb7        	blt	a12, a11, 4200dbfa <_vfprintf_r+0x119a>
4200dbf8:	492c      	movi.n	a9, 36
4200dbfa:	10c1b2        	addi	a11, a1, 16
4200dbfd:	02dbb2        	addmi	a11, a11, 0x200
4200dc00:	182bb2        	l32i	a11, a11, 96
4200dc03:	9e6192        	s32i	a9, a1, 0x278
4200dc06:	bb9a      	add.n	a11, a11, a9
4200dc08:	fccbb2        	addi	a11, a11, -4
4200dc0b:	0b98      	l32i.n	a9, a11, 0
4200dc0d:	b08810        	addx8	a8, a8, a1
4200dc10:	4899      	s32i.n	a9, a8, 16
4200dc12:	000986        	j	4200dc3c <_vfprintf_r+0x11dc>
4200dc15:	1a6e92        	s32i	a9, a14, 104
4200dc18:	881c      	movi.n	a8, 24
4200dc1a:	062897        	blt	a8, a9, 4200dc24 <_vfprintf_r+0x11c4>
4200dc1d:	192e82        	l32i	a8, a14, 100
4200dc20:	000446        	j	4200dc35 <_vfprintf_r+0x11d5>
4200dc23:	28b700        	lsi	f0, a7, 160
4200dc26:	492c01        	l32r	a0, 41fe00d8 <_coredump_iram_end+0x1c5e0d8>
4200dc29:	10c182        	addi	a8, a1, 16
4200dc2c:	02d882        	addmi	a8, a8, 0x200
4200dc2f:	182882        	l32i	a8, a8, 96
4200dc32:	9e6192        	s32i	a9, a1, 0x278
4200dc35:	889a      	add.n	a8, a8, a9
4200dc37:	fcc882        	addi	a8, a8, -4
4200dc3a:	0898      	l32i.n	a9, a8, 0
4200dc3c:	ae2182        	l32i	a8, a1, 0x2b8
4200dc3f:	0989      	s32i.n	a8, a9, 0
4200dc41:	318f80        	srai	a8, a8, 31
4200dc44:	1989      	s32i.n	a8, a9, 4
4200dc46:	002e06        	j	4200dd02 <_vfprintf_r+0x12a2>
4200dc49:	026347        	bbci	a3, 4, 4200dc4f <_vfprintf_r+0x11ef>
4200dc4c:	005b46        	j	4200ddbd <_vfprintf_r+0x135d>
4200dc4f:	02e367        	bbsi	a3, 6, 4200dc55 <_vfprintf_r+0x11f5>
4200dc52:	002c86        	j	4200dd08 <_vfprintf_r+0x12a8>
4200dc55:	f4ac      	beqz.n	a4, 4200dc88 <_vfprintf_r+0x1228>
4200dc57:	0aa687        	bge	a6, a8, 4200dc65 <_vfprintf_r+0x1205>
4200dc5a:	b0e6e0        	addx8	a14, a6, a14
4200dc5d:	0e98      	l32i.n	a9, a14, 0
4200dc5f:	0007c6        	j	4200dc82 <_vfprintf_r+0x1222>
4200dc62:	000000        	ill
4200dc65:	48a282        	movi	a8, 0x248
4200dc68:	8e8a      	add.n	a8, a14, a8
4200dc6a:	4ca2d2        	movi	a13, 0x24c
4200dc6d:	60a2c2        	movi	a12, 0x260
4200dc70:	0189      	s32i.n	a8, a1, 0
4200dc72:	01def2        	addmi	a15, a14, 0x100
4200dc75:	deda      	add.n	a13, a14, a13
4200dc77:	ceca      	add.n	a12, a14, a12
4200dc79:	05bd      	mov.n	a11, a5
4200dc7b:	06ad      	mov.n	a10, a6
4200dc7d:	fe9125        	call8	4200c590 <get_arg$isra$0>
4200dc80:	0a98      	l32i.n	a9, a10, 0
4200dc82:	07ad      	mov.n	a10, a7
4200dc84:	001d06        	j	4200dcfc <_vfprintf_r+0x129c>
4200dc87:	a71b00        	lsi	f0, a11, 0x29c
4200dc8a:	07a787        	bge	a7, a8, 4200dc95 <_vfprintf_r+0x1235>
4200dc8d:	b0e6e0        	addx8	a14, a6, a14
4200dc90:	0e98      	l32i.n	a9, a14, 0
4200dc92:	001986        	j	4200dcfc <_vfprintf_r+0x129c>
4200dc95:	9a2eb2        	l32i	a11, a14, 0x268
4200dc98:	fc1c      	movi.n	a12, 31
4200dc9a:	02dee2        	addmi	a14, a14, 0x200
4200dc9d:	9b4b      	addi.n	a9, a11, 4
4200dc9f:	322c87        	blt	a12, a8, 4200dcd5 <_vfprintf_r+0x1275>
4200dca2:	c81b      	addi.n	a12, a8, 1
4200dca4:	9761c2        	s32i	a12, a1, 0x25c
4200dca7:	1a6e92        	s32i	a9, a14, 104
4200dcaa:	8c1c      	movi.n	a12, 24
4200dcac:	052c97        	blt	a12, a9, 4200dcb5 <_vfprintf_r+0x1255>
4200dcaf:	192eb2        	l32i	a11, a14, 100
4200dcb2:	000406        	j	4200dcc6 <_vfprintf_r+0x1266>
4200dcb5:	012cb7        	blt	a12, a11, 4200dcba <_vfprintf_r+0x125a>
4200dcb8:	492c      	movi.n	a9, 36
4200dcba:	10c1b2        	addi	a11, a1, 16
4200dcbd:	02dbb2        	addmi	a11, a11, 0x200
4200dcc0:	182bb2        	l32i	a11, a11, 96
4200dcc3:	9e6192        	s32i	a9, a1, 0x278
4200dcc6:	bb9a      	add.n	a11, a11, a9
4200dcc8:	fccbb2        	addi	a11, a11, -4
4200dccb:	0b98      	l32i.n	a9, a11, 0
4200dccd:	b08810        	addx8	a8, a8, a1
4200dcd0:	4899      	s32i.n	a9, a8, 16
4200dcd2:	000986        	j	4200dcfc <_vfprintf_r+0x129c>
4200dcd5:	1a6e92        	s32i	a9, a14, 104
4200dcd8:	881c      	movi.n	a8, 24
4200dcda:	062897        	blt	a8, a9, 4200dce4 <_vfprintf_r+0x1284>
4200dcdd:	192e82        	l32i	a8, a14, 100
4200dce0:	000446        	j	4200dcf5 <_vfprintf_r+0x1295>
4200dce3:	28b700        	lsi	f0, a7, 160
4200dce6:	492c01        	l32r	a0, 41fe0198 <_coredump_iram_end+0x1c5e198>
4200dce9:	10c182        	addi	a8, a1, 16
4200dcec:	02d882        	addmi	a8, a8, 0x200
4200dcef:	182882        	l32i	a8, a8, 96
4200dcf2:	9e6192        	s32i	a9, a1, 0x278
4200dcf5:	889a      	add.n	a8, a8, a9
4200dcf7:	fcc882        	addi	a8, a8, -4
4200dcfa:	0898      	l32i.n	a9, a8, 0
4200dcfc:	ae2182        	l32i	a8, a1, 0x2b8
4200dcff:	005982        	s16i	a8, a9, 0
4200dd02:	0a7d      	mov.n	a7, a10
4200dd04:	fbaa86        	j	4200cbb2 <_vfprintf_r+0x152>
4200dd07:	e39700        	lsi	f0, a7, 0x38c
4200dd0a:	2b8602        	lsi	f0, a6, 172
4200dd0d:	e4ac00        	extui	a10, a0, 12, 15
4200dd10:	09a687        	bge	a6, a8, 4200dd1d <_vfprintf_r+0x12bd>
4200dd13:	b0e6e0        	addx8	a14, a6, a14
4200dd16:	0e98      	l32i.n	a9, a14, 0
4200dd18:	000786        	j	4200dd3a <_vfprintf_r+0x12da>
4200dd1b:	820000        	mull	a0, a0, a0
4200dd1e:	8a48a2        	s8i	a10, a8, 138
4200dd21:	8e          	.byte	0x8e
4200dd22:	4ca2d2        	movi	a13, 0x24c
4200dd25:	60a2c2        	movi	a12, 0x260
4200dd28:	0189      	s32i.n	a8, a1, 0
4200dd2a:	01def2        	addmi	a15, a14, 0x100
4200dd2d:	deda      	add.n	a13, a14, a13
4200dd2f:	ceca      	add.n	a12, a14, a12
4200dd31:	05bd      	mov.n	a11, a5
4200dd33:	06ad      	mov.n	a10, a6
4200dd35:	fe85a5        	call8	4200c590 <get_arg$isra$0>
4200dd38:	0a98      	l32i.n	a9, a10, 0
4200dd3a:	07ad      	mov.n	a10, a7
4200dd3c:	001d06        	j	4200ddb4 <_vfprintf_r+0x1354>
4200dd3f:	a71b00        	lsi	f0, a11, 0x29c
4200dd42:	07a787        	bge	a7, a8, 4200dd4d <_vfprintf_r+0x12ed>
4200dd45:	b0e6e0        	addx8	a14, a6, a14
4200dd48:	0e98      	l32i.n	a9, a14, 0
4200dd4a:	001986        	j	4200ddb4 <_vfprintf_r+0x1354>
4200dd4d:	9a2eb2        	l32i	a11, a14, 0x268
4200dd50:	fc1c      	movi.n	a12, 31
4200dd52:	02dee2        	addmi	a14, a14, 0x200
4200dd55:	9b4b      	addi.n	a9, a11, 4
4200dd57:	322c87        	blt	a12, a8, 4200dd8d <_vfprintf_r+0x132d>
4200dd5a:	c81b      	addi.n	a12, a8, 1
4200dd5c:	9761c2        	s32i	a12, a1, 0x25c
4200dd5f:	1a6e92        	s32i	a9, a14, 104
4200dd62:	8c1c      	movi.n	a12, 24
4200dd64:	052c97        	blt	a12, a9, 4200dd6d <_vfprintf_r+0x130d>
4200dd67:	192eb2        	l32i	a11, a14, 100
4200dd6a:	000406        	j	4200dd7e <_vfprintf_r+0x131e>
4200dd6d:	012cb7        	blt	a12, a11, 4200dd72 <_vfprintf_r+0x1312>
4200dd70:	492c      	movi.n	a9, 36
4200dd72:	10c1b2        	addi	a11, a1, 16
4200dd75:	02dbb2        	addmi	a11, a11, 0x200
4200dd78:	182bb2        	l32i	a11, a11, 96
4200dd7b:	9e6192        	s32i	a9, a1, 0x278
4200dd7e:	bb9a      	add.n	a11, a11, a9
4200dd80:	fccbb2        	addi	a11, a11, -4
4200dd83:	0b98      	l32i.n	a9, a11, 0
4200dd85:	b08810        	addx8	a8, a8, a1
4200dd88:	4899      	s32i.n	a9, a8, 16
4200dd8a:	000986        	j	4200ddb4 <_vfprintf_r+0x1354>
4200dd8d:	1a6e92        	s32i	a9, a14, 104
4200dd90:	881c      	movi.n	a8, 24
4200dd92:	062897        	blt	a8, a9, 4200dd9c <_vfprintf_r+0x133c>
4200dd95:	192e82        	l32i	a8, a14, 100
4200dd98:	000446        	j	4200ddad <_vfprintf_r+0x134d>
4200dd9b:	28b700        	lsi	f0, a7, 160
4200dd9e:	492c01        	l32r	a0, 41fe0250 <_coredump_iram_end+0x1c5e250>
4200dda1:	10c182        	addi	a8, a1, 16
4200dda4:	02d882        	addmi	a8, a8, 0x200
4200dda7:	182882        	l32i	a8, a8, 96
4200ddaa:	9e6192        	s32i	a9, a1, 0x278
4200ddad:	889a      	add.n	a8, a8, a9
4200ddaf:	fcc882        	addi	a8, a8, -4
4200ddb2:	0898      	l32i.n	a9, a8, 0
4200ddb4:	ae2182        	l32i	a8, a1, 0x2b8
4200ddb7:	004982        	s8i	a8, a9, 0
4200ddba:	ffd106        	j	4200dd02 <_vfprintf_r+0x12a2>
4200ddbd:	f4ac      	beqz.n	a4, 4200ddf0 <_vfprintf_r+0x1390>
4200ddbf:	0aa687        	bge	a6, a8, 4200ddcd <_vfprintf_r+0x136d>
4200ddc2:	b0e6e0        	addx8	a14, a6, a14
4200ddc5:	0e98      	l32i.n	a9, a14, 0
4200ddc7:	0007c6        	j	4200ddea <_vfprintf_r+0x138a>
4200ddca:	000000        	ill
4200ddcd:	48a282        	movi	a8, 0x248
4200ddd0:	8e8a      	add.n	a8, a14, a8
4200ddd2:	4ca2d2        	movi	a13, 0x24c
4200ddd5:	60a2c2        	movi	a12, 0x260
4200ddd8:	0189      	s32i.n	a8, a1, 0
4200ddda:	01def2        	addmi	a15, a14, 0x100
4200dddd:	deda      	add.n	a13, a14, a13
4200dddf:	ceca      	add.n	a12, a14, a12
4200dde1:	05bd      	mov.n	a11, a5
4200dde3:	06ad      	mov.n	a10, a6
4200dde5:	fe7aa5        	call8	4200c590 <get_arg$isra$0>
4200dde8:	0a98      	l32i.n	a9, a10, 0
4200ddea:	07ad      	mov.n	a10, a7
4200ddec:	001d06        	j	4200de64 <_vfprintf_r+0x1404>
4200ddef:	a71b00        	lsi	f0, a11, 0x29c
4200ddf2:	07a787        	bge	a7, a8, 4200ddfd <_vfprintf_r+0x139d>
4200ddf5:	b0e6e0        	addx8	a14, a6, a14
4200ddf8:	0e98      	l32i.n	a9, a14, 0
4200ddfa:	001986        	j	4200de64 <_vfprintf_r+0x1404>
4200ddfd:	9a2eb2        	l32i	a11, a14, 0x268
4200de00:	fc1c      	movi.n	a12, 31
4200de02:	02dee2        	addmi	a14, a14, 0x200
4200de05:	9b4b      	addi.n	a9, a11, 4
4200de07:	322c87        	blt	a12, a8, 4200de3d <_vfprintf_r+0x13dd>
4200de0a:	c81b      	addi.n	a12, a8, 1
4200de0c:	9761c2        	s32i	a12, a1, 0x25c
4200de0f:	1a6e92        	s32i	a9, a14, 104
4200de12:	8c1c      	movi.n	a12, 24
4200de14:	052c97        	blt	a12, a9, 4200de1d <_vfprintf_r+0x13bd>
4200de17:	192eb2        	l32i	a11, a14, 100
4200de1a:	000406        	j	4200de2e <_vfprintf_r+0x13ce>
4200de1d:	012cb7        	blt	a12, a11, 4200de22 <_vfprintf_r+0x13c2>
4200de20:	492c      	movi.n	a9, 36
4200de22:	10c1b2        	addi	a11, a1, 16
4200de25:	02dbb2        	addmi	a11, a11, 0x200
4200de28:	182bb2        	l32i	a11, a11, 96
4200de2b:	9e6192        	s32i	a9, a1, 0x278
4200de2e:	bb9a      	add.n	a11, a11, a9
4200de30:	fccbb2        	addi	a11, a11, -4
4200de33:	0b98      	l32i.n	a9, a11, 0
4200de35:	b08810        	addx8	a8, a8, a1
4200de38:	4899      	s32i.n	a9, a8, 16
4200de3a:	000986        	j	4200de64 <_vfprintf_r+0x1404>
4200de3d:	1a6e92        	s32i	a9, a14, 104
4200de40:	881c      	movi.n	a8, 24
4200de42:	062897        	blt	a8, a9, 4200de4c <_vfprintf_r+0x13ec>
4200de45:	192e82        	l32i	a8, a14, 100
4200de48:	000446        	j	4200de5d <_vfprintf_r+0x13fd>
4200de4b:	28b700        	lsi	f0, a7, 160
4200de4e:	492c01        	l32r	a0, 41fe0300 <_coredump_iram_end+0x1c5e300>
4200de51:	10c182        	addi	a8, a1, 16
4200de54:	02d882        	addmi	a8, a8, 0x200
4200de57:	182882        	l32i	a8, a8, 96
4200de5a:	9e6192        	s32i	a9, a1, 0x278
4200de5d:	889a      	add.n	a8, a8, a9
4200de5f:	fcc882        	addi	a8, a8, -4
4200de62:	0898      	l32i.n	a9, a8, 0
4200de64:	ae2182        	l32i	a8, a1, 0x2b8
4200de67:	0989      	s32i.n	a8, a9, 0
4200de69:	ffa546        	j	4200dd02 <_vfprintf_r+0x12a2>
4200de6c:	081c      	movi.n	a8, 16
4200de6e:	203380        	or	a3, a3, a8
4200de71:	972192        	l32i	a9, a1, 0x25c
4200de74:	10c1e2        	addi	a14, a1, 16
4200de77:	02e357        	bbsi	a3, 5, 4200de7d <_vfprintf_r+0x141d>
4200de7a:	002fc6        	j	4200df3d <_vfprintf_r+0x14dd>
4200de7d:	04bc      	beqz.n	a4, 4200deb1 <_vfprintf_r+0x1451>
4200de7f:	09a697        	bge	a6, a9, 4200de8c <_vfprintf_r+0x142c>
4200de82:	b0e6e0        	addx8	a14, a6, a14
4200de85:	0e58      	l32i.n	a5, a14, 0
4200de87:	1e48      	l32i.n	a4, a14, 4
4200de89:	0007c6        	j	4200deac <_vfprintf_r+0x144c>
4200de8c:	48a282        	movi	a8, 0x248
4200de8f:	8e8a      	add.n	a8, a14, a8
4200de91:	4ca2d2        	movi	a13, 0x24c
4200de94:	60a2c2        	movi	a12, 0x260
4200de97:	05bd      	mov.n	a11, a5
4200de99:	0189      	s32i.n	a8, a1, 0
4200de9b:	01def2        	addmi	a15, a14, 0x100
4200de9e:	deda      	add.n	a13, a14, a13
4200dea0:	ceca      	add.n	a12, a14, a12
4200dea2:	20a660        	or	a10, a6, a6
4200dea5:	fe6ea5        	call8	4200c590 <get_arg$isra$0>
4200dea8:	0a58      	l32i.n	a5, a10, 0
4200deaa:	1a48      	l32i.n	a4, a10, 4
4200deac:	078d      	mov.n	a8, a7
4200deae:	00a806        	j	4200e152 <_vfprintf_r+0x16f2>
4200deb1:	871b      	addi.n	a8, a7, 1
4200deb3:	09a797        	bge	a7, a9, 4200dec0 <_vfprintf_r+0x1460>
4200deb6:	b0e6e0        	addx8	a14, a6, a14
4200deb9:	0e58      	l32i.n	a5, a14, 0
4200debb:	1e48      	l32i.n	a4, a14, 4
4200debd:	00a446        	j	4200e152 <_vfprintf_r+0x16f2>
4200dec0:	9a2eb2        	l32i	a11, a14, 0x268
4200dec3:	8a7c      	movi.n	a10, -8
4200dec5:	bb7b      	addi.n	a11, a11, 7
4200dec7:	10bba0        	and	a11, a11, a10
4200deca:	fc1c      	movi.n	a12, 31
4200decc:	02dee2        	addmi	a14, a14, 0x200
4200decf:	ab8b      	addi.n	a10, a11, 8
4200ded1:	3b2c97        	blt	a12, a9, 4200df10 <_vfprintf_r+0x14b0>
4200ded4:	c91b      	addi.n	a12, a9, 1
4200ded6:	9761c2        	s32i	a12, a1, 0x25c
4200ded9:	1a6ea2        	s32i	a10, a14, 104
4200dedc:	8c1c      	movi.n	a12, 24
4200dede:	062ca7        	blt	a12, a10, 4200dee8 <_vfprintf_r+0x1488>
4200dee1:	192eb2        	l32i	a11, a14, 100
4200dee4:	000446        	j	4200def9 <_vfprintf_r+0x1499>
4200dee7:	2cb700        	lsi	f0, a7, 176
4200deea:	8a2c01        	l32r	a0, 41ff079c <_coredump_iram_end+0x1c6e79c>
4200deed:	10c1b2        	addi	a11, a1, 16
4200def0:	02dbb2        	addmi	a11, a11, 0x200
4200def3:	182bb2        	l32i	a11, a11, 96
4200def6:	9e61a2        	s32i	a10, a1, 0x278
4200def9:	abaa      	add.n	a10, a11, a10
4200defb:	f8caa2        	addi	a10, a10, -8
4200defe:	0a58      	l32i.n	a5, a10, 0
4200df00:	1a48      	l32i.n	a4, a10, 4
4200df02:	10c1a2        	addi	a10, a1, 16
4200df05:	b099a0        	addx8	a9, a9, a10
4200df08:	0959      	s32i.n	a5, a9, 0
4200df0a:	1949      	s32i.n	a4, a9, 4
4200df0c:	009086        	j	4200e152 <_vfprintf_r+0x16f2>
4200df0f:	6ea200        	f64rnd	a10, a2, a0, 2
4200df12:	1c1a      	add.n	a1, a12, a1
4200df14:	a789      	s32i.n	a8, a7, 40
4200df16:	0729      	s32i.n	a2, a7, 0
4200df18:	192e92        	l32i	a9, a14, 100
4200df1b:	000486        	j	4200df31 <_vfprintf_r+0x14d1>
4200df1e:	b70000        	lsi	f0, a0, 0x2dc
4200df21:	0129      	s32i.n	a2, a1, 0
4200df23:	8a2c      	movi.n	a10, 40
4200df25:	10c192        	addi	a9, a1, 16
4200df28:	02d992        	addmi	a9, a9, 0x200
4200df2b:	182992        	l32i	a9, a9, 96
4200df2e:	9e61a2        	s32i	a10, a1, 0x278
4200df31:	99aa      	add.n	a9, a9, a10
4200df33:	f8c992        	addi	a9, a9, -8
4200df36:	0958      	l32i.n	a5, a9, 0
4200df38:	1948      	l32i.n	a4, a9, 4
4200df3a:	008506        	j	4200e152 <_vfprintf_r+0x16f2>
4200df3d:	036347        	bbci	a3, 4, 4200df44 <_vfprintf_r+0x14e4>
4200df40:	005a06        	j	4200e0ac <_vfprintf_r+0x164c>
4200df43:	e36700        	lsi	f0, a7, 0x38c
4200df46:	2b4602        	s8i	a0, a6, 43
4200df49:	c4ac00        	extui	a10, a0, 12, 13
4200df4c:	09a697        	bge	a6, a9, 4200df59 <_vfprintf_r+0x14f9>
4200df4f:	b0e6e0        	addx8	a14, a6, a14
4200df52:	001e52        	l16ui	a5, a14, 0
4200df55:	005f46        	j	4200e0d6 <_vfprintf_r+0x1676>
4200df58:	a28200        	muluh	a8, a2, a0
4200df5b:	8a48      	l32i.n	a4, a10, 32
4200df5d:	8e          	.byte	0x8e
4200df5e:	4ca2d2        	movi	a13, 0x24c
4200df61:	60a2c2        	movi	a12, 0x260
4200df64:	05bd      	mov.n	a11, a5
4200df66:	0189      	s32i.n	a8, a1, 0
4200df68:	01def2        	addmi	a15, a14, 0x100
4200df6b:	deda      	add.n	a13, a14, a13
4200df6d:	ceca      	add.n	a12, a14, a12
4200df6f:	06ad      	mov.n	a10, a6
4200df71:	fe61e5        	call8	4200c590 <get_arg$isra$0>
4200df74:	001a52        	l16ui	a5, a10, 0
4200df77:	0056c6        	j	4200e0d6 <_vfprintf_r+0x1676>
4200df7a:	871b      	addi.n	a8, a7, 1
4200df7c:	08a797        	bge	a7, a9, 4200df88 <_vfprintf_r+0x1528>
4200df7f:	b0e6e0        	addx8	a14, a6, a14
4200df82:	001e52        	l16ui	a5, a14, 0
4200df85:	0071c6        	j	4200e150 <_vfprintf_r+0x16f0>
4200df88:	9a2eb2        	l32i	a11, a14, 0x268
4200df8b:	fc1c      	movi.n	a12, 31
4200df8d:	02dee2        	addmi	a14, a14, 0x200
4200df90:	ab4b      	addi.n	a10, a11, 4
4200df92:	362c97        	blt	a12, a9, 4200dfcc <_vfprintf_r+0x156c>
4200df95:	c91b      	addi.n	a12, a9, 1
4200df97:	9761c2        	s32i	a12, a1, 0x25c
4200df9a:	1a6ea2        	s32i	a10, a14, 104
4200df9d:	8c1c      	movi.n	a12, 24
4200df9f:	052ca7        	blt	a12, a10, 4200dfa8 <_vfprintf_r+0x1548>
4200dfa2:	192eb2        	l32i	a11, a14, 100
4200dfa5:	000406        	j	4200dfb9 <_vfprintf_r+0x1559>
4200dfa8:	012cb7        	blt	a12, a11, 4200dfad <_vfprintf_r+0x154d>
4200dfab:	4a2c      	movi.n	a10, 36
4200dfad:	10c1b2        	addi	a11, a1, 16
4200dfb0:	02dbb2        	addmi	a11, a11, 0x200
4200dfb3:	182bb2        	l32i	a11, a11, 96
4200dfb6:	9e61a2        	s32i	a10, a1, 0x278
4200dfb9:	bbaa      	add.n	a11, a11, a10
4200dfbb:	fccbb2        	addi	a11, a11, -4
4200dfbe:	0b58      	l32i.n	a5, a11, 0
4200dfc0:	b09910        	addx8	a9, a9, a1
4200dfc3:	4959      	s32i.n	a5, a9, 16
4200dfc5:	f45050        	extui	a5, a5, 0, 16
4200dfc8:	006106        	j	4200e150 <_vfprintf_r+0x16f0>
4200dfcb:	6ea200        	f64rnd	a10, a2, a0, 2
4200dfce:	1c1a      	add.n	a1, a12, a1
4200dfd0:	a789      	s32i.n	a8, a7, 40
4200dfd2:	0729      	s32i.n	a2, a7, 0
4200dfd4:	192e92        	l32i	a9, a14, 100
4200dfd7:	000486        	j	4200dfed <_vfprintf_r+0x158d>
4200dfda:	b70000        	lsi	f0, a0, 0x2dc
4200dfdd:	0129      	s32i.n	a2, a1, 0
4200dfdf:	4a2c      	movi.n	a10, 36
4200dfe1:	10c192        	addi	a9, a1, 16
4200dfe4:	02d992        	addmi	a9, a9, 0x200
4200dfe7:	182992        	l32i	a9, a9, 96
4200dfea:	9e61a2        	s32i	a10, a1, 0x278
4200dfed:	99aa      	add.n	a9, a9, a10
4200dfef:	fcc992        	addi	a9, a9, -4
4200dff2:	001952        	l16ui	a5, a9, 0
4200dff5:	0055c6        	j	4200e150 <_vfprintf_r+0x16f0>
4200dff8:	02e397        	bbsi	a3, 9, 4200dffe <_vfprintf_r+0x159e>
4200dffb:	002b46        	j	4200e0ac <_vfprintf_r+0x164c>
4200dffe:	c4ac      	beqz.n	a4, 4200e02e <_vfprintf_r+0x15ce>
4200e000:	09a697        	bge	a6, a9, 4200e00d <_vfprintf_r+0x15ad>
4200e003:	b0e6e0        	addx8	a14, a6, a14
4200e006:	000e52        	l8ui	a5, a14, 0
4200e009:	003246        	j	4200e0d6 <_vfprintf_r+0x1676>
4200e00c:	a28200        	muluh	a8, a2, a0
4200e00f:	8a48      	l32i.n	a4, a10, 32
4200e011:	8e          	.byte	0x8e
4200e012:	4ca2d2        	movi	a13, 0x24c
4200e015:	60a2c2        	movi	a12, 0x260
4200e018:	05bd      	mov.n	a11, a5
4200e01a:	0189      	s32i.n	a8, a1, 0
4200e01c:	01def2        	addmi	a15, a14, 0x100
4200e01f:	deda      	add.n	a13, a14, a13
4200e021:	ceca      	add.n	a12, a14, a12
4200e023:	06ad      	mov.n	a10, a6
4200e025:	fe56a5        	call8	4200c590 <get_arg$isra$0>
4200e028:	000a52        	l8ui	a5, a10, 0
4200e02b:	0029c6        	j	4200e0d6 <_vfprintf_r+0x1676>
4200e02e:	871b      	addi.n	a8, a7, 1
4200e030:	08a797        	bge	a7, a9, 4200e03c <_vfprintf_r+0x15dc>
4200e033:	b0e6e0        	addx8	a14, a6, a14
4200e036:	000e52        	l8ui	a5, a14, 0
4200e039:	0044c6        	j	4200e150 <_vfprintf_r+0x16f0>
4200e03c:	9a2eb2        	l32i	a11, a14, 0x268
4200e03f:	fc1c      	movi.n	a12, 31
4200e041:	02dee2        	addmi	a14, a14, 0x200
4200e044:	ab4b      	addi.n	a10, a11, 4
4200e046:	362c97        	blt	a12, a9, 4200e080 <_vfprintf_r+0x1620>
4200e049:	c91b      	addi.n	a12, a9, 1
4200e04b:	9761c2        	s32i	a12, a1, 0x25c
4200e04e:	1a6ea2        	s32i	a10, a14, 104
4200e051:	8c1c      	movi.n	a12, 24
4200e053:	052ca7        	blt	a12, a10, 4200e05c <_vfprintf_r+0x15fc>
4200e056:	192eb2        	l32i	a11, a14, 100
4200e059:	000406        	j	4200e06d <_vfprintf_r+0x160d>
4200e05c:	012cb7        	blt	a12, a11, 4200e061 <_vfprintf_r+0x1601>
4200e05f:	4a2c      	movi.n	a10, 36
4200e061:	10c1b2        	addi	a11, a1, 16
4200e064:	02dbb2        	addmi	a11, a11, 0x200
4200e067:	182bb2        	l32i	a11, a11, 96
4200e06a:	9e61a2        	s32i	a10, a1, 0x278
4200e06d:	bbaa      	add.n	a11, a11, a10
4200e06f:	fccbb2        	addi	a11, a11, -4
4200e072:	0b58      	l32i.n	a5, a11, 0
4200e074:	b09910        	addx8	a9, a9, a1
4200e077:	4959      	s32i.n	a5, a9, 16
4200e079:	745050        	extui	a5, a5, 0, 8
4200e07c:	003406        	j	4200e150 <_vfprintf_r+0x16f0>
4200e07f:	6ea200        	f64rnd	a10, a2, a0, 2
4200e082:	1c1a      	add.n	a1, a12, a1
4200e084:	a789      	s32i.n	a8, a7, 40
4200e086:	0729      	s32i.n	a2, a7, 0
4200e088:	192e92        	l32i	a9, a14, 100
4200e08b:	000486        	j	4200e0a1 <_vfprintf_r+0x1641>
4200e08e:	b70000        	lsi	f0, a0, 0x2dc
4200e091:	0129      	s32i.n	a2, a1, 0
4200e093:	4a2c      	movi.n	a10, 36
4200e095:	10c192        	addi	a9, a1, 16
4200e098:	02d992        	addmi	a9, a9, 0x200
4200e09b:	182992        	l32i	a9, a9, 96
4200e09e:	9e61a2        	s32i	a10, a1, 0x278
4200e0a1:	99aa      	add.n	a9, a9, a10
4200e0a3:	fcc992        	addi	a9, a9, -4
4200e0a6:	000952        	l8ui	a5, a9, 0
4200e0a9:	0028c6        	j	4200e150 <_vfprintf_r+0x16f0>
4200e0ac:	c4ac      	beqz.n	a4, 4200e0dc <_vfprintf_r+0x167c>
4200e0ae:	07a697        	bge	a6, a9, 4200e0b9 <_vfprintf_r+0x1659>
4200e0b1:	b0e6e0        	addx8	a14, a6, a14
4200e0b4:	0e58      	l32i.n	a5, a14, 0
4200e0b6:	000706        	j	4200e0d6 <_vfprintf_r+0x1676>
4200e0b9:	48a282        	movi	a8, 0x248
4200e0bc:	8e8a      	add.n	a8, a14, a8
4200e0be:	4ca2d2        	movi	a13, 0x24c
4200e0c1:	60a2c2        	movi	a12, 0x260
4200e0c4:	05bd      	mov.n	a11, a5
4200e0c6:	0189      	s32i.n	a8, a1, 0
4200e0c8:	01def2        	addmi	a15, a14, 0x100
4200e0cb:	deda      	add.n	a13, a14, a13
4200e0cd:	ceca      	add.n	a12, a14, a12
4200e0cf:	06ad      	mov.n	a10, a6
4200e0d1:	fe4be5        	call8	4200c590 <get_arg$isra$0>
4200e0d4:	0a58      	l32i.n	a5, a10, 0
4200e0d6:	078d      	mov.n	a8, a7
4200e0d8:	001d06        	j	4200e150 <_vfprintf_r+0x16f0>
4200e0db:	871b00        	lsi	f0, a11, 0x21c
4200e0de:	07a797        	bge	a7, a9, 4200e0e9 <_vfprintf_r+0x1689>
4200e0e1:	b0e6e0        	addx8	a14, a6, a14
4200e0e4:	0e58      	l32i.n	a5, a14, 0
4200e0e6:	001986        	j	4200e150 <_vfprintf_r+0x16f0>
4200e0e9:	9a2eb2        	l32i	a11, a14, 0x268
4200e0ec:	fc1c      	movi.n	a12, 31
4200e0ee:	02dee2        	addmi	a14, a14, 0x200
4200e0f1:	ab4b      	addi.n	a10, a11, 4
4200e0f3:	322c97        	blt	a12, a9, 4200e129 <_vfprintf_r+0x16c9>
4200e0f6:	c91b      	addi.n	a12, a9, 1
4200e0f8:	9761c2        	s32i	a12, a1, 0x25c
4200e0fb:	1a6ea2        	s32i	a10, a14, 104
4200e0fe:	8c1c      	movi.n	a12, 24
4200e100:	052ca7        	blt	a12, a10, 4200e109 <_vfprintf_r+0x16a9>
4200e103:	192eb2        	l32i	a11, a14, 100
4200e106:	000406        	j	4200e11a <_vfprintf_r+0x16ba>
4200e109:	012cb7        	blt	a12, a11, 4200e10e <_vfprintf_r+0x16ae>
4200e10c:	4a2c      	movi.n	a10, 36
4200e10e:	10c1b2        	addi	a11, a1, 16
4200e111:	02dbb2        	addmi	a11, a11, 0x200
4200e114:	182bb2        	l32i	a11, a11, 96
4200e117:	9e61a2        	s32i	a10, a1, 0x278
4200e11a:	bbaa      	add.n	a11, a11, a10
4200e11c:	fccbb2        	addi	a11, a11, -4
4200e11f:	0b58      	l32i.n	a5, a11, 0
4200e121:	b09910        	addx8	a9, a9, a1
4200e124:	4959      	s32i.n	a5, a9, 16
4200e126:	000986        	j	4200e150 <_vfprintf_r+0x16f0>
4200e129:	1a6ea2        	s32i	a10, a14, 104
4200e12c:	891c      	movi.n	a9, 24
4200e12e:	0629a7        	blt	a9, a10, 4200e138 <_vfprintf_r+0x16d8>
4200e131:	192e92        	l32i	a9, a14, 100
4200e134:	000446        	j	4200e149 <_vfprintf_r+0x16e9>
4200e137:	29b700        	lsi	f0, a7, 164
4200e13a:	4a2c01        	l32r	a0, 41fe09ec <_coredump_iram_end+0x1c5e9ec>
4200e13d:	10c192        	addi	a9, a1, 16
4200e140:	02d992        	addmi	a9, a9, 0x200
4200e143:	182992        	l32i	a9, a9, 96
4200e146:	9e61a2        	s32i	a10, a1, 0x278
4200e149:	99aa      	add.n	a9, a9, a10
4200e14b:	fcc992        	addi	a9, a9, -4
4200e14e:	0958      	l32i.n	a5, a9, 0
4200e150:	040c      	movi.n	a4, 0
4200e152:	ffab92        	movi	a9, 0xfffffbff
4200e155:	103390        	and	a3, a3, a9
4200e158:	090c      	movi.n	a9, 0
4200e15a:	01f686        	j	4200e938 <_vfprintf_r+0x1ed8>
4200e15d:	21a200        	srai	a10, a0, 2
4200e160:	c1e297        	bbsi	a2, 9, 4200e125 <_vfprintf_r+0x16c5>
4200e163:	c4ac10        	extui	a10, a1, 12, 13
4200e166:	07a6a7        	bge	a6, a10, 4200e171 <_vfprintf_r+0x1711>
4200e169:	b0e6e0        	addx8	a14, a6, a14
4200e16c:	0e58      	l32i.n	a5, a14, 0
4200e16e:	000706        	j	4200e18e <_vfprintf_r+0x172e>
4200e171:	48a282        	movi	a8, 0x248
4200e174:	8e8a      	add.n	a8, a14, a8
4200e176:	4ca2d2        	movi	a13, 0x24c
4200e179:	60a2c2        	movi	a12, 0x260
4200e17c:	05bd      	mov.n	a11, a5
4200e17e:	0189      	s32i.n	a8, a1, 0
4200e180:	01def2        	addmi	a15, a14, 0x100
4200e183:	deda      	add.n	a13, a14, a13
4200e185:	ceca      	add.n	a12, a14, a12
4200e187:	06ad      	mov.n	a10, a6
4200e189:	fe4065        	call8	4200c590 <get_arg$isra$0>
4200e18c:	0a58      	l32i.n	a5, a10, 0
4200e18e:	078d      	mov.n	a8, a7
4200e190:	001d06        	j	4200e208 <_vfprintf_r+0x17a8>
4200e193:	871b00        	lsi	f0, a11, 0x21c
4200e196:	07a7a7        	bge	a7, a10, 4200e1a1 <_vfprintf_r+0x1741>
4200e199:	b0e6e0        	addx8	a14, a6, a14
4200e19c:	0e58      	l32i.n	a5, a14, 0
4200e19e:	001986        	j	4200e208 <_vfprintf_r+0x17a8>
4200e1a1:	9a2eb2        	l32i	a11, a14, 0x268
4200e1a4:	fc1c      	movi.n	a12, 31
4200e1a6:	02dee2        	addmi	a14, a14, 0x200
4200e1a9:	9b4b      	addi.n	a9, a11, 4
4200e1ab:	322ca7        	blt	a12, a10, 4200e1e1 <_vfprintf_r+0x1781>
4200e1ae:	ca1b      	addi.n	a12, a10, 1
4200e1b0:	9761c2        	s32i	a12, a1, 0x25c
4200e1b3:	1a6e92        	s32i	a9, a14, 104
4200e1b6:	8c1c      	movi.n	a12, 24
4200e1b8:	052c97        	blt	a12, a9, 4200e1c1 <_vfprintf_r+0x1761>
4200e1bb:	192eb2        	l32i	a11, a14, 100
4200e1be:	000406        	j	4200e1d2 <_vfprintf_r+0x1772>
4200e1c1:	012cb7        	blt	a12, a11, 4200e1c6 <_vfprintf_r+0x1766>
4200e1c4:	492c      	movi.n	a9, 36
4200e1c6:	10c1b2        	addi	a11, a1, 16
4200e1c9:	02dbb2        	addmi	a11, a11, 0x200
4200e1cc:	182bb2        	l32i	a11, a11, 96
4200e1cf:	9e6192        	s32i	a9, a1, 0x278
4200e1d2:	bb9a      	add.n	a11, a11, a9
4200e1d4:	fccbb2        	addi	a11, a11, -4
4200e1d7:	0b58      	l32i.n	a5, a11, 0
4200e1d9:	b09a10        	addx8	a9, a10, a1
4200e1dc:	4959      	s32i.n	a5, a9, 16
4200e1de:	000986        	j	4200e208 <_vfprintf_r+0x17a8>
4200e1e1:	1a6e92        	s32i	a9, a14, 104
4200e1e4:	8a1c      	movi.n	a10, 24
4200e1e6:	062a97        	blt	a10, a9, 4200e1f0 <_vfprintf_r+0x1790>
4200e1e9:	192ea2        	l32i	a10, a14, 100
4200e1ec:	000446        	j	4200e201 <_vfprintf_r+0x17a1>
4200e1ef:	2ab700        	mul.s	f11, f7, f0
4200e1f2:	492c01        	l32r	a0, 41fe06a4 <_coredump_iram_end+0x1c5e6a4>
4200e1f5:	10c1a2        	addi	a10, a1, 16
4200e1f8:	02daa2        	addmi	a10, a10, 0x200
4200e1fb:	182aa2        	l32i	a10, a10, 96
4200e1fe:	9e6192        	s32i	a9, a1, 0x278
4200e201:	aa9a      	add.n	a10, a10, a9
4200e203:	fccaa2        	addi	a10, a10, -4
4200e206:	0a58      	l32i.n	a5, a10, 0
4200e208:	290c      	movi.n	a9, 2
4200e20a:	203390        	or	a3, a3, a9
4200e20d:	10c192        	addi	a9, a1, 16
4200e210:	02d992        	addmi	a9, a9, 0x200
4200e213:	0a3c      	movi.n	a10, 48
4200e215:	5049a2        	s8i	a10, a9, 80
4200e218:	78a0a2        	movi	a10, 120
4200e21b:	5149a2        	s8i	a10, a9, 81
4200e21e:	caf691        	l32r	a9, 42000df8 <_stext+0xdd8> (3c0295c4 <_ZTISt12out_of_range+0x138>)
4200e221:	78a0a2        	movi	a10, 120
4200e224:	b86192        	s32i	a9, a1, 0x2e0
4200e227:	040c      	movi.n	a4, 0
4200e229:	290c      	movi.n	a9, 2
4200e22b:	a361a2        	s32i	a10, a1, 0x28c
4200e22e:	01c186        	j	4200e938 <_vfprintf_r+0x1ed8>
4200e231:	219200        	srai	a9, a0, 2
4200e234:	c1e297        	bbsi	a2, 9, 4200e1f9 <_vfprintf_r+0x1799>
4200e237:	c4ac10        	extui	a10, a1, 12, 13
4200e23a:	07a697        	bge	a6, a9, 4200e245 <_vfprintf_r+0x17e5>
4200e23d:	b0e6e0        	addx8	a14, a6, a14
4200e240:	0e88      	l32i.n	a8, a14, 0
4200e242:	000706        	j	4200e262 <_vfprintf_r+0x1802>
4200e245:	48a282        	movi	a8, 0x248
4200e248:	8e8a      	add.n	a8, a14, a8
4200e24a:	4ca2d2        	movi	a13, 0x24c
4200e24d:	60a2c2        	movi	a12, 0x260
4200e250:	0189      	s32i.n	a8, a1, 0
4200e252:	01def2        	addmi	a15, a14, 0x100
4200e255:	deda      	add.n	a13, a14, a13
4200e257:	ceca      	add.n	a12, a14, a12
4200e259:	05bd      	mov.n	a11, a5
4200e25b:	06ad      	mov.n	a10, a6
4200e25d:	fe3325        	call8	4200c590 <get_arg$isra$0>
4200e260:	0a88      	l32i.n	a8, a10, 0
4200e262:	9f6182        	s32i	a8, a1, 0x27c
4200e265:	002006        	j	4200e2e9 <_vfprintf_r+0x1889>
4200e268:	a71b      	addi.n	a10, a7, 1
4200e26a:	07a797        	bge	a7, a9, 4200e275 <_vfprintf_r+0x1815>
4200e26d:	b0e6e0        	addx8	a14, a6, a14
4200e270:	0e88      	l32i.n	a8, a14, 0
4200e272:	001b86        	j	4200e2e4 <_vfprintf_r+0x1884>
4200e275:	9a2eb2        	l32i	a11, a14, 0x268
4200e278:	fc1c      	movi.n	a12, 31
4200e27a:	02dee2        	addmi	a14, a14, 0x200
4200e27d:	8b4b      	addi.n	a8, a11, 4
4200e27f:	392c97        	blt	a12, a9, 4200e2bc <_vfprintf_r+0x185c>
4200e282:	c91b      	addi.n	a12, a9, 1
4200e284:	9761c2        	s32i	a12, a1, 0x25c
4200e287:	1a6e82        	s32i	a8, a14, 104
4200e28a:	8c1c      	movi.n	a12, 24
4200e28c:	052c87        	blt	a12, a8, 4200e295 <_vfprintf_r+0x1835>
4200e28f:	192eb2        	l32i	a11, a14, 100
4200e292:	000406        	j	4200e2a6 <_vfprintf_r+0x1846>
4200e295:	012cb7        	blt	a12, a11, 4200e29a <_vfprintf_r+0x183a>
4200e298:	482c      	movi.n	a8, 36
4200e29a:	10c1b2        	addi	a11, a1, 16
4200e29d:	02dbb2        	addmi	a11, a11, 0x200
4200e2a0:	182bb2        	l32i	a11, a11, 96
4200e2a3:	9e6182        	s32i	a8, a1, 0x278
4200e2a6:	bb8a      	add.n	a11, a11, a8
4200e2a8:	fccbb2        	addi	a11, a11, -4
4200e2ab:	0b88      	l32i.n	a8, a11, 0
4200e2ad:	9f6182        	s32i	a8, a1, 0x27c
4200e2b0:	b08910        	addx8	a8, a9, a1
4200e2b3:	9f2192        	l32i	a9, a1, 0x27c
4200e2b6:	4899      	s32i.n	a9, a8, 16
4200e2b8:	000ac6        	j	4200e2e7 <_vfprintf_r+0x1887>
4200e2bb:	6e8200        	f64rnd	a8, a2, a0, 2
4200e2be:	1c1a      	add.n	a1, a12, a1
4200e2c0:	8789      	s32i.n	a8, a7, 32
4200e2c2:	0729      	s32i.n	a2, a7, 0
4200e2c4:	192e92        	l32i	a9, a14, 100
4200e2c7:	000486        	j	4200e2dd <_vfprintf_r+0x187d>
4200e2ca:	b70000        	lsi	f0, a0, 0x2dc
4200e2cd:	0129      	s32i.n	a2, a1, 0
4200e2cf:	482c      	movi.n	a8, 36
4200e2d1:	10c192        	addi	a9, a1, 16
4200e2d4:	02d992        	addmi	a9, a9, 0x200
4200e2d7:	182992        	l32i	a9, a9, 96
4200e2da:	9e6182        	s32i	a8, a1, 0x278
4200e2dd:	998a      	add.n	a9, a9, a8
4200e2df:	fcc992        	addi	a9, a9, -4
4200e2e2:	0988      	l32i.n	a8, a9, 0
4200e2e4:	9f6182        	s32i	a8, a1, 0x27c
4200e2e7:	0a7d      	mov.n	a7, a10
4200e2e9:	10c182        	addi	a8, a1, 16
4200e2ec:	02d882        	addmi	a8, a8, 0x200
4200e2ef:	090c      	movi.n	a9, 0
4200e2f1:	524892        	s8i	a9, a8, 82
4200e2f4:	a22182        	l32i	a8, a1, 0x288
4200e2f7:	021896        	bltz	a8, 4200e31c <_vfprintf_r+0x18bc>
4200e2fa:	9f21a2        	l32i	a10, a1, 0x27c
4200e2fd:	08cd      	mov.n	a12, a8
4200e2ff:	00a0b2        	movi	a11, 0
4200e302:	caa981        	l32r	a8, 42000da8 <_stext+0xd88> (40001344 <memchr>)
4200e305:	0008e0        	callx8	a8
4200e308:	a961a2        	s32i	a10, a1, 0x2a4
4200e30b:	1acc      	bnez.n	a10, 4200e310 <_vfprintf_r+0x18b0>
4200e30d:	020f46        	j	4200eb4e <_vfprintf_r+0x20ee>
4200e310:	9f2192        	l32i	a9, a1, 0x27c
4200e313:	c08a90        	sub	a8, a10, a9
4200e316:	a26182        	s32i	a8, a1, 0x288
4200e319:	0002c6        	j	4200e328 <_vfprintf_r+0x18c8>
4200e31c:	9f21a2        	l32i	a10, a1, 0x27c
4200e31f:	c7df81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200e322:	0008e0        	callx8	a8
4200e325:	a261a2        	s32i	a10, a1, 0x288
4200e328:	080c      	movi.n	a8, 0
4200e32a:	a96182        	s32i	a8, a1, 0x2a4
4200e32d:	040c      	movi.n	a4, 0
4200e32f:	0207c6        	j	4200eb52 <_vfprintf_r+0x20f2>
4200e332:	081c      	movi.n	a8, 16
4200e334:	203380        	or	a3, a3, a8
4200e337:	972192        	l32i	a9, a1, 0x25c
4200e33a:	10c1e2        	addi	a14, a1, 16
4200e33d:	02e357        	bbsi	a3, 5, 4200e343 <_vfprintf_r+0x18e3>
4200e340:	002f46        	j	4200e401 <_vfprintf_r+0x19a1>
4200e343:	f4ac      	beqz.n	a4, 4200e376 <_vfprintf_r+0x1916>
4200e345:	09a697        	bge	a6, a9, 4200e352 <_vfprintf_r+0x18f2>
4200e348:	b0e6e0        	addx8	a14, a6, a14
4200e34b:	0e58      	l32i.n	a5, a14, 0
4200e34d:	1e48      	l32i.n	a4, a14, 4
4200e34f:	000786        	j	4200e371 <_vfprintf_r+0x1911>
4200e352:	48a282        	movi	a8, 0x248
4200e355:	8e8a      	add.n	a8, a14, a8
4200e357:	4ca2d2        	movi	a13, 0x24c
4200e35a:	60a2c2        	movi	a12, 0x260
4200e35d:	05bd      	mov.n	a11, a5
4200e35f:	0189      	s32i.n	a8, a1, 0
4200e361:	01def2        	addmi	a15, a14, 0x100
4200e364:	deda      	add.n	a13, a14, a13
4200e366:	ceca      	add.n	a12, a14, a12
4200e368:	06ad      	mov.n	a10, a6
4200e36a:	fe2265        	call8	4200c590 <get_arg$isra$0>
4200e36d:	0a58      	l32i.n	a5, a10, 0
4200e36f:	1a48      	l32i.n	a4, a10, 4
4200e371:	078d      	mov.n	a8, a7
4200e373:	007e06        	j	4200e56f <_vfprintf_r+0x1b0f>
4200e376:	871b      	addi.n	a8, a7, 1
4200e378:	09a797        	bge	a7, a9, 4200e385 <_vfprintf_r+0x1925>
4200e37b:	b0e6e0        	addx8	a14, a6, a14
4200e37e:	0e58      	l32i.n	a5, a14, 0
4200e380:	1e48      	l32i.n	a4, a14, 4
4200e382:	007a46        	j	4200e56f <_vfprintf_r+0x1b0f>
4200e385:	9a2eb2        	l32i	a11, a14, 0x268
4200e388:	8a7c      	movi.n	a10, -8
4200e38a:	bb7b      	addi.n	a11, a11, 7
4200e38c:	10bba0        	and	a11, a11, a10
4200e38f:	fc1c      	movi.n	a12, 31
4200e391:	02dee2        	addmi	a14, a14, 0x200
4200e394:	ab8b      	addi.n	a10, a11, 8
4200e396:	3a2c97        	blt	a12, a9, 4200e3d4 <_vfprintf_r+0x1974>
4200e399:	c91b      	addi.n	a12, a9, 1
4200e39b:	9761c2        	s32i	a12, a1, 0x25c
4200e39e:	1a6ea2        	s32i	a10, a14, 104
4200e3a1:	8c1c      	movi.n	a12, 24
4200e3a3:	052ca7        	blt	a12, a10, 4200e3ac <_vfprintf_r+0x194c>
4200e3a6:	192eb2        	l32i	a11, a14, 100
4200e3a9:	000406        	j	4200e3bd <_vfprintf_r+0x195d>
4200e3ac:	012cb7        	blt	a12, a11, 4200e3b1 <_vfprintf_r+0x1951>
4200e3af:	8a2c      	movi.n	a10, 40
4200e3b1:	10c1b2        	addi	a11, a1, 16
4200e3b4:	02dbb2        	addmi	a11, a11, 0x200
4200e3b7:	182bb2        	l32i	a11, a11, 96
4200e3ba:	9e61a2        	s32i	a10, a1, 0x278
4200e3bd:	abaa      	add.n	a10, a11, a10
4200e3bf:	f8caa2        	addi	a10, a10, -8
4200e3c2:	0a58      	l32i.n	a5, a10, 0
4200e3c4:	1a48      	l32i.n	a4, a10, 4
4200e3c6:	10c1a2        	addi	a10, a1, 16
4200e3c9:	b099a0        	addx8	a9, a9, a10
4200e3cc:	0959      	s32i.n	a5, a9, 0
4200e3ce:	1949      	s32i.n	a4, a9, 4
4200e3d0:	0066c6        	j	4200e56f <_vfprintf_r+0x1b0f>
4200e3d3:	6ea200        	f64rnd	a10, a2, a0, 2
4200e3d6:	1c1a      	add.n	a1, a12, a1
4200e3d8:	a789      	s32i.n	a8, a7, 40
4200e3da:	0729      	s32i.n	a2, a7, 0
4200e3dc:	192e92        	l32i	a9, a14, 100
4200e3df:	000486        	j	4200e3f5 <_vfprintf_r+0x1995>
4200e3e2:	b70000        	lsi	f0, a0, 0x2dc
4200e3e5:	0129      	s32i.n	a2, a1, 0
4200e3e7:	8a2c      	movi.n	a10, 40
4200e3e9:	10c192        	addi	a9, a1, 16
4200e3ec:	02d992        	addmi	a9, a9, 0x200
4200e3ef:	182992        	l32i	a9, a9, 96
4200e3f2:	9e61a2        	s32i	a10, a1, 0x278
4200e3f5:	99aa      	add.n	a9, a9, a10
4200e3f7:	f8c992        	addi	a9, a9, -8
4200e3fa:	0958      	l32i.n	a5, a9, 0
4200e3fc:	1948      	l32i.n	a4, a9, 4
4200e3fe:	005b46        	j	4200e56f <_vfprintf_r+0x1b0f>
4200e401:	036347        	bbci	a3, 4, 4200e408 <_vfprintf_r+0x19a8>
4200e404:	005b06        	j	4200e574 <_vfprintf_r+0x1b14>
4200e407:	e36700        	lsi	f0, a7, 0x38c
4200e40a:	2b4602        	s8i	a0, a6, 43
4200e40d:	c4ac00        	extui	a10, a0, 12, 13
4200e410:	09a697        	bge	a6, a9, 4200e41d <_vfprintf_r+0x19bd>
4200e413:	b0e6e0        	addx8	a14, a6, a14
4200e416:	001e52        	l16ui	a5, a14, 0
4200e419:	006046        	j	4200e59e <_vfprintf_r+0x1b3e>
4200e41c:	a28200        	muluh	a8, a2, a0
4200e41f:	8a48      	l32i.n	a4, a10, 32
4200e421:	8e          	.byte	0x8e
4200e422:	4ca2d2        	movi	a13, 0x24c
4200e425:	60a2c2        	movi	a12, 0x260
4200e428:	05bd      	mov.n	a11, a5
4200e42a:	0189      	s32i.n	a8, a1, 0
4200e42c:	01def2        	addmi	a15, a14, 0x100
4200e42f:	deda      	add.n	a13, a14, a13
4200e431:	ceca      	add.n	a12, a14, a12
4200e433:	06ad      	mov.n	a10, a6
4200e435:	fe15a5        	call8	4200c590 <get_arg$isra$0>
4200e438:	001a52        	l16ui	a5, a10, 0
4200e43b:	0057c6        	j	4200e59e <_vfprintf_r+0x1b3e>
4200e43e:	871b      	addi.n	a8, a7, 1
4200e440:	08a797        	bge	a7, a9, 4200e44c <_vfprintf_r+0x19ec>
4200e443:	b0e6e0        	addx8	a14, a6, a14
4200e446:	001e52        	l16ui	a5, a14, 0
4200e449:	004806        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e44c:	9a2eb2        	l32i	a11, a14, 0x268
4200e44f:	fc1c      	movi.n	a12, 31
4200e451:	02dee2        	addmi	a14, a14, 0x200
4200e454:	ab4b      	addi.n	a10, a11, 4
4200e456:	362c97        	blt	a12, a9, 4200e490 <_vfprintf_r+0x1a30>
4200e459:	c91b      	addi.n	a12, a9, 1
4200e45b:	9761c2        	s32i	a12, a1, 0x25c
4200e45e:	1a6ea2        	s32i	a10, a14, 104
4200e461:	8c1c      	movi.n	a12, 24
4200e463:	052ca7        	blt	a12, a10, 4200e46c <_vfprintf_r+0x1a0c>
4200e466:	192eb2        	l32i	a11, a14, 100
4200e469:	000406        	j	4200e47d <_vfprintf_r+0x1a1d>
4200e46c:	012cb7        	blt	a12, a11, 4200e471 <_vfprintf_r+0x1a11>
4200e46f:	4a2c      	movi.n	a10, 36
4200e471:	10c1b2        	addi	a11, a1, 16
4200e474:	02dbb2        	addmi	a11, a11, 0x200
4200e477:	182bb2        	l32i	a11, a11, 96
4200e47a:	9e61a2        	s32i	a10, a1, 0x278
4200e47d:	bbaa      	add.n	a11, a11, a10
4200e47f:	fccbb2        	addi	a11, a11, -4
4200e482:	0b58      	l32i.n	a5, a11, 0
4200e484:	b09910        	addx8	a9, a9, a1
4200e487:	4959      	s32i.n	a5, a9, 16
4200e489:	f45050        	extui	a5, a5, 0, 16
4200e48c:	003746        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e48f:	6ea200        	f64rnd	a10, a2, a0, 2
4200e492:	1c1a      	add.n	a1, a12, a1
4200e494:	a789      	s32i.n	a8, a7, 40
4200e496:	0729      	s32i.n	a2, a7, 0
4200e498:	192e92        	l32i	a9, a14, 100
4200e49b:	000486        	j	4200e4b1 <_vfprintf_r+0x1a51>
4200e49e:	b70000        	lsi	f0, a0, 0x2dc
4200e4a1:	0129      	s32i.n	a2, a1, 0
4200e4a3:	4a2c      	movi.n	a10, 36
4200e4a5:	10c192        	addi	a9, a1, 16
4200e4a8:	02d992        	addmi	a9, a9, 0x200
4200e4ab:	182992        	l32i	a9, a9, 96
4200e4ae:	9e61a2        	s32i	a10, a1, 0x278
4200e4b1:	99aa      	add.n	a9, a9, a10
4200e4b3:	fcc992        	addi	a9, a9, -4
4200e4b6:	001952        	l16ui	a5, a9, 0
4200e4b9:	002c06        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e4bc:	02e397        	bbsi	a3, 9, 4200e4c2 <_vfprintf_r+0x1a62>
4200e4bf:	002c46        	j	4200e574 <_vfprintf_r+0x1b14>
4200e4c2:	c4ac      	beqz.n	a4, 4200e4f2 <_vfprintf_r+0x1a92>
4200e4c4:	09a697        	bge	a6, a9, 4200e4d1 <_vfprintf_r+0x1a71>
4200e4c7:	b0e6e0        	addx8	a14, a6, a14
4200e4ca:	000e52        	l8ui	a5, a14, 0
4200e4cd:	003346        	j	4200e59e <_vfprintf_r+0x1b3e>
4200e4d0:	a28200        	muluh	a8, a2, a0
4200e4d3:	8a48      	l32i.n	a4, a10, 32
4200e4d5:	8e          	.byte	0x8e
4200e4d6:	4ca2d2        	movi	a13, 0x24c
4200e4d9:	60a2c2        	movi	a12, 0x260
4200e4dc:	05bd      	mov.n	a11, a5
4200e4de:	0189      	s32i.n	a8, a1, 0
4200e4e0:	01def2        	addmi	a15, a14, 0x100
4200e4e3:	deda      	add.n	a13, a14, a13
4200e4e5:	ceca      	add.n	a12, a14, a12
4200e4e7:	06ad      	mov.n	a10, a6
4200e4e9:	fe0a65        	call8	4200c590 <get_arg$isra$0>
4200e4ec:	000a52        	l8ui	a5, a10, 0
4200e4ef:	002ac6        	j	4200e59e <_vfprintf_r+0x1b3e>
4200e4f2:	871b      	addi.n	a8, a7, 1
4200e4f4:	08a797        	bge	a7, a9, 4200e500 <_vfprintf_r+0x1aa0>
4200e4f7:	b0e6e0        	addx8	a14, a6, a14
4200e4fa:	000e52        	l8ui	a5, a14, 0
4200e4fd:	001b06        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e500:	9a2eb2        	l32i	a11, a14, 0x268
4200e503:	fc1c      	movi.n	a12, 31
4200e505:	02dee2        	addmi	a14, a14, 0x200
4200e508:	ab4b      	addi.n	a10, a11, 4
4200e50a:	362c97        	blt	a12, a9, 4200e544 <_vfprintf_r+0x1ae4>
4200e50d:	c91b      	addi.n	a12, a9, 1
4200e50f:	9761c2        	s32i	a12, a1, 0x25c
4200e512:	1a6ea2        	s32i	a10, a14, 104
4200e515:	8c1c      	movi.n	a12, 24
4200e517:	052ca7        	blt	a12, a10, 4200e520 <_vfprintf_r+0x1ac0>
4200e51a:	192eb2        	l32i	a11, a14, 100
4200e51d:	000406        	j	4200e531 <_vfprintf_r+0x1ad1>
4200e520:	012cb7        	blt	a12, a11, 4200e525 <_vfprintf_r+0x1ac5>
4200e523:	4a2c      	movi.n	a10, 36
4200e525:	10c1b2        	addi	a11, a1, 16
4200e528:	02dbb2        	addmi	a11, a11, 0x200
4200e52b:	182bb2        	l32i	a11, a11, 96
4200e52e:	9e61a2        	s32i	a10, a1, 0x278
4200e531:	bbaa      	add.n	a11, a11, a10
4200e533:	fccbb2        	addi	a11, a11, -4
4200e536:	0b58      	l32i.n	a5, a11, 0
4200e538:	b09910        	addx8	a9, a9, a1
4200e53b:	4959      	s32i.n	a5, a9, 16
4200e53d:	745050        	extui	a5, a5, 0, 8
4200e540:	000a46        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e543:	6ea200        	f64rnd	a10, a2, a0, 2
4200e546:	1c1a      	add.n	a1, a12, a1
4200e548:	a789      	s32i.n	a8, a7, 40
4200e54a:	0729      	s32i.n	a2, a7, 0
4200e54c:	192e92        	l32i	a9, a14, 100
4200e54f:	000486        	j	4200e565 <_vfprintf_r+0x1b05>
4200e552:	b70000        	lsi	f0, a0, 0x2dc
4200e555:	0129      	s32i.n	a2, a1, 0
4200e557:	4a2c      	movi.n	a10, 36
4200e559:	10c192        	addi	a9, a1, 16
4200e55c:	02d992        	addmi	a9, a9, 0x200
4200e55f:	182992        	l32i	a9, a9, 96
4200e562:	9e61a2        	s32i	a10, a1, 0x278
4200e565:	99aa      	add.n	a9, a9, a10
4200e567:	fcc992        	addi	a9, a9, -4
4200e56a:	000952        	l8ui	a5, a9, 0
4200e56d:	040c      	movi.n	a4, 0
4200e56f:	190c      	movi.n	a9, 1
4200e571:	00f0c6        	j	4200e938 <_vfprintf_r+0x1ed8>
4200e574:	c4ac      	beqz.n	a4, 4200e5a4 <_vfprintf_r+0x1b44>
4200e576:	07a697        	bge	a6, a9, 4200e581 <_vfprintf_r+0x1b21>
4200e579:	b0e6e0        	addx8	a14, a6, a14
4200e57c:	0e58      	l32i.n	a5, a14, 0
4200e57e:	000706        	j	4200e59e <_vfprintf_r+0x1b3e>
4200e581:	48a282        	movi	a8, 0x248
4200e584:	8e8a      	add.n	a8, a14, a8
4200e586:	4ca2d2        	movi	a13, 0x24c
4200e589:	60a2c2        	movi	a12, 0x260
4200e58c:	05bd      	mov.n	a11, a5
4200e58e:	0189      	s32i.n	a8, a1, 0
4200e590:	01def2        	addmi	a15, a14, 0x100
4200e593:	deda      	add.n	a13, a14, a13
4200e595:	ceca      	add.n	a12, a14, a12
4200e597:	06ad      	mov.n	a10, a6
4200e599:	fdff65        	call8	4200c590 <get_arg$isra$0>
4200e59c:	0a58      	l32i.n	a5, a10, 0
4200e59e:	078d      	mov.n	a8, a7
4200e5a0:	fff246        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e5a3:	871b00        	lsi	f0, a11, 0x21c
4200e5a6:	07a797        	bge	a7, a9, 4200e5b1 <_vfprintf_r+0x1b51>
4200e5a9:	b0e6e0        	addx8	a14, a6, a14
4200e5ac:	0e58      	l32i.n	a5, a14, 0
4200e5ae:	ffeec6        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e5b1:	9a2eb2        	l32i	a11, a14, 0x268
4200e5b4:	fc1c      	movi.n	a12, 31
4200e5b6:	02dee2        	addmi	a14, a14, 0x200
4200e5b9:	ab4b      	addi.n	a10, a11, 4
4200e5bb:	322c97        	blt	a12, a9, 4200e5f1 <_vfprintf_r+0x1b91>
4200e5be:	c91b      	addi.n	a12, a9, 1
4200e5c0:	9761c2        	s32i	a12, a1, 0x25c
4200e5c3:	1a6ea2        	s32i	a10, a14, 104
4200e5c6:	8c1c      	movi.n	a12, 24
4200e5c8:	052ca7        	blt	a12, a10, 4200e5d1 <_vfprintf_r+0x1b71>
4200e5cb:	192eb2        	l32i	a11, a14, 100
4200e5ce:	000406        	j	4200e5e2 <_vfprintf_r+0x1b82>
4200e5d1:	012cb7        	blt	a12, a11, 4200e5d6 <_vfprintf_r+0x1b76>
4200e5d4:	4a2c      	movi.n	a10, 36
4200e5d6:	10c1b2        	addi	a11, a1, 16
4200e5d9:	02dbb2        	addmi	a11, a11, 0x200
4200e5dc:	182bb2        	l32i	a11, a11, 96
4200e5df:	9e61a2        	s32i	a10, a1, 0x278
4200e5e2:	bbaa      	add.n	a11, a11, a10
4200e5e4:	fccbb2        	addi	a11, a11, -4
4200e5e7:	0b58      	l32i.n	a5, a11, 0
4200e5e9:	b09910        	addx8	a9, a9, a1
4200e5ec:	4959      	s32i.n	a5, a9, 16
4200e5ee:	ffdec6        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e5f1:	1a6ea2        	s32i	a10, a14, 104
4200e5f4:	891c      	movi.n	a9, 24
4200e5f6:	0629a7        	blt	a9, a10, 4200e600 <_vfprintf_r+0x1ba0>
4200e5f9:	192e92        	l32i	a9, a14, 100
4200e5fc:	000446        	j	4200e611 <_vfprintf_r+0x1bb1>
4200e5ff:	29b700        	lsi	f0, a7, 164
4200e602:	4a2c01        	l32r	a0, 41fe0eb4 <_coredump_iram_end+0x1c5eeb4>
4200e605:	10c192        	addi	a9, a1, 16
4200e608:	02d992        	addmi	a9, a9, 0x200
4200e60b:	182992        	l32i	a9, a9, 96
4200e60e:	9e61a2        	s32i	a10, a1, 0x278
4200e611:	99aa      	add.n	a9, a9, a10
4200e613:	fcc992        	addi	a9, a9, -4
4200e616:	0958      	l32i.n	a5, a9, 0
4200e618:	ffd446        	j	4200e56d <_vfprintf_r+0x1b0d>
4200e61b:	f88100        	lsi	f0, a1, 0x3e0
4200e61e:	82c9      	s32i.n	a12, a2, 32
4200e620:	92b861        	l32r	a6, 41ff3100 <_coredump_iram_end+0x1c71100>
4200e623:	e29721        	l32r	a2, 42007080 <_open_r+0xa8> (b181e612 <_rtc_reserved_end+0x5171e612>)
4200e626:	5710c1        	l32r	a12, 41fe4268 <_coredump_iram_end+0x1c62268>
4200e629:	4602e3        	lsi	f14, a2, 0x118
4200e62c:	2f          	.byte	0x2f
4200e62d:	f4ac00        	extui	a10, a0, 12, 16
4200e630:	09a697        	bge	a6, a9, 4200e63d <_vfprintf_r+0x1bdd>
4200e633:	b0e6e0        	addx8	a14, a6, a14
4200e636:	0e58      	l32i.n	a5, a14, 0
4200e638:	1e48      	l32i.n	a4, a14, 4
4200e63a:	000786        	j	4200e65c <_vfprintf_r+0x1bfc>
4200e63d:	48a282        	movi	a8, 0x248
4200e640:	8e8a      	add.n	a8, a14, a8
4200e642:	4ca2d2        	movi	a13, 0x24c
4200e645:	60a2c2        	movi	a12, 0x260
4200e648:	05bd      	mov.n	a11, a5
4200e64a:	0189      	s32i.n	a8, a1, 0
4200e64c:	01def2        	addmi	a15, a14, 0x100
4200e64f:	deda      	add.n	a13, a14, a13
4200e651:	ceca      	add.n	a12, a14, a12
4200e653:	06ad      	mov.n	a10, a6
4200e655:	fdf3a5        	call8	4200c590 <get_arg$isra$0>
4200e658:	0a58      	l32i.n	a5, a10, 0
4200e65a:	1a48      	l32i.n	a4, a10, 4
4200e65c:	078d      	mov.n	a8, a7
4200e65e:	00ac06        	j	4200e912 <_vfprintf_r+0x1eb2>
4200e661:	871b      	addi.n	a8, a7, 1
4200e663:	09a797        	bge	a7, a9, 4200e670 <_vfprintf_r+0x1c10>
4200e666:	b0e6e0        	addx8	a14, a6, a14
4200e669:	0e58      	l32i.n	a5, a14, 0
4200e66b:	1e48      	l32i.n	a4, a14, 4
4200e66d:	00a846        	j	4200e912 <_vfprintf_r+0x1eb2>
4200e670:	9a2eb2        	l32i	a11, a14, 0x268
4200e673:	8a7c      	movi.n	a10, -8
4200e675:	bb7b      	addi.n	a11, a11, 7
4200e677:	10bba0        	and	a11, a11, a10
4200e67a:	fc1c      	movi.n	a12, 31
4200e67c:	02dee2        	addmi	a14, a14, 0x200
4200e67f:	ab8b      	addi.n	a10, a11, 8
4200e681:	3a2c97        	blt	a12, a9, 4200e6bf <_vfprintf_r+0x1c5f>
4200e684:	c91b      	addi.n	a12, a9, 1
4200e686:	9761c2        	s32i	a12, a1, 0x25c
4200e689:	1a6ea2        	s32i	a10, a14, 104
4200e68c:	8c1c      	movi.n	a12, 24
4200e68e:	062ca7        	blt	a12, a10, 4200e698 <_vfprintf_r+0x1c38>
4200e691:	192eb2        	l32i	a11, a14, 100
4200e694:	000446        	j	4200e6a9 <_vfprintf_r+0x1c49>
4200e697:	2cb700        	lsi	f0, a7, 176
4200e69a:	8a2c01        	l32r	a0, 41ff0f4c <_coredump_iram_end+0x1c6ef4c>
4200e69d:	10c1b2        	addi	a11, a1, 16
4200e6a0:	02dbb2        	addmi	a11, a11, 0x200
4200e6a3:	182bb2        	l32i	a11, a11, 96
4200e6a6:	9e61a2        	s32i	a10, a1, 0x278
4200e6a9:	abaa      	add.n	a10, a11, a10
4200e6ab:	f8caa2        	addi	a10, a10, -8
4200e6ae:	0a58      	l32i.n	a5, a10, 0
4200e6b0:	1a48      	l32i.n	a4, a10, 4
4200e6b2:	10c1a2        	addi	a10, a1, 16
4200e6b5:	b099a0        	addx8	a9, a9, a10
4200e6b8:	0959      	s32i.n	a5, a9, 0
4200e6ba:	1949      	s32i.n	a4, a9, 4
4200e6bc:	009486        	j	4200e912 <_vfprintf_r+0x1eb2>
4200e6bf:	1a6ea2        	s32i	a10, a14, 104
4200e6c2:	891c      	movi.n	a9, 24
4200e6c4:	0529a7        	blt	a9, a10, 4200e6cd <_vfprintf_r+0x1c6d>
4200e6c7:	192e92        	l32i	a9, a14, 100
4200e6ca:	000406        	j	4200e6de <_vfprintf_r+0x1c7e>
4200e6cd:	0129b7        	blt	a9, a11, 4200e6d2 <_vfprintf_r+0x1c72>
4200e6d0:	8a2c      	movi.n	a10, 40
4200e6d2:	10c192        	addi	a9, a1, 16
4200e6d5:	02d992        	addmi	a9, a9, 0x200
4200e6d8:	182992        	l32i	a9, a9, 96
4200e6db:	9e61a2        	s32i	a10, a1, 0x278
4200e6de:	99aa      	add.n	a9, a9, a10
4200e6e0:	f8c992        	addi	a9, a9, -8
4200e6e3:	0958      	l32i.n	a5, a9, 0
4200e6e5:	1948      	l32i.n	a4, a9, 4
4200e6e7:	0089c6        	j	4200e912 <_vfprintf_r+0x1eb2>
4200e6ea:	470000        	lsi	f0, a0, 0x11c
4200e6ed:	8c1463        	lsi	f6, a4, 0x230
4200e6f0:	5e4614        	lsi	f1, a6, 0x178
4200e6f3:	871b00        	lsi	f0, a11, 0x21c
4200e6f6:	022797        	blt	a7, a9, 4200e6fc <_vfprintf_r+0x1c9c>
4200e6f9:	006b06        	j	4200e8a9 <_vfprintf_r+0x1e49>
4200e6fc:	b0e6e0        	addx8	a14, a6, a14
4200e6ff:	0e58      	l32i.n	a5, a14, 0
4200e701:	0082c6        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e704:	02e367        	bbsi	a3, 6, 4200e70a <_vfprintf_r+0x1caa>
4200e707:	002b46        	j	4200e7b8 <_vfprintf_r+0x1d58>
4200e70a:	c4ac      	beqz.n	a4, 4200e73a <_vfprintf_r+0x1cda>
4200e70c:	09a697        	bge	a6, a9, 4200e719 <_vfprintf_r+0x1cb9>
4200e70f:	b0e6e0        	addx8	a14, a6, a14
4200e712:	001e52        	l16ui	a5, a14, 0
4200e715:	005f46        	j	4200e896 <_vfprintf_r+0x1e36>
4200e718:	a28200        	muluh	a8, a2, a0
4200e71b:	8a48      	l32i.n	a4, a10, 32
4200e71d:	8e          	.byte	0x8e
4200e71e:	4ca2d2        	movi	a13, 0x24c
4200e721:	60a2c2        	movi	a12, 0x260
4200e724:	05bd      	mov.n	a11, a5
4200e726:	0189      	s32i.n	a8, a1, 0
4200e728:	01def2        	addmi	a15, a14, 0x100
4200e72b:	deda      	add.n	a13, a14, a13
4200e72d:	ceca      	add.n	a12, a14, a12
4200e72f:	06ad      	mov.n	a10, a6
4200e731:	fde5e5        	call8	4200c590 <get_arg$isra$0>
4200e734:	001a52        	l16ui	a5, a10, 0
4200e737:	0056c6        	j	4200e896 <_vfprintf_r+0x1e36>
4200e73a:	871b      	addi.n	a8, a7, 1
4200e73c:	08a797        	bge	a7, a9, 4200e748 <_vfprintf_r+0x1ce8>
4200e73f:	b0e6e0        	addx8	a14, a6, a14
4200e742:	001e52        	l16ui	a5, a14, 0
4200e745:	0071c6        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e748:	9a2eb2        	l32i	a11, a14, 0x268
4200e74b:	fc1c      	movi.n	a12, 31
4200e74d:	02dee2        	addmi	a14, a14, 0x200
4200e750:	ab4b      	addi.n	a10, a11, 4
4200e752:	362c97        	blt	a12, a9, 4200e78c <_vfprintf_r+0x1d2c>
4200e755:	c91b      	addi.n	a12, a9, 1
4200e757:	9761c2        	s32i	a12, a1, 0x25c
4200e75a:	1a6ea2        	s32i	a10, a14, 104
4200e75d:	8c1c      	movi.n	a12, 24
4200e75f:	052ca7        	blt	a12, a10, 4200e768 <_vfprintf_r+0x1d08>
4200e762:	192eb2        	l32i	a11, a14, 100
4200e765:	000406        	j	4200e779 <_vfprintf_r+0x1d19>
4200e768:	012cb7        	blt	a12, a11, 4200e76d <_vfprintf_r+0x1d0d>
4200e76b:	4a2c      	movi.n	a10, 36
4200e76d:	10c1b2        	addi	a11, a1, 16
4200e770:	02dbb2        	addmi	a11, a11, 0x200
4200e773:	182bb2        	l32i	a11, a11, 96
4200e776:	9e61a2        	s32i	a10, a1, 0x278
4200e779:	bbaa      	add.n	a11, a11, a10
4200e77b:	fccbb2        	addi	a11, a11, -4
4200e77e:	0b58      	l32i.n	a5, a11, 0
4200e780:	b09910        	addx8	a9, a9, a1
4200e783:	4959      	s32i.n	a5, a9, 16
4200e785:	f45050        	extui	a5, a5, 0, 16
4200e788:	006106        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e78b:	6ea200        	f64rnd	a10, a2, a0, 2
4200e78e:	1c1a      	add.n	a1, a12, a1
4200e790:	a789      	s32i.n	a8, a7, 40
4200e792:	0729      	s32i.n	a2, a7, 0
4200e794:	192e92        	l32i	a9, a14, 100
4200e797:	000486        	j	4200e7ad <_vfprintf_r+0x1d4d>
4200e79a:	b70000        	lsi	f0, a0, 0x2dc
4200e79d:	0129      	s32i.n	a2, a1, 0
4200e79f:	4a2c      	movi.n	a10, 36
4200e7a1:	10c192        	addi	a9, a1, 16
4200e7a4:	02d992        	addmi	a9, a9, 0x200
4200e7a7:	182992        	l32i	a9, a9, 96
4200e7aa:	9e61a2        	s32i	a10, a1, 0x278
4200e7ad:	99aa      	add.n	a9, a9, a10
4200e7af:	fcc992        	addi	a9, a9, -4
4200e7b2:	001952        	l16ui	a5, a9, 0
4200e7b5:	0055c6        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e7b8:	02e397        	bbsi	a3, 9, 4200e7be <_vfprintf_r+0x1d5e>
4200e7bb:	002b46        	j	4200e86c <_vfprintf_r+0x1e0c>
4200e7be:	c4ac      	beqz.n	a4, 4200e7ee <_vfprintf_r+0x1d8e>
4200e7c0:	09a697        	bge	a6, a9, 4200e7cd <_vfprintf_r+0x1d6d>
4200e7c3:	b0e6e0        	addx8	a14, a6, a14
4200e7c6:	000e52        	l8ui	a5, a14, 0
4200e7c9:	003246        	j	4200e896 <_vfprintf_r+0x1e36>
4200e7cc:	a28200        	muluh	a8, a2, a0
4200e7cf:	8a48      	l32i.n	a4, a10, 32
4200e7d1:	8e          	.byte	0x8e
4200e7d2:	4ca2d2        	movi	a13, 0x24c
4200e7d5:	60a2c2        	movi	a12, 0x260
4200e7d8:	05bd      	mov.n	a11, a5
4200e7da:	0189      	s32i.n	a8, a1, 0
4200e7dc:	01def2        	addmi	a15, a14, 0x100
4200e7df:	deda      	add.n	a13, a14, a13
4200e7e1:	ceca      	add.n	a12, a14, a12
4200e7e3:	06ad      	mov.n	a10, a6
4200e7e5:	fddaa5        	call8	4200c590 <get_arg$isra$0>
4200e7e8:	000a52        	l8ui	a5, a10, 0
4200e7eb:	0029c6        	j	4200e896 <_vfprintf_r+0x1e36>
4200e7ee:	871b      	addi.n	a8, a7, 1
4200e7f0:	08a797        	bge	a7, a9, 4200e7fc <_vfprintf_r+0x1d9c>
4200e7f3:	b0e6e0        	addx8	a14, a6, a14
4200e7f6:	000e52        	l8ui	a5, a14, 0
4200e7f9:	0044c6        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e7fc:	9a2eb2        	l32i	a11, a14, 0x268
4200e7ff:	fc1c      	movi.n	a12, 31
4200e801:	02dee2        	addmi	a14, a14, 0x200
4200e804:	ab4b      	addi.n	a10, a11, 4
4200e806:	362c97        	blt	a12, a9, 4200e840 <_vfprintf_r+0x1de0>
4200e809:	c91b      	addi.n	a12, a9, 1
4200e80b:	9761c2        	s32i	a12, a1, 0x25c
4200e80e:	1a6ea2        	s32i	a10, a14, 104
4200e811:	8c1c      	movi.n	a12, 24
4200e813:	052ca7        	blt	a12, a10, 4200e81c <_vfprintf_r+0x1dbc>
4200e816:	192eb2        	l32i	a11, a14, 100
4200e819:	000406        	j	4200e82d <_vfprintf_r+0x1dcd>
4200e81c:	012cb7        	blt	a12, a11, 4200e821 <_vfprintf_r+0x1dc1>
4200e81f:	4a2c      	movi.n	a10, 36
4200e821:	10c1b2        	addi	a11, a1, 16
4200e824:	02dbb2        	addmi	a11, a11, 0x200
4200e827:	182bb2        	l32i	a11, a11, 96
4200e82a:	9e61a2        	s32i	a10, a1, 0x278
4200e82d:	bbaa      	add.n	a11, a11, a10
4200e82f:	fccbb2        	addi	a11, a11, -4
4200e832:	0b58      	l32i.n	a5, a11, 0
4200e834:	b09910        	addx8	a9, a9, a1
4200e837:	4959      	s32i.n	a5, a9, 16
4200e839:	745050        	extui	a5, a5, 0, 8
4200e83c:	003406        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e83f:	6ea200        	f64rnd	a10, a2, a0, 2
4200e842:	1c1a      	add.n	a1, a12, a1
4200e844:	a789      	s32i.n	a8, a7, 40
4200e846:	0729      	s32i.n	a2, a7, 0
4200e848:	192e92        	l32i	a9, a14, 100
4200e84b:	000486        	j	4200e861 <_vfprintf_r+0x1e01>
4200e84e:	b70000        	lsi	f0, a0, 0x2dc
4200e851:	0129      	s32i.n	a2, a1, 0
4200e853:	4a2c      	movi.n	a10, 36
4200e855:	10c192        	addi	a9, a1, 16
4200e858:	02d992        	addmi	a9, a9, 0x200
4200e85b:	182992        	l32i	a9, a9, 96
4200e85e:	9e61a2        	s32i	a10, a1, 0x278
4200e861:	99aa      	add.n	a9, a9, a10
4200e863:	fcc992        	addi	a9, a9, -4
4200e866:	000952        	l8ui	a5, a9, 0
4200e869:	0028c6        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e86c:	c4ac      	beqz.n	a4, 4200e89c <_vfprintf_r+0x1e3c>
4200e86e:	07a697        	bge	a6, a9, 4200e879 <_vfprintf_r+0x1e19>
4200e871:	b0e6e0        	addx8	a14, a6, a14
4200e874:	0e58      	l32i.n	a5, a14, 0
4200e876:	000706        	j	4200e896 <_vfprintf_r+0x1e36>
4200e879:	48a282        	movi	a8, 0x248
4200e87c:	8e8a      	add.n	a8, a14, a8
4200e87e:	4ca2d2        	movi	a13, 0x24c
4200e881:	60a2c2        	movi	a12, 0x260
4200e884:	05bd      	mov.n	a11, a5
4200e886:	0189      	s32i.n	a8, a1, 0
4200e888:	01def2        	addmi	a15, a14, 0x100
4200e88b:	deda      	add.n	a13, a14, a13
4200e88d:	ceca      	add.n	a12, a14, a12
4200e88f:	06ad      	mov.n	a10, a6
4200e891:	fdcfe5        	call8	4200c590 <get_arg$isra$0>
4200e894:	0a58      	l32i.n	a5, a10, 0
4200e896:	078d      	mov.n	a8, a7
4200e898:	001d06        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e89b:	871b00        	lsi	f0, a11, 0x21c
4200e89e:	07a797        	bge	a7, a9, 4200e8a9 <_vfprintf_r+0x1e49>
4200e8a1:	b066e0        	addx8	a6, a6, a14
4200e8a4:	0658      	l32i.n	a5, a6, 0
4200e8a6:	001986        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e8a9:	9a2eb2        	l32i	a11, a14, 0x268
4200e8ac:	fc1c      	movi.n	a12, 31
4200e8ae:	02dee2        	addmi	a14, a14, 0x200
4200e8b1:	ab4b      	addi.n	a10, a11, 4
4200e8b3:	322c97        	blt	a12, a9, 4200e8e9 <_vfprintf_r+0x1e89>
4200e8b6:	c91b      	addi.n	a12, a9, 1
4200e8b8:	9761c2        	s32i	a12, a1, 0x25c
4200e8bb:	1a6ea2        	s32i	a10, a14, 104
4200e8be:	8c1c      	movi.n	a12, 24
4200e8c0:	052ca7        	blt	a12, a10, 4200e8c9 <_vfprintf_r+0x1e69>
4200e8c3:	192eb2        	l32i	a11, a14, 100
4200e8c6:	000406        	j	4200e8da <_vfprintf_r+0x1e7a>
4200e8c9:	012cb7        	blt	a12, a11, 4200e8ce <_vfprintf_r+0x1e6e>
4200e8cc:	4a2c      	movi.n	a10, 36
4200e8ce:	10c1b2        	addi	a11, a1, 16
4200e8d1:	02dbb2        	addmi	a11, a11, 0x200
4200e8d4:	182bb2        	l32i	a11, a11, 96
4200e8d7:	9e61a2        	s32i	a10, a1, 0x278
4200e8da:	bbaa      	add.n	a11, a11, a10
4200e8dc:	fccbb2        	addi	a11, a11, -4
4200e8df:	0b58      	l32i.n	a5, a11, 0
4200e8e1:	b09910        	addx8	a9, a9, a1
4200e8e4:	4959      	s32i.n	a5, a9, 16
4200e8e6:	000986        	j	4200e910 <_vfprintf_r+0x1eb0>
4200e8e9:	1a6ea2        	s32i	a10, a14, 104
4200e8ec:	891c      	movi.n	a9, 24
4200e8ee:	0629a7        	blt	a9, a10, 4200e8f8 <_vfprintf_r+0x1e98>
4200e8f1:	192e92        	l32i	a9, a14, 100
4200e8f4:	000446        	j	4200e909 <_vfprintf_r+0x1ea9>
4200e8f7:	29b700        	lsi	f0, a7, 164
4200e8fa:	4a2c01        	l32r	a0, 41fe11ac <_coredump_iram_end+0x1c5f1ac>
4200e8fd:	10c192        	addi	a9, a1, 16
4200e900:	02d992        	addmi	a9, a9, 0x200
4200e903:	182992        	l32i	a9, a9, 96
4200e906:	9e61a2        	s32i	a10, a1, 0x278
4200e909:	99aa      	add.n	a9, a9, a10
4200e90b:	fcc992        	addi	a9, a9, -4
4200e90e:	0958      	l32i.n	a5, a9, 0
4200e910:	040c      	movi.n	a4, 0
4200e912:	209540        	or	a9, a5, a4
4200e915:	799c      	beqz.n	a9, 4200e930 <_vfprintf_r+0x1ed0>
4200e917:	156307        	bbci	a3, 0, 4200e930 <_vfprintf_r+0x1ed0>
4200e91a:	10c192        	addi	a9, a1, 16
4200e91d:	02d992        	addmi	a9, a9, 0x200
4200e920:	0a3c      	movi.n	a10, 48
4200e922:	5049a2        	s8i	a10, a9, 80
4200e925:	a321a2        	l32i	a10, a1, 0x28c
4200e928:	5149a2        	s8i	a10, a9, 81
4200e92b:	290c      	movi.n	a9, 2
4200e92d:	203390        	or	a3, a3, a9
4200e930:	ffab92        	movi	a9, 0xfffffbff
4200e933:	103390        	and	a3, a3, a9
4200e936:	290c      	movi.n	a9, 2
4200e938:	087d      	mov.n	a7, a8
4200e93a:	080c      	movi.n	a8, 0
4200e93c:	10c1a2        	addi	a10, a1, 16
4200e93f:	02daa2        	addmi	a10, a10, 0x200
4200e942:	524a82        	s8i	a8, a10, 82
4200e945:	a22182        	l32i	a8, a1, 0x288
4200e948:	01c896        	bltz	a8, 4200e968 <_vfprintf_r+0x1f08>
4200e94b:	03ad      	mov.n	a10, a3
4200e94d:	7faf82        	movi	a8, -129
4200e950:	103380        	and	a3, a3, a8
4200e953:	1b0c      	movi.n	a11, 1
4200e955:	208540        	or	a8, a5, a4
4200e958:	83b880        	moveqz	a11, a8, a8
4200e95b:	98cc      	bnez.n	a8, 4200e968 <_vfprintf_r+0x1f08>
4200e95d:	a221c2        	l32i	a12, a1, 0x288
4200e960:	180c      	movi.n	a8, 1
4200e962:	838bc0        	moveqz	a8, a11, a12
4200e965:	15b816        	beqz	a8, 4200eac4 <_vfprintf_r+0x2064>
4200e968:	501926        	beqi	a9, 1, 4200e9bc <_vfprintf_r+0x1f5c>
4200e96b:	10c182        	addi	a8, a1, 16
4200e96e:	022966        	bnei	a9, 2, 4200e974 <_vfprintf_r+0x1f14>
4200e971:	0046c6        	j	4200ea90 <_vfprintf_r+0x2030>
4200e974:	e4a192        	movi	a9, 0x1e4
4200e977:	889a      	add.n	a8, a8, a9
4200e979:	9f6182        	s32i	a8, a1, 0x27c
4200e97c:	9f2192        	l32i	a9, a1, 0x27c
4200e97f:	890b      	addi.n	a8, a9, -1
4200e981:	9f6182        	s32i	a8, a1, 0x27c
4200e984:	9f21a2        	l32i	a10, a1, 0x27c
4200e987:	248050        	extui	a8, a5, 0, 3
4200e98a:	30c882        	addi	a8, a8, 48
4200e98d:	404300        	ssai	3
4200e990:	815450        	src	a5, a4, a5
4200e993:	414340        	srli	a4, a4, 3
4200e996:	004a82        	s8i	a8, a10, 0
4200e999:	20a540        	or	a10, a5, a4
4200e99c:	fdca56        	bnez	a10, 4200e97c <_vfprintf_r+0x1f1c>
4200e99f:	d0c882        	addi	a8, a8, -48
4200e9a2:	152816        	beqz	a8, 4200eaf8 <_vfprintf_r+0x2098>
4200e9a5:	02e307        	bbsi	a3, 0, 4200e9ab <_vfprintf_r+0x1f4b>
4200e9a8:	005306        	j	4200eaf8 <_vfprintf_r+0x2098>
4200e9ab:	9f2182        	l32i	a8, a1, 0x27c
4200e9ae:	0a3c      	movi.n	a10, 48
4200e9b0:	880b      	addi.n	a8, a8, -1
4200e9b2:	0048a2        	s8i	a10, a8, 0
4200e9b5:	fec982        	addi	a8, a9, -2
4200e9b8:	004e46        	j	4200eaf5 <_vfprintf_r+0x2095>
4200e9bb:	54dc00        	extui	a13, a0, 12, 6
4200e9be:	980c      	movi.n	a8, 9
4200e9c0:	113857        	bltu	a8, a5, 4200e9d5 <_vfprintf_r+0x1f75>
4200e9c3:	10c182        	addi	a8, a1, 16
4200e9c6:	01d892        	addmi	a9, a8, 0x100
4200e9c9:	30c552        	addi	a5, a5, 48
4200e9cc:	e34952        	s8i	a5, a9, 227
4200e9cf:	e3a192        	movi	a9, 0x1e3
4200e9d2:	004746        	j	4200eaf3 <_vfprintf_r+0x2093>
4200e9d5:	080c      	movi.n	a8, 0
4200e9d7:	a46182        	s32i	a8, a1, 0x290
4200e9da:	00a462        	movi	a6, 0x400
4200e9dd:	f4a182        	movi	a8, 0x1f4
4200e9e0:	818a      	add.n	a8, a1, a8
4200e9e2:	106360        	and	a6, a3, a6
4200e9e5:	880b      	addi.n	a8, a8, -1
4200e9e7:	9f6182        	s32i	a8, a1, 0x27c
4200e9ea:	ac0c      	movi.n	a12, 10
4200e9ec:	0d0c      	movi.n	a13, 0
4200e9ee:	05ad      	mov.n	a10, a5
4200e9f0:	04bd      	mov.n	a11, a4
4200e9f2:	c91381        	l32r	a8, 42000e40 <_stext+0xe20> (40002574 <__umoddi3>)
4200e9f5:	0008e0        	callx8	a8
4200e9f8:	9f2182        	l32i	a8, a1, 0x27c
4200e9fb:	30caa2        	addi	a10, a10, 48
4200e9fe:	0048a2        	s8i	a10, a8, 0
4200ea01:	a42182        	l32i	a8, a1, 0x290
4200ea04:	881b      	addi.n	a8, a8, 1
4200ea06:	a46182        	s32i	a8, a1, 0x290
4200ea09:	061616        	beqz	a6, 4200ea6e <_vfprintf_r+0x200e>
4200ea0c:	aa2182        	l32i	a8, a1, 0x2a8
4200ea0f:	000892        	l8ui	a9, a8, 0
4200ea12:	01af82        	movi	a8, -255
4200ea15:	808980        	add	a8, a9, a8
4200ea18:	052816        	beqz	a8, 4200ea6e <_vfprintf_r+0x200e>
4200ea1b:	a42182        	l32i	a8, a1, 0x290
4200ea1e:	4c9987        	bne	a9, a8, 4200ea6e <_vfprintf_r+0x200e>
4200ea21:	74cc      	bnez.n	a4, 4200ea2c <_vfprintf_r+0x1fcc>
4200ea23:	09a082        	movi	a8, 9
4200ea26:	023857        	bltu	a8, a5, 4200ea2c <_vfprintf_r+0x1fcc>
4200ea29:	0032c6        	j	4200eaf8 <_vfprintf_r+0x2098>
4200ea2c:	9f2182        	l32i	a8, a1, 0x27c
4200ea2f:	b02192        	l32i	a9, a1, 0x2c0
4200ea32:	b621b2        	l32i	a11, a1, 0x2d8
4200ea35:	c08890        	sub	a8, a8, a9
4200ea38:	08ad      	mov.n	a10, a8
4200ea3a:	09cd      	mov.n	a12, a9
4200ea3c:	9f6182        	s32i	a8, a1, 0x27c
4200ea3f:	c88481        	l32r	a8, 42000c50 <_stext+0xc30> (40001224 <strncpy>)
4200ea42:	0008e0        	callx8	a8
4200ea45:	aa2182        	l32i	a8, a1, 0x2a8
4200ea48:	010882        	l8ui	a8, a8, 1
4200ea4b:	18cc      	bnez.n	a8, 4200ea50 <_vfprintf_r+0x1ff0>
4200ea4d:	0001c6        	j	4200ea58 <_vfprintf_r+0x1ff8>
4200ea50:	aa2182        	l32i	a8, a1, 0x2a8
4200ea53:	881b      	addi.n	a8, a8, 1
4200ea55:	aa6182        	s32i	a8, a1, 0x2a8
4200ea58:	ac0c      	movi.n	a12, 10
4200ea5a:	0d0c      	movi.n	a13, 0
4200ea5c:	05ad      	mov.n	a10, a5
4200ea5e:	04bd      	mov.n	a11, a4
4200ea60:	c5c081        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4200ea63:	0008e0        	callx8	a8
4200ea66:	080c      	movi.n	a8, 0
4200ea68:	a46182        	s32i	a8, a1, 0x290
4200ea6b:	000546        	j	4200ea84 <_vfprintf_r+0x2024>
4200ea6e:	ac0c      	movi.n	a12, 10
4200ea70:	0d0c      	movi.n	a13, 0
4200ea72:	05ad      	mov.n	a10, a5
4200ea74:	20b440        	or	a11, a4, a4
4200ea77:	c5ba81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4200ea7a:	0008e0        	callx8	a8
4200ea7d:	34cc      	bnez.n	a4, 4200ea84 <_vfprintf_r+0x2024>
4200ea7f:	980c      	movi.n	a8, 9
4200ea81:	73b857        	bgeu	a8, a5, 4200eaf8 <_vfprintf_r+0x2098>
4200ea84:	9f2182        	l32i	a8, a1, 0x27c
4200ea87:	0a5d      	mov.n	a5, a10
4200ea89:	0b4d      	mov.n	a4, a11
4200ea8b:	ffd586        	j	4200e9e5 <_vfprintf_r+0x1f85>
4200ea8e:	920000        	lsi	f0, a0, 0x248
4200ea91:	9ae4a1        	l32r	a10, 41ff5624 <_coredump_iram_end+0x1c73624>
4200ea94:	8288      	l32i.n	a8, a2, 32
4200ea96:	829f61        	l32r	a6, 41fef514 <_coredump_iram_end+0x1c6d514>
4200ea99:	929f21        	l32r	a2, 41ff3518 <_coredump_iram_end+0x1c71518>
4200ea9c:	0bb821        	l32r	a2, 41fd197c <_coredump_iram_end+0x1c4f97c>
4200ea9f:	8288      	l32i.n	a8, a2, 32
4200eaa1:	509f61        	l32r	a6, 41fe2d20 <_coredump_iram_end+0x1c60d20>
4200eaa4:	8a3480        	round.s	a3, f4, 8
4200eaa7:	8289      	s32i.n	a8, a2, 32
4200eaa9:	0008      	l32i.n	a0, a0, 0
4200eaab:	9f2192        	l32i	a9, a1, 0x27c
4200eaae:	404400        	ssai	4
4200eab1:	815450        	src	a5, a4, a5
4200eab4:	414440        	srli	a4, a4, 4
4200eab7:	004982        	s8i	a8, a9, 0
4200eaba:	208540        	or	a8, a5, a4
4200eabd:	fd7856        	bnez	a8, 4200ea98 <_vfprintf_r+0x2038>
4200eac0:	000d06        	j	4200eaf8 <_vfprintf_r+0x2098>
4200eac3:	080c00        	lsx	f0, a12, a0
4200eac6:	a26182        	s32i	a8, a1, 0x288
4200eac9:	10c1b2        	addi	a11, a1, 16
4200eacc:	e4a182        	movi	a8, 0x1e4
4200eacf:	8b8a      	add.n	a8, a11, a8
4200ead1:	9f6182        	s32i	a8, a1, 0x27c
4200ead4:	09ec      	bnez.n	a9, 4200eaf8 <_vfprintf_r+0x2098>
4200ead6:	0480a0        	extui	a8, a10, 0, 1
4200ead9:	a26182        	s32i	a8, a1, 0x288
4200eadc:	a22182        	l32i	a8, a1, 0x288
4200eadf:	589c      	beqz.n	a8, 4200eaf8 <_vfprintf_r+0x2098>
4200eae1:	01db82        	addmi	a8, a11, 0x100
4200eae4:	093c      	movi.n	a9, 48
4200eae6:	e34892        	s8i	a9, a8, 227
4200eae9:	080c      	movi.n	a8, 0
4200eaeb:	a26182        	s32i	a8, a1, 0x288
4200eaee:	0b9d      	mov.n	a9, a11
4200eaf0:	e3a182        	movi	a8, 0x1e3
4200eaf3:	898a      	add.n	a8, a9, a8
4200eaf5:	9f6182        	s32i	a8, a1, 0x27c
4200eaf8:	bb2182        	l32i	a8, a1, 0x2ec
4200eafb:	9f2192        	l32i	a9, a1, 0x27c
4200eafe:	a22142        	l32i	a4, a1, 0x288
4200eb01:	c08890        	sub	a8, a8, a9
4200eb04:	a26182        	s32i	a8, a1, 0x288
4200eb07:	080c      	movi.n	a8, 0
4200eb09:	a96182        	s32i	a8, a1, 0x2a4
4200eb0c:	001086        	j	4200eb52 <_vfprintf_r+0x20f2>
4200eb0f:	218200        	srai	a8, a0, 2
4200eb12:	18cca3        	ssip	f10, a12, 96
4200eb15:	02bdc6        	j	4200f610 <_vfprintf_r+0x2bb0>
4200eb18:	a321a2        	l32i	a10, a1, 0x28c
4200eb1b:	10c182        	addi	a8, a1, 16
4200eb1e:	01d892        	addmi	a9, a8, 0x100
4200eb21:	8049a2        	s8i	a10, a9, 128
4200eb24:	02d892        	addmi	a9, a8, 0x200
4200eb27:	0a0c      	movi.n	a10, 0
4200eb29:	5249a2        	s8i	a10, a9, 82
4200eb2c:	090c      	movi.n	a9, 0
4200eb2e:	a96192        	s32i	a9, a1, 0x2a4
4200eb31:	190c      	movi.n	a9, 1
4200eb33:	a26192        	s32i	a9, a1, 0x288
4200eb36:	090c      	movi.n	a9, 0
4200eb38:	ab6192        	s32i	a9, a1, 0x2ac
4200eb3b:	040c      	movi.n	a4, 0
4200eb3d:	050c      	movi.n	a5, 0
4200eb3f:	060c      	movi.n	a6, 0
4200eb41:	80a192        	movi	a9, 0x180
4200eb44:	889a      	add.n	a8, a8, a9
4200eb46:	9f6182        	s32i	a8, a1, 0x27c
4200eb49:	000306        	j	4200eb59 <_vfprintf_r+0x20f9>
4200eb4c:	0c0000        	lsi	f0, a0, 48
4200eb4f:	080c04        	mula.dd.ll.ldinc	m0, a12, m0, m2
4200eb52:	ab6182        	s32i	a8, a1, 0x2ac
4200eb55:	050c      	movi.n	a5, 0
4200eb57:	060c      	movi.n	a6, 0
4200eb59:	a22182        	l32i	a8, a1, 0x288
4200eb5c:	538480        	max	a8, a4, a8
4200eb5f:	af6182        	s32i	a8, a1, 0x2bc
4200eb62:	10c182        	addi	a8, a1, 16
4200eb65:	02d882        	addmi	a8, a8, 0x200
4200eb68:	520882        	l8ui	a8, a8, 82
4200eb6b:	788c      	beqz.n	a8, 4200eb76 <_vfprintf_r+0x2116>
4200eb6d:	af2182        	l32i	a8, a1, 0x2bc
4200eb70:	01c882        	addi	a8, a8, 1
4200eb73:	af6182        	s32i	a8, a1, 0x2bc
4200eb76:	280c      	movi.n	a8, 2
4200eb78:	108380        	and	a8, a3, a8
4200eb7b:	b96182        	s32i	a8, a1, 0x2e4
4200eb7e:	688c      	beqz.n	a8, 4200eb88 <_vfprintf_r+0x2128>
4200eb80:	af2182        	l32i	a8, a1, 0x2bc
4200eb83:	882b      	addi.n	a8, a8, 2
4200eb85:	af6182        	s32i	a8, a1, 0x2bc
4200eb88:	84a082        	movi	a8, 132
4200eb8b:	108380        	and	a8, a3, a8
4200eb8e:	ba6182        	s32i	a8, a1, 0x2e8
4200eb91:	089856        	bnez	a8, 4200ec1e <_vfprintf_r+0x21be>
4200eb94:	ac2182        	l32i	a8, a1, 0x2b0
4200eb97:	af2192        	l32i	a9, a1, 0x2bc
4200eb9a:	10c1d2        	addi	a13, a1, 16
4200eb9d:	c0f890        	sub	a15, a8, a9
4200eba0:	391fe6        	bgei	a15, 1, 4200ebdd <_vfprintf_r+0x217d>
4200eba3:	001dc6        	j	4200ec1e <_vfprintf_r+0x21be>
4200eba6:	10cbb2        	addi	a11, a11, 16
4200eba9:	12e9      	s32i.n	a14, a2, 4
4200ebab:	0b69b2        	s32i	a11, a9, 44
4200ebae:	a989      	s32i.n	a8, a9, 40
4200ebb0:	2488a6        	blti	a8, 8, 4200ebd8 <_vfprintf_r+0x2178>
4200ebb3:	24a2c2        	movi	a12, 0x224
4200ebb6:	a021b2        	l32i	a11, a1, 0x280
4200ebb9:	a121a2        	l32i	a10, a1, 0x284
4200ebbc:	80cdc0        	add	a12, a13, a12
4200ebbf:	bc61f2        	s32i	a15, a1, 0x2f0
4200ebc2:	201110        	or	a1, a1, a1
4200ebc5:	010525        	call8	4200fc18 <__sprint_r>
4200ebc8:	1a8c      	beqz.n	a10, 4200ebcd <_vfprintf_r+0x216d>
4200ebca:	029b86        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ebcd:	e4a1a2        	movi	a10, 0x1e4
4200ebd0:	10c1d2        	addi	a13, a1, 16
4200ebd3:	bc21f2        	l32i	a15, a1, 0x2f0
4200ebd6:	adaa      	add.n	a10, a13, a10
4200ebd8:	f0cff2        	addi	a15, a15, -16
4200ebdb:	0a2d      	mov.n	a2, a10
4200ebdd:	c889c1        	l32r	a12, 42000e04 <_stext+0xde4> (3c029b14 <blanks$1>)
4200ebe0:	8a2d82        	l32i	a8, a13, 0x228
4200ebe3:	0e1c      	movi.n	a14, 16
4200ebe5:	02c9      	s32i.n	a12, a2, 0
4200ebe7:	02dd92        	addmi	a9, a13, 0x200
4200ebea:	881b      	addi.n	a8, a8, 1
4200ebec:	a28b      	addi.n	a10, a2, 8
4200ebee:	b9b8      	l32i.n	a11, a9, 44
4200ebf0:	b22ef7        	blt	a14, a15, 4200eba6 <_vfprintf_r+0x2146>
4200ebf3:	12f9      	s32i.n	a15, a2, 4
4200ebf5:	2fba      	add.n	a2, a15, a11
4200ebf7:	b929      	s32i.n	a2, a9, 44
4200ebf9:	a989      	s32i.n	a8, a9, 40
4200ebfb:	0a2d      	mov.n	a2, a10
4200ebfd:	1d88a6        	blti	a8, 8, 4200ec1e <_vfprintf_r+0x21be>
4200ec00:	24a2c2        	movi	a12, 0x224
4200ec03:	a021b2        	l32i	a11, a1, 0x280
4200ec06:	a121a2        	l32i	a10, a1, 0x284
4200ec09:	cdca      	add.n	a12, a13, a12
4200ec0b:	201110        	or	a1, a1, a1
4200ec0e:	0100a5        	call8	4200fc18 <__sprint_r>
4200ec11:	1a8c      	beqz.n	a10, 4200ec16 <_vfprintf_r+0x21b6>
4200ec13:	028946        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ec16:	e4a182        	movi	a8, 0x1e4
4200ec19:	10c1d2        	addi	a13, a1, 16
4200ec1c:	2d8a      	add.n	a2, a13, a8
4200ec1e:	10c182        	addi	a8, a1, 16
4200ec21:	02d892        	addmi	a9, a8, 0x200
4200ec24:	520982        	l8ui	a8, a9, 82
4200ec27:	e8bc      	beqz.n	a8, 4200ec69 <_vfprintf_r+0x2209>
4200ec29:	b988      	l32i.n	a8, a9, 44
4200ec2b:	52a2a2        	movi	a10, 0x252
4200ec2e:	881b      	addi.n	a8, a8, 1
4200ec30:	10c1b2        	addi	a11, a1, 16
4200ec33:	b989      	s32i.n	a8, a9, 44
4200ec35:	a988      	l32i.n	a8, a9, 40
4200ec37:	abaa      	add.n	a10, a11, a10
4200ec39:	02a9      	s32i.n	a10, a2, 0
4200ec3b:	881b      	addi.n	a8, a8, 1
4200ec3d:	1a0c      	movi.n	a10, 1
4200ec3f:	12a9      	s32i.n	a10, a2, 4
4200ec41:	a989      	s32i.n	a8, a9, 40
4200ec43:	228b      	addi.n	a2, a2, 8
4200ec45:	2088a6        	blti	a8, 8, 4200ec69 <_vfprintf_r+0x2209>
4200ec48:	24a2c2        	movi	a12, 0x224
4200ec4b:	10c182        	addi	a8, a1, 16
4200ec4e:	a021b2        	l32i	a11, a1, 0x280
4200ec51:	a121a2        	l32i	a10, a1, 0x284
4200ec54:	c8ca      	add.n	a12, a8, a12
4200ec56:	201110        	or	a1, a1, a1
4200ec59:	00fbe5        	call8	4200fc18 <__sprint_r>
4200ec5c:	1a8c      	beqz.n	a10, 4200ec61 <_vfprintf_r+0x2201>
4200ec5e:	027686        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ec61:	e4a182        	movi	a8, 0x1e4
4200ec64:	10c192        	addi	a9, a1, 16
4200ec67:	298a      	add.n	a2, a9, a8
4200ec69:	b92182        	l32i	a8, a1, 0x2e4
4200ec6c:	046816        	beqz	a8, 4200ecb6 <_vfprintf_r+0x2256>
4200ec6f:	10c182        	addi	a8, a1, 16
4200ec72:	02d892        	addmi	a9, a8, 0x200
4200ec75:	8f2182        	l32i	a8, a1, 0x23c
4200ec78:	50a2a2        	movi	a10, 0x250
4200ec7b:	882b      	addi.n	a8, a8, 2
4200ec7d:	10c1b2        	addi	a11, a1, 16
4200ec80:	b989      	s32i.n	a8, a9, 44
4200ec82:	a988      	l32i.n	a8, a9, 40
4200ec84:	abaa      	add.n	a10, a11, a10
4200ec86:	02a9      	s32i.n	a10, a2, 0
4200ec88:	881b      	addi.n	a8, a8, 1
4200ec8a:	2a0c      	movi.n	a10, 2
4200ec8c:	12a9      	s32i.n	a10, a2, 4
4200ec8e:	a989      	s32i.n	a8, a9, 40
4200ec90:	228b      	addi.n	a2, a2, 8
4200ec92:	2088a6        	blti	a8, 8, 4200ecb6 <_vfprintf_r+0x2256>
4200ec95:	24a2c2        	movi	a12, 0x224
4200ec98:	10c182        	addi	a8, a1, 16
4200ec9b:	a021b2        	l32i	a11, a1, 0x280
4200ec9e:	a121a2        	l32i	a10, a1, 0x284
4200eca1:	c8ca      	add.n	a12, a8, a12
4200eca3:	201110        	or	a1, a1, a1
4200eca6:	00f725        	call8	4200fc18 <__sprint_r>
4200eca9:	1a8c      	beqz.n	a10, 4200ecae <_vfprintf_r+0x224e>
4200ecab:	026346        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ecae:	e4a182        	movi	a8, 0x1e4
4200ecb1:	10c192        	addi	a9, a1, 16
4200ecb4:	298a      	add.n	a2, a9, a8
4200ecb6:	ba2182        	l32i	a8, a1, 0x2e8
4200ecb9:	02e826        	beqi	a8, 128, 4200ecbf <_vfprintf_r+0x225f>
4200ecbc:	002246        	j	4200ed49 <_vfprintf_r+0x22e9>
4200ecbf:	ac2182        	l32i	a8, a1, 0x2b0
4200ecc2:	af2192        	l32i	a9, a1, 0x2bc
4200ecc5:	10c1e2        	addi	a14, a1, 16
4200ecc8:	c0f890        	sub	a15, a8, a9
4200eccb:	371fe6        	bgei	a15, 1, 4200ed06 <_vfprintf_r+0x22a6>
4200ecce:	001dc6        	j	4200ed49 <_vfprintf_r+0x22e9>
4200ecd1:	10cbb2        	addi	a11, a11, 16
4200ecd4:	12d9      	s32i.n	a13, a2, 4
4200ecd6:	b9b9      	s32i.n	a11, a9, 44
4200ecd8:	a989      	s32i.n	a8, a9, 40
4200ecda:	2388a6        	blti	a8, 8, 4200ed01 <_vfprintf_r+0x22a1>
4200ecdd:	24a2c2        	movi	a12, 0x224
4200ece0:	a021b2        	l32i	a11, a1, 0x280
4200ece3:	a121a2        	l32i	a10, a1, 0x284
4200ece6:	ceca      	add.n	a12, a14, a12
4200ece8:	b961f2        	s32i	a15, a1, 0x2e4
4200eceb:	201110        	or	a1, a1, a1
4200ecee:	00f2a5        	call8	4200fc18 <__sprint_r>
4200ecf1:	1a8c      	beqz.n	a10, 4200ecf6 <_vfprintf_r+0x2296>
4200ecf3:	025146        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ecf6:	e4a1a2        	movi	a10, 0x1e4
4200ecf9:	10c1e2        	addi	a14, a1, 16
4200ecfc:	b921f2        	l32i	a15, a1, 0x2e4
4200ecff:	aeaa      	add.n	a10, a14, a10
4200ed01:	f0cff2        	addi	a15, a15, -16
4200ed04:	0a2d      	mov.n	a2, a10
4200ed06:	c840c1        	l32r	a12, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200ed09:	8a2e82        	l32i	a8, a14, 0x228
4200ed0c:	0d1c      	movi.n	a13, 16
4200ed0e:	02c9      	s32i.n	a12, a2, 0
4200ed10:	02de92        	addmi	a9, a14, 0x200
4200ed13:	881b      	addi.n	a8, a8, 1
4200ed15:	a28b      	addi.n	a10, a2, 8
4200ed17:	b9b8      	l32i.n	a11, a9, 44
4200ed19:	b42df7        	blt	a13, a15, 4200ecd1 <_vfprintf_r+0x2271>
4200ed1c:	bfba      	add.n	a11, a15, a11
4200ed1e:	12f9      	s32i.n	a15, a2, 4
4200ed20:	b9b9      	s32i.n	a11, a9, 44
4200ed22:	0a6982        	s32i	a8, a9, 40
4200ed25:	0a2d      	mov.n	a2, a10
4200ed27:	1e88a6        	blti	a8, 8, 4200ed49 <_vfprintf_r+0x22e9>
4200ed2a:	24a2c2        	movi	a12, 0x224
4200ed2d:	a021b2        	l32i	a11, a1, 0x280
4200ed30:	a121a2        	l32i	a10, a1, 0x284
4200ed33:	80cec0        	add	a12, a14, a12
4200ed36:	201110        	or	a1, a1, a1
4200ed39:	00ede5        	call8	4200fc18 <__sprint_r>
4200ed3c:	1a8c      	beqz.n	a10, 4200ed41 <_vfprintf_r+0x22e1>
4200ed3e:	023e86        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ed41:	e4a182        	movi	a8, 0x1e4
4200ed44:	10c1e2        	addi	a14, a1, 16
4200ed47:	2e8a      	add.n	a2, a14, a8
4200ed49:	a22182        	l32i	a8, a1, 0x288
4200ed4c:	c04480        	sub	a4, a4, a8
4200ed4f:	7b14a6        	blti	a4, 1, 4200edce <_vfprintf_r+0x236e>
4200ed52:	000c46        	j	4200ed87 <_vfprintf_r+0x2327>
4200ed55:	10cbb2        	addi	a11, a11, 16
4200ed58:	12d9      	s32i.n	a13, a2, 4
4200ed5a:	b9b9      	s32i.n	a11, a9, 44
4200ed5c:	a989      	s32i.n	a8, a9, 40
4200ed5e:	2088a6        	blti	a8, 8, 4200ed82 <_vfprintf_r+0x2322>
4200ed61:	24a2c2        	movi	a12, 0x224
4200ed64:	10c182        	addi	a8, a1, 16
4200ed67:	a021b2        	l32i	a11, a1, 0x280
4200ed6a:	a121a2        	l32i	a10, a1, 0x284
4200ed6d:	c8ca      	add.n	a12, a8, a12
4200ed6f:	201110        	or	a1, a1, a1
4200ed72:	00ea65        	call8	4200fc18 <__sprint_r>
4200ed75:	1a8c      	beqz.n	a10, 4200ed7a <_vfprintf_r+0x231a>
4200ed77:	023046        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ed7a:	e4a1a2        	movi	a10, 0x1e4
4200ed7d:	10c182        	addi	a8, a1, 16
4200ed80:	a8aa      	add.n	a10, a8, a10
4200ed82:	f0c442        	addi	a4, a4, -16
4200ed85:	0a2d      	mov.n	a2, a10
4200ed87:	10c182        	addi	a8, a1, 16
4200ed8a:	02d892        	addmi	a9, a8, 0x200
4200ed8d:	c81ec1        	l32r	a12, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200ed90:	a988      	l32i.n	a8, a9, 40
4200ed92:	0d1c      	movi.n	a13, 16
4200ed94:	02c9      	s32i.n	a12, a2, 0
4200ed96:	881b      	addi.n	a8, a8, 1
4200ed98:	a28b      	addi.n	a10, a2, 8
4200ed9a:	b9b8      	l32i.n	a11, a9, 44
4200ed9c:	b52d47        	blt	a13, a4, 4200ed55 <_vfprintf_r+0x22f5>
4200ed9f:	1249      	s32i.n	a4, a2, 4
4200eda1:	44ba      	add.n	a4, a4, a11
4200eda3:	b949      	s32i.n	a4, a9, 44
4200eda5:	a989      	s32i.n	a8, a9, 40
4200eda7:	0a2d      	mov.n	a2, a10
4200eda9:	2188a6        	blti	a8, 8, 4200edce <_vfprintf_r+0x236e>
4200edac:	24a2c2        	movi	a12, 0x224
4200edaf:	10c182        	addi	a8, a1, 16
4200edb2:	a021b2        	l32i	a11, a1, 0x280
4200edb5:	a121a2        	l32i	a10, a1, 0x284
4200edb8:	80c8c0        	add	a12, a8, a12
4200edbb:	201110        	or	a1, a1, a1
4200edbe:	00e5a5        	call8	4200fc18 <__sprint_r>
4200edc1:	1a8c      	beqz.n	a10, 4200edc6 <_vfprintf_r+0x2366>
4200edc3:	021d46        	j	4200f63c <_vfprintf_r+0x2bdc>
4200edc6:	e4a182        	movi	a8, 0x1e4
4200edc9:	10c192        	addi	a9, a1, 16
4200edcc:	298a      	add.n	a2, a9, a8
4200edce:	10c182        	addi	a8, a1, 16
4200edd1:	02d8e2        	addmi	a14, a8, 0x200
4200edd4:	be98      	l32i.n	a9, a14, 44
4200edd6:	3fe387        	bbsi	a3, 8, 4200ee19 <_vfprintf_r+0x23b9>
4200edd9:	9f2182        	l32i	a8, a1, 0x27c
4200eddc:	0289      	s32i.n	a8, a2, 0
4200edde:	a22182        	l32i	a8, a1, 0x288
4200ede1:	1289      	s32i.n	a8, a2, 4
4200ede3:	889a      	add.n	a8, a8, a9
4200ede5:	be89      	s32i.n	a8, a14, 44
4200ede7:	ae88      	l32i.n	a8, a14, 40
4200ede9:	228b      	addi.n	a2, a2, 8
4200edeb:	881b      	addi.n	a8, a8, 1
4200eded:	ae89      	s32i.n	a8, a14, 40
4200edef:	0288e6        	bgei	a8, 8, 4200edf5 <_vfprintf_r+0x2395>
4200edf2:	01d3c6        	j	4200f545 <_vfprintf_r+0x2ae5>
4200edf5:	24a2c2        	movi	a12, 0x224
4200edf8:	10c182        	addi	a8, a1, 16
4200edfb:	a021b2        	l32i	a11, a1, 0x280
4200edfe:	a121a2        	l32i	a10, a1, 0x284
4200ee01:	c8ca      	add.n	a12, a8, a12
4200ee03:	201110        	or	a1, a1, a1
4200ee06:	00e125        	call8	4200fc18 <__sprint_r>
4200ee09:	1a8c      	beqz.n	a10, 4200ee0e <_vfprintf_r+0x23ae>
4200ee0b:	020b46        	j	4200f63c <_vfprintf_r+0x2bdc>
4200ee0e:	e4a182        	movi	a8, 0x1e4
4200ee11:	10c192        	addi	a9, a1, 16
4200ee14:	298a      	add.n	a2, a9, a8
4200ee16:	01cac6        	j	4200f545 <_vfprintf_r+0x2ae5>
4200ee19:	a321a2        	l32i	a10, a1, 0x28c
4200ee1c:	65a082        	movi	a8, 101
4200ee1f:	0228a7        	blt	a8, a10, 4200ee25 <_vfprintf_r+0x23c5>
4200ee22:	015d86        	j	4200f39c <_vfprintf_r+0x293c>
4200ee25:	98a282        	movi	a8, 0x298
4200ee28:	881a      	add.n	a8, a8, a1
4200ee2a:	08a8      	l32i.n	a10, a8, 0
4200ee2c:	0128b2        	l32i	a11, a8, 4
4200ee2f:	a361e2        	s32i	a14, a1, 0x28c
4200ee32:	a26192        	s32i	a9, a1, 0x288
4200ee35:	0c0c      	movi.n	a12, 0
4200ee37:	00a0d2        	movi	a13, 0
4200ee3a:	c7fb81        	l32r	a8, 42000e28 <_stext+0xe08> (4000228c <__eqdf2>)
4200ee3d:	0008e0        	callx8	a8
4200ee40:	a22192        	l32i	a9, a1, 0x288
4200ee43:	a321e2        	l32i	a14, a1, 0x28c
4200ee46:	0dea56        	bnez	a10, 4200ef28 <_vfprintf_r+0x24c8>
4200ee49:	c7f081        	l32r	a8, 42000e0c <_stext+0xdec> (3c0295e6 <_ZTISt12out_of_range+0x15a>)
4200ee4c:	0289      	s32i.n	a8, a2, 0
4200ee4e:	180c      	movi.n	a8, 1
4200ee50:	1289      	s32i.n	a8, a2, 4
4200ee52:	891b      	addi.n	a8, a9, 1
4200ee54:	be89      	s32i.n	a8, a14, 44
4200ee56:	ae88      	l32i.n	a8, a14, 40
4200ee58:	228b      	addi.n	a2, a2, 8
4200ee5a:	881b      	addi.n	a8, a8, 1
4200ee5c:	ae89      	s32i.n	a8, a14, 40
4200ee5e:	1f88a6        	blti	a8, 8, 4200ee81 <_vfprintf_r+0x2421>
4200ee61:	24a2c2        	movi	a12, 0x224
4200ee64:	10c182        	addi	a8, a1, 16
4200ee67:	a021b2        	l32i	a11, a1, 0x280
4200ee6a:	a121a2        	l32i	a10, a1, 0x284
4200ee6d:	c8ca      	add.n	a12, a8, a12
4200ee6f:	201110        	or	a1, a1, a1
4200ee72:	00da65        	call8	4200fc18 <__sprint_r>
4200ee75:	7c3a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200ee78:	e4a182        	movi	a8, 0x1e4
4200ee7b:	10c192        	addi	a9, a1, 16
4200ee7e:	802980        	add	a2, a9, a8
4200ee81:	952182        	l32i	a8, a1, 0x254
4200ee84:	a42192        	l32i	a9, a1, 0x290
4200ee87:	052897        	blt	a8, a9, 4200ee90 <_vfprintf_r+0x2430>
4200ee8a:	02e307        	bbsi	a3, 0, 4200ee90 <_vfprintf_r+0x2430>
4200ee8d:	01ad06        	j	4200f545 <_vfprintf_r+0x2ae5>
4200ee90:	b12182        	l32i	a8, a1, 0x2c4
4200ee93:	10c162        	addi	a6, a1, 16
4200ee96:	0289      	s32i.n	a8, a2, 0
4200ee98:	ad2182        	l32i	a8, a1, 0x2b4
4200ee9b:	ad21a2        	l32i	a10, a1, 0x2b4
4200ee9e:	1289      	s32i.n	a8, a2, 4
4200eea0:	8b2682        	l32i	a8, a6, 0x22c
4200eea3:	228b      	addi.n	a2, a2, 8
4200eea5:	88aa      	add.n	a8, a8, a10
4200eea7:	8b6682        	s32i	a8, a6, 0x22c
4200eeaa:	8a2682        	l32i	a8, a6, 0x228
4200eead:	01c882        	addi	a8, a8, 1
4200eeb0:	8a6682        	s32i	a8, a6, 0x228
4200eeb3:	1988a6        	blti	a8, 8, 4200eed0 <_vfprintf_r+0x2470>
4200eeb6:	24a2c2        	movi	a12, 0x224
4200eeb9:	a021b2        	l32i	a11, a1, 0x280
4200eebc:	a121a2        	l32i	a10, a1, 0x284
4200eebf:	80c6c0        	add	a12, a6, a12
4200eec2:	201110        	or	a1, a1, a1
4200eec5:	00d525        	call8	4200fc18 <__sprint_r>
4200eec8:	770a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200eecb:	e4a182        	movi	a8, 0x1e4
4200eece:	268a      	add.n	a2, a6, a8
4200eed0:	a42182        	l32i	a8, a1, 0x290
4200eed3:	680b      	addi.n	a6, a8, -1
4200eed5:	0216e6        	bgei	a6, 1, 4200eedb <_vfprintf_r+0x247b>
4200eed8:	019a46        	j	4200f545 <_vfprintf_r+0x2ae5>
4200eedb:	10c152        	addi	a5, a1, 16
4200eede:	000ac6        	j	4200ef0d <_vfprintf_r+0x24ad>
4200eee1:	10cbb2        	addi	a11, a11, 16
4200eee4:	12d9      	s32i.n	a13, a2, 4
4200eee6:	b9b9      	s32i.n	a11, a9, 44
4200eee8:	0a6982        	s32i	a8, a9, 40
4200eeeb:	1988a6        	blti	a8, 8, 4200ef08 <_vfprintf_r+0x24a8>
4200eeee:	24a2c2        	movi	a12, 0x224
4200eef1:	a021b2        	l32i	a11, a1, 0x280
4200eef4:	a121a2        	l32i	a10, a1, 0x284
4200eef7:	80c5c0        	add	a12, a5, a12
4200eefa:	201110        	or	a1, a1, a1
4200eefd:	00d1a5        	call8	4200fc18 <__sprint_r>
4200ef00:	738a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200ef03:	e4a1a2        	movi	a10, 0x1e4
4200ef06:	a5aa      	add.n	a10, a5, a10
4200ef08:	f0c662        	addi	a6, a6, -16
4200ef0b:	0a2d      	mov.n	a2, a10
4200ef0d:	c7bec1        	l32r	a12, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200ef10:	8a2582        	l32i	a8, a5, 0x228
4200ef13:	0d1c      	movi.n	a13, 16
4200ef15:	02c9      	s32i.n	a12, a2, 0
4200ef17:	02d592        	addmi	a9, a5, 0x200
4200ef1a:	881b      	addi.n	a8, a8, 1
4200ef1c:	a28b      	addi.n	a10, a2, 8
4200ef1e:	b9b8      	l32i.n	a11, a9, 44
4200ef20:	bd2d67        	blt	a13, a6, 4200eee1 <_vfprintf_r+0x2481>
4200ef23:	011206        	j	4200f36f <_vfprintf_r+0x290f>
4200ef26:	820000        	mull	a0, a0, a0
4200ef29:	a69521        	l32r	a2, 41ff8980 <_coredump_iram_end+0x1c76980>
4200ef2c:	0218      	l32i.n	a1, a2, 0
4200ef2e:	004ac6        	j	4200f05d <_vfprintf_r+0x25fd>
4200ef31:	c7b681        	l32r	a8, 42000e0c <_stext+0xdec> (3c0295e6 <_ZTISt12out_of_range+0x15a>)
4200ef34:	0289      	s32i.n	a8, a2, 0
4200ef36:	180c      	movi.n	a8, 1
4200ef38:	1289      	s32i.n	a8, a2, 4
4200ef3a:	891b      	addi.n	a8, a9, 1
4200ef3c:	be89      	s32i.n	a8, a14, 44
4200ef3e:	ae88      	l32i.n	a8, a14, 40
4200ef40:	228b      	addi.n	a2, a2, 8
4200ef42:	881b      	addi.n	a8, a8, 1
4200ef44:	ae89      	s32i.n	a8, a14, 40
4200ef46:	1e88a6        	blti	a8, 8, 4200ef68 <_vfprintf_r+0x2508>
4200ef49:	24a2c2        	movi	a12, 0x224
4200ef4c:	10c182        	addi	a8, a1, 16
4200ef4f:	a021b2        	l32i	a11, a1, 0x280
4200ef52:	a121a2        	l32i	a10, a1, 0x284
4200ef55:	c8ca      	add.n	a12, a8, a12
4200ef57:	201110        	or	a1, a1, a1
4200ef5a:	00cbe5        	call8	4200fc18 <__sprint_r>
4200ef5d:	6dba56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200ef60:	e4a182        	movi	a8, 0x1e4
4200ef63:	10c192        	addi	a9, a1, 16
4200ef66:	298a      	add.n	a2, a9, a8
4200ef68:	a421b2        	l32i	a11, a1, 0x290
4200ef6b:	952192        	l32i	a9, a1, 0x254
4200ef6e:	10c162        	addi	a6, a1, 16
4200ef71:	209b90        	or	a9, a11, a9
4200ef74:	04b030        	extui	a11, a3, 0, 1
4200ef77:	2099b0        	or	a9, a9, a11
4200ef7a:	8b2682        	l32i	a8, a6, 0x22c
4200ef7d:	5c4916        	beqz	a9, 4200f545 <_vfprintf_r+0x2ae5>
4200ef80:	b12192        	l32i	a9, a1, 0x2c4
4200ef83:	0299      	s32i.n	a9, a2, 0
4200ef85:	ad2192        	l32i	a9, a1, 0x2b4
4200ef88:	898a      	add.n	a8, a9, a8
4200ef8a:	8b6682        	s32i	a8, a6, 0x22c
4200ef8d:	8a2682        	l32i	a8, a6, 0x228
4200ef90:	1299      	s32i.n	a9, a2, 4
4200ef92:	881b      	addi.n	a8, a8, 1
4200ef94:	8a6682        	s32i	a8, a6, 0x228
4200ef97:	0588e6        	bgei	a8, 8, 4200efa0 <_vfprintf_r+0x2540>
4200ef9a:	828b      	addi.n	a8, a2, 8
4200ef9c:	000646        	j	4200efb9 <_vfprintf_r+0x2559>
4200ef9f:	a2c200        	muluh	a12, a2, a0
4200efa2:	21b224        	lsi	f2, a2, 132
4200efa5:	21a2a0        	srai	a10, a10, 2
4200efa8:	c6caa1        	l32r	a10, 42000ad0 <_stext+0xab0> (3c028948 <__func__$11>)
4200efab:	201110        	or	a1, a1, a1
4200efae:	00c6a5        	call8	4200fc18 <__sprint_r>
4200efb1:	687a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200efb4:	e4a182        	movi	a8, 0x1e4
4200efb7:	868a      	add.n	a8, a6, a8
4200efb9:	952162        	l32i	a6, a1, 0x254
4200efbc:	0706d6        	bgez	a6, 4200f030 <_vfprintf_r+0x25d0>
4200efbf:	606060        	neg	a6, a6
4200efc2:	08bd      	mov.n	a11, a8
4200efc4:	10c152        	addi	a5, a1, 16
4200efc7:	000ac6        	j	4200eff6 <_vfprintf_r+0x2596>
4200efca:	c20000        	quou	a0, a0, a0
4200efcd:	10cc      	bnez.n	a0, 4200efd2 <_vfprintf_r+0x2572>
4200efcf:	1be9      	s32i.n	a14, a11, 4
4200efd1:	bac9      	s32i.n	a12, a10, 44
4200efd3:	aa99      	s32i.n	a9, a10, 40
4200efd5:	1889a6        	blti	a9, 8, 4200eff1 <_vfprintf_r+0x2591>
4200efd8:	24a2c2        	movi	a12, 0x224
4200efdb:	a021b2        	l32i	a11, a1, 0x280
4200efde:	a121a2        	l32i	a10, a1, 0x284
4200efe1:	c5ca      	add.n	a12, a5, a12
4200efe3:	201110        	or	a1, a1, a1
4200efe6:	00c325        	call8	4200fc18 <__sprint_r>
4200efe9:	64fa56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200efec:	e4a182        	movi	a8, 0x1e4
4200efef:	858a      	add.n	a8, a5, a8
4200eff1:	f0c662        	addi	a6, a6, -16
4200eff4:	08bd      	mov.n	a11, a8
4200eff6:	c784d1        	l32r	a13, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200eff9:	8a2592        	l32i	a9, a5, 0x228
4200effc:	0e1c      	movi.n	a14, 16
4200effe:	0bd9      	s32i.n	a13, a11, 0
4200f000:	02d5a2        	addmi	a10, a5, 0x200
4200f003:	991b      	addi.n	a9, a9, 1
4200f005:	888b      	addi.n	a8, a8, 8
4200f007:	bac8      	l32i.n	a12, a10, 44
4200f009:	bf2e67        	blt	a14, a6, 4200efcc <_vfprintf_r+0x256c>
4200f00c:	1b69      	s32i.n	a6, a11, 4
4200f00e:	66ca      	add.n	a6, a6, a12
4200f010:	ba69      	s32i.n	a6, a10, 44
4200f012:	aa99      	s32i.n	a9, a10, 40
4200f014:	1889a6        	blti	a9, 8, 4200f030 <_vfprintf_r+0x25d0>
4200f017:	24a2c2        	movi	a12, 0x224
4200f01a:	a021b2        	l32i	a11, a1, 0x280
4200f01d:	a121a2        	l32i	a10, a1, 0x284
4200f020:	c5ca      	add.n	a12, a5, a12
4200f022:	201110        	or	a1, a1, a1
4200f025:	00bf25        	call8	4200fc18 <__sprint_r>
4200f028:	610a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f02b:	e4a182        	movi	a8, 0x1e4
4200f02e:	858a      	add.n	a8, a5, a8
4200f030:	9f2192        	l32i	a9, a1, 0x27c
4200f033:	10c122        	addi	a2, a1, 16
4200f036:	0899      	s32i.n	a9, a8, 0
4200f038:	a42192        	l32i	a9, a1, 0x290
4200f03b:	a421b2        	l32i	a11, a1, 0x290
4200f03e:	1899      	s32i.n	a9, a8, 4
4200f040:	8b2292        	l32i	a9, a2, 0x22c
4200f043:	99ba      	add.n	a9, a9, a11
4200f045:	8b6292        	s32i	a9, a2, 0x22c
4200f048:	8a2292        	l32i	a9, a2, 0x228
4200f04b:	991b      	addi.n	a9, a9, 1
4200f04d:	8a6292        	s32i	a9, a2, 0x228
4200f050:	0289a6        	blti	a9, 8, 4200f056 <_vfprintf_r+0x25f6>
4200f053:	013546        	j	4200f52c <_vfprintf_r+0x2acc>
4200f056:	288b      	addi.n	a2, a8, 8
4200f058:	013a46        	j	4200f545 <_vfprintf_r+0x2ae5>
4200f05b:	820000        	mull	a0, a0, a0
4200f05e:	80a421        	l32r	a2, 41fef2f0 <_coredump_iram_end+0x1c6d2f0>
4200f061:	a64346        	j	41ff8972 <_coredump_iram_end+0x1c76972>
4200f064:	823514        	lsi	f1, a5, 0x208
4200f067:	499f21        	l32r	a2, 41fe16e4 <_coredump_iram_end+0x1c5f6e4>
4200f06a:	028912        	lsi	f1, a9, 8
4200f06d:	849a      	add.n	a8, a4, a9
4200f06f:	be89      	s32i.n	a8, a14, 44
4200f071:	ae88      	l32i.n	a8, a14, 40
4200f073:	228b      	addi.n	a2, a2, 8
4200f075:	881b      	addi.n	a8, a8, 1
4200f077:	ae89      	s32i.n	a8, a14, 40
4200f079:	1f88a6        	blti	a8, 8, 4200f09c <_vfprintf_r+0x263c>
4200f07c:	24a2c2        	movi	a12, 0x224
4200f07f:	10c182        	addi	a8, a1, 16
4200f082:	a021b2        	l32i	a11, a1, 0x280
4200f085:	a121a2        	l32i	a10, a1, 0x284
4200f088:	80c8c0        	add	a12, a8, a12
4200f08b:	201110        	or	a1, a1, a1
4200f08e:	00b8a5        	call8	4200fc18 <__sprint_r>
4200f091:	5a7a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f094:	e4a182        	movi	a8, 0x1e4
4200f097:	10c192        	addi	a9, a1, 16
4200f09a:	298a      	add.n	a2, a9, a8
4200f09c:	080c      	movi.n	a8, 0
4200f09e:	534480        	max	a4, a4, a8
4200f0a1:	c04640        	sub	a4, a6, a4
4200f0a4:	10c1e2        	addi	a14, a1, 16
4200f0a7:	3214e6        	bgei	a4, 1, 4200f0dd <_vfprintf_r+0x267d>
4200f0aa:	001b86        	j	4200f11c <_vfprintf_r+0x26bc>
4200f0ad:	10cbb2        	addi	a11, a11, 16
4200f0b0:	12d9      	s32i.n	a13, a2, 4
4200f0b2:	0b69b2        	s32i	a11, a9, 44
4200f0b5:	0a6982        	s32i	a8, a9, 40
4200f0b8:	1c88a6        	blti	a8, 8, 4200f0d8 <_vfprintf_r+0x2678>
4200f0bb:	24a2c2        	movi	a12, 0x224
4200f0be:	a021b2        	l32i	a11, a1, 0x280
4200f0c1:	a121a2        	l32i	a10, a1, 0x284
4200f0c4:	80cec0        	add	a12, a14, a12
4200f0c7:	201110        	or	a1, a1, a1
4200f0ca:	00b4e5        	call8	4200fc18 <__sprint_r>
4200f0cd:	56ba56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f0d0:	e4a1a2        	movi	a10, 0x1e4
4200f0d3:	10c1e2        	addi	a14, a1, 16
4200f0d6:	aeaa      	add.n	a10, a14, a10
4200f0d8:	f0c442        	addi	a4, a4, -16
4200f0db:	0a2d      	mov.n	a2, a10
4200f0dd:	c74ac1        	l32r	a12, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200f0e0:	8a2e82        	l32i	a8, a14, 0x228
4200f0e3:	0d1c      	movi.n	a13, 16
4200f0e5:	02c9      	s32i.n	a12, a2, 0
4200f0e7:	02de92        	addmi	a9, a14, 0x200
4200f0ea:	881b      	addi.n	a8, a8, 1
4200f0ec:	a28b      	addi.n	a10, a2, 8
4200f0ee:	b9b8      	l32i.n	a11, a9, 44
4200f0f0:	b92d47        	blt	a13, a4, 4200f0ad <_vfprintf_r+0x264d>
4200f0f3:	1249      	s32i.n	a4, a2, 4
4200f0f5:	44ba      	add.n	a4, a4, a11
4200f0f7:	b949      	s32i.n	a4, a9, 44
4200f0f9:	a989      	s32i.n	a8, a9, 40
4200f0fb:	0a2d      	mov.n	a2, a10
4200f0fd:	1b88a6        	blti	a8, 8, 4200f11c <_vfprintf_r+0x26bc>
4200f100:	24a2c2        	movi	a12, 0x224
4200f103:	a021b2        	l32i	a11, a1, 0x280
4200f106:	a121a2        	l32i	a10, a1, 0x284
4200f109:	ceca      	add.n	a12, a14, a12
4200f10b:	201110        	or	a1, a1, a1
4200f10e:	00b0a5        	call8	4200fc18 <__sprint_r>
4200f111:	527a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f114:	e4a182        	movi	a8, 0x1e4
4200f117:	10c1e2        	addi	a14, a1, 16
4200f11a:	2e8a      	add.n	a2, a14, a8
4200f11c:	9f2182        	l32i	a8, a1, 0x27c
4200f11f:	686a      	add.n	a6, a8, a6
4200f121:	02e3a7        	bbsi	a3, 10, 4200f127 <_vfprintf_r+0x26c7>
4200f124:	005346        	j	4200f275 <_vfprintf_r+0x2815>
4200f127:	10c142        	addi	a4, a1, 16
4200f12a:	004ac6        	j	4200f259 <_vfprintf_r+0x27f9>
4200f12d:	ab2182        	l32i	a8, a1, 0x2ac
4200f130:	0718a6        	blti	a8, 1, 4200f13b <_vfprintf_r+0x26db>
4200f133:	880b      	addi.n	a8, a8, -1
4200f135:	ab6182        	s32i	a8, a1, 0x2ac
4200f138:	000246        	j	4200f145 <_vfprintf_r+0x26e5>
4200f13b:	aa2182        	l32i	a8, a1, 0x2a8
4200f13e:	550b      	addi.n	a5, a5, -1
4200f140:	880b      	addi.n	a8, a8, -1
4200f142:	aa6182        	s32i	a8, a1, 0x2a8
4200f145:	b62182        	l32i	a8, a1, 0x2d8
4200f148:	b021a2        	l32i	a10, a1, 0x2c0
4200f14b:	0289      	s32i.n	a8, a2, 0
4200f14d:	b02182        	l32i	a8, a1, 0x2c0
4200f150:	1289      	s32i.n	a8, a2, 4
4200f152:	8b2482        	l32i	a8, a4, 0x22c
4200f155:	228b      	addi.n	a2, a2, 8
4200f157:	88aa      	add.n	a8, a8, a10
4200f159:	8b6482        	s32i	a8, a4, 0x22c
4200f15c:	8a2482        	l32i	a8, a4, 0x228
4200f15f:	881b      	addi.n	a8, a8, 1
4200f161:	8a6482        	s32i	a8, a4, 0x228
4200f164:	1888a6        	blti	a8, 8, 4200f180 <_vfprintf_r+0x2720>
4200f167:	24a2c2        	movi	a12, 0x224
4200f16a:	a021b2        	l32i	a11, a1, 0x280
4200f16d:	a121a2        	l32i	a10, a1, 0x284
4200f170:	c4ca      	add.n	a12, a4, a12
4200f172:	201110        	or	a1, a1, a1
4200f175:	00aa25        	call8	4200fc18 <__sprint_r>
4200f178:	4c0a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f17b:	e4a182        	movi	a8, 0x1e4
4200f17e:	248a      	add.n	a2, a4, a8
4200f180:	a42192        	l32i	a9, a1, 0x290
4200f183:	9f2182        	l32i	a8, a1, 0x27c
4200f186:	889a      	add.n	a8, a8, a9
4200f188:	c09860        	sub	a9, a8, a6
4200f18b:	aa2182        	l32i	a8, a1, 0x2a8
4200f18e:	000882        	l8ui	a8, a8, 0
4200f191:	43d980        	min	a13, a9, a8
4200f194:	381da6        	blti	a13, 1, 4200f1d0 <_vfprintf_r+0x2770>
4200f197:	8b2482        	l32i	a8, a4, 0x22c
4200f19a:	0269      	s32i.n	a6, a2, 0
4200f19c:	8d8a      	add.n	a8, a13, a8
4200f19e:	8b6482        	s32i	a8, a4, 0x22c
4200f1a1:	8a2482        	l32i	a8, a4, 0x228
4200f1a4:	12d9      	s32i.n	a13, a2, 4
4200f1a6:	881b      	addi.n	a8, a8, 1
4200f1a8:	8a6482        	s32i	a8, a4, 0x228
4200f1ab:	228b      	addi.n	a2, a2, 8
4200f1ad:	1f88a6        	blti	a8, 8, 4200f1d0 <_vfprintf_r+0x2770>
4200f1b0:	24a2c2        	movi	a12, 0x224
4200f1b3:	a021b2        	l32i	a11, a1, 0x280
4200f1b6:	a121a2        	l32i	a10, a1, 0x284
4200f1b9:	80c4c0        	add	a12, a4, a12
4200f1bc:	a261d2        	s32i	a13, a1, 0x288
4200f1bf:	201110        	or	a1, a1, a1
4200f1c2:	00a565        	call8	4200fc18 <__sprint_r>
4200f1c5:	473a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f1c8:	e4a182        	movi	a8, 0x1e4
4200f1cb:	a221d2        	l32i	a13, a1, 0x288
4200f1ce:	248a      	add.n	a2, a4, a8
4200f1d0:	aa2182        	l32i	a8, a1, 0x2a8
4200f1d3:	000892        	l8ui	a9, a8, 0
4200f1d6:	080c      	movi.n	a8, 0
4200f1d8:	538d80        	max	a8, a13, a8
4200f1db:	c0e980        	sub	a14, a9, a8
4200f1de:	6f1ea6        	blti	a14, 1, 4200f251 <_vfprintf_r+0x27f1>
4200f1e1:	000c06        	j	4200f215 <_vfprintf_r+0x27b5>
4200f1e4:	10cbb2        	addi	a11, a11, 16
4200f1e7:	12d9      	s32i.n	a13, a2, 4
4200f1e9:	b9b9      	s32i.n	a11, a9, 44
4200f1eb:	a989      	s32i.n	a8, a9, 40
4200f1ed:	1f88a6        	blti	a8, 8, 4200f210 <_vfprintf_r+0x27b0>
4200f1f0:	24a2c2        	movi	a12, 0x224
4200f1f3:	a021b2        	l32i	a11, a1, 0x280
4200f1f6:	a121a2        	l32i	a10, a1, 0x284
4200f1f9:	80c4c0        	add	a12, a4, a12
4200f1fc:	a261e2        	s32i	a14, a1, 0x288
4200f1ff:	201110        	or	a1, a1, a1
4200f202:	00a165        	call8	4200fc18 <__sprint_r>
4200f205:	433a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f208:	e4a1a2        	movi	a10, 0x1e4
4200f20b:	a221e2        	l32i	a14, a1, 0x288
4200f20e:	a4aa      	add.n	a10, a4, a10
4200f210:	f0cee2        	addi	a14, a14, -16
4200f213:	0a2d      	mov.n	a2, a10
4200f215:	c6fcc1        	l32r	a12, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200f218:	8a2482        	l32i	a8, a4, 0x228
4200f21b:	0d1c      	movi.n	a13, 16
4200f21d:	02c9      	s32i.n	a12, a2, 0
4200f21f:	02d492        	addmi	a9, a4, 0x200
4200f222:	881b      	addi.n	a8, a8, 1
4200f224:	a28b      	addi.n	a10, a2, 8
4200f226:	b9b8      	l32i.n	a11, a9, 44
4200f228:	b82de7        	blt	a13, a14, 4200f1e4 <_vfprintf_r+0x2784>
4200f22b:	beba      	add.n	a11, a14, a11
4200f22d:	12e9      	s32i.n	a14, a2, 4
4200f22f:	b9b9      	s32i.n	a11, a9, 44
4200f231:	a989      	s32i.n	a8, a9, 40
4200f233:	0a2d      	mov.n	a2, a10
4200f235:	1888a6        	blti	a8, 8, 4200f251 <_vfprintf_r+0x27f1>
4200f238:	24a2c2        	movi	a12, 0x224
4200f23b:	a021b2        	l32i	a11, a1, 0x280
4200f23e:	a121a2        	l32i	a10, a1, 0x284
4200f241:	c4ca      	add.n	a12, a4, a12
4200f243:	201110        	or	a1, a1, a1
4200f246:	009d25        	call8	4200fc18 <__sprint_r>
4200f249:	3efa56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f24c:	e4a182        	movi	a8, 0x1e4
4200f24f:	248a      	add.n	a2, a4, a8
4200f251:	aa2182        	l32i	a8, a1, 0x2a8
4200f254:	000882        	l8ui	a8, a8, 0
4200f257:	668a      	add.n	a6, a6, a8
4200f259:	080c      	movi.n	a8, 0
4200f25b:	728850        	lsi	f5, a8, 0x1c8
4200f25e:	ecb856        	bnez	a8, 4200f12d <_vfprintf_r+0x26cd>
4200f261:	ab2192        	l32i	a9, a1, 0x2ac
4200f264:	02a897        	bge	a8, a9, 4200f26a <_vfprintf_r+0x280a>
4200f267:	ffb086        	j	4200f12d <_vfprintf_r+0x26cd>
4200f26a:	9f2182        	l32i	a8, a1, 0x27c
4200f26d:	a42192        	l32i	a9, a1, 0x290
4200f270:	889a      	add.n	a8, a8, a9
4200f272:	636680        	minu	a6, a6, a8
4200f275:	952182        	l32i	a8, a1, 0x254
4200f278:	a42192        	l32i	a9, a1, 0x290
4200f27b:	022897        	blt	a8, a9, 4200f281 <_vfprintf_r+0x2821>
4200f27e:	3f6307        	bbci	a3, 0, 4200f2c1 <_vfprintf_r+0x2861>
4200f281:	b12182        	l32i	a8, a1, 0x2c4
4200f284:	10c152        	addi	a5, a1, 16
4200f287:	0289      	s32i.n	a8, a2, 0
4200f289:	ad2182        	l32i	a8, a1, 0x2b4
4200f28c:	ad21a2        	l32i	a10, a1, 0x2b4
4200f28f:	1289      	s32i.n	a8, a2, 4
4200f291:	8b2582        	l32i	a8, a5, 0x22c
4200f294:	228b      	addi.n	a2, a2, 8
4200f296:	88aa      	add.n	a8, a8, a10
4200f298:	8b6582        	s32i	a8, a5, 0x22c
4200f29b:	8a2582        	l32i	a8, a5, 0x228
4200f29e:	881b      	addi.n	a8, a8, 1
4200f2a0:	8a6582        	s32i	a8, a5, 0x228
4200f2a3:	1a88a6        	blti	a8, 8, 4200f2c1 <_vfprintf_r+0x2861>
4200f2a6:	24a2c2        	movi	a12, 0x224
4200f2a9:	a021b2        	l32i	a11, a1, 0x280
4200f2ac:	a121a2        	l32i	a10, a1, 0x284
4200f2af:	80c5c0        	add	a12, a5, a12
4200f2b2:	201110        	or	a1, a1, a1
4200f2b5:	009625        	call8	4200fc18 <__sprint_r>
4200f2b8:	380a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f2bb:	e4a182        	movi	a8, 0x1e4
4200f2be:	802580        	add	a2, a5, a8
4200f2c1:	a42182        	l32i	a8, a1, 0x290
4200f2c4:	952152        	l32i	a5, a1, 0x254
4200f2c7:	a42192        	l32i	a9, a1, 0x290
4200f2ca:	c05850        	sub	a5, a8, a5
4200f2cd:	9f2182        	l32i	a8, a1, 0x27c
4200f2d0:	889a      	add.n	a8, a8, a9
4200f2d2:	c08860        	sub	a8, a8, a6
4200f2d5:	435580        	min	a5, a5, a8
4200f2d8:	3415a6        	blti	a5, 1, 4200f310 <_vfprintf_r+0x28b0>
4200f2db:	8f2182        	l32i	a8, a1, 0x23c
4200f2de:	0269      	s32i.n	a6, a2, 0
4200f2e0:	858a      	add.n	a8, a5, a8
4200f2e2:	8f6182        	s32i	a8, a1, 0x23c
4200f2e5:	8e2182        	l32i	a8, a1, 0x238
4200f2e8:	1259      	s32i.n	a5, a2, 4
4200f2ea:	881b      	addi.n	a8, a8, 1
4200f2ec:	8e6182        	s32i	a8, a1, 0x238
4200f2ef:	10c142        	addi	a4, a1, 16
4200f2f2:	228b      	addi.n	a2, a2, 8
4200f2f4:	1888a6        	blti	a8, 8, 4200f310 <_vfprintf_r+0x28b0>
4200f2f7:	24a2c2        	movi	a12, 0x224
4200f2fa:	a021b2        	l32i	a11, a1, 0x280
4200f2fd:	a121a2        	l32i	a10, a1, 0x284
4200f300:	c4ca      	add.n	a12, a4, a12
4200f302:	201110        	or	a1, a1, a1
4200f305:	009125        	call8	4200fc18 <__sprint_r>
4200f308:	330a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f30b:	e4a182        	movi	a8, 0x1e4
4200f30e:	248a      	add.n	a2, a4, a8
4200f310:	a42182        	l32i	a8, a1, 0x290
4200f313:	952162        	l32i	a6, a1, 0x254
4200f316:	c06860        	sub	a6, a8, a6
4200f319:	080c      	movi.n	a8, 0
4200f31b:	535580        	max	a5, a5, a8
4200f31e:	c06650        	sub	a6, a6, a5
4200f321:	0216e6        	bgei	a6, 1, 4200f327 <_vfprintf_r+0x28c7>
4200f324:	008746        	j	4200f545 <_vfprintf_r+0x2ae5>
4200f327:	10c152        	addi	a5, a1, 16
4200f32a:	000ac6        	j	4200f359 <_vfprintf_r+0x28f9>
4200f32d:	10cbb2        	addi	a11, a11, 16
4200f330:	12d9      	s32i.n	a13, a2, 4
4200f332:	b9b9      	s32i.n	a11, a9, 44
4200f334:	0a6982        	s32i	a8, a9, 40
4200f337:	1988a6        	blti	a8, 8, 4200f354 <_vfprintf_r+0x28f4>
4200f33a:	24a2c2        	movi	a12, 0x224
4200f33d:	a021b2        	l32i	a11, a1, 0x280
4200f340:	a121a2        	l32i	a10, a1, 0x284
4200f343:	80c5c0        	add	a12, a5, a12
4200f346:	201110        	or	a1, a1, a1
4200f349:	008ce5        	call8	4200fc18 <__sprint_r>
4200f34c:	2eca56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f34f:	e4a1a2        	movi	a10, 0x1e4
4200f352:	a5aa      	add.n	a10, a5, a10
4200f354:	f0c662        	addi	a6, a6, -16
4200f357:	0a2d      	mov.n	a2, a10
4200f359:	c6abc1        	l32r	a12, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200f35c:	8a2582        	l32i	a8, a5, 0x228
4200f35f:	0d1c      	movi.n	a13, 16
4200f361:	02c9      	s32i.n	a12, a2, 0
4200f363:	02d592        	addmi	a9, a5, 0x200
4200f366:	881b      	addi.n	a8, a8, 1
4200f368:	a28b      	addi.n	a10, a2, 8
4200f36a:	b9b8      	l32i.n	a11, a9, 44
4200f36c:	bd2d67        	blt	a13, a6, 4200f32d <_vfprintf_r+0x28cd>
4200f36f:	1269      	s32i.n	a6, a2, 4
4200f371:	66ba      	add.n	a6, a6, a11
4200f373:	b969      	s32i.n	a6, a9, 44
4200f375:	a989      	s32i.n	a8, a9, 40
4200f377:	0a2d      	mov.n	a2, a10
4200f379:	0288e6        	bgei	a8, 8, 4200f37f <_vfprintf_r+0x291f>
4200f37c:	007146        	j	4200f545 <_vfprintf_r+0x2ae5>
4200f37f:	24a2c2        	movi	a12, 0x224
4200f382:	a021b2        	l32i	a11, a1, 0x280
4200f385:	a121a2        	l32i	a10, a1, 0x284
4200f388:	c5ca      	add.n	a12, a5, a12
4200f38a:	201110        	or	a1, a1, a1
4200f38d:	0088a5        	call8	4200fc18 <__sprint_r>
4200f390:	2a8a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f393:	e4a182        	movi	a8, 0x1e4
4200f396:	258a      	add.n	a2, a5, a8
4200f398:	006a46        	j	4200f545 <_vfprintf_r+0x2ae5>
4200f39b:	ae8800        	f64iter	a8, a8, a0, 2, 0
4200f39e:	a91b      	addi.n	a10, a9, 1
4200f3a0:	a42192        	l32i	a9, a1, 0x290
4200f3a3:	881b      	addi.n	a8, a8, 1
4200f3a5:	628b      	addi.n	a6, a2, 8
4200f3a7:	0529e6        	bgei	a9, 2, 4200f3b0 <_vfprintf_r+0x2950>
4200f3aa:	02e307        	bbsi	a3, 0, 4200f3b0 <_vfprintf_r+0x2950>
4200f3ad:	004d06        	j	4200f4e5 <_vfprintf_r+0x2a85>
4200f3b0:	9f2192        	l32i	a9, a1, 0x27c
4200f3b3:	8f61a2        	s32i	a10, a1, 0x23c
4200f3b6:	0299      	s32i.n	a9, a2, 0
4200f3b8:	190c      	movi.n	a9, 1
4200f3ba:	016292        	s32i	a9, a2, 4
4200f3bd:	8e6182        	s32i	a8, a1, 0x238
4200f3c0:	10c152        	addi	a5, a1, 16
4200f3c3:	1988a6        	blti	a8, 8, 4200f3e0 <_vfprintf_r+0x2980>
4200f3c6:	24a2c2        	movi	a12, 0x224
4200f3c9:	a021b2        	l32i	a11, a1, 0x280
4200f3cc:	a121a2        	l32i	a10, a1, 0x284
4200f3cf:	80c5c0        	add	a12, a5, a12
4200f3d2:	201110        	or	a1, a1, a1
4200f3d5:	008425        	call8	4200fc18 <__sprint_r>
4200f3d8:	260a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f3db:	e4a162        	movi	a6, 0x1e4
4200f3de:	656a      	add.n	a6, a5, a6
4200f3e0:	b12182        	l32i	a8, a1, 0x2c4
4200f3e3:	10c152        	addi	a5, a1, 16
4200f3e6:	0689      	s32i.n	a8, a6, 0
4200f3e8:	ad2182        	l32i	a8, a1, 0x2b4
4200f3eb:	ad21a2        	l32i	a10, a1, 0x2b4
4200f3ee:	1689      	s32i.n	a8, a6, 4
4200f3f0:	8b2582        	l32i	a8, a5, 0x22c
4200f3f3:	88aa      	add.n	a8, a8, a10
4200f3f5:	8b6582        	s32i	a8, a5, 0x22c
4200f3f8:	8a2582        	l32i	a8, a5, 0x228
4200f3fb:	881b      	addi.n	a8, a8, 1
4200f3fd:	8a6582        	s32i	a8, a5, 0x228
4200f400:	0488e6        	bgei	a8, 8, 4200f408 <_vfprintf_r+0x29a8>
4200f403:	668b      	addi.n	a6, a6, 8
4200f405:	000606        	j	4200f421 <_vfprintf_r+0x29c1>
4200f408:	24a2c2        	movi	a12, 0x224
4200f40b:	a021b2        	l32i	a11, a1, 0x280
4200f40e:	a121a2        	l32i	a10, a1, 0x284
4200f411:	c5ca      	add.n	a12, a5, a12
4200f413:	201110        	or	a1, a1, a1
4200f416:	008025        	call8	4200fc18 <__sprint_r>
4200f419:	21fa56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f41c:	e4a162        	movi	a6, 0x1e4
4200f41f:	656a      	add.n	a6, a5, a6
4200f421:	a42182        	l32i	a8, a1, 0x290
4200f424:	0c0c      	movi.n	a12, 0
4200f426:	580b      	addi.n	a5, a8, -1
4200f428:	98a282        	movi	a8, 0x298
4200f42b:	881a      	add.n	a8, a8, a1
4200f42d:	08a8      	l32i.n	a10, a8, 0
4200f42f:	18b8      	l32i.n	a11, a8, 4
4200f431:	0d0c      	movi.n	a13, 0
4200f433:	c68181        	l32r	a8, 42000e38 <_stext+0xe18> (4000246c <__nedf2>)
4200f436:	0008e0        	callx8	a8
4200f439:	047a16        	beqz	a10, 4200f484 <_vfprintf_r+0x2a24>
4200f43c:	9f21b2        	l32i	a11, a1, 0x27c
4200f43f:	8f21c2        	l32i	a12, a1, 0x23c
4200f442:	bb1b      	addi.n	a11, a11, 1
4200f444:	8e2182        	l32i	a8, a1, 0x238
4200f447:	06b9      	s32i.n	a11, a6, 0
4200f449:	a421b2        	l32i	a11, a1, 0x290
4200f44c:	cc0b      	addi.n	a12, a12, -1
4200f44e:	881b      	addi.n	a8, a8, 1
4200f450:	ccba      	add.n	a12, a12, a11
4200f452:	1659      	s32i.n	a5, a6, 4
4200f454:	8f61c2        	s32i	a12, a1, 0x23c
4200f457:	8e6182        	s32i	a8, a1, 0x238
4200f45a:	10c1a2        	addi	a10, a1, 16
4200f45d:	08c662        	addi	a6, a6, 8
4200f460:	0288e6        	bgei	a8, 8, 4200f466 <_vfprintf_r+0x2a06>
4200f463:	002646        	j	4200f500 <_vfprintf_r+0x2aa0>
4200f466:	24a2c2        	movi	a12, 0x224
4200f469:	80cac0        	add	a12, a10, a12
4200f46c:	a021b2        	l32i	a11, a1, 0x280
4200f46f:	a121a2        	l32i	a10, a1, 0x284
4200f472:	201110        	or	a1, a1, a1
4200f475:	007a25        	call8	4200fc18 <__sprint_r>
4200f478:	1c0a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f47b:	f4a162        	movi	a6, 0x1f4
4200f47e:	616a      	add.n	a6, a1, a6
4200f480:	001f06        	j	4200f500 <_vfprintf_r+0x2aa0>
4200f483:	218200        	srai	a8, a0, 2
4200f486:	28a6a4        	lsi	f10, a6, 160
4200f489:	c14275        	call12	41fd08b0 <_coredump_iram_end+0x1c4e8b0>
4200f48c:	0a4610        	add.s	f4, f6, f1
4200f48f:	cbb200        	movf.s	f11, f2, b0
4200f492:	16d910        	lsi	f1, a9, 88
4200f495:	b9b9      	s32i.n	a11, a9, 44
4200f497:	a989      	s32i.n	a8, a9, 40
4200f499:	1888a6        	blti	a8, 8, 4200f4b5 <_vfprintf_r+0x2a55>
4200f49c:	24a2c2        	movi	a12, 0x224
4200f49f:	a021b2        	l32i	a11, a1, 0x280
4200f4a2:	a121a2        	l32i	a10, a1, 0x284
4200f4a5:	c4ca      	add.n	a12, a4, a12
4200f4a7:	201110        	or	a1, a1, a1
4200f4aa:	0076e5        	call8	4200fc18 <__sprint_r>
4200f4ad:	18ba56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f4b0:	e4a1a2        	movi	a10, 0x1e4
4200f4b3:	a4aa      	add.n	a10, a4, a10
4200f4b5:	f0c552        	addi	a5, a5, -16
4200f4b8:	0a6d      	mov.n	a6, a10
4200f4ba:	c653c1        	l32r	a12, 42000e08 <_stext+0xde8> (3c029b04 <zeroes$0>)
4200f4bd:	8a2482        	l32i	a8, a4, 0x228
4200f4c0:	0d1c      	movi.n	a13, 16
4200f4c2:	06c9      	s32i.n	a12, a6, 0
4200f4c4:	02d492        	addmi	a9, a4, 0x200
4200f4c7:	881b      	addi.n	a8, a8, 1
4200f4c9:	a68b      	addi.n	a10, a6, 8
4200f4cb:	b9b8      	l32i.n	a11, a9, 44
4200f4cd:	bf2d57        	blt	a13, a5, 4200f490 <_vfprintf_r+0x2a30>
4200f4d0:	1659      	s32i.n	a5, a6, 4
4200f4d2:	55ba      	add.n	a5, a5, a11
4200f4d4:	24a2c2        	movi	a12, 0x224
4200f4d7:	b959      	s32i.n	a5, a9, 44
4200f4d9:	a989      	s32i.n	a8, a9, 40
4200f4db:	0a6d      	mov.n	a6, a10
4200f4dd:	c4ca      	add.n	a12, a4, a12
4200f4df:	8988e6        	bgei	a8, 8, 4200f46c <_vfprintf_r+0x2a0c>
4200f4e2:	000686        	j	4200f500 <_vfprintf_r+0x2aa0>
4200f4e5:	9f2192        	l32i	a9, a1, 0x27c
4200f4e8:	bea9      	s32i.n	a10, a14, 44
4200f4ea:	0299      	s32i.n	a9, a2, 0
4200f4ec:	190c      	movi.n	a9, 1
4200f4ee:	1299      	s32i.n	a9, a2, 4
4200f4f0:	ae89      	s32i.n	a8, a14, 40
4200f4f2:	0a88a6        	blti	a8, 8, 4200f500 <_vfprintf_r+0x2aa0>
4200f4f5:	24a2c2        	movi	a12, 0x224
4200f4f8:	10c182        	addi	a8, a1, 16
4200f4fb:	c8ca      	add.n	a12, a8, a12
4200f4fd:	ffdac6        	j	4200f46c <_vfprintf_r+0x2a0c>
4200f500:	10c122        	addi	a2, a1, 16
4200f503:	37a282        	movi	a8, 0x237
4200f506:	828a      	add.n	a8, a2, a8
4200f508:	0689      	s32i.n	a8, a6, 0
4200f50a:	b72182        	l32i	a8, a1, 0x2dc
4200f50d:	b721a2        	l32i	a10, a1, 0x2dc
4200f510:	1689      	s32i.n	a8, a6, 4
4200f512:	8b2282        	l32i	a8, a2, 0x22c
4200f515:	88aa      	add.n	a8, a8, a10
4200f517:	8b6282        	s32i	a8, a2, 0x22c
4200f51a:	8a2282        	l32i	a8, a2, 0x228
4200f51d:	881b      	addi.n	a8, a8, 1
4200f51f:	8a6282        	s32i	a8, a2, 0x228
4200f522:	0688e6        	bgei	a8, 8, 4200f52c <_vfprintf_r+0x2acc>
4200f525:	268b      	addi.n	a2, a6, 8
4200f527:	000686        	j	4200f545 <_vfprintf_r+0x2ae5>
4200f52a:	c20000        	quou	a0, a0, a0
4200f52d:	b224a2        	l32i	a10, a4, 0x2c8
4200f530:	a2a021        	l32r	a2, 41ff7fb0 <_coredump_iram_end+0x1c75fb0>
4200f533:	caa121        	l32r	a2, 42001fb8 <esp_panic_handler+0x114> (8102ad00 <_rtc_reserved_end+0x20f2ad00>)
4200f536:	1110c2        	l16ui	a12, a0, 34
4200f539:	6de520        	lsi	f2, a5, 0x1b4
4200f53c:	ba5600        	ceil.s	a5, f6, 0
4200f53f:	0f          	.byte	0xf
4200f540:	e4a182        	movi	a8, 0x1e4
4200f543:	228a      	add.n	a2, a2, a8
4200f545:	1be327        	bbsi	a3, 2, 4200f564 <_vfprintf_r+0x2b04>
4200f548:	af2192        	l32i	a9, a1, 0x2bc
4200f54b:	ac2182        	l32i	a8, a1, 0x2b0
4200f54e:	538890        	max	a8, a8, a9
4200f551:	ae2192        	l32i	a9, a1, 0x2b8
4200f554:	898a      	add.n	a8, a9, a8
4200f556:	ae6182        	s32i	a8, a1, 0x2b8
4200f559:	8f2182        	l32i	a8, a1, 0x23c
4200f55c:	076816        	beqz	a8, 4200f5d6 <_vfprintf_r+0x2b76>
4200f55f:	002046        	j	4200f5e4 <_vfprintf_r+0x2b84>
4200f562:	820000        	mull	a0, a0, a0
4200f565:	92ac21        	l32r	a2, 41ff4018 <_coredump_iram_end+0x1c72018>
4200f568:	90af21        	l32r	a2, 41ff3824 <_coredump_iram_end+0x1c71824>
4200f56b:	c068      	l32i.n	a6, a0, 48
4200f56d:	d716a6        	blti	a6, 1, 4200f548 <_vfprintf_r+0x2ae8>
4200f570:	10c152        	addi	a5, a1, 16
4200f573:	000a46        	j	4200f5a0 <_vfprintf_r+0x2b40>
4200f576:	10caa2        	addi	a10, a10, 16
4200f579:	12c9      	s32i.n	a12, a2, 4
4200f57b:	b9a9      	s32i.n	a10, a9, 44
4200f57d:	a989      	s32i.n	a8, a9, 40
4200f57f:	228b      	addi.n	a2, a2, 8
4200f581:	1888a6        	blti	a8, 8, 4200f59d <_vfprintf_r+0x2b3d>
4200f584:	24a2c2        	movi	a12, 0x224
4200f587:	a021b2        	l32i	a11, a1, 0x280
4200f58a:	a121a2        	l32i	a10, a1, 0x284
4200f58d:	c5ca      	add.n	a12, a5, a12
4200f58f:	201110        	or	a1, a1, a1
4200f592:	006865        	call8	4200fc18 <__sprint_r>
4200f595:	0a3a56        	bnez	a10, 4200f63c <_vfprintf_r+0x2bdc>
4200f598:	e4a182        	movi	a8, 0x1e4
4200f59b:	258a      	add.n	a2, a5, a8
4200f59d:	f0c662        	addi	a6, a6, -16
4200f5a0:	c619b1        	l32r	a11, 42000e04 <_stext+0xde4> (3c029b14 <blanks$1>)
4200f5a3:	8a2582        	l32i	a8, a5, 0x228
4200f5a6:	0c1c      	movi.n	a12, 16
4200f5a8:	02b9      	s32i.n	a11, a2, 0
4200f5aa:	02d592        	addmi	a9, a5, 0x200
4200f5ad:	881b      	addi.n	a8, a8, 1
4200f5af:	b9a8      	l32i.n	a10, a9, 44
4200f5b1:	c12c67        	blt	a12, a6, 4200f576 <_vfprintf_r+0x2b16>
4200f5b4:	1269      	s32i.n	a6, a2, 4
4200f5b6:	66aa      	add.n	a6, a6, a10
4200f5b8:	b969      	s32i.n	a6, a9, 44
4200f5ba:	a989      	s32i.n	a8, a9, 40
4200f5bc:	8888a6        	blti	a8, 8, 4200f548 <_vfprintf_r+0x2ae8>
4200f5bf:	24a2c2        	movi	a12, 0x224
4200f5c2:	a021b2        	l32i	a11, a1, 0x280
4200f5c5:	a121a2        	l32i	a10, a1, 0x284
4200f5c8:	c5ca      	add.n	a12, a5, a12
4200f5ca:	201110        	or	a1, a1, a1
4200f5cd:	0064a5        	call8	4200fc18 <__sprint_r>
4200f5d0:	f74a16        	beqz	a10, 4200f548 <_vfprintf_r+0x2ae8>
4200f5d3:	001946        	j	4200f63c <_vfprintf_r+0x2bdc>
4200f5d6:	090c      	movi.n	a9, 0
4200f5d8:	a92182        	l32i	a8, a1, 0x2a4
4200f5db:	8e6192        	s32i	a9, a1, 0x238
4200f5de:	e8dc      	bnez.n	a8, 4200f600 <_vfprintf_r+0x2ba0>
4200f5e0:	f57186        	j	4200cbaa <_vfprintf_r+0x14a>
4200f5e3:	a2c200        	muluh	a12, a2, a0
4200f5e6:	c18224        	lsi	f2, a2, 0x304
4200f5e9:	21b210        	srai	a11, a1, 2
4200f5ec:	21a2a0        	srai	a10, a10, 2
4200f5ef:	c8caa1        	l32r	a10, 42001918 <esp_perip_clk_init+0x110> (20c00a <UserFrameTotalSize+0x20bf0a>)
4200f5f2:	201110        	or	a1, a1, a1
4200f5f5:	006225        	call8	4200fc18 <__sprint_r>
4200f5f8:	fdaa16        	beqz	a10, 4200f5d6 <_vfprintf_r+0x2b76>
4200f5fb:	000f46        	j	4200f63c <_vfprintf_r+0x2bdc>
4200f5fe:	b20000        	mulsh	a0, a0, a0
4200f601:	a2a921        	l32r	a2, 41ff80a8 <_coredump_iram_end+0x1c760a8>
4200f604:	81a121        	l32r	a2, 41fefc88 <_coredump_iram_end+0x1c6dc88>
4200f607:	e0c5d2        	addi	a13, a5, -32
4200f60a:	0008      	l32i.n	a0, a0, 0
4200f60c:	f56686        	j	4200cbaa <_vfprintf_r+0x14a>
4200f60f:	218200        	srai	a8, a0, 2
4200f612:	8f          	.byte	0x8f
4200f613:	10c172        	addi	a7, a1, 16
4200f616:	a8cc      	bnez.n	a8, 4200f624 <_vfprintf_r+0x2bc4>
4200f618:	080c      	movi.n	a8, 0
4200f61a:	8a6782        	s32i	a8, a7, 0x228
4200f61d:	02d772        	addmi	a7, a7, 0x200
4200f620:	000a06        	j	4200f64c <_vfprintf_r+0x2bec>
4200f623:	a2c200        	muluh	a12, a2, a0
4200f626:	21b224        	lsi	f2, a2, 132
4200f629:	21a2a0        	srai	a10, a10, 2
4200f62c:	c7caa1        	l32r	a10, 42001554 <start_other_core+0x70> (c0089900 <_rtc_reserved_end+0x5ff89900>)
4200f62f:	201110        	or	a1, a1, a1
4200f632:	005e65        	call8	4200fc18 <__sprint_r>
4200f635:	fdfa16        	beqz	a10, 4200f618 <_vfprintf_r+0x2bb8>
4200f638:	000406        	j	4200f64c <_vfprintf_r+0x2bec>
4200f63b:	218200        	srai	a8, a0, 2
4200f63e:	8ca9      	s32i.n	a10, a12, 32
4200f640:	a298      	l32i.n	a9, a2, 40
4200f642:	bda121        	l32r	a2, 41ffecc8 <_coredump_iram_end+0x1c7ccc8>
4200f645:	8108      	l32i.n	a0, a1, 32
4200f647:	e0c5c2        	addi	a12, a5, -32
4200f64a:	0008      	l32i.n	a0, a0, 0
4200f64c:	a02182        	l32i	a8, a1, 0x280
4200f64f:	192882        	l32i	a8, a8, 100
4200f652:	14e807        	bbsi	a8, 0, 4200f66a <_vfprintf_r+0x2c0a>
4200f655:	a02182        	l32i	a8, a1, 0x280
4200f658:	061882        	l16ui	a8, a8, 12
4200f65b:	0be897        	bbsi	a8, 9, 4200f66a <_vfprintf_r+0x2c0a>
4200f65e:	a02182        	l32i	a8, a1, 0x280
4200f661:	1628a2        	l32i	a10, a8, 88
4200f664:	c5ba81        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200f667:	0008e0        	callx8	a8
4200f66a:	a02182        	l32i	a8, a1, 0x280
4200f66d:	061882        	l16ui	a8, a8, 12
4200f670:	146867        	bbci	a8, 6, 4200f688 <_vfprintf_r+0x2c28>
4200f673:	f51c86        	j	4200cae9 <_vfprintf_r+0x89>
4200f676:	820000        	mull	a0, a0, a0
4200f679:	ada221        	l32r	a2, 41ffad04 <_coredump_iram_end+0x1c78d04>
4200f67c:	190c03        	lsi	f0, a12, 100
4200f67f:	002896        	bltz	a8, 4200f685 <_vfprintf_r+0x2c25>
4200f682:	fcb1c6        	j	4200e94d <_vfprintf_r+0x1eed>
4200f685:	fcccc6        	j	4200e9bc <_vfprintf_r+0x1f5c>
4200f688:	ae2122        	l32i	a2, a1, 0x2b8
4200f68b:	f01d      	retw.n
4200f68d:	000000        	ill

4200f690 <vfprintf>:
4200f690:	006136        	entry	a1, 48
4200f693:	0149      	s32i.n	a4, a1, 0
4200f695:	1159      	s32i.n	a5, a1, 4
4200f697:	026162        	s32i	a6, a1, 8
4200f69a:	c42d81        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
4200f69d:	0008e0        	callx8	a8
4200f6a0:	01d8      	l32i.n	a13, a1, 0
4200f6a2:	11e8      	l32i.n	a14, a1, 4
4200f6a4:	21f8      	l32i.n	a15, a1, 8
4200f6a6:	02bd      	mov.n	a11, a2
4200f6a8:	03cd      	mov.n	a12, a3
4200f6aa:	fd3b65        	call8	4200ca60 <_vfprintf_r>
4200f6ad:	0a2d      	mov.n	a2, a10
4200f6af:	f01d      	retw.n
4200f6b1:	000000        	ill

4200f6b4 <__sbprintf>:
4200f6b4:	024136        	entry	a1, 0x120
4200f6b7:	078d      	mov.n	a8, a7
4200f6b9:	027d      	mov.n	a7, a2
4200f6bb:	f0a022        	movi	a2, 240
4200f6be:	212a      	add.n	a2, a1, a2
4200f6c0:	2289      	s32i.n	a8, a2, 8
4200f6c2:	061382        	l16ui	a8, a3, 12
4200f6c5:	d97c      	movi.n	a9, -3
4200f6c7:	108890        	and	a8, a8, a9
4200f6ca:	465182        	s16i	a8, a1, 140
4200f6cd:	192382        	l32i	a8, a3, 100
4200f6d0:	1269      	s32i.n	a6, a2, 4
4200f6d2:	396182        	s32i	a8, a1, 228
4200f6d5:	071382        	l16ui	a8, a3, 14
4200f6d8:	80a062        	movi	a6, 128
4200f6db:	475182        	s16i	a8, a1, 142
4200f6de:	8388      	l32i.n	a8, a3, 32
4200f6e0:	226162        	s32i	a6, a1, 136
4200f6e3:	286182        	s32i	a8, a1, 160
4200f6e6:	a388      	l32i.n	a8, a3, 40
4200f6e8:	256162        	s32i	a6, a1, 148
4200f6eb:	616a      	add.n	a6, a1, a6
4200f6ed:	0259      	s32i.n	a5, a2, 0
4200f6ef:	2a6182        	s32i	a8, a1, 168
4200f6f2:	58c6a2        	addi	a10, a6, 88
4200f6f5:	080c      	movi.n	a8, 0
4200f6f7:	266182        	s32i	a8, a1, 152
4200f6fa:	206112        	s32i	a1, a1, 128
4200f6fd:	246112        	s32i	a1, a1, 144
4200f700:	c59f81        	l32r	a8, 42000d7c <_stext+0xd5c> (40376a90 <__retarget_lock_init_recursive>)
4200f703:	0008e0        	callx8	a8
4200f706:	02d8      	l32i.n	a13, a2, 0
4200f708:	12e8      	l32i.n	a14, a2, 4
4200f70a:	22f8      	l32i.n	a15, a2, 8
4200f70c:	04cd      	mov.n	a12, a4
4200f70e:	06bd      	mov.n	a11, a6
4200f710:	07ad      	mov.n	a10, a7
4200f712:	fd34e5        	call8	4200ca60 <_vfprintf_r>
4200f715:	0a2d      	mov.n	a2, a10
4200f717:	00ea96        	bltz	a10, 4200f729 <__sbprintf+0x75>
4200f71a:	06bd      	mov.n	a11, a6
4200f71c:	07ad      	mov.n	a10, a7
4200f71e:	201110        	or	a1, a1, a1
4200f721:	fc02a5        	call8	4200b74c <_fflush_r>
4200f724:	f87c      	movi.n	a8, -1
4200f726:	9328a0        	movnez	a2, a8, a10
4200f729:	461182        	l16ui	a8, a1, 140
4200f72c:	094c      	movi.n	a9, 64
4200f72e:	080897        	bnone	a8, a9, 4200f73a <__sbprintf+0x86>
4200f731:	061382        	l16ui	a8, a3, 12
4200f734:	208890        	or	a8, a8, a9
4200f737:	065382        	s16i	a8, a3, 12
4200f73a:	3621a2        	l32i	a10, a1, 216
4200f73d:	c58581        	l32r	a8, 42000d54 <_stext+0xd34> (40376ab4 <__retarget_lock_close_recursive>)
4200f740:	0008e0        	callx8	a8
4200f743:	f01d      	retw.n
4200f745:	000000        	ill

4200f748 <get_arg$isra$0>:
4200f748:	008136        	entry	a1, 64
4200f74b:	102182        	l32i	a8, a1, 64
4200f74e:	1179      	s32i.n	a7, a1, 4
4200f750:	0878      	l32i.n	a7, a8, 0
4200f752:	2129      	s32i.n	a2, a1, 8
4200f754:	21e8      	l32i.n	a14, a1, 8
4200f756:	0528      	l32i.n	a2, a5, 0
4200f758:	4159      	s32i.n	a5, a1, 16
4200f75a:	0169      	s32i.n	a6, a1, 0
4200f75c:	837370        	moveqz	a7, a3, a7
4200f75f:	00e306        	j	4200faef <get_arg$isra$0+0x3a7>
4200f762:	771b      	addi.n	a7, a7, 1
4200f764:	000782        	l8ui	a8, a7, 0
4200f767:	42f816        	beqz	a8, 4200fb9a <get_arg$isra$0+0x452>
4200f76a:	dbc8a2        	addi	a10, a8, -37
4200f76d:	ff1a56        	bnez	a10, 4200f762 <get_arg$isra$0+0x1a>
4200f770:	426816        	beqz	a8, 4200fb9a <get_arg$isra$0+0x452>
4200f773:	080c      	movi.n	a8, 0
4200f775:	a71b      	addi.n	a10, a7, 1
4200f777:	050c      	movi.n	a5, 0
4200f779:	0d0c      	movi.n	a13, 0
4200f77b:	f37c      	movi.n	a3, -1
4200f77d:	060c      	movi.n	a6, 0
4200f77f:	3189      	s32i.n	a8, a1, 12
4200f781:	000046        	j	4200f786 <get_arg$isra$0+0x3e>
4200f784:	07ad      	mov.n	a10, a7
4200f786:	c59091        	l32r	a9, 42000dc8 <_stext+0xda8> (3c02a19c <__chclass>)
4200f789:	000a82        	l8ui	a8, a10, 0
4200f78c:	7a1b      	addi.n	a7, a10, 1
4200f78e:	b98a      	add.n	a11, a9, a8
4200f790:	3198      	l32i.n	a9, a1, 12
4200f792:	000bc2        	l8ui	a12, a11, 0
4200f795:	c58db1        	l32r	a11, 42000dcc <_stext+0xdac> (3c02a130 <__state_table>)
4200f798:	b0f990        	addx8	a15, a9, a9
4200f79b:	bbfa      	add.n	a11, a11, a15
4200f79d:	bbca      	add.n	a11, a11, a12
4200f79f:	000b92        	l8ui	a9, a11, 0
4200f7a2:	c58bb1        	l32r	a11, 42000dd0 <_stext+0xdb0> (3c02a0c4 <__action_table>)
4200f7a5:	3199      	s32i.n	a9, a1, 12
4200f7a7:	bbfa      	add.n	a11, a11, a15
4200f7a9:	bbca      	add.n	a11, a11, a12
4200f7ab:	000bb2        	l8ui	a11, a11, 0
4200f7ae:	bb0b      	addi.n	a11, a11, -1
4200f7b0:	74b0b0        	extui	a11, a11, 0, 8
4200f7b3:	028bb6        	bltui	a11, 8, 4200f7b9 <get_arg$isra$0+0x71>
4200f7b6:	00cac6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f7b9:	c5a2c1        	l32r	a12, 42000e44 <_stext+0xe24> (3c029b24 <blanks$1+0x10>)
4200f7bc:	a0bbc0        	addx4	a11, a11, a12
4200f7bf:	0bb8      	l32i.n	a11, a11, 0
4200f7c1:	000ba0        	jx	a11
4200f7c4:	0c0000        	lsi	f0, a0, 48
4200f7c7:	069a      	add.n	a0, a6, a9
4200f7c9:	ad00c2        	l8ui	a12, a0, 173
4200f7cc:	ac4607        	ball	a6, a0, 4200f77c <get_arg$isra$0+0x34>
4200f7cf:	a0b200        	addx4	a11, a2, a0
4200f7d2:	b76a      	add.n	a11, a7, a6
4200f7d4:	3318      	l32i.n	a1, a3, 12
4200f7d6:	0a3b87        	bltu	a11, a8, 4200f7e4 <get_arg$isra$0+0x9c>
4200f7d9:	cb4c      	movi.n	a11, 76
4200f7db:	2618b7        	beq	a8, a11, 4200f805 <get_arg$isra$0+0xbd>
4200f7de:	68a0b2        	movi	a11, 104
4200f7e1:	0005c6        	j	4200f7fc <get_arg$isra$0+0xb4>
4200f7e4:	71a0b2        	movi	a11, 113
4200f7e7:	1f18b7        	beq	a8, a11, 4200f80a <get_arg$isra$0+0xc2>
4200f7ea:	70a0b2        	movi	a11, 112
4200f7ed:	23bb87        	bgeu	a11, a8, 4200f814 <get_arg$isra$0+0xcc>
4200f7f0:	74a0b2        	movi	a11, 116
4200f7f3:	0298b7        	bne	a8, a11, 4200f7f9 <get_arg$isra$0+0xb1>
4200f7f6:	00bac6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f7f9:	7aa0b2        	movi	a11, 122
4200f7fc:	0298b7        	bne	a8, a11, 4200f802 <get_arg$isra$0+0xba>
4200f7ff:	00b886        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f802:	000386        	j	4200f814 <get_arg$isra$0+0xcc>
4200f805:	880c      	movi.n	a8, 8
4200f807:	000046        	j	4200f80c <get_arg$isra$0+0xc4>
4200f80a:	082c      	movi.n	a8, 32
4200f80c:	206680        	or	a6, a6, a8
4200f80f:	00b486        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f812:	b20000        	mulsh	a0, a0, a0
4200f815:	010a      	add.n	a0, a1, a0
4200f817:	6ca082        	movi	a8, 108
4200f81a:	0a9b87        	bne	a11, a8, 4200f828 <get_arg$isra$0+0xe0>
4200f81d:	082c      	movi.n	a8, 32
4200f81f:	206680        	or	a6, a6, a8
4200f822:	7a2b      	addi.n	a7, a10, 2
4200f824:	00af46        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f827:	081c00        	lsx	f1, a12, a0
4200f82a:	fff786        	j	4200f80c <get_arg$isra$0+0xc4>
4200f82d:	61a0b2        	movi	a11, 97
4200f830:	44a020        	extui	a10, a2, 0, 5
4200f833:	0298b7        	bne	a8, a11, 4200f839 <get_arg$isra$0+0xf1>
4200f836:	00e506        	j	4200fbce <get_arg$isra$0+0x486>
4200f839:	3b3b87        	bltu	a11, a8, 4200f878 <get_arg$isra$0+0x130>
4200f83c:	bfc882        	addi	a8, a8, -65
4200f83f:	748080        	extui	a8, a8, 0, 8
4200f842:	7b1c      	movi.n	a11, 23
4200f844:	24bb87        	bgeu	a11, a8, 4200f86c <get_arg$isra$0+0x124>
4200f847:	001686        	j	4200f8a5 <get_arg$isra$0+0x15d>
4200f84a:	180c      	movi.n	a8, 1
4200f84c:	401b00        	ssl	a11
4200f84f:	a18800        	sll	a8, a8
4200f852:	c561b1        	l32r	a11, 42000dd8 <_stext+0xdb8> (120821 <UserFrameTotalSize+0x120721>)
4200f855:	3388b7        	bany	a8, a11, 4200f88c <get_arg$isra$0+0x144>
4200f858:	5b2c      	movi.n	a11, 37
4200f85a:	11bb60        	slli	a11, a11, 10
4200f85d:	0208b7        	bnone	a8, a11, 4200f863 <get_arg$isra$0+0x11b>
4200f860:	00dd46        	j	4200fbd9 <get_arg$isra$0+0x491>
4200f863:	248180        	extui	a8, a8, 1, 3
4200f866:	364856        	bnez	a8, 4200fbce <get_arg$isra$0+0x486>
4200f869:	000e06        	j	4200f8a5 <get_arg$isra$0+0x15d>
4200f86c:	c577b1        	l32r	a11, 42000e48 <_stext+0xe28> (3c029b44 <blanks$1+0x30>)
4200f86f:	a088b0        	addx4	a8, a8, a11
4200f872:	0888      	l32i.n	a8, a8, 0
4200f874:	0008a0        	jx	a8
4200f877:	a0b200        	addx4	a11, a2, a0
4200f87a:	18b763        	lsi	f6, a7, 96
4200f87d:	8219      	s32i.n	a1, a2, 32
4200f87f:	9cc8      	l32i.n	a12, a12, 36
4200f881:	74b080        	extui	a11, a8, 0, 8
4200f884:	481c      	movi.n	a8, 20
4200f886:	c0b8b7        	bgeu	a8, a11, 4200f84a <get_arg$isra$0+0x102>
4200f889:	000606        	j	4200f8a5 <get_arg$isra$0+0x15d>
4200f88c:	045560        	extui	a5, a6, 5, 1
4200f88f:	555a      	add.n	a5, a5, a5
4200f891:	106647        	bbci	a6, 4, 4200f8a5 <get_arg$isra$0+0x15d>
4200f894:	00d806        	j	4200fbf8 <get_arg$isra$0+0x4b0>
4200f897:	051c00        	extui	a1, a0, 28, 1
4200f89a:	105650        	and	a5, a6, a5
4200f89d:	34c556        	bnez	a5, 4200fbed <get_arg$isra$0+0x4a5>
4200f8a0:	00d006        	j	4200fbe4 <get_arg$isra$0+0x49c>
4200f8a3:	260000        	lsi	f0, a0, 152
4200f8a6:	880b03        	lsi	f0, a11, 0x220
4200f8a9:	0a2d11        	l32r	a1, 41fd2160 <_coredump_iram_end+0x1c50160>
4200f8ac:	a08380        	addx4	a8, a3, a8
4200f8af:	0859      	s32i.n	a5, a8, 0
4200f8b1:	008c06        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f8b4:	b50b      	addi.n	a11, a5, -1
4200f8b6:	2488      	l32i.n	a8, a4, 8
4200f8b8:	2a1b      	addi.n	a2, a10, 1
4200f8ba:	026bb6        	bltui	a11, 6, 4200f8c0 <get_arg$isra$0+0x178>
4200f8bd:	002806        	j	4200f961 <get_arg$isra$0+0x219>
4200f8c0:	c563c1        	l32r	a12, 42000e4c <_stext+0xe2c> (3c029ba4 <blanks$1+0x90>)
4200f8c3:	a0bbc0        	addx4	a11, a11, a12
4200f8c6:	0bc8      	l32i.n	a12, a11, 0
4200f8c8:	f4b0a0        	extui	a11, a10, 0, 16
4200f8cb:	000ca0        	jx	a12
4200f8ce:	0188      	l32i.n	a8, a1, 0
4200f8d0:	24b8      	l32i.n	a11, a4, 8
4200f8d2:	2a1b      	addi.n	a2, a10, 1
4200f8d4:	b0aa80        	addx8	a10, a10, a8
4200f8d7:	8b4b      	addi.n	a8, a11, 4
4200f8d9:	2489      	s32i.n	a8, a4, 8
4200f8db:	8c1c      	movi.n	a12, 24
4200f8dd:	042c87        	blt	a12, a8, 4200f8e5 <get_arg$isra$0+0x19d>
4200f8e0:	14b8      	l32i.n	a11, a4, 4
4200f8e2:	000206        	j	4200f8ee <get_arg$isra$0+0x1a6>
4200f8e5:	012cb7        	blt	a12, a11, 4200f8ea <get_arg$isra$0+0x1a2>
4200f8e8:	482c      	movi.n	a8, 36
4200f8ea:	04b8      	l32i.n	a11, a4, 0
4200f8ec:	2489      	s32i.n	a8, a4, 8
4200f8ee:	bb8a      	add.n	a11, a11, a8
4200f8f0:	fccbb2        	addi	a11, a11, -4
4200f8f3:	0b88      	l32i.n	a8, a11, 0
4200f8f5:	f37c      	movi.n	a3, -1
4200f8f7:	0a89      	s32i.n	a8, a10, 0
4200f8f9:	150c      	movi.n	a5, 1
4200f8fb:	007986        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f8fe:	8a7c      	movi.n	a10, -8
4200f900:	887b      	addi.n	a8, a8, 7
4200f902:	1088a0        	and	a8, a8, a10
4200f905:	0198      	l32i.n	a9, a1, 0
4200f907:	a88b      	addi.n	a10, a8, 8
4200f909:	24a9      	s32i.n	a10, a4, 8
4200f90b:	8c1c      	movi.n	a12, 24
4200f90d:	b0bb90        	addx8	a11, a11, a9
4200f910:	042ca7        	blt	a12, a10, 4200f918 <get_arg$isra$0+0x1d0>
4200f913:	1488      	l32i.n	a8, a4, 4
4200f915:	000206        	j	4200f921 <get_arg$isra$0+0x1d9>
4200f918:	012c87        	blt	a12, a8, 4200f91d <get_arg$isra$0+0x1d5>
4200f91b:	8a2c      	movi.n	a10, 40
4200f91d:	0488      	l32i.n	a8, a4, 0
4200f91f:	24a9      	s32i.n	a10, a4, 8
4200f921:	88aa      	add.n	a8, a8, a10
4200f923:	f8c882        	addi	a8, a8, -8
4200f926:	1898      	l32i.n	a9, a8, 4
4200f928:	0888      	l32i.n	a8, a8, 0
4200f92a:	1b99      	s32i.n	a9, a11, 4
4200f92c:	0b89      	s32i.n	a8, a11, 0
4200f92e:	006cc6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f931:	0188      	l32i.n	a8, a1, 0
4200f933:	24b8      	l32i.n	a11, a4, 8
4200f935:	2a1b      	addi.n	a2, a10, 1
4200f937:	b0aa80        	addx8	a10, a10, a8
4200f93a:	8b4b      	addi.n	a8, a11, 4
4200f93c:	2489      	s32i.n	a8, a4, 8
4200f93e:	8c1c      	movi.n	a12, 24
4200f940:	042c87        	blt	a12, a8, 4200f948 <get_arg$isra$0+0x200>
4200f943:	14b8      	l32i.n	a11, a4, 4
4200f945:	000206        	j	4200f951 <get_arg$isra$0+0x209>
4200f948:	012cb7        	blt	a12, a11, 4200f94d <get_arg$isra$0+0x205>
4200f94b:	482c      	movi.n	a8, 36
4200f94d:	04b8      	l32i.n	a11, a4, 0
4200f94f:	2489      	s32i.n	a8, a4, 8
4200f951:	bb8a      	add.n	a11, a11, a8
4200f953:	fccbb2        	addi	a11, a11, -4
4200f956:	0b88      	l32i.n	a8, a11, 0
4200f958:	f37c      	movi.n	a3, -1
4200f95a:	0a89      	s32i.n	a8, a10, 0
4200f95c:	650c      	movi.n	a5, 6
4200f95e:	0060c6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f961:	0188      	l32i.n	a8, a1, 0
4200f963:	24b8      	l32i.n	a11, a4, 8
4200f965:	2a1b      	addi.n	a2, a10, 1
4200f967:	b0aa80        	addx8	a10, a10, a8
4200f96a:	8b4b      	addi.n	a8, a11, 4
4200f96c:	2489      	s32i.n	a8, a4, 8
4200f96e:	8c1c      	movi.n	a12, 24
4200f970:	042c87        	blt	a12, a8, 4200f978 <get_arg$isra$0+0x230>
4200f973:	14b8      	l32i.n	a11, a4, 4
4200f975:	000206        	j	4200f981 <get_arg$isra$0+0x239>
4200f978:	012cb7        	blt	a12, a11, 4200f97d <get_arg$isra$0+0x235>
4200f97b:	482c      	movi.n	a8, 36
4200f97d:	04b8      	l32i.n	a11, a4, 0
4200f97f:	2489      	s32i.n	a8, a4, 8
4200f981:	bb8a      	add.n	a11, a11, a8
4200f983:	fccbb2        	addi	a11, a11, -4
4200f986:	0b88      	l32i.n	a8, a11, 0
4200f988:	f37c      	movi.n	a3, -1
4200f98a:	0a89      	s32i.n	a8, a10, 0
4200f98c:	050c      	movi.n	a5, 0
4200f98e:	0054c6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f991:	0188      	l32i.n	a8, a1, 0
4200f993:	24b8      	l32i.n	a11, a4, 8
4200f995:	2a1b      	addi.n	a2, a10, 1
4200f997:	b0aa80        	addx8	a10, a10, a8
4200f99a:	8b4b      	addi.n	a8, a11, 4
4200f99c:	2489      	s32i.n	a8, a4, 8
4200f99e:	8c1c      	movi.n	a12, 24
4200f9a0:	042c87        	blt	a12, a8, 4200f9a8 <get_arg$isra$0+0x260>
4200f9a3:	14b8      	l32i.n	a11, a4, 4
4200f9a5:	000206        	j	4200f9b1 <get_arg$isra$0+0x269>
4200f9a8:	012cb7        	blt	a12, a11, 4200f9ad <get_arg$isra$0+0x265>
4200f9ab:	482c      	movi.n	a8, 36
4200f9ad:	04b8      	l32i.n	a11, a4, 0
4200f9af:	2489      	s32i.n	a8, a4, 8
4200f9b1:	bb8a      	add.n	a11, a11, a8
4200f9b3:	fccbb2        	addi	a11, a11, -4
4200f9b6:	0b88      	l32i.n	a8, a11, 0
4200f9b8:	f37c      	movi.n	a3, -1
4200f9ba:	0a89      	s32i.n	a8, a10, 0
4200f9bc:	350c      	movi.n	a5, 3
4200f9be:	0048c6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f9c1:	0188      	l32i.n	a8, a1, 0
4200f9c3:	2a1b      	addi.n	a2, a10, 1
4200f9c5:	b0aa80        	addx8	a10, a10, a8
4200f9c8:	2488      	l32i.n	a8, a4, 8
4200f9ca:	8b7c      	movi.n	a11, -8
4200f9cc:	887b      	addi.n	a8, a8, 7
4200f9ce:	1088b0        	and	a8, a8, a11
4200f9d1:	b88b      	addi.n	a11, a8, 8
4200f9d3:	24b9      	s32i.n	a11, a4, 8
4200f9d5:	8c1c      	movi.n	a12, 24
4200f9d7:	052cb7        	blt	a12, a11, 4200f9e0 <get_arg$isra$0+0x298>
4200f9da:	1488      	l32i.n	a8, a4, 4
4200f9dc:	000246        	j	4200f9e9 <get_arg$isra$0+0x2a1>
4200f9df:	2c8700        	lsi	f0, a7, 176
4200f9e2:	8b2c01        	l32r	a0, 41ff2694 <_coredump_iram_end+0x1c70694>
4200f9e5:	0488      	l32i.n	a8, a4, 0
4200f9e7:	24b9      	s32i.n	a11, a4, 8
4200f9e9:	88ba      	add.n	a8, a8, a11
4200f9eb:	f8c882        	addi	a8, a8, -8
4200f9ee:	1898      	l32i.n	a9, a8, 4
4200f9f0:	0888      	l32i.n	a8, a8, 0
4200f9f2:	f37c      	movi.n	a3, -1
4200f9f4:	0a89      	s32i.n	a8, a10, 0
4200f9f6:	1a99      	s32i.n	a9, a10, 4
4200f9f8:	450c      	movi.n	a5, 4
4200f9fa:	0039c6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200f9fd:	8a7c      	movi.n	a10, -8
4200f9ff:	887b      	addi.n	a8, a8, 7
4200fa01:	1088a0        	and	a8, a8, a10
4200fa04:	0198      	l32i.n	a9, a1, 0
4200fa06:	a88b      	addi.n	a10, a8, 8
4200fa08:	24a9      	s32i.n	a10, a4, 8
4200fa0a:	8c1c      	movi.n	a12, 24
4200fa0c:	b0bb90        	addx8	a11, a11, a9
4200fa0f:	052ca7        	blt	a12, a10, 4200fa18 <get_arg$isra$0+0x2d0>
4200fa12:	1488      	l32i.n	a8, a4, 4
4200fa14:	000246        	j	4200fa21 <get_arg$isra$0+0x2d9>
4200fa17:	2c8700        	lsi	f0, a7, 176
4200fa1a:	8a2c01        	l32r	a0, 41ff22cc <_coredump_iram_end+0x1c702cc>
4200fa1d:	0488      	l32i.n	a8, a4, 0
4200fa1f:	24a9      	s32i.n	a10, a4, 8
4200fa21:	88aa      	add.n	a8, a8, a10
4200fa23:	f8c882        	addi	a8, a8, -8
4200fa26:	1898      	l32i.n	a9, a8, 4
4200fa28:	0888      	l32i.n	a8, a8, 0
4200fa2a:	1b99      	s32i.n	a9, a11, 4
4200fa2c:	0b89      	s32i.n	a8, a11, 0
4200fa2e:	002cc6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200fa31:	1188      	l32i.n	a8, a1, 4
4200fa33:	0888      	l32i.n	a8, a8, 0
4200fa35:	140866        	bnei	a8, -1, 4200fa4d <get_arg$isra$0+0x305>
4200fa38:	11a8      	l32i.n	a10, a1, 4
4200fa3a:	80a0c2        	movi	a12, 128
4200fa3d:	0b0c      	movi.n	a11, 0
4200fa3f:	61d9      	s32i.n	a13, a1, 24
4200fa41:	51e9      	s32i.n	a14, a1, 20
4200fa43:	c22f81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200fa46:	0008e0        	callx8	a8
4200fa49:	61d8      	l32i.n	a13, a1, 24
4200fa4b:	51e8      	l32i.n	a14, a1, 20
4200fa4d:	3d0b      	addi.n	a3, a13, -1
4200fa4f:	53ee30        	max	a14, a14, a3
4200fa52:	0023c6        	j	4200fae5 <get_arg$isra$0+0x39d>
4200fa55:	1188      	l32i.n	a8, a1, 4
4200fa57:	0888      	l32i.n	a8, a8, 0
4200fa59:	140866        	bnei	a8, -1, 4200fa71 <get_arg$isra$0+0x329>
4200fa5c:	11a8      	l32i.n	a10, a1, 4
4200fa5e:	80a0c2        	movi	a12, 128
4200fa61:	0b0c      	movi.n	a11, 0
4200fa63:	61d9      	s32i.n	a13, a1, 24
4200fa65:	51e9      	s32i.n	a14, a1, 20
4200fa67:	c22681        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200fa6a:	0008e0        	callx8	a8
4200fa6d:	61d8      	l32i.n	a13, a1, 24
4200fa6f:	51e8      	l32i.n	a14, a1, 20
4200fa71:	1188      	l32i.n	a8, a1, 4
4200fa73:	dd0b      	addi.n	a13, a13, -1
4200fa75:	a08d80        	addx4	a8, a13, a8
4200fa78:	0a0c      	movi.n	a10, 0
4200fa7a:	08a9      	s32i.n	a10, a8, 0
4200fa7c:	53eed0        	max	a14, a14, a13
4200fa7f:	001886        	j	4200fae5 <get_arg$isra$0+0x39d>
4200fa82:	0188      	l32i.n	a8, a1, 0
4200fa84:	24b8      	l32i.n	a11, a4, 8
4200fa86:	f21b      	addi.n	a15, a2, 1
4200fa88:	b02280        	addx8	a2, a2, a8
4200fa8b:	8b4b      	addi.n	a8, a11, 4
4200fa8d:	2489      	s32i.n	a8, a4, 8
4200fa8f:	8c1c      	movi.n	a12, 24
4200fa91:	042c87        	blt	a12, a8, 4200fa99 <get_arg$isra$0+0x351>
4200fa94:	14b8      	l32i.n	a11, a4, 4
4200fa96:	000206        	j	4200faa2 <get_arg$isra$0+0x35a>
4200fa99:	012cb7        	blt	a12, a11, 4200fa9e <get_arg$isra$0+0x356>
4200fa9c:	482c      	movi.n	a8, 36
4200fa9e:	04b8      	l32i.n	a11, a4, 0
4200faa0:	2489      	s32i.n	a8, a4, 8
4200faa2:	bb8a      	add.n	a11, a11, a8
4200faa4:	fccbb2        	addi	a11, a11, -4
4200faa7:	0b88      	l32i.n	a8, a11, 0
4200faa9:	0a7d      	mov.n	a7, a10
4200faab:	0289      	s32i.n	a8, a2, 0
4200faad:	0f2d      	mov.n	a2, a15
4200faaf:	000c86        	j	4200fae5 <get_arg$isra$0+0x39d>
4200fab2:	d20000        	quos	a0, a0, a0
4200fab5:	d0c8      	l32i.n	a12, a0, 52
4200fab7:	9a0c      	movi.n	a10, 9
4200fab9:	0001c6        	j	4200fac4 <get_arg$isra$0+0x37c>
4200fabc:	a0ddd0        	addx4	a13, a13, a13
4200fabf:	90dd80        	addx2	a13, a13, a8
4200fac2:	771b      	addi.n	a7, a7, 1
4200fac4:	000782        	l8ui	a8, a7, 0
4200fac7:	a89c      	beqz.n	a8, 4200fae5 <get_arg$isra$0+0x39d>
4200fac9:	d0c882        	addi	a8, a8, -48
4200facc:	ecba87        	bgeu	a10, a8, 4200fabc <get_arg$isra$0+0x374>
4200facf:	000486        	j	4200fae5 <get_arg$isra$0+0x39d>
4200fad2:	820000        	mull	a0, a0, a0
4200fad5:	820007        	bnone	a0, a0, 4200fa5b <get_arg$isra$0+0x313>
4200fad8:	d0c8      	l32i.n	a12, a0, 52
4200fada:	748080        	extui	a8, a8, 0, 8
4200fadd:	043a87        	bltu	a10, a8, 4200fae5 <get_arg$isra$0+0x39d>
4200fae0:	771b      	addi.n	a7, a7, 1
4200fae2:	fffb86        	j	4200fad4 <get_arg$isra$0+0x38c>
4200fae5:	3198      	l32i.n	a9, a1, 12
4200fae7:	b80c      	movi.n	a8, 11
4200fae9:	021987        	beq	a9, a8, 4200faef <get_arg$isra$0+0x3a7>
4200faec:	ff2506        	j	4200f784 <get_arg$isra$0+0x3c>
4200faef:	0007a2        	l8ui	a10, a7, 0
4200faf2:	ea8c      	beqz.n	a10, 4200fb04 <get_arg$isra$0+0x3bc>
4200faf4:	2188      	l32i.n	a8, a1, 8
4200faf6:	728820        	lsi	f2, a8, 0x1c8
4200faf9:	880b      	addi.n	a8, a8, -1
4200fafb:	608080        	neg	a8, a8
4200fafe:	748080        	extui	a8, a8, 0, 8
4200fb01:	c5f856        	bnez	a8, 4200f764 <get_arg$isra$0+0x1c>
4200fb04:	2188      	l32i.n	a8, a1, 8
4200fb06:	93e8a0        	movnez	a14, a8, a10
4200fb09:	002346        	j	4200fb9a <get_arg$isra$0+0x452>
4200fb0c:	1188      	l32i.n	a8, a1, 4
4200fb0e:	a08d80        	addx4	a8, a13, a8
4200fb11:	08c8      	l32i.n	a12, a8, 0
4200fb13:	dd1b      	addi.n	a13, a13, 1
4200fb15:	cc0b      	addi.n	a12, a12, -1
4200fb17:	2488      	l32i.n	a8, a4, 8
4200fb19:	5c6cf6        	bgeui	a12, 6, 4200fb79 <get_arg$isra$0+0x431>
4200fb1c:	a0cc60        	addx4	a12, a12, a6
4200fb1f:	0cc8      	l32i.n	a12, a12, 0
4200fb21:	000ca0        	jx	a12
4200fb24:	887b      	addi.n	a8, a8, 7
4200fb26:	1088f0        	and	a8, a8, a15
4200fb29:	c88b      	addi.n	a12, a8, 8
4200fb2b:	24c9      	s32i.n	a12, a4, 8
4200fb2d:	042ac7        	blt	a10, a12, 4200fb35 <get_arg$isra$0+0x3ed>
4200fb30:	1488      	l32i.n	a8, a4, 4
4200fb32:	000206        	j	4200fb3e <get_arg$isra$0+0x3f6>
4200fb35:	012a87        	blt	a10, a8, 4200fb3a <get_arg$isra$0+0x3f2>
4200fb38:	8c2c      	movi.n	a12, 40
4200fb3a:	0488      	l32i.n	a8, a4, 0
4200fb3c:	24c9      	s32i.n	a12, a4, 8
4200fb3e:	88ca      	add.n	a8, a8, a12
4200fb40:	f8c882        	addi	a8, a8, -8
4200fb43:	1898      	l32i.n	a9, a8, 4
4200fb45:	0888      	l32i.n	a8, a8, 0
4200fb47:	1b99      	s32i.n	a9, a11, 4
4200fb49:	0b89      	s32i.n	a8, a11, 0
4200fb4b:	001706        	j	4200fbab <get_arg$isra$0+0x463>
4200fb4e:	887b      	addi.n	a8, a8, 7
4200fb50:	1088f0        	and	a8, a8, a15
4200fb53:	c88b      	addi.n	a12, a8, 8
4200fb55:	24c9      	s32i.n	a12, a4, 8
4200fb57:	052ac7        	blt	a10, a12, 4200fb60 <get_arg$isra$0+0x418>
4200fb5a:	1488      	l32i.n	a8, a4, 4
4200fb5c:	000246        	j	4200fb69 <get_arg$isra$0+0x421>
4200fb5f:	2a8700        	mul.s	f8, f7, f0
4200fb62:	8c2c01        	l32r	a0, 41ff2c14 <_coredump_iram_end+0x1c70c14>
4200fb65:	0488      	l32i.n	a8, a4, 0
4200fb67:	24c9      	s32i.n	a12, a4, 8
4200fb69:	88ca      	add.n	a8, a8, a12
4200fb6b:	f8c882        	addi	a8, a8, -8
4200fb6e:	1898      	l32i.n	a9, a8, 4
4200fb70:	0888      	l32i.n	a8, a8, 0
4200fb72:	1b99      	s32i.n	a9, a11, 4
4200fb74:	0b89      	s32i.n	a8, a11, 0
4200fb76:	000c46        	j	4200fbab <get_arg$isra$0+0x463>
4200fb79:	c84b      	addi.n	a12, a8, 4
4200fb7b:	24c9      	s32i.n	a12, a4, 8
4200fb7d:	042ac7        	blt	a10, a12, 4200fb85 <get_arg$isra$0+0x43d>
4200fb80:	1488      	l32i.n	a8, a4, 4
4200fb82:	000206        	j	4200fb8e <get_arg$isra$0+0x446>
4200fb85:	012a87        	blt	a10, a8, 4200fb8a <get_arg$isra$0+0x442>
4200fb88:	4c2c      	movi.n	a12, 36
4200fb8a:	0488      	l32i.n	a8, a4, 0
4200fb8c:	24c9      	s32i.n	a12, a4, 8
4200fb8e:	88ca      	add.n	a8, a8, a12
4200fb90:	fcc882        	addi	a8, a8, -4
4200fb93:	0888      	l32i.n	a8, a8, 0
4200fb95:	0b89      	s32i.n	a8, a11, 0
4200fb97:	000406        	j	4200fbab <get_arg$isra$0+0x463>
4200fb9a:	0188      	l32i.n	a8, a1, 0
4200fb9c:	c4ad61        	l32r	a6, 42000e50 <_stext+0xe30> (3c029bbc <blanks$1+0xa8>)
4200fb9f:	b0b280        	addx8	a11, a2, a8
4200fba2:	02dd      	mov.n	a13, a2
4200fba4:	8a1c      	movi.n	a10, 24
4200fba6:	8f7c      	movi.n	a15, -8
4200fba8:	000046        	j	4200fbad <get_arg$isra$0+0x465>
4200fbab:	bb8b      	addi.n	a11, a11, 8
4200fbad:	022ed7        	blt	a14, a13, 4200fbb3 <get_arg$isra$0+0x46b>
4200fbb0:	ffd606        	j	4200fb0c <get_arg$isra$0+0x3c4>
4200fbb3:	8e1b      	addi.n	a8, a14, 1
4200fbb5:	728820        	lsi	f2, a8, 0x1c8
4200fbb8:	880b      	addi.n	a8, a8, -1
4200fbba:	608080        	neg	a8, a8
4200fbbd:	748080        	extui	a8, a8, 0, 8
4200fbc0:	0a0c      	movi.n	a10, 0
4200fbc2:	d8bc      	beqz.n	a8, 4200fc03 <get_arg$isra$0+0x4bb>
4200fbc4:	820b      	addi.n	a8, a2, -1
4200fbc6:	608080        	neg	a8, a8
4200fbc9:	a8ea      	add.n	a10, a8, a14
4200fbcb:	000d06        	j	4200fc03 <get_arg$isra$0+0x4bb>
4200fbce:	450c      	movi.n	a5, 4
4200fbd0:	020326        	beqi	a3, -1, 4200fbd6 <get_arg$isra$0+0x48e>
4200fbd3:	ff3446        	j	4200f8a8 <get_arg$isra$0+0x160>
4200fbd6:	ff79c6        	j	4200f9c1 <get_arg$isra$0+0x279>
4200fbd9:	350c      	movi.n	a5, 3
4200fbdb:	020326        	beqi	a3, -1, 4200fbe1 <get_arg$isra$0+0x499>
4200fbde:	ff3186        	j	4200f8a8 <get_arg$isra$0+0x160>
4200fbe1:	ff6b06        	j	4200f991 <get_arg$isra$0+0x249>
4200fbe4:	020326        	beqi	a3, -1, 4200fbea <get_arg$isra$0+0x4a2>
4200fbe7:	ff2f46        	j	4200f8a8 <get_arg$isra$0+0x160>
4200fbea:	ff5cc6        	j	4200f961 <get_arg$isra$0+0x219>
4200fbed:	650c      	movi.n	a5, 6
4200fbef:	020326        	beqi	a3, -1, 4200fbf5 <get_arg$isra$0+0x4ad>
4200fbf2:	ff2c86        	j	4200f8a8 <get_arg$isra$0+0x160>
4200fbf5:	ff4e06        	j	4200f931 <get_arg$isra$0+0x1e9>
4200fbf8:	150c      	movi.n	a5, 1
4200fbfa:	020326        	beqi	a3, -1, 4200fc00 <get_arg$isra$0+0x4b8>
4200fbfd:	ff29c6        	j	4200f8a8 <get_arg$isra$0+0x160>
4200fc00:	ff3286        	j	4200f8ce <get_arg$isra$0+0x186>
4200fc03:	4198      	l32i.n	a9, a1, 16
4200fc05:	8a2a      	add.n	a8, a10, a2
4200fc07:	0989      	s32i.n	a8, a9, 0
4200fc09:	102182        	l32i	a8, a1, 64
4200fc0c:	0198      	l32i.n	a9, a1, 0
4200fc0e:	0879      	s32i.n	a7, a8, 0
4200fc10:	2188      	l32i.n	a8, a1, 8
4200fc12:	b02890        	addx8	a2, a8, a9
4200fc15:	f01d      	retw.n
	...

4200fc18 <__sprint_r>:
4200fc18:	004136        	entry	a1, 32
4200fc1b:	2488      	l32i.n	a8, a4, 8
4200fc1d:	02ad      	mov.n	a10, a2
4200fc1f:	03bd      	mov.n	a11, a3
4200fc21:	020c      	movi.n	a2, 0
4200fc23:	d88c      	beqz.n	a8, 4200fc34 <__sprint_r+0x1c>
4200fc25:	20c440        	or	a12, a4, a4
4200fc28:	201110        	or	a1, a1, a1
4200fc2b:	fbeda5        	call8	4200bb04 <__sfvwrite_r>
4200fc2e:	080c      	movi.n	a8, 0
4200fc30:	0a2d      	mov.n	a2, a10
4200fc32:	2489      	s32i.n	a8, a4, 8
4200fc34:	080c      	movi.n	a8, 0
4200fc36:	1489      	s32i.n	a8, a4, 4
4200fc38:	f01d      	retw.n
	...

4200fc3c <_vfiprintf_r>:
4200fc3c:	058136        	entry	a1, 0x2c0
4200fc3f:	996142        	s32i	a4, a1, 0x264
4200fc42:	9b6122        	s32i	a2, a1, 0x26c
4200fc45:	986132        	s32i	a3, a1, 0x260
4200fc48:	946152        	s32i	a5, a1, 0x250
4200fc4b:	956162        	s32i	a6, a1, 0x254
4200fc4e:	966172        	s32i	a7, a1, 0x258
4200fc51:	10c142        	addi	a4, a1, 16
4200fc54:	c28c      	beqz.n	a2, 4200fc64 <_vfiprintf_r+0x28>
4200fc56:	0a2282        	l32i	a8, a2, 40
4200fc59:	007856        	bnez	a8, 4200fc64 <_vfiprintf_r+0x28>
4200fc5c:	02ad      	mov.n	a10, a2
4200fc5e:	201110        	or	a1, a1, a1
4200fc61:	fbd525        	call8	4200b9b4 <__sinit>
4200fc64:	982182        	l32i	a8, a1, 0x260
4200fc67:	192882        	l32i	a8, a8, 100
4200fc6a:	14e807        	bbsi	a8, 0, 4200fc82 <_vfiprintf_r+0x46>
4200fc6d:	982182        	l32i	a8, a1, 0x260
4200fc70:	061882        	l16ui	a8, a8, 12
4200fc73:	0be897        	bbsi	a8, 9, 4200fc82 <_vfiprintf_r+0x46>
4200fc76:	982182        	l32i	a8, a1, 0x260
4200fc79:	1628a2        	l32i	a10, a8, 88
4200fc7c:	c43381        	l32r	a8, 42000d48 <_stext+0xd28> (40376ae4 <__retarget_lock_acquire_recursive>)
4200fc7f:	0008e0        	callx8	a8
4200fc82:	982182        	l32i	a8, a1, 0x260
4200fc85:	061882        	l16ui	a8, a8, 12
4200fc88:	066837        	bbci	a8, 3, 4200fc92 <_vfiprintf_r+0x56>
4200fc8b:	982182        	l32i	a8, a1, 0x260
4200fc8e:	4888      	l32i.n	a8, a8, 16
4200fc90:	58fc      	bnez.n	a8, 4200fcc9 <_vfiprintf_r+0x8d>
4200fc92:	9821b2        	l32i	a11, a1, 0x260
4200fc95:	9b21a2        	l32i	a10, a1, 0x26c
4200fc98:	201110        	or	a1, a1, a1
4200fc9b:	fc3065        	call8	4200bfa0 <__swsetup_r>
4200fc9e:	7aac      	beqz.n	a10, 4200fcc9 <_vfiprintf_r+0x8d>
4200fca0:	982182        	l32i	a8, a1, 0x260
4200fca3:	192882        	l32i	a8, a8, 100
4200fca6:	076807        	bbci	a8, 0, 4200fcb1 <_vfiprintf_r+0x75>
4200fca9:	f87c      	movi.n	a8, -1
4200fcab:	9d6182        	s32i	a8, a1, 0x274
4200fcae:	06f986        	j	42011898 <_vfiprintf_r+0x1c5c>
4200fcb1:	982182        	l32i	a8, a1, 0x260
4200fcb4:	061882        	l16ui	a8, a8, 12
4200fcb7:	eee897        	bbsi	a8, 9, 4200fca9 <_vfiprintf_r+0x6d>
4200fcba:	982182        	l32i	a8, a1, 0x260
4200fcbd:	1628a2        	l32i	a10, a8, 88
4200fcc0:	c42381        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200fcc3:	0008e0        	callx8	a8
4200fcc6:	fff7c6        	j	4200fca9 <_vfiprintf_r+0x6d>
4200fcc9:	982182        	l32i	a8, a1, 0x260
4200fccc:	069892        	l16si	a9, a8, 12
4200fccf:	1aa082        	movi	a8, 26
4200fcd2:	108980        	and	a8, a9, a8
4200fcd5:	439866        	bnei	a8, 10, 4200fd1c <_vfiprintf_r+0xe0>
4200fcd8:	982182        	l32i	a8, a1, 0x260
4200fcdb:	079882        	l16si	a8, a8, 14
4200fcde:	03a896        	bltz	a8, 4200fd1c <_vfiprintf_r+0xe0>
4200fce1:	982182        	l32i	a8, a1, 0x260
4200fce4:	192882        	l32i	a8, a8, 100
4200fce7:	0ee807        	bbsi	a8, 0, 4200fcf9 <_vfiprintf_r+0xbd>
4200fcea:	0be997        	bbsi	a9, 9, 4200fcf9 <_vfiprintf_r+0xbd>
4200fced:	982182        	l32i	a8, a1, 0x260
4200fcf0:	1628a2        	l32i	a10, a8, 88
4200fcf3:	c41681        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4200fcf6:	0008e0        	callx8	a8
4200fcf9:	9024d2        	l32i	a13, a4, 0x240
4200fcfc:	9124e2        	l32i	a14, a4, 0x244
4200fcff:	9224f2        	l32i	a15, a4, 0x248
4200fd02:	9921c2        	l32i	a12, a1, 0x264
4200fd05:	9821b2        	l32i	a11, a1, 0x260
4200fd08:	9b21a2        	l32i	a10, a1, 0x26c
4200fd0b:	02d442        	addmi	a4, a4, 0x200
4200fd0e:	201110        	or	a1, a1, a1
4200fd11:	01bb25        	call8	420118c4 <__sbprintf>
4200fd14:	9d61a2        	s32i	a10, a1, 0x274
4200fd17:	06df46        	j	42011898 <_vfiprintf_r+0x1c5c>
4200fd1a:	820000        	mull	a0, a0, a0
4200fd1d:	8ae4a1        	l32r	a10, 41ff28b0 <_coredump_iram_end+0x1c708b0>
4200fd20:	090c84        	lsi	f8, a12, 36
4200fd23:	896482        	s32i	a8, a4, 0x224
4200fd26:	976182        	s32i	a8, a1, 0x25c
4200fd29:	080c      	movi.n	a8, 0
4200fd2b:	8b6492        	s32i	a9, a4, 0x22c
4200fd2e:	8a6492        	s32i	a9, a4, 0x228
4200fd31:	906192        	s32i	a9, a1, 0x240
4200fd34:	916192        	s32i	a9, a1, 0x244
4200fd37:	a16182        	s32i	a8, a1, 0x284
4200fd3a:	9f6182        	s32i	a8, a1, 0x27c
4200fd3d:	a06182        	s32i	a8, a1, 0x280
4200fd40:	a26182        	s32i	a8, a1, 0x288
4200fd43:	9d6182        	s32i	a8, a1, 0x274
4200fd46:	10c192        	addi	a9, a1, 16
4200fd49:	e4a182        	movi	a8, 0x1e4
4200fd4c:	fa7c      	movi.n	a10, -1
4200fd4e:	898a      	add.n	a8, a9, a8
4200fd50:	4064a2        	s32i	a10, a4, 0x100
4200fd53:	050c      	movi.n	a5, 0
4200fd55:	a46182        	s32i	a8, a1, 0x290
4200fd58:	992172        	l32i	a7, a1, 0x264
4200fd5b:	000046        	j	4200fd60 <_vfiprintf_r+0x124>
4200fd5e:	771b      	addi.n	a7, a7, 1
4200fd60:	000782        	l8ui	a8, a7, 0
4200fd63:	005816        	beqz	a8, 4200fd6c <_vfiprintf_r+0x130>
4200fd66:	dbc882        	addi	a8, a8, -37
4200fd69:	ff1856        	bnez	a8, 4200fd5e <_vfiprintf_r+0x122>
4200fd6c:	992182        	l32i	a8, a1, 0x264
4200fd6f:	c06780        	sub	a6, a7, a8
4200fd72:	052616        	beqz	a6, 4200fdc8 <_vfiprintf_r+0x18c>
4200fd75:	992192        	l32i	a9, a1, 0x264
4200fd78:	972182        	l32i	a8, a1, 0x25c
4200fd7b:	0899      	s32i.n	a9, a8, 0
4200fd7d:	1869      	s32i.n	a6, a8, 4
4200fd7f:	10c182        	addi	a8, a1, 16
4200fd82:	02d892        	addmi	a9, a8, 0x200
4200fd85:	8f2182        	l32i	a8, a1, 0x23c
4200fd88:	886a      	add.n	a8, a8, a6
4200fd8a:	b989      	s32i.n	a8, a9, 44
4200fd8c:	a988      	l32i.n	a8, a9, 40
4200fd8e:	881b      	addi.n	a8, a8, 1
4200fd90:	a989      	s32i.n	a8, a9, 40
4200fd92:	0788e6        	bgei	a8, 8, 4200fd9d <_vfiprintf_r+0x161>
4200fd95:	972182        	l32i	a8, a1, 0x25c
4200fd98:	888b      	addi.n	a8, a8, 8
4200fd9a:	000786        	j	4200fdbc <_vfiprintf_r+0x180>
4200fd9d:	24a2c2        	movi	a12, 0x224
4200fda0:	10c182        	addi	a8, a1, 16
4200fda3:	9821b2        	l32i	a11, a1, 0x260
4200fda6:	9b21a2        	l32i	a10, a1, 0x26c
4200fda9:	c8ca      	add.n	a12, a8, a12
4200fdab:	ffe6e5        	call8	4200fc18 <__sprint_r>
4200fdae:	1a8c      	beqz.n	a10, 4200fdb3 <_vfiprintf_r+0x177>
4200fdb0:	06ab46        	j	42011861 <_vfiprintf_r+0x1c25>
4200fdb3:	e4a182        	movi	a8, 0x1e4
4200fdb6:	10c192        	addi	a9, a1, 16
4200fdb9:	808980        	add	a8, a9, a8
4200fdbc:	976182        	s32i	a8, a1, 0x25c
4200fdbf:	9d2182        	l32i	a8, a1, 0x274
4200fdc2:	808860        	add	a8, a8, a6
4200fdc5:	9d6182        	s32i	a8, a1, 0x274
4200fdc8:	000782        	l8ui	a8, a7, 0
4200fdcb:	18cc      	bnez.n	a8, 4200fdd0 <_vfiprintf_r+0x194>
4200fdcd:	069ac6        	j	4201183c <_vfiprintf_r+0x1c00>
4200fdd0:	10c192        	addi	a9, a1, 16
4200fdd3:	02d992        	addmi	a9, a9, 0x200
4200fdd6:	0a0c      	movi.n	a10, 0
4200fdd8:	3a49a2        	s8i	a10, a9, 58
4200fddb:	f97c      	movi.n	a9, -1
4200fddd:	9a6192        	s32i	a9, a1, 0x268
4200fde0:	090c      	movi.n	a9, 0
4200fde2:	871b      	addi.n	a8, a7, 1
4200fde4:	056d      	mov.n	a6, a5
4200fde6:	9c6192        	s32i	a9, a1, 0x270
4200fde9:	040c      	movi.n	a4, 0
4200fdeb:	030c      	movi.n	a3, 0
4200fded:	000206        	j	4200fdf9 <_vfiprintf_r+0x1bd>
4200fdf0:	619200        	lsi	f0, a2, 0x184
4200fdf3:	0c99      	s32i.n	a9, a12, 0
4200fdf5:	218204        	lsi	f0, a2, 132
4200fdf8:	1b99      	s32i.n	a9, a11, 4
4200fdfa:	8298      	l32i.n	a9, a2, 32
4200fdfc:	0008      	l32i.n	a0, a0, 0
4200fdfe:	996192        	s32i	a9, a1, 0x264
4200fe01:	9e6182        	s32i	a8, a1, 0x278
4200fe04:	aa5c      	movi.n	a10, 90
4200fe06:	000086        	j	4200fe0c <_vfiprintf_r+0x1d0>
4200fe09:	9c6182        	s32i	a8, a1, 0x270
4200fe0c:	9e2182        	l32i	a8, a1, 0x278
4200fe0f:	e0c882        	addi	a8, a8, -32
4200fe12:	02ba87        	bgeu	a10, a8, 4200fe18 <_vfiprintf_r+0x1dc>
4200fe15:	05a286        	j	420114a3 <_vfiprintf_r+0x1867>
4200fe18:	c41191        	l32r	a9, 42000e5c <_stext+0xe3c> (3c029bd4 <blanks$1+0xc0>)
4200fe1b:	a08890        	addx4	a8, a8, a9
4200fe1e:	0888      	l32i.n	a8, a8, 0
4200fe20:	0008a0        	jx	a8
4200fe23:	c40d81        	l32r	a8, 42000e58 <_stext+0xe38> (3c0295c4 <_ZTISt12out_of_range+0x138>)
4200fe26:	046f46        	j	42010fe7 <_vfiprintf_r+0x13ab>
4200fe29:	9b21a2        	l32i	a10, a1, 0x26c
4200fe2c:	201110        	or	a1, a1, a1
4200fe2f:	01d3e5        	call8	42011b6c <_localeconv_r>
4200fe32:	012a82        	l32i	a8, a10, 4
4200fe35:	08ad      	mov.n	a10, a8
4200fe37:	a26182        	s32i	a8, a1, 0x288
4200fe3a:	c11881        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200fe3d:	0008e0        	callx8	a8
4200fe40:	a061a2        	s32i	a10, a1, 0x280
4200fe43:	9b21a2        	l32i	a10, a1, 0x26c
4200fe46:	201110        	or	a1, a1, a1
4200fe49:	01d225        	call8	42011b6c <_localeconv_r>
4200fe4c:	2a88      	l32i.n	a8, a10, 8
4200fe4e:	9f6182        	s32i	a8, a1, 0x27c
4200fe51:	a02182        	l32i	a8, a1, 0x280
4200fe54:	f9e816        	beqz	a8, 4200fdf6 <_vfiprintf_r+0x1ba>
4200fe57:	9f2182        	l32i	a8, a1, 0x27c
4200fe5a:	f98816        	beqz	a8, 4200fdf6 <_vfiprintf_r+0x1ba>
4200fe5d:	000882        	l8ui	a8, a8, 0
4200fe60:	f92816        	beqz	a8, 4200fdf6 <_vfiprintf_r+0x1ba>
4200fe63:	00a482        	movi	a8, 0x400
4200fe66:	00c246        	j	42010173 <_vfiprintf_r+0x537>
4200fe69:	10c182        	addi	a8, a1, 16
4200fe6c:	02d882        	addmi	a8, a8, 0x200
4200fe6f:	3a0892        	l8ui	a9, a8, 58
4200fe72:	f80956        	bnez	a9, 4200fdf6 <_vfiprintf_r+0x1ba>
4200fe75:	092c      	movi.n	a9, 32
4200fe77:	004786        	j	4200ff99 <_vfiprintf_r+0x35d>
4200fe7a:	180c      	movi.n	a8, 1
4200fe7c:	00bcc6        	j	42010173 <_vfiprintf_r+0x537>
4200fe7f:	992182        	l32i	a8, a1, 0x264
4200fe82:	9a0c      	movi.n	a10, 9
4200fe84:	000882        	l8ui	a8, a8, 0
4200fe87:	d0c892        	addi	a9, a8, -48
4200fe8a:	3e3a97        	bltu	a10, a9, 4200fecc <_vfiprintf_r+0x290>
4200fe8d:	992192        	l32i	a9, a1, 0x264
4200fe90:	0a0c      	movi.n	a10, 0
4200fe92:	01c922        	addi	a2, a9, 1
4200fe95:	09a0b2        	movi	a11, 9
4200fe98:	d0c882        	addi	a8, a8, -48
4200fe9b:	a0aaa0        	addx4	a10, a10, a10
4200fe9e:	90aa80        	addx2	a10, a10, a8
4200fea1:	000282        	l8ui	a8, a2, 0
4200fea4:	221b      	addi.n	a2, a2, 1
4200fea6:	d0c892        	addi	a9, a8, -48
4200fea9:	ebbb97        	bgeu	a11, a9, 4200fe98 <_vfiprintf_r+0x25c>
4200feac:	492c      	movi.n	a9, 36
4200feae:	021897        	beq	a8, a9, 4200feb4 <_vfiprintf_r+0x278>
4200feb1:	ffcfc6        	j	4200fdf4 <_vfiprintf_r+0x1b8>
4200feb4:	082c      	movi.n	a8, 32
4200feb6:	02a8a7        	bge	a8, a10, 4200febc <_vfiprintf_r+0x280>
4200feb9:	066906        	j	42011861 <_vfiprintf_r+0x1c25>
4200febc:	912182        	l32i	a8, a1, 0x244
4200febf:	aa0b      	addi.n	a10, a10, -1
4200fec1:	10c1e2        	addi	a14, a1, 16
4200fec4:	142a87        	blt	a10, a8, 4200fedc <_vfiprintf_r+0x2a0>
4200fec7:	000646        	j	4200fee4 <_vfiprintf_r+0x2a8>
4200feca:	b20000        	mulsh	a0, a0, a0
4200fecd:	1b9121        	l32r	a2, 41fd6d14 <_coredump_iram_end+0x1c54d14>
4200fed0:	c18295        	call4	41fd16fc <_coredump_iram_end+0x1c4f6fc>
4200fed3:	25b710        	extui	a11, a1, 23, 3
4200fed6:	0dc634        	lsi	f3, a6, 52
4200fed9:	000000        	ill
4200fedc:	b0eae0        	addx8	a14, a10, a14
4200fedf:	0e88      	l32i.n	a8, a14, 0
4200fee1:	000686        	j	4200feff <_vfiprintf_r+0x2c3>
4200fee4:	30a282        	movi	a8, 0x230
4200fee7:	8e8a      	add.n	a8, a14, a8
4200fee9:	34a2d2        	movi	a13, 0x234
4200feec:	40a2c2        	movi	a12, 0x240
4200feef:	0189      	s32i.n	a8, a1, 0
4200fef1:	01def2        	addmi	a15, a14, 0x100
4200fef4:	deda      	add.n	a13, a14, a13
4200fef6:	ceca      	add.n	a12, a14, a12
4200fef8:	07bd      	mov.n	a11, a7
4200fefa:	ff84e5        	call8	4200f748 <get_arg$isra$0>
4200fefd:	0a88      	l32i.n	a8, a10, 0
4200feff:	9c6182        	s32i	a8, a1, 0x270
4200ff02:	996122        	s32i	a2, a1, 0x264
4200ff05:	059d      	mov.n	a9, a5
4200ff07:	001cc6        	j	4200ff7e <_vfiprintf_r+0x342>
4200ff0a:	800000        	add	a0, a0, a0
4200ff0d:	86b086        	j	41ff19d3 <_coredump_iram_end+0x1c6f9d3>
4200ff10:	0019      	s32i.n	a1, a0, 0
4200ff12:	9228a2        	l32i	a10, a8, 0x248
4200ff15:	fd1c      	movi.n	a13, 31
4200ff17:	02d882        	addmi	a8, a8, 0x200
4200ff1a:	ca4b      	addi.n	a12, a10, 4
4200ff1c:	342db7        	blt	a13, a11, 4200ff54 <_vfiprintf_r+0x318>
4200ff1f:	db1b      	addi.n	a13, a11, 1
4200ff21:	9161d2        	s32i	a13, a1, 0x244
4200ff24:	1268c2        	s32i	a12, a8, 72
4200ff27:	8d1c      	movi.n	a13, 24
4200ff29:	072dc7        	blt	a13, a12, 4200ff34 <_vfiprintf_r+0x2f8>
4200ff2c:	1128a2        	l32i	a10, a8, 68
4200ff2f:	000306        	j	4200ff3f <_vfiprintf_r+0x303>
4200ff32:	a70000        	lsi	f0, a0, 0x29c
4200ff35:	012d      	mov.n	a2, a1
4200ff37:	4c2c      	movi.n	a12, 36
4200ff39:	9421a2        	l32i	a10, a1, 0x250
4200ff3c:	9661c2        	s32i	a12, a1, 0x258
4200ff3f:	aaca      	add.n	a10, a10, a12
4200ff41:	fccaa2        	addi	a10, a10, -4
4200ff44:	0a88      	l32i.n	a8, a10, 0
4200ff46:	9c6182        	s32i	a8, a1, 0x270
4200ff49:	9c21a2        	l32i	a10, a1, 0x270
4200ff4c:	b08b10        	addx8	a8, a11, a1
4200ff4f:	48a9      	s32i.n	a10, a8, 16
4200ff51:	000a46        	j	4200ff7e <_vfiprintf_r+0x342>
4200ff54:	1268c2        	s32i	a12, a8, 72
4200ff57:	8b1c      	movi.n	a11, 24
4200ff59:	052bc7        	blt	a11, a12, 4200ff62 <_vfiprintf_r+0x326>
4200ff5c:	112882        	l32i	a8, a8, 68
4200ff5f:	000446        	j	4200ff74 <_vfiprintf_r+0x338>
4200ff62:	022ba7        	blt	a11, a10, 4200ff68 <_vfiprintf_r+0x32c>
4200ff65:	24a0c2        	movi	a12, 36
4200ff68:	10c182        	addi	a8, a1, 16
4200ff6b:	02d882        	addmi	a8, a8, 0x200
4200ff6e:	102882        	l32i	a8, a8, 64
4200ff71:	9661c2        	s32i	a12, a1, 0x258
4200ff74:	88ca      	add.n	a8, a8, a12
4200ff76:	fcc882        	addi	a8, a8, -4
4200ff79:	0888      	l32i.n	a8, a8, 0
4200ff7b:	9c6182        	s32i	a8, a1, 0x270
4200ff7e:	9c2182        	l32i	a8, a1, 0x270
4200ff81:	095d      	mov.n	a5, a9
4200ff83:	e6f8d6        	bgez	a8, 4200fdf6 <_vfiprintf_r+0x1ba>
4200ff86:	608080        	neg	a8, a8
4200ff89:	9c6182        	s32i	a8, a1, 0x270
4200ff8c:	480c      	movi.n	a8, 4
4200ff8e:	007846        	j	42010173 <_vfiprintf_r+0x537>
4200ff91:	10c182        	addi	a8, a1, 16
4200ff94:	02d882        	addmi	a8, a8, 0x200
4200ff97:	b92c      	movi.n	a9, 43
4200ff99:	3a4892        	s8i	a9, a8, 58
4200ff9c:	ff9586        	j	4200fdf6 <_vfiprintf_r+0x1ba>
4200ff9f:	992182        	l32i	a8, a1, 0x264
4200ffa2:	981b      	addi.n	a9, a8, 1
4200ffa4:	000882        	l8ui	a8, a8, 0
4200ffa7:	9e6182        	s32i	a8, a1, 0x278
4200ffaa:	9e21b2        	l32i	a11, a1, 0x278
4200ffad:	a82c      	movi.n	a8, 42
4200ffaf:	061b87        	beq	a11, a8, 4200ffb9 <_vfiprintf_r+0x37d>
4200ffb2:	080c      	movi.n	a8, 0
4200ffb4:	9c0c      	movi.n	a12, 9
4200ffb6:	004506        	j	420100ce <_vfiprintf_r+0x492>
4200ffb9:	992182        	l32i	a8, a1, 0x264
4200ffbc:	9b0c      	movi.n	a11, 9
4200ffbe:	010882        	l8ui	a8, a8, 1
4200ffc1:	d0c8a2        	addi	a10, a8, -48
4200ffc4:	3c3ba7        	bltu	a11, a10, 42010004 <_vfiprintf_r+0x3c8>
4200ffc7:	9921a2        	l32i	a10, a1, 0x264
4200ffca:	02ca22        	addi	a2, a10, 2
4200ffcd:	00a0a2        	movi	a10, 0
4200ffd0:	d0c882        	addi	a8, a8, -48
4200ffd3:	a0aaa0        	addx4	a10, a10, a10
4200ffd6:	90aa80        	addx2	a10, a10, a8
4200ffd9:	000282        	l8ui	a8, a2, 0
4200ffdc:	221b      	addi.n	a2, a2, 1
4200ffde:	d0c8c2        	addi	a12, a8, -48
4200ffe1:	ebbbc7        	bgeu	a11, a12, 4200ffd0 <_vfiprintf_r+0x394>
4200ffe4:	4b2c      	movi.n	a11, 36
4200ffe6:	0218b7        	beq	a8, a11, 4200ffec <_vfiprintf_r+0x3b0>
4200ffe9:	ff8106        	j	4200fdf1 <_vfiprintf_r+0x1b5>
4200ffec:	082c      	movi.n	a8, 32
4200ffee:	02a8a7        	bge	a8, a10, 4200fff4 <_vfiprintf_r+0x3b8>
4200fff1:	061b06        	j	42011861 <_vfiprintf_r+0x1c25>
4200fff4:	912182        	l32i	a8, a1, 0x244
4200fff7:	aa0b      	addi.n	a10, a10, -1
4200fff9:	10c1e2        	addi	a14, a1, 16
4200fffc:	142a87        	blt	a10, a8, 42010014 <_vfiprintf_r+0x3d8>
4200ffff:	000646        	j	4201001c <_vfiprintf_r+0x3e0>
42010002:	a20000        	muluh	a0, a0, a0
42010005:	1b9121        	l32r	a2, 41fd6e4c <_coredump_iram_end+0x1c54e4c>
42010008:	c182c5        	call0	41fd1838 <_coredump_iram_end+0x1c4f838>
4201000b:	25a710        	extui	a10, a1, 23, 3
4201000e:	0cc630        	lsi	f3, a6, 48
42010011:	000000        	ill
42010014:	b0eae0        	addx8	a14, a10, a14
42010017:	0e88      	l32i.n	a8, a14, 0
42010019:	000686        	j	42010037 <_vfiprintf_r+0x3fb>
4201001c:	30a282        	movi	a8, 0x230
4201001f:	8e8a      	add.n	a8, a14, a8
42010021:	34a2d2        	movi	a13, 0x234
42010024:	40a2c2        	movi	a12, 0x240
42010027:	0189      	s32i.n	a8, a1, 0
42010029:	01def2        	addmi	a15, a14, 0x100
4201002c:	deda      	add.n	a13, a14, a13
4201002e:	ceca      	add.n	a12, a14, a12
42010030:	07bd      	mov.n	a11, a7
42010032:	ff7165        	call8	4200f748 <get_arg$isra$0>
42010035:	0a88      	l32i.n	a8, a10, 0
42010037:	029d      	mov.n	a9, a2
42010039:	05cd      	mov.n	a12, a5
4201003b:	001c06        	j	420100af <_vfiprintf_r+0x473>
4201003e:	800000        	add	a0, a0, a0
42010041:	86b086        	j	41ff1b07 <_coredump_iram_end+0x1c6fb07>
42010044:	0019      	s32i.n	a1, a0, 0
42010046:	fb1c      	movi.n	a11, 31
42010048:	352ba7        	blt	a11, a10, 42010081 <_vfiprintf_r+0x445>
4201004b:	9228e2        	l32i	a14, a8, 0x248
4201004e:	ba1b      	addi.n	a11, a10, 1
42010050:	9161b2        	s32i	a11, a1, 0x244
42010053:	be4b      	addi.n	a11, a14, 4
42010055:	9268b2        	s32i	a11, a8, 0x248
42010058:	8f1c      	movi.n	a15, 24
4201005a:	062fb7        	blt	a15, a11, 42010064 <_vfiprintf_r+0x428>
4201005d:	912882        	l32i	a8, a8, 0x244
42010060:	000386        	j	42010072 <_vfiprintf_r+0x436>
42010063:	2fe700        	f64cmph	a14, a7, a0, 2
42010066:	4b2c01        	l32r	a0, 41fe2d18 <_coredump_iram_end+0x1c60d18>
42010069:	9268b2        	s32i	a11, a8, 0x248
4201006c:	02d882        	addmi	a8, a8, 0x200
4201006f:	102882        	l32i	a8, a8, 64
42010072:	88ba      	add.n	a8, a8, a11
42010074:	fcc882        	addi	a8, a8, -4
42010077:	0888      	l32i.n	a8, a8, 0
42010079:	b0aa10        	addx8	a10, a10, a1
4201007c:	4a89      	s32i.n	a8, a10, 16
4201007e:	000b46        	j	420100af <_vfiprintf_r+0x473>
42010081:	9228b2        	l32i	a11, a8, 0x248
42010084:	8d1c      	movi.n	a13, 24
42010086:	ab4b      	addi.n	a10, a11, 4
42010088:	9268a2        	s32i	a10, a8, 0x248
4201008b:	02d882        	addmi	a8, a8, 0x200
4201008e:	052da7        	blt	a13, a10, 42010097 <_vfiprintf_r+0x45b>
42010091:	112882        	l32i	a8, a8, 68
42010094:	000406        	j	420100a8 <_vfiprintf_r+0x46c>
42010097:	012db7        	blt	a13, a11, 4201009c <_vfiprintf_r+0x460>
4201009a:	4a2c      	movi.n	a10, 36
4201009c:	10c182        	addi	a8, a1, 16
4201009f:	02d882        	addmi	a8, a8, 0x200
420100a2:	102882        	l32i	a8, a8, 64
420100a5:	9661a2        	s32i	a10, a1, 0x258
420100a8:	88aa      	add.n	a8, a8, a10
420100aa:	fcc882        	addi	a8, a8, -4
420100ad:	0888      	l32i.n	a8, a8, 0
420100af:	fa7c      	movi.n	a10, -1
420100b1:	5388a0        	max	a8, a8, a10
420100b4:	9a6182        	s32i	a8, a1, 0x268
420100b7:	0c5d      	mov.n	a5, a12
420100b9:	996192        	s32i	a9, a1, 0x264
420100bc:	ff4d86        	j	4200fdf6 <_vfiprintf_r+0x1ba>
420100bf:	888000        	lsi	f0, a0, 0x220
420100c2:	88b0a0        	lsi	f10, a0, 0x220
420100c5:	09b290        	l32e	a9, a2, -20
420100c8:	991b00        	lsi	f0, a11, 0x264
420100cb:	9e61b2        	s32i	a11, a1, 0x278
420100ce:	9e21b2        	l32i	a11, a1, 0x278
420100d1:	996192        	s32i	a9, a1, 0x264
420100d4:	d0cbb2        	addi	a11, a11, -48
420100d7:	e5bcb7        	bgeu	a12, a11, 420100c0 <_vfiprintf_r+0x484>
420100da:	f97c      	movi.n	a9, -1
420100dc:	538890        	max	a8, a8, a9
420100df:	9a6182        	s32i	a8, a1, 0x268
420100e2:	9c2182        	l32i	a8, a1, 0x270
420100e5:	ff4806        	j	4200fe09 <_vfiprintf_r+0x1cd>
420100e8:	820000        	mull	a0, a0, a0
420100eb:	8680a0        	lsi	f10, a0, 0x218
420100ee:	0c0020        	lsi	f2, a0, 48
420100f1:	0c08      	l32i.n	a0, a12, 0
420100f3:	929b      	addi.n	a9, a2, 9
420100f5:	809e21        	l32r	a2, 41ff0370 <_coredump_iram_end+0x1c6e370>
420100f8:	a088      	l32i.n	a8, a0, 40
420100fa:	d0c992        	addi	a9, a9, -48
420100fd:	908890        	addx2	a8, a8, a9
42010100:	992192        	l32i	a9, a1, 0x264
42010103:	000992        	l8ui	a9, a9, 0
42010106:	9e6192        	s32i	a9, a1, 0x278
42010109:	992192        	l32i	a9, a1, 0x264
4201010c:	991b      	addi.n	a9, a9, 1
4201010e:	996192        	s32i	a9, a1, 0x264
42010111:	9e2192        	l32i	a9, a1, 0x278
42010114:	d0c992        	addi	a9, a9, -48
42010117:	d9bb97        	bgeu	a11, a9, 420100f4 <_vfiprintf_r+0x4b8>
4201011a:	9e21b2        	l32i	a11, a1, 0x278
4201011d:	492c      	movi.n	a9, 36
4201011f:	021b97        	beq	a11, a9, 42010125 <_vfiprintf_r+0x4e9>
42010122:	ff38c6        	j	4200fe09 <_vfiprintf_r+0x1cd>
42010125:	092c      	movi.n	a9, 32
42010127:	02a987        	bge	a9, a8, 4201012d <_vfiprintf_r+0x4f1>
4201012a:	05ccc6        	j	42011861 <_vfiprintf_r+0x1c25>
4201012d:	680b      	addi.n	a6, a8, -1
4201012f:	140c      	movi.n	a4, 1
42010131:	ff3046        	j	4200fdf6 <_vfiprintf_r+0x1ba>
42010134:	992182        	l32i	a8, a1, 0x264
42010137:	000892        	l8ui	a9, a8, 0
4201013a:	68a082        	movi	a8, 104
4201013d:	0d9987        	bne	a9, a8, 4201014e <_vfiprintf_r+0x512>
42010140:	992182        	l32i	a8, a1, 0x264
42010143:	881b      	addi.n	a8, a8, 1
42010145:	996182        	s32i	a8, a1, 0x264
42010148:	00a282        	movi	a8, 0x200
4201014b:	000906        	j	42010173 <_vfiprintf_r+0x537>
4201014e:	084c      	movi.n	a8, 64
42010150:	0007c6        	j	42010173 <_vfiprintf_r+0x537>
42010153:	992182        	l32i	a8, a1, 0x264
42010156:	000892        	l8ui	a9, a8, 0
42010159:	6ca082        	movi	a8, 108
4201015c:	0a9987        	bne	a9, a8, 4201016a <_vfiprintf_r+0x52e>
4201015f:	992182        	l32i	a8, a1, 0x264
42010162:	881b      	addi.n	a8, a8, 1
42010164:	996182        	s32i	a8, a1, 0x264
42010167:	000186        	j	42010171 <_vfiprintf_r+0x535>
4201016a:	081c      	movi.n	a8, 16
4201016c:	0000c6        	j	42010173 <_vfiprintf_r+0x537>
4201016f:	2c0000        	lsi	f0, a0, 176
42010172:	8008      	l32i.n	a0, a0, 32
42010174:	062033        	lsi	f3, a0, 24
42010177:	1f          	.byte	0x1f
42010178:	ff          	.byte	0xff
42010179:	912192        	l32i	a9, a1, 0x244
4201017c:	10c1e2        	addi	a14, a1, 16
4201017f:	d4ac      	beqz.n	a4, 420101b0 <_vfiprintf_r+0x574>
42010181:	08a697        	bge	a6, a9, 4201018d <_vfiprintf_r+0x551>
42010184:	b0e6e0        	addx8	a14, a6, a14
42010187:	000e82        	l8ui	a8, a14, 0
4201018a:	000746        	j	420101ab <_vfiprintf_r+0x56f>
4201018d:	30a282        	movi	a8, 0x230
42010190:	8e8a      	add.n	a8, a14, a8
42010192:	34a2d2        	movi	a13, 0x234
42010195:	40a2c2        	movi	a12, 0x240
42010198:	0189      	s32i.n	a8, a1, 0
4201019a:	01def2        	addmi	a15, a14, 0x100
4201019d:	deda      	add.n	a13, a14, a13
4201019f:	ceca      	add.n	a12, a14, a12
420101a1:	07bd      	mov.n	a11, a7
420101a3:	06ad      	mov.n	a10, a6
420101a5:	ff5a25        	call8	4200f748 <get_arg$isra$0>
420101a8:	000a82        	l8ui	a8, a10, 0
420101ab:	057d      	mov.n	a7, a5
420101ad:	001f06        	j	4201022d <_vfiprintf_r+0x5f1>
420101b0:	751b      	addi.n	a7, a5, 1
420101b2:	0aa597        	bge	a5, a9, 420101c0 <_vfiprintf_r+0x584>
420101b5:	b0e6e0        	addx8	a14, a6, a14
420101b8:	000e82        	l8ui	a8, a14, 0
420101bb:	001b86        	j	4201022d <_vfiprintf_r+0x5f1>
420101be:	820000        	mull	a0, a0, a0
420101c1:	2e          	.byte	0x2e
420101c2:	fb1c92        	l16ui	a9, a12, 0x1f6
420101c5:	02dee2        	addmi	a14, a14, 0x200
420101c8:	a84b      	addi.n	a10, a8, 4
420101ca:	362b97        	blt	a11, a9, 42010204 <_vfiprintf_r+0x5c8>
420101cd:	b91b      	addi.n	a11, a9, 1
420101cf:	9161b2        	s32i	a11, a1, 0x244
420101d2:	126ea2        	s32i	a10, a14, 72
420101d5:	8b1c      	movi.n	a11, 24
420101d7:	052ba7        	blt	a11, a10, 420101e0 <_vfiprintf_r+0x5a4>
420101da:	112e82        	l32i	a8, a14, 68
420101dd:	000406        	j	420101f1 <_vfiprintf_r+0x5b5>
420101e0:	012b87        	blt	a11, a8, 420101e5 <_vfiprintf_r+0x5a9>
420101e3:	4a2c      	movi.n	a10, 36
420101e5:	10c182        	addi	a8, a1, 16
420101e8:	02d882        	addmi	a8, a8, 0x200
420101eb:	102882        	l32i	a8, a8, 64
420101ee:	9661a2        	s32i	a10, a1, 0x258
420101f1:	88aa      	add.n	a8, a8, a10
420101f3:	fcc882        	addi	a8, a8, -4
420101f6:	0888      	l32i.n	a8, a8, 0
420101f8:	b09910        	addx8	a9, a9, a1
420101fb:	4989      	s32i.n	a8, a9, 16
420101fd:	748080        	extui	a8, a8, 0, 8
42010200:	000a46        	j	4201022d <_vfiprintf_r+0x5f1>
42010203:	6ea200        	f64rnd	a10, a2, a0, 2
42010206:	891c12        	l16ui	a1, a12, 0x112
42010209:	0729a7        	blt	a9, a10, 42010214 <_vfiprintf_r+0x5d8>
4201020c:	112e82        	l32i	a8, a14, 68
4201020f:	000486        	j	42010225 <_vfiprintf_r+0x5e9>
42010212:	870000        	lsi	f0, a0, 0x21c
42010215:	0129      	s32i.n	a2, a1, 0
42010217:	4a2c      	movi.n	a10, 36
42010219:	10c182        	addi	a8, a1, 16
4201021c:	02d882        	addmi	a8, a8, 0x200
4201021f:	102882        	l32i	a8, a8, 64
42010222:	9661a2        	s32i	a10, a1, 0x258
42010225:	88aa      	add.n	a8, a8, a10
42010227:	fcc882        	addi	a8, a8, -4
4201022a:	000882        	l8ui	a8, a8, 0
4201022d:	10c162        	addi	a6, a1, 16
42010230:	01d692        	addmi	a9, a6, 0x100
42010233:	804982        	s8i	a8, a9, 128
42010236:	02d682        	addmi	a8, a6, 0x200
42010239:	090c      	movi.n	a9, 0
4201023b:	3a4892        	s8i	a9, a8, 58
4201023e:	049f46        	j	420114bf <_vfiprintf_r+0x1883>
42010241:	081c      	movi.n	a8, 16
42010243:	203380        	or	a3, a3, a8
42010246:	912182        	l32i	a8, a1, 0x244
42010249:	10c1e2        	addi	a14, a1, 16
4201024c:	02e357        	bbsi	a3, 5, 42010252 <_vfiprintf_r+0x616>
4201024f:	002f46        	j	42010310 <_vfiprintf_r+0x6d4>
42010252:	f4ac      	beqz.n	a4, 42010285 <_vfiprintf_r+0x649>
42010254:	09a687        	bge	a6, a8, 42010261 <_vfiprintf_r+0x625>
42010257:	b0e6e0        	addx8	a14, a6, a14
4201025a:	0e48      	l32i.n	a4, a14, 0
4201025c:	1e28      	l32i.n	a2, a14, 4
4201025e:	000786        	j	42010280 <_vfiprintf_r+0x644>
42010261:	30a282        	movi	a8, 0x230
42010264:	8e8a      	add.n	a8, a14, a8
42010266:	34a2d2        	movi	a13, 0x234
42010269:	40a2c2        	movi	a12, 0x240
4201026c:	0189      	s32i.n	a8, a1, 0
4201026e:	01def2        	addmi	a15, a14, 0x100
42010271:	deda      	add.n	a13, a14, a13
42010273:	ceca      	add.n	a12, a14, a12
42010275:	07bd      	mov.n	a11, a7
42010277:	06ad      	mov.n	a10, a6
42010279:	ff4ce5        	call8	4200f748 <get_arg$isra$0>
4201027c:	0a48      	l32i.n	a4, a10, 0
4201027e:	1a28      	l32i.n	a2, a10, 4
42010280:	057d      	mov.n	a7, a5
42010282:	00aa46        	j	4201052f <_vfiprintf_r+0x8f3>
42010285:	751b      	addi.n	a7, a5, 1
42010287:	09a587        	bge	a5, a8, 42010294 <_vfiprintf_r+0x658>
4201028a:	b0e6e0        	addx8	a14, a6, a14
4201028d:	0e48      	l32i.n	a4, a14, 0
4201028f:	1e28      	l32i.n	a2, a14, 4
42010291:	00a686        	j	4201052f <_vfiprintf_r+0x8f3>
42010294:	922e92        	l32i	a9, a14, 0x248
42010297:	8a7c      	movi.n	a10, -8
42010299:	997b      	addi.n	a9, a9, 7
4201029b:	1099a0        	and	a9, a9, a10
4201029e:	fb1c      	movi.n	a11, 31
420102a0:	02dee2        	addmi	a14, a14, 0x200
420102a3:	a98b      	addi.n	a10, a9, 8
420102a5:	3b2b87        	blt	a11, a8, 420102e4 <_vfiprintf_r+0x6a8>
420102a8:	b81b      	addi.n	a11, a8, 1
420102aa:	9161b2        	s32i	a11, a1, 0x244
420102ad:	126ea2        	s32i	a10, a14, 72
420102b0:	8b1c      	movi.n	a11, 24
420102b2:	062ba7        	blt	a11, a10, 420102bc <_vfiprintf_r+0x680>
420102b5:	112e92        	l32i	a9, a14, 68
420102b8:	000446        	j	420102cd <_vfiprintf_r+0x691>
420102bb:	2b9700        	oeq.s	b9, f7, f0
420102be:	8a2c01        	l32r	a0, 41ff2b70 <_coredump_iram_end+0x1c70b70>
420102c1:	10c192        	addi	a9, a1, 16
420102c4:	02d992        	addmi	a9, a9, 0x200
420102c7:	102992        	l32i	a9, a9, 64
420102ca:	9661a2        	s32i	a10, a1, 0x258
420102cd:	99aa      	add.n	a9, a9, a10
420102cf:	f8c992        	addi	a9, a9, -8
420102d2:	0948      	l32i.n	a4, a9, 0
420102d4:	1928      	l32i.n	a2, a9, 4
420102d6:	10c192        	addi	a9, a1, 16
420102d9:	b08890        	addx8	a8, a8, a9
420102dc:	0849      	s32i.n	a4, a8, 0
420102de:	1829      	s32i.n	a2, a8, 4
420102e0:	0092c6        	j	4201052f <_vfiprintf_r+0x8f3>
420102e3:	6ea200        	f64rnd	a10, a2, a0, 2
420102e6:	881c12        	l16ui	a1, a12, 0x110
420102e9:	0528a7        	blt	a8, a10, 420102f2 <_vfiprintf_r+0x6b6>
420102ec:	112e82        	l32i	a8, a14, 68
420102ef:	000446        	j	42010304 <_vfiprintf_r+0x6c8>
420102f2:	022897        	blt	a8, a9, 420102f8 <_vfiprintf_r+0x6bc>
420102f5:	28a0a2        	movi	a10, 40
420102f8:	10c182        	addi	a8, a1, 16
420102fb:	02d882        	addmi	a8, a8, 0x200
420102fe:	102882        	l32i	a8, a8, 64
42010301:	9661a2        	s32i	a10, a1, 0x258
42010304:	88aa      	add.n	a8, a8, a10
42010306:	f8c882        	addi	a8, a8, -8
42010309:	0848      	l32i.n	a4, a8, 0
4201030b:	1828      	l32i.n	a2, a8, 4
4201030d:	008786        	j	4201052f <_vfiprintf_r+0x8f3>
42010310:	046347        	bbci	a3, 4, 42010318 <_vfiprintf_r+0x6dc>
42010313:	005c46        	j	42010488 <_vfiprintf_r+0x84c>
42010316:	670000        	lsi	f0, a0, 0x19c
42010319:	4602e3        	lsi	f14, a2, 0x118
4201031c:	002b      	addi.n	a0, a0, 2
4201031e:	c4ac      	beqz.n	a4, 4201034e <_vfiprintf_r+0x712>
42010320:	09a687        	bge	a6, a8, 4201032d <_vfiprintf_r+0x6f1>
42010323:	b0e6e0        	addx8	a14, a6, a14
42010326:	009e42        	l16si	a4, a14, 0
42010329:	006146        	j	420104b2 <_vfiprintf_r+0x876>
4201032c:	a28200        	muluh	a8, a2, a0
4201032f:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42010332:	34a2d2        	movi	a13, 0x234
42010335:	40a2c2        	movi	a12, 0x240
42010338:	0189      	s32i.n	a8, a1, 0
4201033a:	01def2        	addmi	a15, a14, 0x100
4201033d:	deda      	add.n	a13, a14, a13
4201033f:	ceca      	add.n	a12, a14, a12
42010341:	07bd      	mov.n	a11, a7
42010343:	06ad      	mov.n	a10, a6
42010345:	ff4025        	call8	4200f748 <get_arg$isra$0>
42010348:	009a42        	l16si	a4, a10, 0
4201034b:	0058c6        	j	420104b2 <_vfiprintf_r+0x876>
4201034e:	751b      	addi.n	a7, a5, 1
42010350:	08a587        	bge	a5, a8, 4201035c <_vfiprintf_r+0x720>
42010353:	b0e6e0        	addx8	a14, a6, a14
42010356:	009e42        	l16si	a4, a14, 0
42010359:	0073c6        	j	4201052c <_vfiprintf_r+0x8f0>
4201035c:	922e92        	l32i	a9, a14, 0x248
4201035f:	fb1c      	movi.n	a11, 31
42010361:	02dee2        	addmi	a14, a14, 0x200
42010364:	a94b      	addi.n	a10, a9, 4
42010366:	362b87        	blt	a11, a8, 420103a0 <_vfiprintf_r+0x764>
42010369:	b81b      	addi.n	a11, a8, 1
4201036b:	9161b2        	s32i	a11, a1, 0x244
4201036e:	126ea2        	s32i	a10, a14, 72
42010371:	8b1c      	movi.n	a11, 24
42010373:	052ba7        	blt	a11, a10, 4201037c <_vfiprintf_r+0x740>
42010376:	112e92        	l32i	a9, a14, 68
42010379:	000406        	j	4201038d <_vfiprintf_r+0x751>
4201037c:	012b97        	blt	a11, a9, 42010381 <_vfiprintf_r+0x745>
4201037f:	4a2c      	movi.n	a10, 36
42010381:	10c192        	addi	a9, a1, 16
42010384:	02d992        	addmi	a9, a9, 0x200
42010387:	102992        	l32i	a9, a9, 64
4201038a:	9661a2        	s32i	a10, a1, 0x258
4201038d:	99aa      	add.n	a9, a9, a10
4201038f:	fcc992        	addi	a9, a9, -4
42010392:	0948      	l32i.n	a4, a9, 0
42010394:	b08810        	addx8	a8, a8, a1
42010397:	4849      	s32i.n	a4, a8, 16
42010399:	234480        	sext	a4, a4, 15
4201039c:	006306        	j	4201052c <_vfiprintf_r+0x8f0>
4201039f:	6ea200        	f64rnd	a10, a2, a0, 2
420103a2:	881c12        	l16ui	a1, a12, 0x110
420103a5:	0728a7        	blt	a8, a10, 420103b0 <_vfiprintf_r+0x774>
420103a8:	112e82        	l32i	a8, a14, 68
420103ab:	000486        	j	420103c1 <_vfiprintf_r+0x785>
420103ae:	970000        	lsi	f0, a0, 0x25c
420103b1:	0128      	l32i.n	a2, a1, 0
420103b3:	4a2c      	movi.n	a10, 36
420103b5:	10c182        	addi	a8, a1, 16
420103b8:	02d882        	addmi	a8, a8, 0x200
420103bb:	102882        	l32i	a8, a8, 64
420103be:	9661a2        	s32i	a10, a1, 0x258
420103c1:	88aa      	add.n	a8, a8, a10
420103c3:	fcc882        	addi	a8, a8, -4
420103c6:	009842        	l16si	a4, a8, 0
420103c9:	0057c6        	j	4201052c <_vfiprintf_r+0x8f0>
420103cc:	02e397        	bbsi	a3, 9, 420103d2 <_vfiprintf_r+0x796>
420103cf:	002d46        	j	42010488 <_vfiprintf_r+0x84c>
420103d2:	e4ac      	beqz.n	a4, 42010404 <_vfiprintf_r+0x7c8>
420103d4:	09a687        	bge	a6, a8, 420103e1 <_vfiprintf_r+0x7a5>
420103d7:	b0e6e0        	addx8	a14, a6, a14
420103da:	000e42        	l8ui	a4, a14, 0
420103dd:	000786        	j	420103ff <_vfiprintf_r+0x7c3>
420103e0:	a28200        	muluh	a8, a2, a0
420103e3:	8e8a30        	f64iter	a8, a10, a3, 0, 0
420103e6:	34a2d2        	movi	a13, 0x234
420103e9:	40a2c2        	movi	a12, 0x240
420103ec:	0189      	s32i.n	a8, a1, 0
420103ee:	01def2        	addmi	a15, a14, 0x100
420103f1:	deda      	add.n	a13, a14, a13
420103f3:	ceca      	add.n	a12, a14, a12
420103f5:	07bd      	mov.n	a11, a7
420103f7:	06ad      	mov.n	a10, a6
420103f9:	ff34e5        	call8	4200f748 <get_arg$isra$0>
420103fc:	000a42        	l8ui	a4, a10, 0
420103ff:	057d      	mov.n	a7, a5
42010401:	001f06        	j	42010481 <_vfiprintf_r+0x845>
42010404:	751b      	addi.n	a7, a5, 1
42010406:	0aa587        	bge	a5, a8, 42010414 <_vfiprintf_r+0x7d8>
42010409:	b0e6e0        	addx8	a14, a6, a14
4201040c:	000e42        	l8ui	a4, a14, 0
4201040f:	001b86        	j	42010481 <_vfiprintf_r+0x845>
42010412:	920000        	lsi	f0, a0, 0x248
42010415:	2e          	.byte	0x2e
42010416:	fb1c92        	l16ui	a9, a12, 0x1f6
42010419:	02dee2        	addmi	a14, a14, 0x200
4201041c:	a94b      	addi.n	a10, a9, 4
4201041e:	362b87        	blt	a11, a8, 42010458 <_vfiprintf_r+0x81c>
42010421:	b81b      	addi.n	a11, a8, 1
42010423:	9161b2        	s32i	a11, a1, 0x244
42010426:	126ea2        	s32i	a10, a14, 72
42010429:	8b1c      	movi.n	a11, 24
4201042b:	052ba7        	blt	a11, a10, 42010434 <_vfiprintf_r+0x7f8>
4201042e:	112e92        	l32i	a9, a14, 68
42010431:	000406        	j	42010445 <_vfiprintf_r+0x809>
42010434:	012b97        	blt	a11, a9, 42010439 <_vfiprintf_r+0x7fd>
42010437:	4a2c      	movi.n	a10, 36
42010439:	10c192        	addi	a9, a1, 16
4201043c:	02d992        	addmi	a9, a9, 0x200
4201043f:	102992        	l32i	a9, a9, 64
42010442:	9661a2        	s32i	a10, a1, 0x258
42010445:	99aa      	add.n	a9, a9, a10
42010447:	fcc992        	addi	a9, a9, -4
4201044a:	0948      	l32i.n	a4, a9, 0
4201044c:	b08810        	addx8	a8, a8, a1
4201044f:	4849      	s32i.n	a4, a8, 16
42010451:	744040        	extui	a4, a4, 0, 8
42010454:	000a46        	j	42010481 <_vfiprintf_r+0x845>
42010457:	6ea200        	f64rnd	a10, a2, a0, 2
4201045a:	881c12        	l16ui	a1, a12, 0x110
4201045d:	0728a7        	blt	a8, a10, 42010468 <_vfiprintf_r+0x82c>
42010460:	112e82        	l32i	a8, a14, 68
42010463:	000486        	j	42010479 <_vfiprintf_r+0x83d>
42010466:	970000        	lsi	f0, a0, 0x25c
42010469:	0128      	l32i.n	a2, a1, 0
4201046b:	4a2c      	movi.n	a10, 36
4201046d:	10c182        	addi	a8, a1, 16
42010470:	02d882        	addmi	a8, a8, 0x200
42010473:	102882        	l32i	a8, a8, 64
42010476:	9661a2        	s32i	a10, a1, 0x258
42010479:	88aa      	add.n	a8, a8, a10
4201047b:	fcc882        	addi	a8, a8, -4
4201047e:	000842        	l8ui	a4, a8, 0
42010481:	234400        	sext	a4, a4, 7
42010484:	002906        	j	4201052c <_vfiprintf_r+0x8f0>
42010487:	c4ac00        	extui	a10, a0, 12, 13
4201048a:	07a687        	bge	a6, a8, 42010495 <_vfiprintf_r+0x859>
4201048d:	b0e6e0        	addx8	a14, a6, a14
42010490:	0e48      	l32i.n	a4, a14, 0
42010492:	000706        	j	420104b2 <_vfiprintf_r+0x876>
42010495:	30a282        	movi	a8, 0x230
42010498:	8e8a      	add.n	a8, a14, a8
4201049a:	34a2d2        	movi	a13, 0x234
4201049d:	40a2c2        	movi	a12, 0x240
420104a0:	0189      	s32i.n	a8, a1, 0
420104a2:	01def2        	addmi	a15, a14, 0x100
420104a5:	deda      	add.n	a13, a14, a13
420104a7:	ceca      	add.n	a12, a14, a12
420104a9:	07bd      	mov.n	a11, a7
420104ab:	06ad      	mov.n	a10, a6
420104ad:	ff29a5        	call8	4200f748 <get_arg$isra$0>
420104b0:	0a48      	l32i.n	a4, a10, 0
420104b2:	057d      	mov.n	a7, a5
420104b4:	001d06        	j	4201052c <_vfiprintf_r+0x8f0>
420104b7:	751b00        	extui	a1, a0, 27, 8
420104ba:	07a587        	bge	a5, a8, 420104c5 <_vfiprintf_r+0x889>
420104bd:	b0e6e0        	addx8	a14, a6, a14
420104c0:	0e48      	l32i.n	a4, a14, 0
420104c2:	001986        	j	4201052c <_vfiprintf_r+0x8f0>
420104c5:	922e92        	l32i	a9, a14, 0x248
420104c8:	fb1c      	movi.n	a11, 31
420104ca:	02dee2        	addmi	a14, a14, 0x200
420104cd:	a94b      	addi.n	a10, a9, 4
420104cf:	322b87        	blt	a11, a8, 42010505 <_vfiprintf_r+0x8c9>
420104d2:	b81b      	addi.n	a11, a8, 1
420104d4:	9161b2        	s32i	a11, a1, 0x244
420104d7:	126ea2        	s32i	a10, a14, 72
420104da:	8b1c      	movi.n	a11, 24
420104dc:	052ba7        	blt	a11, a10, 420104e5 <_vfiprintf_r+0x8a9>
420104df:	112e92        	l32i	a9, a14, 68
420104e2:	000406        	j	420104f6 <_vfiprintf_r+0x8ba>
420104e5:	012b97        	blt	a11, a9, 420104ea <_vfiprintf_r+0x8ae>
420104e8:	4a2c      	movi.n	a10, 36
420104ea:	10c192        	addi	a9, a1, 16
420104ed:	02d992        	addmi	a9, a9, 0x200
420104f0:	102992        	l32i	a9, a9, 64
420104f3:	9661a2        	s32i	a10, a1, 0x258
420104f6:	99aa      	add.n	a9, a9, a10
420104f8:	fcc992        	addi	a9, a9, -4
420104fb:	0948      	l32i.n	a4, a9, 0
420104fd:	b08810        	addx8	a8, a8, a1
42010500:	4849      	s32i.n	a4, a8, 16
42010502:	000986        	j	4201052c <_vfiprintf_r+0x8f0>
42010505:	126ea2        	s32i	a10, a14, 72
42010508:	881c      	movi.n	a8, 24
4201050a:	0528a7        	blt	a8, a10, 42010513 <_vfiprintf_r+0x8d7>
4201050d:	112e82        	l32i	a8, a14, 68
42010510:	000446        	j	42010525 <_vfiprintf_r+0x8e9>
42010513:	022897        	blt	a8, a9, 42010519 <_vfiprintf_r+0x8dd>
42010516:	24a0a2        	movi	a10, 36
42010519:	10c182        	addi	a8, a1, 16
4201051c:	02d882        	addmi	a8, a8, 0x200
4201051f:	102882        	l32i	a8, a8, 64
42010522:	9661a2        	s32i	a10, a1, 0x258
42010525:	88aa      	add.n	a8, a8, a10
42010527:	fcc882        	addi	a8, a8, -4
4201052a:	0848      	l32i.n	a4, a8, 0
4201052c:	312f40        	srai	a2, a4, 31
4201052f:	002296        	bltz	a2, 42010535 <_vfiprintf_r+0x8f9>
42010532:	04d546        	j	4201188b <_vfiprintf_r+0x1c4f>
42010535:	602020        	neg	a2, a2
42010538:	048c      	beqz.n	a4, 4201053c <_vfiprintf_r+0x900>
4201053a:	220b      	addi.n	a2, a2, -1
4201053c:	604040        	neg	a4, a4
4201053f:	d92c      	movi.n	a9, 45
42010541:	180c      	movi.n	a8, 1
42010543:	036f06        	j	42011303 <_vfiprintf_r+0x16c7>
42010546:	820000        	mull	a0, a0, a0
42010549:	e29121        	l32r	a2, 42008f90 <gpio_sleep_input_disable+0x34> (e0dc3481 <_rtc_reserved_end+0x80cc3481>)
4201054c:	5710c1        	l32r	a12, 41fe618c <_coredump_iram_end+0x1c6418c>
4201054f:	c602e3        	lsi	f14, a2, 0x318
42010552:	0029      	s32i.n	a2, a0, 0
42010554:	c4ac      	beqz.n	a4, 42010584 <_vfiprintf_r+0x948>
42010556:	07a687        	bge	a6, a8, 42010561 <_vfiprintf_r+0x925>
42010559:	b0e6e0        	addx8	a14, a6, a14
4201055c:	0e98      	l32i.n	a9, a14, 0
4201055e:	000706        	j	4201057e <_vfiprintf_r+0x942>
42010561:	30a282        	movi	a8, 0x230
42010564:	8e8a      	add.n	a8, a14, a8
42010566:	34a2d2        	movi	a13, 0x234
42010569:	40a2c2        	movi	a12, 0x240
4201056c:	0189      	s32i.n	a8, a1, 0
4201056e:	01def2        	addmi	a15, a14, 0x100
42010571:	deda      	add.n	a13, a14, a13
42010573:	ceca      	add.n	a12, a14, a12
42010575:	07bd      	mov.n	a11, a7
42010577:	06ad      	mov.n	a10, a6
42010579:	ff1ce5        	call8	4200f748 <get_arg$isra$0>
4201057c:	0a98      	l32i.n	a9, a10, 0
4201057e:	05ad      	mov.n	a10, a5
42010580:	001a86        	j	420105ee <_vfiprintf_r+0x9b2>
42010583:	a51b00        	extui	a1, a0, 27, 11
42010586:	07a587        	bge	a5, a8, 42010591 <_vfiprintf_r+0x955>
42010589:	b0e6e0        	addx8	a14, a6, a14
4201058c:	0e98      	l32i.n	a9, a14, 0
4201058e:	001706        	j	420105ee <_vfiprintf_r+0x9b2>
42010591:	922ec2        	l32i	a12, a14, 0x248
42010594:	fd1c      	movi.n	a13, 31
42010596:	02deb2        	addmi	a11, a14, 0x200
42010599:	9c4b      	addi.n	a9, a12, 4
4201059b:	2d2d87        	blt	a13, a8, 420105cc <_vfiprintf_r+0x990>
4201059e:	d81b      	addi.n	a13, a8, 1
420105a0:	9161d2        	s32i	a13, a1, 0x244
420105a3:	126b92        	s32i	a9, a11, 72
420105a6:	8d1c      	movi.n	a13, 24
420105a8:	052d97        	blt	a13, a9, 420105b1 <_vfiprintf_r+0x975>
420105ab:	112bb2        	l32i	a11, a11, 68
420105ae:	000286        	j	420105bc <_vfiprintf_r+0x980>
420105b1:	012dc7        	blt	a13, a12, 420105b6 <_vfiprintf_r+0x97a>
420105b4:	492c      	movi.n	a9, 36
420105b6:	902eb2        	l32i	a11, a14, 0x240
420105b9:	926e92        	s32i	a9, a14, 0x248
420105bc:	bb9a      	add.n	a11, a11, a9
420105be:	fccbb2        	addi	a11, a11, -4
420105c1:	0b98      	l32i.n	a9, a11, 0
420105c3:	b088e0        	addx8	a8, a8, a14
420105c6:	0899      	s32i.n	a9, a8, 0
420105c8:	000886        	j	420105ee <_vfiprintf_r+0x9b2>
420105cb:	6b9200        	ole.s	b9, f2, f0
420105ce:	881c12        	l16ui	a1, a12, 0x110
420105d1:	072897        	blt	a8, a9, 420105dc <_vfiprintf_r+0x9a0>
420105d4:	112b82        	l32i	a8, a11, 68
420105d7:	000306        	j	420105e7 <_vfiprintf_r+0x9ab>
420105da:	c70000        	lsi	f0, a0, 0x31c
420105dd:	0128      	l32i.n	a2, a1, 0
420105df:	492c      	movi.n	a9, 36
420105e1:	902e82        	l32i	a8, a14, 0x240
420105e4:	926e92        	s32i	a9, a14, 0x248
420105e7:	889a      	add.n	a8, a8, a9
420105e9:	fcc882        	addi	a8, a8, -4
420105ec:	0898      	l32i.n	a9, a8, 0
420105ee:	9d2182        	l32i	a8, a1, 0x274
420105f1:	0989      	s32i.n	a8, a9, 0
420105f3:	318f80        	srai	a8, a8, 31
420105f6:	1989      	s32i.n	a8, a9, 4
420105f8:	009606        	j	42010854 <_vfiprintf_r+0xc18>
420105fb:	634700        	minu	a4, a7, a0
420105fe:	148c60        	extui	a8, a6, 12, 2
42010601:	006d46        	j	420107ba <_vfiprintf_r+0xb7e>
42010604:	a51b      	addi.n	a10, a5, 1
42010606:	02a587        	bge	a5, a8, 4201060c <_vfiprintf_r+0x9d0>
42010609:	007806        	j	420107ed <_vfiprintf_r+0xbb1>
4201060c:	922ec2        	l32i	a12, a14, 0x248
4201060f:	fd1c      	movi.n	a13, 31
42010611:	02deb2        	addmi	a11, a14, 0x200
42010614:	9c4b      	addi.n	a9, a12, 4
42010616:	272d87        	blt	a13, a8, 42010641 <_vfiprintf_r+0xa05>
42010619:	d81b      	addi.n	a13, a8, 1
4201061b:	9161d2        	s32i	a13, a1, 0x244
4201061e:	126b92        	s32i	a9, a11, 72
42010621:	8d1c      	movi.n	a13, 24
42010623:	052d97        	blt	a13, a9, 4201062c <_vfiprintf_r+0x9f0>
42010626:	112bb2        	l32i	a11, a11, 68
42010629:	000286        	j	42010637 <_vfiprintf_r+0x9fb>
4201062c:	012dc7        	blt	a13, a12, 42010631 <_vfiprintf_r+0x9f5>
4201062f:	492c      	movi.n	a9, 36
42010631:	902eb2        	l32i	a11, a14, 0x240
42010634:	926e92        	s32i	a9, a14, 0x248
42010637:	bb9a      	add.n	a11, a11, a9
42010639:	fccbb2        	addi	a11, a11, -4
4201063c:	0b98      	l32i.n	a9, a11, 0
4201063e:	007946        	j	42010827 <_vfiprintf_r+0xbeb>
42010641:	126b92        	s32i	a9, a11, 72
42010644:	881c      	movi.n	a8, 24
42010646:	062897        	blt	a8, a9, 42010650 <_vfiprintf_r+0xa14>
42010649:	112b82        	l32i	a8, a11, 68
4201064c:	0002c6        	j	4201065b <_vfiprintf_r+0xa1f>
4201064f:	28c700        	lsi	f0, a7, 160
42010652:	492c01        	l32r	a0, 41fe2b04 <_coredump_iram_end+0x1c60b04>
42010655:	902e82        	l32i	a8, a14, 0x240
42010658:	926e92        	s32i	a9, a14, 0x248
4201065b:	889a      	add.n	a8, a8, a9
4201065d:	007a46        	j	4201084a <_vfiprintf_r+0xc0e>
42010660:	02e367        	bbsi	a3, 6, 42010666 <_vfiprintf_r+0xa2a>
42010663:	002946        	j	4201070c <_vfiprintf_r+0xad0>
42010666:	e4ac      	beqz.n	a4, 42010698 <_vfiprintf_r+0xa5c>
42010668:	09a687        	bge	a6, a8, 42010675 <_vfiprintf_r+0xa39>
4201066b:	b0e6e0        	addx8	a14, a6, a14
4201066e:	0e98      	l32i.n	a9, a14, 0
42010670:	000786        	j	42010692 <_vfiprintf_r+0xa56>
42010673:	820000        	mull	a0, a0, a0
42010676:	8a30a2        	lsi	f10, a0, 0x228
42010679:	8e          	.byte	0x8e
4201067a:	34a2d2        	movi	a13, 0x234
4201067d:	40a2c2        	movi	a12, 0x240
42010680:	0189      	s32i.n	a8, a1, 0
42010682:	01def2        	addmi	a15, a14, 0x100
42010685:	deda      	add.n	a13, a14, a13
42010687:	ceca      	add.n	a12, a14, a12
42010689:	07bd      	mov.n	a11, a7
4201068b:	06ad      	mov.n	a10, a6
4201068d:	ff0ba5        	call8	4200f748 <get_arg$isra$0>
42010690:	0a98      	l32i.n	a9, a10, 0
42010692:	05ad      	mov.n	a10, a5
42010694:	001a86        	j	42010702 <_vfiprintf_r+0xac6>
42010697:	a51b00        	extui	a1, a0, 27, 11
4201069a:	07a587        	bge	a5, a8, 420106a5 <_vfiprintf_r+0xa69>
4201069d:	b0e6e0        	addx8	a14, a6, a14
420106a0:	0e98      	l32i.n	a9, a14, 0
420106a2:	001706        	j	42010702 <_vfiprintf_r+0xac6>
420106a5:	922ec2        	l32i	a12, a14, 0x248
420106a8:	fd1c      	movi.n	a13, 31
420106aa:	02deb2        	addmi	a11, a14, 0x200
420106ad:	9c4b      	addi.n	a9, a12, 4
420106af:	2d2d87        	blt	a13, a8, 420106e0 <_vfiprintf_r+0xaa4>
420106b2:	d81b      	addi.n	a13, a8, 1
420106b4:	9161d2        	s32i	a13, a1, 0x244
420106b7:	126b92        	s32i	a9, a11, 72
420106ba:	8d1c      	movi.n	a13, 24
420106bc:	052d97        	blt	a13, a9, 420106c5 <_vfiprintf_r+0xa89>
420106bf:	112bb2        	l32i	a11, a11, 68
420106c2:	000286        	j	420106d0 <_vfiprintf_r+0xa94>
420106c5:	012dc7        	blt	a13, a12, 420106ca <_vfiprintf_r+0xa8e>
420106c8:	492c      	movi.n	a9, 36
420106ca:	902eb2        	l32i	a11, a14, 0x240
420106cd:	926e92        	s32i	a9, a14, 0x248
420106d0:	bb9a      	add.n	a11, a11, a9
420106d2:	fccbb2        	addi	a11, a11, -4
420106d5:	0b98      	l32i.n	a9, a11, 0
420106d7:	b088e0        	addx8	a8, a8, a14
420106da:	0899      	s32i.n	a9, a8, 0
420106dc:	000886        	j	42010702 <_vfiprintf_r+0xac6>
420106df:	6b9200        	ole.s	b9, f2, f0
420106e2:	881c12        	l16ui	a1, a12, 0x110
420106e5:	072897        	blt	a8, a9, 420106f0 <_vfiprintf_r+0xab4>
420106e8:	112b82        	l32i	a8, a11, 68
420106eb:	000306        	j	420106fb <_vfiprintf_r+0xabf>
420106ee:	c70000        	lsi	f0, a0, 0x31c
420106f1:	0128      	l32i.n	a2, a1, 0
420106f3:	492c      	movi.n	a9, 36
420106f5:	902e82        	l32i	a8, a14, 0x240
420106f8:	926e92        	s32i	a9, a14, 0x248
420106fb:	889a      	add.n	a8, a8, a9
420106fd:	fcc882        	addi	a8, a8, -4
42010700:	0898      	l32i.n	a9, a8, 0
42010702:	9d2182        	l32i	a8, a1, 0x274
42010705:	005982        	s16i	a8, a9, 0
42010708:	005206        	j	42010854 <_vfiprintf_r+0xc18>
4201070b:	e39700        	lsi	f0, a7, 0x38c
4201070e:	294602        	s8i	a0, a6, 41
42010711:	b4ac00        	extui	a10, a0, 12, 12
42010714:	07a687        	bge	a6, a8, 4201071f <_vfiprintf_r+0xae3>
42010717:	b0e6e0        	addx8	a14, a6, a14
4201071a:	0e98      	l32i.n	a9, a14, 0
4201071c:	000706        	j	4201073c <_vfiprintf_r+0xb00>
4201071f:	30a282        	movi	a8, 0x230
42010722:	8e8a      	add.n	a8, a14, a8
42010724:	34a2d2        	movi	a13, 0x234
42010727:	40a2c2        	movi	a12, 0x240
4201072a:	0189      	s32i.n	a8, a1, 0
4201072c:	01def2        	addmi	a15, a14, 0x100
4201072f:	deda      	add.n	a13, a14, a13
42010731:	ceca      	add.n	a12, a14, a12
42010733:	07bd      	mov.n	a11, a7
42010735:	06ad      	mov.n	a10, a6
42010737:	ff0125        	call8	4200f748 <get_arg$isra$0>
4201073a:	0a98      	l32i.n	a9, a10, 0
4201073c:	05ad      	mov.n	a10, a5
4201073e:	001b06        	j	420107ae <_vfiprintf_r+0xb72>
42010741:	a51b      	addi.n	a10, a5, 1
42010743:	09a587        	bge	a5, a8, 42010750 <_vfiprintf_r+0xb14>
42010746:	b0e6e0        	addx8	a14, a6, a14
42010749:	0e98      	l32i.n	a9, a14, 0
4201074b:	0017c6        	j	420107ae <_vfiprintf_r+0xb72>
4201074e:	c20000        	quou	a0, a0, a0
42010751:	2e          	.byte	0x2e
42010752:	fd1c92        	l16ui	a9, a12, 0x1fa
42010755:	02deb2        	addmi	a11, a14, 0x200
42010758:	9c4b      	addi.n	a9, a12, 4
4201075a:	2e2d87        	blt	a13, a8, 4201078c <_vfiprintf_r+0xb50>
4201075d:	d81b      	addi.n	a13, a8, 1
4201075f:	9161d2        	s32i	a13, a1, 0x244
42010762:	126b92        	s32i	a9, a11, 72
42010765:	8d1c      	movi.n	a13, 24
42010767:	052d97        	blt	a13, a9, 42010770 <_vfiprintf_r+0xb34>
4201076a:	112bb2        	l32i	a11, a11, 68
4201076d:	000286        	j	4201077b <_vfiprintf_r+0xb3f>
42010770:	012dc7        	blt	a13, a12, 42010775 <_vfiprintf_r+0xb39>
42010773:	492c      	movi.n	a9, 36
42010775:	902eb2        	l32i	a11, a14, 0x240
42010778:	926e92        	s32i	a9, a14, 0x248
4201077b:	bb9a      	add.n	a11, a11, a9
4201077d:	fccbb2        	addi	a11, a11, -4
42010780:	0b98      	l32i.n	a9, a11, 0
42010782:	b088e0        	addx8	a8, a8, a14
42010785:	0899      	s32i.n	a9, a8, 0
42010787:	0008c6        	j	420107ae <_vfiprintf_r+0xb72>
4201078a:	920000        	lsi	f0, a0, 0x248
4201078d:	126b      	addi.n	a1, a2, 6
4201078f:	881c      	movi.n	a8, 24
42010791:	072897        	blt	a8, a9, 4201079c <_vfiprintf_r+0xb60>
42010794:	112b82        	l32i	a8, a11, 68
42010797:	000306        	j	420107a7 <_vfiprintf_r+0xb6b>
4201079a:	c70000        	lsi	f0, a0, 0x31c
4201079d:	0128      	l32i.n	a2, a1, 0
4201079f:	492c      	movi.n	a9, 36
420107a1:	902e82        	l32i	a8, a14, 0x240
420107a4:	926e92        	s32i	a9, a14, 0x248
420107a7:	889a      	add.n	a8, a8, a9
420107a9:	fcc882        	addi	a8, a8, -4
420107ac:	0898      	l32i.n	a9, a8, 0
420107ae:	9d2182        	l32i	a8, a1, 0x274
420107b1:	004982        	s8i	a8, a9, 0
420107b4:	002706        	j	42010854 <_vfiprintf_r+0xc18>
420107b7:	c4ac00        	extui	a10, a0, 12, 13
420107ba:	07a687        	bge	a6, a8, 420107c5 <_vfiprintf_r+0xb89>
420107bd:	b0e6e0        	addx8	a14, a6, a14
420107c0:	0e98      	l32i.n	a9, a14, 0
420107c2:	000706        	j	420107e2 <_vfiprintf_r+0xba6>
420107c5:	30a282        	movi	a8, 0x230
420107c8:	8e8a      	add.n	a8, a14, a8
420107ca:	34a2d2        	movi	a13, 0x234
420107cd:	40a2c2        	movi	a12, 0x240
420107d0:	0189      	s32i.n	a8, a1, 0
420107d2:	01def2        	addmi	a15, a14, 0x100
420107d5:	deda      	add.n	a13, a14, a13
420107d7:	ceca      	add.n	a12, a14, a12
420107d9:	07bd      	mov.n	a11, a7
420107db:	06ad      	mov.n	a10, a6
420107dd:	fef6a5        	call8	4200f748 <get_arg$isra$0>
420107e0:	0a98      	l32i.n	a9, a10, 0
420107e2:	05ad      	mov.n	a10, a5
420107e4:	0019c6        	j	4201084f <_vfiprintf_r+0xc13>
420107e7:	a51b00        	extui	a1, a0, 27, 11
420107ea:	07a587        	bge	a5, a8, 420107f5 <_vfiprintf_r+0xbb9>
420107ed:	b0e6e0        	addx8	a14, a6, a14
420107f0:	0e98      	l32i.n	a9, a14, 0
420107f2:	001646        	j	4201084f <_vfiprintf_r+0xc13>
420107f5:	922ec2        	l32i	a12, a14, 0x248
420107f8:	fd1c      	movi.n	a13, 31
420107fa:	02de92        	addmi	a9, a14, 0x200
420107fd:	bc4b      	addi.n	a11, a12, 4
420107ff:	2c2d87        	blt	a13, a8, 4201082f <_vfiprintf_r+0xbf3>
42010802:	d81b      	addi.n	a13, a8, 1
42010804:	9161d2        	s32i	a13, a1, 0x244
42010807:	1269b2        	s32i	a11, a9, 72
4201080a:	8d1c      	movi.n	a13, 24
4201080c:	052db7        	blt	a13, a11, 42010815 <_vfiprintf_r+0xbd9>
4201080f:	112992        	l32i	a9, a9, 68
42010812:	000286        	j	42010820 <_vfiprintf_r+0xbe4>
42010815:	012dc7        	blt	a13, a12, 4201081a <_vfiprintf_r+0xbde>
42010818:	4b2c      	movi.n	a11, 36
4201081a:	902e92        	l32i	a9, a14, 0x240
4201081d:	926eb2        	s32i	a11, a14, 0x248
42010820:	99ba      	add.n	a9, a9, a11
42010822:	fcc992        	addi	a9, a9, -4
42010825:	0998      	l32i.n	a9, a9, 0
42010827:	b088e0        	addx8	a8, a8, a14
4201082a:	0899      	s32i.n	a9, a8, 0
4201082c:	0007c6        	j	4201084f <_vfiprintf_r+0xc13>
4201082f:	1269b2        	s32i	a11, a9, 72
42010832:	881c      	movi.n	a8, 24
42010834:	0528b7        	blt	a8, a11, 4201083d <_vfiprintf_r+0xc01>
42010837:	112982        	l32i	a8, a9, 68
4201083a:	000286        	j	42010848 <_vfiprintf_r+0xc0c>
4201083d:	0128c7        	blt	a8, a12, 42010842 <_vfiprintf_r+0xc06>
42010840:	4b2c      	movi.n	a11, 36
42010842:	902e82        	l32i	a8, a14, 0x240
42010845:	926eb2        	s32i	a11, a14, 0x248
42010848:	88ba      	add.n	a8, a8, a11
4201084a:	fcc882        	addi	a8, a8, -4
4201084d:	0898      	l32i.n	a9, a8, 0
4201084f:	9d2182        	l32i	a8, a1, 0x274
42010852:	0989      	s32i.n	a8, a9, 0
42010854:	0a5d      	mov.n	a5, a10
42010856:	fd3f86        	j	4200fd58 <_vfiprintf_r+0x11c>
42010859:	081c      	movi.n	a8, 16
4201085b:	203380        	or	a3, a3, a8
4201085e:	912182        	l32i	a8, a1, 0x244
42010861:	10c1e2        	addi	a14, a1, 16
42010864:	02e357        	bbsi	a3, 5, 4201086a <_vfiprintf_r+0xc2e>
42010867:	002f86        	j	42010929 <_vfiprintf_r+0xced>
4201086a:	f4ac      	beqz.n	a4, 4201089d <_vfiprintf_r+0xc61>
4201086c:	09a687        	bge	a6, a8, 42010879 <_vfiprintf_r+0xc3d>
4201086f:	b0e6e0        	addx8	a14, a6, a14
42010872:	0e48      	l32i.n	a4, a14, 0
42010874:	1e28      	l32i.n	a2, a14, 4
42010876:	000786        	j	42010898 <_vfiprintf_r+0xc5c>
42010879:	30a282        	movi	a8, 0x230
4201087c:	8e8a      	add.n	a8, a14, a8
4201087e:	34a2d2        	movi	a13, 0x234
42010881:	40a2c2        	movi	a12, 0x240
42010884:	0189      	s32i.n	a8, a1, 0
42010886:	01def2        	addmi	a15, a14, 0x100
42010889:	deda      	add.n	a13, a14, a13
4201088b:	ceca      	add.n	a12, a14, a12
4201088d:	07bd      	mov.n	a11, a7
4201088f:	06ad      	mov.n	a10, a6
42010891:	feeb65        	call8	4200f748 <get_arg$isra$0>
42010894:	0a48      	l32i.n	a4, a10, 0
42010896:	1a28      	l32i.n	a2, a10, 4
42010898:	057d      	mov.n	a7, a5
4201089a:	00a806        	j	42010b3e <_vfiprintf_r+0xf02>
4201089d:	751b      	addi.n	a7, a5, 1
4201089f:	09a587        	bge	a5, a8, 420108ac <_vfiprintf_r+0xc70>
420108a2:	b0e6e0        	addx8	a14, a6, a14
420108a5:	0e48      	l32i.n	a4, a14, 0
420108a7:	1e28      	l32i.n	a2, a14, 4
420108a9:	00a446        	j	42010b3e <_vfiprintf_r+0xf02>
420108ac:	922e92        	l32i	a9, a14, 0x248
420108af:	8a7c      	movi.n	a10, -8
420108b1:	997b      	addi.n	a9, a9, 7
420108b3:	1099a0        	and	a9, a9, a10
420108b6:	fb1c      	movi.n	a11, 31
420108b8:	02dee2        	addmi	a14, a14, 0x200
420108bb:	a98b      	addi.n	a10, a9, 8
420108bd:	3b2b87        	blt	a11, a8, 420108fc <_vfiprintf_r+0xcc0>
420108c0:	b81b      	addi.n	a11, a8, 1
420108c2:	9161b2        	s32i	a11, a1, 0x244
420108c5:	126ea2        	s32i	a10, a14, 72
420108c8:	8b1c      	movi.n	a11, 24
420108ca:	062ba7        	blt	a11, a10, 420108d4 <_vfiprintf_r+0xc98>
420108cd:	112e92        	l32i	a9, a14, 68
420108d0:	000446        	j	420108e5 <_vfiprintf_r+0xca9>
420108d3:	2b9700        	oeq.s	b9, f7, f0
420108d6:	8a2c01        	l32r	a0, 41ff3188 <_coredump_iram_end+0x1c71188>
420108d9:	10c192        	addi	a9, a1, 16
420108dc:	02d992        	addmi	a9, a9, 0x200
420108df:	102992        	l32i	a9, a9, 64
420108e2:	9661a2        	s32i	a10, a1, 0x258
420108e5:	99aa      	add.n	a9, a9, a10
420108e7:	f8c992        	addi	a9, a9, -8
420108ea:	0948      	l32i.n	a4, a9, 0
420108ec:	1928      	l32i.n	a2, a9, 4
420108ee:	10c192        	addi	a9, a1, 16
420108f1:	b08890        	addx8	a8, a8, a9
420108f4:	0849      	s32i.n	a4, a8, 0
420108f6:	1829      	s32i.n	a2, a8, 4
420108f8:	009086        	j	42010b3e <_vfiprintf_r+0xf02>
420108fb:	6ea200        	f64rnd	a10, a2, a0, 2
420108fe:	881c12        	l16ui	a1, a12, 0x110
42010901:	0728a7        	blt	a8, a10, 4201090c <_vfiprintf_r+0xcd0>
42010904:	112e82        	l32i	a8, a14, 68
42010907:	000486        	j	4201091d <_vfiprintf_r+0xce1>
4201090a:	970000        	lsi	f0, a0, 0x25c
4201090d:	0128      	l32i.n	a2, a1, 0
4201090f:	8a2c      	movi.n	a10, 40
42010911:	10c182        	addi	a8, a1, 16
42010914:	02d882        	addmi	a8, a8, 0x200
42010917:	102882        	l32i	a8, a8, 64
4201091a:	9661a2        	s32i	a10, a1, 0x258
4201091d:	88aa      	add.n	a8, a8, a10
4201091f:	f8c882        	addi	a8, a8, -8
42010922:	0848      	l32i.n	a4, a8, 0
42010924:	1828      	l32i.n	a2, a8, 4
42010926:	008506        	j	42010b3e <_vfiprintf_r+0xf02>
42010929:	036347        	bbci	a3, 4, 42010930 <_vfiprintf_r+0xcf4>
4201092c:	005946        	j	42010a95 <_vfiprintf_r+0xe59>
4201092f:	e36700        	lsi	f0, a7, 0x38c
42010932:	2b4602        	s8i	a0, a6, 43
42010935:	c4ac00        	extui	a10, a0, 12, 13
42010938:	08a687        	bge	a6, a8, 42010944 <_vfiprintf_r+0xd08>
4201093b:	b0e6e0        	addx8	a14, a6, a14
4201093e:	001e42        	l16ui	a4, a14, 0
42010941:	005f46        	j	42010ac2 <_vfiprintf_r+0xe86>
42010944:	30a282        	movi	a8, 0x230
42010947:	8e8a      	add.n	a8, a14, a8
42010949:	34a2d2        	movi	a13, 0x234
4201094c:	40a2c2        	movi	a12, 0x240
4201094f:	0189      	s32i.n	a8, a1, 0
42010951:	01def2        	addmi	a15, a14, 0x100
42010954:	deda      	add.n	a13, a14, a13
42010956:	ceca      	add.n	a12, a14, a12
42010958:	07bd      	mov.n	a11, a7
4201095a:	20a660        	or	a10, a6, a6
4201095d:	fedea5        	call8	4200f748 <get_arg$isra$0>
42010960:	001a42        	l16ui	a4, a10, 0
42010963:	0056c6        	j	42010ac2 <_vfiprintf_r+0xe86>
42010966:	751b      	addi.n	a7, a5, 1
42010968:	08a587        	bge	a5, a8, 42010974 <_vfiprintf_r+0xd38>
4201096b:	b0e6e0        	addx8	a14, a6, a14
4201096e:	001e42        	l16ui	a4, a14, 0
42010971:	0071c6        	j	42010b3c <_vfiprintf_r+0xf00>
42010974:	922e92        	l32i	a9, a14, 0x248
42010977:	fb1c      	movi.n	a11, 31
42010979:	02dee2        	addmi	a14, a14, 0x200
4201097c:	a94b      	addi.n	a10, a9, 4
4201097e:	362b87        	blt	a11, a8, 420109b8 <_vfiprintf_r+0xd7c>
42010981:	b81b      	addi.n	a11, a8, 1
42010983:	9161b2        	s32i	a11, a1, 0x244
42010986:	126ea2        	s32i	a10, a14, 72
42010989:	8b1c      	movi.n	a11, 24
4201098b:	052ba7        	blt	a11, a10, 42010994 <_vfiprintf_r+0xd58>
4201098e:	112e92        	l32i	a9, a14, 68
42010991:	000406        	j	420109a5 <_vfiprintf_r+0xd69>
42010994:	012b97        	blt	a11, a9, 42010999 <_vfiprintf_r+0xd5d>
42010997:	4a2c      	movi.n	a10, 36
42010999:	10c192        	addi	a9, a1, 16
4201099c:	02d992        	addmi	a9, a9, 0x200
4201099f:	102992        	l32i	a9, a9, 64
420109a2:	9661a2        	s32i	a10, a1, 0x258
420109a5:	99aa      	add.n	a9, a9, a10
420109a7:	fcc992        	addi	a9, a9, -4
420109aa:	0948      	l32i.n	a4, a9, 0
420109ac:	b08810        	addx8	a8, a8, a1
420109af:	4849      	s32i.n	a4, a8, 16
420109b1:	f44040        	extui	a4, a4, 0, 16
420109b4:	006106        	j	42010b3c <_vfiprintf_r+0xf00>
420109b7:	6ea200        	f64rnd	a10, a2, a0, 2
420109ba:	881c12        	l16ui	a1, a12, 0x110
420109bd:	0728a7        	blt	a8, a10, 420109c8 <_vfiprintf_r+0xd8c>
420109c0:	112e82        	l32i	a8, a14, 68
420109c3:	000486        	j	420109d9 <_vfiprintf_r+0xd9d>
420109c6:	970000        	lsi	f0, a0, 0x25c
420109c9:	0128      	l32i.n	a2, a1, 0
420109cb:	4a2c      	movi.n	a10, 36
420109cd:	10c182        	addi	a8, a1, 16
420109d0:	02d882        	addmi	a8, a8, 0x200
420109d3:	102882        	l32i	a8, a8, 64
420109d6:	9661a2        	s32i	a10, a1, 0x258
420109d9:	88aa      	add.n	a8, a8, a10
420109db:	fcc882        	addi	a8, a8, -4
420109de:	001842        	l16ui	a4, a8, 0
420109e1:	0055c6        	j	42010b3c <_vfiprintf_r+0xf00>
420109e4:	02e397        	bbsi	a3, 9, 420109ea <_vfiprintf_r+0xdae>
420109e7:	002a86        	j	42010a95 <_vfiprintf_r+0xe59>
420109ea:	c4ac      	beqz.n	a4, 42010a1a <_vfiprintf_r+0xdde>
420109ec:	09a687        	bge	a6, a8, 420109f9 <_vfiprintf_r+0xdbd>
420109ef:	b0e6e0        	addx8	a14, a6, a14
420109f2:	000e42        	l8ui	a4, a14, 0
420109f5:	003246        	j	42010ac2 <_vfiprintf_r+0xe86>
420109f8:	a28200        	muluh	a8, a2, a0
420109fb:	8e8a30        	f64iter	a8, a10, a3, 0, 0
420109fe:	34a2d2        	movi	a13, 0x234
42010a01:	40a2c2        	movi	a12, 0x240
42010a04:	0189      	s32i.n	a8, a1, 0
42010a06:	01def2        	addmi	a15, a14, 0x100
42010a09:	deda      	add.n	a13, a14, a13
42010a0b:	ceca      	add.n	a12, a14, a12
42010a0d:	07bd      	mov.n	a11, a7
42010a0f:	06ad      	mov.n	a10, a6
42010a11:	fed365        	call8	4200f748 <get_arg$isra$0>
42010a14:	000a42        	l8ui	a4, a10, 0
42010a17:	0029c6        	j	42010ac2 <_vfiprintf_r+0xe86>
42010a1a:	751b      	addi.n	a7, a5, 1
42010a1c:	08a587        	bge	a5, a8, 42010a28 <_vfiprintf_r+0xdec>
42010a1f:	b0e6e0        	addx8	a14, a6, a14
42010a22:	000e42        	l8ui	a4, a14, 0
42010a25:	0044c6        	j	42010b3c <_vfiprintf_r+0xf00>
42010a28:	922e92        	l32i	a9, a14, 0x248
42010a2b:	fb1c      	movi.n	a11, 31
42010a2d:	02dee2        	addmi	a14, a14, 0x200
42010a30:	a94b      	addi.n	a10, a9, 4
42010a32:	352b87        	blt	a11, a8, 42010a6b <_vfiprintf_r+0xe2f>
42010a35:	b81b      	addi.n	a11, a8, 1
42010a37:	9161b2        	s32i	a11, a1, 0x244
42010a3a:	126ea2        	s32i	a10, a14, 72
42010a3d:	8b1c      	movi.n	a11, 24
42010a3f:	052ba7        	blt	a11, a10, 42010a48 <_vfiprintf_r+0xe0c>
42010a42:	112e92        	l32i	a9, a14, 68
42010a45:	000406        	j	42010a59 <_vfiprintf_r+0xe1d>
42010a48:	012b97        	blt	a11, a9, 42010a4d <_vfiprintf_r+0xe11>
42010a4b:	4a2c      	movi.n	a10, 36
42010a4d:	10c192        	addi	a9, a1, 16
42010a50:	02d992        	addmi	a9, a9, 0x200
42010a53:	102992        	l32i	a9, a9, 64
42010a56:	9661a2        	s32i	a10, a1, 0x258
42010a59:	99aa      	add.n	a9, a9, a10
42010a5b:	fcc992        	addi	a9, a9, -4
42010a5e:	0948      	l32i.n	a4, a9, 0
42010a60:	b08810        	addx8	a8, a8, a1
42010a63:	4849      	s32i.n	a4, a8, 16
42010a65:	744040        	extui	a4, a4, 0, 8
42010a68:	003406        	j	42010b3c <_vfiprintf_r+0xf00>
42010a6b:	126ea2        	s32i	a10, a14, 72
42010a6e:	881c      	movi.n	a8, 24
42010a70:	0528a7        	blt	a8, a10, 42010a79 <_vfiprintf_r+0xe3d>
42010a73:	112e82        	l32i	a8, a14, 68
42010a76:	000406        	j	42010a8a <_vfiprintf_r+0xe4e>
42010a79:	012897        	blt	a8, a9, 42010a7e <_vfiprintf_r+0xe42>
42010a7c:	4a2c      	movi.n	a10, 36
42010a7e:	10c182        	addi	a8, a1, 16
42010a81:	02d882        	addmi	a8, a8, 0x200
42010a84:	102882        	l32i	a8, a8, 64
42010a87:	9661a2        	s32i	a10, a1, 0x258
42010a8a:	88aa      	add.n	a8, a8, a10
42010a8c:	fcc882        	addi	a8, a8, -4
42010a8f:	000842        	l8ui	a4, a8, 0
42010a92:	002986        	j	42010b3c <_vfiprintf_r+0xf00>
42010a95:	f4ac      	beqz.n	a4, 42010ac8 <_vfiprintf_r+0xe8c>
42010a97:	0aa687        	bge	a6, a8, 42010aa5 <_vfiprintf_r+0xe69>
42010a9a:	b0e6e0        	addx8	a14, a6, a14
42010a9d:	0e48      	l32i.n	a4, a14, 0
42010a9f:	0007c6        	j	42010ac2 <_vfiprintf_r+0xe86>
42010aa2:	000000        	ill
42010aa5:	30a282        	movi	a8, 0x230
42010aa8:	8e8a      	add.n	a8, a14, a8
42010aaa:	34a2d2        	movi	a13, 0x234
42010aad:	40a2c2        	movi	a12, 0x240
42010ab0:	0189      	s32i.n	a8, a1, 0
42010ab2:	01def2        	addmi	a15, a14, 0x100
42010ab5:	deda      	add.n	a13, a14, a13
42010ab7:	ceca      	add.n	a12, a14, a12
42010ab9:	07bd      	mov.n	a11, a7
42010abb:	06ad      	mov.n	a10, a6
42010abd:	fec8a5        	call8	4200f748 <get_arg$isra$0>
42010ac0:	0a48      	l32i.n	a4, a10, 0
42010ac2:	057d      	mov.n	a7, a5
42010ac4:	001d06        	j	42010b3c <_vfiprintf_r+0xf00>
42010ac7:	751b00        	extui	a1, a0, 27, 8
42010aca:	07a587        	bge	a5, a8, 42010ad5 <_vfiprintf_r+0xe99>
42010acd:	b0e6e0        	addx8	a14, a6, a14
42010ad0:	0e48      	l32i.n	a4, a14, 0
42010ad2:	001986        	j	42010b3c <_vfiprintf_r+0xf00>
42010ad5:	922e92        	l32i	a9, a14, 0x248
42010ad8:	fb1c      	movi.n	a11, 31
42010ada:	02dee2        	addmi	a14, a14, 0x200
42010add:	a94b      	addi.n	a10, a9, 4
42010adf:	322b87        	blt	a11, a8, 42010b15 <_vfiprintf_r+0xed9>
42010ae2:	b81b      	addi.n	a11, a8, 1
42010ae4:	9161b2        	s32i	a11, a1, 0x244
42010ae7:	126ea2        	s32i	a10, a14, 72
42010aea:	8b1c      	movi.n	a11, 24
42010aec:	052ba7        	blt	a11, a10, 42010af5 <_vfiprintf_r+0xeb9>
42010aef:	112e92        	l32i	a9, a14, 68
42010af2:	000406        	j	42010b06 <_vfiprintf_r+0xeca>
42010af5:	012b97        	blt	a11, a9, 42010afa <_vfiprintf_r+0xebe>
42010af8:	4a2c      	movi.n	a10, 36
42010afa:	10c192        	addi	a9, a1, 16
42010afd:	02d992        	addmi	a9, a9, 0x200
42010b00:	102992        	l32i	a9, a9, 64
42010b03:	9661a2        	s32i	a10, a1, 0x258
42010b06:	99aa      	add.n	a9, a9, a10
42010b08:	fcc992        	addi	a9, a9, -4
42010b0b:	0948      	l32i.n	a4, a9, 0
42010b0d:	b08810        	addx8	a8, a8, a1
42010b10:	4849      	s32i.n	a4, a8, 16
42010b12:	000986        	j	42010b3c <_vfiprintf_r+0xf00>
42010b15:	126ea2        	s32i	a10, a14, 72
42010b18:	881c      	movi.n	a8, 24
42010b1a:	0628a7        	blt	a8, a10, 42010b24 <_vfiprintf_r+0xee8>
42010b1d:	112e82        	l32i	a8, a14, 68
42010b20:	000446        	j	42010b35 <_vfiprintf_r+0xef9>
42010b23:	289700        	lsi	f0, a7, 160
42010b26:	4a2c01        	l32r	a0, 41fe33d8 <_coredump_iram_end+0x1c613d8>
42010b29:	10c182        	addi	a8, a1, 16
42010b2c:	02d882        	addmi	a8, a8, 0x200
42010b2f:	102882        	l32i	a8, a8, 64
42010b32:	9661a2        	s32i	a10, a1, 0x258
42010b35:	88aa      	add.n	a8, a8, a10
42010b37:	fcc882        	addi	a8, a8, -4
42010b3a:	0848      	l32i.n	a4, a8, 0
42010b3c:	020c      	movi.n	a2, 0
42010b3e:	ffab82        	movi	a8, 0xfffffbff
42010b41:	103380        	and	a3, a3, a8
42010b44:	080c      	movi.n	a8, 0
42010b46:	01edc6        	j	42011301 <_vfiprintf_r+0x16c5>
42010b49:	218200        	srai	a8, a0, 2
42010b4c:	c1e291        	l32r	a9, 420012d4 <__esp_system_init_fn_init_efuse_show_app_info+0x8> (1738b600 <UserFrameTotalSize+0x1738b500>)
42010b4f:	b4ac10        	extui	a10, a1, 12, 12
42010b52:	07a687        	bge	a6, a8, 42010b5d <_vfiprintf_r+0xf21>
42010b55:	b0e6e0        	addx8	a14, a6, a14
42010b58:	0e48      	l32i.n	a4, a14, 0
42010b5a:	000706        	j	42010b7a <_vfiprintf_r+0xf3e>
42010b5d:	30a282        	movi	a8, 0x230
42010b60:	8e8a      	add.n	a8, a14, a8
42010b62:	34a2d2        	movi	a13, 0x234
42010b65:	40a2c2        	movi	a12, 0x240
42010b68:	0189      	s32i.n	a8, a1, 0
42010b6a:	01def2        	addmi	a15, a14, 0x100
42010b6d:	deda      	add.n	a13, a14, a13
42010b6f:	ceca      	add.n	a12, a14, a12
42010b71:	07bd      	mov.n	a11, a7
42010b73:	06ad      	mov.n	a10, a6
42010b75:	febd25        	call8	4200f748 <get_arg$isra$0>
42010b78:	0a48      	l32i.n	a4, a10, 0
42010b7a:	057d      	mov.n	a7, a5
42010b7c:	001d06        	j	42010bf4 <_vfiprintf_r+0xfb8>
42010b7f:	751b      	addi.n	a7, a5, 1
42010b81:	07a587        	bge	a5, a8, 42010b8c <_vfiprintf_r+0xf50>
42010b84:	b0e6e0        	addx8	a14, a6, a14
42010b87:	0e48      	l32i.n	a4, a14, 0
42010b89:	0019c6        	j	42010bf4 <_vfiprintf_r+0xfb8>
42010b8c:	922e92        	l32i	a9, a14, 0x248
42010b8f:	fb1c      	movi.n	a11, 31
42010b91:	02dee2        	addmi	a14, a14, 0x200
42010b94:	a94b      	addi.n	a10, a9, 4
42010b96:	322b87        	blt	a11, a8, 42010bcc <_vfiprintf_r+0xf90>
42010b99:	b81b      	addi.n	a11, a8, 1
42010b9b:	9161b2        	s32i	a11, a1, 0x244
42010b9e:	126ea2        	s32i	a10, a14, 72
42010ba1:	8b1c      	movi.n	a11, 24
42010ba3:	052ba7        	blt	a11, a10, 42010bac <_vfiprintf_r+0xf70>
42010ba6:	112e92        	l32i	a9, a14, 68
42010ba9:	000406        	j	42010bbd <_vfiprintf_r+0xf81>
42010bac:	012b97        	blt	a11, a9, 42010bb1 <_vfiprintf_r+0xf75>
42010baf:	4a2c      	movi.n	a10, 36
42010bb1:	10c192        	addi	a9, a1, 16
42010bb4:	02d992        	addmi	a9, a9, 0x200
42010bb7:	102992        	l32i	a9, a9, 64
42010bba:	9661a2        	s32i	a10, a1, 0x258
42010bbd:	99aa      	add.n	a9, a9, a10
42010bbf:	fcc992        	addi	a9, a9, -4
42010bc2:	0948      	l32i.n	a4, a9, 0
42010bc4:	b08810        	addx8	a8, a8, a1
42010bc7:	4849      	s32i.n	a4, a8, 16
42010bc9:	0009c6        	j	42010bf4 <_vfiprintf_r+0xfb8>
42010bcc:	126ea2        	s32i	a10, a14, 72
42010bcf:	881c      	movi.n	a8, 24
42010bd1:	0728a7        	blt	a8, a10, 42010bdc <_vfiprintf_r+0xfa0>
42010bd4:	112e82        	l32i	a8, a14, 68
42010bd7:	000486        	j	42010bed <_vfiprintf_r+0xfb1>
42010bda:	970000        	lsi	f0, a0, 0x25c
42010bdd:	0128      	l32i.n	a2, a1, 0
42010bdf:	4a2c      	movi.n	a10, 36
42010be1:	10c182        	addi	a8, a1, 16
42010be4:	02d882        	addmi	a8, a8, 0x200
42010be7:	102882        	l32i	a8, a8, 64
42010bea:	9661a2        	s32i	a10, a1, 0x258
42010bed:	88aa      	add.n	a8, a8, a10
42010bef:	fcc882        	addi	a8, a8, -4
42010bf2:	0848      	l32i.n	a4, a8, 0
42010bf4:	280c      	movi.n	a8, 2
42010bf6:	203380        	or	a3, a3, a8
42010bf9:	10c182        	addi	a8, a1, 16
42010bfc:	02d882        	addmi	a8, a8, 0x200
42010bff:	093c      	movi.n	a9, 48
42010c01:	384892        	s8i	a9, a8, 56
42010c04:	78a092        	movi	a9, 120
42010c07:	394892        	s8i	a9, a8, 57
42010c0a:	c09381        	l32r	a8, 42000e58 <_stext+0xe38> (3c0295c4 <_ZTISt12out_of_range+0x138>)
42010c0d:	020c      	movi.n	a2, 0
42010c0f:	a16182        	s32i	a8, a1, 0x284
42010c12:	01ba46        	j	420112ff <_vfiprintf_r+0x16c3>
42010c15:	218200        	srai	a8, a0, 2
42010c18:	c1e291        	l32r	a9, 420013a0 <esp_register_shutdown_handler> (c004136 <UserFrameTotalSize+0xc004036>)
42010c1b:	c4ac10        	extui	a10, a1, 12, 13
42010c1e:	07a687        	bge	a6, a8, 42010c29 <_vfiprintf_r+0xfed>
42010c21:	b0e6e0        	addx8	a14, a6, a14
42010c24:	0e68      	l32i.n	a6, a14, 0
42010c26:	000706        	j	42010c46 <_vfiprintf_r+0x100a>
42010c29:	30a282        	movi	a8, 0x230
42010c2c:	8e8a      	add.n	a8, a14, a8
42010c2e:	34a2d2        	movi	a13, 0x234
42010c31:	40a2c2        	movi	a12, 0x240
42010c34:	06ad      	mov.n	a10, a6
42010c36:	0189      	s32i.n	a8, a1, 0
42010c38:	01def2        	addmi	a15, a14, 0x100
42010c3b:	deda      	add.n	a13, a14, a13
42010c3d:	ceca      	add.n	a12, a14, a12
42010c3f:	07bd      	mov.n	a11, a7
42010c41:	feb065        	call8	4200f748 <get_arg$isra$0>
42010c44:	0a68      	l32i.n	a6, a10, 0
42010c46:	057d      	mov.n	a7, a5
42010c48:	001cc6        	j	42010cbf <_vfiprintf_r+0x1083>
42010c4b:	751b00        	extui	a1, a0, 27, 8
42010c4e:	07a587        	bge	a5, a8, 42010c59 <_vfiprintf_r+0x101d>
42010c51:	b0e6e0        	addx8	a14, a6, a14
42010c54:	0e68      	l32i.n	a6, a14, 0
42010c56:	001946        	j	42010cbf <_vfiprintf_r+0x1083>
42010c59:	922e92        	l32i	a9, a14, 0x248
42010c5c:	fb1c      	movi.n	a11, 31
42010c5e:	02dee2        	addmi	a14, a14, 0x200
42010c61:	a94b      	addi.n	a10, a9, 4
42010c63:	322b87        	blt	a11, a8, 42010c99 <_vfiprintf_r+0x105d>
42010c66:	b81b      	addi.n	a11, a8, 1
42010c68:	9161b2        	s32i	a11, a1, 0x244
42010c6b:	126ea2        	s32i	a10, a14, 72
42010c6e:	8b1c      	movi.n	a11, 24
42010c70:	052ba7        	blt	a11, a10, 42010c79 <_vfiprintf_r+0x103d>
42010c73:	112e92        	l32i	a9, a14, 68
42010c76:	000406        	j	42010c8a <_vfiprintf_r+0x104e>
42010c79:	012b97        	blt	a11, a9, 42010c7e <_vfiprintf_r+0x1042>
42010c7c:	4a2c      	movi.n	a10, 36
42010c7e:	10c192        	addi	a9, a1, 16
42010c81:	02d992        	addmi	a9, a9, 0x200
42010c84:	102992        	l32i	a9, a9, 64
42010c87:	9661a2        	s32i	a10, a1, 0x258
42010c8a:	99aa      	add.n	a9, a9, a10
42010c8c:	fcc992        	addi	a9, a9, -4
42010c8f:	0968      	l32i.n	a6, a9, 0
42010c91:	b08810        	addx8	a8, a8, a1
42010c94:	4869      	s32i.n	a6, a8, 16
42010c96:	000946        	j	42010cbf <_vfiprintf_r+0x1083>
42010c99:	126ea2        	s32i	a10, a14, 72
42010c9c:	881c      	movi.n	a8, 24
42010c9e:	0528a7        	blt	a8, a10, 42010ca7 <_vfiprintf_r+0x106b>
42010ca1:	112e82        	l32i	a8, a14, 68
42010ca4:	000406        	j	42010cb8 <_vfiprintf_r+0x107c>
42010ca7:	012897        	blt	a8, a9, 42010cac <_vfiprintf_r+0x1070>
42010caa:	4a2c      	movi.n	a10, 36
42010cac:	10c182        	addi	a8, a1, 16
42010caf:	02d882        	addmi	a8, a8, 0x200
42010cb2:	102882        	l32i	a8, a8, 64
42010cb5:	9661a2        	s32i	a10, a1, 0x258
42010cb8:	88aa      	add.n	a8, a8, a10
42010cba:	fcc882        	addi	a8, a8, -4
42010cbd:	0868      	l32i.n	a6, a8, 0
42010cbf:	10c182        	addi	a8, a1, 16
42010cc2:	02d882        	addmi	a8, a8, 0x200
42010cc5:	090c      	movi.n	a9, 0
42010cc7:	3a4892        	s8i	a9, a8, 58
42010cca:	9a2182        	l32i	a8, a1, 0x268
42010ccd:	017896        	bltz	a8, 42010ce8 <_vfiprintf_r+0x10ac>
42010cd0:	08cd      	mov.n	a12, a8
42010cd2:	0b0c      	movi.n	a11, 0
42010cd4:	06ad      	mov.n	a10, a6
42010cd6:	c03481        	l32r	a8, 42000da8 <_stext+0xd88> (40001344 <memchr>)
42010cd9:	0008e0        	callx8	a8
42010cdc:	050c      	movi.n	a5, 0
42010cde:	c08a60        	sub	a8, a10, a6
42010ce1:	7b8a56        	bnez	a10, 4201149d <_vfiprintf_r+0x1861>
42010ce4:	01f8c6        	j	420114cb <_vfiprintf_r+0x188f>
42010ce7:	06ad00        	lsi	f0, a13, 24
42010cea:	bd6c81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42010ced:	0008e0        	callx8	a8
42010cf0:	9a61a2        	s32i	a10, a1, 0x268
42010cf3:	050c      	movi.n	a5, 0
42010cf5:	01f486        	j	420114cb <_vfiprintf_r+0x188f>
42010cf8:	081c00        	lsx	f1, a12, a0
42010cfb:	203380        	or	a3, a3, a8
42010cfe:	912182        	l32i	a8, a1, 0x244
42010d01:	10c1e2        	addi	a14, a1, 16
42010d04:	02e357        	bbsi	a3, 5, 42010d0a <_vfiprintf_r+0x10ce>
42010d07:	002f86        	j	42010dc9 <_vfiprintf_r+0x118d>
42010d0a:	f4ac      	beqz.n	a4, 42010d3d <_vfiprintf_r+0x1101>
42010d0c:	09a687        	bge	a6, a8, 42010d19 <_vfiprintf_r+0x10dd>
42010d0f:	b0e6e0        	addx8	a14, a6, a14
42010d12:	0e48      	l32i.n	a4, a14, 0
42010d14:	1e28      	l32i.n	a2, a14, 4
42010d16:	000786        	j	42010d38 <_vfiprintf_r+0x10fc>
42010d19:	30a282        	movi	a8, 0x230
42010d1c:	8e8a      	add.n	a8, a14, a8
42010d1e:	34a2d2        	movi	a13, 0x234
42010d21:	40a2c2        	movi	a12, 0x240
42010d24:	0189      	s32i.n	a8, a1, 0
42010d26:	01def2        	addmi	a15, a14, 0x100
42010d29:	deda      	add.n	a13, a14, a13
42010d2b:	ceca      	add.n	a12, a14, a12
42010d2d:	07bd      	mov.n	a11, a7
42010d2f:	06ad      	mov.n	a10, a6
42010d31:	fea165        	call8	4200f748 <get_arg$isra$0>
42010d34:	0a48      	l32i.n	a4, a10, 0
42010d36:	1a28      	l32i.n	a2, a10, 4
42010d38:	057d      	mov.n	a7, a5
42010d3a:	007d86        	j	42010f34 <_vfiprintf_r+0x12f8>
42010d3d:	751b      	addi.n	a7, a5, 1
42010d3f:	09a587        	bge	a5, a8, 42010d4c <_vfiprintf_r+0x1110>
42010d42:	b0e6e0        	addx8	a14, a6, a14
42010d45:	0e48      	l32i.n	a4, a14, 0
42010d47:	1e28      	l32i.n	a2, a14, 4
42010d49:	0079c6        	j	42010f34 <_vfiprintf_r+0x12f8>
42010d4c:	922e92        	l32i	a9, a14, 0x248
42010d4f:	8a7c      	movi.n	a10, -8
42010d51:	997b      	addi.n	a9, a9, 7
42010d53:	1099a0        	and	a9, a9, a10
42010d56:	fb1c      	movi.n	a11, 31
42010d58:	02dee2        	addmi	a14, a14, 0x200
42010d5b:	a98b      	addi.n	a10, a9, 8
42010d5d:	3b2b87        	blt	a11, a8, 42010d9c <_vfiprintf_r+0x1160>
42010d60:	b81b      	addi.n	a11, a8, 1
42010d62:	9161b2        	s32i	a11, a1, 0x244
42010d65:	126ea2        	s32i	a10, a14, 72
42010d68:	8b1c      	movi.n	a11, 24
42010d6a:	062ba7        	blt	a11, a10, 42010d74 <_vfiprintf_r+0x1138>
42010d6d:	112e92        	l32i	a9, a14, 68
42010d70:	000446        	j	42010d85 <_vfiprintf_r+0x1149>
42010d73:	2b9700        	oeq.s	b9, f7, f0
42010d76:	8a2c01        	l32r	a0, 41ff3628 <_coredump_iram_end+0x1c71628>
42010d79:	10c192        	addi	a9, a1, 16
42010d7c:	02d992        	addmi	a9, a9, 0x200
42010d7f:	102992        	l32i	a9, a9, 64
42010d82:	9661a2        	s32i	a10, a1, 0x258
42010d85:	99aa      	add.n	a9, a9, a10
42010d87:	f8c992        	addi	a9, a9, -8
42010d8a:	0948      	l32i.n	a4, a9, 0
42010d8c:	1928      	l32i.n	a2, a9, 4
42010d8e:	10c192        	addi	a9, a1, 16
42010d91:	b08890        	addx8	a8, a8, a9
42010d94:	0849      	s32i.n	a4, a8, 0
42010d96:	1829      	s32i.n	a2, a8, 4
42010d98:	006606        	j	42010f34 <_vfiprintf_r+0x12f8>
42010d9b:	6ea200        	f64rnd	a10, a2, a0, 2
42010d9e:	881c12        	l16ui	a1, a12, 0x110
42010da1:	0728a7        	blt	a8, a10, 42010dac <_vfiprintf_r+0x1170>
42010da4:	112e82        	l32i	a8, a14, 68
42010da7:	000486        	j	42010dbd <_vfiprintf_r+0x1181>
42010daa:	970000        	lsi	f0, a0, 0x25c
42010dad:	0128      	l32i.n	a2, a1, 0
42010daf:	8a2c      	movi.n	a10, 40
42010db1:	10c182        	addi	a8, a1, 16
42010db4:	02d882        	addmi	a8, a8, 0x200
42010db7:	102882        	l32i	a8, a8, 64
42010dba:	9661a2        	s32i	a10, a1, 0x258
42010dbd:	88aa      	add.n	a8, a8, a10
42010dbf:	f8c882        	addi	a8, a8, -8
42010dc2:	0848      	l32i.n	a4, a8, 0
42010dc4:	1828      	l32i.n	a2, a8, 4
42010dc6:	005a86        	j	42010f34 <_vfiprintf_r+0x12f8>
42010dc9:	036347        	bbci	a3, 4, 42010dd0 <_vfiprintf_r+0x1194>
42010dcc:	005a46        	j	42010f39 <_vfiprintf_r+0x12fd>
42010dcf:	e36700        	lsi	f0, a7, 0x38c
42010dd2:	2b4602        	s8i	a0, a6, 43
42010dd5:	c4ac00        	extui	a10, a0, 12, 13
42010dd8:	08a687        	bge	a6, a8, 42010de4 <_vfiprintf_r+0x11a8>
42010ddb:	b0e6e0        	addx8	a14, a6, a14
42010dde:	001e42        	l16ui	a4, a14, 0
42010de1:	006046        	j	42010f66 <_vfiprintf_r+0x132a>
42010de4:	30a282        	movi	a8, 0x230
42010de7:	8e8a      	add.n	a8, a14, a8
42010de9:	34a2d2        	movi	a13, 0x234
42010dec:	40a2c2        	movi	a12, 0x240
42010def:	0189      	s32i.n	a8, a1, 0
42010df1:	01def2        	addmi	a15, a14, 0x100
42010df4:	deda      	add.n	a13, a14, a13
42010df6:	ceca      	add.n	a12, a14, a12
42010df8:	07bd      	mov.n	a11, a7
42010dfa:	20a660        	or	a10, a6, a6
42010dfd:	fe94a5        	call8	4200f748 <get_arg$isra$0>
42010e00:	001a42        	l16ui	a4, a10, 0
42010e03:	0057c6        	j	42010f66 <_vfiprintf_r+0x132a>
42010e06:	751b      	addi.n	a7, a5, 1
42010e08:	08a587        	bge	a5, a8, 42010e14 <_vfiprintf_r+0x11d8>
42010e0b:	b0e6e0        	addx8	a14, a6, a14
42010e0e:	001e42        	l16ui	a4, a14, 0
42010e11:	004746        	j	42010f32 <_vfiprintf_r+0x12f6>
42010e14:	922e92        	l32i	a9, a14, 0x248
42010e17:	fb1c      	movi.n	a11, 31
42010e19:	02dee2        	addmi	a14, a14, 0x200
42010e1c:	a94b      	addi.n	a10, a9, 4
42010e1e:	362b87        	blt	a11, a8, 42010e58 <_vfiprintf_r+0x121c>
42010e21:	b81b      	addi.n	a11, a8, 1
42010e23:	9161b2        	s32i	a11, a1, 0x244
42010e26:	126ea2        	s32i	a10, a14, 72
42010e29:	8b1c      	movi.n	a11, 24
42010e2b:	052ba7        	blt	a11, a10, 42010e34 <_vfiprintf_r+0x11f8>
42010e2e:	112e92        	l32i	a9, a14, 68
42010e31:	000406        	j	42010e45 <_vfiprintf_r+0x1209>
42010e34:	012b97        	blt	a11, a9, 42010e39 <_vfiprintf_r+0x11fd>
42010e37:	4a2c      	movi.n	a10, 36
42010e39:	10c192        	addi	a9, a1, 16
42010e3c:	02d992        	addmi	a9, a9, 0x200
42010e3f:	102992        	l32i	a9, a9, 64
42010e42:	9661a2        	s32i	a10, a1, 0x258
42010e45:	99aa      	add.n	a9, a9, a10
42010e47:	fcc992        	addi	a9, a9, -4
42010e4a:	0948      	l32i.n	a4, a9, 0
42010e4c:	b08810        	addx8	a8, a8, a1
42010e4f:	4849      	s32i.n	a4, a8, 16
42010e51:	f44040        	extui	a4, a4, 0, 16
42010e54:	003686        	j	42010f32 <_vfiprintf_r+0x12f6>
42010e57:	6ea200        	f64rnd	a10, a2, a0, 2
42010e5a:	881c12        	l16ui	a1, a12, 0x110
42010e5d:	0728a7        	blt	a8, a10, 42010e68 <_vfiprintf_r+0x122c>
42010e60:	112e82        	l32i	a8, a14, 68
42010e63:	000486        	j	42010e79 <_vfiprintf_r+0x123d>
42010e66:	970000        	lsi	f0, a0, 0x25c
42010e69:	0128      	l32i.n	a2, a1, 0
42010e6b:	4a2c      	movi.n	a10, 36
42010e6d:	10c182        	addi	a8, a1, 16
42010e70:	02d882        	addmi	a8, a8, 0x200
42010e73:	102882        	l32i	a8, a8, 64
42010e76:	9661a2        	s32i	a10, a1, 0x258
42010e79:	88aa      	add.n	a8, a8, a10
42010e7b:	fcc882        	addi	a8, a8, -4
42010e7e:	001842        	l16ui	a4, a8, 0
42010e81:	002b46        	j	42010f32 <_vfiprintf_r+0x12f6>
42010e84:	02e397        	bbsi	a3, 9, 42010e8a <_vfiprintf_r+0x124e>
42010e87:	002b86        	j	42010f39 <_vfiprintf_r+0x12fd>
42010e8a:	c4ac      	beqz.n	a4, 42010eba <_vfiprintf_r+0x127e>
42010e8c:	09a687        	bge	a6, a8, 42010e99 <_vfiprintf_r+0x125d>
42010e8f:	b0e6e0        	addx8	a14, a6, a14
42010e92:	000e42        	l8ui	a4, a14, 0
42010e95:	003346        	j	42010f66 <_vfiprintf_r+0x132a>
42010e98:	a28200        	muluh	a8, a2, a0
42010e9b:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42010e9e:	34a2d2        	movi	a13, 0x234
42010ea1:	40a2c2        	movi	a12, 0x240
42010ea4:	0189      	s32i.n	a8, a1, 0
42010ea6:	01def2        	addmi	a15, a14, 0x100
42010ea9:	deda      	add.n	a13, a14, a13
42010eab:	ceca      	add.n	a12, a14, a12
42010ead:	07bd      	mov.n	a11, a7
42010eaf:	06ad      	mov.n	a10, a6
42010eb1:	fe8965        	call8	4200f748 <get_arg$isra$0>
42010eb4:	000a42        	l8ui	a4, a10, 0
42010eb7:	002ac6        	j	42010f66 <_vfiprintf_r+0x132a>
42010eba:	751b      	addi.n	a7, a5, 1
42010ebc:	08a587        	bge	a5, a8, 42010ec8 <_vfiprintf_r+0x128c>
42010ebf:	b0e6e0        	addx8	a14, a6, a14
42010ec2:	000e42        	l8ui	a4, a14, 0
42010ec5:	001a46        	j	42010f32 <_vfiprintf_r+0x12f6>
42010ec8:	922e92        	l32i	a9, a14, 0x248
42010ecb:	fb1c      	movi.n	a11, 31
42010ecd:	02dee2        	addmi	a14, a14, 0x200
42010ed0:	a94b      	addi.n	a10, a9, 4
42010ed2:	352b87        	blt	a11, a8, 42010f0b <_vfiprintf_r+0x12cf>
42010ed5:	b81b      	addi.n	a11, a8, 1
42010ed7:	9161b2        	s32i	a11, a1, 0x244
42010eda:	126ea2        	s32i	a10, a14, 72
42010edd:	8b1c      	movi.n	a11, 24
42010edf:	052ba7        	blt	a11, a10, 42010ee8 <_vfiprintf_r+0x12ac>
42010ee2:	112e92        	l32i	a9, a14, 68
42010ee5:	000406        	j	42010ef9 <_vfiprintf_r+0x12bd>
42010ee8:	012b97        	blt	a11, a9, 42010eed <_vfiprintf_r+0x12b1>
42010eeb:	4a2c      	movi.n	a10, 36
42010eed:	10c192        	addi	a9, a1, 16
42010ef0:	02d992        	addmi	a9, a9, 0x200
42010ef3:	102992        	l32i	a9, a9, 64
42010ef6:	9661a2        	s32i	a10, a1, 0x258
42010ef9:	99aa      	add.n	a9, a9, a10
42010efb:	fcc992        	addi	a9, a9, -4
42010efe:	0948      	l32i.n	a4, a9, 0
42010f00:	b08810        	addx8	a8, a8, a1
42010f03:	4849      	s32i.n	a4, a8, 16
42010f05:	744040        	extui	a4, a4, 0, 8
42010f08:	000986        	j	42010f32 <_vfiprintf_r+0x12f6>
42010f0b:	126ea2        	s32i	a10, a14, 72
42010f0e:	881c      	movi.n	a8, 24
42010f10:	0528a7        	blt	a8, a10, 42010f19 <_vfiprintf_r+0x12dd>
42010f13:	112e82        	l32i	a8, a14, 68
42010f16:	000406        	j	42010f2a <_vfiprintf_r+0x12ee>
42010f19:	012897        	blt	a8, a9, 42010f1e <_vfiprintf_r+0x12e2>
42010f1c:	4a2c      	movi.n	a10, 36
42010f1e:	10c182        	addi	a8, a1, 16
42010f21:	02d882        	addmi	a8, a8, 0x200
42010f24:	102882        	l32i	a8, a8, 64
42010f27:	9661a2        	s32i	a10, a1, 0x258
42010f2a:	88aa      	add.n	a8, a8, a10
42010f2c:	fcc882        	addi	a8, a8, -4
42010f2f:	000842        	l8ui	a4, a8, 0
42010f32:	020c      	movi.n	a2, 0
42010f34:	180c      	movi.n	a8, 1
42010f36:	00f1c6        	j	42011301 <_vfiprintf_r+0x16c5>
42010f39:	f4ac      	beqz.n	a4, 42010f6c <_vfiprintf_r+0x1330>
42010f3b:	0aa687        	bge	a6, a8, 42010f49 <_vfiprintf_r+0x130d>
42010f3e:	b0e6e0        	addx8	a14, a6, a14
42010f41:	0e48      	l32i.n	a4, a14, 0
42010f43:	0007c6        	j	42010f66 <_vfiprintf_r+0x132a>
42010f46:	000000        	ill
42010f49:	30a282        	movi	a8, 0x230
42010f4c:	8e8a      	add.n	a8, a14, a8
42010f4e:	34a2d2        	movi	a13, 0x234
42010f51:	40a2c2        	movi	a12, 0x240
42010f54:	0189      	s32i.n	a8, a1, 0
42010f56:	01def2        	addmi	a15, a14, 0x100
42010f59:	deda      	add.n	a13, a14, a13
42010f5b:	ceca      	add.n	a12, a14, a12
42010f5d:	07bd      	mov.n	a11, a7
42010f5f:	06ad      	mov.n	a10, a6
42010f61:	fe7e65        	call8	4200f748 <get_arg$isra$0>
42010f64:	0a48      	l32i.n	a4, a10, 0
42010f66:	057d      	mov.n	a7, a5
42010f68:	fff186        	j	42010f32 <_vfiprintf_r+0x12f6>
42010f6b:	751b00        	extui	a1, a0, 27, 8
42010f6e:	07a587        	bge	a5, a8, 42010f79 <_vfiprintf_r+0x133d>
42010f71:	b0e6e0        	addx8	a14, a6, a14
42010f74:	0e48      	l32i.n	a4, a14, 0
42010f76:	ffee06        	j	42010f32 <_vfiprintf_r+0x12f6>
42010f79:	922e92        	l32i	a9, a14, 0x248
42010f7c:	fb1c      	movi.n	a11, 31
42010f7e:	02dee2        	addmi	a14, a14, 0x200
42010f81:	a94b      	addi.n	a10, a9, 4
42010f83:	322b87        	blt	a11, a8, 42010fb9 <_vfiprintf_r+0x137d>
42010f86:	b81b      	addi.n	a11, a8, 1
42010f88:	9161b2        	s32i	a11, a1, 0x244
42010f8b:	126ea2        	s32i	a10, a14, 72
42010f8e:	8b1c      	movi.n	a11, 24
42010f90:	052ba7        	blt	a11, a10, 42010f99 <_vfiprintf_r+0x135d>
42010f93:	112e92        	l32i	a9, a14, 68
42010f96:	000406        	j	42010faa <_vfiprintf_r+0x136e>
42010f99:	012b97        	blt	a11, a9, 42010f9e <_vfiprintf_r+0x1362>
42010f9c:	4a2c      	movi.n	a10, 36
42010f9e:	10c192        	addi	a9, a1, 16
42010fa1:	02d992        	addmi	a9, a9, 0x200
42010fa4:	102992        	l32i	a9, a9, 64
42010fa7:	9661a2        	s32i	a10, a1, 0x258
42010faa:	99aa      	add.n	a9, a9, a10
42010fac:	fcc992        	addi	a9, a9, -4
42010faf:	0948      	l32i.n	a4, a9, 0
42010fb1:	b08810        	addx8	a8, a8, a1
42010fb4:	4849      	s32i.n	a4, a8, 16
42010fb6:	ffde06        	j	42010f32 <_vfiprintf_r+0x12f6>
42010fb9:	126ea2        	s32i	a10, a14, 72
42010fbc:	881c      	movi.n	a8, 24
42010fbe:	0628a7        	blt	a8, a10, 42010fc8 <_vfiprintf_r+0x138c>
42010fc1:	112e82        	l32i	a8, a14, 68
42010fc4:	000446        	j	42010fd9 <_vfiprintf_r+0x139d>
42010fc7:	289700        	lsi	f0, a7, 160
42010fca:	4a2c01        	l32r	a0, 41fe387c <_coredump_iram_end+0x1c6187c>
42010fcd:	10c182        	addi	a8, a1, 16
42010fd0:	02d882        	addmi	a8, a8, 0x200
42010fd3:	102882        	l32i	a8, a8, 64
42010fd6:	9661a2        	s32i	a10, a1, 0x258
42010fd9:	88aa      	add.n	a8, a8, a10
42010fdb:	fcc882        	addi	a8, a8, -4
42010fde:	0848      	l32i.n	a4, a8, 0
42010fe0:	ffd386        	j	42010f32 <_vfiprintf_r+0x12f6>
42010fe3:	9c8100        	lsi	f0, a1, 0x270
42010fe6:	bf          	.byte	0xbf
42010fe7:	a16182        	s32i	a8, a1, 0x284
42010fea:	10c1e2        	addi	a14, a1, 16
42010fed:	912182        	l32i	a8, a1, 0x244
42010ff0:	02e357        	bbsi	a3, 5, 42010ff6 <_vfiprintf_r+0x13ba>
42010ff3:	002f86        	j	420110b5 <_vfiprintf_r+0x1479>
42010ff6:	f4ac      	beqz.n	a4, 42011029 <_vfiprintf_r+0x13ed>
42010ff8:	09a687        	bge	a6, a8, 42011005 <_vfiprintf_r+0x13c9>
42010ffb:	b0e6e0        	addx8	a14, a6, a14
42010ffe:	0e48      	l32i.n	a4, a14, 0
42011000:	1e28      	l32i.n	a2, a14, 4
42011002:	000786        	j	42011024 <_vfiprintf_r+0x13e8>
42011005:	30a282        	movi	a8, 0x230
42011008:	8e8a      	add.n	a8, a14, a8
4201100a:	34a2d2        	movi	a13, 0x234
4201100d:	40a2c2        	movi	a12, 0x240
42011010:	0189      	s32i.n	a8, a1, 0
42011012:	01def2        	addmi	a15, a14, 0x100
42011015:	deda      	add.n	a13, a14, a13
42011017:	ceca      	add.n	a12, a14, a12
42011019:	07bd      	mov.n	a11, a7
4201101b:	06ad      	mov.n	a10, a6
4201101d:	fe72a5        	call8	4200f748 <get_arg$isra$0>
42011020:	0a48      	l32i.n	a4, a10, 0
42011022:	1a28      	l32i.n	a2, a10, 4
42011024:	057d      	mov.n	a7, a5
42011026:	00ac06        	j	420112da <_vfiprintf_r+0x169e>
42011029:	751b      	addi.n	a7, a5, 1
4201102b:	09a587        	bge	a5, a8, 42011038 <_vfiprintf_r+0x13fc>
4201102e:	b0e6e0        	addx8	a14, a6, a14
42011031:	0e48      	l32i.n	a4, a14, 0
42011033:	1e28      	l32i.n	a2, a14, 4
42011035:	00a846        	j	420112da <_vfiprintf_r+0x169e>
42011038:	922e92        	l32i	a9, a14, 0x248
4201103b:	8a7c      	movi.n	a10, -8
4201103d:	997b      	addi.n	a9, a9, 7
4201103f:	1099a0        	and	a9, a9, a10
42011042:	fb1c      	movi.n	a11, 31
42011044:	02dee2        	addmi	a14, a14, 0x200
42011047:	a98b      	addi.n	a10, a9, 8
42011049:	3b2b87        	blt	a11, a8, 42011088 <_vfiprintf_r+0x144c>
4201104c:	b81b      	addi.n	a11, a8, 1
4201104e:	9161b2        	s32i	a11, a1, 0x244
42011051:	126ea2        	s32i	a10, a14, 72
42011054:	8b1c      	movi.n	a11, 24
42011056:	062ba7        	blt	a11, a10, 42011060 <_vfiprintf_r+0x1424>
42011059:	112e92        	l32i	a9, a14, 68
4201105c:	000446        	j	42011071 <_vfiprintf_r+0x1435>
4201105f:	2b9700        	oeq.s	b9, f7, f0
42011062:	8a2c01        	l32r	a0, 41ff3914 <_coredump_iram_end+0x1c71914>
42011065:	10c192        	addi	a9, a1, 16
42011068:	02d992        	addmi	a9, a9, 0x200
4201106b:	102992        	l32i	a9, a9, 64
4201106e:	9661a2        	s32i	a10, a1, 0x258
42011071:	99aa      	add.n	a9, a9, a10
42011073:	f8c992        	addi	a9, a9, -8
42011076:	0948      	l32i.n	a4, a9, 0
42011078:	1928      	l32i.n	a2, a9, 4
4201107a:	10c192        	addi	a9, a1, 16
4201107d:	b08890        	addx8	a8, a8, a9
42011080:	0849      	s32i.n	a4, a8, 0
42011082:	1829      	s32i.n	a2, a8, 4
42011084:	009486        	j	420112da <_vfiprintf_r+0x169e>
42011087:	6ea200        	f64rnd	a10, a2, a0, 2
4201108a:	881c12        	l16ui	a1, a12, 0x110
4201108d:	0728a7        	blt	a8, a10, 42011098 <_vfiprintf_r+0x145c>
42011090:	112e82        	l32i	a8, a14, 68
42011093:	000486        	j	420110a9 <_vfiprintf_r+0x146d>
42011096:	970000        	lsi	f0, a0, 0x25c
42011099:	0128      	l32i.n	a2, a1, 0
4201109b:	8a2c      	movi.n	a10, 40
4201109d:	10c182        	addi	a8, a1, 16
420110a0:	02d882        	addmi	a8, a8, 0x200
420110a3:	102882        	l32i	a8, a8, 64
420110a6:	9661a2        	s32i	a10, a1, 0x258
420110a9:	88aa      	add.n	a8, a8, a10
420110ab:	f8c882        	addi	a8, a8, -8
420110ae:	0848      	l32i.n	a4, a8, 0
420110b0:	1828      	l32i.n	a2, a8, 4
420110b2:	008906        	j	420112da <_vfiprintf_r+0x169e>
420110b5:	146347        	bbci	a3, 4, 420110cd <_vfiprintf_r+0x1491>
420110b8:	148c      	beqz.n	a4, 420110bd <_vfiprintf_r+0x1481>
420110ba:	005e06        	j	42011236 <_vfiprintf_r+0x15fa>
420110bd:	751b      	addi.n	a7, a5, 1
420110bf:	022587        	blt	a5, a8, 420110c5 <_vfiprintf_r+0x1489>
420110c2:	006ac6        	j	42011271 <_vfiprintf_r+0x1635>
420110c5:	b0e6e0        	addx8	a14, a6, a14
420110c8:	0e48      	l32i.n	a4, a14, 0
420110ca:	008286        	j	420112d8 <_vfiprintf_r+0x169c>
420110cd:	02e367        	bbsi	a3, 6, 420110d3 <_vfiprintf_r+0x1497>
420110d0:	002b06        	j	42011180 <_vfiprintf_r+0x1544>
420110d3:	b4ac      	beqz.n	a4, 42011102 <_vfiprintf_r+0x14c6>
420110d5:	08a687        	bge	a6, a8, 420110e1 <_vfiprintf_r+0x14a5>
420110d8:	b0e6e0        	addx8	a14, a6, a14
420110db:	001e42        	l16ui	a4, a14, 0
420110de:	005f06        	j	4201125e <_vfiprintf_r+0x1622>
420110e1:	30a282        	movi	a8, 0x230
420110e4:	8e8a      	add.n	a8, a14, a8
420110e6:	34a2d2        	movi	a13, 0x234
420110e9:	40a2c2        	movi	a12, 0x240
420110ec:	0189      	s32i.n	a8, a1, 0
420110ee:	01def2        	addmi	a15, a14, 0x100
420110f1:	deda      	add.n	a13, a14, a13
420110f3:	ceca      	add.n	a12, a14, a12
420110f5:	07bd      	mov.n	a11, a7
420110f7:	06ad      	mov.n	a10, a6
420110f9:	fe64e5        	call8	4200f748 <get_arg$isra$0>
420110fc:	001a42        	l16ui	a4, a10, 0
420110ff:	0056c6        	j	4201125e <_vfiprintf_r+0x1622>
42011102:	751b      	addi.n	a7, a5, 1
42011104:	08a587        	bge	a5, a8, 42011110 <_vfiprintf_r+0x14d4>
42011107:	b0e6e0        	addx8	a14, a6, a14
4201110a:	001e42        	l16ui	a4, a14, 0
4201110d:	0071c6        	j	420112d8 <_vfiprintf_r+0x169c>
42011110:	922e92        	l32i	a9, a14, 0x248
42011113:	fb1c      	movi.n	a11, 31
42011115:	02dee2        	addmi	a14, a14, 0x200
42011118:	a94b      	addi.n	a10, a9, 4
4201111a:	362b87        	blt	a11, a8, 42011154 <_vfiprintf_r+0x1518>
4201111d:	b81b      	addi.n	a11, a8, 1
4201111f:	9161b2        	s32i	a11, a1, 0x244
42011122:	126ea2        	s32i	a10, a14, 72
42011125:	8b1c      	movi.n	a11, 24
42011127:	052ba7        	blt	a11, a10, 42011130 <_vfiprintf_r+0x14f4>
4201112a:	112e92        	l32i	a9, a14, 68
4201112d:	000406        	j	42011141 <_vfiprintf_r+0x1505>
42011130:	012b97        	blt	a11, a9, 42011135 <_vfiprintf_r+0x14f9>
42011133:	4a2c      	movi.n	a10, 36
42011135:	10c192        	addi	a9, a1, 16
42011138:	02d992        	addmi	a9, a9, 0x200
4201113b:	102992        	l32i	a9, a9, 64
4201113e:	9661a2        	s32i	a10, a1, 0x258
42011141:	99aa      	add.n	a9, a9, a10
42011143:	fcc992        	addi	a9, a9, -4
42011146:	0948      	l32i.n	a4, a9, 0
42011148:	b08810        	addx8	a8, a8, a1
4201114b:	4849      	s32i.n	a4, a8, 16
4201114d:	f44040        	extui	a4, a4, 0, 16
42011150:	006106        	j	420112d8 <_vfiprintf_r+0x169c>
42011153:	6ea200        	f64rnd	a10, a2, a0, 2
42011156:	881c12        	l16ui	a1, a12, 0x110
42011159:	0728a7        	blt	a8, a10, 42011164 <_vfiprintf_r+0x1528>
4201115c:	112e82        	l32i	a8, a14, 68
4201115f:	000486        	j	42011175 <_vfiprintf_r+0x1539>
42011162:	970000        	lsi	f0, a0, 0x25c
42011165:	0128      	l32i.n	a2, a1, 0
42011167:	4a2c      	movi.n	a10, 36
42011169:	10c182        	addi	a8, a1, 16
4201116c:	02d882        	addmi	a8, a8, 0x200
4201116f:	102882        	l32i	a8, a8, 64
42011172:	9661a2        	s32i	a10, a1, 0x258
42011175:	88aa      	add.n	a8, a8, a10
42011177:	fcc882        	addi	a8, a8, -4
4201117a:	001842        	l16ui	a4, a8, 0
4201117d:	0055c6        	j	420112d8 <_vfiprintf_r+0x169c>
42011180:	02e397        	bbsi	a3, 9, 42011186 <_vfiprintf_r+0x154a>
42011183:	002b46        	j	42011234 <_vfiprintf_r+0x15f8>
42011186:	c4ac      	beqz.n	a4, 420111b6 <_vfiprintf_r+0x157a>
42011188:	09a687        	bge	a6, a8, 42011195 <_vfiprintf_r+0x1559>
4201118b:	b0e6e0        	addx8	a14, a6, a14
4201118e:	000e42        	l8ui	a4, a14, 0
42011191:	003246        	j	4201125e <_vfiprintf_r+0x1622>
42011194:	a28200        	muluh	a8, a2, a0
42011197:	8e8a30        	f64iter	a8, a10, a3, 0, 0
4201119a:	34a2d2        	movi	a13, 0x234
4201119d:	40a2c2        	movi	a12, 0x240
420111a0:	0189      	s32i.n	a8, a1, 0
420111a2:	01def2        	addmi	a15, a14, 0x100
420111a5:	deda      	add.n	a13, a14, a13
420111a7:	ceca      	add.n	a12, a14, a12
420111a9:	07bd      	mov.n	a11, a7
420111ab:	06ad      	mov.n	a10, a6
420111ad:	fe59a5        	call8	4200f748 <get_arg$isra$0>
420111b0:	000a42        	l8ui	a4, a10, 0
420111b3:	0029c6        	j	4201125e <_vfiprintf_r+0x1622>
420111b6:	751b      	addi.n	a7, a5, 1
420111b8:	08a587        	bge	a5, a8, 420111c4 <_vfiprintf_r+0x1588>
420111bb:	b0e6e0        	addx8	a14, a6, a14
420111be:	000e42        	l8ui	a4, a14, 0
420111c1:	0044c6        	j	420112d8 <_vfiprintf_r+0x169c>
420111c4:	922e92        	l32i	a9, a14, 0x248
420111c7:	fb1c      	movi.n	a11, 31
420111c9:	02dee2        	addmi	a14, a14, 0x200
420111cc:	a94b      	addi.n	a10, a9, 4
420111ce:	362b87        	blt	a11, a8, 42011208 <_vfiprintf_r+0x15cc>
420111d1:	b81b      	addi.n	a11, a8, 1
420111d3:	9161b2        	s32i	a11, a1, 0x244
420111d6:	126ea2        	s32i	a10, a14, 72
420111d9:	8b1c      	movi.n	a11, 24
420111db:	052ba7        	blt	a11, a10, 420111e4 <_vfiprintf_r+0x15a8>
420111de:	112e92        	l32i	a9, a14, 68
420111e1:	000406        	j	420111f5 <_vfiprintf_r+0x15b9>
420111e4:	012b97        	blt	a11, a9, 420111e9 <_vfiprintf_r+0x15ad>
420111e7:	4a2c      	movi.n	a10, 36
420111e9:	10c192        	addi	a9, a1, 16
420111ec:	02d992        	addmi	a9, a9, 0x200
420111ef:	102992        	l32i	a9, a9, 64
420111f2:	9661a2        	s32i	a10, a1, 0x258
420111f5:	99aa      	add.n	a9, a9, a10
420111f7:	fcc992        	addi	a9, a9, -4
420111fa:	0948      	l32i.n	a4, a9, 0
420111fc:	b08810        	addx8	a8, a8, a1
420111ff:	4849      	s32i.n	a4, a8, 16
42011201:	744040        	extui	a4, a4, 0, 8
42011204:	003406        	j	420112d8 <_vfiprintf_r+0x169c>
42011207:	6ea200        	f64rnd	a10, a2, a0, 2
4201120a:	881c12        	l16ui	a1, a12, 0x110
4201120d:	0728a7        	blt	a8, a10, 42011218 <_vfiprintf_r+0x15dc>
42011210:	112e82        	l32i	a8, a14, 68
42011213:	000486        	j	42011229 <_vfiprintf_r+0x15ed>
42011216:	970000        	lsi	f0, a0, 0x25c
42011219:	0128      	l32i.n	a2, a1, 0
4201121b:	4a2c      	movi.n	a10, 36
4201121d:	10c182        	addi	a8, a1, 16
42011220:	02d882        	addmi	a8, a8, 0x200
42011223:	102882        	l32i	a8, a8, 64
42011226:	9661a2        	s32i	a10, a1, 0x258
42011229:	88aa      	add.n	a8, a8, a10
4201122b:	fcc882        	addi	a8, a8, -4
4201122e:	000842        	l8ui	a4, a8, 0
42011231:	0028c6        	j	420112d8 <_vfiprintf_r+0x169c>
42011234:	c4ac      	beqz.n	a4, 42011264 <_vfiprintf_r+0x1628>
42011236:	07a687        	bge	a6, a8, 42011241 <_vfiprintf_r+0x1605>
42011239:	b0e6e0        	addx8	a14, a6, a14
4201123c:	0e48      	l32i.n	a4, a14, 0
4201123e:	000706        	j	4201125e <_vfiprintf_r+0x1622>
42011241:	30a282        	movi	a8, 0x230
42011244:	8e8a      	add.n	a8, a14, a8
42011246:	34a2d2        	movi	a13, 0x234
42011249:	40a2c2        	movi	a12, 0x240
4201124c:	0189      	s32i.n	a8, a1, 0
4201124e:	01def2        	addmi	a15, a14, 0x100
42011251:	deda      	add.n	a13, a14, a13
42011253:	ceca      	add.n	a12, a14, a12
42011255:	07bd      	mov.n	a11, a7
42011257:	06ad      	mov.n	a10, a6
42011259:	fe4ee5        	call8	4200f748 <get_arg$isra$0>
4201125c:	0a48      	l32i.n	a4, a10, 0
4201125e:	057d      	mov.n	a7, a5
42011260:	001d06        	j	420112d8 <_vfiprintf_r+0x169c>
42011263:	751b00        	extui	a1, a0, 27, 8
42011266:	07a587        	bge	a5, a8, 42011271 <_vfiprintf_r+0x1635>
42011269:	b066e0        	addx8	a6, a6, a14
4201126c:	0648      	l32i.n	a4, a6, 0
4201126e:	001986        	j	420112d8 <_vfiprintf_r+0x169c>
42011271:	922e92        	l32i	a9, a14, 0x248
42011274:	fb1c      	movi.n	a11, 31
42011276:	02dee2        	addmi	a14, a14, 0x200
42011279:	a94b      	addi.n	a10, a9, 4
4201127b:	322b87        	blt	a11, a8, 420112b1 <_vfiprintf_r+0x1675>
4201127e:	b81b      	addi.n	a11, a8, 1
42011280:	9161b2        	s32i	a11, a1, 0x244
42011283:	126ea2        	s32i	a10, a14, 72
42011286:	8b1c      	movi.n	a11, 24
42011288:	052ba7        	blt	a11, a10, 42011291 <_vfiprintf_r+0x1655>
4201128b:	112e92        	l32i	a9, a14, 68
4201128e:	000406        	j	420112a2 <_vfiprintf_r+0x1666>
42011291:	012b97        	blt	a11, a9, 42011296 <_vfiprintf_r+0x165a>
42011294:	4a2c      	movi.n	a10, 36
42011296:	10c192        	addi	a9, a1, 16
42011299:	02d992        	addmi	a9, a9, 0x200
4201129c:	102992        	l32i	a9, a9, 64
4201129f:	9661a2        	s32i	a10, a1, 0x258
420112a2:	99aa      	add.n	a9, a9, a10
420112a4:	fcc992        	addi	a9, a9, -4
420112a7:	0948      	l32i.n	a4, a9, 0
420112a9:	b08810        	addx8	a8, a8, a1
420112ac:	4849      	s32i.n	a4, a8, 16
420112ae:	000986        	j	420112d8 <_vfiprintf_r+0x169c>
420112b1:	126ea2        	s32i	a10, a14, 72
420112b4:	881c      	movi.n	a8, 24
420112b6:	0628a7        	blt	a8, a10, 420112c0 <_vfiprintf_r+0x1684>
420112b9:	112e82        	l32i	a8, a14, 68
420112bc:	000446        	j	420112d1 <_vfiprintf_r+0x1695>
420112bf:	289700        	lsi	f0, a7, 160
420112c2:	4a2c01        	l32r	a0, 41fe3b74 <_coredump_iram_end+0x1c61b74>
420112c5:	10c182        	addi	a8, a1, 16
420112c8:	02d882        	addmi	a8, a8, 0x200
420112cb:	102882        	l32i	a8, a8, 64
420112ce:	9661a2        	s32i	a10, a1, 0x258
420112d1:	88aa      	add.n	a8, a8, a10
420112d3:	fcc882        	addi	a8, a8, -4
420112d6:	0848      	l32i.n	a4, a8, 0
420112d8:	020c      	movi.n	a2, 0
420112da:	208420        	or	a8, a4, a2
420112dd:	889c      	beqz.n	a8, 420112f9 <_vfiprintf_r+0x16bd>
420112df:	166307        	bbci	a3, 0, 420112f9 <_vfiprintf_r+0x16bd>
420112e2:	10c182        	addi	a8, a1, 16
420112e5:	02d882        	addmi	a8, a8, 0x200
420112e8:	093c      	movi.n	a9, 48
420112ea:	384892        	s8i	a9, a8, 56
420112ed:	9e2192        	l32i	a9, a1, 0x278
420112f0:	394892        	s8i	a9, a8, 57
420112f3:	02a082        	movi	a8, 2
420112f6:	203380        	or	a3, a3, a8
420112f9:	ffab82        	movi	a8, 0xfffffbff
420112fc:	103380        	and	a3, a3, a8
420112ff:	280c      	movi.n	a8, 2
42011301:	090c      	movi.n	a9, 0
42011303:	10c1a2        	addi	a10, a1, 16
42011306:	02daa2        	addmi	a10, a10, 0x200
42011309:	3a4a92        	s8i	a9, a10, 58
4201130c:	9a2192        	l32i	a9, a1, 0x268
4201130f:	01d996        	bltz	a9, 42011330 <_vfiprintf_r+0x16f4>
42011312:	20a330        	or	a10, a3, a3
42011315:	7faf92        	movi	a9, -129
42011318:	103390        	and	a3, a3, a9
4201131b:	1b0c      	movi.n	a11, 1
4201131d:	209420        	or	a9, a4, a2
42011320:	83b990        	moveqz	a11, a9, a9
42011323:	99cc      	bnez.n	a9, 42011330 <_vfiprintf_r+0x16f4>
42011325:	9a21c2        	l32i	a12, a1, 0x268
42011328:	190c      	movi.n	a9, 1
4201132a:	839bc0        	moveqz	a9, a11, a12
4201132d:	12f916        	beqz	a9, 42011460 <_vfiprintf_r+0x1824>
42011330:	421826        	beqi	a8, 1, 42011376 <_vfiprintf_r+0x173a>
42011333:	e4a162        	movi	a6, 0x1e4
42011336:	022866        	bnei	a8, 2, 4201133c <_vfiprintf_r+0x1700>
42011339:	003ec6        	j	42011438 <_vfiprintf_r+0x17fc>
4201133c:	10c182        	addi	a8, a1, 16
4201133f:	686a      	add.n	a6, a8, a6
42011341:	248040        	extui	a8, a4, 0, 3
42011344:	069d      	mov.n	a9, a6
42011346:	404300        	ssai	3
42011349:	814240        	src	a4, a2, a4
4201134c:	660b      	addi.n	a6, a6, -1
4201134e:	30c882        	addi	a8, a8, 48
42011351:	412320        	srli	a2, a2, 3
42011354:	004682        	s8i	a8, a6, 0
42011357:	20a420        	or	a10, a4, a2
4201135a:	fe3a56        	bnez	a10, 42011341 <_vfiprintf_r+0x1705>
4201135d:	d0c882        	addi	a8, a8, -48
42011360:	130816        	beqz	a8, 42011494 <_vfiprintf_r+0x1858>
42011363:	02e307        	bbsi	a3, 0, 42011369 <_vfiprintf_r+0x172d>
42011366:	004a86        	j	42011494 <_vfiprintf_r+0x1858>
42011369:	660b      	addi.n	a6, a6, -1
4201136b:	083c      	movi.n	a8, 48
4201136d:	004682        	s8i	a8, a6, 0
42011370:	fec962        	addi	a6, a9, -2
42011373:	004746        	j	42011494 <_vfiprintf_r+0x1858>
42011376:	72dc      	bnez.n	a2, 42011391 <_vfiprintf_r+0x1755>
42011378:	980c      	movi.n	a8, 9
4201137a:	133847        	bltu	a8, a4, 42011391 <_vfiprintf_r+0x1755>
4201137d:	10c162        	addi	a6, a1, 16
42011380:	01d682        	addmi	a8, a6, 0x100
42011383:	30c442        	addi	a4, a4, 48
42011386:	e34842        	s8i	a4, a8, 227
42011389:	e3a182        	movi	a8, 0x1e3
4201138c:	004086        	j	42011492 <_vfiprintf_r+0x1856>
4201138f:	620000        	lsi	f0, a0, 0x188
42011392:	52f4a1        	l32r	a10, 41fe5f64 <_coredump_iram_end+0x1c63f64>
42011395:	0c00a4        	lsi	f10, a0, 48
42011398:	0e          	.byte	0xe
42011399:	616a      	add.n	a6, a1, a6
4201139b:	105350        	and	a5, a3, a5
4201139e:	9e61e2        	s32i	a14, a1, 0x278
420113a1:	ac0c      	movi.n	a12, 10
420113a3:	0d0c      	movi.n	a13, 0
420113a5:	04ad      	mov.n	a10, a4
420113a7:	20b220        	or	a11, a2, a2
420113aa:	bea581        	l32r	a8, 42000e40 <_stext+0xe20> (40002574 <__umoddi3>)
420113ad:	0008e0        	callx8	a8
420113b0:	9e21e2        	l32i	a14, a1, 0x278
420113b3:	660b      	addi.n	a6, a6, -1
420113b5:	30caa2        	addi	a10, a10, 48
420113b8:	0046a2        	s8i	a10, a6, 0
420113bb:	ee1b      	addi.n	a14, a14, 1
420113bd:	053516        	beqz	a5, 42011414 <_vfiprintf_r+0x17d8>
420113c0:	9f2182        	l32i	a8, a1, 0x27c
420113c3:	000892        	l8ui	a9, a8, 0
420113c6:	01af82        	movi	a8, -255
420113c9:	808980        	add	a8, a9, a8
420113cc:	044816        	beqz	a8, 42011414 <_vfiprintf_r+0x17d8>
420113cf:	4199e7        	bne	a9, a14, 42011414 <_vfiprintf_r+0x17d8>
420113d2:	72cc      	bnez.n	a2, 420113dd <_vfiprintf_r+0x17a1>
420113d4:	09a082        	movi	a8, 9
420113d7:	023847        	bltu	a8, a4, 420113dd <_vfiprintf_r+0x17a1>
420113da:	002d86        	j	42011494 <_vfiprintf_r+0x1858>
420113dd:	a02182        	l32i	a8, a1, 0x280
420113e0:	a221b2        	l32i	a11, a1, 0x288
420113e3:	c06680        	sub	a6, a6, a8
420113e6:	08cd      	mov.n	a12, a8
420113e8:	06ad      	mov.n	a10, a6
420113ea:	be1981        	l32r	a8, 42000c50 <_stext+0xc30> (40001224 <strncpy>)
420113ed:	0008e0        	callx8	a8
420113f0:	9f2182        	l32i	a8, a1, 0x27c
420113f3:	010882        	l8ui	a8, a8, 1
420113f6:	688c      	beqz.n	a8, 42011400 <_vfiprintf_r+0x17c4>
420113f8:	9f2182        	l32i	a8, a1, 0x27c
420113fb:	881b      	addi.n	a8, a8, 1
420113fd:	9f6182        	s32i	a8, a1, 0x27c
42011400:	ac0c      	movi.n	a12, 10
42011402:	0d0c      	movi.n	a13, 0
42011404:	04ad      	mov.n	a10, a4
42011406:	02bd      	mov.n	a11, a2
42011408:	bb5681        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4201140b:	0008e0        	callx8	a8
4201140e:	0e0c      	movi.n	a14, 0
42011410:	000706        	j	42011430 <_vfiprintf_r+0x17f4>
42011413:	61e200        	lsi	f0, a2, 0x184
42011416:	9e          	.byte	0x9e
42011417:	ac0c      	movi.n	a12, 10
42011419:	0d0c      	movi.n	a13, 0
4201141b:	04ad      	mov.n	a10, a4
4201141d:	02bd      	mov.n	a11, a2
4201141f:	bb5081        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
42011422:	0008e0        	callx8	a8
42011425:	9e21e2        	l32i	a14, a1, 0x278
42011428:	42cc      	bnez.n	a2, 42011430 <_vfiprintf_r+0x17f4>
4201142a:	09a082        	movi	a8, 9
4201142d:	63b847        	bgeu	a8, a4, 42011494 <_vfiprintf_r+0x1858>
42011430:	0a4d      	mov.n	a4, a10
42011432:	0b2d      	mov.n	a2, a11
42011434:	ffd986        	j	4201139e <_vfiprintf_r+0x1762>
42011437:	c18200        	mul16u	a8, a2, a0
4201143a:	686a10        	lsi	f1, a10, 0x1a0
4201143d:	a12192        	l32i	a9, a1, 0x284
42011440:	348040        	extui	a8, a4, 0, 4
42011443:	898a      	add.n	a8, a9, a8
42011445:	000882        	l8ui	a8, a8, 0
42011448:	404400        	ssai	4
4201144b:	814240        	src	a4, a2, a4
4201144e:	660b      	addi.n	a6, a6, -1
42011450:	412420        	srli	a2, a2, 4
42011453:	004682        	s8i	a8, a6, 0
42011456:	208420        	or	a8, a4, a2
42011459:	fe0856        	bnez	a8, 4201143d <_vfiprintf_r+0x1801>
4201145c:	000d06        	j	42011494 <_vfiprintf_r+0x1858>
4201145f:	090c00        	l32e	a0, a12, -64
42011462:	9a6192        	s32i	a9, a1, 0x268
42011465:	e4a162        	movi	a6, 0x1e4
42011468:	10c192        	addi	a9, a1, 16
4201146b:	696a      	add.n	a6, a9, a6
4201146d:	38ec      	bnez.n	a8, 42011494 <_vfiprintf_r+0x1858>
4201146f:	0480a0        	extui	a8, a10, 0, 1
42011472:	9a6182        	s32i	a8, a1, 0x268
42011475:	9a2182        	l32i	a8, a1, 0x268
42011478:	e4a162        	movi	a6, 0x1e4
4201147b:	696a      	add.n	a6, a9, a6
4201147d:	389c      	beqz.n	a8, 42011494 <_vfiprintf_r+0x1858>
4201147f:	01d982        	addmi	a8, a9, 0x100
42011482:	093c      	movi.n	a9, 48
42011484:	e34892        	s8i	a9, a8, 227
42011487:	080c      	movi.n	a8, 0
42011489:	9a6182        	s32i	a8, a1, 0x268
4201148c:	e3a162        	movi	a6, 0x1e3
4201148f:	10c182        	addi	a8, a1, 16
42011492:	686a      	add.n	a6, a8, a6
42011494:	a42182        	l32i	a8, a1, 0x290
42011497:	9a2152        	l32i	a5, a1, 0x268
4201149a:	c08860        	sub	a8, a8, a6
4201149d:	9a6182        	s32i	a8, a1, 0x268
420114a0:	0009c6        	j	420114cb <_vfiprintf_r+0x188f>
420114a3:	9e2182        	l32i	a8, a1, 0x278
420114a6:	392816        	beqz	a8, 4201183c <_vfiprintf_r+0x1c00>
420114a9:	9e2192        	l32i	a9, a1, 0x278
420114ac:	10c162        	addi	a6, a1, 16
420114af:	01d682        	addmi	a8, a6, 0x100
420114b2:	804892        	s8i	a9, a8, 128
420114b5:	02d682        	addmi	a8, a6, 0x200
420114b8:	090c      	movi.n	a9, 0
420114ba:	3a4892        	s8i	a9, a8, 58
420114bd:	057d      	mov.n	a7, a5
420114bf:	180c      	movi.n	a8, 1
420114c1:	9a6182        	s32i	a8, a1, 0x268
420114c4:	80a182        	movi	a8, 0x180
420114c7:	050c      	movi.n	a5, 0
420114c9:	668a      	add.n	a6, a6, a8
420114cb:	9a2182        	l32i	a8, a1, 0x268
420114ce:	534580        	max	a4, a5, a8
420114d1:	10c182        	addi	a8, a1, 16
420114d4:	02d882        	addmi	a8, a8, 0x200
420114d7:	3a0882        	l8ui	a8, a8, 58
420114da:	088c      	beqz.n	a8, 420114de <_vfiprintf_r+0x18a2>
420114dc:	441b      	addi.n	a4, a4, 1
420114de:	220c      	movi.n	a2, 2
420114e0:	108320        	and	a8, a3, a2
420114e3:	9e6182        	s32i	a8, a1, 0x278
420114e6:	002816        	beqz	a8, 420114ec <_vfiprintf_r+0x18b0>
420114e9:	02c442        	addi	a4, a4, 2
420114ec:	84a082        	movi	a8, 132
420114ef:	108380        	and	a8, a3, a8
420114f2:	a36182        	s32i	a8, a1, 0x28c
420114f5:	084856        	bnez	a8, 4201157d <_vfiprintf_r+0x1941>
420114f8:	9c2182        	l32i	a8, a1, 0x270
420114fb:	10c122        	addi	a2, a1, 16
420114fe:	c08840        	sub	a8, a8, a4
42011501:	3218e6        	bgei	a8, 1, 42011537 <_vfiprintf_r+0x18fb>
42011504:	001d46        	j	4201157d <_vfiprintf_r+0x1941>
42011507:	ccc200        	lsi	f0, a2, 0x330
4201150a:	1df910        	lsi	f1, a9, 116
4201150d:	bac9      	s32i.n	a12, a10, 44
4201150f:	aa99      	s32i.n	a9, a10, 40
42011511:	1c89a6        	blti	a9, 8, 42011531 <_vfiprintf_r+0x18f5>
42011514:	24a2c2        	movi	a12, 0x224
42011517:	9821b2        	l32i	a11, a1, 0x260
4201151a:	9b21a2        	l32i	a10, a1, 0x26c
4201151d:	c2ca      	add.n	a12, a2, a12
4201151f:	976182        	s32i	a8, a1, 0x25c
42011522:	fe6f65        	call8	4200fc18 <__sprint_r>
42011525:	338a56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
42011528:	e4a1b2        	movi	a11, 0x1e4
4201152b:	972182        	l32i	a8, a1, 0x25c
4201152e:	80b2b0        	add	a11, a2, a11
42011531:	f0c882        	addi	a8, a8, -16
42011534:	9761b2        	s32i	a11, a1, 0x25c
42011537:	be4ae1        	l32r	a14, 42000e60 <_stext+0xe40> (3c029d50 <blanks$1>)
4201153a:	9721d2        	l32i	a13, a1, 0x25c
4201153d:	9721b2        	l32i	a11, a1, 0x25c
42011540:	8a2292        	l32i	a9, a2, 0x228
42011543:	0f1c      	movi.n	a15, 16
42011545:	0de9      	s32i.n	a14, a13, 0
42011547:	02d2a2        	addmi	a10, a2, 0x200
4201154a:	991b      	addi.n	a9, a9, 1
4201154c:	bb8b      	addi.n	a11, a11, 8
4201154e:	bac8      	l32i.n	a12, a10, 44
42011550:	b42f87        	blt	a15, a8, 42011508 <_vfiprintf_r+0x18cc>
42011553:	1d89      	s32i.n	a8, a13, 4
42011555:	88ca      	add.n	a8, a8, a12
42011557:	ba89      	s32i.n	a8, a10, 44
42011559:	0a6a92        	s32i	a9, a10, 40
4201155c:	9761b2        	s32i	a11, a1, 0x25c
4201155f:	1a89a6        	blti	a9, 8, 4201157d <_vfiprintf_r+0x1941>
42011562:	24a2c2        	movi	a12, 0x224
42011565:	9821b2        	l32i	a11, a1, 0x260
42011568:	9b21a2        	l32i	a10, a1, 0x26c
4201156b:	80c2c0        	add	a12, a2, a12
4201156e:	fe6aa5        	call8	4200fc18 <__sprint_r>
42011571:	2eca56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
42011574:	e4a182        	movi	a8, 0x1e4
42011577:	808280        	add	a8, a2, a8
4201157a:	976182        	s32i	a8, a1, 0x25c
4201157d:	10c182        	addi	a8, a1, 16
42011580:	02d8a2        	addmi	a10, a8, 0x200
42011583:	3a0a82        	l8ui	a8, a10, 58
42011586:	042816        	beqz	a8, 420115cc <_vfiprintf_r+0x1990>
42011589:	10c1c2        	addi	a12, a1, 16
4201158c:	3aa292        	movi	a9, 0x23a
4201158f:	9c9a      	add.n	a9, a12, a9
42011591:	ba88      	l32i.n	a8, a10, 44
42011593:	9721c2        	l32i	a12, a1, 0x25c
42011596:	aab8      	l32i.n	a11, a10, 40
42011598:	881b      	addi.n	a8, a8, 1
4201159a:	bb1b      	addi.n	a11, a11, 1
4201159c:	0c99      	s32i.n	a9, a12, 0
4201159e:	190c      	movi.n	a9, 1
420115a0:	ba89      	s32i.n	a8, a10, 44
420115a2:	1c99      	s32i.n	a9, a12, 4
420115a4:	aab9      	s32i.n	a11, a10, 40
420115a6:	8c8b      	addi.n	a8, a12, 8
420115a8:	1d8ba6        	blti	a11, 8, 420115c9 <_vfiprintf_r+0x198d>
420115ab:	24a2c2        	movi	a12, 0x224
420115ae:	10c182        	addi	a8, a1, 16
420115b1:	9821b2        	l32i	a11, a1, 0x260
420115b4:	9b21a2        	l32i	a10, a1, 0x26c
420115b7:	80c8c0        	add	a12, a8, a12
420115ba:	fe65e5        	call8	4200fc18 <__sprint_r>
420115bd:	2a0a56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
420115c0:	e4a182        	movi	a8, 0x1e4
420115c3:	10c192        	addi	a9, a1, 16
420115c6:	808980        	add	a8, a9, a8
420115c9:	976182        	s32i	a8, a1, 0x25c
420115cc:	9e2182        	l32i	a8, a1, 0x278
420115cf:	049816        	beqz	a8, 4201161c <_vfiprintf_r+0x19e0>
420115d2:	10c182        	addi	a8, a1, 16
420115d5:	10c1c2        	addi	a12, a1, 16
420115d8:	38a292        	movi	a9, 0x238
420115db:	02d8b2        	addmi	a11, a8, 0x200
420115de:	9c9a      	add.n	a9, a12, a9
420115e0:	8f2182        	l32i	a8, a1, 0x23c
420115e3:	9721c2        	l32i	a12, a1, 0x25c
420115e6:	aba8      	l32i.n	a10, a11, 40
420115e8:	882b      	addi.n	a8, a8, 2
420115ea:	aa1b      	addi.n	a10, a10, 1
420115ec:	0c99      	s32i.n	a9, a12, 0
420115ee:	290c      	movi.n	a9, 2
420115f0:	bb89      	s32i.n	a8, a11, 44
420115f2:	1c99      	s32i.n	a9, a12, 4
420115f4:	aba9      	s32i.n	a10, a11, 40
420115f6:	8c8b      	addi.n	a8, a12, 8
420115f8:	1d8aa6        	blti	a10, 8, 42011619 <_vfiprintf_r+0x19dd>
420115fb:	24a2c2        	movi	a12, 0x224
420115fe:	10c182        	addi	a8, a1, 16
42011601:	9821b2        	l32i	a11, a1, 0x260
42011604:	9b21a2        	l32i	a10, a1, 0x26c
42011607:	80c8c0        	add	a12, a8, a12
4201160a:	fe60e5        	call8	4200fc18 <__sprint_r>
4201160d:	250a56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
42011610:	e4a182        	movi	a8, 0x1e4
42011613:	10c192        	addi	a9, a1, 16
42011616:	808980        	add	a8, a9, a8
42011619:	976182        	s32i	a8, a1, 0x25c
4201161c:	a32182        	l32i	a8, a1, 0x28c
4201161f:	02e826        	beqi	a8, 128, 42011625 <_vfiprintf_r+0x19e9>
42011622:	002286        	j	420116b0 <_vfiprintf_r+0x1a74>
42011625:	9c2182        	l32i	a8, a1, 0x270
42011628:	10c122        	addi	a2, a1, 16
4201162b:	c0e840        	sub	a14, a8, a4
4201162e:	381ee6        	bgei	a14, 1, 4201166a <_vfiprintf_r+0x1a2e>
42011631:	001ec6        	j	420116b0 <_vfiprintf_r+0x1a74>
42011634:	9721f2        	l32i	a15, a1, 0x25c
42011637:	10cbb2        	addi	a11, a11, 16
4201163a:	0fc9      	s32i.n	a12, a15, 0
4201163c:	1fd9      	s32i.n	a13, a15, 4
4201163e:	0b69b2        	s32i	a11, a9, 44
42011641:	0a6982        	s32i	a8, a9, 40
42011644:	1c88a6        	blti	a8, 8, 42011664 <_vfiprintf_r+0x1a28>
42011647:	24a2c2        	movi	a12, 0x224
4201164a:	9821b2        	l32i	a11, a1, 0x260
4201164d:	9b21a2        	l32i	a10, a1, 0x26c
42011650:	80c2c0        	add	a12, a2, a12
42011653:	9761e2        	s32i	a14, a1, 0x25c
42011656:	fe5c25        	call8	4200fc18 <__sprint_r>
42011659:	204a56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
4201165c:	e4a1a2        	movi	a10, 0x1e4
4201165f:	9721e2        	l32i	a14, a1, 0x25c
42011662:	a2aa      	add.n	a10, a2, a10
42011664:	f0cee2        	addi	a14, a14, -16
42011667:	9761a2        	s32i	a10, a1, 0x25c
4201166a:	9721a2        	l32i	a10, a1, 0x25c
4201166d:	8a2282        	l32i	a8, a2, 0x228
42011670:	0d1c      	movi.n	a13, 16
42011672:	02d292        	addmi	a9, a2, 0x200
42011675:	bdfbc1        	l32r	a12, 42000e64 <_stext+0xe44> (3c029d40 <zeroes$0>)
42011678:	881b      	addi.n	a8, a8, 1
4201167a:	aa8b      	addi.n	a10, a10, 8
4201167c:	b9b8      	l32i.n	a11, a9, 44
4201167e:	b22de7        	blt	a13, a14, 42011634 <_vfiprintf_r+0x19f8>
42011681:	9721d2        	l32i	a13, a1, 0x25c
42011684:	beba      	add.n	a11, a14, a11
42011686:	0dc9      	s32i.n	a12, a13, 0
42011688:	1de9      	s32i.n	a14, a13, 4
4201168a:	0b69b2        	s32i	a11, a9, 44
4201168d:	0a6982        	s32i	a8, a9, 40
42011690:	9761a2        	s32i	a10, a1, 0x25c
42011693:	1988a6        	blti	a8, 8, 420116b0 <_vfiprintf_r+0x1a74>
42011696:	24a2c2        	movi	a12, 0x224
42011699:	9821b2        	l32i	a11, a1, 0x260
4201169c:	9b21a2        	l32i	a10, a1, 0x26c
4201169f:	80c2c0        	add	a12, a2, a12
420116a2:	fe5765        	call8	4200fc18 <__sprint_r>
420116a5:	1b8a56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
420116a8:	e4a182        	movi	a8, 0x1e4
420116ab:	828a      	add.n	a8, a2, a8
420116ad:	976182        	s32i	a8, a1, 0x25c
420116b0:	9a2182        	l32i	a8, a1, 0x268
420116b3:	c05580        	sub	a5, a5, a8
420116b6:	0215e6        	bgei	a5, 1, 420116bc <_vfiprintf_r+0x1a80>
420116b9:	002146        	j	42011742 <_vfiprintf_r+0x1b06>
420116bc:	000dc6        	j	420116f7 <_vfiprintf_r+0x1abb>
420116bf:	e20000        	remu	a0, a0, a0
420116c2:	b29721        	l32r	a2, 41ffe120 <_coredump_iram_end+0x1c7c120>
420116c5:	10cb      	addi.n	a1, a0, 12
420116c7:	0ec9      	s32i.n	a12, a14, 0
420116c9:	1ed9      	s32i.n	a13, a14, 4
420116cb:	b9b9      	s32i.n	a11, a9, 44
420116cd:	0a6982        	s32i	a8, a9, 40
420116d0:	1d88a6        	blti	a8, 8, 420116f1 <_vfiprintf_r+0x1ab5>
420116d3:	24a2c2        	movi	a12, 0x224
420116d6:	10c182        	addi	a8, a1, 16
420116d9:	9821b2        	l32i	a11, a1, 0x260
420116dc:	9b21a2        	l32i	a10, a1, 0x26c
420116df:	80c8c0        	add	a12, a8, a12
420116e2:	fe5365        	call8	4200fc18 <__sprint_r>
420116e5:	178a56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
420116e8:	e4a1a2        	movi	a10, 0x1e4
420116eb:	10c182        	addi	a8, a1, 16
420116ee:	80a8a0        	add	a10, a8, a10
420116f1:	f0c552        	addi	a5, a5, -16
420116f4:	9761a2        	s32i	a10, a1, 0x25c
420116f7:	10c182        	addi	a8, a1, 16
420116fa:	02d892        	addmi	a9, a8, 0x200
420116fd:	a988      	l32i.n	a8, a9, 40
420116ff:	9721a2        	l32i	a10, a1, 0x25c
42011702:	0d1c      	movi.n	a13, 16
42011704:	bdd8c1        	l32r	a12, 42000e64 <_stext+0xe44> (3c029d40 <zeroes$0>)
42011707:	881b      	addi.n	a8, a8, 1
42011709:	aa8b      	addi.n	a10, a10, 8
4201170b:	b9b8      	l32i.n	a11, a9, 44
4201170d:	b02d57        	blt	a13, a5, 420116c1 <_vfiprintf_r+0x1a85>
42011710:	9721d2        	l32i	a13, a1, 0x25c
42011713:	a989      	s32i.n	a8, a9, 40
42011715:	1d59      	s32i.n	a5, a13, 4
42011717:	55ba      	add.n	a5, a5, a11
42011719:	0dc9      	s32i.n	a12, a13, 0
4201171b:	b959      	s32i.n	a5, a9, 44
4201171d:	9761a2        	s32i	a10, a1, 0x25c
42011720:	1e88a6        	blti	a8, 8, 42011742 <_vfiprintf_r+0x1b06>
42011723:	24a2c2        	movi	a12, 0x224
42011726:	10c182        	addi	a8, a1, 16
42011729:	9821b2        	l32i	a11, a1, 0x260
4201172c:	9b21a2        	l32i	a10, a1, 0x26c
4201172f:	c8ca      	add.n	a12, a8, a12
42011731:	fe4e65        	call8	4200fc18 <__sprint_r>
42011734:	129a56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
42011737:	e4a182        	movi	a8, 0x1e4
4201173a:	10c192        	addi	a9, a1, 16
4201173d:	898a      	add.n	a8, a9, a8
4201173f:	976182        	s32i	a8, a1, 0x25c
42011742:	9a2192        	l32i	a9, a1, 0x268
42011745:	972182        	l32i	a8, a1, 0x25c
42011748:	9a21a2        	l32i	a10, a1, 0x268
4201174b:	1899      	s32i.n	a9, a8, 4
4201174d:	0869      	s32i.n	a6, a8, 0
4201174f:	10c182        	addi	a8, a1, 16
42011752:	02d892        	addmi	a9, a8, 0x200
42011755:	8f2182        	l32i	a8, a1, 0x23c
42011758:	88aa      	add.n	a8, a8, a10
4201175a:	b989      	s32i.n	a8, a9, 44
4201175c:	a988      	l32i.n	a8, a9, 40
4201175e:	881b      	addi.n	a8, a8, 1
42011760:	a989      	s32i.n	a8, a9, 40
42011762:	0788e6        	bgei	a8, 8, 4201176d <_vfiprintf_r+0x1b31>
42011765:	972182        	l32i	a8, a1, 0x25c
42011768:	888b      	addi.n	a8, a8, 8
4201176a:	0006c6        	j	42011789 <_vfiprintf_r+0x1b4d>
4201176d:	24a2c2        	movi	a12, 0x224
42011770:	10c182        	addi	a8, a1, 16
42011773:	9821b2        	l32i	a11, a1, 0x260
42011776:	9b21a2        	l32i	a10, a1, 0x26c
42011779:	c8ca      	add.n	a12, a8, a12
4201177b:	fe49e5        	call8	4200fc18 <__sprint_r>
4201177e:	0dfa56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
42011781:	e4a182        	movi	a8, 0x1e4
42011784:	10c192        	addi	a9, a1, 16
42011787:	898a      	add.n	a8, a9, a8
42011789:	17e327        	bbsi	a3, 2, 420117a4 <_vfiprintf_r+0x1b68>
4201178c:	9c2182        	l32i	a8, a1, 0x270
4201178f:	534840        	max	a4, a8, a4
42011792:	9d2182        	l32i	a8, a1, 0x274
42011795:	884a      	add.n	a8, a8, a4
42011797:	9d6182        	s32i	a8, a1, 0x274
4201179a:	8f2182        	l32i	a8, a1, 0x23c
4201179d:	06d816        	beqz	a8, 4201180e <_vfiprintf_r+0x1bd2>
420117a0:	001fc6        	j	42011823 <_vfiprintf_r+0x1be7>
420117a3:	219200        	srai	a9, a0, 2
420117a6:	409c      	beqz.n	a0, 420117be <_vfiprintf_r+0x1b82>
420117a8:	c069      	s32i.n	a6, a0, 48
420117aa:	de16a6        	blti	a6, 1, 4201178c <_vfiprintf_r+0x1b50>
420117ad:	10c152        	addi	a5, a1, 16
420117b0:	0009c6        	j	420117db <_vfiprintf_r+0x1b9f>
420117b3:	cbb200        	movf.s	f11, f2, b0
420117b6:	18d910        	lsxp	f13, a9, a1
420117b9:	bab9      	s32i.n	a11, a10, 44
420117bb:	aa99      	s32i.n	a9, a10, 40
420117bd:	888b      	addi.n	a8, a8, 8
420117bf:	1589a6        	blti	a9, 8, 420117d8 <_vfiprintf_r+0x1b9c>
420117c2:	24a2c2        	movi	a12, 0x224
420117c5:	9821b2        	l32i	a11, a1, 0x260
420117c8:	9b21a2        	l32i	a10, a1, 0x26c
420117cb:	c5ca      	add.n	a12, a5, a12
420117cd:	fe44a5        	call8	4200fc18 <__sprint_r>
420117d0:	08da56        	bnez	a10, 42011861 <_vfiprintf_r+0x1c25>
420117d3:	e4a182        	movi	a8, 0x1e4
420117d6:	858a      	add.n	a8, a5, a8
420117d8:	f0c662        	addi	a6, a6, -16
420117db:	bda1c1        	l32r	a12, 42000e60 <_stext+0xe40> (3c029d50 <blanks$1>)
420117de:	8a2592        	l32i	a9, a5, 0x228
420117e1:	0d1c      	movi.n	a13, 16
420117e3:	08c9      	s32i.n	a12, a8, 0
420117e5:	02d5a2        	addmi	a10, a5, 0x200
420117e8:	991b      	addi.n	a9, a9, 1
420117ea:	bab8      	l32i.n	a11, a10, 44
420117ec:	c42d67        	blt	a13, a6, 420117b4 <_vfiprintf_r+0x1b78>
420117ef:	1869      	s32i.n	a6, a8, 4
420117f1:	66ba      	add.n	a6, a6, a11
420117f3:	ba69      	s32i.n	a6, a10, 44
420117f5:	aa99      	s32i.n	a9, a10, 40
420117f7:	9189a6        	blti	a9, 8, 4201178c <_vfiprintf_r+0x1b50>
420117fa:	24a2c2        	movi	a12, 0x224
420117fd:	9821b2        	l32i	a11, a1, 0x260
42011800:	9b21a2        	l32i	a10, a1, 0x26c
42011803:	c5ca      	add.n	a12, a5, a12
42011805:	fe4125        	call8	4200fc18 <__sprint_r>
42011808:	f80a16        	beqz	a10, 4201178c <_vfiprintf_r+0x1b50>
4201180b:	001486        	j	42011861 <_vfiprintf_r+0x1c25>
4201180e:	090c      	movi.n	a9, 0
42011810:	8e6192        	s32i	a9, a1, 0x238
42011813:	e4a182        	movi	a8, 0x1e4
42011816:	10c192        	addi	a9, a1, 16
42011819:	898a      	add.n	a8, a9, a8
4201181b:	075d      	mov.n	a5, a7
4201181d:	976182        	s32i	a8, a1, 0x25c
42011820:	f94d06        	j	4200fd58 <_vfiprintf_r+0x11c>
42011823:	24a2c2        	movi	a12, 0x224
42011826:	10c182        	addi	a8, a1, 16
42011829:	9821b2        	l32i	a11, a1, 0x260
4201182c:	9b21a2        	l32i	a10, a1, 0x26c
4201182f:	c8ca      	add.n	a12, a8, a12
42011831:	fe3e65        	call8	4200fc18 <__sprint_r>
42011834:	fd6a16        	beqz	a10, 4201180e <_vfiprintf_r+0x1bd2>
42011837:	000986        	j	42011861 <_vfiprintf_r+0x1c25>
4201183a:	820000        	mull	a0, a0, a0
4201183d:	728f21        	l32r	a2, 41fee27c <_coredump_iram_end+0x1c6c27c>
42011840:	cc10c1        	l32r	a12, 42004880 <esp_mprot_set_split_addr+0x88> (2c136600 <UserFrameTotalSize+0x2c136500>)
42011843:	0ca8      	l32i.n	a10, a12, 0
42011845:	8208      	l32i.n	a0, a2, 32
42011847:	728a67        	bany	a10, a6, 420118bd <vfiprintf+0x1d>
4201184a:	4602d7        	bnone	a2, a13, 42011894 <_vfiprintf_r+0x1c58>
4201184d:	000004        	lsi	f0, a0, 0
42011850:	24a2c2        	movi	a12, 0x224
42011853:	9821b2        	l32i	a11, a1, 0x260
42011856:	9b21a2        	l32i	a10, a1, 0x26c
42011859:	c7ca      	add.n	a12, a7, a12
4201185b:	fe3be5        	call8	4200fc18 <__sprint_r>
4201185e:	fe2a16        	beqz	a10, 42011844 <_vfiprintf_r+0x1c08>
42011861:	982182        	l32i	a8, a1, 0x260
42011864:	192882        	l32i	a8, a8, 100
42011867:	14e807        	bbsi	a8, 0, 4201187f <_vfiprintf_r+0x1c43>
4201186a:	982182        	l32i	a8, a1, 0x260
4201186d:	061882        	l16ui	a8, a8, 12
42011870:	0be897        	bbsi	a8, 9, 4201187f <_vfiprintf_r+0x1c43>
42011873:	982182        	l32i	a8, a1, 0x260
42011876:	1628a2        	l32i	a10, a8, 88
42011879:	bd3481        	l32r	a8, 42000d4c <_stext+0xd2c> (40376b68 <__retarget_lock_release_recursive>)
4201187c:	0008e0        	callx8	a8
4201187f:	982182        	l32i	a8, a1, 0x260
42011882:	061882        	l16ui	a8, a8, 12
42011885:	0f6867        	bbci	a8, 6, 42011898 <_vfiprintf_r+0x1c5c>
42011888:	f90746        	j	4200fca9 <_vfiprintf_r+0x6d>
4201188b:	9a2192        	l32i	a9, a1, 0x268
4201188e:	03ad      	mov.n	a10, a3
42011890:	180c      	movi.n	a8, 1
42011892:	a7f9d6        	bgez	a9, 42011315 <_vfiprintf_r+0x16d9>
42011895:	feb746        	j	42011376 <_vfiprintf_r+0x173a>
42011898:	9d2122        	l32i	a2, a1, 0x274
4201189b:	f01d      	retw.n
4201189d:	000000        	ill

420118a0 <vfiprintf>:
420118a0:	006136        	entry	a1, 48
420118a3:	0149      	s32i.n	a4, a1, 0
420118a5:	1159      	s32i.n	a5, a1, 4
420118a7:	026162        	s32i	a6, a1, 8
420118aa:	bba981        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
420118ad:	0008e0        	callx8	a8
420118b0:	01d8      	l32i.n	a13, a1, 0
420118b2:	11e8      	l32i.n	a14, a1, 4
420118b4:	21f8      	l32i.n	a15, a1, 8
420118b6:	02bd      	mov.n	a11, a2
420118b8:	03cd      	mov.n	a12, a3
420118ba:	fe3825        	call8	4200fc3c <_vfiprintf_r>
420118bd:	0a2d      	mov.n	a2, a10
420118bf:	f01d      	retw.n
420118c1:	000000        	ill

420118c4 <__sbprintf>:
420118c4:	024136        	entry	a1, 0x120
420118c7:	078d      	mov.n	a8, a7
420118c9:	027d      	mov.n	a7, a2
420118cb:	f0a022        	movi	a2, 240
420118ce:	212a      	add.n	a2, a1, a2
420118d0:	2289      	s32i.n	a8, a2, 8
420118d2:	061382        	l16ui	a8, a3, 12
420118d5:	d97c      	movi.n	a9, -3
420118d7:	108890        	and	a8, a8, a9
420118da:	465182        	s16i	a8, a1, 140
420118dd:	192382        	l32i	a8, a3, 100
420118e0:	1269      	s32i.n	a6, a2, 4
420118e2:	396182        	s32i	a8, a1, 228
420118e5:	071382        	l16ui	a8, a3, 14
420118e8:	80a062        	movi	a6, 128
420118eb:	475182        	s16i	a8, a1, 142
420118ee:	8388      	l32i.n	a8, a3, 32
420118f0:	226162        	s32i	a6, a1, 136
420118f3:	286182        	s32i	a8, a1, 160
420118f6:	a388      	l32i.n	a8, a3, 40
420118f8:	256162        	s32i	a6, a1, 148
420118fb:	616a      	add.n	a6, a1, a6
420118fd:	0259      	s32i.n	a5, a2, 0
420118ff:	2a6182        	s32i	a8, a1, 168
42011902:	58c6a2        	addi	a10, a6, 88
42011905:	080c      	movi.n	a8, 0
42011907:	266182        	s32i	a8, a1, 152
4201190a:	206112        	s32i	a1, a1, 128
4201190d:	246112        	s32i	a1, a1, 144
42011910:	bd1b81        	l32r	a8, 42000d7c <_stext+0xd5c> (40376a90 <__retarget_lock_init_recursive>)
42011913:	0008e0        	callx8	a8
42011916:	02d8      	l32i.n	a13, a2, 0
42011918:	12e8      	l32i.n	a14, a2, 4
4201191a:	22f8      	l32i.n	a15, a2, 8
4201191c:	04cd      	mov.n	a12, a4
4201191e:	06bd      	mov.n	a11, a6
42011920:	07ad      	mov.n	a10, a7
42011922:	fe31a5        	call8	4200fc3c <_vfiprintf_r>
42011925:	0a2d      	mov.n	a2, a10
42011927:	00ea96        	bltz	a10, 42011939 <__sbprintf+0x75>
4201192a:	06bd      	mov.n	a11, a6
4201192c:	07ad      	mov.n	a10, a7
4201192e:	201110        	or	a1, a1, a1
42011931:	f9e1a5        	call8	4200b74c <_fflush_r>
42011934:	f87c      	movi.n	a8, -1
42011936:	9328a0        	movnez	a2, a8, a10
42011939:	461182        	l16ui	a8, a1, 140
4201193c:	094c      	movi.n	a9, 64
4201193e:	080897        	bnone	a8, a9, 4201194a <__sbprintf+0x86>
42011941:	061382        	l16ui	a8, a3, 12
42011944:	208890        	or	a8, a8, a9
42011947:	065382        	s16i	a8, a3, 12
4201194a:	3621a2        	l32i	a10, a1, 216
4201194d:	bd0181        	l32r	a8, 42000d54 <_stext+0xd34> (40376ab4 <__retarget_lock_close_recursive>)
42011950:	0008e0        	callx8	a8
42011953:	f01d      	retw.n
42011955:	000000        	ill

42011958 <__swhatbuf_r>:
42011958:	010136        	entry	a1, 128
4201195b:	0793b2        	l16si	a11, a3, 14
4201195e:	20a220        	or	a10, a2, a2
42011961:	018bd6        	bgez	a11, 4201197d <__swhatbuf_r+0x25>
42011964:	061392        	l16ui	a9, a3, 12
42011967:	080c      	movi.n	a8, 0
42011969:	0589      	s32i.n	a8, a5, 0
4201196b:	049790        	extui	a9, a9, 7, 1
4201196e:	0a4c      	movi.n	a10, 64
42011970:	80a082        	movi	a8, 128
42011973:	938a90        	movnez	a8, a10, a9
42011976:	0489      	s32i.n	a8, a4, 0
42011978:	020c      	movi.n	a2, 0
4201197a:	0010c6        	j	420119c1 <__swhatbuf_r+0x69>
4201197d:	01cd      	mov.n	a12, a1
4201197f:	201110        	or	a1, a1, a1
42011982:	f596e5        	call8	420072f0 <_fstat_r>
42011985:	fdba96        	bltz	a10, 42011964 <__swhatbuf_r+0xc>
42011988:	1188      	l32i.n	a8, a1, 4
4201198a:	348c80        	extui	a8, a8, 12, 4
4201198d:	118840        	slli	a8, a8, 12
42011990:	e0d892        	addmi	a9, a8, 0xffffe000
42011993:	40f990        	nsau	a9, a9
42011996:	419590        	srli	a9, a9, 5
42011999:	0599      	s32i.n	a9, a5, 0
4201199b:	122192        	l32i	a9, a1, 72
4201199e:	1719a6        	blti	a9, 1, 420119b9 <__swhatbuf_r+0x61>
420119a1:	0499      	s32i.n	a9, a4, 0
420119a3:	146392        	s32i	a9, a3, 80
420119a6:	190c      	movi.n	a9, 1
420119a8:	119910        	slli	a9, a9, 15
420119ab:	00a422        	movi	a2, 0x400
420119ae:	0f1897        	beq	a8, a9, 420119c1 <__swhatbuf_r+0x69>
420119b1:	120c      	movi.n	a2, 1
420119b3:	112250        	slli	a2, a2, 11
420119b6:	0001c6        	j	420119c1 <__swhatbuf_r+0x69>
420119b9:	80a082        	movi	a8, 128
420119bc:	0489      	s32i.n	a8, a4, 0
420119be:	fffbc6        	j	420119b1 <__swhatbuf_r+0x59>
420119c1:	f01d      	retw.n
	...

420119c4 <__smakebuf_r>:
420119c4:	006136        	entry	a1, 48
420119c7:	061382        	l16ui	a8, a3, 12
420119ca:	250c      	movi.n	a5, 2
420119cc:	020857        	bnone	a8, a5, 420119d2 <__smakebuf_r+0xe>
420119cf:	000b06        	j	420119ff <__smakebuf_r+0x3b>
420119d2:	01dd      	mov.n	a13, a1
420119d4:	c14b      	addi.n	a12, a1, 4
420119d6:	03bd      	mov.n	a11, a3
420119d8:	20a220        	or	a10, a2, a2
420119db:	fff7e5        	call8	42011958 <__swhatbuf_r>
420119de:	1168      	l32i.n	a6, a1, 4
420119e0:	0a7d      	mov.n	a7, a10
420119e2:	06bd      	mov.n	a11, a6
420119e4:	02ad      	mov.n	a10, a2
420119e6:	bcea81        	l32r	a8, 42000d90 <_stext+0xd70> (4037fef4 <_malloc_r>)
420119e9:	0008e0        	callx8	a8
420119ec:	069382        	l16si	a8, a3, 12
420119ef:	aadc      	bnez.n	a10, 42011a0d <__smakebuf_r+0x49>
420119f1:	54e897        	bbsi	a8, 9, 42011a49 <__smakebuf_r+0x85>
420119f4:	c97c      	movi.n	a9, -4
420119f6:	108890        	and	a8, a8, a9
420119f9:	208850        	or	a8, a8, a5
420119fc:	065382        	s16i	a8, a3, 12
420119ff:	47c382        	addi	a8, a3, 71
42011a02:	0389      	s32i.n	a8, a3, 0
42011a04:	4389      	s32i.n	a8, a3, 16
42011a06:	180c      	movi.n	a8, 1
42011a08:	5389      	s32i.n	a8, a3, 20
42011a0a:	000ec6        	j	42011a49 <__smakebuf_r+0x85>
42011a0d:	80a092        	movi	a9, 128
42011a10:	208890        	or	a8, a8, a9
42011a13:	065382        	s16i	a8, a3, 12
42011a16:	0188      	l32i.n	a8, a1, 0
42011a18:	03a9      	s32i.n	a10, a3, 0
42011a1a:	43a9      	s32i.n	a10, a3, 16
42011a1c:	056362        	s32i	a6, a3, 20
42011a1f:	01d816        	beqz	a8, 42011a40 <__smakebuf_r+0x7c>
42011a22:	0793b2        	l16si	a11, a3, 14
42011a25:	20a220        	or	a10, a2, a2
42011a28:	201110        	or	a1, a1, a1
42011a2b:	03e965        	call8	420158c0 <_getpid_r>
42011a2e:	ea8c      	beqz.n	a10, 42011a40 <__smakebuf_r+0x7c>
42011a30:	061382        	l16ui	a8, a3, 12
42011a33:	c97c      	movi.n	a9, -4
42011a35:	108890        	and	a8, a8, a9
42011a38:	190c      	movi.n	a9, 1
42011a3a:	208890        	or	a8, a8, a9
42011a3d:	065382        	s16i	a8, a3, 12
42011a40:	061382        	l16ui	a8, a3, 12
42011a43:	207780        	or	a7, a7, a8
42011a46:	065372        	s16i	a7, a3, 12
42011a49:	f01d      	retw.n
	...

42011a4c <lflush>:
42011a4c:	004136        	entry	a1, 32
42011a4f:	061392        	l16ui	a9, a3, 12
42011a52:	09a082        	movi	a8, 9
42011a55:	020c      	movi.n	a2, 0
42011a57:	0fc987        	bnall	a9, a8, 42011a6a <lflush+0x1e>
42011a5a:	bb3d81        	l32r	a8, 42000750 <_stext+0x730> (4037c858 <__getreent>)
42011a5d:	0008e0        	callx8	a8
42011a60:	03bd      	mov.n	a11, a3
42011a62:	201110        	or	a1, a1, a1
42011a65:	f9ce65        	call8	4200b74c <_fflush_r>
42011a68:	0a2d      	mov.n	a2, a10
42011a6a:	f01d      	retw.n

42011a6c <__srefill_r>:
42011a6c:	004136        	entry	a1, 32
42011a6f:	b28c      	beqz.n	a2, 42011a7e <__srefill_r+0x12>
42011a71:	a288      	l32i.n	a8, a2, 40
42011a73:	78cc      	bnez.n	a8, 42011a7e <__srefill_r+0x12>
42011a75:	20a220        	or	a10, a2, a2
42011a78:	201110        	or	a1, a1, a1
42011a7b:	f9f3a5        	call8	4200b9b4 <__sinit>
42011a7e:	080c      	movi.n	a8, 0
42011a80:	1389      	s32i.n	a8, a3, 4
42011a82:	069382        	l16si	a8, a3, 12
42011a85:	11e857        	bbsi	a8, 5, 42011a9a <__srefill_r+0x2e>
42011a88:	40e827        	bbsi	a8, 2, 42011acc <__srefill_r+0x60>
42011a8b:	11e847        	bbsi	a8, 4, 42011aa0 <__srefill_r+0x34>
42011a8e:	990c      	movi.n	a9, 9
42011a90:	0299      	s32i.n	a9, a2, 0
42011a92:	094c      	movi.n	a9, 64
42011a94:	208890        	or	a8, a8, a9
42011a97:	065382        	s16i	a8, a3, 12
42011a9a:	f27c      	movi.n	a2, -1
42011a9c:	002ec6        	j	42011b5b <__srefill_r+0xef>
42011a9f:	683700        	lsi	f0, a7, 0x1a0
42011aa2:	bd1c      	movi.n	a13, 27
42011aa4:	02ad03        	lsi	f0, a13, 8
42011aa7:	201110        	or	a1, a1, a1
42011aaa:	f9ca25        	call8	4200b74c <_fflush_r>
42011aad:	fe9a56        	bnez	a10, 42011a9a <__srefill_r+0x2e>
42011ab0:	061382        	l16ui	a8, a3, 12
42011ab3:	797c      	movi.n	a9, -9
42011ab5:	108890        	and	a8, a8, a9
42011ab8:	238880        	sext	a8, a8, 15
42011abb:	23a9      	s32i.n	a10, a3, 8
42011abd:	0663a2        	s32i	a10, a3, 24
42011ac0:	490c      	movi.n	a9, 4
42011ac2:	208890        	or	a8, a8, a9
42011ac5:	065382        	s16i	a8, a3, 12
42011ac8:	000986        	j	42011af2 <__srefill_r+0x86>
42011acb:	d3b800        	movt	a11, a8, b0
42011ace:	0bac      	beqz.n	a11, 42011af2 <__srefill_r+0x86>
42011ad0:	44c382        	addi	a8, a3, 68
42011ad3:	071b87        	beq	a11, a8, 42011ade <__srefill_r+0x72>
42011ad6:	02ad      	mov.n	a10, a2
42011ad8:	bc9e81        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
42011adb:	0008e0        	callx8	a8
42011ade:	080c      	movi.n	a8, 0
42011ae0:	d389      	s32i.n	a8, a3, 52
42011ae2:	102382        	l32i	a8, a3, 64
42011ae5:	1389      	s32i.n	a8, a3, 4
42011ae7:	788c      	beqz.n	a8, 42011af2 <__srefill_r+0x86>
42011ae9:	f388      	l32i.n	a8, a3, 60
42011aeb:	0389      	s32i.n	a8, a3, 0
42011aed:	001546        	j	42011b46 <__srefill_r+0xda>
42011af0:	880000        	lsi	f0, a0, 0x220
42011af3:	98cc43        	ssip	f4, a12, 0x260
42011af6:	03bd      	mov.n	a11, a3
42011af8:	20a220        	or	a10, a2, a2
42011afb:	201110        	or	a1, a1, a1
42011afe:	ffec65        	call8	420119c4 <__smakebuf_r>
42011b01:	061372        	l16ui	a7, a3, 12
42011b04:	148070        	extui	a8, a7, 0, 2
42011b07:	236780        	sext	a6, a7, 15
42011b0a:	48ac      	beqz.n	a8, 42011b32 <__srefill_r+0xc6>
42011b0c:	180c      	movi.n	a8, 1
42011b0e:	bb19c1        	l32r	a12, 42000774 <_stext+0x754> (3fc927b8 <__sglue>)
42011b11:	bcd5b1        	l32r	a11, 42000e68 <_stext+0xe48> (42011a4c <lflush>)
42011b14:	bb15a1        	l32r	a10, 42000768 <_stext+0x748> (3fc927c8 <_impure_data>)
42011b17:	065382        	s16i	a8, a3, 12
42011b1a:	201110        	or	a1, a1, a1
42011b1d:	03fea5        	call8	42015b08 <_fwalk_sglue>
42011b20:	980c      	movi.n	a8, 9
42011b22:	065372        	s16i	a7, a3, 12
42011b25:	09c687        	bnall	a6, a8, 42011b32 <__srefill_r+0xc6>
42011b28:	03bd      	mov.n	a11, a3
42011b2a:	02ad      	mov.n	a10, a2
42011b2c:	201110        	or	a1, a1, a1
42011b2f:	f9aea5        	call8	4200b618 <__sflush_r>
42011b32:	43c8      	l32i.n	a12, a3, 16
42011b34:	9388      	l32i.n	a8, a3, 36
42011b36:	53d8      	l32i.n	a13, a3, 20
42011b38:	83b8      	l32i.n	a11, a3, 32
42011b3a:	03c9      	s32i.n	a12, a3, 0
42011b3c:	02ad      	mov.n	a10, a2
42011b3e:	0008e0        	callx8	a8
42011b41:	13a9      	s32i.n	a10, a3, 4
42011b43:	051aa6        	blti	a10, 1, 42011b4c <__srefill_r+0xe0>
42011b46:	020c      	movi.n	a2, 0
42011b48:	0003c6        	j	42011b5b <__srefill_r+0xef>
42011b4b:	938200        	movnez	a8, a2, a0
42011b4e:	092c06        	j	42014002 <_svfiprintf_r+0x62a>
42011b51:	f3fa16        	beqz	a10, 42011a94 <__srefill_r+0x28>
42011b54:	090c      	movi.n	a9, 0
42011b56:	1399      	s32i.n	a9, a3, 4
42011b58:	ffcd86        	j	42011a92 <__srefill_r+0x26>
42011b5b:	f01d      	retw.n
42011b5d:	000000        	ill

42011b60 <__localeconv_l>:
42011b60:	004136        	entry	a1, 32
42011b63:	f0a082        	movi	a8, 240
42011b66:	228a      	add.n	a2, a2, a8
42011b68:	f01d      	retw.n
	...

42011b6c <_localeconv_r>:
42011b6c:	004136        	entry	a1, 32
42011b6f:	bcbf81        	l32r	a8, 42000e6c <_stext+0xe4c> (3fc928bc <__global_locale_ptr>)
42011b72:	0828      	l32i.n	a2, a8, 0
42011b74:	f0a082        	movi	a8, 240
42011b77:	228a      	add.n	a2, a2, a8
42011b79:	f01d      	retw.n
	...

42011b7c <localeconv>:
42011b7c:	004136        	entry	a1, 32
42011b7f:	bcbb81        	l32r	a8, 42000e6c <_stext+0xe4c> (3fc928bc <__global_locale_ptr>)
42011b82:	0828      	l32i.n	a2, a8, 0
42011b84:	f0a082        	movi	a8, 240
42011b87:	228a      	add.n	a2, a2, a8
42011b89:	f01d      	retw.n
	...

42011b8c <frexp>:
42011b8c:	004136        	entry	a1, 32
42011b8f:	0c0c      	movi.n	a12, 0
42011b91:	833a      	add.n	a8, a3, a3
42011b93:	04c9      	s32i.n	a12, a4, 0
42011b95:	bc9fc1        	l32r	a12, 42000e14 <_stext+0xdf4> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
42011b98:	418180        	srli	a8, a8, 1
42011b9b:	02ad      	mov.n	a10, a2
42011b9d:	03bd      	mov.n	a11, a3
42011b9f:	039d      	mov.n	a9, a3
42011ba1:	403c87        	bltu	a12, a8, 42011be5 <frexp+0x59>
42011ba4:	20c820        	or	a12, a8, a2
42011ba7:	acbc      	beqz.n	a12, 42011be5 <frexp+0x59>
42011ba9:	a5c430        	extui	a12, a3, 20, 11
42011bac:	8cdc      	bnez.n	a12, 42011bc8 <frexp+0x3c>
42011bae:	35a4d2        	movi	a13, 0x435
42011bb1:	0c0c      	movi.n	a12, 0
42011bb3:	01ddc0        	slli	a13, a13, 20
42011bb6:	bc9b81        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
42011bb9:	0008e0        	callx8	a8
42011bbc:	8bba      	add.n	a8, a11, a11
42011bbe:	caafc2        	movi	a12, -54
42011bc1:	0b9d      	mov.n	a9, a11
42011bc3:	418180        	srli	a8, a8, 1
42011bc6:	04c9      	s32i.n	a12, a4, 0
42011bc8:	02acc2        	movi	a12, 0xfffffc02
42011bcb:	318480        	srai	a8, a8, 20
42011bce:	88ca      	add.n	a8, a8, a12
42011bd0:	04c8      	l32i.n	a12, a4, 0
42011bd2:	8c8a      	add.n	a8, a12, a8
42011bd4:	0489      	s32i.n	a8, a4, 0
42011bd6:	bca681        	l32r	a8, 42000e70 <_stext+0xe50> (800fffff <_rtc_reserved_end+0x1fffffff>)
42011bd9:	109980        	and	a9, a9, a8
42011bdc:	ffa182        	movi	a8, 0x1ff
42011bdf:	0188b0        	slli	a8, a8, 21
42011be2:	20b980        	or	a11, a9, a8
42011be5:	0a2d      	mov.n	a2, a10
42011be7:	0b3d      	mov.n	a3, a11
42011be9:	f01d      	retw.n
	...

42011bec <quorem>:
42011bec:	006136        	entry	a1, 48
42011bef:	4288      	l32i.n	a8, a2, 16
42011bf1:	4378      	l32i.n	a7, a3, 16
42011bf3:	025d      	mov.n	a5, a2
42011bf5:	03bd      	mov.n	a11, a3
42011bf7:	020c      	movi.n	a2, 0
42011bf9:	02a877        	bge	a8, a7, 42011bff <quorem+0x13>
42011bfc:	004886        	j	42011d22 <quorem+0x136>
42011bff:	770b      	addi.n	a7, a7, -1
42011c01:	1187e0        	slli	a8, a7, 2
42011c04:	14c362        	addi	a6, a3, 20
42011c07:	368a      	add.n	a3, a6, a8
42011c09:	14c542        	addi	a4, a5, 20
42011c0c:	0398      	l32i.n	a9, a3, 0
42011c0e:	a48a      	add.n	a10, a4, a8
42011c10:	0ac8      	l32i.n	a12, a10, 0
42011c12:	991b      	addi.n	a9, a9, 1
42011c14:	c22c90        	quou	a2, a12, a9
42011c17:	02bc97        	bgeu	a12, a9, 42011c1d <quorem+0x31>
42011c1a:	002386        	j	42011cac <quorem+0xc0>
42011c1d:	090c      	movi.n	a9, 0
42011c1f:	1199      	s32i.n	a9, a1, 4
42011c21:	0199      	s32i.n	a9, a1, 0
42011c23:	8b8a      	add.n	a8, a11, a8
42011c25:	c09360        	sub	a9, a3, a6
42011c28:	419290        	srli	a9, a9, 2
42011c2b:	18cbc2        	addi	a12, a11, 24
42011c2e:	18c882        	addi	a8, a8, 24
42011c31:	04dd      	mov.n	a13, a4
42011c33:	06ed      	mov.n	a14, a6
42011c35:	991b      	addi.n	a9, a9, 1
42011c37:	02b8c7        	bgeu	a8, a12, 42011c3d <quorem+0x51>
42011c3a:	01a092        	movi	a9, 1
42011c3d:	4e8976        	loop	a9, 42011c8f <quorem+0xa3>
42011c40:	0e88      	l32i.n	a8, a14, 0
42011c42:	11f8      	l32i.n	a15, a1, 4
42011c44:	f4c080        	extui	a12, a8, 0, 16
42011c47:	82cc20        	mull	a12, a12, a2
42011c4a:	f58080        	extui	a8, a8, 16, 16
42011c4d:	ccfa      	add.n	a12, a12, a15
42011c4f:	828820        	mull	a8, a8, a2
42011c52:	f5f0c0        	extui	a15, a12, 16, 16
42011c55:	88fa      	add.n	a8, a8, a15
42011c57:	f5f080        	extui	a15, a8, 16, 16
42011c5a:	11f9      	s32i.n	a15, a1, 4
42011c5c:	0df8      	l32i.n	a15, a13, 0
42011c5e:	f4c0c0        	extui	a12, a12, 0, 16
42011c61:	f4f0f0        	extui	a15, a15, 0, 16
42011c64:	c0ffc0        	sub	a15, a15, a12
42011c67:	01c8      	l32i.n	a12, a1, 0
42011c69:	f48080        	extui	a8, a8, 0, 16
42011c6c:	ffca      	add.n	a15, a15, a12
42011c6e:	0dc8      	l32i.n	a12, a13, 0
42011c70:	ee4b      	addi.n	a14, a14, 4
42011c72:	f5c0c0        	extui	a12, a12, 16, 16
42011c75:	c08c80        	sub	a8, a12, a8
42011c78:	31c0f0        	srai	a12, a15, 16
42011c7b:	88ca      	add.n	a8, a8, a12
42011c7d:	31c080        	srai	a12, a8, 16
42011c80:	f4f0f0        	extui	a15, a15, 0, 16
42011c83:	118800        	slli	a8, a8, 16
42011c86:	2088f0        	or	a8, a8, a15
42011c89:	0d89      	s32i.n	a8, a13, 0
42011c8b:	01c9      	s32i.n	a12, a1, 0
42011c8d:	dd4b      	addi.n	a13, a13, 4
42011c8f:	0a88      	l32i.n	a8, a10, 0
42011c91:	388c      	beqz.n	a8, 42011c98 <quorem+0xac>
42011c93:	000546        	j	42011cac <quorem+0xc0>
42011c96:	770b      	addi.n	a7, a7, -1
42011c98:	fccaa2        	addi	a10, a10, -4
42011c9b:	0534a7        	bltu	a4, a10, 42011ca4 <quorem+0xb8>
42011c9e:	4579      	s32i.n	a7, a5, 16
42011ca0:	000206        	j	42011cac <quorem+0xc0>
42011ca3:	0a8800        	add.s	f8, f8, f0
42011ca6:	fec816        	beqz	a8, 42011c96 <quorem+0xaa>
42011ca9:	fffc46        	j	42011c9e <quorem+0xb2>
42011cac:	05ad      	mov.n	a10, a5
42011cae:	201110        	or	a1, a1, a1
42011cb1:	012fe5        	call8	42012fb0 <__mcmp>
42011cb4:	06aa96        	bltz	a10, 42011d22 <quorem+0x136>
42011cb7:	c09360        	sub	a9, a3, a6
42011cba:	419290        	srli	a9, a9, 2
42011cbd:	864b      	addi.n	a8, a6, 4
42011cbf:	334b      	addi.n	a3, a3, 4
42011cc1:	04ad      	mov.n	a10, a4
42011cc3:	0c0c      	movi.n	a12, 0
42011cc5:	991b      	addi.n	a9, a9, 1
42011cc7:	02b387        	bgeu	a3, a8, 42011ccd <quorem+0xe1>
42011cca:	01a092        	movi	a9, 1
42011ccd:	2e8976        	loop	a9, 42011cff <quorem+0x113>
42011cd0:	06d8      	l32i.n	a13, a6, 0
42011cd2:	0a88      	l32i.n	a8, a10, 0
42011cd4:	f4e0d0        	extui	a14, a13, 0, 16
42011cd7:	f4b080        	extui	a11, a8, 0, 16
42011cda:	c0bbe0        	sub	a11, a11, a14
42011cdd:	bbca      	add.n	a11, a11, a12
42011cdf:	f58080        	extui	a8, a8, 16, 16
42011ce2:	f5d0d0        	extui	a13, a13, 16, 16
42011ce5:	31c0b0        	srai	a12, a11, 16
42011ce8:	c088d0        	sub	a8, a8, a13
42011ceb:	88ca      	add.n	a8, a8, a12
42011ced:	31c080        	srai	a12, a8, 16
42011cf0:	f4b0b0        	extui	a11, a11, 0, 16
42011cf3:	118800        	slli	a8, a8, 16
42011cf6:	2088b0        	or	a8, a8, a11
42011cf9:	0a89      	s32i.n	a8, a10, 0
42011cfb:	664b      	addi.n	a6, a6, 4
42011cfd:	aa4b      	addi.n	a10, a10, 4
42011cff:	a08740        	addx4	a8, a7, a4
42011d02:	0898      	l32i.n	a9, a8, 0
42011d04:	498c      	beqz.n	a9, 42011d0c <quorem+0x120>
42011d06:	000586        	j	42011d20 <quorem+0x134>
42011d09:	770b00        	lsi	f0, a11, 0x1dc
42011d0c:	fcc882        	addi	a8, a8, -4
42011d0f:	053487        	bltu	a4, a8, 42011d18 <quorem+0x12c>
42011d12:	4579      	s32i.n	a7, a5, 16
42011d14:	000206        	j	42011d20 <quorem+0x134>
42011d17:	089800        	lsx	f9, a8, a0
42011d1a:	fec916        	beqz	a9, 42011d0a <quorem+0x11e>
42011d1d:	fffc46        	j	42011d12 <quorem+0x126>
42011d20:	221b      	addi.n	a2, a2, 1
42011d22:	f01d      	retw.n

42011d24 <_dtoa_r>:
42011d24:	012136        	entry	a1, 144
42011d27:	92a8      	l32i.n	a10, a2, 36
42011d29:	c169      	s32i.n	a6, a1, 48
42011d2b:	4129      	s32i.n	a2, a1, 16
42011d2d:	146172        	s32i	a7, a1, 80
42011d30:	126142        	s32i	a4, a1, 72
42011d33:	136152        	s32i	a5, a1, 76
42011d36:	252162        	l32i	a6, a1, 148
42011d39:	3aec      	bnez.n	a10, 42011d60 <_dtoa_r+0x3c>
42011d3b:	10a0a2        	movi	a10, 16
42011d3e:	ba9181        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
42011d41:	0008e0        	callx8	a8
42011d44:	4188      	l32i.n	a8, a1, 16
42011d46:	98a9      	s32i.n	a10, a8, 36
42011d48:	aacc      	bnez.n	a10, 42011d56 <_dtoa_r+0x32>
42011d4a:	bc4fd1        	l32r	a13, 42000e88 <_stext+0xe68> (3c0295f5 <_ZTISt12out_of_range+0x169>)
42011d4d:	0c0c      	movi.n	a12, 0
42011d4f:	efa0b2        	movi	a11, 239
42011d52:	00ab86        	j	42012004 <_dtoa_r+0x2e0>
42011d55:	080c00        	lsx	f0, a12, a0
42011d58:	1a89      	s32i.n	a8, a10, 4
42011d5a:	2a89      	s32i.n	a8, a10, 8
42011d5c:	0a89      	s32i.n	a8, a10, 0
42011d5e:	3a89      	s32i.n	a8, a10, 12
42011d60:	0ab8      	l32i.n	a11, a10, 0
42011d62:	cb9c      	beqz.n	a11, 42011d82 <_dtoa_r+0x5e>
42011d64:	1a98      	l32i.n	a9, a10, 4
42011d66:	180c      	movi.n	a8, 1
42011d68:	401900        	ssl	a9
42011d6b:	a18800        	sll	a8, a8
42011d6e:	41a8      	l32i.n	a10, a1, 16
42011d70:	1b99      	s32i.n	a9, a11, 4
42011d72:	2b89      	s32i.n	a8, a11, 8
42011d74:	201110        	or	a1, a1, a1
42011d77:	00cca5        	call8	42012a40 <_Bfree>
42011d7a:	4188      	l32i.n	a8, a1, 16
42011d7c:	090c      	movi.n	a9, 0
42011d7e:	9888      	l32i.n	a8, a8, 36
42011d80:	0899      	s32i.n	a9, a8, 0
42011d82:	053d      	mov.n	a3, a5
42011d84:	00e5d6        	bgez	a5, 42011d96 <_dtoa_r+0x72>
42011d87:	355a      	add.n	a3, a5, a5
42011d89:	180c      	movi.n	a8, 1
42011d8b:	413130        	srli	a3, a3, 1
42011d8e:	0689      	s32i.n	a8, a6, 0
42011d90:	136132        	s32i	a3, a1, 76
42011d93:	0000c6        	j	42011d9a <_dtoa_r+0x76>
42011d96:	080c      	movi.n	a8, 0
42011d98:	0689      	s32i.n	a8, a6, 0
42011d9a:	ffa782        	movi	a8, 0x7ff
42011d9d:	0188c0        	slli	a8, a8, 20
42011da0:	28c387        	bnall	a3, a8, 42011dcc <_dtoa_r+0xa8>
42011da3:	242192        	l32i	a9, a1, 144
42011da6:	f80c      	movi.n	a8, 15
42011da8:	113340        	slli	a3, a3, 12
42011dab:	27d882        	addmi	a8, a8, 0x2700
42011dae:	413c30        	srli	a3, a3, 12
42011db1:	0989      	s32i.n	a8, a9, 0
42011db3:	203340        	or	a3, a3, a4
42011db6:	13cc      	bnez.n	a3, 42011dbb <_dtoa_r+0x97>
42011db8:	02f206        	j	42012984 <_dtoa_r+0xc60>
42011dbb:	02f5c6        	j	42012996 <_dtoa_r+0xc72>
42011dbe:	000000        	ill
42011dc1:	bc2f81        	l32r	a8, 42000e80 <_stext+0xe60> (3c0295f4 <_ZTISt12out_of_range+0x168>)
42011dc4:	262192        	l32i	a9, a1, 152
42011dc7:	0989      	s32i.n	a8, a9, 0
42011dc9:	02fa06        	j	420129b5 <_dtoa_r+0xc91>
42011dcc:	122182        	l32i	a8, a1, 72
42011dcf:	132192        	l32i	a9, a1, 76
42011dd2:	e189      	s32i.n	a8, a1, 56
42011dd4:	f199      	s32i.n	a9, a1, 60
42011dd6:	e1a8      	l32i.n	a10, a1, 56
42011dd8:	f1b8      	l32i.n	a11, a1, 60
42011dda:	00a0c2        	movi	a12, 0
42011ddd:	00a0d2        	movi	a13, 0
42011de0:	bc1281        	l32r	a8, 42000e28 <_stext+0xe08> (4000228c <__eqdf2>)
42011de3:	0008e0        	callx8	a8
42011de6:	8adc      	bnez.n	a10, 42011e02 <_dtoa_r+0xde>
42011de8:	242192        	l32i	a9, a1, 144
42011deb:	180c      	movi.n	a8, 1
42011ded:	0989      	s32i.n	a8, a9, 0
42011def:	262182        	l32i	a8, a1, 152
42011df2:	688c      	beqz.n	a8, 42011dfc <_dtoa_r+0xd8>
42011df4:	bc2781        	l32r	a8, 42000e90 <_stext+0xe70> (3c0295e7 <_ZTISt12out_of_range+0x15b>)
42011df7:	262192        	l32i	a9, a1, 152
42011dfa:	0989      	s32i.n	a8, a9, 0
42011dfc:	bc2221        	l32r	a2, 42000e84 <_stext+0xe64> (3c0295e6 <_ZTISt12out_of_range+0x15a>)
42011dff:	02ec86        	j	420129b5 <_dtoa_r+0xc91>
42011e02:	e1c8      	l32i.n	a12, a1, 56
42011e04:	f1d8      	l32i.n	a13, a1, 60
42011e06:	41a8      	l32i.n	a10, a1, 16
42011e08:	f14b      	addi.n	a15, a1, 4
42011e0a:	01ed      	mov.n	a14, a1
42011e0c:	201110        	or	a1, a1, a1
42011e0f:	014025        	call8	42013210 <__d2b>
42011e12:	51a9      	s32i.n	a10, a1, 20
42011e14:	b59430        	extui	a9, a3, 20, 12
42011e17:	1168      	l32i.n	a6, a1, 4
42011e19:	899c      	beqz.n	a9, 42011e35 <_dtoa_r+0x111>
42011e1b:	f188      	l32i.n	a8, a1, 60
42011e1d:	bc1da1        	l32r	a10, 42000e94 <_stext+0xe74> (3ff00000 <ets_ops_table_ptr+0x210004>)
42011e20:	118840        	slli	a8, a8, 12
42011e23:	418c80        	srli	a8, a8, 12
42011e26:	2088a0        	or	a8, a8, a10
42011e29:	01aca2        	movi	a10, 0xfffffc01
42011e2c:	59aa      	add.n	a5, a9, a10
42011e2e:	e1a8      	l32i.n	a10, a1, 56
42011e30:	090c      	movi.n	a9, 0
42011e32:	0011c6        	j	42011e7d <_dtoa_r+0x159>
42011e35:	0128      	l32i.n	a2, a1, 0
42011e37:	32a4a2        	movi	a10, 0x432
42011e3a:	262a      	add.n	a2, a6, a2
42011e3c:	a2aa      	add.n	a10, a2, a10
42011e3e:	082c      	movi.n	a8, 32
42011e40:	1ca8a7        	bge	a8, a10, 42011e60 <_dtoa_r+0x13c>
42011e43:	c0caa2        	addi	a10, a10, -64
42011e46:	60a0a0        	neg	a10, a10
42011e49:	12c282        	addi	a8, a2, 18
42011e4c:	401a00        	ssl	a10
42011e4f:	a13300        	sll	a3, a3
42011e52:	400800        	ssr	a8
42011e55:	918040        	srl	a8, a4
42011e58:	20a380        	or	a10, a3, a8
42011e5b:	000346        	j	42011e6c <_dtoa_r+0x148>
42011e5e:	a20000        	muluh	a0, a0, a0
42011e61:	e0ca      	add.n	a14, a0, a12
42011e63:	60a0a0        	neg	a10, a10
42011e66:	401a00        	ssl	a10
42011e69:	a1a400        	sll	a10, a4
42011e6c:	bc1781        	l32r	a8, 42000ec8 <_stext+0xea8> (40002364 <__floatunsidf>)
42011e6f:	0008e0        	callx8	a8
42011e72:	186c      	movi.n	a8, -31
42011e74:	0188c0        	slli	a8, a8, 20
42011e77:	88ba      	add.n	a8, a8, a11
42011e79:	520b      	addi.n	a5, a2, -1
42011e7b:	190c      	movi.n	a9, 1
42011e7d:	ffa7d2        	movi	a13, 0x7ff
42011e80:	186192        	s32i	a9, a1, 96
42011e83:	08bd      	mov.n	a11, a8
42011e85:	0c0c      	movi.n	a12, 0
42011e87:	01ddd0        	slli	a13, a13, 19
42011e8a:	bbea81        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
42011e8d:	0008e0        	callx8	a8
42011e90:	bc08c1        	l32r	a12, 42000eb0 <_stext+0xe90> (636f4361 <_rtc_reserved_end+0x35f4361>)
42011e93:	bc08d1        	l32r	a13, 42000eb4 <_stext+0xe94> (3fd287a7 <ets_ops_table_ptr+0x387ab>)
42011e96:	bbe381        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
42011e99:	0008e0        	callx8	a8
42011e9c:	bc07c1        	l32r	a12, 42000eb8 <_stext+0xe98> (8b60c8b3 <_rtc_reserved_end+0x2b50c8b3>)
42011e9f:	bc07d1        	l32r	a13, 42000ebc <_stext+0xe9c> (3fc68a28 <_esp_system_init_fn_array_end+0x3c3e4ec>)
42011ea2:	bc0a81        	l32r	a8, 42000ecc <_stext+0xeac> (40002184 <__adddf3>)
42011ea5:	0008e0        	callx8	a8
42011ea8:	0a2d      	mov.n	a2, a10
42011eaa:	05ad      	mov.n	a10, a5
42011eac:	0b3d      	mov.n	a3, a11
42011eae:	bbe081        	l32r	a8, 42000e30 <_stext+0xe10> (40002334 <__floatsidf>)
42011eb1:	0008e0        	callx8	a8
42011eb4:	bc03c1        	l32r	a12, 42000ec0 <_stext+0xea0> (509f79fb <_coredump_rtc_end+0x9f79fb>)
42011eb7:	bc03d1        	l32r	a13, 42000ec4 <_stext+0xea4> (3fd34413 <ets_ops_table_ptr+0x44417>)
42011eba:	bbda81        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
42011ebd:	0008e0        	callx8	a8
42011ec0:	0acd      	mov.n	a12, a10
42011ec2:	0bdd      	mov.n	a13, a11
42011ec4:	02ad      	mov.n	a10, a2
42011ec6:	03bd      	mov.n	a11, a3
42011ec8:	bc0181        	l32r	a8, 42000ecc <_stext+0xeac> (40002184 <__adddf3>)
42011ecb:	0008e0        	callx8	a8
42011ece:	71b9      	s32i.n	a11, a1, 28
42011ed0:	61a9      	s32i.n	a10, a1, 24
42011ed2:	bbd681        	l32r	a8, 42000e2c <_stext+0xe0c> (400022d4 <__fixdfsi>)
42011ed5:	0008e0        	callx8	a8
42011ed8:	0a3d      	mov.n	a3, a10
42011eda:	71b8      	l32i.n	a11, a1, 28
42011edc:	61a8      	l32i.n	a10, a1, 24
42011ede:	0c0c      	movi.n	a12, 0
42011ee0:	00a0d2        	movi	a13, 0
42011ee3:	bbcf81        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
42011ee6:	0008e0        	callx8	a8
42011ee9:	015ad6        	bgez	a10, 42011f02 <_dtoa_r+0x1de>
42011eec:	03ad      	mov.n	a10, a3
42011eee:	bbd081        	l32r	a8, 42000e30 <_stext+0xe10> (40002334 <__floatsidf>)
42011ef1:	0008e0        	callx8	a8
42011ef4:	61c8      	l32i.n	a12, a1, 24
42011ef6:	71d8      	l32i.n	a13, a1, 28
42011ef8:	bbd081        	l32r	a8, 42000e38 <_stext+0xe18> (4000246c <__nedf2>)
42011efb:	0008e0        	callx8	a8
42011efe:	0a8c      	beqz.n	a10, 42011f02 <_dtoa_r+0x1de>
42011f00:	330b      	addi.n	a3, a3, -1
42011f02:	190c      	movi.n	a9, 1
42011f04:	681c      	movi.n	a8, 22
42011f06:	156192        	s32i	a9, a1, 84
42011f09:	1d3837        	bltu	a8, a3, 42011f2a <_dtoa_r+0x206>
42011f0c:	bbe381        	l32r	a8, 42000e98 <_stext+0xe78> (3c029dc0 <__mprec_tens>)
42011f0f:	e1a8      	l32i.n	a10, a1, 56
42011f11:	b08380        	addx8	a8, a3, a8
42011f14:	08c8      	l32i.n	a12, a8, 0
42011f16:	18d8      	l32i.n	a13, a8, 4
42011f18:	f1b8      	l32i.n	a11, a1, 60
42011f1a:	bbc181        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
42011f1d:	0008e0        	callx8	a8
42011f20:	001ad6        	bgez	a10, 42011f25 <_dtoa_r+0x201>
42011f23:	330b      	addi.n	a3, a3, -1
42011f25:	080c      	movi.n	a8, 0
42011f27:	156182        	s32i	a8, a1, 84
42011f2a:	c06650        	sub	a6, a6, a5
42011f2d:	860b      	addi.n	a8, a6, -1
42011f2f:	a189      	s32i.n	a8, a1, 40
42011f31:	040c      	movi.n	a4, 0
42011f33:	0068d6        	bgez	a8, 42011f3d <_dtoa_r+0x219>
42011f36:	604080        	neg	a4, a8
42011f39:	080c      	movi.n	a8, 0
42011f3b:	a189      	s32i.n	a8, a1, 40
42011f3d:	00f396        	bltz	a3, 42011f50 <_dtoa_r+0x22c>
42011f40:	a188      	l32i.n	a8, a1, 40
42011f42:	116132        	s32i	a3, a1, 68
42011f45:	883a      	add.n	a8, a8, a3
42011f47:	a189      	s32i.n	a8, a1, 40
42011f49:	080c      	movi.n	a8, 0
42011f4b:	d189      	s32i.n	a8, a1, 52
42011f4d:	000306        	j	42011f5d <_dtoa_r+0x239>
42011f50:	608030        	neg	a8, a3
42011f53:	d189      	s32i.n	a8, a1, 52
42011f55:	080c      	movi.n	a8, 0
42011f57:	c04430        	sub	a4, a4, a3
42011f5a:	116182        	s32i	a8, a1, 68
42011f5d:	c198      	l32i.n	a9, a1, 48
42011f5f:	980c      	movi.n	a8, 9
42011f61:	150c      	movi.n	a5, 1
42011f63:	4e3897        	bltu	a8, a9, 42011fb5 <_dtoa_r+0x291>
42011f66:	0669a6        	blti	a9, 6, 42011f70 <_dtoa_r+0x24c>
42011f69:	fcc982        	addi	a8, a9, -4
42011f6c:	c189      	s32i.n	a8, a1, 48
42011f6e:	050c      	movi.n	a5, 0
42011f70:	c188      	l32i.n	a8, a1, 48
42011f72:	124826        	beqi	a8, 4, 42011f88 <_dtoa_r+0x264>
42011f75:	255826        	beqi	a8, 5, 42011f9e <_dtoa_r+0x27a>
42011f78:	112826        	beqi	a8, 2, 42011f8d <_dtoa_r+0x269>
42011f7b:	080c      	movi.n	a8, 0
42011f7d:	106182        	s32i	a8, a1, 64
42011f80:	c188      	l32i.n	a8, a1, 48
42011f82:	1d3826        	beqi	a8, 3, 42011fa3 <_dtoa_r+0x27f>
42011f85:	000c06        	j	42011fb9 <_dtoa_r+0x295>
42011f88:	180c      	movi.n	a8, 1
42011f8a:	000046        	j	42011f8f <_dtoa_r+0x26b>
42011f8d:	080c      	movi.n	a8, 0
42011f8f:	106182        	s32i	a8, a1, 64
42011f92:	3617a6        	blti	a7, 1, 42011fcc <_dtoa_r+0x2a8>
42011f95:	b179      	s32i.n	a7, a1, 44
42011f97:	078d      	mov.n	a8, a7
42011f99:	8179      	s32i.n	a7, a1, 32
42011f9b:	000e06        	j	42011fd7 <_dtoa_r+0x2b3>
42011f9e:	180c      	movi.n	a8, 1
42011fa0:	106182        	s32i	a8, a1, 64
42011fa3:	837a      	add.n	a8, a3, a7
42011fa5:	b189      	s32i.n	a8, a1, 44
42011fa7:	881b      	addi.n	a8, a8, 1
42011fa9:	8189      	s32i.n	a8, a1, 32
42011fab:	8198      	l32i.n	a9, a1, 32
42011fad:	180c      	movi.n	a8, 1
42011faf:	538980        	max	a8, a9, a8
42011fb2:	000846        	j	42011fd7 <_dtoa_r+0x2b3>
42011fb5:	080c      	movi.n	a8, 0
42011fb7:	c189      	s32i.n	a8, a1, 48
42011fb9:	180c      	movi.n	a8, 1
42011fbb:	106182        	s32i	a8, a1, 64
42011fbe:	f87c      	movi.n	a8, -1
42011fc0:	b189      	s32i.n	a8, a1, 44
42011fc2:	8189      	s32i.n	a8, a1, 32
42011fc4:	090c      	movi.n	a9, 0
42011fc6:	281c      	movi.n	a8, 18
42011fc8:	000206        	j	42011fd4 <_dtoa_r+0x2b0>
42011fcb:	180c00        	lsxp	f0, a12, a0
42011fce:	b189      	s32i.n	a8, a1, 44
42011fd0:	8189      	s32i.n	a8, a1, 32
42011fd2:	190c      	movi.n	a9, 1
42011fd4:	146192        	s32i	a9, a1, 80
42011fd7:	4198      	l32i.n	a9, a1, 16
42011fd9:	0b0c      	movi.n	a11, 0
42011fdb:	99a8      	l32i.n	a10, a9, 36
42011fdd:	490c      	movi.n	a9, 4
42011fdf:	0000c6        	j	42011fe6 <_dtoa_r+0x2c2>
42011fe2:	999a      	add.n	a9, a9, a9
42011fe4:	0dbd      	mov.n	a11, a13
42011fe6:	14c9c2        	addi	a12, a9, 20
42011fe9:	db1b      	addi.n	a13, a11, 1
42011feb:	f3b8c7        	bgeu	a8, a12, 42011fe2 <_dtoa_r+0x2be>
42011fee:	1ab9      	s32i.n	a11, a10, 4
42011ff0:	41a8      	l32i.n	a10, a1, 16
42011ff2:	201110        	or	a1, a1, a1
42011ff5:	009c25        	call8	420129b8 <_Balloc>
42011ff8:	0a2d      	mov.n	a2, a10
42011ffa:	facc      	bnez.n	a10, 4201200d <_dtoa_r+0x2e9>
42011ffc:	bba8d1        	l32r	a13, 42000e9c <_stext+0xe7c> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42011fff:	0c0c      	movi.n	a12, 0
42012001:	afa1b2        	movi	a11, 0x1af
42012004:	bba2a1        	l32r	a10, 42000e8c <_stext+0xe6c> (3c02960c <_ZTISt12out_of_range+0x180>)
42012007:	b82e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4201200a:	0008e0        	callx8	a8
4201200d:	4188      	l32i.n	a8, a1, 16
4201200f:	e60c      	movi.n	a6, 14
42012011:	9888      	l32i.n	a8, a8, 36
42012013:	08a9      	s32i.n	a10, a8, 0
42012015:	8188      	l32i.n	a8, a1, 32
42012017:	626680        	lsi	f8, a6, 0x188
4201201a:	660b      	addi.n	a6, a6, -1
4201201c:	606060        	neg	a6, a6
4201201f:	106650        	and	a6, a6, a5
42012022:	348616        	beqz	a6, 4201236e <_dtoa_r+0x64a>
42012025:	0213e6        	bgei	a3, 1, 4201202b <_dtoa_r+0x307>
42012028:	002086        	j	420120ae <_dtoa_r+0x38a>
4201202b:	bb9b91        	l32r	a9, 42000e98 <_stext+0xe78> (3c029dc0 <__mprec_tens>)
4201202e:	348030        	extui	a8, a3, 0, 4
42012031:	b08890        	addx8	a8, a8, a9
42012034:	1898      	l32i.n	a9, a8, 4
42012036:	e1e8      	l32i.n	a14, a1, 56
42012038:	0888      	l32i.n	a8, a8, 0
4201203a:	f1f8      	l32i.n	a15, a1, 60
4201203c:	216430        	srai	a6, a3, 4
4201203f:	270c      	movi.n	a7, 2
42012041:	236387        	bbci	a3, 8, 42012068 <_dtoa_r+0x344>
42012044:	bb97a1        	l32r	a10, 42000ea0 <_stext+0xe80> (3c029d98 <__mprec_bigtens>)
42012047:	6189      	s32i.n	a8, a1, 24
42012049:	8ac8      	l32i.n	a12, a10, 32
4201204b:	9ad8      	l32i.n	a13, a10, 36
4201204d:	7199      	s32i.n	a9, a1, 28
4201204f:	0ead      	mov.n	a10, a14
42012051:	0fbd      	mov.n	a11, a15
42012053:	bb9f81        	l32r	a8, 42000ed0 <_stext+0xeb0> (40002250 <__divdf3>)
42012056:	0008e0        	callx8	a8
42012059:	6188      	l32i.n	a8, a1, 24
4201205b:	7198      	l32i.n	a9, a1, 28
4201205d:	346060        	extui	a6, a6, 0, 4
42012060:	0aed      	mov.n	a14, a10
42012062:	20fbb0        	or	a15, a11, a11
42012065:	03a072        	movi	a7, 3
42012068:	bb8e51        	l32r	a5, 42000ea0 <_stext+0xe80> (3c029d98 <__mprec_bigtens>)
4201206b:	000986        	j	42012095 <_dtoa_r+0x371>
4201206e:	1e6607        	bbci	a6, 0, 42012090 <_dtoa_r+0x36c>
42012071:	05c8      	l32i.n	a12, a5, 0
42012073:	15d8      	l32i.n	a13, a5, 4
42012075:	61e9      	s32i.n	a14, a1, 24
42012077:	71f9      	s32i.n	a15, a1, 28
42012079:	20a880        	or	a10, a8, a8
4201207c:	09bd      	mov.n	a11, a9
4201207e:	bb6981        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
42012081:	0008e0        	callx8	a8
42012084:	61e8      	l32i.n	a14, a1, 24
42012086:	71f8      	l32i.n	a15, a1, 28
42012088:	771b      	addi.n	a7, a7, 1
4201208a:	208aa0        	or	a8, a10, a10
4201208d:	209bb0        	or	a9, a11, a11
42012090:	216160        	srai	a6, a6, 1
42012093:	558b      	addi.n	a5, a5, 8
42012095:	fd5656        	bnez	a6, 4201206e <_dtoa_r+0x34a>
42012098:	08cd      	mov.n	a12, a8
4201209a:	09dd      	mov.n	a13, a9
4201209c:	20aee0        	or	a10, a14, a14
4201209f:	20bff0        	or	a11, a15, a15
420120a2:	bb8b81        	l32r	a8, 42000ed0 <_stext+0xeb0> (40002250 <__divdf3>)
420120a5:	0008e0        	callx8	a8
420120a8:	001686        	j	42012106 <_dtoa_r+0x3e2>
420120ab:	000000        	ill
420120ae:	e188      	l32i.n	a8, a1, 56
420120b0:	f198      	l32i.n	a9, a1, 60
420120b2:	6189      	s32i.n	a8, a1, 24
420120b4:	7199      	s32i.n	a9, a1, 28
420120b6:	270c      	movi.n	a7, 2
420120b8:	050316        	beqz	a3, 4201210c <_dtoa_r+0x3e8>
420120bb:	bb7791        	l32r	a9, 42000e98 <_stext+0xe78> (3c029dc0 <__mprec_tens>)
420120be:	605030        	neg	a5, a3
420120c1:	348050        	extui	a8, a5, 0, 4
420120c4:	b08890        	addx8	a8, a8, a9
420120c7:	08c8      	l32i.n	a12, a8, 0
420120c9:	18d8      	l32i.n	a13, a8, 4
420120cb:	e1a8      	l32i.n	a10, a1, 56
420120cd:	f1b8      	l32i.n	a11, a1, 60
420120cf:	215450        	srai	a5, a5, 4
420120d2:	bb5481        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
420120d5:	0008e0        	callx8	a8
420120d8:	bb7291        	l32r	a9, 42000ea0 <_stext+0xe80> (3c029d98 <__mprec_bigtens>)
420120db:	61a9      	s32i.n	a10, a1, 24
420120dd:	71b9      	s32i.n	a11, a1, 28
420120df:	080c      	movi.n	a8, 0
420120e1:	000706        	j	42012101 <_dtoa_r+0x3dd>
420120e4:	650700        	extui	a0, a0, 23, 7
420120e7:	09c813        	ssip	f1, a8, 36
420120ea:	19d8      	l32i.n	a13, a9, 4
420120ec:	166192        	s32i	a9, a1, 88
420120ef:	bb4d81        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
420120f2:	0008e0        	callx8	a8
420120f5:	162192        	l32i	a9, a1, 88
420120f8:	771b      	addi.n	a7, a7, 1
420120fa:	068d      	mov.n	a8, a6
420120fc:	215150        	srai	a5, a5, 1
420120ff:	998b      	addi.n	a9, a9, 8
42012101:	fe0556        	bnez	a5, 420120e5 <_dtoa_r+0x3c1>
42012104:	488c      	beqz.n	a8, 4201210c <_dtoa_r+0x3e8>
42012106:	0661a2        	s32i	a10, a1, 24
42012109:	0761b2        	s32i	a11, a1, 28
4201210c:	152182        	l32i	a8, a1, 84
4201210f:	98bc      	beqz.n	a8, 4201214c <_dtoa_r+0x428>
42012111:	bb60d1        	l32r	a13, 42000e94 <_stext+0xe74> (3ff00000 <ets_ops_table_ptr+0x210004>)
42012114:	61a8      	l32i.n	a10, a1, 24
42012116:	71b8      	l32i.n	a11, a1, 28
42012118:	0c0c      	movi.n	a12, 0
4201211a:	bb4181        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
4201211d:	0008e0        	callx8	a8
42012120:	028ad6        	bgez	a10, 4201214c <_dtoa_r+0x428>
42012123:	8188      	l32i.n	a8, a1, 32
42012125:	d8ac      	beqz.n	a8, 42012156 <_dtoa_r+0x432>
42012127:	b188      	l32i.n	a8, a1, 44
42012129:	0218e6        	bgei	a8, 1, 4201212f <_dtoa_r+0x40b>
4201212c:	008f86        	j	4201236e <_dtoa_r+0x64a>
4201212f:	61a8      	l32i.n	a10, a1, 24
42012131:	71b8      	l32i.n	a11, a1, 28
42012133:	bb5cd1        	l32r	a13, 42000ea4 <_stext+0xe84> (40240000 <rom_rx_gain_force+0x239bd4>)
42012136:	0c0c      	movi.n	a12, 0
42012138:	bb3b81        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
4201213b:	0008e0        	callx8	a8
4201213e:	530b      	addi.n	a5, a3, -1
42012140:	b168      	l32i.n	a6, a1, 44
42012142:	61a9      	s32i.n	a10, a1, 24
42012144:	71b9      	s32i.n	a11, a1, 28
42012146:	771b      	addi.n	a7, a7, 1
42012148:	000386        	j	4201215a <_dtoa_r+0x436>
4201214b:	816800        	src	a6, a8, a0
4201214e:	035d      	mov.n	a5, a3
42012150:	000186        	j	4201215a <_dtoa_r+0x436>
42012153:	000000        	ill
42012156:	035d      	mov.n	a5, a3
42012158:	060c      	movi.n	a6, 0
4201215a:	07ad      	mov.n	a10, a7
4201215c:	bb3581        	l32r	a8, 42000e30 <_stext+0xe10> (40002334 <__floatsidf>)
4201215f:	0008e0        	callx8	a8
42012162:	61c8      	l32i.n	a12, a1, 24
42012164:	0721d2        	l32i	a13, a1, 28
42012167:	bb2f81        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
4201216a:	0008e0        	callx8	a8
4201216d:	bb4fd1        	l32r	a13, 42000eac <_stext+0xe8c> (401c0000 <rom_rx_gain_force+0x1b9bd4>)
42012170:	0c0c      	movi.n	a12, 0
42012172:	bb5681        	l32r	a8, 42000ecc <_stext+0xeac> (40002184 <__adddf3>)
42012175:	0008e0        	callx8	a8
42012178:	387c      	movi.n	a8, -13
4201217a:	0188a0        	slli	a8, a8, 22
4201217d:	f8ba      	add.n	a15, a8, a11
4201217f:	1661a2        	s32i	a10, a1, 88
42012182:	1761f2        	s32i	a15, a1, 92
42012185:	1a61a2        	s32i	a10, a1, 104
42012188:	1b61f2        	s32i	a15, a1, 108
4201218b:	046656        	bnez	a6, 420121d5 <_dtoa_r+0x4b1>
4201218e:	bb46d1        	l32r	a13, 42000ea8 <_stext+0xe88> (40140000 <rom_rx_gain_force+0x139bd4>)
42012191:	61a8      	l32i.n	a10, a1, 24
42012193:	71b8      	l32i.n	a11, a1, 28
42012195:	0c0c      	movi.n	a12, 0
42012197:	bb2781        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
4201219a:	0008e0        	callx8	a8
4201219d:	1621c2        	l32i	a12, a1, 88
420121a0:	1721d2        	l32i	a13, a1, 92
420121a3:	0a6d      	mov.n	a6, a10
420121a5:	0b7d      	mov.n	a7, a11
420121a7:	bb2581        	l32r	a8, 42000e3c <_stext+0xe1c> (400023a0 <__gtdf2>)
420121aa:	0008e0        	callx8	a8
420121ad:	021aa6        	blti	a10, 1, 420121b3 <_dtoa_r+0x48f>
420121b0:	0151c6        	j	420126fb <_dtoa_r+0x9d7>
420121b3:	1b21f2        	l32i	a15, a1, 108
420121b6:	f87c      	movi.n	a8, -1
420121b8:	018810        	slli	a8, a8, 31
420121bb:	1a21c2        	l32i	a12, a1, 104
420121be:	30d8f0        	xor	a13, a8, a15
420121c1:	06ad      	mov.n	a10, a6
420121c3:	20b770        	or	a11, a7, a7
420121c6:	bb1681        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
420121c9:	0008e0        	callx8	a8
420121cc:	20aa96        	bltz	a10, 420123da <_dtoa_r+0x6b6>
420121cf:	0066c6        	j	4201236e <_dtoa_r+0x64a>
420121d2:	000000        	ill
420121d5:	bb3091        	l32r	a9, 42000e98 <_stext+0xe78> (3c029dc0 <__mprec_tens>)
420121d8:	860b      	addi.n	a8, a6, -1
420121da:	b08890        	addx8	a8, a8, a9
420121dd:	08a8      	l32i.n	a10, a8, 0
420121df:	18b8      	l32i.n	a11, a8, 4
420121e1:	102182        	l32i	a8, a1, 64
420121e4:	726a      	add.n	a7, a2, a6
420121e6:	0bf816        	beqz	a8, 420122a9 <_dtoa_r+0x585>
420121e9:	0bdd      	mov.n	a13, a11
420121eb:	bb09b1        	l32r	a11, 42000e10 <_stext+0xdf0> (3fe00000 <ets_ops_table_ptr+0x110004>)
420121ee:	0acd      	mov.n	a12, a10
420121f0:	0a0c      	movi.n	a10, 0
420121f2:	bb3781        	l32r	a8, 42000ed0 <_stext+0xeb0> (40002250 <__divdf3>)
420121f5:	0008e0        	callx8	a8
420121f8:	1621c2        	l32i	a12, a1, 88
420121fb:	1721d2        	l32i	a13, a1, 92
420121fe:	bb0d81        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
42012201:	0008e0        	callx8	a8
42012204:	1661a2        	s32i	a10, a1, 88
42012207:	1761b2        	s32i	a11, a1, 92
4201220a:	028d      	mov.n	a8, a2
4201220c:	71b8      	l32i.n	a11, a1, 28
4201220e:	61a8      	l32i.n	a10, a1, 24
42012210:	196182        	s32i	a8, a1, 100
42012213:	bb0681        	l32r	a8, 42000e2c <_stext+0xe0c> (400022d4 <__fixdfsi>)
42012216:	0008e0        	callx8	a8
42012219:	1a61a2        	s32i	a10, a1, 104
4201221c:	bb0581        	l32r	a8, 42000e30 <_stext+0xe10> (40002334 <__floatsidf>)
4201221f:	0008e0        	callx8	a8
42012222:	0acd      	mov.n	a12, a10
42012224:	0bdd      	mov.n	a13, a11
42012226:	61a8      	l32i.n	a10, a1, 24
42012228:	0721b2        	l32i	a11, a1, 28
4201222b:	bb0281        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
4201222e:	0008e0        	callx8	a8
42012231:	1a2192        	l32i	a9, a1, 104
42012234:	192182        	l32i	a8, a1, 100
42012237:	30c992        	addi	a9, a9, 48
4201223a:	1621c2        	l32i	a12, a1, 88
4201223d:	1721d2        	l32i	a13, a1, 92
42012240:	61a9      	s32i.n	a10, a1, 24
42012242:	0761b2        	s32i	a11, a1, 28
42012245:	004892        	s8i	a9, a8, 0
42012248:	01c862        	addi	a6, a8, 1
4201224b:	baf581        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
4201224e:	0008e0        	callx8	a8
42012251:	70ba96        	bltz	a10, 42012960 <_dtoa_r+0xc3c>
42012254:	61c8      	l32i.n	a12, a1, 24
42012256:	71d8      	l32i.n	a13, a1, 28
42012258:	bb0fb1        	l32r	a11, 42000e94 <_stext+0xe74> (3ff00000 <ets_ops_table_ptr+0x210004>)
4201225b:	00a0a2        	movi	a10, 0
4201225e:	baf581        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
42012261:	0008e0        	callx8	a8
42012264:	1621c2        	l32i	a12, a1, 88
42012267:	1721d2        	l32i	a13, a1, 92
4201226a:	baed81        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
4201226d:	0008e0        	callx8	a8
42012270:	1faa96        	bltz	a10, 4201246e <_dtoa_r+0x74a>
42012273:	029677        	bne	a6, a7, 42012279 <_dtoa_r+0x555>
42012276:	003d06        	j	4201236e <_dtoa_r+0x64a>
42012279:	bb0ad1        	l32r	a13, 42000ea4 <_stext+0xe84> (40240000 <rom_rx_gain_force+0x239bd4>)
4201227c:	1621a2        	l32i	a10, a1, 88
4201227f:	1721b2        	l32i	a11, a1, 92
42012282:	0c0c      	movi.n	a12, 0
42012284:	bae881        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
42012287:	0008e0        	callx8	a8
4201228a:	1661a2        	s32i	a10, a1, 88
4201228d:	1761b2        	s32i	a11, a1, 92
42012290:	61a8      	l32i.n	a10, a1, 24
42012292:	71b8      	l32i.n	a11, a1, 28
42012294:	bb04d1        	l32r	a13, 42000ea4 <_stext+0xe84> (40240000 <rom_rx_gain_force+0x239bd4>)
42012297:	00a0c2        	movi	a12, 0
4201229a:	bae281        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
4201229d:	0008e0        	callx8	a8
420122a0:	61a9      	s32i.n	a10, a1, 24
420122a2:	71b9      	s32i.n	a11, a1, 28
420122a4:	068d      	mov.n	a8, a6
420122a6:	ffd886        	j	4201220c <_dtoa_r+0x4e8>
420122a9:	1621c2        	l32i	a12, a1, 88
420122ac:	1721d2        	l32i	a13, a1, 92
420122af:	badd81        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
420122b2:	0008e0        	callx8	a8
420122b5:	1661a2        	s32i	a10, a1, 88
420122b8:	1761b2        	s32i	a11, a1, 92
420122bb:	028d      	mov.n	a8, a2
420122bd:	71b8      	l32i.n	a11, a1, 28
420122bf:	61a8      	l32i.n	a10, a1, 24
420122c1:	1a6182        	s32i	a8, a1, 104
420122c4:	bada81        	l32r	a8, 42000e2c <_stext+0xe0c> (400022d4 <__fixdfsi>)
420122c7:	0008e0        	callx8	a8
420122ca:	0a6d      	mov.n	a6, a10
420122cc:	bad981        	l32r	a8, 42000e30 <_stext+0xe10> (40002334 <__floatsidf>)
420122cf:	0008e0        	callx8	a8
420122d2:	0acd      	mov.n	a12, a10
420122d4:	0bdd      	mov.n	a13, a11
420122d6:	61a8      	l32i.n	a10, a1, 24
420122d8:	0721b2        	l32i	a11, a1, 28
420122db:	30c662        	addi	a6, a6, 48
420122de:	bad581        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
420122e1:	0008e0        	callx8	a8
420122e4:	1a2182        	l32i	a8, a1, 104
420122e7:	61a9      	s32i.n	a10, a1, 24
420122e9:	004862        	s8i	a6, a8, 0
420122ec:	71b9      	s32i.n	a11, a1, 28
420122ee:	881b      	addi.n	a8, a8, 1
420122f0:	5e9787        	bne	a7, a8, 42012352 <_dtoa_r+0x62e>
420122f3:	bac7d1        	l32r	a13, 42000e10 <_stext+0xdf0> (3fe00000 <ets_ops_table_ptr+0x110004>)
420122f6:	1621a2        	l32i	a10, a1, 88
420122f9:	1721b2        	l32i	a11, a1, 92
420122fc:	0c0c      	movi.n	a12, 0
420122fe:	baf381        	l32r	a8, 42000ecc <_stext+0xeac> (40002184 <__adddf3>)
42012301:	0008e0        	callx8	a8
42012304:	0acd      	mov.n	a12, a10
42012306:	0bdd      	mov.n	a13, a11
42012308:	61a8      	l32i.n	a10, a1, 24
4201230a:	71b8      	l32i.n	a11, a1, 28
4201230c:	206770        	or	a6, a7, a7
4201230f:	bacb81        	l32r	a8, 42000e3c <_stext+0xe1c> (400023a0 <__gtdf2>)
42012312:	0008e0        	callx8	a8
42012315:	021aa6        	blti	a10, 1, 4201231b <_dtoa_r+0x5f7>
42012318:	005486        	j	4201246e <_dtoa_r+0x74a>
4201231b:	1621c2        	l32i	a12, a1, 88
4201231e:	1721d2        	l32i	a13, a1, 92
42012321:	babbb1        	l32r	a11, 42000e10 <_stext+0xdf0> (3fe00000 <ets_ops_table_ptr+0x110004>)
42012324:	0a0c      	movi.n	a10, 0
42012326:	bac381        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
42012329:	0008e0        	callx8	a8
4201232c:	0acd      	mov.n	a12, a10
4201232e:	20dbb0        	or	a13, a11, a11
42012331:	61a8      	l32i.n	a10, a1, 24
42012333:	0721b2        	l32i	a11, a1, 28
42012336:	baba81        	l32r	a8, 42000e20 <_stext+0xe00> (400023dc <__ltdf2>)
42012339:	0008e0        	callx8	a8
4201233c:	02ead6        	bgez	a10, 4201236e <_dtoa_r+0x64a>
4201233f:	093c      	movi.n	a9, 48
42012341:	068d      	mov.n	a8, a6
42012343:	660b      	addi.n	a6, a6, -1
42012345:	0006a2        	l8ui	a10, a6, 0
42012348:	f51a97        	beq	a10, a9, 42012341 <_dtoa_r+0x61d>
4201234b:	086d      	mov.n	a6, a8
4201234d:	0183c6        	j	42012960 <_dtoa_r+0xc3c>
42012350:	a80000        	lsi	f0, a0, 0x2a0
42012353:	71b861        	l32r	a6, 41feea34 <_coredump_iram_end+0x1c6ca34>
42012356:	bad3d1        	l32r	a13, 42000ea4 <_stext+0xe84> (40240000 <rom_rx_gain_force+0x239bd4>)
42012359:	1a6182        	s32i	a8, a1, 104
4201235c:	0c0c      	movi.n	a12, 0
4201235e:	bab181        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
42012361:	0008e0        	callx8	a8
42012364:	1a2182        	l32i	a8, a1, 104
42012367:	61a9      	s32i.n	a10, a1, 24
42012369:	71b9      	s32i.n	a11, a1, 28
4201236b:	ffd386        	j	420122bd <_dtoa_r+0x599>
4201236e:	0188      	l32i.n	a8, a1, 0
42012370:	138896        	bltz	a8, 420124ac <_dtoa_r+0x788>
42012373:	e90c      	movi.n	a9, 14
42012375:	729930        	lsi	f3, a9, 0x1c8
42012378:	990b      	addi.n	a9, a9, -1
4201237a:	609090        	neg	a9, a9
4201237d:	749090        	extui	a9, a9, 0, 8
42012380:	128916        	beqz	a9, 420124ac <_dtoa_r+0x788>
42012383:	bac581        	l32r	a8, 42000e98 <_stext+0xe78> (3c029dc0 <__mprec_tens>)
42012386:	b08380        	addx8	a8, a3, a8
42012389:	0848      	l32i.n	a4, a8, 0
4201238b:	1858      	l32i.n	a5, a8, 4
4201238d:	142182        	l32i	a8, a1, 80
42012390:	0108d6        	bgez	a8, 420123a4 <_dtoa_r+0x680>
42012393:	8198      	l32i.n	a9, a1, 32
42012395:	080c      	movi.n	a8, 0
42012397:	728890        	lsi	f9, a8, 0x1c8
4201239a:	880b      	addi.n	a8, a8, -1
4201239c:	608080        	neg	a8, a8
4201239f:	748080        	extui	a8, a8, 0, 8
420123a2:	c8cc      	bnez.n	a8, 420123b2 <_dtoa_r+0x68e>
420123a4:	8188      	l32i.n	a8, a1, 32
420123a6:	721b      	addi.n	a7, a2, 1
420123a8:	828a      	add.n	a8, a2, a8
420123aa:	8189      	s32i.n	a8, a1, 32
420123ac:	000d86        	j	420123e6 <_dtoa_r+0x6c2>
420123af:	000000        	ill
420123b2:	8188      	l32i.n	a8, a1, 32
420123b4:	28ec      	bnez.n	a8, 420123da <_dtoa_r+0x6b6>
420123b6:	babcd1        	l32r	a13, 42000ea8 <_stext+0xe88> (40140000 <rom_rx_gain_force+0x139bd4>)
420123b9:	0c0c      	movi.n	a12, 0
420123bb:	04ad      	mov.n	a10, a4
420123bd:	20b550        	or	a11, a5, a5
420123c0:	ba9981        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
420123c3:	0008e0        	callx8	a8
420123c6:	0acd      	mov.n	a12, a10
420123c8:	0bdd      	mov.n	a13, a11
420123ca:	e1a8      	l32i.n	a10, a1, 56
420123cc:	f1b8      	l32i.n	a11, a1, 60
420123ce:	ba9381        	l32r	a8, 42000e1c <_stext+0xdfc> (400023b8 <__ledf2>)
420123d1:	0008e0        	callx8	a8
420123d4:	021aa6        	blti	a10, 1, 420123da <_dtoa_r+0x6b6>
420123d7:	00c786        	j	420126f9 <_dtoa_r+0x9d5>
420123da:	080c      	movi.n	a8, 0
420123dc:	6189      	s32i.n	a8, a1, 24
420123de:	070c      	movi.n	a7, 0
420123e0:	00c206        	j	420126ec <_dtoa_r+0x9c8>
420123e3:	000000        	ill
420123e6:	e1a8      	l32i.n	a10, a1, 56
420123e8:	f1b8      	l32i.n	a11, a1, 60
420123ea:	04cd      	mov.n	a12, a4
420123ec:	05dd      	mov.n	a13, a5
420123ee:	bab881        	l32r	a8, 42000ed0 <_stext+0xeb0> (40002250 <__divdf3>)
420123f1:	0008e0        	callx8	a8
420123f4:	ba8e81        	l32r	a8, 42000e2c <_stext+0xe0c> (400022d4 <__fixdfsi>)
420123f7:	0008e0        	callx8	a8
420123fa:	61a9      	s32i.n	a10, a1, 24
420123fc:	ba8d81        	l32r	a8, 42000e30 <_stext+0xe10> (40002334 <__floatsidf>)
420123ff:	0008e0        	callx8	a8
42012402:	04cd      	mov.n	a12, a4
42012404:	20d550        	or	a13, a5, a5
42012407:	ba8781        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
4201240a:	0008e0        	callx8	a8
4201240d:	0acd      	mov.n	a12, a10
4201240f:	0bdd      	mov.n	a13, a11
42012411:	e1a8      	l32i.n	a10, a1, 56
42012413:	f1b8      	l32i.n	a11, a1, 60
42012415:	076d      	mov.n	a6, a7
42012417:	ba8781        	l32r	a8, 42000e34 <_stext+0xe14> (400024fc <__subdf3>)
4201241a:	0008e0        	callx8	a8
4201241d:	6198      	l32i.n	a9, a1, 24
4201241f:	870b      	addi.n	a8, a7, -1
42012421:	30c992        	addi	a9, a9, 48
42012424:	004892        	s8i	a9, a8, 0
42012427:	8188      	l32i.n	a8, a1, 32
42012429:	5c9877        	bne	a8, a7, 42012489 <_dtoa_r+0x765>
4201242c:	0acd      	mov.n	a12, a10
4201242e:	0bdd      	mov.n	a13, a11
42012430:	baa781        	l32r	a8, 42000ecc <_stext+0xeac> (40002184 <__adddf3>)
42012433:	0008e0        	callx8	a8
42012436:	04cd      	mov.n	a12, a4
42012438:	05dd      	mov.n	a13, a5
4201243a:	81a9      	s32i.n	a10, a1, 32
4201243c:	91b9      	s32i.n	a11, a1, 36
4201243e:	ba7f81        	l32r	a8, 42000e3c <_stext+0xe1c> (400023a0 <__gtdf2>)
42012441:	0008e0        	callx8	a8
42012444:	241ae6        	bgei	a10, 1, 4201246c <_dtoa_r+0x748>
42012447:	81a8      	l32i.n	a10, a1, 32
42012449:	91b8      	l32i.n	a11, a1, 36
4201244b:	04cd      	mov.n	a12, a4
4201244d:	05dd      	mov.n	a13, a5
4201244f:	ba7681        	l32r	a8, 42000e28 <_stext+0xe08> (4000228c <__eqdf2>)
42012452:	0008e0        	callx8	a8
42012455:	509a56        	bnez	a10, 42012962 <_dtoa_r+0xc3e>
42012458:	6188      	l32i.n	a8, a1, 24
4201245a:	0ee807        	bbsi	a8, 0, 4201246c <_dtoa_r+0x748>
4201245d:	014046        	j	42012962 <_dtoa_r+0xc3e>
42012460:	aa0b      	addi.n	a10, a10, -1
42012462:	facc      	bnez.n	a10, 42012475 <_dtoa_r+0x751>
42012464:	551b      	addi.n	a5, a5, 1
42012466:	093c      	movi.n	a9, 48
42012468:	0004c6        	j	4201247f <_dtoa_r+0x75b>
4201246b:	035d00        	lsi	f0, a13, 12
4201246e:	068d      	mov.n	a8, a6
42012470:	9b3c      	movi.n	a11, 57
42012472:	c0a620        	sub	a10, a6, a2
42012475:	086d      	mov.n	a6, a8
42012477:	880b      	addi.n	a8, a8, -1
42012479:	000892        	l8ui	a9, a8, 0
4201247c:	e019b7        	beq	a9, a11, 42012460 <_dtoa_r+0x73c>
4201247f:	991b      	addi.n	a9, a9, 1
42012481:	004892        	s8i	a9, a8, 0
42012484:	013606        	j	42012960 <_dtoa_r+0xc3c>
42012487:	d10000        	mul16s	a0, a0, a0
4201248a:	0cba86        	j	42015778 <get_reset_reason+0x58>
4201248d:	810c      	movi.n	a1, 8
4201248f:	e0ba65        	call8	41ff3034 <_coredump_iram_end+0x1c71034>
42012492:	0008      	l32i.n	a0, a0, 0
42012494:	e1a9      	s32i.n	a10, a1, 56
42012496:	f1b9      	s32i.n	a11, a1, 60
42012498:	0c0c      	movi.n	a12, 0
4201249a:	0d0c      	movi.n	a13, 0
4201249c:	771b      	addi.n	a7, a7, 1
4201249e:	ba6281        	l32r	a8, 42000e28 <_stext+0xe08> (4000228c <__eqdf2>)
420124a1:	0008e0        	callx8	a8
420124a4:	f3ea56        	bnez	a10, 420123e6 <_dtoa_r+0x6c2>
420124a7:	012dc6        	j	42012962 <_dtoa_r+0xc3e>
420124aa:	920000        	lsi	f0, a0, 0x248
420124ad:	581021        	l32r	a2, 41fe84f0 <_coredump_iram_end+0x1c664f0>
420124b0:	046dd1        	l32r	a13, 41fd3664 <_coredump_iram_end+0x1c51664>
420124b3:	070c      	movi.n	a7, 0
420124b5:	069916        	beqz	a9, 42012522 <_dtoa_r+0x7fe>
420124b8:	c198      	l32i.n	a9, a1, 48
420124ba:	1a29e6        	bgei	a9, 2, 420124d8 <_dtoa_r+0x7b4>
420124bd:	182192        	l32i	a9, a1, 96
420124c0:	698c      	beqz.n	a9, 420124ca <_dtoa_r+0x7a6>
420124c2:	33a492        	movi	a9, 0x433
420124c5:	889a      	add.n	a8, a8, a9
420124c7:	0010c6        	j	4201250e <_dtoa_r+0x7ea>
420124ca:	1188      	l32i.n	a8, a1, 4
420124cc:	d158      	l32i.n	a5, a1, 52
420124ce:	cac882        	addi	a8, a8, -54
420124d1:	608080        	neg	a8, a8
420124d4:	000d86        	j	4201250e <_dtoa_r+0x7ea>
420124d7:	818800        	src	a8, a8, a0
420124da:	580b      	addi.n	a5, a8, -1
420124dc:	d188      	l32i.n	a8, a1, 52
420124de:	182857        	blt	a8, a5, 420124fa <_dtoa_r+0x7d6>
420124e1:	c05850        	sub	a5, a8, a5
420124e4:	8198      	l32i.n	a9, a1, 32
420124e6:	8188      	l32i.n	a8, a1, 32
420124e8:	c06480        	sub	a6, a4, a8
420124eb:	080c      	movi.n	a8, 0
420124ed:	01d996        	bltz	a9, 4201250e <_dtoa_r+0x7ea>
420124f0:	046d      	mov.n	a6, a4
420124f2:	098d      	mov.n	a8, a9
420124f4:	000586        	j	4201250e <_dtoa_r+0x7ea>
420124f7:	000000        	ill
420124fa:	d188      	l32i.n	a8, a1, 52
420124fc:	112192        	l32i	a9, a1, 68
420124ff:	c08580        	sub	a8, a5, a8
42012502:	898a      	add.n	a8, a9, a8
42012504:	116182        	s32i	a8, a1, 68
42012507:	8188      	l32i.n	a8, a1, 32
42012509:	d159      	s32i.n	a5, a1, 52
4201250b:	00a052        	movi	a5, 0
4201250e:	a198      	l32i.n	a9, a1, 40
42012510:	41a8      	l32i.n	a10, a1, 16
42012512:	448a      	add.n	a4, a4, a8
42012514:	1b0c      	movi.n	a11, 1
42012516:	898a      	add.n	a8, a9, a8
42012518:	a189      	s32i.n	a8, a1, 40
4201251a:	201110        	or	a1, a1, a1
4201251d:	0073a5        	call8	42012c58 <__i2b>
42012520:	0a7d      	mov.n	a7, a10
42012522:	080c      	movi.n	a8, 0
42012524:	269c      	beqz.n	a6, 4201253a <_dtoa_r+0x816>
42012526:	a198      	l32i.n	a9, a1, 40
42012528:	0ea897        	bge	a8, a9, 4201253a <_dtoa_r+0x816>
4201252b:	438690        	min	a8, a6, a9
4201252e:	c04480        	sub	a4, a4, a8
42012531:	c06680        	sub	a6, a6, a8
42012534:	c08980        	sub	a8, a9, a8
42012537:	0a6182        	s32i	a8, a1, 40
4201253a:	d188      	l32i.n	a8, a1, 52
4201253c:	056816        	beqz	a8, 42012596 <_dtoa_r+0x872>
4201253f:	102182        	l32i	a8, a1, 64
42012542:	042816        	beqz	a8, 42012588 <_dtoa_r+0x864>
42012545:	5188      	l32i.n	a8, a1, 20
42012547:	55bc      	beqz.n	a5, 42012580 <_dtoa_r+0x85c>
42012549:	41a8      	l32i.n	a10, a1, 16
4201254b:	07bd      	mov.n	a11, a7
4201254d:	20c550        	or	a12, a5, a5
42012550:	201110        	or	a1, a1, a1
42012553:	008aa5        	call8	42012dfc <__pow5mult>
42012556:	0abd      	mov.n	a11, a10
42012558:	51c8      	l32i.n	a12, a1, 20
4201255a:	0a7d      	mov.n	a7, a10
4201255c:	0421a2        	l32i	a10, a1, 16
4201255f:	201110        	or	a1, a1, a1
42012562:	0071e5        	call8	42012c80 <__multiply>
42012565:	61a9      	s32i.n	a10, a1, 24
42012567:	51b8      	l32i.n	a11, a1, 20
42012569:	41a8      	l32i.n	a10, a1, 16
4201256b:	201110        	or	a1, a1, a1
4201256e:	004d25        	call8	42012a40 <_Bfree>
42012571:	d188      	l32i.n	a8, a1, 52
42012573:	c08850        	sub	a8, a8, a5
42012576:	d189      	s32i.n	a8, a1, 52
42012578:	6188      	l32i.n	a8, a1, 24
4201257a:	d198      	l32i.n	a9, a1, 52
4201257c:	5189      	s32i.n	a8, a1, 20
4201257e:	499c      	beqz.n	a9, 42012596 <_dtoa_r+0x872>
42012580:	d1c8      	l32i.n	a12, a1, 52
42012582:	08bd      	mov.n	a11, a8
42012584:	000106        	j	4201258c <_dtoa_r+0x868>
42012587:	d1c800        	mul16s	a12, a8, a0
4201258a:	51b8      	l32i.n	a11, a1, 20
4201258c:	41a8      	l32i.n	a10, a1, 16
4201258e:	201110        	or	a1, a1, a1
42012591:	0086a5        	call8	42012dfc <__pow5mult>
42012594:	51a9      	s32i.n	a10, a1, 20
42012596:	41a8      	l32i.n	a10, a1, 16
42012598:	01a0b2        	movi	a11, 1
4201259b:	201110        	or	a1, a1, a1
4201259e:	006ba5        	call8	42012c58 <__i2b>
420125a1:	112182        	l32i	a8, a1, 68
420125a4:	61a9      	s32i.n	a10, a1, 24
420125a6:	3fa816        	beqz	a8, 420129a4 <_dtoa_r+0xc80>
420125a9:	0abd      	mov.n	a11, a10
420125ab:	41a8      	l32i.n	a10, a1, 16
420125ad:	08cd      	mov.n	a12, a8
420125af:	201110        	or	a1, a1, a1
420125b2:	0084a5        	call8	42012dfc <__pow5mult>
420125b5:	080c      	movi.n	a8, 0
420125b7:	e189      	s32i.n	a8, a1, 56
420125b9:	0c2182        	l32i	a8, a1, 48
420125bc:	61a9      	s32i.n	a10, a1, 24
420125be:	2e28e6        	bgei	a8, 2, 420125f0 <_dtoa_r+0x8cc>
420125c1:	080c      	movi.n	a8, 0
420125c3:	e189      	s32i.n	a8, a1, 56
420125c5:	122182        	l32i	a8, a1, 72
420125c8:	d8dc      	bnez.n	a8, 420125e9 <_dtoa_r+0x8c5>
420125ca:	132182        	l32i	a8, a1, 76
420125cd:	118840        	slli	a8, a8, 12
420125d0:	58dc      	bnez.n	a8, 420125e9 <_dtoa_r+0x8c5>
420125d2:	132182        	l32i	a8, a1, 76
420125d5:	a58480        	extui	a8, a8, 20, 11
420125d8:	d88c      	beqz.n	a8, 420125e9 <_dtoa_r+0x8c5>
420125da:	a188      	l32i.n	a8, a1, 40
420125dc:	441b      	addi.n	a4, a4, 1
420125de:	881b      	addi.n	a8, a8, 1
420125e0:	0a6182        	s32i	a8, a1, 40
420125e3:	01a082        	movi	a8, 1
420125e6:	0e6182        	s32i	a8, a1, 56
420125e9:	112182        	l32i	a8, a1, 68
420125ec:	1a0c      	movi.n	a10, 1
420125ee:	589c      	beqz.n	a8, 42012607 <_dtoa_r+0x8e3>
420125f0:	6188      	l32i.n	a8, a1, 24
420125f2:	6198      	l32i.n	a9, a1, 24
420125f4:	4888      	l32i.n	a8, a8, 16
420125f6:	a08890        	addx4	a8, a8, a9
420125f9:	48a8      	l32i.n	a10, a8, 16
420125fb:	201110        	or	a1, a1, a1
420125fe:	0059e5        	call8	42012b9c <__hi0bits>
42012601:	e0caa2        	addi	a10, a10, -32
42012604:	60a0a0        	neg	a10, a10
42012607:	a188      	l32i.n	a8, a1, 40
42012609:	aa8a      	add.n	a10, a10, a8
4201260b:	44a0a0        	extui	a10, a10, 0, 5
4201260e:	0aac      	beqz.n	a10, 42012632 <_dtoa_r+0x90e>
42012610:	e0ca82        	addi	a8, a10, -32
42012613:	608080        	neg	a8, a8
42012616:	1258a6        	blti	a8, 5, 4201262c <_dtoa_r+0x908>
42012619:	a188      	l32i.n	a8, a1, 40
4201261b:	e4caa2        	addi	a10, a10, -28
4201261e:	60a0a0        	neg	a10, a10
42012621:	44aa      	add.n	a4, a4, a10
42012623:	66aa      	add.n	a6, a6, a10
42012625:	88aa      	add.n	a8, a8, a10
42012627:	000506        	j	4201263f <_dtoa_r+0x91b>
4201262a:	260000        	lsi	f0, a0, 152
4201262d:	1148      	l32i.n	a4, a1, 4
4201262f:	000046        	j	42012634 <_dtoa_r+0x910>
42012632:	080c      	movi.n	a8, 0
42012634:	a198      	l32i.n	a9, a1, 40
42012636:	1cc882        	addi	a8, a8, 28
42012639:	448a      	add.n	a4, a4, a8
4201263b:	668a      	add.n	a6, a6, a8
4201263d:	898a      	add.n	a8, a9, a8
4201263f:	a189      	s32i.n	a8, a1, 40
42012641:	0d14a6        	blti	a4, 1, 42012652 <_dtoa_r+0x92e>
42012644:	51b8      	l32i.n	a11, a1, 20
42012646:	41a8      	l32i.n	a10, a1, 16
42012648:	04cd      	mov.n	a12, a4
4201264a:	201110        	or	a1, a1, a1
4201264d:	0085a5        	call8	42012ea8 <__lshift>
42012650:	51a9      	s32i.n	a10, a1, 20
42012652:	a188      	l32i.n	a8, a1, 40
42012654:	1118a6        	blti	a8, 1, 42012669 <_dtoa_r+0x945>
42012657:	0621b2        	l32i	a11, a1, 24
4201265a:	0421a2        	l32i	a10, a1, 16
4201265d:	20c880        	or	a12, a8, a8
42012660:	201110        	or	a1, a1, a1
42012663:	008465        	call8	42012ea8 <__lshift>
42012666:	0661a2        	s32i	a10, a1, 24
42012669:	152182        	l32i	a8, a1, 84
4201266c:	c88c      	beqz.n	a8, 4201267c <_dtoa_r+0x958>
4201266e:	61b8      	l32i.n	a11, a1, 24
42012670:	0521a2        	l32i	a10, a1, 20
42012673:	201110        	or	a1, a1, a1
42012676:	0093a5        	call8	42012fb0 <__mcmp>
42012679:	009a96        	bltz	a10, 42012686 <_dtoa_r+0x962>
4201267c:	8188      	l32i.n	a8, a1, 32
4201267e:	035d      	mov.n	a5, a3
42012680:	b189      	s32i.n	a8, a1, 44
42012682:	000ac6        	j	420126b1 <_dtoa_r+0x98d>
42012685:	51b800        	lsi	f0, a8, 0x144
42012688:	41a8      	l32i.n	a10, a1, 16
4201268a:	0d0c      	movi.n	a13, 0
4201268c:	0aa0c2        	movi	a12, 10
4201268f:	201110        	or	a1, a1, a1
42012692:	003ee5        	call8	42012a80 <__multadd>
42012695:	102182        	l32i	a8, a1, 64
42012698:	51a9      	s32i.n	a10, a1, 20
4201269a:	530b      	addi.n	a5, a3, -1
4201269c:	189c      	beqz.n	a8, 420126b1 <_dtoa_r+0x98d>
4201269e:	41a8      	l32i.n	a10, a1, 16
420126a0:	07bd      	mov.n	a11, a7
420126a2:	00a0d2        	movi	a13, 0
420126a5:	0aa0c2        	movi	a12, 10
420126a8:	201110        	or	a1, a1, a1
420126ab:	003d65        	call8	42012a80 <__multadd>
420126ae:	207aa0        	or	a7, a10, a10
420126b1:	b198      	l32i.n	a9, a1, 44
420126b3:	080c      	movi.n	a8, 0
420126b5:	728890        	lsi	f9, a8, 0x1c8
420126b8:	880b      	addi.n	a8, a8, -1
420126ba:	608080        	neg	a8, a8
420126bd:	748080        	extui	a8, a8, 0, 8
420126c0:	04d816        	beqz	a8, 42012711 <_dtoa_r+0x9ed>
420126c3:	c198      	l32i.n	a9, a1, 48
420126c5:	280c      	movi.n	a8, 2
420126c7:	46a897        	bge	a8, a9, 42012711 <_dtoa_r+0x9ed>
420126ca:	b188      	l32i.n	a8, a1, 44
420126cc:	c8dc      	bnez.n	a8, 420126ec <_dtoa_r+0x9c8>
420126ce:	61b8      	l32i.n	a11, a1, 24
420126d0:	41a8      	l32i.n	a10, a1, 16
420126d2:	0d0c      	movi.n	a13, 0
420126d4:	05a0c2        	movi	a12, 5
420126d7:	201110        	or	a1, a1, a1
420126da:	003a65        	call8	42012a80 <__multadd>
420126dd:	61a9      	s32i.n	a10, a1, 24
420126df:	0abd      	mov.n	a11, a10
420126e1:	51a8      	l32i.n	a10, a1, 20
420126e3:	201110        	or	a1, a1, a1
420126e6:	008ca5        	call8	42012fb0 <__mcmp>
420126e9:	141ae6        	bgei	a10, 1, 42012701 <_dtoa_r+0x9dd>
420126ec:	142192        	l32i	a9, a1, 80
420126ef:	f87c      	movi.n	a8, -1
420126f1:	305980        	xor	a5, a9, a8
420126f4:	026d      	mov.n	a6, a2
420126f6:	000406        	j	4201270a <_dtoa_r+0x9e6>
420126f9:	035d      	mov.n	a5, a3
420126fb:	080c      	movi.n	a8, 0
420126fd:	6189      	s32i.n	a8, a1, 24
420126ff:	070c      	movi.n	a7, 0
42012701:	183c      	movi.n	a8, 49
42012703:	621b      	addi.n	a6, a2, 1
42012705:	004282        	s8i	a8, a2, 0
42012708:	551b      	addi.n	a5, a5, 1
4201270a:	074d      	mov.n	a4, a7
4201270c:	070c      	movi.n	a7, 0
4201270e:	008a06        	j	4201293a <_dtoa_r+0xc16>
42012711:	102182        	l32i	a8, a1, 64
42012714:	189816        	beqz	a8, 420128a1 <_dtoa_r+0xb7d>
42012717:	0d16a6        	blti	a6, 1, 42012728 <_dtoa_r+0xa04>
4201271a:	41a8      	l32i.n	a10, a1, 16
4201271c:	07bd      	mov.n	a11, a7
4201271e:	06cd      	mov.n	a12, a6
42012720:	201110        	or	a1, a1, a1
42012723:	007865        	call8	42012ea8 <__lshift>
42012726:	0a7d      	mov.n	a7, a10
42012728:	e188      	l32i.n	a8, a1, 56
4201272a:	074d      	mov.n	a4, a7
4201272c:	88bc      	beqz.n	a8, 42012768 <_dtoa_r+0xa44>
4201272e:	17b8      	l32i.n	a11, a7, 4
42012730:	41a8      	l32i.n	a10, a1, 16
42012732:	201110        	or	a1, a1, a1
42012735:	002825        	call8	420129b8 <_Balloc>
42012738:	0a6d      	mov.n	a6, a10
4201273a:	aacc      	bnez.n	a10, 42012748 <_dtoa_r+0xa24>
4201273c:	b9d8d1        	l32r	a13, 42000e9c <_stext+0xe7c> (3c029660 <_ZTISt12out_of_range+0x1d4>)
4201273f:	0c0c      	movi.n	a12, 0
42012741:	efa2b2        	movi	a11, 0x2ef
42012744:	fe2f06        	j	42012004 <_dtoa_r+0x2e0>
42012747:	47c800        	lsi	f0, a8, 0x11c
4201274a:	b7cb      	addi.n	a11, a7, 12
4201274c:	cc2b      	addi.n	a12, a12, 2
4201274e:	11cce0        	slli	a12, a12, 2
42012751:	0ccaa2        	addi	a10, a10, 12
42012754:	b63581        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42012757:	0008e0        	callx8	a8
4201275a:	41a8      	l32i.n	a10, a1, 16
4201275c:	1c0c      	movi.n	a12, 1
4201275e:	06bd      	mov.n	a11, a6
42012760:	201110        	or	a1, a1, a1
42012763:	007465        	call8	42012ea8 <__lshift>
42012766:	0a4d      	mov.n	a4, a10
42012768:	b1a8      	l32i.n	a10, a1, 44
4201276a:	820b      	addi.n	a8, a2, -1
4201276c:	88aa      	add.n	a8, a8, a10
4201276e:	e189      	s32i.n	a8, a1, 56
42012770:	122182        	l32i	a8, a1, 72
42012773:	029d      	mov.n	a9, a2
42012775:	048080        	extui	a8, a8, 0, 1
42012778:	b189      	s32i.n	a8, a1, 44
4201277a:	61b8      	l32i.n	a11, a1, 24
4201277c:	0521a2        	l32i	a10, a1, 20
4201277f:	d199      	s32i.n	a9, a1, 52
42012781:	ff46a5        	call8	42011bec <quorem>
42012784:	81a9      	s32i.n	a10, a1, 32
42012786:	30ca32        	addi	a3, a10, 48
42012789:	0521a2        	l32i	a10, a1, 20
4201278c:	07bd      	mov.n	a11, a7
4201278e:	201110        	or	a1, a1, a1
42012791:	0081e5        	call8	42012fb0 <__mcmp>
42012794:	a1a9      	s32i.n	a10, a1, 40
42012796:	61b8      	l32i.n	a11, a1, 24
42012798:	41a8      	l32i.n	a10, a1, 16
4201279a:	04cd      	mov.n	a12, a4
4201279c:	201110        	or	a1, a1, a1
4201279f:	0084e5        	call8	42012fec <__mdiff>
420127a2:	0a6d      	mov.n	a6, a10
420127a4:	3aa8      	l32i.n	a10, a10, 12
420127a6:	1021c2        	l32i	a12, a1, 64
420127a9:	d198      	l32i.n	a9, a1, 52
420127ab:	eacc      	bnez.n	a10, 420127bd <_dtoa_r+0xa99>
420127ad:	51a8      	l32i.n	a10, a1, 20
420127af:	20b660        	or	a11, a6, a6
420127b2:	201110        	or	a1, a1, a1
420127b5:	007fa5        	call8	42012fb0 <__mcmp>
420127b8:	d198      	l32i.n	a9, a1, 52
420127ba:	20caa0        	or	a12, a10, a10
420127bd:	41a8      	l32i.n	a10, a1, 16
420127bf:	06bd      	mov.n	a11, a6
420127c1:	116192        	s32i	a9, a1, 68
420127c4:	d1c9      	s32i.n	a12, a1, 52
420127c6:	201110        	or	a1, a1, a1
420127c9:	002765        	call8	42012a40 <_Bfree>
420127cc:	c188      	l32i.n	a8, a1, 48
420127ce:	d1c8      	l32i.n	a12, a1, 52
420127d0:	112192        	l32i	a9, a1, 68
420127d3:	20a8c0        	or	a10, a8, a12
420127d6:	b188      	l32i.n	a8, a1, 44
420127d8:	691b      	addi.n	a6, a9, 1
420127da:	20aa80        	or	a10, a10, a8
420127dd:	cacc      	bnez.n	a10, 420127ed <_dtoa_r+0xac9>
420127df:	9a3c      	movi.n	a10, 57
420127e1:	5b13a7        	beq	a3, a10, 42012840 <_dtoa_r+0xb1c>
420127e4:	a188      	l32i.n	a8, a1, 40
420127e6:	4618a6        	blti	a8, 1, 42012830 <_dtoa_r+0xb0c>
420127e9:	000f86        	j	4201282b <_dtoa_r+0xb07>
420127ec:	a18800        	sll	a8, a8
420127ef:	00d896        	bltz	a8, 42012800 <_dtoa_r+0xadc>
420127f2:	a1a8      	l32i.n	a10, a1, 40
420127f4:	c188      	l32i.n	a8, a1, 48
420127f6:	2088a0        	or	a8, a8, a10
420127f9:	b1a8      	l32i.n	a10, a1, 44
420127fb:	2088a0        	or	a8, a8, a10
420127fe:	68fc      	bnez.n	a8, 42012838 <_dtoa_r+0xb14>
42012800:	2c1ca6        	blti	a12, 1, 42012830 <_dtoa_r+0xb0c>
42012803:	51b8      	l32i.n	a11, a1, 20
42012805:	41a8      	l32i.n	a10, a1, 16
42012807:	1c0c      	movi.n	a12, 1
42012809:	0a6192        	s32i	a9, a1, 40
4201280c:	201110        	or	a1, a1, a1
4201280f:	0069a5        	call8	42012ea8 <__lshift>
42012812:	61b8      	l32i.n	a11, a1, 24
42012814:	51a9      	s32i.n	a10, a1, 20
42012816:	201110        	or	a1, a1, a1
42012819:	007965        	call8	42012fb0 <__mcmp>
4201281c:	a198      	l32i.n	a9, a1, 40
4201281e:	041ae6        	bgei	a10, 1, 42012826 <_dtoa_r+0xb02>
42012821:	bacc      	bnez.n	a10, 42012830 <_dtoa_r+0xb0c>
42012823:	096307        	bbci	a3, 0, 42012830 <_dtoa_r+0xb0c>
42012826:	9a3c      	movi.n	a10, 57
42012828:	1413a7        	beq	a3, a10, 42012840 <_dtoa_r+0xb1c>
4201282b:	8188      	l32i.n	a8, a1, 32
4201282d:	31c832        	addi	a3, a8, 49
42012830:	004932        	s8i	a3, a9, 0
42012833:	0040c6        	j	4201293a <_dtoa_r+0xc16>
42012836:	a60000        	lsi	f0, a0, 0x298
42012839:	141c      	movi.n	a4, 17
4201283b:	9a3c      	movi.n	a10, 57
4201283d:	0793a7        	bne	a3, a10, 42012848 <_dtoa_r+0xb24>
42012840:	983c      	movi.n	a8, 57
42012842:	004982        	s8i	a8, a9, 0
42012845:	003246        	j	42012912 <_dtoa_r+0xbee>
42012848:	831b      	addi.n	a8, a3, 1
4201284a:	004982        	s8i	a8, a9, 0
4201284d:	003a46        	j	4201293a <_dtoa_r+0xc16>
42012850:	e188      	l32i.n	a8, a1, 56
42012852:	004932        	s8i	a3, a9, 0
42012855:	029897        	bne	a8, a9, 4201285b <_dtoa_r+0xb37>
42012858:	002106        	j	420128e0 <_dtoa_r+0xbbc>
4201285b:	51b8      	l32i.n	a11, a1, 20
4201285d:	41a8      	l32i.n	a10, a1, 16
4201285f:	0d0c      	movi.n	a13, 0
42012861:	ac0c      	movi.n	a12, 10
42012863:	201110        	or	a1, a1, a1
42012866:	0021a5        	call8	42012a80 <__multadd>
42012869:	51a9      	s32i.n	a10, a1, 20
4201286b:	0d0c      	movi.n	a13, 0
4201286d:	41a8      	l32i.n	a10, a1, 16
4201286f:	ac0c      	movi.n	a12, 10
42012871:	07bd      	mov.n	a11, a7
42012873:	0d9747        	bne	a7, a4, 42012884 <_dtoa_r+0xb60>
42012876:	201110        	or	a1, a1, a1
42012879:	002065        	call8	42012a80 <__multadd>
4201287c:	0a7d      	mov.n	a7, a10
4201287e:	0a4d      	mov.n	a4, a10
42012880:	000606        	j	4201289c <_dtoa_r+0xb78>
42012883:	111000        	slli	a1, a0, 16
42012886:	1fa520        	f64cmph	a10, a5, a2, 1
42012889:	0a7d00        	add.s	f7, f13, f0
4201288c:	41a8      	l32i.n	a10, a1, 16
4201288e:	04bd      	mov.n	a11, a4
42012890:	0d0c      	movi.n	a13, 0
42012892:	ac0c      	movi.n	a12, 10
42012894:	201110        	or	a1, a1, a1
42012897:	001ea5        	call8	42012a80 <__multadd>
4201289a:	0a4d      	mov.n	a4, a10
4201289c:	069d      	mov.n	a9, a6
4201289e:	ffb606        	j	4201277a <_dtoa_r+0xa56>
420128a1:	060c      	movi.n	a6, 0
420128a3:	61b8      	l32i.n	a11, a1, 24
420128a5:	51a8      	l32i.n	a10, a1, 20
420128a7:	ff3465        	call8	42011bec <quorem>
420128aa:	926a      	add.n	a9, a2, a6
420128ac:	30ca32        	addi	a3, a10, 48
420128af:	b188      	l32i.n	a8, a1, 44
420128b1:	004932        	s8i	a3, a9, 0
420128b4:	661b      	addi.n	a6, a6, 1
420128b6:	13a687        	bge	a6, a8, 420128cd <_dtoa_r+0xba9>
420128b9:	51b8      	l32i.n	a11, a1, 20
420128bb:	41a8      	l32i.n	a10, a1, 16
420128bd:	0d0c      	movi.n	a13, 0
420128bf:	0aa0c2        	movi	a12, 10
420128c2:	201110        	or	a1, a1, a1
420128c5:	001ba5        	call8	42012a80 <__multadd>
420128c8:	51a9      	s32i.n	a10, a1, 20
420128ca:	fff546        	j	420128a3 <_dtoa_r+0xb7f>
420128cd:	b188      	l32i.n	a8, a1, 44
420128cf:	090c      	movi.n	a9, 0
420128d1:	060c      	movi.n	a6, 0
420128d3:	01a987        	bge	a9, a8, 420128d8 <_dtoa_r+0xbb4>
420128d6:	680b      	addi.n	a6, a8, -1
420128d8:	921b      	addi.n	a9, a2, 1
420128da:	074d      	mov.n	a4, a7
420128dc:	669a      	add.n	a6, a6, a9
420128de:	070c      	movi.n	a7, 0
420128e0:	51b8      	l32i.n	a11, a1, 20
420128e2:	0421a2        	l32i	a10, a1, 16
420128e5:	01a0c2        	movi	a12, 1
420128e8:	201110        	or	a1, a1, a1
420128eb:	005be5        	call8	42012ea8 <__lshift>
420128ee:	61b8      	l32i.n	a11, a1, 24
420128f0:	51a9      	s32i.n	a10, a1, 20
420128f2:	201110        	or	a1, a1, a1
420128f5:	006ba5        	call8	42012fb0 <__mcmp>
420128f8:	161ae6        	bgei	a10, 1, 42012912 <_dtoa_r+0xbee>
420128fb:	daec      	bnez.n	a10, 4201292c <_dtoa_r+0xc08>
420128fd:	11e307        	bbsi	a3, 0, 42012912 <_dtoa_r+0xbee>
42012900:	000a06        	j	4201292c <_dtoa_r+0xc08>
42012903:	aa0b00        	floor.s	a0, f11, 0
42012906:	facc      	bnez.n	a10, 42012919 <_dtoa_r+0xbf5>
42012908:	183c      	movi.n	a8, 49
4201290a:	551b      	addi.n	a5, a5, 1
4201290c:	004282        	s8i	a8, a2, 0
4201290f:	0009c6        	j	4201293a <_dtoa_r+0xc16>
42012912:	068d      	mov.n	a8, a6
42012914:	9b3c      	movi.n	a11, 57
42012916:	c0a620        	sub	a10, a6, a2
42012919:	086d      	mov.n	a6, a8
4201291b:	880b      	addi.n	a8, a8, -1
4201291d:	000892        	l8ui	a9, a8, 0
42012920:	e019b7        	beq	a9, a11, 42012904 <_dtoa_r+0xbe0>
42012923:	991b      	addi.n	a9, a9, 1
42012925:	004892        	s8i	a9, a8, 0
42012928:	000386        	j	4201293a <_dtoa_r+0xc16>
4201292b:	068d00        	lsi	f0, a13, 24
4201292e:	093c      	movi.n	a9, 48
42012930:	086d      	mov.n	a6, a8
42012932:	880b      	addi.n	a8, a8, -1
42012934:	0008a2        	l8ui	a10, a8, 0
42012937:	f51a97        	beq	a10, a9, 42012930 <_dtoa_r+0xc0c>
4201293a:	61b8      	l32i.n	a11, a1, 24
4201293c:	41a8      	l32i.n	a10, a1, 16
4201293e:	201110        	or	a1, a1, a1
42012941:	000fe5        	call8	42012a40 <_Bfree>
42012944:	849c      	beqz.n	a4, 42012960 <_dtoa_r+0xc3c>
42012946:	c78c      	beqz.n	a7, 42012956 <_dtoa_r+0xc32>
42012948:	0a1747        	beq	a7, a4, 42012956 <_dtoa_r+0xc32>
4201294b:	41a8      	l32i.n	a10, a1, 16
4201294d:	20b770        	or	a11, a7, a7
42012950:	201110        	or	a1, a1, a1
42012953:	000ee5        	call8	42012a40 <_Bfree>
42012956:	41a8      	l32i.n	a10, a1, 16
42012958:	04bd      	mov.n	a11, a4
4201295a:	201110        	or	a1, a1, a1
4201295d:	000e25        	call8	42012a40 <_Bfree>
42012960:	053d      	mov.n	a3, a5
42012962:	51b8      	l32i.n	a11, a1, 20
42012964:	41a8      	l32i.n	a10, a1, 16
42012966:	201110        	or	a1, a1, a1
42012969:	000d65        	call8	42012a40 <_Bfree>
4201296c:	080c      	movi.n	a8, 0
4201296e:	242192        	l32i	a9, a1, 144
42012971:	004682        	s8i	a8, a6, 0
42012974:	831b      	addi.n	a8, a3, 1
42012976:	0989      	s32i.n	a8, a9, 0
42012978:	262182        	l32i	a8, a1, 152
4201297b:	68bc      	beqz.n	a8, 420129b5 <_dtoa_r+0xc91>
4201297d:	0869      	s32i.n	a6, a8, 0
4201297f:	000c86        	j	420129b5 <_dtoa_r+0xc91>
42012982:	920000        	lsi	f0, a0, 0x248
42012985:	212621        	l32r	a2, 41fdae20 <_coredump_iram_end+0x1c58e20>
42012988:	b93b      	addi.n	a11, a9, 3
4201298a:	b93b81        	l32r	a8, 42000e78 <_stext+0xe58> (3c0295f0 <_ZTISt12out_of_range+0x164>)
4201298d:	198c      	beqz.n	a9, 42012992 <_dtoa_r+0xc6e>
4201298f:	fd0c46        	j	42011dc4 <_dtoa_r+0xa0>
42012992:	0007c6        	j	420129b5 <_dtoa_r+0xc91>
42012995:	218200        	srai	a8, a0, 2
42012998:	382126        	beqi	a1, 2, 420129d4 <_Balloc+0x1c>
4201299b:	8cb9      	s32i.n	a11, a12, 32
4201299d:	c618      	l32i.n	a1, a6, 48
4201299f:	06fd07        	bbsi	a13, 16, 420129a9 <_dtoa_r+0xc85>
420129a2:	880004        	lsi	f0, a0, 0x220
420129a5:	28e6c1        	l32r	a12, 41fdcd40 <_coredump_iram_end+0x1c5ad40>
420129a8:	050602        	l8ui	a0, a6, 5
420129ab:	ff          	.byte	0xff
420129ac:	080c      	movi.n	a8, 0
420129ae:	e189      	s32i.n	a8, a1, 56
420129b0:	1a0c      	movi.n	a10, 1
420129b2:	ff1446        	j	42012607 <_dtoa_r+0x8e3>
420129b5:	f01d      	retw.n
	...

420129b8 <_Balloc>:
420129b8:	004136        	entry	a1, 32
420129bb:	9278      	l32i.n	a7, a2, 36
420129bd:	026d      	mov.n	a6, a2
420129bf:	77ec      	bnez.n	a7, 420129ea <_Balloc+0x32>
420129c1:	0a1c      	movi.n	a10, 16
420129c3:	b77081        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
420129c6:	0008e0        	callx8	a8
420129c9:	92a9      	s32i.n	a10, a2, 36
420129cb:	0a7d      	mov.n	a7, a10
420129cd:	facc      	bnez.n	a10, 420129e0 <_Balloc+0x28>
420129cf:	b941d1        	l32r	a13, 42000ed4 <_stext+0xeb4> (3c0295f5 <_ZTISt12out_of_range+0x169>)
420129d2:	b941a1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
420129d5:	0c0c      	movi.n	a12, 0
420129d7:	6ba0b2        	movi	a11, 107
420129da:	b5b981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420129dd:	0008e0        	callx8	a8
420129e0:	080c      	movi.n	a8, 0
420129e2:	1a89      	s32i.n	a8, a10, 4
420129e4:	2a89      	s32i.n	a8, a10, 8
420129e6:	0a89      	s32i.n	a8, a10, 0
420129e8:	3a89      	s32i.n	a8, a10, 12
420129ea:	3788      	l32i.n	a8, a7, 12
420129ec:	88dc      	bnez.n	a8, 42012a08 <_Balloc+0x50>
420129ee:	1c2c      	movi.n	a12, 33
420129f0:	4b0c      	movi.n	a11, 4
420129f2:	06ad      	mov.n	a10, a6
420129f4:	b93a81        	l32r	a8, 42000edc <_stext+0xebc> (4037ff00 <_calloc_r>)
420129f7:	0008e0        	callx8	a8
420129fa:	9688      	l32i.n	a8, a6, 36
420129fc:	37a9      	s32i.n	a10, a7, 12
420129fe:	3888      	l32i.n	a8, a8, 12
42012a00:	48cc      	bnez.n	a8, 42012a08 <_Balloc+0x50>
42012a02:	020c      	movi.n	a2, 0
42012a04:	000d06        	j	42012a3c <_Balloc+0x84>
42012a07:	838000        	moveqz	a8, a0, a0
42012a0a:	0828a0        	lsx	f2, a8, a10
42012a0d:	528c      	beqz.n	a2, 42012a16 <_Balloc+0x5e>
42012a0f:	0298      	l32i.n	a9, a2, 0
42012a11:	0899      	s32i.n	a9, a8, 0
42012a13:	0007c6        	j	42012a36 <_Balloc+0x7e>
42012a16:	170c      	movi.n	a7, 1
42012a18:	401300        	ssl	a3
42012a1b:	a17700        	sll	a7, a7
42012a1e:	c75b      	addi.n	a12, a7, 5
42012a20:	11cce0        	slli	a12, a12, 2
42012a23:	1b0c      	movi.n	a11, 1
42012a25:	06ad      	mov.n	a10, a6
42012a27:	b92d81        	l32r	a8, 42000edc <_stext+0xebc> (4037ff00 <_calloc_r>)
42012a2a:	0008e0        	callx8	a8
42012a2d:	0a2d      	mov.n	a2, a10
42012a2f:	fcfa16        	beqz	a10, 42012a02 <_Balloc+0x4a>
42012a32:	1a39      	s32i.n	a3, a10, 4
42012a34:	2a79      	s32i.n	a7, a10, 8
42012a36:	080c      	movi.n	a8, 0
42012a38:	4289      	s32i.n	a8, a2, 16
42012a3a:	3289      	s32i.n	a8, a2, 12
42012a3c:	f01d      	retw.n
	...

42012a40 <_Bfree>:
42012a40:	004136        	entry	a1, 32
42012a43:	9278      	l32i.n	a7, a2, 36
42012a45:	47ec      	bnez.n	a7, 42012a6d <_Bfree+0x2d>
42012a47:	10a0a2        	movi	a10, 16
42012a4a:	b74e81        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
42012a4d:	0008e0        	callx8	a8
42012a50:	92a9      	s32i.n	a10, a2, 36
42012a52:	facc      	bnez.n	a10, 42012a65 <_Bfree+0x25>
42012a54:	b920d1        	l32r	a13, 42000ed4 <_stext+0xeb4> (3c0295f5 <_ZTISt12out_of_range+0x169>)
42012a57:	b920a1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42012a5a:	0c0c      	movi.n	a12, 0
42012a5c:	8fa0b2        	movi	a11, 143
42012a5f:	b59881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42012a62:	0008e0        	callx8	a8
42012a65:	1a79      	s32i.n	a7, a10, 4
42012a67:	2a79      	s32i.n	a7, a10, 8
42012a69:	0a79      	s32i.n	a7, a10, 0
42012a6b:	3a79      	s32i.n	a7, a10, 12
42012a6d:	d38c      	beqz.n	a3, 42012a7e <_Bfree+0x3e>
42012a6f:	9298      	l32i.n	a9, a2, 36
42012a71:	1388      	l32i.n	a8, a3, 4
42012a73:	3998      	l32i.n	a9, a9, 12
42012a75:	a08890        	addx4	a8, a8, a9
42012a78:	0898      	l32i.n	a9, a8, 0
42012a7a:	0399      	s32i.n	a9, a3, 0
42012a7c:	0839      	s32i.n	a3, a8, 0
42012a7e:	f01d      	retw.n

42012a80 <__multadd>:
42012a80:	004136        	entry	a1, 32
42012a83:	4368      	l32i.n	a6, a3, 16
42012a85:	1a0c      	movi.n	a10, 1
42012a87:	027d      	mov.n	a7, a2
42012a89:	14c3b2        	addi	a11, a3, 20
42012a8c:	032d      	mov.n	a2, a3
42012a8e:	53aa60        	max	a10, a10, a6
42012a91:	238a76        	loop	a10, 42012ab8 <__multadd+0x38>
42012a94:	0b88      	l32i.n	a8, a11, 0
42012a96:	f49080        	extui	a9, a8, 0, 16
42012a99:	829940        	mull	a9, a9, a4
42012a9c:	f58080        	extui	a8, a8, 16, 16
42012a9f:	995a      	add.n	a9, a9, a5
42012aa1:	828840        	mull	a8, a8, a4
42012aa4:	f5c090        	extui	a12, a9, 16, 16
42012aa7:	88ca      	add.n	a8, a8, a12
42012aa9:	f55080        	extui	a5, a8, 16, 16
42012aac:	f49090        	extui	a9, a9, 0, 16
42012aaf:	118800        	slli	a8, a8, 16
42012ab2:	889a      	add.n	a8, a8, a9
42012ab4:	0b89      	s32i.n	a8, a11, 0
42012ab6:	bb4b      	addi.n	a11, a11, 4
42012ab8:	049516        	beqz	a5, 42012b05 <__multadd+0x85>
42012abb:	2288      	l32i.n	a8, a2, 8
42012abd:	3b2687        	blt	a6, a8, 42012afc <__multadd+0x7c>
42012ac0:	12b8      	l32i.n	a11, a2, 4
42012ac2:	07ad      	mov.n	a10, a7
42012ac4:	bb1b      	addi.n	a11, a11, 1
42012ac6:	ffef25        	call8	420129b8 <_Balloc>
42012ac9:	0a4d      	mov.n	a4, a10
42012acb:	facc      	bnez.n	a10, 42012ade <__multadd+0x5e>
42012acd:	b904d1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42012ad0:	b902a1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42012ad3:	0c0c      	movi.n	a12, 0
42012ad5:	baa0b2        	movi	a11, 186
42012ad8:	b57a81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42012adb:	0008e0        	callx8	a8
42012ade:	42c8      	l32i.n	a12, a2, 16
42012ae0:	0cc2b2        	addi	a11, a2, 12
42012ae3:	02ccc2        	addi	a12, a12, 2
42012ae6:	11cce0        	slli	a12, a12, 2
42012ae9:	0ccaa2        	addi	a10, a10, 12
42012aec:	b54f81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42012aef:	0008e0        	callx8	a8
42012af2:	02bd      	mov.n	a11, a2
42012af4:	20a770        	or	a10, a7, a7
42012af7:	fff4a5        	call8	42012a40 <_Bfree>
42012afa:	042d      	mov.n	a2, a4
42012afc:	a08620        	addx4	a8, a6, a2
42012aff:	5859      	s32i.n	a5, a8, 20
42012b01:	661b      	addi.n	a6, a6, 1
42012b03:	4269      	s32i.n	a6, a2, 16
42012b05:	f01d      	retw.n
	...

42012b08 <__s2b>:
42012b08:	004136        	entry	a1, 32
42012b0b:	b8f681        	l32r	a8, 42000ee4 <_stext+0xec4> (38e38e39 <UserFrameTotalSize+0x38e38d39>)
42012b0e:	958b      	addi.n	a9, a5, 8
42012b10:	b28980        	mulsh	a8, a9, a8
42012b13:	319f90        	srai	a9, a9, 31
42012b16:	218180        	srai	a8, a8, 1
42012b19:	c08890        	sub	a8, a8, a9
42012b1c:	0b0c      	movi.n	a11, 0
42012b1e:	190c      	movi.n	a9, 1
42012b20:	000106        	j	42012b28 <__s2b+0x20>
42012b23:	999a00        	lsi	f0, a10, 0x264
42012b26:	bb1b      	addi.n	a11, a11, 1
42012b28:	f82987        	blt	a9, a8, 42012b24 <__s2b+0x1c>
42012b2b:	02ad      	mov.n	a10, a2
42012b2d:	ffe8a5        	call8	420129b8 <_Balloc>
42012b30:	0abd      	mov.n	a11, a10
42012b32:	facc      	bnez.n	a10, 42012b45 <__s2b+0x3d>
42012b34:	b8ebd1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42012b37:	b8e8a1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42012b3a:	0c0c      	movi.n	a12, 0
42012b3c:	d3a0b2        	movi	a11, 211
42012b3f:	b56081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42012b42:	0008e0        	callx8	a8
42012b45:	180c      	movi.n	a8, 1
42012b47:	4a89      	s32i.n	a8, a10, 16
42012b49:	5a69      	s32i.n	a6, a10, 20
42012b4b:	980c      	movi.n	a8, 9
42012b4d:	23a847        	bge	a8, a4, 42012b74 <__s2b+0x6c>
42012b50:	09c372        	addi	a7, a3, 9
42012b53:	076d      	mov.n	a6, a7
42012b55:	803340        	add	a3, a3, a4
42012b58:	0006d2        	l8ui	a13, a6, 0
42012b5b:	ac0c      	movi.n	a12, 10
42012b5d:	d0cdd2        	addi	a13, a13, -48
42012b60:	02ad      	mov.n	a10, a2
42012b62:	fff1e5        	call8	42012a80 <__multadd>
42012b65:	661b      	addi.n	a6, a6, 1
42012b67:	0abd      	mov.n	a11, a10
42012b69:	eb9637        	bne	a6, a3, 42012b58 <__s2b+0x50>
42012b6c:	774a      	add.n	a7, a7, a4
42012b6e:	f8c732        	addi	a3, a7, -8
42012b71:	0000c6        	j	42012b78 <__s2b+0x70>
42012b74:	33ab      	addi.n	a3, a3, 10
42012b76:	940c      	movi.n	a4, 9
42012b78:	047d      	mov.n	a7, a4
42012b7a:	000586        	j	42012b94 <__s2b+0x8c>
42012b7d:	c08740        	sub	a8, a7, a4
42012b80:	838a      	add.n	a8, a3, a8
42012b82:	0008d2        	l8ui	a13, a8, 0
42012b85:	ac0c      	movi.n	a12, 10
42012b87:	d0cdd2        	addi	a13, a13, -48
42012b8a:	20a220        	or	a10, a2, a2
42012b8d:	ffef25        	call8	42012a80 <__multadd>
42012b90:	0abd      	mov.n	a11, a10
42012b92:	771b      	addi.n	a7, a7, 1
42012b94:	e52757        	blt	a7, a5, 42012b7d <__s2b+0x75>
42012b97:	0b2d      	mov.n	a2, a11
42012b99:	f01d      	retw.n
	...

42012b9c <__hi0bits>:
42012b9c:	004136        	entry	a1, 32
42012b9f:	f97c      	movi.n	a9, -1
42012ba1:	028d      	mov.n	a8, a2
42012ba3:	f59090        	extui	a9, a9, 16, 16
42012ba6:	020c      	movi.n	a2, 0
42012ba8:	043987        	bltu	a9, a8, 42012bb0 <__hi0bits+0x14>
42012bab:	118800        	slli	a8, a8, 16
42012bae:	021c      	movi.n	a2, 16
42012bb0:	f97c      	movi.n	a9, -1
42012bb2:	419890        	srli	a9, a9, 8
42012bb5:	043987        	bltu	a9, a8, 42012bbd <__hi0bits+0x21>
42012bb8:	228b      	addi.n	a2, a2, 8
42012bba:	118880        	slli	a8, a8, 8
42012bbd:	f97c      	movi.n	a9, -1
42012bbf:	419490        	srli	a9, a9, 4
42012bc2:	043987        	bltu	a9, a8, 42012bca <__hi0bits+0x2e>
42012bc5:	224b      	addi.n	a2, a2, 4
42012bc7:	1188c0        	slli	a8, a8, 4
42012bca:	f97c      	movi.n	a9, -1
42012bcc:	419290        	srli	a9, a9, 2
42012bcf:	053987        	bltu	a9, a8, 42012bd8 <__hi0bits+0x3c>
42012bd2:	02c222        	addi	a2, a2, 2
42012bd5:	1188e0        	slli	a8, a8, 2
42012bd8:	00c896        	bltz	a8, 42012be8 <__hi0bits+0x4c>
42012bdb:	058e80        	extui	a8, a8, 30, 1
42012bde:	221b      	addi.n	a2, a2, 1
42012be0:	018820        	slli	a8, a8, 30
42012be3:	092c      	movi.n	a9, 32
42012be5:	832980        	moveqz	a2, a9, a8
42012be8:	f01d      	retw.n
	...

42012bec <__lo0bits>:
42012bec:	004136        	entry	a1, 32
42012bef:	0288      	l32i.n	a8, a2, 0
42012bf1:	029d      	mov.n	a9, a2
42012bf3:	24a080        	extui	a10, a8, 0, 3
42012bf6:	aa9c      	beqz.n	a10, 42012c14 <__lo0bits+0x28>
42012bf8:	020c      	movi.n	a2, 0
42012bfa:	58e807        	bbsi	a8, 0, 42012c56 <__lo0bits+0x6a>
42012bfd:	096817        	bbci	a8, 1, 42012c0a <__lo0bits+0x1e>
42012c00:	418180        	srli	a8, a8, 1
42012c03:	0989      	s32i.n	a8, a9, 0
42012c05:	120c      	movi.n	a2, 1
42012c07:	0012c6        	j	42012c56 <__lo0bits+0x6a>
42012c0a:	418280        	srli	a8, a8, 2
42012c0d:	0989      	s32i.n	a8, a9, 0
42012c0f:	220c      	movi.n	a2, 2
42012c11:	001046        	j	42012c56 <__lo0bits+0x6a>
42012c14:	f4a080        	extui	a10, a8, 0, 16
42012c17:	020c      	movi.n	a2, 0
42012c19:	3acc      	bnez.n	a10, 42012c20 <__lo0bits+0x34>
42012c1b:	f58080        	extui	a8, a8, 16, 16
42012c1e:	021c      	movi.n	a2, 16
42012c20:	74a080        	extui	a10, a8, 0, 8
42012c23:	005a56        	bnez	a10, 42012c2c <__lo0bits+0x40>
42012c26:	08c222        	addi	a2, a2, 8
42012c29:	418880        	srli	a8, a8, 8
42012c2c:	34a080        	extui	a10, a8, 0, 4
42012c2f:	005a56        	bnez	a10, 42012c38 <__lo0bits+0x4c>
42012c32:	04c222        	addi	a2, a2, 4
42012c35:	418480        	srli	a8, a8, 4
42012c38:	14a080        	extui	a10, a8, 0, 2
42012c3b:	005a56        	bnez	a10, 42012c44 <__lo0bits+0x58>
42012c3e:	02c222        	addi	a2, a2, 2
42012c41:	418280        	srli	a8, a8, 2
42012c44:	06e807        	bbsi	a8, 0, 42012c4e <__lo0bits+0x62>
42012c47:	418180        	srli	a8, a8, 1
42012c4a:	221b      	addi.n	a2, a2, 1
42012c4c:	488c      	beqz.n	a8, 42012c54 <__lo0bits+0x68>
42012c4e:	0989      	s32i.n	a8, a9, 0
42012c50:	000086        	j	42012c56 <__lo0bits+0x6a>
42012c53:	022c00        	andb	b2, b12, b0
42012c56:	f01d      	retw.n

42012c58 <__i2b>:
42012c58:	004136        	entry	a1, 32
42012c5b:	02ad      	mov.n	a10, a2
42012c5d:	1b0c      	movi.n	a11, 1
42012c5f:	ffd5a5        	call8	420129b8 <_Balloc>
42012c62:	0a2d      	mov.n	a2, a10
42012c64:	0adc      	bnez.n	a10, 42012c78 <__i2b+0x20>
42012c66:	b89ed1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42012c69:	b89ba1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42012c6c:	00a0c2        	movi	a12, 0
42012c6f:	45a1b2        	movi	a11, 0x145
42012c72:	b51381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42012c75:	0008e0        	callx8	a8
42012c78:	180c      	movi.n	a8, 1
42012c7a:	5a39      	s32i.n	a3, a10, 20
42012c7c:	4a89      	s32i.n	a8, a10, 16
42012c7e:	f01d      	retw.n

42012c80 <__multiply>:
42012c80:	006136        	entry	a1, 48
42012c83:	4368      	l32i.n	a6, a3, 16
42012c85:	4458      	l32i.n	a5, a4, 16
42012c87:	02ad      	mov.n	a10, a2
42012c89:	0d2657        	blt	a6, a5, 42012c9a <__multiply+0x1a>
42012c8c:	058d      	mov.n	a8, a5
42012c8e:	065d      	mov.n	a5, a6
42012c90:	086d      	mov.n	a6, a8
42012c92:	048d      	mov.n	a8, a4
42012c94:	204330        	or	a4, a3, a3
42012c97:	203880        	or	a3, a8, a8
42012c9a:	2488      	l32i.n	a8, a4, 8
42012c9c:	756a      	add.n	a7, a5, a6
42012c9e:	14b8      	l32i.n	a11, a4, 4
42012ca0:	01a877        	bge	a8, a7, 42012ca5 <__multiply+0x25>
42012ca3:	bb1b      	addi.n	a11, a11, 1
42012ca5:	ffd125        	call8	420129b8 <_Balloc>
42012ca8:	01a9      	s32i.n	a10, a1, 0
42012caa:	facc      	bnez.n	a10, 42012cbd <__multiply+0x3d>
42012cac:	b88dd1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42012caf:	b88aa1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42012cb2:	0c0c      	movi.n	a12, 0
42012cb4:	62a1b2        	movi	a11, 0x162
42012cb7:	b50281        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42012cba:	0008e0        	callx8	a8
42012cbd:	0188      	l32i.n	a8, a1, 0
42012cbf:	090c      	movi.n	a9, 0
42012cc1:	14c8b2        	addi	a11, a8, 20
42012cc4:	a027b0        	addx4	a2, a7, a11
42012cc7:	0b8d      	mov.n	a8, a11
42012cc9:	0000c6        	j	42012cd0 <__multiply+0x50>
42012ccc:	0899      	s32i.n	a9, a8, 0
42012cce:	884b      	addi.n	a8, a8, 4
42012cd0:	f83827        	bltu	a8, a2, 42012ccc <__multiply+0x4c>
42012cd3:	14c332        	addi	a3, a3, 20
42012cd6:	a09630        	addx4	a9, a6, a3
42012cd9:	14c4c2        	addi	a12, a4, 20
42012cdc:	a085c0        	addx4	a8, a5, a12
42012cdf:	3199      	s32i.n	a9, a1, 12
42012ce1:	15c492        	addi	a9, a4, 21
42012ce4:	629890        	lsi	f9, a8, 0x188
42012ce7:	990b      	addi.n	a9, a9, -1
42012ce9:	609090        	neg	a9, a9
42012cec:	0a0c      	movi.n	a10, 0
42012cee:	749090        	extui	a9, a9, 0, 8
42012cf1:	11a9      	s32i.n	a10, a1, 4
42012cf3:	0e2916        	beqz	a9, 42012dd9 <__multiply+0x159>
42012cf6:	15c442        	addi	a4, a4, 21
42012cf9:	604040        	neg	a4, a4
42012cfc:	448a      	add.n	a4, a4, a8
42012cfe:	414240        	srli	a4, a4, 2
42012d01:	1194e0        	slli	a9, a4, 2
42012d04:	1199      	s32i.n	a9, a1, 4
42012d06:	0033c6        	j	42012dd9 <__multiply+0x159>
42012d09:	035800        	lsi	f0, a8, 12
42012d0c:	f49050        	extui	a9, a5, 0, 16
42012d0f:	05a916        	beqz	a9, 42012d6d <__multiply+0xed>
42012d12:	f97c      	movi.n	a9, -1
42012d14:	309c90        	xor	a9, a12, a9
42012d17:	989a      	add.n	a9, a8, a9
42012d19:	419290        	srli	a9, a9, 2
42012d1c:	ac4b      	addi.n	a10, a12, 4
42012d1e:	d83b      	addi.n	a13, a8, 3
42012d20:	0bfd      	mov.n	a15, a11
42012d22:	0c4d      	mov.n	a4, a12
42012d24:	060c      	movi.n	a6, 0
42012d26:	991b      	addi.n	a9, a9, 1
42012d28:	023da7        	bltu	a13, a10, 42012d2e <__multiply+0xae>
42012d2b:	001856        	bnez	a8, 42012d30 <__multiply+0xb0>
42012d2e:	190c      	movi.n	a9, 1
42012d30:	f03d      	nop.n
42012d32:	318976        	loop	a9, 42012d67 <__multiply+0xe7>
42012d35:	04e8      	l32i.n	a14, a4, 0
42012d37:	0fd8      	l32i.n	a13, a15, 0
42012d39:	c1ae50        	mul16u	a10, a14, a5
42012d3c:	f4d0d0        	extui	a13, a13, 0, 16
42012d3f:	aada      	add.n	a10, a10, a13
42012d41:	f5e0e0        	extui	a14, a14, 16, 16
42012d44:	0fd8      	l32i.n	a13, a15, 0
42012d46:	c1ee50        	mul16u	a14, a14, a5
42012d49:	aa6a      	add.n	a10, a10, a6
42012d4b:	f5d0d0        	extui	a13, a13, 16, 16
42012d4e:	deda      	add.n	a13, a14, a13
42012d50:	f5e0a0        	extui	a14, a10, 16, 16
42012d53:	ddea      	add.n	a13, a13, a14
42012d55:	f560d0        	extui	a6, a13, 16, 16
42012d58:	f4a0a0        	extui	a10, a10, 0, 16
42012d5b:	11dd00        	slli	a13, a13, 16
42012d5e:	20dda0        	or	a13, a13, a10
42012d61:	0fd9      	s32i.n	a13, a15, 0
42012d63:	444b      	addi.n	a4, a4, 4
42012d65:	ff4b      	addi.n	a15, a15, 4
42012d67:	1198      	l32i.n	a9, a1, 4
42012d69:	9b9a      	add.n	a9, a11, a9
42012d6b:	1969      	s32i.n	a6, a9, 4
42012d6d:	011362        	l16ui	a6, a3, 2
42012d70:	061616        	beqz	a6, 42012dd5 <__multiply+0x155>
42012d73:	f97c      	movi.n	a9, -1
42012d75:	309c90        	xor	a9, a12, a9
42012d78:	989a      	add.n	a9, a8, a9
42012d7a:	419290        	srli	a9, a9, 2
42012d7d:	991b      	addi.n	a9, a9, 1
42012d7f:	0ba8      	l32i.n	a10, a11, 0
42012d81:	2199      	s32i.n	a9, a1, 8
42012d83:	5c4b      	addi.n	a5, a12, 4
42012d85:	983b      	addi.n	a9, a8, 3
42012d87:	0cfd      	mov.n	a15, a12
42012d89:	0bed      	mov.n	a14, a11
42012d8b:	0add      	mov.n	a13, a10
42012d8d:	040c      	movi.n	a4, 0
42012d8f:	013957        	bltu	a9, a5, 42012d94 <__multiply+0x114>
42012d92:	28cc      	bnez.n	a8, 42012d98 <__multiply+0x118>
42012d94:	190c      	movi.n	a9, 1
42012d96:	2199      	s32i.n	a9, a1, 8
42012d98:	0f58      	l32i.n	a5, a15, 0
42012d9a:	f5d0d0        	extui	a13, a13, 16, 16
42012d9d:	c15560        	mul16u	a5, a5, a6
42012da0:	f4a0a0        	extui	a10, a10, 0, 16
42012da3:	554a      	add.n	a5, a5, a4
42012da5:	55da      	add.n	a5, a5, a13
42012da7:	11d500        	slli	a13, a5, 16
42012daa:	20dda0        	or	a13, a13, a10
42012dad:	0ed9      	s32i.n	a13, a14, 0
42012daf:	011f42        	l16ui	a4, a15, 2
42012db2:	1ed8      	l32i.n	a13, a14, 4
42012db4:	c14460        	mul16u	a4, a4, a6
42012db7:	f4a0d0        	extui	a10, a13, 0, 16
42012dba:	a4aa      	add.n	a10, a4, a10
42012dbc:	f55050        	extui	a5, a5, 16, 16
42012dbf:	2198      	l32i.n	a9, a1, 8
42012dc1:	aa5a      	add.n	a10, a10, a5
42012dc3:	f540a0        	extui	a4, a10, 16, 16
42012dc6:	ff4b      	addi.n	a15, a15, 4
42012dc8:	ee4b      	addi.n	a14, a14, 4
42012dca:	990b      	addi.n	a9, a9, -1
42012dcc:	fc6956        	bnez	a9, 42012d96 <__multiply+0x116>
42012dcf:	1198      	l32i.n	a9, a1, 4
42012dd1:	9b9a      	add.n	a9, a11, a9
42012dd3:	19a9      	s32i.n	a10, a9, 4
42012dd5:	334b      	addi.n	a3, a3, 4
42012dd7:	bb4b      	addi.n	a11, a11, 4
42012dd9:	3198      	l32i.n	a9, a1, 12
42012ddb:	02b397        	bgeu	a3, a9, 42012de1 <__multiply+0x161>
42012dde:	ffca06        	j	42012d0a <__multiply+0x8a>
42012de1:	000046        	j	42012de6 <__multiply+0x166>
42012de4:	770b      	addi.n	a7, a7, -1
42012de6:	0717a6        	blti	a7, 1, 42012df1 <__multiply+0x171>
42012de9:	fcc222        	addi	a2, a2, -4
42012dec:	0288      	l32i.n	a8, a2, 0
42012dee:	ff2816        	beqz	a8, 42012de4 <__multiply+0x164>
42012df1:	0188      	l32i.n	a8, a1, 0
42012df3:	4879      	s32i.n	a7, a8, 16
42012df5:	082d      	mov.n	a2, a8
42012df7:	f01d      	retw.n
42012df9:	000000        	ill

42012dfc <__pow5mult>:
42012dfc:	004136        	entry	a1, 32
42012dff:	148040        	extui	a8, a4, 0, 2
42012e02:	026d      	mov.n	a6, a2
42012e04:	032d      	mov.n	a2, a3
42012e06:	689c      	beqz.n	a8, 42012e20 <__pow5mult+0x24>
42012e08:	b83891        	l32r	a9, 42000ee8 <_stext+0xec8> (3c029d60 <p05$0>)
42012e0b:	880b      	addi.n	a8, a8, -1
42012e0d:	a08890        	addx4	a8, a8, a9
42012e10:	08c8      	l32i.n	a12, a8, 0
42012e12:	00a0d2        	movi	a13, 0
42012e15:	20b330        	or	a11, a3, a3
42012e18:	20a660        	or	a10, a6, a6
42012e1b:	ffc665        	call8	42012a80 <__multadd>
42012e1e:	0a2d      	mov.n	a2, a10
42012e20:	214240        	srai	a4, a4, 2
42012e23:	07e416        	beqz	a4, 42012ea5 <__pow5mult+0xa9>
42012e26:	9658      	l32i.n	a5, a6, 36
42012e28:	85ec      	bnez.n	a5, 42012e54 <__pow5mult+0x58>
42012e2a:	0a1c      	movi.n	a10, 16
42012e2c:	b65681        	l32r	a8, 42000784 <_stext+0x764> (4037fe90 <malloc>)
42012e2f:	0008e0        	callx8	a8
42012e32:	96a9      	s32i.n	a10, a6, 36
42012e34:	0a5d      	mov.n	a5, a10
42012e36:	0adc      	bnez.n	a10, 42012e4a <__pow5mult+0x4e>
42012e38:	b827d1        	l32r	a13, 42000ed4 <_stext+0xeb4> (3c0295f5 <_ZTISt12out_of_range+0x169>)
42012e3b:	b827a1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42012e3e:	00a0c2        	movi	a12, 0
42012e41:	b3a1b2        	movi	a11, 0x1b3
42012e44:	b49f81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42012e47:	0008e0        	callx8	a8
42012e4a:	080c      	movi.n	a8, 0
42012e4c:	1a89      	s32i.n	a8, a10, 4
42012e4e:	2a89      	s32i.n	a8, a10, 8
42012e50:	0a89      	s32i.n	a8, a10, 0
42012e52:	3a89      	s32i.n	a8, a10, 12
42012e54:	2578      	l32i.n	a7, a5, 8
42012e56:	e7cc      	bnez.n	a7, 42012e68 <__pow5mult+0x6c>
42012e58:	71a2b2        	movi	a11, 0x271
42012e5b:	06ad      	mov.n	a10, a6
42012e5d:	ffdfa5        	call8	42012c58 <__i2b>
42012e60:	25a9      	s32i.n	a10, a5, 8
42012e62:	080c      	movi.n	a8, 0
42012e64:	0a7d      	mov.n	a7, a10
42012e66:	0a89      	s32i.n	a8, a10, 0
42012e68:	023d      	mov.n	a3, a2
42012e6a:	050c      	movi.n	a5, 0
42012e6c:	000106        	j	42012e74 <__pow5mult+0x78>
42012e6f:	0a7d00        	add.s	f7, f13, f0
42012e72:	023d      	mov.n	a3, a2
42012e74:	048040        	extui	a8, a4, 0, 1
42012e77:	214140        	srai	a4, a4, 1
42012e7a:	289c      	beqz.n	a8, 42012e90 <__pow5mult+0x94>
42012e7c:	02bd      	mov.n	a11, a2
42012e7e:	07cd      	mov.n	a12, a7
42012e80:	06ad      	mov.n	a10, a6
42012e82:	ffdfe5        	call8	42012c80 <__multiply>
42012e85:	0a2d      	mov.n	a2, a10
42012e87:	03bd      	mov.n	a11, a3
42012e89:	06ad      	mov.n	a10, a6
42012e8b:	ffbb65        	call8	42012a40 <_Bfree>
42012e8e:	349c      	beqz.n	a4, 42012ea5 <__pow5mult+0xa9>
42012e90:	07a8      	l32i.n	a10, a7, 0
42012e92:	fdaa56        	bnez	a10, 42012e70 <__pow5mult+0x74>
42012e95:	07cd      	mov.n	a12, a7
42012e97:	07bd      	mov.n	a11, a7
42012e99:	06ad      	mov.n	a10, a6
42012e9b:	ffde65        	call8	42012c80 <__multiply>
42012e9e:	07a9      	s32i.n	a10, a7, 0
42012ea0:	0a59      	s32i.n	a5, a10, 0
42012ea2:	fff286        	j	42012e70 <__pow5mult+0x74>
42012ea5:	f01d      	retw.n
	...

42012ea8 <__lshift>:
42012ea8:	006136        	entry	a1, 48
42012eab:	4368      	l32i.n	a6, a3, 16
42012ead:	04dd      	mov.n	a13, a4
42012eaf:	214540        	srai	a4, a4, 5
42012eb2:	646a      	add.n	a6, a4, a6
42012eb4:	13b8      	l32i.n	a11, a3, 4
42012eb6:	2388      	l32i.n	a8, a3, 8
42012eb8:	027d      	mov.n	a7, a2
42012eba:	561b      	addi.n	a5, a6, 1
42012ebc:	000106        	j	42012ec4 <__lshift+0x1c>
42012ebf:	bb1b00        	movgez.s	f1, f11, a0
42012ec2:	888a      	add.n	a8, a8, a8
42012ec4:	f82857        	blt	a8, a5, 42012ec0 <__lshift+0x18>
42012ec7:	07ad      	mov.n	a10, a7
42012ec9:	01d9      	s32i.n	a13, a1, 0
42012ecb:	ffaee5        	call8	420129b8 <_Balloc>
42012ece:	0a2d      	mov.n	a2, a10
42012ed0:	14caa2        	addi	a10, a10, 20
42012ed3:	01d8      	l32i.n	a13, a1, 0
42012ed5:	0a9d      	mov.n	a9, a10
42012ed7:	080c      	movi.n	a8, 0
42012ed9:	0b0c      	movi.n	a11, 0
42012edb:	62dc      	bnez.n	a2, 42012ef5 <__lshift+0x4d>
42012edd:	b800d1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42012ee0:	b7fea1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42012ee3:	0c0c      	movi.n	a12, 0
42012ee5:	dea1b2        	movi	a11, 0x1de
42012ee8:	b47681        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42012eeb:	0008e0        	callx8	a8
42012eee:	09b9      	s32i.n	a11, a9, 0
42012ef0:	881b      	addi.n	a8, a8, 1
42012ef2:	04c992        	addi	a9, a9, 4
42012ef5:	f52847        	blt	a8, a4, 42012eee <__lshift+0x46>
42012ef8:	080c      	movi.n	a8, 0
42012efa:	539480        	max	a9, a4, a8
42012efd:	43c8      	l32i.n	a12, a3, 16
42012eff:	a099a0        	addx4	a9, a9, a10
42012f02:	14c382        	addi	a8, a3, 20
42012f05:	0199      	s32i.n	a9, a1, 0
42012f07:	4440d0        	extui	a4, a13, 0, 5
42012f0a:	a0cc80        	addx4	a12, a12, a8
42012f0d:	06b416        	beqz	a4, 42012f7c <__lshift+0xd4>
42012f10:	fb7c      	movi.n	a11, -1
42012f12:	30b8b0        	xor	a11, a8, a11
42012f15:	bcba      	add.n	a11, a12, a11
42012f17:	e0c4a2        	addi	a10, a4, -32
42012f1a:	41b2b0        	srli	a11, a11, 2
42012f1d:	18c3e2        	addi	a14, a3, 24
42012f20:	fc3b      	addi.n	a15, a12, 3
42012f22:	60a0a0        	neg	a10, a10
42012f25:	0d0c      	movi.n	a13, 0
42012f27:	bb1b      	addi.n	a11, a11, 1
42012f29:	013fe7        	bltu	a15, a14, 42012f2e <__lshift+0x86>
42012f2c:	0ccc      	bnez.n	a12, 42012f30 <__lshift+0x88>
42012f2e:	1b0c      	movi.n	a11, 1
42012f30:	f03d      	nop.n
42012f32:	1a8b76        	loop	a11, 42012f50 <__lshift+0xa8>
42012f35:	08e8      	l32i.n	a14, a8, 0
42012f37:	09fd      	mov.n	a15, a9
42012f39:	401400        	ssl	a4
42012f3c:	a1ee00        	sll	a14, a14
42012f3f:	20eed0        	or	a14, a14, a13
42012f42:	0fe9      	s32i.n	a14, a15, 0
42012f44:	08d8      	l32i.n	a13, a8, 0
42012f46:	994b      	addi.n	a9, a9, 4
42012f48:	400a00        	ssr	a10
42012f4b:	91d0d0        	srl	a13, a13
42012f4e:	884b      	addi.n	a8, a8, 4
42012f50:	15c382        	addi	a8, a3, 21
42012f53:	628c80        	lsi	f8, a12, 0x188
42012f56:	880b      	addi.n	a8, a8, -1
42012f58:	608080        	neg	a8, a8
42012f5b:	749080        	extui	a9, a8, 0, 8
42012f5e:	080c      	movi.n	a8, 0
42012f60:	c98c      	beqz.n	a9, 42012f70 <__lshift+0xc8>
42012f62:	15c382        	addi	a8, a3, 21
42012f65:	608080        	neg	a8, a8
42012f68:	88ca      	add.n	a8, a8, a12
42012f6a:	418280        	srli	a8, a8, 2
42012f6d:	1188e0        	slli	a8, a8, 2
42012f70:	0198      	l32i.n	a9, a1, 0
42012f72:	898a      	add.n	a8, a9, a8
42012f74:	18d9      	s32i.n	a13, a8, 4
42012f76:	adec      	bnez.n	a13, 42012fa4 <__lshift+0xfc>
42012f78:	000946        	j	42012fa1 <__lshift+0xf9>
42012f7b:	fa7c00        	mov.s	f7, f12
42012f7e:	30a8a0        	xor	a10, a8, a10
42012f81:	acaa      	add.n	a10, a12, a10
42012f83:	41a2a0        	srli	a10, a10, 2
42012f86:	18c3b2        	addi	a11, a3, 24
42012f89:	dc3b      	addi.n	a13, a12, 3
42012f8b:	aa1b      	addi.n	a10, a10, 1
42012f8d:	013db7        	bltu	a13, a11, 42012f92 <__lshift+0xea>
42012f90:	0ccc      	bnez.n	a12, 42012f94 <__lshift+0xec>
42012f92:	1a0c      	movi.n	a10, 1
42012f94:	f03d      	nop.n
42012f96:	078a76        	loop	a10, 42012fa1 <__lshift+0xf9>
42012f99:	08c8      	l32i.n	a12, a8, 0
42012f9b:	884b      	addi.n	a8, a8, 4
42012f9d:	09c9      	s32i.n	a12, a9, 0
42012f9f:	994b      	addi.n	a9, a9, 4
42012fa1:	205660        	or	a5, a6, a6
42012fa4:	4259      	s32i.n	a5, a2, 16
42012fa6:	03bd      	mov.n	a11, a3
42012fa8:	07ad      	mov.n	a10, a7
42012faa:	ffa965        	call8	42012a40 <_Bfree>
42012fad:	f01d      	retw.n
	...

42012fb0 <__mcmp>:
42012fb0:	004136        	entry	a1, 32
42012fb3:	43a8      	l32i.n	a10, a3, 16
42012fb5:	028d      	mov.n	a8, a2
42012fb7:	4228      	l32i.n	a2, a2, 16
42012fb9:	c022a0        	sub	a2, a2, a10
42012fbc:	82ec      	bnez.n	a2, 42012fe8 <__mcmp+0x38>
42012fbe:	14c892        	addi	a9, a8, 20
42012fc1:	14c332        	addi	a3, a3, 20
42012fc4:	118ae0        	slli	a8, a10, 2
42012fc7:	a98a      	add.n	a10, a9, a8
42012fc9:	808380        	add	a8, a3, a8
42012fcc:	fccaa2        	addi	a10, a10, -4
42012fcf:	fcc882        	addi	a8, a8, -4
42012fd2:	0ac8      	l32i.n	a12, a10, 0
42012fd4:	08b8      	l32i.n	a11, a8, 0
42012fd6:	0b1cb7        	beq	a12, a11, 42012fe5 <__mcmp+0x35>
42012fd9:	120c      	movi.n	a2, 1
42012fdb:	09bcb7        	bgeu	a12, a11, 42012fe8 <__mcmp+0x38>
42012fde:	f27c      	movi.n	a2, -1
42012fe0:	000106        	j	42012fe8 <__mcmp+0x38>
42012fe3:	a70000        	lsi	f0, a0, 0x29c
42012fe6:	e339      	s32i.n	a3, a3, 56
42012fe8:	f01d      	retw.n
	...

42012fec <__mdiff>:
42012fec:	006136        	entry	a1, 48
42012fef:	04bd      	mov.n	a11, a4
42012ff1:	03ad      	mov.n	a10, a3
42012ff3:	fffbe5        	call8	42012fb0 <__mcmp>
42012ff6:	0a7d      	mov.n	a7, a10
42012ff8:	dadc      	bnez.n	a10, 42013019 <__mdiff+0x2d>
42012ffa:	02ad      	mov.n	a10, a2
42012ffc:	0b0c      	movi.n	a11, 0
42012ffe:	ff9ba5        	call8	420129b8 <_Balloc>
42013001:	0a2d      	mov.n	a2, a10
42013003:	9acc      	bnez.n	a10, 42013010 <__mdiff+0x24>
42013005:	b7b6d1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42013008:	0c0c      	movi.n	a12, 0
4201300a:	37a2b2        	movi	a11, 0x237
4201300d:	000a06        	j	42013039 <__mdiff+0x4d>
42013010:	180c      	movi.n	a8, 1
42013012:	4a89      	s32i.n	a8, a10, 16
42013014:	5a79      	s32i.n	a7, a10, 20
42013016:	0046c6        	j	42013135 <__mdiff+0x149>
42013019:	060c      	movi.n	a6, 0
4201301b:	007ad6        	bgez	a10, 42013026 <__mdiff+0x3a>
4201301e:	038d      	mov.n	a8, a3
42013020:	160c      	movi.n	a6, 1
42013022:	043d      	mov.n	a3, a4
42013024:	084d      	mov.n	a4, a8
42013026:	13b8      	l32i.n	a11, a3, 4
42013028:	02ad      	mov.n	a10, a2
4201302a:	ff98e5        	call8	420129b8 <_Balloc>
4201302d:	0a2d      	mov.n	a2, a10
4201302f:	facc      	bnez.n	a10, 42013042 <__mdiff+0x56>
42013031:	b7abd1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42013034:	0c0c      	movi.n	a12, 0
42013036:	45a2b2        	movi	a11, 0x245
42013039:	b7a7a1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
4201303c:	b42181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4201303f:	0008e0        	callx8	a8
42013042:	3a69      	s32i.n	a6, a10, 12
42013044:	44a8      	l32i.n	a10, a4, 16
42013046:	14c482        	addi	a8, a4, 20
42013049:	a0aa80        	addx4	a10, a10, a8
4201304c:	ebca92        	addi	a9, a10, -21
4201304f:	43f8      	l32i.n	a15, a3, 16
42013051:	c09940        	sub	a9, a9, a4
42013054:	14c3d2        	addi	a13, a3, 20
42013057:	419290        	srli	a9, a9, 2
4201305a:	18c482        	addi	a8, a4, 24
4201305d:	ba3b      	addi.n	a11, a10, 3
4201305f:	a0cfd0        	addx4	a12, a15, a13
42013062:	14c252        	addi	a5, a2, 20
42013065:	4e1c      	movi.n	a14, 20
42013067:	070c      	movi.n	a7, 0
42013069:	01c992        	addi	a9, a9, 1
4201306c:	023b87        	bltu	a11, a8, 42013072 <__mdiff+0x86>
4201306f:	001a56        	bnez	a10, 42013074 <__mdiff+0x88>
42013072:	190c      	movi.n	a9, 1
42013074:	f03d      	nop.n
42013076:	368976        	loop	a9, 420130b0 <__mdiff+0xc4>
42013079:	b4ea      	add.n	a11, a4, a14
4201307b:	83ea      	add.n	a8, a3, a14
4201307d:	0888      	l32i.n	a8, a8, 0
4201307f:	0b68      	l32i.n	a6, a11, 0
42013081:	0189      	s32i.n	a8, a1, 0
42013083:	f4b060        	extui	a11, a6, 0, 16
42013086:	f48080        	extui	a8, a8, 0, 16
42013089:	c0b8b0        	sub	a11, a8, a11
4201308c:	0188      	l32i.n	a8, a1, 0
4201308e:	bb7a      	add.n	a11, a11, a7
42013090:	f56060        	extui	a6, a6, 16, 16
42013093:	f58080        	extui	a8, a8, 16, 16
42013096:	3170b0        	srai	a7, a11, 16
42013099:	c08860        	sub	a8, a8, a6
4201309c:	887a      	add.n	a8, a8, a7
4201309e:	317080        	srai	a7, a8, 16
420130a1:	f4b0b0        	extui	a11, a11, 0, 16
420130a4:	118800        	slli	a8, a8, 16
420130a7:	62ea      	add.n	a6, a2, a14
420130a9:	20bb80        	or	a11, a11, a8
420130ac:	06b9      	s32i.n	a11, a6, 0
420130ae:	ee4b      	addi.n	a14, a14, 4
420130b0:	15c482        	addi	a8, a4, 21
420130b3:	628a80        	lsi	f8, a10, 0x188
420130b6:	880b      	addi.n	a8, a8, -1
420130b8:	608080        	neg	a8, a8
420130bb:	749080        	extui	a9, a8, 0, 8
420130be:	080c      	movi.n	a8, 0
420130c0:	c98c      	beqz.n	a9, 420130d0 <__mdiff+0xe4>
420130c2:	15c442        	addi	a4, a4, 21
420130c5:	604040        	neg	a4, a4
420130c8:	44aa      	add.n	a4, a4, a10
420130ca:	414240        	srli	a4, a4, 2
420130cd:	1184e0        	slli	a8, a4, 2
420130d0:	958a      	add.n	a9, a5, a8
420130d2:	8d8a      	add.n	a8, a13, a8
420130d4:	b84b      	addi.n	a11, a8, 4
420130d6:	994b      	addi.n	a9, a9, 4
420130d8:	0b6d      	mov.n	a6, a11
420130da:	c0d5d0        	sub	a13, a5, a13
420130dd:	000886        	j	42013103 <__mdiff+0x117>
420130e0:	06a8      	l32i.n	a10, a6, 0
420130e2:	074d      	mov.n	a4, a7
420130e4:	f4e0a0        	extui	a14, a10, 0, 16
420130e7:	ee7a      	add.n	a14, a14, a7
420130e9:	31e0e0        	srai	a14, a14, 16
420130ec:	f570a0        	extui	a7, a10, 16, 16
420130ef:	ee7a      	add.n	a14, a14, a7
420130f1:	aa4a      	add.n	a10, a10, a4
420130f3:	3170e0        	srai	a7, a14, 16
420130f6:	f4a0a0        	extui	a10, a10, 0, 16
420130f9:	11ee00        	slli	a14, a14, 16
420130fc:	20aae0        	or	a10, a10, a14
420130ff:	664b      	addi.n	a6, a6, 4
42013101:	05a9      	s32i.n	a10, a5, 0
42013103:	56da      	add.n	a5, a6, a13
42013105:	d736c7        	bltu	a6, a12, 420130e0 <__mdiff+0xf4>
42013108:	881b      	addi.n	a8, a8, 1
4201310a:	628c80        	lsi	f8, a12, 0x188
4201310d:	880b      	addi.n	a8, a8, -1
4201310f:	608080        	neg	a8, a8
42013112:	748080        	extui	a8, a8, 0, 8
42013115:	0a0c      	movi.n	a10, 0
42013117:	988c      	beqz.n	a8, 42013124 <__mdiff+0x138>
42013119:	cc3b      	addi.n	a12, a12, 3
4201311b:	c0ccb0        	sub	a12, a12, a11
4201311e:	41c2c0        	srli	a12, a12, 2
42013121:	11ace0        	slli	a10, a12, 2
42013124:	8a9a      	add.n	a8, a10, a9
42013126:	000046        	j	4201312b <__mdiff+0x13f>
42013129:	ff0b      	addi.n	a15, a15, -1
4201312b:	fcc882        	addi	a8, a8, -4
4201312e:	0898      	l32i.n	a9, a8, 0
42013130:	ff5916        	beqz	a9, 42013129 <__mdiff+0x13d>
42013133:	42f9      	s32i.n	a15, a2, 16
42013135:	f01d      	retw.n
	...

42013138 <__ulp>:
42013138:	004136        	entry	a1, 32
4201313b:	a58430        	extui	a8, a3, 20, 11
4201313e:	397c      	movi.n	a9, -13
42013140:	0188c0        	slli	a8, a8, 20
42013143:	0199a0        	slli	a9, a9, 22
42013146:	889a      	add.n	a8, a8, a9
42013148:	0a0c      	movi.n	a10, 0
4201314a:	3018e6        	bgei	a8, 1, 4201317e <__ulp+0x46>
4201314d:	608080        	neg	a8, a8
42013150:	319480        	srai	a9, a8, 20
42013153:	381c      	movi.n	a8, 19
42013155:	0d2897        	blt	a8, a9, 42013166 <__ulp+0x2e>
42013158:	180c      	movi.n	a8, 1
4201315a:	0188d0        	slli	a8, a8, 19
4201315d:	400900        	ssr	a9
42013160:	b18080        	sra	a8, a8
42013163:	0005c6        	j	4201317e <__ulp+0x46>
42013166:	ecc992        	addi	a9, a9, -20
42013169:	e81c      	movi.n	a8, 30
4201316b:	01a0a2        	movi	a10, 1
4201316e:	0a2897        	blt	a8, a9, 4201317c <__ulp+0x44>
42013171:	fa7c      	movi.n	a10, -1
42013173:	01aa10        	slli	a10, a10, 31
42013176:	400900        	ssr	a9
42013179:	91a0a0        	srl	a10, a10
4201317c:	080c      	movi.n	a8, 0
4201317e:	083d      	mov.n	a3, a8
42013180:	0a2d      	mov.n	a2, a10
42013182:	f01d      	retw.n

42013184 <__b2d>:
42013184:	004136        	entry	a1, 32
42013187:	4258      	l32i.n	a5, a2, 16
42013189:	14c242        	addi	a4, a2, 20
4201318c:	a05540        	addx4	a5, a5, a4
4201318f:	fcc572        	addi	a7, a5, -4
42013192:	0768      	l32i.n	a6, a7, 0
42013194:	06ad      	mov.n	a10, a6
42013196:	ffa065        	call8	42012b9c <__hi0bits>
42013199:	e0ca82        	addi	a8, a10, -32
4201319c:	608080        	neg	a8, a8
4201319f:	0389      	s32i.n	a8, a3, 0
420131a1:	ffa392        	movi	a9, 0x3ff
420131a4:	a80c      	movi.n	a8, 10
420131a6:	0199c0        	slli	a9, a9, 20
420131a9:	2528a7        	blt	a8, a10, 420131d2 <__b2d+0x4e>
420131ac:	f5cab2        	addi	a11, a10, -11
420131af:	60b0b0        	neg	a11, a11
420131b2:	400b00        	ssr	a11
420131b5:	918060        	srl	a8, a6
420131b8:	203890        	or	a3, a8, a9
420131bb:	090c      	movi.n	a9, 0
420131bd:	04b477        	bgeu	a4, a7, 420131c5 <__b2d+0x41>
420131c0:	f8c552        	addi	a5, a5, -8
420131c3:	0598      	l32i.n	a9, a5, 0
420131c5:	15ca82        	addi	a8, a10, 21
420131c8:	401800        	ssl	a8
420131cb:	a18600        	sll	a8, a6
420131ce:	000c46        	j	42013203 <__b2d+0x7f>
420131d1:	080c00        	lsx	f0, a12, a0
420131d4:	04b477        	bgeu	a4, a7, 420131dc <__b2d+0x58>
420131d7:	f8c572        	addi	a7, a5, -8
420131da:	0788      	l32i.n	a8, a7, 0
420131dc:	f5caa2        	addi	a10, a10, -11
420131df:	203690        	or	a3, a6, a9
420131e2:	6aac      	beqz.n	a10, 4201320c <__b2d+0x88>
420131e4:	e0cab2        	addi	a11, a10, -32
420131e7:	401a00        	ssl	a10
420131ea:	816680        	src	a6, a6, a8
420131ed:	203690        	or	a3, a6, a9
420131f0:	60b0b0        	neg	a11, a11
420131f3:	090c      	movi.n	a9, 0
420131f5:	04b477        	bgeu	a4, a7, 420131fd <__b2d+0x79>
420131f8:	fcc772        	addi	a7, a7, -4
420131fb:	0798      	l32i.n	a9, a7, 0
420131fd:	401a00        	ssl	a10
42013200:	a18800        	sll	a8, a8
42013203:	400b00        	ssr	a11
42013206:	919090        	srl	a9, a9
42013209:	208890        	or	a8, a8, a9
4201320c:	082d      	mov.n	a2, a8
4201320e:	f01d      	retw.n

42013210 <__d2b>:
42013210:	006136        	entry	a1, 48
42013213:	02ad      	mov.n	a10, a2
42013215:	1b0c      	movi.n	a11, 1
42013217:	ff7a25        	call8	420129b8 <_Balloc>
4201321a:	0a2d      	mov.n	a2, a10
4201321c:	011a56        	bnez	a10, 42013231 <__d2b+0x21>
4201321f:	b730d1        	l32r	a13, 42000ee0 <_stext+0xec0> (3c029660 <_ZTISt12out_of_range+0x1d4>)
42013222:	b72da1        	l32r	a10, 42000ed8 <_stext+0xeb8> (3c029671 <_ZTISt12out_of_range+0x1e5>)
42013225:	00a0c2        	movi	a12, 0
42013228:	0fa3b2        	movi	a11, 0x30f
4201322b:	b3a581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4201322e:	0008e0        	callx8	a8
42013231:	118540        	slli	a8, a5, 12
42013234:	a53450        	extui	a3, a5, 20, 11
42013237:	418c80        	srli	a8, a8, 12
4201323a:	738c      	beqz.n	a3, 42013245 <__d2b+0x35>
4201323c:	01a092        	movi	a9, 1
4201323f:	0199c0        	slli	a9, a9, 20
42013242:	208890        	or	a8, a8, a9
42013245:	0189      	s32i.n	a8, a1, 0
42013247:	74bc      	beqz.n	a4, 42013282 <__d2b+0x72>
42013249:	a14b      	addi.n	a10, a1, 4
4201324b:	1149      	s32i.n	a4, a1, 4
4201324d:	ff99e5        	call8	42012bec <__lo0bits>
42013250:	11b8      	l32i.n	a11, a1, 4
42013252:	ca9c      	beqz.n	a10, 42013272 <__d2b+0x62>
42013254:	0198      	l32i.n	a9, a1, 0
42013256:	e0ca82        	addi	a8, a10, -32
42013259:	608080        	neg	a8, a8
4201325c:	401800        	ssl	a8
4201325f:	a18900        	sll	a8, a9
42013262:	2088b0        	or	a8, a8, a11
42013265:	400a00        	ssr	a10
42013268:	919090        	srl	a9, a9
4201326b:	5289      	s32i.n	a8, a2, 20
4201326d:	0199      	s32i.n	a9, a1, 0
4201326f:	000046        	j	42013274 <__d2b+0x64>
42013272:	52b9      	s32i.n	a11, a2, 20
42013274:	0188      	l32i.n	a8, a1, 0
42013276:	150c      	movi.n	a5, 1
42013278:	290c      	movi.n	a9, 2
4201327a:	6289      	s32i.n	a8, a2, 24
4201327c:	935980        	movnez	a5, a9, a8
4201327f:	000346        	j	42013290 <__d2b+0x80>
42013282:	01ad      	mov.n	a10, a1
42013284:	ff9665        	call8	42012bec <__lo0bits>
42013287:	0188      	l32i.n	a8, a1, 0
42013289:	20caa2        	addi	a10, a10, 32
4201328c:	5289      	s32i.n	a8, a2, 20
4201328e:	150c      	movi.n	a5, 1
42013290:	4259      	s32i.n	a5, a2, 16
42013292:	239c      	beqz.n	a3, 420132a8 <__d2b+0x98>
42013294:	cdab82        	movi	a8, 0xfffffbcd
42013297:	338a      	add.n	a3, a3, a8
42013299:	33aa      	add.n	a3, a3, a10
4201329b:	cbca52        	addi	a5, a10, -53
4201329e:	0639      	s32i.n	a3, a6, 0
420132a0:	605050        	neg	a5, a5
420132a3:	000706        	j	420132c3 <__d2b+0xb3>
420132a6:	820000        	mull	a0, a0, a0
420132a9:	ceab      	addi.n	a12, a14, 10
420132ab:	8a8a      	add.n	a8, a10, a8
420132ad:	0689      	s32i.n	a8, a6, 0
420132af:	c87c      	movi.n	a8, -4
420132b1:	a08580        	addx4	a8, a5, a8
420132b4:	808280        	add	a8, a2, a8
420132b7:	0528a2        	l32i	a10, a8, 20
420132ba:	1155b0        	slli	a5, a5, 5
420132bd:	ff8de5        	call8	42012b9c <__hi0bits>
420132c0:	c055a0        	sub	a5, a5, a10
420132c3:	0759      	s32i.n	a5, a7, 0
420132c5:	f01d      	retw.n
	...

420132c8 <__ratio>:
420132c8:	006136        	entry	a1, 48
420132cb:	b14b      	addi.n	a11, a1, 4
420132cd:	02ad      	mov.n	a10, a2
420132cf:	ffeb65        	call8	42013184 <__b2d>
420132d2:	0a4d      	mov.n	a4, a10
420132d4:	0b5d      	mov.n	a5, a11
420132d6:	0a6d      	mov.n	a6, a10
420132d8:	0b7d      	mov.n	a7, a11
420132da:	03ad      	mov.n	a10, a3
420132dc:	01bd      	mov.n	a11, a1
420132de:	ffea65        	call8	42013184 <__b2d>
420132e1:	0acd      	mov.n	a12, a10
420132e3:	0b9d      	mov.n	a9, a11
420132e5:	42a8      	l32i.n	a10, a2, 16
420132e7:	0bdd      	mov.n	a13, a11
420132e9:	43b8      	l32i.n	a11, a3, 16
420132eb:	01e8      	l32i.n	a14, a1, 0
420132ed:	c0aab0        	sub	a10, a10, a11
420132f0:	11b8      	l32i.n	a11, a1, 4
420132f2:	11aab0        	slli	a10, a10, 5
420132f5:	c0bbe0        	sub	a11, a11, a14
420132f8:	aaba      	add.n	a10, a10, a11
420132fa:	071aa6        	blti	a10, 1, 42013305 <__ratio+0x3d>
420132fd:	01aac0        	slli	a10, a10, 20
42013300:	7a5a      	add.n	a7, a10, a5
42013302:	000146        	j	4201330b <__ratio+0x43>
42013305:	01aac0        	slli	a10, a10, 20
42013308:	c0d9a0        	sub	a13, a9, a10
4201330b:	06ad      	mov.n	a10, a6
4201330d:	07bd      	mov.n	a11, a7
4201330f:	b6f081        	l32r	a8, 42000ed0 <_stext+0xeb0> (40002250 <__divdf3>)
42013312:	0008e0        	callx8	a8
42013315:	0a2d      	mov.n	a2, a10
42013317:	0b3d      	mov.n	a3, a11
42013319:	f01d      	retw.n
	...

4201331c <_mprec_log10>:
4201331c:	004136        	entry	a1, 32
4201331f:	ffa3b2        	movi	a11, 0x3ff
42013322:	781c      	movi.n	a8, 23
42013324:	0a0c      	movi.n	a10, 0
42013326:	01bbc0        	slli	a11, a11, 20
42013329:	0c2827        	blt	a8, a2, 42013339 <_mprec_log10+0x1d>
4201332c:	b6db81        	l32r	a8, 42000e98 <_stext+0xe78> (3c029dc0 <__mprec_tens>)
4201332f:	b07280        	addx8	a7, a2, a8
42013332:	07a8      	l32i.n	a10, a7, 0
42013334:	17b8      	l32i.n	a11, a7, 4
42013336:	000446        	j	4201334b <_mprec_log10+0x2f>
42013339:	b6dad1        	l32r	a13, 42000ea4 <_stext+0xe84> (40240000 <rom_rx_gain_force+0x239bd4>)
4201333c:	00a0c2        	movi	a12, 0
4201333f:	ffc222        	addi	a2, a2, -1
42013342:	b6b881        	l32r	a8, 42000e24 <_stext+0xe04> (40002418 <__muldf3>)
42013345:	0008e0        	callx8	a8
42013348:	fed256        	bnez	a2, 42013339 <_mprec_log10+0x1d>
4201334b:	0a2d      	mov.n	a2, a10
4201334d:	0b3d      	mov.n	a3, a11
4201334f:	f01d      	retw.n
42013351:	000000        	ill

42013354 <__copybits>:
42013354:	004136        	entry	a1, 32
42013357:	330b      	addi.n	a3, a3, -1
42013359:	4498      	l32i.n	a9, a4, 16
4201335b:	213530        	srai	a3, a3, 5
4201335e:	331b      	addi.n	a3, a3, 1
42013360:	14c482        	addi	a8, a4, 20
42013363:	a03320        	addx4	a3, a3, a2
42013366:	a09980        	addx4	a9, a9, a8
42013369:	02ad      	mov.n	a10, a2
4201336b:	0001c6        	j	42013376 <__copybits+0x22>
4201336e:	08b8      	l32i.n	a11, a8, 0
42013370:	884b      	addi.n	a8, a8, 4
42013372:	0ab9      	s32i.n	a11, a10, 0
42013374:	aa4b      	addi.n	a10, a10, 4
42013376:	f43897        	bltu	a8, a9, 4201336e <__copybits+0x1a>
42013379:	11c482        	addi	a8, a4, 17
4201337c:	628980        	lsi	f8, a9, 0x188
4201337f:	880b      	addi.n	a8, a8, -1
42013381:	608080        	neg	a8, a8
42013384:	748080        	extui	a8, a8, 0, 8
42013387:	0a0c      	movi.n	a10, 0
42013389:	c88c      	beqz.n	a8, 42013399 <__copybits+0x45>
4201338b:	11c442        	addi	a4, a4, 17
4201338e:	604040        	neg	a4, a4
42013391:	449a      	add.n	a4, a4, a9
42013393:	414240        	srli	a4, a4, 2
42013396:	11a4e0        	slli	a10, a4, 2
42013399:	22aa      	add.n	a2, a2, a10
4201339b:	080c      	movi.n	a8, 0
4201339d:	0000c6        	j	420133a4 <__copybits+0x50>
420133a0:	0289      	s32i.n	a8, a2, 0
420133a2:	224b      	addi.n	a2, a2, 4
420133a4:	f83237        	bltu	a2, a3, 420133a0 <__copybits+0x4c>
420133a7:	f01d      	retw.n
420133a9:	000000        	ill

420133ac <__any_on>:
420133ac:	004136        	entry	a1, 32
420133af:	42a8      	l32i.n	a10, a2, 16
420133b1:	218530        	srai	a8, a3, 5
420133b4:	14c292        	addi	a9, a2, 20
420133b7:	232a87        	blt	a10, a8, 420133de <__any_on+0x32>
420133ba:	22a8a7        	bge	a8, a10, 420133e0 <__any_on+0x34>
420133bd:	443030        	extui	a3, a3, 0, 5
420133c0:	c39c      	beqz.n	a3, 420133e0 <__any_on+0x34>
420133c2:	a0a890        	addx4	a10, a8, a9
420133c5:	0ab8      	l32i.n	a11, a10, 0
420133c7:	120c      	movi.n	a2, 1
420133c9:	400300        	ssr	a3
420133cc:	91a0b0        	srl	a10, a11
420133cf:	401300        	ssl	a3
420133d2:	a1aa00        	sll	a10, a10
420133d5:	219ba7        	bne	a11, a10, 420133fa <__any_on+0x4e>
420133d8:	000106        	j	420133e0 <__any_on+0x34>
420133db:	000000        	ill
420133de:	0a8d      	mov.n	a8, a10
420133e0:	a08890        	addx4	a8, a8, a9
420133e3:	000206        	j	420133ef <__any_on+0x43>
420133e6:	820000        	mull	a0, a0, a0
420133e9:	fcc8      	l32i.n	a12, a12, 60
420133eb:	08a8      	l32i.n	a10, a8, 0
420133ed:	7acc      	bnez.n	a10, 420133f8 <__any_on+0x4c>
420133ef:	f53987        	bltu	a9, a8, 420133e8 <__any_on+0x3c>
420133f2:	020c      	movi.n	a2, 0
420133f4:	000086        	j	420133fa <__any_on+0x4e>
420133f7:	120c00        	andbc	b0, b12, b0
420133fa:	f01d      	retw.n

420133fc <get_arg$isra$0>:
420133fc:	008136        	entry	a1, 64
420133ff:	102182        	l32i	a8, a1, 64
42013402:	1179      	s32i.n	a7, a1, 4
42013404:	0878      	l32i.n	a7, a8, 0
42013406:	2129      	s32i.n	a2, a1, 8
42013408:	21e8      	l32i.n	a14, a1, 8
4201340a:	0528      	l32i.n	a2, a5, 0
4201340c:	4159      	s32i.n	a5, a1, 16
4201340e:	0169      	s32i.n	a6, a1, 0
42013410:	837370        	moveqz	a7, a3, a7
42013413:	00e306        	j	420137a3 <get_arg$isra$0+0x3a7>
42013416:	771b      	addi.n	a7, a7, 1
42013418:	000782        	l8ui	a8, a7, 0
4201341b:	42f816        	beqz	a8, 4201384e <get_arg$isra$0+0x452>
4201341e:	dbc8a2        	addi	a10, a8, -37
42013421:	ff1a56        	bnez	a10, 42013416 <get_arg$isra$0+0x1a>
42013424:	426816        	beqz	a8, 4201384e <get_arg$isra$0+0x452>
42013427:	080c      	movi.n	a8, 0
42013429:	a71b      	addi.n	a10, a7, 1
4201342b:	050c      	movi.n	a5, 0
4201342d:	0d0c      	movi.n	a13, 0
4201342f:	f37c      	movi.n	a3, -1
42013431:	060c      	movi.n	a6, 0
42013433:	3189      	s32i.n	a8, a1, 12
42013435:	000046        	j	4201343a <get_arg$isra$0+0x3e>
42013438:	07ad      	mov.n	a10, a7
4201343a:	b66391        	l32r	a9, 42000dc8 <_stext+0xda8> (3c02a19c <__chclass>)
4201343d:	000a82        	l8ui	a8, a10, 0
42013440:	7a1b      	addi.n	a7, a10, 1
42013442:	b98a      	add.n	a11, a9, a8
42013444:	3198      	l32i.n	a9, a1, 12
42013446:	000bc2        	l8ui	a12, a11, 0
42013449:	b660b1        	l32r	a11, 42000dcc <_stext+0xdac> (3c02a130 <__state_table>)
4201344c:	b0f990        	addx8	a15, a9, a9
4201344f:	bbfa      	add.n	a11, a11, a15
42013451:	bbca      	add.n	a11, a11, a12
42013453:	000b92        	l8ui	a9, a11, 0
42013456:	b65eb1        	l32r	a11, 42000dd0 <_stext+0xdb0> (3c02a0c4 <__action_table>)
42013459:	3199      	s32i.n	a9, a1, 12
4201345b:	bbfa      	add.n	a11, a11, a15
4201345d:	bbca      	add.n	a11, a11, a12
4201345f:	000bb2        	l8ui	a11, a11, 0
42013462:	bb0b      	addi.n	a11, a11, -1
42013464:	74b0b0        	extui	a11, a11, 0, 8
42013467:	028bb6        	bltui	a11, 8, 4201346d <get_arg$isra$0+0x71>
4201346a:	00cac6        	j	42013799 <get_arg$isra$0+0x39d>
4201346d:	b69fc1        	l32r	a12, 42000eec <_stext+0xecc> (3c029e88 <__mprec_tens+0xc8>)
42013470:	a0bbc0        	addx4	a11, a11, a12
42013473:	0bb8      	l32i.n	a11, a11, 0
42013475:	000ba0        	jx	a11
42013478:	0c0000        	lsi	f0, a0, 48
4201347b:	069a      	add.n	a0, a6, a9
4201347d:	ad00c2        	l8ui	a12, a0, 173
42013480:	ac4607        	ball	a6, a0, 42013430 <get_arg$isra$0+0x34>
42013483:	a0b200        	addx4	a11, a2, a0
42013486:	b76a      	add.n	a11, a7, a6
42013488:	3318      	l32i.n	a1, a3, 12
4201348a:	0a3b87        	bltu	a11, a8, 42013498 <get_arg$isra$0+0x9c>
4201348d:	cb4c      	movi.n	a11, 76
4201348f:	2618b7        	beq	a8, a11, 420134b9 <get_arg$isra$0+0xbd>
42013492:	68a0b2        	movi	a11, 104
42013495:	0005c6        	j	420134b0 <get_arg$isra$0+0xb4>
42013498:	71a0b2        	movi	a11, 113
4201349b:	1f18b7        	beq	a8, a11, 420134be <get_arg$isra$0+0xc2>
4201349e:	70a0b2        	movi	a11, 112
420134a1:	23bb87        	bgeu	a11, a8, 420134c8 <get_arg$isra$0+0xcc>
420134a4:	74a0b2        	movi	a11, 116
420134a7:	0298b7        	bne	a8, a11, 420134ad <get_arg$isra$0+0xb1>
420134aa:	00bac6        	j	42013799 <get_arg$isra$0+0x39d>
420134ad:	7aa0b2        	movi	a11, 122
420134b0:	0298b7        	bne	a8, a11, 420134b6 <get_arg$isra$0+0xba>
420134b3:	00b886        	j	42013799 <get_arg$isra$0+0x39d>
420134b6:	000386        	j	420134c8 <get_arg$isra$0+0xcc>
420134b9:	880c      	movi.n	a8, 8
420134bb:	000046        	j	420134c0 <get_arg$isra$0+0xc4>
420134be:	082c      	movi.n	a8, 32
420134c0:	206680        	or	a6, a6, a8
420134c3:	00b486        	j	42013799 <get_arg$isra$0+0x39d>
420134c6:	b20000        	mulsh	a0, a0, a0
420134c9:	010a      	add.n	a0, a1, a0
420134cb:	6ca082        	movi	a8, 108
420134ce:	0a9b87        	bne	a11, a8, 420134dc <get_arg$isra$0+0xe0>
420134d1:	082c      	movi.n	a8, 32
420134d3:	206680        	or	a6, a6, a8
420134d6:	7a2b      	addi.n	a7, a10, 2
420134d8:	00af46        	j	42013799 <get_arg$isra$0+0x39d>
420134db:	081c00        	lsx	f1, a12, a0
420134de:	fff786        	j	420134c0 <get_arg$isra$0+0xc4>
420134e1:	61a0b2        	movi	a11, 97
420134e4:	44a020        	extui	a10, a2, 0, 5
420134e7:	0298b7        	bne	a8, a11, 420134ed <get_arg$isra$0+0xf1>
420134ea:	00e506        	j	42013882 <get_arg$isra$0+0x486>
420134ed:	3b3b87        	bltu	a11, a8, 4201352c <get_arg$isra$0+0x130>
420134f0:	bfc882        	addi	a8, a8, -65
420134f3:	748080        	extui	a8, a8, 0, 8
420134f6:	7b1c      	movi.n	a11, 23
420134f8:	24bb87        	bgeu	a11, a8, 42013520 <get_arg$isra$0+0x124>
420134fb:	001686        	j	42013559 <get_arg$isra$0+0x15d>
420134fe:	180c      	movi.n	a8, 1
42013500:	401b00        	ssl	a11
42013503:	a18800        	sll	a8, a8
42013506:	b634b1        	l32r	a11, 42000dd8 <_stext+0xdb8> (120821 <UserFrameTotalSize+0x120721>)
42013509:	3388b7        	bany	a8, a11, 42013540 <get_arg$isra$0+0x144>
4201350c:	5b2c      	movi.n	a11, 37
4201350e:	11bb60        	slli	a11, a11, 10
42013511:	0208b7        	bnone	a8, a11, 42013517 <get_arg$isra$0+0x11b>
42013514:	00dd46        	j	4201388d <get_arg$isra$0+0x491>
42013517:	248180        	extui	a8, a8, 1, 3
4201351a:	364856        	bnez	a8, 42013882 <get_arg$isra$0+0x486>
4201351d:	000e06        	j	42013559 <get_arg$isra$0+0x15d>
42013520:	b674b1        	l32r	a11, 42000ef0 <_stext+0xed0> (3c029ea8 <__mprec_tens+0xe8>)
42013523:	a088b0        	addx4	a8, a8, a11
42013526:	0888      	l32i.n	a8, a8, 0
42013528:	0008a0        	jx	a8
4201352b:	a0b200        	addx4	a11, a2, a0
4201352e:	18b763        	lsi	f6, a7, 96
42013531:	8219      	s32i.n	a1, a2, 32
42013533:	9cc8      	l32i.n	a12, a12, 36
42013535:	74b080        	extui	a11, a8, 0, 8
42013538:	481c      	movi.n	a8, 20
4201353a:	c0b8b7        	bgeu	a8, a11, 420134fe <get_arg$isra$0+0x102>
4201353d:	000606        	j	42013559 <get_arg$isra$0+0x15d>
42013540:	045560        	extui	a5, a6, 5, 1
42013543:	555a      	add.n	a5, a5, a5
42013545:	106647        	bbci	a6, 4, 42013559 <get_arg$isra$0+0x15d>
42013548:	00d806        	j	420138ac <get_arg$isra$0+0x4b0>
4201354b:	051c00        	extui	a1, a0, 28, 1
4201354e:	105650        	and	a5, a6, a5
42013551:	34c556        	bnez	a5, 420138a1 <get_arg$isra$0+0x4a5>
42013554:	00d006        	j	42013898 <get_arg$isra$0+0x49c>
42013557:	260000        	lsi	f0, a0, 152
4201355a:	880b03        	lsi	f0, a11, 0x220
4201355d:	0a2d11        	l32r	a1, 41fd5e14 <_coredump_iram_end+0x1c53e14>
42013560:	a08380        	addx4	a8, a3, a8
42013563:	0859      	s32i.n	a5, a8, 0
42013565:	008c06        	j	42013799 <get_arg$isra$0+0x39d>
42013568:	b50b      	addi.n	a11, a5, -1
4201356a:	2488      	l32i.n	a8, a4, 8
4201356c:	2a1b      	addi.n	a2, a10, 1
4201356e:	026bb6        	bltui	a11, 6, 42013574 <get_arg$isra$0+0x178>
42013571:	002806        	j	42013615 <get_arg$isra$0+0x219>
42013574:	b660c1        	l32r	a12, 42000ef4 <_stext+0xed4> (3c029f08 <__mprec_tens+0x148>)
42013577:	a0bbc0        	addx4	a11, a11, a12
4201357a:	0bc8      	l32i.n	a12, a11, 0
4201357c:	f4b0a0        	extui	a11, a10, 0, 16
4201357f:	000ca0        	jx	a12
42013582:	0188      	l32i.n	a8, a1, 0
42013584:	24b8      	l32i.n	a11, a4, 8
42013586:	2a1b      	addi.n	a2, a10, 1
42013588:	b0aa80        	addx8	a10, a10, a8
4201358b:	8b4b      	addi.n	a8, a11, 4
4201358d:	2489      	s32i.n	a8, a4, 8
4201358f:	8c1c      	movi.n	a12, 24
42013591:	042c87        	blt	a12, a8, 42013599 <get_arg$isra$0+0x19d>
42013594:	14b8      	l32i.n	a11, a4, 4
42013596:	000206        	j	420135a2 <get_arg$isra$0+0x1a6>
42013599:	012cb7        	blt	a12, a11, 4201359e <get_arg$isra$0+0x1a2>
4201359c:	482c      	movi.n	a8, 36
4201359e:	04b8      	l32i.n	a11, a4, 0
420135a0:	2489      	s32i.n	a8, a4, 8
420135a2:	bb8a      	add.n	a11, a11, a8
420135a4:	fccbb2        	addi	a11, a11, -4
420135a7:	0b88      	l32i.n	a8, a11, 0
420135a9:	f37c      	movi.n	a3, -1
420135ab:	0a89      	s32i.n	a8, a10, 0
420135ad:	150c      	movi.n	a5, 1
420135af:	007986        	j	42013799 <get_arg$isra$0+0x39d>
420135b2:	8a7c      	movi.n	a10, -8
420135b4:	887b      	addi.n	a8, a8, 7
420135b6:	1088a0        	and	a8, a8, a10
420135b9:	0198      	l32i.n	a9, a1, 0
420135bb:	a88b      	addi.n	a10, a8, 8
420135bd:	24a9      	s32i.n	a10, a4, 8
420135bf:	8c1c      	movi.n	a12, 24
420135c1:	b0bb90        	addx8	a11, a11, a9
420135c4:	042ca7        	blt	a12, a10, 420135cc <get_arg$isra$0+0x1d0>
420135c7:	1488      	l32i.n	a8, a4, 4
420135c9:	000206        	j	420135d5 <get_arg$isra$0+0x1d9>
420135cc:	012c87        	blt	a12, a8, 420135d1 <get_arg$isra$0+0x1d5>
420135cf:	8a2c      	movi.n	a10, 40
420135d1:	0488      	l32i.n	a8, a4, 0
420135d3:	24a9      	s32i.n	a10, a4, 8
420135d5:	88aa      	add.n	a8, a8, a10
420135d7:	f8c882        	addi	a8, a8, -8
420135da:	1898      	l32i.n	a9, a8, 4
420135dc:	0888      	l32i.n	a8, a8, 0
420135de:	1b99      	s32i.n	a9, a11, 4
420135e0:	0b89      	s32i.n	a8, a11, 0
420135e2:	006cc6        	j	42013799 <get_arg$isra$0+0x39d>
420135e5:	0188      	l32i.n	a8, a1, 0
420135e7:	24b8      	l32i.n	a11, a4, 8
420135e9:	2a1b      	addi.n	a2, a10, 1
420135eb:	b0aa80        	addx8	a10, a10, a8
420135ee:	8b4b      	addi.n	a8, a11, 4
420135f0:	2489      	s32i.n	a8, a4, 8
420135f2:	8c1c      	movi.n	a12, 24
420135f4:	042c87        	blt	a12, a8, 420135fc <get_arg$isra$0+0x200>
420135f7:	14b8      	l32i.n	a11, a4, 4
420135f9:	000206        	j	42013605 <get_arg$isra$0+0x209>
420135fc:	012cb7        	blt	a12, a11, 42013601 <get_arg$isra$0+0x205>
420135ff:	482c      	movi.n	a8, 36
42013601:	04b8      	l32i.n	a11, a4, 0
42013603:	2489      	s32i.n	a8, a4, 8
42013605:	bb8a      	add.n	a11, a11, a8
42013607:	fccbb2        	addi	a11, a11, -4
4201360a:	0b88      	l32i.n	a8, a11, 0
4201360c:	f37c      	movi.n	a3, -1
4201360e:	0a89      	s32i.n	a8, a10, 0
42013610:	650c      	movi.n	a5, 6
42013612:	0060c6        	j	42013799 <get_arg$isra$0+0x39d>
42013615:	0188      	l32i.n	a8, a1, 0
42013617:	24b8      	l32i.n	a11, a4, 8
42013619:	2a1b      	addi.n	a2, a10, 1
4201361b:	b0aa80        	addx8	a10, a10, a8
4201361e:	8b4b      	addi.n	a8, a11, 4
42013620:	2489      	s32i.n	a8, a4, 8
42013622:	8c1c      	movi.n	a12, 24
42013624:	042c87        	blt	a12, a8, 4201362c <get_arg$isra$0+0x230>
42013627:	14b8      	l32i.n	a11, a4, 4
42013629:	000206        	j	42013635 <get_arg$isra$0+0x239>
4201362c:	012cb7        	blt	a12, a11, 42013631 <get_arg$isra$0+0x235>
4201362f:	482c      	movi.n	a8, 36
42013631:	04b8      	l32i.n	a11, a4, 0
42013633:	2489      	s32i.n	a8, a4, 8
42013635:	bb8a      	add.n	a11, a11, a8
42013637:	fccbb2        	addi	a11, a11, -4
4201363a:	0b88      	l32i.n	a8, a11, 0
4201363c:	f37c      	movi.n	a3, -1
4201363e:	0a89      	s32i.n	a8, a10, 0
42013640:	050c      	movi.n	a5, 0
42013642:	0054c6        	j	42013799 <get_arg$isra$0+0x39d>
42013645:	0188      	l32i.n	a8, a1, 0
42013647:	24b8      	l32i.n	a11, a4, 8
42013649:	2a1b      	addi.n	a2, a10, 1
4201364b:	b0aa80        	addx8	a10, a10, a8
4201364e:	8b4b      	addi.n	a8, a11, 4
42013650:	2489      	s32i.n	a8, a4, 8
42013652:	8c1c      	movi.n	a12, 24
42013654:	042c87        	blt	a12, a8, 4201365c <get_arg$isra$0+0x260>
42013657:	14b8      	l32i.n	a11, a4, 4
42013659:	000206        	j	42013665 <get_arg$isra$0+0x269>
4201365c:	012cb7        	blt	a12, a11, 42013661 <get_arg$isra$0+0x265>
4201365f:	482c      	movi.n	a8, 36
42013661:	04b8      	l32i.n	a11, a4, 0
42013663:	2489      	s32i.n	a8, a4, 8
42013665:	bb8a      	add.n	a11, a11, a8
42013667:	fccbb2        	addi	a11, a11, -4
4201366a:	0b88      	l32i.n	a8, a11, 0
4201366c:	f37c      	movi.n	a3, -1
4201366e:	0a89      	s32i.n	a8, a10, 0
42013670:	350c      	movi.n	a5, 3
42013672:	0048c6        	j	42013799 <get_arg$isra$0+0x39d>
42013675:	0188      	l32i.n	a8, a1, 0
42013677:	2a1b      	addi.n	a2, a10, 1
42013679:	b0aa80        	addx8	a10, a10, a8
4201367c:	2488      	l32i.n	a8, a4, 8
4201367e:	8b7c      	movi.n	a11, -8
42013680:	887b      	addi.n	a8, a8, 7
42013682:	1088b0        	and	a8, a8, a11
42013685:	b88b      	addi.n	a11, a8, 8
42013687:	24b9      	s32i.n	a11, a4, 8
42013689:	8c1c      	movi.n	a12, 24
4201368b:	052cb7        	blt	a12, a11, 42013694 <get_arg$isra$0+0x298>
4201368e:	1488      	l32i.n	a8, a4, 4
42013690:	000246        	j	4201369d <get_arg$isra$0+0x2a1>
42013693:	2c8700        	lsi	f0, a7, 176
42013696:	8b2c01        	l32r	a0, 41ff6348 <_coredump_iram_end+0x1c74348>
42013699:	0488      	l32i.n	a8, a4, 0
4201369b:	24b9      	s32i.n	a11, a4, 8
4201369d:	88ba      	add.n	a8, a8, a11
4201369f:	f8c882        	addi	a8, a8, -8
420136a2:	1898      	l32i.n	a9, a8, 4
420136a4:	0888      	l32i.n	a8, a8, 0
420136a6:	f37c      	movi.n	a3, -1
420136a8:	0a89      	s32i.n	a8, a10, 0
420136aa:	1a99      	s32i.n	a9, a10, 4
420136ac:	450c      	movi.n	a5, 4
420136ae:	0039c6        	j	42013799 <get_arg$isra$0+0x39d>
420136b1:	8a7c      	movi.n	a10, -8
420136b3:	887b      	addi.n	a8, a8, 7
420136b5:	1088a0        	and	a8, a8, a10
420136b8:	0198      	l32i.n	a9, a1, 0
420136ba:	a88b      	addi.n	a10, a8, 8
420136bc:	24a9      	s32i.n	a10, a4, 8
420136be:	8c1c      	movi.n	a12, 24
420136c0:	b0bb90        	addx8	a11, a11, a9
420136c3:	052ca7        	blt	a12, a10, 420136cc <get_arg$isra$0+0x2d0>
420136c6:	1488      	l32i.n	a8, a4, 4
420136c8:	000246        	j	420136d5 <get_arg$isra$0+0x2d9>
420136cb:	2c8700        	lsi	f0, a7, 176
420136ce:	8a2c01        	l32r	a0, 41ff5f80 <_coredump_iram_end+0x1c73f80>
420136d1:	0488      	l32i.n	a8, a4, 0
420136d3:	24a9      	s32i.n	a10, a4, 8
420136d5:	88aa      	add.n	a8, a8, a10
420136d7:	f8c882        	addi	a8, a8, -8
420136da:	1898      	l32i.n	a9, a8, 4
420136dc:	0888      	l32i.n	a8, a8, 0
420136de:	1b99      	s32i.n	a9, a11, 4
420136e0:	0b89      	s32i.n	a8, a11, 0
420136e2:	002cc6        	j	42013799 <get_arg$isra$0+0x39d>
420136e5:	1188      	l32i.n	a8, a1, 4
420136e7:	0888      	l32i.n	a8, a8, 0
420136e9:	140866        	bnei	a8, -1, 42013701 <get_arg$isra$0+0x305>
420136ec:	11a8      	l32i.n	a10, a1, 4
420136ee:	80a0c2        	movi	a12, 128
420136f1:	0b0c      	movi.n	a11, 0
420136f3:	61d9      	s32i.n	a13, a1, 24
420136f5:	51e9      	s32i.n	a14, a1, 20
420136f7:	b30281        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420136fa:	0008e0        	callx8	a8
420136fd:	61d8      	l32i.n	a13, a1, 24
420136ff:	51e8      	l32i.n	a14, a1, 20
42013701:	3d0b      	addi.n	a3, a13, -1
42013703:	53ee30        	max	a14, a14, a3
42013706:	0023c6        	j	42013799 <get_arg$isra$0+0x39d>
42013709:	1188      	l32i.n	a8, a1, 4
4201370b:	0888      	l32i.n	a8, a8, 0
4201370d:	140866        	bnei	a8, -1, 42013725 <get_arg$isra$0+0x329>
42013710:	11a8      	l32i.n	a10, a1, 4
42013712:	80a0c2        	movi	a12, 128
42013715:	0b0c      	movi.n	a11, 0
42013717:	61d9      	s32i.n	a13, a1, 24
42013719:	51e9      	s32i.n	a14, a1, 20
4201371b:	b2f981        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4201371e:	0008e0        	callx8	a8
42013721:	61d8      	l32i.n	a13, a1, 24
42013723:	51e8      	l32i.n	a14, a1, 20
42013725:	1188      	l32i.n	a8, a1, 4
42013727:	dd0b      	addi.n	a13, a13, -1
42013729:	a08d80        	addx4	a8, a13, a8
4201372c:	0a0c      	movi.n	a10, 0
4201372e:	08a9      	s32i.n	a10, a8, 0
42013730:	53eed0        	max	a14, a14, a13
42013733:	001886        	j	42013799 <get_arg$isra$0+0x39d>
42013736:	0188      	l32i.n	a8, a1, 0
42013738:	24b8      	l32i.n	a11, a4, 8
4201373a:	f21b      	addi.n	a15, a2, 1
4201373c:	b02280        	addx8	a2, a2, a8
4201373f:	8b4b      	addi.n	a8, a11, 4
42013741:	2489      	s32i.n	a8, a4, 8
42013743:	8c1c      	movi.n	a12, 24
42013745:	042c87        	blt	a12, a8, 4201374d <get_arg$isra$0+0x351>
42013748:	14b8      	l32i.n	a11, a4, 4
4201374a:	000206        	j	42013756 <get_arg$isra$0+0x35a>
4201374d:	012cb7        	blt	a12, a11, 42013752 <get_arg$isra$0+0x356>
42013750:	482c      	movi.n	a8, 36
42013752:	04b8      	l32i.n	a11, a4, 0
42013754:	2489      	s32i.n	a8, a4, 8
42013756:	bb8a      	add.n	a11, a11, a8
42013758:	fccbb2        	addi	a11, a11, -4
4201375b:	0b88      	l32i.n	a8, a11, 0
4201375d:	0a7d      	mov.n	a7, a10
4201375f:	0289      	s32i.n	a8, a2, 0
42013761:	0f2d      	mov.n	a2, a15
42013763:	000c86        	j	42013799 <get_arg$isra$0+0x39d>
42013766:	d20000        	quos	a0, a0, a0
42013769:	d0c8      	l32i.n	a12, a0, 52
4201376b:	9a0c      	movi.n	a10, 9
4201376d:	0001c6        	j	42013778 <get_arg$isra$0+0x37c>
42013770:	a0ddd0        	addx4	a13, a13, a13
42013773:	90dd80        	addx2	a13, a13, a8
42013776:	771b      	addi.n	a7, a7, 1
42013778:	000782        	l8ui	a8, a7, 0
4201377b:	a89c      	beqz.n	a8, 42013799 <get_arg$isra$0+0x39d>
4201377d:	d0c882        	addi	a8, a8, -48
42013780:	ecba87        	bgeu	a10, a8, 42013770 <get_arg$isra$0+0x374>
42013783:	000486        	j	42013799 <get_arg$isra$0+0x39d>
42013786:	820000        	mull	a0, a0, a0
42013789:	820007        	bnone	a0, a0, 4201370f <get_arg$isra$0+0x313>
4201378c:	d0c8      	l32i.n	a12, a0, 52
4201378e:	748080        	extui	a8, a8, 0, 8
42013791:	043a87        	bltu	a10, a8, 42013799 <get_arg$isra$0+0x39d>
42013794:	771b      	addi.n	a7, a7, 1
42013796:	fffb86        	j	42013788 <get_arg$isra$0+0x38c>
42013799:	3198      	l32i.n	a9, a1, 12
4201379b:	b80c      	movi.n	a8, 11
4201379d:	021987        	beq	a9, a8, 420137a3 <get_arg$isra$0+0x3a7>
420137a0:	ff2506        	j	42013438 <get_arg$isra$0+0x3c>
420137a3:	0007a2        	l8ui	a10, a7, 0
420137a6:	ea8c      	beqz.n	a10, 420137b8 <get_arg$isra$0+0x3bc>
420137a8:	2188      	l32i.n	a8, a1, 8
420137aa:	728820        	lsi	f2, a8, 0x1c8
420137ad:	880b      	addi.n	a8, a8, -1
420137af:	608080        	neg	a8, a8
420137b2:	748080        	extui	a8, a8, 0, 8
420137b5:	c5f856        	bnez	a8, 42013418 <get_arg$isra$0+0x1c>
420137b8:	2188      	l32i.n	a8, a1, 8
420137ba:	93e8a0        	movnez	a14, a8, a10
420137bd:	002346        	j	4201384e <get_arg$isra$0+0x452>
420137c0:	1188      	l32i.n	a8, a1, 4
420137c2:	a08d80        	addx4	a8, a13, a8
420137c5:	08c8      	l32i.n	a12, a8, 0
420137c7:	dd1b      	addi.n	a13, a13, 1
420137c9:	cc0b      	addi.n	a12, a12, -1
420137cb:	2488      	l32i.n	a8, a4, 8
420137cd:	5c6cf6        	bgeui	a12, 6, 4201382d <get_arg$isra$0+0x431>
420137d0:	a0cc60        	addx4	a12, a12, a6
420137d3:	0cc8      	l32i.n	a12, a12, 0
420137d5:	000ca0        	jx	a12
420137d8:	887b      	addi.n	a8, a8, 7
420137da:	1088f0        	and	a8, a8, a15
420137dd:	c88b      	addi.n	a12, a8, 8
420137df:	24c9      	s32i.n	a12, a4, 8
420137e1:	042ac7        	blt	a10, a12, 420137e9 <get_arg$isra$0+0x3ed>
420137e4:	1488      	l32i.n	a8, a4, 4
420137e6:	000206        	j	420137f2 <get_arg$isra$0+0x3f6>
420137e9:	012a87        	blt	a10, a8, 420137ee <get_arg$isra$0+0x3f2>
420137ec:	8c2c      	movi.n	a12, 40
420137ee:	0488      	l32i.n	a8, a4, 0
420137f0:	24c9      	s32i.n	a12, a4, 8
420137f2:	88ca      	add.n	a8, a8, a12
420137f4:	f8c882        	addi	a8, a8, -8
420137f7:	1898      	l32i.n	a9, a8, 4
420137f9:	0888      	l32i.n	a8, a8, 0
420137fb:	1b99      	s32i.n	a9, a11, 4
420137fd:	0b89      	s32i.n	a8, a11, 0
420137ff:	001706        	j	4201385f <get_arg$isra$0+0x463>
42013802:	887b      	addi.n	a8, a8, 7
42013804:	1088f0        	and	a8, a8, a15
42013807:	c88b      	addi.n	a12, a8, 8
42013809:	24c9      	s32i.n	a12, a4, 8
4201380b:	052ac7        	blt	a10, a12, 42013814 <get_arg$isra$0+0x418>
4201380e:	1488      	l32i.n	a8, a4, 4
42013810:	000246        	j	4201381d <get_arg$isra$0+0x421>
42013813:	2a8700        	mul.s	f8, f7, f0
42013816:	8c2c01        	l32r	a0, 41ff68c8 <_coredump_iram_end+0x1c748c8>
42013819:	0488      	l32i.n	a8, a4, 0
4201381b:	24c9      	s32i.n	a12, a4, 8
4201381d:	88ca      	add.n	a8, a8, a12
4201381f:	f8c882        	addi	a8, a8, -8
42013822:	1898      	l32i.n	a9, a8, 4
42013824:	0888      	l32i.n	a8, a8, 0
42013826:	1b99      	s32i.n	a9, a11, 4
42013828:	0b89      	s32i.n	a8, a11, 0
4201382a:	000c46        	j	4201385f <get_arg$isra$0+0x463>
4201382d:	c84b      	addi.n	a12, a8, 4
4201382f:	24c9      	s32i.n	a12, a4, 8
42013831:	042ac7        	blt	a10, a12, 42013839 <get_arg$isra$0+0x43d>
42013834:	1488      	l32i.n	a8, a4, 4
42013836:	000206        	j	42013842 <get_arg$isra$0+0x446>
42013839:	012a87        	blt	a10, a8, 4201383e <get_arg$isra$0+0x442>
4201383c:	4c2c      	movi.n	a12, 36
4201383e:	0488      	l32i.n	a8, a4, 0
42013840:	24c9      	s32i.n	a12, a4, 8
42013842:	88ca      	add.n	a8, a8, a12
42013844:	fcc882        	addi	a8, a8, -4
42013847:	0888      	l32i.n	a8, a8, 0
42013849:	0b89      	s32i.n	a8, a11, 0
4201384b:	000406        	j	4201385f <get_arg$isra$0+0x463>
4201384e:	0188      	l32i.n	a8, a1, 0
42013850:	b5aa61        	l32r	a6, 42000ef8 <_stext+0xed8> (3c029f20 <__mprec_tens+0x160>)
42013853:	b0b280        	addx8	a11, a2, a8
42013856:	02dd      	mov.n	a13, a2
42013858:	8a1c      	movi.n	a10, 24
4201385a:	8f7c      	movi.n	a15, -8
4201385c:	000046        	j	42013861 <get_arg$isra$0+0x465>
4201385f:	bb8b      	addi.n	a11, a11, 8
42013861:	022ed7        	blt	a14, a13, 42013867 <get_arg$isra$0+0x46b>
42013864:	ffd606        	j	420137c0 <get_arg$isra$0+0x3c4>
42013867:	8e1b      	addi.n	a8, a14, 1
42013869:	728820        	lsi	f2, a8, 0x1c8
4201386c:	880b      	addi.n	a8, a8, -1
4201386e:	608080        	neg	a8, a8
42013871:	748080        	extui	a8, a8, 0, 8
42013874:	0a0c      	movi.n	a10, 0
42013876:	d8bc      	beqz.n	a8, 420138b7 <get_arg$isra$0+0x4bb>
42013878:	820b      	addi.n	a8, a2, -1
4201387a:	608080        	neg	a8, a8
4201387d:	a8ea      	add.n	a10, a8, a14
4201387f:	000d06        	j	420138b7 <get_arg$isra$0+0x4bb>
42013882:	450c      	movi.n	a5, 4
42013884:	020326        	beqi	a3, -1, 4201388a <get_arg$isra$0+0x48e>
42013887:	ff3446        	j	4201355c <get_arg$isra$0+0x160>
4201388a:	ff79c6        	j	42013675 <get_arg$isra$0+0x279>
4201388d:	350c      	movi.n	a5, 3
4201388f:	020326        	beqi	a3, -1, 42013895 <get_arg$isra$0+0x499>
42013892:	ff3186        	j	4201355c <get_arg$isra$0+0x160>
42013895:	ff6b06        	j	42013645 <get_arg$isra$0+0x249>
42013898:	020326        	beqi	a3, -1, 4201389e <get_arg$isra$0+0x4a2>
4201389b:	ff2f46        	j	4201355c <get_arg$isra$0+0x160>
4201389e:	ff5cc6        	j	42013615 <get_arg$isra$0+0x219>
420138a1:	650c      	movi.n	a5, 6
420138a3:	020326        	beqi	a3, -1, 420138a9 <get_arg$isra$0+0x4ad>
420138a6:	ff2c86        	j	4201355c <get_arg$isra$0+0x160>
420138a9:	ff4e06        	j	420135e5 <get_arg$isra$0+0x1e9>
420138ac:	150c      	movi.n	a5, 1
420138ae:	020326        	beqi	a3, -1, 420138b4 <get_arg$isra$0+0x4b8>
420138b1:	ff29c6        	j	4201355c <get_arg$isra$0+0x160>
420138b4:	ff3286        	j	42013582 <get_arg$isra$0+0x186>
420138b7:	4198      	l32i.n	a9, a1, 16
420138b9:	8a2a      	add.n	a8, a10, a2
420138bb:	0989      	s32i.n	a8, a9, 0
420138bd:	102182        	l32i	a8, a1, 64
420138c0:	0198      	l32i.n	a9, a1, 0
420138c2:	0879      	s32i.n	a7, a8, 0
420138c4:	2188      	l32i.n	a8, a1, 8
420138c6:	b02890        	addx8	a2, a8, a9
420138c9:	f01d      	retw.n
	...

420138cc <__ssprint_r>:
420138cc:	006136        	entry	a1, 48
420138cf:	2498      	l32i.n	a9, a4, 8
420138d1:	0129      	s32i.n	a2, a1, 0
420138d3:	035d      	mov.n	a5, a3
420138d5:	398c      	beqz.n	a9, 420138dc <__ssprint_r+0x10>
420138d7:	0468      	l32i.n	a6, a4, 0
420138d9:	000106        	j	420138e1 <__ssprint_r+0x15>
420138dc:	020c      	movi.n	a2, 0
420138de:	003b46        	j	420139cf <__ssprint_r+0x103>
420138e1:	0688      	l32i.n	a8, a6, 0
420138e3:	1638      	l32i.n	a3, a6, 4
420138e5:	1189      	s32i.n	a8, a1, 4
420138e7:	668b      	addi.n	a6, a6, 8
420138e9:	ff4316        	beqz	a3, 420138e1 <__ssprint_r+0x15>
420138ec:	25d8      	l32i.n	a13, a5, 8
420138ee:	0d7d      	mov.n	a7, a13
420138f0:	02b3d7        	bgeu	a3, a13, 420138f6 <__ssprint_r+0x2a>
420138f3:	0024c6        	j	4201398a <__ssprint_r+0xbe>
420138f6:	0695f2        	l16si	a15, a5, 12
420138f9:	80a482        	movi	a8, 0x480
420138fc:	109f80        	and	a9, a15, a8
420138ff:	239980        	sext	a9, a9, 15
42013902:	088916        	beqz	a9, 4201398e <__ssprint_r+0xc2>
42013905:	55a8      	l32i.n	a10, a5, 20
42013907:	45b8      	l32i.n	a11, a5, 16
42013909:	0578      	l32i.n	a7, a5, 0
4201390b:	90aaa0        	addx2	a10, a10, a10
4201390e:	059fa0        	extui	a9, a10, 31, 1
42013911:	c077b0        	sub	a7, a7, a11
42013914:	99aa      	add.n	a9, a9, a10
42013916:	a71b      	addi.n	a10, a7, 1
42013918:	212190        	srai	a2, a9, 1
4201391b:	aa3a      	add.n	a10, a10, a3
4201391d:	20c220        	or	a12, a2, a2
42013920:	04b2a7        	bgeu	a2, a10, 42013928 <__ssprint_r+0x5c>
42013923:	0a2d      	mov.n	a2, a10
42013925:	20caa0        	or	a12, a10, a10
42013928:	326fa7        	bbci	a15, 10, 4201395e <__ssprint_r+0x92>
4201392b:	01a8      	l32i.n	a10, a1, 0
4201392d:	0cbd      	mov.n	a11, a12
4201392f:	b51881        	l32r	a8, 42000d90 <_stext+0xd70> (4037fef4 <_malloc_r>)
42013932:	0008e0        	callx8	a8
42013935:	07fa16        	beqz	a10, 420139b8 <__ssprint_r+0xec>
42013938:	45b8      	l32i.n	a11, a5, 16
4201393a:	07cd      	mov.n	a12, a7
4201393c:	21a9      	s32i.n	a10, a1, 8
4201393e:	b1ba81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42013941:	0008e0        	callx8	a8
42013944:	0615a2        	l16ui	a10, a5, 12
42013947:	7fabb2        	movi	a11, 0xfffffb7f
4201394a:	10aab0        	and	a10, a10, a11
4201394d:	80a0b2        	movi	a11, 128
42013950:	20aab0        	or	a10, a10, a11
42013953:	21d8      	l32i.n	a13, a1, 8
42013955:	0655a2        	s16i	a10, a5, 12
42013958:	000706        	j	42013978 <__ssprint_r+0xac>
4201395b:	000000        	ill
4201395e:	01a8      	l32i.n	a10, a1, 0
42013960:	b51181        	l32r	a8, 42000da4 <_stext+0xd84> (4037fee0 <_realloc_r>)
42013963:	0008e0        	callx8	a8
42013966:	0add      	mov.n	a13, a10
42013968:	cacc      	bnez.n	a10, 42013978 <__ssprint_r+0xac>
4201396a:	45b8      	l32i.n	a11, a5, 16
4201396c:	01a8      	l32i.n	a10, a1, 0
4201396e:	b4f881        	l32r	a8, 42000d50 <_stext+0xd30> (4037fed4 <_free_r>)
42013971:	0008e0        	callx8	a8
42013974:	001006        	j	420139b8 <__ssprint_r+0xec>
42013977:	45d900        	extui	a13, a0, 25, 5
4201397a:	c09270        	sub	a9, a2, a7
4201397d:	dd7a      	add.n	a13, a13, a7
4201397f:	05d9      	s32i.n	a13, a5, 0
42013981:	5529      	s32i.n	a2, a5, 20
42013983:	03dd      	mov.n	a13, a3
42013985:	2599      	s32i.n	a9, a5, 8
42013987:	000046        	j	4201398c <__ssprint_r+0xc0>
4201398a:	03dd      	mov.n	a13, a3
4201398c:	037d      	mov.n	a7, a3
4201398e:	11b8      	l32i.n	a11, a1, 4
42013990:	05a8      	l32i.n	a10, a5, 0
42013992:	07cd      	mov.n	a12, a7
42013994:	21d9      	s32i.n	a13, a1, 8
42013996:	b3ea81        	l32r	a8, 42000940 <_stext+0x920> (40001200 <memmove>)
42013999:	0008e0        	callx8	a8
4201399c:	2598      	l32i.n	a9, a5, 8
4201399e:	21d8      	l32i.n	a13, a1, 8
420139a0:	c099d0        	sub	a9, a9, a13
420139a3:	2599      	s32i.n	a9, a5, 8
420139a5:	0598      	l32i.n	a9, a5, 0
420139a7:	997a      	add.n	a9, a9, a7
420139a9:	0599      	s32i.n	a9, a5, 0
420139ab:	2498      	l32i.n	a9, a4, 8
420139ad:	c09930        	sub	a9, a9, a3
420139b0:	2499      	s32i.n	a9, a4, 8
420139b2:	f2b956        	bnez	a9, 420138e1 <__ssprint_r+0x15>
420139b5:	ffc8c6        	j	420138dc <__ssprint_r+0x10>
420139b8:	0188      	l32i.n	a8, a1, 0
420139ba:	c90c      	movi.n	a9, 12
420139bc:	0899      	s32i.n	a9, a8, 0
420139be:	061592        	l16ui	a9, a5, 12
420139c1:	0a4c      	movi.n	a10, 64
420139c3:	2099a0        	or	a9, a9, a10
420139c6:	065592        	s16i	a9, a5, 12
420139c9:	080c      	movi.n	a8, 0
420139cb:	2489      	s32i.n	a8, a4, 8
420139cd:	f27c      	movi.n	a2, -1
420139cf:	080c      	movi.n	a8, 0
420139d1:	1489      	s32i.n	a8, a4, 4
420139d3:	f01d      	retw.n
420139d5:	000000        	ill

420139d8 <_svfiprintf_r>:
420139d8:	058136        	entry	a1, 0x2c0
420139db:	9a6142        	s32i	a4, a1, 0x268
420139de:	061382        	l16ui	a8, a3, 12
420139e1:	9d6122        	s32i	a2, a1, 0x274
420139e4:	9c6132        	s32i	a3, a1, 0x270
420139e7:	946152        	s32i	a5, a1, 0x250
420139ea:	956162        	s32i	a6, a1, 0x254
420139ed:	966172        	s32i	a7, a1, 0x258
420139f0:	10c142        	addi	a4, a1, 16
420139f3:	296877        	bbci	a8, 7, 42013a20 <_svfiprintf_r+0x48>
420139f6:	4388      	l32i.n	a8, a3, 16
420139f8:	48ec      	bnez.n	a8, 42013a20 <_svfiprintf_r+0x48>
420139fa:	0b4c      	movi.n	a11, 64
420139fc:	02ad      	mov.n	a10, a2
420139fe:	b4e481        	l32r	a8, 42000d90 <_stext+0xd70> (4037fef4 <_malloc_r>)
42013a01:	0008e0        	callx8	a8
42013a04:	9c2182        	l32i	a8, a1, 0x270
42013a07:	08a9      	s32i.n	a10, a8, 0
42013a09:	48a9      	s32i.n	a10, a8, 16
42013a0b:	aacc      	bnez.n	a10, 42013a19 <_svfiprintf_r+0x41>
42013a0d:	9d2192        	l32i	a9, a1, 0x274
42013a10:	c80c      	movi.n	a8, 12
42013a12:	0989      	s32i.n	a8, a9, 0
42013a14:	071346        	j	42015665 <_svfiprintf_r+0x1c8d>
42013a17:	920000        	lsi	f0, a0, 0x248
42013a1a:	4c9c21        	l32r	a2, 41fe6c8c <_coredump_iram_end+0x1c64c8c>
42013a1d:	8908      	l32i.n	a0, a9, 32
42013a1f:	8259      	s32i.n	a5, a2, 32
42013a21:	8ae4a1        	l32r	a10, 41ff65b4 <_coredump_iram_end+0x1c745b4>
42013a24:	090c84        	lsi	f8, a12, 36
42013a27:	896482        	s32i	a8, a4, 0x224
42013a2a:	986182        	s32i	a8, a1, 0x260
42013a2d:	080c      	movi.n	a8, 0
42013a2f:	906192        	s32i	a9, a1, 0x240
42013a32:	916192        	s32i	a9, a1, 0x244
42013a35:	976192        	s32i	a9, a1, 0x25c
42013a38:	996192        	s32i	a9, a1, 0x264
42013a3b:	a26182        	s32i	a8, a1, 0x288
42013a3e:	a06182        	s32i	a8, a1, 0x280
42013a41:	a16182        	s32i	a8, a1, 0x284
42013a44:	a36182        	s32i	a8, a1, 0x28c
42013a47:	9f6182        	s32i	a8, a1, 0x27c
42013a4a:	10c192        	addi	a9, a1, 16
42013a4d:	e4a182        	movi	a8, 0x1e4
42013a50:	fa7c      	movi.n	a10, -1
42013a52:	898a      	add.n	a8, a9, a8
42013a54:	4064a2        	s32i	a10, a4, 0x100
42013a57:	060c      	movi.n	a6, 0
42013a59:	a56182        	s32i	a8, a1, 0x294
42013a5c:	9a2172        	l32i	a7, a1, 0x268
42013a5f:	000046        	j	42013a64 <_svfiprintf_r+0x8c>
42013a62:	771b      	addi.n	a7, a7, 1
42013a64:	000782        	l8ui	a8, a7, 0
42013a67:	005816        	beqz	a8, 42013a70 <_svfiprintf_r+0x98>
42013a6a:	dbc882        	addi	a8, a8, -37
42013a6d:	ff1856        	bnez	a8, 42013a62 <_svfiprintf_r+0x8a>
42013a70:	9a2182        	l32i	a8, a1, 0x268
42013a73:	c05780        	sub	a5, a7, a8
42013a76:	066516        	beqz	a5, 42013ae0 <_svfiprintf_r+0x108>
42013a79:	982182        	l32i	a8, a1, 0x260
42013a7c:	9a2192        	l32i	a9, a1, 0x268
42013a7f:	1859      	s32i.n	a5, a8, 4
42013a81:	0899      	s32i.n	a9, a8, 0
42013a83:	972182        	l32i	a8, a1, 0x25c
42013a86:	885a      	add.n	a8, a8, a5
42013a88:	976182        	s32i	a8, a1, 0x25c
42013a8b:	992182        	l32i	a8, a1, 0x264
42013a8e:	881b      	addi.n	a8, a8, 1
42013a90:	996182        	s32i	a8, a1, 0x264
42013a93:	0788e6        	bgei	a8, 8, 42013a9e <_svfiprintf_r+0xc6>
42013a96:	982182        	l32i	a8, a1, 0x260
42013a99:	888b      	addi.n	a8, a8, 8
42013a9b:	000d86        	j	42013ad5 <_svfiprintf_r+0xfd>
42013a9e:	992182        	l32i	a8, a1, 0x264
42013aa1:	10c132        	addi	a3, a1, 16
42013aa4:	8e6182        	s32i	a8, a1, 0x238
42013aa7:	9c21b2        	l32i	a11, a1, 0x270
42013aaa:	972182        	l32i	a8, a1, 0x25c
42013aad:	9d21a2        	l32i	a10, a1, 0x274
42013ab0:	24a2c2        	movi	a12, 0x224
42013ab3:	80c3c0        	add	a12, a3, a12
42013ab6:	8f6182        	s32i	a8, a1, 0x23c
42013ab9:	ffe125        	call8	420138cc <__ssprint_r>
42013abc:	8e2182        	l32i	a8, a1, 0x238
42013abf:	02d342        	addmi	a4, a3, 0x200
42013ac2:	996182        	s32i	a8, a1, 0x264
42013ac5:	8f2182        	l32i	a8, a1, 0x23c
42013ac8:	976182        	s32i	a8, a1, 0x25c
42013acb:	1a8c      	beqz.n	a10, 42013ad0 <_svfiprintf_r+0xf8>
42013acd:	06e2c6        	j	4201565c <_svfiprintf_r+0x1c84>
42013ad0:	e4a182        	movi	a8, 0x1e4
42013ad3:	838a      	add.n	a8, a3, a8
42013ad5:	986182        	s32i	a8, a1, 0x260
42013ad8:	9f2182        	l32i	a8, a1, 0x27c
42013adb:	885a      	add.n	a8, a8, a5
42013add:	9f6182        	s32i	a8, a1, 0x27c
42013ae0:	000782        	l8ui	a8, a7, 0
42013ae3:	18cc      	bnez.n	a8, 42013ae8 <_svfiprintf_r+0x110>
42013ae5:	06d3c6        	j	42015638 <_svfiprintf_r+0x1c60>
42013ae8:	10c192        	addi	a9, a1, 16
42013aeb:	02d992        	addmi	a9, a9, 0x200
42013aee:	0a0c      	movi.n	a10, 0
42013af0:	3a49a2        	s8i	a10, a9, 58
42013af3:	f97c      	movi.n	a9, -1
42013af5:	9b6192        	s32i	a9, a1, 0x26c
42013af8:	090c      	movi.n	a9, 0
42013afa:	871b      	addi.n	a8, a7, 1
42013afc:	065d      	mov.n	a5, a6
42013afe:	9e6192        	s32i	a9, a1, 0x278
42013b01:	030c      	movi.n	a3, 0
42013b03:	020c      	movi.n	a2, 0
42013b05:	000206        	j	42013b11 <_svfiprintf_r+0x139>
42013b08:	619200        	lsi	f0, a2, 0x184
42013b0b:	0c9a      	add.n	a0, a12, a9
42013b0d:	218203        	lsip	f0, a2, 132
42013b10:	1b9a      	add.n	a1, a11, a9
42013b12:	4298      	l32i.n	a9, a2, 16
42013b14:	0008      	l32i.n	a0, a0, 0
42013b16:	9a6192        	s32i	a9, a1, 0x268
42013b19:	aa5c      	movi.n	a10, 90
42013b1b:	000106        	j	42013b23 <_svfiprintf_r+0x14b>
42013b1e:	820000        	mull	a0, a0, a0
42013b21:	829e61        	l32r	a6, 41ff459c <_coredump_iram_end+0x1c7259c>
42013b24:	87e0c4        	lsi	f12, a0, 0x21c
42013b27:	02ba      	add.n	a0, a2, a11
42013b29:	0587c6        	j	4201514c <_svfiprintf_r+0x1774>
42013b2c:	b4f691        	l32r	a9, 42000f04 <_stext+0xee4> (3c029f38 <__mprec_tens+0x178>)
42013b2f:	a08890        	addx4	a8, a8, a9
42013b32:	0888      	l32i.n	a8, a8, 0
42013b34:	0008a0        	jx	a8
42013b37:	810000        	src	a0, a0, a0
42013b3a:	c6b4f1        	l32r	a15, 4200560c <esp_mprot_set_prot+0x418> (854b0004 <_rtc_reserved_end+0x253b0004>)
42013b3d:	a20457        	bnone	a4, a5, 42013ae3 <_svfiprintf_r+0x10b>
42013b40:	109d21        	l32r	a2, 41fd7db4 <_coredump_iram_end+0x1c55db4>
42013b43:	652011        	l32r	a1, 41fecfc4 <_coredump_iram_end+0x1c6afc4>
42013b46:	88fe02        	s32ri	a0, a14, 0x220
42013b49:	ad1a      	add.n	a10, a13, a1
42013b4b:	8208      	l32i.n	a0, a2, 32
42013b4d:	81a361        	l32r	a6, 41ff41dc <_coredump_iram_end+0x1c721dc>
42013b50:	e0b1d3        	lsi	f13, a1, 0x380
42013b53:	0008      	l32i.n	a0, a0, 0
42013b55:	a161a2        	s32i	a10, a1, 0x284
42013b58:	9d21a2        	l32i	a10, a1, 0x274
42013b5b:	201110        	or	a1, a1, a1
42013b5e:	fe00e5        	call8	42011b6c <_localeconv_r>
42013b61:	2a88      	l32i.n	a8, a10, 8
42013b63:	a06182        	s32i	a8, a1, 0x280
42013b66:	a12182        	l32i	a8, a1, 0x284
42013b69:	fa1816        	beqz	a8, 42013b0e <_svfiprintf_r+0x136>
42013b6c:	a02182        	l32i	a8, a1, 0x280
42013b6f:	f9b816        	beqz	a8, 42013b0e <_svfiprintf_r+0x136>
42013b72:	000882        	l8ui	a8, a8, 0
42013b75:	f95816        	beqz	a8, 42013b0e <_svfiprintf_r+0x136>
42013b78:	00a482        	movi	a8, 0x400
42013b7b:	00b906        	j	42013e63 <_svfiprintf_r+0x48b>
42013b7e:	10c182        	addi	a8, a1, 16
42013b81:	02d882        	addmi	a8, a8, 0x200
42013b84:	3a0892        	l8ui	a9, a8, 58
42013b87:	f83956        	bnez	a9, 42013b0e <_svfiprintf_r+0x136>
42013b8a:	092c      	movi.n	a9, 32
42013b8c:	004686        	j	42013caa <_svfiprintf_r+0x2d2>
42013b8f:	180c      	movi.n	a8, 1
42013b91:	00b386        	j	42013e63 <_svfiprintf_r+0x48b>
42013b94:	9a2182        	l32i	a8, a1, 0x268
42013b97:	9a0c      	movi.n	a10, 9
42013b99:	000882        	l8ui	a8, a8, 0
42013b9c:	d0c892        	addi	a9, a8, -48
42013b9f:	3d3a97        	bltu	a10, a9, 42013be0 <_svfiprintf_r+0x208>
42013ba2:	9a2192        	l32i	a9, a1, 0x268
42013ba5:	0a0c      	movi.n	a10, 0
42013ba7:	491b      	addi.n	a4, a9, 1
42013ba9:	09a0b2        	movi	a11, 9
42013bac:	d0c882        	addi	a8, a8, -48
42013baf:	a0aaa0        	addx4	a10, a10, a10
42013bb2:	90aa80        	addx2	a10, a10, a8
42013bb5:	000482        	l8ui	a8, a4, 0
42013bb8:	441b      	addi.n	a4, a4, 1
42013bba:	d0c892        	addi	a9, a8, -48
42013bbd:	ebbb97        	bgeu	a11, a9, 42013bac <_svfiprintf_r+0x1d4>
42013bc0:	492c      	movi.n	a9, 36
42013bc2:	021897        	beq	a8, a9, 42013bc8 <_svfiprintf_r+0x1f0>
42013bc5:	ffd0c6        	j	42013b0c <_svfiprintf_r+0x134>
42013bc8:	082c      	movi.n	a8, 32
42013bca:	02a8a7        	bge	a8, a10, 42013bd0 <_svfiprintf_r+0x1f8>
42013bcd:	06a2c6        	j	4201565c <_svfiprintf_r+0x1c84>
42013bd0:	912182        	l32i	a8, a1, 0x244
42013bd3:	aa0b      	addi.n	a10, a10, -1
42013bd5:	10c1e2        	addi	a14, a1, 16
42013bd8:	142a87        	blt	a10, a8, 42013bf0 <_svfiprintf_r+0x218>
42013bdb:	000646        	j	42013bf8 <_svfiprintf_r+0x220>
42013bde:	b20000        	mulsh	a0, a0, a0
42013be1:	1b9121        	l32r	a2, 41fdaa28 <_coredump_iram_end+0x1c58a28>
42013be4:	c18296        	bltz	a2, 42013800 <get_arg$isra$0+0x404>
42013be7:	26b710        	lsi	f1, a7, 152
42013bea:	0d4632        	s8i	a3, a6, 13
42013bed:	000000        	ill
42013bf0:	b0eae0        	addx8	a14, a10, a14
42013bf3:	0e88      	l32i.n	a8, a14, 0
42013bf5:	000686        	j	42013c13 <_svfiprintf_r+0x23b>
42013bf8:	30a282        	movi	a8, 0x230
42013bfb:	8e8a      	add.n	a8, a14, a8
42013bfd:	34a2d2        	movi	a13, 0x234
42013c00:	40a2c2        	movi	a12, 0x240
42013c03:	0189      	s32i.n	a8, a1, 0
42013c05:	01def2        	addmi	a15, a14, 0x100
42013c08:	deda      	add.n	a13, a14, a13
42013c0a:	ceca      	add.n	a12, a14, a12
42013c0c:	07bd      	mov.n	a11, a7
42013c0e:	ff7ee5        	call8	420133fc <get_arg$isra$0>
42013c11:	0a88      	l32i.n	a8, a10, 0
42013c13:	9e6182        	s32i	a8, a1, 0x278
42013c16:	9a6142        	s32i	a4, a1, 0x268
42013c19:	069d      	mov.n	a9, a6
42013c1b:	001c06        	j	42013c8f <_svfiprintf_r+0x2b7>
42013c1e:	b08580        	addx8	a8, a5, a8
42013c21:	001946        	j	42013c8a <_svfiprintf_r+0x2b2>
42013c24:	9228a2        	l32i	a10, a8, 0x248
42013c27:	fd1c      	movi.n	a13, 31
42013c29:	02d882        	addmi	a8, a8, 0x200
42013c2c:	ca4b      	addi.n	a12, a10, 4
42013c2e:	322db7        	blt	a13, a11, 42013c64 <_svfiprintf_r+0x28c>
42013c31:	db1b      	addi.n	a13, a11, 1
42013c33:	9161d2        	s32i	a13, a1, 0x244
42013c36:	1268c2        	s32i	a12, a8, 72
42013c39:	8d1c      	movi.n	a13, 24
42013c3b:	052dc7        	blt	a13, a12, 42013c44 <_svfiprintf_r+0x26c>
42013c3e:	1128a2        	l32i	a10, a8, 68
42013c41:	000286        	j	42013c4f <_svfiprintf_r+0x277>
42013c44:	012da7        	blt	a13, a10, 42013c49 <_svfiprintf_r+0x271>
42013c47:	4c2c      	movi.n	a12, 36
42013c49:	9421a2        	l32i	a10, a1, 0x250
42013c4c:	9661c2        	s32i	a12, a1, 0x258
42013c4f:	aaca      	add.n	a10, a10, a12
42013c51:	fccaa2        	addi	a10, a10, -4
42013c54:	0a88      	l32i.n	a8, a10, 0
42013c56:	9e6182        	s32i	a8, a1, 0x278
42013c59:	9e21a2        	l32i	a10, a1, 0x278
42013c5c:	b08b10        	addx8	a8, a11, a1
42013c5f:	48a9      	s32i.n	a10, a8, 16
42013c61:	000a86        	j	42013c8f <_svfiprintf_r+0x2b7>
42013c64:	1268c2        	s32i	a12, a8, 72
42013c67:	8b1c      	movi.n	a11, 24
42013c69:	072bc7        	blt	a11, a12, 42013c74 <_svfiprintf_r+0x29c>
42013c6c:	112882        	l32i	a8, a8, 68
42013c6f:	000486        	j	42013c85 <_svfiprintf_r+0x2ad>
42013c72:	a70000        	lsi	f0, a0, 0x29c
42013c75:	012b      	addi.n	a0, a1, 2
42013c77:	4c2c      	movi.n	a12, 36
42013c79:	10c182        	addi	a8, a1, 16
42013c7c:	02d882        	addmi	a8, a8, 0x200
42013c7f:	102882        	l32i	a8, a8, 64
42013c82:	9661c2        	s32i	a12, a1, 0x258
42013c85:	88ca      	add.n	a8, a8, a12
42013c87:	fcc882        	addi	a8, a8, -4
42013c8a:	0888      	l32i.n	a8, a8, 0
42013c8c:	9e6182        	s32i	a8, a1, 0x278
42013c8f:	9e2182        	l32i	a8, a1, 0x278
42013c92:	096d      	mov.n	a6, a9
42013c94:	e768d6        	bgez	a8, 42013b0e <_svfiprintf_r+0x136>
42013c97:	608080        	neg	a8, a8
42013c9a:	9e6182        	s32i	a8, a1, 0x278
42013c9d:	480c      	movi.n	a8, 4
42013c9f:	007006        	j	42013e63 <_svfiprintf_r+0x48b>
42013ca2:	10c182        	addi	a8, a1, 16
42013ca5:	02d882        	addmi	a8, a8, 0x200
42013ca8:	b92c      	movi.n	a9, 43
42013caa:	3a4892        	s8i	a9, a8, 58
42013cad:	ff9746        	j	42013b0e <_svfiprintf_r+0x136>
42013cb0:	9a2182        	l32i	a8, a1, 0x268
42013cb3:	000842        	l8ui	a4, a8, 0
42013cb6:	981b      	addi.n	a9, a8, 1
42013cb8:	a82c      	movi.n	a8, 42
42013cba:	061487        	beq	a4, a8, 42013cc4 <_svfiprintf_r+0x2ec>
42013cbd:	080c      	movi.n	a8, 0
42013cbf:	9c0c      	movi.n	a12, 9
42013cc1:	004386        	j	42013dd3 <_svfiprintf_r+0x3fb>
42013cc4:	9a2182        	l32i	a8, a1, 0x268
42013cc7:	9b0c      	movi.n	a11, 9
42013cc9:	010882        	l8ui	a8, a8, 1
42013ccc:	d0c8a2        	addi	a10, a8, -48
42013ccf:	393ba7        	bltu	a11, a10, 42013d0c <_svfiprintf_r+0x334>
42013cd2:	9a21a2        	l32i	a10, a1, 0x268
42013cd5:	4a2b      	addi.n	a4, a10, 2
42013cd7:	0a0c      	movi.n	a10, 0
42013cd9:	d0c882        	addi	a8, a8, -48
42013cdc:	a0aaa0        	addx4	a10, a10, a10
42013cdf:	90aa80        	addx2	a10, a10, a8
42013ce2:	000482        	l8ui	a8, a4, 0
42013ce5:	441b      	addi.n	a4, a4, 1
42013ce7:	d0c8c2        	addi	a12, a8, -48
42013cea:	ebbbc7        	bgeu	a11, a12, 42013cd9 <_svfiprintf_r+0x301>
42013ced:	4b2c      	movi.n	a11, 36
42013cef:	0218b7        	beq	a8, a11, 42013cf5 <_svfiprintf_r+0x31d>
42013cf2:	ff84c6        	j	42013b09 <_svfiprintf_r+0x131>
42013cf5:	082c      	movi.n	a8, 32
42013cf7:	02a8a7        	bge	a8, a10, 42013cfd <_svfiprintf_r+0x325>
42013cfa:	065786        	j	4201565c <_svfiprintf_r+0x1c84>
42013cfd:	912182        	l32i	a8, a1, 0x244
42013d00:	aa0b      	addi.n	a10, a10, -1
42013d02:	10c1e2        	addi	a14, a1, 16
42013d05:	132a87        	blt	a10, a8, 42013d1c <_svfiprintf_r+0x344>
42013d08:	000606        	j	42013d24 <_svfiprintf_r+0x34c>
42013d0b:	21a200        	srai	a10, a0, 2
42013d0e:	c61b91        	l32r	a9, 4200557c <esp_mprot_set_prot+0x388> (c582000c <_rtc_reserved_end+0x6572000c>)
42013d11:	10c182        	addi	a8, a1, 16
42013d14:	2e26a7        	blt	a6, a10, 42013d46 <_svfiprintf_r+0x36e>
42013d17:	000c46        	j	42013d4c <_svfiprintf_r+0x374>
42013d1a:	e00000        	subx4	a0, a0, a0
42013d1d:	b0ea      	add.n	a11, a0, a14
42013d1f:	0e88      	l32i.n	a8, a14, 0
42013d21:	000686        	j	42013d3f <_svfiprintf_r+0x367>
42013d24:	30a282        	movi	a8, 0x230
42013d27:	8e8a      	add.n	a8, a14, a8
42013d29:	34a2d2        	movi	a13, 0x234
42013d2c:	40a2c2        	movi	a12, 0x240
42013d2f:	0189      	s32i.n	a8, a1, 0
42013d31:	01def2        	addmi	a15, a14, 0x100
42013d34:	deda      	add.n	a13, a14, a13
42013d36:	ceca      	add.n	a12, a14, a12
42013d38:	07bd      	mov.n	a11, a7
42013d3a:	ff6c25        	call8	420133fc <get_arg$isra$0>
42013d3d:	0a88      	l32i.n	a8, a10, 0
42013d3f:	049d      	mov.n	a9, a4
42013d41:	06cd      	mov.n	a12, a6
42013d43:	001c46        	j	42013db8 <_svfiprintf_r+0x3e0>
42013d46:	b08580        	addx8	a8, a5, a8
42013d49:	001a46        	j	42013db6 <_svfiprintf_r+0x3de>
42013d4c:	fb1c      	movi.n	a11, 31
42013d4e:	362ba7        	blt	a11, a10, 42013d88 <_svfiprintf_r+0x3b0>
42013d51:	9228e2        	l32i	a14, a8, 0x248
42013d54:	ba1b      	addi.n	a11, a10, 1
42013d56:	9161b2        	s32i	a11, a1, 0x244
42013d59:	be4b      	addi.n	a11, a14, 4
42013d5b:	9268b2        	s32i	a11, a8, 0x248
42013d5e:	8f1c      	movi.n	a15, 24
42013d60:	052fb7        	blt	a15, a11, 42013d69 <_svfiprintf_r+0x391>
42013d63:	912882        	l32i	a8, a8, 0x244
42013d66:	000346        	j	42013d77 <_svfiprintf_r+0x39f>
42013d69:	012fe7        	blt	a15, a14, 42013d6e <_svfiprintf_r+0x396>
42013d6c:	4b2c      	movi.n	a11, 36
42013d6e:	9268b2        	s32i	a11, a8, 0x248
42013d71:	02d882        	addmi	a8, a8, 0x200
42013d74:	102882        	l32i	a8, a8, 64
42013d77:	88ba      	add.n	a8, a8, a11
42013d79:	fcc882        	addi	a8, a8, -4
42013d7c:	0888      	l32i.n	a8, a8, 0
42013d7e:	b0aa10        	addx8	a10, a10, a1
42013d81:	4a89      	s32i.n	a8, a10, 16
42013d83:	000c46        	j	42013db8 <_svfiprintf_r+0x3e0>
42013d86:	b20000        	mulsh	a0, a0, a0
42013d89:	9228      	l32i.n	a2, a2, 36
42013d8b:	8d1c      	movi.n	a13, 24
42013d8d:	ab4b      	addi.n	a10, a11, 4
42013d8f:	9268a2        	s32i	a10, a8, 0x248
42013d92:	02d882        	addmi	a8, a8, 0x200
42013d95:	072da7        	blt	a13, a10, 42013da0 <_svfiprintf_r+0x3c8>
42013d98:	112882        	l32i	a8, a8, 68
42013d9b:	000486        	j	42013db1 <_svfiprintf_r+0x3d9>
42013d9e:	b70000        	lsi	f0, a0, 0x2dc
42013da1:	012d      	mov.n	a2, a1
42013da3:	4a2c      	movi.n	a10, 36
42013da5:	10c182        	addi	a8, a1, 16
42013da8:	02d882        	addmi	a8, a8, 0x200
42013dab:	102882        	l32i	a8, a8, 64
42013dae:	9661a2        	s32i	a10, a1, 0x258
42013db1:	88aa      	add.n	a8, a8, a10
42013db3:	fcc882        	addi	a8, a8, -4
42013db6:	0888      	l32i.n	a8, a8, 0
42013db8:	fa7c      	movi.n	a10, -1
42013dba:	5388a0        	max	a8, a8, a10
42013dbd:	9b6182        	s32i	a8, a1, 0x26c
42013dc0:	0c6d      	mov.n	a6, a12
42013dc2:	9a6192        	s32i	a9, a1, 0x268
42013dc5:	ff5146        	j	42013b0e <_svfiprintf_r+0x136>
42013dc8:	a08880        	addx4	a8, a8, a8
42013dcb:	000942        	l8ui	a4, a9, 0
42013dce:	9088b0        	addx2	a8, a8, a11
42013dd1:	991b      	addi.n	a9, a9, 1
42013dd3:	9a6192        	s32i	a9, a1, 0x268
42013dd6:	d0c4b2        	addi	a11, a4, -48
42013dd9:	ebbcb7        	bgeu	a12, a11, 42013dc8 <_svfiprintf_r+0x3f0>
42013ddc:	f97c      	movi.n	a9, -1
42013dde:	538890        	max	a8, a8, a9
42013de1:	9b6182        	s32i	a8, a1, 0x26c
42013de4:	9e2182        	l32i	a8, a1, 0x278
42013de7:	ff4d46        	j	42013b20 <_svfiprintf_r+0x148>
42013dea:	80a082        	movi	a8, 128
42013ded:	001c86        	j	42013e63 <_svfiprintf_r+0x48b>
42013df0:	080c      	movi.n	a8, 0
42013df2:	9b0c      	movi.n	a11, 9
42013df4:	9a2192        	l32i	a9, a1, 0x268
42013df7:	d0c442        	addi	a4, a4, -48
42013dfa:	a08880        	addx4	a8, a8, a8
42013dfd:	908840        	addx2	a8, a8, a4
42013e00:	000942        	l8ui	a4, a9, 0
42013e03:	991b      	addi.n	a9, a9, 1
42013e05:	9a6192        	s32i	a9, a1, 0x268
42013e08:	d0c492        	addi	a9, a4, -48
42013e0b:	e5bb97        	bgeu	a11, a9, 42013df4 <_svfiprintf_r+0x41c>
42013e0e:	492c      	movi.n	a9, 36
42013e10:	021497        	beq	a4, a9, 42013e16 <_svfiprintf_r+0x43e>
42013e13:	ff4246        	j	42013b20 <_svfiprintf_r+0x148>
42013e16:	092c      	movi.n	a9, 32
42013e18:	02a987        	bge	a9, a8, 42013e1e <_svfiprintf_r+0x446>
42013e1b:	060f46        	j	4201565c <_svfiprintf_r+0x1c84>
42013e1e:	580b      	addi.n	a5, a8, -1
42013e20:	130c      	movi.n	a3, 1
42013e22:	ff3a06        	j	42013b0e <_svfiprintf_r+0x136>
42013e25:	218200        	srai	a8, a0, 2
42013e28:	929a      	add.n	a9, a2, a9
42013e2a:	0008      	l32i.n	a0, a0, 0
42013e2c:	68a082        	movi	a8, 104
42013e2f:	0d9987        	bne	a9, a8, 42013e40 <_svfiprintf_r+0x468>
42013e32:	9a2182        	l32i	a8, a1, 0x268
42013e35:	881b      	addi.n	a8, a8, 1
42013e37:	9a6182        	s32i	a8, a1, 0x268
42013e3a:	00a282        	movi	a8, 0x200
42013e3d:	000886        	j	42013e63 <_svfiprintf_r+0x48b>
42013e40:	084c      	movi.n	a8, 64
42013e42:	000746        	j	42013e63 <_svfiprintf_r+0x48b>
42013e45:	9a2182        	l32i	a8, a1, 0x268
42013e48:	000892        	l8ui	a9, a8, 0
42013e4b:	6ca082        	movi	a8, 108
42013e4e:	0a9987        	bne	a9, a8, 42013e5c <_svfiprintf_r+0x484>
42013e51:	9a2182        	l32i	a8, a1, 0x268
42013e54:	881b      	addi.n	a8, a8, 1
42013e56:	9a6182        	s32i	a8, a1, 0x268
42013e59:	000106        	j	42013e61 <_svfiprintf_r+0x489>
42013e5c:	081c      	movi.n	a8, 16
42013e5e:	000046        	j	42013e63 <_svfiprintf_r+0x48b>
42013e61:	082c      	movi.n	a8, 32
42013e63:	202280        	or	a2, a2, a8
42013e66:	ff2906        	j	42013b0e <_svfiprintf_r+0x136>
42013e69:	912182        	l32i	a8, a1, 0x244
42013e6c:	10c1e2        	addi	a14, a1, 16
42013e6f:	d3ac      	beqz.n	a3, 42013ea0 <_svfiprintf_r+0x4c8>
42013e71:	08a587        	bge	a5, a8, 42013e7d <_svfiprintf_r+0x4a5>
42013e74:	b0e5e0        	addx8	a14, a5, a14
42013e77:	000e92        	l8ui	a9, a14, 0
42013e7a:	000746        	j	42013e9b <_svfiprintf_r+0x4c3>
42013e7d:	30a282        	movi	a8, 0x230
42013e80:	8e8a      	add.n	a8, a14, a8
42013e82:	34a2d2        	movi	a13, 0x234
42013e85:	40a2c2        	movi	a12, 0x240
42013e88:	0189      	s32i.n	a8, a1, 0
42013e8a:	01def2        	addmi	a15, a14, 0x100
42013e8d:	deda      	add.n	a13, a14, a13
42013e8f:	ceca      	add.n	a12, a14, a12
42013e91:	07bd      	mov.n	a11, a7
42013e93:	05ad      	mov.n	a10, a5
42013e95:	ff5665        	call8	420133fc <get_arg$isra$0>
42013e98:	000a92        	l8ui	a9, a10, 0
42013e9b:	067d      	mov.n	a7, a6
42013e9d:	001f06        	j	42013f1d <_svfiprintf_r+0x545>
42013ea0:	761b      	addi.n	a7, a6, 1
42013ea2:	0aa687        	bge	a6, a8, 42013eb0 <_svfiprintf_r+0x4d8>
42013ea5:	b0e5e0        	addx8	a14, a5, a14
42013ea8:	000e92        	l8ui	a9, a14, 0
42013eab:	001b86        	j	42013f1d <_svfiprintf_r+0x545>
42013eae:	920000        	lsi	f0, a0, 0x248
42013eb1:	2e          	.byte	0x2e
42013eb2:	fb1c92        	l16ui	a9, a12, 0x1f6
42013eb5:	02dee2        	addmi	a14, a14, 0x200
42013eb8:	a94b      	addi.n	a10, a9, 4
42013eba:	362b87        	blt	a11, a8, 42013ef4 <_svfiprintf_r+0x51c>
42013ebd:	b81b      	addi.n	a11, a8, 1
42013ebf:	9161b2        	s32i	a11, a1, 0x244
42013ec2:	126ea2        	s32i	a10, a14, 72
42013ec5:	8b1c      	movi.n	a11, 24
42013ec7:	052ba7        	blt	a11, a10, 42013ed0 <_svfiprintf_r+0x4f8>
42013eca:	112e92        	l32i	a9, a14, 68
42013ecd:	000406        	j	42013ee1 <_svfiprintf_r+0x509>
42013ed0:	012b97        	blt	a11, a9, 42013ed5 <_svfiprintf_r+0x4fd>
42013ed3:	4a2c      	movi.n	a10, 36
42013ed5:	10c192        	addi	a9, a1, 16
42013ed8:	02d992        	addmi	a9, a9, 0x200
42013edb:	102992        	l32i	a9, a9, 64
42013ede:	9661a2        	s32i	a10, a1, 0x258
42013ee1:	99aa      	add.n	a9, a9, a10
42013ee3:	fcc992        	addi	a9, a9, -4
42013ee6:	0998      	l32i.n	a9, a9, 0
42013ee8:	b08810        	addx8	a8, a8, a1
42013eeb:	4899      	s32i.n	a9, a8, 16
42013eed:	749090        	extui	a9, a9, 0, 8
42013ef0:	000a46        	j	42013f1d <_svfiprintf_r+0x545>
42013ef3:	6ea200        	f64rnd	a10, a2, a0, 2
42013ef6:	881c12        	l16ui	a1, a12, 0x110
42013ef9:	0728a7        	blt	a8, a10, 42013f04 <_svfiprintf_r+0x52c>
42013efc:	112e82        	l32i	a8, a14, 68
42013eff:	000486        	j	42013f15 <_svfiprintf_r+0x53d>
42013f02:	970000        	lsi	f0, a0, 0x25c
42013f05:	0128      	l32i.n	a2, a1, 0
42013f07:	4a2c      	movi.n	a10, 36
42013f09:	10c182        	addi	a8, a1, 16
42013f0c:	02d882        	addmi	a8, a8, 0x200
42013f0f:	102882        	l32i	a8, a8, 64
42013f12:	9661a2        	s32i	a10, a1, 0x258
42013f15:	88aa      	add.n	a8, a8, a10
42013f17:	fcc882        	addi	a8, a8, -4
42013f1a:	000892        	l8ui	a9, a8, 0
42013f1d:	10c182        	addi	a8, a1, 16
42013f20:	01d8a2        	addmi	a10, a8, 0x100
42013f23:	804a92        	s8i	a9, a10, 128
42013f26:	02d892        	addmi	a9, a8, 0x200
42013f29:	0a0c      	movi.n	a10, 0
42013f2b:	3a49a2        	s8i	a10, a9, 58
42013f2e:	048c06        	j	42015162 <_svfiprintf_r+0x178a>
42013f31:	081c      	movi.n	a8, 16
42013f33:	202280        	or	a2, a2, a8
42013f36:	912182        	l32i	a8, a1, 0x244
42013f39:	10c1e2        	addi	a14, a1, 16
42013f3c:	02e257        	bbsi	a2, 5, 42013f42 <_svfiprintf_r+0x56a>
42013f3f:	002f86        	j	42014001 <_svfiprintf_r+0x629>
42013f42:	f3ac      	beqz.n	a3, 42013f75 <_svfiprintf_r+0x59d>
42013f44:	09a587        	bge	a5, a8, 42013f51 <_svfiprintf_r+0x579>
42013f47:	b0e5e0        	addx8	a14, a5, a14
42013f4a:	0e58      	l32i.n	a5, a14, 0
42013f4c:	1e38      	l32i.n	a3, a14, 4
42013f4e:	000786        	j	42013f70 <_svfiprintf_r+0x598>
42013f51:	30a282        	movi	a8, 0x230
42013f54:	8e8a      	add.n	a8, a14, a8
42013f56:	34a2d2        	movi	a13, 0x234
42013f59:	40a2c2        	movi	a12, 0x240
42013f5c:	05ad      	mov.n	a10, a5
42013f5e:	0189      	s32i.n	a8, a1, 0
42013f60:	01def2        	addmi	a15, a14, 0x100
42013f63:	deda      	add.n	a13, a14, a13
42013f65:	ceca      	add.n	a12, a14, a12
42013f67:	07bd      	mov.n	a11, a7
42013f69:	ff4925        	call8	420133fc <get_arg$isra$0>
42013f6c:	0a58      	l32i.n	a5, a10, 0
42013f6e:	1a38      	l32i.n	a3, a10, 4
42013f70:	067d      	mov.n	a7, a6
42013f72:	00a946        	j	4201421b <_svfiprintf_r+0x843>
42013f75:	761b      	addi.n	a7, a6, 1
42013f77:	09a687        	bge	a6, a8, 42013f84 <_svfiprintf_r+0x5ac>
42013f7a:	b0e5e0        	addx8	a14, a5, a14
42013f7d:	0e58      	l32i.n	a5, a14, 0
42013f7f:	1e38      	l32i.n	a3, a14, 4
42013f81:	00a586        	j	4201421b <_svfiprintf_r+0x843>
42013f84:	922e92        	l32i	a9, a14, 0x248
42013f87:	8a7c      	movi.n	a10, -8
42013f89:	997b      	addi.n	a9, a9, 7
42013f8b:	1099a0        	and	a9, a9, a10
42013f8e:	fb1c      	movi.n	a11, 31
42013f90:	02dee2        	addmi	a14, a14, 0x200
42013f93:	a98b      	addi.n	a10, a9, 8
42013f95:	3b2b87        	blt	a11, a8, 42013fd4 <_svfiprintf_r+0x5fc>
42013f98:	b81b      	addi.n	a11, a8, 1
42013f9a:	9161b2        	s32i	a11, a1, 0x244
42013f9d:	126ea2        	s32i	a10, a14, 72
42013fa0:	8b1c      	movi.n	a11, 24
42013fa2:	062ba7        	blt	a11, a10, 42013fac <_svfiprintf_r+0x5d4>
42013fa5:	112e92        	l32i	a9, a14, 68
42013fa8:	000446        	j	42013fbd <_svfiprintf_r+0x5e5>
42013fab:	2b9700        	oeq.s	b9, f7, f0
42013fae:	8a2c01        	l32r	a0, 41ff6860 <_coredump_iram_end+0x1c74860>
42013fb1:	10c192        	addi	a9, a1, 16
42013fb4:	02d992        	addmi	a9, a9, 0x200
42013fb7:	102992        	l32i	a9, a9, 64
42013fba:	9661a2        	s32i	a10, a1, 0x258
42013fbd:	99aa      	add.n	a9, a9, a10
42013fbf:	f8c992        	addi	a9, a9, -8
42013fc2:	0958      	l32i.n	a5, a9, 0
42013fc4:	1938      	l32i.n	a3, a9, 4
42013fc6:	10c192        	addi	a9, a1, 16
42013fc9:	b08890        	addx8	a8, a8, a9
42013fcc:	0859      	s32i.n	a5, a8, 0
42013fce:	1839      	s32i.n	a3, a8, 4
42013fd0:	0091c6        	j	4201421b <_svfiprintf_r+0x843>
42013fd3:	6ea200        	f64rnd	a10, a2, a0, 2
42013fd6:	881c12        	l16ui	a1, a12, 0x110
42013fd9:	0728a7        	blt	a8, a10, 42013fe4 <_svfiprintf_r+0x60c>
42013fdc:	112e82        	l32i	a8, a14, 68
42013fdf:	000486        	j	42013ff5 <_svfiprintf_r+0x61d>
42013fe2:	970000        	lsi	f0, a0, 0x25c
42013fe5:	0128      	l32i.n	a2, a1, 0
42013fe7:	8a2c      	movi.n	a10, 40
42013fe9:	10c182        	addi	a8, a1, 16
42013fec:	02d882        	addmi	a8, a8, 0x200
42013fef:	102882        	l32i	a8, a8, 64
42013ff2:	9661a2        	s32i	a10, a1, 0x258
42013ff5:	88aa      	add.n	a8, a8, a10
42013ff7:	f8c882        	addi	a8, a8, -8
42013ffa:	0858      	l32i.n	a5, a8, 0
42013ffc:	1838      	l32i.n	a3, a8, 4
42013ffe:	008646        	j	4201421b <_svfiprintf_r+0x843>
42014001:	036247        	bbci	a2, 4, 42014008 <_svfiprintf_r+0x630>
42014004:	005b06        	j	42014174 <_svfiprintf_r+0x79c>
42014007:	e26700        	remu	a6, a7, a0
4201400a:	2a8602        	lsi	f0, a6, 168
4201400d:	c3ac00        	movf	a10, a12, b0
42014010:	09a587        	bge	a5, a8, 4201401d <_svfiprintf_r+0x645>
42014013:	b0e5e0        	addx8	a14, a5, a14
42014016:	009e52        	l16si	a5, a14, 0
42014019:	006046        	j	4201419e <_svfiprintf_r+0x7c6>
4201401c:	a28200        	muluh	a8, a2, a0
4201401f:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42014022:	34a2d2        	movi	a13, 0x234
42014025:	40a2c2        	movi	a12, 0x240
42014028:	05ad      	mov.n	a10, a5
4201402a:	0189      	s32i.n	a8, a1, 0
4201402c:	01def2        	addmi	a15, a14, 0x100
4201402f:	deda      	add.n	a13, a14, a13
42014031:	ceca      	add.n	a12, a14, a12
42014033:	07bd      	mov.n	a11, a7
42014035:	ff3c65        	call8	420133fc <get_arg$isra$0>
42014038:	009a52        	l16si	a5, a10, 0
4201403b:	0057c6        	j	4201419e <_svfiprintf_r+0x7c6>
4201403e:	761b      	addi.n	a7, a6, 1
42014040:	08a687        	bge	a6, a8, 4201404c <_svfiprintf_r+0x674>
42014043:	b0e5e0        	addx8	a14, a5, a14
42014046:	009e52        	l16si	a5, a14, 0
42014049:	0072c6        	j	42014218 <_svfiprintf_r+0x840>
4201404c:	922e92        	l32i	a9, a14, 0x248
4201404f:	fb1c      	movi.n	a11, 31
42014051:	02dee2        	addmi	a14, a14, 0x200
42014054:	a94b      	addi.n	a10, a9, 4
42014056:	352b87        	blt	a11, a8, 4201408f <_svfiprintf_r+0x6b7>
42014059:	b81b      	addi.n	a11, a8, 1
4201405b:	9161b2        	s32i	a11, a1, 0x244
4201405e:	126ea2        	s32i	a10, a14, 72
42014061:	8b1c      	movi.n	a11, 24
42014063:	052ba7        	blt	a11, a10, 4201406c <_svfiprintf_r+0x694>
42014066:	112e92        	l32i	a9, a14, 68
42014069:	000406        	j	4201407d <_svfiprintf_r+0x6a5>
4201406c:	012b97        	blt	a11, a9, 42014071 <_svfiprintf_r+0x699>
4201406f:	4a2c      	movi.n	a10, 36
42014071:	10c192        	addi	a9, a1, 16
42014074:	02d992        	addmi	a9, a9, 0x200
42014077:	102992        	l32i	a9, a9, 64
4201407a:	9661a2        	s32i	a10, a1, 0x258
4201407d:	99aa      	add.n	a9, a9, a10
4201407f:	fcc992        	addi	a9, a9, -4
42014082:	0958      	l32i.n	a5, a9, 0
42014084:	b08810        	addx8	a8, a8, a1
42014087:	4859      	s32i.n	a5, a8, 16
42014089:	235580        	sext	a5, a5, 15
4201408c:	006206        	j	42014218 <_svfiprintf_r+0x840>
4201408f:	126ea2        	s32i	a10, a14, 72
42014092:	881c      	movi.n	a8, 24
42014094:	0528a7        	blt	a8, a10, 4201409d <_svfiprintf_r+0x6c5>
42014097:	112e82        	l32i	a8, a14, 68
4201409a:	000406        	j	420140ae <_svfiprintf_r+0x6d6>
4201409d:	012897        	blt	a8, a9, 420140a2 <_svfiprintf_r+0x6ca>
420140a0:	4a2c      	movi.n	a10, 36
420140a2:	10c182        	addi	a8, a1, 16
420140a5:	02d882        	addmi	a8, a8, 0x200
420140a8:	102882        	l32i	a8, a8, 64
420140ab:	9661a2        	s32i	a10, a1, 0x258
420140ae:	88aa      	add.n	a8, a8, a10
420140b0:	fcc882        	addi	a8, a8, -4
420140b3:	009852        	l16si	a5, a8, 0
420140b6:	005786        	j	42014218 <_svfiprintf_r+0x840>
420140b9:	02e297        	bbsi	a2, 9, 420140bf <_svfiprintf_r+0x6e7>
420140bc:	002d06        	j	42014174 <_svfiprintf_r+0x79c>
420140bf:	d3ac      	beqz.n	a3, 420140f0 <_svfiprintf_r+0x718>
420140c1:	08a587        	bge	a5, a8, 420140cd <_svfiprintf_r+0x6f5>
420140c4:	b0e5e0        	addx8	a14, a5, a14
420140c7:	000e52        	l8ui	a5, a14, 0
420140ca:	000746        	j	420140eb <_svfiprintf_r+0x713>
420140cd:	30a282        	movi	a8, 0x230
420140d0:	8e8a      	add.n	a8, a14, a8
420140d2:	34a2d2        	movi	a13, 0x234
420140d5:	40a2c2        	movi	a12, 0x240
420140d8:	05ad      	mov.n	a10, a5
420140da:	0189      	s32i.n	a8, a1, 0
420140dc:	01def2        	addmi	a15, a14, 0x100
420140df:	deda      	add.n	a13, a14, a13
420140e1:	ceca      	add.n	a12, a14, a12
420140e3:	07bd      	mov.n	a11, a7
420140e5:	ff3165        	call8	420133fc <get_arg$isra$0>
420140e8:	000a52        	l8ui	a5, a10, 0
420140eb:	067d      	mov.n	a7, a6
420140ed:	001f06        	j	4201416d <_svfiprintf_r+0x795>
420140f0:	761b      	addi.n	a7, a6, 1
420140f2:	0aa687        	bge	a6, a8, 42014100 <_svfiprintf_r+0x728>
420140f5:	b0e5e0        	addx8	a14, a5, a14
420140f8:	000e52        	l8ui	a5, a14, 0
420140fb:	001b86        	j	4201416d <_svfiprintf_r+0x795>
420140fe:	920000        	lsi	f0, a0, 0x248
42014101:	2e          	.byte	0x2e
42014102:	fb1c92        	l16ui	a9, a12, 0x1f6
42014105:	02dee2        	addmi	a14, a14, 0x200
42014108:	a94b      	addi.n	a10, a9, 4
4201410a:	362b87        	blt	a11, a8, 42014144 <_svfiprintf_r+0x76c>
4201410d:	b81b      	addi.n	a11, a8, 1
4201410f:	9161b2        	s32i	a11, a1, 0x244
42014112:	126ea2        	s32i	a10, a14, 72
42014115:	8b1c      	movi.n	a11, 24
42014117:	052ba7        	blt	a11, a10, 42014120 <_svfiprintf_r+0x748>
4201411a:	112e92        	l32i	a9, a14, 68
4201411d:	000406        	j	42014131 <_svfiprintf_r+0x759>
42014120:	012b97        	blt	a11, a9, 42014125 <_svfiprintf_r+0x74d>
42014123:	4a2c      	movi.n	a10, 36
42014125:	10c192        	addi	a9, a1, 16
42014128:	02d992        	addmi	a9, a9, 0x200
4201412b:	102992        	l32i	a9, a9, 64
4201412e:	9661a2        	s32i	a10, a1, 0x258
42014131:	99aa      	add.n	a9, a9, a10
42014133:	fcc992        	addi	a9, a9, -4
42014136:	0958      	l32i.n	a5, a9, 0
42014138:	b08810        	addx8	a8, a8, a1
4201413b:	4859      	s32i.n	a5, a8, 16
4201413d:	745050        	extui	a5, a5, 0, 8
42014140:	000a46        	j	4201416d <_svfiprintf_r+0x795>
42014143:	6ea200        	f64rnd	a10, a2, a0, 2
42014146:	881c12        	l16ui	a1, a12, 0x110
42014149:	0728a7        	blt	a8, a10, 42014154 <_svfiprintf_r+0x77c>
4201414c:	112e82        	l32i	a8, a14, 68
4201414f:	000486        	j	42014165 <_svfiprintf_r+0x78d>
42014152:	970000        	lsi	f0, a0, 0x25c
42014155:	0128      	l32i.n	a2, a1, 0
42014157:	4a2c      	movi.n	a10, 36
42014159:	10c182        	addi	a8, a1, 16
4201415c:	02d882        	addmi	a8, a8, 0x200
4201415f:	102882        	l32i	a8, a8, 64
42014162:	9661a2        	s32i	a10, a1, 0x258
42014165:	88aa      	add.n	a8, a8, a10
42014167:	fcc882        	addi	a8, a8, -4
4201416a:	000852        	l8ui	a5, a8, 0
4201416d:	235500        	sext	a5, a5, 7
42014170:	002906        	j	42014218 <_svfiprintf_r+0x840>
42014173:	b3ac00        	movgez	a10, a12, a0
42014176:	07a587        	bge	a5, a8, 42014181 <_svfiprintf_r+0x7a9>
42014179:	b0e5e0        	addx8	a14, a5, a14
4201417c:	0e58      	l32i.n	a5, a14, 0
4201417e:	000706        	j	4201419e <_svfiprintf_r+0x7c6>
42014181:	30a282        	movi	a8, 0x230
42014184:	8e8a      	add.n	a8, a14, a8
42014186:	34a2d2        	movi	a13, 0x234
42014189:	40a2c2        	movi	a12, 0x240
4201418c:	05ad      	mov.n	a10, a5
4201418e:	0189      	s32i.n	a8, a1, 0
42014190:	01def2        	addmi	a15, a14, 0x100
42014193:	deda      	add.n	a13, a14, a13
42014195:	ceca      	add.n	a12, a14, a12
42014197:	07bd      	mov.n	a11, a7
42014199:	ff2625        	call8	420133fc <get_arg$isra$0>
4201419c:	0a58      	l32i.n	a5, a10, 0
4201419e:	067d      	mov.n	a7, a6
420141a0:	001d06        	j	42014218 <_svfiprintf_r+0x840>
420141a3:	761b      	addi.n	a7, a6, 1
420141a5:	07a687        	bge	a6, a8, 420141b0 <_svfiprintf_r+0x7d8>
420141a8:	b0e5e0        	addx8	a14, a5, a14
420141ab:	0e58      	l32i.n	a5, a14, 0
420141ad:	0019c6        	j	42014218 <_svfiprintf_r+0x840>
420141b0:	922e92        	l32i	a9, a14, 0x248
420141b3:	fb1c      	movi.n	a11, 31
420141b5:	02dee2        	addmi	a14, a14, 0x200
420141b8:	a94b      	addi.n	a10, a9, 4
420141ba:	322b87        	blt	a11, a8, 420141f0 <_svfiprintf_r+0x818>
420141bd:	b81b      	addi.n	a11, a8, 1
420141bf:	9161b2        	s32i	a11, a1, 0x244
420141c2:	126ea2        	s32i	a10, a14, 72
420141c5:	8b1c      	movi.n	a11, 24
420141c7:	052ba7        	blt	a11, a10, 420141d0 <_svfiprintf_r+0x7f8>
420141ca:	112e92        	l32i	a9, a14, 68
420141cd:	000406        	j	420141e1 <_svfiprintf_r+0x809>
420141d0:	012b97        	blt	a11, a9, 420141d5 <_svfiprintf_r+0x7fd>
420141d3:	4a2c      	movi.n	a10, 36
420141d5:	10c192        	addi	a9, a1, 16
420141d8:	02d992        	addmi	a9, a9, 0x200
420141db:	102992        	l32i	a9, a9, 64
420141de:	9661a2        	s32i	a10, a1, 0x258
420141e1:	99aa      	add.n	a9, a9, a10
420141e3:	fcc992        	addi	a9, a9, -4
420141e6:	0958      	l32i.n	a5, a9, 0
420141e8:	b08810        	addx8	a8, a8, a1
420141eb:	4859      	s32i.n	a5, a8, 16
420141ed:	0009c6        	j	42014218 <_svfiprintf_r+0x840>
420141f0:	126ea2        	s32i	a10, a14, 72
420141f3:	881c      	movi.n	a8, 24
420141f5:	0728a7        	blt	a8, a10, 42014200 <_svfiprintf_r+0x828>
420141f8:	112e82        	l32i	a8, a14, 68
420141fb:	000486        	j	42014211 <_svfiprintf_r+0x839>
420141fe:	970000        	lsi	f0, a0, 0x25c
42014201:	0128      	l32i.n	a2, a1, 0
42014203:	4a2c      	movi.n	a10, 36
42014205:	10c182        	addi	a8, a1, 16
42014208:	02d882        	addmi	a8, a8, 0x200
4201420b:	102882        	l32i	a8, a8, 64
4201420e:	9661a2        	s32i	a10, a1, 0x258
42014211:	88aa      	add.n	a8, a8, a10
42014213:	fcc882        	addi	a8, a8, -4
42014216:	0858      	l32i.n	a5, a8, 0
42014218:	313f50        	srai	a3, a5, 31
4201421b:	002396        	bltz	a3, 42014221 <_svfiprintf_r+0x849>
4201421e:	0512c6        	j	4201566d <_svfiprintf_r+0x1c95>
42014221:	603030        	neg	a3, a3
42014224:	058c      	beqz.n	a5, 42014228 <_svfiprintf_r+0x850>
42014226:	330b      	addi.n	a3, a3, -1
42014228:	605050        	neg	a5, a5
4201422b:	d82c      	movi.n	a8, 45
4201422d:	190c      	movi.n	a9, 1
4201422f:	036006        	j	42014fb3 <_svfiprintf_r+0x15db>
42014232:	820000        	mull	a0, a0, a0
42014235:	e29121        	l32r	a2, 4200cc7c <_vfprintf_r+0x21c> (a121a206 <_rtc_reserved_end+0x4111a206>)
42014238:	5710c1        	l32r	a12, 41fe9e78 <_coredump_iram_end+0x1c67e78>
4201423b:	c602e2        	l8ui	a14, a2, 198
4201423e:	002b      	addi.n	a0, a0, 2
42014240:	c3ac      	beqz.n	a3, 42014270 <_svfiprintf_r+0x898>
42014242:	07a587        	bge	a5, a8, 4201424d <_svfiprintf_r+0x875>
42014245:	b0e5e0        	addx8	a14, a5, a14
42014248:	0e98      	l32i.n	a9, a14, 0
4201424a:	000706        	j	4201426a <_svfiprintf_r+0x892>
4201424d:	30a282        	movi	a8, 0x230
42014250:	8e8a      	add.n	a8, a14, a8
42014252:	34a2d2        	movi	a13, 0x234
42014255:	40a2c2        	movi	a12, 0x240
42014258:	0189      	s32i.n	a8, a1, 0
4201425a:	01def2        	addmi	a15, a14, 0x100
4201425d:	deda      	add.n	a13, a14, a13
4201425f:	ceca      	add.n	a12, a14, a12
42014261:	07bd      	mov.n	a11, a7
42014263:	05ad      	mov.n	a10, a5
42014265:	ff1965        	call8	420133fc <get_arg$isra$0>
42014268:	0a98      	l32i.n	a9, a10, 0
4201426a:	06ad      	mov.n	a10, a6
4201426c:	001cc6        	j	420142e3 <_svfiprintf_r+0x90b>
4201426f:	a61b00        	lsi	f0, a11, 0x298
42014272:	07a687        	bge	a6, a8, 4201427d <_svfiprintf_r+0x8a5>
42014275:	b0e5e0        	addx8	a14, a5, a14
42014278:	0e98      	l32i.n	a9, a14, 0
4201427a:	001946        	j	420142e3 <_svfiprintf_r+0x90b>
4201427d:	922e92        	l32i	a9, a14, 0x248
42014280:	fc1c      	movi.n	a12, 31
42014282:	02dee2        	addmi	a14, a14, 0x200
42014285:	b94b      	addi.n	a11, a9, 4
42014287:	322c87        	blt	a12, a8, 420142bd <_svfiprintf_r+0x8e5>
4201428a:	c81b      	addi.n	a12, a8, 1
4201428c:	9161c2        	s32i	a12, a1, 0x244
4201428f:	126eb2        	s32i	a11, a14, 72
42014292:	8c1c      	movi.n	a12, 24
42014294:	052cb7        	blt	a12, a11, 4201429d <_svfiprintf_r+0x8c5>
42014297:	112e92        	l32i	a9, a14, 68
4201429a:	000406        	j	420142ae <_svfiprintf_r+0x8d6>
4201429d:	012c97        	blt	a12, a9, 420142a2 <_svfiprintf_r+0x8ca>
420142a0:	4b2c      	movi.n	a11, 36
420142a2:	10c192        	addi	a9, a1, 16
420142a5:	02d992        	addmi	a9, a9, 0x200
420142a8:	102992        	l32i	a9, a9, 64
420142ab:	9661b2        	s32i	a11, a1, 0x258
420142ae:	99ba      	add.n	a9, a9, a11
420142b0:	fcc992        	addi	a9, a9, -4
420142b3:	0998      	l32i.n	a9, a9, 0
420142b5:	b08810        	addx8	a8, a8, a1
420142b8:	4899      	s32i.n	a9, a8, 16
420142ba:	000946        	j	420142e3 <_svfiprintf_r+0x90b>
420142bd:	126eb2        	s32i	a11, a14, 72
420142c0:	881c      	movi.n	a8, 24
420142c2:	0528b7        	blt	a8, a11, 420142cb <_svfiprintf_r+0x8f3>
420142c5:	112e82        	l32i	a8, a14, 68
420142c8:	000406        	j	420142dc <_svfiprintf_r+0x904>
420142cb:	012897        	blt	a8, a9, 420142d0 <_svfiprintf_r+0x8f8>
420142ce:	4b2c      	movi.n	a11, 36
420142d0:	10c182        	addi	a8, a1, 16
420142d3:	02d882        	addmi	a8, a8, 0x200
420142d6:	102882        	l32i	a8, a8, 64
420142d9:	9661b2        	s32i	a11, a1, 0x258
420142dc:	88ba      	add.n	a8, a8, a11
420142de:	fcc882        	addi	a8, a8, -4
420142e1:	0898      	l32i.n	a9, a8, 0
420142e3:	9f2182        	l32i	a8, a1, 0x27c
420142e6:	0989      	s32i.n	a8, a9, 0
420142e8:	318f80        	srai	a8, a8, 31
420142eb:	1989      	s32i.n	a8, a9, 4
420142ed:	0086c6        	j	4201450c <_svfiprintf_r+0xb34>
420142f0:	046247        	bbci	a2, 4, 420142f8 <_svfiprintf_r+0x920>
420142f3:	005a86        	j	42014461 <_svfiprintf_r+0xa89>
420142f6:	670000        	lsi	f0, a0, 0x19c
420142f9:	8602e2        	l8ui	a14, a2, 134
420142fc:	002b      	addi.n	a0, a0, 2
420142fe:	e3ac      	beqz.n	a3, 42014330 <_svfiprintf_r+0x958>
42014300:	09a587        	bge	a5, a8, 4201430d <_svfiprintf_r+0x935>
42014303:	b0e5e0        	addx8	a14, a5, a14
42014306:	0e98      	l32i.n	a9, a14, 0
42014308:	000786        	j	4201432a <_svfiprintf_r+0x952>
4201430b:	820000        	mull	a0, a0, a0
4201430e:	8a30a2        	lsi	f10, a0, 0x228
42014311:	8e          	.byte	0x8e
42014312:	34a2d2        	movi	a13, 0x234
42014315:	40a2c2        	movi	a12, 0x240
42014318:	0189      	s32i.n	a8, a1, 0
4201431a:	01def2        	addmi	a15, a14, 0x100
4201431d:	deda      	add.n	a13, a14, a13
4201431f:	ceca      	add.n	a12, a14, a12
42014321:	07bd      	mov.n	a11, a7
42014323:	05ad      	mov.n	a10, a5
42014325:	ff0d65        	call8	420133fc <get_arg$isra$0>
42014328:	0a98      	l32i.n	a9, a10, 0
4201432a:	06ad      	mov.n	a10, a6
4201432c:	001d06        	j	420143a4 <_svfiprintf_r+0x9cc>
4201432f:	a61b00        	lsi	f0, a11, 0x298
42014332:	07a687        	bge	a6, a8, 4201433d <_svfiprintf_r+0x965>
42014335:	b0e5e0        	addx8	a14, a5, a14
42014338:	0e98      	l32i.n	a9, a14, 0
4201433a:	001986        	j	420143a4 <_svfiprintf_r+0x9cc>
4201433d:	922e92        	l32i	a9, a14, 0x248
42014340:	fc1c      	movi.n	a12, 31
42014342:	02dee2        	addmi	a14, a14, 0x200
42014345:	b94b      	addi.n	a11, a9, 4
42014347:	322c87        	blt	a12, a8, 4201437d <_svfiprintf_r+0x9a5>
4201434a:	c81b      	addi.n	a12, a8, 1
4201434c:	9161c2        	s32i	a12, a1, 0x244
4201434f:	126eb2        	s32i	a11, a14, 72
42014352:	8c1c      	movi.n	a12, 24
42014354:	052cb7        	blt	a12, a11, 4201435d <_svfiprintf_r+0x985>
42014357:	112e92        	l32i	a9, a14, 68
4201435a:	000406        	j	4201436e <_svfiprintf_r+0x996>
4201435d:	012c97        	blt	a12, a9, 42014362 <_svfiprintf_r+0x98a>
42014360:	4b2c      	movi.n	a11, 36
42014362:	10c192        	addi	a9, a1, 16
42014365:	02d992        	addmi	a9, a9, 0x200
42014368:	102992        	l32i	a9, a9, 64
4201436b:	9661b2        	s32i	a11, a1, 0x258
4201436e:	99ba      	add.n	a9, a9, a11
42014370:	fcc992        	addi	a9, a9, -4
42014373:	0998      	l32i.n	a9, a9, 0
42014375:	b08810        	addx8	a8, a8, a1
42014378:	4899      	s32i.n	a9, a8, 16
4201437a:	000986        	j	420143a4 <_svfiprintf_r+0x9cc>
4201437d:	126eb2        	s32i	a11, a14, 72
42014380:	881c      	movi.n	a8, 24
42014382:	0628b7        	blt	a8, a11, 4201438c <_svfiprintf_r+0x9b4>
42014385:	112e82        	l32i	a8, a14, 68
42014388:	000446        	j	4201439d <_svfiprintf_r+0x9c5>
4201438b:	289700        	lsi	f0, a7, 160
4201438e:	4b2c01        	l32r	a0, 41fe7040 <_coredump_iram_end+0x1c65040>
42014391:	10c182        	addi	a8, a1, 16
42014394:	02d882        	addmi	a8, a8, 0x200
42014397:	102882        	l32i	a8, a8, 64
4201439a:	9661b2        	s32i	a11, a1, 0x258
4201439d:	88ba      	add.n	a8, a8, a11
4201439f:	fcc882        	addi	a8, a8, -4
420143a2:	0898      	l32i.n	a9, a8, 0
420143a4:	9f2182        	l32i	a8, a1, 0x27c
420143a7:	005982        	s16i	a8, a9, 0
420143aa:	005786        	j	4201450c <_svfiprintf_r+0xb34>
420143ad:	02e297        	bbsi	a2, 9, 420143b3 <_svfiprintf_r+0x9db>
420143b0:	002b46        	j	42014461 <_svfiprintf_r+0xa89>
420143b3:	c3ac      	beqz.n	a3, 420143e3 <_svfiprintf_r+0xa0b>
420143b5:	08a587        	bge	a5, a8, 420143c1 <_svfiprintf_r+0x9e9>
420143b8:	b0e5e0        	addx8	a14, a5, a14
420143bb:	0e98      	l32i.n	a9, a14, 0
420143bd:	000746        	j	420143de <_svfiprintf_r+0xa06>
420143c0:	a28200        	muluh	a8, a2, a0
420143c3:	8e8a30        	f64iter	a8, a10, a3, 0, 0
420143c6:	34a2d2        	movi	a13, 0x234
420143c9:	40a2c2        	movi	a12, 0x240
420143cc:	0189      	s32i.n	a8, a1, 0
420143ce:	01def2        	addmi	a15, a14, 0x100
420143d1:	deda      	add.n	a13, a14, a13
420143d3:	ceca      	add.n	a12, a14, a12
420143d5:	07bd      	mov.n	a11, a7
420143d7:	05ad      	mov.n	a10, a5
420143d9:	ff0225        	call8	420133fc <get_arg$isra$0>
420143dc:	0a98      	l32i.n	a9, a10, 0
420143de:	06ad      	mov.n	a10, a6
420143e0:	001d06        	j	42014458 <_svfiprintf_r+0xa80>
420143e3:	a61b      	addi.n	a10, a6, 1
420143e5:	07a687        	bge	a6, a8, 420143f0 <_svfiprintf_r+0xa18>
420143e8:	b0e5e0        	addx8	a14, a5, a14
420143eb:	0e98      	l32i.n	a9, a14, 0
420143ed:	0019c6        	j	42014458 <_svfiprintf_r+0xa80>
420143f0:	922e92        	l32i	a9, a14, 0x248
420143f3:	fc1c      	movi.n	a12, 31
420143f5:	02dee2        	addmi	a14, a14, 0x200
420143f8:	b94b      	addi.n	a11, a9, 4
420143fa:	322c87        	blt	a12, a8, 42014430 <_svfiprintf_r+0xa58>
420143fd:	c81b      	addi.n	a12, a8, 1
420143ff:	9161c2        	s32i	a12, a1, 0x244
42014402:	126eb2        	s32i	a11, a14, 72
42014405:	8c1c      	movi.n	a12, 24
42014407:	052cb7        	blt	a12, a11, 42014410 <_svfiprintf_r+0xa38>
4201440a:	112e92        	l32i	a9, a14, 68
4201440d:	000406        	j	42014421 <_svfiprintf_r+0xa49>
42014410:	012c97        	blt	a12, a9, 42014415 <_svfiprintf_r+0xa3d>
42014413:	4b2c      	movi.n	a11, 36
42014415:	10c192        	addi	a9, a1, 16
42014418:	02d992        	addmi	a9, a9, 0x200
4201441b:	102992        	l32i	a9, a9, 64
4201441e:	9661b2        	s32i	a11, a1, 0x258
42014421:	99ba      	add.n	a9, a9, a11
42014423:	fcc992        	addi	a9, a9, -4
42014426:	0998      	l32i.n	a9, a9, 0
42014428:	b08810        	addx8	a8, a8, a1
4201442b:	4899      	s32i.n	a9, a8, 16
4201442d:	0009c6        	j	42014458 <_svfiprintf_r+0xa80>
42014430:	126eb2        	s32i	a11, a14, 72
42014433:	881c      	movi.n	a8, 24
42014435:	0728b7        	blt	a8, a11, 42014440 <_svfiprintf_r+0xa68>
42014438:	112e82        	l32i	a8, a14, 68
4201443b:	000486        	j	42014451 <_svfiprintf_r+0xa79>
4201443e:	970000        	lsi	f0, a0, 0x25c
42014441:	0128      	l32i.n	a2, a1, 0
42014443:	4b2c      	movi.n	a11, 36
42014445:	10c182        	addi	a8, a1, 16
42014448:	02d882        	addmi	a8, a8, 0x200
4201444b:	102882        	l32i	a8, a8, 64
4201444e:	9661b2        	s32i	a11, a1, 0x258
42014451:	88ba      	add.n	a8, a8, a11
42014453:	fcc882        	addi	a8, a8, -4
42014456:	0898      	l32i.n	a9, a8, 0
42014458:	9f2182        	l32i	a8, a1, 0x27c
4201445b:	004982        	s8i	a8, a9, 0
4201445e:	002a86        	j	4201450c <_svfiprintf_r+0xb34>
42014461:	f3ac      	beqz.n	a3, 42014494 <_svfiprintf_r+0xabc>
42014463:	0aa587        	bge	a5, a8, 42014471 <_svfiprintf_r+0xa99>
42014466:	b0e5e0        	addx8	a14, a5, a14
42014469:	0e98      	l32i.n	a9, a14, 0
4201446b:	0007c6        	j	4201448e <_svfiprintf_r+0xab6>
4201446e:	000000        	ill
42014471:	30a282        	movi	a8, 0x230
42014474:	8e8a      	add.n	a8, a14, a8
42014476:	34a2d2        	movi	a13, 0x234
42014479:	40a2c2        	movi	a12, 0x240
4201447c:	0189      	s32i.n	a8, a1, 0
4201447e:	01def2        	addmi	a15, a14, 0x100
42014481:	deda      	add.n	a13, a14, a13
42014483:	ceca      	add.n	a12, a14, a12
42014485:	07bd      	mov.n	a11, a7
42014487:	05ad      	mov.n	a10, a5
42014489:	fef725        	call8	420133fc <get_arg$isra$0>
4201448c:	0a98      	l32i.n	a9, a10, 0
4201448e:	06ad      	mov.n	a10, a6
42014490:	001cc6        	j	42014507 <_svfiprintf_r+0xb2f>
42014493:	a61b00        	lsi	f0, a11, 0x298
42014496:	07a687        	bge	a6, a8, 420144a1 <_svfiprintf_r+0xac9>
42014499:	b0e5e0        	addx8	a14, a5, a14
4201449c:	0e98      	l32i.n	a9, a14, 0
4201449e:	001946        	j	42014507 <_svfiprintf_r+0xb2f>
420144a1:	922e92        	l32i	a9, a14, 0x248
420144a4:	fc1c      	movi.n	a12, 31
420144a6:	02dee2        	addmi	a14, a14, 0x200
420144a9:	b94b      	addi.n	a11, a9, 4
420144ab:	322c87        	blt	a12, a8, 420144e1 <_svfiprintf_r+0xb09>
420144ae:	c81b      	addi.n	a12, a8, 1
420144b0:	9161c2        	s32i	a12, a1, 0x244
420144b3:	126eb2        	s32i	a11, a14, 72
420144b6:	8c1c      	movi.n	a12, 24
420144b8:	052cb7        	blt	a12, a11, 420144c1 <_svfiprintf_r+0xae9>
420144bb:	112e92        	l32i	a9, a14, 68
420144be:	000406        	j	420144d2 <_svfiprintf_r+0xafa>
420144c1:	012c97        	blt	a12, a9, 420144c6 <_svfiprintf_r+0xaee>
420144c4:	4b2c      	movi.n	a11, 36
420144c6:	10c192        	addi	a9, a1, 16
420144c9:	02d992        	addmi	a9, a9, 0x200
420144cc:	102992        	l32i	a9, a9, 64
420144cf:	9661b2        	s32i	a11, a1, 0x258
420144d2:	99ba      	add.n	a9, a9, a11
420144d4:	fcc992        	addi	a9, a9, -4
420144d7:	0998      	l32i.n	a9, a9, 0
420144d9:	b08810        	addx8	a8, a8, a1
420144dc:	4899      	s32i.n	a9, a8, 16
420144de:	000946        	j	42014507 <_svfiprintf_r+0xb2f>
420144e1:	126eb2        	s32i	a11, a14, 72
420144e4:	881c      	movi.n	a8, 24
420144e6:	0528b7        	blt	a8, a11, 420144ef <_svfiprintf_r+0xb17>
420144e9:	112e82        	l32i	a8, a14, 68
420144ec:	000406        	j	42014500 <_svfiprintf_r+0xb28>
420144ef:	012897        	blt	a8, a9, 420144f4 <_svfiprintf_r+0xb1c>
420144f2:	4b2c      	movi.n	a11, 36
420144f4:	10c182        	addi	a8, a1, 16
420144f7:	02d882        	addmi	a8, a8, 0x200
420144fa:	102882        	l32i	a8, a8, 64
420144fd:	9661b2        	s32i	a11, a1, 0x258
42014500:	88ba      	add.n	a8, a8, a11
42014502:	fcc882        	addi	a8, a8, -4
42014505:	0898      	l32i.n	a9, a8, 0
42014507:	9f2182        	l32i	a8, a1, 0x27c
4201450a:	0989      	s32i.n	a8, a9, 0
4201450c:	0a6d      	mov.n	a6, a10
4201450e:	fd5286        	j	42013a5c <_svfiprintf_r+0x84>
42014511:	081c      	movi.n	a8, 16
42014513:	202280        	or	a2, a2, a8
42014516:	912182        	l32i	a8, a1, 0x244
42014519:	10c1e2        	addi	a14, a1, 16
4201451c:	02e257        	bbsi	a2, 5, 42014522 <_svfiprintf_r+0xb4a>
4201451f:	002f86        	j	420145e1 <_svfiprintf_r+0xc09>
42014522:	f3ac      	beqz.n	a3, 42014555 <_svfiprintf_r+0xb7d>
42014524:	09a587        	bge	a5, a8, 42014531 <_svfiprintf_r+0xb59>
42014527:	b0e5e0        	addx8	a14, a5, a14
4201452a:	0e58      	l32i.n	a5, a14, 0
4201452c:	1e38      	l32i.n	a3, a14, 4
4201452e:	000786        	j	42014550 <_svfiprintf_r+0xb78>
42014531:	30a282        	movi	a8, 0x230
42014534:	8e8a      	add.n	a8, a14, a8
42014536:	34a2d2        	movi	a13, 0x234
42014539:	40a2c2        	movi	a12, 0x240
4201453c:	05ad      	mov.n	a10, a5
4201453e:	0189      	s32i.n	a8, a1, 0
42014540:	01def2        	addmi	a15, a14, 0x100
42014543:	deda      	add.n	a13, a14, a13
42014545:	ceca      	add.n	a12, a14, a12
42014547:	07bd      	mov.n	a11, a7
42014549:	feeb25        	call8	420133fc <get_arg$isra$0>
4201454c:	0a58      	l32i.n	a5, a10, 0
4201454e:	1a38      	l32i.n	a3, a10, 4
42014550:	067d      	mov.n	a7, a6
42014552:	00a806        	j	420147f6 <_svfiprintf_r+0xe1e>
42014555:	761b      	addi.n	a7, a6, 1
42014557:	09a687        	bge	a6, a8, 42014564 <_svfiprintf_r+0xb8c>
4201455a:	b0e5e0        	addx8	a14, a5, a14
4201455d:	0e58      	l32i.n	a5, a14, 0
4201455f:	1e38      	l32i.n	a3, a14, 4
42014561:	00a446        	j	420147f6 <_svfiprintf_r+0xe1e>
42014564:	922e92        	l32i	a9, a14, 0x248
42014567:	8a7c      	movi.n	a10, -8
42014569:	997b      	addi.n	a9, a9, 7
4201456b:	1099a0        	and	a9, a9, a10
4201456e:	fb1c      	movi.n	a11, 31
42014570:	02dee2        	addmi	a14, a14, 0x200
42014573:	a98b      	addi.n	a10, a9, 8
42014575:	3b2b87        	blt	a11, a8, 420145b4 <_svfiprintf_r+0xbdc>
42014578:	b81b      	addi.n	a11, a8, 1
4201457a:	9161b2        	s32i	a11, a1, 0x244
4201457d:	126ea2        	s32i	a10, a14, 72
42014580:	8b1c      	movi.n	a11, 24
42014582:	062ba7        	blt	a11, a10, 4201458c <_svfiprintf_r+0xbb4>
42014585:	112e92        	l32i	a9, a14, 68
42014588:	000446        	j	4201459d <_svfiprintf_r+0xbc5>
4201458b:	2b9700        	oeq.s	b9, f7, f0
4201458e:	8a2c01        	l32r	a0, 41ff6e40 <_coredump_iram_end+0x1c74e40>
42014591:	10c192        	addi	a9, a1, 16
42014594:	02d992        	addmi	a9, a9, 0x200
42014597:	102992        	l32i	a9, a9, 64
4201459a:	9661a2        	s32i	a10, a1, 0x258
4201459d:	99aa      	add.n	a9, a9, a10
4201459f:	f8c992        	addi	a9, a9, -8
420145a2:	0958      	l32i.n	a5, a9, 0
420145a4:	1938      	l32i.n	a3, a9, 4
420145a6:	10c192        	addi	a9, a1, 16
420145a9:	b08890        	addx8	a8, a8, a9
420145ac:	0859      	s32i.n	a5, a8, 0
420145ae:	1839      	s32i.n	a3, a8, 4
420145b0:	009086        	j	420147f6 <_svfiprintf_r+0xe1e>
420145b3:	6ea200        	f64rnd	a10, a2, a0, 2
420145b6:	881c12        	l16ui	a1, a12, 0x110
420145b9:	0728a7        	blt	a8, a10, 420145c4 <_svfiprintf_r+0xbec>
420145bc:	112e82        	l32i	a8, a14, 68
420145bf:	000486        	j	420145d5 <_svfiprintf_r+0xbfd>
420145c2:	970000        	lsi	f0, a0, 0x25c
420145c5:	0128      	l32i.n	a2, a1, 0
420145c7:	8a2c      	movi.n	a10, 40
420145c9:	10c182        	addi	a8, a1, 16
420145cc:	02d882        	addmi	a8, a8, 0x200
420145cf:	102882        	l32i	a8, a8, 64
420145d2:	9661a2        	s32i	a10, a1, 0x258
420145d5:	88aa      	add.n	a8, a8, a10
420145d7:	f8c882        	addi	a8, a8, -8
420145da:	0858      	l32i.n	a5, a8, 0
420145dc:	1838      	l32i.n	a3, a8, 4
420145de:	008506        	j	420147f6 <_svfiprintf_r+0xe1e>
420145e1:	036247        	bbci	a2, 4, 420145e8 <_svfiprintf_r+0xc10>
420145e4:	005a06        	j	42014750 <_svfiprintf_r+0xd78>
420145e7:	e26700        	remu	a6, a7, a0
420145ea:	2b4602        	s8i	a0, a6, 43
420145ed:	c3ac00        	movf	a10, a12, b0
420145f0:	09a587        	bge	a5, a8, 420145fd <_svfiprintf_r+0xc25>
420145f3:	b0e5e0        	addx8	a14, a5, a14
420145f6:	001e52        	l16ui	a5, a14, 0
420145f9:	005f46        	j	4201477a <_svfiprintf_r+0xda2>
420145fc:	a28200        	muluh	a8, a2, a0
420145ff:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42014602:	34a2d2        	movi	a13, 0x234
42014605:	40a2c2        	movi	a12, 0x240
42014608:	05ad      	mov.n	a10, a5
4201460a:	0189      	s32i.n	a8, a1, 0
4201460c:	01def2        	addmi	a15, a14, 0x100
4201460f:	deda      	add.n	a13, a14, a13
42014611:	ceca      	add.n	a12, a14, a12
42014613:	07bd      	mov.n	a11, a7
42014615:	fede65        	call8	420133fc <get_arg$isra$0>
42014618:	001a52        	l16ui	a5, a10, 0
4201461b:	0056c6        	j	4201477a <_svfiprintf_r+0xda2>
4201461e:	761b      	addi.n	a7, a6, 1
42014620:	08a687        	bge	a6, a8, 4201462c <_svfiprintf_r+0xc54>
42014623:	b0e5e0        	addx8	a14, a5, a14
42014626:	001e52        	l16ui	a5, a14, 0
42014629:	0071c6        	j	420147f4 <_svfiprintf_r+0xe1c>
4201462c:	922e92        	l32i	a9, a14, 0x248
4201462f:	fb1c      	movi.n	a11, 31
42014631:	02dee2        	addmi	a14, a14, 0x200
42014634:	a94b      	addi.n	a10, a9, 4
42014636:	362b87        	blt	a11, a8, 42014670 <_svfiprintf_r+0xc98>
42014639:	b81b      	addi.n	a11, a8, 1
4201463b:	9161b2        	s32i	a11, a1, 0x244
4201463e:	126ea2        	s32i	a10, a14, 72
42014641:	8b1c      	movi.n	a11, 24
42014643:	052ba7        	blt	a11, a10, 4201464c <_svfiprintf_r+0xc74>
42014646:	112e92        	l32i	a9, a14, 68
42014649:	000406        	j	4201465d <_svfiprintf_r+0xc85>
4201464c:	012b97        	blt	a11, a9, 42014651 <_svfiprintf_r+0xc79>
4201464f:	4a2c      	movi.n	a10, 36
42014651:	10c192        	addi	a9, a1, 16
42014654:	02d992        	addmi	a9, a9, 0x200
42014657:	102992        	l32i	a9, a9, 64
4201465a:	9661a2        	s32i	a10, a1, 0x258
4201465d:	99aa      	add.n	a9, a9, a10
4201465f:	fcc992        	addi	a9, a9, -4
42014662:	0958      	l32i.n	a5, a9, 0
42014664:	b08810        	addx8	a8, a8, a1
42014667:	4859      	s32i.n	a5, a8, 16
42014669:	f45050        	extui	a5, a5, 0, 16
4201466c:	006106        	j	420147f4 <_svfiprintf_r+0xe1c>
4201466f:	6ea200        	f64rnd	a10, a2, a0, 2
42014672:	881c12        	l16ui	a1, a12, 0x110
42014675:	0728a7        	blt	a8, a10, 42014680 <_svfiprintf_r+0xca8>
42014678:	112e82        	l32i	a8, a14, 68
4201467b:	000486        	j	42014691 <_svfiprintf_r+0xcb9>
4201467e:	970000        	lsi	f0, a0, 0x25c
42014681:	0128      	l32i.n	a2, a1, 0
42014683:	4a2c      	movi.n	a10, 36
42014685:	10c182        	addi	a8, a1, 16
42014688:	02d882        	addmi	a8, a8, 0x200
4201468b:	102882        	l32i	a8, a8, 64
4201468e:	9661a2        	s32i	a10, a1, 0x258
42014691:	88aa      	add.n	a8, a8, a10
42014693:	fcc882        	addi	a8, a8, -4
42014696:	001852        	l16ui	a5, a8, 0
42014699:	0055c6        	j	420147f4 <_svfiprintf_r+0xe1c>
4201469c:	02e297        	bbsi	a2, 9, 420146a2 <_svfiprintf_r+0xcca>
4201469f:	002b46        	j	42014750 <_svfiprintf_r+0xd78>
420146a2:	c3ac      	beqz.n	a3, 420146d2 <_svfiprintf_r+0xcfa>
420146a4:	09a587        	bge	a5, a8, 420146b1 <_svfiprintf_r+0xcd9>
420146a7:	b0e5e0        	addx8	a14, a5, a14
420146aa:	000e52        	l8ui	a5, a14, 0
420146ad:	003246        	j	4201477a <_svfiprintf_r+0xda2>
420146b0:	a28200        	muluh	a8, a2, a0
420146b3:	8e8a30        	f64iter	a8, a10, a3, 0, 0
420146b6:	34a2d2        	movi	a13, 0x234
420146b9:	40a2c2        	movi	a12, 0x240
420146bc:	05ad      	mov.n	a10, a5
420146be:	0189      	s32i.n	a8, a1, 0
420146c0:	01def2        	addmi	a15, a14, 0x100
420146c3:	deda      	add.n	a13, a14, a13
420146c5:	ceca      	add.n	a12, a14, a12
420146c7:	07bd      	mov.n	a11, a7
420146c9:	fed325        	call8	420133fc <get_arg$isra$0>
420146cc:	000a52        	l8ui	a5, a10, 0
420146cf:	0029c6        	j	4201477a <_svfiprintf_r+0xda2>
420146d2:	761b      	addi.n	a7, a6, 1
420146d4:	08a687        	bge	a6, a8, 420146e0 <_svfiprintf_r+0xd08>
420146d7:	b0e5e0        	addx8	a14, a5, a14
420146da:	000e52        	l8ui	a5, a14, 0
420146dd:	0044c6        	j	420147f4 <_svfiprintf_r+0xe1c>
420146e0:	922e92        	l32i	a9, a14, 0x248
420146e3:	fb1c      	movi.n	a11, 31
420146e5:	02dee2        	addmi	a14, a14, 0x200
420146e8:	a94b      	addi.n	a10, a9, 4
420146ea:	362b87        	blt	a11, a8, 42014724 <_svfiprintf_r+0xd4c>
420146ed:	b81b      	addi.n	a11, a8, 1
420146ef:	9161b2        	s32i	a11, a1, 0x244
420146f2:	126ea2        	s32i	a10, a14, 72
420146f5:	8b1c      	movi.n	a11, 24
420146f7:	052ba7        	blt	a11, a10, 42014700 <_svfiprintf_r+0xd28>
420146fa:	112e92        	l32i	a9, a14, 68
420146fd:	000406        	j	42014711 <_svfiprintf_r+0xd39>
42014700:	012b97        	blt	a11, a9, 42014705 <_svfiprintf_r+0xd2d>
42014703:	4a2c      	movi.n	a10, 36
42014705:	10c192        	addi	a9, a1, 16
42014708:	02d992        	addmi	a9, a9, 0x200
4201470b:	102992        	l32i	a9, a9, 64
4201470e:	9661a2        	s32i	a10, a1, 0x258
42014711:	99aa      	add.n	a9, a9, a10
42014713:	fcc992        	addi	a9, a9, -4
42014716:	0958      	l32i.n	a5, a9, 0
42014718:	b08810        	addx8	a8, a8, a1
4201471b:	4859      	s32i.n	a5, a8, 16
4201471d:	745050        	extui	a5, a5, 0, 8
42014720:	003406        	j	420147f4 <_svfiprintf_r+0xe1c>
42014723:	6ea200        	f64rnd	a10, a2, a0, 2
42014726:	881c12        	l16ui	a1, a12, 0x110
42014729:	0528a7        	blt	a8, a10, 42014732 <_svfiprintf_r+0xd5a>
4201472c:	112e82        	l32i	a8, a14, 68
4201472f:	000446        	j	42014744 <_svfiprintf_r+0xd6c>
42014732:	022897        	blt	a8, a9, 42014738 <_svfiprintf_r+0xd60>
42014735:	24a0a2        	movi	a10, 36
42014738:	10c182        	addi	a8, a1, 16
4201473b:	02d882        	addmi	a8, a8, 0x200
4201473e:	102882        	l32i	a8, a8, 64
42014741:	9661a2        	s32i	a10, a1, 0x258
42014744:	88aa      	add.n	a8, a8, a10
42014746:	fcc882        	addi	a8, a8, -4
42014749:	000852        	l8ui	a5, a8, 0
4201474c:	002906        	j	420147f4 <_svfiprintf_r+0xe1c>
4201474f:	c3ac00        	movf	a10, a12, b0
42014752:	07a587        	bge	a5, a8, 4201475d <_svfiprintf_r+0xd85>
42014755:	b0e5e0        	addx8	a14, a5, a14
42014758:	0e58      	l32i.n	a5, a14, 0
4201475a:	000706        	j	4201477a <_svfiprintf_r+0xda2>
4201475d:	30a282        	movi	a8, 0x230
42014760:	8e8a      	add.n	a8, a14, a8
42014762:	34a2d2        	movi	a13, 0x234
42014765:	40a2c2        	movi	a12, 0x240
42014768:	05ad      	mov.n	a10, a5
4201476a:	0189      	s32i.n	a8, a1, 0
4201476c:	01def2        	addmi	a15, a14, 0x100
4201476f:	deda      	add.n	a13, a14, a13
42014771:	ceca      	add.n	a12, a14, a12
42014773:	07bd      	mov.n	a11, a7
42014775:	fec865        	call8	420133fc <get_arg$isra$0>
42014778:	0a58      	l32i.n	a5, a10, 0
4201477a:	067d      	mov.n	a7, a6
4201477c:	001d06        	j	420147f4 <_svfiprintf_r+0xe1c>
4201477f:	761b00        	lsi	f0, a11, 0x1d8
42014782:	07a687        	bge	a6, a8, 4201478d <_svfiprintf_r+0xdb5>
42014785:	b0e5e0        	addx8	a14, a5, a14
42014788:	0e58      	l32i.n	a5, a14, 0
4201478a:	001986        	j	420147f4 <_svfiprintf_r+0xe1c>
4201478d:	922e92        	l32i	a9, a14, 0x248
42014790:	fb1c      	movi.n	a11, 31
42014792:	02dee2        	addmi	a14, a14, 0x200
42014795:	a94b      	addi.n	a10, a9, 4
42014797:	322b87        	blt	a11, a8, 420147cd <_svfiprintf_r+0xdf5>
4201479a:	b81b      	addi.n	a11, a8, 1
4201479c:	9161b2        	s32i	a11, a1, 0x244
4201479f:	126ea2        	s32i	a10, a14, 72
420147a2:	8b1c      	movi.n	a11, 24
420147a4:	052ba7        	blt	a11, a10, 420147ad <_svfiprintf_r+0xdd5>
420147a7:	112e92        	l32i	a9, a14, 68
420147aa:	000406        	j	420147be <_svfiprintf_r+0xde6>
420147ad:	012b97        	blt	a11, a9, 420147b2 <_svfiprintf_r+0xdda>
420147b0:	4a2c      	movi.n	a10, 36
420147b2:	10c192        	addi	a9, a1, 16
420147b5:	02d992        	addmi	a9, a9, 0x200
420147b8:	102992        	l32i	a9, a9, 64
420147bb:	9661a2        	s32i	a10, a1, 0x258
420147be:	99aa      	add.n	a9, a9, a10
420147c0:	fcc992        	addi	a9, a9, -4
420147c3:	0958      	l32i.n	a5, a9, 0
420147c5:	b08810        	addx8	a8, a8, a1
420147c8:	4859      	s32i.n	a5, a8, 16
420147ca:	000986        	j	420147f4 <_svfiprintf_r+0xe1c>
420147cd:	126ea2        	s32i	a10, a14, 72
420147d0:	881c      	movi.n	a8, 24
420147d2:	0628a7        	blt	a8, a10, 420147dc <_svfiprintf_r+0xe04>
420147d5:	112e82        	l32i	a8, a14, 68
420147d8:	000446        	j	420147ed <_svfiprintf_r+0xe15>
420147db:	289700        	lsi	f0, a7, 160
420147de:	4a2c01        	l32r	a0, 41fe7090 <_coredump_iram_end+0x1c65090>
420147e1:	10c182        	addi	a8, a1, 16
420147e4:	02d882        	addmi	a8, a8, 0x200
420147e7:	102882        	l32i	a8, a8, 64
420147ea:	9661a2        	s32i	a10, a1, 0x258
420147ed:	88aa      	add.n	a8, a8, a10
420147ef:	fcc882        	addi	a8, a8, -4
420147f2:	0858      	l32i.n	a5, a8, 0
420147f4:	030c      	movi.n	a3, 0
420147f6:	ffab82        	movi	a8, 0xfffffbff
420147f9:	102280        	and	a2, a2, a8
420147fc:	090c      	movi.n	a9, 0
420147fe:	01ebc6        	j	42014fb1 <_svfiprintf_r+0x15d9>
42014801:	218200        	srai	a8, a0, 2
42014804:	c1e291        	l32r	a9, 42004f8c <esp_mprot_set_monitor_en+0x50> (edb22100 <_rtc_reserved_end+0x8da22100>)
42014807:	c3ac10        	movf	a10, a12, b1
4201480a:	07a587        	bge	a5, a8, 42014815 <_svfiprintf_r+0xe3d>
4201480d:	b0e5e0        	addx8	a14, a5, a14
42014810:	0e58      	l32i.n	a5, a14, 0
42014812:	000706        	j	42014832 <_svfiprintf_r+0xe5a>
42014815:	30a282        	movi	a8, 0x230
42014818:	8e8a      	add.n	a8, a14, a8
4201481a:	34a2d2        	movi	a13, 0x234
4201481d:	40a2c2        	movi	a12, 0x240
42014820:	05ad      	mov.n	a10, a5
42014822:	0189      	s32i.n	a8, a1, 0
42014824:	01def2        	addmi	a15, a14, 0x100
42014827:	deda      	add.n	a13, a14, a13
42014829:	ceca      	add.n	a12, a14, a12
4201482b:	07bd      	mov.n	a11, a7
4201482d:	febce5        	call8	420133fc <get_arg$isra$0>
42014830:	0a58      	l32i.n	a5, a10, 0
42014832:	067d      	mov.n	a7, a6
42014834:	001d06        	j	420148ac <_svfiprintf_r+0xed4>
42014837:	761b00        	lsi	f0, a11, 0x1d8
4201483a:	07a687        	bge	a6, a8, 42014845 <_svfiprintf_r+0xe6d>
4201483d:	b0e5e0        	addx8	a14, a5, a14
42014840:	0e58      	l32i.n	a5, a14, 0
42014842:	001986        	j	420148ac <_svfiprintf_r+0xed4>
42014845:	922e92        	l32i	a9, a14, 0x248
42014848:	fb1c      	movi.n	a11, 31
4201484a:	02dee2        	addmi	a14, a14, 0x200
4201484d:	a94b      	addi.n	a10, a9, 4
4201484f:	322b87        	blt	a11, a8, 42014885 <_svfiprintf_r+0xead>
42014852:	b81b      	addi.n	a11, a8, 1
42014854:	9161b2        	s32i	a11, a1, 0x244
42014857:	126ea2        	s32i	a10, a14, 72
4201485a:	8b1c      	movi.n	a11, 24
4201485c:	052ba7        	blt	a11, a10, 42014865 <_svfiprintf_r+0xe8d>
4201485f:	112e92        	l32i	a9, a14, 68
42014862:	000406        	j	42014876 <_svfiprintf_r+0xe9e>
42014865:	012b97        	blt	a11, a9, 4201486a <_svfiprintf_r+0xe92>
42014868:	4a2c      	movi.n	a10, 36
4201486a:	10c192        	addi	a9, a1, 16
4201486d:	02d992        	addmi	a9, a9, 0x200
42014870:	102992        	l32i	a9, a9, 64
42014873:	9661a2        	s32i	a10, a1, 0x258
42014876:	99aa      	add.n	a9, a9, a10
42014878:	fcc992        	addi	a9, a9, -4
4201487b:	0958      	l32i.n	a5, a9, 0
4201487d:	b08810        	addx8	a8, a8, a1
42014880:	4859      	s32i.n	a5, a8, 16
42014882:	000986        	j	420148ac <_svfiprintf_r+0xed4>
42014885:	126ea2        	s32i	a10, a14, 72
42014888:	881c      	movi.n	a8, 24
4201488a:	0628a7        	blt	a8, a10, 42014894 <_svfiprintf_r+0xebc>
4201488d:	112e82        	l32i	a8, a14, 68
42014890:	000446        	j	420148a5 <_svfiprintf_r+0xecd>
42014893:	289700        	lsi	f0, a7, 160
42014896:	4a2c01        	l32r	a0, 41fe7148 <_coredump_iram_end+0x1c65148>
42014899:	10c182        	addi	a8, a1, 16
4201489c:	02d882        	addmi	a8, a8, 0x200
4201489f:	102882        	l32i	a8, a8, 64
420148a2:	9661a2        	s32i	a10, a1, 0x258
420148a5:	88aa      	add.n	a8, a8, a10
420148a7:	fcc882        	addi	a8, a8, -4
420148aa:	0858      	l32i.n	a5, a8, 0
420148ac:	280c      	movi.n	a8, 2
420148ae:	202280        	or	a2, a2, a8
420148b1:	10c182        	addi	a8, a1, 16
420148b4:	02d882        	addmi	a8, a8, 0x200
420148b7:	093c      	movi.n	a9, 48
420148b9:	384892        	s8i	a9, a8, 56
420148bc:	78a092        	movi	a9, 120
420148bf:	394892        	s8i	a9, a8, 57
420148c2:	b18f81        	l32r	a8, 42000f00 <_stext+0xee0> (3c0295c4 <_ZTISt12out_of_range+0x138>)
420148c5:	030c      	movi.n	a3, 0
420148c7:	a26182        	s32i	a8, a1, 0x288
420148ca:	01b846        	j	42014faf <_svfiprintf_r+0x15d7>
420148cd:	219200        	srai	a9, a0, 2
420148d0:	c1e291        	l32r	a9, 42005058 <esp_mprot_monitor_clear_intr+0x60> (65ff35a5 <_rtc_reserved_end+0x5ef35a5>)
420148d3:	c3ac10        	movf	a10, a12, b1
420148d6:	07a597        	bge	a5, a9, 420148e1 <_svfiprintf_r+0xf09>
420148d9:	b0e5e0        	addx8	a14, a5, a14
420148dc:	0e48      	l32i.n	a4, a14, 0
420148de:	000706        	j	420148fe <_svfiprintf_r+0xf26>
420148e1:	30a282        	movi	a8, 0x230
420148e4:	8e8a      	add.n	a8, a14, a8
420148e6:	34a2d2        	movi	a13, 0x234
420148e9:	40a2c2        	movi	a12, 0x240
420148ec:	0189      	s32i.n	a8, a1, 0
420148ee:	01def2        	addmi	a15, a14, 0x100
420148f1:	deda      	add.n	a13, a14, a13
420148f3:	ceca      	add.n	a12, a14, a12
420148f5:	07bd      	mov.n	a11, a7
420148f7:	05ad      	mov.n	a10, a5
420148f9:	feb025        	call8	420133fc <get_arg$isra$0>
420148fc:	0a48      	l32i.n	a4, a10, 0
420148fe:	067d      	mov.n	a7, a6
42014900:	001d06        	j	42014978 <_svfiprintf_r+0xfa0>
42014903:	761b00        	lsi	f0, a11, 0x1d8
42014906:	07a697        	bge	a6, a9, 42014911 <_svfiprintf_r+0xf39>
42014909:	b0e5e0        	addx8	a14, a5, a14
4201490c:	0e48      	l32i.n	a4, a14, 0
4201490e:	001986        	j	42014978 <_svfiprintf_r+0xfa0>
42014911:	922e82        	l32i	a8, a14, 0x248
42014914:	fb1c      	movi.n	a11, 31
42014916:	02dee2        	addmi	a14, a14, 0x200
42014919:	a84b      	addi.n	a10, a8, 4
4201491b:	322b97        	blt	a11, a9, 42014951 <_svfiprintf_r+0xf79>
4201491e:	b91b      	addi.n	a11, a9, 1
42014920:	9161b2        	s32i	a11, a1, 0x244
42014923:	126ea2        	s32i	a10, a14, 72
42014926:	8b1c      	movi.n	a11, 24
42014928:	052ba7        	blt	a11, a10, 42014931 <_svfiprintf_r+0xf59>
4201492b:	112e82        	l32i	a8, a14, 68
4201492e:	000406        	j	42014942 <_svfiprintf_r+0xf6a>
42014931:	012b87        	blt	a11, a8, 42014936 <_svfiprintf_r+0xf5e>
42014934:	4a2c      	movi.n	a10, 36
42014936:	10c182        	addi	a8, a1, 16
42014939:	02d882        	addmi	a8, a8, 0x200
4201493c:	102882        	l32i	a8, a8, 64
4201493f:	9661a2        	s32i	a10, a1, 0x258
42014942:	88aa      	add.n	a8, a8, a10
42014944:	fcc882        	addi	a8, a8, -4
42014947:	0848      	l32i.n	a4, a8, 0
42014949:	b09910        	addx8	a9, a9, a1
4201494c:	4949      	s32i.n	a4, a9, 16
4201494e:	000986        	j	42014978 <_svfiprintf_r+0xfa0>
42014951:	126ea2        	s32i	a10, a14, 72
42014954:	891c      	movi.n	a9, 24
42014956:	0629a7        	blt	a9, a10, 42014960 <_svfiprintf_r+0xf88>
42014959:	112e82        	l32i	a8, a14, 68
4201495c:	000446        	j	42014971 <_svfiprintf_r+0xf99>
4201495f:	298700        	lsi	f0, a7, 164
42014962:	4a2c01        	l32r	a0, 41fe7214 <_coredump_iram_end+0x1c65214>
42014965:	10c182        	addi	a8, a1, 16
42014968:	02d882        	addmi	a8, a8, 0x200
4201496b:	102882        	l32i	a8, a8, 64
4201496e:	9661a2        	s32i	a10, a1, 0x258
42014971:	88aa      	add.n	a8, a8, a10
42014973:	fcc882        	addi	a8, a8, -4
42014976:	0848      	l32i.n	a4, a8, 0
42014978:	10c192        	addi	a9, a1, 16
4201497b:	02d992        	addmi	a9, a9, 0x200
4201497e:	0a0c      	movi.n	a10, 0
42014980:	9b2182        	l32i	a8, a1, 0x26c
42014983:	3a49a2        	s8i	a10, a9, 58
42014986:	016896        	bltz	a8, 420149a0 <_svfiprintf_r+0xfc8>
42014989:	08cd      	mov.n	a12, a8
4201498b:	0b0c      	movi.n	a11, 0
4201498d:	04ad      	mov.n	a10, a4
4201498f:	b10681        	l32r	a8, 42000da8 <_stext+0xd88> (40001344 <memchr>)
42014992:	0008e0        	callx8	a8
42014995:	060c      	movi.n	a6, 0
42014997:	c08a40        	sub	a8, a10, a4
4201499a:	7a7a56        	bnez	a10, 42015145 <_svfiprintf_r+0x176d>
4201499d:	01f346        	j	4201516e <_svfiprintf_r+0x1796>
420149a0:	04ad      	mov.n	a10, a4
420149a2:	ae3e81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
420149a5:	0008e0        	callx8	a8
420149a8:	9b61a2        	s32i	a10, a1, 0x26c
420149ab:	060c      	movi.n	a6, 0
420149ad:	01ef46        	j	4201516e <_svfiprintf_r+0x1796>
420149b0:	081c00        	lsx	f1, a12, a0
420149b3:	202280        	or	a2, a2, a8
420149b6:	912182        	l32i	a8, a1, 0x244
420149b9:	10c1e2        	addi	a14, a1, 16
420149bc:	02e257        	bbsi	a2, 5, 420149c2 <_svfiprintf_r+0xfea>
420149bf:	002f86        	j	42014a81 <_svfiprintf_r+0x10a9>
420149c2:	f3ac      	beqz.n	a3, 420149f5 <_svfiprintf_r+0x101d>
420149c4:	09a587        	bge	a5, a8, 420149d1 <_svfiprintf_r+0xff9>
420149c7:	b0e5e0        	addx8	a14, a5, a14
420149ca:	0e58      	l32i.n	a5, a14, 0
420149cc:	1e38      	l32i.n	a3, a14, 4
420149ce:	000786        	j	420149f0 <_svfiprintf_r+0x1018>
420149d1:	30a282        	movi	a8, 0x230
420149d4:	8e8a      	add.n	a8, a14, a8
420149d6:	34a2d2        	movi	a13, 0x234
420149d9:	40a2c2        	movi	a12, 0x240
420149dc:	05ad      	mov.n	a10, a5
420149de:	0189      	s32i.n	a8, a1, 0
420149e0:	01def2        	addmi	a15, a14, 0x100
420149e3:	deda      	add.n	a13, a14, a13
420149e5:	ceca      	add.n	a12, a14, a12
420149e7:	07bd      	mov.n	a11, a7
420149e9:	fea125        	call8	420133fc <get_arg$isra$0>
420149ec:	0a58      	l32i.n	a5, a10, 0
420149ee:	1a38      	l32i.n	a3, a10, 4
420149f0:	067d      	mov.n	a7, a6
420149f2:	007e06        	j	42014bee <_svfiprintf_r+0x1216>
420149f5:	761b      	addi.n	a7, a6, 1
420149f7:	09a687        	bge	a6, a8, 42014a04 <_svfiprintf_r+0x102c>
420149fa:	b0e5e0        	addx8	a14, a5, a14
420149fd:	0e58      	l32i.n	a5, a14, 0
420149ff:	1e38      	l32i.n	a3, a14, 4
42014a01:	007a46        	j	42014bee <_svfiprintf_r+0x1216>
42014a04:	922e92        	l32i	a9, a14, 0x248
42014a07:	8a7c      	movi.n	a10, -8
42014a09:	997b      	addi.n	a9, a9, 7
42014a0b:	1099a0        	and	a9, a9, a10
42014a0e:	fb1c      	movi.n	a11, 31
42014a10:	02dee2        	addmi	a14, a14, 0x200
42014a13:	a98b      	addi.n	a10, a9, 8
42014a15:	3b2b87        	blt	a11, a8, 42014a54 <_svfiprintf_r+0x107c>
42014a18:	b81b      	addi.n	a11, a8, 1
42014a1a:	9161b2        	s32i	a11, a1, 0x244
42014a1d:	126ea2        	s32i	a10, a14, 72
42014a20:	8b1c      	movi.n	a11, 24
42014a22:	062ba7        	blt	a11, a10, 42014a2c <_svfiprintf_r+0x1054>
42014a25:	112e92        	l32i	a9, a14, 68
42014a28:	000446        	j	42014a3d <_svfiprintf_r+0x1065>
42014a2b:	2b9700        	oeq.s	b9, f7, f0
42014a2e:	8a2c01        	l32r	a0, 41ff72e0 <_coredump_iram_end+0x1c752e0>
42014a31:	10c192        	addi	a9, a1, 16
42014a34:	02d992        	addmi	a9, a9, 0x200
42014a37:	102992        	l32i	a9, a9, 64
42014a3a:	9661a2        	s32i	a10, a1, 0x258
42014a3d:	99aa      	add.n	a9, a9, a10
42014a3f:	f8c992        	addi	a9, a9, -8
42014a42:	0958      	l32i.n	a5, a9, 0
42014a44:	1938      	l32i.n	a3, a9, 4
42014a46:	10c192        	addi	a9, a1, 16
42014a49:	b08890        	addx8	a8, a8, a9
42014a4c:	0859      	s32i.n	a5, a8, 0
42014a4e:	1839      	s32i.n	a3, a8, 4
42014a50:	006686        	j	42014bee <_svfiprintf_r+0x1216>
42014a53:	6ea200        	f64rnd	a10, a2, a0, 2
42014a56:	881c12        	l16ui	a1, a12, 0x110
42014a59:	0728a7        	blt	a8, a10, 42014a64 <_svfiprintf_r+0x108c>
42014a5c:	112e82        	l32i	a8, a14, 68
42014a5f:	000486        	j	42014a75 <_svfiprintf_r+0x109d>
42014a62:	970000        	lsi	f0, a0, 0x25c
42014a65:	0128      	l32i.n	a2, a1, 0
42014a67:	8a2c      	movi.n	a10, 40
42014a69:	10c182        	addi	a8, a1, 16
42014a6c:	02d882        	addmi	a8, a8, 0x200
42014a6f:	102882        	l32i	a8, a8, 64
42014a72:	9661a2        	s32i	a10, a1, 0x258
42014a75:	88aa      	add.n	a8, a8, a10
42014a77:	f8c882        	addi	a8, a8, -8
42014a7a:	0858      	l32i.n	a5, a8, 0
42014a7c:	1838      	l32i.n	a3, a8, 4
42014a7e:	005b06        	j	42014bee <_svfiprintf_r+0x1216>
42014a81:	036247        	bbci	a2, 4, 42014a88 <_svfiprintf_r+0x10b0>
42014a84:	005b06        	j	42014bf4 <_svfiprintf_r+0x121c>
42014a87:	e26700        	remu	a6, a7, a0
42014a8a:	2b4602        	s8i	a0, a6, 43
42014a8d:	c3ac00        	movf	a10, a12, b0
42014a90:	09a587        	bge	a5, a8, 42014a9d <_svfiprintf_r+0x10c5>
42014a93:	b0e5e0        	addx8	a14, a5, a14
42014a96:	001e52        	l16ui	a5, a14, 0
42014a99:	006046        	j	42014c1e <_svfiprintf_r+0x1246>
42014a9c:	a28200        	muluh	a8, a2, a0
42014a9f:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42014aa2:	34a2d2        	movi	a13, 0x234
42014aa5:	40a2c2        	movi	a12, 0x240
42014aa8:	05ad      	mov.n	a10, a5
42014aaa:	0189      	s32i.n	a8, a1, 0
42014aac:	01def2        	addmi	a15, a14, 0x100
42014aaf:	deda      	add.n	a13, a14, a13
42014ab1:	ceca      	add.n	a12, a14, a12
42014ab3:	07bd      	mov.n	a11, a7
42014ab5:	fe9465        	call8	420133fc <get_arg$isra$0>
42014ab8:	001a52        	l16ui	a5, a10, 0
42014abb:	0057c6        	j	42014c1e <_svfiprintf_r+0x1246>
42014abe:	761b      	addi.n	a7, a6, 1
42014ac0:	08a687        	bge	a6, a8, 42014acc <_svfiprintf_r+0x10f4>
42014ac3:	b0e5e0        	addx8	a14, a5, a14
42014ac6:	001e52        	l16ui	a5, a14, 0
42014ac9:	0047c6        	j	42014bec <_svfiprintf_r+0x1214>
42014acc:	922e92        	l32i	a9, a14, 0x248
42014acf:	fb1c      	movi.n	a11, 31
42014ad1:	02dee2        	addmi	a14, a14, 0x200
42014ad4:	a94b      	addi.n	a10, a9, 4
42014ad6:	362b87        	blt	a11, a8, 42014b10 <_svfiprintf_r+0x1138>
42014ad9:	b81b      	addi.n	a11, a8, 1
42014adb:	9161b2        	s32i	a11, a1, 0x244
42014ade:	126ea2        	s32i	a10, a14, 72
42014ae1:	8b1c      	movi.n	a11, 24
42014ae3:	052ba7        	blt	a11, a10, 42014aec <_svfiprintf_r+0x1114>
42014ae6:	112e92        	l32i	a9, a14, 68
42014ae9:	000406        	j	42014afd <_svfiprintf_r+0x1125>
42014aec:	012b97        	blt	a11, a9, 42014af1 <_svfiprintf_r+0x1119>
42014aef:	4a2c      	movi.n	a10, 36
42014af1:	10c192        	addi	a9, a1, 16
42014af4:	02d992        	addmi	a9, a9, 0x200
42014af7:	102992        	l32i	a9, a9, 64
42014afa:	9661a2        	s32i	a10, a1, 0x258
42014afd:	99aa      	add.n	a9, a9, a10
42014aff:	fcc992        	addi	a9, a9, -4
42014b02:	0958      	l32i.n	a5, a9, 0
42014b04:	b08810        	addx8	a8, a8, a1
42014b07:	4859      	s32i.n	a5, a8, 16
42014b09:	f45050        	extui	a5, a5, 0, 16
42014b0c:	003706        	j	42014bec <_svfiprintf_r+0x1214>
42014b0f:	6ea200        	f64rnd	a10, a2, a0, 2
42014b12:	881c12        	l16ui	a1, a12, 0x110
42014b15:	0728a7        	blt	a8, a10, 42014b20 <_svfiprintf_r+0x1148>
42014b18:	112e82        	l32i	a8, a14, 68
42014b1b:	000486        	j	42014b31 <_svfiprintf_r+0x1159>
42014b1e:	970000        	lsi	f0, a0, 0x25c
42014b21:	0128      	l32i.n	a2, a1, 0
42014b23:	4a2c      	movi.n	a10, 36
42014b25:	10c182        	addi	a8, a1, 16
42014b28:	02d882        	addmi	a8, a8, 0x200
42014b2b:	102882        	l32i	a8, a8, 64
42014b2e:	9661a2        	s32i	a10, a1, 0x258
42014b31:	88aa      	add.n	a8, a8, a10
42014b33:	fcc882        	addi	a8, a8, -4
42014b36:	001852        	l16ui	a5, a8, 0
42014b39:	002bc6        	j	42014bec <_svfiprintf_r+0x1214>
42014b3c:	02e297        	bbsi	a2, 9, 42014b42 <_svfiprintf_r+0x116a>
42014b3f:	002c46        	j	42014bf4 <_svfiprintf_r+0x121c>
42014b42:	c3ac      	beqz.n	a3, 42014b72 <_svfiprintf_r+0x119a>
42014b44:	09a587        	bge	a5, a8, 42014b51 <_svfiprintf_r+0x1179>
42014b47:	b0e5e0        	addx8	a14, a5, a14
42014b4a:	000e52        	l8ui	a5, a14, 0
42014b4d:	003346        	j	42014c1e <_svfiprintf_r+0x1246>
42014b50:	a28200        	muluh	a8, a2, a0
42014b53:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42014b56:	34a2d2        	movi	a13, 0x234
42014b59:	40a2c2        	movi	a12, 0x240
42014b5c:	05ad      	mov.n	a10, a5
42014b5e:	0189      	s32i.n	a8, a1, 0
42014b60:	01def2        	addmi	a15, a14, 0x100
42014b63:	deda      	add.n	a13, a14, a13
42014b65:	ceca      	add.n	a12, a14, a12
42014b67:	07bd      	mov.n	a11, a7
42014b69:	fe8925        	call8	420133fc <get_arg$isra$0>
42014b6c:	000a52        	l8ui	a5, a10, 0
42014b6f:	002ac6        	j	42014c1e <_svfiprintf_r+0x1246>
42014b72:	761b      	addi.n	a7, a6, 1
42014b74:	08a687        	bge	a6, a8, 42014b80 <_svfiprintf_r+0x11a8>
42014b77:	b0e5e0        	addx8	a14, a5, a14
42014b7a:	000e52        	l8ui	a5, a14, 0
42014b7d:	001ac6        	j	42014bec <_svfiprintf_r+0x1214>
42014b80:	922e92        	l32i	a9, a14, 0x248
42014b83:	fb1c      	movi.n	a11, 31
42014b85:	02dee2        	addmi	a14, a14, 0x200
42014b88:	a94b      	addi.n	a10, a9, 4
42014b8a:	362b87        	blt	a11, a8, 42014bc4 <_svfiprintf_r+0x11ec>
42014b8d:	b81b      	addi.n	a11, a8, 1
42014b8f:	9161b2        	s32i	a11, a1, 0x244
42014b92:	126ea2        	s32i	a10, a14, 72
42014b95:	8b1c      	movi.n	a11, 24
42014b97:	052ba7        	blt	a11, a10, 42014ba0 <_svfiprintf_r+0x11c8>
42014b9a:	112e92        	l32i	a9, a14, 68
42014b9d:	000406        	j	42014bb1 <_svfiprintf_r+0x11d9>
42014ba0:	012b97        	blt	a11, a9, 42014ba5 <_svfiprintf_r+0x11cd>
42014ba3:	4a2c      	movi.n	a10, 36
42014ba5:	10c192        	addi	a9, a1, 16
42014ba8:	02d992        	addmi	a9, a9, 0x200
42014bab:	102992        	l32i	a9, a9, 64
42014bae:	9661a2        	s32i	a10, a1, 0x258
42014bb1:	99aa      	add.n	a9, a9, a10
42014bb3:	fcc992        	addi	a9, a9, -4
42014bb6:	0958      	l32i.n	a5, a9, 0
42014bb8:	b08810        	addx8	a8, a8, a1
42014bbb:	4859      	s32i.n	a5, a8, 16
42014bbd:	745050        	extui	a5, a5, 0, 8
42014bc0:	000a06        	j	42014bec <_svfiprintf_r+0x1214>
42014bc3:	6ea200        	f64rnd	a10, a2, a0, 2
42014bc6:	881c12        	l16ui	a1, a12, 0x110
42014bc9:	0528a7        	blt	a8, a10, 42014bd2 <_svfiprintf_r+0x11fa>
42014bcc:	112e82        	l32i	a8, a14, 68
42014bcf:	000446        	j	42014be4 <_svfiprintf_r+0x120c>
42014bd2:	022897        	blt	a8, a9, 42014bd8 <_svfiprintf_r+0x1200>
42014bd5:	24a0a2        	movi	a10, 36
42014bd8:	10c182        	addi	a8, a1, 16
42014bdb:	02d882        	addmi	a8, a8, 0x200
42014bde:	102882        	l32i	a8, a8, 64
42014be1:	9661a2        	s32i	a10, a1, 0x258
42014be4:	88aa      	add.n	a8, a8, a10
42014be6:	fcc882        	addi	a8, a8, -4
42014be9:	000852        	l8ui	a5, a8, 0
42014bec:	030c      	movi.n	a3, 0
42014bee:	190c      	movi.n	a9, 1
42014bf0:	00ef46        	j	42014fb1 <_svfiprintf_r+0x15d9>
42014bf3:	c3ac00        	movf	a10, a12, b0
42014bf6:	07a587        	bge	a5, a8, 42014c01 <_svfiprintf_r+0x1229>
42014bf9:	b0e5e0        	addx8	a14, a5, a14
42014bfc:	0e58      	l32i.n	a5, a14, 0
42014bfe:	000706        	j	42014c1e <_svfiprintf_r+0x1246>
42014c01:	30a282        	movi	a8, 0x230
42014c04:	8e8a      	add.n	a8, a14, a8
42014c06:	34a2d2        	movi	a13, 0x234
42014c09:	40a2c2        	movi	a12, 0x240
42014c0c:	05ad      	mov.n	a10, a5
42014c0e:	0189      	s32i.n	a8, a1, 0
42014c10:	01def2        	addmi	a15, a14, 0x100
42014c13:	deda      	add.n	a13, a14, a13
42014c15:	ceca      	add.n	a12, a14, a12
42014c17:	07bd      	mov.n	a11, a7
42014c19:	fe7e25        	call8	420133fc <get_arg$isra$0>
42014c1c:	0a58      	l32i.n	a5, a10, 0
42014c1e:	067d      	mov.n	a7, a6
42014c20:	fff206        	j	42014bec <_svfiprintf_r+0x1214>
42014c23:	761b00        	lsi	f0, a11, 0x1d8
42014c26:	07a687        	bge	a6, a8, 42014c31 <_svfiprintf_r+0x1259>
42014c29:	b0e5e0        	addx8	a14, a5, a14
42014c2c:	0e58      	l32i.n	a5, a14, 0
42014c2e:	ffee86        	j	42014bec <_svfiprintf_r+0x1214>
42014c31:	922e92        	l32i	a9, a14, 0x248
42014c34:	fb1c      	movi.n	a11, 31
42014c36:	02dee2        	addmi	a14, a14, 0x200
42014c39:	a94b      	addi.n	a10, a9, 4
42014c3b:	322b87        	blt	a11, a8, 42014c71 <_svfiprintf_r+0x1299>
42014c3e:	b81b      	addi.n	a11, a8, 1
42014c40:	9161b2        	s32i	a11, a1, 0x244
42014c43:	126ea2        	s32i	a10, a14, 72
42014c46:	8b1c      	movi.n	a11, 24
42014c48:	052ba7        	blt	a11, a10, 42014c51 <_svfiprintf_r+0x1279>
42014c4b:	112e92        	l32i	a9, a14, 68
42014c4e:	000406        	j	42014c62 <_svfiprintf_r+0x128a>
42014c51:	012b97        	blt	a11, a9, 42014c56 <_svfiprintf_r+0x127e>
42014c54:	4a2c      	movi.n	a10, 36
42014c56:	10c192        	addi	a9, a1, 16
42014c59:	02d992        	addmi	a9, a9, 0x200
42014c5c:	102992        	l32i	a9, a9, 64
42014c5f:	9661a2        	s32i	a10, a1, 0x258
42014c62:	99aa      	add.n	a9, a9, a10
42014c64:	fcc992        	addi	a9, a9, -4
42014c67:	0958      	l32i.n	a5, a9, 0
42014c69:	b08810        	addx8	a8, a8, a1
42014c6c:	4859      	s32i.n	a5, a8, 16
42014c6e:	ffde86        	j	42014bec <_svfiprintf_r+0x1214>
42014c71:	126ea2        	s32i	a10, a14, 72
42014c74:	881c      	movi.n	a8, 24
42014c76:	0628a7        	blt	a8, a10, 42014c80 <_svfiprintf_r+0x12a8>
42014c79:	112e82        	l32i	a8, a14, 68
42014c7c:	000446        	j	42014c91 <_svfiprintf_r+0x12b9>
42014c7f:	289700        	lsi	f0, a7, 160
42014c82:	4a2c01        	l32r	a0, 41fe7534 <_coredump_iram_end+0x1c65534>
42014c85:	10c182        	addi	a8, a1, 16
42014c88:	02d882        	addmi	a8, a8, 0x200
42014c8b:	102882        	l32i	a8, a8, 64
42014c8e:	9661a2        	s32i	a10, a1, 0x258
42014c91:	88aa      	add.n	a8, a8, a10
42014c93:	fcc882        	addi	a8, a8, -4
42014c96:	0858      	l32i.n	a5, a8, 0
42014c98:	ffd406        	j	42014bec <_svfiprintf_r+0x1214>
42014c9b:	988100        	lsi	f0, a1, 0x260
42014c9e:	6182b0        	lsi	f11, a2, 0x184
42014ca1:	c1e2a2        	s32c1i	a10, a2, 0x304
42014ca4:	218210        	srai	a8, a1, 2
42014ca7:	e25791        	l32r	a9, 4200d604 <_vfprintf_r+0xba4> (97a32192 <_rtc_reserved_end+0x37932192>)
42014caa:	2f8602        	lsi	f0, a6, 188
42014cad:	f3ac00        	lsi	f0, a12, 0x3cc
42014cb0:	09a587        	bge	a5, a8, 42014cbd <_svfiprintf_r+0x12e5>
42014cb3:	b0e5e0        	addx8	a14, a5, a14
42014cb6:	0e58      	l32i.n	a5, a14, 0
42014cb8:	1e38      	l32i.n	a3, a14, 4
42014cba:	000786        	j	42014cdc <_svfiprintf_r+0x1304>
42014cbd:	30a282        	movi	a8, 0x230
42014cc0:	8e8a      	add.n	a8, a14, a8
42014cc2:	34a2d2        	movi	a13, 0x234
42014cc5:	40a2c2        	movi	a12, 0x240
42014cc8:	05ad      	mov.n	a10, a5
42014cca:	0189      	s32i.n	a8, a1, 0
42014ccc:	01def2        	addmi	a15, a14, 0x100
42014ccf:	deda      	add.n	a13, a14, a13
42014cd1:	ceca      	add.n	a12, a14, a12
42014cd3:	07bd      	mov.n	a11, a7
42014cd5:	fe7265        	call8	420133fc <get_arg$isra$0>
42014cd8:	0a58      	l32i.n	a5, a10, 0
42014cda:	1a38      	l32i.n	a3, a10, 4
42014cdc:	067d      	mov.n	a7, a6
42014cde:	00ab06        	j	42014f8e <_svfiprintf_r+0x15b6>
42014ce1:	761b      	addi.n	a7, a6, 1
42014ce3:	09a687        	bge	a6, a8, 42014cf0 <_svfiprintf_r+0x1318>
42014ce6:	b0e5e0        	addx8	a14, a5, a14
42014ce9:	0e58      	l32i.n	a5, a14, 0
42014ceb:	1e38      	l32i.n	a3, a14, 4
42014ced:	00a746        	j	42014f8e <_svfiprintf_r+0x15b6>
42014cf0:	922e92        	l32i	a9, a14, 0x248
42014cf3:	8a7c      	movi.n	a10, -8
42014cf5:	997b      	addi.n	a9, a9, 7
42014cf7:	1099a0        	and	a9, a9, a10
42014cfa:	fb1c      	movi.n	a11, 31
42014cfc:	02dee2        	addmi	a14, a14, 0x200
42014cff:	a98b      	addi.n	a10, a9, 8
42014d01:	3b2b87        	blt	a11, a8, 42014d40 <_svfiprintf_r+0x1368>
42014d04:	b81b      	addi.n	a11, a8, 1
42014d06:	9161b2        	s32i	a11, a1, 0x244
42014d09:	126ea2        	s32i	a10, a14, 72
42014d0c:	8b1c      	movi.n	a11, 24
42014d0e:	062ba7        	blt	a11, a10, 42014d18 <_svfiprintf_r+0x1340>
42014d11:	112e92        	l32i	a9, a14, 68
42014d14:	000446        	j	42014d29 <_svfiprintf_r+0x1351>
42014d17:	2b9700        	oeq.s	b9, f7, f0
42014d1a:	8a2c01        	l32r	a0, 41ff75cc <_coredump_iram_end+0x1c755cc>
42014d1d:	10c192        	addi	a9, a1, 16
42014d20:	02d992        	addmi	a9, a9, 0x200
42014d23:	102992        	l32i	a9, a9, 64
42014d26:	9661a2        	s32i	a10, a1, 0x258
42014d29:	99aa      	add.n	a9, a9, a10
42014d2b:	f8c992        	addi	a9, a9, -8
42014d2e:	0958      	l32i.n	a5, a9, 0
42014d30:	1938      	l32i.n	a3, a9, 4
42014d32:	10c192        	addi	a9, a1, 16
42014d35:	b08890        	addx8	a8, a8, a9
42014d38:	0859      	s32i.n	a5, a8, 0
42014d3a:	1839      	s32i.n	a3, a8, 4
42014d3c:	009386        	j	42014f8e <_svfiprintf_r+0x15b6>
42014d3f:	6ea200        	f64rnd	a10, a2, a0, 2
42014d42:	881c12        	l16ui	a1, a12, 0x110
42014d45:	0728a7        	blt	a8, a10, 42014d50 <_svfiprintf_r+0x1378>
42014d48:	112e82        	l32i	a8, a14, 68
42014d4b:	000486        	j	42014d61 <_svfiprintf_r+0x1389>
42014d4e:	970000        	lsi	f0, a0, 0x25c
42014d51:	0128      	l32i.n	a2, a1, 0
42014d53:	8a2c      	movi.n	a10, 40
42014d55:	10c182        	addi	a8, a1, 16
42014d58:	02d882        	addmi	a8, a8, 0x200
42014d5b:	102882        	l32i	a8, a8, 64
42014d5e:	9661a2        	s32i	a10, a1, 0x258
42014d61:	88aa      	add.n	a8, a8, a10
42014d63:	f8c882        	addi	a8, a8, -8
42014d66:	0858      	l32i.n	a5, a8, 0
42014d68:	1838      	l32i.n	a3, a8, 4
42014d6a:	008806        	j	42014f8e <_svfiprintf_r+0x15b6>
42014d6d:	146247        	bbci	a2, 4, 42014d85 <_svfiprintf_r+0x13ad>
42014d70:	138c      	beqz.n	a3, 42014d75 <_svfiprintf_r+0x139d>
42014d72:	005d06        	j	42014eea <_svfiprintf_r+0x1512>
42014d75:	761b      	addi.n	a7, a6, 1
42014d77:	022687        	blt	a6, a8, 42014d7d <_svfiprintf_r+0x13a5>
42014d7a:	006986        	j	42014f24 <_svfiprintf_r+0x154c>
42014d7d:	b0e5e0        	addx8	a14, a5, a14
42014d80:	0e58      	l32i.n	a5, a14, 0
42014d82:	008186        	j	42014f8c <_svfiprintf_r+0x15b4>
42014d85:	02e267        	bbsi	a2, 6, 42014d8b <_svfiprintf_r+0x13b3>
42014d88:	002a46        	j	42014e35 <_svfiprintf_r+0x145d>
42014d8b:	b3ac      	beqz.n	a3, 42014dba <_svfiprintf_r+0x13e2>
42014d8d:	08a587        	bge	a5, a8, 42014d99 <_svfiprintf_r+0x13c1>
42014d90:	b0e5e0        	addx8	a14, a5, a14
42014d93:	001e52        	l16ui	a5, a14, 0
42014d96:	005e06        	j	42014f12 <_svfiprintf_r+0x153a>
42014d99:	30a282        	movi	a8, 0x230
42014d9c:	8e8a      	add.n	a8, a14, a8
42014d9e:	34a2d2        	movi	a13, 0x234
42014da1:	40a2c2        	movi	a12, 0x240
42014da4:	05ad      	mov.n	a10, a5
42014da6:	0189      	s32i.n	a8, a1, 0
42014da8:	01def2        	addmi	a15, a14, 0x100
42014dab:	deda      	add.n	a13, a14, a13
42014dad:	ceca      	add.n	a12, a14, a12
42014daf:	07bd      	mov.n	a11, a7
42014db1:	fe64a5        	call8	420133fc <get_arg$isra$0>
42014db4:	001a52        	l16ui	a5, a10, 0
42014db7:	0055c6        	j	42014f12 <_svfiprintf_r+0x153a>
42014dba:	761b      	addi.n	a7, a6, 1
42014dbc:	08a687        	bge	a6, a8, 42014dc8 <_svfiprintf_r+0x13f0>
42014dbf:	b0e5e0        	addx8	a14, a5, a14
42014dc2:	001e52        	l16ui	a5, a14, 0
42014dc5:	0070c6        	j	42014f8c <_svfiprintf_r+0x15b4>
42014dc8:	922e92        	l32i	a9, a14, 0x248
42014dcb:	fb1c      	movi.n	a11, 31
42014dcd:	02dee2        	addmi	a14, a14, 0x200
42014dd0:	a94b      	addi.n	a10, a9, 4
42014dd2:	352b87        	blt	a11, a8, 42014e0b <_svfiprintf_r+0x1433>
42014dd5:	b81b      	addi.n	a11, a8, 1
42014dd7:	9161b2        	s32i	a11, a1, 0x244
42014dda:	126ea2        	s32i	a10, a14, 72
42014ddd:	8b1c      	movi.n	a11, 24
42014ddf:	052ba7        	blt	a11, a10, 42014de8 <_svfiprintf_r+0x1410>
42014de2:	112e92        	l32i	a9, a14, 68
42014de5:	000406        	j	42014df9 <_svfiprintf_r+0x1421>
42014de8:	012b97        	blt	a11, a9, 42014ded <_svfiprintf_r+0x1415>
42014deb:	4a2c      	movi.n	a10, 36
42014ded:	10c192        	addi	a9, a1, 16
42014df0:	02d992        	addmi	a9, a9, 0x200
42014df3:	102992        	l32i	a9, a9, 64
42014df6:	9661a2        	s32i	a10, a1, 0x258
42014df9:	99aa      	add.n	a9, a9, a10
42014dfb:	fcc992        	addi	a9, a9, -4
42014dfe:	0958      	l32i.n	a5, a9, 0
42014e00:	b08810        	addx8	a8, a8, a1
42014e03:	4859      	s32i.n	a5, a8, 16
42014e05:	f45050        	extui	a5, a5, 0, 16
42014e08:	006006        	j	42014f8c <_svfiprintf_r+0x15b4>
42014e0b:	126ea2        	s32i	a10, a14, 72
42014e0e:	881c      	movi.n	a8, 24
42014e10:	0528a7        	blt	a8, a10, 42014e19 <_svfiprintf_r+0x1441>
42014e13:	112e82        	l32i	a8, a14, 68
42014e16:	000406        	j	42014e2a <_svfiprintf_r+0x1452>
42014e19:	012897        	blt	a8, a9, 42014e1e <_svfiprintf_r+0x1446>
42014e1c:	4a2c      	movi.n	a10, 36
42014e1e:	10c182        	addi	a8, a1, 16
42014e21:	02d882        	addmi	a8, a8, 0x200
42014e24:	102882        	l32i	a8, a8, 64
42014e27:	9661a2        	s32i	a10, a1, 0x258
42014e2a:	88aa      	add.n	a8, a8, a10
42014e2c:	fcc882        	addi	a8, a8, -4
42014e2f:	001852        	l16ui	a5, a8, 0
42014e32:	005586        	j	42014f8c <_svfiprintf_r+0x15b4>
42014e35:	02e297        	bbsi	a2, 9, 42014e3b <_svfiprintf_r+0x1463>
42014e38:	002b06        	j	42014ee8 <_svfiprintf_r+0x1510>
42014e3b:	b3ac      	beqz.n	a3, 42014e6a <_svfiprintf_r+0x1492>
42014e3d:	08a587        	bge	a5, a8, 42014e49 <_svfiprintf_r+0x1471>
42014e40:	b0e5e0        	addx8	a14, a5, a14
42014e43:	000e52        	l8ui	a5, a14, 0
42014e46:	003206        	j	42014f12 <_svfiprintf_r+0x153a>
42014e49:	30a282        	movi	a8, 0x230
42014e4c:	8e8a      	add.n	a8, a14, a8
42014e4e:	34a2d2        	movi	a13, 0x234
42014e51:	40a2c2        	movi	a12, 0x240
42014e54:	05ad      	mov.n	a10, a5
42014e56:	0189      	s32i.n	a8, a1, 0
42014e58:	01def2        	addmi	a15, a14, 0x100
42014e5b:	deda      	add.n	a13, a14, a13
42014e5d:	ceca      	add.n	a12, a14, a12
42014e5f:	07bd      	mov.n	a11, a7
42014e61:	fe59a5        	call8	420133fc <get_arg$isra$0>
42014e64:	000a52        	l8ui	a5, a10, 0
42014e67:	0029c6        	j	42014f12 <_svfiprintf_r+0x153a>
42014e6a:	761b      	addi.n	a7, a6, 1
42014e6c:	08a687        	bge	a6, a8, 42014e78 <_svfiprintf_r+0x14a0>
42014e6f:	b0e5e0        	addx8	a14, a5, a14
42014e72:	000e52        	l8ui	a5, a14, 0
42014e75:	0044c6        	j	42014f8c <_svfiprintf_r+0x15b4>
42014e78:	922e92        	l32i	a9, a14, 0x248
42014e7b:	fb1c      	movi.n	a11, 31
42014e7d:	02dee2        	addmi	a14, a14, 0x200
42014e80:	a94b      	addi.n	a10, a9, 4
42014e82:	362b87        	blt	a11, a8, 42014ebc <_svfiprintf_r+0x14e4>
42014e85:	b81b      	addi.n	a11, a8, 1
42014e87:	9161b2        	s32i	a11, a1, 0x244
42014e8a:	126ea2        	s32i	a10, a14, 72
42014e8d:	8b1c      	movi.n	a11, 24
42014e8f:	052ba7        	blt	a11, a10, 42014e98 <_svfiprintf_r+0x14c0>
42014e92:	112e92        	l32i	a9, a14, 68
42014e95:	000406        	j	42014ea9 <_svfiprintf_r+0x14d1>
42014e98:	012b97        	blt	a11, a9, 42014e9d <_svfiprintf_r+0x14c5>
42014e9b:	4a2c      	movi.n	a10, 36
42014e9d:	10c192        	addi	a9, a1, 16
42014ea0:	02d992        	addmi	a9, a9, 0x200
42014ea3:	102992        	l32i	a9, a9, 64
42014ea6:	9661a2        	s32i	a10, a1, 0x258
42014ea9:	99aa      	add.n	a9, a9, a10
42014eab:	fcc992        	addi	a9, a9, -4
42014eae:	0958      	l32i.n	a5, a9, 0
42014eb0:	b08810        	addx8	a8, a8, a1
42014eb3:	4859      	s32i.n	a5, a8, 16
42014eb5:	745050        	extui	a5, a5, 0, 8
42014eb8:	003406        	j	42014f8c <_svfiprintf_r+0x15b4>
42014ebb:	6ea200        	f64rnd	a10, a2, a0, 2
42014ebe:	881c12        	l16ui	a1, a12, 0x110
42014ec1:	0728a7        	blt	a8, a10, 42014ecc <_svfiprintf_r+0x14f4>
42014ec4:	112e82        	l32i	a8, a14, 68
42014ec7:	000486        	j	42014edd <_svfiprintf_r+0x1505>
42014eca:	970000        	lsi	f0, a0, 0x25c
42014ecd:	0128      	l32i.n	a2, a1, 0
42014ecf:	4a2c      	movi.n	a10, 36
42014ed1:	10c182        	addi	a8, a1, 16
42014ed4:	02d882        	addmi	a8, a8, 0x200
42014ed7:	102882        	l32i	a8, a8, 64
42014eda:	9661a2        	s32i	a10, a1, 0x258
42014edd:	88aa      	add.n	a8, a8, a10
42014edf:	fcc882        	addi	a8, a8, -4
42014ee2:	000852        	l8ui	a5, a8, 0
42014ee5:	0028c6        	j	42014f8c <_svfiprintf_r+0x15b4>
42014ee8:	b3ac      	beqz.n	a3, 42014f17 <_svfiprintf_r+0x153f>
42014eea:	07a587        	bge	a5, a8, 42014ef5 <_svfiprintf_r+0x151d>
42014eed:	b0e5e0        	addx8	a14, a5, a14
42014ef0:	0e58      	l32i.n	a5, a14, 0
42014ef2:	000706        	j	42014f12 <_svfiprintf_r+0x153a>
42014ef5:	30a282        	movi	a8, 0x230
42014ef8:	8e8a      	add.n	a8, a14, a8
42014efa:	34a2d2        	movi	a13, 0x234
42014efd:	40a2c2        	movi	a12, 0x240
42014f00:	05ad      	mov.n	a10, a5
42014f02:	0189      	s32i.n	a8, a1, 0
42014f04:	01def2        	addmi	a15, a14, 0x100
42014f07:	deda      	add.n	a13, a14, a13
42014f09:	ceca      	add.n	a12, a14, a12
42014f0b:	07bd      	mov.n	a11, a7
42014f0d:	fe4ee5        	call8	420133fc <get_arg$isra$0>
42014f10:	0a58      	l32i.n	a5, a10, 0
42014f12:	067d      	mov.n	a7, a6
42014f14:	001d06        	j	42014f8c <_svfiprintf_r+0x15b4>
42014f17:	761b      	addi.n	a7, a6, 1
42014f19:	07a687        	bge	a6, a8, 42014f24 <_svfiprintf_r+0x154c>
42014f1c:	b055e0        	addx8	a5, a5, a14
42014f1f:	0558      	l32i.n	a5, a5, 0
42014f21:	0019c6        	j	42014f8c <_svfiprintf_r+0x15b4>
42014f24:	922e92        	l32i	a9, a14, 0x248
42014f27:	fb1c      	movi.n	a11, 31
42014f29:	02dee2        	addmi	a14, a14, 0x200
42014f2c:	a94b      	addi.n	a10, a9, 4
42014f2e:	322b87        	blt	a11, a8, 42014f64 <_svfiprintf_r+0x158c>
42014f31:	b81b      	addi.n	a11, a8, 1
42014f33:	9161b2        	s32i	a11, a1, 0x244
42014f36:	126ea2        	s32i	a10, a14, 72
42014f39:	8b1c      	movi.n	a11, 24
42014f3b:	052ba7        	blt	a11, a10, 42014f44 <_svfiprintf_r+0x156c>
42014f3e:	112e92        	l32i	a9, a14, 68
42014f41:	000406        	j	42014f55 <_svfiprintf_r+0x157d>
42014f44:	012b97        	blt	a11, a9, 42014f49 <_svfiprintf_r+0x1571>
42014f47:	4a2c      	movi.n	a10, 36
42014f49:	10c192        	addi	a9, a1, 16
42014f4c:	02d992        	addmi	a9, a9, 0x200
42014f4f:	102992        	l32i	a9, a9, 64
42014f52:	9661a2        	s32i	a10, a1, 0x258
42014f55:	99aa      	add.n	a9, a9, a10
42014f57:	fcc992        	addi	a9, a9, -4
42014f5a:	0958      	l32i.n	a5, a9, 0
42014f5c:	b08810        	addx8	a8, a8, a1
42014f5f:	4859      	s32i.n	a5, a8, 16
42014f61:	0009c6        	j	42014f8c <_svfiprintf_r+0x15b4>
42014f64:	126ea2        	s32i	a10, a14, 72
42014f67:	881c      	movi.n	a8, 24
42014f69:	0728a7        	blt	a8, a10, 42014f74 <_svfiprintf_r+0x159c>
42014f6c:	112e82        	l32i	a8, a14, 68
42014f6f:	000486        	j	42014f85 <_svfiprintf_r+0x15ad>
42014f72:	970000        	lsi	f0, a0, 0x25c
42014f75:	0128      	l32i.n	a2, a1, 0
42014f77:	4a2c      	movi.n	a10, 36
42014f79:	10c182        	addi	a8, a1, 16
42014f7c:	02d882        	addmi	a8, a8, 0x200
42014f7f:	102882        	l32i	a8, a8, 64
42014f82:	9661a2        	s32i	a10, a1, 0x258
42014f85:	88aa      	add.n	a8, a8, a10
42014f87:	fcc882        	addi	a8, a8, -4
42014f8a:	0858      	l32i.n	a5, a8, 0
42014f8c:	030c      	movi.n	a3, 0
42014f8e:	208530        	or	a8, a5, a3
42014f91:	489c      	beqz.n	a8, 42014fa9 <_svfiprintf_r+0x15d1>
42014f93:	126207        	bbci	a2, 0, 42014fa9 <_svfiprintf_r+0x15d1>
42014f96:	10c182        	addi	a8, a1, 16
42014f99:	02d882        	addmi	a8, a8, 0x200
42014f9c:	093c      	movi.n	a9, 48
42014f9e:	384892        	s8i	a9, a8, 56
42014fa1:	394842        	s8i	a4, a8, 57
42014fa4:	280c      	movi.n	a8, 2
42014fa6:	202280        	or	a2, a2, a8
42014fa9:	ffab82        	movi	a8, 0xfffffbff
42014fac:	102280        	and	a2, a2, a8
42014faf:	290c      	movi.n	a9, 2
42014fb1:	080c      	movi.n	a8, 0
42014fb3:	10c1a2        	addi	a10, a1, 16
42014fb6:	02daa2        	addmi	a10, a10, 0x200
42014fb9:	3a4a82        	s8i	a8, a10, 58
42014fbc:	9b2182        	l32i	a8, a1, 0x26c
42014fbf:	01d896        	bltz	a8, 42014fe0 <_svfiprintf_r+0x1608>
42014fc2:	20a220        	or	a10, a2, a2
42014fc5:	7faf82        	movi	a8, -129
42014fc8:	102280        	and	a2, a2, a8
42014fcb:	1b0c      	movi.n	a11, 1
42014fcd:	208530        	or	a8, a5, a3
42014fd0:	83b880        	moveqz	a11, a8, a8
42014fd3:	98cc      	bnez.n	a8, 42014fe0 <_svfiprintf_r+0x1608>
42014fd5:	9b21c2        	l32i	a12, a1, 0x26c
42014fd8:	180c      	movi.n	a8, 1
42014fda:	838bc0        	moveqz	a8, a11, a12
42014fdd:	12d816        	beqz	a8, 4201510e <_svfiprintf_r+0x1736>
42014fe0:	421926        	beqi	a9, 1, 42015026 <_svfiprintf_r+0x164e>
42014fe3:	e4a182        	movi	a8, 0x1e4
42014fe6:	022966        	bnei	a9, 2, 42014fec <_svfiprintf_r+0x1614>
42014fe9:	003dc6        	j	420150e4 <_svfiprintf_r+0x170c>
42014fec:	10c192        	addi	a9, a1, 16
42014fef:	498a      	add.n	a4, a9, a8
42014ff1:	249050        	extui	a9, a5, 0, 3
42014ff4:	04ad      	mov.n	a10, a4
42014ff6:	404300        	ssai	3
42014ff9:	815350        	src	a5, a3, a5
42014ffc:	440b      	addi.n	a4, a4, -1
42014ffe:	30c992        	addi	a9, a9, 48
42015001:	413330        	srli	a3, a3, 3
42015004:	004492        	s8i	a9, a4, 0
42015007:	20b530        	or	a11, a5, a3
4201500a:	fe3b56        	bnez	a11, 42014ff1 <_svfiprintf_r+0x1619>
4201500d:	d0c992        	addi	a9, a9, -48
42015010:	128916        	beqz	a9, 4201513c <_svfiprintf_r+0x1764>
42015013:	02e207        	bbsi	a2, 0, 42015019 <_svfiprintf_r+0x1641>
42015016:	004886        	j	4201513c <_svfiprintf_r+0x1764>
42015019:	840b      	addi.n	a8, a4, -1
4201501b:	093c      	movi.n	a9, 48
4201501d:	004892        	s8i	a9, a8, 0
42015020:	feca42        	addi	a4, a10, -2
42015023:	004546        	j	4201513c <_svfiprintf_r+0x1764>
42015026:	63dc      	bnez.n	a3, 42015040 <_svfiprintf_r+0x1668>
42015028:	980c      	movi.n	a8, 9
4201502a:	123857        	bltu	a8, a5, 42015040 <_svfiprintf_r+0x1668>
4201502d:	10c182        	addi	a8, a1, 16
42015030:	01d892        	addmi	a9, a8, 0x100
42015033:	30c552        	addi	a5, a5, 48
42015036:	e34952        	s8i	a5, a9, 227
42015039:	e3a192        	movi	a9, 0x1e3
4201503c:	003e86        	j	4201513a <_svfiprintf_r+0x1762>
4201503f:	a18200        	sll	a8, a2
42015042:	a462f4        	lsi	f15, a2, 0x290
42015045:	0e0c00        	lsi	f0, a12, 56
42015048:	818a      	add.n	a8, a1, a8
4201504a:	106260        	and	a6, a2, a6
4201504d:	a461e2        	s32i	a14, a1, 0x290
42015050:	ac0c      	movi.n	a12, 10
42015052:	0d0c      	movi.n	a13, 0
42015054:	05ad      	mov.n	a10, a5
42015056:	03bd      	mov.n	a11, a3
42015058:	480b      	addi.n	a4, a8, -1
4201505a:	af7981        	l32r	a8, 42000e40 <_stext+0xe20> (40002574 <__umoddi3>)
4201505d:	0008e0        	callx8	a8
42015060:	a421e2        	l32i	a14, a1, 0x290
42015063:	30caa2        	addi	a10, a10, 48
42015066:	0044a2        	s8i	a10, a4, 0
42015069:	ee1b      	addi.n	a14, a14, 1
4201506b:	04e616        	beqz	a6, 420150bd <_svfiprintf_r+0x16e5>
4201506e:	a02182        	l32i	a8, a1, 0x280
42015071:	01af92        	movi	a9, -255
42015074:	0008a2        	l8ui	a10, a8, 0
42015077:	9a9a      	add.n	a9, a10, a9
42015079:	040916        	beqz	a9, 420150bd <_svfiprintf_r+0x16e5>
4201507c:	3d9ae7        	bne	a10, a14, 420150bd <_svfiprintf_r+0x16e5>
4201507f:	63cc      	bnez.n	a3, 42015089 <_svfiprintf_r+0x16b1>
42015081:	990c      	movi.n	a9, 9
42015083:	023957        	bltu	a9, a5, 42015089 <_svfiprintf_r+0x16b1>
42015086:	002c86        	j	4201513c <_svfiprintf_r+0x1764>
42015089:	a12182        	l32i	a8, a1, 0x284
4201508c:	a321b2        	l32i	a11, a1, 0x28c
4201508f:	c04480        	sub	a4, a4, a8
42015092:	08cd      	mov.n	a12, a8
42015094:	20a440        	or	a10, a4, a4
42015097:	aeee81        	l32r	a8, 42000c50 <_stext+0xc30> (40001224 <strncpy>)
4201509a:	0008e0        	callx8	a8
4201509d:	a02182        	l32i	a8, a1, 0x280
420150a0:	010892        	l8ui	a9, a8, 1
420150a3:	398c      	beqz.n	a9, 420150aa <_svfiprintf_r+0x16d2>
420150a5:	881b      	addi.n	a8, a8, 1
420150a7:	a06182        	s32i	a8, a1, 0x280
420150aa:	ac0c      	movi.n	a12, 10
420150ac:	0d0c      	movi.n	a13, 0
420150ae:	05ad      	mov.n	a10, a5
420150b0:	03bd      	mov.n	a11, a3
420150b2:	ac2b81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
420150b5:	0008e0        	callx8	a8
420150b8:	0e0c      	movi.n	a14, 0
420150ba:	000706        	j	420150da <_svfiprintf_r+0x1702>
420150bd:	a461e2        	s32i	a14, a1, 0x290
420150c0:	ac0c      	movi.n	a12, 10
420150c2:	0d0c      	movi.n	a13, 0
420150c4:	20a550        	or	a10, a5, a5
420150c7:	20b330        	or	a11, a3, a3
420150ca:	ac2581        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
420150cd:	0008e0        	callx8	a8
420150d0:	a421e2        	l32i	a14, a1, 0x290
420150d3:	33cc      	bnez.n	a3, 420150da <_svfiprintf_r+0x1702>
420150d5:	990c      	movi.n	a9, 9
420150d7:	61b957        	bgeu	a9, a5, 4201513c <_svfiprintf_r+0x1764>
420150da:	0a5d      	mov.n	a5, a10
420150dc:	0b3d      	mov.n	a3, a11
420150de:	048d      	mov.n	a8, a4
420150e0:	ffda46        	j	4201504d <_svfiprintf_r+0x1675>
420150e3:	c19200        	mul16u	a9, a2, a0
420150e6:	498a10        	s32e	a1, a10, -32
420150e9:	a22182        	l32i	a8, a1, 0x288
420150ec:	349050        	extui	a9, a5, 0, 4
420150ef:	989a      	add.n	a9, a8, a9
420150f1:	000992        	l8ui	a9, a9, 0
420150f4:	404400        	ssai	4
420150f7:	815350        	src	a5, a3, a5
420150fa:	440b      	addi.n	a4, a4, -1
420150fc:	413430        	srli	a3, a3, 4
420150ff:	004492        	s8i	a9, a4, 0
42015102:	209530        	or	a9, a5, a3
42015105:	fe0956        	bnez	a9, 420150e9 <_svfiprintf_r+0x1711>
42015108:	000c06        	j	4201513c <_svfiprintf_r+0x1764>
4201510b:	000000        	ill
4201510e:	080c      	movi.n	a8, 0
42015110:	9b6182        	s32i	a8, a1, 0x26c
42015113:	10c1b2        	addi	a11, a1, 16
42015116:	e4a182        	movi	a8, 0x1e4
42015119:	4b8a      	add.n	a4, a11, a8
4201511b:	d9dc      	bnez.n	a9, 4201513c <_svfiprintf_r+0x1764>
4201511d:	0480a0        	extui	a8, a10, 0, 1
42015120:	9b6182        	s32i	a8, a1, 0x26c
42015123:	9b2182        	l32i	a8, a1, 0x26c
42015126:	289c      	beqz.n	a8, 4201513c <_svfiprintf_r+0x1764>
42015128:	01db82        	addmi	a8, a11, 0x100
4201512b:	093c      	movi.n	a9, 48
4201512d:	e34892        	s8i	a9, a8, 227
42015130:	080c      	movi.n	a8, 0
42015132:	9b6182        	s32i	a8, a1, 0x26c
42015135:	0b9d      	mov.n	a9, a11
42015137:	e3a182        	movi	a8, 0x1e3
4201513a:	498a      	add.n	a4, a9, a8
4201513c:	a52182        	l32i	a8, a1, 0x294
4201513f:	9b2162        	l32i	a6, a1, 0x26c
42015142:	c08840        	sub	a8, a8, a4
42015145:	9b6182        	s32i	a8, a1, 0x26c
42015148:	000886        	j	4201516e <_svfiprintf_r+0x1796>
4201514b:	841600        	extui	a1, a0, 6, 9
4201514e:	4e          	.byte	0x4e
4201514f:	10c182        	addi	a8, a1, 16
42015152:	01d892        	addmi	a9, a8, 0x100
42015155:	804942        	s8i	a4, a9, 128
42015158:	0a0c      	movi.n	a10, 0
4201515a:	02d892        	addmi	a9, a8, 0x200
4201515d:	3a49a2        	s8i	a10, a9, 58
42015160:	067d      	mov.n	a7, a6
42015162:	190c      	movi.n	a9, 1
42015164:	9b6192        	s32i	a9, a1, 0x26c
42015167:	80a192        	movi	a9, 0x180
4201516a:	060c      	movi.n	a6, 0
4201516c:	489a      	add.n	a4, a8, a9
4201516e:	9b2182        	l32i	a8, a1, 0x26c
42015171:	535680        	max	a5, a6, a8
42015174:	10c182        	addi	a8, a1, 16
42015177:	02d892        	addmi	a9, a8, 0x200
4201517a:	3a0992        	l8ui	a9, a9, 58
4201517d:	098c      	beqz.n	a9, 42015181 <_svfiprintf_r+0x17a9>
4201517f:	551b      	addi.n	a5, a5, 1
42015181:	230c      	movi.n	a3, 2
42015183:	103230        	and	a3, a2, a3
42015186:	002316        	beqz	a3, 4201518c <_svfiprintf_r+0x17b4>
42015189:	02c552        	addi	a5, a5, 2
4201518c:	84a082        	movi	a8, 132
4201518f:	108280        	and	a8, a2, a8
42015192:	a46182        	s32i	a8, a1, 0x290
42015195:	0d5856        	bnez	a8, 4201526e <_svfiprintf_r+0x1896>
42015198:	9e2182        	l32i	a8, a1, 0x278
4201519b:	10c1e2        	addi	a14, a1, 16
4201519e:	24a2c2        	movi	a12, 0x224
420151a1:	c09850        	sub	a9, a8, a5
420151a4:	ceca      	add.n	a12, a14, a12
420151a6:	5819e6        	bgei	a9, 1, 42015202 <_svfiprintf_r+0x182a>
420151a9:	003046        	j	4201526e <_svfiprintf_r+0x1896>
420151ac:	982182        	l32i	a8, a1, 0x260
420151af:	af56f1        	l32r	a15, 42000f08 <_stext+0xee8> (3c02a0b4 <blanks$1>)
420151b2:	0168d2        	s32i	a13, a8, 4
420151b5:	0068f2        	s32i	a15, a8, 0
420151b8:	972182        	l32i	a8, a1, 0x25c
420151bb:	10c882        	addi	a8, a8, 16
420151be:	976182        	s32i	a8, a1, 0x25c
420151c1:	348ba6        	blti	a11, 8, 420151f9 <_svfiprintf_r+0x1821>
420151c4:	8a6eb2        	s32i	a11, a14, 0x228
420151c7:	9d21a2        	l32i	a10, a1, 0x274
420151ca:	9c21b2        	l32i	a11, a1, 0x270
420151cd:	02ded2        	addmi	a13, a14, 0x200
420151d0:	8b6e82        	s32i	a8, a14, 0x22c
420151d3:	9761d2        	s32i	a13, a1, 0x25c
420151d6:	986192        	s32i	a9, a1, 0x260
420151d9:	fe6f25        	call8	420138cc <__ssprint_r>
420151dc:	9721d2        	l32i	a13, a1, 0x25c
420151df:	bd88      	l32i.n	a8, a13, 44
420151e1:	adb8      	l32i.n	a11, a13, 40
420151e3:	976182        	s32i	a8, a1, 0x25c
420151e6:	472a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
420151e9:	e4a1a2        	movi	a10, 0x1e4
420151ec:	10c1e2        	addi	a14, a1, 16
420151ef:	34a2c2        	movi	a12, 0x234
420151f2:	982192        	l32i	a9, a1, 0x260
420151f5:	aeaa      	add.n	a10, a14, a10
420151f7:	cc1a      	add.n	a12, a12, a1
420151f9:	f0c992        	addi	a9, a9, -16
420151fc:	9961b2        	s32i	a11, a1, 0x264
420151ff:	9861a2        	s32i	a10, a1, 0x260
42015202:	992182        	l32i	a8, a1, 0x264
42015205:	0d1c      	movi.n	a13, 16
42015207:	b81b      	addi.n	a11, a8, 1
42015209:	982182        	l32i	a8, a1, 0x260
4201520c:	a88b      	addi.n	a10, a8, 8
4201520e:	9a2d97        	blt	a13, a9, 420151ac <_svfiprintf_r+0x17d4>
42015211:	af3dc1        	l32r	a12, 42000f08 <_stext+0xee8> (3c02a0b4 <blanks$1>)
42015214:	1899      	s32i.n	a9, a8, 4
42015216:	08c9      	s32i.n	a12, a8, 0
42015218:	972182        	l32i	a8, a1, 0x25c
4201521b:	808890        	add	a8, a8, a9
4201521e:	976182        	s32i	a8, a1, 0x25c
42015221:	992182        	l32i	a8, a1, 0x264
42015224:	4078a6        	blti	a8, 7, 42015268 <_svfiprintf_r+0x1890>
42015227:	9721a2        	l32i	a10, a1, 0x25c
4201522a:	10c192        	addi	a9, a1, 16
4201522d:	8e61b2        	s32i	a11, a1, 0x238
42015230:	8f61a2        	s32i	a10, a1, 0x23c
42015233:	9c21b2        	l32i	a11, a1, 0x270
42015236:	9d21a2        	l32i	a10, a1, 0x274
42015239:	24a2c2        	movi	a12, 0x224
4201523c:	02d982        	addmi	a8, a9, 0x200
4201523f:	80c9c0        	add	a12, a9, a12
42015242:	976182        	s32i	a8, a1, 0x25c
42015245:	fe6865        	call8	420138cc <__ssprint_r>
42015248:	972182        	l32i	a8, a1, 0x25c
4201524b:	a898      	l32i.n	a9, a8, 40
4201524d:	b888      	l32i.n	a8, a8, 44
4201524f:	996192        	s32i	a9, a1, 0x264
42015252:	976182        	s32i	a8, a1, 0x25c
42015255:	403a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
42015258:	e4a1a2        	movi	a10, 0x1e4
4201525b:	10c192        	addi	a9, a1, 16
4201525e:	89aa      	add.n	a8, a9, a10
42015260:	986182        	s32i	a8, a1, 0x260
42015263:	0001c6        	j	4201526e <_svfiprintf_r+0x1896>
42015266:	b20000        	mulsh	a0, a0, a0
42015269:	a29961        	l32r	a6, 41ffdcd0 <_coredump_iram_end+0x1c7bcd0>
4201526c:	829861        	l32r	a6, 41ff5ccc <_coredump_iram_end+0x1c73ccc>
4201526f:	8210c1        	l32r	a12, 41ff5ab0 <_coredump_iram_end+0x1c73ab0>
42015272:	02d8      	l32i.n	a13, a2, 0
42015274:	3a0892        	l8ui	a9, a8, 58
42015277:	065916        	beqz	a9, 420152e0 <_svfiprintf_r+0x1908>
4201527a:	992192        	l32i	a9, a1, 0x264
4201527d:	10c1b2        	addi	a11, a1, 16
42015280:	a91b      	addi.n	a10, a9, 1
42015282:	3aa292        	movi	a9, 0x23a
42015285:	9b9a      	add.n	a9, a11, a9
42015287:	9821b2        	l32i	a11, a1, 0x260
4201528a:	0b99      	s32i.n	a9, a11, 0
4201528c:	190c      	movi.n	a9, 1
4201528e:	1b99      	s32i.n	a9, a11, 4
42015290:	972192        	l32i	a9, a1, 0x25c
42015293:	991b      	addi.n	a9, a9, 1
42015295:	976192        	s32i	a9, a1, 0x25c
42015298:	992192        	l32i	a9, a1, 0x264
4201529b:	0a79e6        	bgei	a9, 7, 420152a9 <_svfiprintf_r+0x18d1>
4201529e:	8b8b      	addi.n	a8, a11, 8
420152a0:	986182        	s32i	a8, a1, 0x260
420152a3:	9961a2        	s32i	a10, a1, 0x264
420152a6:	000d86        	j	420152e0 <_svfiprintf_r+0x1908>
420152a9:	972192        	l32i	a9, a1, 0x25c
420152ac:	a8a9      	s32i.n	a10, a8, 40
420152ae:	b899      	s32i.n	a9, a8, 44
420152b0:	976182        	s32i	a8, a1, 0x25c
420152b3:	9c21b2        	l32i	a11, a1, 0x270
420152b6:	10c182        	addi	a8, a1, 16
420152b9:	9d21a2        	l32i	a10, a1, 0x274
420152bc:	24a2c2        	movi	a12, 0x224
420152bf:	80c8c0        	add	a12, a8, a12
420152c2:	fe60a5        	call8	420138cc <__ssprint_r>
420152c5:	972182        	l32i	a8, a1, 0x25c
420152c8:	a898      	l32i.n	a9, a8, 40
420152ca:	b888      	l32i.n	a8, a8, 44
420152cc:	996192        	s32i	a9, a1, 0x264
420152cf:	976182        	s32i	a8, a1, 0x25c
420152d2:	386a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
420152d5:	e4a192        	movi	a9, 0x1e4
420152d8:	10c182        	addi	a8, a1, 16
420152db:	889a      	add.n	a8, a8, a9
420152dd:	986182        	s32i	a8, a1, 0x260
420152e0:	068316        	beqz	a3, 4201534c <_svfiprintf_r+0x1974>
420152e3:	992182        	l32i	a8, a1, 0x264
420152e6:	38a292        	movi	a9, 0x238
420152e9:	a81b      	addi.n	a10, a8, 1
420152eb:	10c182        	addi	a8, a1, 16
420152ee:	989a      	add.n	a9, a8, a9
420152f0:	982182        	l32i	a8, a1, 0x260
420152f3:	0899      	s32i.n	a9, a8, 0
420152f5:	290c      	movi.n	a9, 2
420152f7:	1899      	s32i.n	a9, a8, 4
420152f9:	972182        	l32i	a8, a1, 0x25c
420152fc:	882b      	addi.n	a8, a8, 2
420152fe:	976182        	s32i	a8, a1, 0x25c
42015301:	992182        	l32i	a8, a1, 0x264
42015304:	0d78e6        	bgei	a8, 7, 42015315 <_svfiprintf_r+0x193d>
42015307:	982182        	l32i	a8, a1, 0x260
4201530a:	9961a2        	s32i	a10, a1, 0x264
4201530d:	888b      	addi.n	a8, a8, 8
4201530f:	986182        	s32i	a8, a1, 0x260
42015312:	000d86        	j	4201534c <_svfiprintf_r+0x1974>
42015315:	10c182        	addi	a8, a1, 16
42015318:	02d832        	addmi	a3, a8, 0x200
4201531b:	972182        	l32i	a8, a1, 0x25c
4201531e:	8e61a2        	s32i	a10, a1, 0x238
42015321:	b389      	s32i.n	a8, a3, 44
42015323:	9c21b2        	l32i	a11, a1, 0x270
42015326:	10c182        	addi	a8, a1, 16
42015329:	9d21a2        	l32i	a10, a1, 0x274
4201532c:	24a2c2        	movi	a12, 0x224
4201532f:	c8ca      	add.n	a12, a8, a12
42015331:	fe59a5        	call8	420138cc <__ssprint_r>
42015334:	a388      	l32i.n	a8, a3, 40
42015336:	996182        	s32i	a8, a1, 0x264
42015339:	b388      	l32i.n	a8, a3, 44
4201533b:	976182        	s32i	a8, a1, 0x25c
4201533e:	31aa56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
42015341:	e4a192        	movi	a9, 0x1e4
42015344:	10c182        	addi	a8, a1, 16
42015347:	889a      	add.n	a8, a8, a9
42015349:	986182        	s32i	a8, a1, 0x260
4201534c:	a42182        	l32i	a8, a1, 0x290
4201534f:	02e826        	beqi	a8, 128, 42015355 <_svfiprintf_r+0x197d>
42015352:	003406        	j	42015426 <_svfiprintf_r+0x1a4e>
42015355:	9e2182        	l32i	a8, a1, 0x278
42015358:	c08850        	sub	a8, a8, a5
4201535b:	0218e6        	bgei	a8, 1, 42015361 <_svfiprintf_r+0x1989>
4201535e:	003106        	j	42015426 <_svfiprintf_r+0x1a4e>
42015361:	10c192        	addi	a9, a1, 16
42015364:	24a232        	movi	a3, 0x224
42015367:	a93a      	add.n	a10, a9, a3
42015369:	a461a2        	s32i	a10, a1, 0x290
4201536c:	001346        	j	420153bd <_svfiprintf_r+0x19e5>
4201536f:	21d200        	srai	a13, a0, 2
42015372:	e198      	l32i.n	a9, a1, 56
42015374:	c9aee6        	bgei	a14, 12, 42015341 <_svfiprintf_r+0x1969>
42015377:	c21d      	lsi	f1, a2, 8
42015379:	e99721        	l32r	a2, 4200f9d8 <get_arg$isra$0+0x290> (1488052c <UserFrameTotalSize+0x1488042c>)
4201537c:	c20d      	lsi	f0, a2, 8
4201537e:	10cc      	bnez.n	a0, 42015383 <_svfiprintf_r+0x19ab>
42015380:	9761c2        	s32i	a12, a1, 0x25c
42015383:	2d8ba6        	blti	a11, 8, 420153b4 <_svfiprintf_r+0x19dc>
42015386:	8a69b2        	s32i	a11, a9, 0x228
42015389:	8b69c2        	s32i	a12, a9, 0x22c
4201538c:	9c21b2        	l32i	a11, a1, 0x270
4201538f:	a421c2        	l32i	a12, a1, 0x290
42015392:	9d21a2        	l32i	a10, a1, 0x274
42015395:	02d932        	addmi	a3, a9, 0x200
42015398:	986182        	s32i	a8, a1, 0x260
4201539b:	fe5325        	call8	420138cc <__ssprint_r>
4201539e:	b388      	l32i.n	a8, a3, 44
420153a0:	a3b8      	l32i.n	a11, a3, 40
420153a2:	976182        	s32i	a8, a1, 0x25c
420153a5:	2b3a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
420153a8:	e4a1a2        	movi	a10, 0x1e4
420153ab:	10c192        	addi	a9, a1, 16
420153ae:	982182        	l32i	a8, a1, 0x260
420153b1:	80a9a0        	add	a10, a9, a10
420153b4:	f0c882        	addi	a8, a8, -16
420153b7:	9961b2        	s32i	a11, a1, 0x264
420153ba:	9861a2        	s32i	a10, a1, 0x260
420153bd:	9921a2        	l32i	a10, a1, 0x264
420153c0:	0c1c      	movi.n	a12, 16
420153c2:	ba1b      	addi.n	a11, a10, 1
420153c4:	9821a2        	l32i	a10, a1, 0x260
420153c7:	aa8b      	addi.n	a10, a10, 8
420153c9:	a32c87        	blt	a12, a8, 42015370 <_svfiprintf_r+0x1998>
420153cc:	982192        	l32i	a9, a1, 0x260
420153cf:	aecfc1        	l32r	a12, 42000f0c <_stext+0xeec> (3c02a0a4 <zeroes$0>)
420153d2:	1989      	s32i.n	a8, a9, 4
420153d4:	09c9      	s32i.n	a12, a9, 0
420153d6:	972192        	l32i	a9, a1, 0x25c
420153d9:	898a      	add.n	a8, a9, a8
420153db:	976182        	s32i	a8, a1, 0x25c
420153de:	992182        	l32i	a8, a1, 0x264
420153e1:	3b78a6        	blti	a8, 7, 42015420 <_svfiprintf_r+0x1a48>
420153e4:	972192        	l32i	a9, a1, 0x25c
420153e7:	10c132        	addi	a3, a1, 16
420153ea:	8e61b2        	s32i	a11, a1, 0x238
420153ed:	9d21a2        	l32i	a10, a1, 0x274
420153f0:	9c21b2        	l32i	a11, a1, 0x270
420153f3:	24a2c2        	movi	a12, 0x224
420153f6:	02d382        	addmi	a8, a3, 0x200
420153f9:	c3ca      	add.n	a12, a3, a12
420153fb:	8f6192        	s32i	a9, a1, 0x23c
420153fe:	976182        	s32i	a8, a1, 0x25c
42015401:	fe4ca5        	call8	420138cc <__ssprint_r>
42015404:	972182        	l32i	a8, a1, 0x25c
42015407:	a898      	l32i.n	a9, a8, 40
42015409:	b888      	l32i.n	a8, a8, 44
4201540b:	996192        	s32i	a9, a1, 0x264
4201540e:	976182        	s32i	a8, a1, 0x25c
42015411:	247a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
42015414:	e4a192        	movi	a9, 0x1e4
42015417:	839a      	add.n	a8, a3, a9
42015419:	986182        	s32i	a8, a1, 0x260
4201541c:	000186        	j	42015426 <_svfiprintf_r+0x1a4e>
4201541f:	61b200        	xsr.epc2	a0
42015422:	a299      	s32i.n	a9, a2, 40
42015424:	829861        	l32r	a6, 41ff5e84 <_coredump_iram_end+0x1c73e84>
42015427:	809b21        	l32r	a2, 41ff5694 <_coredump_iram_end+0x1c73694>
4201542a:	e6c066        	bnei	a0, 32, 42015414 <_svfiprintf_r+0x1a3c>
4201542d:	060216        	beqz	a2, 42015491 <_svfiprintf_r+0x1ab9>
42015430:	2f          	.byte	0x2f
42015431:	a23200        	muluh	a3, a2, a0
42015434:	c18224        	lsi	f2, a2, 0x304
42015437:	c83a10        	lsi	f1, a10, 0x320
4201543a:	0013c6        	j	4201548d <_svfiprintf_r+0x1ab5>
4201543d:	982182        	l32i	a8, a1, 0x260
42015440:	aeb3d1        	l32r	a13, 42000f0c <_stext+0xeec> (3c02a0a4 <zeroes$0>)
42015443:	18a9      	s32i.n	a10, a8, 4
42015445:	08d9      	s32i.n	a13, a8, 0
42015447:	972182        	l32i	a8, a1, 0x25c
4201544a:	10c882        	addi	a8, a8, 16
4201544d:	976182        	s32i	a8, a1, 0x25c
42015450:	308ba6        	blti	a11, 8, 42015484 <_svfiprintf_r+0x1aac>
42015453:	10c182        	addi	a8, a1, 16
42015456:	02d832        	addmi	a3, a8, 0x200
42015459:	972182        	l32i	a8, a1, 0x25c
4201545c:	8e61b2        	s32i	a11, a1, 0x238
4201545f:	9d21a2        	l32i	a10, a1, 0x274
42015462:	9c21b2        	l32i	a11, a1, 0x270
42015465:	0b6382        	s32i	a8, a3, 44
42015468:	9861c2        	s32i	a12, a1, 0x260
4201546b:	fe4625        	call8	420138cc <__ssprint_r>
4201546e:	b388      	l32i.n	a8, a3, 44
42015470:	a3b8      	l32i.n	a11, a3, 40
42015472:	976182        	s32i	a8, a1, 0x25c
42015475:	1e3a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
42015478:	e4a192        	movi	a9, 0x1e4
4201547b:	10c182        	addi	a8, a1, 16
4201547e:	9821c2        	l32i	a12, a1, 0x260
42015481:	809890        	add	a9, a8, a9
42015484:	f0c662        	addi	a6, a6, -16
42015487:	9961b2        	s32i	a11, a1, 0x264
4201548a:	986192        	s32i	a9, a1, 0x260
4201548d:	992182        	l32i	a8, a1, 0x264
42015490:	0a1c      	movi.n	a10, 16
42015492:	b81b      	addi.n	a11, a8, 1
42015494:	982182        	l32i	a8, a1, 0x260
42015497:	988b      	addi.n	a9, a8, 8
42015499:	a02a67        	blt	a10, a6, 4201543d <_svfiprintf_r+0x1a65>
4201549c:	ae9ca1        	l32r	a10, 42000f0c <_stext+0xeec> (3c02a0a4 <zeroes$0>)
4201549f:	1869      	s32i.n	a6, a8, 4
420154a1:	08a9      	s32i.n	a10, a8, 0
420154a3:	972182        	l32i	a8, a1, 0x25c
420154a6:	886a      	add.n	a8, a8, a6
420154a8:	976182        	s32i	a8, a1, 0x25c
420154ab:	992182        	l32i	a8, a1, 0x264
420154ae:	3778a6        	blti	a8, 7, 420154e9 <_svfiprintf_r+0x1b11>
420154b1:	972182        	l32i	a8, a1, 0x25c
420154b4:	10c132        	addi	a3, a1, 16
420154b7:	8e61b2        	s32i	a11, a1, 0x238
420154ba:	9d21a2        	l32i	a10, a1, 0x274
420154bd:	9c21b2        	l32i	a11, a1, 0x270
420154c0:	24a2c2        	movi	a12, 0x224
420154c3:	80c3c0        	add	a12, a3, a12
420154c6:	8f6182        	s32i	a8, a1, 0x23c
420154c9:	fe4025        	call8	420138cc <__ssprint_r>
420154cc:	8e2182        	l32i	a8, a1, 0x238
420154cf:	02d362        	addmi	a6, a3, 0x200
420154d2:	996182        	s32i	a8, a1, 0x264
420154d5:	8f2182        	l32i	a8, a1, 0x23c
420154d8:	976182        	s32i	a8, a1, 0x25c
420154db:	17da56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
420154de:	e4a192        	movi	a9, 0x1e4
420154e1:	839a      	add.n	a8, a3, a9
420154e3:	986182        	s32i	a8, a1, 0x260
420154e6:	000146        	j	420154ef <_svfiprintf_r+0x1b17>
420154e9:	9961b2        	s32i	a11, a1, 0x264
420154ec:	986192        	s32i	a9, a1, 0x260
420154ef:	982182        	l32i	a8, a1, 0x260
420154f2:	9b2192        	l32i	a9, a1, 0x26c
420154f5:	0849      	s32i.n	a4, a8, 0
420154f7:	1899      	s32i.n	a9, a8, 4
420154f9:	972182        	l32i	a8, a1, 0x25c
420154fc:	889a      	add.n	a8, a8, a9
420154fe:	976182        	s32i	a8, a1, 0x25c
42015501:	992182        	l32i	a8, a1, 0x264
42015504:	981b      	addi.n	a9, a8, 1
42015506:	982182        	l32i	a8, a1, 0x260
42015509:	888b      	addi.n	a8, a8, 8
4201550b:	3189a6        	blti	a9, 8, 42015540 <_svfiprintf_r+0x1b68>
4201550e:	10c182        	addi	a8, a1, 16
42015511:	02d862        	addmi	a6, a8, 0x200
42015514:	972182        	l32i	a8, a1, 0x25c
42015517:	9c21b2        	l32i	a11, a1, 0x270
4201551a:	b689      	s32i.n	a8, a6, 44
4201551c:	9d21a2        	l32i	a10, a1, 0x274
4201551f:	10c182        	addi	a8, a1, 16
42015522:	24a2c2        	movi	a12, 0x224
42015525:	80c8c0        	add	a12, a8, a12
42015528:	8e6192        	s32i	a9, a1, 0x238
4201552b:	fe3a25        	call8	420138cc <__ssprint_r>
4201552e:	b688      	l32i.n	a8, a6, 44
42015530:	a698      	l32i.n	a9, a6, 40
42015532:	976182        	s32i	a8, a1, 0x25c
42015535:	123a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
42015538:	e4a182        	movi	a8, 0x1e4
4201553b:	10c1a2        	addi	a10, a1, 16
4201553e:	8a8a      	add.n	a8, a10, a8
42015540:	02e227        	bbsi	a2, 2, 42015546 <_svfiprintf_r+0x1b6e>
42015543:	002846        	j	420155e8 <_svfiprintf_r+0x1c10>
42015546:	9e21a2        	l32i	a10, a1, 0x278
42015549:	c03a50        	sub	a3, a10, a5
4201554c:	0213e6        	bgei	a3, 1, 42015552 <_svfiprintf_r+0x1b7a>
4201554f:	002546        	j	420155e8 <_svfiprintf_r+0x1c10>
42015552:	10c122        	addi	a2, a1, 16
42015555:	24a242        	movi	a4, 0x224
42015558:	424a      	add.n	a4, a2, a4
4201555a:	001106        	j	420155a2 <_svfiprintf_r+0x1bca>
4201555d:	ae6a91        	l32r	a9, 42000f08 <_stext+0xee8> (3c02a0b4 <blanks$1>)
42015560:	18a9      	s32i.n	a10, a8, 4
42015562:	0899      	s32i.n	a9, a8, 0
42015564:	972192        	l32i	a9, a1, 0x25c
42015567:	08c882        	addi	a8, a8, 8
4201556a:	10c992        	addi	a9, a9, 16
4201556d:	976192        	s32i	a9, a1, 0x25c
42015570:	298ba6        	blti	a11, 8, 4201559d <_svfiprintf_r+0x1bc5>
42015573:	972182        	l32i	a8, a1, 0x25c
42015576:	8a62b2        	s32i	a11, a2, 0x228
42015579:	9d21a2        	l32i	a10, a1, 0x274
4201557c:	9c21b2        	l32i	a11, a1, 0x270
4201557f:	8b6282        	s32i	a8, a2, 0x22c
42015582:	20c440        	or	a12, a4, a4
42015585:	fe3465        	call8	420138cc <__ssprint_r>
42015588:	8b2282        	l32i	a8, a2, 0x22c
4201558b:	8a22b2        	l32i	a11, a2, 0x228
4201558e:	976182        	s32i	a8, a1, 0x25c
42015591:	02d262        	addmi	a6, a2, 0x200
42015594:	0c4a56        	bnez	a10, 4201565c <_svfiprintf_r+0x1c84>
42015597:	e4a182        	movi	a8, 0x1e4
4201559a:	808280        	add	a8, a2, a8
4201559d:	f0c332        	addi	a3, a3, -16
420155a0:	0b9d      	mov.n	a9, a11
420155a2:	0a1c      	movi.n	a10, 16
420155a4:	b91b      	addi.n	a11, a9, 1
420155a6:	b32a37        	blt	a10, a3, 4201555d <_svfiprintf_r+0x1b85>
420155a9:	ae57a1        	l32r	a10, 42000f08 <_stext+0xee8> (3c02a0b4 <blanks$1>)
420155ac:	1839      	s32i.n	a3, a8, 4
420155ae:	08a9      	s32i.n	a10, a8, 0
420155b0:	972182        	l32i	a8, a1, 0x25c
420155b3:	883a      	add.n	a8, a8, a3
420155b5:	976182        	s32i	a8, a1, 0x25c
420155b8:	2a79a6        	blti	a9, 7, 420155e6 <_svfiprintf_r+0x1c0e>
420155bb:	10c182        	addi	a8, a1, 16
420155be:	972192        	l32i	a9, a1, 0x25c
420155c1:	8e61b2        	s32i	a11, a1, 0x238
420155c4:	9d21a2        	l32i	a10, a1, 0x274
420155c7:	9c21b2        	l32i	a11, a1, 0x270
420155ca:	24a2c2        	movi	a12, 0x224
420155cd:	c8ca      	add.n	a12, a8, a12
420155cf:	02d862        	addmi	a6, a8, 0x200
420155d2:	8f6192        	s32i	a9, a1, 0x23c
420155d5:	fe2f65        	call8	420138cc <__ssprint_r>
420155d8:	b688      	l32i.n	a8, a6, 44
420155da:	a698      	l32i.n	a9, a6, 40
420155dc:	976182        	s32i	a8, a1, 0x25c
420155df:	5a8c      	beqz.n	a10, 420155e8 <_svfiprintf_r+0x1c10>
420155e1:	001dc6        	j	4201565c <_svfiprintf_r+0x1c84>
420155e4:	9d0000        	lsi	f0, a0, 0x274
420155e7:	820b      	addi.n	a8, a2, -1
420155e9:	509e21        	l32r	a2, 41fe9864 <_coredump_iram_end+0x1c67864>
420155ec:	5358      	l32i.n	a5, a3, 20
420155ee:	9f2182        	l32i	a8, a1, 0x27c
420155f1:	885a      	add.n	a8, a8, a5
420155f3:	9f6182        	s32i	a8, a1, 0x27c
420155f6:	972182        	l32i	a8, a1, 0x25c
420155f9:	48ac      	beqz.n	a8, 42015621 <_svfiprintf_r+0x1c49>
420155fb:	10c182        	addi	a8, a1, 16
420155fe:	02d862        	addmi	a6, a8, 0x200
42015601:	972182        	l32i	a8, a1, 0x25c
42015604:	9c21b2        	l32i	a11, a1, 0x270
42015607:	b689      	s32i.n	a8, a6, 44
42015609:	9d21a2        	l32i	a10, a1, 0x274
4201560c:	10c182        	addi	a8, a1, 16
4201560f:	24a2c2        	movi	a12, 0x224
42015612:	c8ca      	add.n	a12, a8, a12
42015614:	8e6192        	s32i	a9, a1, 0x238
42015617:	fe2b65        	call8	420138cc <__ssprint_r>
4201561a:	b688      	l32i.n	a8, a6, 44
4201561c:	976182        	s32i	a8, a1, 0x25c
4201561f:	9afc      	bnez.n	a10, 4201565c <_svfiprintf_r+0x1c84>
42015621:	080c      	movi.n	a8, 0
42015623:	996182        	s32i	a8, a1, 0x264
42015626:	10c192        	addi	a9, a1, 16
42015629:	e4a182        	movi	a8, 0x1e4
4201562c:	898a      	add.n	a8, a9, a8
4201562e:	076d      	mov.n	a6, a7
42015630:	986182        	s32i	a8, a1, 0x260
42015633:	f90946        	j	42013a5c <_svfiprintf_r+0x84>
42015636:	820000        	mull	a0, a0, a0
42015639:	169721        	l32r	a2, 41fdb098 <_coredump_iram_end+0x1c59098>
4201563c:	01d8      	l32i.n	a13, a1, 0
4201563e:	9921a2        	l32i	a10, a1, 0x264
42015641:	10c182        	addi	a8, a1, 16
42015644:	8e61a2        	s32i	a10, a1, 0x238
42015647:	9721a2        	l32i	a10, a1, 0x25c
4201564a:	24a2c2        	movi	a12, 0x224
4201564d:	8f61a2        	s32i	a10, a1, 0x23c
42015650:	9c21b2        	l32i	a11, a1, 0x270
42015653:	9d21a2        	l32i	a10, a1, 0x274
42015656:	80c8c0        	add	a12, a8, a12
42015659:	fe2725        	call8	420138cc <__ssprint_r>
4201565c:	9c2182        	l32i	a8, a1, 0x270
4201565f:	061882        	l16ui	a8, a8, 12
42015662:	166867        	bbci	a8, 6, 4201567c <_svfiprintf_r+0x1ca4>
42015665:	f87c      	movi.n	a8, -1
42015667:	9f6182        	s32i	a8, a1, 0x27c
4201566a:	000386        	j	4201567c <_svfiprintf_r+0x1ca4>
4201566d:	9b2182        	l32i	a8, a1, 0x26c
42015670:	02ad      	mov.n	a10, a2
42015672:	190c      	movi.n	a9, 1
42015674:	94d8d6        	bgez	a8, 42014fc5 <_svfiprintf_r+0x15ed>
42015677:	fe6ac6        	j	42015026 <_svfiprintf_r+0x164e>
4201567a:	220000        	orb	b0, b0, b0
4201567d:	1d9f21        	l32r	a2, 41fdccfc <_coredump_iram_end+0x1c5acfc>
42015680:	0000f0        	callx12	a0
	...

42015684 <_mbtowc_r>:
42015684:	004136        	entry	a1, 32
42015687:	adf981        	l32r	a8, 42000e6c <_stext+0xe4c> (3fc928bc <__global_locale_ptr>)
4201568a:	02ad      	mov.n	a10, a2
4201568c:	0888      	l32i.n	a8, a8, 0
4201568e:	03bd      	mov.n	a11, a3
42015690:	392882        	l32i	a8, a8, 228
42015693:	04cd      	mov.n	a12, a4
42015695:	05dd      	mov.n	a13, a5
42015697:	06ed      	mov.n	a14, a6
42015699:	0008e0        	callx8	a8
4201569c:	0a2d      	mov.n	a2, a10
4201569e:	f01d      	retw.n

420156a0 <__ascii_mbtowc>:
420156a0:	006136        	entry	a1, 48
420156a3:	038d      	mov.n	a8, a3
420156a5:	838130        	moveqz	a8, a1, a3
420156a8:	020c      	movi.n	a2, 0
420156aa:	049c      	beqz.n	a4, 420156be <__ascii_mbtowc+0x1e>
420156ac:	e27c      	movi.n	a2, -2
420156ae:	c58c      	beqz.n	a5, 420156be <__ascii_mbtowc+0x1e>
420156b0:	000492        	l8ui	a9, a4, 0
420156b3:	120c      	movi.n	a2, 1
420156b5:	005892        	s16i	a9, a8, 0
420156b8:	000482        	l8ui	a8, a4, 0
420156bb:	832880        	moveqz	a2, a8, a8
420156be:	f01d      	retw.n

420156c0 <_wctomb_r>:
420156c0:	004136        	entry	a1, 32
420156c3:	adea81        	l32r	a8, 42000e6c <_stext+0xe4c> (3fc928bc <__global_locale_ptr>)
420156c6:	02ad      	mov.n	a10, a2
420156c8:	0888      	l32i.n	a8, a8, 0
420156ca:	03bd      	mov.n	a11, a3
420156cc:	382882        	l32i	a8, a8, 224
420156cf:	20d550        	or	a13, a5, a5
420156d2:	f4c040        	extui	a12, a4, 0, 16
420156d5:	0008e0        	callx8	a8
420156d8:	0a2d      	mov.n	a2, a10
420156da:	f01d      	retw.n

420156dc <__ascii_wctomb>:
420156dc:	004136        	entry	a1, 32
420156df:	028d      	mov.n	a8, a2
420156e1:	f44040        	extui	a4, a4, 0, 16
420156e4:	020c      	movi.n	a2, 0
420156e6:	339c      	beqz.n	a3, 420156fd <__ascii_wctomb+0x21>
420156e8:	ffa092        	movi	a9, 255
420156eb:	09b947        	bgeu	a9, a4, 420156f8 <__ascii_wctomb+0x1c>
420156ee:	8aa092        	movi	a9, 138
420156f1:	0899      	s32i.n	a9, a8, 0
420156f3:	f27c      	movi.n	a2, -1
420156f5:	000106        	j	420156fd <__ascii_wctomb+0x21>
420156f8:	004342        	s8i	a4, a3, 0
420156fb:	120c      	movi.n	a2, 1
420156fd:	f01d      	retw.n
	...

42015700 <init_efuse_secure>:
{
42015700:	004136        	entry	a1, 32
}
42015703:	020c      	movi.n	a2, 0
42015705:	f01d      	retw.n
	...

42015708 <esp_efuse_startup_include_func>:

void esp_efuse_startup_include_func(void)
{
42015708:	004136        	entry	a1, 32
    // Hook to force the linker to include this file
}
4201570b:	f01d      	retw.n
4201570d:	000000        	ill

42015710 <esp_efuse_utility_check_errors>:
    efuse_hal_read();
    efuse_hal_clear_program_registers();
}

esp_err_t esp_efuse_utility_check_errors(void)
{
42015710:	004136        	entry	a1, 32
    return ESP_OK;
}
42015713:	020c      	movi.n	a2, 0
42015715:	f01d      	retw.n
	...

42015718 <esp_system_include_startup_funcs>:
{
42015718:	004136        	entry	a1, 32
}
4201571b:	f01d      	retw.n
4201571d:	000000        	ill

42015720 <get_reset_reason>:
{
42015720:	004136        	entry	a1, 32
    switch (rtc_reset_reason) {
42015723:	028266        	bnei	a2, 8, 42015729 <get_reset_reason+0x9>
42015726:	002206        	j	420157b2 <get_reset_reason+0x92>
42015729:	880c      	movi.n	a8, 8
4201572b:	1e3827        	bltu	a8, a2, 4201574d <get_reset_reason+0x2d>
4201572e:	025266        	bnei	a2, 5, 42015734 <get_reset_reason+0x14>
42015731:	0020c6        	j	420157b8 <get_reset_reason+0x98>
42015734:	0d62f6        	bgeui	a2, 6, 42015745 <get_reset_reason+0x25>
42015737:	021266        	bnei	a2, 1, 4201573d <get_reset_reason+0x1d>
4201573a:	002a86        	j	420157e8 <get_reset_reason+0xc8>
4201573d:	4f3226        	beqi	a2, 3, 42015790 <get_reset_reason+0x70>
        return ESP_RST_UNKNOWN;
42015740:	020c      	movi.n	a2, 0
42015742:	002886        	j	420157e8 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
42015745:	747266        	bnei	a2, 7, 420157bd <get_reset_reason+0x9d>
        return ESP_RST_TASK_WDT;
42015748:	620c      	movi.n	a2, 6
4201574a:	002686        	j	420157e8 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
4201574d:	f80c      	movi.n	a8, 15
4201574f:	6f1287        	beq	a2, a8, 420157c2 <get_reset_reason+0xa2>
42015752:	203827        	bltu	a8, a2, 42015776 <get_reset_reason+0x56>
42015755:	37a226        	beqi	a2, 12, 42015790 <get_reset_reason+0x70>
42015758:	c80c      	movi.n	a8, 12
4201575a:	0e3827        	bltu	a8, a2, 4201576c <get_reset_reason+0x4c>
4201575d:	980c      	movi.n	a8, 9
4201575f:	641287        	beq	a2, a8, 420157c7 <get_reset_reason+0xa7>
42015762:	b80c      	movi.n	a8, 11
42015764:	649287        	bne	a2, a8, 420157cc <get_reset_reason+0xac>
        return ESP_RST_WDT;
42015767:	720c      	movi.n	a2, 7
42015769:	001ec6        	j	420157e8 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
4201576c:	d80c      	movi.n	a8, 13
4201576e:	5f9287        	bne	a2, a8, 420157d1 <get_reset_reason+0xb1>
        return ESP_RST_WDT;
42015771:	720c      	movi.n	a2, 7
42015773:	001c46        	j	420157e8 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
42015776:	281c      	movi.n	a8, 18
42015778:	083827        	bltu	a8, a2, 42015784 <get_reset_reason+0x64>
4201577b:	57b2b6        	bltui	a2, 16, 420157d6 <get_reset_reason+0xb6>
        return ESP_RST_WDT;
4201577e:	720c      	movi.n	a2, 7
42015780:	001906        	j	420157e8 <get_reset_reason+0xc8>
42015783:	c22200        	quou	a2, a2, a0
    switch (rtc_reset_reason) {
42015786:	b6eb      	addi.n	a11, a6, 14
42015788:	0c5122        	s16i	a2, a1, 24
        return ESP_RST_UNKNOWN;
4201578b:	160602        	l8ui	a0, a6, 22
4201578e:	820000        	mull	a0, a0, a0
        if (reset_reason_hint == ESP_RST_PANIC ||
42015791:	80fcc3        	lsi	f12, a12, 0x200
42015794:	40f8      	l32i.n	a15, a0, 16
42015796:	418580        	srli	a8, a8, 5
                reset_reason_hint == ESP_RST_BROWNOUT ||
42015799:	f7c392        	addi	a9, a3, -9
4201579c:	40f990        	nsau	a9, a9
4201579f:	419590        	srli	a9, a9, 5
        if (reset_reason_hint == ESP_RST_PANIC ||
420157a2:	208890        	or	a8, a8, a9
420157a5:	88fc      	bnez.n	a8, 420157e1 <get_reset_reason+0xc1>
                reset_reason_hint == ESP_RST_TASK_WDT ||
420157a7:	fbc382        	addi	a8, a3, -5
420157aa:	3828b6        	bltui	a8, 2, 420157e6 <get_reset_reason+0xc6>
        return ESP_RST_SW;
420157ad:	320c      	movi.n	a2, 3
420157af:	000d46        	j	420157e8 <get_reset_reason+0xc8>
        return ESP_RST_INT_WDT;
420157b2:	520c      	movi.n	a2, 5
420157b4:	000c06        	j	420157e8 <get_reset_reason+0xc8>
420157b7:	820c00        	mull	a0, a12, a0
        return ESP_RST_DEEPSLEEP;
420157ba:	000a86        	j	420157e8 <get_reset_reason+0xc8>
        return ESP_RST_UNKNOWN;
420157bd:	020c      	movi.n	a2, 0
420157bf:	000946        	j	420157e8 <get_reset_reason+0xc8>
        return ESP_RST_BROWNOUT;
420157c2:	920c      	movi.n	a2, 9
420157c4:	000806        	j	420157e8 <get_reset_reason+0xc8>
        return ESP_RST_WDT;
420157c7:	720c      	movi.n	a2, 7
420157c9:	0006c6        	j	420157e8 <get_reset_reason+0xc8>
        return ESP_RST_UNKNOWN;
420157cc:	020c      	movi.n	a2, 0
420157ce:	000586        	j	420157e8 <get_reset_reason+0xc8>
420157d1:	020c      	movi.n	a2, 0
420157d3:	000446        	j	420157e8 <get_reset_reason+0xc8>
420157d6:	020c      	movi.n	a2, 0
420157d8:	000306        	j	420157e8 <get_reset_reason+0xc8>
420157db:	b20c00        	mulsh	a0, a12, a0
        return ESP_RST_USB;
420157de:	000186        	j	420157e8 <get_reset_reason+0xc8>
            return reset_reason_hint;
420157e1:	032d      	mov.n	a2, a3
420157e3:	000046        	j	420157e8 <get_reset_reason+0xc8>
420157e6:	032d      	mov.n	a2, a3
}
420157e8:	f01d      	retw.n
	...

420157ec <get_cache_error>:
{
420157ec:	004136        	entry	a1, 32
    for (int i = 0; i < size; i++) {
420157ef:	090c      	movi.n	a9, 0
420157f1:	000a86        	j	4201581f <get_cache_error+0x33>
420157f4:	89c000        	lsi	f0, a0, 0x224
        const uint32_t bit = reg_bits[i].bit;
420157f7:	838a11        	l32r	a1, 41ff6620 <_coredump_iram_end+0x1c74620>
420157fa:	08a8      	l32i.n	a10, a8, 0
        if ((status & bit) == bit) {
420157fc:	1dc2a7        	bnall	a2, a10, 4201581d <get_cache_error+0x31>
            err_info->err_str = reg_bits[i].msg;
420157ff:	1898      	l32i.n	a9, a8, 4
42015801:	0599      	s32i.n	a9, a5, 0
            err_info->vaddr = reg_bits[i].fault_addr_reg ? REG_READ(reg_bits[i].fault_addr_reg) : 0;
42015803:	2898      	l32i.n	a9, a8, 8
42015805:	498c      	beqz.n	a9, 4201580d <get_cache_error+0x21>
42015807:	0020c0        	memw
4201580a:	002992        	l32i	a9, a9, 0
4201580d:	1599      	s32i.n	a9, a5, 4
            err_info->size = reg_bits[i].fault_size_reg ? REG_READ(reg_bits[i].fault_size_reg) : 0;
4201580f:	3888      	l32i.n	a8, a8, 12
42015811:	388c      	beqz.n	a8, 42015818 <get_cache_error+0x2c>
42015813:	0020c0        	memw
42015816:	0888      	l32i.n	a8, a8, 0
42015818:	2589      	s32i.n	a8, a5, 8
            return;
4201581a:	000106        	j	42015822 <get_cache_error+0x36>
    for (int i = 0; i < size; i++) {
4201581d:	991b      	addi.n	a9, a9, 1
4201581f:	d23947        	bltu	a9, a4, 420157f5 <get_cache_error+0x9>
}
42015822:	f01d      	retw.n

42015824 <panic_soc_check_pseudo_cause>:
{
42015824:	004136        	entry	a1, 32
}
42015827:	020c      	movi.n	a2, 0
42015829:	f01d      	retw.n
	...

4201582c <panic_get_address>:
{
4201582c:	004136        	entry	a1, 32
}
4201582f:	1228      	l32i.n	a2, a2, 4
42015831:	f01d      	retw.n
	...

42015834 <panic_get_cause>:
{
42015834:	004136        	entry	a1, 32
}
42015837:	142222        	l32i	a2, a2, 80
4201583a:	f01d      	retw.n

4201583c <panic_set_address>:
{
4201583c:	004136        	entry	a1, 32
    ((XtExcFrame *)f)->pc = addr;
4201583f:	1239      	s32i.n	a3, a2, 4
}
42015841:	f01d      	retw.n
	...

42015844 <heap_caps_match>:
{
42015844:	004136        	entry	a1, 32
    return heap->heap != NULL && ((get_all_caps(heap) & caps) == caps);
42015847:	7288      	l32i.n	a8, a2, 28
42015849:	08dc      	bnez.n	a8, 4201585d <heap_caps_match+0x19>
4201584b:	020c      	movi.n	a2, 0
4201584d:	000746        	j	4201586e <heap_caps_match+0x2a>
        all_caps |= heap->caps[prio];
42015850:	a0a820        	addx4	a10, a8, a2
42015853:	0aa8      	l32i.n	a10, a10, 0
42015855:	2099a0        	or	a9, a9, a10
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
42015858:	881b      	addi.n	a8, a8, 1
4201585a:	0000c6        	j	42015861 <heap_caps_match+0x1d>
4201585d:	080c      	movi.n	a8, 0
    uint32_t all_caps = 0;
4201585f:	089d      	mov.n	a9, a8
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
42015861:	eb38a6        	blti	a8, 3, 42015850 <heap_caps_match+0xc>
42015864:	04c937        	bnall	a9, a3, 4201586c <heap_caps_match+0x28>
42015867:	120c      	movi.n	a2, 1
42015869:	000046        	j	4201586e <heap_caps_match+0x2a>
4201586c:	020c      	movi.n	a2, 0
}
4201586e:	f01d      	retw.n

42015870 <s_compare_reserved_regions>:
{
42015870:	004136        	entry	a1, 32
    return (int)r_a->start - (int)r_b->start;
42015873:	0228      	l32i.n	a2, a2, 0
42015875:	0388      	l32i.n	a8, a3, 0
}
42015877:	c02280        	sub	a2, a2, a8
4201587a:	f01d      	retw.n

4201587c <__esp_system_init_fn_esp_security_init>:
    };
#endif /* SOC_KEY_MANAGER_ECDSA_KEY_DEPLOY || SOC_KEY_MANAGER_FE_KEY_DEPLOY */
}

ESP_SYSTEM_INIT_FN(esp_security_init, SECONDARY, BIT(0), 103)
{
4201587c:	004136        	entry	a1, 32
            return err;
        }
    }
#endif
    return ESP_OK;
}
4201587f:	020c      	movi.n	a2, 0
42015881:	f01d      	retw.n
	...

42015884 <esp_security_init_include_impl>:

void esp_security_init_include_impl(void)
{
42015884:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
42015887:	f01d      	retw.n
42015889:	000000        	ill

4201588c <esp_intr_get_cpu>:
{
4201588c:	004136        	entry	a1, 32
    return handle->vector_desc->cpu;
4201588f:	0288      	l32i.n	a8, a2, 0
42015891:	0828      	l32i.n	a2, a8, 0
}
42015893:	052020        	extui	a2, a2, 16, 1
42015896:	f01d      	retw.n

42015898 <esp_sleep_gpio_include>:

void esp_sleep_gpio_include(void)
{
42015898:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
4201589b:	f01d      	retw.n
4201589d:	000000        	ill

420158a0 <esp_libc_init_funcs>:

// Hook to force the linker to include this file
void esp_libc_init_funcs(void)
{
420158a0:	004136        	entry	a1, 32
}
420158a3:	f01d      	retw.n
420158a5:	000000        	ill

420158a8 <esp_libc_include_pthread_impl>:
    }
    return 0;
}

void esp_libc_include_pthread_impl(void)
{
420158a8:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
420158ab:	f01d      	retw.n
420158ad:	000000        	ill

420158b0 <esp_libc_include_getentropy_impl>:

    return 0;
}

void esp_libc_include_getentropy_impl(void)
{
420158b0:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
420158b3:	f01d      	retw.n
420158b5:	000000        	ill

420158b8 <esp_libc_include_syscalls_impl>:
{
    return _system_r(__getreent(), str);
}

void esp_libc_include_syscalls_impl(void)
{
420158b8:	004136        	entry	a1, 32
}
420158bb:	f01d      	retw.n
420158bd:	000000        	ill

420158c0 <_getpid_r>:
{
420158c0:	004136        	entry	a1, 32
    __errno_r(r) = ENOSYS;
420158c3:	885c      	movi.n	a8, 88
420158c5:	0289      	s32i.n	a8, a2, 0
}
420158c7:	f27c      	movi.n	a2, -1
420158c9:	f01d      	retw.n
	...

420158cc <esp_libc_include_reent_syscalls_impl>:

/* No-op function, used to force linking this file,
   instead of the syscalls implementation from libgloss.
 */
void esp_libc_include_reent_syscalls_impl(void)
{
420158cc:	004136        	entry	a1, 32
}
420158cf:	f01d      	retw.n
420158d1:	000000        	ill

420158d4 <esp_libc_include_init_funcs>:
}
#endif /* CONFIG_VFS_SUPPORT_IO */

// Hook to force the linker to include this file
void esp_libc_include_init_funcs(void)
{
420158d4:	004136        	entry	a1, 32
}
420158d7:	f01d      	retw.n
420158d9:	000000        	ill

420158dc <mutexattr_check>:
{
420158dc:	004136        	entry	a1, 32
    if (attr->type != PTHREAD_MUTEX_NORMAL &&
420158df:	1288      	l32i.n	a8, a2, 4
420158e1:	0438f6        	bgeui	a8, 3, 420158e9 <mutexattr_check+0xd>
    return 0;
420158e4:	020c      	movi.n	a2, 0
420158e6:	000046        	j	420158eb <mutexattr_check+0xf>
        return EINVAL;
420158e9:	621c      	movi.n	a2, 22
}
420158eb:	f01d      	retw.n
420158ed:	000000        	ill

420158f0 <pthread_include_pthread_impl>:
    return configMAX_PRIORITIES - 1;
}

/* Hook function to force linking this file */
void pthread_include_pthread_impl(void)
{
420158f0:	004136        	entry	a1, 32
}
420158f3:	f01d      	retw.n
420158f5:	000000        	ill

420158f8 <pthread_include_pthread_cond_var_impl>:
    return ret;
}

/* Hook function to force linking this file */
void pthread_include_pthread_cond_var_impl(void)
{
420158f8:	004136        	entry	a1, 32
}
420158fb:	f01d      	retw.n
420158fd:	000000        	ill

42015900 <find_value>:
{
42015900:	004136        	entry	a1, 32
    SLIST_FOREACH(result, list, next) {
42015903:	0228      	l32i.n	a2, a2, 0
42015905:	000186        	j	4201590f <find_value+0xf>
        if (result->key == key) {
42015908:	0288      	l32i.n	a8, a2, 0
4201590a:	041837        	beq	a8, a3, 42015912 <find_value+0x12>
    SLIST_FOREACH(result, list, next) {
4201590d:	2228      	l32i.n	a2, a2, 8
4201590f:	ff5256        	bnez	a2, 42015908 <find_value+0x8>
}
42015912:	f01d      	retw.n

42015914 <pthread_include_pthread_local_storage_impl>:

/* Hook function to force linking this file */
void pthread_include_pthread_local_storage_impl(void)
{
42015914:	004136        	entry	a1, 32
}
42015917:	f01d      	retw.n
42015919:	000000        	ill

4201591c <pthread_include_pthread_rwlock_impl>:
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_rwlock_impl(void)
{
4201591c:	004136        	entry	a1, 32
}
4201591f:	f01d      	retw.n
42015921:	000000        	ill

42015924 <pthread_include_pthread_semaphore_impl>:
    *sval = uxSemaphoreGetCount(freertos_semaphore);
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_semaphore_impl(void) { }
42015924:	004136        	entry	a1, 32
42015927:	f01d      	retw.n
42015929:	000000        	ill

4201592c <__cxa_guard_dummy>:
/**
 * Dummy function used to force linking this file instead of the same one in libstdc++.
 * This works via -u __cxa_guard_dummy flag in component.mk
 */
extern "C" void __cxa_guard_dummy(void)
{
4201592c:	004136        	entry	a1, 32
}
4201592f:	f01d      	retw.n
42015931:	000000        	ill

42015934 <__cxx_eh_arena_size_get>:
 * Consequently, libsupc++ will then follow our configured exception emergency pool size.
 *
 * It will be called even with -fno-exception for user code since the stdlib still uses exceptions.
 */
extern "C" size_t __cxx_eh_arena_size_get(void)
{
42015934:	004136        	entry	a1, 32
    return CONFIG_COMPILER_CXX_EXCEPTIONS_EMG_POOL_SIZE;
#else
    ESP_EARLY_LOGD(TAG, "Setting C++ exception emergency pool to 0.");
    return 0;
#endif
}
42015937:	020c      	movi.n	a2, 0
42015939:	f01d      	retw.n
	...

4201593c <__cxx_init_dummy>:
/**
 * Dummy function used to force linking this file.
 * This works via -u __cxx_init_dummy flag in CMakeLists.txt
 */
extern "C" void __cxx_init_dummy(void)
{
4201593c:	004136        	entry	a1, 32
}
4201593f:	f01d      	retw.n
42015941:	000000        	ill

42015944 <esp_timer_init_include_func>:

void esp_timer_init_include_func(void)
{
42015944:	004136        	entry	a1, 32
    // Hook to force the linker to include this file
}
42015947:	f01d      	retw.n
42015949:	000000        	ill

4201594c <include_esp_phy_override>:
static bool s_wifi_pwdet_xpd_flag;
static bool s_wifi_tsens_xpd_flag;
#endif

void include_esp_phy_override(void)
{
4201594c:	004136        	entry	a1, 32
    /* When this empty function is called, all functions below will be linked. */
}
4201594f:	f01d      	retw.n
42015951:	000000        	ill

42015954 <usb_serial_jtag_connection_monitor_include>:

void usb_serial_jtag_connection_monitor_include(void)
{
42015954:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
42015957:	f01d      	retw.n
42015959:	000000        	ill

4201595c <usb_serial_jtag_close>:
{
4201595c:	004136        	entry	a1, 32
}
4201595f:	020c      	movi.n	a2, 0
42015961:	f01d      	retw.n
	...

42015964 <usb_serial_jtag_vfs_include_dev_init>:
    _lock_release_recursive(&s_ctx.write_lock);
    _lock_release_recursive(&s_ctx.read_lock);
}

void usb_serial_jtag_vfs_include_dev_init(void)
{
42015964:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
42015967:	f01d      	retw.n
42015969:	000000        	ill

4201596c <esp_vfs_include_console_register>:

#endif // CONFIG_VFS_SUPPORT_IO

void esp_vfs_include_console_register(void)
{
4201596c:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
4201596f:	f01d      	retw.n
42015971:	000000        	ill

42015974 <vfs_include_syscalls_impl>:
void rewinddir(DIR* pdir)
    __attribute__((alias("esp_vfs_rewinddir")));
#endif // CONFIG_VFS_SUPPORT_DIR

void vfs_include_syscalls_impl(void)
{
42015974:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
42015977:	f01d      	retw.n
42015979:	000000        	ill

4201597c <esp_vfs_include_nullfs_register>:
#endif // CONFIG_VFS_INITIALIZE_DEV_NULL

void esp_vfs_include_nullfs_register(void)
{
4201597c:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
4201597f:	f01d      	retw.n
42015981:	000000        	ill

42015984 <nvs_sec_provider_include_impl>:

    return ESP_OK;
}

void nvs_sec_provider_include_impl(void)
{
42015984:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
42015987:	f01d      	retw.n
42015989:	000000        	ill

4201598c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6rbeginEv>:
      rbegin() _GLIBCXX_NOEXCEPT
4201598c:	004136        	entry	a1, 32
      { return _M_dataplus._M_p; }
4201598f:	0388      	l32i.n	a8, a3, 0
      { return _M_string_length; }
42015991:	1398      	l32i.n	a9, a3, 4
      { return iterator(_M_data() + this->size()); }
42015993:	889a      	add.n	a8, a8, a9
      : current(__x)
42015995:	0289      	s32i.n	a8, a2, 0
      { return reverse_iterator(this->end()); }
42015997:	f01d      	retw.n
42015999:	000000        	ill

4201599c <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4rendEv>:
      rend() _GLIBCXX_NOEXCEPT
4201599c:	004136        	entry	a1, 32
      { return _M_dataplus._M_p; }
4201599f:	0388      	l32i.n	a8, a3, 0
420159a1:	0289      	s32i.n	a8, a2, 0
      { return reverse_iterator(this->begin()); }
420159a3:	f01d      	retw.n
420159a5:	000000        	ill

420159a8 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag>:
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
420159a8:	004136        	entry	a1, 32
      if (__first == __last)
420159ab:	2a1327        	beq	a3, a2, 420159d9 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag+0x31>
	--_M_current;
420159ae:	330b      	addi.n	a3, a3, -1
	return *this;
420159b0:	0003c6        	j	420159c3 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag+0x1b>
    {
#if __cplusplus < 201103L
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
#endif
      _Tp __tmp = _GLIBCXX_MOVE(__a);
420159b3:	000282        	l8ui	a8, a2, 0
      __a = _GLIBCXX_MOVE(__b);
420159b6:	000392        	l8ui	a9, a3, 0
420159b9:	004292        	s8i	a9, a2, 0
      __b = _GLIBCXX_MOVE(__tmp);
420159bc:	004382        	s8i	a8, a3, 0
	++_M_current;
420159bf:	221b      	addi.n	a2, a2, 1
	--_M_current;
420159c1:	330b      	addi.n	a3, a3, -1
	  { __t < __u } -> __boolean_testable;
	  { __u < __t } -> __boolean_testable;
	}
	{
	  if constexpr (three_way_comparable_with<_Tp, _Up>)
	    return __t <=> __u;
420159c3:	0d1237        	beq	a2, a3, 420159d4 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag+0x2c>
420159c6:	04b237        	bgeu	a2, a3, 420159ce <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag+0x26>
420159c9:	f87c      	movi.n	a8, -1
420159cb:	0001c6        	j	420159d6 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag+0x2e>
420159ce:	180c      	movi.n	a8, 1
420159d0:	000086        	j	420159d6 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag+0x2e>
420159d3:	00          	.byte	00
420159d4:	080c      	movi.n	a8, 0
      while (__first < __last)
420159d6:	d9e877        	bbsi	a8, 7, 420159b3 <_ZSt9__reverseIN9__gnu_cxx17__normal_iteratorIPcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvT_SA_St26random_access_iterator_tag+0xb>
    }
420159d9:	f01d      	retw.n
	...

420159dc <s_mem_caps_check>:
{
420159dc:	004136        	entry	a1, 32
    if (caps & MMU_MEM_CAP_EXEC) {
420159df:	096207        	bbci	a2, 0, 420159ec <s_mem_caps_check+0x10>
        if ((caps & MMU_MEM_CAP_8BIT) || (caps & MMU_MEM_CAP_WRITE)) {
420159e2:	481c      	movi.n	a8, 20
420159e4:	098287        	bany	a2, a8, 420159f1 <s_mem_caps_check+0x15>
    return ESP_OK;
420159e7:	020c      	movi.n	a2, 0
420159e9:	0001c6        	j	420159f4 <s_mem_caps_check+0x18>
420159ec:	020c      	movi.n	a2, 0
420159ee:	000086        	j	420159f4 <s_mem_caps_check+0x18>
            return ESP_ERR_INVALID_ARG;
420159f1:	02a122        	movi	a2, 0x102
}
420159f4:	f01d      	retw.n
	...

420159f8 <s_find_available_region>:
{
420159f8:	004136        	entry	a1, 32
420159fb:	02ad      	mov.n	a10, a2
    for (int i = 0; i < region_nums; i++) {
420159fd:	020c      	movi.n	a2, 0
420159ff:	000606        	j	42015a1b <s_find_available_region+0x23>
42015a02:	200000        	or	a0, a0, a0
        if (((mem_regions[i].caps & caps) == caps) && ((mem_regions[i].targets & target) == target)) {
42015a05:	a0a082        	movi	a8, 160
42015a08:	b088      	l32i.n	a8, a0, 44
42015a0a:	6898      	l32i.n	a9, a8, 24
42015a0c:	09c957        	bnall	a9, a5, 42015a19 <s_find_available_region+0x21>
42015a0f:	7898      	l32i.n	a9, a8, 28
42015a11:	04c967        	bnall	a9, a6, 42015a19 <s_find_available_region+0x21>
            if (mem_regions[i].max_slot_size >= size) {
42015a14:	5888      	l32i.n	a8, a8, 20
42015a16:	06b847        	bgeu	a8, a4, 42015a20 <s_find_available_region+0x28>
    for (int i = 0; i < region_nums; i++) {
42015a19:	221b      	addi.n	a2, a2, 1
42015a1b:	e53237        	bltu	a2, a3, 42015a04 <s_find_available_region+0xc>
    int32_t found_region_id = -1;
42015a1e:	f27c      	movi.n	a2, -1
}
42015a20:	f01d      	retw.n
	...

42015a24 <s_is_enclosed>:
 * @param new_block_size  New block size
 *
 * @return True: new block is enclosed; False: new block is not enclosed
 */
static bool s_is_enclosed(uint32_t block_start, uint32_t block_end, uint32_t new_block_start, uint32_t new_block_size)
{
42015a24:	004136        	entry	a1, 32
    bool is_enclosed = false;
    uint32_t new_block_end = new_block_start + new_block_size;
42015a27:	545a      	add.n	a5, a4, a5

    if ((new_block_start >= block_start) && (new_block_end <= block_end)) {
42015a29:	622420        	lsi	f2, a4, 0x188
42015a2c:	220b      	addi.n	a2, a2, -1
42015a2e:	602020        	neg	a2, a2
42015a31:	623350        	lsi	f5, a3, 0x188
42015a34:	330b      	addi.n	a3, a3, -1
42015a36:	603030        	neg	a3, a3
42015a39:	743030        	extui	a3, a3, 0, 8
    } else {
        is_enclosed = false;
    }

    return is_enclosed;
}
42015a3c:	102230        	and	a2, a2, a3
42015a3f:	f01d      	retw.n
42015a41:	000000        	ill

42015a44 <s_is_overlapped>:
 * @param new_block_size  New block size
 *
 * @return True: new block is overlapped; False: new block is not overlapped
 */
static bool s_is_overlapped(uint32_t block_start, uint32_t block_end, uint32_t new_block_start, uint32_t new_block_size)
{
42015a44:	004136        	entry	a1, 32
    bool is_overlapped = false;
    uint32_t new_block_end = new_block_start + new_block_size;
42015a47:	545a      	add.n	a5, a4, a5

    if (((new_block_start < block_start) && (new_block_end > block_start)) ||
42015a49:	629420        	lsi	f2, a4, 0x188
42015a4c:	628250        	lsi	f5, a2, 0x188
42015a4f:	102980        	and	a2, a9, a8
42015a52:	088987        	bany	a9, a8, 42015a5e <s_is_overlapped+0x1a>
            ((new_block_start < block_end) && (new_block_end > block_end))) {
42015a55:	624430        	lsi	f3, a4, 0x188
42015a58:	623350        	lsi	f5, a3, 0x188
42015a5b:	102430        	and	a2, a4, a3
    } else {
        is_overlapped = false;
    }

    return is_overlapped;
}
42015a5e:	f01d      	retw.n

42015a60 <mpu_hal_set_region_access>:
#include "hal/mpu_types.h"

#include "soc/soc_caps.h"

void mpu_hal_set_region_access(int id, mpu_access_t access)
{
42015a60:	004136        	entry	a1, 32
    // 0x60000000 = 3
    // 0x80000000 = 4
    // 0xa0000000 = 5
    // 0xc0000000 = 6
    // 0xe0000000 = 7
    return id * SOC_MPU_MIN_REGION_SIZE;
42015a63:	012230        	slli	a2, a2, 29
    uint32_t addr = mpu_ll_id_to_addr(id);

    switch (access)
42015a66:	1b2326        	beqi	a3, 2, 42015a85 <mpu_hal_set_region_access+0x25>
42015a69:	0733f6        	bgeui	a3, 3, 42015a74 <mpu_hal_set_region_access+0x14>
42015a6c:	c3ac      	beqz.n	a3, 42015a9c <mpu_hal_set_region_access+0x3c>
42015a6e:	081326        	beqi	a3, 1, 42015a7a <mpu_hal_set_region_access+0x1a>
42015a71:	000d46        	j	42015aaa <mpu_hal_set_region_access+0x4a>
42015a74:	183326        	beqi	a3, 3, 42015a90 <mpu_hal_set_region_access+0x30>
42015a77:	000bc6        	j	42015aaa <mpu_hal_set_region_access+0x4a>
}

static inline void mpu_ll_set_region_rw(uint32_t addr)
{
    WDTLB(0x0, addr); // cached, no allocate
42015a7a:	080c      	movi.n	a8, 0
42015a7c:	50e280        	wdtlb	a8, a2
42015a7f:	002030        	dsync
}
42015a82:	000906        	j	42015aaa <mpu_hal_set_region_access+0x4a>
    WDTLB(0x2, addr); // bypass cache
}

static inline void mpu_ll_set_region_x(uint32_t addr)
{
    WITLB(0x3, addr); // cached
42015a85:	380c      	movi.n	a8, 3
42015a87:	506280        	witlb	a8, a2
42015a8a:	002000        	isync
}
42015a8d:	000646        	j	42015aaa <mpu_hal_set_region_access+0x4a>
    WDTLB(0x2, addr); // bypass cache
42015a90:	280c      	movi.n	a8, 2
42015a92:	50e280        	wdtlb	a8, a2
42015a95:	002030        	dsync
}
42015a98:	000386        	j	42015aaa <mpu_hal_set_region_access+0x4a>
42015a9b:	f80c00        	lsi	f0, a12, 0x3e0

static inline void mpu_ll_set_region_illegal(uint32_t addr)
{
    WITLB(0xF, addr);
42015a9e:	506280        	witlb	a8, a2
42015aa1:	002000        	isync
    WDTLB(0xF, addr);
42015aa4:	50e280        	wdtlb	a8, a2
42015aa7:	002030        	dsync
            mpu_ll_set_region_illegal(addr);
            break;
        default:
            break;
    }
}
42015aaa:	f01d      	retw.n

42015aac <_ZNSt9type_infoD1Ev>:
42015aac:	004136        	entry	a1, 32
42015aaf:	f01d      	retw.n
42015ab1:	000000        	ill

42015ab4 <_ZNKSt9type_info14__is_pointer_pEv>:
42015ab4:	004136        	entry	a1, 32
42015ab7:	020c      	movi.n	a2, 0
42015ab9:	f01d      	retw.n
	...

42015abc <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv>:
42015abc:	006136        	entry	a1, 48
42015abf:	080c      	movi.n	a8, 0
42015ac1:	0189      	s32i.n	a8, a1, 0
42015ac3:	1189      	s32i.n	a8, a1, 4
42015ac5:	3189      	s32i.n	a8, a1, 12
42015ac7:	0288      	l32i.n	a8, a2, 0
42015ac9:	091c      	movi.n	a9, 16
42015acb:	6888      	l32i.n	a8, a8, 24
42015acd:	04c8      	l32i.n	a12, a4, 0
42015acf:	02ad      	mov.n	a10, a2
42015ad1:	2199      	s32i.n	a9, a1, 8
42015ad3:	03bd      	mov.n	a11, a3
42015ad5:	01dd      	mov.n	a13, a1
42015ad7:	0008e0        	callx8	a8
42015ada:	1198      	l32i.n	a9, a1, 4
42015adc:	680c      	movi.n	a8, 6
42015ade:	020c      	movi.n	a2, 0
42015ae0:	05c987        	bnall	a9, a8, 42015ae9 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv+0x2d>
42015ae3:	0188      	l32i.n	a8, a1, 0
42015ae5:	120c      	movi.n	a2, 1
42015ae7:	0489      	s32i.n	a8, a4, 0
42015ae9:	f01d      	retw.n
	...

42015aec <_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_>:
42015aec:	004136        	entry	a1, 32
42015aef:	620c      	movi.n	a2, 6
42015af1:	011647        	beq	a6, a4, 42015af6 <_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_+0xa>
42015af4:	120c      	movi.n	a2, 1
42015af6:	f01d      	retw.n

42015af8 <_ZNSt9exceptionD1Ev>:
42015af8:	004136        	entry	a1, 32
42015afb:	f01d      	retw.n
42015afd:	000000        	ill

42015b00 <_ZNKSt11logic_error4whatEv>:
42015b00:	004136        	entry	a1, 32
42015b03:	1228      	l32i.n	a2, a2, 4
42015b05:	f01d      	retw.n
	...

42015b08 <_fwalk_sglue>:
42015b08:	004136        	entry	a1, 32
42015b0b:	026d      	mov.n	a6, a2
42015b0d:	00a022        	movi	a2, 0
42015b10:	2478      	l32i.n	a7, a4, 8
42015b12:	1458      	l32i.n	a5, a4, 4
42015b14:	0006c6        	j	42015b33 <_fwalk_sglue+0x2b>
42015b17:	820000        	mull	a0, a0, a0
42015b1a:	b60617        	bnone	a6, a1, 42015ad4 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv+0x18>
42015b1d:	1028      	l32i.n	a2, a0, 4
42015b1f:	079782        	l16si	a8, a7, 14
42015b22:	0a0826        	beqi	a8, -1, 42015b30 <_fwalk_sglue+0x28>
42015b25:	07bd      	mov.n	a11, a7
42015b27:	20a660        	or	a10, a6, a6
42015b2a:	0003e0        	callx8	a3
42015b2d:	2022a0        	or	a2, a2, a10
42015b30:	68c772        	addi	a7, a7, 104
42015b33:	550b      	addi.n	a5, a5, -1
42015b35:	fe05d6        	bgez	a5, 42015b19 <_fwalk_sglue+0x11>
42015b38:	0448      	l32i.n	a4, a4, 0
42015b3a:	fd2456        	bnez	a4, 42015b10 <_fwalk_sglue+0x8>
42015b3d:	f01d      	retw.n
	...

42015b40 <__sflags>:
42015b40:	004136        	entry	a1, 32
42015b43:	000382        	l8ui	a8, a3, 0
42015b46:	72a092        	movi	a9, 114
42015b49:	351897        	beq	a8, a9, 42015b82 <__sflags+0x42>
42015b4c:	77a092        	movi	a9, 119
42015b4f:	391897        	beq	a8, a9, 42015b8c <__sflags+0x4c>
42015b52:	61a092        	movi	a9, 97
42015b55:	3f1897        	beq	a8, a9, 42015b98 <__sflags+0x58>
42015b58:	681c      	movi.n	a8, 22
42015b5a:	0289      	s32i.n	a8, a2, 0
42015b5c:	020c      	movi.n	a2, 0
42015b5e:	001746        	j	42015bbf <__sflags+0x7f>
42015b61:	071ab7        	beq	a10, a11, 42015b6c <__sflags+0x2c>
42015b64:	141a77        	beq	a10, a7, 42015b7c <__sflags+0x3c>
42015b67:	0011c6        	j	42015bb2 <__sflags+0x72>
42015b6a:	c00000        	sub	a0, a0, a0
42015b6d:	e01022        	l16ui	a2, a0, 0x1c0
42015b70:	1088      	l32i.n	a8, a0, 4
42015b72:	2022d0        	or	a2, a2, a13
42015b75:	2088f0        	or	a8, a8, a15
42015b78:	000d86        	j	42015bb2 <__sflags+0x72>
42015b7b:	886000        	lsi	f0, a0, 0x220
42015b7e:	0bc620        	lsi	f2, a6, 44
42015b81:	090c00        	l32e	a0, a12, -64
42015b84:	080c      	movi.n	a8, 0
42015b86:	420c      	movi.n	a2, 4
42015b88:	000506        	j	42015ba0 <__sflags+0x60>
42015b8b:	a69200        	lsi	f0, a2, 0x298
42015b8e:	180c00        	lsxp	f0, a12, a0
42015b91:	820c      	movi.n	a2, 8
42015b93:	000246        	j	42015ba0 <__sflags+0x60>
42015b96:	920000        	lsi	f0, a0, 0x248
42015b99:	0c08a2        	l8ui	a10, a8, 12
42015b9c:	2218      	l32i.n	a1, a2, 8
42015b9e:	0c08a1        	l32r	a10, 41fd8bc0 <_coredump_iram_end+0x1c56bc0>
42015ba1:	bb2c16        	beqz	a12, 42015757 <get_reset_reason+0x37>
42015ba4:	3c6c      	movi.n	a12, -29
42015ba6:	0d1c      	movi.n	a13, 16
42015ba8:	ce7c      	movi.n	a14, -4
42015baa:	2f0c      	movi.n	a15, 2
42015bac:	78a072        	movi	a7, 120
42015baf:	116650        	slli	a6, a6, 11
42015bb2:	0103a2        	l8ui	a10, a3, 1
42015bb5:	331b      	addi.n	a3, a3, 1
42015bb7:	fa6a56        	bnez	a10, 42015b61 <__sflags+0x21>
42015bba:	208890        	or	a8, a8, a9
42015bbd:	0489      	s32i.n	a8, a4, 0
42015bbf:	f01d      	retw.n
42015bc1:	000000        	ill

42015bc4 <esp_cpu_set_breakpoint>:
{
42015bc4:	004136        	entry	a1, 32
    if (bp_num == 1) {
42015bc7:	051266        	bnei	a2, 1, 42015bd0 <esp_cpu_set_breakpoint+0xc>
        WSR(IBREAKA_1, bp_addr);
42015bca:	138130        	wsr.ibreaka1	a3
42015bcd:	000086        	j	42015bd3 <esp_cpu_set_breakpoint+0xf>
        WSR(IBREAKA_0, bp_addr);
42015bd0:	138030        	wsr.ibreaka0	a3
    RSR(IBREAKENABLE, brk_ena_reg);
42015bd3:	036080        	rsr.ibreakenable	a8
    brk_ena_reg |= BIT(bp_num);
42015bd6:	190c      	movi.n	a9, 1
42015bd8:	401200        	ssl	a2
42015bdb:	a19900        	sll	a9, a9
42015bde:	208890        	or	a8, a8, a9
    WSR(IBREAKENABLE, brk_ena_reg);
42015be1:	136080        	wsr.ibreakenable	a8
}
42015be4:	020c      	movi.n	a2, 0
42015be6:	f01d      	retw.n

42015be8 <periph_ll_get_clk_en_mask>:
#include "soc/syscon_reg.h"
#include "soc/dport_access.h"
#include "soc/soc_caps.h"

static inline uint32_t periph_ll_get_clk_en_mask(periph_module_t periph)
{
42015be8:	004136        	entry	a1, 32
    switch (periph) {
42015beb:	581c      	movi.n	a8, 21
42015bed:	029287        	bne	a2, a8, 42015bf3 <periph_ll_get_clk_en_mask+0xb>
42015bf0:	006506        	j	42015d88 <periph_ll_get_clk_en_mask+0x1a0>
42015bf3:	02b827        	bgeu	a8, a2, 42015bf9 <periph_ll_get_clk_en_mask+0x11>
42015bf6:	003106        	j	42015cbe <periph_ll_get_clk_en_mask+0xd6>
42015bf9:	980c      	movi.n	a8, 9
42015bfb:	029287        	bne	a2, a8, 42015c01 <periph_ll_get_clk_en_mask+0x19>
42015bfe:	0062c6        	j	42015d8d <periph_ll_get_clk_en_mask+0x1a5>
42015c01:	533827        	bltu	a8, a2, 42015c58 <periph_ll_get_clk_en_mask+0x70>
42015c04:	024266        	bnei	a2, 4, 42015c0a <periph_ll_get_clk_en_mask+0x22>
42015c07:	006246        	j	42015d94 <periph_ll_get_clk_en_mask+0x1ac>
42015c0a:	2252f6        	bgeui	a2, 5, 42015c30 <periph_ll_get_clk_en_mask+0x48>
42015c0d:	022266        	bnei	a2, 2, 42015c13 <periph_ll_get_clk_en_mask+0x2b>
42015c10:	006186        	j	42015d9a <periph_ll_get_clk_en_mask+0x1b2>
42015c13:	0d32f6        	bgeui	a2, 3, 42015c24 <periph_ll_get_clk_en_mask+0x3c>
42015c16:	186216        	beqz	a2, 42015da0 <periph_ll_get_clk_en_mask+0x1b8>
42015c19:	021226        	beqi	a2, 1, 42015c1f <periph_ll_get_clk_en_mask+0x37>
42015c1c:	006186        	j	42015da6 <periph_ll_get_clk_en_mask+0x1be>
    case PERIPH_RMT_MODULE:
        return SYSTEM_RMT_CLK_EN;
    case PERIPH_LEDC_MODULE:
        return SYSTEM_LEDC_CLK_EN;
    case PERIPH_UART0_MODULE:
        return SYSTEM_UART_CLK_EN;
42015c1f:	420c      	movi.n	a2, 4
42015c21:	0090c6        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015c24:	023226        	beqi	a2, 3, 42015c2a <periph_ll_get_clk_en_mask+0x42>
42015c27:	006046        	j	42015dac <periph_ll_get_clk_en_mask+0x1c4>
    case PERIPH_UART1_MODULE:
        return SYSTEM_UART1_CLK_EN;
    case PERIPH_UART2_MODULE:
        return SYSTEM_UART2_CLK_EN;
42015c2a:	00a222        	movi	a2, 0x200
42015c2d:	008dc6        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015c30:	027266        	bnei	a2, 7, 42015c36 <periph_ll_get_clk_en_mask+0x4e>
42015c33:	005e86        	j	42015db1 <periph_ll_get_clk_en_mask+0x1c9>
42015c36:	1282f6        	bgeui	a2, 8, 42015c4c <periph_ll_get_clk_en_mask+0x64>
42015c39:	025266        	bnei	a2, 5, 42015c3f <periph_ll_get_clk_en_mask+0x57>
42015c3c:	005e06        	j	42015db8 <periph_ll_get_clk_en_mask+0x1d0>
42015c3f:	026226        	beqi	a2, 6, 42015c45 <periph_ll_get_clk_en_mask+0x5d>
42015c42:	005e06        	j	42015dbe <periph_ll_get_clk_en_mask+0x1d6>
    case PERIPH_USB_MODULE:
        return SYSTEM_USB_CLK_EN;
    case PERIPH_I2C0_MODULE:
        return SYSTEM_I2C_EXT0_CLK_EN;
    case PERIPH_I2C1_MODULE:
        return SYSTEM_I2C_EXT1_CLK_EN;
42015c45:	acb421        	l32r	a2, 42000f18 <_stext+0xef8> (40000 <UserFrameTotalSize+0x3ff00>)
42015c48:	008706        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015c4b:	822600        	mull	a2, a6, a0
    switch (periph) {
42015c4e:	5c4602        	s8i	a0, a6, 92
42015c51:	b22100        	mulsh	a2, a1, a0
    case PERIPH_I2S0_MODULE:
        return SYSTEM_I2S0_CLK_EN;
    case PERIPH_I2S1_MODULE:
        return SYSTEM_I2S1_CLK_EN;
42015c54:	c6ac      	beqz.n	a6, 42015c84 <periph_ll_get_clk_en_mask+0x9c>
42015c56:	660083        	lsi	f8, a0, 0x198
    switch (periph) {
42015c59:	8602b2        	l8ui	a11, a2, 134
42015c5c:	005a      	add.n	a0, a0, a5
42015c5e:	081c      	movi.n	a8, 16
42015c60:	2c3827        	bltu	a8, a2, 42015c90 <periph_ll_get_clk_en_mask+0xa8>
42015c63:	02a266        	bnei	a2, 12, 42015c69 <periph_ll_get_clk_en_mask+0x81>
42015c66:	005986        	j	42015dd0 <periph_ll_get_clk_en_mask+0x1e8>
42015c69:	c80c      	movi.n	a8, 12
42015c6b:	133827        	bltu	a8, a2, 42015c82 <periph_ll_get_clk_en_mask+0x9a>
42015c6e:	029266        	bnei	a2, 10, 42015c74 <periph_ll_get_clk_en_mask+0x8c>
42015c71:	0058c6        	j	42015dd8 <periph_ll_get_clk_en_mask+0x1f0>
42015c74:	b80c      	movi.n	a8, 11
42015c76:	021287        	beq	a2, a8, 42015c7c <periph_ll_get_clk_en_mask+0x94>
42015c79:	005846        	j	42015dde <periph_ll_get_clk_en_mask+0x1f6>
    case PERIPH_LCD_CAM_MODULE:
        return SYSTEM_LCD_CAM_CLK_EN;
    case PERIPH_TIMG0_MODULE:
        return SYSTEM_TIMERGROUP_CLK_EN;
    case PERIPH_TIMG1_MODULE:
        return SYSTEM_TIMERGROUP1_CLK_EN;
42015c7c:	a96821        	l32r	a2, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
42015c7f:	007946        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015c82:	d80c      	movi.n	a8, 13
42015c84:	021287        	beq	a2, a8, 42015c8a <periph_ll_get_clk_en_mask+0xa2>
42015c87:	005646        	j	42015de4 <periph_ll_get_clk_en_mask+0x1fc>
    case PERIPH_PWM0_MODULE:
        return SYSTEM_PWM0_CLK_EN;
    case PERIPH_PWM1_MODULE:
        return SYSTEM_PWM1_CLK_EN;
42015c8a:	aca621        	l32r	a2, 42000f24 <_stext+0xf04> (100000 <UserFrameTotalSize+0xfff00>)
42015c8d:	0075c6        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015c90:	381c      	movi.n	a8, 19
42015c92:	029287        	bne	a2, a8, 42015c98 <periph_ll_get_clk_en_mask+0xb0>
42015c95:	005406        	j	42015de9 <periph_ll_get_clk_en_mask+0x201>
42015c98:	153827        	bltu	a8, a2, 42015cb1 <periph_ll_get_clk_en_mask+0xc9>
42015c9b:	181c      	movi.n	a8, 17
42015c9d:	029287        	bne	a2, a8, 42015ca3 <periph_ll_get_clk_en_mask+0xbb>
42015ca0:	005306        	j	42015df0 <periph_ll_get_clk_en_mask+0x208>
42015ca3:	281c      	movi.n	a8, 18
42015ca5:	021287        	beq	a2, a8, 42015cab <periph_ll_get_clk_en_mask+0xc3>
42015ca8:	005286        	j	42015df6 <periph_ll_get_clk_en_mask+0x20e>
        return SYSTEM_RMT_CLK_EN;
42015cab:	00a222        	movi	a2, 0x200
42015cae:	006d86        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015cb1:	481c      	movi.n	a8, 20
42015cb3:	021287        	beq	a2, a8, 42015cb9 <periph_ll_get_clk_en_mask+0xd1>
42015cb6:	005086        	j	42015dfc <periph_ll_get_clk_en_mask+0x214>
    case PERIPH_UHCI1_MODULE:
        return SYSTEM_UHCI1_CLK_EN;
    case PERIPH_PCNT_MODULE:
        return SYSTEM_PCNT_CLK_EN;
    case PERIPH_SPI_MODULE:
        return SYSTEM_SPI01_CLK_EN;
42015cb9:	220c      	movi.n	a2, 2
42015cbb:	006a46        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015cbe:	f81c      	movi.n	a8, 31
42015cc0:	029287        	bne	a2, a8, 42015cc6 <periph_ll_get_clk_en_mask+0xde>
42015cc3:	004e86        	j	42015e01 <periph_ll_get_clk_en_mask+0x219>
42015cc6:	6a3827        	bltu	a8, a2, 42015d34 <periph_ll_get_clk_en_mask+0x14c>
42015cc9:	a81c      	movi.n	a8, 26
42015ccb:	029287        	bne	a2, a8, 42015cd1 <periph_ll_get_clk_en_mask+0xe9>
42015cce:	004d06        	j	42015e06 <periph_ll_get_clk_en_mask+0x21e>
42015cd1:	2f3827        	bltu	a8, a2, 42015d04 <periph_ll_get_clk_en_mask+0x11c>
42015cd4:	881c      	movi.n	a8, 24
42015cd6:	029287        	bne	a2, a8, 42015cdc <periph_ll_get_clk_en_mask+0xf4>
42015cd9:	004bc6        	j	42015e0c <periph_ll_get_clk_en_mask+0x224>
42015cdc:	153827        	bltu	a8, a2, 42015cf5 <periph_ll_get_clk_en_mask+0x10d>
42015cdf:	681c      	movi.n	a8, 22
42015ce1:	029287        	bne	a2, a8, 42015ce7 <periph_ll_get_clk_en_mask+0xff>
42015ce4:	004b06        	j	42015e14 <periph_ll_get_clk_en_mask+0x22c>
42015ce7:	781c      	movi.n	a8, 23
42015ce9:	021287        	beq	a2, a8, 42015cef <periph_ll_get_clk_en_mask+0x107>
42015cec:	004a86        	j	42015e1a <periph_ll_get_clk_en_mask+0x232>
    case PERIPH_SPI2_MODULE:
        return SYSTEM_SPI2_CLK_EN;
    case PERIPH_SPI3_MODULE:
        return SYSTEM_SPI3_CLK_EN;
    case PERIPH_SDMMC_MODULE:
        return SYSTEM_SDIO_HOST_CLK_EN;
42015cef:	80a022        	movi	a2, 128
42015cf2:	005c86        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015cf5:	981c      	movi.n	a8, 25
42015cf7:	021287        	beq	a2, a8, 42015cfd <periph_ll_get_clk_en_mask+0x115>
42015cfa:	004886        	j	42015e20 <periph_ll_get_clk_en_mask+0x238>
    case PERIPH_TWAI_MODULE:
        return SYSTEM_TWAI_CLK_EN;
    case PERIPH_RNG_MODULE:
        return SYSTEM_WIFI_CLK_RNG_EN;
42015cfd:	a94721        	l32r	a2, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
42015d00:	005906        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015d03:	d81c00        	lsi	f0, a12, 0x360
    switch (periph) {
42015d06:	029287        	bne	a2, a8, 42015d0c <periph_ll_get_clk_en_mask+0x124>
42015d09:	004606        	j	42015e25 <periph_ll_get_clk_en_mask+0x23d>
42015d0c:	153827        	bltu	a8, a2, 42015d25 <periph_ll_get_clk_en_mask+0x13d>
42015d0f:	b81c      	movi.n	a8, 27
42015d11:	029287        	bne	a2, a8, 42015d17 <periph_ll_get_clk_en_mask+0x12f>
42015d14:	004506        	j	42015e2c <periph_ll_get_clk_en_mask+0x244>
42015d17:	c81c      	movi.n	a8, 28
42015d19:	021287        	beq	a2, a8, 42015d1f <periph_ll_get_clk_en_mask+0x137>
42015d1c:	004446        	j	42015e31 <periph_ll_get_clk_en_mask+0x249>
    case PERIPH_WIFI_MODULE:
        return SYSTEM_WIFI_CLK_WIFI_EN_M;
    case PERIPH_BT_MODULE:
        return SYSTEM_WIFI_CLK_BT_EN_M;
    case PERIPH_WIFI_BT_COMMON_MODULE:
        return SYSTEM_WIFI_CLK_WIFI_BT_COMMON_M;
42015d1f:	ac8421        	l32r	a2, 42000f30 <_stext+0xf10> (78078f <UserFrameTotalSize+0x78068f>)
42015d22:	005086        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015d25:	e81c      	movi.n	a8, 30
42015d27:	021287        	beq	a2, a8, 42015d2d <periph_ll_get_clk_en_mask+0x145>
42015d2a:	004206        	j	42015e36 <periph_ll_get_clk_en_mask+0x24e>
    case PERIPH_BT_BASEBAND_MODULE:
        return SYSTEM_BT_BASEBAND_EN;
    case PERIPH_BT_LC_MODULE:
        return SYSTEM_BT_LC_EN;
42015d2d:	ac8121        	l32r	a2, 42000f34 <_stext+0xf14> (30000 <UserFrameTotalSize+0x2ff00>)
42015d30:	004d06        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015d33:	482c00        	ssx	f2, a12, a0
    switch (periph) {
42015d36:	029287        	bne	a2, a8, 42015d3c <periph_ll_get_clk_en_mask+0x154>
42015d39:	003fc6        	j	42015e3c <periph_ll_get_clk_en_mask+0x254>
42015d3c:	2a3827        	bltu	a8, a2, 42015d6a <periph_ll_get_clk_en_mask+0x182>
42015d3f:	282c      	movi.n	a8, 34
42015d41:	029287        	bne	a2, a8, 42015d47 <periph_ll_get_clk_en_mask+0x15f>
42015d44:	003e86        	j	42015e42 <periph_ll_get_clk_en_mask+0x25a>
42015d47:	123827        	bltu	a8, a2, 42015d5d <periph_ll_get_clk_en_mask+0x175>
42015d4a:	02c266        	bnei	a2, 32, 42015d50 <periph_ll_get_clk_en_mask+0x168>
42015d4d:	003dc6        	j	42015e48 <periph_ll_get_clk_en_mask+0x260>
42015d50:	182c      	movi.n	a8, 33
42015d52:	021287        	beq	a2, a8, 42015d58 <periph_ll_get_clk_en_mask+0x170>
42015d55:	003d06        	j	42015e4d <periph_ll_get_clk_en_mask+0x265>
    case PERIPH_SHA_MODULE:
        return SYSTEM_CRYPTO_SHA_CLK_EN;
    case PERIPH_RSA_MODULE:
        return SYSTEM_CRYPTO_RSA_CLK_EN;
    case PERIPH_HMAC_MODULE:
        return SYSTEM_CRYPTO_HMAC_CLK_EN;
42015d58:	022c      	movi.n	a2, 32
42015d5a:	004286        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015d5d:	382c      	movi.n	a8, 35
42015d5f:	021287        	beq	a2, a8, 42015d65 <periph_ll_get_clk_en_mask+0x17d>
42015d62:	003b06        	j	42015e52 <periph_ll_get_clk_en_mask+0x26a>
        return SYSTEM_CRYPTO_RSA_CLK_EN;
42015d65:	820c      	movi.n	a2, 8
42015d67:	003f46        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42015d6a:	682c      	movi.n	a8, 38
42015d6c:	029287        	bne	a2, a8, 42015d72 <periph_ll_get_clk_en_mask+0x18a>
42015d6f:	003946        	j	42015e58 <periph_ll_get_clk_en_mask+0x270>
42015d72:	782c      	movi.n	a8, 39
42015d74:	029287        	bne	a2, a8, 42015d7a <periph_ll_get_clk_en_mask+0x192>
42015d77:	003946        	j	42015e60 <periph_ll_get_clk_en_mask+0x278>
42015d7a:	582c      	movi.n	a8, 37
42015d7c:	021287        	beq	a2, a8, 42015d82 <periph_ll_get_clk_en_mask+0x19a>
42015d7f:	0038c6        	j	42015e66 <periph_ll_get_clk_en_mask+0x27e>
        return SYSTEM_DMA_CLK_EN;
42015d82:	024c      	movi.n	a2, 64
42015d84:	003806        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015d87:	024c00        	andb	b4, b12, b0
        return SYSTEM_SPI2_CLK_EN;
42015d8a:	003686        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_LCD_CAM_CLK_EN;
42015d8d:	00a122        	movi	a2, 0x100
42015d90:	003506        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015d93:	602100        	abs	a2, a0
        return SYSTEM_USB_CLK_EN;
42015d96:	46ac      	beqz.n	a6, 42015dbe <periph_ll_get_clk_en_mask+0x1d6>
42015d98:	2c0033        	lsi	f3, a0, 176
        return SYSTEM_UART1_CLK_EN;
42015d9b:	320602        	l8ui	a0, a6, 50
42015d9e:	210000        	srai	a0, a0, 0
        return SYSTEM_LEDC_CLK_EN;
42015da1:	a9fc      	bnez.n	a9, 42015ddf <periph_ll_get_clk_en_mask+0x1f7>
42015da3:	003046        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
    case PERIPH_DS_MODULE:
        return SYSTEM_CRYPTO_DS_CLK_EN;
    default:
        return 0;
42015da6:	020c      	movi.n	a2, 0
42015da8:	002f06        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015dab:	020c00        	andb	b0, b12, b0
42015dae:	002d86        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_I2S0_CLK_EN;
42015db1:	021c      	movi.n	a2, 16
42015db3:	002c46        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015db6:	220000        	orb	b0, b0, b0
        return SYSTEM_I2C_EXT0_CLK_EN;
42015db9:	4680a0        	lsi	f10, a0, 0x118
42015dbc:	002a      	add.n	a0, a0, a2
        return 0;
42015dbe:	020c      	movi.n	a2, 0
42015dc0:	002906        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015dc3:	020c00        	andb	b0, b12, b0
42015dc6:	002786        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_UHCI0_CLK_EN;
42015dc9:	00a122        	movi	a2, 0x100
42015dcc:	002606        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015dcf:	542100        	extui	a2, a0, 1, 6
        return SYSTEM_PWM0_CLK_EN;
42015dd2:	46ac      	beqz.n	a6, 42015dfa <periph_ll_get_clk_en_mask+0x212>
42015dd4:	000024        	lsi	f2, a0, 0
42015dd7:	9d2100        	lsi	f0, a1, 0x274
        return SYSTEM_TIMERGROUP_CLK_EN;
42015dda:	46aa      	add.n	a4, a6, a10
42015ddc:	0c0022        	l8ui	a2, a0, 12
        return 0;
42015ddf:	210602        	l8ui	a0, a6, 33
42015de2:	0c0000        	lsi	f0, a0, 48
42015de5:	1f8602        	lsi	f0, a6, 124
42015de8:	a42200        	extui	a2, a0, 2, 11
        return SYSTEM_PCNT_CLK_EN;
42015deb:	1e0600        	f64sexp	a0, a6, a0
42015dee:	210000        	srai	a0, a0, 0
        return SYSTEM_UHCI1_CLK_EN;
42015df1:	46aa92        	movi	a9, 0xfffffa46
42015df4:	001c      	movi.n	a0, 16
        return 0;
42015df6:	020c      	movi.n	a2, 0
42015df8:	001b06        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015dfb:	020c00        	andb	b0, b12, b0
42015dfe:	001986        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_CRYPTO_AES_CLK_EN;
42015e01:	220c      	movi.n	a2, 2
42015e03:	001846        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_WIFI_CLK_WIFI_EN_M;
42015e06:	020c      	movi.n	a2, 0
42015e08:	001706        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015e0b:	482100        	ssx	f2, a1, a0
        return SYSTEM_TWAI_CLK_EN;
42015e0e:	46ac      	beqz.n	a6, 42015e36 <periph_ll_get_clk_en_mask+0x24e>
42015e10:	000015        	call4	42015e14 <periph_ll_get_clk_en_mask+0x22c>
42015e13:	452100        	extui	a2, a0, 17, 5
        return SYSTEM_SPI3_CLK_EN;
42015e16:	46ac      	beqz.n	a6, 42015e3e <periph_ll_get_clk_en_mask+0x256>
42015e18:	0c0013        	lsi	f1, a0, 48
        return 0;
42015e1b:	120602        	l8ui	a0, a6, 18
42015e1e:	0c0000        	lsi	f0, a0, 48
42015e21:	108602        	lsi	f0, a6, 64
42015e24:	da2100        	ufloat.s	f2, a1, 0
        return SYSTEM_BT_BASEBAND_EN;
42015e27:	06a9      	s32i.n	a10, a6, 0
42015e29:	0f          	.byte	0xf
42015e2a:	0c0000        	lsi	f0, a0, 48
        return SYSTEM_WIFI_CLK_BT_EN_M;
42015e2d:	0d8602        	lsi	f0, a6, 52
42015e30:	020c00        	andb	b0, b12, b0
        return 0;
42015e33:	000c46        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015e36:	020c      	movi.n	a2, 0
42015e38:	000b06        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015e3b:	7d2100        	lsi	f0, a1, 0x1f4
        return SYSTEM_SYSTIMER_CLK_EN;
42015e3e:	46a9      	s32i.n	a10, a6, 16
42015e40:	0009      	s32i.n	a0, a0, 0
        return SYSTEM_CRYPTO_DS_CLK_EN;
42015e42:	021c      	movi.n	a2, 16
42015e44:	000806        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015e47:	420c00        	xorb	b0, b12, b0
        return SYSTEM_CRYPTO_SHA_CLK_EN;
42015e4a:	000686        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42015e4d:	020c      	movi.n	a2, 0
42015e4f:	000546        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015e52:	020c      	movi.n	a2, 0
42015e54:	000406        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
42015e57:	a02200        	addx4	a2, a2, a0
        return SYSTEM_CLK_EN_DEDICATED_GPIO;
42015e5a:	024680        	andb	b4, b6, b8
42015e5d:	000000        	ill
    switch (periph) {
42015e60:	ac2c21        	l32r	a2, 42000f10 <_stext+0xef0> (10000000 <UserFrameTotalSize+0xfffff00>)
42015e63:	000046        	j	42015e68 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42015e66:	020c      	movi.n	a2, 0
    }
}
42015e68:	f01d      	retw.n
	...

42015e6c <periph_ll_get_rst_en_mask>:

static inline uint32_t periph_ll_get_rst_en_mask(periph_module_t periph, bool enable)
{
42015e6c:	004136        	entry	a1, 32
    switch (periph) {
42015e6f:	381c      	movi.n	a8, 19
42015e71:	029287        	bne	a2, a8, 42015e77 <periph_ll_get_rst_en_mask+0xb>
42015e74:	005846        	j	42015fd9 <periph_ll_get_rst_en_mask+0x16d>
42015e77:	02b827        	bgeu	a8, a2, 42015e7d <periph_ll_get_rst_en_mask+0x11>
42015e7a:	002886        	j	42015f20 <periph_ll_get_rst_en_mask+0xb4>
42015e7d:	028266        	bnei	a2, 8, 42015e83 <periph_ll_get_rst_en_mask+0x17>
42015e80:	005706        	j	42015fe0 <periph_ll_get_rst_en_mask+0x174>
42015e83:	880c      	movi.n	a8, 8
42015e85:	433827        	bltu	a8, a2, 42015ecc <periph_ll_get_rst_en_mask+0x60>
42015e88:	024266        	bnei	a2, 4, 42015e8e <periph_ll_get_rst_en_mask+0x22>
42015e8b:	005646        	j	42015fe8 <periph_ll_get_rst_en_mask+0x17c>
42015e8e:	2252f6        	bgeui	a2, 5, 42015eb4 <periph_ll_get_rst_en_mask+0x48>
42015e91:	022266        	bnei	a2, 2, 42015e97 <periph_ll_get_rst_en_mask+0x2b>
42015e94:	005586        	j	42015fee <periph_ll_get_rst_en_mask+0x182>
42015e97:	0d32f6        	bgeui	a2, 3, 42015ea8 <periph_ll_get_rst_en_mask+0x3c>
42015e9a:	156216        	beqz	a2, 42015ff4 <periph_ll_get_rst_en_mask+0x188>
42015e9d:	021226        	beqi	a2, 1, 42015ea3 <periph_ll_get_rst_en_mask+0x37>
42015ea0:	005586        	j	42015ffa <periph_ll_get_rst_en_mask+0x18e>
    case PERIPH_WIFI_MODULE:
        return SYSTEM_WIFIMAC_RST;
    case PERIPH_BT_MODULE:
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
    case PERIPH_UART0_MODULE:
        return SYSTEM_UART_RST;
42015ea3:	420c      	movi.n	a2, 4
42015ea5:	007ec6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015ea8:	023226        	beqi	a2, 3, 42015eae <periph_ll_get_rst_en_mask+0x42>
42015eab:	005446        	j	42016000 <periph_ll_get_rst_en_mask+0x194>
    case PERIPH_UART1_MODULE:
        return SYSTEM_UART1_RST;
    case PERIPH_UART2_MODULE:
        return SYSTEM_UART2_RST;
42015eae:	00a222        	movi	a2, 0x200
42015eb1:	007bc6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015eb4:	026266        	bnei	a2, 6, 42015eba <periph_ll_get_rst_en_mask+0x4e>
42015eb7:	005286        	j	42016005 <periph_ll_get_rst_en_mask+0x199>
42015eba:	027266        	bnei	a2, 7, 42015ec0 <periph_ll_get_rst_en_mask+0x54>
42015ebd:	0052c6        	j	4201600c <periph_ll_get_rst_en_mask+0x1a0>
42015ec0:	025226        	beqi	a2, 5, 42015ec6 <periph_ll_get_rst_en_mask+0x5a>
42015ec3:	005286        	j	42016011 <periph_ll_get_rst_en_mask+0x1a5>
    case PERIPH_USB_MODULE:
        return SYSTEM_USB_RST;
    case PERIPH_I2C0_MODULE:
        return SYSTEM_I2C_EXT0_RST;
42015ec6:	80a022        	movi	a2, 128
42015ec9:	0075c6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015ecc:	d80c      	movi.n	a8, 13
42015ece:	029287        	bne	a2, a8, 42015ed4 <periph_ll_get_rst_en_mask+0x68>
42015ed1:	005046        	j	42016016 <periph_ll_get_rst_en_mask+0x1aa>
42015ed4:	2c3827        	bltu	a8, a2, 42015f04 <periph_ll_get_rst_en_mask+0x98>
42015ed7:	b80c      	movi.n	a8, 11
42015ed9:	029287        	bne	a2, a8, 42015edf <periph_ll_get_rst_en_mask+0x73>
42015edc:	004f06        	j	4201601c <periph_ll_get_rst_en_mask+0x1b0>
42015edf:	153827        	bltu	a8, a2, 42015ef8 <periph_ll_get_rst_en_mask+0x8c>
42015ee2:	980c      	movi.n	a8, 9
42015ee4:	029287        	bne	a2, a8, 42015eea <periph_ll_get_rst_en_mask+0x7e>
42015ee7:	004e46        	j	42016024 <periph_ll_get_rst_en_mask+0x1b8>
42015eea:	029226        	beqi	a2, 10, 42015ef0 <periph_ll_get_rst_en_mask+0x84>
42015eed:	004e46        	j	4201602a <periph_ll_get_rst_en_mask+0x1be>
    case PERIPH_I2S1_MODULE:
        return SYSTEM_I2S1_RST;
    case PERIPH_LCD_CAM_MODULE:
        return SYSTEM_LCD_CAM_RST;
    case PERIPH_TIMG0_MODULE:
        return SYSTEM_TIMERGROUP_RST;
42015ef0:	aa5721        	l32r	a2, 4200084c <_stext+0x82c> (2000 <UserFrameTotalSize+0x1f00>)
42015ef3:	006b46        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42015ef6:	260000        	lsi	f0, a0, 152
    switch (periph) {
42015ef9:	4602a2        	l8ui	a10, a2, 70
42015efc:	004c      	movi.n	a0, 64
    case PERIPH_TIMG1_MODULE:
        return SYSTEM_TIMERGROUP1_RST;
    case PERIPH_PWM0_MODULE:
        return SYSTEM_PWM0_RST;
42015efe:	ac0821        	l32r	a2, 42000f20 <_stext+0xf00> (20000 <UserFrameTotalSize+0x1ff00>)
42015f01:	0067c6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015f04:	181c      	movi.n	a8, 17
42015f06:	029287        	bne	a2, a8, 42015f0c <periph_ll_get_rst_en_mask+0xa0>
42015f09:	004a06        	j	42016035 <periph_ll_get_rst_en_mask+0x1c9>
42015f0c:	281c      	movi.n	a8, 18
42015f0e:	029287        	bne	a2, a8, 42015f14 <periph_ll_get_rst_en_mask+0xa8>
42015f11:	0049c6        	j	4201603c <periph_ll_get_rst_en_mask+0x1d0>
42015f14:	02b226        	beqi	a2, 16, 42015f1a <periph_ll_get_rst_en_mask+0xae>
42015f17:	0049c6        	j	42016042 <periph_ll_get_rst_en_mask+0x1d6>
    case PERIPH_PWM1_MODULE:
        return SYSTEM_PWM1_RST;
    case PERIPH_UHCI0_MODULE:
        return SYSTEM_UHCI0_RST;
42015f1a:	00a122        	movi	a2, 0x100
42015f1d:	0060c6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015f20:	02c266        	bnei	a2, 32, 42015f26 <periph_ll_get_rst_en_mask+0xba>
42015f23:	002886        	j	42015fc9 <periph_ll_get_rst_en_mask+0x15d>
42015f26:	082c      	movi.n	a8, 32
42015f28:	523827        	bltu	a8, a2, 42015f7e <periph_ll_get_rst_en_mask+0x112>
42015f2b:	881c      	movi.n	a8, 24
42015f2d:	029287        	bne	a2, a8, 42015f33 <periph_ll_get_rst_en_mask+0xc7>
42015f30:	004506        	j	42016048 <periph_ll_get_rst_en_mask+0x1dc>
42015f33:	2d3827        	bltu	a8, a2, 42015f64 <periph_ll_get_rst_en_mask+0xf8>
42015f36:	681c      	movi.n	a8, 22
42015f38:	029287        	bne	a2, a8, 42015f3e <periph_ll_get_rst_en_mask+0xd2>
42015f3b:	004446        	j	42016050 <periph_ll_get_rst_en_mask+0x1e4>
42015f3e:	143827        	bltu	a8, a2, 42015f56 <periph_ll_get_rst_en_mask+0xea>
42015f41:	481c      	movi.n	a8, 20
42015f43:	029287        	bne	a2, a8, 42015f49 <periph_ll_get_rst_en_mask+0xdd>
42015f46:	004306        	j	42016056 <periph_ll_get_rst_en_mask+0x1ea>
42015f49:	581c      	movi.n	a8, 21
42015f4b:	021287        	beq	a2, a8, 42015f51 <periph_ll_get_rst_en_mask+0xe5>
42015f4e:	004246        	j	4201605b <periph_ll_get_rst_en_mask+0x1ef>
    case PERIPH_PCNT_MODULE:
        return SYSTEM_PCNT_RST;
    case PERIPH_SPI_MODULE:
        return SYSTEM_SPI01_RST;
    case PERIPH_SPI2_MODULE:
        return SYSTEM_SPI2_RST;
42015f51:	024c      	movi.n	a2, 64
42015f53:	005346        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015f56:	781c      	movi.n	a8, 23
42015f58:	021287        	beq	a2, a8, 42015f5e <periph_ll_get_rst_en_mask+0xf2>
42015f5b:	004046        	j	42016060 <periph_ll_get_rst_en_mask+0x1f4>
    case PERIPH_SPI3_MODULE:
        return SYSTEM_SPI3_RST;
    case PERIPH_SDMMC_MODULE:
        return SYSTEM_SDIO_HOST_RST;
42015f5e:	80a022        	movi	a2, 128
42015f61:	004fc6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015f64:	b81c      	movi.n	a8, 27
42015f66:	029287        	bne	a2, a8, 42015f6c <periph_ll_get_rst_en_mask+0x100>
42015f69:	003e06        	j	42016065 <periph_ll_get_rst_en_mask+0x1f9>
42015f6c:	f81c      	movi.n	a8, 31
42015f6e:	4f1287        	beq	a2, a8, 42015fc1 <periph_ll_get_rst_en_mask+0x155>
42015f71:	a81c      	movi.n	a8, 26
42015f73:	021287        	beq	a2, a8, 42015f79 <periph_ll_get_rst_en_mask+0x10d>
42015f76:	003c86        	j	4201606c <periph_ll_get_rst_en_mask+0x200>
        return SYSTEM_WIFIMAC_RST;
42015f79:	420c      	movi.n	a2, 4
42015f7b:	004946        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42015f7e:	482c      	movi.n	a8, 36
42015f80:	029287        	bne	a2, a8, 42015f86 <periph_ll_get_rst_en_mask+0x11a>
42015f83:	003a86        	j	42016071 <periph_ll_get_rst_en_mask+0x205>
42015f86:	1a3827        	bltu	a8, a2, 42015fa4 <periph_ll_get_rst_en_mask+0x138>
42015f89:	282c      	movi.n	a8, 34
42015f8b:	029287        	bne	a2, a8, 42015f91 <periph_ll_get_rst_en_mask+0x125>
42015f8e:	003986        	j	42016078 <periph_ll_get_rst_en_mask+0x20c>
42015f91:	382c      	movi.n	a8, 35
42015f93:	3a1287        	beq	a2, a8, 42015fd1 <periph_ll_get_rst_en_mask+0x165>
42015f96:	182c      	movi.n	a8, 33
42015f98:	021287        	beq	a2, a8, 42015f9e <periph_ll_get_rst_en_mask+0x132>
42015f9b:	003786        	j	4201607d <periph_ll_get_rst_en_mask+0x211>
    case PERIPH_DEDIC_GPIO_MODULE:
        return SYSTEM_RST_EN_DEDICATED_GPIO;
    case PERIPH_GDMA_MODULE:
        return SYSTEM_DMA_RST;
    case PERIPH_HMAC_MODULE:
        return SYSTEM_CRYPTO_HMAC_RST;
42015f9e:	022c      	movi.n	a2, 32
42015fa0:	004006        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42015fa3:	682c00        	lsi	f0, a12, 0x1a0
    switch (periph) {
42015fa6:	029287        	bne	a2, a8, 42015fac <periph_ll_get_rst_en_mask+0x140>
42015fa9:	0035c6        	j	42016084 <periph_ll_get_rst_en_mask+0x218>
42015fac:	782c      	movi.n	a8, 39
42015fae:	029287        	bne	a2, a8, 42015fb4 <periph_ll_get_rst_en_mask+0x148>
42015fb1:	0035c6        	j	4201608c <periph_ll_get_rst_en_mask+0x220>
42015fb4:	582c      	movi.n	a8, 37
42015fb6:	021287        	beq	a2, a8, 42015fbc <periph_ll_get_rst_en_mask+0x150>
42015fb9:	003546        	j	42016092 <periph_ll_get_rst_en_mask+0x226>
        return SYSTEM_DMA_RST;
42015fbc:	024c      	movi.n	a2, 64
42015fbe:	003886        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
    case PERIPH_DS_MODULE:
        return SYSTEM_CRYPTO_DS_RST;
    case PERIPH_AES_MODULE:
        if (enable == true) {
42015fc1:	0d3316        	beqz	a3, 42016098 <periph_ll_get_rst_en_mask+0x22c>
            // Clear reset on digital signature, otherwise AES unit is held in reset also.
            return (SYSTEM_CRYPTO_AES_RST | SYSTEM_CRYPTO_DS_RST);
42015fc4:	221c      	movi.n	a2, 18
42015fc6:	003686        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        } else {
            //Don't return other units to reset, as this pulls reset on RSA & SHA units, respectively.
            return SYSTEM_CRYPTO_AES_RST;
        }
    case PERIPH_SHA_MODULE:
        if (enable == true) {
42015fc9:	0d0316        	beqz	a3, 4201609d <periph_ll_get_rst_en_mask+0x231>
            // Clear reset on digital signature and HMAC, otherwise SHA is held in reset
            return (SYSTEM_CRYPTO_SHA_RST | SYSTEM_CRYPTO_DS_RST | SYSTEM_CRYPTO_HMAC_RST) ;
42015fcc:	423c      	movi.n	a2, 52
42015fce:	003486        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        } else {
            // Don't assert reset on secure boot, otherwise AES is held in reset
            return SYSTEM_CRYPTO_SHA_RST;
        }
    case PERIPH_RSA_MODULE:
        if (enable == true) {
42015fd1:	0cd316        	beqz	a3, 420160a2 <periph_ll_get_rst_en_mask+0x236>
            /* also clear reset on digital signature, otherwise RSA is held in reset */
            return (SYSTEM_CRYPTO_RSA_RST | SYSTEM_CRYPTO_DS_RST);
42015fd4:	821c      	movi.n	a2, 24
42015fd6:	003286        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_PCNT_RST;
42015fd9:	00a422        	movi	a2, 0x400
42015fdc:	003106        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42015fdf:	cf2100        	f64cmph	a2, a1, a0, 12
        return SYSTEM_I2S1_RST;
42015fe2:	46ab      	addi.n	a4, a6, 10
42015fe4:	2f          	.byte	0x2f
42015fe5:	000000        	ill
        return SYSTEM_USB_RST;
42015fe8:	abcb21        	l32r	a2, 42000f14 <_stext+0xef4> (800000 <UserFrameTotalSize+0x7fff00>)
42015feb:	002d46        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_UART1_RST;
42015fee:	022c      	movi.n	a2, 32
42015ff0:	002c06        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42015ff3:	672100        	lsi	f0, a1, 0x19c
        return SYSTEM_LEDC_RST;
42015ff6:	46a9      	s32i.n	a10, a6, 16
42015ff8:	002a      	add.n	a0, a0, a2
        } else {
            /* don't reset digital signature unit, as this resets AES also */
            return SYSTEM_CRYPTO_RSA_RST;
        }
    default:
        return 0;
42015ffa:	020c      	movi.n	a2, 0
42015ffc:	002906        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42015fff:	020c00        	andb	b0, b12, b0
42016002:	002786        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_I2C_EXT1_RST;
42016005:	abc421        	l32r	a2, 42000f18 <_stext+0xef8> (40000 <UserFrameTotalSize+0x3ff00>)
42016008:	002606        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
4201600b:	021c00        	andb	b1, b12, b0
        return SYSTEM_I2S0_RST;
4201600e:	002486        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return 0;
42016011:	020c      	movi.n	a2, 0
42016013:	002346        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_PWM1_RST;
42016016:	abc321        	l32r	a2, 42000f24 <_stext+0xf04> (100000 <UserFrameTotalSize+0xfff00>)
42016019:	0021c6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_TIMERGROUP1_RST;
4201601c:	a88021        	l32r	a2, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
4201601f:	002046        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42016022:	220000        	orb	b0, b0, b0
        return SYSTEM_LCD_CAM_RST;
42016025:	4600a1        	l32r	a10, 41fe7828 <_coredump_iram_end+0x1c65828>
42016028:	1e          	.byte	0x1e
42016029:	020c00        	andb	b0, b12, b0
        return 0;
4201602c:	001d06        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
4201602f:	020c00        	andb	b0, b12, b0
42016032:	001b86        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_UHCI1_RST;
42016035:	aa0021        	l32r	a2, 42000838 <_stext+0x818> (1000 <UserFrameTotalSize+0xf00>)
42016038:	001a06        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
4201603b:	a22200        	muluh	a2, a2, a0
        return SYSTEM_RMT_RST;
4201603e:	184600        	lsxp	f4, a6, a0
42016041:	020c00        	andb	b0, b12, b0
        return 0;
42016044:	001706        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42016047:	b92100        	lsi	f0, a1, 0x2e4
        return SYSTEM_TWAI_RST;
4201604a:	46ab      	addi.n	a4, a6, 10
4201604c:	000015        	call4	42016050 <periph_ll_get_rst_en_mask+0x1e4>
4201604f:	b62100        	lsi	f0, a1, 0x2d8
        return SYSTEM_SPI3_RST;
42016052:	46ab      	addi.n	a4, a6, 10
42016054:	0c0013        	lsi	f1, a0, 48
        return SYSTEM_SPI01_RST;
42016057:	120622        	l8ui	a2, a6, 18
4201605a:	020c00        	andb	b0, b12, b0
        return 0;
4201605d:	0010c6        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42016060:	020c      	movi.n	a2, 0
42016062:	000f86        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
42016065:	abb421        	l32r	a2, 42000f38 <_stext+0xf18> (3e08 <UserFrameTotalSize+0x3d08>)
42016068:	000e06        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
4201606b:	020c00        	andb	b0, b12, b0
        return 0;
4201606e:	000c86        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_SYSTIMER_RST;
42016071:	a8ef21        	l32r	a2, 42000430 <_stext+0x410> (20000000 <UserFrameTotalSize+0x1fffff00>)
42016074:	000b06        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42016077:	021c00        	andb	b1, b12, b0
        return SYSTEM_CRYPTO_DS_RST;
4201607a:	000986        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
        return 0;
4201607d:	020c      	movi.n	a2, 0
4201607f:	000846        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
42016082:	220000        	orb	b0, b0, b0
        return SYSTEM_RST_EN_DEDICATED_GPIO;
42016085:	4680a0        	lsi	f10, a0, 0x118
42016088:	000006        	j	4201608c <periph_ll_get_rst_en_mask+0x220>
4201608b:	a12100        	sll	a2, a1
    switch (periph) {
4201608e:	46ab      	addi.n	a4, a6, 10
42016090:	0c0004        	lsi	f0, a0, 48
        return 0;
42016093:	030602        	l8ui	a0, a6, 3
42016096:	0c0000        	lsi	f0, a0, 48
            return SYSTEM_CRYPTO_AES_RST;
42016099:	018622        	lsi	f2, a6, 4
4201609c:	420c00        	xorb	b0, b12, b0
            return SYSTEM_CRYPTO_SHA_RST;
4201609f:	000046        	j	420160a4 <periph_ll_get_rst_en_mask+0x238>
            return SYSTEM_CRYPTO_RSA_RST;
420160a2:	820c      	movi.n	a2, 8
    }
}
420160a4:	f01d      	retw.n
	...

420160a8 <periph_ll_get_clk_en_reg>:

static inline uint32_t periph_ll_get_clk_en_reg(periph_module_t periph)
{
420160a8:	004136        	entry	a1, 32
    switch (periph) {
420160ab:	2d3226        	beqi	a2, 3, 420160dc <periph_ll_get_clk_en_reg+0x34>
420160ae:	3232b6        	bltui	a2, 3, 420160e4 <periph_ll_get_clk_en_reg+0x3c>
420160b1:	682c      	movi.n	a8, 38
420160b3:	353827        	bltu	a8, a2, 420160ec <periph_ll_get_clk_en_reg+0x44>
420160b6:	980c      	movi.n	a8, 9
420160b8:	383287        	bltu	a2, a8, 420160f4 <periph_ll_get_clk_en_reg+0x4c>
420160bb:	f7c222        	addi	a2, a2, -9
420160be:	180c      	movi.n	a8, 1
420160c0:	401200        	ssl	a2
420160c3:	a18800        	sll	a8, a8
420160c6:	ab9e91        	l32r	a9, 42000f40 <_stext+0xf20> (17c04001 <UserFrameTotalSize+0x17c03f01>)
420160c9:	2f8897        	bany	a8, a9, 420160fc <periph_ll_get_clk_en_reg+0x54>
420160cc:	559080        	extui	a9, a8, 16, 6
420160cf:	19fc      	bnez.n	a9, 42016104 <periph_ll_get_clk_en_reg+0x5c>
420160d1:	3778d7        	bbci	a8, 29, 4201610c <periph_ll_get_clk_en_reg+0x64>
420160d4:	ab9a21        	l32r	a2, 42000f3c <_stext+0xf1c> (600c0008 <SYSTEM+0x8>)
420160d7:	000d06        	j	4201610f <periph_ll_get_clk_en_reg+0x67>
420160da:	210000        	srai	a0, a0, 0
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_CLK_EN1_REG;
420160dd:	a82b      	addi.n	a10, a8, 2
420160df:	000b06        	j	4201610f <periph_ll_get_clk_en_reg+0x67>
420160e2:	210000        	srai	a0, a0, 0
    default:
        return SYSTEM_PERIP_CLK_EN0_REG;
420160e5:	a828      	l32i.n	a2, a8, 40
420160e7:	000906        	j	4201610f <periph_ll_get_clk_en_reg+0x67>
420160ea:	210000        	srai	a0, a0, 0
420160ed:	06a826        	beqi	a8, 12, 420160f7 <periph_ll_get_clk_en_reg+0x4f>
420160f0:	000007        	bnone	a0, a0, 420160f4 <periph_ll_get_clk_en_reg+0x4c>
420160f3:	242100        	extui	a2, a0, 1, 3
420160f6:	06a8      	l32i.n	a10, a6, 0
420160f8:	000005        	call0	420160fc <periph_ll_get_clk_en_reg+0x54>
420160fb:	232100        	sext	a2, a1, 7
        return SYSTEM_PERIP_CLK_EN1_REG;
420160fe:	06a8      	l32i.n	a10, a6, 0
42016100:	000003        	lsi	f0, a0, 0
42016103:	222100        	orb	b2, b1, b0
        return SYSTEM_WIFI_CLK_EN_REG ;
42016106:	06a8      	l32i.n	a10, a6, 0
42016108:	000001        	l32r	a0, 41fd6108 <_coredump_iram_end+0x1c54108>
4201610b:	1e2100        	f64sexp	a2, a1, a0
        return SYSTEM_PERIP_CLK_EN0_REG;
4201610e:	1da8      	l32i.n	a10, a13, 4
    }
}
42016110:	0000f0        	callx12	a0
	...

42016114 <periph_ll_get_rst_en_reg>:

static inline uint32_t periph_ll_get_rst_en_reg(periph_module_t periph)
{
42016114:	004136        	entry	a1, 32
    switch (periph) {
42016117:	2b3226        	beqi	a2, 3, 42016146 <periph_ll_get_rst_en_reg+0x32>
4201611a:	2e32b6        	bltui	a2, 3, 4201614c <periph_ll_get_rst_en_reg+0x38>
4201611d:	682c      	movi.n	a8, 38
4201611f:	313827        	bltu	a8, a2, 42016154 <periph_ll_get_rst_en_reg+0x40>
42016122:	980c      	movi.n	a8, 9
42016124:	343287        	bltu	a2, a8, 4201615c <periph_ll_get_rst_en_reg+0x48>
42016127:	f7c222        	addi	a2, a2, -9
4201612a:	180c      	movi.n	a8, 1
4201612c:	401200        	ssl	a2
4201612f:	a18800        	sll	a8, a8
42016132:	ab8391        	l32r	a9, 42000f40 <_stext+0xf20> (17c04001 <UserFrameTotalSize+0x17c03f01>)
42016135:	2b8897        	bany	a8, a9, 42016164 <periph_ll_get_rst_en_reg+0x50>
42016138:	559080        	extui	a9, a8, 16, 6
4201613b:	d9ec      	bnez.n	a9, 4201616c <periph_ll_get_rst_en_reg+0x58>
4201613d:	3378d7        	bbci	a8, 29, 42016174 <periph_ll_get_rst_en_reg+0x60>
42016140:	ab8221        	l32r	a2, 42000f48 <_stext+0xf28> (600c000c <SYSTEM+0xc>)
42016143:	000c06        	j	42016177 <periph_ll_get_rst_en_reg+0x63>
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_RST_EN1_REG;
42016146:	a81421        	l32r	a2, 42000198 <_stext+0x178> (600c0024 <SYSTEM+0x24>)
42016149:	000a86        	j	42016177 <periph_ll_get_rst_en_reg+0x63>
    default:
        return SYSTEM_PERIP_RST_EN0_REG;
4201614c:	a81221        	l32r	a2, 42000194 <_stext+0x174> (600c0020 <SYSTEM+0x20>)
4201614f:	000906        	j	42016177 <periph_ll_get_rst_en_reg+0x63>
42016152:	210000        	srai	a0, a0, 0
42016155:	06a810        	lsi	f1, a8, 24
42016158:	000007        	bnone	a0, a0, 4201615c <periph_ll_get_rst_en_reg+0x48>
4201615b:	0e2100        	wrmsk_expstate	a0, a1
4201615e:	06a8      	l32i.n	a10, a6, 0
42016160:	000005        	call0	42016164 <periph_ll_get_rst_en_reg+0x50>
42016163:	0d2100        	lsi	f0, a1, 52
        return SYSTEM_PERIP_RST_EN1_REG;
42016166:	06a8      	l32i.n	a10, a6, 0
42016168:	000003        	lsi	f0, a0, 0
4201616b:	762100        	lsi	f0, a1, 0x1d8
        return SYSTEM_CORE_RST_EN_REG;
4201616e:	06ab      	addi.n	a0, a6, 10
42016170:	000001        	l32r	a0, 41fd6170 <_coredump_iram_end+0x1c54170>
42016173:	082100        	lsx	f2, a1, a0
        return SYSTEM_PERIP_RST_EN0_REG;
42016176:	1da8      	l32i.n	a10, a13, 4
    }
}
42016178:	0000f0        	callx12	a0
	...

4201617c <periph_ll_enable_clk_clear_rst>:

static inline void periph_ll_enable_clk_clear_rst(periph_module_t periph)
{
4201617c:	004136        	entry	a1, 32
    DPORT_SET_PERI_REG_MASK(periph_ll_get_clk_en_reg(periph), periph_ll_get_clk_en_mask(periph));
4201617f:	20a220        	or	a10, a2, a2
42016182:	fff265        	call8	420160a8 <periph_ll_get_clk_en_reg>
42016185:	0a7d      	mov.n	a7, a10
42016187:	0020c0        	memw
4201618a:	0a68      	l32i.n	a6, a10, 0
4201618c:	20a220        	or	a10, a2, a2
4201618f:	ffa5a5        	call8	42015be8 <periph_ll_get_clk_en_mask>
42016192:	2066a0        	or	a6, a6, a10
42016195:	0020c0        	memw
42016198:	0769      	s32i.n	a6, a7, 0
    DPORT_CLEAR_PERI_REG_MASK(periph_ll_get_rst_en_reg(periph), periph_ll_get_rst_en_mask(periph, true));
4201619a:	02ad      	mov.n	a10, a2
4201619c:	fff765        	call8	42016114 <periph_ll_get_rst_en_reg>
4201619f:	0a7d      	mov.n	a7, a10
420161a1:	0020c0        	memw
420161a4:	0a68      	l32i.n	a6, a10, 0
420161a6:	1b0c      	movi.n	a11, 1
420161a8:	02ad      	mov.n	a10, a2
420161aa:	ffcc25        	call8	42015e6c <periph_ll_get_rst_en_mask>
420161ad:	108a60        	and	a8, a10, a6
420161b0:	308860        	xor	a8, a8, a6
420161b3:	0020c0        	memw
420161b6:	0789      	s32i.n	a8, a7, 0
}
420161b8:	f01d      	retw.n
	...

420161bc <periph_module_enable>:
    ref_counts[periph] = ref_count;
    periph_rcc_exit();
}

void periph_module_enable(periph_module_t periph)
{
420161bc:	004136        	entry	a1, 32
#ifdef __PERIPH_CTRL_ALLOW_LEGACY_API
    assert(periph < PERIPH_MODULE_MAX);
420161bf:	882c      	movi.n	a8, 40
420161c1:	10b827        	bgeu	a8, a2, 420161d5 <periph_module_enable+0x19>
420161c4:	ab62d1        	l32r	a13, 42000f4c <_stext+0xf2c> (3c0235e0 <_flash_rodata_start+0x34c0>)
420161c7:	ab62c1        	l32r	a12, 42000f50 <_stext+0xf30> (3c027de0 <__func__$2>)
420161ca:	db3c      	movi.n	a11, 61
420161cc:	ab62a1        	l32r	a10, 42000f54 <_stext+0xf34> (3c02361c <_flash_rodata_start+0x34fc>)
420161cf:	a7bc81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420161d2:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
420161d5:	a88781        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
420161d8:	0008e0        	callx8	a8
420161db:	ea8c      	beqz.n	a10, 420161ed <periph_module_enable+0x31>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
420161dd:	fb7c      	movi.n	a11, -1
420161df:	ab5ea1        	l32r	a10, 42000f58 <_stext+0xf38> (3fc92058 <periph_spinlock>)
420161e2:	a88b81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420161e5:	0008e0        	callx8	a8
420161e8:	000306        	j	420161f8 <periph_module_enable+0x3c>
420161eb:	7c0000        	lsi	f0, a0, 0x1f0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
420161ee:	a1fb      	addi.n	a10, a1, 15
420161f0:	ab5a      	add.n	a10, a11, a5
420161f2:	a88781        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420161f5:	0008e0        	callx8	a8
    portENTER_CRITICAL_SAFE(&periph_spinlock);
    if (ref_counts[periph] == 0) {
420161f8:	ab5981        	l32r	a8, 42000f5c <_stext+0xf3c> (3fc94bf0 <ref_counts>)
420161fb:	882a      	add.n	a8, a8, a2
420161fd:	000882        	l8ui	a8, a8, 0
42016200:	005856        	bnez	a8, 42016209 <periph_module_enable+0x4d>
        periph_ll_enable_clk_clear_rst(periph);
42016203:	20a220        	or	a10, a2, a2
42016206:	fff765        	call8	4201617c <periph_ll_enable_clk_clear_rst>
    }
    ref_counts[periph]++;
42016209:	ab5481        	l32r	a8, 42000f5c <_stext+0xf3c> (3fc94bf0 <ref_counts>)
4201620c:	882a      	add.n	a8, a8, a2
4201620e:	000892        	l8ui	a9, a8, 0
42016211:	01c992        	addi	a9, a9, 1
42016214:	004892        	s8i	a9, a8, 0
    if (xPortInIsrContext()) {
42016217:	a87781        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
4201621a:	0008e0        	callx8	a8
4201621d:	ba8c      	beqz.n	a10, 4201622c <periph_module_enable+0x70>
        portEXIT_CRITICAL_ISR(mux);
4201621f:	ab4ea1        	l32r	a10, 42000f58 <_stext+0xf38> (3fc92058 <periph_spinlock>)
42016222:	a87c81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42016225:	0008e0        	callx8	a8
42016228:	000246        	j	42016235 <periph_module_enable+0x79>
4201622b:	4ba100        	olt.s	b10, f1, f0
        portEXIT_CRITICAL(mux);
4201622e:	81ab      	addi.n	a8, a1, 10
42016230:	a879      	s32i.n	a7, a8, 40
42016232:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
#endif
}
42016235:	f01d      	retw.n
	...

42016238 <set_ocode_by_efuse>:
    val |= RTC_CNTL_SDIO_PD_EN;
    REG_WRITE(RTC_CNTL_SDIO_CONF_REG, val);
}

static void set_ocode_by_efuse(int calib_version)
{
42016238:	004136        	entry	a1, 32
    assert(calib_version == 1);
4201623b:	111226        	beqi	a2, 1, 42016250 <set_ocode_by_efuse+0x18>
4201623e:	ab48d1        	l32r	a13, 42000f60 <_stext+0xf40> (3c0236c8 <_flash_rodata_start+0x35a8>)
42016241:	ab48c1        	l32r	a12, 42000f64 <_stext+0xf44> (3c027e54 <__func__$3>)
42016244:	fca0b2        	movi	a11, 252
42016247:	ab48a1        	l32r	a10, 42000f68 <_stext+0xf48> (3c023709 <_flash_rodata_start+0x35e9>)
4201624a:	a79d81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
4201624d:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_ocode(void)
{
    // EFUSE_BLK2,  141,    8,     ADC OCode
    return EFUSE.rd_sys_part1_data4.ocode;
42016250:	ab4781        	l32r	a8, 42000f6c <_stext+0xf4c> (60007000 <EFUSE>)
42016253:	0020c0        	memw
42016256:	1b28f2        	l32i	a15, a8, 108
    // use efuse ocode.
    uint32_t ocode = efuse_ll_get_ocode();
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_EXT_CODE, ocode);
42016259:	74fdf0        	extui	a15, a15, 13, 8
4201625c:	0e0c      	movi.n	a14, 0
4201625e:	7d0c      	movi.n	a13, 7
42016260:	6c0c      	movi.n	a12, 6
42016262:	1b0c      	movi.n	a11, 1
42016264:	61a0a2        	movi	a10, 97
42016267:	a86f81        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
4201626a:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_FORCE_CODE, 1);
4201626d:	1f0c      	movi.n	a15, 1
4201626f:	6e0c      	movi.n	a14, 6
42016271:	0edd      	mov.n	a13, a14
42016273:	5c0c      	movi.n	a12, 5
42016275:	0fbd      	mov.n	a11, a15
42016277:	61a0a2        	movi	a10, 97
4201627a:	a86a81        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
4201627d:	0008e0        	callx8	a8
}
42016280:	f01d      	retw.n
	...

42016284 <get_dig1v3_dbias_by_efuse>:
    }
    return rtc_dbias;
}

static uint32_t get_dig1v3_dbias_by_efuse(uint8_t pvt_scheme_ver)
{
42016284:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
42016287:	111226        	beqi	a2, 1, 4201629c <get_dig1v3_dbias_by_efuse+0x18>
4201628a:	ab39d1        	l32r	a13, 42000f70 <_stext+0xf50> (3c023714 <_flash_rodata_start+0x35f4>)
4201628d:	ab39c1        	l32r	a12, 42000f74 <_stext+0xf54> (3c027e38 <__func__$2>)
42016290:	6ca1b2        	movi	a11, 0x16c
42016293:	ab35a1        	l32r	a10, 42000f68 <_stext+0xf48> (3c023709 <_flash_rodata_start+0x35e9>)
42016296:	a78a81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016299:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_k_dig_ldo(void)
{
    // EFUSE_BLK1,  148,    7,     BLOCK1 K_DIG_LDO
    return EFUSE.rd_mac_spi_sys_4.k_dig_ldo;
4201629c:	ab3481        	l32r	a8, 42000f6c <_stext+0xf4c> (60007000 <EFUSE>)
4201629f:	0020c0        	memw
420162a2:	1528a2        	l32i	a10, a8, 84
420162a5:	65a4a0        	extui	a10, a10, 20, 7
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_v_dig_dbias20(void)
{
    // EFUSE_BLK1,  163,    8,     BLOCK1 voltage of digital dbias20
    return EFUSE.rd_mac_spi_sys_5.v_dig_dbias20;
420162a8:	0020c0        	memw
420162ab:	162892        	l32i	a9, a8, 88
420162ae:	748390        	extui	a8, a9, 3, 8
420162b1:	209880        	or	a9, a8, a8
    signed int k_dig_ldo = efuse_ll_get_k_dig_ldo();
    signed int v_dig_bias20 = efuse_ll_get_v_dig_dbias20();
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
420162b4:	3fa0b2        	movi	a11, 63
420162b7:	05bba7        	bgeu	a11, a10, 420162c0 <get_dig1v3_dbias_by_efuse+0x3c>
420162ba:	10aab0        	and	a10, a10, a11
420162bd:	60a0a0        	neg	a10, a10
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
420162c0:	056877        	bbci	a8, 7, 420162c9 <get_dig1v3_dbias_by_efuse+0x45>
420162c3:	649090        	extui	a9, a9, 0, 7
420162c6:	609090        	neg	a9, a9

    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
420162c9:	a09990        	addx4	a9, a9, a9
420162cc:	ab2b81        	l32r	a8, 42000f78 <_stext+0xf58> (2a59 <UserFrameTotalSize+0x2959>)
420162cf:	a09980        	addx4	a9, a9, a8
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
420162d2:	d3a082        	movi	a8, 211
420162d5:	aa8a      	add.n	a10, a10, a8
    uint32_t dig_dbias =15;
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
420162d7:	f20c      	movi.n	a2, 15
420162d9:	0003c6        	j	420162ec <get_dig1v3_dbias_by_efuse+0x68>
        uint32_t v_dig_nearest_1v3_mul10000 = 0;
        v_dig_nearest_1v3_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
420162dc:	ecc282        	addi	a8, a2, -20
420162df:	828a80        	mull	a8, a10, a8
420162e2:	889a      	add.n	a8, a8, a9
        if (v_dig_nearest_1v3_mul10000 >= 13000) {
420162e4:	ab26b1        	l32r	a11, 42000f7c <_stext+0xf5c> (32c7 <UserFrameTotalSize+0x31c7>)
420162e7:	063b87        	bltu	a11, a8, 420162f1 <get_dig1v3_dbias_by_efuse+0x6d>
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
420162ea:	221b      	addi.n	a2, a2, 1
420162ec:	e81c      	movi.n	a8, 30
420162ee:	eab827        	bgeu	a8, a2, 420162dc <get_dig1v3_dbias_by_efuse+0x58>
            break;
        }
    }
    return dig_dbias;
}
420162f1:	f01d      	retw.n
	...

420162f4 <get_dig_dbias_by_efuse>:
{
420162f4:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
420162f7:	111226        	beqi	a2, 1, 4201630c <get_dig_dbias_by_efuse+0x18>
420162fa:	ab1dd1        	l32r	a13, 42000f70 <_stext+0xf50> (3c023714 <_flash_rodata_start+0x35f4>)
420162fd:	ab20c1        	l32r	a12, 42000f80 <_stext+0xf60> (3c027e20 <__func__$1>)
42016300:	4aa1b2        	movi	a11, 0x14a
42016303:	ab19a1        	l32r	a10, 42000f68 <_stext+0xf48> (3c023709 <_flash_rodata_start+0x35e9>)
42016306:	a76e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016309:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_dig_dbias_hvt(void)
{
    // EFUSE_BLK1,  171,    5,     BLOCK1 digital dbias when hvt
    return EFUSE.rd_mac_spi_sys_5.dig_dbias_hvt;
4201630c:	ab1881        	l32r	a8, 42000f6c <_stext+0xf4c> (60007000 <EFUSE>)
4201630f:	0020c0        	memw
42016312:	162822        	l32i	a2, a8, 88
}
42016315:	442b20        	extui	a2, a2, 11, 5
42016318:	f01d      	retw.n
	...

4201631c <get_rtc_dbias_by_efuse>:
{
4201631c:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
4201631f:	111226        	beqi	a2, 1, 42016334 <get_rtc_dbias_by_efuse+0x18>
42016322:	ab13d1        	l32r	a13, 42000f70 <_stext+0xf50> (3c023714 <_flash_rodata_start+0x35f4>)
42016325:	ab17c1        	l32r	a12, 42000f84 <_stext+0xf64> (3c027e08 <__func__$0>)
42016328:	50a1b2        	movi	a11, 0x150
4201632b:	ab0fa1        	l32r	a10, 42000f68 <_stext+0xf48> (3c023709 <_flash_rodata_start+0x35e9>)
4201632e:	a76481        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016331:	0008e0        	callx8	a8
    return EFUSE.rd_mac_spi_sys_4.k_rtc_ldo;
42016334:	ab0e81        	l32r	a8, 42000f6c <_stext+0xf4c> (60007000 <EFUSE>)
42016337:	0020c0        	memw
4201633a:	1528c2        	l32i	a12, a8, 84
4201633d:	64cdc0        	extui	a12, a12, 13, 7
    return EFUSE.rd_mac_spi_sys_4.k_dig_ldo;
42016340:	0020c0        	memw
42016343:	1528b2        	l32i	a11, a8, 84
42016346:	65b4b0        	extui	a11, a11, 20, 7
    return (EFUSE.rd_mac_spi_sys_5.v_rtc_dbias20_1 << 5) + EFUSE.rd_mac_spi_sys_4.v_rtc_dbias20;
42016349:	0020c0        	memw
4201634c:	1628a2        	l32i	a10, a8, 88
4201634f:	24a0a0        	extui	a10, a10, 0, 3
42016352:	11aab0        	slli	a10, a10, 5
42016355:	0020c0        	memw
42016358:	152892        	l32i	a9, a8, 84
4201635b:	459b90        	extui	a9, a9, 27, 5
4201635e:	aa9a      	add.n	a10, a10, a9
    return EFUSE.rd_mac_spi_sys_5.v_dig_dbias20;
42016360:	0020c0        	memw
42016363:	162882        	l32i	a8, a8, 88
42016366:	749380        	extui	a9, a8, 3, 8
42016369:	098d      	mov.n	a8, a9
    k_rtc_ldo =  ((k_rtc_ldo & BIT(6)) != 0)? -(k_rtc_ldo & 0x3f): (uint8_t)k_rtc_ldo;
4201636b:	fd3c      	movi.n	a13, 63
4201636d:	05bdc7        	bgeu	a13, a12, 42016376 <get_rtc_dbias_by_efuse+0x5a>
42016370:	10ccd0        	and	a12, a12, a13
42016373:	60c0c0        	neg	a12, a12
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
42016376:	fd3c      	movi.n	a13, 63
42016378:	05bdb7        	bgeu	a13, a11, 42016381 <get_rtc_dbias_by_efuse+0x65>
4201637b:	10bbd0        	and	a11, a11, a13
4201637e:	60b0b0        	neg	a11, a11
    v_rtc_bias20 =  ((v_rtc_bias20 & BIT(7)) != 0)? -(v_rtc_bias20 & 0x7f): (uint8_t)v_rtc_bias20;
42016381:	086a77        	bbci	a10, 7, 4201638d <get_rtc_dbias_by_efuse+0x71>
42016384:	64a0a0        	extui	a10, a10, 0, 7
42016387:	60a0a0        	neg	a10, a10
4201638a:	000086        	j	42016390 <get_rtc_dbias_by_efuse+0x74>
4201638d:	74a0a0        	extui	a10, a10, 0, 8
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
42016390:	056977        	bbci	a9, 7, 42016399 <get_rtc_dbias_by_efuse+0x7d>
42016393:	648080        	extui	a8, a8, 0, 7
42016396:	608080        	neg	a8, a8
    uint32_t v_rtc_dbias20_real_mul10000 = V_RTC_MID_MUL10000 + v_rtc_bias20 * 10000 / 500;
42016399:	a0aaa0        	addx4	a10, a10, a10
4201639c:	aafb91        	l32r	a9, 42000f88 <_stext+0xf68> (27c5 <UserFrameTotalSize+0x26c5>)
4201639f:	a0aa90        	addx4	a10, a10, a9
    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
420163a2:	a08880        	addx4	a8, a8, a8
420163a5:	aaf491        	l32r	a9, 42000f78 <_stext+0xf58> (2a59 <UserFrameTotalSize+0x2959>)
420163a8:	a08890        	addx4	a8, a8, a9
    signed int k_rtc_ldo_real_mul10000 = K_RTC_MID_MUL10000 + k_rtc_ldo;
420163ab:	c6a092        	movi	a9, 198
420163ae:	cc9a      	add.n	a12, a12, a9
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
420163b0:	d3a092        	movi	a9, 211
420163b3:	bb9a      	add.n	a11, a11, a9
    uint32_t v_dig_nearest_1v15_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
420163b5:	ecc332        	addi	a3, a3, -20
420163b8:	82bb30        	mull	a11, a11, a3
420163bb:	bb8a      	add.n	a11, a11, a8
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
420163bd:	f20c      	movi.n	a2, 15
420163bf:	000506        	j	420163d7 <get_rtc_dbias_by_efuse+0xbb>
420163c2:	000000        	ill
        v_rtc_nearest_1v15_mul10000 = v_rtc_dbias20_real_mul10000 + k_rtc_ldo_real_mul10000 * (rtc_dbias - 20);
420163c5:	ecc282        	addi	a8, a2, -20
420163c8:	828c80        	mull	a8, a12, a8
420163cb:	88aa      	add.n	a8, a8, a10
        if (v_rtc_nearest_1v15_mul10000 >= v_dig_nearest_1v15_mul10000 - 250) {
420163cd:	06af92        	movi	a9, -250
420163d0:	9b9a      	add.n	a9, a11, a9
420163d2:	06b897        	bgeu	a8, a9, 420163dc <get_rtc_dbias_by_efuse+0xc0>
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
420163d5:	221b      	addi.n	a2, a2, 1
420163d7:	e81c      	movi.n	a8, 30
420163d9:	e8b827        	bgeu	a8, a2, 420163c5 <get_rtc_dbias_by_efuse+0xa9>
}
420163dc:	f01d      	retw.n
	...

420163e0 <rtc_set_stored_dbias>:

static void rtc_set_stored_dbias(void)
{
420163e0:	004136        	entry	a1, 32
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
420163e3:	aae281        	l32r	a8, 42000f6c <_stext+0xf4c> (60007000 <EFUSE>)
420163e6:	0020c0        	memw
420163e9:	1428b2        	l32i	a11, a8, 80
420163ec:	25b8b0        	extui	a11, a11, 24, 3
    return EFUSE.rd_sys_part1_data4.blk_version_major;
420163ef:	0020c0        	memw
420163f2:	1b2892        	l32i	a9, a8, 108
420163f5:	149090        	extui	a9, a9, 0, 2
    4. save these values for reuse
    */
    uint8_t blk_minor = efuse_ll_get_blk_version_minor();
    uint8_t blk_major = efuse_ll_get_blk_version_major();
    uint8_t pvt_scheme_ver = 0;
    if ( (blk_major <= 1 && blk_minor == 1) || blk_major > 1 || (blk_major == 1 && blk_minor >= 2) ) {
420163f8:	180c      	movi.n	a8, 1
420163fa:	628890        	lsi	f9, a8, 0x188
420163fd:	880b      	addi.n	a8, a8, -1
420163ff:	608080        	neg	a8, a8
42016402:	ab0b      	addi.n	a10, a11, -1
42016404:	40faa0        	nsau	a10, a10
42016407:	41a5a0        	srli	a10, a10, 5
4201640a:	1288a7        	bany	a8, a10, 42016420 <rtc_set_stored_dbias+0x40>
4201640d:	0f29f6        	bgeui	a9, 2, 42016420 <rtc_set_stored_dbias+0x40>
42016410:	990b      	addi.n	a9, a9, -1
42016412:	40f990        	nsau	a9, a9
42016415:	419590        	srli	a9, a9, 5
42016418:	180c      	movi.n	a8, 1
4201641a:	6288b0        	lsi	f11, a8, 0x188
4201641d:	380987        	bnone	a9, a8, 42016459 <rtc_set_stored_dbias+0x79>
        /* PVT supported after blk_ver 1.2 */
        pvt_scheme_ver = 1;
    }

    if (pvt_scheme_ver == 1) {
        uint32_t dig1v3_dbias = get_dig1v3_dbias_by_efuse(pvt_scheme_ver);
42016420:	1a0c      	movi.n	a10, 1
42016422:	ffe625        	call8	42016284 <get_dig1v3_dbias_by_efuse>
42016425:	0a7d      	mov.n	a7, a10
        uint32_t dig_dbias = get_dig_dbias_by_efuse(pvt_scheme_ver);
42016427:	1a0c      	movi.n	a10, 1
42016429:	ffeca5        	call8	420162f4 <get_dig_dbias_by_efuse>
        if (dig_dbias != 0) {
4201642c:	9aac      	beqz.n	a10, 42016459 <rtc_set_stored_dbias+0x79>
            g_dig_dbias_pvt_240m = MIN(dig1v3_dbias, dig_dbias + 3);
4201642e:	ba3b      	addi.n	a11, a10, 3
42016430:	63bb70        	minu	a11, a11, a7
42016433:	aad681        	l32r	a8, 42000f8c <_stext+0xf6c> (3fc92074 <g_dig_dbias_pvt_240m>)
42016436:	08b9      	s32i.n	a11, a8, 0
            g_dig_dbias_pvt_non_240m = MIN(dig1v3_dbias, dig_dbias + 2);
42016438:	8a2b      	addi.n	a8, a10, 2
4201643a:	63a870        	minu	a10, a8, a7
4201643d:	aad471        	l32r	a7, 42000f90 <_stext+0xf70> (3fc9206c <g_dig_dbias_pvt_non_240m>)
42016440:	07a9      	s32i.n	a10, a7, 0
            g_rtc_dbias_pvt_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_240m);
42016442:	01a0a2        	movi	a10, 1
42016445:	ffed65        	call8	4201631c <get_rtc_dbias_by_efuse>
42016448:	aad381        	l32r	a8, 42000f94 <_stext+0xf74> (3fc92070 <g_rtc_dbias_pvt_240m>)
4201644b:	08a9      	s32i.n	a10, a8, 0
            g_rtc_dbias_pvt_non_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_non_240m);
4201644d:	07b8      	l32i.n	a11, a7, 0
4201644f:	1a0c      	movi.n	a10, 1
42016451:	ffeca5        	call8	4201631c <get_rtc_dbias_by_efuse>
42016454:	aad181        	l32r	a8, 42000f98 <_stext+0xf78> (3fc92068 <g_rtc_dbias_pvt_non_240m>)
42016457:	08a9      	s32i.n	a10, a8, 0
            ESP_HW_LOGD(TAG, "not burn core voltage in efuse or burn wrong voltage value in blk version: 0%d\n", pvt_scheme_ver);
        }
    } else {
        ESP_HW_LOGD(TAG, "core voltage not decided in efuse, use default value.");
    }
}
42016459:	f01d      	retw.n
	...

4201645c <calibrate_ocode>:
{
4201645c:	006136        	entry	a1, 48
    mspi_timing_change_speed_mode_cache_safe(true);
4201645f:	01a0a2        	movi	a10, 1
42016462:	aad081        	l32r	a8, 42000fa4 <_stext+0xf84> (403784a4 <mspi_timing_change_speed_mode_cache_safe>)
42016465:	0008e0        	callx8	a8
    soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
42016468:	aad081        	l32r	a8, 42000fa8 <_stext+0xf88> (40378a04 <rtc_clk_slow_src_get>)
4201646b:	0008e0        	callx8	a8
    if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
4201646e:	071a26        	beqi	a10, 1, 42016479 <calibrate_ocode+0x1d>
    } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
42016471:	092a26        	beqi	a10, 2, 4201647e <calibrate_ocode+0x22>
    rtc_cal_sel_t cal_clk = RTC_CAL_RTC_MUX;
42016474:	0a0c      	movi.n	a10, 0
42016476:	000186        	j	42016480 <calibrate_ocode+0x24>
        cal_clk = RTC_CAL_32K_XTAL;
42016479:	2a0c      	movi.n	a10, 2
4201647b:	000046        	j	42016480 <calibrate_ocode+0x24>
        cal_clk  = RTC_CAL_8MD256;
4201647e:	1a0c      	movi.n	a10, 1
    uint32_t slow_clk_period = rtc_clk_cal(cal_clk, 100);
42016480:	64a0b2        	movi	a11, 100
42016483:	a72781        	l32r	a8, 42000120 <_stext+0x100> (403792f4 <rtc_clk_cal>)
42016486:	0008e0        	callx8	a8
    uint64_t max_delay_cycle = rtc_time_us_to_slowclk(max_delay_time_us, slow_clk_period);
42016489:	0acd      	mov.n	a12, a10
4201648b:	a76aa1        	l32r	a10, 42000234 <_stext+0x214> (2710 <UserFrameTotalSize+0x2610>)
4201648e:	0b0c      	movi.n	a11, 0
42016490:	aac781        	l32r	a8, 42000fac <_stext+0xf8c> (403793bc <rtc_time_us_to_slowclk>)
42016493:	0008e0        	callx8	a8
42016496:	0a4d      	mov.n	a4, a10
42016498:	0b5d      	mov.n	a5, a11
    uint64_t cycle0 = rtc_time_get();
4201649a:	a81d81        	l32r	a8, 42000510 <_stext+0x4f0> (403793f0 <rtc_time_get>)
4201649d:	0008e0        	callx8	a8
    uint64_t timeout_cycle = cycle0 + max_delay_cycle;
420164a0:	55ba      	add.n	a5, a5, a11
420164a2:	44aa      	add.n	a4, a4, a10
420164a4:	01b4a7        	bgeu	a4, a10, 420164a9 <calibrate_ocode+0x4d>
420164a7:	551b      	addi.n	a5, a5, 1
    rtc_clk_cpu_freq_get_config(&old_config);
420164a9:	01ad      	mov.n	a10, a1
420164ab:	a73081        	l32r	a8, 4200016c <_stext+0x14c> (40378b44 <rtc_clk_cpu_freq_get_config>)
420164ae:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_set_xtal();
420164b1:	aabf81        	l32r	a8, 42000fb0 <_stext+0xf90> (40378f10 <rtc_clk_cpu_freq_set_xtal>)
420164b4:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 0);
420164b7:	0f0c      	movi.n	a15, 0
420164b9:	0fed      	mov.n	a14, a15
420164bb:	0fdd      	mov.n	a13, a15
420164bd:	0fcd      	mov.n	a12, a15
420164bf:	1b0c      	movi.n	a11, 1
420164c1:	61a0a2        	movi	a10, 97
420164c4:	a7d881        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420164c7:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 1);
420164ca:	1f0c      	movi.n	a15, 1
420164cc:	0e0c      	movi.n	a14, 0
420164ce:	0edd      	mov.n	a13, a14
420164d0:	0ecd      	mov.n	a12, a14
420164d2:	0fbd      	mov.n	a11, a15
420164d4:	61a0a2        	movi	a10, 97
420164d7:	a7d381        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420164da:	0008e0        	callx8	a8
        odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_O_DONE_FLAG);
420164dd:	0e0c      	movi.n	a14, 0
420164df:	0edd      	mov.n	a13, a14
420164e1:	3c0c      	movi.n	a12, 3
420164e3:	1b0c      	movi.n	a11, 1
420164e5:	61a0a2        	movi	a10, 97
420164e8:	aab381        	l32r	a8, 42000fb4 <_stext+0xf94> (40376784 <regi2c_ctrl_read_reg_mask>)
420164eb:	0008e0        	callx8	a8
420164ee:	160c      	movi.n	a6, 1
420164f0:	836aa0        	moveqz	a6, a10, a10
        bg_odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_BG_O_DONE_FLAG);
420164f3:	3e0c      	movi.n	a14, 3
420164f5:	0edd      	mov.n	a13, a14
420164f7:	0ecd      	mov.n	a12, a14
420164f9:	01a0b2        	movi	a11, 1
420164fc:	61a0a2        	movi	a10, 97
420164ff:	aaad81        	l32r	a8, 42000fb4 <_stext+0xf94> (40376784 <regi2c_ctrl_read_reg_mask>)
42016502:	0008e0        	callx8	a8
42016505:	170c      	movi.n	a7, 1
42016507:	837aa0        	moveqz	a7, a10, a10
        cycle1 = rtc_time_get();
4201650a:	a80181        	l32r	a8, 42000510 <_stext+0x4f0> (403793f0 <rtc_time_get>)
4201650d:	0008e0        	callx8	a8
        if (odone_flag && bg_odone_flag) {
42016510:	248677        	bany	a6, a7, 42016538 <calibrate_ocode+0xdc>
        if (cycle1 >= timeout_cycle) {
42016513:	c63b57        	bltu	a11, a5, 420164dd <calibrate_ocode+0x81>
42016516:	0295b7        	bne	a5, a11, 4201651c <calibrate_ocode+0xc0>
42016519:	c03a47        	bltu	a10, a4, 420164dd <calibrate_ocode+0x81>
4201651c:	a6c481        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
4201651f:	0888      	l32i.n	a8, a8, 0
            ESP_HW_LOGW(TAG, "o_code calibration fail\n");
42016521:	1328b6        	bltui	a8, 2, 42016538 <calibrate_ocode+0xdc>
42016524:	a6cf81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42016527:	0008e0        	callx8	a8
4201652a:	aa9cc1        	l32r	a12, 42000f9c <_stext+0xf7c> (3c023728 <_flash_rodata_start+0x3608>)
4201652d:	0abd      	mov.n	a11, a10
4201652f:	aa9ca1        	l32r	a10, 42000fa0 <_stext+0xf80> (3c023730 <_flash_rodata_start+0x3610>)
42016532:	a6cc81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42016535:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_set_config(&old_config);
42016538:	01ad      	mov.n	a10, a1
4201653a:	a70f81        	l32r	a8, 42000178 <_stext+0x158> (40378ea0 <rtc_clk_cpu_freq_set_config>)
4201653d:	0008e0        	callx8	a8
    mspi_timing_change_speed_mode_cache_safe(false);
42016540:	0a0c      	movi.n	a10, 0
42016542:	aa9881        	l32r	a8, 42000fa4 <_stext+0xf84> (403784a4 <mspi_timing_change_speed_mode_cache_safe>)
42016545:	0008e0        	callx8	a8
}
42016548:	f01d      	retw.n
	...

4201654c <rtc_init>:
{
4201654c:	006136        	entry	a1, 48
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
4201654f:	aa9a91        	l32r	a9, 42000fb8 <_stext+0xf98> (60008090 <RTCCNTL+0x90>)
42016552:	0020c0        	memw
42016555:	0988      	l32i.n	a8, a9, 0
42016557:	aa99a1        	l32r	a10, 42000fbc <_stext+0xf9c> (fffdffff <_rtc_reserved_end+0x9fedffff>)
4201655a:	1088a0        	and	a8, a8, a10
4201655d:	0020c0        	memw
42016560:	0989      	s32i.n	a8, a9, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_ISO);
42016562:	aa9791        	l32r	a9, 42000fc0 <_stext+0xfa0> (60008094 <RTCCNTL+0x94>)
42016565:	0020c0        	memw
42016568:	0988      	l32i.n	a8, a9, 0
4201656a:	a7afa1        	l32r	a10, 42000428 <_stext+0x408> (efffffff <_rtc_reserved_end+0x8fefffff>)
4201656d:	1088a0        	and	a8, a8, a10
42016570:	0020c0        	memw
42016573:	0989      	s32i.n	a8, a9, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_RTC_REG, 0);
42016575:	0f0c      	movi.n	a15, 0
42016577:	2e0c      	movi.n	a14, 2
42016579:	0edd      	mov.n	a13, a14
4201657b:	dc0c      	movi.n	a12, 13
4201657d:	1b0c      	movi.n	a11, 1
4201657f:	6da0a2        	movi	a10, 109
42016582:	a7a881        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42016585:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_DIG_REG, 0);
42016588:	0f0c      	movi.n	a15, 0
4201658a:	3e0c      	movi.n	a14, 3
4201658c:	0edd      	mov.n	a13, a14
4201658e:	dc0c      	movi.n	a12, 13
42016590:	01a0b2        	movi	a11, 1
42016593:	6da0a2        	movi	a10, 109
42016596:	a7a381        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42016599:	0008e0        	callx8	a8
    CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_PVTMON_PU);
4201659c:	aa8a91        	l32r	a9, 42000fc4 <_stext+0xfa4> (60008034 <RTCCNTL+0x34>)
4201659f:	0020c0        	memw
420165a2:	0988      	l32i.n	a8, a9, 0
420165a4:	a7a6a1        	l32r	a10, 4200043c <_stext+0x41c> (fbffffff <_rtc_reserved_end+0x9befffff>)
420165a7:	1088a0        	and	a8, a8, a10
420165aa:	0020c0        	memw
420165ad:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_PLL_BUF_WAIT, cfg.pll_wait);
420165af:	aa8691        	l32r	a9, 42000fc8 <_stext+0xfa8> (6000801c <RTCCNTL+0x1c>)
420165b2:	0020c0        	memw
420165b5:	0988      	l32i.n	a8, a9, 0
420165b7:	118880        	slli	a8, a8, 8
420165ba:	418880        	srli	a8, a8, 8
420165bd:	75a020        	extui	a10, a2, 16, 8
420165c0:	01aa80        	slli	a10, a10, 24
420165c3:	2088a0        	or	a8, a8, a10
420165c6:	0020c0        	memw
420165c9:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, cfg.ck8m_wait);
420165cb:	0020c0        	memw
420165ce:	0988      	l32i.n	a8, a9, 0
420165d0:	aa7fa1        	l32r	a10, 42000fcc <_stext+0xfac> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
420165d3:	1088a0        	and	a8, a8, a10
420165d6:	74a020        	extui	a10, a2, 0, 8
420165d9:	11aaa0        	slli	a10, a10, 6
420165dc:	2088a0        	or	a8, a8, a10
420165df:	0020c0        	memw
420165e2:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER5_REG, RTC_CNTL_MIN_SLP_VAL, RTC_CNTL_MIN_SLP_VAL_MIN);
420165e4:	aa7b91        	l32r	a9, 42000fd0 <_stext+0xfb0> (6000802c <RTCCNTL+0x2c>)
420165e7:	0020c0        	memw
420165ea:	0988      	l32i.n	a8, a9, 0
420165ec:	aa7aa1        	l32r	a10, 42000fd4 <_stext+0xfb4> (ffff00ff <_rtc_reserved_end+0x9fef00ff>)
420165ef:	1088a0        	and	a8, a8, a10
420165f2:	00a2a2        	movi	a10, 0x200
420165f5:	2088a0        	or	a8, a8, a10
420165f8:	0020c0        	memw
420165fb:	0989      	s32i.n	a8, a9, 0
    rtc_init_config_t rtc_init_cfg = RTC_INIT_CONFIG_DEFAULT();
420165fd:	aa7681        	l32r	a8, 42000fd8 <_stext+0xfb8> (3c027df8 <__func__$2+0x18>)
42016600:	0898      	l32i.n	a9, a8, 0
42016602:	18b8      	l32i.n	a11, a8, 4
42016604:	0199      	s32i.n	a9, a1, 0
42016606:	28a8      	l32i.n	a10, a8, 8
42016608:	11b9      	s32i.n	a11, a1, 4
4201660a:	061882        	l16ui	a8, a8, 12
4201660d:	21a9      	s32i.n	a10, a1, 8
4201660f:	065182        	s16i	a8, a1, 12
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_POWERUP_TIMER, rtc_init_cfg.wifi_powerup_cycles);
42016612:	aa7281        	l32r	a8, 42000fdc <_stext+0xfbc> (60008024 <RTCCNTL+0x24>)
42016615:	0020c0        	memw
42016618:	08a8      	l32i.n	a10, a8, 0
4201661a:	aa71c1        	l32r	a12, 42000fe0 <_stext+0xfc0> (ffff01ff <_rtc_reserved_end+0x9fef01ff>)
4201661d:	10aac0        	and	a10, a10, a12
42016620:	649090        	extui	a9, a9, 0, 7
42016623:	119970        	slli	a9, a9, 9
42016626:	209a90        	or	a9, a10, a9
42016629:	0020c0        	memw
4201662c:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_WAIT_TIMER, rtc_init_cfg.wifi_wait_cycles);
4201662e:	0020c0        	memw
42016631:	0898      	l32i.n	a9, a8, 0
42016633:	00aee2        	movi	a14, 0xfffffe00
42016636:	1099e0        	and	a9, a9, a14
42016639:	01a8      	l32i.n	a10, a1, 0
4201663b:	84a7a0        	extui	a10, a10, 7, 9
4201663e:	2099a0        	or	a9, a9, a10
42016641:	0020c0        	memw
42016644:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_POWERUP_TIMER, rtc_init_cfg.bt_powerup_cycles);
42016646:	0020c0        	memw
42016649:	0898      	l32i.n	a9, a8, 0
4201664b:	a724d1        	l32r	a13, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4201664e:	1099d0        	and	a9, a9, a13
42016651:	01a8      	l32i.n	a10, a1, 0
42016653:	65a0a0        	extui	a10, a10, 16, 7
42016656:	01aa70        	slli	a10, a10, 25
42016659:	2099a0        	or	a9, a9, a10
4201665c:	0020c0        	memw
4201665f:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_WAIT_TIMER, rtc_init_cfg.bt_wait_cycles);
42016661:	0020c0        	memw
42016664:	0898      	l32i.n	a9, a8, 0
42016666:	aa5fb1        	l32r	a11, 42000fe4 <_stext+0xfc4> (fe00ffff <_rtc_reserved_end+0x9df0ffff>)
42016669:	1099b0        	and	a9, a9, a11
4201666c:	01a8      	l32i.n	a10, a1, 0
4201666e:	85a7a0        	extui	a10, a10, 23, 9
42016671:	11aa00        	slli	a10, a10, 16
42016674:	2099a0        	or	a9, a9, a10
42016677:	0020c0        	memw
4201667a:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_POWERUP_TIMER, rtc_init_cfg.cpu_top_powerup_cycles);
4201667c:	aa5b81        	l32r	a8, 42000fe8 <_stext+0xfc8> (60008030 <RTCCNTL+0x30>)
4201667f:	0020c0        	memw
42016682:	0898      	l32i.n	a9, a8, 0
42016684:	1099c0        	and	a9, a9, a12
42016687:	11a8      	l32i.n	a10, a1, 4
42016689:	65a0a0        	extui	a10, a10, 16, 7
4201668c:	11aa70        	slli	a10, a10, 9
4201668f:	2099a0        	or	a9, a9, a10
42016692:	0020c0        	memw
42016695:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_WAIT_TIMER, rtc_init_cfg.cpu_top_wait_cycles);
42016697:	0020c0        	memw
4201669a:	0898      	l32i.n	a9, a8, 0
4201669c:	1099e0        	and	a9, a9, a14
4201669f:	11a8      	l32i.n	a10, a1, 4
420166a1:	85a7a0        	extui	a10, a10, 23, 9
420166a4:	2099a0        	or	a9, a9, a10
420166a7:	0020c0        	memw
420166aa:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_POWERUP_TIMER, rtc_init_cfg.rtc_powerup_cycles);
420166ac:	aa5091        	l32r	a9, 42000fec <_stext+0xfcc> (60008028 <RTCCNTL+0x28>)
420166af:	0020c0        	memw
420166b2:	09a8      	l32i.n	a10, a9, 0
420166b4:	10aac0        	and	a10, a10, a12
420166b7:	11c8      	l32i.n	a12, a1, 4
420166b9:	64c0c0        	extui	a12, a12, 0, 7
420166bc:	11cc70        	slli	a12, a12, 9
420166bf:	20aac0        	or	a10, a10, a12
420166c2:	0020c0        	memw
420166c5:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_WAIT_TIMER, rtc_init_cfg.rtc_wait_cycles);
420166c7:	0020c0        	memw
420166ca:	09a8      	l32i.n	a10, a9, 0
420166cc:	10aae0        	and	a10, a10, a14
420166cf:	11c8      	l32i.n	a12, a1, 4
420166d1:	84c7c0        	extui	a12, a12, 7, 9
420166d4:	20aac0        	or	a10, a10, a12
420166d7:	0020c0        	memw
420166da:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_POWERUP_TIMER, rtc_init_cfg.dg_wrap_powerup_cycles);
420166dc:	0020c0        	memw
420166df:	09a8      	l32i.n	a10, a9, 0
420166e1:	10aad0        	and	a10, a10, a13
420166e4:	21c8      	l32i.n	a12, a1, 8
420166e6:	01cc70        	slli	a12, a12, 25
420166e9:	20aac0        	or	a10, a10, a12
420166ec:	0020c0        	memw
420166ef:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_WAIT_TIMER, rtc_init_cfg.dg_wrap_wait_cycles);
420166f1:	0020c0        	memw
420166f4:	09a8      	l32i.n	a10, a9, 0
420166f6:	10aab0        	and	a10, a10, a11
420166f9:	21c8      	l32i.n	a12, a1, 8
420166fb:	84c7c0        	extui	a12, a12, 7, 9
420166fe:	11cc00        	slli	a12, a12, 16
42016701:	20aac0        	or	a10, a10, a12
42016704:	0020c0        	memw
42016707:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_POWERUP_TIMER, rtc_init_cfg.dg_peri_powerup_cycles);
42016709:	0020c0        	memw
4201670c:	0898      	l32i.n	a9, a8, 0
4201670e:	1099d0        	and	a9, a9, a13
42016711:	21a8      	l32i.n	a10, a1, 8
42016713:	65a0a0        	extui	a10, a10, 16, 7
42016716:	01aa70        	slli	a10, a10, 25
42016719:	2099a0        	or	a9, a9, a10
4201671c:	0020c0        	memw
4201671f:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_WAIT_TIMER, rtc_init_cfg.dg_peri_wait_cycles);
42016721:	0020c0        	memw
42016724:	0898      	l32i.n	a9, a8, 0
42016726:	1099b0        	and	a9, a9, a11
42016729:	21a8      	l32i.n	a10, a1, 8
4201672b:	85a7a0        	extui	a10, a10, 23, 9
4201672e:	11aa00        	slli	a10, a10, 16
42016731:	2099a0        	or	a9, a9, a10
42016734:	0020c0        	memw
42016737:	0899      	s32i.n	a9, a8, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG_SLEEP, RTC_CNTL_DBIAS_1V10);
42016739:	7f1c      	movi.n	a15, 23
4201673b:	0e0c      	movi.n	a14, 0
4201673d:	4d0c      	movi.n	a13, 4
4201673f:	5c0c      	movi.n	a12, 5
42016741:	1b0c      	movi.n	a11, 1
42016743:	6da0a2        	movi	a10, 109
42016746:	a73781        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42016749:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, RTC_CNTL_DBIAS_1V10);
4201674c:	7f1c      	movi.n	a15, 23
4201674e:	0e0c      	movi.n	a14, 0
42016750:	4d0c      	movi.n	a13, 4
42016752:	0dcd      	mov.n	a12, a13
42016754:	1b0c      	movi.n	a11, 1
42016756:	6da0a2        	movi	a10, 109
42016759:	a73281        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
4201675c:	0008e0        	callx8	a8
    REG_SET_FIELD(RTC_CNTL_TIMER2_REG, RTC_CNTL_ULPCP_TOUCH_START_WAIT, RTC_CNTL_ULPCP_TOUCH_START_WAIT_DEFAULT);
4201675f:	aa2491        	l32r	a9, 42000ff0 <_stext+0xfd0> (60008020 <RTCCNTL+0x20>)
42016762:	0020c0        	memw
42016765:	0988      	l32i.n	a8, a9, 0
42016767:	aa23a1        	l32r	a10, 42000ff4 <_stext+0xfd4> (ff007fff <_rtc_reserved_end+0x9ef07fff>)
4201676a:	1088a0        	and	a8, a8, a10
4201676d:	a9efa1        	l32r	a10, 42000f2c <_stext+0xf0c> (80000 <UserFrameTotalSize+0x7ff00>)
42016770:	2088a0        	or	a8, a8, a10
42016773:	0020c0        	memw
42016776:	0989      	s32i.n	a8, a9, 0
    if (cfg.cali_ocode) {
42016778:	1872e7        	bbci	a2, 30, 42016794 <rtc_init+0x248>
4201677b:	a9fc81        	l32r	a8, 42000f6c <_stext+0xf4c> (60007000 <EFUSE>)
4201677e:	0020c0        	memw
42016781:	1b28a2        	l32i	a10, a8, 108
42016784:	14a0a0        	extui	a10, a10, 0, 2
        if (ocode_efuse_cali) {
42016787:	061a66        	bnei	a10, 1, 42016791 <rtc_init+0x245>
            set_ocode_by_efuse(blk_ver_major);
4201678a:	ffaae5        	call8	42016238 <set_ocode_by_efuse>
4201678d:	0000c6        	j	42016794 <rtc_init+0x248>
42016790:	cca500        	lsi	f0, a5, 0x330
            calibrate_ocode();
42016793:	ff          	.byte	0xff
    rtc_set_stored_dbias();
42016794:	ffc4a5        	call8	420163e0 <rtc_set_stored_dbias>
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
42016797:	aa0081        	l32r	a8, 42000f98 <_stext+0xf78> (3fc92068 <g_rtc_dbias_pvt_non_240m>)
4201679a:	0008f2        	l8ui	a15, a8, 0
4201679d:	0e0c      	movi.n	a14, 0
4201679f:	4d0c      	movi.n	a13, 4
420167a1:	0dcd      	mov.n	a12, a13
420167a3:	1b0c      	movi.n	a11, 1
420167a5:	6da0a2        	movi	a10, 109
420167a8:	a71f81        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420167ab:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
420167ae:	a9f881        	l32r	a8, 42000f90 <_stext+0xf70> (3fc9206c <g_dig_dbias_pvt_non_240m>)
420167b1:	0008f2        	l8ui	a15, a8, 0
420167b4:	0e0c      	movi.n	a14, 0
420167b6:	4d0c      	movi.n	a13, 4
420167b8:	6c0c      	movi.n	a12, 6
420167ba:	1b0c      	movi.n	a11, 1
420167bc:	6da0a2        	movi	a10, 109
420167bf:	a71981        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420167c2:	0008e0        	callx8	a8
    if (cfg.clkctl_init) {
420167c5:	5b7287        	bbci	a2, 24, 42016824 <rtc_init+0x2d8>
        CLEAR_PERI_REG_MASK(EXTMEM_CACHE_MMU_POWER_CTRL_REG, EXTMEM_CACHE_MMU_MEM_FORCE_ON);
420167c8:	aa0ca1        	l32r	a10, 42000ff8 <_stext+0xfd8> (600c412c <SYSTEM+0x412c>)
420167cb:	0020c0        	memw
420167ce:	0a98      	l32i.n	a9, a10, 0
420167d0:	e87c      	movi.n	a8, -2
420167d2:	109980        	and	a9, a9, a8
420167d5:	0020c0        	memw
420167d8:	0a99      	s32i.n	a9, a10, 0
        REG_WRITE(SYSCON_CLKGATE_FORCE_ON_REG, 0);
420167da:	aa0891        	l32r	a9, 42000ffc <_stext+0xfdc> (600260a8 <SYSCON+0xa8>)
420167dd:	0a0c      	movi.n	a10, 0
420167df:	0020c0        	memw
420167e2:	09a9      	s32i.n	a10, a9, 0
        CLEAR_PERI_REG_MASK(EXTMEM_DCACHE_TAG_POWER_CTRL_REG, EXTMEM_DCACHE_TAG_MEM_FORCE_ON);
420167e4:	aa07a1        	l32r	a10, 42001000 <_stext+0xfe0> (600c4008 <SYSTEM+0x4008>)
420167e7:	0020c0        	memw
420167ea:	0a98      	l32i.n	a9, a10, 0
420167ec:	109980        	and	a9, a9, a8
420167ef:	0020c0        	memw
420167f2:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(EXTMEM_ICACHE_TAG_POWER_CTRL_REG, EXTMEM_ICACHE_TAG_MEM_FORCE_ON);
420167f4:	aa04a1        	l32r	a10, 42001004 <_stext+0xfe4> (600c4068 <SYSTEM+0x4068>)
420167f7:	0020c0        	memw
420167fa:	0a98      	l32i.n	a9, a10, 0
420167fc:	109980        	and	a9, a9, a8
420167ff:	0020c0        	memw
42016802:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(0), SPI_MEM_CLK_EN);
42016804:	aa01a1        	l32r	a10, 42001008 <_stext+0xfe8> (600030e8 <SPIMEM0+0xe8>)
42016807:	0020c0        	memw
4201680a:	0a98      	l32i.n	a9, a10, 0
4201680c:	109980        	and	a9, a9, a8
4201680f:	0020c0        	memw
42016812:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(1), SPI_MEM_CLK_EN);
42016814:	a9fea1        	l32r	a10, 4200100c <_stext+0xfec> (600020e8 <SPIMEM1+0xe8>)
42016817:	0020c0        	memw
4201681a:	0a98      	l32i.n	a9, a10, 0
4201681c:	108980        	and	a8, a9, a8
4201681f:	0020c0        	memw
42016822:	0a89      	s32i.n	a8, a10, 0
    if (cfg.pwrctl_init) {
42016824:	02f297        	bbsi	a2, 25, 4201682a <rtc_init+0x2de>
42016827:	00a206        	j	42016ab3 <rtc_init+0x567>
        CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_CK8M_FORCE_PU);
4201682a:	a9f991        	l32r	a9, 42001010 <_stext+0xff0> (60008074 <RTCCNTL+0x74>)
4201682d:	0020c0        	memw
42016830:	0988      	l32i.n	a8, a9, 0
42016832:	a702a1        	l32r	a10, 4200043c <_stext+0x41c> (fbffffff <_rtc_reserved_end+0x9befffff>)
42016835:	1088a0        	and	a8, a8, a10
42016838:	0020c0        	memw
4201683b:	0989      	s32i.n	a8, a9, 0
        if (!(cfg.xtal_fpu | cfg.bbpll_fpu)) {
4201683d:	058b20        	extui	a8, a2, 27, 1
42016840:	059c20        	extui	a9, a2, 28, 1
42016843:	208890        	or	a8, a8, a9
42016846:	68dc      	bnez.n	a8, 42016860 <rtc_init+0x314>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
42016848:	a9f391        	l32r	a9, 42001014 <_stext+0xff4> (60008000 <RTCCNTL>)
4201684b:	0020c0        	memw
4201684e:	0988      	l32i.n	a8, a9, 0
42016850:	a9f2a1        	l32r	a10, 42001018 <_stext+0xff8> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
42016853:	1088a0        	and	a8, a8, a10
42016856:	0020c0        	memw
42016859:	0989      	s32i.n	a8, a9, 0
4201685b:	000506        	j	42016873 <rtc_init+0x327>
4201685e:	910000        	srl	a0, a0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
42016861:	a9ed      	lsi	f14, a9, 36
42016863:	0020c0        	memw
42016866:	0988      	l32i.n	a8, a9, 0
42016868:	a7f9a1        	l32r	a10, 4200084c <_stext+0x82c> (2000 <UserFrameTotalSize+0x1f00>)
4201686b:	2088a0        	or	a8, a8, a10
4201686e:	0020c0        	memw
42016871:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
42016873:	a9d491        	l32r	a9, 42000fc4 <_stext+0xfa4> (60008034 <RTCCNTL+0x34>)
42016876:	0020c0        	memw
42016879:	0988      	l32i.n	a8, a9, 0
4201687b:	a9e8a1        	l32r	a10, 4200101c <_stext+0xffc> (fffbffff <_rtc_reserved_end+0x9febffff>)
4201687e:	1088a0        	and	a8, a8, a10
42016881:	0020c0        	memw
42016884:	0989      	s32i.n	a8, a9, 0
        if (!cfg.bbpll_fpu) {
42016886:	36f2c7        	bbsi	a2, 28, 420168c0 <rtc_init+0x374>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
42016889:	a9e281        	l32r	a8, 42001014 <_stext+0xff4> (60008000 <RTCCNTL>)
4201688c:	0020c0        	memw
4201688f:	0898      	l32i.n	a9, a8, 0
42016891:	a9e3a1        	l32r	a10, 42001020 <_stext+0x1000> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
42016894:	1099a0        	and	a9, a9, a10
42016897:	0020c0        	memw
4201689a:	0899      	s32i.n	a9, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
4201689c:	0020c0        	memw
4201689f:	0898      	l32i.n	a9, a8, 0
420168a1:	ffada2        	movi	a10, 0xfffffdff
420168a4:	1099a0        	and	a9, a9, a10
420168a7:	0020c0        	memw
420168aa:	0899      	s32i.n	a9, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
420168ac:	0020c0        	memw
420168af:	0898      	l32i.n	a9, a8, 0
420168b1:	7fafa2        	movi	a10, -129
420168b4:	1099a0        	and	a9, a9, a10
420168b7:	0020c0        	memw
420168ba:	0899      	s32i.n	a9, a8, 0
420168bc:	000cc6        	j	420168f3 <rtc_init+0x3a7>
420168bf:	d58100        	extui	a8, a0, 17, 14
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
420168c2:	c0a9      	s32i.n	a10, a0, 48
420168c4:	980020        	lsi	f2, a0, 0x260
420168c7:	a108      	l32i.n	a0, a1, 40
420168c9:	a0a732        	movi	a3, 0x7a0
420168cc:	2099      	s32i.n	a9, a0, 8
420168ce:	0020c0        	memw
420168d1:	0899      	s32i.n	a9, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
420168d3:	0020c0        	memw
420168d6:	0898      	l32i.n	a9, a8, 0
420168d8:	00a2a2        	movi	a10, 0x200
420168db:	2099a0        	or	a9, a9, a10
420168de:	0020c0        	memw
420168e1:	0899      	s32i.n	a9, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
420168e3:	0020c0        	memw
420168e6:	0898      	l32i.n	a9, a8, 0
420168e8:	80a0a2        	movi	a10, 128
420168eb:	2099a0        	or	a9, a9, a10
420168ee:	0020c0        	memw
420168f1:	0899      	s32i.n	a9, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
420168f3:	a9cc91        	l32r	a9, 42001024 <_stext+0x1004> (60008088 <RTCCNTL+0x88>)
420168f6:	0020c0        	memw
420168f9:	0988      	l32i.n	a8, a9, 0
420168fb:	a9cba1        	l32r	a10, 42001028 <_stext+0x1008> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
420168fe:	1088a0        	and	a8, a8, a10
42016901:	0020c0        	memw
42016904:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_REGULATOR_FORCE_PU);
42016906:	a9c9a1        	l32r	a10, 4200102c <_stext+0x100c> (60008084 <RTCCNTL+0x84>)
42016909:	0020c0        	memw
4201690c:	0a88      	l32i.n	a8, a10, 0
4201690e:	888a      	add.n	a8, a8, a8
42016910:	418180        	srli	a8, a8, 1
42016913:	0020c0        	memw
42016916:	0a89      	s32i.n	a8, a10, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PU);
42016918:	0020c0        	memw
4201691b:	0a88      	l32i.n	a8, a10, 0
4201691d:	a6c5b1        	l32r	a11, 42000434 <_stext+0x414> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42016920:	1088b0        	and	a8, a8, a11
42016923:	0020c0        	memw
42016926:	0a89      	s32i.n	a8, a10, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_NOISO | RTC_CNTL_FASTMEM_FORCE_NOISO);
42016928:	0020c0        	memw
4201692b:	0988      	l32i.n	a8, a9, 0
4201692d:	aa7c      	movi.n	a10, -6
4201692f:	1088a0        	and	a8, a8, a10
42016932:	0020c0        	memw
42016935:	0989      	s32i.n	a8, a9, 0
        if (cfg.rtc_dboost_fpd) {
42016937:	1572a7        	bbci	a2, 26, 42016950 <rtc_init+0x404>
            SET_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
4201693a:	a9bc91        	l32r	a9, 4200102c <_stext+0x100c> (60008084 <RTCCNTL+0x84>)
4201693d:	0020c0        	memw
42016940:	0988      	l32i.n	a8, a9, 0
42016942:	a973a1        	l32r	a10, 42000f10 <_stext+0xef0> (10000000 <UserFrameTotalSize+0xfffff00>)
42016945:	2088a0        	or	a8, a8, a10
42016948:	0020c0        	memw
4201694b:	0989      	s32i.n	a8, a9, 0
4201694d:	000486        	j	42016963 <rtc_init+0x417>
            CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
42016950:	a9b791        	l32r	a9, 4200102c <_stext+0x100c> (60008084 <RTCCNTL+0x84>)
42016953:	0020c0        	memw
42016956:	0988      	l32i.n	a8, a9, 0
42016958:	a6b4a1        	l32r	a10, 42000428 <_stext+0x408> (efffffff <_rtc_reserved_end+0x8fefffff>)
4201695b:	1088a0        	and	a8, a8, a10
4201695e:	0020c0        	memw
42016961:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
42016963:	a99891        	l32r	a9, 42000fc4 <_stext+0xfa4> (60008034 <RTCCNTL+0x34>)
42016966:	0020c0        	memw
42016969:	0988      	l32i.n	a8, a9, 0
4201696b:	a9ac71        	l32r	a7, 4200101c <_stext+0xffc> (fffbffff <_rtc_reserved_end+0x9febffff>)
4201696e:	108870        	and	a8, a8, a7
42016971:	0020c0        	memw
42016974:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(SYSTEM_MEM_PD_MASK_REG, SYSTEM_LSLP_MEM_PD_MASK);
42016976:	a9ae91        	l32r	a9, 42001030 <_stext+0x1010> (600c0014 <SYSTEM+0x14>)
42016979:	0020c0        	memw
4201697c:	0988      	l32i.n	a8, a9, 0
4201697e:	ea7c      	movi.n	a10, -2
42016980:	1088a0        	and	a8, a8, a10
42016983:	0020c0        	memw
42016986:	0989      	s32i.n	a8, a9, 0
        rtc_sleep_pu(pu_cfg);
42016988:	0a0c      	movi.n	a10, 0
4201698a:	a9b281        	l32r	a8, 42001054 <_stext+0x1034> (40378f1c <rtc_sleep_pu>)
4201698d:	0008e0        	callx8	a8
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_WRAP_FORCE_PU);
42016990:	a98a81        	l32r	a8, 42000fb8 <_stext+0xf98> (60008090 <RTCCNTL+0x90>)
42016993:	0020c0        	memw
42016996:	0898      	l32i.n	a9, a8, 0
42016998:	a9a7a1        	l32r	a10, 42001034 <_stext+0x1014> (ffefffff <_rtc_reserved_end+0x9fdfffff>)
4201699b:	1099a0        	and	a9, a9, a10
4201699e:	0020c0        	memw
420169a1:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_WRAP_FORCE_NOISO | RTC_CNTL_DG_WRAP_FORCE_ISO);
420169a3:	a98791        	l32r	a9, 42000fc0 <_stext+0xfa0> (60008094 <RTCCNTL+0x94>)
420169a6:	0020c0        	memw
420169a9:	09a8      	l32i.n	a10, a9, 0
420169ab:	11aae0        	slli	a10, a10, 2
420169ae:	41a2a0        	srli	a10, a10, 2
420169b1:	0020c0        	memw
420169b4:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_NOISO | RTC_CNTL_WIFI_FORCE_ISO);
420169b6:	0020c0        	memw
420169b9:	09a8      	l32i.n	a10, a9, 0
420169bb:	a99fb1        	l32r	a11, 42001038 <_stext+0x1018> (cfffffff <_rtc_reserved_end+0x6fefffff>)
420169be:	10aab0        	and	a10, a10, a11
420169c1:	0020c0        	memw
420169c4:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PU);
420169c6:	0020c0        	memw
420169c9:	08a8      	l32i.n	a10, a8, 0
420169cb:	10aa70        	and	a10, a10, a7
420169ce:	0020c0        	memw
420169d1:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_BT_FORCE_NOISO | RTC_CNTL_BT_FORCE_ISO);
420169d3:	0020c0        	memw
420169d6:	09a8      	l32i.n	a10, a9, 0
420169d8:	a999b1        	l32r	a11, 4200103c <_stext+0x101c> (ff3fffff <_rtc_reserved_end+0x9f2fffff>)
420169db:	10aab0        	and	a10, a10, a11
420169de:	0020c0        	memw
420169e1:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_BT_FORCE_PU);
420169e3:	0020c0        	memw
420169e6:	08a8      	l32i.n	a10, a8, 0
420169e8:	a996b1        	l32r	a11, 42001040 <_stext+0x1020> (ffffefff <_rtc_reserved_end+0x9fefefff>)
420169eb:	10aab0        	and	a10, a10, a11
420169ee:	0020c0        	memw
420169f1:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_CPU_TOP_FORCE_NOISO | RTC_CNTL_CPU_TOP_FORCE_ISO);
420169f3:	0020c0        	memw
420169f6:	09a8      	l32i.n	a10, a9, 0
420169f8:	a993b1        	l32r	a11, 42001044 <_stext+0x1024> (f3ffffff <_rtc_reserved_end+0x93efffff>)
420169fb:	10aab0        	and	a10, a10, a11
420169fe:	0020c0        	memw
42016a01:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_CPU_TOP_FORCE_PU);
42016a03:	0020c0        	memw
42016a06:	08a8      	l32i.n	a10, a8, 0
42016a08:	a990b1        	l32r	a11, 42001048 <_stext+0x1028> (ffbfffff <_rtc_reserved_end+0x9fafffff>)
42016a0b:	10aab0        	and	a10, a10, a11
42016a0e:	0020c0        	memw
42016a11:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PERI_FORCE_NOISO | RTC_CNTL_DG_PERI_FORCE_ISO);
42016a13:	0020c0        	memw
42016a16:	09a8      	l32i.n	a10, a9, 0
42016a18:	a98db1        	l32r	a11, 4200104c <_stext+0x102c> (fcffffff <_rtc_reserved_end+0x9cefffff>)
42016a1b:	10aab0        	and	a10, a10, a11
42016a1e:	0020c0        	memw
42016a21:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_PERI_FORCE_PU);
42016a23:	0020c0        	memw
42016a26:	0898      	l32i.n	a9, a8, 0
42016a28:	a600a1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42016a2b:	1099a0        	and	a9, a9, a10
42016a2e:	0020c0        	memw
42016a31:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_NOISO);
42016a33:	a97c81        	l32r	a8, 42001024 <_stext+0x1004> (60008088 <RTCCNTL+0x88>)
42016a36:	0020c0        	memw
42016a39:	0898      	l32i.n	a9, a8, 0
42016a3b:	dfafa2        	movi	a10, -33
42016a3e:	1099a0        	and	a9, a9, a10
42016a41:	0020c0        	memw
42016a44:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_ISO);
42016a46:	0020c0        	memw
42016a49:	0898      	l32i.n	a9, a8, 0
42016a4b:	fa6c      	movi.n	a10, -17
42016a4d:	1099a0        	and	a9, a9, a10
42016a50:	0020c0        	memw
42016a53:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
42016a55:	0020c0        	memw
42016a58:	0898      	l32i.n	a9, a8, 0
42016a5a:	a973a1        	l32r	a10, 42001028 <_stext+0x1008> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
42016a5d:	1099a0        	and	a9, a9, a10
42016a60:	0020c0        	memw
42016a63:	0899      	s32i.n	a9, a8, 0
        if (cfg.cpu_waiti_clk_gate) {
42016a65:	1472d7        	bbci	a2, 29, 42016a7d <rtc_init+0x531>
            CLEAR_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42016a68:	a97a91        	l32r	a9, 42001050 <_stext+0x1030> (600c0010 <SYSTEM+0x10>)
42016a6b:	0020c0        	memw
42016a6e:	0988      	l32i.n	a8, a9, 0
42016a70:	7a7c      	movi.n	a10, -9
42016a72:	1088a0        	and	a8, a8, a10
42016a75:	0020c0        	memw
42016a78:	0989      	s32i.n	a8, a9, 0
42016a7a:	000446        	j	42016a8f <rtc_init+0x543>
            SET_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42016a7d:	a97491        	l32r	a9, 42001050 <_stext+0x1030> (600c0010 <SYSTEM+0x10>)
42016a80:	0020c0        	memw
42016a83:	0988      	l32i.n	a8, a9, 0
42016a85:	8a0c      	movi.n	a10, 8
42016a87:	2088a0        	or	a8, a8, a10
42016a8a:	0020c0        	memw
42016a8d:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_UNHOLD);
42016a8f:	a94c81        	l32r	a8, 42000fc0 <_stext+0xfa0> (60008094 <RTCCNTL+0x94>)
42016a92:	0020c0        	memw
42016a95:	0898      	l32i.n	a9, a8, 0
42016a97:	a5e4a1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42016a9a:	1099a0        	and	a9, a9, a10
42016a9d:	0020c0        	memw
42016aa0:	0899      	s32i.n	a9, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_NOISO);
42016aa2:	0020c0        	memw
42016aa5:	0898      	l32i.n	a9, a8, 0
42016aa7:	a966a1        	l32r	a10, 42001040 <_stext+0x1020> (ffffefff <_rtc_reserved_end+0x9fefefff>)
42016aaa:	1099a0        	and	a9, a9, a10
42016aad:	0020c0        	memw
42016ab0:	006892        	s32i	a9, a8, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_ISO);
42016ab3:	a94391        	l32r	a9, 42000fc0 <_stext+0xfa0> (60008094 <RTCCNTL+0x94>)
42016ab6:	0020c0        	memw
42016ab9:	0988      	l32i.n	a8, a9, 0
42016abb:	a915a1        	l32r	a10, 42000f10 <_stext+0xef0> (10000000 <UserFrameTotalSize+0xfffff00>)
42016abe:	2088a0        	or	a8, a8, a10
42016ac1:	0020c0        	memw
42016ac4:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
42016ac6:	a93c91        	l32r	a9, 42000fb8 <_stext+0xf98> (60008090 <RTCCNTL+0x90>)
42016ac9:	0020c0        	memw
42016acc:	0988      	l32i.n	a8, a9, 0
42016ace:	a914a1        	l32r	a10, 42000f20 <_stext+0xf00> (20000 <UserFrameTotalSize+0x1ff00>)
42016ad1:	2088a0        	or	a8, a8, a10
42016ad4:	0020c0        	memw
42016ad7:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
42016ad9:	a6a981        	l32r	a8, 42000580 <_stext+0x560> (60008040 <RTCCNTL+0x40>)
42016adc:	090c      	movi.n	a9, 0
42016ade:	0020c0        	memw
42016ae1:	0899      	s32i.n	a9, a8, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
42016ae3:	a6a881        	l32r	a8, 42000584 <_stext+0x564> (6000804c <RTCCNTL+0x4c>)
42016ae6:	f97c      	movi.n	a9, -1
42016ae8:	0020c0        	memw
42016aeb:	0899      	s32i.n	a9, a8, 0
    sar_periph_ctrl_init();
42016aed:	000065        	call8	42016af4 <sar_periph_ctrl_init>
}
42016af0:	f01d      	retw.n
	...

42016af4 <sar_periph_ctrl_init>:
static const char *TAG = "sar_periph_ctrl";
extern portMUX_TYPE rtc_spinlock;


void sar_periph_ctrl_init(void)
{
42016af4:	004136        	entry	a1, 32
 */
__attribute__((always_inline))
static inline void sar_ctrl_ll_set_power_mode(sar_ctrl_ll_power_t mode)
{
    if (mode == SAR_CTRL_LL_POWER_FSM) {
        SENS.sar_peri_clk_gate_conf.saradc_clk_en = 1;
42016af7:	a95881        	l32r	a8, 42001058 <_stext+0x1038> (60008800 <SENS>)
42016afa:	0020c0        	memw
42016afd:	4128a2        	l32i	a10, a8, 0x104
42016b00:	a58c91        	l32r	a9, 42000130 <_stext+0x110> (40000000 <_heap_end>)
42016b03:	209a90        	or	a9, a10, a9
42016b06:	0020c0        	memw
42016b09:	416892        	s32i	a9, a8, 0x104
        SENS.sar_power_xpd_sar.force_xpd_sar = 0x0;
42016b0c:	0020c0        	memw
42016b0f:	f8a8      	l32i.n	a10, a8, 60
42016b11:	a95291        	l32r	a9, 4200105c <_stext+0x103c> (9fffffff <_rtc_reserved_end+0x3fefffff>)
42016b14:	109a90        	and	a9, a10, a9
42016b17:	0020c0        	memw
42016b1a:	f899      	s32i.n	a9, a8, 60
    //Put SAR control mux to FSM state
    sar_ctrl_ll_set_power_mode(SAR_CTRL_LL_POWER_FSM);

    //Add other periph power control initialisation here
}
42016b1c:	f01d      	retw.n
	...

42016b20 <other_cpu_startup_idle_hook_cb>:
static const char* MAIN_TAG = "main_task";

#if !CONFIG_FREERTOS_UNICORE
static volatile bool s_other_cpu_startup_done = false;
static bool other_cpu_startup_idle_hook_cb(void)
{
42016b20:	004136        	entry	a1, 32
    s_other_cpu_startup_done = true;
42016b23:	a94f81        	l32r	a8, 42001060 <_stext+0x1040> (3fc94c2c <s_other_cpu_startup_done>)
42016b26:	190c      	movi.n	a9, 1
42016b28:	0020c0        	memw
42016b2b:	004892        	s8i	a9, a8, 0
    return true;
}
42016b2e:	120c      	movi.n	a2, 1
42016b30:	f01d      	retw.n
	...

42016b34 <main_task>:
#endif

static void main_task(void* args)
{
42016b34:	004136        	entry	a1, 32
    ESP_LOGI(MAIN_TAG, "Started on CPU%d", (int)xPortGetCoreID());
42016b37:	a54a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42016b3a:	0008e0        	callx8	a8
42016b3d:	0add      	mov.n	a13, a10
    asm volatile (
42016b3f:	03ebf0        	rsr.prid	a15
42016b42:	04fdf0        	extui	a15, a15, 13, 1
42016b45:	a947b1        	l32r	a11, 42001064 <_stext+0x1044> (3c0240dc <_flash_rodata_start+0x3fbc>)
42016b48:	0bed      	mov.n	a14, a11
42016b4a:	a947c1        	l32r	a12, 42001068 <_stext+0x1048> (3c0240e8 <_flash_rodata_start+0x3fc8>)
42016b4d:	3a0c      	movi.n	a10, 3
42016b4f:	a55181        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42016b52:	0008e0        	callx8	a8
42016b55:	03ebb0        	rsr.prid	a11
42016b58:	04bdb0        	extui	a11, a11, 13, 1
#if !CONFIG_FREERTOS_UNICORE
    // Wait for FreeRTOS initialization to finish on other core, before replacing its startup stack
    esp_register_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42016b5b:	40fbb0        	nsau	a11, a11
42016b5e:	41b5b0        	srli	a11, a11, 5
42016b61:	a942a1        	l32r	a10, 4200106c <_stext+0x104c> (42016b20 <other_cpu_startup_idle_hook_cb>)
42016b64:	ebc525        	call8	420027b8 <esp_register_freertos_idle_hook_for_cpu>
    while (!s_other_cpu_startup_done) {
42016b67:	a93e81        	l32r	a8, 42001060 <_stext+0x1040> (3fc94c2c <s_other_cpu_startup_done>)
42016b6a:	0020c0        	memw
42016b6d:	000882        	l8ui	a8, a8, 0
42016b70:	748080        	extui	a8, a8, 0, 8
42016b73:	ff0816        	beqz	a8, 42016b67 <main_task+0x33>
42016b76:	03ebb0        	rsr.prid	a11
42016b79:	04bdb0        	extui	a11, a11, 13, 1
        ;
    }
    esp_deregister_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42016b7c:	40fbb0        	nsau	a11, a11
42016b7f:	41b5b0        	srli	a11, a11, 5
42016b82:	a93aa1        	l32r	a10, 4200106c <_stext+0x104c> (42016b20 <other_cpu_startup_idle_hook_cb>)
42016b85:	ebcfe5        	call8	42002884 <esp_deregister_freertos_idle_hook_for_cpu>
#endif

    // [refactor-todo] check if there is a way to move the following block to esp_system startup
    heap_caps_enable_nonos_stack_heaps();
42016b88:	ec1625        	call8	42002cec <heap_caps_enable_nonos_stack_heaps>

    /*
    Note: Be careful when changing the "Calling app_main()" log below as multiple pytest scripts expect this log as a
    start-of-application marker.
    */
    ESP_LOGI(MAIN_TAG, "Calling app_main()");
42016b8b:	a53581        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42016b8e:	0008e0        	callx8	a8
42016b91:	a93471        	l32r	a7, 42001064 <_stext+0x1044> (3c0240dc <_flash_rodata_start+0x3fbc>)
42016b94:	07ed      	mov.n	a14, a7
42016b96:	0add      	mov.n	a13, a10
42016b98:	a936c1        	l32r	a12, 42001070 <_stext+0x1050> (3c024108 <_flash_rodata_start+0x3fe8>)
42016b9b:	20b770        	or	a11, a7, a7
42016b9e:	03a0a2        	movi	a10, 3
42016ba1:	a53c81        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42016ba4:	0008e0        	callx8	a8
    extern void app_main(void);
    app_main();
42016ba7:	f0ffe5        	call8	42007ba4 <app_main>
    ESP_LOGI(MAIN_TAG, "Returned from app_main()");
42016baa:	a52d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc30 <esp_log_timestamp>)
42016bad:	0008e0        	callx8	a8
42016bb0:	07ed      	mov.n	a14, a7
42016bb2:	0add      	mov.n	a13, a10
42016bb4:	a930c1        	l32r	a12, 42001074 <_stext+0x1054> (3c024128 <_flash_rodata_start+0x4008>)
42016bb7:	07bd      	mov.n	a11, a7
42016bb9:	3a0c      	movi.n	a10, 3
42016bbb:	a53681        	l32r	a8, 42000094 <_stext+0x74> (4037fc78 <esp_log_write>)
42016bbe:	0008e0        	callx8	a8
    vTaskDelete(NULL);
42016bc1:	0a0c      	movi.n	a10, 0
42016bc3:	a92d81        	l32r	a8, 42001078 <_stext+0x1058> (4037ba80 <vTaskDelete>)
42016bc6:	0008e0        	callx8	a8
}
42016bc9:	f01d      	retw.n
	...

42016bcc <esp_startup_start_app>:
{
42016bcc:	006136        	entry	a1, 48
    esp_int_wdt_init();
42016bcf:	eb00e5        	call8	42001bdc <esp_int_wdt_init>
    esp_int_wdt_cpu_init();
42016bd2:	eb0c25        	call8	42001c94 <esp_int_wdt_cpu_init>
    esp_crosscore_int_init();
42016bd5:	f364a5        	call8	4200a220 <esp_crosscore_int_init>
    BaseType_t res = xTaskCreatePinnedToCore(main_task, "main",
42016bd8:	00a0d2        	movi	a13, 0
42016bdb:	01d9      	s32i.n	a13, a1, 0
42016bdd:	0dfd      	mov.n	a15, a13
42016bdf:	01a0e2        	movi	a14, 1
42016be2:	a926c1        	l32r	a12, 4200107c <_stext+0x105c> (2200 <UserFrameTotalSize+0x2100>)
42016be5:	a926b1        	l32r	a11, 42001080 <_stext+0x1060> (3c024150 <_flash_rodata_start+0x4030>)
42016be8:	a927a1        	l32r	a10, 42001084 <_stext+0x1064> (42016b34 <main_task>)
42016beb:	a5fc81        	l32r	a8, 420003dc <_stext+0x3bc> (4037c5c0 <xTaskCreatePinnedToCore>)
42016bee:	0008e0        	callx8	a8
    assert(res == pdTRUE);
42016bf1:	101a26        	beqi	a10, 1, 42016c05 <esp_startup_start_app+0x39>
42016bf4:	a925d1        	l32r	a13, 42001088 <_stext+0x1068> (3c020f64 <_flash_rodata_start+0xe44>)
42016bf7:	a925c1        	l32r	a12, 4200108c <_stext+0x106c> (3c0280f8 <__func__$0>)
42016bfa:	6b5c      	movi.n	a11, 86
42016bfc:	a925a1        	l32r	a10, 42001090 <_stext+0x1070> (3c024172 <_flash_rodata_start+0x4052>)
42016bff:	a53081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016c02:	0008e0        	callx8	a8
    if (port_start_app_hook != NULL) {
42016c05:	a92381        	l32r	a8, 42001094 <_stext+0x1074> (0 <IDF_TARGET_ESP32S3>)
42016c08:	488c      	beqz.n	a8, 42016c10 <esp_startup_start_app+0x44>
        port_start_app_hook();
42016c0a:	a92281        	l32r	a8, 42001094 <_stext+0x1074> (0 <IDF_TARGET_ESP32S3>)
42016c0d:	0008e0        	callx8	a8
    vTaskStartScheduler();
42016c10:	a92281        	l32r	a8, 42001098 <_stext+0x1078> (4037c7c0 <vTaskStartScheduler>)
42016c13:	0008e0        	callx8	a8
}
42016c16:	f01d      	retw.n

42016c18 <esp_startup_start_app_other_cores>:
{
42016c18:	004136        	entry	a1, 32
42016c1b:	03eb80        	rsr.prid	a8
42016c1e:	048d80        	extui	a8, a8, 13, 1
    if (xPortGetCoreID() >= 2) {
42016c21:	0528a6        	blti	a8, 2, 42016c2a <esp_startup_start_app_other_cores+0x12>
        abort();
42016c24:	a53481        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42016c27:	0008e0        	callx8	a8
    while (port_xSchedulerRunning[0] == 0) {
42016c2a:	a91c81        	l32r	a8, 4200109c <_stext+0x107c> (3fc94f08 <port_xSchedulerRunning>)
42016c2d:	0020c0        	memw
42016c30:	0888      	l32i.n	a8, a8, 0
42016c32:	ff4816        	beqz	a8, 42016c2a <esp_startup_start_app_other_cores+0x12>
    esp_int_wdt_cpu_init();
42016c35:	eb05e5        	call8	42001c94 <esp_int_wdt_cpu_init>
    esp_crosscore_int_init();
42016c38:	f35e65        	call8	4200a220 <esp_crosscore_int_init>
    xPortStartScheduler();
42016c3b:	a91981        	l32r	a8, 420010a0 <_stext+0x1080> (4037a048 <xPortStartScheduler>)
42016c3e:	0008e0        	callx8	a8
    abort(); // Only get to here if FreeRTOS somehow very broken
42016c41:	a52c81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fce4 <abort>)
42016c44:	0008e0        	callx8	a8
	...

42016c48 <multi_heap_register>:
{
42016c48:	004136        	entry	a1, 32
42016c4b:	027d      	mov.n	a7, a2
    assert(start_ptr);
42016c4d:	02dc      	bnez.n	a2, 42016c61 <multi_heap_register+0x19>
42016c4f:	a915d1        	l32r	a13, 420010a4 <_stext+0x1084> (3c022a1c <_flash_rodata_start+0x28fc>)
42016c52:	a915c1        	l32r	a12, 420010a8 <_stext+0x1088> (3c027a84 <__func__$0>)
42016c55:	85a0b2        	movi	a11, 133
42016c58:	a915a1        	l32r	a10, 420010ac <_stext+0x108c> (3c022a3e <_flash_rodata_start+0x291e>)
42016c5b:	a51981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016c5e:	0008e0        	callx8	a8
    if(size < (sizeof(heap_t))) {
42016c61:	381c      	movi.n	a8, 19
42016c63:	2bb837        	bgeu	a8, a3, 42016c92 <multi_heap_register+0x4a>
    size -= sizeof(heap_t);
42016c66:	ecc332        	addi	a3, a3, -20
    result->heap_data = tlsf_create_with_pool(start_ptr + sizeof(heap_t), size, max_bytes);
42016c69:	0c0c      	movi.n	a12, 0
42016c6b:	03bd      	mov.n	a11, a3
42016c6d:	14c2a2        	addi	a10, a2, 20
42016c70:	004d65        	call8	42017148 <tlsf_create_with_pool>
42016c73:	0a2d      	mov.n	a2, a10
42016c75:	47a9      	s32i.n	a10, a7, 16
    if(!result->heap_data) {
42016c77:	9a9c      	beqz.n	a10, 42016c94 <multi_heap_register+0x4c>
    result->lock = NULL;
42016c79:	080c      	movi.n	a8, 0
42016c7b:	006782        	s32i	a8, a7, 0
    result->free_bytes = size - tlsf_size(result->heap_data);
42016c7e:	a90c81        	l32r	a8, 420010b0 <_stext+0x1090> (4037fb84 <tlsf_size>)
42016c81:	0008e0        	callx8	a8
42016c84:	c0a3a0        	sub	a10, a3, a10
42016c87:	17a9      	s32i.n	a10, a7, 4
    result->pool_size = size;
42016c89:	3739      	s32i.n	a3, a7, 12
    result->minimum_free_bytes = result->free_bytes;
42016c8b:	27a9      	s32i.n	a10, a7, 8
    return result;
42016c8d:	072d      	mov.n	a2, a7
42016c8f:	000046        	j	42016c94 <multi_heap_register+0x4c>
        return NULL;
42016c92:	020c      	movi.n	a2, 0
}
42016c94:	f01d      	retw.n
	...

42016c98 <multi_heap_get_info>:
    info->total_blocks++;
    return true;
}

void multi_heap_get_info_impl(multi_heap_handle_t heap, multi_heap_info_t *info)
{
42016c98:	004136        	entry	a1, 32
    uint32_t overhead;

    memset(info, 0, sizeof(multi_heap_info_t));
42016c9b:	cc1c      	movi.n	a12, 28
42016c9d:	0b0c      	movi.n	a11, 0
42016c9f:	03ad      	mov.n	a10, a3
42016ca1:	a59781        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42016ca4:	0008e0        	callx8	a8

    if (heap == NULL) {
42016ca7:	053216        	beqz	a2, 42016cfe <multi_heap_get_info+0x66>
        return;
    }

    multi_heap_internal_lock(heap);
42016caa:	20a220        	or	a10, a2, a2
42016cad:	a90281        	l32r	a8, 420010b8 <_stext+0x1098> (4037e708 <multi_heap_internal_lock>)
42016cb0:	0008e0        	callx8	a8
    tlsf_walk_pool(tlsf_get_pool(heap->heap_data), multi_heap_get_info_tlsf, info);
42016cb3:	42a8      	l32i.n	a10, a2, 16
42016cb5:	a90181        	l32r	a8, 420010bc <_stext+0x109c> (4037ec1c <tlsf_get_pool>)
42016cb8:	0008e0        	callx8	a8
42016cbb:	03cd      	mov.n	a12, a3
42016cbd:	a8fdb1        	l32r	a11, 420010b4 <_stext+0x1094> (42016d00 <multi_heap_get_info_tlsf>)
42016cc0:	001fa5        	call8	42016ebc <tlsf_walk_pool>
    /* TLSF has an overhead per block. Calculate the total amount of overhead, it shall not be
     * part of the allocated bytes */
    overhead = info->allocated_blocks * tlsf_alloc_overhead();
42016cc3:	4368      	l32i.n	a6, a3, 16
42016cc5:	a8fe81        	l32r	a8, 420010c0 <_stext+0x10a0> (4037e818 <tlsf_alloc_overhead>)
42016cc8:	0008e0        	callx8	a8
42016ccb:	8266a0        	mull	a6, a6, a10
    info->total_allocated_bytes = (heap->pool_size - tlsf_size(heap->heap_data)) - heap->free_bytes - overhead;
42016cce:	3278      	l32i.n	a7, a2, 12
42016cd0:	42a8      	l32i.n	a10, a2, 16
42016cd2:	a8f781        	l32r	a8, 420010b0 <_stext+0x1090> (4037fb84 <tlsf_size>)
42016cd5:	0008e0        	callx8	a8
42016cd8:	c0a7a0        	sub	a10, a7, a10
42016cdb:	1288      	l32i.n	a8, a2, 4
42016cdd:	c0aa80        	sub	a10, a10, a8
42016ce0:	c0aa60        	sub	a10, a10, a6
42016ce3:	13a9      	s32i.n	a10, a3, 4
    info->minimum_free_bytes = heap->minimum_free_bytes;
42016ce5:	2288      	l32i.n	a8, a2, 8
42016ce7:	3389      	s32i.n	a8, a3, 12
    info->total_free_bytes = heap->free_bytes;
42016ce9:	1288      	l32i.n	a8, a2, 4
42016ceb:	0389      	s32i.n	a8, a3, 0
    info->largest_free_block = tlsf_fit_size(heap->heap_data, info->largest_free_block);
42016ced:	23b8      	l32i.n	a11, a3, 8
42016cef:	42a8      	l32i.n	a10, a2, 16
42016cf1:	002225        	call8	42016f14 <tlsf_fit_size>
42016cf4:	23a9      	s32i.n	a10, a3, 8
    multi_heap_internal_unlock(heap);
42016cf6:	02ad      	mov.n	a10, a2
42016cf8:	a8f381        	l32r	a8, 420010c4 <_stext+0x10a4> (4037e72c <multi_heap_internal_unlock>)
42016cfb:	0008e0        	callx8	a8
}
42016cfe:	f01d      	retw.n

42016d00 <multi_heap_get_info_tlsf>:
{
42016d00:	004136        	entry	a1, 32
    if(used) {
42016d03:	748c      	beqz.n	a4, 42016d0e <multi_heap_get_info_tlsf+0xe>
        info->allocated_blocks++;
42016d05:	4588      	l32i.n	a8, a5, 16
42016d07:	881b      	addi.n	a8, a8, 1
42016d09:	4589      	s32i.n	a8, a5, 16
42016d0b:	000346        	j	42016d1c <multi_heap_get_info_tlsf+0x1c>
        info->free_blocks++;
42016d0e:	5588      	l32i.n	a8, a5, 20
42016d10:	881b      	addi.n	a8, a8, 1
42016d12:	5589      	s32i.n	a8, a5, 20
        if(size > info->largest_free_block ) {
42016d14:	2588      	l32i.n	a8, a5, 8
42016d16:	02b837        	bgeu	a8, a3, 42016d1c <multi_heap_get_info_tlsf+0x1c>
            info->largest_free_block = size;
42016d19:	026532        	s32i	a3, a5, 8
    info->total_blocks++;
42016d1c:	6588      	l32i.n	a8, a5, 24
42016d1e:	881b      	addi.n	a8, a8, 1
42016d20:	6589      	s32i.n	a8, a5, 24
}
42016d22:	120c      	movi.n	a2, 1
42016d24:	f01d      	retw.n
	...

42016d28 <control_construct>:
{
42016d28:	004136        	entry	a1, 32
	if (bytes < sizeof(control_t))
42016d2b:	382c      	movi.n	a8, 35
42016d2d:	023837        	bltu	a8, a3, 42016d33 <control_construct+0xb>
42016d30:	005646        	j	42016e8d <control_construct+0x165>
	control->fl_index_max = 32 - __builtin_clz(bytes);
42016d33:	40f390        	nsau	a9, a3
42016d36:	e0c992        	addi	a9, a9, -32
42016d39:	609090        	neg	a9, a9
42016d3c:	748090        	extui	a8, a9, 0, 8
42016d3f:	549090        	extui	a9, a9, 0, 6
42016d42:	119980        	slli	a9, a9, 8
42016d45:	42a8      	l32i.n	a10, a2, 16
42016d47:	a8e0b1        	l32r	a11, 420010c8 <_stext+0x10a8> (ffffc0ff <_rtc_reserved_end+0x9fefc0ff>)
42016d4a:	10aab0        	and	a10, a10, a11
42016d4d:	209a90        	or	a9, a10, a9
42016d50:	4299      	s32i.n	a9, a2, 16
	if (bytes <= 16 * 1024) control->sl_index_count_log2 = 3;
42016d52:	a52b91        	l32r	a9, 42000200 <_stext+0x1e0> (4000 <UserFrameTotalSize+0x3f00>)
42016d55:	133937        	bltu	a9, a3, 42016d6c <control_construct+0x44>
42016d58:	4298      	l32i.n	a9, a2, 16
42016d5a:	a8dca1        	l32r	a10, 420010cc <_stext+0x10ac> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
42016d5d:	1099a0        	and	a9, a9, a10
42016d60:	a8dca1        	l32r	a10, 420010d0 <_stext+0x10b0> (300000 <UserFrameTotalSize+0x2fff00>)
42016d63:	2099a0        	or	a9, a9, a10
42016d66:	4299      	s32i.n	a9, a2, 16
42016d68:	000a46        	j	42016d95 <control_construct+0x6d>
42016d6b:	6b9100        	ole.s	b9, f1, f0
	else if (bytes <= 256 * 1024) control->sl_index_count_log2 = 4;
42016d6e:	37a8      	l32i.n	a10, a7, 12
42016d70:	1239      	s32i.n	a3, a2, 4
42016d72:	4298      	l32i.n	a9, a2, 16
42016d74:	a8d6a1        	l32r	a10, 420010cc <_stext+0x10ac> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
42016d77:	1099a0        	and	a9, a9, a10
42016d7a:	a8d6a1        	l32r	a10, 420010d4 <_stext+0x10b4> (400000 <UserFrameTotalSize+0x3fff00>)
42016d7d:	2099a0        	or	a9, a9, a10
42016d80:	4299      	s32i.n	a9, a2, 16
42016d82:	0003c6        	j	42016d95 <control_construct+0x6d>
	else control->sl_index_count_log2 = 5;
42016d85:	4298      	l32i.n	a9, a2, 16
42016d87:	a8d1a1        	l32r	a10, 420010cc <_stext+0x10ac> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
42016d8a:	1099a0        	and	a9, a9, a10
42016d8d:	a8d2a1        	l32r	a10, 420010d8 <_stext+0x10b8> (500000 <UserFrameTotalSize+0x4fff00>)
42016d90:	2099a0        	or	a9, a9, a10
42016d93:	4299      	s32i.n	a9, a2, 16
	control->fl_index_shift = (control->sl_index_count_log2 + ALIGN_SIZE_LOG2);
42016d95:	4298      	l32i.n	a9, a2, 16
42016d97:	25a490        	extui	a10, a9, 20, 3
42016d9a:	ea2b      	addi.n	a14, a10, 2
42016d9c:	24c0e0        	extui	a12, a14, 0, 3
42016d9f:	11bcb0        	slli	a11, a12, 5
42016da2:	1fafd2        	movi	a13, -225
42016da5:	1099d0        	and	a9, a9, a13
42016da8:	2099b0        	or	a9, a9, a11
42016dab:	4299      	s32i.n	a9, a2, 16
	control->sl_index_count = 1 << control->sl_index_count_log2;
42016dad:	1b0c      	movi.n	a11, 1
42016daf:	401a00        	ssl	a10
42016db2:	a1ab00        	sll	a10, a11
42016db5:	54d0a0        	extui	a13, a10, 0, 6
42016db8:	11fd20        	slli	a15, a13, 14
42016dbb:	a8c871        	l32r	a7, 420010dc <_stext+0x10bc> (fff03fff <_rtc_reserved_end+0x9fe03fff>)
42016dbe:	109970        	and	a9, a9, a7
42016dc1:	2099f0        	or	a9, a9, a15
42016dc4:	4299      	s32i.n	a9, a2, 16
	control->fl_index_count = control->fl_index_max - control->fl_index_shift + 1;
42016dc6:	548080        	extui	a8, a8, 0, 6
42016dc9:	c088c0        	sub	a8, a8, a12
42016dcc:	748080        	extui	a8, a8, 0, 8
42016dcf:	88ba      	add.n	a8, a8, a11
42016dd1:	44e080        	extui	a14, a8, 0, 5
42016dd4:	0f6c      	movi.n	a15, -32
42016dd6:	1099f0        	and	a9, a9, a15
42016dd9:	2089e0        	or	a8, a9, a14
42016ddc:	4289      	s32i.n	a8, a2, 16
	control->small_block_size = 1 << control->fl_index_shift;
42016dde:	401c00        	ssl	a12
42016de1:	a1bb00        	sll	a11, a11
42016de4:	7490b0        	extui	a9, a11, 0, 8
42016de7:	019990        	slli	a9, a9, 23
42016dea:	a8bdc1        	l32r	a12, 420010e0 <_stext+0x10c0> (807fffff <_rtc_reserved_end+0x206fffff>)
42016ded:	1088c0        	and	a8, a8, a12
42016df0:	208890        	or	a8, a8, a9
42016df3:	4289      	s32i.n	a8, a2, 16
										(sizeof(*control->blocks) * (control->fl_index_count * control->sl_index_count));
42016df5:	828ed0        	mull	a8, a14, a13
	control->size = sizeof(control_t) + (sizeof(*control->sl_bitmap) * control->fl_index_count) +
42016df8:	88ea      	add.n	a8, a8, a14
42016dfa:	889b      	addi.n	a8, a8, 9
42016dfc:	1188e0        	slli	a8, a8, 2
42016dff:	5289      	s32i.n	a8, a2, 20
	if (bytes < control->size + block_size_min)
42016e01:	88cb      	addi.n	a8, a8, 12
42016e03:	02b387        	bgeu	a3, a8, 42016e09 <control_construct+0xe1>
42016e06:	002206        	j	42016e92 <control_construct+0x16a>
	control->block_null.next_free = &control->block_null;
42016e09:	02cd      	mov.n	a12, a2
42016e0b:	2229      	s32i.n	a2, a2, 8
	control->block_null.prev_free = &control->block_null;
42016e0d:	3229      	s32i.n	a2, a2, 12
	control->fl_bitmap = 0;
42016e0f:	080c      	movi.n	a8, 0
42016e11:	6289      	s32i.n	a8, a2, 24
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
42016e13:	27c282        	addi	a8, a2, 39
42016e16:	c97c      	movi.n	a9, -4
42016e18:	108890        	and	a8, a8, a9
	control->sl_bitmap = align_ptr(control + 1, sizeof(*control->sl_bitmap));
42016e1b:	7289      	s32i.n	a8, a2, 28
	control->blocks = align_ptr(control->sl_bitmap + control->fl_index_count, sizeof(*control->blocks));
42016e1d:	a08e80        	addx4	a8, a14, a8
42016e20:	883b      	addi.n	a8, a8, 3
42016e22:	108890        	and	a8, a8, a9
42016e25:	8289      	s32i.n	a8, a2, 32
	tlsf_assert(sizeof(unsigned int) * CHAR_BIT >= control->sl_index_count
42016e27:	082c      	movi.n	a8, 32
42016e29:	10b8d7        	bgeu	a8, a13, 42016e3d <control_construct+0x115>
42016e2c:	a8aed1        	l32r	a13, 420010e4 <_stext+0x10c4> (3c022a5c <_flash_rodata_start+0x293c>)
42016e2f:	a8aec1        	l32r	a12, 420010e8 <_stext+0x10c8> (3c027b74 <__func__$13>)
42016e32:	ab4c      	movi.n	a11, 74
42016e34:	a8aea1        	l32r	a10, 420010ec <_stext+0x10cc> (3c022adb <_flash_rodata_start+0x29bb>)
42016e37:	a4a281        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016e3a:	0008e0        	callx8	a8
	tlsf_assert(ALIGN_SIZE == control->small_block_size / control->sl_index_count); //ALIGN_SIZE does not match");
42016e3d:	74b0b0        	extui	a11, a11, 0, 8
42016e40:	d28bd0        	quos	a8, a11, a13
42016e43:	394826        	beqi	a8, 4, 42016e80 <control_construct+0x158>
42016e46:	a8aad1        	l32r	a13, 420010f0 <_stext+0x10d0> (3c022ae4 <_flash_rodata_start+0x29c4>)
42016e49:	a8a7c1        	l32r	a12, 420010e8 <_stext+0x10c8> (3c027b74 <__func__$13>)
42016e4c:	4ea0b2        	movi	a11, 78
42016e4f:	a8a7a1        	l32r	a10, 420010ec <_stext+0x10cc> (3c022adb <_flash_rodata_start+0x29bb>)
42016e52:	a49b81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016e55:	0008e0        	callx8	a8
		control->sl_bitmap[i] = 0;
42016e58:	7288      	l32i.n	a8, a2, 28
42016e5a:	a08b80        	addx4	a8, a11, a8
42016e5d:	090c      	movi.n	a9, 0
42016e5f:	0899      	s32i.n	a9, a8, 0
		for (int j = 0; j < control->sl_index_count; ++j)
42016e61:	000346        	j	42016e72 <control_construct+0x14a>
			control->blocks[i * control->sl_index_count + j] = &control->block_null;
42016e64:	82a8      	l32i.n	a10, a2, 32
42016e66:	8288b0        	mull	a8, a8, a11
42016e69:	889a      	add.n	a8, a8, a9
42016e6b:	a088a0        	addx4	a8, a8, a10
42016e6e:	08c9      	s32i.n	a12, a8, 0
		for (int j = 0; j < control->sl_index_count; ++j)
42016e70:	991b      	addi.n	a9, a9, 1
42016e72:	4288      	l32i.n	a8, a2, 16
42016e74:	548e80        	extui	a8, a8, 14, 6
42016e77:	e92987        	blt	a9, a8, 42016e64 <control_construct+0x13c>
	for (int i = 0; i < control->fl_index_count; ++i)
42016e7a:	bb1b      	addi.n	a11, a11, 1
42016e7c:	000086        	j	42016e82 <control_construct+0x15a>
42016e7f:	0b0c00        	lsi	f0, a12, 44
42016e82:	4288      	l32i.n	a8, a2, 16
42016e84:	448080        	extui	a8, a8, 0, 5
42016e87:	cd2b87        	blt	a11, a8, 42016e58 <control_construct+0x130>
42016e8a:	000186        	j	42016e94 <control_construct+0x16c>
		return NULL;
42016e8d:	020c      	movi.n	a2, 0
42016e8f:	000046        	j	42016e94 <control_construct+0x16c>
		return NULL;
42016e92:	020c      	movi.n	a2, 0
}
42016e94:	f01d      	retw.n
	...

42016e98 <default_walker>:
{
42016e98:	004136        	entry	a1, 32
42016e9b:	02bd      	mov.n	a11, a2
42016e9d:	03dd      	mov.n	a13, a3
	printf("\t%p %s size: %x (%p)\n", ptr, used ? "used" : "free", (unsigned int)size, block_from_ptr(ptr));
42016e9f:	648c      	beqz.n	a4, 42016ea9 <default_walker+0x11>
42016ea1:	a894c1        	l32r	a12, 420010f4 <_stext+0x10d4> (3c022b28 <_flash_rodata_start+0x2a08>)
42016ea4:	000106        	j	42016eac <default_walker+0x14>
42016ea7:	c10000        	mul16u	a0, a0, a0
42016eaa:	e2a893        	lsi	f9, a8, 0x388
42016ead:	f8cb      	addi.n	a15, a8, 12
42016eaf:	a893a1        	l32r	a10, 420010fc <_stext+0x10dc> (3c022b38 <_flash_rodata_start+0x2a18>)
42016eb2:	f4f2a5        	call8	4200bddc <printf>
}
42016eb5:	120c      	movi.n	a2, 1
42016eb7:	f01d      	retw.n
42016eb9:	000000        	ill

42016ebc <tlsf_walk_pool>:
{
42016ebc:	004136        	entry	a1, 32
	tlsf_walker pool_walker = walker ? walker : default_walker;
42016ebf:	13cc      	bnez.n	a3, 42016ec4 <tlsf_walk_pool+0x8>
42016ec1:	a88f31        	l32r	a3, 42001100 <_stext+0x10e0> (42016e98 <default_walker>)
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42016ec4:	fcc272        	addi	a7, a2, -4
	bool ret_val = true;
42016ec7:	1a0c      	movi.n	a10, 1
	while (block && !block_is_last(block) && ret_val == true)
42016ec9:	000ec6        	j	42016f08 <tlsf_walk_pool+0x4c>
	return tlsf_cast(void*,
42016ecc:	678b      	addi.n	a6, a7, 8
		ret_val = pool_walker(
42016ece:	04c080        	extui	a12, a8, 0, 1
42016ed1:	04dd      	mov.n	a13, a4
42016ed3:	190c      	movi.n	a9, 1
42016ed5:	30cc90        	xor	a12, a12, a9
42016ed8:	cb7c      	movi.n	a11, -4
42016eda:	10b8b0        	and	a11, a8, a11
42016edd:	06ad      	mov.n	a10, a6
42016edf:	0003e0        	callx8	a3
		if (ret_val == true) {
42016ee2:	2aac      	beqz.n	a10, 42016f08 <tlsf_walk_pool+0x4c>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42016ee4:	1788      	l32i.n	a8, a7, 4
42016ee6:	c77c      	movi.n	a7, -4
42016ee8:	107870        	and	a7, a8, a7
	block_header_t* next = offset_to_block(block_to_ptr(block),
42016eeb:	fcc772        	addi	a7, a7, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42016eee:	807760        	add	a7, a7, a6
	tlsf_assert(!block_is_last(block));
42016ef1:	390c      	movi.n	a9, 3
42016ef3:	113987        	bltu	a9, a8, 42016f08 <tlsf_walk_pool+0x4c>
42016ef6:	a883d1        	l32r	a13, 42001104 <_stext+0x10e4> (3c022b50 <_flash_rodata_start+0x2a30>)
42016ef9:	a883c1        	l32r	a12, 42001108 <_stext+0x10e8> (3c027bc8 <__func__$20>)
42016efc:	a1a0b2        	movi	a11, 161
42016eff:	a883a1        	l32r	a10, 4200110c <_stext+0x10ec> (3c022b83 <_flash_rodata_start+0x2a63>)
42016f02:	a46f81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42016f05:	0008e0        	callx8	a8
	while (block && !block_is_last(block) && ret_val == true)
42016f08:	678c      	beqz.n	a7, 42016f12 <tlsf_walk_pool+0x56>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42016f0a:	1788      	l32i.n	a8, a7, 4
42016f0c:	0248b6        	bltui	a8, 4, 42016f12 <tlsf_walk_pool+0x56>
42016f0f:	fb9a56        	bnez	a10, 42016ecc <tlsf_walk_pool+0x10>
}
42016f12:	f01d      	retw.n

42016f14 <tlsf_fit_size>:
{
42016f14:	004136        	entry	a1, 32
	if (size == 0 || tlsf == NULL) {
42016f17:	40f380        	nsau	a8, a3
42016f1a:	418580        	srli	a8, a8, 5
42016f1d:	40f290        	nsau	a9, a2
42016f20:	419590        	srli	a9, a9, 5
42016f23:	208890        	or	a8, a8, a9
42016f26:	054856        	bnez	a8, 42016f7e <tlsf_fit_size+0x6a>
	if (size < control->small_block_size) {
42016f29:	4288      	l32i.n	a8, a2, 16
42016f2b:	758780        	extui	a8, a8, 23, 8
42016f2e:	2fb387        	bgeu	a3, a8, 42016f61 <tlsf_fit_size+0x4d>
	if (size)
42016f31:	73ac      	beqz.n	a3, 42016f5c <tlsf_fit_size+0x48>
	return (x + (align - 1)) & ~(align - 1);
42016f33:	333b      	addi.n	a3, a3, 3
42016f35:	c87c      	movi.n	a8, -4
42016f37:	103380        	and	a3, a3, a8
	if (control == NULL)
42016f3a:	629c      	beqz.n	a2, 42016f54 <tlsf_fit_size+0x40>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
42016f3c:	4298      	l32i.n	a9, a2, 16
42016f3e:	549890        	extui	a9, a9, 8, 6
42016f41:	180c      	movi.n	a8, 1
42016f43:	401900        	ssl	a9
42016f46:	a18800        	sll	a8, a8
		if (aligned < tlsf_block_size_max(control)) 
42016f49:	0db387        	bgeu	a3, a8, 42016f5a <tlsf_fit_size+0x46>
			adjust = tlsf_max(aligned, block_size_min);
42016f4c:	c80c      	movi.n	a8, 12
42016f4e:	733380        	maxu	a3, a3, a8
42016f51:	0001c6        	j	42016f5c <tlsf_fit_size+0x48>
	size_t adjust = 0;
42016f54:	030c      	movi.n	a3, 0
42016f56:	000086        	j	42016f5c <tlsf_fit_size+0x48>
42016f59:	030c00        	rsr.scompare1	a0
		return adjust_request_size(tlsf, size, ALIGN_SIZE);
42016f5c:	032d      	mov.n	a2, a3
42016f5e:	000786        	j	42016f80 <tlsf_fit_size+0x6c>
	sl_interval = (1 << (32 - __builtin_clz(size) - 1)) / control->sl_index_count;
42016f61:	40f390        	nsau	a9, a3
42016f64:	a72481        	l32r	a8, 42000bf4 <_stext+0xbd4> (80000000 <_rtc_reserved_end+0x1ff00000>)
42016f67:	400900        	ssr	a9
42016f6a:	918080        	srl	a8, a8
42016f6d:	4298      	l32i.n	a9, a2, 16
42016f6f:	549e90        	extui	a9, a9, 14, 6
42016f72:	d28890        	quos	a8, a8, a9
	return size & ~(sl_interval - 1);
42016f75:	608080        	neg	a8, a8
42016f78:	102830        	and	a2, a8, a3
42016f7b:	000046        	j	42016f80 <tlsf_fit_size+0x6c>
		return 0;
42016f7e:	020c      	movi.n	a2, 0
}
42016f80:	f01d      	retw.n
	...

42016f84 <tlsf_add_pool>:
{
42016f84:	004136        	entry	a1, 32
	const size_t pool_overhead = tlsf_pool_overhead();
42016f87:	001ee5        	call8	42017174 <tlsf_pool_overhead>
	const size_t pool_bytes = align_down(bytes - pool_overhead, ALIGN_SIZE);
42016f8a:	c044a0        	sub	a4, a4, a10
	return x - (x & (align - 1));
42016f8d:	fcaf82        	movi	a8, -4
42016f90:	108480        	and	a8, a4, a8
	if (((ptrdiff_t)mem % ALIGN_SIZE) != 0)
42016f93:	149030        	extui	a9, a3, 0, 2
42016f96:	00c916        	beqz	a9, 42016fa6 <tlsf_add_pool+0x22>
		printf("tlsf_add_pool: Memory must be aligned by %u bytes.\n",
42016f99:	4b0c      	movi.n	a11, 4
42016f9b:	a85da1        	l32r	a10, 42001110 <_stext+0x10f0> (3c022b9c <_flash_rodata_start+0x2a7c>)
42016f9e:	f4e3e5        	call8	4200bddc <printf>
		return 0;
42016fa1:	020c      	movi.n	a2, 0
42016fa3:	005bc6        	j	42017116 <tlsf_add_pool+0x192>
	if (pool_bytes < block_size_min || pool_bytes > tlsf_block_size_max(tlsf))
42016fa6:	bb0c      	movi.n	a11, 11
42016fa8:	16bb87        	bgeu	a11, a8, 42016fc2 <tlsf_add_pool+0x3e>
	if (control == NULL)
42016fab:	e28c      	beqz.n	a2, 42016fbd <tlsf_add_pool+0x39>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
42016fad:	42c8      	l32i.n	a12, a2, 16
42016faf:	54c8c0        	extui	a12, a12, 8, 6
42016fb2:	1b0c      	movi.n	a11, 1
42016fb4:	401c00        	ssl	a12
42016fb7:	a1bb00        	sll	a11, a11
42016fba:	000046        	j	42016fbf <tlsf_add_pool+0x3b>
		return 0;
42016fbd:	09bd      	mov.n	a11, a9
42016fbf:	1ebb87        	bgeu	a11, a8, 42016fe1 <tlsf_add_pool+0x5d>
			(unsigned int)(pool_overhead + block_size_min),
42016fc2:	bacb      	addi.n	a11, a10, 12
	if (control == NULL)
42016fc4:	c28c      	beqz.n	a2, 42016fd4 <tlsf_add_pool+0x50>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
42016fc6:	4288      	l32i.n	a8, a2, 16
42016fc8:	548880        	extui	a8, a8, 8, 6
42016fcb:	01a092        	movi	a9, 1
42016fce:	401800        	ssl	a8
42016fd1:	a19900        	sll	a9, a9
		printf("tlsf_add_pool: Memory size must be between %u and %u bytes.\n", 
42016fd4:	ca9a      	add.n	a12, a10, a9
42016fd6:	a84fa1        	l32r	a10, 42001114 <_stext+0x10f4> (3c022bd0 <_flash_rodata_start+0x2ab0>)
42016fd9:	f4e025        	call8	4200bddc <printf>
		return 0;
42016fdc:	020c      	movi.n	a2, 0
42016fde:	004d06        	j	42017116 <tlsf_add_pool+0x192>
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42016fe1:	fcc392        	addi	a9, a3, -4
	const size_t oldsize = block->size;
42016fe4:	19a8      	l32i.n	a10, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
42016fe6:	14a0a0        	extui	a10, a10, 0, 2
42016fe9:	2088a0        	or	a8, a8, a10
42016fec:	1989      	s32i.n	a8, a9, 4
	block->size |= block_header_free_bit;
42016fee:	1b0c      	movi.n	a11, 1
42016ff0:	20a8b0        	or	a10, a8, a11
42016ff3:	19a9      	s32i.n	a10, a9, 4
	block->size &= ~block_header_prev_free_bit;
42016ff5:	da7c      	movi.n	a10, -3
42016ff7:	10a8a0        	and	a10, a8, a10
42016ffa:	20aab0        	or	a10, a10, a11
42016ffd:	19a9      	s32i.n	a10, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
42016fff:	ca7c      	movi.n	a10, -4
42017001:	1088a0        	and	a8, a8, a10
	if (size < control->small_block_size)
42017004:	42a8      	l32i.n	a10, a2, 16
42017006:	75a7a0        	extui	a10, a10, 23, 8
42017009:	0fb8a7        	bgeu	a8, a10, 4201701c <tlsf_add_pool+0x98>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4201700c:	42b8      	l32i.n	a11, a2, 16
4201700e:	54beb0        	extui	a11, a11, 14, 6
42017011:	d2aab0        	quos	a10, a10, a11
42017014:	d288a0        	quos	a8, a8, a10
		fl = 0;
42017017:	0b0c      	movi.n	a11, 0
42017019:	000c06        	j	4201704d <tlsf_add_pool+0xc9>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4201701c:	a88c      	beqz.n	a8, 4201702a <tlsf_add_pool+0xa6>
4201701e:	40f8b0        	nsau	a11, a8
42017021:	e0cbb2        	addi	a11, a11, -32
42017024:	60b0b0        	neg	a11, a11
42017027:	000046        	j	4201702c <tlsf_add_pool+0xa8>
4201702a:	0b0c      	movi.n	a11, 0
	return bit - 1;
4201702c:	cb0b      	addi.n	a12, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4201702e:	42a8      	l32i.n	a10, a2, 16
42017030:	25d4a0        	extui	a13, a10, 20, 3
42017033:	c0ccd0        	sub	a12, a12, a13
42017036:	400c00        	ssr	a12
42017039:	918080        	srl	a8, a8
4201703c:	1c0c      	movi.n	a12, 1
4201703e:	401d00        	ssl	a13
42017041:	a1cc00        	sll	a12, a12
42017044:	3088c0        	xor	a8, a8, a12
		fl -= (control->fl_index_shift - 1);
42017047:	24a5a0        	extui	a10, a10, 5, 3
4201704a:	c0bba0        	sub	a11, a11, a10
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4201704d:	82c8      	l32i.n	a12, a2, 32
4201704f:	42a8      	l32i.n	a10, a2, 16
42017051:	54aea0        	extui	a10, a10, 14, 6
42017054:	82aab0        	mull	a10, a10, a11
42017057:	80aa80        	add	a10, a10, a8
4201705a:	a0aac0        	addx4	a10, a10, a12
4201705d:	0aa8      	l32i.n	a10, a10, 0
	tlsf_assert(current && "free list cannot have a null entry");
4201705f:	011a56        	bnez	a10, 42017074 <tlsf_add_pool+0xf0>
42017062:	a82dd1        	l32r	a13, 42001118 <_stext+0x10f8> (3c022c10 <_flash_rodata_start+0x2af0>)
42017065:	a82dc1        	l32r	a12, 4200111c <_stext+0x10fc> (3c027ba8 <__func__$17>)
42017068:	90a1b2        	movi	a11, 0x190
4201706b:	a82da1        	l32r	a10, 42001120 <_stext+0x1100> (3c022c5b <_flash_rodata_start+0x2b3b>)
4201706e:	a41481        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42017071:	0008e0        	callx8	a8
	tlsf_assert(block && "cannot insert a null entry into the free list");
42017074:	114366        	bnei	a3, 4, 42017089 <tlsf_add_pool+0x105>
42017077:	a82bd1        	l32r	a13, 42001124 <_stext+0x1104> (3c022c74 <_flash_rodata_start+0x2b54>)
4201707a:	a828c1        	l32r	a12, 4200111c <_stext+0x10fc> (3c027ba8 <__func__$17>)
4201707d:	91a1b2        	movi	a11, 0x191
42017080:	a828a1        	l32r	a10, 42001120 <_stext+0x1100> (3c022c5b <_flash_rodata_start+0x2b3b>)
42017083:	a40f81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
42017086:	0008e0        	callx8	a8
	block->next_free = current;
42017089:	29a9      	s32i.n	a10, a9, 8
	block->prev_free = &control->block_null;
4201708b:	3929      	s32i.n	a2, a9, 12
	current->prev_free = block;
4201708d:	3a99      	s32i.n	a9, a10, 12
	return tlsf_cast(void*,
4201708f:	c98b      	addi.n	a12, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
42017091:	a9bb      	addi.n	a10, a9, 11
42017093:	cd7c      	movi.n	a13, -4
42017095:	10aad0        	and	a10, a10, a13
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
42017098:	111ca7        	beq	a12, a10, 420170ad <tlsf_add_pool+0x129>
4201709b:	a823d1        	l32r	a13, 42001128 <_stext+0x1108> (3c022cb0 <_flash_rodata_start+0x2b90>)
4201709e:	a81fc1        	l32r	a12, 4200111c <_stext+0x10fc> (3c027ba8 <__func__$17>)
420170a1:	96a1b2        	movi	a11, 0x196
420170a4:	a81fa1        	l32r	a10, 42001120 <_stext+0x1100> (3c022c5b <_flash_rodata_start+0x2b3b>)
420170a7:	a40681        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420170aa:	0008e0        	callx8	a8
	control->blocks[fl * control->sl_index_count + sl] = block;
420170ad:	82d8      	l32i.n	a13, a2, 32
420170af:	42a8      	l32i.n	a10, a2, 16
420170b1:	54aea0        	extui	a10, a10, 14, 6
420170b4:	82aba0        	mull	a10, a11, a10
420170b7:	a8aa      	add.n	a10, a8, a10
420170b9:	a0aad0        	addx4	a10, a10, a13
420170bc:	0a99      	s32i.n	a9, a10, 0
	control->fl_bitmap |= (1U << fl);
420170be:	62d8      	l32i.n	a13, a2, 24
420170c0:	1a0c      	movi.n	a10, 1
420170c2:	401b00        	ssl	a11
420170c5:	a1ea00        	sll	a14, a10
420170c8:	20dde0        	or	a13, a13, a14
420170cb:	62d9      	s32i.n	a13, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
420170cd:	72d8      	l32i.n	a13, a2, 28
420170cf:	a0bbd0        	addx4	a11, a11, a13
420170d2:	0bd8      	l32i.n	a13, a11, 0
420170d4:	401800        	ssl	a8
420170d7:	a1aa00        	sll	a10, a10
420170da:	208da0        	or	a8, a13, a10
420170dd:	0b89      	s32i.n	a8, a11, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
420170df:	19a8      	l32i.n	a10, a9, 4
420170e1:	c87c      	movi.n	a8, -4
420170e3:	108a80        	and	a8, a10, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
420170e6:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
420170e9:	88ca      	add.n	a8, a8, a12
	tlsf_assert(!block_is_last(block));
420170eb:	3b0c      	movi.n	a11, 3
420170ed:	113ba7        	bltu	a11, a10, 42017102 <tlsf_add_pool+0x17e>
420170f0:	a805d1        	l32r	a13, 42001104 <_stext+0x10e4> (3c022b50 <_flash_rodata_start+0x2a30>)
420170f3:	a805c1        	l32r	a12, 42001108 <_stext+0x10e8> (3c027bc8 <__func__$20>)
420170f6:	a1a0b2        	movi	a11, 161
420170f9:	a804a1        	l32r	a10, 4200110c <_stext+0x10ec> (3c022b83 <_flash_rodata_start+0x2a63>)
420170fc:	a3f181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fda0 <__assert_func>)
420170ff:	0008e0        	callx8	a8
	next->prev_phys_block = block;
42017102:	0899      	s32i.n	a9, a8, 0
	const size_t oldsize = block->size;
42017104:	1898      	l32i.n	a9, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
42017106:	14a090        	extui	a10, a9, 0, 2
42017109:	18a9      	s32i.n	a10, a8, 4
	block->size &= ~block_header_free_bit;
4201710b:	2a0c      	movi.n	a10, 2
4201710d:	1099a0        	and	a9, a9, a10
42017110:	1899      	s32i.n	a9, a8, 4
	block->size |= block_header_prev_free_bit;
42017112:	18a9      	s32i.n	a10, a8, 4
	return mem;
42017114:	032d      	mov.n	a2, a3
}
42017116:	f01d      	retw.n

42017118 <tlsf_create>:
{
42017118:	004136        	entry	a1, 32
4201711b:	20a220        	or	a10, a2, a2
4201711e:	20b330        	or	a11, a3, a3
	if (mem == NULL)
42017121:	01e216        	beqz	a2, 42017143 <tlsf_create+0x2b>
	if (((tlsfptr_t)mem % ALIGN_SIZE) != 0)
42017124:	148020        	extui	a8, a2, 0, 2
42017127:	d88c      	beqz.n	a8, 42017138 <tlsf_create+0x20>
		printf("tlsf_create: Memory must be aligned to %u bytes.\n",
42017129:	4b0c      	movi.n	a11, 4
4201712b:	a800a1        	l32r	a10, 4200112c <_stext+0x110c> (3c022e2c <_flash_rodata_start+0x2d0c>)
4201712e:	f4cae5        	call8	4200bddc <printf>
		return NULL;
42017131:	020c      	movi.n	a2, 0
42017133:	000306        	j	42017143 <tlsf_create+0x2b>
42017136:	e50000        	extui	a0, a0, 16, 15
	control_t* control_ptr = control_construct(tlsf_cast(control_t*, mem), max_bytes);
42017139:	be          	.byte	0xbe
4201713a:	ff          	.byte	0xff
4201713b:	0a2d      	mov.n	a2, a10
	return tlsf_cast(tlsf_t, control_ptr);
4201713d:	000086        	j	42017143 <tlsf_create+0x2b>
42017140:	000000        	ill
}
42017143:	f01d      	retw.n
42017145:	000000        	ill

42017148 <tlsf_create_with_pool>:
{
42017148:	004136        	entry	a1, 32
4201714b:	027d      	mov.n	a7, a2
4201714d:	20b440        	or	a11, a4, a4
	tlsf_t tlsf = tlsf_create(mem, max_bytes ? max_bytes : pool_bytes);
42017150:	002456        	bnez	a4, 42017156 <tlsf_create_with_pool+0xe>
42017153:	20b330        	or	a11, a3, a3
42017156:	20a770        	or	a10, a7, a7
42017159:	fffbe5        	call8	42017118 <tlsf_create>
4201715c:	202aa0        	or	a2, a10, a10
	if (tlsf != NULL)
4201715f:	ea8c      	beqz.n	a10, 42017171 <tlsf_create_with_pool+0x29>
		tlsf_add_pool(tlsf, (char*)mem + tlsf_size(tlsf), pool_bytes - tlsf_size(tlsf));
42017161:	a7d381        	l32r	a8, 420010b0 <_stext+0x1090> (4037fb84 <tlsf_size>)
42017164:	0008e0        	callx8	a8
42017167:	c0c3a0        	sub	a12, a3, a10
4201716a:	b7aa      	add.n	a11, a7, a10
4201716c:	02ad      	mov.n	a10, a2
4201716e:	ffe165        	call8	42016f84 <tlsf_add_pool>
}
42017171:	f01d      	retw.n
	...

42017174 <tlsf_pool_overhead>:
{
42017174:	004136        	entry	a1, 32
}
42017177:	820c      	movi.n	a2, 8
42017179:	f01d      	retw.n
	...

4201717c <log_level_get>:
{
4201717c:	006136        	entry	a1, 48
4201717f:	027d      	mov.n	a7, a2
42017181:	a3aa81        	l32r	a8, 4200002c <_stext+0xc> (3fc9203c <esp_log_default_level>)
42017184:	0828      	l32i.n	a2, a8, 0
    esp_log_level_t level_for_tag = esp_log_get_default_level();
42017186:	0129      	s32i.n	a2, a1, 0
    if (tag == NULL) {
42017188:	47bc      	beqz.n	a7, 420171c0 <log_level_get+0x44>
    if (timeout) {
4201718a:	b38c      	beqz.n	a3, 42017199 <log_level_get+0x1d>
        if (esp_log_impl_lock_timeout() == false) {
4201718c:	a7e981        	l32r	a8, 42001130 <_stext+0x1110> (4037fbbc <esp_log_impl_lock_timeout>)
4201718f:	0008e0        	callx8	a8
42017192:	9acc      	bnez.n	a10, 4201719f <log_level_get+0x23>
            return ESP_LOG_NONE;
42017194:	020c      	movi.n	a2, 0
42017196:	000986        	j	420171c0 <log_level_get+0x44>
        esp_log_impl_lock();
42017199:	a7e681        	l32r	a8, 42001134 <_stext+0x1114> (4037fb94 <esp_log_impl_lock>)
4201719c:	0008e0        	callx8	a8
    bool cache_miss = !esp_log_cache_get_level(tag, &level_for_tag);
4201719f:	20b110        	or	a11, a1, a1
420171a2:	20a770        	or	a10, a7, a7
420171a5:	eb9225        	call8	42002ac8 <esp_log_cache_get_level>
    if (cache_miss) {
420171a8:	cacc      	bnez.n	a10, 420171b8 <log_level_get+0x3c>
        esp_log_linked_list_get_level(tag, &level_for_tag);
420171aa:	01bd      	mov.n	a11, a1
420171ac:	07ad      	mov.n	a10, a7
420171ae:	eb8625        	call8	42002a10 <esp_log_linked_list_get_level>
        esp_log_cache_add(tag, level_for_tag);
420171b1:	01b8      	l32i.n	a11, a1, 0
420171b3:	07ad      	mov.n	a10, a7
420171b5:	eb9c25        	call8	42002b78 <esp_log_cache_add>
    esp_log_impl_unlock();
420171b8:	a7e081        	l32r	a8, 42001138 <_stext+0x1118> (4037fbf4 <esp_log_impl_unlock>)
420171bb:	0008e0        	callx8	a8
    return level_for_tag;
420171be:	0128      	l32i.n	a2, a1, 0
}
420171c0:	f01d      	retw.n
	...

420171c4 <xt_int_has_handler>:

//Returns true if handler for interrupt is not the default unhandled interrupt handler
bool xt_int_has_handler(int intr, int cpu)
{
420171c4:	004136        	entry	a1, 32
    return (_xt_interrupt_table[intr*portNUM_PROCESSORS+cpu].handler != xt_unhandled_interrupt);
420171c7:	902230        	addx2	a2, a2, a3
420171ca:	a7dc81        	l32r	a8, 4200113c <_stext+0x111c> (3fc922d8 <_xt_interrupt_table>)
420171cd:	b02280        	addx8	a2, a2, a8
420171d0:	0228      	l32i.n	a2, a2, 0
420171d2:	a7db81        	l32r	a8, 42001140 <_stext+0x1120> (40376cbc <xt_unhandled_interrupt>)
420171d5:	c02280        	sub	a2, a2, a8
}
420171d8:	180c      	movi.n	a8, 1
420171da:	932820        	movnez	a2, a8, a2
420171dd:	f01d      	retw.n
	...

420171e0 <xt_set_interrupt_handler>:
  parameter specifies the argument to be passed to the handler when it is
  invoked. The function returns the address of the previous handler.
  On error, it returns 0.
*/
xt_handler xt_set_interrupt_handler(int n, xt_handler f, void * arg)
{
420171e0:	004136        	entry	a1, 32
    xt_handler_table_entry * entry;
    xt_handler               old;

    if( n < 0 || n >= XCHAL_NUM_INTERRUPTS )
420171e3:	f81c      	movi.n	a8, 31
420171e5:	373827        	bltu	a8, a2, 42017220 <xt_set_interrupt_handler+0x40>
        return 0;       /* invalid interrupt number */
    if( Xthal_intlevel[n] > XCHAL_EXCM_LEVEL )
420171e8:	a7d781        	l32r	a8, 42001144 <_stext+0x1124> (3c0293bc <Xthal_intlevel>)
420171eb:	882a      	add.n	a8, a8, a2
420171ed:	000882        	l8ui	a8, a8, 0
420171f0:	3148f6        	bgeui	a8, 4, 42017225 <xt_set_interrupt_handler+0x45>
        return 0;       /* priority level too high to safely handle in C */

    /* Convert exception number to _xt_exception_table name */
    n = n * portNUM_PROCESSORS + xPortGetCoreID();
420171f3:	222a      	add.n	a2, a2, a2
420171f5:	03eb80        	rsr.prid	a8
420171f8:	048d80        	extui	a8, a8, 13, 1
420171fb:	828a      	add.n	a8, a2, a8

    entry = _xt_interrupt_table + n;
420171fd:	a7cf91        	l32r	a9, 4200113c <_stext+0x111c> (3fc922d8 <_xt_interrupt_table>)
42017200:	b09890        	addx8	a9, a8, a9
    old   = entry->handler;
42017203:	0928      	l32i.n	a2, a9, 0

    if (f) {
42017205:	738c      	beqz.n	a3, 42017210 <xt_set_interrupt_handler+0x30>
        entry->handler = f;
42017207:	0939      	s32i.n	a3, a9, 0
        entry->arg     = arg;
42017209:	1949      	s32i.n	a4, a9, 4
4201720b:	000206        	j	42017217 <xt_set_interrupt_handler+0x37>
4201720e:	a10000        	sll	a0, a0
    }
    else {
        entry->handler = &xt_unhandled_interrupt;
42017211:	a7cc      	bnez.n	a7, 4201721f <xt_set_interrupt_handler+0x3f>
42017213:	09a9      	s32i.n	a10, a9, 0
        entry->arg     = (void*)n;
42017215:	1989      	s32i.n	a8, a9, 4
    }

    return ((old == &xt_unhandled_interrupt) ? 0 : old);
42017217:	a7ca81        	l32r	a8, 42001140 <_stext+0x1120> (40376cbc <xt_unhandled_interrupt>)
4201721a:	0e9287        	bne	a2, a8, 4201722c <xt_set_interrupt_handler+0x4c>
4201721d:	000246        	j	4201722a <xt_set_interrupt_handler+0x4a>
        return 0;       /* invalid interrupt number */
42017220:	020c      	movi.n	a2, 0
42017222:	000186        	j	4201722c <xt_set_interrupt_handler+0x4c>
        return 0;       /* priority level too high to safely handle in C */
42017225:	020c      	movi.n	a2, 0
42017227:	000046        	j	4201722c <xt_set_interrupt_handler+0x4c>
    return ((old == &xt_unhandled_interrupt) ? 0 : old);
4201722a:	020c      	movi.n	a2, 0
}
4201722c:	f01d      	retw.n
	...
