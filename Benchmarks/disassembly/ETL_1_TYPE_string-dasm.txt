
build/Benchmarks.elf:     file format elf32-xtensa-le


Disassembly of section .iram0.vectors:

40374000 <_WindowOverflow4>:

    .org    0x0
    .global _WindowOverflow4
_WindowOverflow4:

    s32e    a0, a5, -16     /* save a0 to call[j+1]'s stack frame */
40374000:	49c500        	s32e	a0, a5, -16
    s32e    a1, a5, -12     /* save a1 to call[j+1]'s stack frame */
40374003:	49d510        	s32e	a1, a5, -12
    s32e    a2, a5,  -8     /* save a2 to call[j+1]'s stack frame */
40374006:	49e520        	s32e	a2, a5, -8
    s32e    a3, a5,  -4     /* save a3 to call[j+1]'s stack frame */
40374009:	49f530        	s32e	a3, a5, -4
    rfwo                    /* rotates back to call[i] position */
4037400c:	003400        	rfwo
	...

40374040 <_WindowUnderflow4>:

    .org    0x40
    .global _WindowUnderflow4
_WindowUnderflow4:

    l32e    a0, a5, -16     /* restore a0 from call[i+1]'s stack frame */
40374040:	09c500        	l32e	a0, a5, -16
    l32e    a1, a5, -12     /* restore a1 from call[i+1]'s stack frame */
40374043:	09d510        	l32e	a1, a5, -12
    l32e    a2, a5,  -8     /* restore a2 from call[i+1]'s stack frame */
40374046:	09e520        	l32e	a2, a5, -8
    l32e    a3, a5,  -4     /* restore a3 from call[i+1]'s stack frame */
40374049:	09f530        	l32e	a3, a5, -4
    rfwu
4037404c:	003500        	rfwu
	...

40374050 <_xt_alloca_exc>:

    .align  4
    .global _xt_alloca_exc
_xt_alloca_exc:

    rsr     a0, WINDOWBASE  /* grab WINDOWBASE before rotw changes it */
40374050:	034800        	rsr.windowbase	a0
    rotw    -1              /* WINDOWBASE goes to a4, new a0-a3 are scratch */
40374053:	4080f0        	rotw	-1
    rsr     a2, PS
40374056:	03e620        	rsr.ps	a2
    extui   a3, a2, XCHAL_PS_OWB_SHIFT, XCHAL_PS_OWB_BITS
40374059:	343820        	extui	a3, a2, 8, 4
    xor     a3, a3, a4      /* bits changed from old to current windowbase */
4037405c:	303340        	xor	a3, a3, a4
    rsr     a4, EXCSAVE_1   /* restore original a0 (now in a4) */
4037405f:	03d140        	rsr.excsave1	a4
    slli    a3, a3, XCHAL_PS_OWB_SHIFT
40374062:	113380        	slli	a3, a3, 8
    xor     a2, a2, a3      /* flip changed bits in old window base */
40374065:	302230        	xor	a2, a2, a3
    wsr     a2, PS          /* update PS.OWB to new window base */
40374068:	13e620        	wsr.ps	a2
    rsync
4037406b:	002010        	rsync

    bbci.l a4, 31, _WindowUnderflow4
4037406e:	ce74f7        	bbci	a4, 31, 40374040 <_WindowUnderflow4>
    rotw    -1              /* original a0 goes to a8 */
40374071:	4080f0        	rotw	-1
    bbci.l a8, 30, _WindowUnderflow8
40374074:	4878e7        	bbci	a8, 30, 403740c0 <_WindowUnderflow8>
    rotw    -1
40374077:	4080f0        	rotw	-1
    j               _WindowUnderflow12
4037407a:	003086        	j	40374140 <_WindowUnderflow12>
4037407d:	000000        	ill

40374080 <_WindowOverflow8>:

    .org    0x80
    .global _WindowOverflow8
_WindowOverflow8:

    s32e    a0, a9, -16     /* save a0 to call[j+1]'s stack frame */
40374080:	49c900        	s32e	a0, a9, -16
    l32e    a0, a1, -12     /* a0 <- call[j-1]'s sp
40374083:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1, a9, -12     /* save a1 to call[j+1]'s stack frame */
40374086:	49d910        	s32e	a1, a9, -12
    s32e    a2, a9,  -8     /* save a2 to call[j+1]'s stack frame */
40374089:	49e920        	s32e	a2, a9, -8
    s32e    a3, a9,  -4     /* save a3 to call[j+1]'s stack frame */
4037408c:	49f930        	s32e	a3, a9, -4
    s32e    a4, a0, -32     /* save a4 to call[j]'s stack frame */
4037408f:	498040        	s32e	a4, a0, -32
    s32e    a5, a0, -28     /* save a5 to call[j]'s stack frame */
40374092:	499050        	s32e	a5, a0, -28
    s32e    a6, a0, -24     /* save a6 to call[j]'s stack frame */
40374095:	49a060        	s32e	a6, a0, -24
    s32e    a7, a0, -20     /* save a7 to call[j]'s stack frame */
40374098:	49b070        	s32e	a7, a0, -20
    rfwo                    /* rotates back to call[i] position */
4037409b:	003400        	rfwo
	...

403740c0 <_WindowUnderflow8>:

    .org    0xC0
    .global _WindowUnderflow8
_WindowUnderflow8:

    l32e    a0, a9, -16     /* restore a0 from call[i+1]'s stack frame */
403740c0:	09c900        	l32e	a0, a9, -16
    l32e    a1, a9, -12     /* restore a1 from call[i+1]'s stack frame */
403740c3:	09d910        	l32e	a1, a9, -12
    l32e    a2, a9,  -8     /* restore a2 from call[i+1]'s stack frame */
403740c6:	09e920        	l32e	a2, a9, -8
    l32e    a7, a1, -12     /* a7 <- call[i-1]'s sp
403740c9:	09d170        	l32e	a7, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3, a9,  -4     /* restore a3 from call[i+1]'s stack frame */
403740cc:	09f930        	l32e	a3, a9, -4
    l32e    a4, a7, -32     /* restore a4 from call[i]'s stack frame */
403740cf:	098740        	l32e	a4, a7, -32
    l32e    a5, a7, -28     /* restore a5 from call[i]'s stack frame */
403740d2:	099750        	l32e	a5, a7, -28
    l32e    a6, a7, -24     /* restore a6 from call[i]'s stack frame */
403740d5:	09a760        	l32e	a6, a7, -24
    l32e    a7, a7, -20     /* restore a7 from call[i]'s stack frame */
403740d8:	09b770        	l32e	a7, a7, -20
    rfwu
403740db:	003500        	rfwu
	...

40374100 <_WindowOverflow12>:

    .org    0x100
    .global _WindowOverflow12
_WindowOverflow12:

    s32e    a0,  a13, -16   /* save a0 to call[j+1]'s stack frame */
40374100:	49cd00        	s32e	a0, a13, -16
    l32e    a0,  a1,  -12   /* a0 <- call[j-1]'s sp
40374103:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1,  a13, -12   /* save a1 to call[j+1]'s stack frame */
40374106:	49dd10        	s32e	a1, a13, -12
    s32e    a2,  a13,  -8   /* save a2 to call[j+1]'s stack frame */
40374109:	49ed20        	s32e	a2, a13, -8
    s32e    a3,  a13,  -4   /* save a3 to call[j+1]'s stack frame */
4037410c:	49fd30        	s32e	a3, a13, -4
    s32e    a4,  a0,  -48   /* save a4 to end of call[j]'s stack frame */
4037410f:	494040        	s32e	a4, a0, -48
    s32e    a5,  a0,  -44   /* save a5 to end of call[j]'s stack frame */
40374112:	495050        	s32e	a5, a0, -44
    s32e    a6,  a0,  -40   /* save a6 to end of call[j]'s stack frame */
40374115:	496060        	s32e	a6, a0, -40
    s32e    a7,  a0,  -36   /* save a7 to end of call[j]'s stack frame */
40374118:	497070        	s32e	a7, a0, -36
    s32e    a8,  a0,  -32   /* save a8 to end of call[j]'s stack frame */
4037411b:	498080        	s32e	a8, a0, -32
    s32e    a9,  a0,  -28   /* save a9 to end of call[j]'s stack frame */
4037411e:	499090        	s32e	a9, a0, -28
    s32e    a10, a0,  -24   /* save a10 to end of call[j]'s stack frame */
40374121:	49a0a0        	s32e	a10, a0, -24
    s32e    a11, a0,  -20   /* save a11 to end of call[j]'s stack frame */
40374124:	49b0b0        	s32e	a11, a0, -20
    rfwo                    /* rotates back to call[i] position */
40374127:	003400        	rfwo
	...

40374140 <_WindowUnderflow12>:

    .org 0x140
    .global _WindowUnderflow12
_WindowUnderflow12:

    l32e    a0,  a13, -16   /* restore a0 from call[i+1]'s stack frame */
40374140:	09cd00        	l32e	a0, a13, -16
    l32e    a1,  a13, -12   /* restore a1 from call[i+1]'s stack frame */
40374143:	09dd10        	l32e	a1, a13, -12
    l32e    a2,  a13,  -8   /* restore a2 from call[i+1]'s stack frame */
40374146:	09ed20        	l32e	a2, a13, -8
    l32e    a11, a1,  -12   /* a11 <- call[i-1]'s sp
40374149:	09d1b0        	l32e	a11, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3,  a13,  -4   /* restore a3 from call[i+1]'s stack frame */
4037414c:	09fd30        	l32e	a3, a13, -4
    l32e    a4,  a11, -48   /* restore a4 from end of call[i]'s stack frame */
4037414f:	094b40        	l32e	a4, a11, -48
    l32e    a5,  a11, -44   /* restore a5 from end of call[i]'s stack frame */
40374152:	095b50        	l32e	a5, a11, -44
    l32e    a6,  a11, -40   /* restore a6 from end of call[i]'s stack frame */
40374155:	096b60        	l32e	a6, a11, -40
    l32e    a7,  a11, -36   /* restore a7 from end of call[i]'s stack frame */
40374158:	097b70        	l32e	a7, a11, -36
    l32e    a8,  a11, -32   /* restore a8 from end of call[i]'s stack frame */
4037415b:	098b80        	l32e	a8, a11, -32
    l32e    a9,  a11, -28   /* restore a9 from end of call[i]'s stack frame */
4037415e:	099b90        	l32e	a9, a11, -28
    l32e    a10, a11, -24   /* restore a10 from end of call[i]'s stack frame */
40374161:	09aba0        	l32e	a10, a11, -24
    l32e    a11, a11, -20   /* restore a11 from end of call[i]'s stack frame */
40374164:	09bbb0        	l32e	a11, a11, -20
    rfwu
40374167:	003500        	rfwu
	...

40374180 <_Level2Vector>:
    wsr     a0, EXCSAVE_2                   /* preserve a0 */
40374180:	13d200        	wsr.excsave2	a0
    call0   _xt_medint2                     /* load interrupt handler */
40374183:	02fbc5        	call0	40377140 <_xt_medint2>
	...

403741c0 <_Level3Vector>:
    wsr     a0, EXCSAVE_3                   /* preserve a0 */
403741c0:	13d300        	wsr.excsave3	a0
    call0   _xt_medint3                     /* load interrupt handler */
403741c3:	0302c5        	call0	403771f0 <_xt_medint3>
	...

40374200 <_Level4Vector>:
    wsr     a0, EXCSAVE_4                   /* preserve a0 */
40374200:	13d400        	wsr.excsave4	a0
    call0   xt_highint4                     /* load interrupt handler */
40374203:	013b85        	call0	403755bc <xt_highint4>
	...

40374240 <_Level5Vector>:
    wsr     a0, EXCSAVE_5                   /* preserve a0 */
40374240:	13d500        	wsr.excsave5	a0
    call0   xt_highint5                    /* load interrupt handler */
40374243:	030645        	call0	403772a8 <xt_highint5>
	...

40374280 <_DebugExceptionVector>:
    wsr     a0, EXCSAVE+XCHAL_DEBUGLEVEL    /* preserve a0 */
40374280:	13d600        	wsr.excsave6	a0
    J   xt_debugexception            /* load exception handler */
40374283:	0a9346        	j	40376cd4 <xt_debugexception>
	...

403742c0 <_NMIExceptionVector>:
    wsr     a0, EXCSAVE + XCHAL_NMILEVEL   /* preserve a0 */
403742c0:	13d700        	wsr.excsave7	a0
    call0   xt_nmi                         /* load interrupt handler */
403742c3:	02fec5        	call0	403772b0 <xt_nmi>
	...

40374300 <_KernelExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374300:	13d100        	wsr.excsave1	a0
    call0   _xt_kernel_exc                  /* kernel exception handler */
40374303:	029e85        	call0	40376cec <_xt_kernel_exc>
	...

40374340 <_UserExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374340:	13d100        	wsr.excsave1	a0
    call0   _xt_user_exc                    /* user exception handler */
40374343:	029c85        	call0	40376d0c <_xt_user_exc>
	...

403743c0 <_DoubleExceptionVector>:
    break   1, 4                            /* unhandled double exception */
403743c0:	004140        	break	1, 4
    movi    a0,PANIC_RSN_DOUBLEEXCEPTION
403743c3:	200c      	movi.n	a0, 2
    wsr     a0,EXCCAUSE
403743c5:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
403743c8:	03d105        	call0	403780dc <_xt_panic>
    rfde                                    /* make a0 point here not later */
403743cb:	003200        	rfde
	...

40374400 <_invalid_pc_placeholder>:
_invalid_pc_placeholder:
    /* This should be an entry instruction for correct stack unwinding.
     * There could be just a line ".cfi_startproc", but unfortunately,
     * CFI is not supported for the Xtensa architecture. */
#define UNREACHABLE_INSTRUCTION_CHECK_PREVIOUS_FRAMES ENTRY0
    UNREACHABLE_INSTRUCTION_CHECK_PREVIOUS_FRAMES
40374400:	002136        	entry	a1, 16
	...

Disassembly of section .iram0.text:

40374404 <call_start_cpu1-0xd98>:
40374404:	374000        	lsi	f0, a0, 220
40374407:	e0d840        	subx4	a13, a8, a4
4037440a:	600c      	movi.n	a0, 6
4037440c:	e0dc      	bnez.n	a0, 4037442e <_iram_text_start+0x2a>
4037440e:	600c      	movi.n	a0, 6
40374410:	4888      	l32i.n	a8, a8, 16
40374412:	3fc9      	s32i.n	a12, a15, 12
40374414:	c94884        	lsi	f8, a8, 0x324
40374417:	3f          	.byte	0x3f
40374418:	c94880        	lsi	f8, a8, 0x324
4037441b:	3f          	.byte	0x3f
4037441c:	026f34        	lsi	f3, a15, 8
4037441f:	203c      	movi.n	a0, 50
40374421:	400007        	bnone	a0, a0, 40374465 <_iram_text_start+0x61>
40374424:	009170        	all4	b7, b0:b1:b2:b3
40374427:	06c042        	addi	a4, a0, 6
4037442a:	b84000        	lsi	f0, a0, 0x2e0
4037442d:	420013        	lsi	f1, a0, 0x108
40374430:	0019a0        	movsp	a10, a9
40374433:	060042        	l8ui	a4, a0, 6
40374436:	644000        	extui	a4, a0, 0, 7
40374439:	600c40        	lsi	f4, a12, 0x180
4037443c:	0c4004        	lsi	f0, a0, 48
4037443f:	61f060        	xsr.ccompare0	a6
40374442:	3fc9      	s32i.n	a12, a15, 12
40374444:	c94860        	lsi	f6, a8, 0x324
40374447:	3f          	.byte	0x3f
40374448:	000000        	ill
4037444b:	000050        	lsi	f5, a0, 0
4037444e:	005000        	syscall
40374451:	000040        	lsi	f4, a0, 0
40374454:	008000        	any4	b0, b0:b1:b2:b3
40374457:	625600        	lsi	f0, a6, 0x188
4037445a:	204201        	l32r	a0, 4033c564 <rom_rx_gain_force+0x336138>
4037445d:	420000        	xorb	b0, b0, b0
40374460:	ff          	.byte	0xff
40374461:	ff          	.byte	0xff
40374462:	740000        	extui	a0, a0, 0, 8
40374465:	9f          	.byte	0x9f
40374466:	203c02        	lsi	f0, a12, 128
40374469:	3c0200        	lsi	f0, a2, 240
4037446c:	1f3c      	movi.n	a15, 49
4037446e:	3fc9      	s32i.n	a12, a15, 12
40374470:	0202e4        	lsi	f14, a2, 8
40374473:	b43c      	movi.n	a4, 59
40374475:	3c0204        	muls.ad.ll	a2, m2
40374478:	48b8      	l32i.n	a11, a8, 16
4037447a:	3fc9      	s32i.n	a12, a15, 12
4037447c:	0204d0        	andb	b0, b4, b13
4037447f:	543c      	movi.n	a4, 53
40374481:	6e          	.byte	0x6e
40374482:	343c02        	lsi	f0, a12, 208
40374485:	3c0205        	call0	403b04a8 <_coredump_iram_end+0x2e5a8>
40374488:	0578      	l32i.n	a7, a5, 0
4037448a:	7c3c02        	lsi	f0, a12, 0x1f0
4037448d:	400005        	call0	403b4490 <_coredump_iram_end+0x32590>
40374490:	11e8      	l32i.n	a14, a1, 4
40374492:	1c4000        	lsi	f0, a0, 112
40374495:	001a      	add.n	a0, a0, a1
40374497:	1a2840        	sub.s	f2, f8, f4
4037449a:	c04000        	sub	a4, a0, a0
4037449d:	0018      	l32i.n	a1, a0, 0
4037449f:	191440        	lsi	f4, a4, 100
403744a2:	784000        	lsi	f0, a0, 0x1e0
403744a5:	420091        	l32r	a9, 40344ca8 <rom_rx_gain_force+0x33e87c>
403744a8:	0015b0        	movsp	a11, a5
403744ab:	92d842        	addmi	a4, a8, 0xffff9200
403744ae:	6c4200        	lsi	f0, a2, 0x1b0
403744b1:	009b      	addi.n	a0, a0, 9
403744b3:	05d042        	addmi	a4, a0, 0x500
403744b6:	dc4000        	lsi	f0, a0, 0x370
403744b9:	420013        	lsi	f1, a0, 0x108
403744bc:	001950        	movsp	a5, a9
403744bf:	15d840        	extui	a13, a4, 24, 2
403744c2:	004200        	break	2, 0
403744c5:	420017        	bnone	a0, a1, 4037450b <_iram_text_start+0x107>
403744c8:	0030e4        	lsi	f14, a0, 0
403744cb:	3b0842        	l8ui	a4, a8, 59
403744ce:	644200        	extui	a4, a0, 2, 7
403744d1:	4f          	.byte	0x4f
403744d2:	f44200        	extui	a4, a0, 2, 16
403744d5:	400011        	l32r	a1, 403444d8 <rom_rx_gain_force+0x33e0ac>
403744d8:	50ec      	bnez.n	a0, 40374501 <_iram_text_start+0xfd>
403744da:	bc4200        	lsi	f0, a2, 0x2f0
403744dd:	420027        	bnone	a0, a2, 40374523 <_iram_text_start+0x11f>
403744e0:	008000        	any4	b0, b0:b1:b2:b3
403744e3:	27c860        	lsi	f6, a8, 156
403744e6:	3fc9      	s32i.n	a12, a15, 12
403744e8:	279c      	beqz.n	a7, 403744fe <_iram_text_start+0xfa>
403744ea:	3fc9      	s32i.n	a12, a15, 12
403744ec:	0c0020        	lsi	f2, a0, 48
403744ef:	001860        	movsp	a6, a8
403744f2:	600c      	movi.n	a0, 6
403744f4:	069c      	beqz.n	a6, 40374508 <_iram_text_start+0x104>
403744f6:	d84000        	lsi	f0, a0, 0x360
403744f9:	400006        	j	403844fd <_coredump_iram_end+0x25fd>
403744fc:	ff          	.byte	0xff
403744fd:	ff          	.byte	0xff
403744fe:	ff          	.byte	0xff
403744ff:	9cfd      	lsi	f15, a12, 48
40374501:	c948      	l32i.n	a4, a9, 48
40374503:	3f          	.byte	0x3f
40374504:	040025        	call8	40378508 <mspi_timing_set_pin_drive_strength+0x34>
40374507:	59f800        	s32nb	a0, a8, 60
4037450a:	ff4037        	ball	a0, a3, 4037450d <_iram_text_start+0x109>
4037450d:	7f          	.byte	0x7f
4037450e:	5c0000        	lsi	f0, a0, 0x170
40374511:	3c0206        	j	4038351d <_coredump_iram_end+0x161d>
40374514:	6e88      	l32i.n	a8, a14, 24
40374516:	ad3c02        	lsi	f0, a12, 0x2b4
40374519:	3c0206        	j	40383525 <_coredump_iram_end+0x1625>
4037451c:	000000        	ill
4037451f:	80c880        	add	a12, a8, a8
40374522:	186000        	lsxp	f6, a0, a0
40374525:	600260        	lsi	f6, a2, 0x180
40374528:	af          	.byte	0xaf
40374529:	3f          	.byte	0x3f
4037452a:	070000        	lsi	f0, a0, 28
4037452d:	201200        	or	a1, a2, a0
40374530:	0c0024        	lsi	f2, a0, 48
40374533:	004460        	break	4, 6
40374536:	600c      	movi.n	a0, 6
40374538:	026ea4        	lsi	f10, a14, 8
4037453b:	ac3c      	movi.n	a12, 58
4037453d:	6e          	.byte	0x6e
4037453e:	543c02        	lsi	f0, a12, 0x150
40374541:	600041        	l32r	a4, 4034c544 <rom_rx_gain_force+0x346118>
40374544:	4158      	l32i.n	a5, a1, 16
40374546:	5c6000        	lsi	f0, a0, 0x170
40374549:	600041        	l32r	a4, 4034c54c <rom_rx_gain_force+0x346120>
4037454c:	004160        	break	1, 6
4037454f:	416460        	srli	a6, a6, 4
40374552:	686000        	lsi	f0, a0, 0x1a0
40374555:	600041        	l32r	a4, 4034c558 <rom_rx_gain_force+0x34612c>
40374558:	0c0004        	lsi	f0, a0, 48
4037455b:	0dbc60        	lsi	f6, a12, 52
4037455e:	444000        	extui	a4, a0, 0, 5
40374561:	400025        	call8	403b4564 <_coredump_iram_end+0x32664>
40374564:	000de0        	callx8	a13
40374567:	0dd440        	lsi	f4, a4, 52
4037456a:	284000        	lsi	f0, a0, 160
4037456d:	0e          	.byte	0xe
4037456e:	ec4000        	lsi	f0, a0, 0x3b0
40374571:	000d      	mov.n	a0, a0
40374573:	0e0440        	lsi	f4, a4, 56
40374576:	6c4000        	lsi	f0, a0, 0x1b0
40374579:	0018      	l32i.n	a1, a0, 0
4037457b:	188440        	lsxp	f8, a4, a4
4037457e:	e44000        	extui	a4, a0, 0, 15
40374581:	400006        	j	40384585 <_coredump_iram_end+0x2685>
40374584:	c91f00        	lsi	f0, a15, 0x324
40374587:	3f          	.byte	0x3f
40374588:	c948a0        	lsi	f10, a8, 0x324
4037458b:	3f          	.byte	0x3f
4037458c:	0e1c      	movi.n	a14, 16
4037458e:	b04000        	addx8	a4, a0, a0
40374591:	c948      	l32i.n	a4, a9, 48
40374593:	3f          	.byte	0x3f
40374594:	48ac      	beqz.n	a8, 403745bc <_iram_text_start+0x1b8>
40374596:	3fc9      	s32i.n	a12, a15, 12
40374598:	c948b1        	l32r	a11, 40366ab8 <rom_rx_gain_force+0x36068c>
4037459b:	3f          	.byte	0x3f
4037459c:	1f6c      	movi.n	a15, -31
4037459e:	304200        	xor	a4, a2, a0
403745a1:	015c      	movi.n	a1, 80
403745a3:	18f042        	s32ri	a4, a0, 96
403745a6:	a84200        	lsi	f0, a2, 0x2a0
403745a9:	420020        	xorb	b0, b0, b2
403745ac:	48c8      	l32i.n	a12, a8, 16
403745ae:	3fc9      	s32i.n	a12, a15, 12
403745b0:	1f1c      	movi.n	a15, 17
403745b2:	3fc9      	s32i.n	a12, a15, 12
403745b4:	000000        	ill
403745b7:	003c10        	rfi	12
403745ba:	600c      	movi.n	a0, 6
403745bc:	0038      	l32i.n	a3, a0, 0
403745be:	600c      	movi.n	a0, 6
403745c0:	c948d4        	lsi	f13, a8, 0x324
403745c3:	3f          	.byte	0x3f
403745c4:	c948d0        	lsi	f13, a8, 0x324
403745c7:	3f          	.byte	0x3f
403745c8:	48cc      	bnez.n	a8, 403745d0 <_iram_text_start+0x1cc>
403745ca:	3fc9      	s32i.n	a12, a15, 12
403745cc:	1f18      	l32i.n	a1, a15, 4
403745ce:	3fc9      	s32i.n	a12, a15, 12
403745d0:	09c8      	l32i.n	a12, a9, 0
403745d2:	643c02        	lsi	f0, a12, 0x190
403745d5:	0e          	.byte	0xe
403745d6:	683c02        	lsi	f0, a12, 0x1a0
403745d9:	0e          	.byte	0xe
403745da:	883c02        	lsi	f0, a12, 0x220
403745dd:	001c      	movi.n	a0, 16
403745df:	1cb442        	l32ai	a4, a4, 112
403745e2:	f04200        	subx8	a4, a2, a0
403745e5:	7f          	.byte	0x7f
403745e6:	e0c037        	bnall	a0, a3, 403745ca <_iram_text_start+0x1c6>
403745e9:	7f          	.byte	0x7f
403745ea:	000007        	bnone	a0, a0, 403745ee <_iram_text_start+0x1ea>
403745ed:	9ff020        	f64cmph	a15, a0, a2, 9
403745f0:	ff          	.byte	0xff
403745f1:	1f          	.byte	0x1f
403745f2:	000000        	ill
403745f5:	400000        	ssr	a0
403745f8:	fffd      	lsi	f15, a15, 60
403745fa:	ff          	.byte	0xff
403745fb:	ffbd      	lsi	f11, a15, 60
403745fd:	ff          	.byte	0xff
403745fe:	ff          	.byte	0xff
403745ff:	fffd01        	l32r	a0, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40374602:	bfc8      	l32i.n	a12, a15, 44
40374604:	ff          	.byte	0xff
40374605:	ff          	.byte	0xff
40374606:	fd0006        	j	40373a0a <rom_rx_gain_force+0x36d5de>
40374609:	ff          	.byte	0xff
4037460a:	ff          	.byte	0xff
4037460b:	bf          	.byte	0xbf
4037460c:	ff          	.byte	0xff
4037460d:	ff          	.byte	0xff
4037460e:	fd0005        	call0	40371610 <rom_rx_gain_force+0x36b1e4>
40374611:	1f          	.byte	0x1f
40374612:	7c9ff0        	lsi	f15, a15, 0x1f0
40374615:	0e          	.byte	0xe
40374616:	8c3c02        	lsi	f0, a12, 0x230
40374619:	0e          	.byte	0xe
4037461a:	9c3c02        	lsi	f0, a12, 0x270
4037461d:	0e          	.byte	0xe
4037461e:	ac3c02        	lsi	f0, a12, 0x2b0
40374621:	0e          	.byte	0xe
40374622:	203c02        	lsi	f0, a12, 128
40374625:	0f          	.byte	0xf
40374626:	5c3c02        	lsi	f0, a12, 0x170
40374629:	3c0270        	lsi	f7, a2, 240
4037462c:	0f58      	l32i.n	a5, a15, 0
4037462e:	e03c02        	lsi	f0, a12, 0x380
40374631:	c948      	l32i.n	a4, a9, 48
40374633:	3f          	.byte	0x3f
40374634:	c948e4        	lsi	f14, a8, 0x324
40374637:	3f          	.byte	0x3f
40374638:	48d8      	l32i.n	a13, a8, 16
4037463a:	3fc9      	s32i.n	a12, a15, 12
4037463c:	48fc      	bnez.n	a8, 40374674 <_iram_text_start+0x270>
4037463e:	3fc9      	s32i.n	a12, a15, 12
40374640:	c948f4        	lsi	f15, a8, 0x324
40374643:	3f          	.byte	0x3f
40374644:	48ec      	bnez.n	a8, 4037466c <_iram_text_start+0x268>
40374646:	3fc9      	s32i.n	a12, a15, 12
40374648:	c94904        	lsi	f0, a9, 0x324
4037464b:	3f          	.byte	0x3f
4037464c:	226c      	movi.n	a2, -30
4037464e:	1c4200        	lsi	f0, a2, 112
40374651:	c949      	s32i.n	a4, a9, 48
40374653:	3f          	.byte	0x3f
40374654:	007000        	waiti	0
40374657:	285860        	lsi	f6, a8, 160
4037465a:	b03c02        	lsi	f0, a12, 0x2c0
4037465d:	c94a      	add.n	a12, a9, a4
4037465f:	3f          	.byte	0x3f
40374660:	77d8      	l32i.n	a13, a7, 28
40374662:	403c02        	lsi	f0, a12, 0x100
40374665:	1f          	.byte	0x1f
40374666:	3fc9      	s32i.n	a12, a15, 12
40374668:	001800        	movsp	a0, a8
4037466b:	140000        	extui	a0, a0, 0, 2
4037466e:	000000        	ill
40374671:	000010        	lsi	f1, a0, 0
40374674:	77bc      	beqz.n	a7, 403746af <_iram_text_start+0x2ab>
40374676:	8c3c02        	lsi	f0, a12, 0x230
40374679:	3c0277        	bnone	a2, a7, 403746b9 <_iram_text_start+0x2b5>
4037467c:	0277a0        	andb	b7, b7, b10
4037467f:	783c      	movi.n	a8, 55
40374681:	3c0277        	bnone	a2, a7, 403746c1 <_iram_text_start+0x2bd>
40374684:	378000        	lsi	f0, a0, 220
40374687:	7fffc0        	f64cmph	a15, a15, a12, 7
4037468a:	d40006        	j	4036968e <rom_rx_gain_force+0x363262>
4037468d:	3c0232        	l8ui	a3, a2, 60
40374690:	7ad8      	l32i.n	a13, a10, 28
40374692:	3e3c02        	lsi	f0, a12, 248
40374695:	3c0233        	lsi	f3, a2, 240
40374698:	7ffc      	bnez.n	a15, 403746d3 <_iram_text_start+0x2cf>
4037469a:	fcc037        	bnall	a0, a3, 4037469a <_iram_text_start+0x296>
4037469d:	1f          	.byte	0x1f
4037469e:	509ff0        	lsi	f15, a15, 0x140
403746a1:	3c0233        	lsi	f3, a2, 240
403746a4:	0233a0        	andb	b3, b3, b10
403746a7:	b43c      	movi.n	a4, 59
403746a9:	3c0233        	lsi	f3, a2, 240
403746ac:	6f0000        	f64cmph	a0, a0, a0, 6
403746af:	800000        	add	a0, a0, a0
403746b2:	bfc8      	l32i.n	a12, a15, 44
403746b4:	c94ab4        	lsi	f11, a10, 0x324
403746b7:	3f          	.byte	0x3f
403746b8:	0233c4        	lsi	f12, a3, 8
403746bb:	f03c      	movi.n	a0, 63
403746bd:	027a      	add.n	a0, a2, a7
403746bf:	003c      	movi.n	a0, 48
403746c1:	020000        	andb	b0, b0, b0
403746c4:	023404        	lsi	f0, a4, 8
403746c7:	c03c      	movi.n	a0, 60
403746c9:	027a      	add.n	a0, a2, a7
403746cb:	403c      	movi.n	a0, 52
403746cd:	3c0234        	lsi	f3, a2, 240
403746d0:	0f4240        	f64cmph	a4, a2, a4, 0
403746d3:	1a4000        	sub.s	f4, f0, f0
403746d6:	504000        	iitlb	a0
403746d9:	1f          	.byte	0x1f
403746da:	3fc9      	s32i.n	a12, a15, 12
403746dc:	c94ac4        	lsi	f12, a10, 0x324
403746df:	3f          	.byte	0x3f
403746e0:	4ab8      	l32i.n	a11, a10, 16
403746e2:	3fc9      	s32i.n	a12, a15, 12
403746e4:	4abc      	beqz.n	a10, 4037471c <_iram_text_start+0x318>
403746e6:	3fc9      	s32i.n	a12, a15, 12
403746e8:	0234a4        	lsi	f10, a4, 8
403746eb:	203c      	movi.n	a0, 50
403746ed:	027b      	addi.n	a0, a2, 7
403746ef:	d03c      	movi.n	a0, 61
403746f1:	3c0234        	lsi	f3, a2, 240
403746f4:	001b54        	lsi	f5, a11, 0
403746f7:	1f5840        	f64cmph	a5, a8, a4, 1
403746fa:	3fc9      	s32i.n	a12, a15, 12
403746fc:	c94ad0        	lsi	f13, a10, 0x324
403746ff:	3f          	.byte	0x3f
40374700:	8048      	l32i.n	a4, a0, 32
40374702:	1c6000        	lsi	f0, a0, 112
40374705:	c929      	s32i.n	a2, a9, 48
40374707:	3f          	.byte	0x3f
40374708:	c92924        	lsi	f2, a9, 0x324
4037470b:	3f          	.byte	0x3f
4037470c:	804c      	movi.n	a0, 72
4037470e:	286000        	lsi	f0, a0, 160
40374711:	c929      	s32i.n	a2, a9, 48
40374713:	3f          	.byte	0x3f
40374714:	292c      	movi.n	a9, 34
40374716:	3fc9      	s32i.n	a12, a15, 12
40374718:	c92930        	lsi	f3, a9, 0x324
4037471b:	3f          	.byte	0x3f
4037471c:	c91f60        	lsi	f6, a15, 0x324
4037471f:	3f          	.byte	0x3f
40374720:	005d54        	lsi	f5, a13, 0
40374723:	5d6040        	lsi	f4, a0, 0x174
40374726:	6c4000        	lsi	f0, a0, 0x1b0
40374729:	005d      	mov.n	a5, a0
4037472b:	4de040        	lsi	f4, a0, 0x134
4037472e:	3fc9      	s32i.n	a12, a15, 12
40374730:	c92000        	lsi	f0, a0, 0x324
40374733:	3f          	.byte	0x3f
40374734:	024da4        	lsi	f10, a13, 8
40374737:	903c      	movi.n	a0, 57
40374739:	3c0282        	l8ui	a8, a2, 60
4037473c:	4dec      	bnez.n	a13, 40374764 <_iram_text_start+0x360>
4037473e:	f43c02        	lsi	f0, a12, 0x3d0
40374741:	024d      	mov.n	a4, a2
40374743:	bc3c      	movi.n	a12, 59
40374745:	3c0282        	l8ui	a8, a2, 60
40374748:	2b98      	l32i.n	a9, a11, 8
4037474a:	a43c02        	lsi	f0, a12, 0x290
4037474d:	3c0282        	l8ui	a8, a2, 60
40374750:	4e08      	l32i.n	a0, a14, 16
40374752:	d43c02        	lsi	f0, a12, 0x350
40374755:	3c0282        	l8ui	a8, a2, 60
40374758:	10c433        	ssip	f3, a4, 64
4037475b:	58bb      	addi.n	a5, a8, 11
4037475d:	4e          	.byte	0x4e
4037475e:	3fc9      	s32i.n	a12, a15, 12
40374760:	c94e04        	lsi	f0, a14, 0x324
40374763:	3f          	.byte	0x3f
40374764:	5bac      	beqz.n	a11, 4037478d <_iram_text_start+0x389>
40374766:	644200        	extui	a4, a0, 2, 7
40374769:	005c      	movi.n	a0, 80
4037476b:	257442        	lsi	f4, a4, 148
4037476e:	a44000        	extui	a4, a0, 0, 11
40374771:	3fc926        	beqi	a9, 32, 403747b4 <_iram_text_start+0x3b0>
40374774:	4ed8      	l32i.n	a13, a14, 16
40374776:	3fc9      	s32i.n	a12, a15, 12
40374778:	c94ee0        	lsi	f14, a14, 0x324
4037477b:	3f          	.byte	0x3f
4037477c:	038000        	rsr.ibreaka0	a0
4037477f:	4ef060        	f64rnd	a15, a0, a6, 0
40374782:	3fc9      	s32i.n	a12, a15, 12
40374784:	4eec      	bnez.n	a14, 403747ac <_iram_text_start+0x3a8>
40374786:	3fc9      	s32i.n	a12, a15, 12
40374788:	5b1c      	movi.n	a11, 21
4037478a:	243c02        	lsi	f0, a12, 144
4037478d:	000400        	lsi	f0, a4, 0
40374790:	000000        	ill
40374793:	23b8c0        	sext	a11, a8, 19
40374796:	3fc9      	s32i.n	a12, a15, 12
40374798:	6da8      	l32i.n	a10, a13, 24
4037479a:	d04037        	ball	a0, a3, 4037476e <_iram_text_start+0x36a>
4037479d:	3c0284        	lsi	f8, a2, 240
403747a0:	c925c0        	lsi	f12, a5, 0x324
403747a3:	3f          	.byte	0x3f
403747a4:	c925e0        	lsi	f14, a5, 0x324
403747a7:	3f          	.byte	0x3f
403747a8:	0284b0        	andb	b8, b4, b11
403747ab:	213c      	movi.n	a1, 50
403747ad:	000400        	lsi	f0, a4, 0
403747b0:	ff          	.byte	0xff
403747b1:	000637        	bnone	a6, a3, 403747b5 <_iram_text_start+0x3b1>
403747b4:	21b8      	l32i.n	a11, a1, 8
403747b6:	3fc9      	s32i.n	a12, a15, 12
403747b8:	71dc      	bnez.n	a1, 403747d3 <_iram_text_start+0x3cf>
403747ba:	224037        	ball	a0, a3, 403747e0 <_iram_text_start+0x3dc>
403747bd:	000400        	lsi	f0, a4, 0
403747c0:	380000        	lsi	f0, a0, 224
403747c3:	728c00        	lsi	f0, a12, 0x1c8
403747c6:	234037        	ball	a0, a3, 403747ed <_iram_text_start+0x3e9>
403747c9:	000400        	lsi	f0, a4, 0
403747cc:	c08800        	sub	a8, a8, a0
403747cf:	e428      	l32i.n	a2, a4, 56
403747d1:	025b      	addi.n	a0, a2, 5
403747d3:	0c3c      	movi.n	a12, 48
403747d5:	3c0286        	j	403837e3 <_coredump_iram_end+0x18e3>
403747d8:	5c2d      	lsi	f2, a12, 48
403747da:	403c02        	lsi	f0, a12, 0x100
403747dd:	025c      	movi.n	a2, 80
403747df:	003c      	movi.n	a0, 48
403747e1:	600020        	neg	a0, a2
403747e4:	200000        	or	a0, a0, a0
403747e7:	000000        	ill
403747ea:	ff7000        	f64cmph	a7, a0, a0, 15
403747ed:	ff          	.byte	0xff
403747ee:	ff          	.byte	0xff
403747ef:	bf          	.byte	0xbf
403747f0:	ceffe4        	lsi	f14, a15, 0x338
403747f3:	3f          	.byte	0x3f
403747f4:	ff          	.byte	0xff
403747f5:	ff          	.byte	0xff
403747f6:	ff          	.byte	0xff
403747f7:	df          	.byte	0xdf
403747f8:	ff          	.byte	0xff
403747f9:	ff          	.byte	0xff
403747fa:	ff          	.byte	0xff
403747fb:	fffff7        	bbsi	a15, 31, 403747fe <_iram_text_start+0x3fa>
403747fe:	ff          	.byte	0xff
403747ff:	ef          	.byte	0xef
40374800:	040000        	extui	a0, a0, 0, 1
40374803:	205800        	or	a5, a8, a0
40374806:	ff6000        	f64cmph	a6, a0, a0, 15
40374809:	ff          	.byte	0xff
4037480a:	ff          	.byte	0xff
4037480b:	7f          	.byte	0x7f
4037480c:	003000        	rfe
4037480f:	ffff60        	f64cmph	a15, a15, a6, 15
40374812:	ff          	.byte	0xff
40374813:	ffff41        	l32r	a4, 40374810 <_iram_text_start+0x40c> (41ffffff <_coredump_iram_end+0x1c7e0ff>)
40374816:	ff          	.byte	0xff
40374817:	ffff43        	lsi	f4, a15, 0x3fc
4037481a:	ff          	.byte	0xff
4037481b:	ff3b      	addi.n	a15, a15, 3
4037481d:	ff          	.byte	0xff
4037481e:	ff          	.byte	0xff
4037481f:	983d      	lsi	f3, a8, 32
40374821:	3c0245        	call0	403b0848 <_coredump_iram_end+0x2e948>
40374824:	868c      	beqz.n	a6, 40374830 <_iram_text_start+0x42c>
40374826:	803c02        	lsi	f0, a12, 0x200
40374829:	3c0204        	muls.ad.ll	a2, m2
4037482c:	5eac      	beqz.n	a14, 40374855 <_iram_text_start+0x451>
4037482e:	3fc9      	s32i.n	a12, a15, 12
40374830:	0008      	l32i.n	a0, a0, 0
40374832:	0e          	.byte	0xe
40374833:	ffff00        	f64cmph	a15, a15, a0, 15
40374836:	fff9      	s32i.n	a15, a15, 60
40374838:	ff          	.byte	0xff
40374839:	ff          	.byte	0xff
4037483a:	fffff7        	bbsi	a15, 31, 4037483d <_iram_text_start+0x439>
4037483d:	7f          	.byte	0x7f
4037483e:	d40007        	bnone	a0, a0, 40374816 <_iram_text_start+0x412>
40374841:	3c0260        	lsi	f6, a2, 240
40374844:	8718      	l32i.n	a1, a7, 32
40374846:	c33c02        	lsi	f0, a12, 0x30c
40374849:	3c0260        	lsi	f6, a2, 240
4037484c:	260c      	movi.n	a6, 2
4037484e:	3fc9      	s32i.n	a12, a15, 12
40374850:	60fc      	bnez.n	a0, 4037488a <_iram_text_start+0x486>
40374852:	143c02        	lsi	f0, a12, 80
40374855:	3c0261        	l32r	a6, 40343860 <rom_rx_gain_force+0x33d434>
40374858:	5edb      	addi.n	a5, a14, 13
4037485a:	3fc9      	s32i.n	a12, a15, 12
4037485c:	377980        	lsi	f8, a9, 220
4037485f:	5ee040        	f64rnd	a14, a0, a4, 1
40374862:	3fc9      	s32i.n	a12, a15, 12
40374864:	99cc      	bnez.n	a9, 40374871 <_iram_text_start+0x46d>
40374866:	cc4200        	lsi	f0, a2, 0x330
40374869:	420025        	call8	403b686c <_coredump_iram_end+0x3496c>
4037486c:	5eda      	add.n	a5, a14, a13
4037486e:	3fc9      	s32i.n	a12, a15, 12
40374870:	6128      	l32i.n	a2, a1, 24
40374872:	e43c02        	lsi	f0, a12, 0x390
40374875:	3c0286        	j	40383883 <_coredump_iram_end+0x1983>
40374878:	026140        	andb	b6, b1, b4
4037487b:	e03c      	movi.n	a0, 62
4037487d:	0099      	s32i.n	a9, a0, 0
4037487f:	000042        	l8ui	a4, a0, 0
40374882:	ff          	.byte	0xff
40374883:	ff          	.byte	0xff
40374884:	010000        	slli	a0, a0, 32
40374887:	5ee800        	f64rnd	a14, a8, a0, 1
4037488a:	3fc9      	s32i.n	a12, a15, 12
4037488c:	000894        	lsi	f9, a8, 0
4037488f:	355840        	extui	a5, a4, 24, 4
40374892:	3fc9      	s32i.n	a12, a15, 12
40374894:	006003        	lsi	f0, a0, 0
40374897:	5eec00        	f64rnd	a14, a12, a0, 1
4037489a:	3fc9      	s32i.n	a12, a15, 12
4037489c:	264c      	movi.n	a6, 66
4037489e:	3fc9      	s32i.n	a12, a15, 12
403748a0:	356c      	movi.n	a5, -29
403748a2:	3fc9      	s32i.n	a12, a15, 12
403748a4:	026294        	lsi	f9, a2, 8
403748a7:	053c      	movi.n	a5, 48
403748a9:	000060        	lsi	f6, a0, 0
403748ac:	0262b4        	lsi	f11, a2, 8
403748af:	fc3c      	movi.n	a12, 63
403748b1:	3c0263        	lsi	f6, a2, 240
403748b4:	000000        	ill
403748b7:	62dc01        	l32r	a0, 4034d428 <rom_rx_gain_force+0x346ffc>
403748ba:	903c02        	lsi	f0, a12, 0x240
403748bd:	3c0287        	bnone	a2, a8, 403748fd <_iram_text_start+0x4f9>
403748c0:	634c      	movi.n	a3, 70
403748c2:	c43c02        	lsi	f0, a12, 0x310
403748c5:	009b      	addi.n	a0, a0, 9
403748c7:	270f42        	l8ui	a4, a15, 39
403748ca:	1f0000        	f64cmph	a0, a0, a0, 1
403748cd:	4e          	.byte	0x4e
403748ce:	080000        	lsx	f0, a0, a0
403748d1:	3c0266        	bnei	a2, -1, 40374911 <_iram_text_start+0x50d>
403748d4:	886c      	movi.n	a8, -24
403748d6:	373c02        	lsi	f0, a12, 220
403748d9:	3c0266        	bnei	a2, -1, 40374919 <_iram_text_start+0x515>
403748dc:	000804        	lsi	f0, a8, 0
403748df:	2b5800        	oeq.s	b5, f8, f0
403748e2:	4c4200        	lsi	f0, a2, 0x130
403748e5:	4200a4        	lsi	f10, a0, 0x108
403748e8:	a49c      	beqz.n	a4, 40374906 <_iram_text_start+0x502>
403748ea:	304200        	xor	a4, a2, a0
403748ed:	600c00        	lsi	f0, a12, 0x180
403748f0:	0c0034        	lsi	f3, a0, 48
403748f3:	267460        	lsi	f6, a4, 152
403748f6:	3fc9      	s32i.n	a12, a15, 12
403748f8:	026650        	andb	b6, b6, b5
403748fb:	883c      	movi.n	a8, 56
403748fd:	0288      	l32i.n	a8, a2, 0
403748ff:	983c      	movi.n	a8, 57
40374901:	3c0266        	bnei	a2, -1, 40374941 <_iram_text_start+0x53d>
40374904:	5ef8      	l32i.n	a15, a14, 20
40374906:	3fc9      	s32i.n	a12, a15, 12
40374908:	000000        	ill
4037490b:	00fc      	bnez.n	a0, 4037493f <_iram_text_start+0x53b>
4037490d:	03f000        	rsr.ccompare0	a0
40374910:	023450        	andb	b3, b4, b5
40374913:	103c      	movi.n	a0, 49
40374915:	027b      	addi.n	a0, a2, 7
40374917:	9c3c      	movi.n	a12, 57
40374919:	3c0234        	lsi	f3, a2, 240
4037491c:	008000        	any4	b0, b0:b1:b2:b3
4037491f:	80bc60        	add	a11, a12, a6
40374922:	006000        	rsil	a0, 0
40374925:	027b      	addi.n	a0, a2, 7
40374927:	2c3c      	movi.n	a12, 50
40374929:	c938      	l32i.n	a3, a9, 48
4037492b:	3f          	.byte	0x3f
4037492c:	36e8      	l32i.n	a14, a6, 12
4037492e:	3fc9      	s32i.n	a12, a15, 12
40374930:	c93980        	lsi	f8, a9, 0x324
40374933:	3f          	.byte	0x3f
40374934:	060003        	lsi	f0, a0, 24
40374937:	39b400        	lsi	f0, a4, 228
4037493a:	3fc9      	s32i.n	a12, a15, 12
4037493c:	3708      	l32i.n	a0, a7, 12
4037493e:	3fc9      	s32i.n	a12, a15, 12
40374940:	c93a00        	lsi	f0, a10, 0x324
40374943:	3f          	.byte	0x3f
40374944:	003014        	lsi	f1, a0, 0
40374947:	201460        	or	a1, a4, a6
4037494a:	c46000        	extui	a6, a0, 0, 13
4037494d:	3fc936        	entry	a9, 0x1fe0
40374950:	003050        	lsi	f5, a0, 0
40374953:	33fc60        	clamps	a15, a12, 13
40374956:	2c6000        	lsi	f0, a0, 176
40374959:	3fc937        	bnall	a9, a3, 4037499c <_iram_text_start+0x598>
4037495c:	000c00        	lsi	f0, a12, 0
4037495f:	4b0800        	olt.s	b0, f8, f0
40374962:	3fc9      	s32i.n	a12, a15, 12
40374964:	3868      	l32i.n	a6, a8, 12
40374966:	3fc9      	s32i.n	a12, a15, 12
40374968:	c93750        	lsi	f5, a7, 0x324
4037496b:	3f          	.byte	0x3f
4037496c:	38b9      	s32i.n	a11, a8, 12
4037496e:	3fc9      	s32i.n	a12, a15, 12
40374970:	0c0010        	lsi	f1, a0, 48
40374973:	e04060        	subx4	a4, a0, a6
40374976:	006000        	rsil	a0, 0
40374979:	c94b      	addi.n	a12, a9, 4
4037497b:	3f          	.byte	0x3f
4037497c:	0084c0        	any4	b12, b4:b5:b6:b7
4037497f:	000060        	lsi	f6, a0, 0
40374982:	0008      	l32i.n	a0, a0, 0
40374984:	0084c4        	lsi	f12, a4, 0
40374987:	806060        	add	a6, a0, a6
4037498a:	ff6000        	f64cmph	a6, a0, a0, 15
4037498d:	ff          	.byte	0xff
4037498e:	7f          	.byte	0x7f
4037498f:	ff          	.byte	0xff
40374990:	ff          	.byte	0xff
40374991:	ff          	.byte	0xff
40374992:	00fff1        	l32r	a15, 40334d90 <rom_rx_gain_force+0x32e964>
40374995:	000600        	lsi	f0, a6, 0
40374998:	ff          	.byte	0xff
40374999:	1f          	.byte	0x1f
4037499a:	ff          	.byte	0xff
4037499b:	ff          	.byte	0xff
4037499c:	ff          	.byte	0xff
4037499d:	ffffe3        	lsi	f14, a15, 0x3fc
403749a0:	ff          	.byte	0xff
403749a1:	ff          	.byte	0xff
403749a2:	fe          	.byte	0xfe
403749a3:	ff          	.byte	0xff
403749a4:	009040        	all4	b4, b0:b1:b2:b3
403749a7:	890460        	lsi	f6, a4, 0x224
403749aa:	d86000        	lsi	f0, a0, 0x360
403749ad:	600080        	neg	a0, a8
403749b0:	800000        	add	a0, a0, a0
403749b3:	807400        	add	a7, a4, a0
403749b6:	1c6000        	lsi	f0, a0, 112
403749b9:	600080        	neg	a0, a8
403749bc:	3f          	.byte	0x3f
403749bd:	ffffc0        	f64cmph	a15, a15, a12, 15
403749c0:	382c      	movi.n	a8, 35
403749c2:	3fc9      	s32i.n	a12, a15, 12
403749c4:	c93780        	lsi	f8, a7, 0x324
403749c7:	3f          	.byte	0x3f
403749c8:	c938c4        	lsi	f12, a8, 0x324
403749cb:	3f          	.byte	0x3f
403749cc:	005984        	lsi	f8, a9, 0
403749cf:	134042        	s8i	a4, a0, 19
403749d2:	070002        	l8ui	a0, a0, 7
403749d5:	010b      	addi.n	a0, a1, -1
403749d7:	000000        	ill
403749da:	c02000        	sub	a2, a0, a0
403749dd:	600080        	neg	a0, a8
403749e0:	38fc      	bnez.n	a8, 40374a17 <_iram_text_start+0x613>
403749e2:	3fc9      	s32i.n	a12, a15, 12
403749e4:	c93904        	lsi	f0, a9, 0x324
403749e7:	3f          	.byte	0x3f
403749e8:	0c0060        	lsi	f6, a0, 48
403749eb:	394060        	lsi	f6, a0, 228
403749ee:	3fc9      	s32i.n	a12, a15, 12
403749f0:	c94b04        	lsi	f0, a11, 0x324
403749f3:	3f          	.byte	0x3f
403749f4:	666667        	bbci	a6, 6, 40374a5e <_iram_text_start+0x65a>
403749f7:	1f7066        	bnei	a0, 7, 40374a1a <_iram_text_start+0x616>
403749fa:	3fc9      	s32i.n	a12, a15, 12
403749fc:	c91f74        	lsi	f7, a15, 0x324
403749ff:	3f          	.byte	0x3f
40374a00:	81fc      	bnez.n	a1, 40374a3c <_iram_text_start+0x638>
40374a02:	ff6000        	f64cmph	a6, a0, a0, 15
40374a05:	1f          	.byte	0x1f
40374a06:	fff8      	l32i.n	a15, a15, 60
40374a08:	ff          	.byte	0xff
40374a09:	fffff3        	lsi	f15, a15, 0x3fc
40374a0c:	c4b400        	extui	a11, a0, 4, 13
40374a0f:	1f6804        	lsi	f0, a8, 124
40374a12:	3fc9      	s32i.n	a12, a15, 12
40374a14:	1f6c      	movi.n	a15, -31
40374a16:	3fc9      	s32i.n	a12, a15, 12
40374a18:	1a4c      	movi.n	a10, 65
40374a1a:	744000        	extui	a4, a0, 0, 8
40374a1d:	c939      	s32i.n	a3, a9, 48
40374a1f:	3f          	.byte	0x3f
40374a20:	3768      	l32i.n	a6, a7, 12
40374a22:	3fc9      	s32i.n	a12, a15, 12
40374a24:	00e000        	lsi	f0, a0, 0
40374a27:	809000        	add	a9, a0, a0
40374a2a:	886000        	lsi	f0, a0, 0x220
40374a2d:	600080        	neg	a0, a8
40374a30:	ff          	.byte	0xff
40374a31:	fffff7        	bbsi	a15, 31, 40374a34 <_iram_text_start+0x630>
40374a34:	609c      	beqz.n	a0, 40374a4e <_iram_text_start+0x64a>
40374a36:	546002        	s32i	a0, a0, 0x150
40374a39:	6001d0        	abs	a0, a13
40374a3c:	01ccd4        	lsi	f13, a12, 4
40374a3f:	609060        	neg	a9, a6
40374a42:	f06000        	subx8	a6, a0, a0
40374a45:	600050        	neg	a0, a5
40374a48:	0260b0        	andb	b6, b0, b11
40374a4b:	3ff860        	f64cmph	a15, a8, a6, 3
40374a4e:	070000        	lsi	f0, a0, 28
40374a51:	ffffc0        	f64cmph	a15, a15, a12, 15
40374a54:	f068      	l32i.n	a6, a0, 60
40374a56:	806001        	l32r	a0, 40354bd8 <rom_rx_gain_force+0x34e7ac>
40374a59:	6001f0        	abs	a0, a15
40374a5c:	ff          	.byte	0xff
40374a5d:	9f          	.byte	0x9f
40374a5e:	ff          	.byte	0xff
40374a5f:	ff          	.byte	0xff
40374a60:	ff          	.byte	0xff
40374a61:	ef          	.byte	0xef
40374a62:	ff          	.byte	0xff
40374a63:	ff          	.byte	0xff
40374a64:	ff          	.byte	0xff
40374a65:	ff          	.byte	0xff
40374a66:	6c8000        	lsi	f0, a0, 0x1b0
40374a69:	6001f0        	abs	a0, a15
40374a6c:	3758      	l32i.n	a5, a7, 12
40374a6e:	343c02        	lsi	f0, a12, 208
40374a71:	027c      	movi.n	a2, -16
40374a73:	953c      	movi.n	a5, 57
40374a75:	3c0237        	bnone	a2, a3, 40374ab5 <_iram_text_start+0x6b1>
40374a78:	0237a0        	andb	b3, b7, b10
40374a7b:	1c3c      	movi.n	a12, 49
40374a7d:	027c      	movi.n	a2, -16
40374a7f:	0c3c      	movi.n	a12, 48
40374a81:	600080        	neg	a0, a8
40374a84:	008010        	any4	b1, b0:b1:b2:b3
40374a87:	801460        	add	a1, a4, a6
40374a8a:	006000        	rsil	a0, 0
40374a8d:	600c00        	lsi	f0, a12, 0x180
40374a90:	002000        	isync
40374a93:	dfff00        	f64cmph	a15, a15, a0, 13
40374a96:	ff          	.byte	0xff
40374a97:	ff          	.byte	0xff
40374a98:	01f000        	slli	a15, a0, 32
40374a9b:	bfff60        	f64cmph	a15, a15, a6, 11
40374a9e:	ff          	.byte	0xff
40374a9f:	ff          	.byte	0xff
40374aa0:	3798      	l32i.n	a9, a7, 12
40374aa2:	3fc9      	s32i.n	a12, a15, 12
40374aa4:	c93a74        	lsi	f7, a10, 0x324
40374aa7:	3f          	.byte	0x3f
40374aa8:	3a7c      	movi.n	a10, -13
40374aaa:	3fc9      	s32i.n	a12, a15, 12
40374aac:	6c3c      	movi.n	a12, 54
40374aae:	c83c02        	lsi	f0, a12, 0x320
40374ab1:	3c0290        	lsi	f9, a2, 240
40374ab4:	026c05        	call0	40377178 <_xt_medint2+0x38>
40374ab7:	b43c      	movi.n	a4, 59
40374ab9:	3c0290        	lsi	f9, a2, 240
40374abc:	0c4130        	lsi	f3, a1, 48
40374abf:	189c60        	lsxp	f9, a12, a6
40374ac2:	b44000        	extui	a4, a0, 0, 12
40374ac5:	0018      	l32i.n	a1, a0, 0
40374ac7:	18e440        	lsxp	f14, a4, a4
40374aca:	fc4000        	lsi	f0, a0, 0x3f0
40374acd:	0018      	l32i.n	a1, a0, 0
40374acf:	301840        	xor	a1, a8, a4
40374ad2:	006000        	rsil	a0, 0
40374ad5:	500000        	lsi	f0, a0, 0x140
40374ad8:	301c      	movi.n	a0, 19
40374ada:	206000        	or	a6, a0, a0
40374add:	600030        	neg	a0, a3
40374ae0:	0030e0        	lsi	f14, a0, 0
40374ae3:	08a060        	lsx	f10, a0, a6
40374ae6:	604000        	neg	a4, a0
40374ae9:	000c      	movi.n	a0, 0
40374aeb:	1f3440        	f64cmph	a3, a4, a4, 1
40374aee:	3fc9      	s32i.n	a12, a15, 12
40374af0:	0006b4        	lsi	f11, a6, 0
40374af3:	ffb940        	f64cmph	a11, a9, a4, 15
40374af6:	ce          	.byte	0xce
40374af7:	3f          	.byte	0x3f
40374af8:	ffb8      	l32i.n	a11, a15, 60
40374afa:	ce          	.byte	0xce
40374afb:	3f          	.byte	0x3f
40374afc:	05e8      	l32i.n	a14, a5, 0
40374afe:	c84000        	lsi	f0, a0, 0x320
40374b01:	c93d      	lsi	f3, a9, 36
40374b03:	3f          	.byte	0x3f
40374b04:	c93de4        	lsi	f14, a13, 0x324
40374b07:	3f          	.byte	0x3f
40374b08:	3dec      	bnez.n	a13, 40374b2f <_iram_text_start+0x72b>
40374b0a:	3fc9      	s32i.n	a12, a15, 12
40374b0c:	3df8      	l32i.n	a15, a13, 12
40374b0e:	3fc9      	s32i.n	a12, a15, 12
40374b10:	976d      	lsi	f6, a7, 28
40374b12:	244037        	ball	a0, a3, 40374b3a <_iram_text_start+0x736>
40374b15:	3e          	.byte	0x3e
40374b16:	3fc9      	s32i.n	a12, a15, 12
40374b18:	024180        	andb	b4, b1, b8
40374b1b:	143c      	movi.n	a4, 49
40374b1d:	7f          	.byte	0x7f
40374b1e:	213c02        	lsi	f0, a12, 132
40374b21:	000d      	mov.n	a0, a0
40374b23:	41be00        	srli	a11, a0, 14
40374b26:	c83c02        	lsi	f0, a12, 0x320
40374b29:	3c0241        	l32r	a4, 40343b34 <rom_rx_gain_force+0x33d708>
40374b2c:	000d22        	l8ui	a2, a13, 0
40374b2f:	421000        	xorb	b1, b0, b0
40374b32:	d83c02        	lsi	f0, a12, 0x360
40374b35:	7f          	.byte	0x7f
40374b36:	ff3c02        	lsi	f0, a12, 0x3fc
40374b39:	ff          	.byte	0xff
40374b3a:	3f          	.byte	0x3f
40374b3b:	4218b3        	lsi	f11, a8, 0x108
40374b3e:	3c3c02        	lsi	f0, a12, 240
40374b41:	3c0242        	l8ui	a4, a2, 60
40374b44:	7fa8      	l32i.n	a10, a15, 28
40374b46:	4c3c02        	lsi	f0, a12, 0x130
40374b49:	3c0242        	l8ui	a4, a2, 60
40374b4c:	4268      	l32i.n	a6, a2, 16
40374b4e:	943c02        	lsi	f0, a12, 0x250
40374b51:	7f          	.byte	0x7f
40374b52:	743c02        	lsi	f0, a12, 0x1d0
40374b55:	3c0242        	l8ui	a4, a2, 60
40374b58:	7f7c      	movi.n	a15, -9
40374b5a:	303c02        	lsi	f0, a12, 192
40374b5d:	7f          	.byte	0x7f
40374b5e:	803c02        	lsi	f0, a12, 0x200
40374b61:	3c0242        	l8ui	a4, a2, 60
40374b64:	42d8      	l32i.n	a13, a2, 16
40374b66:	283c02        	lsi	f0, a12, 160
40374b69:	3c0243        	lsi	f4, a2, 240
40374b6c:	022934        	lsi	f3, a9, 8
40374b6f:	c43c      	movi.n	a4, 60
40374b71:	7f          	.byte	0x7f
40374b72:	643c02        	lsi	f0, a12, 0x190
40374b75:	0229      	s32i.n	a2, a2, 0
40374b77:	7c3c      	movi.n	a12, 55
40374b79:	3c0243        	lsi	f4, a2, 240
40374b7c:	027f60        	andb	b7, b15, b6
40374b7f:	003c      	movi.n	a0, 48
40374b81:	7f          	.byte	0x7f
40374b82:	843c02        	lsi	f0, a12, 0x210
40374b85:	3c0243        	lsi	f4, a2, 240
40374b88:	0243a0        	andb	b4, b3, b10
40374b8b:	043c      	movi.n	a4, 48
40374b8d:	3c0244        	muls.ad.ll	a2, m3
40374b90:	7eec      	bnez.n	a14, 40374bbb <_iram_text_start+0x7b7>
40374b92:	443c02        	lsi	f0, a12, 0x110
40374b95:	7f          	.byte	0x7f
40374b96:	d43c02        	lsi	f0, a12, 0x350
40374b99:	7e          	.byte	0x7e
40374b9a:	6d3c02        	lsi	f0, a12, 0x1b4
40374b9d:	0008      	l32i.n	a0, a0, 0
40374b9f:	446c00        	extui	a6, a0, 12, 5
40374ba2:	6e3c02        	lsi	f0, a12, 0x1b8
40374ba5:	0008      	l32i.n	a0, a0, 0
40374ba7:	7ec400        	f64rnd	a12, a4, a0, 3
40374baa:	333c02        	lsi	f0, a12, 204
40374bad:	0009      	s32i.n	a0, a0, 0
40374baf:	4a4000        	madd.s	f4, f0, f0
40374bb2:	4c3c02        	lsi	f0, a12, 0x130
40374bb5:	024a      	add.n	a0, a2, a4
40374bb7:	003c      	movi.n	a0, 48
40374bb9:	be0000        	f64iter	a0, a0, a0, 3, 0
40374bbc:	c90000        	lsi	f0, a0, 0x324
40374bbf:	bf          	.byte	0xbf
40374bc0:	024a90        	andb	b4, b10, b9
40374bc3:	e83c      	movi.n	a8, 62
40374bc5:	c94d      	lsi	f4, a9, 36
40374bc7:	3f          	.byte	0x3f
40374bc8:	4af8      	l32i.n	a15, a10, 16
40374bca:	2c3c02        	lsi	f0, a12, 176
40374bcd:	3c0282        	l8ui	a8, a2, 60
40374bd0:	024b56        	bnez	a11, 40374bf8 <_iram_text_start+0x7f4>
40374bd3:	743c      	movi.n	a4, 55
40374bd5:	9f          	.byte	0x9f
40374bd6:	103c02        	lsi	f0, a12, 64
40374bd9:	000000        	ill
40374bdc:	020120        	andb	b0, b1, b2
40374bdf:	783c      	movi.n	a8, 55
40374be1:	9f          	.byte	0x9f
40374be2:	304037        	ball	a0, a3, 40374c16 <_iram_text_start+0x812>
40374be5:	000500        	lsi	f0, a5, 0
40374be8:	029f83        	lsi	f8, a15, 8
40374beb:	383c      	movi.n	a8, 51
40374bed:	001c      	movi.n	a0, 16
40374bef:	293440        	lsi	f4, a4, 164
40374bf2:	183c02        	lsi	f0, a12, 96
40374bf5:	3c0282        	l8ui	a8, a2, 60
40374bf8:	022964        	lsi	f6, a9, 8
40374bfb:	603c      	movi.n	a0, 54
40374bfd:	024b      	addi.n	a0, a2, 4
40374bff:	883c      	movi.n	a8, 56
40374c01:	024b      	addi.n	a0, a2, 4
40374c03:	a83c      	movi.n	a8, 58
40374c05:	024b      	addi.n	a0, a2, 4
40374c07:	663c      	movi.n	a6, 54
40374c09:	000066        	bnei	a0, -1, 40374c0d <_iram_text_start+0x809>
40374c0c:	4bbc      	beqz.n	a11, 40374c44 <_iram_text_start+0x840>
40374c0e:	003c02        	lsi	f0, a12, 0
40374c11:	024c      	movi.n	a2, 64
40374c13:	d83c      	movi.n	a8, 61
40374c15:	c94d      	lsi	f4, a9, 36
40374c17:	3f          	.byte	0x3f
40374c18:	c94dd0        	lsi	f13, a13, 0x324
40374c1b:	3f          	.byte	0x3f
40374c1c:	0281f0        	andb	b8, b1, b15
40374c1f:	143c      	movi.n	a4, 49
40374c21:	024c      	movi.n	a2, 64
40374c23:	343c      	movi.n	a4, 51
40374c25:	024c      	movi.n	a2, 64
40374c27:	483c      	movi.n	a8, 52
40374c29:	024c      	movi.n	a2, 64
40374c2b:	043c      	movi.n	a4, 48
40374c2d:	3c0282        	l8ui	a8, a2, 60
40374c30:	024c54        	lsi	f5, a12, 8
40374c33:	7c3c      	movi.n	a12, 55
40374c35:	024c      	movi.n	a2, 64
40374c37:	743c      	movi.n	a4, 55
40374c39:	400013        	lsi	f1, a0, 0x100
40374c3c:	4dc8      	l32i.n	a12, a13, 16
40374c3e:	3fc9      	s32i.n	a12, a15, 12
40374c40:	c94dc0        	lsi	f12, a13, 0x324
40374c43:	3f          	.byte	0x3f
40374c44:	c92f40        	lsi	f4, a15, 0x324
40374c47:	3f          	.byte	0x3f
40374c48:	3548      	l32i.n	a4, a5, 12
40374c4a:	3fc9      	s32i.n	a12, a15, 12
40374c4c:	c93544        	lsi	f4, a5, 0x324
40374c4f:	3f          	.byte	0x3f
40374c50:	fbfff0        	f64subc	a15, a15, 3, 1
40374c53:	ff          	.byte	0xff
40374c54:	c93540        	lsi	f4, a5, 0x324
40374c57:	3f          	.byte	0x3f
40374c58:	ff          	.byte	0xff
40374c59:	7f          	.byte	0x7f
40374c5a:	000075        	call12	40374c60 <_iram_text_start+0x85c>
40374c5d:	b00000        	addx8	a0, a0, a0
40374c60:	024c90        	andb	b4, b12, b9
40374c63:	443c      	movi.n	a4, 52
40374c65:	3c0282        	l8ui	a8, a2, 60
40374c68:	024cc2        	s8i	a12, a12, 2
40374c6b:	d03c      	movi.n	a0, 61
40374c6d:	024c      	movi.n	a2, 64
40374c6f:	f03c      	movi.n	a0, 63
40374c71:	c94d      	lsi	f4, a9, 36
40374c73:	3f          	.byte	0x3f
40374c74:	a828      	l32i.n	a2, a8, 40
40374c76:	ec4037        	ball	a0, a3, 40374c66 <_iram_text_start+0x862>
40374c79:	024c      	movi.n	a2, 64
40374c7b:	6c3c      	movi.n	a12, 54
40374c7d:	3c0282        	l8ui	a8, a2, 60
40374c80:	4d6c      	movi.n	a13, -28
40374c82:	643c02        	lsi	f0, a12, 0x190
40374c85:	3c0282        	l8ui	a8, a2, 60
40374c88:	002710        	lsi	f1, a7, 0
40374c8b:	138800        	lsi	f0, a8, 76
40374c8e:	4c0000        	lsi	f0, a0, 0x130
40374c91:	0038      	l32i.n	a3, a0, 0
40374c93:	4dfc42        	s32ri	a4, a12, 0x134
40374c96:	3fc9      	s32i.n	a12, a15, 12
40374c98:	c94b10        	lsi	f1, a11, 0x324
40374c9b:	3f          	.byte	0x3f
40374c9c:	c94ba0        	lsi	f10, a11, 0x324
40374c9f:	3f          	.byte	0x3f
40374ca0:	c94b20        	lsi	f2, a11, 0x324
40374ca3:	3f          	.byte	0x3f
40374ca4:	0244c0        	andb	b4, b4, b12
40374ca7:	983c      	movi.n	a8, 57
40374ca9:	3c0281        	l32r	a8, 40343cb4 <rom_rx_gain_force+0x33d888>
40374cac:	024502        	s8i	a0, a5, 2
40374caf:	3c3c      	movi.n	a12, 51
40374cb1:	c94b      	addi.n	a12, a9, 4
40374cb3:	3f          	.byte	0x3f
40374cb4:	4bcc      	bnez.n	a11, 40374cbc <_iram_text_start+0x8b8>
40374cb6:	3fc9      	s32i.n	a12, a15, 12
40374cb8:	450c      	movi.n	a5, 4
40374cba:	303c02        	lsi	f0, a12, 192
40374cbd:	3c0281        	l32r	a8, 40343cc8 <rom_rx_gain_force+0x33d89c>
40374cc0:	2e          	.byte	0x2e
40374cc1:	0e          	.byte	0xe
40374cc2:	340000        	extui	a0, a0, 0, 4
40374cc5:	3c0245        	call0	403b0cec <_coredump_iram_end+0x2edec>
40374cc8:	0281d0        	andb	b8, b1, b13
40374ccb:	393c      	movi.n	a9, 51
40374ccd:	000013        	lsi	f1, a0, 0
40374cd0:	b3c8      	l32i.n	a12, a3, 44
40374cd2:	f84200        	lsi	f0, a2, 0x3e0
40374cd5:	1f          	.byte	0x1f
40374cd6:	3fc9      	s32i.n	a12, a15, 12
40374cd8:	c94b60        	lsi	f6, a11, 0x324
40374cdb:	3f          	.byte	0x3f
40374cdc:	c94b44        	lsi	f4, a11, 0x324
40374cdf:	3f          	.byte	0x3f
40374ce0:	4b5c      	movi.n	a11, 84
40374ce2:	3fc9      	s32i.n	a12, a15, 12
40374ce4:	4b68      	l32i.n	a6, a11, 16
40374ce6:	3fc9      	s32i.n	a12, a15, 12
40374ce8:	c94b40        	lsi	f4, a11, 0x324
40374ceb:	3f          	.byte	0x3f
40374cec:	4b48      	l32i.n	a4, a11, 16
40374cee:	3fc9      	s32i.n	a12, a15, 12
40374cf0:	4b9c      	beqz.n	a11, 40374d08 <_iram_text_start+0x904>
40374cf2:	3fc9      	s32i.n	a12, a15, 12
40374cf4:	267c      	movi.n	a6, -14
40374cf6:	684200        	lsi	f0, a2, 0x1a0
40374cf9:	3c0245        	call0	403b0d20 <_coredump_iram_end+0x2ee20>
40374cfc:	800c      	movi.n	a0, 8
40374cfe:	b83c02        	lsi	f0, a12, 0x2e0
40374d01:	c94b      	addi.n	a12, a9, 4
40374d03:	3f          	.byte	0x3f
40374d04:	c94ba4        	lsi	f10, a11, 0x324
40374d07:	3f          	.byte	0x3f
40374d08:	c94b74        	lsi	f7, a11, 0x324
40374d0b:	3f          	.byte	0x3f
40374d0c:	4b38      	l32i.n	a3, a11, 16
40374d0e:	3fc9      	s32i.n	a12, a15, 12
40374d10:	c94b24        	lsi	f2, a11, 0x324
40374d13:	3f          	.byte	0x3f
40374d14:	024584        	lsi	f8, a5, 8
40374d17:	503c      	movi.n	a0, 53
40374d19:	3c0281        	l32r	a8, 40343d24 <rom_rx_gain_force+0x33d8f8>
40374d1c:	0c7b      	addi.n	a0, a12, 7
40374d1e:	9c0000        	lsi	f0, a0, 0x270
40374d21:	3c0245        	call0	403b0d48 <_coredump_iram_end+0x2ee48>
40374d24:	0c9b      	addi.n	a0, a12, 9
40374d26:	280000        	lsi	f0, a0, 160
40374d29:	c94b      	addi.n	a12, a9, 4
40374d2b:	3f          	.byte	0x3f
40374d2c:	4b2c      	movi.n	a11, 36
40374d2e:	3fc9      	s32i.n	a12, a15, 12
40374d30:	c94b34        	lsi	f3, a11, 0x324
40374d33:	3f          	.byte	0x3f
40374d34:	a5a5a5        	call8	4031a790 <rom_rx_gain_force+0x314364>
40374d37:	4614a5        	call8	403bae80 <_coredump_iram_end+0x38f80>
40374d3a:	183c02        	lsi	f0, a12, 96
40374d3d:	3c0281        	l32r	a8, 40343d48 <rom_rx_gain_force+0x33d91c>
40374d40:	000e95        	call4	40374e2c <_iram_text_start+0xa28>
40374d43:	462000        	lsi	f0, a0, 0x118
40374d46:	fc3c02        	lsi	f0, a12, 0x3f0
40374d49:	3c0280        	lsi	f8, a2, 240
40374d4c:	0f2a      	add.n	a0, a15, a2
40374d4e:	300000        	xor	a0, a0, a0
40374d51:	3c0246        	j	40383d5e <_coredump_iram_end+0x1e5e>
40374d54:	0f4d      	mov.n	a4, a15
40374d56:	6c0000        	lsi	f0, a0, 0x1b0
40374d59:	3c0246        	j	40383d66 <_coredump_iram_end+0x1e66>
40374d5c:	0280e4        	lsi	f14, a0, 8
40374d5f:	3a3c      	movi.n	a10, 51
40374d61:	000010        	lsi	f1, a0, 0
40374d64:	4678      	l32i.n	a7, a6, 16
40374d66:	3b3c02        	lsi	f0, a12, 236
40374d69:	000010        	lsi	f1, a0, 0
40374d6c:	4688      	l32i.n	a8, a6, 16
40374d6e:	b03c02        	lsi	f0, a12, 0x2c0
40374d71:	3c0281        	l32r	a8, 40343d7c <rom_rx_gain_force+0x33d950>
40374d74:	457c      	movi.n	a5, -12
40374d76:	643c02        	lsi	f0, a12, 0x190
40374d79:	3c0281        	l32r	a8, 40343d84 <rom_rx_gain_force+0x33d958>
40374d7c:	000ac4        	lsi	f12, a10, 0
40374d7f:	46a000        	lsi	f0, a0, 0x118
40374d82:	e03c02        	lsi	f0, a12, 0x380
40374d85:	3c0281        	l32r	a8, 40343d90 <rom_rx_gain_force+0x33d964>
40374d88:	0281c4        	lsi	f12, a1, 8
40374d8b:	203c      	movi.n	a0, 50
40374d8d:	3c0247        	bnone	a2, a4, 40374dcd <_iram_text_start+0x9c9>
40374d90:	028174        	lsi	f7, a1, 8
40374d93:	0d3c      	movi.n	a13, 48
40374d95:	000a      	add.n	a0, a0, a0
40374d97:	47a000        	lsi	f0, a0, 0x11c
40374d9a:	cc3c02        	lsi	f0, a12, 0x330
40374d9d:	3c0280        	lsi	f8, a2, 240
40374da0:	001412        	l16ui	a1, a4, 0
40374da3:	47cc00        	lsi	f0, a12, 0x11c
40374da6:	133c02        	lsi	f0, a12, 76
40374da9:	000014        	lsi	f1, a0, 0
40374dac:	80a8      	l32i.n	a10, a0, 32
40374dae:	693c02        	lsi	f0, a12, 0x1a4
40374db1:	000014        	lsi	f1, a0, 0
40374db4:	0247e4        	lsi	f14, a7, 8
40374db7:	843c      	movi.n	a4, 56
40374db9:	000014        	lsi	f1, a0, 0
40374dbc:	024810        	andb	b4, b8, b1
40374dbf:	903c      	movi.n	a0, 57
40374dc1:	3c0280        	lsi	f8, a2, 240
40374dc4:	001654        	lsi	f5, a6, 0
40374dc7:	482400        	ssx	f2, a4, a0
40374dca:	7c3c02        	lsi	f0, a12, 0x1f0
40374dcd:	3c0280        	lsi	f8, a2, 240
40374dd0:	001702        	l16ui	a0, a7, 0
40374dd3:	483800        	ssx	f3, a8, a0
40374dd6:	033c02        	lsi	f0, a12, 12
40374dd9:	000017        	bnone	a0, a1, 40374ddd <_iram_text_start+0x9d9>
40374ddc:	4848      	l32i.n	a4, a8, 16
40374dde:	383c02        	lsi	f0, a12, 224
40374de1:	000017        	bnone	a0, a1, 40374de5 <_iram_text_start+0x9e1>
40374de4:	4868      	l32i.n	a6, a8, 16
40374de6:	473c02        	lsi	f0, a12, 0x11c
40374de9:	000017        	bnone	a0, a1, 40374ded <_iram_text_start+0x9e9>
40374dec:	805c      	movi.n	a0, 88
40374dee:	093c02        	lsi	f0, a12, 36
40374df1:	0018      	l32i.n	a1, a0, 0
40374df3:	180a00        	lsxp	f0, a10, a0
40374df6:	330000        	clamps	a0, a0, 7
40374df9:	0018      	l32i.n	a1, a0, 0
40374dfb:	48a800        	ssx	f10, a8, a0
40374dfe:	3c3c02        	lsi	f0, a12, 240
40374e01:	3c0280        	lsi	f8, a2, 240
40374e04:	0248e0        	andb	b4, b8, b14
40374e07:	003c      	movi.n	a0, 48
40374e09:	0249      	s32i.n	a4, a2, 0
40374e0b:	243c      	movi.n	a4, 50
40374e0d:	3c0280        	lsi	f8, a2, 240
40374e10:	49bc      	beqz.n	a9, 40374e48 <_iram_text_start+0xa44>
40374e12:	ec3c02        	lsi	f0, a12, 0x3b0
40374e15:	7f          	.byte	0x7f
40374e16:	e43c02        	lsi	f0, a12, 0x390
40374e19:	0249      	s32i.n	a4, a2, 0
40374e1b:	083c      	movi.n	a8, 48
40374e1d:	024a      	add.n	a0, a2, a4
40374e1f:	243c      	movi.n	a4, 50
40374e21:	024a      	add.n	a0, a2, a4
40374e23:	ec3c      	movi.n	a12, 62
40374e25:	ae          	.byte	0xae
40374e26:	184037        	ball	a0, a3, 40374e42 <_iram_text_start+0xa3e>
40374e29:	c94b      	addi.n	a12, a9, 4
40374e2b:	3f          	.byte	0x3f
40374e2c:	4a2c      	movi.n	a10, 36
40374e2e:	843c02        	lsi	f0, a12, 0x210
40374e31:	3c0281        	l32r	a8, 40343e3c <rom_rx_gain_force+0x33da10>
40374e34:	098b      	addi.n	a0, a9, 8
40374e36:	ec0000        	lsi	f0, a0, 0x3b0
40374e39:	3c0281        	l32r	a8, 40343e44 <rom_rx_gain_force+0x33da18>
40374e3c:	404c      	movi.n	a0, 68
40374e3e:	600c      	movi.n	a0, 6
40374e40:	499c      	beqz.n	a9, 40374e58 <_iram_text_start+0xa54>
40374e42:	3fc9      	s32i.n	a12, a15, 12
40374e44:	0c40a0        	lsi	f10, a0, 48
40374e47:	187860        	lsxp	f7, a8, a6
40374e4a:	904000        	addx2	a4, a0, a0
40374e4d:	0018      	l32i.n	a1, a0, 0
40374e4f:	37b040        	lsi	f4, a0, 220
40374e52:	3fc9      	s32i.n	a12, a15, 12
40374e54:	c94180        	lsi	f8, a1, 0x324
40374e57:	3f          	.byte	0x3f
40374e58:	c937e4        	lsi	f14, a7, 0x324
40374e5b:	3f          	.byte	0x3f
40374e5c:	416c      	movi.n	a1, -28
40374e5e:	3fc9      	s32i.n	a12, a15, 12
40374e60:	4158      	l32i.n	a5, a1, 16
40374e62:	3fc9      	s32i.n	a12, a15, 12
40374e64:	c94144        	lsi	f4, a1, 0x324
40374e67:	3f          	.byte	0x3f
40374e68:	18a8      	l32i.n	a10, a8, 4
40374e6a:	004000        	break	0, 0
40374e6d:	600c40        	lsi	f4, a12, 0x180
40374e70:	0c4060        	lsi	f6, a0, 48
40374e73:	ffff60        	f64cmph	a15, a15, a6, 15
40374e76:	ff          	.byte	0xff
40374e77:	00bd      	mov.n	a11, a0
40374e79:	c40000        	extui	a0, a0, 0, 13
40374e7c:	ff          	.byte	0xff
40374e7d:	ff          	.byte	0xff
40374e7e:	ff          	.byte	0xff
40374e7f:	16b0c3        	lsi	f12, a0, 88
40374e82:	304000        	xor	a4, a0, a0
40374e85:	3fc941        	l32r	a4, 40344dac <rom_rx_gain_force+0x33e980>
40374e88:	411c      	movi.n	a1, 20
40374e8a:	3fc9      	s32i.n	a12, a15, 12
40374e8c:	0018f0        	movsp	a15, a8
40374e8f:	190840        	lsi	f4, a8, 100
40374e92:	044000        	extui	a4, a0, 0, 1
40374e95:	c938      	l32i.n	a3, a9, 48
40374e97:	3f          	.byte	0x3f
40374e98:	40fc      	bnez.n	a0, 40374ed0 <_iram_text_start+0xacc>
40374e9a:	3fc9      	s32i.n	a12, a15, 12
40374e9c:	382c      	movi.n	a8, 35
40374e9e:	3fc9      	s32i.n	a12, a15, 12
40374ea0:	c940e4        	lsi	f14, a0, 0x324
40374ea3:	3f          	.byte	0x3f
40374ea4:	c93834        	lsi	f3, a8, 0x324
40374ea7:	3f          	.byte	0x3f
40374ea8:	15fc      	bnez.n	a5, 40374edd <_iram_text_start+0xad9>
40374eaa:	084000        	lsx	f4, a0, a0
40374ead:	400016        	beqz	a0, 403752b1 <call_start_cpu0+0x5>
40374eb0:	c93e34        	lsi	f3, a14, 0x324
40374eb3:	3f          	.byte	0x3f
40374eb4:	c941e4        	lsi	f14, a1, 0x324
40374eb7:	3f          	.byte	0x3f
40374eb8:	c93e54        	lsi	f5, a14, 0x324
40374ebb:	3f          	.byte	0x3f
40374ebc:	031400        	lsi	f0, a4, 12
40374ebf:	cc18      	l32i.n	a1, a12, 48
40374ec1:	3fc941        	l32r	a4, 40344de8 <rom_rx_gain_force+0x33e9bc>
40374ec4:	41ac      	beqz.n	a1, 40374eec <_iram_text_start+0xae8>
40374ec6:	3fc9      	s32i.n	a12, a15, 12
40374ec8:	ff          	.byte	0xff
40374ec9:	ff          	.byte	0xff
40374eca:	ff          	.byte	0xff
40374ecb:	3f          	.byte	0x3f
40374ecc:	3e88      	l32i.n	a8, a14, 12
40374ece:	3fc9      	s32i.n	a12, a15, 12
40374ed0:	c94194        	lsi	f9, a1, 0x324
40374ed3:	3f          	.byte	0x3f
40374ed4:	3ebc      	beqz.n	a14, 40374f0b <_iram_text_start+0xb07>
40374ed6:	3fc9      	s32i.n	a12, a15, 12
40374ed8:	000000        	ill
40374edb:	000042        	l8ui	a4, a0, 0
40374ede:	dc3c00        	lsi	f0, a12, 0x370
40374ee1:	3e          	.byte	0x3e
40374ee2:	3fc9      	s32i.n	a12, a15, 12
40374ee4:	c94230        	lsi	f3, a2, 0x324
40374ee7:	3f          	.byte	0x3f
40374ee8:	3efc      	bnez.n	a14, 40374f1f <_iram_text_start+0xb1b>
40374eea:	3fc9      	s32i.n	a12, a15, 12
40374eec:	3f1c      	movi.n	a15, 19
40374eee:	3fc9      	s32i.n	a12, a15, 12
40374ef0:	c93f50        	lsi	f5, a15, 0x324
40374ef3:	3f          	.byte	0x3f
40374ef4:	4218      	l32i.n	a1, a2, 16
40374ef6:	3fc9      	s32i.n	a12, a15, 12
40374ef8:	c93fb4        	lsi	f11, a15, 0x324
40374efb:	3f          	.byte	0x3f
40374efc:	c94200        	lsi	f0, a2, 0x324
40374eff:	3f          	.byte	0x3f
40374f00:	c94014        	lsi	f1, a0, 0x324
40374f03:	3f          	.byte	0x3f
40374f04:	c94244        	lsi	f4, a2, 0x324
40374f07:	3f          	.byte	0x3f
40374f08:	c94054        	lsi	f5, a0, 0x324
40374f0b:	3f          	.byte	0x3f
40374f0c:	0cc000        	lsi	f0, a0, 48
40374f0f:	004c60        	break	12, 6
40374f12:	600c      	movi.n	a0, 6
40374f14:	0cc044        	lsi	f4, a0, 48
40374f17:	c04060        	sub	a4, a0, a6
40374f1a:	600c      	movi.n	a0, 6
40374f1c:	c048      	l32i.n	a4, a0, 48
40374f1e:	600c      	movi.n	a0, 6
40374f20:	c04c      	movi.n	a0, 76
40374f22:	600c      	movi.n	a0, 6
40374f24:	c058      	l32i.n	a5, a0, 48
40374f26:	600c      	movi.n	a0, 6
40374f28:	0cc050        	lsi	f5, a0, 48
40374f2b:	c05460        	sub	a5, a4, a6
40374f2e:	600c      	movi.n	a0, 6
40374f30:	9f          	.byte	0x9f
40374f31:	ff3c      	movi.n	a15, 63
40374f33:	ff          	.byte	0xff
40374f34:	ff          	.byte	0xff
40374f35:	cf          	.byte	0xcf
40374f36:	ff          	.byte	0xff
40374f37:	ff          	.byte	0xff
40374f38:	100000        	and	a0, a0, a0
40374f3b:	ffff00        	f64cmph	a15, a15, a0, 15
40374f3e:	fffb      	addi.n	a15, a15, 15
40374f40:	ff          	.byte	0xff
40374f41:	ff          	.byte	0xff
40374f42:	3f          	.byte	0x3f
40374f43:	fff8      	l32i.n	a15, a15, 60
40374f45:	ff          	.byte	0xff
40374f46:	00ffc1        	l32r	a12, 40335344 <rom_rx_gain_force+0x32ef18>
40374f49:	f00000        	subx8	a0, a0, a0
40374f4c:	8f          	.byte	0x8f
40374f4d:	6fbd      	lsi	f11, a15, 60
40374f4f:	fe          	.byte	0xfe
40374f50:	400000        	ssr	a0
40374f53:	000000        	ill
40374f56:	ff5c00        	f64cmph	a5, a12, a0, 15
40374f59:	fffe01        	l32r	a0, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
40374f5c:	ff          	.byte	0xff
40374f5d:	ffff03        	lsi	f0, a15, 0x3fc
40374f60:	fff003        	lsi	f0, a0, 0x3fc
40374f63:	ff          	.byte	0xff
40374f64:	624dd3        	ssi	f13, a13, 0x188
40374f67:	ffff10        	f64cmph	a15, a15, a1, 15
40374f6a:	ff          	.byte	0xff
40374f6b:	080081        	l32r	a8, 40336f6c <rom_rx_gain_force+0x330b40>
40374f6e:	000000        	ill
40374f71:	600230        	lsi	f3, a2, 0x180
40374f74:	ff          	.byte	0xff
40374f75:	ff          	.byte	0xff
40374f76:	ff          	.byte	0xff
40374f77:	409803        	lsi	f0, a8, 0x100
40374f7a:	3fc9      	s32i.n	a12, a15, 12
40374f7c:	4268      	l32i.n	a6, a2, 16
40374f7e:	3fc9      	s32i.n	a12, a15, 12
40374f80:	40ac      	beqz.n	a0, 40374fa8 <_iram_text_start+0xba4>
40374f82:	3fc9      	s32i.n	a12, a15, 12
40374f84:	29e8      	l32i.n	a14, a9, 8
40374f86:	4c3c02        	lsi	f0, a12, 0x130
40374f89:	022a      	add.n	a0, a2, a2
40374f8b:	203c      	movi.n	a0, 50
40374f8d:	0278      	l32i.n	a7, a2, 0
40374f8f:	3e3c      	movi.n	a14, 51
40374f91:	022a      	add.n	a0, a2, a2
40374f93:	743c      	movi.n	a4, 55
40374f95:	3c0230        	lsi	f3, a2, 240
40374f98:	78ac      	beqz.n	a8, 40374fc3 <_iram_text_start+0xbbf>
40374f9a:	db3c02        	lsi	f0, a12, 0x36c
40374f9d:	022a      	add.n	a0, a2, a2
40374f9f:	503c      	movi.n	a0, 53
40374fa1:	022b      	addi.n	a0, a2, 2
40374fa3:	7c3c      	movi.n	a12, 55
40374fa5:	0279      	s32i.n	a7, a2, 0
40374fa7:	833c      	movi.n	a3, 56
40374fa9:	022b      	addi.n	a0, a2, 2
40374fab:	ac3c      	movi.n	a12, 58
40374fad:	3c0230        	lsi	f3, a2, 240
40374fb0:	7898      	l32i.n	a9, a8, 28
40374fb2:	5b3c02        	lsi	f0, a12, 0x16c
40374fb5:	022c      	movi.n	a2, 32
40374fb7:	d83c      	movi.n	a8, 61
40374fb9:	3c0230        	lsi	f3, a2, 240
40374fbc:	022dd4        	lsi	f13, a13, 8
40374fbf:	3c3c      	movi.n	a12, 51
40374fc1:	0279      	s32i.n	a7, a2, 0
40374fc3:	003c      	movi.n	a0, 48
40374fc5:	2e          	.byte	0x2e
40374fc6:	203c02        	lsi	f0, a12, 128
40374fc9:	3c0231        	l32r	a3, 40343fd4 <rom_rx_gain_force+0x33dba8>
40374fcc:	7888      	l32i.n	a8, a8, 28
40374fce:	003c02        	lsi	f0, a12, 0
40374fd1:	000000        	ill
40374fd4:	3158      	l32i.n	a5, a1, 12
40374fd6:	743c02        	lsi	f0, a12, 0x1d0
40374fd9:	0278      	l32i.n	a7, a2, 0
40374fdb:	103c      	movi.n	a0, 49
40374fdd:	022c      	movi.n	a2, 32
40374fdf:	5c3c      	movi.n	a12, 53
40374fe1:	0279      	s32i.n	a7, a2, 0
40374fe3:	743c      	movi.n	a4, 55
40374fe5:	022c      	movi.n	a2, 32
40374fe7:	b03c      	movi.n	a0, 59
40374fe9:	022c      	movi.n	a2, 32
40374feb:	603c      	movi.n	a0, 54
40374fed:	2e          	.byte	0x2e
40374fee:	703c02        	lsi	f0, a12, 0x1c0
40374ff1:	0279      	s32i.n	a7, a2, 0
40374ff3:	a03c      	movi.n	a0, 58
40374ff5:	2e          	.byte	0x2e
40374ff6:	fc3c02        	lsi	f0, a12, 0x3f0
40374ff9:	0278      	l32i.n	a7, a2, 0
40374ffb:	dc3c      	movi.n	a12, 61
40374ffd:	2e          	.byte	0x2e
40374ffe:	143c02        	lsi	f0, a12, 80
40375001:	0279      	s32i.n	a7, a2, 0
40375003:	f83c      	movi.n	a8, 63
40375005:	2e          	.byte	0x2e
40375006:	e83c02        	lsi	f0, a12, 0x3a0
40375009:	0278      	l32i.n	a7, a2, 0
4037500b:	183c      	movi.n	a8, 49
4037500d:	2f          	.byte	0x2f
4037500e:	d83c02        	lsi	f0, a12, 0x360
40375011:	0278      	l32i.n	a7, a2, 0
40375013:	483c      	movi.n	a8, 52
40375015:	2f          	.byte	0x2f
40375016:	cc3c02        	lsi	f0, a12, 0x330
40375019:	0278      	l32i.n	a7, a2, 0
4037501b:	bc3c      	movi.n	a12, 59
4037501d:	2f          	.byte	0x2f
4037501e:	fc3c02        	lsi	f0, a12, 0x3f0
40375021:	2f          	.byte	0x2f
40375022:	503c02        	lsi	f0, a12, 0x140
40375025:	0279      	s32i.n	a7, a2, 0
40375027:	483c      	movi.n	a8, 52
40375029:	3c0230        	lsi	f3, a2, 240
4037502c:	78b8      	l32i.n	a11, a8, 28
4037502e:	643c02        	lsi	f0, a12, 0x190
40375031:	0278      	l32i.n	a7, a2, 0
40375033:	843c      	movi.n	a4, 56
40375035:	3c0231        	l32r	a3, 40344040 <rom_rx_gain_force+0x33dc14>
40375038:	027854        	lsi	f5, a8, 8
4037503b:	ac3c      	movi.n	a12, 58
4037503d:	c94a      	add.n	a12, a9, a4
4037503f:	3f          	.byte	0x3f
40375040:	c949a0        	lsi	f10, a9, 0x324
40375043:	3f          	.byte	0x3f
40375044:	1f38      	l32i.n	a3, a15, 4
40375046:	3fc9      	s32i.n	a12, a15, 12
40375048:	016194        	lsi	f9, a1, 4
4037504b:	fcc142        	addi	a4, a1, -4
4037504e:	184037        	ball	a0, a3, 4037506a <_iram_text_start+0xc66>
40375051:	c93a      	add.n	a12, a9, a3
40375053:	3f          	.byte	0x3f
40375054:	c93a34        	lsi	f3, a10, 0x324
40375057:	3f          	.byte	0x3f
40375058:	0014c4        	lsi	f12, a4, 0
4037505b:	fd2e40        	lsi	f4, a14, 0x3f4
4037505e:	404037        	ball	a0, a3, 403750a2 <_iram_text_start+0xc9e>
40375061:	c93a      	add.n	a12, a9, a3
40375063:	3f          	.byte	0x3f
40375064:	c93a54        	lsi	f5, a10, 0x324
40375067:	3f          	.byte	0x3f
40375068:	3a58      	l32i.n	a5, a10, 12
4037506a:	3fc9      	s32i.n	a12, a15, 12
4037506c:	3a68      	l32i.n	a6, a10, 12
4037506e:	3fc9      	s32i.n	a12, a15, 12
40375070:	3a6c      	movi.n	a10, -29
40375072:	3fc9      	s32i.n	a12, a15, 12
40375074:	c93a70        	lsi	f7, a10, 0x324
40375077:	3f          	.byte	0x3f
40375078:	3eb8      	l32i.n	a11, a14, 12
4037507a:	3fc9      	s32i.n	a12, a15, 12
4037507c:	1248      	l32i.n	a4, a2, 4
4037507e:	604000        	neg	a4, a0
40375081:	400012        	l8ui	a1, a0, 64
40375084:	2688      	l32i.n	a8, a6, 8
40375086:	3fc9      	s32i.n	a12, a15, 12
40375088:	5ed9      	s32i.n	a13, a14, 20
4037508a:	3fc9      	s32i.n	a12, a15, 12
4037508c:	5ed8      	l32i.n	a13, a14, 20
4037508e:	3fc9      	s32i.n	a12, a15, 12
40375090:	ff          	.byte	0xff
40375091:	ff          	.byte	0xff
40375092:	ff          	.byte	0xff
40375093:	42d800        	xorb	b13, b8, b0
40375096:	3fc9      	s32i.n	a12, a15, 12
40375098:	c93d24        	lsi	f2, a13, 0x324
4037509b:	3f          	.byte	0x3f
4037509c:	3d5c      	movi.n	a13, 83
4037509e:	3fc9      	s32i.n	a12, a15, 12
403750a0:	42bc      	beqz.n	a2, 403750d8 <_iram_text_start+0xcd4>
403750a2:	3fc9      	s32i.n	a12, a15, 12
403750a4:	c93d93        	lsi	f9, a13, 0x324
403750a7:	3f          	.byte	0x3f
403750a8:	c942a4        	lsi	f10, a2, 0x324
403750ab:	3f          	.byte	0x3f
403750ac:	3da8      	l32i.n	a10, a13, 12
403750ae:	3fc9      	s32i.n	a12, a15, 12
403750b0:	4288      	l32i.n	a8, a2, 16
403750b2:	3fc9      	s32i.n	a12, a15, 12
403750b4:	366c      	movi.n	a6, -29
403750b6:	3fc9      	s32i.n	a12, a15, 12
403750b8:	c942e0        	lsi	f14, a2, 0x324
403750bb:	3f          	.byte	0x3f
403750bc:	9f78      	l32i.n	a7, a15, 36
403750be:	004200        	break	2, 0
403750c1:	000060        	lsi	f6, a0, 0
403750c4:	071c      	movi.n	a7, 16
403750c6:	4038      	l32i.n	a3, a0, 16
403750c8:	380754        	lsi	f5, a7, 224
403750cb:	0a3040        	add.s	f3, f0, f4
403750ce:	4038      	l32i.n	a3, a0, 16
403750d0:	0a98      	l32i.n	a9, a10, 0
403750d2:	4038      	l32i.n	a3, a0, 16
403750d4:	c93654        	lsi	f5, a6, 0x324
403750d7:	3f          	.byte	0x3f
403750d8:	3658      	l32i.n	a5, a6, 12
403750da:	3fc9      	s32i.n	a12, a15, 12
403750dc:	363c      	movi.n	a6, 51
403750de:	3fc9      	s32i.n	a12, a15, 12
403750e0:	44ec      	bnez.n	a4, 40375108 <_iram_text_start+0xd04>
403750e2:	3fc9      	s32i.n	a12, a15, 12
403750e4:	c93b80        	lsi	f8, a11, 0x324
403750e7:	3f          	.byte	0x3f
403750e8:	3bbc      	beqz.n	a11, 4037511f <_iram_text_start+0xd1b>
403750ea:	3fc9      	s32i.n	a12, a15, 12
403750ec:	443c      	movi.n	a4, 52
403750ee:	3fc9      	s32i.n	a12, a15, 12
403750f0:	ef          	.byte	0xef
403750f1:	c93b      	addi.n	a12, a9, 3
403750f3:	3f          	.byte	0x3f
403750f4:	3c08      	l32i.n	a0, a12, 12
403750f6:	3fc9      	s32i.n	a12, a15, 12
403750f8:	c93c60        	lsi	f6, a12, 0x324
403750fb:	3f          	.byte	0x3f
403750fc:	21cc      	bnez.n	a1, 40375102 <_iram_text_start+0xcfe>
403750fe:	004000        	break	0, 0
40375101:	cf          	.byte	0xcf
40375102:	680000        	lsi	f0, a0, 0x1a0
40375105:	380a      	add.n	a3, a8, a0
40375107:	0a8040        	add.s	f8, f0, f4
4037510a:	4038      	l32i.n	a3, a0, 16
4037510c:	ff9f60        	f64cmph	a9, a15, a6, 15
4037510f:	ff          	.byte	0xff
40375110:	ffde21        	l32r	a2, 40375088 <_iram_text_start+0xc84> (3fc95ed9 <flash_brownout_needs_reset>)
40375113:	ff          	.byte	0xff
40375114:	23dc      	bnez.n	a3, 4037512a <_iram_text_start+0xd26>
40375116:	120000        	andbc	b0, b0, b0
40375119:	ffed      	lsi	f14, a15, 60
4037511b:	ff          	.byte	0xff
4037511c:	13ec      	bnez.n	a3, 40375141 <_iram_text_start+0xd3d>
4037511e:	ee0000        	f64iter	a0, a0, a0, 2, 1
40375121:	000011        	l32r	a1, 40335124 <rom_rx_gain_force+0x32ecf8>
40375124:	3ca8      	l32i.n	a10, a12, 12
40375126:	3fc9      	s32i.n	a12, a15, 12
40375128:	c94630        	lsi	f3, a6, 0x324
4037512b:	3f          	.byte	0x3f
4037512c:	c93d07        	bltu	a13, a0, 403750f9 <_iram_text_start+0xcf5>
4037512f:	3f          	.byte	0x3f
40375130:	9f          	.byte	0x9f
40375131:	000060        	lsi	f6, a0, 0
40375134:	46dc      	bnez.n	a6, 4037514c <_iram_text_start+0xd48>
40375136:	3fc9      	s32i.n	a12, a15, 12
40375138:	c93d24        	lsi	f2, a13, 0x324
4037513b:	3f          	.byte	0x3f
4037513c:	21d8      	l32i.n	a13, a1, 8
4037513e:	714000        	lsi	f0, a0, 0x1c4
40375141:	8e          	.byte	0x8e
40375142:	ff          	.byte	0xff
40375143:	ff          	.byte	0xff
40375144:	c93d40        	lsi	f4, a13, 0x324
40375147:	3f          	.byte	0x3f
40375148:	c94604        	lsi	f0, a6, 0x324
4037514b:	3f          	.byte	0x3f
4037514c:	47ec      	bnez.n	a7, 40375174 <_iram_text_start+0xd70>
4037514e:	3fc9      	s32i.n	a12, a15, 12
40375150:	c93b80        	lsi	f8, a11, 0x324
40375153:	3f          	.byte	0x3f
40375154:	ffe8      	l32i.n	a14, a15, 60
40375156:	ce          	.byte	0xce
40375157:	3f          	.byte	0x3f
40375158:	c92610        	lsi	f1, a6, 0x324
4037515b:	3f          	.byte	0x3f
4037515c:	9078      	l32i.n	a7, a0, 36
4037515e:	d06000        	subx2	a6, a0, a0
40375161:	c93a      	add.n	a12, a9, a3
40375163:	3f          	.byte	0x3f
40375164:	3adc      	bnez.n	a10, 4037517b <_iram_text_start+0xd77>
40375166:	3fc9      	s32i.n	a12, a15, 12
40375168:	093c      	movi.n	a9, 48
4037516a:	b84000        	lsi	f0, a0, 0x2e0
4037516d:	0008      	l32i.n	a0, a0, 0
4037516f:	0a4440        	add.s	f4, f4, f4
40375172:	f44000        	extui	a4, a0, 0, 16
40375175:	3fc947        	bnall	a9, a4, 403751b8 <call_start_cpu1+0x1c>
40375178:	cefff4        	lsi	f15, a15, 0x338
4037517b:	3f          	.byte	0x3f
4037517c:	000954        	lsi	f5, a9, 0
4037517f:	096040        	l32e	a4, a0, -40
40375182:	e84000        	lsi	f0, a0, 0x3a0
40375185:	0008      	l32i.n	a0, a0, 0
40375187:	264440        	lsi	f4, a4, 152
4037518a:	3fc9      	s32i.n	a12, a15, 12
4037518c:	c95ef4        	lsi	f15, a14, 0x324
4037518f:	3f          	.byte	0x3f
40375190:	c95ef0        	lsi	f15, a14, 0x324
40375193:	3f          	.byte	0x3f
40375194:	3b1c      	movi.n	a11, 19
40375196:	3fc9      	s32i.n	a12, a15, 12
40375198:	040020        	extui	a0, a2, 0, 1
	...

4037519c <call_start_cpu1>:
{
    s_resume_cores = true;
}

void IRAM_ATTR call_start_cpu1(void)
{
4037519c:	004136        	entry	a1, 32
 * @param ivt_addr Interrupt Vector Table's base address
 */
FORCE_INLINE_ATTR void esp_cpu_intr_set_ivt_addr(const void *ivt_addr)
{
#ifdef __XTENSA__
    xt_utils_set_vecbase((uint32_t)ivt_addr);
4037519f:	fc9981        	l32r	a8, 40374404 <_iram_text_start> (40374000 <_WindowOverflow4>)

// --------------- Interrupt Configuration -----------------

FORCE_INLINE_ATTR void xt_utils_set_vecbase(uint32_t vecbase)
{
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
403751a2:	13e780        	wsr.vecbase	a8
     * the CPU jumps to this base address + 4 * interrupt_id.
     */
    esp_cpu_intr_set_mtvt_addr(&_mtvt_table);
#endif

    ets_set_appcpu_boot_addr(0);
403751a5:	0a0c      	movi.n	a10, 0
403751a7:	fc9e81        	l32r	a8, 40374420 <_iram_text_start+0x1c> (40000720 <ets_set_appcpu_boot_addr>)
403751aa:	0008e0        	callx8	a8

    bootloader_init_mem();
403751ad:	fc9d81        	l32r	a8, 40374424 <_iram_text_start+0x20> (42009170 <bootloader_init_mem>)
403751b0:	0008e0        	callx8	a8

#if CONFIG_ESP_CONSOLE_NONE
    esp_rom_install_channel_putc(1, NULL);
    esp_rom_install_channel_putc(2, NULL);
#elif !CONFIG_ESP_CONSOLE_USB_CDC
    esp_rom_install_uart_printf();
403751b3:	0453e5        	call8	403796f0 <esp_rom_install_uart_printf>
    esp_rom_output_set_as_console(CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM);
403751b6:	4a0c      	movi.n	a10, 4
403751b8:	fc9c81        	l32r	a8, 40374428 <_iram_text_start+0x24> (400006c0 <esp_rom_output_set_as_console>)
403751bb:	0008e0        	callx8	a8
    DPORT_REG_CLR_BIT(DPORT_APP_CPU_RECORD_CTRL_REG, DPORT_APP_CPU_RECORD_ENABLE);
#elif CONFIG_IDF_TARGET_ESP32P4
    REG_SET_BIT(ASSIST_DEBUG_CORE_1_RCD_EN_REG, ASSIST_DEBUG_CORE_1_RCD_PDEBUGEN);
    REG_SET_BIT(ASSIST_DEBUG_CORE_1_RCD_EN_REG, ASSIST_DEBUG_CORE_1_RCD_RECORDEN);
#else
    REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_PDEBUGENABLE_REG, 1);
403751be:	170c      	movi.n	a7, 1
403751c0:	fc9281        	l32r	a8, 40374408 <_iram_text_start+0x4> (600ce0d8 <SYSTEM+0xe0d8>)
403751c3:	0020c0        	memw
403751c6:	0879      	s32i.n	a7, a8, 0
    REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_RECORDING_REG, 1);
403751c8:	fc9181        	l32r	a8, 4037440c <_iram_text_start+0x8> (600ce0dc <SYSTEM+0xe0dc>)
403751cb:	0020c0        	memw
403751ce:	006872        	s32i	a7, a8, 0
#endif

    s_cpu_up[1] = true;
403751d1:	fc8f81        	l32r	a8, 40374410 <_iram_text_start+0xc> (3fc94888 <s_cpu_up>)
403751d4:	0020c0        	memw
403751d7:	014872        	s8i	a7, a8, 1
    ESP_EARLY_LOGD(TAG, "App cpu up");

    // Clear interrupt matrix for APP CPU core
    core_intr_matrix_clear();
403751da:	fc9481        	l32r	a8, 4037442c <_iram_text_start+0x28> (420013b8 <core_intr_matrix_clear>)
403751dd:	0008e0        	callx8	a8

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    //Take care putting stuff here: if asked, FreeRTOS will happily tell you the scheduler
    //has started, but it isn't active *on this CPU* yet.
    esp_cache_err_int_init();
403751e0:	fc9481        	l32r	a8, 40374430 <_iram_text_start+0x2c> (420019a0 <esp_cache_err_int_init>)
403751e3:	0008e0        	callx8	a8
#if (CONFIG_IDF_TARGET_ESP32 && CONFIG_ESP32_TRAX_TWOBANKS) || \
    (CONFIG_IDF_TARGET_ESP32S3 && CONFIG_ESP32S3_TRAX_TWOBANKS)
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif

    s_cpu_inited[1] = true;
403751e6:	fc8b81        	l32r	a8, 40374414 <_iram_text_start+0x10> (3fc94884 <s_cpu_inited>)
403751e9:	0020c0        	memw
403751ec:	014872        	s8i	a7, a8, 1

    while (!s_resume_cores) {
403751ef:	000286        	j	403751fd <call_start_cpu1+0x61>
403751f2:	a20000        	muluh	a0, a0, a0
        esp_rom_delay_us(100);
403751f5:	8164a0        	src	a6, a4, a10
403751f8:	8f          	.byte	0x8f
403751f9:	e0fc      	bnez.n	a0, 4037523b <do_multicore_settings+0x1b>
403751fb:	0008      	l32i.n	a0, a0, 0
    while (!s_resume_cores) {
403751fd:	fc8681        	l32r	a8, 40374418 <_iram_text_start+0x14> (3fc94880 <s_resume_cores>)
40375200:	0020c0        	memw
40375203:	000882        	l8ui	a8, a8, 0
40375206:	748080        	extui	a8, a8, 0, 8
40375209:	fe7816        	beqz	a8, 403751f4 <call_start_cpu1+0x58>
    asm volatile (
4037520c:	03eb80        	rsr.prid	a8
4037520f:	048d80        	extui	a8, a8, 13, 1
    }

    SYS_STARTUP_FN();
40375212:	fc8291        	l32r	a9, 4037441c <_iram_text_start+0x18> (3c026f34 <g_startup_fn>)
40375215:	a08890        	addx4	a8, a8, a9
40375218:	0888      	l32i.n	a8, a8, 0
4037521a:	0008e0        	callx8	a8
}
4037521d:	f01d      	retw.n
	...

40375220 <do_multicore_settings>:
}
#endif
// This function is needed to make the multicore app runnable on a unicore bootloader (built with FREERTOS UNICORE).
// It does some cache settings for other CPUs.
void IRAM_ATTR do_multicore_settings(void)
{
40375220:	004136        	entry	a1, 32
{
    cache_bus_mask_t mask = (cache_bus_mask_t)0;
    HAL_ASSERT(cache_id <= CACHE_LL_ID_ALL);
    //On esp32s3, only `CACHE_BUS_IBUS0` and `CACHE_BUS_DBUS0` are supported. Use `cache_ll_l1_get_bus()` to get your bus first

    uint32_t ibus_mask = REG_READ(EXTMEM_ICACHE_CTRL1_REG);
40375223:	fc8581        	l32r	a8, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
40375226:	0020c0        	memw
40375229:	0888      	l32i.n	a8, a8, 0
    if (cache_id == 0) {
        mask = (cache_bus_mask_t)(mask | ((!(ibus_mask & EXTMEM_ICACHE_SHUT_CORE0_BUS)) ? CACHE_BUS_IBUS0 : 0));
4037522b:	05e807        	bbsi	a8, 0, 40375234 <do_multicore_settings+0x14>
4037522e:	170c      	movi.n	a7, 1
40375230:	000086        	j	40375236 <do_multicore_settings+0x16>
40375233:	070c00        	lsi	f0, a12, 28
    } else {
        mask = (cache_bus_mask_t)(mask | ((!(ibus_mask & EXTMEM_ICACHE_SHUT_CORE1_BUS)) ? CACHE_BUS_IBUS0 : 0));
    }

    uint32_t dbus_mask = REG_READ(EXTMEM_DCACHE_CTRL1_REG);
40375236:	fc8181        	l32r	a8, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
40375239:	0020c0        	memw
4037523c:	0888      	l32i.n	a8, a8, 0
    if (cache_id == 1) {
        mask = (cache_bus_mask_t)(mask | ((!(dbus_mask & EXTMEM_DCACHE_SHUT_CORE0_BUS)) ? CACHE_BUS_DBUS0 : 0));
    } else {
        mask = (cache_bus_mask_t)(mask | ((!(dbus_mask & EXTMEM_DCACHE_SHUT_CORE1_BUS)) ? CACHE_BUS_DBUS0 : 0));
4037523e:	04e817        	bbsi	a8, 1, 40375246 <do_multicore_settings+0x26>
40375241:	880c      	movi.n	a8, 8
40375243:	000086        	j	40375249 <do_multicore_settings+0x29>
40375246:	00a082        	movi	a8, 0
40375249:	207780        	or	a7, a7, a8
#endif

    cache_bus_mask_t cache_bus_mask_core0 = cache_ll_l1_get_enabled_bus(0);
#ifndef CONFIG_IDF_TARGET_ESP32
    // 1. disable the cache before changing its settings.
    cache_hal_disable(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
4037524c:	02a0b2        	movi	a11, 2
4037524f:	01a0a2        	movi	a10, 1
40375252:	076d65        	call8	4037c928 <cache_hal_disable>
#endif
    for (unsigned core = 1; core < SOC_CPU_CORES_NUM; core++) {
40375255:	180c      	movi.n	a8, 1
40375257:	001146        	j	403752a0 <do_multicore_settings+0x80>
    if (cache_id == 0) {
4037525a:	48cc      	bnez.n	a8, 40375262 <do_multicore_settings+0x42>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE0_BUS : 0);
4037525c:	049070        	extui	a9, a7, 0, 1
4037525f:	000186        	j	40375269 <do_multicore_settings+0x49>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE1_BUS : 0);
40375262:	977a      	add.n	a9, a7, a7
40375264:	2a0c      	movi.n	a10, 2
40375266:	1099a0        	and	a9, a9, a10
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
40375269:	fc73a1        	l32r	a10, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
4037526c:	0020c0        	memw
4037526f:	0ab8      	l32i.n	a11, a10, 0
40375271:	1099b0        	and	a9, a9, a11
40375274:	3099b0        	xor	a9, a9, a11
40375277:	0020c0        	memw
4037527a:	0a99      	s32i.n	a9, a10, 0
    if (cache_id == 1) {
4037527c:	051866        	bnei	a8, 1, 40375285 <do_multicore_settings+0x65>
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE0_BUS : 0);
4037527f:	419370        	srli	a9, a7, 3
40375282:	000086        	j	40375288 <do_multicore_settings+0x68>
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE1_BUS : 0);
40375285:	419270        	srli	a9, a7, 2
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
40375288:	fc6da1        	l32r	a10, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
4037528b:	0020c0        	memw
4037528e:	002ab2        	l32i	a11, a10, 0
40375291:	1099b0        	and	a9, a9, a11
40375294:	3099b0        	xor	a9, a9, a11
40375297:	0020c0        	memw
4037529a:	006a92        	s32i	a9, a10, 0
4037529d:	01c882        	addi	a8, a8, 1
403752a0:	b628b6        	bltui	a8, 2, 4037525a <do_multicore_settings+0x3a>
        // 2. change cache settings. All cores must have the same settings.
        cache_ll_l1_enable_bus(core, cache_bus_mask_core0);
    }
#ifndef CONFIG_IDF_TARGET_ESP32
    // 3. enable the cache after changing its settings.
    cache_hal_enable(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403752a3:	2b0c      	movi.n	a11, 2
403752a5:	1a0c      	movi.n	a10, 1
403752a7:	076be5        	call8	4037c964 <cache_hal_enable>
#endif
}
403752aa:	f01d      	retw.n

403752ac <call_start_cpu0>:
/*
 * We arrive here after the bootloader finished loading the program from flash. The hardware is mostly uninitialized,
 * and the app CPU is in reset. We do have a stack, so we can do the initialization in C.
 */
void IRAM_ATTR call_start_cpu0(void)
{
403752ac:	00c136        	entry	a1, 96
403752af:	fc5581        	l32r	a8, 40374404 <_iram_text_start> (40374000 <_WindowOverflow4>)
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
403752b2:	13e780        	wsr.vecbase	a8
#if CONFIG_SECURE_ENABLE_TEE
    extern uint32_t esp_tee_service_call(int argc, ...);
    esprv_int_setup_mgmt_cb((void *)esp_tee_service_call);
#endif

    rst_reas[0] = esp_rom_get_reset_reason(0);
403752b5:	0a0c      	movi.n	a10, 0
403752b7:	fc7581        	l32r	a8, 4037448c <_iram_text_start+0x88> (4000057c <esp_rom_get_reset_reason>)
403752ba:	0008e0        	callx8	a8
403752bd:	0a5d      	mov.n	a5, a10
403752bf:	01a9      	s32i.n	a10, a1, 0
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    rst_reas[1] = esp_rom_get_reset_reason(1);
403752c1:	1a0c      	movi.n	a10, 1
403752c3:	fc7281        	l32r	a8, 4037448c <_iram_text_start+0x88> (4000057c <esp_rom_get_reset_reason>)
403752c6:	0008e0        	callx8	a8
403752c9:	11a9      	s32i.n	a10, a1, 4
    //Clear BSS. Please do not attempt to do any complex stuff (like early logging) before this.
#if SOC_MEM_NON_CONTIGUOUS_SRAM
    memset(&_bss_start_low, 0, (&_bss_end_low - &_bss_start_low) * sizeof(_bss_start_low));
    memset(&_bss_start_high, 0, (&_bss_end_high - &_bss_start_high) * sizeof(_bss_start_high));
#else
    memset(&_bss_start, 0, (&_bss_end - &_bss_start) * sizeof(_bss_start));
403752cb:	fc5ea1        	l32r	a10, 40374444 <_iram_text_start+0x40> (3fc94860 <app_elf_sha256_str>)
403752ce:	fc5cc1        	l32r	a12, 40374440 <_iram_text_start+0x3c> (3fc961f0 <_bss_end>)
403752d1:	c0cca0        	sub	a12, a12, a10
403752d4:	0b0c      	movi.n	a11, 0
403752d6:	fc6e81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403752d9:	0008e0        	callx8	a8
    memset(&_iram_bss_start, 0, (&_iram_bss_end - &_iram_bss_start) * sizeof(_iram_bss_start));
#endif

#if SOC_RTC_FAST_MEM_SUPPORTED || SOC_RTC_SLOW_MEM_SUPPORTED
    /* Unless waking from deep sleep (implying RTC memory is intact), clear RTC bss */
    if (rst_reas[0] != RESET_REASON_CORE_DEEP_SLEEP) {
403752dc:	105526        	beqi	a5, 5, 403752f0 <call_start_cpu0+0x44>
        memset(&_rtc_bss_start, 0, (&_rtc_bss_end - &_rtc_bss_start) * sizeof(_rtc_bss_start));
403752df:	fc5ba1        	l32r	a10, 4037444c <_iram_text_start+0x48> (50000000 <_coredump_rtc_end>)
403752e2:	fc59c1        	l32r	a12, 40374448 <_iram_text_start+0x44> (50000000 <_coredump_rtc_end>)
403752e5:	c0cca0        	sub	a12, a12, a10
403752e8:	0b0c      	movi.n	a11, 0
403752ea:	fc6981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403752ed:	0008e0        	callx8	a8
    }
#endif

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP && !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE && !SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE
    // It helps to fix missed cache settings for other cores. It happens when bootloader is unicore.
    do_multicore_settings();
403752f0:	fff2e5        	call8	40375220 <do_multicore_settings>
#endif

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    //cache hal ctx needs to be initialised
    cache_hal_init();
403752f3:	0759e5        	call8	4037c890 <cache_hal_init>
#endif

#if CONFIG_IDF_TARGET_ESP32S3
    /* Configure the mode of instruction cache : cache size, cache line size. */
    extern void rom_config_instruction_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_instruction_cache_mode(CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE, CONFIG_ESP32S3_ICACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE);
403752f6:	0c2c      	movi.n	a12, 32
403752f8:	8b0c      	movi.n	a11, 8
403752fa:	fc55a1        	l32r	a10, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
403752fd:	fc6581        	l32r	a8, 40374494 <_iram_text_start+0x90> (40001a1c <rom_config_instruction_cache_mode>)
40375300:	0008e0        	callx8	a8

    /* If we need use SPIRAM, we should use data cache.
       Configure the mode of data : cache size, cache line size.*/
    Cache_Suspend_DCache();
40375303:	0429e5        	call8	403795a0 <Cache_Suspend_DCache>
    extern void rom_config_data_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_data_cache_mode(CONFIG_ESP32S3_DATA_CACHE_SIZE, CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE);
40375306:	0c2c      	movi.n	a12, 32
40375308:	8b0c      	movi.n	a11, 8
4037530a:	fc52a1        	l32r	a10, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
4037530d:	fc6281        	l32r	a8, 40374498 <_iram_text_start+0x94> (40001a28 <rom_config_data_cache_mode>)
40375310:	0008e0        	callx8	a8
    Cache_Resume_DCache(0);
40375313:	0a0c      	movi.n	a10, 0
40375315:	fc6181        	l32r	a8, 4037449c <_iram_text_start+0x98> (400018c0 <Cache_Resume_DCache>)
40375318:	0008e0        	callx8	a8
    // are all in internal RAM. If the RAM loadable ELF has any requirement to memory map the
    // external flash then it should use flash or partition mmap APIs.
    uint32_t cache_mmu_irom_size = 0;
    __attribute__((unused)) uint32_t cache_mmu_drom_size = 0;
#else // CONFIG_APP_BUILD_TYPE_ELF_RAM
    uint32_t _instruction_size = (uint32_t)&_instruction_reserved_end - (uint32_t)&_instruction_reserved_start;
4037531b:	fc4f71        	l32r	a7, 40374458 <_iram_text_start+0x54> (42016256 <_etext>)
4037531e:	fc4f81        	l32r	a8, 4037445c <_iram_text_start+0x58> (42000020 <_instruction_reserved_start>)
40375321:	c07780        	sub	a7, a7, a8
    uint32_t cache_mmu_irom_size = ((_instruction_size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
40375324:	fc4f81        	l32r	a8, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40375327:	778a      	add.n	a7, a7, a8
40375329:	f57070        	extui	a7, a7, 16, 16
4037532c:	11a7e0        	slli	a10, a7, 2

    uint32_t _rodata_size = (uint32_t)&_rodata_reserved_end - (uint32_t)&_rodata_reserved_start;
4037532f:	fc4d31        	l32r	a3, 40374464 <_iram_text_start+0x60> (3c029f74 <_esp_system_init_fn_array_end>)
40375332:	fc4d41        	l32r	a4, 40374468 <_iram_text_start+0x64> (3c020020 <esp_app_desc>)
40375335:	c06340        	sub	a6, a3, a4
    __attribute__((unused)) uint32_t cache_mmu_drom_size = ((_rodata_size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
40375338:	668a      	add.n	a6, a6, a8
4037533a:	f56060        	extui	a6, a6, 16, 16
#endif // !CONFIG_APP_BUILD_TYPE_ELF_RAM

    /* Configure the Cache MMU size for instruction and rodata in flash. */
    Cache_Set_IDROM_MMU_Size(cache_mmu_irom_size, CACHE_DROM_MMU_MAX_END - cache_mmu_irom_size);
4037533d:	fcdab2        	addmi	a11, a10, 0xfffffc00
40375340:	60b0b0        	neg	a11, a11
40375343:	fc5781        	l32r	a8, 403744a0 <_iram_text_start+0x9c> (40001914 <Cache_Set_IDROM_MMU_Size>)
40375346:	0008e0        	callx8	a8
        ESP_DRAM_LOGE(TAG, "Octal Flash option selected, but EFUSE not configured!");
        abort();
    }
#endif

    esp_mspi_pin_init();
40375349:	027d65        	call8	40377b20 <esp_mspi_pin_init>
    // For Octal flash, it's hard to implement a read_id function in OPI mode for all vendors.
    // So we have to read it here in SPI mode, before entering the OPI mode.
    bootloader_flash_update_id();
4037534c:	fc5681        	l32r	a8, 403744a4 <_iram_text_start+0xa0> (42009178 <bootloader_flash_update_id>)
4037534f:	0008e0        	callx8	a8

    // Configure the power related stuff. After this the MSPI timing tuning can be done.
    esp_rtc_init();
40375352:	fc5581        	l32r	a8, 403744a8 <_iram_text_start+0xa4> (420015b0 <esp_rtc_init>)
40375355:	0008e0        	callx8	a8
     *
     * In bootloader, we only init Flash (and MSPI) to a preliminary state, for being flexible to
     * different chips.
     * In this stage, we re-configure the Flash (and MSPI) to required configuration
     */
    spi_flash_init_chip_state();
40375358:	027de5        	call8	40377b38 <spi_flash_init_chip_state>
#if SOC_MEMSPI_SRC_FREQ_120M_SUPPORTED
    // This function needs to be called when PLL is enabled. Needs to be called after spi_flash_init_chip_state in case
    // some state of flash is modified.
    mspi_timing_flash_tuning();
4037535b:	031de5        	call8	40378538 <mspi_timing_flash_tuning>
#endif

    esp_mmu_map_init();
4037535e:	fc5381        	l32r	a8, 403744ac <_iram_text_start+0xa8> (420092d8 <esp_mmu_map_init>)
40375361:	0008e0        	callx8	a8
    /**
     * @note
     * After this stage, you can access the flash through the cache, i.e. run code which is not placed in IRAM
     * or print string which locates on flash
     */
    esp_mspi_pin_reserve();
40375364:	fc5381        	l32r	a8, 403744b0 <_iram_text_start+0xac> (42009b6c <esp_mspi_pin_reserve>)
40375367:	0008e0        	callx8	a8
__attribute__((always_inline))
static inline esp_log_level_t esp_log_get_default_level(void)
{
#if CONFIG_LOG_DYNAMIC_LEVEL_CONTROL
    extern esp_log_level_t esp_log_default_level;
    return esp_log_default_level;
4037536a:	fc4081        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
4037536d:	0888      	l32i.n	a8, a8, 0
#endif // !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP

#if CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    ESP_EARLY_LOGI(TAG, "Unicore app");
#else
    ESP_EARLY_LOGI(TAG, "Multicore app");
4037536f:	1138b6        	bltui	a8, 3, 40375384 <call_start_cpu0+0xd8>
40375372:	0a86e5        	call8	4037fbe0 <esp_log_timestamp>
40375375:	fc3ec1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
40375378:	20baa0        	or	a11, a10, a10
4037537b:	fc3ea1        	l32r	a10, 40374474 <_iram_text_start+0x70> (3c0204b4 <_flash_rodata_start+0x394>)
4037537e:	fc4d81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375381:	0008e0        	callx8	a8
#endif
    /* NOTE: When ESP-TEE is enabled, it configures its own memory protection
     * scheme using the CPU-inherent features PMP and PMA and the APM peripheral.
     */
#if !CONFIG_SECURE_ENABLE_TEE
    bootloader_init_mem();
40375384:	fc2881        	l32r	a8, 40374424 <_iram_text_start+0x20> (42009170 <bootloader_init_mem>)
40375387:	0008e0        	callx8	a8
#endif

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_up[0] = true;
4037538a:	fc2181        	l32r	a8, 40374410 <_iram_text_start+0xc> (3fc94888 <s_cpu_up>)
4037538d:	01a092        	movi	a9, 1
40375390:	0020c0        	memw
40375393:	004892        	s8i	a9, a8, 0

    ESP_EARLY_LOGD(TAG, "Pro cpu up");

#if SOC_CPU_CORES_NUM > 1 // there is no 'single-core mode' for natively single-core processors
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    start_other_core();
40375396:	fc4881        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (420013dc <start_other_core>)
40375399:	0008e0        	callx8	a8
    s_instr_flash2spiram_off = instruction_flash2spiram_offset();
#endif
#if CONFIG_SPIRAM_RODATA
    s_rodata_flash2spiram_off = rodata_flash2spiram_offset();
#endif
    Cache_Set_IDROM_MMU_Info(cache_mmu_irom_size / sizeof(uint32_t), \
4037539c:	0f0c      	movi.n	a15, 0
4037539e:	0fed      	mov.n	a14, a15
403753a0:	03dd      	mov.n	a13, a3
403753a2:	04cd      	mov.n	a12, a4
403753a4:	20b660        	or	a11, a6, a6
403753a7:	20a770        	or	a10, a7, a7
403753aa:	fc4481        	l32r	a8, 403744bc <_iram_text_start+0xb8> (40001950 <Cache_Set_IDROM_MMU_Info>)
403753ad:	0008e0        	callx8	a8
    trax_enable(TRAX_ENA_PRO);
#endif
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif // CONFIG_ESP32_TRAX || CONFIG_ESP32S2_TRAX || CONFIG_ESP32S3_TRAX

    esp_clk_init();
403753b0:	fc4481        	l32r	a8, 403744c0 <_iram_text_start+0xbc> (420015d8 <esp_clk_init>)
403753b3:	0008e0        	callx8	a8
    esp_perip_clk_init();
403753b6:	fc4381        	l32r	a8, 403744c4 <_iram_text_start+0xc0> (42001700 <esp_perip_clk_init>)
403753b9:	0008e0        	callx8	a8

    // Now that the clocks have been set-up, set the startup time from RTC
    // and default RTC-backed system time provider.
    g_startup_time = esp_rtc_get_time_us();
403753bc:	fc4381        	l32r	a8, 403744c8 <_iram_text_start+0xc4> (420030e4 <esp_rtc_get_time_us>)
403753bf:	0008e0        	callx8	a8
403753c2:	fc2d81        	l32r	a8, 40374478 <_iram_text_start+0x74> (3fc948b8 <g_startup_time>)
403753c5:	08a9      	s32i.n	a10, a8, 0
403753c7:	0168b2        	s32i	a11, a8, 4

    // Clear interrupt matrix for PRO CPU core
    core_intr_matrix_clear();
403753ca:	fc1881        	l32r	a8, 4037442c <_iram_text_start+0x28> (420013b8 <core_intr_matrix_clear>)
403753cd:	0008e0        	callx8	a8
#endif
#endif

#if SOC_DEEP_SLEEP_SUPPORTED
    // Need to unhold the IOs that were hold right before entering deep sleep, which are used as wakeup pins
    if (rst_reas[0] == RESET_REASON_CORE_DEEP_SLEEP) {
403753d0:	055566        	bnei	a5, 5, 403753d9 <call_start_cpu0+0x12d>
        esp_deep_sleep_wakeup_io_reset();
403753d3:	fc3e81        	l32r	a8, 403744cc <_iram_text_start+0xc8> (42003b08 <esp_deep_sleep_wakeup_io_reset>)
403753d6:	0008e0        	callx8	a8
    }
#endif  //#if SOC_DEEP_SLEEP_SUPPORTED

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    esp_cache_err_int_init();
403753d9:	fc1581        	l32r	a8, 40374430 <_iram_text_start+0x2c> (420019a0 <esp_cache_err_int_init>)
403753dc:	0008e0        	callx8	a8
    // If such a situation appears, it is likely an malicious attempt to bypass the system safety setup -> print error & reset

#if CONFIG_IDF_TARGET_ESP32S2
    if (esp_memprot_is_locked_any()) {
#else
    bool is_locked = false;
403753df:	080c      	movi.n	a8, 0
403753e1:	084182        	s8i	a8, a1, 8
    if (esp_mprot_is_conf_locked_any(&is_locked) != ESP_OK || is_locked) {
403753e4:	a18b      	addi.n	a10, a1, 8
403753e6:	fc3a81        	l32r	a8, 403744d0 <_iram_text_start+0xcc> (42004f64 <esp_mprot_is_conf_locked_any>)
403753e9:	0008e0        	callx8	a8
403753ec:	3acc      	bnez.n	a10, 403753f3 <call_start_cpu0+0x147>
403753ee:	080182        	l8ui	a8, a1, 8
403753f1:	d89c      	beqz.n	a8, 40375412 <call_start_cpu0+0x166>
403753f3:	fc1e81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
403753f6:	0888      	l32i.n	a8, a8, 0
#endif
        ESP_EARLY_LOGE(TAG, "Memprot feature locked after the system reset! Potential safety corruption, rebooting.");
403753f8:	089c      	beqz.n	a8, 4037540c <call_start_cpu0+0x160>
403753fa:	0a7e65        	call8	4037fbe0 <esp_log_timestamp>
403753fd:	fc1cc1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
40375400:	20baa0        	or	a11, a10, a10
40375403:	fc1ea1        	l32r	a10, 4037447c <_iram_text_start+0x78> (3c0204d0 <_flash_rodata_start+0x3b0>)
40375406:	fc2b81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375409:	0008e0        	callx8	a8
        esp_restart_noos();
4037540c:	201110        	or	a1, a1, a1
4037540f:	003525        	call8	40375760 <esp_restart_noos>
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_LOCK, NULL);
#else
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_UNLOCK, NULL);
#endif
#else //CONFIG_IDF_TARGET_ESP32S2 specific end
    esp_memp_config_t memp_cfg = ESP_MEMPROT_DEFAULT_CONFIG();
40375412:	71cb      	addi.n	a7, a1, 12
40375414:	8c1c      	movi.n	a12, 24
40375416:	fc1ab1        	l32r	a11, 40374480 <_iram_text_start+0x7c> (3c026e54 <__func__$0+0x20>)
40375419:	07ad      	mov.n	a10, a7
4037541b:	fc2e81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037541e:	0008e0        	callx8	a8
#if !CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK
    memp_cfg.lock_feature = false;
#endif
    memp_err = esp_mprot_set_prot(&memp_cfg);
40375421:	07ad      	mov.n	a10, a7
40375423:	fc2d81        	l32r	a8, 403744d8 <_iram_text_start+0xd4> (420050ec <esp_mprot_set_prot>)
40375426:	0008e0        	callx8	a8
40375429:	0a7d      	mov.n	a7, a10
#endif //other IDF_TARGETS end

    if (memp_err != ESP_OK) {
4037542b:	9aac      	beqz.n	a10, 40375458 <call_start_cpu0+0x1ac>
4037542d:	fc0f81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40375430:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Failed to set Memprot feature (0x%08X: %s), rebooting.", memp_err, esp_err_to_name(memp_err));
40375433:	e89c      	beqz.n	a8, 40375455 <call_start_cpu0+0x1a9>
40375435:	0a7aa5        	call8	4037fbe0 <esp_log_timestamp>
40375438:	0a6d      	mov.n	a6, a10
4037543a:	07ad      	mov.n	a10, a7
4037543c:	fc2881        	l32r	a8, 403744dc <_iram_text_start+0xd8> (420027bc <esp_err_to_name>)
4037543f:	0008e0        	callx8	a8
40375442:	0aed      	mov.n	a14, a10
40375444:	07dd      	mov.n	a13, a7
40375446:	fc0ac1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
40375449:	20b660        	or	a11, a6, a6
4037544c:	fc0ea1        	l32r	a10, 40374484 <_iram_text_start+0x80> (3c020534 <_flash_rodata_start+0x414>)
4037544f:	fc1981        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375452:	0008e0        	callx8	a8
        esp_restart_noos();
40375455:	0030a5        	call8	40375760 <esp_restart_noos>

#if !CONFIG_APP_BUILD_TYPE_RAM
    // Normal startup flow. We arrive here with the help of 1st, 2nd bootloader. There are valid headers (app/bootloader)

    // Read the application binary image header. This will also decrypt the header if the image is encrypted.
    __attribute__((unused)) esp_image_header_t fhdr = {0};
40375458:	24c162        	addi	a6, a1, 36
4037545b:	851c      	movi.n	a5, 24
4037545d:	05cd      	mov.n	a12, a5
4037545f:	0b0c      	movi.n	a11, 0
40375461:	06ad      	mov.n	a10, a6
40375463:	fc0b81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40375466:	0008e0        	callx8	a8

    // We can access the image header through the cache by reading from the memory-mapped virtual DROM start offset
    uint32_t fhdr_src_addr = (uint32_t)(&_rodata_reserved_start) - sizeof(esp_image_header_t) - sizeof(esp_image_segment_header_t);
    hal_memcpy(&fhdr, (void *) fhdr_src_addr, sizeof(fhdr));
40375469:	05cd      	mov.n	a12, a5
4037546b:	e0c4b2        	addi	a11, a4, -32
4037546e:	06ad      	mov.n	a10, a6
40375470:	fc1981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375473:	0008e0        	callx8	a8
    if (fhdr.magic != ESP_IMAGE_HEADER_MAGIC) {
40375476:	240192        	l8ui	a9, a1, 36
40375479:	e9a082        	movi	a8, 233
4037547c:	1c1987        	beq	a9, a8, 4037549c <call_start_cpu0+0x1f0>
4037547f:	fbfb81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40375482:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Invalid app image header");
40375485:	010816        	beqz	a8, 40375499 <call_start_cpu0+0x1ed>
40375488:	0a7565        	call8	4037fbe0 <esp_log_timestamp>
4037548b:	fbf9c1        	l32r	a12, 40374470 <_iram_text_start+0x6c> (3c0202e4 <_flash_rodata_start+0x1c4>)
4037548e:	0abd      	mov.n	a11, a10
40375490:	fbfea1        	l32r	a10, 40374488 <_iram_text_start+0x84> (3c020578 <_flash_rodata_start+0x458>)
40375493:	fc0881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375496:	0008e0        	callx8	a8
        abort();
40375499:	0a7fa5        	call8	4037fc94 <abort>
    bootloader_flash_unlock();
#endif
#endif //!CONFIG_APP_BUILD_TYPE_PURE_RAM_APP

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_inited[0] = true;
4037549c:	fbde81        	l32r	a8, 40374414 <_iram_text_start+0x10> (3fc94884 <s_cpu_inited>)
4037549f:	190c      	movi.n	a9, 1
403754a1:	0020c0        	memw
403754a4:	004892        	s8i	a9, a8, 0

    volatile bool cpus_inited = false;
403754a7:	080c      	movi.n	a8, 0
403754a9:	0020c0        	memw
403754ac:	3c4182        	s8i	a8, a1, 60

    while (!cpus_inited) {
403754af:	000e46        	j	403754ec <call_start_cpu0+0x240>
        cpus_inited = true;
403754b2:	180c      	movi.n	a8, 1
403754b4:	0020c0        	memw
403754b7:	3c4182        	s8i	a8, a1, 60
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
403754ba:	079d      	mov.n	a9, a7
403754bc:	000806        	j	403754e0 <call_start_cpu0+0x234>
403754bf:	810000        	src	a0, a0, a0
            cpus_inited &= s_cpu_inited[i];
403754c2:	9afbd4        	lsi	f13, a11, 0x268
403754c5:	c088      	l32i.n	a8, a0, 48
403754c7:	a20020        	muluh	a0, a0, a2
403754ca:	0008      	l32i.n	a0, a0, 0
403754cc:	0020c0        	memw
403754cf:	3c0182        	l8ui	a8, a1, 60
403754d2:	748080        	extui	a8, a8, 0, 8
403754d5:	1088a0        	and	a8, a8, a10
403754d8:	0020c0        	memw
403754db:	3c4182        	s8i	a8, a1, 60
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
403754de:	991b      	addi.n	a9, a9, 1
403754e0:	dd29a6        	blti	a9, 2, 403754c1 <call_start_cpu0+0x215>
        }
        esp_rom_delay_us(100);
403754e3:	64a0a2        	movi	a10, 100
403754e6:	fbd381        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
403754e9:	0008e0        	callx8	a8
    while (!cpus_inited) {
403754ec:	0020c0        	memw
403754ef:	3c0182        	l8ui	a8, a1, 60
403754f2:	748080        	extui	a8, a8, 0, 8
403754f5:	fb9816        	beqz	a8, 403754b2 <call_start_cpu0+0x206>
    asm volatile (
403754f8:	03eb80        	rsr.prid	a8
403754fb:	048d80        	extui	a8, a8, 13, 1
    }
#endif

    SYS_STARTUP_FN();
403754fe:	fbc791        	l32r	a9, 4037441c <_iram_text_start+0x18> (3c026f34 <g_startup_fn>)
40375501:	a08890        	addx4	a8, a8, a9
40375504:	0888      	l32i.n	a8, a8, 0
40375506:	0008e0        	callx8	a8
}
40375509:	f01d      	retw.n
	...

4037550c <rtc_brownout_isr_handler>:

static __attribute__((unused)) DRAM_ATTR const char TAG[] = "BOD";

#if CONFIG_ESP_SYSTEM_BROWNOUT_INTR
IRAM_ATTR static void rtc_brownout_isr_handler(void *arg)
{
4037550c:	004136        	entry	a1, 32
 * @brief Clear interrupt bits.
 */
__attribute__((always_inline))
static inline void brownout_ll_intr_clear(void)
{
    RTCCNTL.int_clr.rtc_brown_out = 1;
4037550f:	fbf491        	l32r	a9, 403744e0 <_iram_text_start+0xdc> (60008000 <RTCCNTL>)
40375512:	0020c0        	memw
40375515:	132982        	l32i	a8, a9, 76
40375518:	00a2a2        	movi	a10, 0x200
4037551b:	2088a0        	or	a8, a8, a10
4037551e:	0020c0        	memw
40375521:	136982        	s32i	a8, a9, 76
40375524:	03eba0        	rsr.prid	a10
40375527:	04ada0        	extui	a10, a10, 13, 1

    // Stop the other core.
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    const uint32_t core_id = esp_cpu_get_core_id();
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
    esp_cpu_stall(other_core_id);
4037552a:	40faa0        	nsau	a10, a10
4037552d:	41a5a0        	srli	a10, a10, 5
40375530:	02c8a5        	call8	403781bc <esp_cpu_stall>
#endif

    esp_reset_reason_set_hint(ESP_RST_BROWNOUT);
40375533:	9a0c      	movi.n	a10, 9
40375535:	001325        	call8	40375668 <esp_reset_reason_set_hint>
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    if (spi_flash_brownout_need_reset()) {
40375538:	0aa0a5        	call8	4037ff44 <spi_flash_brownout_need_reset>
4037553b:	5a8c      	beqz.n	a10, 40375544 <rtc_brownout_isr_handler+0x38>
        bootloader_flash_reset_chip();
4037553d:	0209e5        	call8	403775dc <bootloader_flash_reset_chip>
40375540:	001a86        	j	403755ae <rtc_brownout_isr_handler+0xa2>
40375543:	ca8100        	float.s	f8, a1, 0
40375546:	88fb      	addi.n	a8, a8, 15
40375548:	b608      	l32i.n	a0, a6, 44
    } else
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET
    {
        ESP_DRAM_LOGI(TAG, "Brownout detector was triggered\r\n\r\n");
4037554a:	6138      	l32i.n	a3, a1, 24
4037554c:	fbe6b1        	l32r	a11, 403744e4 <_iram_text_start+0xe0> (3fc927c8 <TAG>)
4037554f:	fbe6a1        	l32r	a10, 403744e8 <_iram_text_start+0xe4> (3fc9279c <__c$0>)
40375552:	fbd881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375555:	0008e0        	callx8	a8
40375558:	001486        	j	403755ae <rtc_brownout_isr_handler+0xa2>
4037555b:	079d00        	lsi	f0, a13, 28
 *
 * @return true: enabled; false: disabled
 */
FORCE_INLINE_ATTR bool uart_ll_is_enabled(uint32_t uart_num)
{
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
4037555e:	679c      	beqz.n	a7, 40375578 <rtc_brownout_isr_handler+0x6c>
                            (uart_num == 1) ? SYSTEM_UART1_RST :
40375560:	1c1726        	beqi	a7, 1, 40375580 <rtc_brownout_isr_handler+0x74>
                            (uart_num == 2) ? SYSTEM_UART2_RST : 0);
40375563:	052766        	bnei	a7, 2, 4037556c <rtc_brownout_isr_handler+0x60>
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
40375566:	00a282        	movi	a8, 0x200
40375569:	000046        	j	4037556e <rtc_brownout_isr_handler+0x62>
4037556c:	080c      	movi.n	a8, 0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
4037556e:	162966        	bnei	a9, 2, 40375588 <rtc_brownout_isr_handler+0x7c>
40375571:	00a2a2        	movi	a10, 0x200
40375574:	000486        	j	4037558a <rtc_brownout_isr_handler+0x7e>
40375577:	480c00        	ssx	f0, a12, a0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
4037557a:	08ad      	mov.n	a10, a8
4037557c:	000286        	j	4037558a <rtc_brownout_isr_handler+0x7e>
4037557f:	082c00        	lsx	f2, a12, a0
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
40375582:	0a2c      	movi.n	a10, 32
40375584:	000086        	j	4037558a <rtc_brownout_isr_handler+0x7e>
40375587:	0a0c00        	add.s	f0, f12, f0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
4037558a:	fbd891        	l32r	a9, 403744ec <_iram_text_start+0xe8> (600c0020 <SYSTEM+0x20>)
4037558d:	0020c0        	memw
40375590:	0998      	l32i.n	a9, a9, 0
40375592:	138987        	bany	a9, a8, 403755a9 <rtc_brownout_isr_handler+0x9d>
        DPORT_REG_GET_BIT(SYSTEM_PERIP_CLK_EN0_REG, uart_en_bit) != 0;
40375595:	fbd681        	l32r	a8, 403744f0 <_iram_text_start+0xec> (600c0018 <SYSTEM+0x18>)
40375598:	0020c0        	memw
4037559b:	0888      	l32i.n	a8, a8, 0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
4037559d:	0808a7        	bnone	a8, a10, 403755a9 <rtc_brownout_isr_handler+0x9d>
    }

    // Flush any data left in UART FIFOs
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
        if (uart_ll_is_enabled(i)) {
            esp_rom_output_tx_wait_idle(i);
403755a0:	74a070        	extui	a10, a7, 0, 8
403755a3:	fbd481        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (4000069c <esp_rom_output_tx_wait_idle>)
403755a6:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
403755a9:	771b      	addi.n	a7, a7, 1
403755ab:	000046        	j	403755b0 <rtc_brownout_isr_handler+0xa4>
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
403755ae:	070c      	movi.n	a7, 0
403755b0:	a837a6        	blti	a7, 3, 4037555c <rtc_brownout_isr_handler+0x50>
        }
    }

    esp_rom_software_reset_system();
403755b3:	fbd181        	l32r	a8, 403744f8 <_iram_text_start+0xf4> (400006d8 <esp_rom_software_reset_system>)
403755b6:	0008e0        	callx8	a8

    ESP_INFINITE_LOOP();
403755b9:	ffff06        	j	403755b9 <rtc_brownout_isr_handler+0xad>

403755bc <xt_highint4>:
    .align      4
xt_highint4:

#ifndef CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    /* See if we're here for the IPC_ISR interrupt */
    rsr     a0, INTERRUPT
403755bc:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_IPC_ISR_INUM, 1
403755bf:	050c00        	extui	a0, a0, 28, 1
    bnez    a0, jump_to_esp_ipc_isr_handler
403755c2:	07f056        	bnez	a0, 40375645 <jump_to_esp_ipc_isr_handler>
#endif // not CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE

    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
403755c5:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
403755c7:	ffd112        	addmi	a1, a1, 0xffffff00
403755ca:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
403755cd:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
403755cf:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
403755d2:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
403755d5:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_4                       /* save interruptee's PC */
403755d7:	03b400        	rsr.epc4	a0
    s32i    a0, sp, XT_STK_PC
403755da:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_4                   /* save interruptee's a0 */
403755dc:	03d400        	rsr.excsave4	a0
    s32i    a0, sp, XT_STK_A0
403755df:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
403755e1:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
403755e4:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
403755e6:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
403755e9:	0c7285        	call0	40381d14 <_xt_context_save>

    /* Save vaddr into exception frame */
    rsr     a0, EXCVADDR
403755ec:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
403755ef:	156102        	s32i	a0, a1, 84

    /* Figure out reason, save into EXCCAUSE reg */

    rsr     a0, INTERRUPT
403755f2:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_CACHEERR_INUM, 1 /* get cacheerr int bit */
403755f5:	050900        	extui	a0, a0, 25, 1
    beqz    a0, 1f
403755f8:	009c      	beqz.n	a0, 4037560c <xt_highint4+0x50>
    /* Kill this interrupt; we cannot reset it. */
    rsr     a0, INTENABLE
403755fa:	03e400        	rsr.intenable	a0
    movi    a4, ~(1<<ETS_CACHEERR_INUM)
403755fd:	fbbf41        	l32r	a4, 403744fc <_iram_text_start+0xf8> (fdffffff <_rtc_reserved_end+0x9defffff>)
    and     a0, a4, a0
40375600:	100400        	and	a0, a4, a0
    wsr     a0, INTENABLE
40375603:	13e400        	wsr.intenable	a0
    movi    a0, PANIC_RSN_CACHEERR
40375606:	700c      	movi.n	a0, 7
    j 9f
40375608:	000406        	j	4037561c <xt_highint4+0x60>
4037560b:	bd0100        	lsi	f0, a1, 0x2f4

1:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    /* Check if the cause is the app cpu failing to tick.*/
    movi    a0, int_wdt_cpu1_ticked
4037560e:	08fb      	addi.n	a0, a8, 15
    l32i    a0, a0, 0
40375610:	40cc00        	lsi	f0, a12, 0x100
    bnez    a0, 2f
    /* It is. Modify cause. */
    movi    a0,PANIC_RSN_INTWDT_CPU1
40375613:	600c      	movi.n	a0, 6
    j 9f
40375615:	0000c6        	j	4037561c <xt_highint4+0x60>
40375618:	a00200        	addx4	a0, a2, a0
2:
#endif

    /* Set EXCCAUSE to reflect cause of the wdt int trigger */
    movi    a0,PANIC_RSN_INTWDT_CPU0
4037561b:	610205        	call0	403d663c <_coredump_iram_end+0x5473c>
9:
    /* Found the reason, now save it. */
    s32i    a0, sp, XT_STK_EXCCAUSE
4037561e:	b90114        	lsi	f1, a1, 0x2e4

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(5) | PS_UM | PS_WOE
40375621:	00fb      	addi.n	a0, a0, 15
    wsr     a0, PS
40375623:	1013e6        	bgei	a3, 1, 40375637 <xt_highint4+0x7b>

    //Call panic handler
    mov     a6,sp
40375626:	552061        	l32r	a6, 4034aaa8 <rom_rx_gain_force+0x34467c>
    call4   panicHandler
40375629:	0039      	s32i.n	a3, a0, 0

    call0   _xt_context_restore
4037562b:	0c78c5        	call0	40381db8 <_xt_context_restore>
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
4037562e:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40375630:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40375633:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_4
40375635:	13b400        	wsr.epc4	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40375638:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
4037563a:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
4037563c:	002010        	rsync

    rsr     a0, EXCSAVE_4                   /* restore a0 */
4037563f:	03d400        	rsr.excsave4	a0
    rfi     4
40375642:	003410        	rfi	4

40375645 <jump_to_esp_ipc_isr_handler>:

#ifdef CONFIG_ESP_IPC_ISR_ENABLE
jump_to_esp_ipc_isr_handler:
    /* Address of `esp_ipc_isr_handler_address` will always be in `movi` range
     * as it is defined right above. */
    movi    a0, esp_ipc_isr_handler
40375645:	fbb001        	l32r	a0, 40374508 <_iram_text_start+0x104> (403759f8 <esp_ipc_isr_handler>)
    jx      a0
40375648:	0000a0        	jx	a0

4037564b <ld_include_highint_hdl>:
	...

4037564c <recalib_bbpll>:
}

// Workaround for bootloader not calibrated well issue.
// Placed in IRAM because disabling BBPLL may influence the cache
static void IRAM_ATTR NOINLINE_ATTR recalib_bbpll(void)
{
4037564c:	006136        	entry	a1, 48
    rtc_cpu_freq_config_t old_config;
    rtc_clk_cpu_freq_get_config(&old_config);
4037564f:	20a110        	or	a10, a1, a1
40375652:	034f25        	call8	40378b44 <rtc_clk_cpu_freq_get_config>
    // There are two paths we arrive here: 1. CPU reset. 2. Other reset reasons.
    // - For other reasons, the bootloader will set CPU source to BBPLL and enable it. But there are calibration issues.
    //   Turn off the BBPLL and do calibration again to fix the issue.
    // - For CPU reset, the CPU source will be set to XTAL, while the BBPLL is kept to meet USB Serial JTAG's
    //   requirements. In this case, we don't touch BBPLL to avoid USJ disconnection.
    if (old_config.source == SOC_CPU_CLK_SRC_PLL) {
40375655:	002182        	l32i	a8, a1, 0
40375658:	081866        	bnei	a8, 1, 40375664 <recalib_bbpll+0x18>
        rtc_clk_cpu_freq_set_xtal();
4037565b:	038b65        	call8	40378f10 <rtc_clk_cpu_freq_set_xtal>
        rtc_clk_cpu_freq_set_config(&old_config);
4037565e:	20a110        	or	a10, a1, a1
40375661:	0383e5        	call8	40378ea0 <rtc_clk_cpu_freq_set_config>
    }
}
40375664:	f01d      	retw.n
	...

40375668 <esp_reset_reason_set_hint>:
#define RST_REASON_MASK 0x7FFF
#define RST_REASON_SHIFT 16

/* in IRAM, can be called from panic handler */
void IRAM_ATTR esp_reset_reason_set_hint(esp_reset_reason_t hint)
{
40375668:	004136        	entry	a1, 32
    assert((hint & (~RST_REASON_MASK)) == 0);
4037566b:	fba881        	l32r	a8, 4037450c <_iram_text_start+0x108> (7fff <UserFrameTotalSize+0x7eff>)
4037566e:	0eb827        	bgeu	a8, a2, 40375680 <esp_reset_reason_set_hint+0x18>
40375671:	fba7d1        	l32r	a13, 40374510 <_iram_text_start+0x10c> (3c02065c <_flash_rodata_start+0x53c>)
40375674:	fba8c1        	l32r	a12, 40374514 <_iram_text_start+0x110> (3c026e88 <__func__$0>)
40375677:	5da0b2        	movi	a11, 93
4037567a:	fba7a1        	l32r	a10, 40374518 <_iram_text_start+0x114> (3c0206ad <_flash_rodata_start+0x58d>)
4037567d:	0a6d25        	call8	4037fd50 <__assert_func>
    uint32_t val = hint | (hint << RST_REASON_SHIFT) | RST_REASON_BIT;
40375680:	118200        	slli	a8, a2, 16
40375683:	208820        	or	a8, a8, a2
40375686:	fba591        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
40375689:	208890        	or	a8, a8, a9
    REG_WRITE(RTC_RESET_CAUSE_REG, val);
4037568c:	fba591        	l32r	a9, 40374520 <_iram_text_start+0x11c> (600080c8 <RTCCNTL+0xc8>)
4037568f:	0020c0        	memw
40375692:	006982        	s32i	a8, a9, 0
}
40375695:	000090        	retw

40375698 <esp_system_reset_modules_on_exit>:
#define ALIGN_DOWN(val, align)  ((val) & ~((align) - 1))

extern int _bss_end;

void IRAM_ATTR esp_system_reset_modules_on_exit(void)
{
40375698:	004136        	entry	a1, 32
    // Flush any data left in UART FIFOs before reset the UART peripheral
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
4037569b:	070c      	movi.n	a7, 0
4037569d:	001386        	j	403756ef <esp_system_reset_modules_on_exit+0x57>
        if (uart_ll_is_enabled(i)) {
403756a0:	079d      	mov.n	a9, a7
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
403756a2:	679c      	beqz.n	a7, 403756bc <esp_system_reset_modules_on_exit+0x24>
                            (uart_num == 1) ? SYSTEM_UART1_RST :
403756a4:	1c1726        	beqi	a7, 1, 403756c4 <esp_system_reset_modules_on_exit+0x2c>
                            (uart_num == 2) ? SYSTEM_UART2_RST : 0);
403756a7:	052766        	bnei	a7, 2, 403756b0 <esp_system_reset_modules_on_exit+0x18>
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
403756aa:	00a282        	movi	a8, 0x200
403756ad:	000046        	j	403756b2 <esp_system_reset_modules_on_exit+0x1a>
403756b0:	080c      	movi.n	a8, 0
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
403756b2:	162966        	bnei	a9, 2, 403756cc <esp_system_reset_modules_on_exit+0x34>
403756b5:	00a2a2        	movi	a10, 0x200
403756b8:	000486        	j	403756ce <esp_system_reset_modules_on_exit+0x36>
403756bb:	480c00        	ssx	f0, a12, a0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
403756be:	08ad      	mov.n	a10, a8
403756c0:	000286        	j	403756ce <esp_system_reset_modules_on_exit+0x36>
403756c3:	082c00        	lsx	f2, a12, a0
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
403756c6:	08ad      	mov.n	a10, a8
403756c8:	000086        	j	403756ce <esp_system_reset_modules_on_exit+0x36>
403756cb:	0a0c00        	add.s	f0, f12, f0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
403756ce:	fb8791        	l32r	a9, 403744ec <_iram_text_start+0xe8> (600c0020 <SYSTEM+0x20>)
403756d1:	0020c0        	memw
403756d4:	0998      	l32i.n	a9, a9, 0
403756d6:	138987        	bany	a9, a8, 403756ed <esp_system_reset_modules_on_exit+0x55>
        DPORT_REG_GET_BIT(SYSTEM_PERIP_CLK_EN0_REG, uart_en_bit) != 0;
403756d9:	fb8581        	l32r	a8, 403744f0 <_iram_text_start+0xec> (600c0018 <SYSTEM+0x18>)
403756dc:	0020c0        	memw
403756df:	0888      	l32i.n	a8, a8, 0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
403756e1:	0808a7        	bnone	a8, a10, 403756ed <esp_system_reset_modules_on_exit+0x55>
            esp_rom_output_tx_wait_idle(i);
403756e4:	74a070        	extui	a10, a7, 0, 8
403756e7:	fb8381        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (4000069c <esp_rom_output_tx_wait_idle>)
403756ea:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
403756ed:	771b      	addi.n	a7, a7, 1
403756ef:	ad37a6        	blti	a7, 3, 403756a0 <esp_system_reset_modules_on_exit+0x8>
        }
    }

    // Reset wifi/bluetooth/ethernet/sdio (bb/mac)
    SET_PERI_REG_MASK(SYSTEM_CORE_RST_EN_REG,
403756f2:	fb8c81        	l32r	a8, 40374524 <_iram_text_start+0x120> (60026018 <SYSCON+0x18>)
403756f5:	0020c0        	memw
403756f8:	0898      	l32i.n	a9, a8, 0
403756fa:	fb8ba1        	l32r	a10, 40374528 <_iram_text_start+0x124> (3faf <UserFrameTotalSize+0x3eaf>)
403756fd:	2099a0        	or	a9, a9, a10
40375700:	0020c0        	memw
40375703:	0899      	s32i.n	a9, a8, 0
                      SYSTEM_WIFIBB_RST | SYSTEM_FE_RST | SYSTEM_WIFIMAC_RST | SYSTEM_SDIO_RST |
                      SYSTEM_EMAC_RST | SYSTEM_MACPWR_RST | SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST |
                      SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
    REG_WRITE(SYSTEM_CORE_RST_EN_REG, 0);
40375705:	090c      	movi.n	a9, 0
40375707:	0020c0        	memw
4037570a:	0899      	s32i.n	a9, a8, 0

    // Reset timer, systimer, spi, uart, mcpwm
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG,
4037570c:	fb7881        	l32r	a8, 403744ec <_iram_text_start+0xe8> (600c0020 <SYSTEM+0x20>)
4037570f:	0020c0        	memw
40375712:	08a8      	l32i.n	a10, a8, 0
40375714:	fb86b1        	l32r	a11, 4037452c <_iram_text_start+0x128> (20120007 <UserFrameTotalSize+0x2011ff07>)
40375717:	20aab0        	or	a10, a10, a11
4037571a:	0020c0        	memw
4037571d:	08a9      	s32i.n	a10, a8, 0
                      SYSTEM_TIMERS_RST | SYSTEM_SPI01_RST | SYSTEM_UART_RST | SYSTEM_SYSTIMER_RST |
                      SYSTEM_PWM0_RST | SYSTEM_PWM1_RST);
    REG_WRITE(SYSTEM_PERIP_RST_EN0_REG, 0);
4037571f:	0020c0        	memw
40375722:	0899      	s32i.n	a9, a8, 0

    // Reset dma
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_DMA_RST);
40375724:	fb8381        	l32r	a8, 40374530 <_iram_text_start+0x12c> (600c0024 <SYSTEM+0x24>)
40375727:	0020c0        	memw
4037572a:	08a8      	l32i.n	a10, a8, 0
4037572c:	0b4c      	movi.n	a11, 64
4037572e:	20aab0        	or	a10, a10, a11
40375731:	0020c0        	memw
40375734:	08a9      	s32i.n	a10, a8, 0
    REG_WRITE(SYSTEM_PERIP_RST_EN1_REG, 0);
40375736:	0020c0        	memw
40375739:	0899      	s32i.n	a9, a8, 0

    SET_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
4037573b:	fb7e81        	l32r	a8, 40374534 <_iram_text_start+0x130> (600c0044 <SYSTEM+0x44>)
4037573e:	0020c0        	memw
40375741:	0898      	l32i.n	a9, a8, 0
40375743:	2a0c      	movi.n	a10, 2
40375745:	2099a0        	or	a9, a9, a10
40375748:	0020c0        	memw
4037574b:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
4037574d:	0020c0        	memw
40375750:	0898      	l32i.n	a9, a8, 0
40375752:	da7c      	movi.n	a10, -3
40375754:	1099a0        	and	a9, a9, a10
40375757:	0020c0        	memw
4037575a:	0899      	s32i.n	a9, a8, 0
}
4037575c:	f01d      	retw.n
	...

40375760 <esp_restart_noos>:
/* "inner" restart function for after RTOS, interrupts & anything else on this
 * core are already stopped. Stalls other core, resets hardware,
 * triggers restart.
*/
void IRAM_ATTR esp_restart_noos(void)
{
40375760:	008136        	entry	a1, 64
 * @param intr_mask Bit mask of the interrupts to disable
 */
FORCE_INLINE_ATTR void esp_cpu_intr_disable(uint32_t intr_mask)
{
#ifdef __XTENSA__
    xt_ints_off(intr_mask);
40375763:	fa7c      	movi.n	a10, -1
40375765:	0c75a5        	call8	40381ec0 <xt_ints_off>
    // Disable interrupts
    esp_cpu_intr_disable(0xFFFFFFFF);

    // Enable RTC watchdog for 1 second
    wdt_hal_context_t rtc_wdt_ctx;
    wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
40375768:	0d0c      	movi.n	a13, 0
4037576a:	0dcd      	mov.n	a12, a13
4037576c:	0dbd      	mov.n	a11, a13
4037576e:	01ad      	mov.n	a10, a1
40375770:	fb7b81        	l32r	a8, 4037455c <_iram_text_start+0x158> (40000dbc <wdt_hal_init>)
40375773:	0008e0        	callx8	a8
    uint32_t stage_timeout_ticks = (uint32_t)(1000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
40375776:	032ba5        	call8	40378a30 <rtc_clk_slow_freq_get_hz>
40375779:	060c      	movi.n	a6, 0
4037577b:	e8a3c2        	movi	a12, 0x3e8
4037577e:	a2bca0        	muluh	a11, a12, a10
40375781:	06dd      	mov.n	a13, a6
40375783:	82aca0        	mull	a10, a12, a10
40375786:	fb7681        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
40375789:	0008e0        	callx8	a8
4037578c:	0a7d      	mov.n	a7, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
4037578e:	01ad      	mov.n	a10, a1
40375790:	fb7581        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
40375793:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_SYSTEM);
40375796:	3d0c      	movi.n	a13, 3
40375798:	07cd      	mov.n	a12, a7
4037579a:	06bd      	mov.n	a11, a6
4037579c:	01ad      	mov.n	a10, a1
4037579e:	fb7281        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
403757a1:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE1, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
403757a4:	4d0c      	movi.n	a13, 4
403757a6:	07cd      	mov.n	a12, a7
403757a8:	1b0c      	movi.n	a11, 1
403757aa:	01ad      	mov.n	a10, a1
403757ac:	fb6f81        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
403757af:	0008e0        	callx8	a8
    //Enable flash boot mode so that flash booting after restart is protected by the RTC WDT.
    wdt_hal_set_flashboot_en(&rtc_wdt_ctx, true);
403757b2:	1b0c      	movi.n	a11, 1
403757b4:	01ad      	mov.n	a10, a1
403757b6:	fb6d81        	l32r	a8, 4037456c <_iram_text_start+0x168> (40000e28 <wdt_hal_set_flashboot_en>)
403757b9:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
403757bc:	01ad      	mov.n	a10, a1
403757be:	fb6c81        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
403757c1:	0008e0        	callx8	a8

    // Disable TG0/TG1 watchdogs
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
403757c4:	fb5d81        	l32r	a8, 40374538 <_iram_text_start+0x134> (3c026ea4 <__func__$0+0x1c>)
403757c7:	718b      	addi.n	a7, a1, 8
403757c9:	0898      	l32i.n	a9, a8, 0
403757cb:	1888      	l32i.n	a8, a8, 4
403757cd:	2199      	s32i.n	a9, a1, 8
403757cf:	3189      	s32i.n	a8, a1, 12
    wdt_hal_write_protect_disable(&wdt0_context);
403757d1:	07ad      	mov.n	a10, a7
403757d3:	fb6481        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
403757d6:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
403757d9:	07ad      	mov.n	a10, a7
403757db:	fb6681        	l32r	a8, 40374574 <_iram_text_start+0x170> (40000e04 <wdt_hal_disable>)
403757de:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
403757e1:	07ad      	mov.n	a10, a7
403757e3:	fb6381        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
403757e6:	0008e0        	callx8	a8

    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
403757e9:	fb5481        	l32r	a8, 4037453c <_iram_text_start+0x138> (3c026eac <__func__$0+0x24>)
403757ec:	10c172        	addi	a7, a1, 16
403757ef:	0898      	l32i.n	a9, a8, 0
403757f1:	1888      	l32i.n	a8, a8, 4
403757f3:	4199      	s32i.n	a9, a1, 16
403757f5:	5189      	s32i.n	a8, a1, 20
    wdt_hal_write_protect_disable(&wdt1_context);
403757f7:	07ad      	mov.n	a10, a7
403757f9:	fb5a81        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
403757fc:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
403757ff:	07ad      	mov.n	a10, a7
40375801:	fb5c81        	l32r	a8, 40374574 <_iram_text_start+0x170> (40000e04 <wdt_hal_disable>)
40375804:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
40375807:	07ad      	mov.n	a10, a7
40375809:	fb5981        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
4037580c:	0008e0        	callx8	a8
        SET_STACK(new_sp);
    }
#endif

    // Disable cache
    Cache_Disable_ICache();
4037580f:	fb5a81        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
40375812:	0008e0        	callx8	a8
    Cache_Disable_DCache();
40375815:	fb5981        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
40375818:	0008e0        	callx8	a8
4037581b:	03eb50        	rsr.prid	a5
4037581e:	045d50        	extui	a5, a5, 13, 1
    // CPU must be reset before stalling, in case it was running a s32c1i
    // instruction. This would cause memory pool to be locked by arbiter
    // to the stalled CPU, preventing current CPU from accessing this pool.
    const uint32_t core_id = esp_cpu_get_core_id();
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
40375821:	40f570        	nsau	a7, a5
40375824:	417570        	srli	a7, a7, 5
    esp_rom_software_reset_cpu(other_core_id);
40375827:	07ad      	mov.n	a10, a7
40375829:	fb5581        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
4037582c:	0008e0        	callx8	a8
    esp_cpu_stall(other_core_id);
4037582f:	07ad      	mov.n	a10, a7
40375831:	0298a5        	call8	403781bc <esp_cpu_stall>
#endif

    // 2nd stage bootloader reconfigures SPI flash signals.
    // Reset them to the defaults expected by ROM.
    WRITE_PERI_REG(GPIO_FUNC0_IN_SEL_CFG_REG, 0x30);
40375834:	083c      	movi.n	a8, 48
40375836:	fb4291        	l32r	a9, 40374540 <_iram_text_start+0x13c> (60004154 <GPIO+0x154>)
40375839:	0020c0        	memw
4037583c:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC1_IN_SEL_CFG_REG, 0x30);
4037583e:	fb4191        	l32r	a9, 40374544 <_iram_text_start+0x140> (60004158 <GPIO+0x158>)
40375841:	0020c0        	memw
40375844:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC2_IN_SEL_CFG_REG, 0x30);
40375846:	fb4091        	l32r	a9, 40374548 <_iram_text_start+0x144> (6000415c <GPIO+0x15c>)
40375849:	0020c0        	memw
4037584c:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC3_IN_SEL_CFG_REG, 0x30);
4037584e:	fb3f91        	l32r	a9, 4037454c <_iram_text_start+0x148> (60004160 <GPIO+0x160>)
40375851:	0020c0        	memw
40375854:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC4_IN_SEL_CFG_REG, 0x30);
40375856:	fb3e91        	l32r	a9, 40374550 <_iram_text_start+0x14c> (60004164 <GPIO+0x164>)
40375859:	0020c0        	memw
4037585c:	006982        	s32i	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC5_IN_SEL_CFG_REG, 0x30);
4037585f:	fb3d91        	l32r	a9, 40374554 <_iram_text_start+0x150> (60004168 <GPIO+0x168>)
40375862:	0020c0        	memw
40375865:	006982        	s32i	a8, a9, 0

    // reset necessary peripheral modules
    esp_system_reset_modules_on_exit();
40375868:	ffe2e5        	call8	40375698 <esp_system_reset_modules_on_exit>

    // Set CPU back to XTAL source, same as hard reset, but keep BBPLL on so that USB Serial JTAG can log at 1st stage bootloader.
#if !CONFIG_IDF_ENV_FPGA
    rtc_clk_cpu_set_to_default_config();
4037586b:	036965        	call8	40378f00 <rtc_clk_cpu_set_to_default_config>
#endif

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // Clear entry point for APP CPU
    REG_WRITE(SYSTEM_CORE_1_CONTROL_1_REG, 0);
4037586e:	fb3a81        	l32r	a8, 40374558 <_iram_text_start+0x154> (600c0004 <SYSTEM+0x4>)
40375871:	0020c0        	memw
40375874:	0869      	s32i.n	a6, a8, 0
#endif

    // Reset CPUs
    if (core_id == 0) {
40375876:	25dc      	bnez.n	a5, 4037588c <esp_restart_noos+0x12c>
        // Running on PRO CPU: APP CPU is stalled. Can reset both CPUs.
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
        esp_rom_software_reset_cpu(1);
40375878:	1a0c      	movi.n	a10, 1
4037587a:	fb4181        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
4037587d:	0008e0        	callx8	a8
#endif
        esp_rom_software_reset_cpu(0);
40375880:	0a0c      	movi.n	a10, 0
40375882:	fb3f81        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
40375885:	0008e0        	callx8	a8
40375888:	000606        	j	403758a4 <esp_restart_noos+0x144>
4037588b:	a0a200        	addx4	a10, a2, a0
    }
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    else {
        // Running on APP CPU: need to reset PRO CPU and unstall it,
        // then reset APP CPU
        esp_rom_software_reset_cpu(0);
4037588e:	3c8100        	lsi	f0, a1, 240
40375891:	e0fb      	addi.n	a14, a0, 15
40375893:	0008      	l32i.n	a0, a0, 0
        esp_cpu_unstall(0);
40375895:	00a0a2        	movi	a10, 0
40375898:	029a65        	call8	40378240 <esp_cpu_unstall>
        esp_rom_software_reset_cpu(1);
4037589b:	01a0a2        	movi	a10, 1
4037589e:	fb3881        	l32r	a8, 40374580 <_iram_text_start+0x17c> (400006e4 <esp_rom_software_reset_cpu>)
403758a1:	0008e0        	callx8	a8
    }
#endif

    ESP_INFINITE_LOOP();
403758a4:	ffff06        	j	403758a4 <esp_restart_noos+0x144>
	...

403758a8 <apb_backup_dma_unlock>:
        portENTER_CRITICAL(&s_apb_backup_dma_mutex);
    }
}

static void IRAM_ATTR apb_backup_dma_unlock(void)
{
403758a8:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403758ab:	048625        	call8	4037a10c <xPortInIsrContext>
403758ae:	aa8c      	beqz.n	a10, 403758bc <apb_backup_dma_unlock+0x14>
        portEXIT_CRITICAL_ISR(&s_apb_backup_dma_mutex);
403758b0:	fb35a1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc91f00 <s_apb_backup_dma_mutex>)
403758b3:	049ce5        	call8	4037a280 <vPortExitCritical>
403758b6:	000206        	j	403758c2 <apb_backup_dma_unlock+0x1a>
403758b9:	000000        	ill
    } else {
        portEXIT_CRITICAL(&s_apb_backup_dma_mutex);
403758bc:	fb32a1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc91f00 <s_apb_backup_dma_mutex>)
403758bf:	049c25        	call8	4037a280 <vPortExitCritical>
    }
}
403758c2:	f01d      	retw.n

403758c4 <apb_backup_dma_lock>:
{
403758c4:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403758c7:	048465        	call8	4037a10c <xPortInIsrContext>
403758ca:	00ba16        	beqz	a10, 403758d9 <apb_backup_dma_lock+0x15>

// ------------------ Critical Sections --------------------

static inline void __attribute__((always_inline)) vPortEnterCritical(portMUX_TYPE *mux)
{
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403758cd:	fb7c      	movi.n	a11, -1
403758cf:	fb2da1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc91f00 <s_apb_backup_dma_mutex>)
403758d2:	0485e5        	call8	4037a130 <xPortEnterCriticalTimeout>
}
403758d5:	000206        	j	403758e1 <apb_backup_dma_lock+0x1d>
403758d8:	fb7c00        	f64addc	a0, a12, 3, 1
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403758db:	fb2aa1        	l32r	a10, 40374584 <_iram_text_start+0x180> (3fc91f00 <s_apb_backup_dma_mutex>)
403758de:	048525        	call8	4037a130 <xPortEnterCriticalTimeout>
}
403758e1:	f01d      	retw.n
	...

403758e4 <tick_hook>:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
volatile bool int_wdt_cpu1_ticked = false;
#endif

static void IRAM_ATTR tick_hook(void)
{
403758e4:	004136        	entry	a1, 32
403758e7:	03eb80        	rsr.prid	a8
403758ea:	048d80        	extui	a8, a8, 13, 1
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    if (esp_cpu_get_core_id() != 0) {
403758ed:	c88c      	beqz.n	a8, 403758fd <tick_hook+0x19>
        int_wdt_cpu1_ticked = true;
403758ef:	fb0481        	l32r	a8, 40374500 <_iram_text_start+0xfc> (3fc9489c <int_wdt_cpu1_ticked>)
403758f2:	190c      	movi.n	a9, 1
403758f4:	0020c0        	memw
403758f7:	004892        	s8i	a9, a8, 0
403758fa:	001586        	j	40375954 <tick_hook+0x70>
    } else {
        // Only feed wdt if app cpu also ticked.
        if (int_wdt_cpu1_ticked) {
403758fd:	fb0081        	l32r	a8, 40374500 <_iram_text_start+0xfc> (3fc9489c <int_wdt_cpu1_ticked>)
40375900:	0020c0        	memw
40375903:	000882        	l8ui	a8, a8, 0
40375906:	748080        	extui	a8, a8, 0, 8
40375909:	047816        	beqz	a8, 40375954 <tick_hook+0x70>
            // Todo: Check if there's a way to avoid reconfiguring the stages on each feed.
            wdt_hal_write_protect_disable(&iwdt_context);
4037590c:	fb1f71        	l32r	a7, 40374588 <_iram_text_start+0x184> (3fc948a0 <iwdt_context>)
4037590f:	20a770        	or	a10, a7, a7
40375912:	fb1481        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000de0 <wdt_hal_write_protect_disable>)
40375915:	0008e0        	callx8	a8
#if CONFIG_ESP32_ECO3_CACHE_LOCK_FIX
            _lx_intr_livelock_counter = 0;
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE0,
                                 CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US / (_lx_intr_livelock_max + 1), WDT_STAGE_ACTION_INT);                    // Set timeout before interrupt
#else
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);          // Set timeout before interrupt
40375918:	01a0d2        	movi	a13, 1
4037591b:	58a2c2        	movi	a12, 0x258
4037591e:	00a0b2        	movi	a11, 0
40375921:	20a770        	or	a10, a7, a7
40375924:	fb1181        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
40375927:	0008e0        	callx8	a8
#endif
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
4037592a:	3d0c      	movi.n	a13, 3
4037592c:	b0a4c2        	movi	a12, 0x4b0
4037592f:	1b0c      	movi.n	a11, 1
40375931:	07ad      	mov.n	a10, a7
40375933:	fb0d81        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000dd4 <wdt_hal_config_stage>)
40375936:	0008e0        	callx8	a8
            wdt_hal_feed(&iwdt_context);
40375939:	07ad      	mov.n	a10, a7
4037593b:	fb1481        	l32r	a8, 4037458c <_iram_text_start+0x188> (40000e1c <wdt_hal_feed>)
4037593e:	0008e0        	callx8	a8
            wdt_hal_write_protect_enable(&iwdt_context);
40375941:	07ad      	mov.n	a10, a7
40375943:	fb0b81        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000dec <wdt_hal_write_protect_enable>)
40375946:	0008e0        	callx8	a8
            int_wdt_cpu1_ticked = false;
40375949:	faed81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (3fc9489c <int_wdt_cpu1_ticked>)
4037594c:	090c      	movi.n	a9, 0
4037594e:	0020c0        	memw
40375951:	004892        	s8i	a9, a8, 0
        wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
        wdt_hal_feed(&iwdt_context);
        wdt_hal_write_protect_enable(&iwdt_context);
    }
#endif // CONFIG_ESP_INT_WDT_CHECK_CPU1
}
40375954:	f01d      	retw.n
	...

40375958 <panic_abort>:
#endif /* CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT || CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT */
#endif /* CONFIG_ESP_SYSTEM_PANIC_GDBSTUB */
}

void IRAM_ATTR __attribute__((noreturn, no_sanitize_undefined)) panic_abort(const char *details)
{
40375958:	004136        	entry	a1, 32
    g_panic_abort = true;
4037595b:	fb0d81        	l32r	a8, 40374590 <_iram_text_start+0x18c> (3fc948b0 <g_panic_abort>)
4037595e:	190c      	movi.n	a9, 1
40375960:	004892        	s8i	a9, a8, 0
    g_panic_abort_details = (char *) details;
40375963:	fb0c81        	l32r	a8, 40374594 <_iram_text_start+0x190> (3fc948ac <g_panic_abort_details>)
40375966:	0829      	s32i.n	a2, a8, 0
                              APPTRACE_ONPANIC_HOST_FLUSH_TMO);
#endif
#endif

#ifdef __XTENSA__
    asm("ill");     // should be an invalid operation on xtensa targets
40375968:	000000        	ill
#elif __riscv
    asm("unimp");   // should be an invalid operation on RISC-V targets
#endif

    ESP_INFINITE_LOOP();
4037596b:	ffff06        	j	4037596b <panic_abort+0x13>
	...

40375970 <start_cpu_other_cores>:

/* This function has to be in IRAM, as while it is running on CPU1, CPU0 may do some flash operations
 * (e.g. initialize the core dump), which means that cache will be disabled.
 */
static void IRAM_ATTR start_cpu_other_cores_default(void)
{
40375970:	004136        	entry	a1, 32
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_SECONDARY);
40375973:	01a0a2        	movi	a10, 1
40375976:	fb0981        	l32r	a8, 4037459c <_iram_text_start+0x198> (42001f6c <do_system_init_fn>)
40375979:	0008e0        	callx8	a8

    while (!s_system_full_inited) {
4037597c:	000206        	j	40375988 <start_cpu_other_cores+0x18>
        esp_rom_delay_us(100);
4037597f:	64a0a2        	movi	a10, 100
40375982:	faac81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40375985:	0008e0        	callx8	a8
    while (!s_system_full_inited) {
40375988:	fb0481        	l32r	a8, 40374598 <_iram_text_start+0x194> (3fc948b1 <s_system_full_inited>)
4037598b:	0020c0        	memw
4037598e:	000882        	l8ui	a8, a8, 0
40375991:	748080        	extui	a8, a8, 0, 8
40375994:	fe7816        	beqz	a8, 4037597f <start_cpu_other_cores+0xf>
    }

    esp_startup_start_app_other_cores();
40375997:	fb0281        	l32r	a8, 403745a0 <_iram_text_start+0x19c> (42015c30 <esp_startup_start_app_other_cores>)
4037599a:	0008e0        	callx8	a8
4037599d:	000000        	ill

403759a0 <panic_enable_cache>:
 * This function must always be in IRAM as it is required to
 * re-enable the flash cache.
 */
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
static void IRAM_ATTR panic_enable_cache(void)
{
403759a0:	004136        	entry	a1, 32
403759a3:	03eb70        	rsr.prid	a7
403759a6:	047d70        	extui	a7, a7, 13, 1
    int core_id = esp_cpu_get_core_id();
    if (!spi_flash_cache_enabled()) {
403759a9:	020b25        	call8	40377a5c <spi_flash_cache_enabled>
403759ac:	008a56        	bnez	a10, 403759b8 <panic_enable_cache+0x18>
        esp_ipc_isr_stall_abort();
403759af:	0003a5        	call8	403759e8 <esp_ipc_isr_stall_abort>
        spi_flash_enable_cache(core_id);
403759b2:	20a770        	or	a10, a7, a7
403759b5:	020965        	call8	40377a4c <spi_flash_enable_cache>
    }

#if SOC_CACHE_ACS_INVALID_STATE_ON_PANIC
    // Some errors need to be cleared here to allow cache to operate normally again
    // for certain circumstances.
    esp_cache_err_acs_save_and_clr();
403759b8:	fafb81        	l32r	a8, 403745a4 <_iram_text_start+0x1a0> (420018f0 <esp_cache_err_acs_save_and_clr>)
403759bb:	0008e0        	callx8	a8
#endif //SOC_CACHE_ACS_INVALID_STATE_ON_PANIC
}
403759be:	f01d      	retw.n

403759c0 <panicHandler>:
#endif

void IRAM_ATTR panicHandler(void *frame)
{
403759c0:	004136        	entry	a1, 32
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    panic_enable_cache();
403759c3:	fffde5        	call8	403759a0 <panic_enable_cache>
#endif
    // This panic handler gets called for when the double exception vector,
    // kernel exception vector gets used; as well as handling interrupt-based
    // faults cache error, wdt expiry. EXCAUSE register gets written with
    // one of PANIC_RSN_* values.
    panic_handler(frame, true);
403759c6:	1b0c      	movi.n	a11, 1
403759c8:	02ad      	mov.n	a10, a2
403759ca:	faf781        	l32r	a8, 403745a8 <_iram_text_start+0x1a4> (420020a8 <panic_handler>)
403759cd:	0008e0        	callx8	a8
}
403759d0:	f01d      	retw.n
	...

403759d4 <xt_unhandled_exception>:

void IRAM_ATTR xt_unhandled_exception(void *frame)
{
403759d4:	004136        	entry	a1, 32
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    panic_enable_cache();
403759d7:	fffca5        	call8	403759a0 <panic_enable_cache>
#endif
    panic_handler(frame, false);
403759da:	0b0c      	movi.n	a11, 0
403759dc:	02ad      	mov.n	a10, a2
403759de:	faf281        	l32r	a8, 403745a8 <_iram_text_start+0x1a4> (420020a8 <panic_handler>)
403759e1:	0008e0        	callx8	a8
}
403759e4:	f01d      	retw.n
	...

403759e8 <esp_ipc_isr_stall_abort>:
    s_stall_state = STALL_STATE_IDLE;
    IPC_ISR_EXIT_CRITICAL();
}

void IRAM_ATTR esp_ipc_isr_stall_abort(void)
{
403759e8:	004136        	entry	a1, 32
    //Note: We don't enter a critical section here as we are calling this from a panic.
    s_stall_state = STALL_STATE_IDLE;
403759eb:	faf081        	l32r	a8, 403745ac <_iram_text_start+0x1a8> (3fc948c8 <s_stall_state>)
403759ee:	090c      	movi.n	a9, 0
403759f0:	0020c0        	memw
403759f3:	0899      	s32i.n	a9, a8, 0
}
403759f5:	f01d      	retw.n
	...

403759f8 <esp_ipc_isr_handler>:
       allows one cpu to enter in the IPC_ISR section of the LX
       interrupt at one time, there's no need to have two
       _lx_intr_stack for each cpu */

    /* Save A0, A2, A3, A4 so we can use those registers further*/
    movi    a0, _lx_intr_stack
403759f8:	faee01        	l32r	a0, 403745b0 <_iram_text_start+0x1ac> (3fc91f1c <_lx_intr_stack>)
    s32i    a2, a0, LX_INTR_A2_OFFSET
403759fb:	1029      	s32i.n	a2, a0, 4
    s32i    a3, a0, LX_INTR_A3_OFFSET
403759fd:	2039      	s32i.n	a3, a0, 8
    s32i    a4, a0, LX_INTR_A4_OFFSET
403759ff:	3049      	s32i.n	a4, a0, 12
    rsr     a2, EXCSAVE_X
40375a01:	03d420        	rsr.excsave4	a2
    s32i    a2, a0, LX_INTR_A0_OFFSET
40375a04:	0029      	s32i.n	a2, a0, 0

    /* disable nested iterrupts */
    /* PS.EXCM is changed from 1 to 0 . It allows using usually exception handler instead of the Double exception handler. */
    /* PS_UM = 1 */
    movi    a0, PS_INTLEVEL(5) | PS_UM
40375a06:	502c      	movi.n	a0, 37
    wsr     a0, PS
40375a08:	13e600        	wsr.ps	a0
    rsync
40375a0b:	002010        	rsync
#if CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5
    /* This int is level-triggered and doesn't need clearing.
       Do nothing here and clear int status by peripheral register later.*/
#elif CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4
    /* This int is edge-triggered and needs clearing. */
    movi    a3, (1 << ETS_IPC_ISR_INUM)
40375a0e:	fae931        	l32r	a3, 403745b4 <_iram_text_start+0x1b0> (10000000 <UserFrameTotalSize+0xfffff00>)
    wsr     a3, INTCLEAR
40375a11:	13e330        	wsr.intclear	a3
#endif /* CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5 */

    /* get CORE_ID */
    getcoreid   a3
40375a14:	03eb30        	rsr.prid	a3
40375a17:	043d30        	extui	a3, a3, 13, 1
    beqz    a3, 1f
40375a1a:	a38c      	beqz.n	a3, 40375a28 <esp_ipc_isr_handler+0x30>

    /* current cpu is 1 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_3_REG
40375a1c:	fae731        	l32r	a3, 403745b8 <_iram_text_start+0x1b4> (600c003c <SYSTEM+0x3c>)
    movi    a4, 0
40375a1f:	040c      	movi.n	a4, 0
    s32i    a4, a3, 0   /* clear intr */
40375a21:	0349      	s32i.n	a4, a3, 0
    j       2f
40375a23:	000206        	j	40375a2f <esp_ipc_isr_handler+0x37>
40375a26:	310000        	srai	a0, a0, 16
1:
    /* current cpu is 0 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_2_REG
40375a29:	0cfae5        	call8	403829d8 <_coredump_iram_end+0xad8>
    movi    a4, 0
40375a2c:	034904        	lsi	f0, a9, 12
    s32i    a4, a3, 0   /* clear intr */
2:

    /* set the start flag */
    movi    a0, esp_ipc_isr_start_fl
40375a2f:	fae401        	l32r	a0, 403745c0 <_iram_text_start+0x1bc> (3fc948d4 <esp_ipc_isr_start_fl>)
    memw
40375a32:	0020c0        	memw
    s32i    a0, a0, 0
40375a35:	0009      	s32i.n	a0, a0, 0

    /* Call the esp_ipc_function(void* arg) */
    movi    a0, esp_ipc_func
40375a37:	fae301        	l32r	a0, 403745c4 <_iram_text_start+0x1c0> (3fc948d0 <esp_ipc_func>)
    l32i    a0, a0, 0
40375a3a:	0008      	l32i.n	a0, a0, 0
    movi    a2, esp_ipc_func_arg
40375a3c:	fae321        	l32r	a2, 403745c8 <_iram_text_start+0x1c4> (3fc948cc <esp_ipc_func_arg>)
    l32i    a2, a2, 0
40375a3f:	0228      	l32i.n	a2, a2, 0
    callx0  a0
40375a41:	0000c0        	callx0	a0

    /* Done. Restore registers and return. */
    movi    a0, _lx_intr_stack
40375a44:	fadb01        	l32r	a0, 403745b0 <_iram_text_start+0x1ac> (3fc91f1c <_lx_intr_stack>)
    l32i    a2, a0, LX_INTR_A2_OFFSET
40375a47:	1028      	l32i.n	a2, a0, 4
    l32i    a3, a0, LX_INTR_A3_OFFSET
40375a49:	2038      	l32i.n	a3, a0, 8
    l32i    a4, a0, LX_INTR_A4_OFFSET
40375a4b:	3048      	l32i.n	a4, a0, 12

    /* set the end flag */
    movi    a0, esp_ipc_isr_end_fl
40375a4d:	fadf01        	l32r	a0, 403745cc <_iram_text_start+0x1c8> (3fc91f18 <esp_ipc_isr_end_fl>)
    memw
40375a50:	0020c0        	memw
    s32i    a0, a0, 0
40375a53:	0009      	s32i.n	a0, a0, 0

    /* restore a0 */
    rsr     a0, EXCSAVE_X
40375a55:	03d400        	rsr.excsave4	a0
    /* restores PS from EPS[X] and jumps to the address in EPC[X] */
    rfi     RFI_X
40375a58:	003410        	rfi	4
	...

40375a5c <print_entry>:
    //Return true if both sp and pc of frame(i-1) are sane, false otherwise
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
}

static void IRAM_ATTR print_entry(uint32_t pc, uint32_t sp, bool panic)
{
40375a5c:	004136        	entry	a1, 32
    if (panic) {
40375a5f:	54ac      	beqz.n	a4, 40375a88 <print_entry+0x2c>
        panic_print_str(" 0x");
40375a61:	fadba1        	l32r	a10, 403745d0 <_iram_text_start+0x1cc> (3c0209c8 <_flash_rodata_start+0x8a8>)
40375a64:	fade81        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (42001c88 <panic_print_str>)
40375a67:	0008e0        	callx8	a8
        panic_print_hex(pc);
40375a6a:	02ad      	mov.n	a10, a2
40375a6c:	fadd81        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (42001cb4 <panic_print_hex>)
40375a6f:	0008e0        	callx8	a8
        panic_print_str(":0x");
40375a72:	fad8a1        	l32r	a10, 403745d4 <_iram_text_start+0x1d0> (3c020e64 <_flash_rodata_start+0xd44>)
40375a75:	fad981        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (42001c88 <panic_print_str>)
40375a78:	0008e0        	callx8	a8
        panic_print_hex(sp);
40375a7b:	20a330        	or	a10, a3, a3
40375a7e:	fad881        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (42001cb4 <panic_print_hex>)
40375a81:	0008e0        	callx8	a8
40375a84:	000346        	j	40375a95 <print_entry+0x39>
40375a87:	03cd00        	lsi	f0, a13, 12
    } else {
        esp_rom_printf(" 0x%08" PRIX32 ":0x%08" PRIX32, pc, sp);
40375a8a:	02bd      	mov.n	a11, a2
40375a8c:	fad3a1        	l32r	a10, 403745d8 <_iram_text_start+0x1d4> (3c020e68 <_flash_rodata_start+0xd48>)
40375a8f:	fa8981        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375a92:	0008e0        	callx8	a8
    }
}
40375a95:	f01d      	retw.n
	...

40375a98 <print_str>:

static void IRAM_ATTR print_str(const char* str, bool panic)
{
40375a98:	004136        	entry	a1, 32
40375a9b:	02ad      	mov.n	a10, a2
    if (panic) {
40375a9d:	738c      	beqz.n	a3, 40375aa8 <print_str+0x10>
        panic_print_str(str);
40375a9f:	facf81        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (42001c88 <panic_print_str>)
40375aa2:	0008e0        	callx8	a8
40375aa5:	000146        	j	40375aae <print_str+0x16>
    } else {
        esp_rom_printf(str);
40375aa8:	fa8381        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40375aab:	0008e0        	callx8	a8
    }
}
40375aae:	f01d      	retw.n

40375ab0 <esp_backtrace_get_next_frame>:
{
40375ab0:	004136        	entry	a1, 32
    void *base_save = (void *)frame->sp;     //Base save area consists of 4 words under SP
40375ab3:	1288      	l32i.n	a8, a2, 4
    frame->pc = frame->next_pc;
40375ab5:	22a8      	l32i.n	a10, a2, 8
40375ab7:	02a9      	s32i.n	a10, a2, 0
    frame->next_pc = *((uint32_t *)(base_save - 16));     //If next_pc = 0, indicates frame(i-1) is the last frame on the stack
40375ab9:	f0c892        	addi	a9, a8, -16
40375abc:	0998      	l32i.n	a9, a9, 0
40375abe:	2299      	s32i.n	a9, a2, 8
    frame->sp =  *((uint32_t *)(base_save - 12));
40375ac0:	f4c882        	addi	a8, a8, -12
40375ac3:	0888      	l32i.n	a8, a8, 0
40375ac5:	1289      	s32i.n	a8, a2, 4
 */
__attribute__((always_inline))
inline static bool esp_stack_ptr_in_dram(uint32_t sp)
{
    //Check if stack ptr is in between SOC_DRAM_LOW and SOC_DRAM_HIGH, and 16 byte aligned.
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375ac7:	fac791        	l32r	a9, 403745e4 <_iram_text_start+0x1e0> (c0377ff0 <_rtc_reserved_end+0x60277ff0>)
40375aca:	809890        	add	a9, a8, a9
40375acd:	fac6b1        	l32r	a11, 403745e8 <_iram_text_start+0x1e4> (77fe0 <UserFrameTotalSize+0x77ee0>)
40375ad0:	053b97        	bltu	a11, a9, 40375ad9 <esp_backtrace_get_next_frame+0x29>
40375ad3:	349080        	extui	a9, a8, 0, 4
40375ad6:	00b916        	beqz	a9, 40375ae5 <esp_backtrace_get_next_frame+0x35>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40375ad9:	fac491        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40375adc:	808890        	add	a8, a8, a9
    return esp_stack_ptr_in_dram(sp)
#if CONFIG_FREERTOS_TASK_CREATE_ALLOW_EXT_MEM
        || esp_stack_ptr_in_extram(sp)
#endif
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375adf:	fac491        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375ae2:	543987        	bltu	a9, a8, 40375b3a <esp_backtrace_get_next_frame+0x8a>
 * @param pc PC value of the current backtrace frame
 *
 */
static inline uint32_t esp_cpu_process_stack_pc(uint32_t pc)
{
    if (pc & 0x80000000) {
40375ae5:	00bad6        	bgez	a10, 40375af4 <esp_backtrace_get_next_frame+0x44>
        //Top two bits of a0 (return address) specify window increment. Overwrite to map to address space.
        pc = (pc & 0x3fffffff) | 0x40000000;
40375ae8:	11aae0        	slli	a10, a10, 2
40375aeb:	41a2a0        	srli	a10, a10, 2
40375aee:	fac181        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375af1:	20aa80        	or	a10, a10, a8
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40375af4:	fac191        	l32r	a9, 403745f8 <_iram_text_start+0x1f4> (bdfffffd <_rtc_reserved_end+0x5deffffd>)
40375af7:	9a9a      	add.n	a9, a10, a9
40375af9:	fac081        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
40375afc:	628890        	lsi	f9, a8, 0x188
40375aff:	880b      	addi.n	a8, a8, -1
40375b01:	608080        	neg	a8, a8
40375b04:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40375b07:	fabeb1        	l32r	a11, 40374600 <_iram_text_start+0x1fc> (bfc8fffd <_rtc_reserved_end+0x5fb8fffd>)
40375b0a:	baba      	add.n	a11, a10, a11
40375b0c:	fabe91        	l32r	a9, 40374604 <_iram_text_start+0x200> (6ffff <UserFrameTotalSize+0x6feff>)
40375b0f:	6299b0        	lsi	f11, a9, 0x188
40375b12:	990b      	addi.n	a9, a9, -1
40375b14:	609090        	neg	a9, a9
40375b17:	749090        	extui	a9, a9, 0, 8
40375b1a:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375b1d:	f8dc      	bnez.n	a8, 40375b40 <esp_backtrace_get_next_frame+0x90>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40375b1f:	faba81        	l32r	a8, 40374608 <_iram_text_start+0x204> (bffffffd <_rtc_reserved_end+0x5feffffd>)
40375b22:	8a8a      	add.n	a8, a10, a8
40375b24:	faba91        	l32r	a9, 4037460c <_iram_text_start+0x208> (5ffff <UserFrameTotalSize+0x5feff>)
40375b27:	1ab987        	bgeu	a9, a8, 40375b45 <esp_backtrace_get_next_frame+0x95>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375b2a:	fab981        	l32r	a8, 40374610 <_iram_text_start+0x20c> (9ff01ffd <_rtc_reserved_end+0x3fe01ffd>)
40375b2d:	aa8a      	add.n	a10, a10, a8
40375b2f:	fab081        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375b32:	1438a7        	bltu	a8, a10, 40375b4a <esp_backtrace_get_next_frame+0x9a>
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
40375b35:	120c      	movi.n	a2, 1
40375b37:	000446        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b3a:	020c      	movi.n	a2, 0
40375b3c:	000306        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b3f:	120c00        	andbc	b0, b12, b0
40375b42:	000186        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b45:	120c      	movi.n	a2, 1
40375b47:	000046        	j	40375b4c <esp_backtrace_get_next_frame+0x9c>
40375b4a:	020c      	movi.n	a2, 0
}
40375b4c:	f01d      	retw.n
	...

40375b50 <esp_backtrace_print_from_frame>:

esp_err_t IRAM_ATTR esp_backtrace_print_from_frame(int depth, const esp_backtrace_frame_t* frame, bool panic)
{
40375b50:	006136        	entry	a1, 48
40375b53:	20b330        	or	a11, a3, a3
40375b56:	744040        	extui	a4, a4, 0, 8
    //Check arguments
    if (depth <= 0) {
40375b59:	0212e6        	bgei	a2, 1, 40375b5f <esp_backtrace_print_from_frame+0xf>
40375b5c:	004e46        	j	40375c99 <esp_backtrace_print_from_frame+0x149>
        return ESP_ERR_INVALID_ARG;
    }

    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t stk_frame;
    memcpy(&stk_frame, frame, sizeof(esp_backtrace_frame_t));
40375b5f:	10a0c2        	movi	a12, 16
40375b62:	20a110        	or	a10, a1, a1
40375b65:	fa5b81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375b68:	0008e0        	callx8	a8

    print_str("\r\n\r\nBacktrace:", panic);
40375b6b:	04bd      	mov.n	a11, a4
40375b6d:	faa9a1        	l32r	a10, 40374614 <_iram_text_start+0x210> (3c020e7c <_flash_rodata_start+0xd5c>)
40375b70:	fff265        	call8	40375a98 <print_str>
    print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
40375b73:	01a8      	l32i.n	a10, a1, 0
    if (pc & 0x80000000) {
40375b75:	00bad6        	bgez	a10, 40375b84 <esp_backtrace_print_from_frame+0x34>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375b78:	11aae0        	slli	a10, a10, 2
40375b7b:	41a2a0        	srli	a10, a10, 2
40375b7e:	fa9d81        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375b81:	20aa80        	or	a10, a10, a8
40375b84:	04cd      	mov.n	a12, a4
40375b86:	11b8      	l32i.n	a11, a1, 4
40375b88:	fdcaa2        	addi	a10, a10, -3
40375b8b:	ffed25        	call8	40375a5c <print_entry>

    //Check if first frame is valid
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375b8e:	1188      	l32i.n	a8, a1, 4
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375b90:	fa9591        	l32r	a9, 403745e4 <_iram_text_start+0x1e0> (c0377ff0 <_rtc_reserved_end+0x60277ff0>)
40375b93:	989a      	add.n	a9, a8, a9
40375b95:	fa94a1        	l32r	a10, 403745e8 <_iram_text_start+0x1e4> (77fe0 <UserFrameTotalSize+0x77ee0>)
40375b98:	053a97        	bltu	a10, a9, 40375ba1 <esp_backtrace_print_from_frame+0x51>
40375b9b:	349080        	extui	a9, a8, 0, 4
40375b9e:	00a916        	beqz	a9, 40375bac <esp_backtrace_print_from_frame+0x5c>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40375ba1:	fa9291        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40375ba4:	889a      	add.n	a8, a8, a9
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375ba6:	fa9291        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375ba9:	623987        	bltu	a9, a8, 40375c0f <esp_backtrace_print_from_frame+0xbf>
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
40375bac:	01a8      	l32i.n	a10, a1, 0
    if (pc & 0x80000000) {
40375bae:	00bad6        	bgez	a10, 40375bbd <esp_backtrace_print_from_frame+0x6d>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375bb1:	11aae0        	slli	a10, a10, 2
40375bb4:	41a2a0        	srli	a10, a10, 2
40375bb7:	fa8f81        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375bba:	20aa80        	or	a10, a10, a8
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40375bbd:	fa8e91        	l32r	a9, 403745f8 <_iram_text_start+0x1f4> (bdfffffd <_rtc_reserved_end+0x5deffffd>)
40375bc0:	9a9a      	add.n	a9, a10, a9
40375bc2:	fa8e81        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
40375bc5:	628890        	lsi	f9, a8, 0x188
40375bc8:	880b      	addi.n	a8, a8, -1
40375bca:	608080        	neg	a8, a8
40375bcd:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40375bd0:	fa8cb1        	l32r	a11, 40374600 <_iram_text_start+0x1fc> (bfc8fffd <_rtc_reserved_end+0x5fb8fffd>)
40375bd3:	baba      	add.n	a11, a10, a11
40375bd5:	fa8b91        	l32r	a9, 40374604 <_iram_text_start+0x200> (6ffff <UserFrameTotalSize+0x6feff>)
40375bd8:	6299b0        	lsi	f11, a9, 0x188
40375bdb:	990b      	addi.n	a9, a9, -1
40375bdd:	609090        	neg	a9, a9
40375be0:	749090        	extui	a9, a9, 0, 8
40375be3:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375be6:	a8ec      	bnez.n	a8, 40375c14 <esp_backtrace_print_from_frame+0xc4>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40375be8:	fa8881        	l32r	a8, 40374608 <_iram_text_start+0x204> (bffffffd <_rtc_reserved_end+0x5feffffd>)
40375beb:	8a8a      	add.n	a8, a10, a8
40375bed:	fa8791        	l32r	a9, 4037460c <_iram_text_start+0x208> (5ffff <UserFrameTotalSize+0x5feff>)
40375bf0:	25b987        	bgeu	a9, a8, 40375c19 <esp_backtrace_print_from_frame+0xc9>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375bf3:	fa8781        	l32r	a8, 40374610 <_iram_text_start+0x20c> (9ff01ffd <_rtc_reserved_end+0x3fe01ffd>)
40375bf6:	aa8a      	add.n	a10, a10, a8
40375bf8:	fa7e81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40375bfb:	1fb8a7        	bgeu	a8, a10, 40375c1e <esp_backtrace_print_from_frame+0xce>
                        /* Ignore the first corrupted PC in case of InstrFetchProhibited */
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375bfe:	3188      	l32i.n	a8, a1, 12
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
40375c00:	08ac      	beqz.n	a8, 40375c24 <esp_backtrace_print_from_frame+0xd4>
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375c02:	142892        	l32i	a9, a8, 80
40375c05:	481c      	movi.n	a8, 20
40375c07:	1e9987        	bne	a9, a8, 40375c29 <esp_backtrace_print_from_frame+0xd9>
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375c0a:	070c      	movi.n	a7, 0
40375c0c:	001246        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c0f:	170c      	movi.n	a7, 1
40375c11:	001106        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c14:	070c      	movi.n	a7, 0
40375c16:	000fc6        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c19:	070c      	movi.n	a7, 0
40375c1b:	000e86        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c1e:	070c      	movi.n	a7, 0
40375c20:	000d46        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c23:	170c00        	lsi	f0, a12, 92
40375c26:	000bc6        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
40375c29:	170c      	movi.n	a7, 1

    uint32_t i = (depth <= 0) ? INT32_MAX : depth;
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375c2b:	000a86        	j	40375c59 <esp_backtrace_print_from_frame+0x109>
        if (!esp_backtrace_get_next_frame(&stk_frame)) {    //Get previous stack frame
40375c2e:	20a110        	or	a10, a1, a1
40375c31:	ffe7e5        	call8	40375ab0 <esp_backtrace_get_next_frame>
40375c34:	002a56        	bnez	a10, 40375c3a <esp_backtrace_print_from_frame+0xea>
            corrupted = true;
40375c37:	01a072        	movi	a7, 1
        }
        print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
40375c3a:	0021a2        	l32i	a10, a1, 0
    if (pc & 0x80000000) {
40375c3d:	00bad6        	bgez	a10, 40375c4c <esp_backtrace_print_from_frame+0xfc>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375c40:	11aae0        	slli	a10, a10, 2
40375c43:	41a2a0        	srli	a10, a10, 2
40375c46:	fa6b81        	l32r	a8, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
40375c49:	20aa80        	or	a10, a10, a8
40375c4c:	20c440        	or	a12, a4, a4
40375c4f:	11b8      	l32i.n	a11, a1, 4
40375c51:	fdcaa2        	addi	a10, a10, -3
40375c54:	ffe065        	call8	40375a5c <print_entry>
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375c57:	062d      	mov.n	a2, a6
40375c59:	620b      	addi.n	a6, a2, -1
40375c5b:	528c      	beqz.n	a2, 40375c64 <esp_backtrace_print_from_frame+0x114>
40375c5d:	2188      	l32i.n	a8, a1, 8
40375c5f:	188c      	beqz.n	a8, 40375c64 <esp_backtrace_print_from_frame+0x114>
40375c61:	fc9716        	beqz	a7, 40375c2e <esp_backtrace_print_from_frame+0xde>
    }

    //Print backtrace termination marker
    esp_err_t ret = ESP_OK;
    if (corrupted) {
40375c64:	d78c      	beqz.n	a7, 40375c75 <esp_backtrace_print_from_frame+0x125>
        print_str(" |<-CORRUPTED", panic);
40375c66:	04bd      	mov.n	a11, a4
40375c68:	fa6ca1        	l32r	a10, 40374618 <_iram_text_start+0x214> (3c020e8c <_flash_rodata_start+0xd6c>)
40375c6b:	ffe2e5        	call8	40375a98 <print_str>
        ret =  ESP_FAIL;
40375c6e:	f27c      	movi.n	a2, -1
40375c70:	0005c6        	j	40375c8b <esp_backtrace_print_from_frame+0x13b>
40375c73:	820000        	mull	a0, a0, a0
    } else if (stk_frame.next_pc != 0) {    //Backtrace continues
40375c76:	160221        	l32r	a2, 4033b480 <rom_rx_gain_force+0x335054>
40375c79:	00d8      	l32i.n	a13, a0, 0
        print_str(" |<-CONTINUES", panic);
40375c7b:	20b440        	or	a11, a4, a4
40375c7e:	fa67a1        	l32r	a10, 4037461c <_iram_text_start+0x218> (3c020e9c <_flash_rodata_start+0xd7c>)
40375c81:	ffe165        	call8	40375a98 <print_str>
    esp_err_t ret = ESP_OK;
40375c84:	020c      	movi.n	a2, 0
40375c86:	000046        	j	40375c8b <esp_backtrace_print_from_frame+0x13b>
40375c89:	020c      	movi.n	a2, 0
    }
    print_str("\r\n\r\n", panic);
40375c8b:	04bd      	mov.n	a11, a4
40375c8d:	fa64a1        	l32r	a10, 40374620 <_iram_text_start+0x21c> (3c020eac <_flash_rodata_start+0xd8c>)
40375c90:	ffe065        	call8	40375a98 <print_str>
    return ret;
40375c93:	000146        	j	40375c9c <esp_backtrace_print_from_frame+0x14c>
40375c96:	000000        	ill
        return ESP_ERR_INVALID_ARG;
40375c99:	02a122        	movi	a2, 0x102
}
40375c9c:	f01d      	retw.n
	...

40375ca0 <esp_backtrace_print>:

esp_err_t IRAM_ATTR esp_backtrace_print(int depth)
{
40375ca0:	006136        	entry	a1, 48
    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t start = { 0 };
40375ca3:	10a0c2        	movi	a12, 16
40375ca6:	00a0b2        	movi	a11, 0
40375ca9:	20a110        	or	a10, a1, a1
40375cac:	f9f981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40375caf:	0008e0        	callx8	a8
    esp_backtrace_get_start(&(start.pc), &(start.sp), &(start.next_pc));
40375cb2:	c18b      	addi.n	a12, a1, 8
40375cb4:	b14b      	addi.n	a11, a1, 4
40375cb6:	01ad      	mov.n	a10, a1
40375cb8:	0000e5        	call8	40375cc8 <esp_backtrace_get_start>
    return esp_backtrace_print_from_frame(depth, &start, false);
40375cbb:	0c0c      	movi.n	a12, 0
40375cbd:	01bd      	mov.n	a11, a1
40375cbf:	02ad      	mov.n	a10, a2
40375cc1:	ffe8e5        	call8	40375b50 <esp_backtrace_print_from_frame>
}
40375cc4:	0a2d      	mov.n	a2, a10
40375cc6:	f01d      	retw.n

40375cc8 <esp_backtrace_get_start>:
    .section    .iram1, "ax"
    .align      4
    .global     esp_backtrace_get_start
    .type       esp_backtrace_get_start, @function
esp_backtrace_get_start:
    entry   a1, 32
40375cc8:	004136        	entry	a1, 32
    call8   xthal_window_spill  //Spill registers onto stack (excluding this function)
40375ccb:	0bfc65        	call8	40381c90 <xthal_window_spill>
    //a2, a3, a4 should be out arguments for i SP, i PC, i-1 PC respectively. Use a5 and a6 as scratch
    l32e    a5, sp, -16         //Get i PC, which is ret addres of i+1
40375cce:	09c150        	l32e	a5, a1, -16
    s32i    a5, a2, 0           //Store i PC to arg *pc
40375cd1:	006252        	s32i	a5, a2, 0
    l32e    a6, sp, -12         //Get i+1 SP. Used to access i BS
40375cd4:	09d160        	l32e	a6, a1, -12
    l32e    a5, a6, -12         //Get i SP
40375cd7:	09d650        	l32e	a5, a6, -12
    s32i    a5, a3, 0           //Store i SP to arg *sp
40375cda:	006352        	s32i	a5, a3, 0
    l32e    a5, a6, -16         //Get i-1 PC, which is ret address of i
40375cdd:	09c650        	l32e	a5, a6, -16
    s32i    a5, a4, 0           //Store i-1 PC to arg *next_pc
40375ce0:	006452        	s32i	a5, a4, 0
    retw
40375ce3:	f01d      	retw.n
40375ce5:	000000        	ill

40375ce8 <ipc_task>:
static volatile esp_ipc_func_t s_no_block_func[portNUM_PROCESSORS] = { 0 };
static volatile bool s_no_block_func_and_arg_are_ready[portNUM_PROCESSORS] = { 0 };
static void * volatile s_no_block_func_arg[portNUM_PROCESSORS];

static void IRAM_ATTR ipc_task(void* arg)
{
40375ce8:	004136        	entry	a1, 32
40375ceb:	027d      	mov.n	a7, a2
40375ced:	03eb80        	rsr.prid	a8
40375cf0:	048d80        	extui	a8, a8, 13, 1
    const int cpuid = (int) arg;

    assert(cpuid == xPortGetCoreID());
40375cf3:	0d1287        	beq	a2, a8, 40375d04 <ipc_task+0x1c>
40375cf6:	fa4bd1        	l32r	a13, 40374624 <_iram_text_start+0x220> (3c020f20 <_flash_rodata_start+0xe00>)
40375cf9:	fa4bc1        	l32r	a12, 40374628 <_iram_text_start+0x224> (3c02705c <__func__$0>)
40375cfc:	8b3c      	movi.n	a11, 56
40375cfe:	fa4ba1        	l32r	a10, 4037462c <_iram_text_start+0x228> (3c020f58 <_flash_rodata_start+0xe38>)
40375d01:	0a04e5        	call8	4037fd50 <__assert_func>
#ifdef CONFIG_ESP_IPC_ISR_ENABLE
    esp_ipc_isr_init();
40375d04:	fa5281        	l32r	a8, 4037464c <_iram_text_start+0x248> (4200226c <esp_ipc_isr_init>)
40375d07:	0008e0        	callx8	a8
#endif

    while (true) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
40375d0a:	fc7c      	movi.n	a12, -1
40375d0c:	1b0c      	movi.n	a11, 1
40375d0e:	00a0a2        	movi	a10, 0
40375d11:	063aa5        	call8	4037c0bc <ulTaskGenericNotifyTake>

        if (s_no_block_func_and_arg_are_ready[cpuid] && s_no_block_func[cpuid]) {
40375d14:	fa4781        	l32r	a8, 40374630 <_iram_text_start+0x22c> (3fc948e0 <s_no_block_func_and_arg_are_ready>)
40375d17:	887a      	add.n	a8, a8, a7
40375d19:	0020c0        	memw
40375d1c:	000882        	l8ui	a8, a8, 0
40375d1f:	748080        	extui	a8, a8, 0, 8
40375d22:	b8bc      	beqz.n	a8, 40375d61 <ipc_task+0x79>
40375d24:	fa4481        	l32r	a8, 40374634 <_iram_text_start+0x230> (3fc948e4 <s_no_block_func>)
40375d27:	a08780        	addx4	a8, a7, a8
40375d2a:	0020c0        	memw
40375d2d:	0888      	l32i.n	a8, a8, 0
40375d2f:	02e816        	beqz	a8, 40375d61 <ipc_task+0x79>
            (*s_no_block_func[cpuid])(s_no_block_func_arg[cpuid]);
40375d32:	fa4061        	l32r	a6, 40374634 <_iram_text_start+0x230> (3fc948e4 <s_no_block_func>)
40375d35:	a06760        	addx4	a6, a7, a6
40375d38:	0020c0        	memw
40375d3b:	0698      	l32i.n	a9, a6, 0
40375d3d:	fa3e81        	l32r	a8, 40374638 <_iram_text_start+0x234> (3fc948d8 <s_no_block_func_arg>)
40375d40:	a08780        	addx4	a8, a7, a8
40375d43:	0020c0        	memw
40375d46:	0028a2        	l32i	a10, a8, 0
40375d49:	0009e0        	callx8	a9
            s_no_block_func_and_arg_are_ready[cpuid] = false;
40375d4c:	fa3981        	l32r	a8, 40374630 <_iram_text_start+0x22c> (3fc948e0 <s_no_block_func_and_arg_are_ready>)
40375d4f:	887a      	add.n	a8, a8, a7
40375d51:	090c      	movi.n	a9, 0
40375d53:	0020c0        	memw
40375d56:	004892        	s8i	a9, a8, 0
            s_no_block_func[cpuid] = NULL;
40375d59:	080c      	movi.n	a8, 0
40375d5b:	0020c0        	memw
40375d5e:	006682        	s32i	a8, a6, 0
        }

#ifndef CONFIG_FREERTOS_UNICORE
        if (s_func[cpuid]) {
40375d61:	fa3681        	l32r	a8, 4037463c <_iram_text_start+0x238> (3fc948fc <s_func>)
40375d64:	a08780        	addx4	a8, a7, a8
40375d67:	0020c0        	memw
40375d6a:	0888      	l32i.n	a8, a8, 0
40375d6c:	f9a816        	beqz	a8, 40375d0a <ipc_task+0x22>
            // we need to cache s_func, s_func_arg and ipc_ack variables locally
            // because they can be changed by a subsequent IPC call (after xTaskNotify(caller_task_handle)).
            esp_ipc_func_t func = s_func[cpuid];
40375d6f:	fa3381        	l32r	a8, 4037463c <_iram_text_start+0x238> (3fc948fc <s_func>)
40375d72:	a08780        	addx4	a8, a7, a8
40375d75:	0020c0        	memw
40375d78:	0868      	l32i.n	a6, a8, 0
            void* func_arg = s_func_arg[cpuid];
40375d7a:	fa3191        	l32r	a9, 40374640 <_iram_text_start+0x23c> (3fc948f4 <s_func_arg>)
40375d7d:	a09790        	addx4	a9, a7, a9
40375d80:	0020c0        	memw
40375d83:	0958      	l32i.n	a5, a9, 0
            esp_ipc_wait_t ipc_wait = s_wait_for[cpuid];
40375d85:	fa2f91        	l32r	a9, 40374644 <_iram_text_start+0x240> (3fc948ec <s_wait_for>)
40375d88:	a09790        	addx4	a9, a7, a9
40375d8b:	0020c0        	memw
40375d8e:	09a8      	l32i.n	a10, a9, 0
            SemaphoreHandle_t ipc_ack = s_ipc_ack[cpuid];
40375d90:	fa2e91        	l32r	a9, 40374648 <_iram_text_start+0x244> (3fc94904 <s_ipc_ack>)
40375d93:	a09790        	addx4	a9, a7, a9
40375d96:	0948      	l32i.n	a4, a9, 0
            s_func[cpuid] = NULL;
40375d98:	090c      	movi.n	a9, 0
40375d9a:	0020c0        	memw
40375d9d:	0899      	s32i.n	a9, a8, 0

            if (ipc_wait == IPC_WAIT_FOR_START) {
40375d9f:	121a66        	bnei	a10, 1, 40375db5 <ipc_task+0xcd>
                xSemaphoreGive(ipc_ack);
40375da2:	09dd      	mov.n	a13, a9
40375da4:	09cd      	mov.n	a12, a9
40375da6:	09bd      	mov.n	a11, a9
40375da8:	04ad      	mov.n	a10, a4
40375daa:	03d2e5        	call8	40379ad8 <xQueueGenericSend>
                (*func)(func_arg);
40375dad:	05ad      	mov.n	a10, a5
40375daf:	0006e0        	callx8	a6
40375db2:	ffd506        	j	40375d0a <ipc_task+0x22>
            } else if (ipc_wait == IPC_WAIT_FOR_END) {
40375db5:	132a66        	bnei	a10, 2, 40375dcc <ipc_task+0xe4>
                (*func)(func_arg);
40375db8:	05ad      	mov.n	a10, a5
40375dba:	0006e0        	callx8	a6
                xSemaphoreGive(ipc_ack);
40375dbd:	0d0c      	movi.n	a13, 0
40375dbf:	0dcd      	mov.n	a12, a13
40375dc1:	0dbd      	mov.n	a11, a13
40375dc3:	04ad      	mov.n	a10, a4
40375dc5:	03d125        	call8	40379ad8 <xQueueGenericSend>
40375dc8:	ffcf86        	j	40375d0a <ipc_task+0x22>
40375dcb:	ec6500        	lsi	f0, a5, 0x3b0
            } else {
                abort();
40375dce:	0009      	s32i.n	a0, a0, 0

40375dd0 <esp_vApplicationTickHook>:
static portMUX_TYPE hooks_spinlock = portMUX_INITIALIZER_UNLOCKED;
static esp_freertos_idle_cb_t idle_cb[CONFIG_FREERTOS_NUMBER_OF_CORES][MAX_HOOKS] = {0};
static esp_freertos_tick_cb_t tick_cb[CONFIG_FREERTOS_NUMBER_OF_CORES][MAX_HOOKS] = {0};

void IRAM_ATTR esp_vApplicationTickHook(void)
{
40375dd0:	004136        	entry	a1, 32
40375dd3:	03eb60        	rsr.prid	a6
40375dd6:	046d60        	extui	a6, a6, 13, 1
    int n;
    int core = xPortGetCoreID();
    for (n = 0; n < MAX_HOOKS; n++) {
40375dd9:	070c      	movi.n	a7, 0
40375ddb:	0004c6        	j	40375df2 <esp_vApplicationTickHook+0x22>
40375dde:	700000        	lsi	f0, a0, 0x1c0
        if (tick_cb[core][n] != NULL) {
40375de1:	91b086        	j	4035a4a7 <rom_rx_gain_force+0x35407b>
40375de4:	fa1b      	addi.n	a15, a10, 1
40375de6:	a08890        	addx4	a8, a8, a9
40375de9:	0888      	l32i.n	a8, a8, 0
40375deb:	188c      	beqz.n	a8, 40375df0 <esp_vApplicationTickHook+0x20>
            tick_cb[core][n]();
40375ded:	0008e0        	callx8	a8
    for (n = 0; n < MAX_HOOKS; n++) {
40375df0:	771b      	addi.n	a7, a7, 1
40375df2:	ea87a6        	blti	a7, 8, 40375de0 <esp_vApplicationTickHook+0x10>
        }
    }
}
40375df5:	f01d      	retw.n
	...

40375df8 <efuse_hal_chip_revision>:
    *((uint32_t*)&mac[0]) = efuse_ll_get_mac0();
    *((uint16_t*)&mac[4]) = (uint16_t) efuse_ll_get_mac1();
}

IRAM_ATTR uint32_t efuse_hal_chip_revision(void)
{
40375df8:	004136        	entry	a1, 32
    return efuse_hal_get_major_chip_version() * 100 + efuse_hal_get_minor_chip_version();
40375dfb:	000525        	call8	40375e4c <efuse_hal_get_major_chip_version>
40375dfe:	a0aaa0        	addx4	a10, a10, a10
40375e01:	a0aaa0        	addx4	a10, a10, a10
40375e04:	112ae0        	slli	a2, a10, 2
40375e07:	0008e5        	call8	40375e94 <efuse_hal_get_minor_chip_version>
}
40375e0a:	8022a0        	add	a2, a2, a10
40375e0d:	000090        	retw

40375e10 <efuse_hal_get_disable_wafer_version_major>:
{
    return efuse_ll_get_blk_version_major() * 100 + efuse_ll_get_blk_version_minor();
}

IRAM_ATTR bool efuse_hal_get_disable_wafer_version_major(void)
{
40375e10:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
}

__attribute__((always_inline)) static inline bool efuse_ll_get_disable_wafer_version_major(void)
{
    return EFUSE.rd_repeat_data4.disable_wafer_version_major;
40375e13:	fa1081        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e16:	0020c0        	memw
40375e19:	102822        	l32i	a2, a8, 64
    return efuse_ll_get_disable_wafer_version_major();
}
40375e1c:	042020        	extui	a2, a2, 0, 1
40375e1f:	f01d      	retw.n
40375e21:	000000        	ill

40375e24 <efuse_hal_flash_encryption_enabled>:
{
    return efuse_ll_get_disable_blk_version_major();
}

IRAM_ATTR bool efuse_hal_flash_encryption_enabled(void)
{
40375e24:	004136        	entry	a1, 32
    return EFUSE.rd_repeat_data1.spi_boot_crypt_cnt;
40375e27:	fa0b81        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e2a:	0020c0        	memw
40375e2d:	d888      	l32i.n	a8, a8, 52
40375e2f:	258280        	extui	a8, a8, 18, 3
    uint32_t flash_crypt_cnt = efuse_ll_get_flash_crypt_cnt();
    bool enabled = false;
40375e32:	020c      	movi.n	a2, 0
    while (flash_crypt_cnt) {
40375e34:	0003c6        	j	40375e47 <efuse_hal_flash_encryption_enabled+0x23>
40375e37:	070000        	lsi	f0, a0, 28
        if (flash_crypt_cnt & 1) {
40375e3a:	0768      	l32i.n	a6, a7, 0
            enabled = !enabled;
40375e3c:	190c      	movi.n	a9, 1
40375e3e:	302290        	xor	a2, a2, a9
40375e41:	742020        	extui	a2, a2, 0, 8
        }
        flash_crypt_cnt >>= 1;
40375e44:	418180        	srli	a8, a8, 1
    while (flash_crypt_cnt) {
40375e47:	fee856        	bnez	a8, 40375e39 <efuse_hal_flash_encryption_enabled+0x15>
    }
    return enabled;
}
40375e4a:	f01d      	retw.n

40375e4c <efuse_hal_get_major_chip_version>:
    return ((minor_raw & 0x7) == 0 &&
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
}

IRAM_ATTR uint32_t efuse_hal_get_major_chip_version(void)
{
40375e4c:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
40375e4f:	fa0181        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e52:	0020c0        	memw
40375e55:	162892        	l32i	a9, a8, 88
40375e58:	0020c0        	memw
40375e5b:	142882        	l32i	a8, a8, 80
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375e5e:	258280        	extui	a8, a8, 18, 3
40375e61:	c8dc      	bnez.n	a8, 40375e81 <efuse_hal_get_major_chip_version+0x35>
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_major(void)
{
    return EFUSE.rd_sys_part1_data4.blk_version_major;
40375e63:	f9fc81        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e66:	0020c0        	memw
40375e69:	1b2882        	l32i	a8, a8, 108
40375e6c:	148080        	extui	a8, a8, 0, 2
    return ((minor_raw & 0x7) == 0 &&
40375e6f:	0e1866        	bnei	a8, 1, 40375e81 <efuse_hal_get_major_chip_version+0x35>
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_minor(void)
{
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
40375e72:	f9f881        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e75:	0020c0        	memw
40375e78:	142882        	l32i	a8, a8, 80
40375e7b:	258880        	extui	a8, a8, 24, 3
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375e7e:	0e1826        	beqi	a8, 1, 40375e90 <efuse_hal_get_major_chip_version+0x44>
    return EFUSE.rd_mac_spi_sys_5.wafer_version_major;
40375e81:	f9f481        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e84:	0020c0        	memw
40375e87:	162822        	l32i	a2, a8, 88
40375e8a:	152820        	extui	a2, a2, 24, 2
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
        return 0;
    }
    return efuse_ll_get_chip_wafer_version_major();
40375e8d:	000046        	j	40375e92 <efuse_hal_get_major_chip_version+0x46>
        return 0;
40375e90:	020c      	movi.n	a2, 0
}
40375e92:	f01d      	retw.n

40375e94 <efuse_hal_get_minor_chip_version>:

IRAM_ATTR uint32_t efuse_hal_get_minor_chip_version(void)
{
40375e94:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
40375e97:	f9ef81        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375e9a:	0020c0        	memw
40375e9d:	162822        	l32i	a2, a8, 88
40375ea0:	0020c0        	memw
40375ea3:	142882        	l32i	a8, a8, 80
40375ea6:	258280        	extui	a8, a8, 18, 3
40375ea9:	052720        	extui	a2, a2, 23, 1
40375eac:	b02280        	addx8	a2, a2, a8
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375eaf:	e8dc      	bnez.n	a8, 40375ed1 <efuse_hal_get_minor_chip_version+0x3d>
    return EFUSE.rd_sys_part1_data4.blk_version_major;
40375eb1:	f9e881        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375eb4:	0020c0        	memw
40375eb7:	1b2882        	l32i	a8, a8, 108
40375eba:	148080        	extui	a8, a8, 0, 2
    return ((minor_raw & 0x7) == 0 &&
40375ebd:	101866        	bnei	a8, 1, 40375ed1 <efuse_hal_get_minor_chip_version+0x3d>
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
40375ec0:	f9e581        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40375ec3:	0020c0        	memw
40375ec6:	142882        	l32i	a8, a8, 80
40375ec9:	258880        	extui	a8, a8, 24, 3
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375ecc:	011866        	bnei	a8, 1, 40375ed1 <efuse_hal_get_minor_chip_version+0x3d>
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
        return 0;
40375ecf:	020c      	movi.n	a2, 0
    }
    return minor_raw;
}
40375ed1:	f01d      	retw.n
	...

40375ed4 <fmt_abort_str>:
        uint8_t b4 = (n >> (28 - i * 4)) & 0b1111;
        buf[i] = b4 <= 9 ? '0' + b4 : 'a' + b4 - 10;
    }
}
HEAP_IRAM_ATTR static void fmt_abort_str(char dest[48], size_t size, uint32_t caps)
{
40375ed4:	006136        	entry	a1, 48
40375ed7:	20b330        	or	a11, a3, a3
    char sSize[8];
    char sCaps[8];
    hex_to_str(sSize, size);
40375eda:	20a110        	or	a10, a1, a1
40375edd:	0223e5        	call8	4037811c <hex_to_str>
    hex_to_str(sCaps, caps);
40375ee0:	718b      	addi.n	a7, a1, 8
40375ee2:	04bd      	mov.n	a11, a4
40375ee4:	07ad      	mov.n	a10, a7
40375ee6:	022365        	call8	4037811c <hex_to_str>
    memcpy(dest, "Mem alloc fail. size 0x00000000 caps 0x00000000", 48);
40375ee9:	0c3c      	movi.n	a12, 48
40375eeb:	f9dbb1        	l32r	a11, 40374658 <_iram_text_start+0x254> (3c022858 <_flash_rodata_start+0x2738>)
40375eee:	02ad      	mov.n	a10, a2
40375ef0:	f97981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375ef3:	0008e0        	callx8	a8
    memcpy(dest + 23, sSize, 8);
40375ef6:	8c0c      	movi.n	a12, 8
40375ef8:	20b110        	or	a11, a1, a1
40375efb:	17c2a2        	addi	a10, a2, 23
40375efe:	f97581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375f01:	0008e0        	callx8	a8
    memcpy(dest + 39, sCaps, 8);
40375f04:	8c0c      	movi.n	a12, 8
40375f06:	07bd      	mov.n	a11, a7
40375f08:	27c2a2        	addi	a10, a2, 39
40375f0b:	f97281        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40375f0e:	0008e0        	callx8	a8
}
40375f11:	f01d      	retw.n
	...

40375f14 <heap_caps_alloc_failed>:
#endif

HEAP_IRAM_ATTR NOINLINE_ATTR static void heap_caps_alloc_failed(size_t requested_size, uint32_t caps, const char *function_name)
{
40375f14:	00a136        	entry	a1, 80
40375f17:	04cd      	mov.n	a12, a4
    if (alloc_failed_callback) {
40375f19:	f9d081        	l32r	a8, 4037465c <_iram_text_start+0x258> (3fc94ab0 <alloc_failed_callback>)
40375f1c:	0888      	l32i.n	a8, a8, 0
40375f1e:	688c      	beqz.n	a8, 40375f28 <heap_caps_alloc_failed+0x14>
        alloc_failed_callback(requested_size, caps, function_name);
40375f20:	03bd      	mov.n	a11, a3
40375f22:	20a220        	or	a10, a2, a2
40375f25:	0008e0        	callx8	a8
    }

#ifdef CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS
    char buf[48];
    fmt_abort_str(buf, requested_size, caps);
40375f28:	20c330        	or	a12, a3, a3
40375f2b:	20b220        	or	a11, a2, a2
40375f2e:	01ad      	mov.n	a10, a1
40375f30:	fffa25        	call8	40375ed4 <fmt_abort_str>
    esp_system_abort(buf);
40375f33:	01ad      	mov.n	a10, a1
40375f35:	038565        	call8	4037978c <esp_system_abort>

40375f38 <heap_caps_malloc>:

/*
Routine to allocate a bit of memory with certain capabilities. caps is a bitfield of MALLOC_CAP_* bits.
*/
HEAP_IRAM_ATTR void *heap_caps_malloc( size_t size, uint32_t caps)
{
40375f38:	004136        	entry	a1, 32
40375f3b:	207220        	or	a7, a2, a2
    void* ptr = heap_caps_malloc_base(size, caps);
40375f3e:	20b330        	or	a11, a3, a3
40375f41:	20a220        	or	a10, a2, a2
40375f44:	003625        	call8	403762a8 <heap_caps_malloc_base>
40375f47:	0a2d      	mov.n	a2, a10


    if (!ptr && size > 0){
40375f49:	40fa80        	nsau	a8, a10
40375f4c:	418580        	srli	a8, a8, 5
40375f4f:	190c      	movi.n	a9, 1
40375f51:	839770        	moveqz	a9, a7, a7
40375f54:	090897        	bnone	a8, a9, 40375f61 <heap_caps_malloc+0x29>
        heap_caps_alloc_failed(size, caps, __func__);
40375f57:	f9c2c1        	l32r	a12, 40374660 <_iram_text_start+0x25c> (3c0277d8 <__func__$12>)
40375f5a:	03bd      	mov.n	a11, a3
40375f5c:	07ad      	mov.n	a10, a7
40375f5e:	fffb65        	call8	40375f14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40375f61:	f01d      	retw.n
	...

40375f64 <heap_caps_malloc_default>:

/*
 Default memory allocation implementation. Should return standard 8-bit memory. malloc() essentially resolves to this function.
*/
HEAP_IRAM_ATTR void *heap_caps_malloc_default( size_t size )
{
40375f64:	004136        	entry	a1, 32
40375f67:	207220        	or	a7, a2, a2
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375f6a:	f9be81        	l32r	a8, 40374664 <_iram_text_start+0x260> (3fc91f40 <malloc_alwaysinternal_limit>)
40375f6d:	002882        	l32i	a8, a8, 0
40375f70:	0d0866        	bnei	a8, -1, 40375f81 <heap_caps_malloc_default+0x1d>
        return heap_caps_malloc( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
40375f73:	f9bdb1        	l32r	a11, 40374668 <_iram_text_start+0x264> (1800 <UserFrameTotalSize+0x1700>)
40375f76:	20a220        	or	a10, a2, a2
40375f79:	fffbe5        	call8	40375f38 <heap_caps_malloc>
40375f7c:	0a2d      	mov.n	a2, a10
40375f7e:	0011c6        	j	40375fc9 <heap_caps_malloc_default+0x65>

        // use heap_caps_malloc_base() since we'll
        // check for allocation failure ourselves

        void *r;
        if (size <= (size_t)malloc_alwaysinternal_limit) {
40375f81:	0c3827        	bltu	a8, a2, 40375f91 <heap_caps_malloc_default+0x2d>
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40375f84:	f9b9b1        	l32r	a11, 40374668 <_iram_text_start+0x264> (1800 <UserFrameTotalSize+0x1700>)
40375f87:	02ad      	mov.n	a10, a2
40375f89:	0031e5        	call8	403762a8 <heap_caps_malloc_base>
40375f8c:	0a2d      	mov.n	a2, a10
40375f8e:	000246        	j	40375f9b <heap_caps_malloc_default+0x37>
        } else {
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM );
40375f91:	f9b6b1        	l32r	a11, 4037466c <_iram_text_start+0x268> (1400 <UserFrameTotalSize+0x1300>)
40375f94:	02ad      	mov.n	a10, a2
40375f96:	003125        	call8	403762a8 <heap_caps_malloc_base>
40375f99:	0a2d      	mov.n	a2, a10
        }
        if (r==NULL && size > 0) {
40375f9b:	40f280        	nsau	a8, a2
40375f9e:	418580        	srli	a8, a8, 5
40375fa1:	160c      	movi.n	a6, 1
40375fa3:	836770        	moveqz	a6, a7, a7
40375fa6:	0b0867        	bnone	a8, a6, 40375fb5 <heap_caps_malloc_default+0x51>
            //try again while being less picky
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT );
40375fa9:	f9b1b1        	l32r	a11, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
40375fac:	20a770        	or	a10, a7, a7
40375faf:	002fa5        	call8	403762a8 <heap_caps_malloc_base>
40375fb2:	202aa0        	or	a2, a10, a10
        }

        // allocation failure?
        if (r==NULL && size > 0){
40375fb5:	40f280        	nsau	a8, a2
40375fb8:	418580        	srli	a8, a8, 5
40375fbb:	0a0687        	bnone	a6, a8, 40375fc9 <heap_caps_malloc_default+0x65>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
40375fbe:	f9adc1        	l32r	a12, 40374674 <_iram_text_start+0x270> (3c0277bc <__func__$11>)
40375fc1:	f9abb1        	l32r	a11, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
40375fc4:	07ad      	mov.n	a10, a7
40375fc6:	fff4e5        	call8	40375f14 <heap_caps_alloc_failed>
        }

        return r;
    }
}
40375fc9:	f01d      	retw.n
	...

40375fcc <heap_caps_realloc>:
    va_end( argp );
    return r;
}

HEAP_IRAM_ATTR void *heap_caps_realloc( void *ptr, size_t size, uint32_t caps)
{
40375fcc:	004136        	entry	a1, 32
40375fcf:	20a220        	or	a10, a2, a2
    ptr = heap_caps_realloc_base(ptr, size, caps);
40375fd2:	20c440        	or	a12, a4, a4
40375fd5:	20b330        	or	a11, a3, a3
40375fd8:	002de5        	call8	403762b8 <heap_caps_realloc_base>
40375fdb:	0a2d      	mov.n	a2, a10


    if (ptr == NULL && size > 0){
40375fdd:	40fa80        	nsau	a8, a10
40375fe0:	418580        	srli	a8, a8, 5
40375fe3:	190c      	movi.n	a9, 1
40375fe5:	839330        	moveqz	a9, a3, a3
40375fe8:	090897        	bnone	a8, a9, 40375ff5 <heap_caps_realloc+0x29>
        heap_caps_alloc_failed(size, caps, __func__);
40375feb:	f9a3c1        	l32r	a12, 40374678 <_iram_text_start+0x274> (3c02778c <__func__$6>)
40375fee:	04bd      	mov.n	a11, a4
40375ff0:	03ad      	mov.n	a10, a3
40375ff2:	fff225        	call8	40375f14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40375ff5:	f01d      	retw.n
	...

40375ff8 <heap_caps_realloc_default>:
{
40375ff8:	004136        	entry	a1, 32
40375ffb:	207220        	or	a7, a2, a2
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375ffe:	f99981        	l32r	a8, 40374664 <_iram_text_start+0x260> (3fc91f40 <malloc_alwaysinternal_limit>)
40376001:	002882        	l32i	a8, a8, 0
40376004:	100866        	bnei	a8, -1, 40376018 <heap_caps_realloc_default+0x20>
        return heap_caps_realloc( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40376007:	f998c1        	l32r	a12, 40374668 <_iram_text_start+0x264> (1800 <UserFrameTotalSize+0x1700>)
4037600a:	20b330        	or	a11, a3, a3
4037600d:	02ad      	mov.n	a10, a2
4037600f:	fffbe5        	call8	40375fcc <heap_caps_realloc>
40376012:	0a2d      	mov.n	a2, a10
40376014:	001446        	j	40376069 <heap_caps_realloc_default+0x71>
40376017:	383700        	lsi	f0, a7, 224
        if (size <= (size_t)malloc_alwaysinternal_limit) {
4037601a:	93c111        	l32r	a1, 4035af20 <rom_rx_gain_force+0x354af4>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
4037601d:	30f9      	s32i.n	a15, a0, 12
4037601f:	2020b3        	lsi	f11, a0, 128
40376022:	2520a2        	l32i	a10, a0, 148
40376025:	0029      	s32i.n	a2, a0, 0
40376027:	202aa0        	or	a2, a10, a10
4037602a:	0002c6        	j	40376039 <heap_caps_realloc_default+0x41>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM);
4037602d:	f98fc1        	l32r	a12, 4037466c <_iram_text_start+0x268> (1400 <UserFrameTotalSize+0x1300>)
40376030:	03bd      	mov.n	a11, a3
40376032:	02ad      	mov.n	a10, a2
40376034:	002825        	call8	403762b8 <heap_caps_realloc_base>
40376037:	0a2d      	mov.n	a2, a10
        if (r==NULL && size>0) {
40376039:	40f280        	nsau	a8, a2
4037603c:	418580        	srli	a8, a8, 5
4037603f:	160c      	movi.n	a6, 1
40376041:	836330        	moveqz	a6, a3, a3
40376044:	0d0867        	bnone	a8, a6, 40376055 <heap_caps_realloc_default+0x5d>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT);
40376047:	f98ac1        	l32r	a12, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037604a:	03bd      	mov.n	a11, a3
4037604c:	20a770        	or	a10, a7, a7
4037604f:	0026a5        	call8	403762b8 <heap_caps_realloc_base>
40376052:	202aa0        	or	a2, a10, a10
        if (r==NULL && size>0){
40376055:	40f280        	nsau	a8, a2
40376058:	418580        	srli	a8, a8, 5
4037605b:	0a0687        	bnone	a6, a8, 40376069 <heap_caps_realloc_default+0x71>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
4037605e:	f987c1        	l32r	a12, 4037467c <_iram_text_start+0x278> (3c0277a0 <__func__$10>)
40376061:	f983b1        	l32r	a11, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
40376064:	03ad      	mov.n	a10, a3
40376066:	ffeae5        	call8	40375f14 <heap_caps_alloc_failed>
}
40376069:	f01d      	retw.n
	...

4037606c <heap_caps_calloc>:

HEAP_IRAM_ATTR void *heap_caps_calloc( size_t n, size_t size, uint32_t caps)
{
4037606c:	004136        	entry	a1, 32
4037606f:	207220        	or	a7, a2, a2
    void* ptr = heap_caps_calloc_base(n, size, caps);
40376072:	20c440        	or	a12, a4, a4
40376075:	03bd      	mov.n	a11, a3
40376077:	20a220        	or	a10, a2, a2
4037607a:	003965        	call8	40376410 <heap_caps_calloc_base>
4037607d:	0a2d      	mov.n	a2, a10


    if (!ptr && size > 0){
4037607f:	40fa80        	nsau	a8, a10
40376082:	418580        	srli	a8, a8, 5
40376085:	190c      	movi.n	a9, 1
40376087:	839330        	moveqz	a9, a3, a3
4037608a:	0a0897        	bnone	a8, a9, 40376098 <heap_caps_calloc+0x2c>
        heap_caps_alloc_failed(n * size, caps, __func__);
4037608d:	f97cc1        	l32r	a12, 40374680 <_iram_text_start+0x27c> (3c027778 <__func__$5>)
40376090:	04bd      	mov.n	a11, a4
40376092:	82a730        	mull	a10, a7, a3
40376095:	ffe7e5        	call8	40375f14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40376098:	f01d      	retw.n
	...

4037609c <dram_alloc_to_iram_addr>:
  This takes a memory chunk in a region that can be addressed as both DRAM as well as IRAM. It will convert it to
  IRAM in such a way that it can be later freed. It assumes both the address as well as the length to be word-aligned.
  It returns a region that's 1 word smaller than the region given because it stores the original Dram address there.
*/
HEAP_IRAM_ATTR static void *dram_alloc_to_iram_addr(void *addr, size_t len)
{
4037609c:	004136        	entry	a1, 32
    uintptr_t dstart = (uintptr_t)addr; //First word
4037609f:	20a220        	or	a10, a2, a2
    uintptr_t dend __attribute__((unused)) = dstart + len - 4; //Last word
403760a2:	803230        	add	a3, a2, a3
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
403760a5:	f97791        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
403760a8:	929a      	add.n	a9, a2, a9
403760aa:	f97781        	l32r	a8, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
403760ad:	628890        	lsi	f9, a8, 0x188
403760b0:	880b      	addi.n	a8, a8, -1
403760b2:	608080        	neg	a8, a8
403760b5:	748080        	extui	a8, a8, 0, 8
    assert(esp_ptr_in_diram_dram((void *)dstart) || esp_ptr_in_rtc_dram_fast((void *)dstart));
403760b8:	38ec      	bnez.n	a8, 403760df <dram_alloc_to_iram_addr+0x43>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403760ba:	f94c91        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403760bd:	929a      	add.n	a9, a2, a9
403760bf:	f94c81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403760c2:	628890        	lsi	f9, a8, 0x188
403760c5:	880b      	addi.n	a8, a8, -1
403760c7:	608080        	neg	a8, a8
403760ca:	748080        	extui	a8, a8, 0, 8
403760cd:	00e856        	bnez	a8, 403760df <dram_alloc_to_iram_addr+0x43>
403760d0:	f96fd1        	l32r	a13, 4037468c <_iram_text_start+0x288> (3c0232d4 <_flash_rodata_start+0x31b4>)
403760d3:	f96fc1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027ad8 <__func__$1>)
403760d6:	29a0b2        	movi	a11, 41
403760d9:	f96ea1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
403760dc:	09c725        	call8	4037fd50 <__assert_func>
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
403760df:	f96e91        	l32r	a9, 40374698 <_iram_text_start+0x294> (c0377ffc <_rtc_reserved_end+0x60277ffc>)
403760e2:	939a      	add.n	a9, a3, a9
403760e4:	f96981        	l32r	a8, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
403760e7:	628890        	lsi	f9, a8, 0x188
403760ea:	880b      	addi.n	a8, a8, -1
403760ec:	608080        	neg	a8, a8
403760ef:	748080        	extui	a8, a8, 0, 8
    assert(esp_ptr_in_diram_dram((void *)dend) || esp_ptr_in_rtc_dram_fast((void *)dend));
403760f2:	28ec      	bnez.n	a8, 40376118 <dram_alloc_to_iram_addr+0x7c>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403760f4:	f96a91        	l32r	a9, 4037469c <_iram_text_start+0x298> (9ff01ffc <_rtc_reserved_end+0x3fe01ffc>)
403760f7:	939a      	add.n	a9, a3, a9
403760f9:	f93d81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403760fc:	628890        	lsi	f9, a8, 0x188
403760ff:	880b      	addi.n	a8, a8, -1
40376101:	608080        	neg	a8, a8
40376104:	748080        	extui	a8, a8, 0, 8
40376107:	00d856        	bnez	a8, 40376118 <dram_alloc_to_iram_addr+0x7c>
4037610a:	f965d1        	l32r	a13, 403746a0 <_iram_text_start+0x29c> (3c023350 <_flash_rodata_start+0x3230>)
4037610d:	f960c1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027ad8 <__func__$1>)
40376110:	ab2c      	movi.n	a11, 42
40376112:	f960a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
40376115:	09c3a5        	call8	4037fd50 <__assert_func>
    assert((dstart & 3) == 0);
40376118:	1480a0        	extui	a8, a10, 0, 2
4037611b:	00d816        	beqz	a8, 4037612c <dram_alloc_to_iram_addr+0x90>
4037611e:	f961d1        	l32r	a13, 403746a4 <_iram_text_start+0x2a0> (3c0233a0 <_flash_rodata_start+0x3280>)
40376121:	f95bc1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027ad8 <__func__$1>)
40376124:	bb2c      	movi.n	a11, 43
40376126:	f95ba1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
40376129:	09c265        	call8	4037fd50 <__assert_func>
    assert((dend & 3) == 0);
4037612c:	143030        	extui	a3, a3, 0, 2
4037612f:	00d316        	beqz	a3, 40376140 <dram_alloc_to_iram_addr+0xa4>
40376132:	f95dd1        	l32r	a13, 403746a8 <_iram_text_start+0x2a4> (3c0233b4 <_flash_rodata_start+0x3294>)
40376135:	f956c1        	l32r	a12, 40374690 <_iram_text_start+0x28c> (3c027ad8 <__func__$1>)
40376138:	cb2c      	movi.n	a11, 44
4037613a:	f956a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
4037613d:	09c125        	call8	4037fd50 <__assert_func>
40376140:	f92b81        	l32r	a8, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40376143:	8a8a      	add.n	a8, a10, a8
#if SOC_DIRAM_INVERTED // We want the word before the result to hold the DRAM address
    uint32_t *iptr = esp_ptr_diram_dram_to_iram((void *)dend);
#else
    uint32_t *iptr = NULL;
    if (esp_ptr_in_rtc_dram_fast((void *)dstart)) {
40376145:	f92a91        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40376148:	04b987        	bgeu	a9, a8, 40376150 <dram_alloc_to_iram_addr+0xb4>
    return (void *) ( SOC_DIRAM_IRAM_LOW + ((intptr_t)p - SOC_DIRAM_DRAM_LOW) );
4037614b:	f95881        	l32r	a8, 403746ac <_iram_text_start+0x2a8> (6f0000 <UserFrameTotalSize+0x6eff00>)
4037614e:	228a      	add.n	a2, a2, a8
        iptr = esp_ptr_rtc_dram_to_iram((void *)dstart);
    } else {
        iptr = esp_ptr_diram_dram_to_iram((void *)dstart);
    }
#endif
    *iptr = dstart;
40376150:	02a9      	s32i.n	a10, a2, 0
    return iptr + 1;
}
40376152:	224b      	addi.n	a2, a2, 4
40376154:	f01d      	retw.n
	...

40376158 <aligned_or_unaligned_alloc>:
    multi_heap_free(heap->heap, block_owner_ptr);

    CALL_HOOK(esp_heap_trace_free_hook, ptr);
}

HEAP_IRAM_ATTR static inline void *aligned_or_unaligned_alloc(multi_heap_handle_t heap, size_t size, size_t alignment, size_t offset) {
40376158:	004136        	entry	a1, 32
4037615b:	20a220        	or	a10, a2, a2
4037615e:	20b330        	or	a11, a3, a3
40376161:	20c440        	or	a12, a4, a4
40376164:	05dd      	mov.n	a13, a5
    if (alignment<=UNALIGNED_MEM_ALIGNMENT_BYTES) { //alloc and friends align to 32-bit by default
40376166:	0754f6        	bgeui	a4, 5, 40376171 <aligned_or_unaligned_alloc+0x19>
        return multi_heap_malloc(heap, size);
40376169:	085925        	call8	4037e6fc <multi_heap_malloc>
4037616c:	0a2d      	mov.n	a2, a10
4037616e:	000106        	j	40376176 <aligned_or_unaligned_alloc+0x1e>
    } else {
        return multi_heap_aligned_alloc_offs(heap, size, alignment, offset);
40376171:	084da5        	call8	4037e64c <multi_heap_aligned_alloc_offs>
40376174:	0a2d      	mov.n	a2, a10
    }
}
40376176:	f01d      	retw.n

40376178 <heap_caps_free>:
{
40376178:	004136        	entry	a1, 32
4037617b:	02bd      	mov.n	a11, a2
    if (ptr == NULL) {
4037617d:	044216        	beqz	a2, 403761c5 <heap_caps_free+0x4d>
    return ((intptr_t)p >= SOC_DIRAM_IRAM_LOW && (intptr_t)p < SOC_DIRAM_IRAM_HIGH);
40376180:	f94c81        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
40376183:	828a      	add.n	a8, a2, a8
    if (esp_ptr_in_diram_iram(ptr) || esp_ptr_in_rtc_iram_fast(ptr)) {
40376185:	f94091        	l32r	a9, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
40376188:	043987        	bltu	a9, a8, 40376190 <heap_caps_free+0x18>
        ptr = (void *)dramAddrPtr[-1];
4037618b:	fcc2b2        	addi	a11, a2, -4
4037618e:	0bb8      	l32i.n	a11, a11, 0
   (This confirms if ptr is inside the heap's region, doesn't confirm if 'ptr'
   is an allocated block or is some other random address inside the heap.)
*/
FORCE_INLINE_ATTR heap_t *find_containing_heap(void *ptr )
{
    intptr_t p = (intptr_t)ptr;
40376190:	0bad      	mov.n	a10, a11
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376192:	f94881        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94ab4 <registered_heaps>)
40376195:	0888      	l32i.n	a8, a8, 0
40376197:	000406        	j	403761ab <heap_caps_free+0x33>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
4037619a:	7898      	l32i.n	a9, a8, 28
4037619c:	898c      	beqz.n	a9, 403761a8 <heap_caps_free+0x30>
4037619e:	3898      	l32i.n	a9, a8, 12
403761a0:	042a97        	blt	a10, a9, 403761a8 <heap_caps_free+0x30>
403761a3:	4898      	l32i.n	a9, a8, 16
403761a5:	052a97        	blt	a10, a9, 403761ae <heap_caps_free+0x36>
    SLIST_FOREACH(heap, &registered_heaps, next) {
403761a8:	082882        	l32i	a8, a8, 32
403761ab:	feb856        	bnez	a8, 4037619a <heap_caps_free+0x22>
    assert(heap != NULL && "free() target pointer is outside heap areas");
403761ae:	00e856        	bnez	a8, 403761c0 <heap_caps_free+0x48>
403761b1:	f941d1        	l32r	a13, 403746b8 <_iram_text_start+0x2b4> (3c0233c4 <_flash_rodata_start+0x32a4>)
403761b4:	f942c1        	l32r	a12, 403746bc <_iram_text_start+0x2b8> (3c027af0 <__func__$2>)
403761b7:	4aa0b2        	movi	a11, 74
403761ba:	f936a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
403761bd:	09b925        	call8	4037fd50 <__assert_func>
    multi_heap_free(heap->heap, block_owner_ptr);
403761c0:	78a8      	l32i.n	a10, a8, 28
403761c2:	084a25        	call8	4037e664 <multi_heap_aligned_free>
}
403761c5:	f01d      	retw.n
	...

403761c8 <heap_caps_aligned_alloc_base>:
This function should not be called directly as it does not check for failure / call heap_caps_alloc_failed()
Note that this function does 'unaligned' alloc calls if alignment <= UNALIGNED_MEM_ALIGNMENT_BYTES (=4) as the
allocator will align to that value by default.
*/
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_aligned_alloc_base(size_t alignment, size_t size, uint32_t caps)
{
403761c8:	006136        	entry	a1, 48
403761cb:	006122        	s32i	a2, a1, 0
403761ce:	016132        	s32i	a3, a1, 4
403761d1:	026142        	s32i	a4, a1, 8
    void *ret = NULL;

    // Alignment, size and caps may need to be modified because of hardware requirements.
    esp_heap_adjust_alignment_to_hw(&alignment, &size, &caps);
403761d4:	c18b      	addi.n	a12, a1, 8
403761d6:	b14b      	addi.n	a11, a1, 4
403761d8:	01ad      	mov.n	a10, a1
403761da:	0164e5        	call8	40377828 <esp_heap_adjust_alignment_to_hw>

    // remove block owner size to HEAP_SIZE_MAX rather than adding the block owner size
    // to size to prevent overflows.
    if (size == 0 || size > MULTI_HEAP_REMOVE_BLOCK_OWNER_SIZE(HEAP_SIZE_MAX) ) {
403761dd:	1188      	l32i.n	a8, a1, 4
403761df:	980b      	addi.n	a9, a8, -1
403761e1:	f906a1        	l32r	a10, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
403761e4:	02ba97        	bgeu	a10, a9, 403761ea <heap_caps_aligned_alloc_base+0x22>
403761e7:	002c86        	j	4037629d <heap_caps_aligned_alloc_base+0xd5>
        // Avoids int overflow when adding small numbers to size, or
        // calculating 'end' from start+size, by limiting 'size' to the possible range
        return NULL;
    }

    if (caps & MALLOC_CAP_EXEC) {
403761ea:	2198      	l32i.n	a9, a1, 8
403761ec:	0c6907        	bbci	a9, 0, 403761fc <heap_caps_aligned_alloc_base+0x34>
        //MALLOC_CAP_EXEC forces an alloc from IRAM. There is a region which has both this as well as the following
        //caps, but the following caps are not possible for IRAM.  Thus, the combination is impossible and we return
        //NULL directly, even although our heap capabilities (based on soc_memory_tags & soc_memory_regions) would
        //indicate there is a tag for this.
        if ((caps & MALLOC_CAP_8BIT) || (caps & MALLOC_CAP_DMA)) {
403761ef:	14a290        	extui	a10, a9, 2, 2
403761f2:	0aca56        	bnez	a10, 403762a2 <heap_caps_aligned_alloc_base+0xda>
            return NULL;
        }
        caps |= MALLOC_CAP_32BIT; // IRAM is 32-bit accessible RAM
403761f5:	2a0c      	movi.n	a10, 2
403761f7:	2099a0        	or	a9, a9, a10
403761fa:	2199      	s32i.n	a9, a1, 8
    }

    if (caps & MALLOC_CAP_32BIT) {
403761fc:	2198      	l32i.n	a9, a1, 8
403761fe:	02e917        	bbsi	a9, 1, 40376204 <heap_caps_aligned_alloc_base+0x3c>
40376201:	0022c6        	j	40376290 <heap_caps_aligned_alloc_base+0xc8>
        /* 32-bit accessible RAM should allocated in 4 byte aligned sizes
         * (Future versions of ESP-IDF should possibly fail if an invalid size is requested)
         */
        size = (size + 3) & (~3); // int overflow checked above
40376204:	883b      	addi.n	a8, a8, 3
40376206:	c97c      	movi.n	a9, -4
40376208:	108890        	and	a8, a8, a9
4037620b:	1189      	s32i.n	a8, a1, 4
4037620d:	001fc6        	j	40376290 <heap_caps_aligned_alloc_base+0xc8>
    }

    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
        //Iterate over heaps and check capabilities at this priority
        heap_t *heap;
        SLIST_FOREACH(heap, &registered_heaps, next) {
40376210:	f92981        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94ab4 <registered_heaps>)
40376213:	0878      	l32i.n	a7, a8, 0
40376215:	001bc6        	j	40376288 <heap_caps_aligned_alloc_base+0xc0>
            if (heap->heap == NULL) {
40376218:	77a8      	l32i.n	a10, a7, 28
4037621a:	068a16        	beqz	a10, 40376286 <heap_caps_aligned_alloc_base+0xbe>
                continue;
            }
            if ((heap->caps[prio] & caps) != 0) {
4037621d:	a08670        	addx4	a8, a6, a7
40376220:	0888      	l32i.n	a8, a8, 0
40376222:	2198      	l32i.n	a9, a1, 8
40376224:	5e0897        	bnone	a8, a9, 40376286 <heap_caps_aligned_alloc_base+0xbe>
40376227:	000386        	j	40376239 <heap_caps_aligned_alloc_base+0x71>
4037622a:	700000        	lsi	f0, a0, 0x1c0
        all_caps |= heap->caps[prio];
4037622d:	a0c8      	l32i.n	a12, a0, 40
4037622f:	0cc8      	l32i.n	a12, a12, 0
40376231:	20bbc0        	or	a11, a11, a12
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
40376234:	881b      	addi.n	a8, a8, 1
40376236:	0000c6        	j	4037623d <heap_caps_aligned_alloc_base+0x75>
40376239:	080c      	movi.n	a8, 0
    uint32_t all_caps = 0;
4037623b:	08bd      	mov.n	a11, a8
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037623d:	eb38a6        	blti	a8, 3, 4037622c <heap_caps_aligned_alloc_base+0x64>
                //Heap has at least one of the caps requested. If caps has other bits set that this prio
                //doesn't cover, see if they're available in other prios.
                if ((get_all_caps(heap) & caps) == caps) {
40376240:	42cb97        	bnall	a11, a9, 40376286 <heap_caps_aligned_alloc_base+0xbe>
                    //This heap can satisfy all the requested capabilities. See if we can grab some memory using it.
                    // If MALLOC_CAP_EXEC is requested but the DRAM and IRAM are on the same addresses (like on esp32c6)
                    // proceed as for a default allocation.
                    if (((caps & MALLOC_CAP_EXEC) && !esp_dram_match_iram()) &&
40376243:	316907        	bbci	a9, 0, 40376278 <heap_caps_aligned_alloc_base+0xb0>
                        (esp_ptr_in_diram_dram((void *)heap->start) || esp_ptr_in_rtc_dram_fast((void *)heap->start))) {
40376246:	3788      	l32i.n	a8, a7, 12
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
40376248:	f90f91        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
4037624b:	989a      	add.n	a9, a8, a9
                    if (((caps & MALLOC_CAP_EXEC) && !esp_dram_match_iram()) &&
4037624d:	f90eb1        	l32r	a11, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
40376250:	0abb97        	bgeu	a11, a9, 4037625e <heap_caps_aligned_alloc_base+0x96>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40376253:	f8e691        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40376256:	889a      	add.n	a8, a8, a9
                        (esp_ptr_in_diram_dram((void *)heap->start) || esp_ptr_in_rtc_dram_fast((void *)heap->start))) {
40376258:	f8e691        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
4037625b:	193987        	bltu	a9, a8, 40376278 <heap_caps_aligned_alloc_base+0xb0>
                        //This is special, insofar that what we're going to get back is a DRAM address. If so,
                        //we need to 'invert' it (lowest address in DRAM == highest address in IRAM and vice-versa) and
                        //add a pointer to the DRAM equivalent before the address we're going to return.
                        ret = aligned_or_unaligned_alloc(heap->heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size) + 4,
4037625e:	00a0d2        	movi	a13, 0
40376261:	0021c2        	l32i	a12, a1, 0
40376264:	11b8      	l32i.n	a11, a1, 4
40376266:	bb4b      	addi.n	a11, a11, 4
40376268:	ffeee5        	call8	40376158 <aligned_or_unaligned_alloc>
                                                        alignment, MULTI_HEAP_BLOCK_OWNER_SIZE());  // int overflow checked above
                        if (ret != NULL) {
4037626b:	7a9c      	beqz.n	a10, 40376286 <heap_caps_aligned_alloc_base+0xbe>
                            MULTI_HEAP_SET_BLOCK_OWNER(ret);
                            ret = MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ret);
                            uint32_t *iptr = dram_alloc_to_iram_addr(ret, size + 4);  // int overflow checked above
4037626d:	11b8      	l32i.n	a11, a1, 4
4037626f:	bb4b      	addi.n	a11, a11, 4
40376271:	ffe2a5        	call8	4037609c <dram_alloc_to_iram_addr>
                            CALL_HOOK(esp_heap_trace_alloc_hook, iptr, size, caps);
                            return iptr;
40376274:	000b06        	j	403762a4 <heap_caps_aligned_alloc_base+0xdc>
40376277:	a0d200        	addx4	a13, a2, a0
                        }
                    } else {
                        //Just try to alloc, nothing special.
                        ret = aligned_or_unaligned_alloc(heap->heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size),
4037627a:	21c200        	srai	a12, a0, 2
4037627d:	21b200        	srai	a11, a0, 2
40376280:	ed6501        	l32r	a0, 40371814 <rom_rx_gain_force+0x36b3e8>
40376283:	ff          	.byte	0xff
                                                        alignment, MULTI_HEAP_BLOCK_OWNER_SIZE());
                        if (ret != NULL) {
40376284:	cadc      	bnez.n	a10, 403762a4 <heap_caps_aligned_alloc_base+0xdc>
        SLIST_FOREACH(heap, &registered_heaps, next) {
40376286:	8778      	l32i.n	a7, a7, 32
40376288:	f8c756        	bnez	a7, 40376218 <heap_caps_aligned_alloc_base+0x50>
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037628b:	661b      	addi.n	a6, a6, 1
4037628d:	000046        	j	40376292 <heap_caps_aligned_alloc_base+0xca>
    uint32_t all_caps = 0;
40376290:	060c      	movi.n	a6, 0
40376292:	0236e6        	bgei	a6, 3, 40376298 <heap_caps_aligned_alloc_base+0xd0>
40376295:	ffddc6        	j	40376210 <heap_caps_aligned_alloc_base+0x48>
            }
        }
    }

    //Nothing usable found.
    return NULL;
40376298:	0a0c      	movi.n	a10, 0
4037629a:	000186        	j	403762a4 <heap_caps_aligned_alloc_base+0xdc>
        return NULL;
4037629d:	0a0c      	movi.n	a10, 0
4037629f:	000046        	j	403762a4 <heap_caps_aligned_alloc_base+0xdc>
            return NULL;
403762a2:	0a0c      	movi.n	a10, 0
}
403762a4:	0a2d      	mov.n	a2, a10
403762a6:	f01d      	retw.n

403762a8 <heap_caps_malloc_base>:

//Wrapper for heap_caps_aligned_alloc_base as that can also do unaligned allocs.
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_malloc_base( size_t size, uint32_t caps) {
403762a8:	004136        	entry	a1, 32
403762ab:	02bd      	mov.n	a11, a2
403762ad:	03cd      	mov.n	a12, a3
    return heap_caps_aligned_alloc_base(UNALIGNED_MEM_ALIGNMENT_BYTES, size, caps);
403762af:	4a0c      	movi.n	a10, 4
403762b1:	fff165        	call8	403761c8 <heap_caps_aligned_alloc_base>
}
403762b4:	0a2d      	mov.n	a2, a10
403762b6:	f01d      	retw.n

403762b8 <heap_caps_realloc_base>:
/*
This function should not be called directly as it does not
check for failure / call heap_caps_alloc_failed()
*/
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_realloc_base( void *ptr, size_t size, uint32_t caps)
{
403762b8:	008136        	entry	a1, 64
403762bb:	206220        	or	a6, a2, a2
403762be:	046132        	s32i	a3, a1, 16
403762c1:	5149      	s32i.n	a4, a1, 20
    bool ptr_in_diram_case = false;
    heap_t *heap = NULL;
    void *dram_ptr = NULL;

    //See if memory needs alignment because of hardware reasons.
    size_t alignment = UNALIGNED_MEM_ALIGNMENT_BYTES;
403762c3:	480c      	movi.n	a8, 4
403762c5:	006182        	s32i	a8, a1, 0
    esp_heap_adjust_alignment_to_hw(&alignment, &size, &caps);
403762c8:	14c1c2        	addi	a12, a1, 20
403762cb:	10c1b2        	addi	a11, a1, 16
403762ce:	01ad      	mov.n	a10, a1
403762d0:	015565        	call8	40377828 <esp_heap_adjust_alignment_to_hw>

    if (ptr == NULL) {
403762d3:	d2cc      	bnez.n	a2, 403762e4 <heap_caps_realloc_base+0x2c>
        return heap_caps_aligned_alloc_base(alignment, size, caps);
403762d5:	51c8      	l32i.n	a12, a1, 20
403762d7:	41b8      	l32i.n	a11, a1, 16
403762d9:	01a8      	l32i.n	a10, a1, 0
403762db:	ffeee5        	call8	403761c8 <heap_caps_aligned_alloc_base>
403762de:	0a2d      	mov.n	a2, a10
403762e0:	004a86        	j	4037640e <heap_caps_realloc_base+0x156>
403762e3:	21c200        	srai	a12, a0, 2
    }

    if (size == 0) {
403762e6:	ac5604        	lsi	f0, a6, 0x2b0
403762e9:	a22000        	muluh	a2, a0, a0
        heap_caps_free(ptr);
403762ec:	e8a520        	lsi	f2, a5, 0x3a0
403762ef:	ff          	.byte	0xff
        return NULL;
403762f0:	020c      	movi.n	a2, 0
403762f2:	004606        	j	4037640e <heap_caps_realloc_base+0x156>
    }

    // remove block owner size to HEAP_SIZE_MAX rather than adding the block owner size
    // to size to prevent overflows.
    if (size > MULTI_HEAP_REMOVE_BLOCK_OWNER_SIZE(HEAP_SIZE_MAX)) {
403762f5:	f8f281        	l32r	a8, 403746c0 <_iram_text_start+0x2bc> (2000000 <UserFrameTotalSize+0x1ffff00>)
403762f8:	02b8c7        	bgeu	a8, a12, 403762fe <heap_caps_realloc_base+0x46>
403762fb:	004346        	j	4037640c <heap_caps_realloc_base+0x154>
    return ((intptr_t)p >= SOC_DIRAM_IRAM_LOW && (intptr_t)p < SOC_DIRAM_IRAM_HIGH);
403762fe:	f8ec81        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
40376301:	828a      	add.n	a8, a2, a8
        return NULL;
    }

    //The pointer to memory may be aliased, we need to
    //recover the corresponding address before to manage a new allocation:
    if(esp_ptr_in_diram_iram((void *)ptr)) {
40376303:	f8e191        	l32r	a9, 40374688 <_iram_text_start+0x284> (67fff <UserFrameTotalSize+0x67eff>)
40376306:	343987        	bltu	a9, a8, 4037633e <heap_caps_realloc_base+0x86>
        uint32_t *dram_addr = (uint32_t *)ptr;
        dram_ptr  = (void *)dram_addr[-1];
40376309:	fcc282        	addi	a8, a2, -4
4037630c:	0848      	l32i.n	a4, a8, 0
    intptr_t p = (intptr_t)ptr;
4037630e:	049d      	mov.n	a9, a4
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376310:	f8e981        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94ab4 <registered_heaps>)
40376313:	0878      	l32i.n	a7, a8, 0
40376315:	000406        	j	40376329 <heap_caps_realloc_base+0x71>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
40376318:	7788      	l32i.n	a8, a7, 28
4037631a:	888c      	beqz.n	a8, 40376326 <heap_caps_realloc_base+0x6e>
4037631c:	3788      	l32i.n	a8, a7, 12
4037631e:	042987        	blt	a9, a8, 40376326 <heap_caps_realloc_base+0x6e>
40376321:	4788      	l32i.n	a8, a7, 16
40376323:	052987        	blt	a9, a8, 4037632c <heap_caps_realloc_base+0x74>
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376326:	082772        	l32i	a7, a7, 32
40376329:	feb756        	bnez	a7, 40376318 <heap_caps_realloc_base+0x60>
        dram_ptr = MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(dram_ptr);

        heap = find_containing_heap(dram_ptr);
        assert(heap != NULL && "realloc() pointer is outside heap areas");
4037632c:	040756        	bnez	a7, 40376370 <heap_caps_realloc_base+0xb8>
4037632f:	f8e5d1        	l32r	a13, 403746c4 <_iram_text_start+0x2c0> (3c023404 <_flash_rodata_start+0x32e4>)
40376332:	f8e5c1        	l32r	a12, 403746c8 <_iram_text_start+0x2c4> (3c027ac0 <__func__$0>)
40376335:	d8a0b2        	movi	a11, 216
40376338:	f8d7a1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
4037633b:	09a165        	call8	4037fd50 <__assert_func>
    intptr_t p = (intptr_t)ptr;
4037633e:	209220        	or	a9, a2, a2
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376341:	f8dc81        	l32r	a8, 403746b4 <_iram_text_start+0x2b0> (3fc94ab4 <registered_heaps>)
40376344:	002872        	l32i	a7, a8, 0
40376347:	000406        	j	4037635b <heap_caps_realloc_base+0xa3>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
4037634a:	7788      	l32i.n	a8, a7, 28
4037634c:	888c      	beqz.n	a8, 40376358 <heap_caps_realloc_base+0xa0>
4037634e:	3788      	l32i.n	a8, a7, 12
40376350:	042987        	blt	a9, a8, 40376358 <heap_caps_realloc_base+0xa0>
40376353:	4788      	l32i.n	a8, a7, 16
40376355:	052987        	blt	a9, a8, 4037635e <heap_caps_realloc_base+0xa6>
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376358:	082772        	l32i	a7, a7, 32
4037635b:	feb756        	bnez	a7, 4037634a <heap_caps_realloc_base+0x92>
        //instead force a malloc/copy/free
        ptr_in_diram_case = true;

    } else {
        heap = find_containing_heap(ptr);
        assert(heap != NULL && "realloc() pointer is outside heap areas");
4037635e:	014756        	bnez	a7, 40376376 <heap_caps_realloc_base+0xbe>
40376361:	f8d8d1        	l32r	a13, 403746c4 <_iram_text_start+0x2c0> (3c023404 <_flash_rodata_start+0x32e4>)
40376364:	f8d9c1        	l32r	a12, 403746c8 <_iram_text_start+0x2c4> (3c027ac0 <__func__$0>)
40376367:	e1a0b2        	movi	a11, 225
4037636a:	f8caa1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
4037636d:	099e25        	call8	4037fd50 <__assert_func>
        ptr_in_diram_case = true;
40376370:	01a052        	movi	a5, 1
40376373:	0000c6        	j	4037637a <heap_caps_realloc_base+0xc2>
    void *dram_ptr = NULL;
40376376:	040c      	movi.n	a4, 0
    bool ptr_in_diram_case = false;
40376378:	045d      	mov.n	a5, a4
    if (heap->heap == NULL) {
4037637a:	77a8      	l32i.n	a10, a7, 28
4037637c:	5a9c      	beqz.n	a10, 40376395 <heap_caps_realloc_base+0xdd>
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037637e:	090c      	movi.n	a9, 0
    uint32_t all_caps = 0;
40376380:	098d      	mov.n	a8, a9
40376382:	000246        	j	4037638f <heap_caps_realloc_base+0xd7>
        all_caps |= heap->caps[prio];
40376385:	a0b970        	addx4	a11, a9, a7
40376388:	0bb8      	l32i.n	a11, a11, 0
4037638a:	2088b0        	or	a8, a8, a11
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037638d:	991b      	addi.n	a9, a9, 1
4037638f:	f239a6        	blti	a9, 3, 40376385 <heap_caps_realloc_base+0xcd>
40376392:	000046        	j	40376397 <heap_caps_realloc_base+0xdf>
        return 0;
40376395:	080c      	movi.n	a8, 0
    // processing the realloc.
    ptr = MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(ptr);

    // are the existing heap's capabilities compatible with the
    // requested ones?
    bool compatible_caps = (caps & get_all_caps(heap)) == caps;
40376397:	5198      	l32i.n	a9, a1, 20
40376399:	108890        	and	a8, a8, a9
4037639c:	308890        	xor	a8, a8, a9
4037639f:	40f880        	nsau	a8, a8
403763a2:	418580        	srli	a8, a8, 5

    //Note we don't try realloc() on memory that needs to be aligned, that is handled
    //by the fallthrough code.
    if (compatible_caps && !ptr_in_diram_case && alignment<=UNALIGNED_MEM_ALIGNMENT_BYTES) {
403763a5:	190c      	movi.n	a9, 1
403763a7:	309590        	xor	a9, a5, a9
403763aa:	0e0987        	bnone	a9, a8, 403763bc <heap_caps_realloc_base+0x104>
403763ad:	0188      	l32i.n	a8, a1, 0
403763af:	0958f6        	bgeui	a8, 5, 403763bc <heap_caps_realloc_base+0x104>
        // try to reallocate this memory within the same heap
        // (which will resize the block if it can)
        void *r = multi_heap_realloc(heap->heap, ptr, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size));
403763b2:	06bd      	mov.n	a11, a6
403763b4:	083965        	call8	4037e74c <multi_heap_realloc>
403763b7:	0a2d      	mov.n	a2, a10
        if (r != NULL) {
403763b9:	051a56        	bnez	a10, 4037640e <heap_caps_realloc_base+0x156>
        }
    }

    // if we couldn't do that, try to see if we can reallocate
    // in a different heap with requested capabilities.
    void *new_p = heap_caps_aligned_alloc_base(alignment, size, caps);
403763bc:	51c8      	l32i.n	a12, a1, 20
403763be:	41b8      	l32i.n	a11, a1, 16
403763c0:	01a8      	l32i.n	a10, a1, 0
403763c2:	ffe065        	call8	403761c8 <heap_caps_aligned_alloc_base>
403763c5:	0a2d      	mov.n	a2, a10
    if (new_p != NULL) {
403763c7:	043a16        	beqz	a10, 4037640e <heap_caps_realloc_base+0x156>
        size_t old_size = 0;

        //If we're dealing with aliased ptr, information regarding its containing
        //heap can only be obtained with translated address.
        if(ptr_in_diram_case) {
403763ca:	a58c      	beqz.n	a5, 403763d8 <heap_caps_realloc_base+0x120>
            old_size = multi_heap_get_allocated_size(heap->heap, dram_ptr);
403763cc:	04bd      	mov.n	a11, a4
403763ce:	0727a2        	l32i	a10, a7, 28
403763d1:	082da5        	call8	4037e6ac <multi_heap_get_allocated_size>
403763d4:	000246        	j	403763e1 <heap_caps_realloc_base+0x129>
403763d7:	b66000        	lsi	f0, a0, 0x2d8
        } else {
            old_size = multi_heap_get_allocated_size(heap->heap, ptr);
403763da:	27a220        	lsi	f2, a2, 156
403763dd:	2ce507        	bbsi	a5, 0, 4037640d <heap_caps_realloc_base+0x155>
403763e0:	cc08      	l32i.n	a0, a12, 48
        }

        assert(old_size > 0);
403763e2:	d1da      	add.n	a13, a1, a13
403763e4:	f8ba      	add.n	a15, a8, a11
403763e6:	f8b8c1        	l32r	a12, 403746c8 <_iram_text_start+0x2c4> (3c027ac0 <__func__$0>)
403763e9:	0aa1b2        	movi	a11, 0x10a
403763ec:	f8aaa1        	l32r	a10, 40374694 <_iram_text_start+0x290> (3c02333e <_flash_rodata_start+0x321e>)
403763ef:	099625        	call8	4037fd50 <__assert_func>
        // do not copy the block owner bytes
        memcpy(new_p, MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ptr), MIN(size, old_size));
403763f2:	0421c2        	l32i	a12, a1, 16
403763f5:	63cac0        	minu	a12, a10, a12
403763f8:	20b660        	or	a11, a6, a6
403763fb:	20a220        	or	a10, a2, a2
403763fe:	f83581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40376401:	0008e0        	callx8	a8
        // add the block owner bytes to ptr since they are removed in heap_caps_free
        heap_caps_free(MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ptr));
40376404:	06ad      	mov.n	a10, a6
40376406:	ffd725        	call8	40376178 <heap_caps_free>
        return new_p;
40376409:	000046        	j	4037640e <heap_caps_realloc_base+0x156>
        return NULL;
4037640c:	020c      	movi.n	a2, 0
    }

    return NULL;
}
4037640e:	f01d      	retw.n

40376410 <heap_caps_calloc_base>:
/*
This function should not be called directly as it does not
check for failure / call heap_caps_alloc_failed()
*/
HEAP_IRAM_ATTR void *heap_caps_calloc_base( size_t n, size_t size, uint32_t caps)
{
40376410:	004136        	entry	a1, 32
40376413:	04bd      	mov.n	a11, a4
    void *result;
    size_t size_bytes;

    if (__builtin_mul_overflow(n, size, &size_bytes)) {
40376415:	080c      	movi.n	a8, 0
40376417:	827230        	mull	a7, a2, a3
4037641a:	a22230        	muluh	a2, a2, a3
4037641d:	028c      	beqz.n	a2, 40376421 <heap_caps_calloc_base+0x11>
4037641f:	180c      	movi.n	a8, 1
40376421:	017856        	bnez	a8, 4037643c <heap_caps_calloc_base+0x2c>
        return NULL;
    }

    result = heap_caps_malloc_base(size_bytes, caps);
40376424:	20a770        	or	a10, a7, a7
40376427:	ffe825        	call8	403762a8 <heap_caps_malloc_base>
4037642a:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
4037642c:	ea8c      	beqz.n	a10, 4037643e <heap_caps_calloc_base+0x2e>
        memset(result, 0, size_bytes);
4037642e:	07cd      	mov.n	a12, a7
40376430:	0b0c      	movi.n	a11, 0
40376432:	f81781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40376435:	0008e0        	callx8	a8
40376438:	000086        	j	4037643e <heap_caps_calloc_base+0x2e>
4037643b:	020c00        	andb	b0, b12, b0
    }
    return result;
}
4037643e:	f01d      	retw.n

40376440 <esp_clk_cpu_freq>:
    return g_ticks_per_us_pro;
#endif
}

int IRAM_ATTR esp_clk_cpu_freq(void)
{
40376440:	004136        	entry	a1, 32
    return esp_rom_get_cpu_ticks_per_us();
40376443:	f8a481        	l32r	a8, 403746d4 <_iram_text_start+0x2d0> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
40376446:	0008e0        	callx8	a8
    return s_get_cpu_freq_mhz() * MHZ;
}
40376449:	f8a181        	l32r	a8, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
4037644c:	822a80        	mull	a2, a10, a8
4037644f:	f01d      	retw.n
40376451:	000000        	ill

40376454 <shared_intr_isr>:
    return best;
}

//Common shared isr handler. Chain-call all ISRs.
static void IRAM_ATTR shared_intr_isr(void *arg)
{
40376454:	004136        	entry	a1, 32
    vector_desc_t *vd = (vector_desc_t*)arg;
    shared_vector_desc_t *sh_vec = vd->shared_vec_info;
40376457:	1278      	l32i.n	a7, a2, 4
40376459:	fb7c      	movi.n	a11, -1
4037645b:	f89fa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
4037645e:	03cd25        	call8	4037a130 <xPortEnterCriticalTimeout>
}
40376461:	000746        	j	40376482 <shared_intr_isr+0x2e>
    portENTER_CRITICAL_ISR(&spinlock);
    while(sh_vec) {
        if (!sh_vec->disabled) {
40376464:	001782        	l16ui	a8, a7, 0
40376467:	15e807        	bbsi	a8, 0, 40376480 <shared_intr_isr+0x2c>
            if ((sh_vec->statusreg == NULL) || (*sh_vec->statusreg & sh_vec->statusmask)) {
4037646a:	1788      	l32i.n	a8, a7, 4
4037646c:	988c      	beqz.n	a8, 40376479 <shared_intr_isr+0x25>
4037646e:	0020c0        	memw
40376471:	0898      	l32i.n	a9, a8, 0
40376473:	022782        	l32i	a8, a7, 8
40376476:	060987        	bnone	a9, a8, 40376480 <shared_intr_isr+0x2c>
                traceISR_ENTER(sh_vec->source + ETS_INTERNAL_INTR_SOURCE_OFF);
                sh_vec->isr(sh_vec->arg);
40376479:	3788      	l32i.n	a8, a7, 12
4037647b:	47a8      	l32i.n	a10, a7, 16
4037647d:	0008e0        	callx8	a8
                if (!os_task_switch_is_pended(esp_cpu_get_core_id())) {
                    traceISR_EXIT();
                }
            }
        }
        sh_vec = sh_vec->next;
40376480:	5778      	l32i.n	a7, a7, 20
    while(sh_vec) {
40376482:	fde756        	bnez	a7, 40376464 <shared_intr_isr+0x10>
    }
    portEXIT_CRITICAL_ISR(&spinlock);
40376485:	f894a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
40376488:	03df65        	call8	4037a280 <vPortExitCritical>
}
4037648b:	f01d      	retw.n
4037648d:	000000        	ill

40376490 <esp_intr_noniram_disable>:
    portEXIT_CRITICAL_SAFE(&spinlock);
    return ESP_OK;
}

void IRAM_ATTR esp_intr_noniram_disable(void)
{
40376490:	004136        	entry	a1, 32
}

static inline BaseType_t __attribute__((always_inline)) xPortEnterCriticalTimeoutSafe(portMUX_TYPE *mux, BaseType_t timeout)
{
    BaseType_t ret;
    if (xPortInIsrContext()) {
40376493:	03c7a5        	call8	4037a10c <xPortInIsrContext>
40376496:	00ba16        	beqz	a10, 403764a5 <esp_intr_noniram_disable+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376499:	ffafb2        	movi	a11, -1
4037649c:	f88fa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
4037649f:	03c925        	call8	4037a130 <xPortEnterCriticalTimeout>
403764a2:	000206        	j	403764ae <esp_intr_noniram_disable+0x1e>
    } else {
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403764a5:	ffafb2        	movi	a11, -1
403764a8:	f88ca1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
403764ab:	03c865        	call8	4037a130 <xPortEnterCriticalTimeout>
403764ae:	03eb70        	rsr.prid	a7
403764b1:	047d70        	extui	a7, a7, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t oldint;
    uint32_t cpu = esp_cpu_get_core_id();
    uint32_t non_iram_ints = non_iram_int_mask[cpu];
403764b4:	f88a81        	l32r	a8, 403746dc <_iram_text_start+0x2d8> (3fc94ac4 <non_iram_int_mask>)
403764b7:	a08780        	addx4	a8, a7, a8
403764ba:	002862        	l32i	a6, a8, 0
    if (non_iram_int_disabled_flag[cpu]) {
403764bd:	f88881        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94ab8 <non_iram_int_disabled_flag>)
403764c0:	808870        	add	a8, a8, a7
403764c3:	000882        	l8ui	a8, a8, 0
403764c6:	002816        	beqz	a8, 403764cc <esp_intr_noniram_disable+0x3c>
        abort();
403764c9:	097ca5        	call8	4037fc94 <abort>
    }
    non_iram_int_disabled_flag[cpu] = true;
403764cc:	f88581        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94ab8 <non_iram_int_disabled_flag>)
403764cf:	887a      	add.n	a8, a8, a7
403764d1:	190c      	movi.n	a9, 1
403764d3:	004892        	s8i	a9, a8, 0
// ------------------ Interrupt Control --------------------

FORCE_INLINE_ATTR uint32_t xt_utils_intr_get_enabled_mask(void)
{
    uint32_t intr_mask;
    RSR(INTENABLE, intr_mask);
403764d6:	03e450        	rsr.intenable	a5
403764d9:	06ad      	mov.n	a10, a6
403764db:	0b9e65        	call8	40381ec0 <xt_ints_off>
    oldint = esp_cpu_intr_get_enabled_mask();
    esp_cpu_intr_disable(non_iram_ints);
    // Disable the RTC bit which don't want to be put in IRAM.
    rtc_isr_noniram_disable(cpu);
403764de:	07ad      	mov.n	a10, a7
403764e0:	0024e5        	call8	40376730 <rtc_isr_noniram_disable>
    // Save disabled ints
    non_iram_int_disabled[cpu] = oldint & non_iram_ints;
403764e3:	106650        	and	a6, a6, a5
403764e6:	f87f81        	l32r	a8, 403746e4 <_iram_text_start+0x2e0> (3fc94abc <non_iram_int_disabled>)
403764e9:	a07780        	addx4	a7, a7, a8
403764ec:	0769      	s32i.n	a6, a7, 0
    xPortEnterCriticalTimeoutSafe(mux, portMUX_NO_TIMEOUT);
}

static inline void __attribute__((always_inline)) vPortExitCriticalSafe(portMUX_TYPE *mux)
{
    if (xPortInIsrContext()) {
403764ee:	03c1e5        	call8	4037a10c <xPortInIsrContext>
403764f1:	7a8c      	beqz.n	a10, 403764fc <esp_intr_noniram_disable+0x6c>
        portEXIT_CRITICAL_ISR(mux);
403764f3:	f879a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
403764f6:	03d8a5        	call8	4037a280 <vPortExitCritical>
403764f9:	000146        	j	40376502 <esp_intr_noniram_disable+0x72>
    } else {
        portEXIT_CRITICAL(mux);
403764fc:	f877a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
403764ff:	03d825        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
40376502:	f01d      	retw.n

40376504 <esp_intr_noniram_enable>:

void IRAM_ATTR esp_intr_noniram_enable(void)
{
40376504:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40376507:	03c065        	call8	4037a10c <xPortInIsrContext>
4037650a:	00ba16        	beqz	a10, 40376519 <esp_intr_noniram_enable+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037650d:	fb7c      	movi.n	a11, -1
4037650f:	f872a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
40376512:	03c1e5        	call8	4037a130 <xPortEnterCriticalTimeout>
40376515:	000246        	j	40376522 <esp_intr_noniram_enable+0x1e>
40376518:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037651b:	ff          	.byte	0xff
4037651c:	f86fa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
4037651f:	03c125        	call8	4037a130 <xPortEnterCriticalTimeout>
    asm volatile (
40376522:	03eb70        	rsr.prid	a7
40376525:	047d70        	extui	a7, a7, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t cpu = esp_cpu_get_core_id();
    int non_iram_ints = non_iram_int_disabled[cpu];
40376528:	f86f81        	l32r	a8, 403746e4 <_iram_text_start+0x2e0> (3fc94abc <non_iram_int_disabled>)
4037652b:	a08780        	addx4	a8, a7, a8
4037652e:	0028a2        	l32i	a10, a8, 0
    if (!non_iram_int_disabled_flag[cpu]) {
40376531:	f86b81        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94ab8 <non_iram_int_disabled_flag>)
40376534:	808870        	add	a8, a8, a7
40376537:	000882        	l8ui	a8, a8, 0
4037653a:	002856        	bnez	a8, 40376540 <esp_intr_noniram_enable+0x3c>
        abort();
4037653d:	097565        	call8	4037fc94 <abort>
    }
    non_iram_int_disabled_flag[cpu] = false;
40376540:	f86881        	l32r	a8, 403746e0 <_iram_text_start+0x2dc> (3fc94ab8 <non_iram_int_disabled_flag>)
40376543:	887a      	add.n	a8, a8, a7
40376545:	090c      	movi.n	a9, 0
40376547:	004892        	s8i	a9, a8, 0
    xt_ints_on(intr_mask);
4037654a:	0b95e5        	call8	40381ea8 <xt_ints_on>
    esp_cpu_intr_enable(non_iram_ints);
    rtc_isr_noniram_enable(cpu);
4037654d:	07ad      	mov.n	a10, a7
4037654f:	002165        	call8	40376764 <rtc_isr_noniram_enable>
    if (xPortInIsrContext()) {
40376552:	03bba5        	call8	4037a10c <xPortInIsrContext>
40376555:	7a8c      	beqz.n	a10, 40376560 <esp_intr_noniram_enable+0x5c>
        portEXIT_CRITICAL_ISR(mux);
40376557:	f860a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
4037655a:	03d265        	call8	4037a280 <vPortExitCritical>
4037655d:	000146        	j	40376566 <esp_intr_noniram_enable+0x62>
        portEXIT_CRITICAL(mux);
40376560:	f85ea1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
40376563:	03d1e5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
40376566:	f01d      	retw.n

40376568 <esp_intr_enable_source>:
void IRAM_ATTR ets_isr_mask(uint32_t mask) {
    esp_cpu_intr_disable(mask);
}

void IRAM_ATTR esp_intr_enable_source(int inum)
{
40376568:	004136        	entry	a1, 32
4037656b:	1a0c      	movi.n	a10, 1
4037656d:	401200        	ssl	a2
40376570:	a1aa00        	sll	a10, a10
40376573:	0b9365        	call8	40381ea8 <xt_ints_on>
    esp_cpu_intr_enable(1 << inum);
}
40376576:	f01d      	retw.n

40376578 <esp_intr_disable_source>:

void IRAM_ATTR esp_intr_disable_source(int inum)
{
40376578:	004136        	entry	a1, 32
    xt_ints_off(intr_mask);
4037657b:	1a0c      	movi.n	a10, 1
4037657d:	401200        	ssl	a2
40376580:	a1aa00        	sll	a10, a10
40376583:	0b93e5        	call8	40381ec0 <xt_ints_off>
    esp_cpu_intr_disable(1 << inum);
}
40376586:	f01d      	retw.n

40376588 <esp_intr_disable>:
{
40376588:	004136        	entry	a1, 32
    if (handle == NULL) {
4037658b:	0ea216        	beqz	a2, 40376679 <esp_intr_disable+0xf1>
    if (xPortInIsrContext()) {
4037658e:	03b7e5        	call8	4037a10c <xPortInIsrContext>
40376591:	00ca16        	beqz	a10, 403765a1 <esp_intr_disable+0x19>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376594:	ffafb2        	movi	a11, -1
40376597:	f850a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
4037659a:	03b965        	call8	4037a130 <xPortEnterCriticalTimeout>
4037659d:	000246        	j	403765aa <esp_intr_disable+0x22>
403765a0:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403765a3:	ff          	.byte	0xff
403765a4:	f84da1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
403765a7:	03b8a5        	call8	4037a130 <xPortEnterCriticalTimeout>
    if (handle->shared_vector_desc) {
403765aa:	012282        	l32i	a8, a2, 4
403765ad:	047816        	beqz	a8, 403765f8 <esp_intr_disable+0x70>
        handle->shared_vector_desc->disabled = 1;
403765b0:	001892        	l16ui	a9, a8, 0
403765b3:	1a0c      	movi.n	a10, 1
403765b5:	2099a0        	or	a9, a9, a10
403765b8:	005892        	s16i	a9, a8, 0
        source=handle->shared_vector_desc->source;
403765bb:	1288      	l32i.n	a8, a2, 4
403765bd:	08c8      	l32i.n	a12, a8, 0
403765bf:	74c1c0        	extui	a12, a12, 1, 8
403765c2:	23bc00        	sext	a11, a12, 7
        shared_vector_desc_t *svd = handle->vector_desc->shared_vec_info;
403765c5:	0288      	l32i.n	a8, a2, 0
403765c7:	1898      	l32i.n	a9, a8, 4
        assert(svd != NULL);
403765c9:	39ec      	bnez.n	a9, 403765f0 <esp_intr_disable+0x68>
403765cb:	f847d1        	l32r	a13, 403746e8 <_iram_text_start+0x2e4> (3c0234a4 <_flash_rodata_start+0x3384>)
403765ce:	f847c1        	l32r	a12, 403746ec <_iram_text_start+0x2e8> (3c027b20 <__func__$0>)
403765d1:	62a3b2        	movi	a11, 0x362
403765d4:	f847a1        	l32r	a10, 403746f0 <_iram_text_start+0x2ec> (3c0234d0 <_flash_rodata_start+0x33b0>)
403765d7:	0977a5        	call8	4037fd50 <__assert_func>
            if (svd->source == source && !svd->disabled) {
403765da:	0988      	l32i.n	a8, a9, 0
403765dc:	748180        	extui	a8, a8, 1, 8
403765df:	23ac00        	sext	a10, a12, 7
403765e2:	238800        	sext	a8, a8, 7
403765e5:	059a87        	bne	a10, a8, 403765ee <esp_intr_disable+0x66>
403765e8:	001982        	l16ui	a8, a9, 0
403765eb:	1a6807        	bbci	a8, 0, 40376609 <esp_intr_disable+0x81>
            svd = svd->next;
403765ee:	5998      	l32i.n	a9, a9, 20
        while(svd) {
403765f0:	fe6956        	bnez	a9, 403765da <esp_intr_disable+0x52>
    bool disabled = true;
403765f3:	180c      	movi.n	a8, 1
403765f5:	000486        	j	4037660b <esp_intr_disable+0x83>
        source=handle->vector_desc->source;
403765f8:	0288      	l32i.n	a8, a2, 0
403765fa:	08b8      	l32i.n	a11, a8, 0
403765fc:	75b6b0        	extui	a11, a11, 22, 8
403765ff:	23bb00        	sext	a11, a11, 7
    bool disabled = true;
40376602:	180c      	movi.n	a8, 1
40376604:	0000c6        	j	4037660b <esp_intr_disable+0x83>
40376607:	0c0000        	lsi	f0, a0, 48
                disabled = false;
4037660a:	9608      	l32i.n	a0, a6, 36
    if (source >= 0) {
4037660c:	015b      	addi.n	a0, a1, 5
        if (disabled) {
4037660e:	048816        	beqz	a8, 4037665a <esp_intr_disable+0xd2>
            esp_rom_route_intr_matrix(handle->vector_desc->cpu, source, INT_MUX_DISABLED_INTNO);
40376611:	0288      	l32i.n	a8, a2, 0
40376613:	08a8      	l32i.n	a10, a8, 0
40376615:	6c0c      	movi.n	a12, 6
40376617:	05a0a0        	extui	a10, a10, 16, 1
4037661a:	f83681        	l32r	a8, 403746f4 <_iram_text_start+0x2f0> (40001b54 <esp_rom_route_intr_matrix>)
4037661d:	0008e0        	callx8	a8
40376620:	000d86        	j	4037665a <esp_intr_disable+0xd2>
40376623:	229200        	orb	b9, b2, b0
        if (handle->vector_desc->cpu != esp_cpu_get_core_id()) {
40376626:	298200        	lsi	f0, a2, 164
40376629:	808000        	add	a8, a0, a0
4037662c:	eba005        	call0	40362030 <rom_rx_gain_force+0x35bc04>
4037662f:	ada003        	lsi	f0, a0, 0x2b4
40376632:	18a704        	lsi	f0, a7, 96
40376635:	651a      	add.n	a6, a5, a1
    if (xPortInIsrContext()) {
40376637:	03ad      	mov.n	a10, a3
40376639:	7a8c      	beqz.n	a10, 40376644 <esp_intr_disable+0xbc>
        portEXIT_CRITICAL_ISR(mux);
4037663b:	f827a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
4037663e:	03c425        	call8	4037a280 <vPortExitCritical>
40376641:	000146        	j	4037664a <esp_intr_disable+0xc2>
        portEXIT_CRITICAL(mux);
40376644:	f825a1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
40376647:	03c3a5        	call8	4037a280 <vPortExitCritical>
            return ESP_ERR_INVALID_ARG; //Can only enable these ints on this cpu
4037664a:	02a122        	movi	a2, 0x102
4037664d:	000ac6        	j	4037667c <esp_intr_disable+0xf4>
40376650:	29a200        	lsi	f0, a2, 164
        ESP_INTR_DISABLE(handle->vector_desc->intno);
40376653:	a1a000        	sll	a10, a0
40376656:	f22545        	call0	403688ac <rom_rx_gain_force+0x362480>
40376659:	ff          	.byte	0xff
    if (xPortInIsrContext()) {
4037665a:	03ab25        	call8	4037a10c <xPortInIsrContext>
4037665d:	0a2d      	mov.n	a2, a10
4037665f:	00aa16        	beqz	a10, 4037666d <esp_intr_disable+0xe5>
        portEXIT_CRITICAL_ISR(mux);
40376662:	f81da1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
40376665:	03c1a5        	call8	4037a280 <vPortExitCritical>
    return ESP_OK;
40376668:	020c      	movi.n	a2, 0
4037666a:	000386        	j	4037667c <esp_intr_disable+0xf4>
        portEXIT_CRITICAL(mux);
4037666d:	f81aa1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3fc91f50 <spinlock>)
40376670:	03c0e5        	call8	4037a280 <vPortExitCritical>
40376673:	000146        	j	4037667c <esp_intr_disable+0xf4>
40376676:	000000        	ill
        return ESP_ERR_INVALID_ARG;
40376679:	02a122        	movi	a2, 0x102
}
4037667c:	f01d      	retw.n
	...

40376680 <periph_rcc_enter>:
static portMUX_TYPE periph_spinlock = portMUX_INITIALIZER_UNLOCKED;

static uint8_t ref_counts[PERIPH_MODULE_MAX] = {0};

IRAM_ATTR void periph_rcc_enter(void)
{
40376680:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40376683:	03a8a5        	call8	4037a10c <xPortInIsrContext>
40376686:	00ba16        	beqz	a10, 40376695 <periph_rcc_enter+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376689:	ffafb2        	movi	a11, -1
4037668c:	f81ba1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc91f58 <periph_spinlock>)
4037668f:	03aa25        	call8	4037a130 <xPortEnterCriticalTimeout>
40376692:	0001c6        	j	4037669d <periph_rcc_enter+0x1d>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
40376695:	fb7c      	movi.n	a11, -1
40376697:	f818a1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc91f58 <periph_spinlock>)
4037669a:	03a965        	call8	4037a130 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL_SAFE(&periph_spinlock);
}
4037669d:	f01d      	retw.n
	...

403766a0 <periph_rcc_exit>:

IRAM_ATTR void periph_rcc_exit(void)
{
403766a0:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403766a3:	03a6a5        	call8	4037a10c <xPortInIsrContext>
403766a6:	aa8c      	beqz.n	a10, 403766b4 <periph_rcc_exit+0x14>
        portEXIT_CRITICAL_ISR(mux);
403766a8:	f814a1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc91f58 <periph_spinlock>)
403766ab:	03bd65        	call8	4037a280 <vPortExitCritical>
403766ae:	000206        	j	403766ba <periph_rcc_exit+0x1a>
403766b1:	000000        	ill
        portEXIT_CRITICAL(mux);
403766b4:	f811a1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc91f58 <periph_spinlock>)
403766b7:	03bca5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
}
403766ba:	f01d      	retw.n

403766bc <periph_rcc_acquire_enter>:

IRAM_ATTR uint8_t periph_rcc_acquire_enter(periph_module_t periph)
{
403766bc:	004136        	entry	a1, 32
    periph_rcc_enter();
403766bf:	fffc25        	call8	40376680 <periph_rcc_enter>
    return ref_counts[periph];
403766c2:	f80e81        	l32r	a8, 403746fc <_iram_text_start+0x2f8> (3fc94ad0 <ref_counts>)
403766c5:	282a      	add.n	a2, a8, a2
}
403766c7:	000222        	l8ui	a2, a2, 0
403766ca:	f01d      	retw.n

403766cc <periph_rcc_acquire_exit>:

IRAM_ATTR void periph_rcc_acquire_exit(periph_module_t periph, uint8_t ref_count)
{
403766cc:	004136        	entry	a1, 32
403766cf:	743030        	extui	a3, a3, 0, 8
    ref_counts[periph] = ++ref_count;
403766d2:	f80a81        	l32r	a8, 403746fc <_iram_text_start+0x2f8> (3fc94ad0 <ref_counts>)
403766d5:	808820        	add	a8, a8, a2
403766d8:	01c332        	addi	a3, a3, 1
403766db:	004832        	s8i	a3, a8, 0
    periph_rcc_exit();
403766de:	fffc25        	call8	403766a0 <periph_rcc_exit>
}
403766e1:	000090        	retw

403766e4 <rtc_isr>:
        SLIST_HEAD_INITIALIZER(s_rtc_isr_handler_list);
static DRAM_ATTR portMUX_TYPE s_rtc_isr_handler_list_lock = portMUX_INITIALIZER_UNLOCKED;
static intr_handle_t s_rtc_isr_handle;

IRAM_ATTR static void rtc_isr(void* arg)
{
403766e4:	004136        	entry	a1, 32
    uint32_t status = REG_READ(RTC_CNTL_INT_ST_REG);
403766e7:	f80681        	l32r	a8, 40374700 <_iram_text_start+0x2fc> (60008048 <RTCCNTL+0x48>)
403766ea:	0020c0        	memw
403766ed:	0868      	l32i.n	a6, a8, 0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403766ef:	ffafb2        	movi	a11, -1
403766f2:	f804a1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc9291c <s_rtc_isr_handler_list_lock>)
403766f5:	03a3a5        	call8	4037a130 <xPortEnterCriticalTimeout>
    rtc_isr_handler_t* it;
    portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
403766f8:	f80481        	l32r	a8, 40374708 <_iram_text_start+0x304> (3fc92924 <s_rtc_isr_handler_list>)
403766fb:	0878      	l32i.n	a7, a8, 0
403766fd:	000706        	j	4037671d <rtc_isr+0x39>
        if (it->mask & status) {
40376700:	002782        	l32i	a8, a7, 0
40376703:	140867        	bnone	a8, a6, 4037671b <rtc_isr+0x37>
            portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
40376706:	f7ffa1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc9291c <s_rtc_isr_handler_list_lock>)
40376709:	03b765        	call8	4037a280 <vPortExitCritical>
            (*it->handler)(it->handler_arg);
4037670c:	1788      	l32i.n	a8, a7, 4
4037670e:	27a8      	l32i.n	a10, a7, 8
40376710:	0008e0        	callx8	a8
40376713:	fb7c      	movi.n	a11, -1
40376715:	f7fba1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc9291c <s_rtc_isr_handler_list_lock>)
40376718:	03a165        	call8	4037a130 <xPortEnterCriticalTimeout>
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
4037671b:	4778      	l32i.n	a7, a7, 16
4037671d:	fdf756        	bnez	a7, 40376700 <rtc_isr+0x1c>
            portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
        }
    }
    portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
40376720:	f7f9a1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc9291c <s_rtc_isr_handler_list_lock>)
40376723:	03b5e5        	call8	4037a280 <vPortExitCritical>
    REG_WRITE(RTC_CNTL_INT_CLR_REG, status);
40376726:	f7f981        	l32r	a8, 4037470c <_iram_text_start+0x308> (6000804c <RTCCNTL+0x4c>)
40376729:	0020c0        	memw
4037672c:	0869      	s32i.n	a6, a8, 0
}
4037672e:	f01d      	retw.n

40376730 <rtc_isr_noniram_disable>:
}
#endif


IRAM_ATTR void rtc_isr_noniram_disable(uint32_t cpu)
{
40376730:	004136        	entry	a1, 32
#if SOC_LP_PERIPH_SHARE_INTERRUPT // TODO: IDF-8008
    if (rtc_isr_cpu == cpu) {
40376733:	f7f781        	l32r	a8, 40374710 <_iram_text_start+0x30c> (3fc92928 <rtc_isr_cpu>)
40376736:	0888      	l32i.n	a8, a8, 0
40376738:	269827        	bne	a8, a2, 40376762 <rtc_isr_noniram_disable+0x32>
        rtc_intr_enabled |= RTCCNTL.int_ena.val;
4037673b:	f76981        	l32r	a8, 403744e0 <_iram_text_start+0xdc> (60008000 <RTCCNTL>)
4037673e:	0020c0        	memw
40376741:	1028b2        	l32i	a11, a8, 64
40376744:	f7f4a1        	l32r	a10, 40374714 <_iram_text_start+0x310> (3fc9292c <rtc_intr_enabled>)
40376747:	0a98      	l32i.n	a9, a10, 0
40376749:	2099b0        	or	a9, a9, a11
4037674c:	0a99      	s32i.n	a9, a10, 0
        RTCCNTL.int_ena.val &= rtc_intr_cache;
4037674e:	0020c0        	memw
40376751:	102892        	l32i	a9, a8, 64
40376754:	f7f1a1        	l32r	a10, 40374718 <_iram_text_start+0x314> (3fc92930 <rtc_intr_cache>)
40376757:	0aa8      	l32i.n	a10, a10, 0
40376759:	1099a0        	and	a9, a9, a10
4037675c:	0020c0        	memw
4037675f:	106892        	s32i	a9, a8, 64
    }
#endif
}
40376762:	f01d      	retw.n

40376764 <rtc_isr_noniram_enable>:

IRAM_ATTR void rtc_isr_noniram_enable(uint32_t cpu)
{
40376764:	004136        	entry	a1, 32
#if SOC_LP_PERIPH_SHARE_INTERRUPT // TODO: IDF-8008
    if (rtc_isr_cpu == cpu) {
40376767:	f7ea81        	l32r	a8, 40374710 <_iram_text_start+0x30c> (3fc92928 <rtc_isr_cpu>)
4037676a:	0888      	l32i.n	a8, a8, 0
4037676c:	119827        	bne	a8, a2, 40376781 <rtc_isr_noniram_enable+0x1d>
        RTCCNTL.int_ena.val = rtc_intr_enabled;
4037676f:	f7e981        	l32r	a8, 40374714 <_iram_text_start+0x310> (3fc9292c <rtc_intr_enabled>)
40376772:	08a8      	l32i.n	a10, a8, 0
40376774:	f75b91        	l32r	a9, 403744e0 <_iram_text_start+0xdc> (60008000 <RTCCNTL>)
40376777:	0020c0        	memw
4037677a:	1069a2        	s32i	a10, a9, 64
        rtc_intr_enabled = 0;
4037677d:	090c      	movi.n	a9, 0
4037677f:	0899      	s32i.n	a9, a8, 0
    }
#endif
}
40376781:	f01d      	retw.n
	...

40376784 <regi2c_ctrl_read_reg_mask>:
    REGI2C_CLOCK_DISABLE();
    return value;
}

uint8_t IRAM_ATTR regi2c_ctrl_read_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb)
{
40376784:	004136        	entry	a1, 32
40376787:	742020        	extui	a2, a2, 0, 8
4037678a:	743030        	extui	a3, a3, 0, 8
4037678d:	744040        	extui	a4, a4, 0, 8
40376790:	745050        	extui	a5, a5, 0, 8
40376793:	746060        	extui	a6, a6, 0, 8
    if (xPortInIsrContext()) {
40376796:	039765        	call8	4037a10c <xPortInIsrContext>
40376799:	00ca16        	beqz	a10, 403767a9 <regi2c_ctrl_read_reg_mask+0x25>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037679c:	ffafb2        	movi	a11, -1
4037679f:	f7dfa1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
403767a2:	0398e5        	call8	4037a130 <xPortEnterCriticalTimeout>
403767a5:	000246        	j	403767b2 <regi2c_ctrl_read_reg_mask+0x2e>
403767a8:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403767ab:	ff          	.byte	0xff
403767ac:	f7dca1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
403767af:	039825        	call8	4037a130 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    uint8_t value = regi2c_read_reg_mask_raw(block, host_id, reg_add, msb, lsb);
403767b2:	06ed      	mov.n	a14, a6
403767b4:	05dd      	mov.n	a13, a5
403767b6:	04cd      	mov.n	a12, a4
403767b8:	03bd      	mov.n	a11, a3
403767ba:	20a220        	or	a10, a2, a2
403767bd:	f7d881        	l32r	a8, 40374720 <_iram_text_start+0x31c> (40005d54 <esp_rom_regi2c_read_mask>)
403767c0:	0008e0        	callx8	a8
403767c3:	0a2d      	mov.n	a2, a10
    if (xPortInIsrContext()) {
403767c5:	039465        	call8	4037a10c <xPortInIsrContext>
403767c8:	8a8c      	beqz.n	a10, 403767d4 <regi2c_ctrl_read_reg_mask+0x50>
        portEXIT_CRITICAL_ISR(mux);
403767ca:	f7d4a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
403767cd:	03ab25        	call8	4037a280 <vPortExitCritical>
403767d0:	000186        	j	403767da <regi2c_ctrl_read_reg_mask+0x56>
403767d3:	d2a100        	quos	a10, a1, a0
        portEXIT_CRITICAL(mux);
403767d6:	aaa5f7        	bge	a5, a15, 40376784 <regi2c_ctrl_read_reg_mask>
403767d9:	f01d03        	lsi	f0, a13, 0x3c0

403767dc <regi2c_ctrl_write_reg>:
    REGI2C_CLOCK_DISABLE();
    return value;
}

void IRAM_ATTR regi2c_ctrl_write_reg(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t data)
{
403767dc:	004136        	entry	a1, 32
403767df:	742020        	extui	a2, a2, 0, 8
403767e2:	743030        	extui	a3, a3, 0, 8
403767e5:	744040        	extui	a4, a4, 0, 8
403767e8:	745050        	extui	a5, a5, 0, 8
    if (xPortInIsrContext()) {
403767eb:	039225        	call8	4037a10c <xPortInIsrContext>
403767ee:	00ba16        	beqz	a10, 403767fd <regi2c_ctrl_write_reg+0x21>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
403767f1:	fb7c      	movi.n	a11, -1
403767f3:	f7caa1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
403767f6:	0393a5        	call8	4037a130 <xPortEnterCriticalTimeout>
403767f9:	000246        	j	40376806 <regi2c_ctrl_write_reg+0x2a>
403767fc:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403767ff:	ff          	.byte	0xff
40376800:	f7c7a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
40376803:	0392e5        	call8	4037a130 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_raw(block, host_id, reg_add, data);
40376806:	05dd      	mov.n	a13, a5
40376808:	20c440        	or	a12, a4, a4
4037680b:	20b330        	or	a11, a3, a3
4037680e:	02ad      	mov.n	a10, a2
40376810:	f7c581        	l32r	a8, 40374724 <_iram_text_start+0x320> (40005d60 <esp_rom_regi2c_write>)
40376813:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
40376816:	038f65        	call8	4037a10c <xPortInIsrContext>
40376819:	7a8c      	beqz.n	a10, 40376824 <regi2c_ctrl_write_reg+0x48>
        portEXIT_CRITICAL_ISR(mux);
4037681b:	f7c0a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
4037681e:	03a625        	call8	4037a280 <vPortExitCritical>
40376821:	000146        	j	4037682a <regi2c_ctrl_write_reg+0x4e>
        portEXIT_CRITICAL(mux);
40376824:	f7bea1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
40376827:	03a5a5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    REGI2C_CLOCK_DISABLE();
}
4037682a:	f01d      	retw.n

4037682c <regi2c_ctrl_write_reg_mask>:

void IRAM_ATTR regi2c_ctrl_write_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb, uint8_t data)
{
4037682c:	004136        	entry	a1, 32
4037682f:	742020        	extui	a2, a2, 0, 8
40376832:	743030        	extui	a3, a3, 0, 8
40376835:	744040        	extui	a4, a4, 0, 8
40376838:	745050        	extui	a5, a5, 0, 8
4037683b:	746060        	extui	a6, a6, 0, 8
4037683e:	747070        	extui	a7, a7, 0, 8
    if (xPortInIsrContext()) {
40376841:	038ca5        	call8	4037a10c <xPortInIsrContext>
40376844:	00da16        	beqz	a10, 40376855 <regi2c_ctrl_write_reg_mask+0x29>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376847:	ffafb2        	movi	a11, -1
4037684a:	f7b4a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
4037684d:	038e25        	call8	4037a130 <xPortEnterCriticalTimeout>
40376850:	000286        	j	4037685e <regi2c_ctrl_write_reg_mask+0x32>
40376853:	b20000        	mulsh	a0, a0, a0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
40376856:	af          	.byte	0xaf
40376857:	ff          	.byte	0xff
40376858:	f7b1a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
4037685b:	038d65        	call8	4037a130 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_mask_raw(block, host_id, reg_add, msb, lsb, data);
4037685e:	07fd      	mov.n	a15, a7
40376860:	06ed      	mov.n	a14, a6
40376862:	05dd      	mov.n	a13, a5
40376864:	20c440        	or	a12, a4, a4
40376867:	20b330        	or	a11, a3, a3
4037686a:	02ad      	mov.n	a10, a2
4037686c:	f7af81        	l32r	a8, 40374728 <_iram_text_start+0x324> (40005d6c <esp_rom_regi2c_write_mask>)
4037686f:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
40376872:	0389a5        	call8	4037a10c <xPortInIsrContext>
40376875:	7a8c      	beqz.n	a10, 40376880 <regi2c_ctrl_write_reg_mask+0x54>
        portEXIT_CRITICAL_ISR(mux);
40376877:	f7a9a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
4037687a:	03a065        	call8	4037a280 <vPortExitCritical>
4037687d:	000146        	j	40376886 <regi2c_ctrl_write_reg_mask+0x5a>
        portEXIT_CRITICAL(mux);
40376880:	f7a7a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3fc91f60 <mux>)
40376883:	039fe5        	call8	4037a280 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    REGI2C_CLOCK_DISABLE();
}
40376886:	f01d      	retw.n

40376888 <xPortInterruptedFromISRContext>:
    /* Assert if the interrupt nesting count is > 0 */
    configASSERT(xPortInIsrContext() == 0);
}

BaseType_t IRAM_ATTR xPortInterruptedFromISRContext(void)
{
40376888:	004136        	entry	a1, 32
4037688b:	03eb80        	rsr.prid	a8
4037688e:	048d80        	extui	a8, a8, 13, 1
    return (port_interruptNesting[xPortGetCoreID()] != 0);
40376891:	f7a691        	l32r	a9, 4037472c <_iram_text_start+0x328> (3fc94de0 <port_interruptNesting>)
40376894:	a08890        	addx4	a8, a8, a9
40376897:	0828      	l32i.n	a2, a8, 0
}
40376899:	180c      	movi.n	a8, 1
4037689b:	932820        	movnez	a2, a8, a2
4037689e:	f01d      	retw.n

403768a0 <lock_init_generic>:

   Called by _lock_init*, also called by _lock_acquire* to lazily initialize locks that might have
   been initialised (to zero only) before the RTOS scheduler started.
*/
static void IRAM_ATTR lock_init_generic(_lock_t *lock, uint8_t mutex_type)
{
403768a0:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403768a3:	ffafb2        	movi	a11, -1
403768a6:	f7a2a1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92000 <lock_init_spinlock>)
403768a9:	038865        	call8	4037a130 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL(&lock_init_spinlock);
    if (*lock) {
403768ac:	0288      	l32i.n	a8, a2, 0
403768ae:	a8cc      	bnez.n	a8, 403768bc <lock_init_generic+0x1c>
           implements these as macros instead of inline functions
           (*party like it's 1998!*) it's not possible to do this
           without writing wrappers. Doing it this way seems much less
           spaghetti-like.
        */
        SemaphoreHandle_t new_sem = xQueueCreateMutex(mutex_type);
403768b0:	03ad      	mov.n	a10, a3
403768b2:	0339e5        	call8	40379c50 <xQueueCreateMutex>
        if (!new_sem) {
403768b5:	1acc      	bnez.n	a10, 403768ba <lock_init_generic+0x1a>
            abort(); /* No more semaphores available or OOM */
403768b7:	093de5        	call8	4037fc94 <abort>
        }
        *lock = (_lock_t)new_sem;
403768ba:	02a9      	s32i.n	a10, a2, 0
    }
    portEXIT_CRITICAL(&lock_init_spinlock);
403768bc:	f79da1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92000 <lock_init_spinlock>)
403768bf:	039c25        	call8	4037a280 <vPortExitCritical>
}
403768c2:	f01d      	retw.n

403768c4 <check_lock_nonzero>:
    _lock_close_recursive(&lock);
}

/* Separate function, to prevent generating multiple assert strings */
static void IRAM_ATTR check_lock_nonzero(_LOCK_T lock)
{
403768c4:	004136        	entry	a1, 32
    assert(lock != NULL && "Uninitialized lock used");
403768c7:	00e256        	bnez	a2, 403768d9 <check_lock_nonzero+0x15>
403768ca:	f79ad1        	l32r	a13, 40374734 <_iram_text_start+0x330> (3c024da4 <_flash_rodata_start+0x4c84>)
403768cd:	f79ac1        	l32r	a12, 40374738 <_iram_text_start+0x334> (3c028290 <__func__$3>)
403768d0:	39a1b2        	movi	a11, 0x139
403768d3:	f79aa1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
403768d6:	0947a5        	call8	4037fd50 <__assert_func>
}
403768d9:	f01d      	retw.n
	...

403768dc <lock_acquire_generic>:
{
403768dc:	006136        	entry	a1, 48
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
403768df:	002272        	l32i	a7, a2, 0
    if (!h) {
403768e2:	27ec      	bnez.n	a7, 40376908 <lock_acquire_generic+0x2c>
        if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
403768e4:	051465        	call8	4037ba2c <xTaskGetSchedulerState>
403768e7:	021a66        	bnei	a10, 1, 403768ed <lock_acquire_generic+0x11>
403768ea:	002106        	j	40376972 <lock_acquire_generic+0x96>
        lock_init_generic(lock, mutex_type);
403768ed:	04bd      	mov.n	a11, a4
403768ef:	20a220        	or	a10, a2, a2
403768f2:	fffae5        	call8	403768a0 <lock_init_generic>
        h = (SemaphoreHandle_t)(*lock);
403768f5:	0278      	l32i.n	a7, a2, 0
        configASSERT(h != NULL);
403768f7:	d7cc      	bnez.n	a7, 40376908 <lock_acquire_generic+0x2c>
403768f9:	f791d1        	l32r	a13, 40374740 <_iram_text_start+0x33c> (3c024df4 <_flash_rodata_start+0x4cd4>)
403768fc:	f792c1        	l32r	a12, 40374744 <_iram_text_start+0x340> (3c0282bc <__func__$1>)
403768ff:	81a0b2        	movi	a11, 129
40376902:	f78ea1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
40376905:	0944a5        	call8	4037fd50 <__assert_func>
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376908:	201110        	or	a1, a1, a1
4037690b:	051225        	call8	4037ba2c <xTaskGetSchedulerState>
4037690e:	661a26        	beqi	a10, 1, 40376978 <lock_acquire_generic+0x9c>
FORCE_INLINE_ATTR bool xPortCanYield(void)
{
    uint32_t ps_reg = 0;

    //Get the current value of PS (processor status) register
    RSR(PS, ps_reg);
40376911:	03e680        	rsr.ps	a8
     * excm  = (ps_reg >> 4) & 0x1;
     * CINTLEVEL is max(excm * EXCMLEVEL, INTLEVEL), where EXCMLEVEL is 3.
     * However, just return true, only intlevel is zero.
     */

    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
40376914:	348080        	extui	a8, a8, 0, 4
    if (!xPortCanYield()) {
40376917:	18bc      	beqz.n	a8, 4037694c <lock_acquire_generic+0x70>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
40376919:	054466        	bnei	a4, 4, 40376922 <lock_acquire_generic+0x46>
            abort(); /* recursive mutexes make no sense in ISR context */
4037691c:	201110        	or	a1, a1, a1
4037691f:	093765        	call8	4037fc94 <abort>
        BaseType_t higher_task_woken = false;
40376922:	00a0b2        	movi	a11, 0
40376925:	0061b2        	s32i	a11, a1, 0
        success = xSemaphoreTakeFromISR(h, &higher_task_woken);
40376928:	01cd      	mov.n	a12, a1
4037692a:	07ad      	mov.n	a10, a7
4037692c:	0359e5        	call8	40379ecc <xQueueReceiveFromISR>
4037692f:	0a2d      	mov.n	a2, a10
        if (!success && delay > 0) {
40376931:	40fa80        	nsau	a8, a10
40376934:	418580        	srli	a8, a8, 5
40376937:	190c      	movi.n	a9, 1
40376939:	839330        	moveqz	a9, a3, a3
4037693c:	020897        	bnone	a8, a9, 40376942 <lock_acquire_generic+0x66>
            abort(); /* Tried to block on mutex from ISR, couldn't... rewrite your program to avoid libc interactions in ISRs! */
4037693f:	093565        	call8	4037fc94 <abort>
        if (higher_task_woken) {
40376942:	0188      	l32i.n	a8, a1, 0
40376944:	28ac      	beqz.n	a8, 4037696a <lock_acquire_generic+0x8e>
            portYIELD_FROM_ISR();
40376946:	03a365        	call8	4037a37c <_frxt_setup_switch>
40376949:	000746        	j	4037696a <lock_acquire_generic+0x8e>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
4037694c:	0e4466        	bnei	a4, 4, 4037695e <lock_acquire_generic+0x82>
            success = xSemaphoreTakeRecursive(h, delay);
4037694f:	20b330        	or	a11, a3, a3
40376952:	20a770        	or	a10, a7, a7
40376955:	035325        	call8	40379e88 <xQueueTakeMutexRecursive>
40376958:	202aa0        	or	a2, a10, a10
4037695b:	0002c6        	j	4037696a <lock_acquire_generic+0x8e>
            success = xSemaphoreTake(h, delay);
4037695e:	20b330        	or	a11, a3, a3
40376961:	20a770        	or	a10, a7, a7
40376964:	0341a5        	call8	40379d80 <xQueueSemaphoreTake>
40376967:	202aa0        	or	a2, a10, a10
    return (success == pdTRUE) ? 0 : -1;
4037696a:	0f1266        	bnei	a2, 1, 4037697d <lock_acquire_generic+0xa1>
4037696d:	020c      	movi.n	a2, 0
4037696f:	000306        	j	4037697f <lock_acquire_generic+0xa3>
            return 0; /* locking is a no-op before scheduler is up, so this "succeeds" */
40376972:	020c      	movi.n	a2, 0
40376974:	0001c6        	j	4037697f <lock_acquire_generic+0xa3>
40376977:	020c00        	andb	b0, b12, b0
        return 0; /* locking is a no-op before scheduler is up, so this "succeeds" */
4037697a:	000046        	j	4037697f <lock_acquire_generic+0xa3>
    return (success == pdTRUE) ? 0 : -1;
4037697d:	f27c      	movi.n	a2, -1
}
4037697f:	f01d      	retw.n
40376981:	000000        	ill

40376984 <lock_release_generic>:
{
40376984:	006136        	entry	a1, 48
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376987:	050a65        	call8	4037ba2c <xTaskGetSchedulerState>
4037698a:	521a26        	beqi	a10, 1, 403769e0 <lock_release_generic+0x5c>
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
4037698d:	0022a2        	l32i	a10, a2, 0
    assert(h);
40376990:	00ea56        	bnez	a10, 403769a2 <lock_release_generic+0x1e>
40376993:	f76dd1        	l32r	a13, 40374748 <_iram_text_start+0x344> (3c022b98 <_flash_rodata_start+0x2a78>)
40376996:	f76dc1        	l32r	a12, 4037474c <_iram_text_start+0x348> (3c0282a4 <__func__$2>)
40376999:	bea0b2        	movi	a11, 190
4037699c:	f768a1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
4037699f:	093b25        	call8	4037fd50 <__assert_func>
    RSR(PS, ps_reg);
403769a2:	03e680        	rsr.ps	a8
    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
403769a5:	348080        	extui	a8, a8, 0, 4
    if (!xPortCanYield()) {
403769a8:	01c816        	beqz	a8, 403769c8 <lock_release_generic+0x44>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
403769ab:	024366        	bnei	a3, 4, 403769b1 <lock_release_generic+0x2d>
            abort(); /* indicates logic bug, it shouldn't be possible to lock recursively in ISR */
403769ae:	092e65        	call8	4037fc94 <abort>
        BaseType_t higher_task_woken = false;
403769b1:	00a082        	movi	a8, 0
403769b4:	006182        	s32i	a8, a1, 0
        xSemaphoreGiveFromISR(h, &higher_task_woken);
403769b7:	20b110        	or	a11, a1, a1
403769ba:	0330a5        	call8	40379cc4 <xQueueGiveFromISR>
        if (higher_task_woken) {
403769bd:	0188      	l32i.n	a8, a1, 0
403769bf:	d89c      	beqz.n	a8, 403769e0 <lock_release_generic+0x5c>
            portYIELD_FROM_ISR();
403769c1:	039ba5        	call8	4037a37c <_frxt_setup_switch>
403769c4:	000606        	j	403769e0 <lock_release_generic+0x5c>
403769c7:	436600        	min	a6, a6, a0
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
403769ca:	a508      	l32i.n	a0, a5, 40
            xSemaphoreGiveRecursive(h);
403769cc:	032b      	addi.n	a0, a3, 2
403769ce:	000386        	j	403769e0 <lock_release_generic+0x5c>
403769d1:	000000        	ill
            xSemaphoreGive(h);
403769d4:	00a0d2        	movi	a13, 0
403769d7:	20cdd0        	or	a12, a13, a13
403769da:	20bdd0        	or	a11, a13, a13
403769dd:	030fa5        	call8	40379ad8 <xQueueGenericSend>
}
403769e0:	f01d      	retw.n
	...

403769e4 <_lock_close>:
{
403769e4:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403769e7:	ffafb2        	movi	a11, -1
403769ea:	f751a1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92000 <lock_init_spinlock>)
403769ed:	037425        	call8	4037a130 <xPortEnterCriticalTimeout>
    if (*lock) {
403769f0:	0278      	l32i.n	a7, a2, 0
403769f2:	d79c      	beqz.n	a7, 40376a13 <_lock_close+0x2f>
        configASSERT(xSemaphoreGetMutexHolder(h) == NULL); /* mutex should not be held */
403769f4:	07ad      	mov.n	a10, a7
403769f6:	030aa5        	call8	40379aa0 <xQueueGetMutexHolder>
403769f9:	da8c      	beqz.n	a10, 40376a0a <_lock_close+0x26>
403769fb:	f755d1        	l32r	a13, 40374750 <_iram_text_start+0x34c> (3c024e08 <_flash_rodata_start+0x4ce8>)
403769fe:	f755c1        	l32r	a12, 40374754 <_iram_text_start+0x350> (3c0282d4 <__func__$0>)
40376a01:	6aa0b2        	movi	a11, 106
40376a04:	f74ea1        	l32r	a10, 4037473c <_iram_text_start+0x338> (3c024dec <_flash_rodata_start+0x4ccc>)
40376a07:	0934a5        	call8	4037fd50 <__assert_func>
        vSemaphoreDelete(h);
40376a0a:	07ad      	mov.n	a10, a7
40376a0c:	035465        	call8	40379f54 <vQueueDelete>
        *lock = 0;
40376a0f:	080c      	movi.n	a8, 0
40376a11:	0289      	s32i.n	a8, a2, 0
    portEXIT_CRITICAL(&lock_init_spinlock);
40376a13:	f747a1        	l32r	a10, 40374730 <_iram_text_start+0x32c> (3fc92000 <lock_init_spinlock>)
40376a16:	0386a5        	call8	4037a280 <vPortExitCritical>
}
40376a19:	f01d      	retw.n
	...

40376a1c <_lock_acquire>:
{
40376a1c:	004136        	entry	a1, 32
40376a1f:	02ad      	mov.n	a10, a2
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_MUTEX);
40376a21:	1c0c      	movi.n	a12, 1
40376a23:	fb7c      	movi.n	a11, -1
40376a25:	ffeb65        	call8	403768dc <lock_acquire_generic>
}
40376a28:	f01d      	retw.n
	...

40376a2c <_lock_acquire_recursive>:
{
40376a2c:	004136        	entry	a1, 32
40376a2f:	02ad      	mov.n	a10, a2
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a31:	4c0c      	movi.n	a12, 4
40376a33:	fb7c      	movi.n	a11, -1
40376a35:	ffea65        	call8	403768dc <lock_acquire_generic>
}
40376a38:	f01d      	retw.n
	...

40376a3c <_lock_try_acquire>:
{
40376a3c:	004136        	entry	a1, 32
40376a3f:	02ad      	mov.n	a10, a2
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_MUTEX);
40376a41:	1c0c      	movi.n	a12, 1
40376a43:	0b0c      	movi.n	a11, 0
40376a45:	ffe965        	call8	403768dc <lock_acquire_generic>
}
40376a48:	0a2d      	mov.n	a2, a10
40376a4a:	f01d      	retw.n

40376a4c <_lock_try_acquire_recursive>:
{
40376a4c:	004136        	entry	a1, 32
40376a4f:	02ad      	mov.n	a10, a2
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a51:	4c0c      	movi.n	a12, 4
40376a53:	0b0c      	movi.n	a11, 0
40376a55:	ffe865        	call8	403768dc <lock_acquire_generic>
}
40376a58:	0a2d      	mov.n	a2, a10
40376a5a:	f01d      	retw.n

40376a5c <_lock_release>:
{
40376a5c:	004136        	entry	a1, 32
40376a5f:	20a220        	or	a10, a2, a2
    lock_release_generic(lock, queueQUEUE_TYPE_MUTEX);
40376a62:	01a0b2        	movi	a11, 1
40376a65:	fff1e5        	call8	40376984 <lock_release_generic>
}
40376a68:	000090        	retw
	...

40376a6c <_lock_release_recursive>:
{
40376a6c:	004136        	entry	a1, 32
40376a6f:	20a220        	or	a10, a2, a2
    lock_release_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a72:	04a0b2        	movi	a11, 4
40376a75:	fff0e5        	call8	40376984 <lock_release_generic>
}
40376a78:	000090        	retw
	...

40376a7c <__retarget_lock_init>:
{
40376a7c:	004136        	entry	a1, 32
40376a7f:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376a82:	00a082        	movi	a8, 0
40376a85:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_MUTEX);
40376a88:	1b0c      	movi.n	a11, 1
40376a8a:	ffe165        	call8	403768a0 <lock_init_generic>
}
40376a8d:	f01d      	retw.n
	...

40376a90 <__retarget_lock_init_recursive>:
{
40376a90:	004136        	entry	a1, 32
40376a93:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376a96:	00a082        	movi	a8, 0
40376a99:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a9c:	4b0c      	movi.n	a11, 4
40376a9e:	ffe025        	call8	403768a0 <lock_init_generic>
}
40376aa1:	f01d      	retw.n
	...

40376aa4 <__retarget_lock_close>:
{
40376aa4:	006136        	entry	a1, 48
40376aa7:	006122        	s32i	a2, a1, 0
    _lock_close(&lock);
40376aaa:	20a110        	or	a10, a1, a1
40376aad:	fff365        	call8	403769e4 <_lock_close>
}
40376ab0:	000090        	retw
	...

40376ab4 <__retarget_lock_close_recursive>:
{
40376ab4:	006136        	entry	a1, 48
40376ab7:	006122        	s32i	a2, a1, 0
    _lock_close_recursive(&lock);
40376aba:	20a110        	or	a10, a1, a1
40376abd:	fff265        	call8	403769e4 <_lock_close>
}
40376ac0:	000090        	retw
	...

40376ac4 <__retarget_lock_acquire>:

void IRAM_ATTR __retarget_lock_acquire(_LOCK_T lock)
{
40376ac4:	006136        	entry	a1, 48
40376ac7:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376ac9:	027d      	mov.n	a7, a2
40376acb:	02ad      	mov.n	a10, a2
40376acd:	ffdf65        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376ad0:	0298      	l32i.n	a9, a2, 0
40376ad2:	f72181        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376ad5:	049987        	bne	a9, a8, 40376add <__retarget_lock_acquire+0x19>
40376ad8:	f72181        	l32r	a8, 4037475c <_iram_text_start+0x358> (3fc94e58 <__lock___arc4random_mutex>)
40376adb:	0189      	s32i.n	a8, a1, 0
    _lock_acquire(&lock);
40376add:	01ad      	mov.n	a10, a1
40376adf:	fff3e5        	call8	40376a1c <_lock_acquire>
}
40376ae2:	f01d      	retw.n

40376ae4 <__retarget_lock_acquire_recursive>:

void IRAM_ATTR __retarget_lock_acquire_recursive(_LOCK_T lock)
{
40376ae4:	006136        	entry	a1, 48
40376ae7:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376ae9:	027d      	mov.n	a7, a2
40376aeb:	02ad      	mov.n	a10, a2
40376aed:	ffdd65        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376af0:	0298      	l32i.n	a9, a2, 0
40376af2:	f71981        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376af5:	049987        	bne	a9, a8, 40376afd <__retarget_lock_acquire_recursive+0x19>
40376af8:	f71a81        	l32r	a8, 40374760 <_iram_text_start+0x35c> (3fc94e04 <__lock___atexit_recursive_mutex>)
40376afb:	0189      	s32i.n	a8, a1, 0
    _lock_acquire_recursive(&lock);
40376afd:	01ad      	mov.n	a10, a1
40376aff:	fff2e5        	call8	40376a2c <_lock_acquire_recursive>
}
40376b02:	f01d      	retw.n

40376b04 <__retarget_lock_try_acquire>:

int IRAM_ATTR __retarget_lock_try_acquire(_LOCK_T lock)
{
40376b04:	006136        	entry	a1, 48
40376b07:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376b09:	027d      	mov.n	a7, a2
40376b0b:	02ad      	mov.n	a10, a2
40376b0d:	ffdb65        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376b10:	0298      	l32i.n	a9, a2, 0
40376b12:	f71181        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376b15:	049987        	bne	a9, a8, 40376b1d <__retarget_lock_try_acquire+0x19>
40376b18:	f71181        	l32r	a8, 4037475c <_iram_text_start+0x358> (3fc94e58 <__lock___arc4random_mutex>)
40376b1b:	0189      	s32i.n	a8, a1, 0
    return _lock_try_acquire(&lock);
40376b1d:	20a110        	or	a10, a1, a1
40376b20:	fff1a5        	call8	40376a3c <_lock_try_acquire>
}
40376b23:	202aa0        	or	a2, a10, a10
40376b26:	000090        	retw
40376b29:	000000        	ill

40376b2c <__retarget_lock_try_acquire_recursive>:

int IRAM_ATTR __retarget_lock_try_acquire_recursive(_LOCK_T lock)
{
40376b2c:	006136        	entry	a1, 48
40376b2f:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376b31:	027d      	mov.n	a7, a2
40376b33:	02ad      	mov.n	a10, a2
40376b35:	ffd8e5        	call8	403768c4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376b38:	0298      	l32i.n	a9, a2, 0
40376b3a:	f70781        	l32r	a8, 40374758 <_iram_text_start+0x354> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376b3d:	049987        	bne	a9, a8, 40376b45 <__retarget_lock_try_acquire_recursive+0x19>
40376b40:	f70881        	l32r	a8, 40374760 <_iram_text_start+0x35c> (3fc94e04 <__lock___atexit_recursive_mutex>)
40376b43:	0189      	s32i.n	a8, a1, 0
    return _lock_try_acquire_recursive(&lock);
40376b45:	20a110        	or	a10, a1, a1
40376b48:	fff025        	call8	40376a4c <_lock_try_acquire_recursive>
}
40376b4b:	202aa0        	or	a2, a10, a10
40376b4e:	000090        	retw
40376b51:	000000        	ill

40376b54 <__retarget_lock_release>:

void IRAM_ATTR __retarget_lock_release(_LOCK_T lock)
{
40376b54:	006136        	entry	a1, 48
40376b57:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376b5a:	20a220        	or	a10, a2, a2
40376b5d:	ffd665        	call8	403768c4 <check_lock_nonzero>
    _lock_release(&lock);
40376b60:	01ad      	mov.n	a10, a1
40376b62:	ffefa5        	call8	40376a5c <_lock_release>
}
40376b65:	f01d      	retw.n
	...

40376b68 <__retarget_lock_release_recursive>:

void IRAM_ATTR __retarget_lock_release_recursive(_LOCK_T lock)
{
40376b68:	006136        	entry	a1, 48
40376b6b:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376b6e:	20a220        	or	a10, a2, a2
40376b71:	ffd525        	call8	403768c4 <check_lock_nonzero>
    _lock_release_recursive(&lock);
40376b74:	01ad      	mov.n	a10, a1
40376b76:	ffef65        	call8	40376a6c <_lock_release_recursive>
}
40376b79:	f01d      	retw.n
	...

40376b7c <_gettimeofday_r>:
    _gettimeofday_r(r, &tv, NULL);
    return (clock_t) tv.tv_sec;
}

WEAK_UNLESS_TIMEFUNC_IMPL int IRAM_ATTR _gettimeofday_r(struct _reent *r, struct timeval *tv, void *tz)
{
40376b7c:	004136        	entry	a1, 32
    (void) tz;

#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
40376b7f:	041316        	beqz	a3, 40376bc4 <_gettimeofday_r+0x48>
        uint64_t microseconds = get_adjusted_boot_time() + esp_time_impl_get_time_since_boot();
40376b82:	f6f881        	l32r	a8, 40374764 <_iram_text_start+0x360> (42005bac <get_adjusted_boot_time>)
40376b85:	0008e0        	callx8	a8
40376b88:	206aa0        	or	a6, a10, a10
40376b8b:	207bb0        	or	a7, a11, a11
40376b8e:	f6f681        	l32r	a8, 40374768 <_iram_text_start+0x364> (42005c64 <esp_time_impl_get_time_since_boot>)
40376b91:	0008e0        	callx8	a8
40376b94:	77ba      	add.n	a7, a7, a11
40376b96:	66aa      	add.n	a6, a6, a10
40376b98:	01b6a7        	bgeu	a6, a10, 40376b9d <_gettimeofday_r+0x21>
40376b9b:	771b      	addi.n	a7, a7, 1
        tv->tv_sec = microseconds / 1000000;
40376b9d:	f6ccc1        	l32r	a12, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40376ba0:	0d0c      	movi.n	a13, 0
40376ba2:	20a660        	or	a10, a6, a6
40376ba5:	20b770        	or	a11, a7, a7
40376ba8:	f66e81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
40376bab:	0008e0        	callx8	a8
40376bae:	03a9      	s32i.n	a10, a3, 0
40376bb0:	13b9      	s32i.n	a11, a3, 4
        tv->tv_usec = microseconds % 1000000;
40376bb2:	f6c7c1        	l32r	a12, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40376bb5:	0d0c      	movi.n	a13, 0
40376bb7:	06ad      	mov.n	a10, a6
40376bb9:	20b770        	or	a11, a7, a7
40376bbc:	f6ec81        	l32r	a8, 4037476c <_iram_text_start+0x368> (40002574 <__umoddi3>)
40376bbf:	0008e0        	callx8	a8
40376bc2:	23a9      	s32i.n	a10, a3, 8
    return 0;
#else
    __errno_r(r) = ENOSYS;
    return -1;
#endif
}
40376bc4:	020c      	movi.n	a2, 0
40376bc6:	f01d      	retw.n

40376bc8 <_times_r>:
{
40376bc8:	006136        	entry	a1, 48
    clock_t t = xTaskGetTickCount() * (portTICK_PERIOD_MS * CLK_TCK / 1000);
40376bcb:	0460e5        	call8	4037b1d8 <xTaskGetTickCount>
40376bce:	a0aaa0        	addx4	a10, a10, a10
40376bd1:	80aaa0        	add	a10, a10, a10
    ptms->tms_cstime = 0;
40376bd4:	00a0c2        	movi	a12, 0
40376bd7:	33c9      	s32i.n	a12, a3, 12
    ptms->tms_cutime = 0;
40376bd9:	23c9      	s32i.n	a12, a3, 8
    ptms->tms_stime = t;
40376bdb:	13a9      	s32i.n	a10, a3, 4
    ptms->tms_utime = 0;
40376bdd:	03c9      	s32i.n	a12, a3, 0
    struct timeval tv = {0, 0};
40376bdf:	01c9      	s32i.n	a12, a1, 0
40376be1:	11c9      	s32i.n	a12, a1, 4
40376be3:	21c9      	s32i.n	a12, a1, 8
    _gettimeofday_r(r, &tv, NULL);
40376be5:	01bd      	mov.n	a11, a1
40376be7:	02ad      	mov.n	a10, a2
40376be9:	fff925        	call8	40376b7c <_gettimeofday_r>
}
40376bec:	0128      	l32i.n	a2, a1, 0
40376bee:	f01d      	retw.n

40376bf0 <esp_reent_init>:
 * is a bit too much on a small embedded system. So we point streams
 * to the streams of the global struct _reent, which are initialized in
 * startup code.
 */
void IRAM_ATTR esp_reent_init(struct _reent* r)
{
40376bf0:	004136        	entry	a1, 32
    memset(r, 0, sizeof(*r));
40376bf3:	f0a0c2        	movi	a12, 240
40376bf6:	0b0c      	movi.n	a11, 0
40376bf8:	02ad      	mov.n	a10, a2
40376bfa:	f62581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40376bfd:	0008e0        	callx8	a8
    _REENT_STDIN(r) = _REENT_STDIN(_GLOBAL_REENT);
40376c00:	f6dc81        	l32r	a8, 40374770 <_iram_text_start+0x36c> (3fc926a4 <_impure_data>)
40376c03:	1898      	l32i.n	a9, a8, 4
40376c05:	1299      	s32i.n	a9, a2, 4
    _REENT_STDOUT(r) = _REENT_STDOUT(_GLOBAL_REENT);
40376c07:	2898      	l32i.n	a9, a8, 8
40376c09:	2299      	s32i.n	a9, a2, 8
    _REENT_STDERR(r) = _REENT_STDERR(_GLOBAL_REENT);
40376c0b:	3898      	l32i.n	a9, a8, 12
40376c0d:	3299      	s32i.n	a9, a2, 12
    _REENT_CLEANUP(r) = _REENT_CLEANUP(_GLOBAL_REENT);
40376c0f:	a898      	l32i.n	a9, a8, 40
40376c11:	a299      	s32i.n	a9, a2, 40
    _REENT_SDIDINIT(r) = _REENT_SDIDINIT(_GLOBAL_REENT);
40376c13:	6888      	l32i.n	a8, a8, 24
40376c15:	6289      	s32i.n	a8, a2, 24
}
40376c17:	f01d      	retw.n
40376c19:	000000        	ill

40376c1c <esp_system_get_time>:
    }
#endif
}

int64_t IRAM_ATTR esp_system_get_time(void)
{
40376c1c:	004136        	entry	a1, 32
    return esp_timer_get_time() + s_correction_us;
40376c1f:	0001a5        	call8	40376c38 <esp_timer_get_time>
40376c22:	f6d491        	l32r	a9, 40374774 <_iram_text_start+0x370> (3fc94ed8 <s_correction_us>)
40376c25:	002982        	l32i	a8, a9, 0
40376c28:	012992        	l32i	a9, a9, 4
40376c2b:	803b90        	add	a3, a11, a9
40376c2e:	2a8a      	add.n	a2, a10, a8
40376c30:	01b287        	bgeu	a2, a8, 40376c35 <esp_system_get_time+0x19>
40376c33:	331b      	addi.n	a3, a3, 1
}
40376c35:	f01d      	retw.n
	...

40376c38 <esp_timer_get_time>:
{
    return systimer_hal_get_counter_value(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER);
}

int64_t IRAM_ATTR esp_timer_impl_get_time(void)
{
40376c38:	004136        	entry	a1, 32
    // we hope the execution time of this function won't > 1us
    // thus, to save one function call, we didn't use the existing `systimer_hal_get_time`
    return systimer_hal.ticks_to_us(systimer_hal_get_counter_value(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER));
40376c3b:	f6cfa1        	l32r	a10, 40374778 <_iram_text_start+0x374> (3fc94ee0 <systimer_hal>)
40376c3e:	1a78      	l32i.n	a7, a10, 4
40376c40:	0b0c      	movi.n	a11, 0
40376c42:	077525        	call8	4037e394 <systimer_hal_get_counter_value>
40376c45:	0007e0        	callx8	a7
}
40376c48:	0a2d      	mov.n	a2, a10
40376c4a:	0b3d      	mov.n	a3, a11
40376c4c:	f01d      	retw.n
	...

40376c50 <usb_serial_jtag_sof_tick_hook>:
{
    return s_usb_serial_jtag_conn_status;
}

static void IRAM_ATTR usb_serial_jtag_sof_tick_hook(void)
{
40376c50:	004136        	entry	a1, 32
 *
 * @return The USB_SERIAL_JTAG raw interrupt status.
 */
static inline __attribute__((always_inline)) uint32_t usb_serial_jtag_ll_get_intraw_mask(void)
{
    return USB_SERIAL_JTAG.int_raw.val;
40376c53:	f6ca91        	l32r	a9, 4037477c <_iram_text_start+0x378> (60038000 <USB_SERIAL_JTAG>)
40376c56:	0020c0        	memw
40376c59:	2988      	l32i.n	a8, a9, 8
    // SOF packet is sent by the HOST every 1ms on a full speed bus
    // Between two consecutive tick hooks, there will be at least 1ms (selectable tick rate range is 1 - 1000Hz)
    // Therefore, SOF intr bit must have be raised at every tick hook if it is connected to a HOST
    // Here, the strategy is: Always assume USB Serial/JTAG is connected until we are sure it is not connected
    // Consider it is disconnected only if SOF intr bit is not raised within (ALLOWED_NO_SOF_TICKS + 1) tick periods
    bool sof_received = (usb_serial_jtag_ll_get_intraw_mask() & USB_SERIAL_JTAG_INTR_SOF);
40376c5b:	2a0c      	movi.n	a10, 2
40376c5d:	1088a0        	and	a8, a8, a10
40376c60:	1b0c      	movi.n	a11, 1
40376c62:	83b880        	moveqz	a11, a8, a8
 *
 * @return None
 */
static inline __attribute__((always_inline)) void usb_serial_jtag_ll_clr_intsts_mask(uint32_t mask)
{
    USB_SERIAL_JTAG.int_clr.val = mask;
40376c65:	0020c0        	memw
40376c68:	59a9      	s32i.n	a10, a9, 20
    usb_serial_jtag_ll_clr_intsts_mask(USB_SERIAL_JTAG_INTR_SOF);
    if (s_usb_serial_jtag_conn_status != sof_received) {
40376c6a:	f6c591        	l32r	a9, 40374780 <_iram_text_start+0x37c> (3fc94ef0 <s_usb_serial_jtag_conn_status>)
40376c6d:	0020c0        	memw
40376c70:	000992        	l8ui	a9, a9, 0
40376c73:	749090        	extui	a9, a9, 0, 8
40376c76:	3e19b7        	beq	a9, a11, 40376cb8 <usb_serial_jtag_sof_tick_hook+0x68>
        if (!sof_received) {
40376c79:	38ec      	bnez.n	a8, 40376ca0 <usb_serial_jtag_sof_tick_hook+0x50>
            if (remaining_allowed_no_sof_ticks > 0) {
40376c7b:	f6c281        	l32r	a8, 40374784 <_iram_text_start+0x380> (3fc94eec <remaining_allowed_no_sof_ticks>)
40376c7e:	0888      	l32i.n	a8, a8, 0
40376c80:	888c      	beqz.n	a8, 40376c8c <usb_serial_jtag_sof_tick_hook+0x3c>
                remaining_allowed_no_sof_ticks--;
40376c82:	880b      	addi.n	a8, a8, -1
40376c84:	f6c091        	l32r	a9, 40374784 <_iram_text_start+0x380> (3fc94eec <remaining_allowed_no_sof_ticks>)
40376c87:	0989      	s32i.n	a8, a9, 0
40376c89:	000ac6        	j	40376cb8 <usb_serial_jtag_sof_tick_hook+0x68>
                // Tolerance credit used up, considered as USJ disconnected
#if CONFIG_USJ_NO_AUTO_LS_ON_CONNECTION
                esp_pm_lock_release(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
                rtc_clk_bbpll_remove_consumer();
40376c8c:	01a6e5        	call8	403786fc <rtc_clk_bbpll_remove_consumer>
#endif
                s_usb_serial_jtag_conn_status = false;
40376c8f:	f6bc81        	l32r	a8, 40374780 <_iram_text_start+0x37c> (3fc94ef0 <s_usb_serial_jtag_conn_status>)
40376c92:	090c      	movi.n	a9, 0
40376c94:	0020c0        	memw
40376c97:	004892        	s8i	a9, a8, 0
40376c9a:	000686        	j	40376cb8 <usb_serial_jtag_sof_tick_hook+0x68>
40376c9d:	000000        	ill
            // USJ re-connected
#if CONFIG_USJ_NO_AUTO_LS_ON_CONNECTION
            esp_pm_lock_acquire(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
            rtc_clk_bbpll_add_consumer();
40376ca0:	01a4a5        	call8	403786ec <rtc_clk_bbpll_add_consumer>
#endif
            s_usb_serial_jtag_conn_status = true;
40376ca3:	f6b781        	l32r	a8, 40374780 <_iram_text_start+0x37c> (3fc94ef0 <s_usb_serial_jtag_conn_status>)
40376ca6:	01a092        	movi	a9, 1
40376ca9:	0020c0        	memw
40376cac:	004892        	s8i	a9, a8, 0
            remaining_allowed_no_sof_ticks = ALLOWED_NO_SOF_TICKS;
40376caf:	f6b581        	l32r	a8, 40374784 <_iram_text_start+0x380> (3fc94eec <remaining_allowed_no_sof_ticks>)
40376cb2:	00a092        	movi	a9, 0
40376cb5:	006892        	s32i	a9, a8, 0
        }
    }
}
40376cb8:	f01d      	retw.n
	...

40376cbc <xt_unhandled_interrupt>:

/*
  Default handler for unhandled interrupts.
*/
void IRAM_ATTR xt_unhandled_interrupt(void * arg)
{
40376cbc:	004136        	entry	a1, 32
40376cbf:	02bd      	mov.n	a11, a2
40376cc1:	03ebc0        	rsr.prid	a12
40376cc4:	04cdc0        	extui	a12, a12, 13, 1
    esp_rom_printf("Unhandled interrupt %d on cpu %d!\n", (int)arg, xPortGetCoreID());
40376cc7:	f6b0a1        	l32r	a10, 40374788 <_iram_text_start+0x384> (3c025b1c <_flash_rodata_start+0x59fc>)
40376cca:	f5fa81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40376ccd:	0008e0        	callx8	a8
}
40376cd0:	f01d      	retw.n
	...

40376cd4 <xt_debugexception>:
    movi    a0,PANIC_RSN_DEBUGEXCEPTION
40376cd4:	100c      	movi.n	a0, 1
    wsr     a0,EXCCAUSE
40376cd6:	13e800        	wsr.exccause	a0
    rsr     a0,(EPC + XCHAL_DEBUGLEVEL)
40376cd9:	03b600        	rsr.epc6	a0
    wsr     a0,EPC_1
40376cdc:	13b100        	wsr.epc1	a0
    rsr     a0,(EXCSAVE + XCHAL_DEBUGLEVEL)
40376cdf:	03d600        	rsr.excsave6	a0
    wsr     a0,EXCSAVE_1
40376ce2:	13d100        	wsr.excsave1	a0
    call0   _xt_panic                       /* does not return */
40376ce5:	013f45        	call0	403780dc <_xt_panic>
    rfi     XCHAL_DEBUGLEVEL
40376ce8:	003610        	rfi	6
	...

40376cec <_xt_kernel_exc>:
    break   1, 0                            /* unhandled kernel exception */
40376cec:	004100        	break	1, 0
    movi    a0,PANIC_RSN_KERNELEXCEPTION
40376cef:	300c      	movi.n	a0, 3
    wsr     a0,EXCCAUSE
40376cf1:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
40376cf4:	013e45        	call0	403780dc <_xt_panic>
    rfe                                     /* make a0 point here not there */
40376cf7:	003000        	rfe
	...

40376cfc <_xt_to_alloca_exc>:
    call0   _xt_alloca_exc                  /* in window vectors section */
40376cfc:	201110        	or	a1, a1, a1
40376cff:	fd3505        	call0	40374050 <_xt_alloca_exc>
	...

40376d04 <_xt_to_syscall_exc>:
    call0   _xt_syscall_exc
40376d04:	000b45        	call0	40376dbc <_xt_syscall_exc>
	...

40376d08 <_xt_to_coproc_exc>:
    call0   _xt_coproc_exc
40376d08:	000f85        	call0	40376e04 <_xt_coproc_exc>
	...

40376d0c <_xt_user_exc>:
    rsr     a0, EXCCAUSE
40376d0c:	03e800        	rsr.exccause	a0
    bnei    a0, EXCCAUSE_LEVEL1INTERRUPT, _xt_handle_exc
40376d0f:	024066        	bnei	a0, 4, 40376d15 <_xt_handle_exc>
    j       _xt_lowint1
40376d12:	00e386        	j	403770a4 <_xt_lowint1>

40376d15 <_xt_handle_exc>:
    bgeui   a0, EXCCAUSE_CP0_DISABLED, _xt_to_coproc_exc
40376d15:	efc0f6        	bgeui	a0, 32, 40376d08 <_xt_to_coproc_exc>
    beqi    a0, EXCCAUSE_ALLOCA,  _xt_to_alloca_exc
40376d18:	e05026        	beqi	a0, 5, 40376cfc <_xt_to_alloca_exc>
    beqi    a0, EXCCAUSE_SYSCALL, _xt_to_syscall_exc
40376d1b:	e51026        	beqi	a0, 1, 40376d04 <_xt_to_syscall_exc>
    mov     a0, sp
40376d1e:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ
40376d21:	ffd112        	addmi	a1, a1, 0xffffff00
40376d24:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40376d27:	046102        	s32i	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
40376d2a:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
40376d2d:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376d30:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376d32:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376d35:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376d37:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40376d3a:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
40376d3c:	49c100        	s32e	a0, a1, -16
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40376d3f:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40376d42:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40376d45:	0afcc5        	call0	40381d14 <_xt_context_save>
    rsr     a0, EXCCAUSE
40376d48:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
40376d4b:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
40376d4e:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
40376d51:	156102        	s32i	a0, a1, 84
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
40376d54:	f68e01        	l32r	a0, 4037478c <_iram_text_start+0x388> (40024 <UserFrameTotalSize+0x3ff24>)
    wsr     a0, PS
40376d57:	13e600        	wsr.ps	a0
    l32i    a3, sp, XT_STK_A0               /* Copy pre-exception a0 (return address) */
40376d5a:	3138      	l32i.n	a3, a1, 12
    s32e    a3, sp, -16
40376d5c:	49c130        	s32e	a3, a1, -16
    l32i    a3, sp, XT_STK_A1               /* Copy pre-exception a1 (stack pointer) */
40376d5f:	4138      	l32i.n	a3, a1, 16
    s32e    a3, sp, -12
40376d61:	49d130        	s32e	a3, a1, -12
    rsr     a0, EPC_1                       /* return address for debug backtrace */
40376d64:	03b100        	rsr.epc1	a0
    movi    a5, 0xC0000000                  /* constant with top 2 bits set (call size) */
40376d67:	f68a51        	l32r	a5, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
    rsync                                   /* wait for WSR.PS to complete */
40376d6a:	002010        	rsync
    or      a0, a0, a5                      /* set top 2 bits */
40376d6d:	200050        	or	a0, a0, a5
    addx2   a0, a5, a0                      /* clear top bit -- thus simulating call4 size */
40376d70:	900500        	addx2	a0, a5, a0
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376d73:	03e820        	rsr.exccause	a2
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376d76:	03e820        	rsr.exccause	a2
    movi    a3, _xt_exception_table
40376d79:	f68631        	l32r	a3, 40374794 <_iram_text_start+0x390> (3fc923b8 <_xt_exception_table>)
    get_percpu_entry_for a2, a4
40376d7c:	03eb40        	rsr.prid	a4
40376d7f:	044d40        	extui	a4, a4, 13, 1
40376d82:	902240        	addx2	a2, a2, a4
    addx4   a4, a2, a3                      /* a4 = address of exception table entry */
40376d85:	a04230        	addx4	a4, a2, a3
    l32i    a4, a4, 0                       /* a4 = handler address */
40376d88:	0448      	l32i.n	a4, a4, 0
    mov     a6, sp                          /* a6 = pointer to exc frame */
40376d8a:	016d      	mov.n	a6, a1
    callx4  a4                              /* call handler */
40376d8c:	0004d0        	callx4	a4
    call0   _xt_context_restore
40376d8f:	0b0285        	call0	40381db8 <_xt_context_restore>
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376d92:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40376d94:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376d97:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
40376d99:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376d9c:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
40376d9e:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
40376da0:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
40376da3:	003000        	rfe
	...

40376da8 <_xt_user_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376da8:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40376daa:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376dad:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
40376daf:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376db2:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40376db4:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
40376db6:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
40376db9:	003000        	rfe

40376dbc <_xt_syscall_exc>:
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376dbc:	ffd112        	addmi	a1, a1, 0xffffff00
40376dbf:	40c112        	addi	a1, a1, 64
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40376dc2:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40376dc5:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40376dc8:	0af485        	call0	40381d14 <_xt_context_save>
    rsr     a2, EPC_1                       /* a2 = PC of 'syscall' */
40376dcb:	03b120        	rsr.epc1	a2
    addi    a3, a2, 3                       /* ++PC                 */
40376dce:	03c232        	addi	a3, a2, 3
    rsr     a0, LEND                        /* if (PC == LEND       */
40376dd1:	030100        	rsr.lend	a0
    bne     a3, a0, 1f
40376dd4:	0d9307        	bne	a3, a0, 40376de5 <_xt_syscall_exc+0x29>
    rsr     a0, LCOUNT                      /*     && LCOUNT != 0)  */
40376dd7:	030200        	rsr.lcount	a0
    beqz    a0, 1f                          /* {                    */
40376dda:	007016        	beqz	a0, 40376de5 <_xt_syscall_exc+0x29>
    addi    a0, a0, -1                      /*   --LCOUNT           */
40376ddd:	000b      	addi.n	a0, a0, -1
    rsr     a3, LBEG                        /*   PC = LBEG          */
40376ddf:	030030        	rsr.lbeg	a3
    wsr     a0, LCOUNT                      /* }                    */
40376de2:	130200        	wsr.lcount	a0
1:  wsr     a3, EPC_1                       /* update PC            */
40376de5:	13b130        	wsr.epc1	a3
    call0   _xt_context_restore
40376de8:	0afcc5        	call0	40381db8 <_xt_context_restore>
    addi    sp, sp, XT_STK_FRMSZ
40376deb:	01d112        	addmi	a1, a1, 0x100
40376dee:	c0c112        	addi	a1, a1, -64
    movi    a0, -1
40376df1:	f07c      	movi.n	a0, -1
    movnez  a2, a0, a2                      /* return -1 if not syscall 0 */
40376df3:	932020        	movnez	a2, a0, a2
    rsr     a0, EXCSAVE_1
40376df6:	03d100        	rsr.excsave1	a0
    rfe
40376df9:	003000        	rfe
    j   .L_xt_coproc_invalid    /* not in a thread (invalid) */
40376dfc:	00a646        	j	40377099 <_xt_coproc_exc+0x295>
40376dff:	980600        	lsi	f0, a6, 0x260
	...

40376e04 <_xt_coproc_exc>:
    mov     a0, sp                          /* sp == a1 */
40376e04:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376e07:	ffd112        	addmi	a1, a1, 0xffffff00
40376e0a:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40376e0d:	046102        	s32i	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
40376e10:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
40376e13:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376e16:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376e18:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376e1b:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376e1d:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40376e20:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
40376e22:	49c100        	s32e	a0, a1, -16
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
40376e25:	f65c01        	l32r	a0, 40374798 <_iram_text_start+0x394> (40376da8 <_xt_user_exit>)
    s32i    a0, sp, XT_STK_EXIT
40376e28:	0109      	s32i.n	a0, a1, 0
    rsr     a0, EXCCAUSE
40376e2a:	03e800        	rsr.exccause	a0
    s32i    a5, sp, XT_STK_A5               /* save a5 */
40376e2d:	8159      	s32i.n	a5, a1, 32
    addi    a5, a0, -EXCCAUSE_CP0_DISABLED  /* a5 = CP index */
40376e2f:	e0c052        	addi	a5, a0, -32
    s32i    a2,  sp, XT_STK_A2
40376e32:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
40376e34:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
40376e36:	7149      	s32i.n	a4, a1, 28
    s32i    a6,  sp, XT_STK_A6
40376e38:	096162        	s32i	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
40376e3b:	a179      	s32i.n	a7, a1, 40
    s32i    a15, sp, XT_STK_A15
40376e3d:	1261f2        	s32i	a15, a1, 72
    call0   XT_RTOS_CP_EXC_HOOK
40376e40:	037205        	call0	4037a564 <_frxt_coproc_exc_hook>
    call0   XT_RTOS_CP_STATE                /* a15 = new owner's save area */
40376e43:	036e05        	call0	4037a524 <_frxt_task_coproc_state>
    beqz    a15, .L_goto_invalid            /* not in a thread (invalid) */
40376e46:	fb2f16        	beqz	a15, 40376dfc <_xt_syscall_exc+0x40>
    movi    a0, _xt_coproc_mask
40376e49:	f65401        	l32r	a0, 4037479c <_iram_text_start+0x398> (3c0284d0 <_xt_coproc_mask>)
    rsr     a4, CPENABLE                    /* a4 = CPENABLE */
40376e4c:	03e040        	rsr.cpenable	a4
    addx4   a0, a5, a0                      /* a0 = &_xt_coproc_mask[n] */
40376e4f:	a00500        	addx4	a0, a5, a0
    l32i    a0, a0, 0                       /* a0 = (n << 16) | (1 << n) */
40376e52:	0008      	l32i.n	a0, a0, 0
    extui   a2, a0, 0, 16                   /* coprocessor bitmask portion */
40376e54:	f42000        	extui	a2, a0, 0, 16
    or      a4, a4, a2                      /* a4 = CPENABLE | (1 << n) */
40376e57:	204420        	or	a4, a4, a2
    wsr     a4, CPENABLE
40376e5a:	13e040        	wsr.cpenable	a4
    getcoreid a3                            /* a3 = current core ID */
40376e5d:	03eb30        	rsr.prid	a3
40376e60:	043d30        	extui	a3, a3, 13, 1
    movi    a2, XCHAL_CP_MAX << 2           /* a2 = size of an owner array */
40376e63:	021c      	movi.n	a2, 16
    mull    a2, a2, a3                      /* a2 = offset to the owner array of the current core*/
40376e65:	822230        	mull	a2, a2, a3
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of all owner arrays */
40376e68:	f64e31        	l32r	a3, 403747a0 <_iram_text_start+0x39c> (3fc925c0 <_xt_coproc_owner_sa>)
    add     a3, a3, a2                      /* a3 = base of owner array of the current core */
40376e6b:	332a      	add.n	a3, a3, a2
    spinlock_take a6 a7 _xt_coproc_owner_sa_lock
40376e6d:	f64d61        	l32r	a6, 403747a4 <_iram_text_start+0x3a0> (3fc925e0 <_xt_coproc_owner_sa_lock>)
40376e70:	070c      	movi.n	a7, 0
40376e72:	130c70        	wsr.scompare1	a7
40376e75:	002010        	rsync
40376e78:	03eb70        	rsr.prid	a7
40376e7b:	00e672        	s32c1i	a7, a6, 0
40376e7e:	fee756        	bnez	a7, 40376e70 <_xt_coproc_exc+0x6c>
    addx4   a3,  a5, a3                      /* a3 = &_xt_coproc_owner_sa[n] */
40376e81:	a03530        	addx4	a3, a5, a3
    l32i    a2,  a3, 0                       /* a2 = old owner's save area */
40376e84:	0328      	l32i.n	a2, a3, 0
    s32i    a15, a3, 0                       /* _xt_coproc_owner_sa[n] = new */
40376e86:	03f9      	s32i.n	a15, a3, 0
    rsync                                    /* ensure wsr.CPENABLE is complete */
40376e88:	002010        	rsync
    spinlock_release a6 a7 _xt_coproc_owner_sa_lock
40376e8b:	f64661        	l32r	a6, 403747a4 <_iram_text_start+0x3a0> (3fc925e0 <_xt_coproc_owner_sa_lock>)
40376e8e:	070c      	movi.n	a7, 0
40376e90:	0679      	s32i.n	a7, a6, 0
    bne     a15, a2, .L_switch_context
40376e92:	029f27        	bne	a15, a2, 40376e98 <_xt_coproc_exc+0x94>
    j    .L_goto_done                       /* new owner == old, we're done */
40376e95:	ffd9c6        	j	40376e00 <_xt_syscall_exc+0x44>
    beqz    a2, .L_check_new
40376e98:	0e8216        	beqz	a2, 40376f84 <_xt_coproc_exc+0x180>
    l16ui   a4,  a2,  XT_CPENABLE           /* a4 = old owner's CPENABLE */
40376e9b:	001242        	l16ui	a4, a2, 0
    bnone   a4,  a0,  .L_check_new          /* old owner not using CP    */
40376e9e:	028407        	bany	a4, a0, 40376ea4 <_xt_coproc_exc+0xa0>
40376ea1:	0037c6        	j	40376f84 <_xt_coproc_exc+0x180>
    movi    a5, _xt_coproc_sa_offset
40376ea4:	f64151        	l32r	a5, 403747a8 <_iram_text_start+0x3a4> (3c0284b0 <_xt_coproc_sa_offset>)
    xor     a4,  a4,  a0                    /* clear CP bit in CPENABLE    */
40376ea7:	304400        	xor	a4, a4, a0
    s16i    a4,  a2,  XT_CPENABLE           /* update old owner's CPENABLE */
40376eaa:	005242        	s16i	a4, a2, 0
    extui   a4,  a0,  16,  5                /* a4 = CP index = n */
40376ead:	454000        	extui	a4, a0, 16, 5
    addx4   a5,  a4,  a5                    /* a5 = &_xt_coproc_sa_offset[n] */
40376eb0:	a05450        	addx4	a5, a4, a5
    l16ui   a4,  a2,  XT_CPSTORED           /* a4 = old owner's CPSTORED */
40376eb3:	011242        	l16ui	a4, a2, 2
    l32i    a5,  a5,  0                     /* a5 = XT_CP[n]_SA offset */
40376eb6:	0558      	l32i.n	a5, a5, 0
    or      a4,  a4,  a0                    /* set CP in old owner's CPSTORED */
40376eb8:	204400        	or	a4, a4, a0
    s16i    a4,  a2,  XT_CPSTORED           /* update old owner's CPSTORED */
40376ebb:	015242        	s16i	a4, a2, 2
    l32i    a2, a2, XT_CP_ASA               /* ptr to actual (aligned) save area */
40376ebe:	2228      	l32i.n	a2, a2, 8
    extui   a3, a0, 16, 5                   /* a3 = CP index = n */
40376ec0:	453000        	extui	a3, a0, 16, 5
    add     a2, a2, a5                      /* a2 = old owner's area for CP n */
40376ec3:	225a      	add.n	a2, a2, a5
    xchal_cpi_store_funcbody
40376ec5:	b3fc      	bnez.n	a3, 40376f04 <_xt_coproc_exc+0x100>
40376ec7:	e33e80        	rur.fcr	a3
40376eca:	0239      	s32i.n	a3, a2, 0
40376ecc:	e33e90        	rur.fsr	a3
40376ecf:	1239      	s32i.n	a3, a2, 4
40376ed1:	024203        	ssi	f0, a2, 8
40376ed4:	034213        	ssi	f1, a2, 12
40376ed7:	044223        	ssi	f2, a2, 16
40376eda:	054233        	ssi	f3, a2, 20
40376edd:	064243        	ssi	f4, a2, 24
40376ee0:	074253        	ssi	f5, a2, 28
40376ee3:	084263        	ssi	f6, a2, 32
40376ee6:	094273        	ssi	f7, a2, 36
40376ee9:	0a4283        	ssi	f8, a2, 40
40376eec:	0b4293        	ssi	f9, a2, 44
40376eef:	0c42a3        	ssi	f10, a2, 48
40376ef2:	0d42b3        	ssi	f11, a2, 52
40376ef5:	0e42c3        	ssi	f12, a2, 56
40376ef8:	0f42d3        	ssi	f13, a2, 60
40376efb:	1042e3        	ssi	f14, a2, 64
40376efe:	1142f3        	ssi	f15, a2, 68
40376f01:	001fc6        	j	40376f84 <_xt_coproc_exc+0x180>
40376f04:	7c3366        	bnei	a3, 3, 40376f84 <_xt_coproc_exc+0x180>
40376f07:	e33000        	lsi	f0, a0, 0x38c
40376f0a:	0239      	s32i.n	a3, a2, 0
40376f0c:	e33010        	lsi	f1, a0, 0x38c
40376f0f:	1239      	s32i.n	a3, a2, 4
40376f11:	e33020        	lsi	f2, a0, 0x38c
40376f14:	2239      	s32i.n	a3, a2, 8
40376f16:	e33030        	lsi	f3, a0, 0x38c
40376f19:	3239      	s32i.n	a3, a2, 12
40376f1b:	e33040        	lsi	f4, a0, 0x38c
40376f1e:	4239      	s32i.n	a3, a2, 16
40376f20:	e33050        	lsi	f5, a0, 0x38c
40376f23:	5239      	s32i.n	a3, a2, 20
40376f25:	e33060        	lsi	f6, a0, 0x38c
40376f28:	6239      	s32i.n	a3, a2, 24
40376f2a:	e33070        	lsi	f7, a0, 0x38c
40376f2d:	7239      	s32i.n	a3, a2, 28
40376f2f:	e33080        	lsi	f8, a0, 0x38c
40376f32:	8239      	s32i.n	a3, a2, 32
40376f34:	e33090        	lsi	f9, a0, 0x38c
40376f37:	9239      	s32i.n	a3, a2, 36
40376f39:	e330a0        	lsi	f10, a0, 0x38c
40376f3c:	a239      	s32i.n	a3, a2, 40
40376f3e:	e330b0        	lsi	f11, a0, 0x38c
40376f41:	b239      	s32i.n	a3, a2, 44
40376f43:	e330d0        	lsi	f13, a0, 0x38c
40376f46:	c239      	s32i.n	a3, a2, 48
40376f48:	e330e0        	lsi	f14, a0, 0x38c
40376f4b:	d239      	s32i.n	a3, a2, 52
40376f4d:	e330f0        	lsi	f15, a0, 0x38c
40376f50:	e239      	s32i.n	a3, a2, 56
40376f52:	e33100        	lsi	f0, a1, 0x38c
40376f55:	f239      	s32i.n	a3, a2, 60
40376f57:	e33110        	lsi	f1, a1, 0x38c
40376f5a:	106232        	s32i	a3, a2, 64
40376f5d:	e33120        	lsi	f2, a1, 0x38c
40376f60:	116232        	s32i	a3, a2, 68
40376f63:	cd6524        	lsi	f2, a5, 0x334
40376f66:	cde624        	lsi	f2, a6, 0x334
40376f69:	dd6724        	lsi	f2, a7, 0x374
40376f6c:	01d222        	addmi	a2, a2, 0x100
40376f6f:	80c222        	addi	a2, a2, -128
40376f72:	dde024        	lsi	f2, a0, 0x374
40376f75:	ed6124        	lsi	f2, a1, 0x3b4
40376f78:	ede224        	lsi	f2, a2, 0x3b4
40376f7b:	fd6324        	lsi	f2, a3, 0x3f4
40376f7e:	fde424        	lsi	f2, a4, 0x3f4
40376f81:	ffffc6        	j	40376f84 <_xt_coproc_exc+0x180>
    beqz    a15, .L_xt_coproc_done
40376f84:	0dcf16        	beqz	a15, 40377064 <_xt_coproc_exc+0x260>
    l16ui   a3,  a15, XT_CPSTORED           /* a3 = new owner's CPSTORED */
40376f87:	011f32        	l16ui	a3, a15, 2
    movi    a4, _xt_coproc_sa_offset
40376f8a:	f60741        	l32r	a4, 403747a8 <_iram_text_start+0x3a4> (3c0284b0 <_xt_coproc_sa_offset>)
    bnone   a3,  a0,  .L_check_cs           /* full CP not saved, check callee-saved */
40376f8d:	028307        	bany	a3, a0, 40376f93 <_xt_coproc_exc+0x18f>
40376f90:	003906        	j	40377078 <_xt_coproc_exc+0x274>
    xor     a3,  a3,  a0                    /* CPSTORED bit is set, clear it */
40376f93:	303300        	xor	a3, a3, a0
    s16i    a3,  a15, XT_CPSTORED           /* update new owner's CPSTORED */
40376f96:	015f32        	s16i	a3, a15, 2
    extui   a3,  a0, 16, 5                  /* a3 = CP index = n */
40376f99:	453000        	extui	a3, a0, 16, 5
    addx4   a4,  a3, a4                     /* a4 = &_xt_coproc_sa_offset[n] */
40376f9c:	a04340        	addx4	a4, a3, a4
    l32i    a4,  a4, 0                      /* a4 = XT_CP[n]_SA */
40376f9f:	0448      	l32i.n	a4, a4, 0
    l32i    a5, a15, XT_CP_ASA              /* ptr to actual (aligned) save area */
40376fa1:	2f58      	l32i.n	a5, a15, 8
    add     a2,  a4, a5                     /* a2 = new owner's area for CP */
40376fa3:	245a      	add.n	a2, a4, a5
    xchal_cpi_load_funcbody
40376fa5:	b3fc      	bnez.n	a3, 40376fe4 <_xt_coproc_exc+0x1e0>
40376fa7:	0238      	l32i.n	a3, a2, 0
40376fa9:	f3e830        	wur.fcr	a3
40376fac:	1238      	l32i.n	a3, a2, 4
40376fae:	f3e930        	wur.fsr	a3
40376fb1:	020203        	lsi	f0, a2, 8
40376fb4:	030213        	lsi	f1, a2, 12
40376fb7:	040223        	lsi	f2, a2, 16
40376fba:	050233        	lsi	f3, a2, 20
40376fbd:	060243        	lsi	f4, a2, 24
40376fc0:	070253        	lsi	f5, a2, 28
40376fc3:	080263        	lsi	f6, a2, 32
40376fc6:	090273        	lsi	f7, a2, 36
40376fc9:	0a0283        	lsi	f8, a2, 40
40376fcc:	0b0293        	lsi	f9, a2, 44
40376fcf:	0c02a3        	lsi	f10, a2, 48
40376fd2:	0d02b3        	lsi	f11, a2, 52
40376fd5:	0e02c3        	lsi	f12, a2, 56
40376fd8:	0f02d3        	lsi	f13, a2, 60
40376fdb:	1002e3        	lsi	f14, a2, 64
40376fde:	1102f3        	lsi	f15, a2, 68
40376fe1:	001fc6        	j	40377064 <_xt_coproc_exc+0x260>
40376fe4:	7c3366        	bnei	a3, 3, 40377064 <_xt_coproc_exc+0x260>
40376fe7:	0238      	l32i.n	a3, a2, 0
40376fe9:	f30030        	lsi	f3, a0, 0x3cc
40376fec:	1238      	l32i.n	a3, a2, 4
40376fee:	f30130        	lsi	f3, a1, 0x3cc
40376ff1:	2238      	l32i.n	a3, a2, 8
40376ff3:	f30230        	lsi	f3, a2, 0x3cc
40376ff6:	3238      	l32i.n	a3, a2, 12
40376ff8:	f30330        	lsi	f3, a3, 0x3cc
40376ffb:	4238      	l32i.n	a3, a2, 16
40376ffd:	f30430        	lsi	f3, a4, 0x3cc
40377000:	5238      	l32i.n	a3, a2, 20
40377002:	f30530        	lsi	f3, a5, 0x3cc
40377005:	6238      	l32i.n	a3, a2, 24
40377007:	f30630        	lsi	f3, a6, 0x3cc
4037700a:	7238      	l32i.n	a3, a2, 28
4037700c:	f30730        	lsi	f3, a7, 0x3cc
4037700f:	8238      	l32i.n	a3, a2, 32
40377011:	f30830        	lsi	f3, a8, 0x3cc
40377014:	9238      	l32i.n	a3, a2, 36
40377016:	f30930        	lsi	f3, a9, 0x3cc
40377019:	a238      	l32i.n	a3, a2, 40
4037701b:	f30a30        	lsi	f3, a10, 0x3cc
4037701e:	b238      	l32i.n	a3, a2, 44
40377020:	f30b30        	lsi	f3, a11, 0x3cc
40377023:	c238      	l32i.n	a3, a2, 48
40377025:	f30d30        	lsi	f3, a13, 0x3cc
40377028:	d238      	l32i.n	a3, a2, 52
4037702a:	f30e30        	lsi	f3, a14, 0x3cc
4037702d:	e238      	l32i.n	a3, a2, 56
4037702f:	f30f30        	lsi	f3, a15, 0x3cc
40377032:	f238      	l32i.n	a3, a2, 60
40377034:	f31030        	lsi	f3, a0, 0x3cc
40377037:	102232        	l32i	a3, a2, 64
4037703a:	f31130        	lsi	f3, a1, 0x3cc
4037703d:	112232        	l32i	a3, a2, 68
40377040:	f31230        	lsi	f3, a2, 0x3cc
40377043:	cd2524        	lsi	f2, a5, 0x334
40377046:	cda624        	lsi	f2, a6, 0x334
40377049:	dd2724        	lsi	f2, a7, 0x374
4037704c:	01d222        	addmi	a2, a2, 0x100
4037704f:	80c222        	addi	a2, a2, -128
40377052:	dda024        	lsi	f2, a0, 0x374
40377055:	ed2124        	lsi	f2, a1, 0x3b4
40377058:	eda224        	lsi	f2, a2, 0x3b4
4037705b:	fd2324        	lsi	f2, a3, 0x3f4
4037705e:	fda424        	lsi	f2, a4, 0x3f4
40377061:	ffffc6        	j	40377064 <_xt_coproc_exc+0x260>
    l32i    a15, sp, XT_STK_A15
40377064:	1221f2        	l32i	a15, a1, 72
    l32i    a6,  sp, XT_STK_A6
40377067:	9168      	l32i.n	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
40377069:	a178      	l32i.n	a7, a1, 40
    l32i    a5,  sp, XT_STK_A5
4037706b:	8158      	l32i.n	a5, a1, 32
    l32i    a4,  sp, XT_STK_A4
4037706d:	7148      	l32i.n	a4, a1, 28
    l32i    a3,  sp, XT_STK_A3
4037706f:	062132        	l32i	a3, a1, 24
    l32i    a2,  sp, XT_STK_A2
40377072:	052122        	l32i	a2, a1, 20
    call0   _xt_user_exit                   /* return via exit dispatcher */
40377075:	ffd305        	call0	40376da8 <_xt_user_exit>
    l16ui   a2, a15, XT_CP_CS_ST            /* a2 = mask of CPs saved    */
40377078:	021f22        	l16ui	a2, a15, 4
    bnone   a2,  a0, .L_xt_coproc_done      /* if no match then done     */
4037707b:	e50207        	bnone	a2, a0, 40377064 <_xt_coproc_exc+0x260>
    and     a2,  a2, a0                     /* a2 = which CPs to restore */
4037707e:	102200        	and	a2, a2, a0
    extui   a2,  a2, 0, 8                   /* extract low 8 bits        */
40377081:	742020        	extui	a2, a2, 0, 8
    s32i    a13, sp, XT_STK_A13
40377084:	1061d2        	s32i	a13, a1, 64
    s32i    a14, sp, XT_STK_A14
40377087:	1161e2        	s32i	a14, a1, 68
    call0   _xt_coproc_restorecs            /* restore CP registers      */
4037708a:	0adf45        	call0	40381e80 <_xt_coproc_restorecs>
    l32i    a13, sp, XT_STK_A13
4037708d:	1021d2        	l32i	a13, a1, 64
    l32i    a14, sp, XT_STK_A14
40377090:	1121e2        	l32i	a14, a1, 68
    j       .L_xt_coproc_done
40377093:	fff346        	j	40377064 <_xt_coproc_exc+0x260>
40377096:	000000        	ill
    movi    a0,PANIC_RSN_COPROCEXCEPTION
40377099:	400c      	movi.n	a0, 4
    wsr     a0,EXCCAUSE
4037709b:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* not in a thread (invalid) */
4037709e:	201110        	or	a1, a1, a1
403770a1:	010385        	call0	403780dc <_xt_panic>

403770a4 <_xt_lowint1>:
    mov     a0, sp                          /* sp == a1 */
403770a4:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
403770a7:	ffd112        	addmi	a1, a1, 0xffffff00
403770aa:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
403770ad:	046102        	s32i	a0, a1, 16
    rsr     a0, PS                          /* save interruptee's PS */
403770b0:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
403770b3:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
403770b6:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
403770b9:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
403770bb:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
403770be:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
403770c0:	f5b601        	l32r	a0, 40374798 <_iram_text_start+0x394> (40376da8 <_xt_user_exit>)
    s32i    a0, sp, XT_STK_EXIT
403770c3:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
403770c5:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_1
403770c7:	13d100        	wsr.excsave1	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
403770ca:	032c85        	call0	4037a394 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(1) | PS_UM | PS_WOE
403770cd:	f5b701        	l32r	a0, 403747ac <_iram_text_start+0x3a8> (40021 <UserFrameTotalSize+0x3ff21>)
    wsr     a0, PS
403770d0:	13e600        	wsr.ps	a0
    rsync
403770d3:	002010        	rsync
    dispatch_c_isr 1 XCHAL_INTLEVEL1_MASK
403770d6:	03e420        	rsr.intenable	a2
403770d9:	03e230        	rsr.interrupt	a3
403770dc:	f5b541        	l32r	a4, 403747b0 <_iram_text_start+0x3ac> (637ff <UserFrameTotalSize+0x636ff>)
403770df:	102230        	and	a2, a2, a3
403770e2:	102240        	and	a2, a2, a4
403770e5:	04f216        	beqz	a2, 40377138 <_xt_lowint1+0x94>
403770e8:	03d100        	rsr.excsave1	a0
403770eb:	3038      	l32i.n	a3, a0, 12
403770ed:	49c130        	s32e	a3, a1, -16
403770f0:	4038      	l32i.n	a3, a0, 16
403770f2:	49d130        	s32e	a3, a1, -12
403770f5:	03b100        	rsr.epc1	a0
403770f8:	f5a641        	l32r	a4, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
403770fb:	200040        	or	a0, a0, a4
403770fe:	900400        	addx2	a0, a4, a0
40377101:	420b      	addi.n	a4, a2, -1
40377103:	102240        	and	a2, a2, a4
40377106:	ff7256        	bnez	a2, 40377101 <_xt_lowint1+0x5d>
40377109:	441b      	addi.n	a4, a4, 1
4037710b:	13e340        	wsr.intclear	a4
4037710e:	f31c      	movi.n	a3, 31
40377110:	40f440        	nsau	a4, a4
40377113:	c03340        	sub	a3, a3, a4
40377116:	03ebc0        	rsr.prid	a12
40377119:	04cdc0        	extui	a12, a12, 13, 1
4037711c:	9033c0        	addx2	a3, a3, a12
4037711f:	f5a541        	l32r	a4, 403747b4 <_iram_text_start+0x3b0> (3fc921b8 <_xt_interrupt_table>)
40377122:	b03340        	addx8	a3, a3, a4
40377125:	0348      	l32i.n	a4, a3, 0
40377127:	202660        	or	a2, a6, a6
4037712a:	012362        	l32i	a6, a3, 4
4037712d:	0004d0        	callx4	a4
40377130:	ffe886        	j	403770d6 <_xt_lowint1+0x32>
40377133:	460000        	lsi	f0, a0, 0x118
40377136:	10ffe7        	bbsi	a15, 30, 4037714a <_xt_medint2+0xa>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40377139:	c52011        	l32r	a1, 403685bc <rom_rx_gain_force+0x362190>
4037713c:	0329      	s32i.n	a2, a3, 0
	...

40377140 <_xt_medint2>:
    mov     a0, sp                          /* sp == a1 */
40377140:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40377143:	ffd112        	addmi	a1, a1, 0xffffff00
40377146:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40377149:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_2                       /* save interruptee's PS */
4037714c:	03c200        	rsr.eps2	a0
    s32i    a0, sp, XT_STK_PS
4037714f:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_2                       /* save interruptee's PC */
40377152:	03b200        	rsr.epc2	a0
    s32i    a0, sp, XT_STK_PC
40377155:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_2                   /* save interruptee's a0 */
40377157:	03d200        	rsr.excsave2	a0
    s32i    a0, sp, XT_STK_A0
4037715a:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint2_exit            /* save exit point for dispatch */
4037715c:	f59701        	l32r	a0, 403747b8 <_iram_text_start+0x3b4> (403771dc <_xt_medint2_exit>)
    s32i    a0, sp, XT_STK_EXIT
4037715f:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40377161:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_2
40377163:	13d200        	wsr.excsave2	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40377166:	0322c5        	call0	4037a394 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(2) | PS_UM | PS_WOE
40377169:	f59401        	l32r	a0, 403747bc <_iram_text_start+0x3b8> (40022 <UserFrameTotalSize+0x3ff22>)
    wsr     a0, PS
4037716c:	13e600        	wsr.ps	a0
    rsync
4037716f:	002010        	rsync
    dispatch_c_isr 2 XCHAL_INTLEVEL2_MASK
40377172:	03e420        	rsr.intenable	a2
40377175:	03e230        	rsr.interrupt	a3
40377178:	f59241        	l32r	a4, 403747c0 <_iram_text_start+0x3bc> (380000 <UserFrameTotalSize+0x37ff00>)
4037717b:	102230        	and	a2, a2, a3
4037717e:	102240        	and	a2, a2, a4
40377181:	04f216        	beqz	a2, 403771d4 <_xt_medint2+0x94>
40377184:	03d200        	rsr.excsave2	a0
40377187:	3038      	l32i.n	a3, a0, 12
40377189:	49c130        	s32e	a3, a1, -16
4037718c:	4038      	l32i.n	a3, a0, 16
4037718e:	49d130        	s32e	a3, a1, -12
40377191:	03b200        	rsr.epc2	a0
40377194:	f57f41        	l32r	a4, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40377197:	200040        	or	a0, a0, a4
4037719a:	900400        	addx2	a0, a4, a0
4037719d:	420b      	addi.n	a4, a2, -1
4037719f:	102240        	and	a2, a2, a4
403771a2:	ff7256        	bnez	a2, 4037719d <_xt_medint2+0x5d>
403771a5:	441b      	addi.n	a4, a4, 1
403771a7:	13e340        	wsr.intclear	a4
403771aa:	f31c      	movi.n	a3, 31
403771ac:	40f440        	nsau	a4, a4
403771af:	c03340        	sub	a3, a3, a4
403771b2:	03ebc0        	rsr.prid	a12
403771b5:	04cdc0        	extui	a12, a12, 13, 1
403771b8:	9033c0        	addx2	a3, a3, a12
403771bb:	f57e41        	l32r	a4, 403747b4 <_iram_text_start+0x3b0> (3fc921b8 <_xt_interrupt_table>)
403771be:	b03340        	addx8	a3, a3, a4
403771c1:	0348      	l32i.n	a4, a3, 0
403771c3:	202660        	or	a2, a6, a6
403771c6:	012362        	l32i	a6, a3, 4
403771c9:	0004d0        	callx4	a4
403771cc:	ffe886        	j	40377172 <_xt_medint2+0x32>
403771cf:	460000        	lsi	f0, a0, 0x118
403771d2:	10ffe7        	bbsi	a15, 30, 403771e6 <_xt_medint2_exit+0xa>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
403771d5:	052011        	l32r	a1, 40338658 <rom_rx_gain_force+0x33222c>
403771d8:	000320        	lsi	f2, a3, 0
	...

403771dc <_xt_medint2_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
403771dc:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_2
403771de:	13c200        	wsr.eps2	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
403771e1:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_2
403771e3:	13b200        	wsr.epc2	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
403771e6:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
403771e8:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
403771ea:	002010        	rsync
    rfi     2
403771ed:	003210        	rfi	2

403771f0 <_xt_medint3>:
    mov     a0, sp                          /* sp == a1 */
403771f0:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
403771f3:	ffd112        	addmi	a1, a1, 0xffffff00
403771f6:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
403771f9:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_3                       /* save interruptee's PS */
403771fc:	03c300        	rsr.eps3	a0
    s32i    a0, sp, XT_STK_PS
403771ff:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_3                       /* save interruptee's PC */
40377202:	03b300        	rsr.epc3	a0
    s32i    a0, sp, XT_STK_PC
40377205:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_3                   /* save interruptee's a0 */
40377207:	03d300        	rsr.excsave3	a0
    s32i    a0, sp, XT_STK_A0
4037720a:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint3_exit            /* save exit point for dispatch */
4037720c:	f56e01        	l32r	a0, 403747c4 <_iram_text_start+0x3c0> (4037728c <_xt_medint3_exit>)
    s32i    a0, sp, XT_STK_EXIT
4037720f:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40377211:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_3
40377213:	13d300        	wsr.excsave3	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40377216:	0317c5        	call0	4037a394 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(3) | PS_UM | PS_WOE
40377219:	f56b01        	l32r	a0, 403747c8 <_iram_text_start+0x3c4> (40023 <UserFrameTotalSize+0x3ff23>)
    wsr     a0, PS
4037721c:	13e600        	wsr.ps	a0
    rsync
4037721f:	002010        	rsync
    dispatch_c_isr 3 XCHAL_INTLEVEL3_MASK
40377222:	03e420        	rsr.intenable	a2
40377225:	03e230        	rsr.interrupt	a3
40377228:	f56941        	l32r	a4, 403747cc <_iram_text_start+0x3c8> (28c08800 <UserFrameTotalSize+0x28c08700>)
4037722b:	102230        	and	a2, a2, a3
4037722e:	102240        	and	a2, a2, a4
40377231:	04f216        	beqz	a2, 40377284 <_xt_medint3+0x94>
40377234:	03d300        	rsr.excsave3	a0
40377237:	3038      	l32i.n	a3, a0, 12
40377239:	49c130        	s32e	a3, a1, -16
4037723c:	4038      	l32i.n	a3, a0, 16
4037723e:	49d130        	s32e	a3, a1, -12
40377241:	03b300        	rsr.epc3	a0
40377244:	f55341        	l32r	a4, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40377247:	200040        	or	a0, a0, a4
4037724a:	900400        	addx2	a0, a4, a0
4037724d:	420b      	addi.n	a4, a2, -1
4037724f:	102240        	and	a2, a2, a4
40377252:	ff7256        	bnez	a2, 4037724d <_xt_medint3+0x5d>
40377255:	441b      	addi.n	a4, a4, 1
40377257:	13e340        	wsr.intclear	a4
4037725a:	f31c      	movi.n	a3, 31
4037725c:	40f440        	nsau	a4, a4
4037725f:	c03340        	sub	a3, a3, a4
40377262:	03ebc0        	rsr.prid	a12
40377265:	04cdc0        	extui	a12, a12, 13, 1
40377268:	9033c0        	addx2	a3, a3, a12
4037726b:	f55241        	l32r	a4, 403747b4 <_iram_text_start+0x3b0> (3fc921b8 <_xt_interrupt_table>)
4037726e:	b03340        	addx8	a3, a3, a4
40377271:	0348      	l32i.n	a4, a3, 0
40377273:	202660        	or	a2, a6, a6
40377276:	012362        	l32i	a6, a3, 4
40377279:	0004d0        	callx4	a4
4037727c:	ffe886        	j	40377222 <_xt_medint3+0x32>
4037727f:	ffe7c6        	j	40377222 <_xt_medint3+0x32>
40377282:	100000        	and	a0, a0, a0
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40377285:	052011        	l32r	a1, 40338708 <rom_rx_gain_force+0x3322dc>
40377288:	000315        	call4	403772bc <bootloader_flash_execute_command_common+0x4>
	...

4037728c <_xt_medint3_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
4037728c:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_3
4037728e:	13c300        	wsr.eps3	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40377291:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_3
40377293:	13b300        	wsr.epc3	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40377296:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40377298:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
4037729a:	002010        	rsync
    rfi     3
4037729d:	003310        	rfi	3

403772a0 <_xt_highint4>:
    rsr     a0, EXCSAVE_4                   /* restore a0 */
403772a0:	03d400        	rsr.excsave4	a0
    rfi     4
403772a3:	003410        	rfi	4
	...

403772a8 <xt_highint5>:
    rsr     a0, EXCSAVE_5                   /* restore a0 */
403772a8:	03d500        	rsr.excsave5	a0
    rfi     5
403772ab:	003510        	rfi	5
	...

403772b0 <xt_nmi>:
    rsr     a0, EXCSAVE + XCHAL_NMILEVEL    /* restore a0 */
403772b0:	03d700        	rsr.excsave7	a0
    rfi     XCHAL_NMILEVEL
403772b3:	003710        	rfi	7
	...

403772b8 <bootloader_flash_execute_command_common>:
    uint8_t command,
    uint32_t addr_len, uint32_t address,
    uint8_t dummy_len,
    uint8_t mosi_len, uint32_t mosi_data,
    uint8_t miso_len)
{
403772b8:	00a136        	entry	a1, 80
403772bb:	4179      	s32i.n	a7, a1, 16
403772bd:	749020        	extui	a9, a2, 0, 8
403772c0:	745050        	extui	a5, a5, 0, 8
403772c3:	746060        	extui	a6, a6, 0, 8
403772c6:	500122        	l8ui	a2, a1, 80
    assert(mosi_len <= 32);
403772c9:	082c      	movi.n	a8, 32
403772cb:	0eb867        	bgeu	a8, a6, 403772dd <bootloader_flash_execute_command_common+0x25>
403772ce:	f540d1        	l32r	a13, 403747d0 <_iram_text_start+0x3cc> (3c025be4 <_flash_rodata_start+0x5ac4>)
403772d1:	f540c1        	l32r	a12, 403747d4 <_iram_text_start+0x3d0> (3c02860c <__func__$4>)
403772d4:	faa2b2        	movi	a11, 0x2fa
403772d7:	f540a1        	l32r	a10, 403747d8 <_iram_text_start+0x3d4> (3c025c2d <_flash_rodata_start+0x5b0d>)
403772da:	08a765        	call8	4037fd50 <__assert_func>
    assert(miso_len <= 32);
403772dd:	082c      	movi.n	a8, 32
403772df:	0eb827        	bgeu	a8, a2, 403772f1 <bootloader_flash_execute_command_common+0x39>
403772e2:	f53ed1        	l32r	a13, 403747dc <_iram_text_start+0x3d8> (3c025c40 <_flash_rodata_start+0x5b20>)
403772e5:	f53bc1        	l32r	a12, 403747d4 <_iram_text_start+0x3d0> (3c02860c <__func__$4>)
403772e8:	fba2b2        	movi	a11, 0x2fb
403772eb:	f53ba1        	l32r	a10, 403747d8 <_iram_text_start+0x3d4> (3c025c2d <_flash_rodata_start+0x5b0d>)
403772ee:	08a625        	call8	4037fd50 <__assert_func>
 * @param user1_reg user1_reg
 * @param user2_reg user2_reg
 */
static inline void spimem_flash_ll_get_common_command_register_info(spi_mem_dev_t *dev, uint32_t *ctrl_reg, uint32_t *user_reg, uint32_t *user1_reg, uint32_t *user2_reg)
{
    *ctrl_reg = dev->ctrl.val;
403772f1:	f53b81        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403772f4:	0020c0        	memw
403772f7:	28a8      	l32i.n	a10, a8, 8
403772f9:	51a9      	s32i.n	a10, a1, 20
    *user_reg = dev->user.val;
403772fb:	0020c0        	memw
403772fe:	68a8      	l32i.n	a10, a8, 24
40377300:	61a9      	s32i.n	a10, a1, 24
    *user1_reg = dev->user1.val;
40377302:	0020c0        	memw
40377305:	78a8      	l32i.n	a10, a8, 28
40377307:	71a9      	s32i.n	a10, a1, 28
    *user2_reg = dev->user2.val;
40377309:	0020c0        	memw
4037730c:	88a8      	l32i.n	a10, a8, 32
4037730e:	81a9      	s32i.n	a10, a1, 32
    uint32_t old_ctrl_reg = 0;
    uint32_t old_user_reg = 0;
    uint32_t old_user1_reg = 0;
    uint32_t old_user2_reg = 0;
    spi_flash_ll_get_common_command_register_info(&SPIMEM_LL_APB, &old_ctrl_reg, &old_user_reg, &old_user1_reg, &old_user2_reg);
    SPIMEM_LL_APB.ctrl.val = 0;
40377310:	0a0c      	movi.n	a10, 0
40377312:	0020c0        	memw
40377315:	28a9      	s32i.n	a10, a8, 8
    dev->ctrl.wp = level;
40377317:	0020c0        	memw
4037731a:	28a8      	l32i.n	a10, a8, 8
4037731c:	f532b1        	l32r	a11, 403747e4 <_iram_text_start+0x3e0> (200000 <UserFrameTotalSize+0x1fff00>)
4037731f:	20aab0        	or	a10, a10, a11
40377322:	0020c0        	memw
40377325:	28a9      	s32i.n	a10, a8, 8
    dev->user.usr_command = 1;
40377327:	0020c0        	memw
4037732a:	68a8      	l32i.n	a10, a8, 24
4037732c:	f47cb1        	l32r	a11, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037732f:	20aab0        	or	a10, a10, a11
40377332:	0020c0        	memw
40377335:	68a9      	s32i.n	a10, a8, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
40377337:	0020c0        	memw
4037733a:	88a8      	l32i.n	a10, a8, 32
4037733c:	0020c0        	memw
4037733f:	21a9      	s32i.n	a10, a1, 8
40377341:	0020c0        	memw
40377344:	21a8      	l32i.n	a10, a1, 8
40377346:	f5a0a0        	extui	a10, a10, 16, 16
40377349:	11aa00        	slli	a10, a10, 16
4037734c:	2099a0        	or	a9, a9, a10
4037734f:	0020c0        	memw
40377352:	2199      	s32i.n	a9, a1, 8
40377354:	0020c0        	memw
40377357:	2198      	l32i.n	a9, a1, 8
40377359:	0020c0        	memw
4037735c:	8899      	s32i.n	a9, a8, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037735e:	0020c0        	memw
40377361:	8898      	l32i.n	a9, a8, 32
40377363:	0020c0        	memw
40377366:	1199      	s32i.n	a9, a1, 4
40377368:	0020c0        	memw
4037736b:	1198      	l32i.n	a9, a1, 4
4037736d:	1199c0        	slli	a9, a9, 4
40377370:	419490        	srli	a9, a9, 4
40377373:	f51da1        	l32r	a10, 403747e8 <_iram_text_start+0x3e4> (70000000 <_rtc_reserved_end+0xff00000>)
40377376:	2099a0        	or	a9, a9, a10
40377379:	0020c0        	memw
4037737c:	1199      	s32i.n	a9, a1, 4
4037737e:	0020c0        	memw
40377381:	1198      	l32i.n	a9, a1, 4
40377383:	0020c0        	memw
40377386:	8899      	s32i.n	a9, a8, 32
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
40377388:	e0c392        	addi	a9, a3, -32
4037738b:	0020c0        	memw
4037738e:	f8a8      	l32i.n	a10, a8, 60
40377390:	40f990        	nsau	a9, a9
40377393:	419590        	srli	a9, a9, 5
40377396:	999a      	add.n	a9, a9, a9
40377398:	db7c      	movi.n	a11, -3
4037739a:	10aab0        	and	a10, a10, a11
4037739d:	209a90        	or	a9, a10, a9
403773a0:	0020c0        	memw
403773a3:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
403773a5:	a30b      	addi.n	a10, a3, -1
403773a7:	0020c0        	memw
403773aa:	7898      	l32i.n	a9, a8, 28
403773ac:	01aa60        	slli	a10, a10, 26
403773af:	1199a0        	slli	a9, a9, 6
403773b2:	419690        	srli	a9, a9, 6
403773b5:	2099a0        	or	a9, a9, a10
403773b8:	0020c0        	memw
403773bb:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
403773bd:	0020c0        	memw
403773c0:	6898      	l32i.n	a9, a8, 24
403773c2:	1a0c      	movi.n	a10, 1
403773c4:	83a330        	moveqz	a10, a3, a3
403773c7:	01aa20        	slli	a10, a10, 30
403773ca:	f508b1        	l32r	a11, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
403773cd:	1099b0        	and	a9, a9, a11
403773d0:	2099a0        	or	a9, a9, a10
403773d3:	0020c0        	memw
403773d6:	6899      	s32i.n	a9, a8, 24
    dev->addr = addr;
403773d8:	0020c0        	memw
403773db:	1849      	s32i.n	a4, a8, 4
    spi_flash_ll_set_command(&SPIMEM_LL_APB, command, 8);
    //addr phase
    spi_flash_ll_set_addr_bitlen(&SPIMEM_LL_APB, addr_len);
    spi_flash_ll_set_usr_address(&SPIMEM_LL_APB, address, addr_len);
    //dummy phase
    uint32_t total_dummy = dummy_len;
403773dd:	058d      	mov.n	a8, a5
    if (miso_len > 0) {
403773df:	928c      	beqz.n	a2, 403773ec <bootloader_flash_execute_command_common+0x134>
        total_dummy += g_rom_spiflash_dummy_len_plus[1];
403773e1:	f50381        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
403773e4:	0888      	l32i.n	a8, a8, 0
403773e6:	190882        	l8ui	a8, a8, 25
403773e9:	808580        	add	a8, a5, a8
    dev->user.usr_dummy = dummy_n ? 1 : 0;
403773ec:	f4fdb1        	l32r	a11, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403773ef:	0020c0        	memw
403773f2:	6b98      	l32i.n	a9, a11, 24
403773f4:	1a0c      	movi.n	a10, 1
403773f6:	83a880        	moveqz	a10, a8, a8
403773f9:	01aa30        	slli	a10, a10, 29
403773fc:	f4fec1        	l32r	a12, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
403773ff:	1099c0        	and	a9, a9, a12
40377402:	2099a0        	or	a9, a9, a10
40377405:	0020c0        	memw
40377408:	6b99      	s32i.n	a9, a11, 24
    if (dummy_n > 0) {
4037740a:	a89c      	beqz.n	a8, 40377428 <bootloader_flash_execute_command_common+0x170>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037740c:	880b      	addi.n	a8, a8, -1
4037740e:	0bad      	mov.n	a10, a11
40377410:	0020c0        	memw
40377413:	072b92        	l32i	a9, a11, 28
40377416:	548080        	extui	a8, a8, 0, 6
40377419:	c0afb2        	movi	a11, -64
4037741c:	1099b0        	and	a9, a9, a11
4037741f:	208980        	or	a8, a9, a8
40377422:	0020c0        	memw
40377425:	076a82        	s32i	a8, a10, 28
    dev->user.usr_mosi = bitlen > 0;
40377428:	f4eea1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037742b:	0020c0        	memw
4037742e:	6a88      	l32i.n	a8, a10, 24
40377430:	190c      	movi.n	a9, 1
40377432:	839660        	moveqz	a9, a6, a6
40377435:	019950        	slli	a9, a9, 27
40377438:	f4f0b1        	l32r	a11, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037743b:	1088b0        	and	a8, a8, a11
4037743e:	208890        	or	a8, a8, a9
40377441:	0020c0        	memw
40377444:	6a89      	s32i.n	a8, a10, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
40377446:	668c      	beqz.n	a6, 40377450 <bootloader_flash_execute_command_common+0x198>
40377448:	860b      	addi.n	a8, a6, -1
4037744a:	948080        	extui	a8, a8, 0, 10
4037744d:	000046        	j	40377452 <bootloader_flash_execute_command_common+0x19a>
40377450:	080c      	movi.n	a8, 0
40377452:	f4e3a1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
40377455:	0020c0        	memw
40377458:	9a98      	l32i.n	a9, a10, 36
4037745a:	00acb2        	movi	a11, 0xfffffc00
4037745d:	1099b0        	and	a9, a9, a11
40377460:	208890        	or	a8, a8, a9
40377463:	0020c0        	memw
40377466:	9a89      	s32i.n	a8, a10, 36
    }
    spi_flash_ll_set_dummy(&SPIMEM_LL_APB, total_dummy);
    //output data

    spi_flash_ll_set_mosi_bitlen(&SPIMEM_LL_APB, mosi_len);
    spi_flash_ll_set_buffer_data(&SPIMEM_LL_APB, &mosi_data, mosi_len / 8);
40377468:	416360        	srli	a6, a6, 3
    int num_words = (length + 3) / 4;
4037746b:	363b      	addi.n	a3, a6, 3
4037746d:	413230        	srli	a3, a3, 2
    for (int i = 0; i < num_words; i++) {
40377470:	050c      	movi.n	a5, 0
40377472:	10c142        	addi	a4, a1, 16
40377475:	000ac6        	j	403774a4 <bootloader_flash_execute_command_common+0x1ec>
        uint32_t word = 0;
40377478:	080c      	movi.n	a8, 0
4037747a:	3189      	s32i.n	a8, a1, 12
        uint32_t word_len = MIN(length, sizeof(word));
4037747c:	470c      	movi.n	a7, 4
4037747e:	637670        	minu	a7, a6, a7
        memcpy(&word, buffer, word_len);
40377481:	07cd      	mov.n	a12, a7
40377483:	04bd      	mov.n	a11, a4
40377485:	a1cb      	addi.n	a10, a1, 12
40377487:	f41381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037748a:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037748d:	14c582        	addi	a8, a5, 20
40377490:	f4d491        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
40377493:	a08890        	addx4	a8, a8, a9
40377496:	3198      	l32i.n	a9, a1, 12
40377498:	0020c0        	memw
4037749b:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037749d:	c06670        	sub	a6, a6, a7
        buffer = (void *)((intptr_t)buffer + word_len);
403774a0:	474a      	add.n	a4, a7, a4
    for (int i = 0; i < num_words; i++) {
403774a2:	551b      	addi.n	a5, a5, 1
403774a4:	d02537        	blt	a5, a3, 40377478 <bootloader_flash_execute_command_common+0x1c0>
    dev->user.usr_miso = bitlen > 0;
403774a7:	f4cea1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403774aa:	0020c0        	memw
403774ad:	6a88      	l32i.n	a8, a10, 24
403774af:	190c      	movi.n	a9, 1
403774b1:	839220        	moveqz	a9, a2, a2
403774b4:	019940        	slli	a9, a9, 28
403774b7:	f4d1b1        	l32r	a11, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
403774ba:	1088b0        	and	a8, a8, a11
403774bd:	208890        	or	a8, a8, a9
403774c0:	0020c0        	memw
403774c3:	6a89      	s32i.n	a8, a10, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
403774c5:	628c      	beqz.n	a2, 403774cf <bootloader_flash_execute_command_common+0x217>
403774c7:	920b      	addi.n	a9, a2, -1
403774c9:	949090        	extui	a9, a9, 0, 10
403774cc:	000046        	j	403774d1 <bootloader_flash_execute_command_common+0x219>
403774cf:	090c      	movi.n	a9, 0
403774d1:	f4c381        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403774d4:	0020c0        	memw
403774d7:	a8a8      	l32i.n	a10, a8, 40
403774d9:	00acb2        	movi	a11, 0xfffffc00
403774dc:	10aab0        	and	a10, a10, a11
403774df:	2099a0        	or	a9, a9, a10
403774e2:	0020c0        	memw
403774e5:	a899      	s32i.n	a9, a8, 40
    dev->cmd.val |= usr_pe;
403774e7:	0020c0        	memw
403774ea:	0898      	l32i.n	a9, a8, 0
403774ec:	f4c5a1        	l32r	a10, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
403774ef:	2099a0        	or	a9, a9, a10
403774f2:	0020c0        	memw
403774f5:	006892        	s32i	a9, a8, 0
    return (dev->cmd.val == 0);
403774f8:	f4ba81        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403774fb:	0020c0        	memw
403774fe:	0878      	l32i.n	a7, a8, 0
    //input data
    spi_flash_ll_set_miso_bitlen(&SPIMEM_LL_APB, miso_len);

    spi_flash_ll_user_start(&SPIMEM_LL_APB, false);
    while(!spi_flash_ll_cmd_is_done(&SPIMEM_LL_APB)) {
40377500:	ff4756        	bnez	a7, 403774f8 <bootloader_flash_execute_command_common+0x240>
 * @param user1_reg user1_reg
 * @param user2_reg user2_reg
 */
static inline void spimem_flash_ll_set_common_command_register_info(spi_mem_dev_t *dev, uint32_t ctrl_reg, uint32_t user_reg, uint32_t user1_reg, uint32_t user2_reg)
{
    dev->ctrl.val = ctrl_reg;
40377503:	5198      	l32i.n	a9, a1, 20
40377505:	0020c0        	memw
40377508:	2899      	s32i.n	a9, a8, 8
    dev->user.val = user_reg;
4037750a:	6198      	l32i.n	a9, a1, 24
4037750c:	0020c0        	memw
4037750f:	6899      	s32i.n	a9, a8, 24
    dev->user1.val = user1_reg;
40377511:	7198      	l32i.n	a9, a1, 28
40377513:	0020c0        	memw
40377516:	7899      	s32i.n	a9, a8, 28
    dev->user2.val = user2_reg;
40377518:	8198      	l32i.n	a9, a1, 32
4037751a:	0020c0        	memw
4037751d:	8899      	s32i.n	a9, a8, 32
    }
    spi_flash_ll_set_common_command_register_info(&SPIMEM_LL_APB, old_ctrl_reg, old_user_reg, old_user1_reg, old_user2_reg);

    uint32_t output_data = 0;
4037751f:	080c      	movi.n	a8, 0
40377521:	0189      	s32i.n	a8, a1, 0
    spi_flash_ll_get_buffer_data(&SPIMEM_LL_APB, &output_data, miso_len / 8);
40377523:	413320        	srli	a3, a2, 3
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
40377526:	148320        	extui	a8, a2, 3, 2
40377529:	f8cc      	bnez.n	a8, 4037753c <bootloader_flash_execute_command_common+0x284>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037752b:	03cd      	mov.n	a12, a3
4037752d:	f4b5b1        	l32r	a11, 40374804 <_iram_text_start+0x400> (60002058 <SPIMEM1+0x58>)
40377530:	01ad      	mov.n	a10, a1
40377532:	f3e881        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40377535:	0008e0        	callx8	a8
40377538:	000e06        	j	40377574 <bootloader_flash_execute_command_common+0x2bc>
4037753b:	034d00        	lsi	f0, a13, 12
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037753e:	015d      	mov.n	a5, a1
40377540:	000a06        	j	4037756c <bootloader_flash_execute_command_common+0x2b4>
40377543:	460c00        	lsi	f0, a12, 0x118
            int word_len = MIN(sizeof(uint32_t), copy_len);
40377546:	636460        	minu	a6, a4, a6
            uint32_t word = dev->data_buf[i];
40377549:	14c782        	addi	a8, a7, 20
4037754c:	f4a591        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037754f:	a08890        	addx4	a8, a8, a9
40377552:	0020c0        	memw
40377555:	2888      	l32i.n	a8, a8, 8
40377557:	3189      	s32i.n	a8, a1, 12
            memcpy(buffer, &word, word_len);
40377559:	06cd      	mov.n	a12, a6
4037755b:	b1cb      	addi.n	a11, a1, 12
4037755d:	05ad      	mov.n	a10, a5
4037755f:	f3dd81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40377562:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
40377565:	565a      	add.n	a5, a6, a5
            copy_len -= word_len;
40377567:	c04460        	sub	a4, a4, a6
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037756a:	771b      	addi.n	a7, a7, 1
4037756c:	833b      	addi.n	a8, a3, 3
4037756e:	418280        	srli	a8, a8, 2
40377571:	cf3787        	bltu	a7, a8, 40377544 <bootloader_flash_execute_command_common+0x28c>
    uint32_t ret = output_data;
40377574:	0188      	l32i.n	a8, a1, 0
    if (miso_len < 32) {
40377576:	f91c      	movi.n	a9, 31
40377578:	0d3927        	bltu	a9, a2, 40377589 <bootloader_flash_execute_command_common+0x2d1>
        //set unused bits to 0
        ret &= ~(UINT32_MAX << miso_len);
4037757b:	f97c      	movi.n	a9, -1
4037757d:	401200        	ssl	a2
40377580:	a19900        	sll	a9, a9
40377583:	109980        	and	a9, a9, a8
40377586:	308980        	xor	a8, a9, a8
    }
    return ret;
}
40377589:	082d      	mov.n	a2, a8
4037758b:	f01d      	retw.n
4037758d:	000000        	ill

40377590 <bootloader_execute_flash_command>:

uint32_t IRAM_ATTR bootloader_execute_flash_command(uint8_t command, uint32_t mosi_data, uint8_t mosi_len, uint8_t miso_len)
{
40377590:	006136        	entry	a1, 48
40377593:	20f330        	or	a15, a3, a3
40377596:	745050        	extui	a5, a5, 0, 8
    const uint8_t addr_len = 0;
    const uint8_t address = 0;
    const uint8_t dummy_len = 0;

    return bootloader_flash_execute_command_common(command, addr_len, address,
40377599:	006152        	s32i	a5, a1, 0
4037759c:	74e040        	extui	a14, a4, 0, 8
4037759f:	00a0d2        	movi	a13, 0
403775a2:	0dcd      	mov.n	a12, a13
403775a4:	0dbd      	mov.n	a11, a13
403775a6:	74a020        	extui	a10, a2, 0, 8
403775a9:	ffd0e5        	call8	403772b8 <bootloader_flash_execute_command_common>
            dummy_len, mosi_len, mosi_data, miso_len);
}
403775ac:	0a2d      	mov.n	a2, a10
403775ae:	f01d      	retw.n

403775b0 <bootloader_read_flash_id>:
{
    bootloader_execute_flash_command(CMD_WRDI, 0, 0, 0);   /* Exit OTP mode */
}

uint32_t IRAM_ATTR bootloader_read_flash_id(void)
{
403775b0:	004136        	entry	a1, 32
    uint32_t id = bootloader_execute_flash_command(CMD_RDID, 0, 0, 24);
403775b3:	8d1c      	movi.n	a13, 24
403775b5:	0c0c      	movi.n	a12, 0
403775b7:	20bcc0        	or	a11, a12, a12
403775ba:	9fa0a2        	movi	a10, 159
403775bd:	fffd25        	call8	40377590 <bootloader_execute_flash_command>
    id = ((id & 0xff) << 16) | ((id >> 16) & 0xff) | (id & 0xff00);
403775c0:	112a00        	slli	a2, a10, 16
403775c3:	752020        	extui	a2, a2, 16, 8
403775c6:	112200        	slli	a2, a2, 16
403775c9:	7580a0        	extui	a8, a10, 16, 8
403775cc:	202280        	or	a2, a2, a8
403775cf:	74a8a0        	extui	a10, a10, 8, 8
403775d2:	11aa80        	slli	a10, a10, 8
    return id;
}
403775d5:	2022a0        	or	a2, a2, a10
403775d8:	f01d      	retw.n
	...

403775dc <bootloader_flash_reset_chip>:
}

#endif //XMC_SUPPORT

esp_err_t IRAM_ATTR bootloader_flash_reset_chip(void)
{
403775dc:	004136        	entry	a1, 32
    SPIMEM1.ctrl2.sync_reset = 0;
403775df:	f48071        	l32r	a7, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
403775e2:	0020c0        	memw
403775e5:	0427a2        	l32i	a10, a7, 16
403775e8:	f48881        	l32r	a8, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
403775eb:	109a80        	and	a9, a10, a8
403775ee:	0020c0        	memw
403775f1:	4799      	s32i.n	a9, a7, 16
    SPIMEM0.ctrl2.sync_reset = 0;
403775f3:	f48691        	l32r	a9, 4037480c <_iram_text_start+0x408> (60003000 <SPIMEM0>)
403775f6:	0020c0        	memw
403775f9:	49b8      	l32i.n	a11, a9, 16
403775fb:	10ab80        	and	a10, a11, a8
403775fe:	0020c0        	memw
40377601:	49a9      	s32i.n	a10, a9, 16
    SPIMEM1.ctrl2.sync_reset = 1;
40377603:	0020c0        	memw
40377606:	47c8      	l32i.n	a12, a7, 16
40377608:	f3c5a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037760b:	20bca0        	or	a11, a12, a10
4037760e:	0020c0        	memw
40377611:	47b9      	s32i.n	a11, a7, 16
    SPIMEM0.ctrl2.sync_reset = 1;
40377613:	0020c0        	memw
40377616:	49b8      	l32i.n	a11, a9, 16
40377618:	20aba0        	or	a10, a11, a10
4037761b:	0020c0        	memw
4037761e:	49a9      	s32i.n	a10, a9, 16
    SPIMEM1.ctrl2.sync_reset = 0;
40377620:	0020c0        	memw
40377623:	47b8      	l32i.n	a11, a7, 16
40377625:	10ab80        	and	a10, a11, a8
40377628:	0020c0        	memw
4037762b:	47a9      	s32i.n	a10, a7, 16
    SPIMEM0.ctrl2.sync_reset = 0;
4037762d:	0020c0        	memw
40377630:	49a8      	l32i.n	a10, a9, 16
40377632:	108a80        	and	a8, a10, a8
40377635:	0020c0        	memw
40377638:	4989      	s32i.n	a8, a9, 16
    spi_flash_ll_sync_reset();
    // Seems that sync_reset cannot make host totally idle.'
    // Sending an extra(useless) command to make the host idle in order to send reset command.
    bootloader_execute_flash_command(0x05, 0, 0, 0);
4037763a:	0d0c      	movi.n	a13, 0
4037763c:	0dcd      	mov.n	a12, a13
4037763e:	20bdd0        	or	a11, a13, a13
40377641:	5a0c      	movi.n	a10, 5
40377643:	fff4e5        	call8	40377590 <bootloader_execute_flash_command>
    return dev->cmd.val == 0;
40377646:	0020c0        	memw
40377649:	0788      	l32i.n	a8, a7, 0
#if CONFIG_IDF_TARGET_ESP32
    if (SPI1.ext2.st != 0)
#else
    if (!spimem_flash_ll_host_idle(&SPIMEM1))
4037764b:	b8dc      	bnez.n	a8, 4037766a <bootloader_flash_reset_chip+0x8e>
#endif
    {
        return ESP_FAIL;
    }
    bootloader_execute_flash_command(0x66, 0, 0, 0);
4037764d:	0d0c      	movi.n	a13, 0
4037764f:	0dcd      	mov.n	a12, a13
40377651:	0dbd      	mov.n	a11, a13
40377653:	66a0a2        	movi	a10, 102
40377656:	fff3a5        	call8	40377590 <bootloader_execute_flash_command>
    bootloader_execute_flash_command(0x99, 0, 0, 0);
40377659:	0d0c      	movi.n	a13, 0
4037765b:	0dcd      	mov.n	a12, a13
4037765d:	0dbd      	mov.n	a11, a13
4037765f:	99a0a2        	movi	a10, 153
40377662:	fff2e5        	call8	40377590 <bootloader_execute_flash_command>

    return ESP_OK;
40377665:	020c      	movi.n	a2, 0
40377667:	000046        	j	4037766c <bootloader_flash_reset_chip+0x90>
        return ESP_FAIL;
4037766a:	f27c      	movi.n	a2, -1
}
4037766c:	f01d      	retw.n
	...

40377670 <bootloader_flash_is_octal_mode_enabled>:

bool IRAM_ATTR bootloader_flash_is_octal_mode_enabled(void)
{
40377670:	004136        	entry	a1, 32
    return EFUSE.rd_repeat_data3.flash_type;
40377673:	f3f881        	l32r	a8, 40374654 <_iram_text_start+0x250> (60007000 <EFUSE>)
40377676:	0020c0        	memw
40377679:	f828      	l32i.n	a2, a8, 60
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    return efuse_ll_get_flash_type();
#else
    return false;
#endif
}
4037767b:	042920        	extui	a2, a2, 9, 1
4037767e:	f01d      	retw.n

40377680 <esp_flash_encryption_enabled>:
 * would require the caller component to include `efuse` as part of its `REQUIRES` or
 * `PRIV_REQUIRES` entries.
 * Attribute IRAM_ATTR must be specified for the app build.
 */
bool IRAM_ATTR esp_flash_encryption_enabled(void)
{
40377680:	004136        	entry	a1, 32
#ifndef CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
    return efuse_hal_flash_encryption_enabled();
40377683:	fe7a25        	call8	40375e24 <efuse_hal_flash_encryption_enabled>
        }
        flash_crypt_cnt >>= 1;
    }
    return enabled;
#endif // CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
}
40377686:	0a2d      	mov.n	a2, a10
40377688:	f01d      	retw.n
	...

4037768c <s_do_cache_invalidate>:
    *out_caps = found_block->caps;
    return ESP_OK;
}

static void IRAM_ATTR NOINLINE_ATTR s_do_cache_invalidate(uint32_t vaddr_start, uint32_t size)
{
4037768c:	004136        	entry	a1, 32
4037768f:	20a220        	or	a10, a2, a2
40377692:	20b330        	or	a11, a3, a3
     * easy way to sync between cache and external memory wrt
     * certain range. So we do a full sync here
     */
    cache_sync();
#else   //Other chips
    cache_hal_invalidate_addr(vaddr_start, size);
40377695:	0549e5        	call8	4037cb34 <cache_hal_invalidate_addr>
#endif // CONFIG_IDF_TARGET_ESP32
}
40377698:	000090        	retw
	...

4037769c <s_do_mapping>:
    return actual_mapped_len;
}
#endif

static void IRAM_ATTR NOINLINE_ATTR s_do_mapping(mmu_target_t target, uint32_t vaddr_start, esp_paddr_t paddr_start, uint32_t size)
{
4037769c:	006136        	entry	a1, 48
    /**
     * Disable Cache, after this function, involved code and data should be placed in internal RAM.
     *
     * @note we call this for now, but this will be refactored to move out of `spi_flash`
     */
    spi_flash_disable_interrupts_caches_and_other_cpu();
4037769f:	002025        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
    uint32_t actual_mapped_len = 0;
403776a2:	00a0a2        	movi	a10, 0
403776a5:	01a9      	s32i.n	a10, a1, 0
    mmu_hal_map_region(0, target, vaddr_start, paddr_start, size, &actual_mapped_len);
403776a7:	01fd      	mov.n	a15, a1
403776a9:	05ed      	mov.n	a14, a5
403776ab:	04dd      	mov.n	a13, a4
403776ad:	03cd      	mov.n	a12, a3
403776af:	02bd      	mov.n	a11, a2
403776b1:	056f65        	call8	4037cda8 <mmu_hal_map_region>
    uint32_t vaddr_end = vaddr_start + len - 1;
403776b4:	a35a      	add.n	a10, a3, a5
403776b6:	aa0b      	addi.n	a10, a10, -1
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
403776b8:	f45691        	l32r	a9, 40374810 <_iram_text_start+0x40c> (41ffffff <_coredump_iram_end+0x1c7e0ff>)
403776bb:	629930        	lsi	f3, a9, 0x188
403776be:	f45581        	l32r	a8, 40374814 <_iram_text_start+0x410> (43ffffff <_etext+0x1fe9da9>)
403776c1:	6288a0        	lsi	f10, a8, 0x188
403776c4:	880b      	addi.n	a8, a8, -1
403776c6:	608080        	neg	a8, a8
403776c9:	10b890        	and	a11, a8, a9
403776cc:	228897        	bany	a8, a9, 403776f2 <s_do_mapping+0x56>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
403776cf:	f45291        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
403776d2:	629930        	lsi	f3, a9, 0x188
403776d5:	f45181        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd608b>)
403776d8:	6288a0        	lsi	f10, a8, 0x188
403776db:	880b      	addi.n	a8, a8, -1
403776dd:	608080        	neg	a8, a8
403776e0:	148897        	bany	a8, a9, 403776f8 <s_do_mapping+0x5c>
        HAL_ASSERT(0);      //Out of region
403776e3:	f44fd1        	l32r	a13, 40374820 <_iram_text_start+0x41c> (3c024598 <_flash_rodata_start+0x4478>)
403776e6:	f44fc1        	l32r	a12, 40374824 <_iram_text_start+0x420> (3c02868c <__func__$9>)
403776e9:	3aa2b2        	movi	a11, 0x23a
403776ec:	f44fa1        	l32r	a10, 40374828 <_iram_text_start+0x424> (3c020480 <_flash_rodata_start+0x360>)
403776ef:	086625        	call8	4037fd50 <__assert_func>
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_IBUS0);    //Both cores have their own IBUS0
403776f2:	180c      	movi.n	a8, 1
403776f4:	0000c6        	j	403776fb <s_do_mapping+0x5f>
403776f7:	a08200        	addx4	a8, a2, a0
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_DBUS0);    //Both cores have their own DBUS0
403776fa:	8008      	l32i.n	a0, a0, 32
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE0_BUS : 0);
403776fc:	c10490        	mul16u	a0, a4, a9
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
403776ff:	4e          	.byte	0x4e
40377700:	20c0f3        	ssip	f15, a0, 128
40377703:	0cd800        	lsi	f0, a8, 48
40377706:	1099d0        	and	a9, a9, a13
40377709:	3099d0        	xor	a9, a9, a13
4037770c:	0020c0        	memw
4037770f:	0c99      	s32i.n	a9, a12, 0
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE1_BUS : 0);
40377711:	419280        	srli	a9, a8, 2
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
40377714:	f34ac1        	l32r	a12, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
40377717:	0020c0        	memw
4037771a:	0cd8      	l32i.n	a13, a12, 0
4037771c:	1099d0        	and	a9, a9, a13
4037771f:	3099d0        	xor	a9, a9, a13
40377722:	0020c0        	memw
40377725:	0c99      	s32i.n	a9, a12, 0
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
40377727:	1bec      	bnez.n	a11, 4037774c <s_do_mapping+0xb0>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
40377729:	f43bb1        	l32r	a11, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037772c:	62bb30        	lsi	f3, a11, 0x188
4037772f:	f43b91        	l32r	a9, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd608b>)
40377732:	6299a0        	lsi	f10, a9, 0x188
40377735:	990b      	addi.n	a9, a9, -1
40377737:	609090        	neg	a9, a9
4037773a:	0e89b7        	bany	a9, a11, 4037774c <s_do_mapping+0xb0>
        HAL_ASSERT(0);      //Out of region
4037773d:	f438d1        	l32r	a13, 40374820 <_iram_text_start+0x41c> (3c024598 <_flash_rodata_start+0x4478>)
40377740:	f439c1        	l32r	a12, 40374824 <_iram_text_start+0x420> (3c02868c <__func__$9>)
40377743:	3aa2b2        	movi	a11, 0x23a
40377746:	f438a1        	l32r	a10, 40374828 <_iram_text_start+0x424> (3c020480 <_flash_rodata_start+0x360>)
40377749:	086065        	call8	4037fd50 <__assert_func>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE1_BUS : 0);
4037774c:	988a      	add.n	a9, a8, a8
4037774e:	2a0c      	movi.n	a10, 2
40377750:	1099a0        	and	a9, a9, a10
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
40377753:	f339a1        	l32r	a10, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
40377756:	0020c0        	memw
40377759:	0ab8      	l32i.n	a11, a10, 0
4037775b:	1099b0        	and	a9, a9, a11
4037775e:	3099b0        	xor	a9, a9, a11
40377761:	0020c0        	memw
40377764:	0a99      	s32i.n	a9, a10, 0
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE0_BUS : 0);
40377766:	418380        	srli	a8, a8, 3
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
40377769:	f33491        	l32r	a9, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
4037776c:	0020c0        	memw
4037776f:	09a8      	l32i.n	a10, a9, 0
40377771:	1088a0        	and	a8, a8, a10
40377774:	3088a0        	xor	a8, a8, a10
40377777:	0020c0        	memw
4037777a:	0989      	s32i.n	a8, a9, 0
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    bus_mask = cache_ll_l1_get_bus(0, vaddr_start, size);
    cache_ll_l1_enable_bus(1, bus_mask);
#endif

    s_do_cache_invalidate(vaddr_start, size);
4037777c:	05bd      	mov.n	a11, a5
4037777e:	03ad      	mov.n	a10, a3
40377780:	fff0a5        	call8	4037768c <s_do_cache_invalidate>

    //enable Cache, after this function, internal RAM access is no longer mandatory
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377783:	002465        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>

    ESP_EARLY_LOGV(TAG, "actual_mapped_len is 0x%"PRIx32, actual_mapped_len);
}
40377786:	f01d      	retw.n

40377788 <s_do_unmapping>:
#endif //  #if (SOC_MMU_PERIPH_NUM == 2)
}
#endif

static void IRAM_ATTR NOINLINE_ATTR s_do_unmapping(uint32_t vaddr_start, uint32_t size)
{
40377788:	004136        	entry	a1, 32
    /**
     * Disable Cache, after this function, involved code and data should be placed in internal RAM.
     *
     * @note we call this for now, but this will be refactored to move out of `spi_flash`
     */
    spi_flash_disable_interrupts_caches_and_other_cpu();
4037778b:	001165        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
    mmu_hal_unmap_region(0, vaddr_start, size);
4037778e:	20c330        	or	a12, a3, a3
40377791:	02bd      	mov.n	a11, a2
40377793:	0a0c      	movi.n	a10, 0
40377795:	056ce5        	call8	4037ce64 <mmu_hal_unmap_region>

    s_unmapping_operation(vaddr_start, size);

    //enable Cache, after this function, internal RAM access is no longer mandatory
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377798:	0022e5        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>
}
4037779b:	f01d      	retw.n
4037779d:	000000        	ill

403777a0 <s_vaddr_to_paddr>:

/*---------------------------------------------------------------
    Helper APIs for conversion between vaddr and paddr
---------------------------------------------------------------*/
static bool NOINLINE_ATTR IRAM_ATTR s_vaddr_to_paddr(uint32_t vaddr, esp_paddr_t *out_paddr, mmu_target_t *out_target)
{
403777a0:	004136        	entry	a1, 32
    //we call this for now, but this will be refactored to move out of `spi_flash`
    spi_flash_disable_interrupts_caches_and_other_cpu();
403777a3:	000fe5        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
    bool is_mapped = mmu_hal_vaddr_to_paddr(0, vaddr, out_paddr, out_target);
403777a6:	20d440        	or	a13, a4, a4
403777a9:	03cd      	mov.n	a12, a3
403777ab:	02bd      	mov.n	a11, a2
403777ad:	00a0a2        	movi	a10, 0
403777b0:	0571a5        	call8	4037cecc <mmu_hal_vaddr_to_paddr>
403777b3:	0a2d      	mov.n	a2, a10
#if SOC_MMU_PER_EXT_MEM_TARGET
    if (!is_mapped) {
        is_mapped = mmu_hal_vaddr_to_paddr(1, vaddr, out_paddr, out_target);
    }
#endif
    spi_flash_enable_interrupts_caches_and_other_cpu();
403777b5:	002125        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>

    return is_mapped;
}
403777b8:	f01d      	retw.n
	...

403777bc <esp_mmu_paddr_find_caps>:
{
403777bc:	004136        	entry	a1, 32
    if (out_caps == NULL) {
403777bf:	055316        	beqz	a3, 40377818 <esp_mmu_paddr_find_caps+0x5c>
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
403777c2:	0a0c      	movi.n	a10, 0
    mem_block_t *found_block = NULL;
403777c4:	0aed      	mov.n	a14, a10
    bool found = false;
403777c6:	0add      	mov.n	a13, a10
403777c8:	000e06        	j	40377804 <esp_mmu_paddr_find_caps+0x48>
403777cb:	8aa000        	round.s	a10, f0, 0
        TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
403777ce:	1791a0        	lsi	f10, a1, 92
403777d1:	8890f4        	lsi	f15, a0, 0x220
403777d4:	98c8b0        	lsi	f11, a8, 0x260
403777d7:	0c8d      	mov.n	a8, a12
403777d9:	0006c6        	j	403777f8 <esp_mmu_paddr_find_caps+0x3c>
            if (mem_block == TAILQ_FIRST(&region->mem_block_head) || mem_block == TAILQ_LAST(&region->mem_block_head, mem_block_head_)) {
403777dc:	1618c7        	beq	a8, a12, 403777f6 <esp_mmu_paddr_find_caps+0x3a>
403777df:	a09aa0        	addx4	a9, a10, a10
403777e2:	f412b1        	l32r	a11, 4037482c <_iram_text_start+0x428> (3fc95eac <s_mmu_ctx>)
403777e5:	b099b0        	addx8	a9, a9, a11
403777e8:	a998      	l32i.n	a9, a9, 40
403777ea:	1998      	l32i.n	a9, a9, 4
403777ec:	0998      	l32i.n	a9, a9, 0
403777ee:	041987        	beq	a9, a8, 403777f6 <esp_mmu_paddr_find_caps+0x3a>
            if (mem_block->paddr_start == paddr) {
403777f1:	6898      	l32i.n	a9, a8, 24
403777f3:	071927        	beq	a9, a2, 403777fe <esp_mmu_paddr_find_caps+0x42>
        TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
403777f6:	9888      	l32i.n	a8, a8, 36
403777f8:	fe0856        	bnez	a8, 403777dc <esp_mmu_paddr_find_caps+0x20>
403777fb:	0000c6        	j	40377802 <esp_mmu_paddr_find_caps+0x46>
                found_block = mem_block;
403777fe:	08ed      	mov.n	a14, a8
                found = true;
40377800:	1d0c      	movi.n	a13, 1
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
40377802:	aa1b      	addi.n	a10, a10, 1
40377804:	f40a81        	l32r	a8, 4037482c <_iram_text_start+0x428> (3fc95eac <s_mmu_ctx>)
40377807:	0888      	l32i.n	a8, a8, 0
40377809:	bf3a87        	bltu	a10, a8, 403777cc <esp_mmu_paddr_find_caps+0x10>
    if (!found) {
4037780c:	0d9c      	beqz.n	a13, 40377820 <esp_mmu_paddr_find_caps+0x64>
    *out_caps = found_block->caps;
4037780e:	5e88      	l32i.n	a8, a14, 20
40377810:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40377812:	020c      	movi.n	a2, 0
40377814:	0002c6        	j	40377823 <esp_mmu_paddr_find_caps+0x67>
40377817:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4037781a:	010602        	l8ui	a0, a6, 1
4037781d:	000000        	ill
        return ESP_ERR_NOT_FOUND;
40377820:	05a122        	movi	a2, 0x105
}
40377823:	f01d      	retw.n
40377825:	000000        	ill

40377828 <esp_heap_adjust_alignment_to_hw>:
#endif

#define CAPS_NEEDING_ALIGNMENT (MALLOC_CAP_DMA|MALLOC_CAP_DMA_DESC_AHB|MALLOC_CAP_DMA_DESC_AXI|MALLOC_CAP_CACHE_ALIGNED)

HEAP_IRAM_ATTR void esp_heap_adjust_alignment_to_hw(size_t *p_alignment, size_t *p_size, uint32_t *p_caps)
{
40377828:	006136        	entry	a1, 48
    size_t size = *p_size;
4037782b:	002362        	l32i	a6, a3, 0
    size_t alignment = *p_alignment;
4037782e:	002252        	l32i	a5, a2, 0
    uint32_t caps = *p_caps;
40377831:	002472        	l32i	a7, a4, 0

    //Bail out early if we don't need alignment
    if (!(caps & CAPS_NEEDING_ALIGNMENT)) {
40377834:	f3ff81        	l32r	a8, 40374830 <_iram_text_start+0x42c> (e0008 <UserFrameTotalSize+0xdff08>)
40377837:	510787        	bnone	a7, a8, 4037788c <esp_heap_adjust_alignment_to_hw+0x64>
#endif
    return;
#endif

    //Ask cache driver what alignment is applicable here.
    size_t cache_alignment_bytes = 0;
4037783a:	080c      	movi.n	a8, 0
4037783c:	0189      	s32i.n	a8, a1, 0
    esp_err_t ret = esp_cache_get_alignment(caps, &cache_alignment_bytes);
4037783e:	01bd      	mov.n	a11, a1
40377840:	07ad      	mov.n	a10, a7
40377842:	01c6a5        	call8	403794ac <esp_cache_get_alignment>
    if (ret != ESP_OK) {
40377845:	ca8c      	beqz.n	a10, 40377855 <esp_heap_adjust_alignment_to_hw+0x2d>
        //This is not supposed to happen.
        *p_caps |= MALLOC_CAP_INVALID;
40377847:	0488      	l32i.n	a8, a4, 0
40377849:	f33491        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037784c:	208890        	or	a8, a8, a9
4037784f:	0489      	s32i.n	a8, a4, 0
        return;
40377851:	000dc6        	j	4037788c <esp_heap_adjust_alignment_to_hw+0x64>
40377854:	018800        	slli	a8, a8, 32
    // do this because:
    // - DMA alignment in current chips always is a power of two, and is unlikely to ever
    //   be something else,
    // - Requested alignment is checked by heap_caps_aligned_check_args to be a power
    //   of two.
    if (cache_alignment_bytes > alignment) {
40377857:	013587        	bltu	a5, a8, 4037785c <esp_heap_adjust_alignment_to_hw+0x34>
    size_t alignment = *p_alignment;
4037785a:	058d      	mov.n	a8, a5
        alignment = cache_alignment_bytes;
    }
    // Align up `size` to resulting alignment as well.
    size = (size + alignment - 1) & (~(alignment - 1));
4037785c:	686a      	add.n	a6, a8, a6
4037785e:	660b      	addi.n	a6, a6, -1
40377860:	609080        	neg	a9, a8
40377863:	106690        	and	a6, a6, a9

    // For the heap allocator itself, there's no difference between data and descriptor DMA; the regions
    // are only marked as DMA-capable.
    if (caps & (MALLOC_CAP_DMA_DESC_AHB | MALLOC_CAP_DMA_DESC_AXI)) {
40377866:	159170        	extui	a9, a7, 17, 2
40377869:	00b916        	beqz	a9, 40377878 <esp_heap_adjust_alignment_to_hw+0x50>
        caps &= ~(MALLOC_CAP_DMA_DESC_AHB | MALLOC_CAP_DMA_DESC_AXI);
4037786c:	f3f291        	l32r	a9, 40374834 <_iram_text_start+0x430> (fff9ffff <_rtc_reserved_end+0x9fe9ffff>)
4037786f:	109790        	and	a9, a7, a9
        caps |= MALLOC_CAP_DMA;
40377872:	08a072        	movi	a7, 8
40377875:	207970        	or	a7, a9, a7
    }

    // Workaround: the heap allocator doesn't have regions marked `MALLOC_CAP_DMA | MALLOC_CAP_SPIRAM`
    // so we need to request those without the DMA flag.
    if (caps & MALLOC_CAP_SPIRAM) {
40377878:	0467a7        	bbci	a7, 10, 40377880 <esp_heap_adjust_alignment_to_hw+0x58>
        caps &= ~MALLOC_CAP_DMA;
4037787b:	797c      	movi.n	a9, -9
4037787d:	107790        	and	a7, a7, a9
        //memory, so the MALLOC_CAP_SPIRAM|MALLOC_CAP_DMA_DESC_* simply will not return any
        //usable memory.
    }
    // MALLOC_CAP_CACHE_ALIGNED is not a real flag the heap_base component will understand; it
    // only sets alignment (which we handled here)
    caps &= ~ MALLOC_CAP_CACHE_ALIGNED;
40377880:	f3ee91        	l32r	a9, 40374838 <_iram_text_start+0x434> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
40377883:	107790        	and	a7, a7, a9

    *p_size = size;
40377886:	0369      	s32i.n	a6, a3, 0
    *p_alignment = alignment;
40377888:	0289      	s32i.n	a8, a2, 0
    *p_caps = caps;
4037788a:	0479      	s32i.n	a7, a4, 0
}
4037788c:	f01d      	retw.n
	...

40377890 <spi_flash_disable_cache>:
    spi_flash_restore_cache(0, 0); // TODO cache_value should be non-zero
#endif
}

void IRAM_ATTR spi_flash_disable_cache(uint32_t cpuid, uint32_t *saved_state)
{
40377890:	004136        	entry	a1, 32
#if SOC_BRANCH_PREDICTOR_SUPPORTED
    //branch predictor will start cache request as well
    esp_cpu_branch_prediction_disable();
#endif
    cache_hal_suspend(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377893:	02a0b2        	movi	a11, 2
40377896:	01a0a2        	movi	a10, 1
40377899:	051365        	call8	4037c9d0 <cache_hal_suspend>
}
4037789c:	000090        	retw
	...

403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>:
{
403778a0:	004136        	entry	a1, 32
    asm volatile ("mov %0, sp;" : "=r" (sp));
403778a3:	209110        	or	a9, a1, a1
    return ((intptr_t)p >= SOC_DRAM_LOW && (intptr_t)p < SOC_DRAM_HIGH);
403778a6:	f37781        	l32r	a8, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
403778a9:	808980        	add	a8, a9, a8
           || esp_ptr_in_rtc_dram_fast(sp)
403778ac:	f3e4a1        	l32r	a10, 4037483c <_iram_text_start+0x438> (77fff <UserFrameTotalSize+0x77eff>)
403778af:	1aba87        	bgeu	a10, a8, 403778cd <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403778b2:	f34e81        	l32r	a8, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403778b5:	809980        	add	a9, a9, a8
403778b8:	f34e81        	l32r	a8, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403778bb:	0eb897        	bgeu	a8, a9, 403778cd <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    assert(esp_task_stack_is_sane_cache_disabled());
403778be:	f3e0d1        	l32r	a13, 40374840 <_iram_text_start+0x43c> (3c0260d4 <_flash_rodata_start+0x5fb4>)
403778c1:	f3e0c1        	l32r	a12, 40374844 <_iram_text_start+0x440> (3c028718 <__func__$1>)
403778c4:	86a0b2        	movi	a11, 134
403778c7:	f3e0a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c0260c3 <_flash_rodata_start+0x5fa3>)
403778ca:	084865        	call8	4037fd50 <__assert_func>
    spi_flash_op_lock();
403778cd:	f3e581        	l32r	a8, 40374864 <_iram_text_start+0x460> (420099cc <spi_flash_op_lock>)
403778d0:	0008e0        	callx8	a8
    asm volatile (
403778d3:	03eb70        	rsr.prid	a7
403778d6:	047d70        	extui	a7, a7, 13, 1
    return (int)xt_utils_get_core_id();
403778d9:	076d      	mov.n	a6, a7
    assert(s_flash_op_cpu == -1);
403778db:	f3dc81        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9260c <s_flash_op_cpu>)
403778de:	0020c0        	memw
403778e1:	0888      	l32i.n	a8, a8, 0
403778e3:	0e0826        	beqi	a8, -1, 403778f5 <spi_flash_disable_interrupts_caches_and_other_cpu+0x55>
403778e6:	f3dad1        	l32r	a13, 40374850 <_iram_text_start+0x44c> (3c0260fc <_flash_rodata_start+0x5fdc>)
403778e9:	f3d6c1        	l32r	a12, 40374844 <_iram_text_start+0x440> (3c028718 <__func__$1>)
403778ec:	8ea0b2        	movi	a11, 142
403778ef:	f3d6a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c0260c3 <_flash_rodata_start+0x5fa3>)
403778f2:	0845e5        	call8	4037fd50 <__assert_func>
    s_flash_op_cpu = cpuid;
403778f5:	f3d581        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9260c <s_flash_op_cpu>)
403778f8:	0020c0        	memw
403778fb:	0879      	s32i.n	a7, a8, 0
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
403778fd:	0412e5        	call8	4037ba2c <xTaskGetSchedulerState>
40377900:	111a66        	bnei	a10, 1, 40377915 <spi_flash_disable_interrupts_caches_and_other_cpu+0x75>
        assert(other_cpuid == 1);
40377903:	058716        	beqz	a7, 4037795f <spi_flash_disable_interrupts_caches_and_other_cpu+0xbf>
40377906:	f3d3d1        	l32r	a13, 40374854 <_iram_text_start+0x450> (3c026114 <_flash_rodata_start+0x5ff4>)
40377909:	f3cec1        	l32r	a12, 40374844 <_iram_text_start+0x440> (3c028718 <__func__$1>)
4037790c:	98a0b2        	movi	a11, 152
4037790f:	f3cea1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c0260c3 <_flash_rodata_start+0x5fa3>)
40377912:	0843e5        	call8	4037fd50 <__assert_func>
            vTaskSuspendAll();
40377915:	038925        	call8	4037b1a8 <vTaskSuspendAll>
40377918:	03eb80        	rsr.prid	a8
4037791b:	048d80        	extui	a8, a8, 13, 1
4037791e:	086d      	mov.n	a6, a8
            other_cpuid = (cpuid == 0) ? 1 : 0;
40377920:	40f8a0        	nsau	a10, a8
40377923:	41a5a0        	srli	a10, a10, 5
            s_flash_op_cpu = cpuid;
40377926:	f3c991        	l32r	a9, 4037484c <_iram_text_start+0x448> (3fc9260c <s_flash_op_cpu>)
40377929:	0020c0        	memw
4037792c:	006982        	s32i	a8, a9, 0
            s_flash_op_can_start = false;
4037792f:	090c      	movi.n	a9, 0
40377931:	f3c981        	l32r	a8, 40374858 <_iram_text_start+0x454> (3fc95edb <s_flash_op_can_start>)
40377934:	0020c0        	memw
40377937:	004892        	s8i	a9, a8, 0
            ipc_call_was_send_to_other_cpu = esp_ipc_call_nonblocking(other_cpuid, &spi_flash_op_block_func, (void *) other_cpuid) == ESP_OK;
4037793a:	0acd      	mov.n	a12, a10
4037793c:	f3c8b1        	l32r	a11, 4037485c <_iram_text_start+0x458> (40377980 <spi_flash_op_block_func>)
4037793f:	f3ca81        	l32r	a8, 40374868 <_iram_text_start+0x464> (420025cc <esp_ipc_call_nonblocking>)
40377942:	0008e0        	callx8	a8
40377945:	0a7d      	mov.n	a7, a10
            if (!ipc_call_was_send_to_other_cpu) {
40377947:	002a16        	beqz	a10, 4037794d <spi_flash_disable_interrupts_caches_and_other_cpu+0xad>
                xTaskResumeAll();
4037794a:	0424a5        	call8	4037bb94 <xTaskResumeAll>
        } while (!ipc_call_was_send_to_other_cpu);
4037794d:	fc4756        	bnez	a7, 40377915 <spi_flash_disable_interrupts_caches_and_other_cpu+0x75>
        while (!s_flash_op_can_start) {
40377950:	f3c281        	l32r	a8, 40374858 <_iram_text_start+0x454> (3fc95edb <s_flash_op_can_start>)
40377953:	0020c0        	memw
40377956:	000882        	l8ui	a8, a8, 0
40377959:	748080        	extui	a8, a8, 0, 8
4037795c:	ff0816        	beqz	a8, 40377950 <spi_flash_disable_interrupts_caches_and_other_cpu+0xb0>
    esp_intr_noniram_disable();
4037795f:	feb325        	call8	40376490 <esp_intr_noniram_disable>
    spi_flash_disable_cache(cpuid, &s_flash_op_cache_state[cpuid]);
40377962:	f3bfb1        	l32r	a11, 40374860 <_iram_text_start+0x45c> (3fc95ee0 <s_flash_op_cache_state>)
40377965:	a0b6b0        	addx4	a11, a6, a11
40377968:	06ad      	mov.n	a10, a6
4037796a:	fff265        	call8	40377890 <spi_flash_disable_cache>
}
4037796d:	f01d      	retw.n
	...

40377970 <spi_flash_restore_cache>:

void IRAM_ATTR spi_flash_restore_cache(uint32_t cpuid, uint32_t saved_state)
{
40377970:	004136        	entry	a1, 32
    cache_hal_resume(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377973:	02a0b2        	movi	a11, 2
40377976:	01a0a2        	movi	a10, 1
40377979:	0508e5        	call8	4037ca08 <cache_hal_resume>
#if SOC_BRANCH_PREDICTOR_SUPPORTED
    esp_cpu_branch_prediction_enable();
#endif
}
4037797c:	000090        	retw
	...

40377980 <spi_flash_op_block_func>:
{
40377980:	004136        	entry	a1, 32
    vTaskSuspendAll();
40377983:	038265        	call8	4037b1a8 <vTaskSuspendAll>
    esp_intr_noniram_disable();
40377986:	feb0a5        	call8	40376490 <esp_intr_noniram_disable>
    s_flash_op_complete = false;
40377989:	f3b881        	l32r	a8, 4037486c <_iram_text_start+0x468> (3fc95eda <s_flash_op_complete>)
4037798c:	00a092        	movi	a9, 0
4037798f:	0020c0        	memw
40377992:	004892        	s8i	a9, a8, 0
    s_flash_op_can_start = true;
40377995:	f3b081        	l32r	a8, 40374858 <_iram_text_start+0x454> (3fc95edb <s_flash_op_can_start>)
40377998:	01a092        	movi	a9, 1
4037799b:	0020c0        	memw
4037799e:	004892        	s8i	a9, a8, 0
    while (!s_flash_op_complete) {
403779a1:	f3b281        	l32r	a8, 4037486c <_iram_text_start+0x468> (3fc95eda <s_flash_op_complete>)
403779a4:	0020c0        	memw
403779a7:	000882        	l8ui	a8, a8, 0
403779aa:	748080        	extui	a8, a8, 0, 8
403779ad:	ff0816        	beqz	a8, 403779a1 <spi_flash_op_block_func+0x21>
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
403779b0:	f3ac81        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc95ee0 <s_flash_op_cache_state>)
403779b3:	a08280        	addx4	a8, a2, a8
403779b6:	0028b2        	l32i	a11, a8, 0
403779b9:	02ad      	mov.n	a10, a2
403779bb:	fffb65        	call8	40377970 <spi_flash_restore_cache>
    esp_intr_noniram_enable();
403779be:	feb465        	call8	40376504 <esp_intr_noniram_enable>
    xTaskResumeAll();
403779c1:	041d25        	call8	4037bb94 <xTaskResumeAll>
}
403779c4:	f01d      	retw.n
	...

403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>:
{
403779c8:	004136        	entry	a1, 32
403779cb:	03eb70        	rsr.prid	a7
403779ce:	047d70        	extui	a7, a7, 13, 1
    assert(cpuid == s_flash_op_cpu);
403779d1:	f39e81        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9260c <s_flash_op_cpu>)
403779d4:	0020c0        	memw
403779d7:	002882        	l32i	a8, a8, 0
403779da:	0e1877        	beq	a8, a7, 403779ec <spi_flash_enable_interrupts_caches_and_other_cpu+0x24>
403779dd:	f3a4d1        	l32r	a13, 40374870 <_iram_text_start+0x46c> (3c026128 <_flash_rodata_start+0x6008>)
403779e0:	f3a5c1        	l32r	a12, 40374874 <_iram_text_start+0x470> (3c0286e4 <__func__$0>)
403779e3:	d0a0b2        	movi	a11, 208
403779e6:	f398a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c0260c3 <_flash_rodata_start+0x5fa3>)
403779e9:	083665        	call8	4037fd50 <__assert_func>
    assert(!(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED && cpuid != 0));
403779ec:	0403e5        	call8	4037ba2c <xTaskGetSchedulerState>
403779ef:	111a66        	bnei	a10, 1, 40377a04 <spi_flash_enable_interrupts_caches_and_other_cpu+0x3c>
403779f2:	00e716        	beqz	a7, 40377a04 <spi_flash_enable_interrupts_caches_and_other_cpu+0x3c>
403779f5:	f3a0d1        	l32r	a13, 40374878 <_iram_text_start+0x474> (3c026140 <_flash_rodata_start+0x6020>)
403779f8:	f39fc1        	l32r	a12, 40374874 <_iram_text_start+0x470> (3c0286e4 <__func__$0>)
403779fb:	d2a0b2        	movi	a11, 210
403779fe:	f392a1        	l32r	a10, 40374848 <_iram_text_start+0x444> (3c0260c3 <_flash_rodata_start+0x5fa3>)
40377a01:	0834e5        	call8	4037fd50 <__assert_func>
    s_flash_op_cpu = -1;
40377a04:	f39281        	l32r	a8, 4037484c <_iram_text_start+0x448> (3fc9260c <s_flash_op_cpu>)
40377a07:	f97c      	movi.n	a9, -1
40377a09:	0020c0        	memw
40377a0c:	0899      	s32i.n	a9, a8, 0
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
40377a0e:	f39481        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc95ee0 <s_flash_op_cache_state>)
40377a11:	a08780        	addx4	a8, a7, a8
40377a14:	08b8      	l32i.n	a11, a8, 0
40377a16:	07ad      	mov.n	a10, a7
40377a18:	fff565        	call8	40377970 <spi_flash_restore_cache>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
40377a1b:	040125        	call8	4037ba2c <xTaskGetSchedulerState>
40377a1e:	0a1a26        	beqi	a10, 1, 40377a2c <spi_flash_enable_interrupts_caches_and_other_cpu+0x64>
        s_flash_op_complete = true;
40377a21:	f39281        	l32r	a8, 4037486c <_iram_text_start+0x468> (3fc95eda <s_flash_op_complete>)
40377a24:	190c      	movi.n	a9, 1
40377a26:	0020c0        	memw
40377a29:	004892        	s8i	a9, a8, 0
    esp_intr_noniram_enable();
40377a2c:	201110        	or	a1, a1, a1
40377a2f:	fead65        	call8	40376504 <esp_intr_noniram_enable>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
40377a32:	201110        	or	a1, a1, a1
40377a35:	03ff65        	call8	4037ba2c <xTaskGetSchedulerState>
40377a38:	051a26        	beqi	a10, 1, 40377a41 <spi_flash_enable_interrupts_caches_and_other_cpu+0x79>
        xTaskResumeAll();
40377a3b:	201110        	or	a1, a1, a1
40377a3e:	041565        	call8	4037bb94 <xTaskResumeAll>
    spi_flash_op_unlock();
40377a41:	f38e81        	l32r	a8, 4037487c <_iram_text_start+0x478> (420099e0 <spi_flash_op_unlock>)
40377a44:	0008e0        	callx8	a8
}
40377a47:	f01d      	retw.n
40377a49:	000000        	ill

40377a4c <spi_flash_enable_cache>:
{
40377a4c:	004136        	entry	a1, 32
    spi_flash_restore_cache(0, 0); // TODO cache_value should be non-zero
40377a4f:	00a0b2        	movi	a11, 0
40377a52:	20abb0        	or	a10, a11, a11
40377a55:	fff1a5        	call8	40377970 <spi_flash_restore_cache>
}
40377a58:	000090        	retw
	...

40377a5c <spi_flash_cache_enabled>:

bool IRAM_ATTR spi_flash_cache_enabled(void)
{
40377a5c:	004136        	entry	a1, 32
    return cache_hal_is_cache_enabled(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377a5f:	02a0b2        	movi	a11, 2
40377a62:	01a0a2        	movi	a10, 1
40377a65:	0500e5        	call8	4037ca74 <cache_hal_is_cache_enabled>
}
40377a68:	202aa0        	or	a2, a10, a10
40377a6b:	f01d      	retw.n
40377a6d:	000000        	ill

40377a70 <is_page_mapped_in_cache>:
    esp_mmu_map_get_max_consecutive_free_block_size(caps, MMU_TARGET_FLASH0, &len);
    return len / CONFIG_MMU_PAGE_SIZE;
}

static bool IRAM_ATTR is_page_mapped_in_cache(uint32_t phys_addr, const void **out_ptr)
{
40377a70:	006136        	entry	a1, 48
    *out_ptr = NULL;
40377a73:	080c      	movi.n	a8, 0
40377a75:	0389      	s32i.n	a8, a3, 0
    mmu_mem_caps_t caps = 0;
40377a77:	0189      	s32i.n	a8, a1, 0

    esp_err_t err = esp_mmu_paddr_find_caps(phys_addr, &caps);
40377a79:	01bd      	mov.n	a11, a1
40377a7b:	02ad      	mov.n	a10, a2
40377a7d:	ffd3e5        	call8	403777bc <esp_mmu_paddr_find_caps>
    if (err == ESP_OK) {
40377a80:	1afc      	bnez.n	a10, 40377ab5 <is_page_mapped_in_cache+0x45>
    // On ESP32, we will always flush all, so always return true, and don't care the vaddr
#if !CONFIG_IDF_TARGET_ESP32
        uint32_t vaddr = 0;
40377a82:	080c      	movi.n	a8, 0
40377a84:	1189      	s32i.n	a8, a1, 4
        if (caps & MMU_MEM_CAP_EXEC) {
40377a86:	0188      	l32i.n	a8, a1, 0
40377a88:	106807        	bbci	a8, 0, 40377a9c <is_page_mapped_in_cache+0x2c>
            mmu_hal_paddr_to_vaddr(0, phys_addr, MMU_TARGET_FLASH0, MMU_VADDR_INSTRUCTION, &vaddr);
40377a8b:	e14b      	addi.n	a14, a1, 4
40377a8d:	2d0c      	movi.n	a13, 2
40377a8f:	01a0c2        	movi	a12, 1
40377a92:	20b220        	or	a11, a2, a2
40377a95:	052625        	call8	4037ccf8 <mmu_hal_paddr_to_vaddr>
40377a98:	000406        	j	40377aac <is_page_mapped_in_cache+0x3c>
40377a9b:	c1e200        	mul16u	a14, a2, a0
        } else {
            mmu_hal_paddr_to_vaddr(0, phys_addr, MMU_TARGET_FLASH0, MMU_VADDR_DATA, &vaddr);
40377a9e:	a0d204        	lsi	f0, a2, 0x280
40377aa1:	cdd001        	l32r	a0, 4036b1e4 <rom_rx_gain_force+0x364db8>
40377aa4:	02bd20        	andb	b11, b13, b2
40377aa7:	0a0c      	movi.n	a10, 0
40377aa9:	0524e5        	call8	4037ccf8 <mmu_hal_paddr_to_vaddr>
        }
        *out_ptr = (void *)vaddr;
40377aac:	1188      	l32i.n	a8, a1, 4
40377aae:	0389      	s32i.n	a8, a3, 0
#endif
        return true;
40377ab0:	120c      	movi.n	a2, 1
40377ab2:	000046        	j	40377ab7 <is_page_mapped_in_cache+0x47>
    }
    return false;
40377ab5:	020c      	movi.n	a2, 0
}
40377ab7:	f01d      	retw.n
40377ab9:	000000        	ill

40377abc <spi_flash_check_and_flush_cache>:

/* Validates if given flash address has corresponding cache mapping, if yes, flushes cache memories */
IRAM_ATTR bool spi_flash_check_and_flush_cache(size_t start_addr, size_t length)
{
40377abc:	006136        	entry	a1, 48
    bool ret = false;
    /* align start_addr & length to full MMU pages */
    uint32_t page_start_addr = start_addr & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377abf:	f37081        	l32r	a8, 40374880 <_iram_text_start+0x47c> (ffff0000 <_rtc_reserved_end+0x9fef0000>)
40377ac2:	104280        	and	a4, a2, a8
    length += (start_addr - page_start_addr);
40377ac5:	c02240        	sub	a2, a2, a4
40377ac8:	223a      	add.n	a2, a2, a3
    length = (length + SPI_FLASH_MMU_PAGE_SIZE - 1) & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377aca:	f26591        	l32r	a9, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40377acd:	529a      	add.n	a5, a2, a9
40377acf:	105580        	and	a5, a5, a8
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377ad2:	047d      	mov.n	a7, a4
    bool ret = false;
40377ad4:	020c      	movi.n	a2, 0
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377ad6:	000cc6        	j	40377b0d <spi_flash_check_and_flush_cache+0x51>
        if (addr >= g_rom_flashchip.chip_size) {
40377ad9:	f34581        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40377adc:	0888      	l32i.n	a8, a8, 0
40377ade:	1888      	l32i.n	a8, a8, 4
40377ae0:	043787        	bltu	a7, a8, 40377ae8 <spi_flash_check_and_flush_cache+0x2c>
            return false; /* invalid address */
40377ae3:	020c      	movi.n	a2, 0
40377ae5:	000a46        	j	40377b12 <spi_flash_check_and_flush_cache+0x56>
        }

        const void *vaddr = NULL;
40377ae8:	00a082        	movi	a8, 0
40377aeb:	006182        	s32i	a8, a1, 0
        if (is_page_mapped_in_cache(addr, &vaddr)) {
40377aee:	01bd      	mov.n	a11, a1
40377af0:	07ad      	mov.n	a10, a7
40377af2:	fff7e5        	call8	40377a70 <is_page_mapped_in_cache>
40377af5:	0a6d      	mov.n	a6, a10
40377af7:	00da16        	beqz	a10, 40377b08 <spi_flash_check_and_flush_cache+0x4c>
#if CONFIG_IDF_TARGET_ESP32
            cache_sync();
            return true;
#else // CONFIG_IDF_TARGET_ESP32
            if (vaddr != NULL) {
40377afa:	0021a2        	l32i	a10, a1, 0
40377afd:	007a16        	beqz	a10, 40377b08 <spi_flash_check_and_flush_cache+0x4c>
                cache_hal_invalidate_addr((uint32_t)vaddr, SPI_FLASH_MMU_PAGE_SIZE);
40377b00:	f361b1        	l32r	a11, 40374884 <_iram_text_start+0x480> (10000 <UserFrameTotalSize+0xff00>)
40377b03:	050325        	call8	4037cb34 <cache_hal_invalidate_addr>
                ret = true;
40377b06:	062d      	mov.n	a2, a6
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377b08:	f35f81        	l32r	a8, 40374884 <_iram_text_start+0x480> (10000 <UserFrameTotalSize+0xff00>)
40377b0b:	778a      	add.n	a7, a7, a8
40377b0d:	845a      	add.n	a8, a4, a5
40377b0f:	c63787        	bltu	a7, a8, 40377ad9 <spi_flash_check_and_flush_cache+0x1d>
#endif // CONFIG_IDF_TARGET_ESP32

        }
    }
    return ret;
}
40377b12:	f01d      	retw.n

40377b14 <spi_flash_guard_set>:
};

static const spi_flash_guard_funcs_t *s_flash_guard_ops;

void IRAM_ATTR spi_flash_guard_set(const spi_flash_guard_funcs_t *funcs)
{
40377b14:	004136        	entry	a1, 32
    s_flash_guard_ops = funcs;
40377b17:	f35c81        	l32r	a8, 40374888 <_iram_text_start+0x484> (3fc95ee8 <s_flash_guard_ops>)
40377b1a:	0829      	s32i.n	a2, a8, 0
}
40377b1c:	f01d      	retw.n
	...

40377b20 <esp_mspi_pin_init>:
    spi_flash_mmap_page_num_init(128);
}
#endif

void IRAM_ATTR esp_mspi_pin_init(void)
{
40377b20:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    bool octal_mspi_required = bootloader_flash_is_octal_mode_enabled();
40377b23:	ffb4e5        	call8	40377670 <bootloader_flash_is_octal_mode_enabled>
#if CONFIG_SPIRAM_MODE_OCT
    octal_mspi_required |= true;
#endif

    if (octal_mspi_required) {
40377b26:	008a16        	beqz	a10, 40377b32 <esp_mspi_pin_init+0x12>
        esp_rom_opiflash_pin_config();
40377b29:	f35881        	l32r	a8, 4037488c <_iram_text_start+0x488> (40000894 <esp_rom_opiflash_pin_config>)
40377b2c:	0008e0        	callx8	a8
        mspi_timing_set_pin_drive_strength();
40377b2f:	009a65        	call8	403784d4 <mspi_timing_set_pin_drive_strength>
    }
    //Set F4R4 board pin drive strength. TODO: IDF-3663
#endif
}
40377b32:	000090        	retw
40377b35:	000000        	ill

40377b38 <spi_flash_init_chip_state>:
    }
    esp_gpio_reserve(reserve_pin_mask);
}

esp_err_t IRAM_ATTR spi_flash_init_chip_state(void)
{
40377b38:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    if (bootloader_flash_is_octal_mode_enabled()) {
40377b3b:	ffb365        	call8	40377670 <bootloader_flash_is_octal_mode_enabled>
40377b3e:	00fa16        	beqz	a10, 40377b51 <spi_flash_init_chip_state+0x19>
        return esp_opiflash_init(rom_spiflash_legacy_data->chip.device_id);
40377b41:	f32b81        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40377b44:	002882        	l32i	a8, a8, 0
40377b47:	08a8      	l32i.n	a10, a8, 0
40377b49:	09fce5        	call8	40381b18 <esp_opiflash_init>
40377b4c:	0a2d      	mov.n	a2, a10
40377b4e:	000106        	j	40377b56 <spi_flash_init_chip_state+0x1e>
    }
#endif
#if CONFIG_SPI_FLASH_HPM_ON
        return spi_flash_enable_high_performance_mode();
40377b51:	09dd25        	call8	40381924 <spi_flash_enable_high_performance_mode>
40377b54:	0a2d      	mov.n	a2, a10
#endif // CONFIG_SPI_FLASH_HPM_ON
    return ESP_OK;
}
40377b56:	f01d      	retw.n

40377b58 <flash_end_flush_cache>:
    }
    return ESP_OK;
}

static IRAM_ATTR esp_err_t flash_end_flush_cache(esp_flash_t* chip, esp_err_t err, bool bus_acquired, uint32_t address, uint32_t length)
{
40377b58:	004136        	entry	a1, 32
40377b5b:	744040        	extui	a4, a4, 0, 8
    if (!bus_acquired) {
40377b5e:	64dc      	bnez.n	a4, 40377b78 <flash_end_flush_cache+0x20>
        // Try to acquire the bus again to flush the cache before exit.
        esp_err_t acquire_err = rom_spiflash_api_funcs->start(chip);
40377b60:	f34c81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377b63:	0888      	l32i.n	a8, a8, 0
40377b65:	0888      	l32i.n	a8, a8, 0
40377b67:	02ad      	mov.n	a10, a2
40377b69:	0008e0        	callx8	a8
        if (acquire_err != ESP_OK) {
40377b6c:	8a8c      	beqz.n	a10, 40377b78 <flash_end_flush_cache+0x20>
            return (err == ESP_OK)? acquire_err: err;
40377b6e:	03cc      	bnez.n	a3, 40377b72 <flash_end_flush_cache+0x1a>
40377b70:	0a3d      	mov.n	a3, a10
40377b72:	032d      	mov.n	a2, a3
40377b74:	000906        	j	40377b9c <flash_end_flush_cache+0x44>
40377b77:	02a800        	andb	b10, b8, b0
        }
    }

    if (chip->host->driver->flush_cache) {
40377b7a:	0a88      	l32i.n	a8, a10, 0
40377b7c:	112882        	l32i	a8, a8, 68
40377b7f:	988c      	beqz.n	a8, 40377b8c <flash_end_flush_cache+0x34>
        esp_err_t flush_err = chip->host->driver->flush_cache(chip->host, address, length);
40377b81:	06cd      	mov.n	a12, a6
40377b83:	05bd      	mov.n	a11, a5
40377b85:	0008e0        	callx8	a8
        if (err == ESP_OK) {
40377b88:	03cc      	bnez.n	a3, 40377b8c <flash_end_flush_cache+0x34>
            err = flush_err;
40377b8a:	0a3d      	mov.n	a3, a10
        }
    }
    return rom_spiflash_api_funcs->end(chip, err);
40377b8c:	f34181        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377b8f:	0888      	l32i.n	a8, a8, 0
40377b91:	1888      	l32i.n	a8, a8, 4
40377b93:	03bd      	mov.n	a11, a3
40377b95:	02ad      	mov.n	a10, a2
40377b97:	0008e0        	callx8	a8
40377b9a:	0a2d      	mov.n	a2, a10
}
40377b9c:	f01d      	retw.n
	...

40377ba0 <check_chip_pointer_default>:
{
40377ba0:	004136        	entry	a1, 32
    esp_flash_t *chip = *inout_chip;
40377ba3:	0022a2        	l32i	a10, a2, 0
    if (chip == NULL) {
40377ba6:	009a56        	bnez	a10, 40377bb3 <check_chip_pointer_default+0x13>
        chip = esp_flash_default_chip;
40377ba9:	f33b81        	l32r	a8, 40374898 <_iram_text_start+0x494> (3fc95eec <esp_flash_default_chip>)
40377bac:	0028a2        	l32i	a10, a8, 0
    *inout_chip = chip;
40377baf:	02a9      	s32i.n	a10, a2, 0
    if (chip == NULL || !esp_flash_chip_driver_initialized(chip)) {
40377bb1:	3a8c      	beqz.n	a10, 40377bb8 <check_chip_pointer_default+0x18>
40377bb3:	005e65        	call8	40378198 <esp_flash_chip_driver_initialized>
40377bb6:	4acc      	bnez.n	a10, 40377bbe <check_chip_pointer_default+0x1e>
        return ESP_ERR_FLASH_NOT_INITIALISED;
40377bb8:	f33721        	l32r	a2, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
40377bbb:	000046        	j	40377bc0 <check_chip_pointer_default+0x20>
    return ESP_OK;
40377bbe:	020c      	movi.n	a2, 0
}
40377bc0:	f01d      	retw.n
	...

40377bc4 <detect_spi_flash_chip>:

    return read_unique_id(chip, out_uid);
}

static esp_err_t IRAM_ATTR detect_spi_flash_chip(esp_flash_t *chip)
{
40377bc4:	004136        	entry	a1, 32
40377bc7:	027d      	mov.n	a7, a2
    esp_err_t err;
    uint32_t flash_id = chip->chip_id;
40377bc9:	6258      	l32i.n	a5, a2, 24

    // Detect the chip and set the chip_drv structure for it
    const spi_flash_chip_t **drivers = esp_flash_registered_chips;
40377bcb:	f33481        	l32r	a8, 4037489c <_iram_text_start+0x498> (3fc9264c <esp_flash_registered_chips>)
40377bce:	0868      	l32i.n	a6, a8, 0
    while (*drivers != NULL && !esp_flash_chip_driver_initialized(chip)) {
40377bd0:	000f06        	j	40377c10 <detect_spi_flash_chip+0x4c>
40377bd3:	172900        	lsi	f0, a9, 92
        chip->chip_drv = *drivers;
        // start/end SPI operation each time, for multitasking
        // and also so esp_flash_registered_flash_drivers can live in flash
        ESP_EARLY_LOGD(TAG, "trying chip: %s", chip->chip_drv->name);

        err = rom_spiflash_api_funcs->start(chip);
40377bd6:	f32e81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377bd9:	0888      	l32i.n	a8, a8, 0
40377bdb:	0888      	l32i.n	a8, a8, 0
40377bdd:	07ad      	mov.n	a10, a7
40377bdf:	0008e0        	callx8	a8
40377be2:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40377be4:	068a56        	bnez	a10, 40377c50 <detect_spi_flash_chip+0x8c>
            return err;
        }

        if (chip->chip_drv->probe(chip, flash_id) != ESP_OK) {
40377be7:	1788      	l32i.n	a8, a7, 4
40377be9:	2888      	l32i.n	a8, a8, 8
40377beb:	05bd      	mov.n	a11, a5
40377bed:	07ad      	mov.n	a10, a7
40377bef:	0008e0        	callx8	a8
40377bf2:	2a8c      	beqz.n	a10, 40377bf8 <detect_spi_flash_chip+0x34>
            chip->chip_drv = NULL;
40377bf4:	080c      	movi.n	a8, 0
40377bf6:	1789      	s32i.n	a8, a7, 4
        }
        // if probe succeeded, chip->drv stays set
        drivers++;
40377bf8:	04c662        	addi	a6, a6, 4

        err = rom_spiflash_api_funcs->end(chip, err);
40377bfb:	f32581        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377bfe:	002882        	l32i	a8, a8, 0
40377c01:	012882        	l32i	a8, a8, 4
40377c04:	02bd      	mov.n	a11, a2
40377c06:	07ad      	mov.n	a10, a7
40377c08:	0008e0        	callx8	a8
40377c0b:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40377c0d:	03fa56        	bnez	a10, 40377c50 <detect_spi_flash_chip+0x8c>
    while (*drivers != NULL && !esp_flash_chip_driver_initialized(chip)) {
40377c10:	0628      	l32i.n	a2, a6, 0
40377c12:	628c      	beqz.n	a2, 40377c1c <detect_spi_flash_chip+0x58>
40377c14:	07ad      	mov.n	a10, a7
40377c16:	005825        	call8	40378198 <esp_flash_chip_driver_initialized>
40377c19:	fb7a16        	beqz	a10, 40377bd4 <detect_spi_flash_chip+0x10>
            return err;
        }
    }
    if (!esp_flash_chip_driver_initialized(chip)) {
40377c1c:	20a770        	or	a10, a7, a7
40377c1f:	0057a5        	call8	40378198 <esp_flash_chip_driver_initialized>
40377c22:	022a16        	beqz	a10, 40377c48 <detect_spi_flash_chip+0x84>
40377c25:	f21181        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40377c28:	0888      	l32i.n	a8, a8, 0
        return ESP_ERR_NOT_FOUND;
    }
    ESP_EARLY_LOGI(TAG, "detected chip: %s", chip->chip_drv->name);
40377c2a:	2038b6        	bltui	a8, 3, 40377c4e <detect_spi_flash_chip+0x8a>
40377c2d:	07fb25        	call8	4037fbe0 <esp_log_timestamp>
40377c30:	1788      	l32i.n	a8, a7, 4
40377c32:	08d8      	l32i.n	a13, a8, 0
40377c34:	f31bc1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9356c <TAG>)
40377c37:	0abd      	mov.n	a11, a10
40377c39:	f31aa1        	l32r	a10, 403748a4 <_iram_text_start+0x4a0> (3c026294 <_flash_rodata_start+0x6174>)
40377c3c:	f21e81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377c3f:	0008e0        	callx8	a8
    return ESP_OK;
40377c42:	020c      	movi.n	a2, 0
40377c44:	000206        	j	40377c50 <detect_spi_flash_chip+0x8c>
40377c47:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40377c4a:	004605        	call0	403780ac <esp_crosscore_int_send+0x34>
40377c4d:	020c00        	andb	b0, b12, b0
}
40377c50:	f01d      	retw.n
	...

40377c54 <read_id_core>:
{
40377c54:	006136        	entry	a1, 48
40377c57:	027d      	mov.n	a7, a2
    bool installed = esp_flash_chip_driver_initialized(chip);
40377c59:	02ad      	mov.n	a10, a2
40377c5b:	0053e5        	call8	40378198 <esp_flash_chip_driver_initialized>
40377c5e:	0a6d      	mov.n	a6, a10
    esp_err_t err = rom_spiflash_api_funcs->start(chip);
40377c60:	f30c81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377c63:	0888      	l32i.n	a8, a8, 0
40377c65:	0888      	l32i.n	a8, a8, 0
40377c67:	02ad      	mov.n	a10, a2
40377c69:	0008e0        	callx8	a8
40377c6c:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377c6e:	04ca56        	bnez	a10, 40377cbe <read_id_core+0x6a>
    if (installed && chip->chip_drv->read_id) {
40377c71:	568c      	beqz.n	a6, 40377c7a <read_id_core+0x26>
40377c73:	1788      	l32i.n	a8, a7, 4
40377c75:	182822        	l32i	a2, a8, 96
40377c78:	92cc      	bnez.n	a2, 40377c85 <read_id_core+0x31>
        read_id_func = (void*)chip->host->driver->read_id;
40377c7a:	0768      	l32i.n	a6, a7, 0
40377c7c:	0688      	l32i.n	a8, a6, 0
40377c7e:	2828      	l32i.n	a2, a8, 8
        read_id_arg = (void*)chip->host;
40377c80:	0000c6        	j	40377c87 <read_id_core+0x33>
40377c83:	6d0000        	lsi	f0, a0, 0x1b4
        read_id_arg = (void*)chip;
40377c86:	03bd07        	bgeu	a13, a0, 40377c8d <read_id_core+0x39>
    err = read_id_func(read_id_arg, out_id);
40377c89:	06ad      	mov.n	a10, a6
40377c8b:	0002e0        	callx8	a2
40377c8e:	0abd      	mov.n	a11, a10
    if (sanity_check && err == ESP_OK) {
40377c90:	40fa80        	nsau	a8, a10
40377c93:	418580        	srli	a8, a8, 5
40377c96:	160847        	bnone	a8, a4, 40377cb0 <read_id_core+0x5c>
        err = read_id_func(read_id_arg, &new_id);
40377c99:	20b110        	or	a11, a1, a1
40377c9c:	20a660        	or	a10, a6, a6
40377c9f:	0002e0        	callx8	a2
40377ca2:	0abd      	mov.n	a11, a10
        if (err == ESP_OK && (new_id != *out_id)) {
40377ca4:	8acc      	bnez.n	a10, 40377cb0 <read_id_core+0x5c>
40377ca6:	0398      	l32i.n	a9, a3, 0
40377ca8:	0188      	l32i.n	a8, a1, 0
40377caa:	021987        	beq	a9, a8, 40377cb0 <read_id_core+0x5c>
            err = ESP_ERR_FLASH_NOT_INITIALISED;
40377cad:	f2f9b1        	l32r	a11, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
    return rom_spiflash_api_funcs->end(chip, err);
40377cb0:	f2f881        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377cb3:	0888      	l32i.n	a8, a8, 0
40377cb5:	1888      	l32i.n	a8, a8, 4
40377cb7:	07ad      	mov.n	a10, a7
40377cb9:	0008e0        	callx8	a8
40377cbc:	0a2d      	mov.n	a2, a10
}
40377cbe:	f01d      	retw.n

40377cc0 <esp_flash_get_physical_size>:

esp_err_t IRAM_ATTR esp_flash_get_physical_size(esp_flash_t *chip, uint32_t *flash_size)
{
40377cc0:	008136        	entry	a1, 64
40377cc3:	4129      	s32i.n	a2, a1, 16
    esp_err_t err = rom_spiflash_api_funcs->chip_check(&chip);
40377cc5:	f2f281        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377cc8:	0888      	l32i.n	a8, a8, 0
40377cca:	2888      	l32i.n	a8, a8, 8
40377ccc:	10c1a2        	addi	a10, a1, 16
40377ccf:	0008e0        	callx8	a8
40377cd2:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377cd4:	054a56        	bnez	a10, 40377d2c <esp_flash_get_physical_size+0x6c>
        return err;
    }
    VERIFY_CHIP_OP(detect_size);
40377cd7:	41a8      	l32i.n	a10, a1, 16
40377cd9:	1a88      	l32i.n	a8, a10, 4
40377cdb:	4888      	l32i.n	a8, a8, 16
40377cdd:	040816        	beqz	a8, 40377d21 <esp_flash_get_physical_size+0x61>
    if (flash_size == NULL) {
40377ce0:	045316        	beqz	a3, 40377d29 <esp_flash_get_physical_size+0x69>
        return ESP_ERR_INVALID_ARG;
    }

    err = rom_spiflash_api_funcs->start(chip);
40377ce3:	f2eb81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377ce6:	0888      	l32i.n	a8, a8, 0
40377ce8:	002882        	l32i	a8, a8, 0
40377ceb:	0008e0        	callx8	a8
40377cee:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377cf0:	8afc      	bnez.n	a10, 40377d2c <esp_flash_get_physical_size+0x6c>
        return err;
    }
    uint32_t detect_size;
    err = chip->chip_drv->detect_size(chip, &detect_size);
40377cf2:	41a8      	l32i.n	a10, a1, 16
40377cf4:	1a88      	l32i.n	a8, a10, 4
40377cf6:	4888      	l32i.n	a8, a8, 16
40377cf8:	20b110        	or	a11, a1, a1
40377cfb:	0008e0        	callx8	a8
40377cfe:	0abd      	mov.n	a11, a10
    if (err == ESP_OK) {
40377d00:	cacc      	bnez.n	a10, 40377d10 <esp_flash_get_physical_size+0x50>
        if (chip->size == 0) {
40377d02:	4188      	l32i.n	a8, a1, 16
40377d04:	5898      	l32i.n	a9, a8, 20
40377d06:	29cc      	bnez.n	a9, 40377d0c <esp_flash_get_physical_size+0x4c>
            // chip->size will not be changed if detected, it will always be equal to configured flash size.
            chip->size = detect_size;
40377d08:	0198      	l32i.n	a9, a1, 0
40377d0a:	5899      	s32i.n	a9, a8, 20
        }
        *flash_size = detect_size;
40377d0c:	0188      	l32i.n	a8, a1, 0
40377d0e:	0389      	s32i.n	a8, a3, 0
    }
    return rom_spiflash_api_funcs->end(chip, err);
40377d10:	f2e081        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377d13:	0888      	l32i.n	a8, a8, 0
40377d15:	1888      	l32i.n	a8, a8, 4
40377d17:	41a8      	l32i.n	a10, a1, 16
40377d19:	0008e0        	callx8	a8
40377d1c:	0a2d      	mov.n	a2, a10
40377d1e:	000286        	j	40377d2c <esp_flash_get_physical_size+0x6c>
    VERIFY_CHIP_OP(detect_size);
40377d21:	f2e121        	l32r	a2, 403748a8 <_iram_text_start+0x4a4> (6005 <UserFrameTotalSize+0x5f05>)
40377d24:	000106        	j	40377d2c <esp_flash_get_physical_size+0x6c>
40377d27:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
40377d2a:	1d02a1        	l32r	a10, 4033f134 <rom_rx_gain_force+0x338d08>
}
40377d2d:	0000f0        	callx12	a0

40377d30 <esp_flash_init_main>:
{
40377d30:	006136        	entry	a1, 48
40377d33:	027d      	mov.n	a7, a2
    if (chip == NULL || chip->host == NULL || chip->host->driver == NULL ||
40377d35:	14b216        	beqz	a2, 40377e84 <esp_flash_init_main+0x154>
40377d38:	0288      	l32i.n	a8, a2, 0
40377d3a:	14e816        	beqz	a8, 40377e8c <esp_flash_init_main+0x15c>
40377d3d:	0898      	l32i.n	a9, a8, 0
40377d3f:	14f916        	beqz	a9, 40377e92 <esp_flash_init_main+0x162>
        ((memspi_host_inst_t*)chip->host)->spi == NULL) {
40377d42:	1888      	l32i.n	a8, a8, 4
    if (chip == NULL || chip->host == NULL || chip->host->driver == NULL ||
40377d44:	151816        	beqz	a8, 40377e99 <esp_flash_init_main+0x169>
    octal_mode = (chip->read_mode >= SPI_FLASH_OPI_FLAG);
40377d47:	4258      	l32i.n	a5, a2, 16
    uint32_t flash_id = 0;
40377d49:	080c      	movi.n	a8, 0
40377d4b:	0189      	s32i.n	a8, a1, 0
    if (octal_mode) {
40377d4d:	f80c      	movi.n	a8, 15
40377d4f:	0bb857        	bgeu	a8, a5, 40377d5e <esp_flash_init_main+0x2e>
        flash_id = g_rom_flashchip.device_id;
40377d52:	f2a781        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40377d55:	0888      	l32i.n	a8, a8, 0
40377d57:	0888      	l32i.n	a8, a8, 0
40377d59:	0189      	s32i.n	a8, a1, 0
    if (err != ESP_OK) {
40377d5b:	000846        	j	40377d80 <esp_flash_init_main+0x50>
        int retries = 10;
40377d5e:	a60c      	movi.n	a6, 10
40377d60:	000086        	j	40377d66 <esp_flash_init_main+0x36>
40377d63:	086d00        	lsx	f6, a13, a0
            err = esp_flash_read_chip_id(chip, &flash_id);
40377d66:	01bd      	mov.n	a11, a1
40377d68:	07ad      	mov.n	a10, a7
40377d6a:	f2d681        	l32r	a8, 403748c4 <_iram_text_start+0x4c0> (42009bc4 <esp_flash_read_chip_id>)
40377d6d:	0008e0        	callx8	a8
40377d70:	0a2d      	mov.n	a2, a10
        } while (err == ESP_ERR_FLASH_NOT_INITIALISED && retries-- > 0);
40377d72:	f2c881        	l32r	a8, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
40377d75:	049a87        	bne	a10, a8, 40377d7d <esp_flash_init_main+0x4d>
40377d78:	860b      	addi.n	a8, a6, -1
40377d7a:	e616e6        	bgei	a6, 1, 40377d64 <esp_flash_init_main+0x34>
    if (err != ESP_OK) {
40377d7d:	11b256        	bnez	a2, 40377e9c <esp_flash_init_main+0x16c>
    chip->chip_id = flash_id;
40377d80:	0188      	l32i.n	a8, a1, 0
40377d82:	6789      	s32i.n	a8, a7, 24
    if (!esp_flash_chip_driver_initialized(chip)) {
40377d84:	07ad      	mov.n	a10, a7
40377d86:	004125        	call8	40378198 <esp_flash_chip_driver_initialized>
40377d89:	9acc      	bnez.n	a10, 40377d96 <esp_flash_init_main+0x66>
        err = detect_spi_flash_chip(chip);
40377d8b:	07ad      	mov.n	a10, a7
40377d8d:	ffe365        	call8	40377bc4 <detect_spi_flash_chip>
40377d90:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
40377d93:	105a56        	bnez	a10, 40377e9c <esp_flash_init_main+0x16c>
    err = esp_flash_get_physical_size(chip, &size);
40377d96:	04c1b2        	addi	a11, a1, 4
40377d99:	20a770        	or	a10, a7, a7
40377d9c:	fff225        	call8	40377cc0 <esp_flash_get_physical_size>
40377d9f:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377da1:	01ca16        	beqz	a10, 40377dc1 <esp_flash_init_main+0x91>
40377da4:	f1b281        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40377da7:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "failed to get chip size");
40377daa:	0ee816        	beqz	a8, 40377e9c <esp_flash_init_main+0x16c>
40377dad:	07e325        	call8	4037fbe0 <esp_log_timestamp>
40377db0:	f2bcc1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9356c <TAG>)
40377db3:	0abd      	mov.n	a11, a10
40377db5:	f2bda1        	l32r	a10, 403748ac <_iram_text_start+0x4a8> (3c0262b4 <_flash_rodata_start+0x6194>)
40377db8:	f1bf81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377dbb:	0008e0        	callx8	a8
        return err;
40377dbe:	003686        	j	40377e9c <esp_flash_init_main+0x16c>
    if (chip->chip_drv->get_chip_caps == NULL) {
40377dc1:	1788      	l32i.n	a8, a7, 4
40377dc3:	1d2882        	l32i	a8, a8, 116
40377dc6:	01c856        	bnez	a8, 40377de6 <esp_flash_init_main+0xb6>
40377dc9:	f1a881        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40377dcc:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGW(TAG, "get_chip_caps function pointer hasn't been initialized");
40377dce:	4328b6        	bltui	a8, 2, 40377e15 <esp_flash_init_main+0xe5>
40377dd1:	07e0e5        	call8	4037fbe0 <esp_log_timestamp>
40377dd4:	f2b3c1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9356c <TAG>)
40377dd7:	0abd      	mov.n	a11, a10
40377dd9:	f2b5a1        	l32r	a10, 403748b0 <_iram_text_start+0x4ac> (3c0263fc <_flash_rodata_start+0x62dc>)
40377ddc:	f1b681        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377ddf:	0008e0        	callx8	a8
40377de2:	000bc6        	j	40377e15 <esp_flash_init_main+0xe5>
40377de5:	07ad00        	lsi	f0, a13, 28
        if (((chip->chip_drv->get_chip_caps(chip) & SPI_FLASH_CHIP_CAP_32MB_SUPPORT) == 0) && (size > (16 *1024 * 1024))) {
40377de8:	0008e0        	callx8	a8
40377deb:	26ea17        	bbsi	a10, 1, 40377e15 <esp_flash_init_main+0xe5>
40377dee:	1188      	l32i.n	a8, a1, 4
40377df0:	f2b191        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
40377df3:	1eb987        	bgeu	a9, a8, 40377e15 <esp_flash_init_main+0xe5>
40377df6:	f19d81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40377df9:	0888      	l32i.n	a8, a8, 0
            ESP_EARLY_LOGW(TAG, "Detected flash size > 16 MB, but access beyond 16 MB is not supported for this flash model yet.");
40377dfb:	1128b6        	bltui	a8, 2, 40377e10 <esp_flash_init_main+0xe0>
40377dfe:	07de25        	call8	4037fbe0 <esp_log_timestamp>
40377e01:	f2a7c1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9356c <TAG>)
40377e04:	20baa0        	or	a11, a10, a10
40377e07:	f2aca1        	l32r	a10, 403748b8 <_iram_text_start+0x4b4> (3c0262dc <_flash_rodata_start+0x61bc>)
40377e0a:	f1aa81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377e0d:	0008e0        	callx8	a8
            size = (16 * 1024 * 1024);
40377e10:	f2a981        	l32r	a8, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
40377e13:	1189      	s32i.n	a8, a1, 4
40377e15:	f19581        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40377e18:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "flash io: %s", io_mode_str[chip->read_mode]);
40377e1a:	1b38b6        	bltui	a8, 3, 40377e39 <esp_flash_init_main+0x109>
40377e1d:	07dc25        	call8	4037fbe0 <esp_log_timestamp>
40377e20:	47d8      	l32i.n	a13, a7, 16
40377e22:	a0ddd0        	addx4	a13, a13, a13
40377e25:	f2a581        	l32r	a8, 403748bc <_iram_text_start+0x4b8> (3c028790 <io_mode_str>)
40377e28:	90dd80        	addx2	a13, a13, a8
40377e2b:	f29dc1        	l32r	a12, 403748a0 <_iram_text_start+0x49c> (3fc9356c <TAG>)
40377e2e:	0abd      	mov.n	a11, a10
40377e30:	f2a4a1        	l32r	a10, 403748c0 <_iram_text_start+0x4bc> (3c02634c <_flash_rodata_start+0x622c>)
40377e33:	f1a081        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40377e36:	0008e0        	callx8	a8
    err = rom_spiflash_api_funcs->start(chip);
40377e39:	f29581        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3fc93558 <rom_spiflash_api_funcs>)
40377e3c:	0888      	l32i.n	a8, a8, 0
40377e3e:	0888      	l32i.n	a8, a8, 0
40377e40:	07ad      	mov.n	a10, a7
40377e42:	0008e0        	callx8	a8
40377e45:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377e47:	051a56        	bnez	a10, 40377e9c <esp_flash_init_main+0x16c>
    if (err == ESP_OK && !octal_mode) {
40377e4a:	f80c      	movi.n	a8, 15
40377e4c:	203857        	bltu	a8, a5, 40377e70 <esp_flash_init_main+0x140>
        err = chip->chip_drv->set_io_mode(chip);
40377e4f:	1788      	l32i.n	a8, a7, 4
40377e51:	162882        	l32i	a8, a8, 88
40377e54:	07ad      	mov.n	a10, a7
40377e56:	0008e0        	callx8	a8
        if (err == ESP_ERR_FLASH_NO_RESPONSE && !esp_flash_is_quad_mode(chip)) {
40377e59:	08a182        	movi	a8, 0x108
40377e5c:	0e9a87        	bne	a10, a8, 40377e6e <esp_flash_init_main+0x13e>
 *
 * @return true if flash works in quad mode, otherwise false
 */
static inline bool esp_flash_is_quad_mode(const esp_flash_t *chip)
{
    return (chip->read_mode == SPI_FLASH_QIO) || (chip->read_mode == SPI_FLASH_QOUT);
40377e5f:	4788      	l32i.n	a8, a7, 16
40377e61:	fcc882        	addi	a8, a8, -4
40377e64:	0828f6        	bgeui	a8, 2, 40377e70 <esp_flash_init_main+0x140>
        err = chip->chip_drv->set_io_mode(chip);
40377e67:	0a2d      	mov.n	a2, a10
40377e69:	0000c6        	j	40377e70 <esp_flash_init_main+0x140>
40377e6c:	2d0000        	lsi	f0, a0, 180
40377e6f:	810a      	add.n	a8, a1, a0
    return rom_spiflash_api_funcs->end(chip, err);
40377e71:	f288      	l32i.n	a8, a2, 60
40377e73:	0888      	l32i.n	a8, a8, 0
40377e75:	1888      	l32i.n	a8, a8, 4
40377e77:	02bd      	mov.n	a11, a2
40377e79:	07ad      	mov.n	a10, a7
40377e7b:	0008e0        	callx8	a8
40377e7e:	0a2d      	mov.n	a2, a10
40377e80:	000606        	j	40377e9c <esp_flash_init_main+0x16c>
40377e83:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
40377e86:	044602        	s8i	a0, a6, 4
40377e89:	000000        	ill
40377e8c:	02a122        	movi	a2, 0x102
40377e8f:	000246        	j	40377e9c <esp_flash_init_main+0x16c>
40377e92:	02a122        	movi	a2, 0x102
40377e95:	0000c6        	j	40377e9c <esp_flash_init_main+0x16c>
40377e98:	a12200        	sll	a2, a2
40377e9b:	f01d02        	l16ui	a0, a13, 0x1e0
	...

40377ea0 <spi_flash_os_yield>:
    }
    return ret;
}

static IRAM_ATTR esp_err_t spi_flash_os_yield(void *arg, uint32_t* out_status)
{
40377ea0:	004136        	entry	a1, 32
    if (likely(xTaskGetSchedulerState() == taskSCHEDULER_RUNNING)) {
40377ea3:	03b8a5        	call8	4037ba2c <xTaskGetSchedulerState>
40377ea6:	052a66        	bnei	a10, 2, 40377eaf <spi_flash_os_yield+0xf>
#ifdef CONFIG_SPI_FLASH_ERASE_YIELD_TICKS
        vTaskDelay(CONFIG_SPI_FLASH_ERASE_YIELD_TICKS);
40377ea9:	01a0a2        	movi	a10, 1
40377eac:	03caa5        	call8	4037bb58 <vTaskDelay>
    // in that function instead.
}

static inline IRAM_ATTR void on_spi_yielded(app_func_arg_t* ctx)
{
    uint32_t time = esp_system_get_time();
40377eaf:	fed6e5        	call8	40376c1c <esp_system_get_time>
    ctx->acquired_since_us = time;
40377eb2:	22a9      	s32i.n	a10, a2, 8
}
40377eb4:	020c      	movi.n	a2, 0
40377eb6:	f01d      	retw.n

40377eb8 <on_spi_check_yield>:
{
40377eb8:	004136        	entry	a1, 32
    uint32_t time = esp_system_get_time();
40377ebb:	fed625        	call8	40376c1c <esp_system_get_time>
    if ((time - ctx->released_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_TICKS * portTICK_PERIOD_MS * 1000) {
40377ebe:	032282        	l32i	a8, a2, 12
40377ec1:	c08a80        	sub	a8, a10, a8
40377ec4:	f28191        	l32r	a9, 403748c8 <_iram_text_start+0x4c4> (270f <UserFrameTotalSize+0x260f>)
40377ec7:	09b987        	bgeu	a9, a8, 40377ed4 <on_spi_check_yield+0x1c>
        ctx->acquired_since_us = time;
40377eca:	0262a2        	s32i	a10, a2, 8
    return false;
40377ecd:	00a022        	movi	a2, 0
40377ed0:	000486        	j	40377ee6 <on_spi_check_yield+0x2e>
40377ed3:	228800        	orb	b8, b8, b0
    } else if ((time - ctx->acquired_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS * 1000) {
40377ed6:	c0aa80        	sub	a10, a10, a8
40377ed9:	f27c81        	l32r	a8, 403748cc <_iram_text_start+0x4c8> (4e1f <UserFrameTotalSize+0x4d1f>)
40377edc:	0438a7        	bltu	a8, a10, 40377ee4 <on_spi_check_yield+0x2c>
    return false;
40377edf:	020c      	movi.n	a2, 0
40377ee1:	000046        	j	40377ee6 <on_spi_check_yield+0x2e>
        return true;
40377ee4:	120c      	movi.n	a2, 1
}
40377ee6:	f01d      	retw.n

40377ee8 <spi_flash_os_check_yield>:
{
40377ee8:	004136        	entry	a1, 32
40377eeb:	02ad      	mov.n	a10, a2
    assert (chip_status == 0);  //TODO: support suspend
40377eed:	039c      	beqz.n	a3, 40377f01 <spi_flash_os_check_yield+0x19>
40377eef:	f278d1        	l32r	a13, 403748d0 <_iram_text_start+0x4cc> (3c026608 <_flash_rodata_start+0x64e8>)
40377ef2:	f278c1        	l32r	a12, 403748d4 <_iram_text_start+0x4d0> (3c02886c <__func__$0>)
40377ef5:	afa0b2        	movi	a11, 175
40377ef8:	f278a1        	l32r	a10, 403748d8 <_iram_text_start+0x4d4> (3c026637 <_flash_rodata_start+0x6517>)
40377efb:	201110        	or	a1, a1, a1
40377efe:	07e525        	call8	4037fd50 <__assert_func>
    if (on_spi_check_yield((app_func_arg_t *)arg)) {
40377f01:	fffb65        	call8	40377eb8 <on_spi_check_yield>
40377f04:	9acc      	bnez.n	a10, 40377f11 <spi_flash_os_check_yield+0x29>
    uint32_t request = 0;
40377f06:	080c      	movi.n	a8, 0
    esp_err_t ret = ESP_ERR_TIMEOUT;    //Nothing happened
40377f08:	07a122        	movi	a2, 0x107
40377f0b:	000186        	j	40377f15 <spi_flash_os_check_yield+0x2d>
40377f0e:	000000        	ill
        request = SPI_FLASH_YIELD_REQ_YIELD;
40377f11:	180c      	movi.n	a8, 1
        ret = ESP_OK;
40377f13:	020c      	movi.n	a2, 0
    if (out_request) {
40377f15:	048c      	beqz.n	a4, 40377f19 <spi_flash_os_check_yield+0x31>
        *out_request = request;
40377f17:	0489      	s32i.n	a8, a4, 0
}
40377f19:	f01d      	retw.n
	...

40377f1c <release_buffer_malloc>:
{
40377f1c:	004136        	entry	a1, 32
40377f1f:	03ad      	mov.n	a10, a3
    free(temp_buf);
40377f21:	07f2a5        	call8	4037fe4c <cfree>
}
40377f24:	f01d      	retw.n
	...

40377f28 <get_buffer_malloc>:
{
40377f28:	004136        	entry	a1, 32
    unsigned retries = 5;
40377f2b:	580c      	movi.n	a8, 5
    void* ret = NULL;
40377f2d:	0a0c      	movi.n	a10, 0
    while(ret == NULL && retries--) {
40377f2f:	000a86        	j	40377f5d <get_buffer_malloc+0x35>
40377f32:	a10000        	sll	a0, a0
        read_chunk_size = MIN(read_chunk_size, heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT));
40377f35:	f26a      	add.n	a15, a2, a6
40377f37:	f26a81        	l32r	a8, 403748e0 <_iram_text_start+0x4dc> (42002b58 <heap_caps_get_largest_free_block>)
40377f3a:	0008e0        	callx8	a8
40377f3d:	0b33a7        	bltu	a3, a10, 40377f4c <get_buffer_malloc+0x24>
40377f40:	f267a1        	l32r	a10, 403748dc <_iram_text_start+0x4d8> (804 <UserFrameTotalSize+0x704>)
40377f43:	f26781        	l32r	a8, 403748e0 <_iram_text_start+0x4dc> (42002b58 <heap_caps_get_largest_free_block>)
40377f46:	0008e0        	callx8	a8
40377f49:	203aa0        	or	a3, a10, a10
        read_chunk_size = (read_chunk_size + 3) & ~3;
40377f4c:	333b      	addi.n	a3, a3, 3
40377f4e:	c87c      	movi.n	a8, -4
40377f50:	103380        	and	a3, a3, a8
        ret = heap_caps_malloc(read_chunk_size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
40377f53:	f262b1        	l32r	a11, 403748dc <_iram_text_start+0x4d8> (804 <UserFrameTotalSize+0x704>)
40377f56:	03ad      	mov.n	a10, a3
40377f58:	fdfde5        	call8	40375f38 <heap_caps_malloc>
    while(ret == NULL && retries--) {
40377f5b:	078d      	mov.n	a8, a7
40377f5d:	3acc      	bnez.n	a10, 40377f64 <get_buffer_malloc+0x3c>
40377f5f:	780b      	addi.n	a7, a8, -1
40377f61:	fcf856        	bnez	a8, 40377f34 <get_buffer_malloc+0xc>
    *out_size = (ret != NULL? read_chunk_size: 0);
40377f64:	0acc      	bnez.n	a10, 40377f68 <get_buffer_malloc+0x40>
40377f66:	030c      	movi.n	a3, 0
40377f68:	0439      	s32i.n	a3, a4, 0
}
40377f6a:	0a2d      	mov.n	a2, a10
40377f6c:	f01d      	retw.n
	...

40377f70 <delay_us>:
{
40377f70:	004136        	entry	a1, 32
40377f73:	20a330        	or	a10, a3, a3
    esp_rom_delay_us(us);
40377f76:	f12f81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40377f79:	0008e0        	callx8	a8
}
40377f7c:	020c      	movi.n	a2, 0
40377f7e:	f01d      	retw.n

40377f80 <main_flash_op_status>:
{
40377f80:	004136        	entry	a1, 32
    spi_flash_set_erasing_flag(is_erasing);
40377f83:	04a020        	extui	a10, a2, 0, 1
40377f86:	07fb25        	call8	4037ff38 <spi_flash_set_erasing_flag>
}
40377f89:	f01d      	retw.n
	...

40377f8c <main_flash_region_protected>:
{
40377f8c:	004136        	entry	a1, 32
    if (!esp_partition_is_flash_region_writable(start_addr, size)) {
40377f8f:	04bd      	mov.n	a11, a4
40377f91:	03ad      	mov.n	a10, a3
40377f93:	f25481        	l32r	a8, 403748e4 <_iram_text_start+0x4e0> (4200a44c <esp_partition_is_flash_region_writable>)
40377f96:	0008e0        	callx8	a8
40377f99:	4a9c      	beqz.n	a10, 40377fb1 <main_flash_region_protected+0x25>
    if (((app_func_arg_t*)arg)->no_protect || esp_partition_main_flash_region_safe(start_addr, size)) {
40377f9b:	040282        	l8ui	a8, a2, 4
40377f9e:	a8cc      	bnez.n	a8, 40377fac <main_flash_region_protected+0x20>
40377fa0:	04bd      	mov.n	a11, a4
40377fa2:	03ad      	mov.n	a10, a3
40377fa4:	f25181        	l32r	a8, 403748e8 <_iram_text_start+0x4e4> (4200a49c <esp_partition_main_flash_region_safe>)
40377fa7:	0008e0        	callx8	a8
40377faa:	aa8c      	beqz.n	a10, 40377fb8 <main_flash_region_protected+0x2c>
        return ESP_OK;
40377fac:	020c      	movi.n	a2, 0
40377fae:	000246        	j	40377fbb <main_flash_region_protected+0x2f>
        return ESP_ERR_NOT_ALLOWED;
40377fb1:	0da122        	movi	a2, 0x10d
40377fb4:	0000c6        	j	40377fbb <main_flash_region_protected+0x2f>
40377fb7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
40377fba:	f01d06        	j	40374032 <_WindowOverflow4+0x32>
40377fbd:	000000        	ill

40377fc0 <cache_enable>:
{
40377fc0:	004136        	entry	a1, 32
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377fc3:	ffa065        	call8	403779c8 <spi_flash_enable_interrupts_caches_and_other_cpu>
}
40377fc6:	f01d      	retw.n

40377fc8 <spi1_end>:
{
40377fc8:	004136        	entry	a1, 32
    cache_enable(NULL);
40377fcb:	00a0a2        	movi	a10, 0
40377fce:	ffff25        	call8	40377fc0 <cache_enable>
    ctx->released_since_us = esp_system_get_time();
40377fd1:	fec4a5        	call8	40376c1c <esp_system_get_time>
40377fd4:	0362a2        	s32i	a10, a2, 12
}
40377fd7:	00a022        	movi	a2, 0
40377fda:	f01d      	retw.n

40377fdc <cache_disable>:
{
40377fdc:	004136        	entry	a1, 32
    spi_flash_disable_interrupts_caches_and_other_cpu();
40377fdf:	ff8c25        	call8	403778a0 <spi_flash_disable_interrupts_caches_and_other_cpu>
}
40377fe2:	f01d      	retw.n

40377fe4 <spi1_start>:
{
40377fe4:	004136        	entry	a1, 32
    cache_disable(NULL);
40377fe7:	0a0c      	movi.n	a10, 0
40377fe9:	ffff25        	call8	40377fdc <cache_disable>
}
40377fec:	020c      	movi.n	a2, 0
40377fee:	f01d      	retw.n

40377ff0 <delay_us>:

    return ESP_OK;
}

static IRAM_ATTR esp_err_t delay_us(void *arg, uint32_t us)
{
40377ff0:	004136        	entry	a1, 32
40377ff3:	20a330        	or	a10, a3, a3
    esp_rom_delay_us(us);
40377ff6:	f10f81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40377ff9:	0008e0        	callx8	a8
    return ESP_OK;
}
40377ffc:	020c      	movi.n	a2, 0
40377ffe:	f01d      	retw.n

40378000 <end>:
{
40378000:	004136        	entry	a1, 32
    cache_hal_resume(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40378003:	02a0b2        	movi	a11, 2
40378006:	01a0a2        	movi	a10, 1
40378009:	049fe5        	call8	4037ca08 <cache_hal_resume>
}
4037800c:	00a022        	movi	a2, 0
4037800f:	f01d      	retw.n
40378011:	000000        	ill

40378014 <start>:
{
40378014:	004136        	entry	a1, 32
    cache_hal_suspend(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40378017:	02a0b2        	movi	a11, 2
4037801a:	01a0a2        	movi	a10, 1
4037801d:	049b25        	call8	4037c9d0 <cache_hal_suspend>
}
40378020:	00a022        	movi	a2, 0
40378023:	f01d      	retw.n
40378025:	000000        	ill

40378028 <esp_crosscore_isr>:
{
    portYIELD_FROM_ISR();
}

static void IRAM_ATTR esp_crosscore_isr(void *arg)
{
40378028:	004136        	entry	a1, 32
4037802b:	03eb80        	rsr.prid	a8
4037802e:	048d80        	extui	a8, a8, 13, 1
/**
 * @brief Clear the crosscore interrupt that just occurred on the current core
 */
FORCE_INLINE_ATTR void crosscore_int_ll_clear_interrupt(int core_id)
{
    if (core_id == 0) {
40378031:	b8cc      	bnez.n	a8, 40378040 <esp_crosscore_isr+0x18>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, 0);
40378033:	f22e81        	l32r	a8, 403748ec <_iram_text_start+0x4e8> (600c0030 <SYSTEM+0x30>)
40378036:	090c      	movi.n	a9, 0
40378038:	0020c0        	memw
4037803b:	0899      	s32i.n	a9, a8, 0
4037803d:	000246        	j	4037804a <esp_crosscore_isr+0x22>
    } else {
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, 0);
40378040:	f22c81        	l32r	a8, 403748f0 <_iram_text_start+0x4ec> (600c0034 <SYSTEM+0x34>)
40378043:	090c      	movi.n	a9, 0
40378045:	0020c0        	memw
40378048:	0899      	s32i.n	a9, a8, 0
4037804a:	fb7c      	movi.n	a11, -1
4037804c:	f22aa1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92674 <reason_spinlock>)
4037804f:	020e25        	call8	4037a130 <xPortEnterCriticalTimeout>
    //Clear the interrupt first.
    crosscore_int_ll_clear_interrupt(esp_cpu_get_core_id());

    //Grab the reason and clear it.
    portENTER_CRITICAL_ISR(&reason_spinlock);
    my_reason_val = *my_reason;
40378052:	0020c0        	memw
40378055:	002272        	l32i	a7, a2, 0
    *my_reason = 0;
40378058:	080c      	movi.n	a8, 0
4037805a:	0020c0        	memw
4037805d:	006282        	s32i	a8, a2, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40378060:	f225a1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92674 <reason_spinlock>)
40378063:	0221e5        	call8	4037a280 <vPortExitCritical>

    //Check what we need to do.
    if (my_reason_val & REASON_YIELD) {
40378066:	026707        	bbci	a7, 0, 4037806c <esp_crosscore_isr+0x44>
    portYIELD_FROM_ISR();
40378069:	023125        	call8	4037a37c <_frxt_setup_switch>
    if (my_reason_val & REASON_GDB_CALL) {
        update_breakpoints();
    }
#endif // !CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME

    if (my_reason_val & REASON_PRINT_BACKTRACE) {
4037806c:	056727        	bbci	a7, 2, 40378075 <esp_crosscore_isr+0x4d>
        esp_backtrace_print(100);
4037806f:	64a0a2        	movi	a10, 100
40378072:	fdc2e5        	call8	40375ca0 <esp_backtrace_print>
         * the TWDT interrupt, call the function with `false` as a parameter. */
        task_wdt_timeout_abort(false);
    }
#endif // CONFIG_ESP_TASK_WDT_EN

}
40378075:	f01d      	retw.n
	...

40378078 <esp_crosscore_int_send>:
#endif
    ESP_ERROR_CHECK(err);
}

static void IRAM_ATTR esp_crosscore_int_send(int core_id, uint32_t reason_mask)
{
40378078:	004136        	entry	a1, 32
    assert(core_id < CONFIG_FREERTOS_NUMBER_OF_CORES);
4037807b:	01a082        	movi	a8, 1
4037807e:	0ea827        	bge	a8, a2, 40378090 <esp_crosscore_int_send+0x18>
40378081:	f21dd1        	l32r	a13, 403748f8 <_iram_text_start+0x4f4> (3c026650 <_flash_rodata_start+0x6530>)
40378084:	f21ec1        	l32r	a12, 403748fc <_iram_text_start+0x4f8> (3c028888 <__func__$0>)
40378087:	71a0b2        	movi	a11, 113
4037808a:	f21da1        	l32r	a10, 40374900 <_iram_text_start+0x4fc> (3c026698 <_flash_rodata_start+0x6578>)
4037808d:	07cc25        	call8	4037fd50 <__assert_func>
40378090:	fb7c      	movi.n	a11, -1
40378092:	f218a1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92674 <reason_spinlock>)
40378095:	0209a5        	call8	4037a130 <xPortEnterCriticalTimeout>
    //Mark the reason we interrupt the other CPU
    portENTER_CRITICAL_ISR(&reason_spinlock);
    reason[core_id] |= reason_mask;
40378098:	f21b81        	l32r	a8, 40374904 <_iram_text_start+0x500> (3fc95ef8 <reason>)
4037809b:	a08280        	addx4	a8, a2, a8
4037809e:	0020c0        	memw
403780a1:	0898      	l32i.n	a9, a8, 0
403780a3:	209930        	or	a9, a9, a3
403780a6:	0020c0        	memw
403780a9:	0899      	s32i.n	a9, a8, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
403780ab:	f212a1        	l32r	a10, 403748f4 <_iram_text_start+0x4f0> (3fc92674 <reason_spinlock>)
403780ae:	021d25        	call8	4037a280 <vPortExitCritical>
 *
 * @param core_id Core to trigger an interrupt on.
 */
FORCE_INLINE_ATTR void crosscore_int_ll_trigger_interrupt(int core_id)
{
    if (core_id == 0) {
403780b1:	b2cc      	bnez.n	a2, 403780c0 <esp_crosscore_int_send+0x48>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, SYSTEM_CPU_INTR_FROM_CPU_0);
403780b3:	f20e81        	l32r	a8, 403748ec <_iram_text_start+0x4e8> (600c0030 <SYSTEM+0x30>)
403780b6:	190c      	movi.n	a9, 1
403780b8:	0020c0        	memw
403780bb:	0899      	s32i.n	a9, a8, 0
403780bd:	000246        	j	403780ca <esp_crosscore_int_send+0x52>
    } else {
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, SYSTEM_CPU_INTR_FROM_CPU_1);
403780c0:	f20c81        	l32r	a8, 403748f0 <_iram_text_start+0x4ec> (600c0034 <SYSTEM+0x34>)
403780c3:	190c      	movi.n	a9, 1
403780c5:	0020c0        	memw
403780c8:	0899      	s32i.n	a9, a8, 0
    //Poke the other CPU.
    crosscore_int_ll_trigger_interrupt(core_id);
}
403780ca:	f01d      	retw.n

403780cc <esp_crosscore_int_send_yield>:

void IRAM_ATTR esp_crosscore_int_send_yield(int core_id)
{
403780cc:	004136        	entry	a1, 32
403780cf:	20a220        	or	a10, a2, a2
    esp_crosscore_int_send(core_id, REASON_YIELD);
403780d2:	01a0b2        	movi	a11, 1
403780d5:	fffa25        	call8	40378078 <esp_crosscore_int_send>
}
403780d8:	000090        	retw
	...

403780dc <_xt_panic>:
    .literal_position
    .align      4

_xt_panic:
    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
403780dc:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
403780de:	ffd112        	addmi	a1, a1, 0xffffff00
403780e1:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
403780e4:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
403780e6:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
403780e9:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
403780ec:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
403780ee:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
403780f1:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
403780f3:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
403780f6:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
403780f8:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
403780fb:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
403780fd:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40378100:	09c105        	call0	40381d14 <_xt_context_save>

    /* Save exc cause and vaddr into exception frame */
    rsr     a0, EXCCAUSE
40378103:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
40378106:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
40378109:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
4037810c:	156102        	s32i	a0, a1, 84

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
4037810f:	f19f01        	l32r	a0, 4037478c <_iram_text_start+0x388> (40024 <UserFrameTotalSize+0x3ff24>)
    wsr     a0, PS
40378112:	13e600        	wsr.ps	a0

    //Call panic handler
    mov     a6,sp
40378115:	016d      	mov.n	a6, a1
    call4 panicHandler
40378117:	fd8a95        	call4	403759c0 <panicHandler>

    ret
4037811a:	f00d      	ret.n

4037811c <hex_to_str>:
{
4037811c:	004136        	entry	a1, 32
    for (int i = 0; i < 8; i++) {
4037811f:	090c      	movi.n	a9, 0
40378121:	000986        	j	4037814b <hex_to_str+0x2f>
        uint8_t b4 = (n >> (28 - i * 4)) & 0b1111;
40378124:	f9c982        	addi	a8, a9, -7
40378127:	608080        	neg	a8, a8
4037812a:	1188e0        	slli	a8, a8, 2
4037812d:	400800        	ssr	a8
40378130:	918030        	srl	a8, a3
40378133:	348080        	extui	a8, a8, 0, 4
        buf[i] = b4 <= 9 ? '0' + b4 : 'a' + b4 - 10;
40378136:	9a0c      	movi.n	a10, 9
40378138:	053a87        	bltu	a10, a8, 40378141 <hex_to_str+0x25>
4037813b:	30c882        	addi	a8, a8, 48
4037813e:	000086        	j	40378144 <hex_to_str+0x28>
40378141:	57c882        	addi	a8, a8, 87
40378144:	a29a      	add.n	a10, a2, a9
40378146:	004a82        	s8i	a8, a10, 0
    for (int i = 0; i < 8; i++) {
40378149:	991b      	addi.n	a9, a9, 1
4037814b:	d589a6        	blti	a9, 8, 40378124 <hex_to_str+0x8>
}
4037814e:	f01d      	retw.n

40378150 <esp_mspi_32bit_address_flash_feature_check>:
#endif // SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE
}

#if !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM  // IDF-10019
esp_err_t IRAM_ATTR esp_mspi_32bit_address_flash_feature_check(void)
{
40378150:	004136        	entry	a1, 32
        return ESP_ERR_NOT_SUPPORTED;
    }
#endif

    return ESP_OK;
}
40378153:	020c      	movi.n	a2, 0
40378155:	f01d      	retw.n
	...

40378158 <spiflash_start_default>:
{
40378158:	004136        	entry	a1, 32
4037815b:	027d      	mov.n	a7, a2
    if (chip->os_func != NULL && chip->os_func->start != NULL) {
4037815d:	2288      	l32i.n	a8, a2, 8
4037815f:	b88c      	beqz.n	a8, 4037816e <spiflash_start_default+0x16>
40378161:	0888      	l32i.n	a8, a8, 0
40378163:	788c      	beqz.n	a8, 4037816e <spiflash_start_default+0x16>
        esp_err_t err = chip->os_func->start(chip->os_func_data);
40378165:	32a8      	l32i.n	a10, a2, 12
40378167:	0008e0        	callx8	a8
4037816a:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
4037816c:	aacc      	bnez.n	a10, 4037817a <spiflash_start_default+0x22>
    chip->host->driver->dev_config(chip->host);
4037816e:	07a8      	l32i.n	a10, a7, 0
40378170:	002a82        	l32i	a8, a10, 0
40378173:	0888      	l32i.n	a8, a8, 0
40378175:	0008e0        	callx8	a8
    return ESP_OK;
40378178:	020c      	movi.n	a2, 0
}
4037817a:	f01d      	retw.n

4037817c <spiflash_end_default>:
{
4037817c:	004136        	entry	a1, 32
4037817f:	028d      	mov.n	a8, a2
40378181:	032d      	mov.n	a2, a3
    if (chip->os_func != NULL
40378183:	2898      	l32i.n	a9, a8, 8
40378185:	b98c      	beqz.n	a9, 40378194 <spiflash_end_default+0x18>
        && chip->os_func->end != NULL) {
40378187:	1998      	l32i.n	a9, a9, 4
40378189:	798c      	beqz.n	a9, 40378194 <spiflash_end_default+0x18>
        esp_err_t end_err = chip->os_func->end(chip->os_func_data);
4037818b:	38a8      	l32i.n	a10, a8, 12
4037818d:	0009e0        	callx8	a9
        if (err == ESP_OK) {
40378190:	03cc      	bnez.n	a3, 40378194 <spiflash_end_default+0x18>
            err = end_err; // Only return the 'end' error if we haven't already failed
40378192:	0a2d      	mov.n	a2, a10
}
40378194:	f01d      	retw.n
	...

40378198 <esp_flash_chip_driver_initialized>:
{
40378198:	004136        	entry	a1, 32
    if (!chip->chip_drv) return false;
4037819b:	1288      	l32i.n	a8, a2, 4
4037819d:	388c      	beqz.n	a8, 403781a4 <esp_flash_chip_driver_initialized+0xc>
    return true;
4037819f:	120c      	movi.n	a2, 1
403781a1:	000046        	j	403781a6 <esp_flash_chip_driver_initialized+0xe>
    if (!chip->chip_drv) return false;
403781a4:	020c      	movi.n	a2, 0
}
403781a6:	f01d      	retw.n

403781a8 <esp_cpu_compare_and_set>:
#if __XTENSA__ && XCHAL_HAVE_S32C1I && CONFIG_SPIRAM
static DRAM_ATTR uint32_t external_ram_cas_lock = 0;
#endif

bool esp_cpu_compare_and_set(volatile uint32_t *addr, uint32_t compare_value, uint32_t new_value)
{
403781a8:	004136        	entry	a1, 32
    temp = *addr;
    *addr = temp;
#endif
    // Atomic compare and set using S32C1I instruction
    uint32_t old_value = new_value;
    __asm__ __volatile__ (
403781ab:	130c30        	wsr.scompare1	a3
403781ae:	00e242        	s32c1i	a4, a2, 0
        "S32C1I %0, %1, 0 \n"
        :"=r"(old_value)
        :"r"(addr), "r"(compare_value), "0"(old_value)
    );

    return (old_value == compare_value);
403781b1:	c03340        	sub	a3, a3, a4
    return ret;

#else // __riscv
    return rv_utils_compare_and_set(addr, compare_value, new_value);
#endif
}
403781b4:	40f320        	nsau	a2, a3
403781b7:	412520        	srli	a2, a2, 5
403781ba:	f01d      	retw.n

403781bc <esp_cpu_stall>:
{
403781bc:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
403781bf:	01a082        	movi	a8, 1
403781c2:	0eb827        	bgeu	a8, a2, 403781d4 <esp_cpu_stall+0x18>
403781c5:	f1d2d1        	l32r	a13, 40374910 <_iram_text_start+0x50c> (3c023450 <_flash_rodata_start+0x3330>)
403781c8:	f1d3c1        	l32r	a12, 40374914 <_iram_text_start+0x510> (3c027b10 <__func__$2>)
403781cb:	21a0b2        	movi	a11, 33
403781ce:	f1d2a1        	l32r	a10, 40374918 <_iram_text_start+0x514> (3c02349c <_flash_rodata_start+0x337c>)
403781d1:	07b7e5        	call8	4037fd50 <__assert_func>

        Note: This function can be called when the cache is disabled. We use "ternary if" instead of an array so that the
        "rodata" of the register masks/shifts will be stored in this function's "rodata" section, instead of the source
        file's "rodata" section (see IDF-5214).
    */
    uint32_t rtc_cntl_c0_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
403781d4:	00c256        	bnez	a2, 403781e4 <esp_cpu_stall+0x28>
    uint32_t rtc_cntl_c0_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_S : RTC_CNTL_SW_STALL_APPCPU_C0_S;
    uint32_t rtc_cntl_c1_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
403781d7:	f1cc81        	l32r	a8, 40374908 <_iram_text_start+0x504> (fc000000 <_rtc_reserved_end+0x9bf00000>)
    uint32_t rtc_cntl_c0_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
403781da:	2d0c      	movi.n	a13, 2
403781dc:	c90c      	movi.n	a9, 12
    uint32_t rtc_cntl_c1_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
403781de:	ac1c      	movi.n	a12, 26
403781e0:	000246        	j	403781ed <esp_cpu_stall+0x31>
403781e3:	ca8100        	float.s	f8, a1, 0
    uint32_t rtc_cntl_c1_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
403781e6:	0d0cf1        	l32r	a15, 4033b618 <rom_rx_gain_force+0x3351ec>
403781e9:	390c      	movi.n	a9, 3
    uint32_t rtc_cntl_c1_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
403781eb:	4c1c      	movi.n	a12, 20
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0_m);
403781ed:	f1cba1        	l32r	a10, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
403781f0:	0020c0        	memw
403781f3:	0ab8      	l32i.n	a11, a10, 0
403781f5:	1099b0        	and	a9, a9, a11
403781f8:	3099b0        	xor	a9, a9, a11
403781fb:	0020c0        	memw
403781fe:	0a99      	s32i.n	a9, a10, 0
    SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, 2 << rtc_cntl_c0_s);
40378200:	0020c0        	memw
40378203:	0a98      	l32i.n	a9, a10, 0
40378205:	2b0c      	movi.n	a11, 2
40378207:	401d00        	ssl	a13
4037820a:	a1bb00        	sll	a11, a11
4037820d:	2099b0        	or	a9, a9, a11
40378210:	0020c0        	memw
40378213:	0a99      	s32i.n	a9, a10, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1_m);
40378215:	f1c291        	l32r	a9, 40374920 <_iram_text_start+0x51c> (600080bc <RTCCNTL+0xbc>)
40378218:	0020c0        	memw
4037821b:	09a8      	l32i.n	a10, a9, 0
4037821d:	1088a0        	and	a8, a8, a10
40378220:	3088a0        	xor	a8, a8, a10
40378223:	0020c0        	memw
40378226:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, 0x21 << rtc_cntl_c1_s);
40378228:	0020c0        	memw
4037822b:	0988      	l32i.n	a8, a9, 0
4037822d:	1a2c      	movi.n	a10, 33
4037822f:	401c00        	ssl	a12
40378232:	a1aa00        	sll	a10, a10
40378235:	2088a0        	or	a8, a8, a10
40378238:	0020c0        	memw
4037823b:	0989      	s32i.n	a8, a9, 0
}
4037823d:	f01d      	retw.n
	...

40378240 <esp_cpu_unstall>:
{
40378240:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
40378243:	01a082        	movi	a8, 1
40378246:	0eb827        	bgeu	a8, a2, 40378258 <esp_cpu_unstall+0x18>
40378249:	f1b1d1        	l32r	a13, 40374910 <_iram_text_start+0x50c> (3c023450 <_flash_rodata_start+0x3330>)
4037824c:	f1b6c1        	l32r	a12, 40374924 <_iram_text_start+0x520> (3c027b00 <__func__$1>)
4037824f:	29a0b2        	movi	a11, 41
40378252:	f1b1a1        	l32r	a10, 40374918 <_iram_text_start+0x514> (3c02349c <_flash_rodata_start+0x337c>)
40378255:	07afa5        	call8	4037fd50 <__assert_func>

        Note: This function can be called when the cache is disabled. We use "ternary if" instead of an array so that the
        "rodata" of the register masks/shifts will be stored in this function's "rodata" section, instead of the source
        file's "rodata" section (see IDF-5214).
    */
    uint32_t rtc_cntl_c0 = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
40378258:	004256        	bnez	a2, 40378260 <esp_cpu_unstall+0x20>
4037825b:	c80c      	movi.n	a8, 12
4037825d:	000046        	j	40378262 <esp_cpu_unstall+0x22>
40378260:	380c      	movi.n	a8, 3
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0);
40378262:	f1ae91        	l32r	a9, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
40378265:	0020c0        	memw
40378268:	09a8      	l32i.n	a10, a9, 0
4037826a:	1088a0        	and	a8, a8, a10
4037826d:	3088a0        	xor	a8, a8, a10
40378270:	0020c0        	memw
40378273:	0989      	s32i.n	a8, a9, 0
    int rtc_cntl_c1 = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40378275:	42cc      	bnez.n	a2, 4037827d <esp_cpu_unstall+0x3d>
40378277:	f1a481        	l32r	a8, 40374908 <_iram_text_start+0x504> (fc000000 <_rtc_reserved_end+0x9bf00000>)
4037827a:	000086        	j	40378280 <esp_cpu_unstall+0x40>
4037827d:	f1a381        	l32r	a8, 4037490c <_iram_text_start+0x508> (3f00000 <UserFrameTotalSize+0x3efff00>)
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1);
40378280:	f1a891        	l32r	a9, 40374920 <_iram_text_start+0x51c> (600080bc <RTCCNTL+0xbc>)
40378283:	0020c0        	memw
40378286:	09a8      	l32i.n	a10, a9, 0
40378288:	1088a0        	and	a8, a8, a10
4037828b:	3088a0        	xor	a8, a8, a10
4037828e:	0020c0        	memw
40378291:	0989      	s32i.n	a8, a9, 0
}
40378293:	f01d      	retw.n
40378295:	000000        	ill

40378298 <esp_cpu_wait_for_intr>:
{
40378298:	004136        	entry	a1, 32
    asm volatile ("waiti 0\n");
4037829b:	007000        	waiti	0
}
4037829e:	f01d      	retw.n

403782a0 <esp_ptr_byte_accessible>:
    return false;
#endif  //CONFIG_SPIRAM
}

bool esp_ptr_byte_accessible(const void *p)
{
403782a0:	004136        	entry	a1, 32
    intptr_t ip = (intptr_t) p;
    bool r;
    r = (ip >= SOC_BYTE_ACCESSIBLE_LOW && ip < SOC_BYTE_ACCESSIBLE_HIGH);
403782a3:	f0f891        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
403782a6:	929a      	add.n	a9, a2, a9
403782a8:	f16581        	l32r	a8, 4037483c <_iram_text_start+0x438> (77fff <UserFrameTotalSize+0x77eff>)
403782ab:	628890        	lsi	f9, a8, 0x188
403782ae:	880b      	addi.n	a8, a8, -1
403782b0:	608080        	neg	a8, a8
403782b3:	748080        	extui	a8, a8, 0, 8
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
    /* For ESP32 case, RTC fast memory is accessible to PRO cpu only and hence
     * for single core configuration (where it gets added to system heap) following
     * additional check is required */
    r |= (ip >= SOC_RTC_DRAM_LOW && ip < SOC_RTC_DRAM_HIGH);
403782b6:	f0cd91        	l32r	a9, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403782b9:	929a      	add.n	a9, a2, a9
403782bb:	f0cd21        	l32r	a2, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
403782be:	622290        	lsi	f9, a2, 0x188
403782c1:	220b      	addi.n	a2, a2, -1
403782c3:	602020        	neg	a2, a2
403782c6:	742020        	extui	a2, a2, 0, 8
     * from the internal RAM in terms of hardware attributes. It is a part of
     * the internal RAM when added to the heap and is byte-accessible .*/
    r |= (ip >= SOC_DROM_LOW && ip < (SOC_DROM_LOW + 0x4000));
#endif
    return r;
}
403782c9:	202280        	or	a2, a2, a8
403782cc:	f01d      	retw.n
	...

403782d0 <s_mspi_flash_set_core_clock>:
/**
 * Currently we only need these on chips with timing tuning
 */
//-------------------------------------MSPI Clock Setting-------------------------------------//
static void s_mspi_flash_set_core_clock(uint8_t spi_num, uint32_t core_clock_mhz)
{
403782d0:	004136        	entry	a1, 32
__attribute__((always_inline))
static inline void mspi_timing_ll_set_core_clock(uint8_t spi_num, uint32_t core_clk_mhz)
{
    uint32_t reg_val = 0;

    switch (core_clk_mhz) {
403782d3:	a0a082        	movi	a8, 160
403782d6:	271387        	beq	a3, a8, 40378301 <s_mspi_flash_set_core_clock+0x31>
403782d9:	0f3837        	bltu	a8, a3, 403782ec <s_mspi_flash_set_core_clock+0x1c>
403782dc:	085c      	movi.n	a8, 80
403782de:	271387        	beq	a3, a8, 40378309 <s_mspi_flash_set_core_clock+0x39>
403782e1:	78a082        	movi	a8, 120
403782e4:	261387        	beq	a3, a8, 4037830e <s_mspi_flash_set_core_clock+0x3e>
403782e7:	0001c6        	j	403782f2 <s_mspi_flash_set_core_clock+0x22>
403782ea:	820000        	mull	a0, a0, a0
403782ed:	87f0a0        	lsi	f10, a0, 0x21c
403782f0:	d12113        	lsi	f1, a1, 0x344
            break;
        case 240:
            reg_val = 3;
            break;
        default:
            HAL_ASSERT(false);
403782f3:	f18d      	lsi	f8, a1, 4
403782f5:	f18dc1        	l32r	a12, 4037492c <_iram_text_start+0x528> (3fc936e8 <__func__$1>)
403782f8:	b0a0b2        	movi	a11, 176
403782fb:	f18da1        	l32r	a10, 40374930 <_iram_text_start+0x52c> (3fc93980 <__FUNCTION__$0+0x1e8>)
403782fe:	07a525        	call8	4037fd50 <__assert_func>
            reg_val = 2;
40378301:	2b0c      	movi.n	a11, 2
40378303:	0003c6        	j	40378316 <s_mspi_flash_set_core_clock+0x46>
40378306:	000000        	ill
    switch (core_clk_mhz) {
40378309:	0b0c      	movi.n	a11, 0
4037830b:	0001c6        	j	40378316 <s_mspi_flash_set_core_clock+0x46>
            reg_val = 1;
4037830e:	1b0c      	movi.n	a11, 1
40378310:	000086        	j	40378316 <s_mspi_flash_set_core_clock+0x46>
40378313:	3b0c00        	ueq.s	b0, f12, f0
    }

    REG_SET_FIELD(SPI_MEM_CORE_CLK_SEL_REG(spi_num), SPI_MEM_CORE_CLK_SEL, reg_val);
40378316:	f18781        	l32r	a8, 40374934 <_iram_text_start+0x530> (60003 <UserFrameTotalSize+0x5ff03>)
40378319:	c08820        	sub	a8, a8, a2
4037831c:	118840        	slli	a8, a8, 12
4037831f:	eca092        	movi	a9, 236
40378322:	889a      	add.n	a8, a8, a9
40378324:	0020c0        	memw
40378327:	0898      	l32i.n	a9, a8, 0
40378329:	ca7c      	movi.n	a10, -4
4037832b:	1099a0        	and	a9, a9, a10
4037832e:	2099b0        	or	a9, a9, a11
40378331:	0020c0        	memw
40378334:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_core_clock(spi_num, core_clock_mhz);
}
40378336:	f01d      	retw.n

40378338 <s_mspi_psram_set_core_clock>:

static void s_mspi_psram_set_core_clock(uint8_t spi_num, uint32_t core_clock_mhz)
{
40378338:	004136        	entry	a1, 32
    switch (core_clk_mhz) {
4037833b:	a0a082        	movi	a8, 160
4037833e:	271387        	beq	a3, a8, 40378369 <s_mspi_psram_set_core_clock+0x31>
40378341:	0f3837        	bltu	a8, a3, 40378354 <s_mspi_psram_set_core_clock+0x1c>
40378344:	085c      	movi.n	a8, 80
40378346:	271387        	beq	a3, a8, 40378371 <s_mspi_psram_set_core_clock+0x39>
40378349:	78a082        	movi	a8, 120
4037834c:	261387        	beq	a3, a8, 40378376 <s_mspi_psram_set_core_clock+0x3e>
4037834f:	0001c6        	j	4037835a <s_mspi_psram_set_core_clock+0x22>
40378352:	820000        	mull	a0, a0, a0
40378355:	87f0a0        	lsi	f10, a0, 0x21c
40378358:	d12113        	lsi	f1, a1, 0x344
            HAL_ASSERT(false);
4037835b:	c1f173        	lsi	f7, a1, 0x304
4037835e:	b2f173        	lsi	f7, a1, 0x2c8
40378361:	a1b0a0        	lsi	f10, a0, 0x284
40378364:	a5f173        	lsi	f7, a1, 0x294
40378367:	9e          	.byte	0x9e
40378368:	2b0c07        	bnone	a12, a0, 40378397 <s_mspi_psram_set_core_clock+0x5f>
            reg_val = 2;
4037836b:	0003c6        	j	4037837e <s_mspi_psram_set_core_clock+0x46>
4037836e:	000000        	ill
    switch (core_clk_mhz) {
40378371:	0b0c      	movi.n	a11, 0
40378373:	0001c6        	j	4037837e <s_mspi_psram_set_core_clock+0x46>
            reg_val = 1;
40378376:	1b0c      	movi.n	a11, 1
40378378:	000086        	j	4037837e <s_mspi_psram_set_core_clock+0x46>
4037837b:	3b0c00        	ueq.s	b0, f12, f0
    REG_SET_FIELD(SPI_MEM_CORE_CLK_SEL_REG(spi_num), SPI_MEM_CORE_CLK_SEL, reg_val);
4037837e:	f16d81        	l32r	a8, 40374934 <_iram_text_start+0x530> (60003 <UserFrameTotalSize+0x5ff03>)
40378381:	c08820        	sub	a8, a8, a2
40378384:	118840        	slli	a8, a8, 12
40378387:	eca092        	movi	a9, 236
4037838a:	889a      	add.n	a8, a8, a9
4037838c:	0020c0        	memw
4037838f:	0898      	l32i.n	a9, a8, 0
40378391:	ca7c      	movi.n	a10, -4
40378393:	1099a0        	and	a9, a9, a10
40378396:	2099b0        	or	a9, a9, a11
40378399:	0020c0        	memw
4037839c:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_core_clock(spi_num, core_clock_mhz);
}
4037839e:	f01d      	retw.n

403783a0 <mspi_timing_config_set_flash_clock>:

void mspi_timing_config_set_flash_clock(uint32_t flash_freq_mhz, mspi_timing_speed_mode_t speed_mode, bool control_both_mspi)
{
403783a0:	004136        	entry	a1, 32
403783a3:	744040        	extui	a4, a4, 0, 8
        core_clock_mhz = FLASH_LOW_SPEED_CORE_CLOCK_MHZ;
    } else {
        core_clock_mhz = FLASH_HIGH_SPEED_CORE_CLOCK_MHZ;
    }
    //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
    s_mspi_flash_set_core_clock(0, core_clock_mhz);
403783a6:	50a0b2        	movi	a11, 80
403783a9:	00a0a2        	movi	a10, 0
403783ac:	fff225        	call8	403782d0 <s_mspi_flash_set_core_clock>

    uint32_t freqdiv = core_clock_mhz / flash_freq_mhz;
403783af:	095c      	movi.n	a9, 80
403783b1:	c28920        	quou	a8, a9, a2
    assert(freqdiv > 0);
403783b4:	0db927        	bgeu	a9, a2, 403783c5 <mspi_timing_config_set_flash_clock+0x25>
403783b7:	f160d1        	l32r	a13, 40374938 <_iram_text_start+0x534> (3fc939b4 <__FUNCTION__$0+0x21c>)
403783ba:	f160c1        	l32r	a12, 4037493c <_iram_text_start+0x538> (3fc93708 <__func__$2>)
403783bd:	1b3c      	movi.n	a11, 49
403783bf:	f160a1        	l32r	a10, 40374940 <_iram_text_start+0x53c> (3fc93a00 <__FUNCTION__$0+0x268>)
403783c2:	0798e5        	call8	4037fd50 <__assert_func>
 * @param freqdiv  Divider value
 */
__attribute__((always_inline))
static inline void mspi_timing_ll_set_flash_clock(uint8_t spi_num, uint32_t freqdiv)
{
    if (freqdiv == 1) {
403783c5:	0d1866        	bnei	a8, 1, 403783d6 <mspi_timing_config_set_flash_clock+0x36>
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
403783c8:	f15f91        	l32r	a9, 40374944 <_iram_text_start+0x540> (60003014 <SPIMEM0+0x14>)
403783cb:	f054a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403783ce:	0020c0        	memw
403783d1:	09a9      	s32i.n	a10, a9, 0
403783d3:	000686        	j	403783f1 <mspi_timing_config_set_flash_clock+0x51>
    } else {
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
403783d6:	a80b      	addi.n	a10, a8, -1
403783d8:	11ba00        	slli	a11, a10, 16
403783db:	419180        	srli	a9, a8, 1
403783de:	990b      	addi.n	a9, a9, -1
403783e0:	119980        	slli	a9, a9, 8
403783e3:	209b90        	or	a9, a11, a9
403783e6:	20aa90        	or	a10, a10, a9
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), freqbits);
403783e9:	f15691        	l32r	a9, 40374944 <_iram_text_start+0x540> (60003014 <SPIMEM0+0x14>)
403783ec:	0020c0        	memw
403783ef:	09a9      	s32i.n	a10, a9, 0
    mspi_timing_ll_set_flash_clock(0, freqdiv);
    if (control_both_mspi) {
403783f1:	b4ac      	beqz.n	a4, 40378420 <mspi_timing_config_set_flash_clock+0x80>
    if (freqdiv == 1) {
403783f3:	0e1866        	bnei	a8, 1, 40378405 <mspi_timing_config_set_flash_clock+0x65>
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
403783f6:	f15481        	l32r	a8, 40374948 <_iram_text_start+0x544> (60002014 <SPIMEM1+0x14>)
403783f9:	f04891        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403783fc:	0020c0        	memw
403783ff:	0899      	s32i.n	a9, a8, 0
40378401:	0006c6        	j	40378420 <mspi_timing_config_set_flash_clock+0x80>
40378404:	980b00        	lsi	f0, a11, 0x260
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
40378407:	11a900        	slli	a10, a9, 16
4037840a:	418180        	srli	a8, a8, 1
4037840d:	880b      	addi.n	a8, a8, -1
4037840f:	118880        	slli	a8, a8, 8
40378412:	208a80        	or	a8, a10, a8
40378415:	209980        	or	a9, a9, a8
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), freqbits);
40378418:	f14c81        	l32r	a8, 40374948 <_iram_text_start+0x544> (60002014 <SPIMEM1+0x14>)
4037841b:	0020c0        	memw
4037841e:	0899      	s32i.n	a9, a8, 0
        mspi_timing_ll_set_flash_clock(1, freqdiv);
    }
}
40378420:	f01d      	retw.n
	...

40378424 <mspi_timing_config_set_psram_clock>:

void mspi_timing_config_set_psram_clock(uint32_t psram_freq_mhz, mspi_timing_speed_mode_t speed_mode, bool control_both_mspi)
{
40378424:	004136        	entry	a1, 32
        core_clock_mhz = PSRAM_LOW_SPEED_CORE_CLOCK_MHZ;
    } else {
        core_clock_mhz = PSRAM_HIGH_SPEED_CORE_CLOCK_MHZ;
    }
    //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
    s_mspi_psram_set_core_clock(0, core_clock_mhz);
40378427:	0b5c      	movi.n	a11, 80
40378429:	0a0c      	movi.n	a10, 0
4037842b:	fff0e5        	call8	40378338 <s_mspi_psram_set_core_clock>

    uint32_t freqdiv = core_clock_mhz / psram_freq_mhz;
4037842e:	095c      	movi.n	a9, 80
40378430:	c28920        	quou	a8, a9, a2
    assert(freqdiv > 0);
40378433:	0db927        	bgeu	a9, a2, 40378444 <mspi_timing_config_set_psram_clock+0x20>
40378436:	f140d1        	l32r	a13, 40374938 <_iram_text_start+0x534> (3fc939b4 <__FUNCTION__$0+0x21c>)
40378439:	f144c1        	l32r	a12, 4037494c <_iram_text_start+0x548> (3fc936c4 <__func__$0>)
4037843c:	5b4c      	movi.n	a11, 69
4037843e:	f140a1        	l32r	a10, 40374940 <_iram_text_start+0x53c> (3fc93a00 <__FUNCTION__$0+0x268>)
40378441:	0790e5        	call8	4037fd50 <__assert_func>
 * @param freqdiv  Divider value
 */
__attribute__((always_inline))
static inline void mspi_timing_ll_set_psram_clock(uint8_t spi_num, uint32_t freqdiv)
{
    if (freqdiv == 1) {
40378444:	0d1866        	bnei	a8, 1, 40378455 <mspi_timing_config_set_psram_clock+0x31>
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), SPI_MEM_SCLK_EQU_SYSCLK);
40378447:	f14281        	l32r	a8, 40374950 <_iram_text_start+0x54c> (60003050 <SPIMEM0+0x50>)
4037844a:	f03491        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037844d:	0020c0        	memw
40378450:	0899      	s32i.n	a9, a8, 0
40378452:	000686        	j	40378470 <mspi_timing_config_set_psram_clock+0x4c>
    } else {
        uint32_t freqbits = (((freqdiv-1)<<SPI_MEM_SCLKCNT_N_S)) | (((freqdiv/2-1)<<SPI_MEM_SCLKCNT_H_S)) | ((freqdiv-1)<<SPI_MEM_SCLKCNT_L_S);
40378455:	980b      	addi.n	a9, a8, -1
40378457:	11a900        	slli	a10, a9, 16
4037845a:	418180        	srli	a8, a8, 1
4037845d:	880b      	addi.n	a8, a8, -1
4037845f:	118880        	slli	a8, a8, 8
40378462:	208a80        	or	a8, a10, a8
40378465:	209980        	or	a9, a9, a8
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), freqbits);
40378468:	f13a81        	l32r	a8, 40374950 <_iram_text_start+0x54c> (60003050 <SPIMEM0+0x50>)
4037846b:	0020c0        	memw
4037846e:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_psram_clock(0, freqdiv);
}
40378470:	f01d      	retw.n
	...

40378474 <mspi_timing_enter_low_speed_mode>:

/*------------------------------------------------------------------------------
 * APIs to make SPI0 (and SPI1) FLASH work for high/low freq
 *----------------------------------------------------------------------------*/
void mspi_timing_enter_low_speed_mode(bool control_spi1)
{
40378474:	004136        	entry	a1, 32
40378477:	742020        	extui	a2, a2, 0, 8
     *
     * Currently we only need to change these clocks on chips with timing tuning
     * Should be extended to other no-timing-tuning chips if needed. e.g.:
     * we still need to turn down Flash / PSRAM clock speed at a certain period of time
     */
    mspi_timing_config_set_flash_clock(20, MSPI_TIMING_SPEED_MODE_LOW_PERF, control_spi1);
4037847a:	20c220        	or	a12, a2, a2
4037847d:	00a0b2        	movi	a11, 0
40378480:	4a1c      	movi.n	a10, 20
40378482:	fff1e5        	call8	403783a0 <mspi_timing_config_set_flash_clock>
    mspi_timing_config_set_psram_clock(20, MSPI_TIMING_SPEED_MODE_LOW_PERF, control_spi1);
40378485:	02cd      	mov.n	a12, a2
40378487:	0b0c      	movi.n	a11, 0
40378489:	4a1c      	movi.n	a10, 20
4037848b:	fff9a5        	call8	40378424 <mspi_timing_config_set_psram_clock>

#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
    mspi_timing_flash_config_clear_tuning_regs(control_spi1);
    mspi_timing_psram_config_clear_tuning_regs(control_spi1);
#endif  //#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
}
4037848e:	f01d      	retw.n

40378490 <mspi_timing_enter_high_speed_mode>:
 * iF control_spi1 == 1, will also update SPI1 timing registers. Should only be set to 1 when do tuning.
 *
 * This function should always be called after `mspi_timing_flash_tuning` or `calculate_best_flash_tuning_config`
 */
void mspi_timing_enter_high_speed_mode(bool control_spi1)
{
40378490:	004136        	entry	a1, 32
    /**
     * Currently we only need to change these clocks on chips with timing tuning
     * Should be extended to other no-timing-tuning chips if needed. e.g.:
     * we still need to turn down Flash / PSRAM clock speed at a certain period of time
     */
    mspi_timing_config_set_flash_clock(FLASH_FREQUENCY_MHZ, MSPI_TIMING_SPEED_MODE_NORMAL_PERF, control_spi1);
40378493:	74c020        	extui	a12, a2, 0, 8
40378496:	01a0b2        	movi	a11, 1
40378499:	50a0a2        	movi	a10, 80
4037849c:	fff025        	call8	403783a0 <mspi_timing_config_set_flash_clock>

#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
    mspi_timing_flash_config_set_tuning_regs(control_spi1);
    mspi_timing_psram_config_set_tuning_regs(control_spi1);
#endif  //#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
}
4037849f:	000090        	retw
	...

403784a4 <mspi_timing_change_speed_mode_cache_safe>:

void mspi_timing_change_speed_mode_cache_safe(bool switch_down)
{
403784a4:	004136        	entry	a1, 32
403784a7:	742020        	extui	a2, a2, 0, 8
     * - or other way
     *
     * for preventing concurrent from MSPI to external memory
     */
#if SOC_CACHE_FREEZE_SUPPORTED
    cache_hal_freeze(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403784aa:	2b0c      	movi.n	a11, 2
403784ac:	1a0c      	movi.n	a10, 1
403784ae:	046ae5        	call8	4037cb5c <cache_hal_freeze>
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

    if (switch_down) {
403784b1:	728c      	beqz.n	a2, 403784bc <mspi_timing_change_speed_mode_cache_safe+0x18>
        //enter MSPI low speed mode, extra delays should be removed
        mspi_timing_enter_low_speed_mode(false);
403784b3:	0a0c      	movi.n	a10, 0
403784b5:	fffbe5        	call8	40378474 <mspi_timing_enter_low_speed_mode>
403784b8:	000186        	j	403784c2 <mspi_timing_change_speed_mode_cache_safe+0x1e>
403784bb:	a0a200        	addx4	a10, a2, a0
    } else {
        //enter MSPI high speed mode, extra delays should be considered
        mspi_timing_enter_high_speed_mode(false);
403784be:	fd2500        	lsi	f0, a5, 0x3f4
403784c1:	ff          	.byte	0xff
    }

#if SOC_CACHE_FREEZE_SUPPORTED
    cache_hal_unfreeze(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403784c2:	02a0b2        	movi	a11, 2
403784c5:	1a0c      	movi.n	a10, 1
403784c7:	046d25        	call8	4037cb98 <cache_hal_unfreeze>
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE && !CONFIG_FREERTOS_UNICORE
    esp_ipc_isr_release_other_cpu();
#endif
}
403784ca:	f01d      	retw.n

403784cc <spi_timing_get_flash_timing_param>:
    // Get CS setup/hold value here.
    mspi_timing_config_get_cs_timing(&out_timing_config->cs_setup, &out_timing_config->cs_hold);
}
#else
void spi_timing_get_flash_timing_param(spi_flash_hal_timing_config_t *out_timing_config)
{
403784cc:	004136        	entry	a1, 32
    // This function shouldn't be called if timing tuning is not used.
    abort();
403784cf:	077c65        	call8	4037fc94 <abort>
	...

403784d4 <mspi_timing_set_pin_drive_strength>:

/*------------------------------------------------------------------------------
 * Common settings
 *----------------------------------------------------------------------------*/
void mspi_timing_set_pin_drive_strength(void)
{
403784d4:	00a136        	entry	a1, 80
    SET_PERI_REG_MASK(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPICLK_PAD_DRV_CTL_EN);
403784d7:	f11f81        	l32r	a8, 40374954 <_iram_text_start+0x550> (600033fc <SPIMEM0+0x3fc>)
403784da:	0020c0        	memw
403784dd:	0898      	l32i.n	a9, a8, 0
403784df:	0a1c      	movi.n	a10, 16
403784e1:	2099a0        	or	a9, a9, a10
403784e4:	0020c0        	memw
403784e7:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPI_SMEM_SPICLK_FUN_DRV, val);
403784e9:	0020c0        	memw
403784ec:	0898      	l32i.n	a9, a8, 0
403784ee:	3a0c      	movi.n	a10, 3
403784f0:	2099a0        	or	a9, a9, a10
403784f3:	0020c0        	memw
403784f6:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPI_FMEM_SPICLK_FUN_DRV, val);
403784f8:	0020c0        	memw
403784fb:	0898      	l32i.n	a9, a8, 0
403784fd:	ca0c      	movi.n	a10, 12
403784ff:	2099a0        	or	a9, a9, a10
40378502:	0020c0        	memw
40378505:	0899      	s32i.n	a9, a8, 0
    uint32_t regs[] = {IO_MUX_GPIO27_REG, IO_MUX_GPIO28_REG,
40378507:	4c2c      	movi.n	a12, 36
40378509:	f113b1        	l32r	a11, 40374958 <_iram_text_start+0x554> (3fc9372c <__func__$2+0x24>)
4037850c:	01ad      	mov.n	a10, a1
4037850e:	eff181        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40378511:	0008e0        	callx8	a8
    for (int i = 0; i < ARRAY_SIZE(regs); i++) {
40378514:	080c      	movi.n	a8, 0
40378516:	000586        	j	40378530 <mspi_timing_set_pin_drive_strength+0x5c>
        PIN_SET_DRV(regs[i], val);
40378519:	a09810        	addx4	a9, a8, a1
4037851c:	09a8      	l32i.n	a10, a9, 0
4037851e:	0020c0        	memw
40378521:	0a98      	l32i.n	a9, a10, 0
40378523:	f10eb1        	l32r	a11, 4037495c <_iram_text_start+0x558> (c00 <UserFrameTotalSize+0xb00>)
40378526:	2099b0        	or	a9, a9, a11
40378529:	0020c0        	memw
4037852c:	0a99      	s32i.n	a9, a10, 0
    for (int i = 0; i < ARRAY_SIZE(regs); i++) {
4037852e:	881b      	addi.n	a8, a8, 1
40378530:	890c      	movi.n	a9, 8
40378532:	e3b987        	bgeu	a9, a8, 40378519 <mspi_timing_set_pin_drive_strength+0x45>
#if SOC_MEMSPI_TIMING_TUNING_BY_MSPI_DELAY
    //For now, set them all to 3. Need to check after QVL test results are out. TODO: IDF-3663
    //Set default pin drive
    mspi_timing_ll_set_all_pin_drive(0, 3);
#endif  //  #if SOC_MEMSPI_TIMING_TUNING_BY_MSPI_DELAY
}
40378535:	f01d      	retw.n
	...

40378538 <mspi_timing_flash_tuning>:
{
40378538:	004136        	entry	a1, 32
}
4037853b:	f01d      	retw.n
4037853d:	000000        	ill

40378540 <spi_flash_timing_is_tuned>:
{
40378540:	004136        	entry	a1, 32
}
40378543:	020c      	movi.n	a2, 0
40378545:	f01d      	retw.n
	...

40378548 <rtc_clk_bbpll_disable>:
{
    return clk_ll_rtc_fast_get_src();
}

static void rtc_clk_bbpll_disable(void)
{
40378548:	004136        	entry	a1, 32
/**
 * @brief Power down BBPLL circuit
 */
static inline __attribute__((always_inline)) void clk_ll_bbpll_disable(void)
{
    REG_SET_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
4037854b:	f0f491        	l32r	a9, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
4037854e:	0020c0        	memw
40378551:	0988      	l32i.n	a8, a9, 0
40378553:	40a5a2        	movi	a10, 0x540
40378556:	2088a0        	or	a8, a8, a10
40378559:	0020c0        	memw
4037855c:	0989      	s32i.n	a8, a9, 0
    clk_ll_bbpll_disable();
    s_cur_pll_freq = 0;
4037855e:	f10081        	l32r	a8, 40374960 <_iram_text_start+0x55c> (3fc94b08 <s_cur_pll_freq>)
40378561:	090c      	movi.n	a9, 0
40378563:	0899      	s32i.n	a9, a8, 0
}
40378565:	f01d      	retw.n
	...

40378568 <rtc_clk_bbpll_enable>:

static void rtc_clk_bbpll_enable(void)
{
40378568:	004136        	entry	a1, 32
    REG_CLR_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
4037856b:	f0ec91        	l32r	a9, 4037491c <_iram_text_start+0x518> (60008000 <RTCCNTL>)
4037856e:	0020c0        	memw
40378571:	0988      	l32i.n	a8, a9, 0
40378573:	bfaaa2        	movi	a10, 0xfffffabf
40378576:	1088a0        	and	a8, a8, a10
40378579:	0020c0        	memw
4037857c:	0989      	s32i.n	a8, a9, 0
    clk_ll_bbpll_enable();
}
4037857e:	f01d      	retw.n

40378580 <rtc_clk_cpu_freq_to_8m>:

    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
}

static void rtc_clk_cpu_freq_to_8m(void)
{
40378580:	004136        	entry	a1, 32
    assert(0 && "LDO dbias need to modified");
40378583:	f0f8d1        	l32r	a13, 40374964 <_iram_text_start+0x560> (3fc93868 <__FUNCTION__$0+0xd0>)
40378586:	f0f8c1        	l32r	a12, 40374968 <_iram_text_start+0x564> (3fc93750 <__func__$2>)
40378589:	9da1b2        	movi	a11, 0x19d
4037858c:	f0f8a1        	l32r	a10, 4037496c <_iram_text_start+0x568> (3fc938b9 <__FUNCTION__$0+0x121>)
4037858f:	077c25        	call8	4037fd50 <__assert_func>
	...

40378594 <rtc_clk_bbpll_configure>:
{
40378594:	004136        	entry	a1, 32
 *
 * @param pll_freq_mhz PLL frequency, in MHz
 */
static inline __attribute__((always_inline)) void clk_ll_bbpll_set_freq_mhz(uint32_t pll_freq_mhz)
{
    switch (pll_freq_mhz) {
40378597:	40a182        	movi	a8, 0x140
4037859a:	0a1387        	beq	a3, a8, 403785a8 <rtc_clk_bbpll_configure+0x14>
4037859d:	e0a182        	movi	a8, 0x1e0
403785a0:	191387        	beq	a3, a8, 403785bd <rtc_clk_bbpll_configure+0x29>
403785a3:	000ac6        	j	403785d2 <rtc_clk_bbpll_configure+0x3e>
403785a6:	910000        	srl	a0, a0
    case CLK_LL_PLL_320M_FREQ_MHZ: // PLL_320M
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 0);
403785a9:	c0f0f2        	s32ri	a15, a0, 0x300
403785ac:	880020        	lsi	f2, a0, 0x220
403785af:	7c09      	s32i.n	a0, a12, 28
403785b1:	a0ba      	add.n	a10, a0, a11
403785b3:	1088      	l32i.n	a8, a0, 4
403785b5:	0020c0        	memw
403785b8:	0989      	s32i.n	a8, a9, 0
        break;
403785ba:	0005c6        	j	403785d5 <rtc_clk_bbpll_configure+0x41>
    case CLK_LL_PLL_480M_FREQ_MHZ: // PLL_480M
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 1);
403785bd:	f0ec91        	l32r	a9, 40374970 <_iram_text_start+0x56c> (600c0010 <SYSTEM+0x10>)
403785c0:	0020c0        	memw
403785c3:	0988      	l32i.n	a8, a9, 0
403785c5:	4a0c      	movi.n	a10, 4
403785c7:	2088a0        	or	a8, a8, a10
403785ca:	0020c0        	memw
403785cd:	0989      	s32i.n	a8, a9, 0
        break;
403785cf:	000086        	j	403785d5 <rtc_clk_bbpll_configure+0x41>
    default:
        abort();
403785d2:	076c25        	call8	4037fc94 <abort>
/**
 * @brief Start BBPLL self-calibration
 */
static inline __attribute__((always_inline)) void regi2c_ctrl_ll_bbpll_calibration_start(void)
{
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
403785d5:	f0e781        	l32r	a8, 40374974 <_iram_text_start+0x570> (6000e040 <SENS+0x5840>)
403785d8:	0020c0        	memw
403785db:	002892        	l32i	a9, a8, 0
403785de:	fbafa2        	movi	a10, -5
403785e1:	1099a0        	and	a9, a9, a10
403785e4:	0020c0        	memw
403785e7:	006892        	s32i	a9, a8, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
403785ea:	0020c0        	memw
403785ed:	0898      	l32i.n	a9, a8, 0
403785ef:	8a0c      	movi.n	a10, 8
403785f1:	2099a0        	or	a9, a9, a10
403785f4:	0020c0        	memw
403785f7:	0899      	s32i.n	a9, a8, 0
    uint8_t dr3;
    uint8_t dchgp;
    uint8_t dcur;
    uint8_t dbias = 3;

    if (pll_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
403785f9:	e0a182        	movi	a8, 0x1e0
403785fc:	2c9387        	bne	a3, a8, 4037862c <rtc_clk_bbpll_configure+0x98>
        /* Configure 480M PLL */
        switch (xtal_freq_mhz) {
403785ff:	0ac226        	beqi	a2, 32, 4037860d <rtc_clk_bbpll_configure+0x79>
            div_ref = 0;
            div7_0 = 8;
            dr1 = 0;
            dr3 = 0;
            dchgp = 5;
            dcur = 3;
40378602:	370c      	movi.n	a7, 3
            dchgp = 5;
40378604:	520c      	movi.n	a2, 5
            div7_0 = 8;
40378606:	0a4d      	mov.n	a4, a10
            div_ref = 0;
40378608:	050c      	movi.n	a5, 0
4037860a:	000286        	j	40378618 <rtc_clk_bbpll_configure+0x84>
            div_ref = 1;
            div7_0 = 26;
            dr1 = 1;
            dr3 = 1;
            dchgp = 4;
            dcur = 0;
4037860d:	00a072        	movi	a7, 0
            dchgp = 4;
40378610:	04a022        	movi	a2, 4
            div7_0 = 26;
40378613:	1aa042        	movi	a4, 26
            div_ref = 1;
40378616:	150c      	movi.n	a5, 1
            dr3 = 0;
            dchgp = 5;
            dcur = 3;
            break;
        }
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x6B);
40378618:	6ba0d2        	movi	a13, 107
4037861b:	4c0c      	movi.n	a12, 4
4037861d:	1b0c      	movi.n	a11, 1
4037861f:	66a0a2        	movi	a10, 102
40378622:	fe1ba5        	call8	403767dc <regi2c_ctrl_write_reg>
40378625:	056d      	mov.n	a6, a5
40378627:	000886        	j	4037864d <rtc_clk_bbpll_configure+0xb9>
4037862a:	260000        	lsi	f0, a0, 152
    } else {
        /* Configure 320M PLL */
        switch (xtal_freq_mhz) {
4037862d:	0c06c2        	l8ui	a12, a6, 12
        case SOC_XTAL_FREQ_40M:
            div_ref = 0;
            div7_0 = 4;
40378630:	050c44        	lsi	f4, a12, 20
            div_ref = 0;
40378633:	0000c6        	j	4037863a <rtc_clk_bbpll_configure+0xa6>
            dchgp = 5;
            dcur = 3;
            break;
        case SOC_XTAL_FREQ_32M:
            div_ref = 1;
            div7_0 = 6;
40378636:	640c      	movi.n	a4, 6
            div_ref = 1;
40378638:	150c      	movi.n	a5, 1
            dr3 = 0;
            dchgp = 5;
            dcur = 3;
            break;
        }
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x69);
4037863a:	69a0d2        	movi	a13, 105
4037863d:	4c0c      	movi.n	a12, 4
4037863f:	1b0c      	movi.n	a11, 1
40378641:	66a0a2        	movi	a10, 102
40378644:	fe1965        	call8	403767dc <regi2c_ctrl_write_reg>
40378647:	370c      	movi.n	a7, 3
40378649:	520c      	movi.n	a2, 5
4037864b:	060c      	movi.n	a6, 0
    }
    uint8_t i2c_bbpll_lref  = (dchgp << I2C_BBPLL_OC_DCHGP_LSB) | (div_ref);
4037864d:	11d2c0        	slli	a13, a2, 4
    uint8_t i2c_bbpll_div_7_0 = div7_0;
    uint8_t i2c_bbpll_dcur = (1 << I2C_BBPLL_OC_DLREF_SEL_LSB ) | (3 << I2C_BBPLL_OC_DHREF_SEL_LSB) | dcur;
40378650:	70a082        	movi	a8, 112
40378653:	207780        	or	a7, a7, a8
40378656:	747070        	extui	a7, a7, 0, 8
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_REF_DIV, i2c_bbpll_lref);
40378659:	20d5d0        	or	a13, a5, a13
4037865c:	2c0c      	movi.n	a12, 2
4037865e:	1b0c      	movi.n	a11, 1
40378660:	66a0a2        	movi	a10, 102
40378663:	fe17a5        	call8	403767dc <regi2c_ctrl_write_reg>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DIV_7_0, i2c_bbpll_div_7_0);
40378666:	04dd      	mov.n	a13, a4
40378668:	3c0c      	movi.n	a12, 3
4037866a:	1b0c      	movi.n	a11, 1
4037866c:	66a0a2        	movi	a10, 102
4037866f:	fe16e5        	call8	403767dc <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR1, dr1);
40378672:	06fd      	mov.n	a15, a6
40378674:	0e0c      	movi.n	a14, 0
40378676:	2d0c      	movi.n	a13, 2
40378678:	5c0c      	movi.n	a12, 5
4037867a:	1b0c      	movi.n	a11, 1
4037867c:	66a0a2        	movi	a10, 102
4037867f:	fe1ae5        	call8	4037682c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR3, dr3);
40378682:	06fd      	mov.n	a15, a6
40378684:	4e0c      	movi.n	a14, 4
40378686:	6d0c      	movi.n	a13, 6
40378688:	5c0c      	movi.n	a12, 5
4037868a:	01a0b2        	movi	a11, 1
4037868d:	66a0a2        	movi	a10, 102
40378690:	fe19a5        	call8	4037682c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DCUR, i2c_bbpll_dcur);
40378693:	07dd      	mov.n	a13, a7
40378695:	6c0c      	movi.n	a12, 6
40378697:	01a0b2        	movi	a11, 1
4037869a:	66a0a2        	movi	a10, 102
4037869d:	fe13e5        	call8	403767dc <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_VCO_DBIAS, dbias);
403786a0:	3f0c      	movi.n	a15, 3
403786a2:	0e0c      	movi.n	a14, 0
403786a4:	1d0c      	movi.n	a13, 1
403786a6:	9c0c      	movi.n	a12, 9
403786a8:	20bdd0        	or	a11, a13, a13
403786ab:	66a0a2        	movi	a10, 102
403786ae:	fe17e5        	call8	4037682c <regi2c_ctrl_write_reg_mask>
 *
 * @return True if calibration is done; otherwise false
 */
static inline __attribute__((always_inline)) bool regi2c_ctrl_ll_bbpll_calibration_is_done(void)
{
    return REG_GET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_CAL_DONE);
403786b1:	f0b081        	l32r	a8, 40374974 <_iram_text_start+0x570> (6000e040 <SENS+0x5840>)
403786b4:	0020c0        	memw
403786b7:	0888      	l32i.n	a8, a8, 0
    while(!regi2c_ctrl_ll_bbpll_calibration_is_done());
403786b9:	f47887        	bbci	a8, 24, 403786b1 <rtc_clk_bbpll_configure+0x11d>
    esp_rom_delay_us(10);
403786bc:	aa0c      	movi.n	a10, 10
403786be:	ef5d81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
403786c1:	0008e0        	callx8	a8
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
403786c4:	f0ac81        	l32r	a8, 40374974 <_iram_text_start+0x570> (6000e040 <SENS+0x5840>)
403786c7:	0020c0        	memw
403786ca:	0898      	l32i.n	a9, a8, 0
403786cc:	7a7c      	movi.n	a10, -9
403786ce:	1099a0        	and	a9, a9, a10
403786d1:	0020c0        	memw
403786d4:	0899      	s32i.n	a9, a8, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
403786d6:	0020c0        	memw
403786d9:	0898      	l32i.n	a9, a8, 0
403786db:	4a0c      	movi.n	a10, 4
403786dd:	2099a0        	or	a9, a9, a10
403786e0:	0020c0        	memw
403786e3:	0899      	s32i.n	a9, a8, 0
    s_cur_pll_freq = pll_freq;
403786e5:	f09e81        	l32r	a8, 40374960 <_iram_text_start+0x55c> (3fc94b08 <s_cur_pll_freq>)
403786e8:	0839      	s32i.n	a3, a8, 0
}
403786ea:	f01d      	retw.n

403786ec <rtc_clk_bbpll_add_consumer>:
{
403786ec:	004136        	entry	a1, 32
    s_bbpll_digi_consumers_ref_count += 1;
403786ef:	f0a291        	l32r	a9, 40374978 <_iram_text_start+0x574> (3fc94b00 <s_bbpll_digi_consumers_ref_count>)
403786f2:	0988      	l32i.n	a8, a9, 0
403786f4:	881b      	addi.n	a8, a8, 1
403786f6:	0989      	s32i.n	a8, a9, 0
}
403786f8:	f01d      	retw.n
	...

403786fc <rtc_clk_bbpll_remove_consumer>:
{
403786fc:	004136        	entry	a1, 32
    s_bbpll_digi_consumers_ref_count -= 1;
403786ff:	f09e91        	l32r	a9, 40374978 <_iram_text_start+0x574> (3fc94b00 <s_bbpll_digi_consumers_ref_count>)
40378702:	0988      	l32i.n	a8, a9, 0
40378704:	880b      	addi.n	a8, a8, -1
40378706:	0989      	s32i.n	a8, a9, 0
}
40378708:	f01d      	retw.n
	...

4037870c <rtc_clk_32k_enable>:
{
4037870c:	004136        	entry	a1, 32
4037870f:	742020        	extui	a2, a2, 0, 8
    if (enable) {
40378712:	0be216        	beqz	a2, 403787d4 <rtc_clk_32k_enable+0xc8>
        SET_PERI_REG_MASK(RTC_IO_XTAL_32P_PAD_REG, RTC_IO_X32P_MUX_SEL);
40378715:	f09991        	l32r	a9, 4037497c <_iram_text_start+0x578> (600084c0 <RTCIO+0xc0>)
40378718:	0020c0        	memw
4037871b:	0988      	l32i.n	a8, a9, 0
4037871d:	f098a1        	l32r	a10, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
40378720:	2088a0        	or	a8, a8, a10
40378723:	0020c0        	memw
40378726:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_IO_XTAL_32N_PAD_REG, RTC_IO_X32N_MUX_SEL);
40378728:	f09791        	l32r	a9, 40374984 <_iram_text_start+0x580> (600084c4 <RTCIO+0xc4>)
4037872b:	0020c0        	memw
4037872e:	0988      	l32i.n	a8, a9, 0
40378730:	2088a0        	or	a8, a8, a10
40378733:	0020c0        	memw
40378736:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_GPIO_SEL);
40378738:	f09491        	l32r	a9, 40374988 <_iram_text_start+0x584> (60008060 <RTCCNTL+0x60>)
4037873b:	0020c0        	memw
4037873e:	0988      	l32i.n	a8, a9, 0
40378740:	f093a1        	l32r	a10, 4037498c <_iram_text_start+0x588> (ff7fffff <_rtc_reserved_end+0x9f6fffff>)
40378743:	1088a0        	and	a8, a8, a10
40378746:	0020c0        	memw
40378749:	0989      	s32i.n	a8, a9, 0
        clk_ll_xtal32k_config_t cfg = CLK_LL_XTAL32K_CONFIG_DEFAULT();
4037874b:	380c      	movi.n	a8, 3
4037874d:	c0a0a2        	movi	a10, 192
40378750:	2088a0        	or	a8, a8, a10
40378753:	00a6a2        	movi	a10, 0x600
40378756:	2088a0        	or	a8, a8, a10
40378759:	efc5a1        	l32r	a10, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037875c:	2088a0        	or	a8, a8, a10
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DAC_XTAL_32K, cfg.dac);
4037875f:	0020c0        	memw
40378762:	09a8      	l32i.n	a10, a9, 0
40378764:	f08bb1        	l32r	a11, 40374990 <_iram_text_start+0x58c> (fff1ffff <_rtc_reserved_end+0x9fe1ffff>)
40378767:	10aab0        	and	a10, a10, a11
4037876a:	f08ab1        	l32r	a11, 40374994 <_iram_text_start+0x590> (60000 <UserFrameTotalSize+0x5ff00>)
4037876d:	20aab0        	or	a10, a10, a11
40378770:	0020c0        	memw
40378773:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DRES_XTAL_32K, cfg.dres);
40378775:	0020c0        	memw
40378778:	09a8      	l32i.n	a10, a9, 0
4037877a:	f087b1        	l32r	a11, 40374998 <_iram_text_start+0x594> (ffff1fff <_rtc_reserved_end+0x9fef1fff>)
4037877d:	10aab0        	and	a10, a10, a11
40378780:	24b680        	extui	a11, a8, 6, 3
40378783:	11bb30        	slli	a11, a11, 13
40378786:	20aab0        	or	a10, a10, a11
40378789:	0020c0        	memw
4037878c:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DGM_XTAL_32K, cfg.dgm);
4037878e:	0020c0        	memw
40378791:	09a8      	l32i.n	a10, a9, 0
40378793:	f082b1        	l32r	a11, 4037499c <_iram_text_start+0x598> (ffffe3ff <_rtc_reserved_end+0x9fefe3ff>)
40378796:	10aab0        	and	a10, a10, a11
40378799:	24b980        	extui	a11, a8, 9, 3
4037879c:	11bb60        	slli	a11, a11, 10
4037879f:	20aab0        	or	a10, a10, a11
403787a2:	0020c0        	memw
403787a5:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DBUF_XTAL_32K, cfg.dbuf);
403787a7:	0020c0        	memw
403787aa:	09a8      	l32i.n	a10, a9, 0
403787ac:	ffadb2        	movi	a11, 0xfffffdff
403787af:	10aab0        	and	a10, a10, a11
403787b2:	048c80        	extui	a8, a8, 12, 1
403787b5:	118870        	slli	a8, a8, 9
403787b8:	208a80        	or	a8, a10, a8
403787bb:	0020c0        	memw
403787be:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
403787c0:	0020c0        	memw
403787c3:	0988      	l32i.n	a8, a9, 0
403787c5:	f02fa1        	l32r	a10, 40374884 <_iram_text_start+0x480> (10000 <UserFrameTotalSize+0xff00>)
403787c8:	2088a0        	or	a8, a8, a10
403787cb:	0020c0        	memw
403787ce:	0989      	s32i.n	a8, a9, 0
403787d0:	0008c6        	j	403787f7 <rtc_clk_32k_enable+0xeb>
403787d3:	6d8100        	lsi	f0, a1, 0x1b4
    SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_XPD_FORCE);
403787d6:	20c0f0        	or	a12, a0, a15
403787d9:	089800        	lsx	f9, a8, a0
403787dc:	80a0a2        	movi	a10, 128
403787df:	2099a0        	or	a9, a9, a10
403787e2:	0020c0        	memw
403787e5:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
403787e7:	0020c0        	memw
403787ea:	0898      	l32i.n	a9, a8, 0
403787ec:	f06da1        	l32r	a10, 403749a0 <_iram_text_start+0x59c> (fffeffff <_rtc_reserved_end+0x9feeffff>)
403787ef:	1099a0        	and	a9, a9, a10
403787f2:	0020c0        	memw
403787f5:	0899      	s32i.n	a9, a8, 0
}
403787f7:	f01d      	retw.n
403787f9:	000000        	ill

403787fc <rtc_clk_32k_enable_external>:
{
403787fc:	004136        	entry	a1, 32
    PIN_INPUT_ENABLE(IO_MUX_GPIO15_REG);
403787ff:	f06991        	l32r	a9, 403749a4 <_iram_text_start+0x5a0> (60009040 <SENS+0x840>)
40378802:	0020c0        	memw
40378805:	0988      	l32i.n	a8, a9, 0
40378807:	00a2a2        	movi	a10, 0x200
4037880a:	2088a0        	or	a8, a8, a10
4037880d:	0020c0        	memw
40378810:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(SENS_SAR_PERI_CLK_GATE_CONF_REG, SENS_IOMUX_CLK_EN);
40378812:	f06591        	l32r	a9, 403749a8 <_iram_text_start+0x5a4> (60008904 <SENS+0x104>)
40378815:	0020c0        	memw
40378818:	0988      	l32i.n	a8, a9, 0
4037881a:	ef40a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037881d:	2088a0        	or	a8, a8, a10
40378820:	0020c0        	memw
40378823:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, RTC_CNTL_X32P_HOLD);
40378825:	f06191        	l32r	a9, 403749ac <_iram_text_start+0x5a8> (600080d8 <RTCCNTL+0xd8>)
40378828:	0020c0        	memw
4037882b:	0988      	l32i.n	a8, a9, 0
4037882d:	ef09a1        	l32r	a10, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
40378830:	2088a0        	or	a8, a8, a10
40378833:	0020c0        	memw
40378836:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_GPIO_SEL);
40378838:	f05491        	l32r	a9, 40374988 <_iram_text_start+0x584> (60008060 <RTCCNTL+0x60>)
4037883b:	0020c0        	memw
4037883e:	0988      	l32i.n	a8, a9, 0
40378840:	f05ca1        	l32r	a10, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
40378843:	2088a0        	or	a8, a8, a10
40378846:	0020c0        	memw
40378849:	0989      	s32i.n	a8, a9, 0
}
4037884b:	f01d      	retw.n
4037884d:	000000        	ill

40378850 <rtc_clk_8m_enable>:
{
40378850:	004136        	entry	a1, 32
40378853:	742020        	extui	a2, a2, 0, 8
40378856:	743030        	extui	a3, a3, 0, 8
    if (clk_8m_en) {
40378859:	72bc      	beqz.n	a2, 40378894 <rtc_clk_8m_enable+0x44>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
4037885b:	f05691        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
4037885e:	0020c0        	memw
40378861:	0988      	l32i.n	a8, a9, 0
40378863:	bfafa2        	movi	a10, -65
40378866:	1088a0        	and	a8, a8, a10
40378869:	0020c0        	memw
4037886c:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, CLK_LL_RC_FAST_ENABLE_WAIT_DEFAULT);
4037886e:	f05291        	l32r	a9, 403749b8 <_iram_text_start+0x5b4> (6000801c <RTCCNTL+0x1c>)
40378871:	0020c0        	memw
40378874:	0988      	l32i.n	a8, a9, 0
40378876:	f051a1        	l32r	a10, 403749bc <_iram_text_start+0x5b8> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
40378879:	1088a0        	and	a8, a8, a10
4037887c:	40a1a2        	movi	a10, 0x140
4037887f:	2088a0        	or	a8, a8, a10
40378882:	0020c0        	memw
40378885:	0989      	s32i.n	a8, a9, 0
        esp_rom_delay_us(SOC_DELAY_RC_FAST_ENABLE);
40378887:	32a0a2        	movi	a10, 50
4037888a:	eeea81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
4037888d:	0008e0        	callx8	a8
40378890:	000ac6        	j	403788bf <rtc_clk_8m_enable+0x6f>
40378893:	489100        	ssx	f9, a1, a0
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
40378896:	20c0f0        	or	a12, a0, a15
40378899:	098800        	l32e	a0, a8, -32
4037889c:	0a4c      	movi.n	a10, 64
4037889e:	2088a0        	or	a8, a8, a10
403788a1:	0020c0        	memw
403788a4:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, CLK_LL_RC_FAST_WAIT_DEFAULT);
403788a6:	f04491        	l32r	a9, 403749b8 <_iram_text_start+0x5b4> (6000801c <RTCCNTL+0x1c>)
403788a9:	0020c0        	memw
403788ac:	0988      	l32i.n	a8, a9, 0
403788ae:	f043a1        	l32r	a10, 403749bc <_iram_text_start+0x5b8> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
403788b1:	1088a0        	and	a8, a8, a10
403788b4:	00a5a2        	movi	a10, 0x500
403788b7:	2088a0        	or	a8, a8, a10
403788ba:	0020c0        	memw
403788bd:	0989      	s32i.n	a8, a9, 0
    if (d256_en) {
403788bf:	539c      	beqz.n	a3, 403788d8 <rtc_clk_8m_enable+0x88>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
403788c1:	f03c91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403788c4:	0020c0        	memw
403788c7:	0988      	l32i.n	a8, a9, 0
403788c9:	7fafa2        	movi	a10, -129
403788cc:	1088a0        	and	a8, a8, a10
403788cf:	0020c0        	memw
403788d2:	0989      	s32i.n	a8, a9, 0
}
403788d4:	0004c6        	j	403788eb <rtc_clk_8m_enable+0x9b>
403788d7:	379100        	lsi	f0, a1, 220
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
403788da:	20c0f0        	or	a12, a0, a15
403788dd:	098800        	l32e	a0, a8, -32
403788e0:	80a0a2        	movi	a10, 128
403788e3:	2088a0        	or	a8, a8, a10
403788e6:	0020c0        	memw
403788e9:	0989      	s32i.n	a8, a9, 0
}
403788eb:	f01d      	retw.n
403788ed:	000000        	ill

403788f0 <rtc_clk_8md256_enabled>:
{
403788f0:	004136        	entry	a1, 32
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
403788f3:	f03081        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403788f6:	0020c0        	memw
403788f9:	0828      	l32i.n	a2, a8, 0
403788fb:	80a082        	movi	a8, 128
403788fe:	102280        	and	a2, a2, a8
}
40378901:	40f220        	nsau	a2, a2
40378904:	412520        	srli	a2, a2, 5
40378907:	f01d      	retw.n
40378909:	000000        	ill

4037890c <rtc_clk_slow_src_set>:
{
4037890c:	004136        	entry	a1, 32
 *
 * @return Currently selected clock source (one of soc_rtc_slow_clk_src_t values)
 */
static inline __attribute__((always_inline)) soc_rtc_slow_clk_src_t clk_ll_rtc_slow_get_src(void)
{
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
4037890f:	f02981        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378912:	0020c0        	memw
40378915:	0888      	l32i.n	a8, a8, 0
40378917:	158e80        	extui	a8, a8, 30, 2
    switch (clk_sel) {
4037891a:	131826        	beqi	a8, 1, 40378931 <rtc_clk_slow_src_set+0x25>
4037891d:	102826        	beqi	a8, 2, 40378931 <rtc_clk_slow_src_set+0x25>
40378920:	d88c      	beqz.n	a8, 40378931 <rtc_clk_slow_src_set+0x25>
        return SOC_RTC_SLOW_CLK_SRC_XTAL32K;
    case 2:
        return SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256;
    default:
        // Invalid ANA_CLK_RTC_SEL value
        HAL_ASSERT(false);
40378922:	f027d1        	l32r	a13, 403749c0 <_iram_text_start+0x5bc> (3fc9382c <__FUNCTION__$0+0x94>)
40378925:	f027c1        	l32r	a12, 403749c4 <_iram_text_start+0x5c0> (3fc93780 <__func__$0>)
40378928:	1aa2b2        	movi	a11, 0x21a
4037892b:	f027a1        	l32r	a10, 403749c8 <_iram_text_start+0x5c4> (3fc938c4 <__FUNCTION__$0+0x12c>)
4037892e:	074225        	call8	4037fd50 <__assert_func>
    if (clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256 && clk_src_before_switch != SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {       // Switch to RC_FAST_D256
40378931:	fec292        	addi	a9, a2, -2
40378934:	40f990        	nsau	a9, a9
40378937:	419590        	srli	a9, a9, 5
4037893a:	fec8b2        	addi	a11, a8, -2
4037893d:	1a0c      	movi.n	a10, 1
4037893f:	83abb0        	moveqz	a10, a11, a11
40378942:	0d09a7        	bnone	a9, a10, 40378953 <rtc_clk_slow_src_set+0x47>
        esp_sleep_sub_mode_config(ESP_SLEEP_RTC_USE_RC_FAST_MODE, true);
40378945:	1b0c      	movi.n	a11, 1
40378947:	00a0a2        	movi	a10, 0
4037894a:	f02081        	l32r	a8, 403749cc <_iram_text_start+0x5c8> (42005984 <esp_sleep_sub_mode_config>)
4037894d:	0008e0        	callx8	a8
40378950:	000746        	j	40378971 <rtc_clk_slow_src_set+0x65>
    } else if (clk_src != SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256 && clk_src_before_switch == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) { // Switch away from RC_FAST_D256
40378953:	fec2a2        	addi	a10, a2, -2
40378956:	190c      	movi.n	a9, 1
40378958:	839aa0        	moveqz	a9, a10, a10
4037895b:	fec882        	addi	a8, a8, -2
4037895e:	40f880        	nsau	a8, a8
40378961:	418580        	srli	a8, a8, 5
40378964:	090987        	bnone	a9, a8, 40378971 <rtc_clk_slow_src_set+0x65>
        esp_sleep_sub_mode_config(ESP_SLEEP_RTC_USE_RC_FAST_MODE, false);
40378967:	0b0c      	movi.n	a11, 0
40378969:	0bad      	mov.n	a10, a11
4037896b:	f01881        	l32r	a8, 403749cc <_iram_text_start+0x5c8> (42005984 <esp_sleep_sub_mode_config>)
4037896e:	0008e0        	callx8	a8
    switch (in_sel) {
40378971:	1b1226        	beqi	a2, 1, 40378990 <rtc_clk_slow_src_set+0x84>
40378974:	342226        	beqi	a2, 2, 403789ac <rtc_clk_slow_src_set+0xa0>
40378977:	04d256        	bnez	a2, 403789c8 <rtc_clk_slow_src_set+0xbc>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 0);
4037897a:	f00e91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
4037897d:	0020c0        	memw
40378980:	0988      	l32i.n	a8, a9, 0
40378982:	1188e0        	slli	a8, a8, 2
40378985:	418280        	srli	a8, a8, 2
40378988:	0020c0        	memw
4037898b:	0989      	s32i.n	a8, a9, 0
        break;
4037898d:	000e86        	j	403789cb <rtc_clk_slow_src_set+0xbf>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 1);
40378990:	f00991        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378993:	0020c0        	memw
40378996:	0988      	l32i.n	a8, a9, 0
40378998:	1188e0        	slli	a8, a8, 2
4037899b:	418280        	srli	a8, a8, 2
4037899e:	ef15a1        	l32r	a10, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
403789a1:	2088a0        	or	a8, a8, a10
403789a4:	0020c0        	memw
403789a7:	0989      	s32i.n	a8, a9, 0
        break;
403789a9:	000786        	j	403789cb <rtc_clk_slow_src_set+0xbf>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 2);
403789ac:	f00291        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403789af:	0020c0        	memw
403789b2:	0988      	l32i.n	a8, a9, 0
403789b4:	1188e0        	slli	a8, a8, 2
403789b7:	418280        	srli	a8, a8, 2
403789ba:	eed8a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403789bd:	2088a0        	or	a8, a8, a10
403789c0:	0020c0        	memw
403789c3:	0989      	s32i.n	a8, a9, 0
        break;
403789c5:	000086        	j	403789cb <rtc_clk_slow_src_set+0xbf>
        abort();
403789c8:	072ca5        	call8	4037fc94 <abort>
    if (clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
403789cb:	151266        	bnei	a2, 1, 403789e4 <rtc_clk_slow_src_set+0xd8>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
403789ce:	eff991        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403789d1:	0020c0        	memw
403789d4:	0988      	l32i.n	a8, a9, 0
403789d6:	00a1a2        	movi	a10, 0x100
403789d9:	2088a0        	or	a8, a8, a10
403789dc:	0020c0        	memw
403789df:	0989      	s32i.n	a8, a9, 0
}
403789e1:	000486        	j	403789f7 <rtc_clk_slow_src_set+0xeb>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
403789e4:	eff491        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403789e7:	0020c0        	memw
403789ea:	0988      	l32i.n	a8, a9, 0
403789ec:	ffaea2        	movi	a10, 0xfffffeff
403789ef:	1088a0        	and	a8, a8, a10
403789f2:	0020c0        	memw
403789f5:	0989      	s32i.n	a8, a9, 0
    esp_rom_delay_us(SOC_DELAY_RTC_SLOW_CLK_SWITCH);
403789f7:	2ca1a2        	movi	a10, 0x12c
403789fa:	ee8e81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
403789fd:	0008e0        	callx8	a8
}
40378a00:	f01d      	retw.n
	...

40378a04 <rtc_clk_slow_src_get>:
{
40378a04:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
40378a07:	efeb81        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378a0a:	0020c0        	memw
40378a0d:	002822        	l32i	a2, a8, 0
40378a10:	152e20        	extui	a2, a2, 30, 2
    switch (clk_sel) {
40378a13:	141226        	beqi	a2, 1, 40378a2b <rtc_clk_slow_src_get+0x27>
40378a16:	112226        	beqi	a2, 2, 40378a2b <rtc_clk_slow_src_get+0x27>
40378a19:	00e216        	beqz	a2, 40378a2b <rtc_clk_slow_src_get+0x27>
        HAL_ASSERT(false);
40378a1c:	efe9d1        	l32r	a13, 403749c0 <_iram_text_start+0x5bc> (3fc9382c <__FUNCTION__$0+0x94>)
40378a1f:	efe9c1        	l32r	a12, 403749c4 <_iram_text_start+0x5c0> (3fc93780 <__func__$0>)
40378a22:	1aa2b2        	movi	a11, 0x21a
40378a25:	efe8a1        	l32r	a10, 403749c8 <_iram_text_start+0x5c4> (3fc938c4 <__FUNCTION__$0+0x12c>)
40378a28:	073265        	call8	4037fd50 <__assert_func>
}
40378a2b:	000090        	retw
	...

40378a30 <rtc_clk_slow_freq_get_hz>:
{
40378a30:	004136        	entry	a1, 32
    switch (rtc_clk_slow_src_get()) {
40378a33:	fffd25        	call8	40378a04 <rtc_clk_slow_src_get>
40378a36:	0a1a26        	beqi	a10, 1, 40378a44 <rtc_clk_slow_freq_get_hz+0x14>
40378a39:	0f2a26        	beqi	a10, 2, 40378a4c <rtc_clk_slow_freq_get_hz+0x1c>
40378a3c:	2adc      	bnez.n	a10, 40378a52 <rtc_clk_slow_freq_get_hz+0x22>
40378a3e:	efe421        	l32r	a2, 403749d0 <_iram_text_start+0x5cc> (21340 <UserFrameTotalSize+0x21240>)
40378a41:	0003c6        	j	40378a54 <rtc_clk_slow_freq_get_hz+0x24>
    case SOC_RTC_SLOW_CLK_SRC_XTAL32K: return SOC_CLK_XTAL32K_FREQ_APPROX;
40378a44:	ee8421        	l32r	a2, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
40378a47:	000246        	j	40378a54 <rtc_clk_slow_freq_get_hz+0x24>
40378a4a:	210000        	srai	a0, a0, 0
    case SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256: return SOC_CLK_RC_FAST_D256_FREQ_APPROX;
40378a4d:	46efe2        	s32c1i	a14, a15, 0x118
40378a50:	0c0000        	lsi	f0, a0, 48
    default: return 0;
40378a53:	f01d02        	l16ui	a0, a13, 0x1e0
	...

40378a58 <rtc_clk_fast_src_set>:
{
40378a58:	004136        	entry	a1, 32
 *
 * @param in_sel One of the clock sources in soc_rtc_fast_clk_src_t
 */
static inline __attribute__((always_inline)) void clk_ll_rtc_fast_set_src(soc_rtc_fast_clk_src_t in_sel)
{
    switch (in_sel) {
40378a5b:	428c      	beqz.n	a2, 40378a63 <rtc_clk_fast_src_set+0xb>
40378a5d:	181226        	beqi	a2, 1, 40378a79 <rtc_clk_fast_src_set+0x21>
40378a60:	000ac6        	j	40378a8f <rtc_clk_fast_src_set+0x37>
    case SOC_RTC_FAST_CLK_SRC_XTAL_D2:
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 0);
40378a63:	efd491        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378a66:	0020c0        	memw
40378a69:	0988      	l32i.n	a8, a9, 0
40378a6b:	ef62a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
40378a6e:	1088a0        	and	a8, a8, a10
40378a71:	0020c0        	memw
40378a74:	0989      	s32i.n	a8, a9, 0
        break;
40378a76:	000606        	j	40378a92 <rtc_clk_fast_src_set+0x3a>
    case SOC_RTC_FAST_CLK_SRC_RC_FAST:
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 1);
40378a79:	efce91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40378a7c:	0020c0        	memw
40378a7f:	0988      	l32i.n	a8, a9, 0
40378a81:	efd5a1        	l32r	a10, 403749d8 <_iram_text_start+0x5d4> (20000000 <UserFrameTotalSize+0x1fffff00>)
40378a84:	2088a0        	or	a8, a8, a10
40378a87:	0020c0        	memw
40378a8a:	0989      	s32i.n	a8, a9, 0
        break;
40378a8c:	000086        	j	40378a92 <rtc_clk_fast_src_set+0x3a>
    default:
        // Unsupported RTC_FAST_CLK mux input sel
        abort();
40378a8f:	072065        	call8	4037fc94 <abort>
    esp_rom_delay_us(SOC_DELAY_RTC_FAST_CLK_SWITCH);
40378a92:	3a0c      	movi.n	a10, 3
40378a94:	ee6881        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378a97:	0008e0        	callx8	a8
}
40378a9a:	f01d      	retw.n

40378a9c <rtc_clk_xtal_freq_get>:
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
}

soc_xtal_freq_t rtc_clk_xtal_freq_get(void)
{
40378a9c:	004136        	entry	a1, 32
 * @return XTAL frequency, in MHz. Returns 0 if value in reg is invalid.
 */
static inline __attribute__((always_inline)) uint32_t clk_ll_xtal_load_freq_mhz(void)
{
    // Read from the RTC storage register
    uint32_t xtal_freq_reg = READ_PERI_REG(RTC_XTAL_FREQ_REG);
40378a9f:	efcf81        	l32r	a8, 403749dc <_iram_text_start+0x5d8> (600080c0 <RTCCNTL+0xc0>)
40378aa2:	0020c0        	memw
40378aa5:	0828      	l32i.n	a2, a8, 0
    if ((xtal_freq_reg & 0xFFFF) == ((xtal_freq_reg >> 16) & 0xFFFF) &&
40378aa7:	f49020        	extui	a9, a2, 0, 16
40378aaa:	f58020        	extui	a8, a2, 16, 16
40378aad:	0e9987        	bne	a9, a8, 40378abf <rtc_clk_xtal_freq_get+0x23>
        xtal_freq_reg != 0 && xtal_freq_reg != UINT32_MAX) {
40378ab0:	820b      	addi.n	a8, a2, -1
40378ab2:	d97c      	movi.n	a9, -3
40378ab4:	073987        	bltu	a9, a8, 40378abf <rtc_clk_xtal_freq_get+0x23>
        return xtal_freq_reg & ~RTC_DISABLE_ROM_LOG & UINT16_MAX;
40378ab7:	e42120        	extui	a2, a2, 1, 15
40378aba:	222a      	add.n	a2, a2, a2
    uint32_t xtal_freq_mhz = clk_ll_xtal_load_freq_mhz();
    if (xtal_freq_mhz == 0) {
40378abc:	01a256        	bnez	a2, 40378ada <rtc_clk_xtal_freq_get+0x3e>
40378abf:	ee6b81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40378ac2:	0888      	l32i.n	a8, a8, 0
        ESP_HW_LOGW(TAG, "invalid RTC_XTAL_FREQ_REG value, assume 40MHz");
40378ac4:	1028b6        	bltui	a8, 2, 40378ad8 <rtc_clk_xtal_freq_get+0x3c>
40378ac7:	0711a5        	call8	4037fbe0 <esp_log_timestamp>
40378aca:	efc5c1        	l32r	a12, 403749e0 <_iram_text_start+0x5dc> (3fc938fc <__FUNCTION__$0+0x164>)
40378acd:	0abd      	mov.n	a11, a10
40378acf:	efc5a1        	l32r	a10, 403749e4 <_iram_text_start+0x5e0> (3fc93904 <__FUNCTION__$0+0x16c>)
40378ad2:	ee7881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40378ad5:	0008e0        	callx8	a8
        return SOC_XTAL_FREQ_40M;
40378ad8:	822c      	movi.n	a2, 40
    }
    return (soc_xtal_freq_t)xtal_freq_mhz;
}
40378ada:	f01d      	retw.n

40378adc <rtc_clk_cpu_freq_mhz_to_config>:
{
40378adc:	004136        	entry	a1, 32
    uint32_t xtal_freq = (uint32_t)rtc_clk_xtal_freq_get();
40378adf:	fffbe5        	call8	40378a9c <rtc_clk_xtal_freq_get>
    if (freq_mhz <= xtal_freq && freq_mhz != 0) {
40378ae2:	ffc282        	addi	a8, a2, -1
40378ae5:	17b8a7        	bgeu	a8, a10, 40378b00 <rtc_clk_cpu_freq_mhz_to_config+0x24>
        divider = xtal_freq / freq_mhz;
40378ae8:	c29a20        	quou	a9, a10, a2
        real_freq_mhz = (xtal_freq + divider / 2) / divider; /* round */
40378aeb:	418190        	srli	a8, a9, 1
40378aee:	8088a0        	add	a8, a8, a10
40378af1:	c28890        	quou	a8, a8, a9
        if (real_freq_mhz != freq_mhz) {
40378af4:	429287        	bne	a2, a8, 40378b3a <rtc_clk_cpu_freq_mhz_to_config+0x5e>
        real_freq_mhz = (xtal_freq + divider / 2) / divider; /* round */
40378af7:	202880        	or	a2, a8, a8
        source = SOC_CPU_CLK_SRC_XTAL;
40378afa:	080c      	movi.n	a8, 0
40378afc:	000b46        	j	40378b2d <rtc_clk_cpu_freq_mhz_to_config+0x51>
40378aff:	085c00        	lsx	f5, a12, a0
    } else if (freq_mhz == 80) {
40378b02:	161287        	beq	a2, a8, 40378b1c <rtc_clk_cpu_freq_mhz_to_config+0x40>
    } else if (freq_mhz == 160) {
40378b05:	a0a082        	movi	a8, 160
40378b08:	1a1287        	beq	a2, a8, 40378b26 <rtc_clk_cpu_freq_mhz_to_config+0x4a>
    } else if (freq_mhz == 240) {
40378b0b:	f0a082        	movi	a8, 240
40378b0e:	2e9287        	bne	a2, a8, 40378b40 <rtc_clk_cpu_freq_mhz_to_config+0x64>
        divider = 2;
40378b11:	290c      	movi.n	a9, 2
        source = SOC_CPU_CLK_SRC_PLL;
40378b13:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
40378b15:	e0a1a2        	movi	a10, 0x1e0
40378b18:	000446        	j	40378b2d <rtc_clk_cpu_freq_mhz_to_config+0x51>
40378b1b:	690c00        	lsi	f0, a12, 0x1a4
        source = SOC_CPU_CLK_SRC_PLL;
40378b1e:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
40378b20:	e0a1a2        	movi	a10, 0x1e0
40378b23:	000186        	j	40378b2d <rtc_clk_cpu_freq_mhz_to_config+0x51>
        divider = 3;
40378b26:	390c      	movi.n	a9, 3
        source = SOC_CPU_CLK_SRC_PLL;
40378b28:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
40378b2a:	e0a1a2        	movi	a10, 0x1e0
    *out_config = (rtc_cpu_freq_config_t) {
40378b2d:	0389      	s32i.n	a8, a3, 0
40378b2f:	13a9      	s32i.n	a10, a3, 4
40378b31:	2399      	s32i.n	a9, a3, 8
40378b33:	3329      	s32i.n	a2, a3, 12
    return true;
40378b35:	120c      	movi.n	a2, 1
40378b37:	0001c6        	j	40378b42 <rtc_clk_cpu_freq_mhz_to_config+0x66>
            return false;
40378b3a:	020c      	movi.n	a2, 0
40378b3c:	000086        	j	40378b42 <rtc_clk_cpu_freq_mhz_to_config+0x66>
40378b3f:	020c00        	andb	b0, b12, b0
}
40378b42:	f01d      	retw.n

40378b44 <rtc_clk_cpu_freq_get_config>:
{
40378b44:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
40378b47:	efa881        	l32r	a8, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378b4a:	0020c0        	memw
40378b4d:	002872        	l32i	a7, a8, 0
40378b50:	147a70        	extui	a7, a7, 10, 2
    switch (clk_sel) {
40378b53:	291726        	beqi	a7, 1, 40378b80 <rtc_clk_cpu_freq_get_config+0x3c>
40378b56:	022766        	bnei	a7, 2, 40378b5c <rtc_clk_cpu_freq_get_config+0x18>
40378b59:	003586        	j	40378c33 <rtc_clk_cpu_freq_get_config+0xef>
40378b5c:	014756        	bnez	a7, 40378b74 <rtc_clk_cpu_freq_get_config+0x30>
    return REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT) + 1;
40378b5f:	0020c0        	memw
40378b62:	002862        	l32i	a6, a8, 0
40378b65:	946060        	extui	a6, a6, 0, 10
40378b68:	661b      	addi.n	a6, a6, 1
        source_freq_mhz = (uint32_t)rtc_clk_xtal_freq_get();
40378b6a:	fff325        	call8	40378a9c <rtc_clk_xtal_freq_get>
        freq_mhz = source_freq_mhz / div;
40378b6d:	c2ba60        	quou	a11, a10, a6
    break;
40378b70:	003506        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
40378b73:	3e8100        	f64norm	a8, a1, a0, 1
40378b76:	ee          	.byte	0xee
40378b77:	0888      	l32i.n	a8, a8, 0
        ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378b79:	0d3816        	beqz	a8, 40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
40378b7c:	0027c6        	j	40378c1f <rtc_clk_cpu_freq_get_config+0xdb>
40378b7f:	7c8100        	lsi	f0, a1, 0x1f0
    uint32_t cpu_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL);
40378b82:	ef          	.byte	0xef
40378b83:	0020c0        	memw
40378b86:	0888      	l32i.n	a8, a8, 0
40378b88:	148080        	extui	a8, a8, 0, 2
    switch (cpu_freq_sel) {
40378b8b:	091826        	beqi	a8, 1, 40378b98 <rtc_clk_cpu_freq_get_config+0x54>
40378b8e:	0e2826        	beqi	a8, 2, 40378ba0 <rtc_clk_cpu_freq_get_config+0x5c>
40378b91:	18dc      	bnez.n	a8, 40378ba6 <rtc_clk_cpu_freq_get_config+0x62>
40378b93:	0b5c      	movi.n	a11, 80
40378b95:	0003c6        	j	40378ba8 <rtc_clk_cpu_freq_get_config+0x64>
        return CLK_LL_PLL_160M_FREQ_MHZ;
40378b98:	a0a0b2        	movi	a11, 160
40378b9b:	000246        	j	40378ba8 <rtc_clk_cpu_freq_get_config+0x64>
40378b9e:	b20000        	mulsh	a0, a0, a0
        return CLK_LL_PLL_240M_FREQ_MHZ;
40378ba1:	46f0a0        	lsi	f10, a0, 0x118
40378ba4:	0c0000        	lsi	f0, a0, 48
        return 0;
40378ba7:	810b      	addi.n	a8, a1, -1
    uint32_t pll_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
40378ba9:	c0ef72        	s32c1i	a7, a15, 0x300
40378bac:	880020        	lsi	f2, a0, 0x220
40378baf:	8008      	l32i.n	a0, a0, 32
40378bb1:	270492        	l8ui	a9, a4, 39
    switch (pll_freq_sel) {
40378bb4:	0968      	l32i.n	a6, a9, 0
40378bb6:	0c1966        	bnei	a9, 1, 40378bc6 <rtc_clk_cpu_freq_get_config+0x82>
        return CLK_LL_PLL_480M_FREQ_MHZ;
40378bb9:	e0a1a2        	movi	a10, 0x1e0
40378bbc:	000206        	j	40378bc8 <rtc_clk_cpu_freq_get_config+0x84>
40378bbf:	a1a200        	sll	a10, a2
    switch (pll_freq_sel) {
40378bc2:	004640        	break	6, 4
40378bc5:	0a0c00        	add.s	f0, f12, f0
        if (freq_mhz == CLK_LL_PLL_80M_FREQ_MHZ) {
40378bc8:	085c      	movi.n	a8, 80
40378bca:	0a9b87        	bne	a11, a8, 40378bd8 <rtc_clk_cpu_freq_get_config+0x94>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
40378bcd:	e0a182        	movi	a8, 0x1e0
40378bd0:	689a87        	bne	a10, a8, 40378c3c <rtc_clk_cpu_freq_get_config+0xf8>
40378bd3:	660c      	movi.n	a6, 6
40378bd5:	001bc6        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
        } else if (freq_mhz == CLK_LL_PLL_160M_FREQ_MHZ) {
40378bd8:	a0a082        	movi	a8, 160
40378bdb:	0a9b87        	bne	a11, a8, 40378be9 <rtc_clk_cpu_freq_get_config+0xa5>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
40378bde:	e0a182        	movi	a8, 0x1e0
40378be1:	5c9a87        	bne	a10, a8, 40378c41 <rtc_clk_cpu_freq_get_config+0xfd>
40378be4:	360c      	movi.n	a6, 3
40378be6:	001786        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
        } else if (freq_mhz == CLK_LL_PLL_240M_FREQ_MHZ  && source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
40378be9:	10af92        	movi	a9, -240
40378bec:	9b9a      	add.n	a9, a11, a9
40378bee:	40f990        	nsau	a9, a9
40378bf1:	419590        	srli	a9, a9, 5
40378bf4:	20ae82        	movi	a8, 0xfffffe20
40378bf7:	8a8a      	add.n	a8, a10, a8
40378bf9:	40f880        	nsau	a8, a8
40378bfc:	418580        	srli	a8, a8, 5
40378bff:	438987        	bany	a9, a8, 40378c46 <rtc_clk_cpu_freq_get_config+0x102>
40378c02:	ee1a81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40378c05:	0888      	l32i.n	a8, a8, 0
            ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378c07:	045816        	beqz	a8, 40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
40378c0a:	06fd65        	call8	4037fbe0 <esp_log_timestamp>
40378c0d:	ef74c1        	l32r	a12, 403749e0 <_iram_text_start+0x5dc> (3fc938fc <__FUNCTION__$0+0x164>)
40378c10:	20baa0        	or	a11, a10, a10
40378c13:	ef76a1        	l32r	a10, 403749ec <_iram_text_start+0x5e8> (3fc93940 <__FUNCTION__$0+0x1a8>)
40378c16:	ee2781        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40378c19:	0008e0        	callx8	a8
            return;
40378c1c:	000c06        	j	40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
        ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378c1f:	06fc25        	call8	4037fbe0 <esp_log_timestamp>
40378c22:	ef6fc1        	l32r	a12, 403749e0 <_iram_text_start+0x5dc> (3fc938fc <__FUNCTION__$0+0x164>)
40378c25:	0abd      	mov.n	a11, a10
40378c27:	ef71a1        	l32r	a10, 403749ec <_iram_text_start+0x5e8> (3fc93940 <__FUNCTION__$0+0x1a8>)
40378c2a:	ee2281        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40378c2d:	0008e0        	callx8	a8
40378c30:	000706        	j	40378c50 <rtc_clk_cpu_freq_get_config+0x10c>
    switch (clk_sel) {
40378c33:	4b1c      	movi.n	a11, 20
40378c35:	160c      	movi.n	a6, 1
40378c37:	0bad      	mov.n	a10, a11
40378c39:	0002c6        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
40378c3c:	460c      	movi.n	a6, 4
40378c3e:	000186        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
40378c41:	260c      	movi.n	a6, 2
40378c43:	000046        	j	40378c48 <rtc_clk_cpu_freq_get_config+0x104>
            div = 2;
40378c46:	260c      	movi.n	a6, 2
    *out_config = (rtc_cpu_freq_config_t) {
40378c48:	0279      	s32i.n	a7, a2, 0
40378c4a:	12a9      	s32i.n	a10, a2, 4
40378c4c:	2269      	s32i.n	a6, a2, 8
40378c4e:	32b9      	s32i.n	a11, a2, 12
}
40378c50:	f01d      	retw.n
	...

40378c54 <rtc_clk_apb_freq_update>:
{
    clk_ll_xtal_store_freq_mhz(xtal_freq);
}

void rtc_clk_apb_freq_update(uint32_t apb_freq)
{
40378c54:	004136        	entry	a1, 32
    s_apb_freq = apb_freq;
40378c57:	ef6681        	l32r	a8, 403749f0 <_iram_text_start+0x5ec> (3fc94b04 <s_apb_freq>)
40378c5a:	0829      	s32i.n	a2, a8, 0
}
40378c5c:	f01d      	retw.n
	...

40378c60 <rtc_clk_cpu_freq_to_pll_mhz>:
{
40378c60:	006136        	entry	a1, 48
    int pd_slave = cpu_freq_mhz / 80;
40378c63:	ef6471        	l32r	a7, 403749f4 <_iram_text_start+0x5f0> (66666667 <_rtc_reserved_end+0x6566667>)
40378c66:	b27270        	mulsh	a7, a2, a7
40378c69:	217570        	srai	a7, a7, 5
40378c6c:	318f20        	srai	a8, a2, 31
40378c6f:	c07780        	sub	a7, a7, a8
    rtc_clk_cpu_freq_get_config(&cur_config);
40378c72:	01ad      	mov.n	a10, a1
40378c74:	ffece5        	call8	40378b44 <rtc_clk_cpu_freq_get_config>
    if (cpu_freq_mhz > cur_config.freq_mhz) {
40378c77:	3188      	l32i.n	a8, a1, 12
40378c79:	026d      	mov.n	a6, a2
40378c7b:	5db827        	bgeu	a8, a2, 40378cdc <rtc_clk_cpu_freq_to_pll_mhz+0x7c>
        if (cpu_freq_mhz == 240) {
40378c7e:	f0a082        	movi	a8, 240
40378c81:	309287        	bne	a2, a8, 40378cb5 <rtc_clk_cpu_freq_to_pll_mhz+0x55>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_240m);
40378c84:	ef5d81        	l32r	a8, 403749f8 <_iram_text_start+0x5f4> (3fc91f70 <g_rtc_dbias_pvt_240m>)
40378c87:	0008f2        	l8ui	a15, a8, 0
40378c8a:	0e0c      	movi.n	a14, 0
40378c8c:	4d0c      	movi.n	a13, 4
40378c8e:	0dcd      	mov.n	a12, a13
40378c90:	1b0c      	movi.n	a11, 1
40378c92:	6da0a2        	movi	a10, 109
40378c95:	fdb965        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_240m);
40378c98:	ef5981        	l32r	a8, 403749fc <_iram_text_start+0x5f8> (3fc91f74 <g_dig_dbias_pvt_240m>)
40378c9b:	0008f2        	l8ui	a15, a8, 0
40378c9e:	0e0c      	movi.n	a14, 0
40378ca0:	4d0c      	movi.n	a13, 4
40378ca2:	6c0c      	movi.n	a12, 6
40378ca4:	01a0b2        	movi	a11, 1
40378ca7:	6da0a2        	movi	a10, 109
40378caa:	fdb825        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            esp_rom_delay_us(40);
40378cad:	8a2c      	movi.n	a10, 40
40378caf:	ede181        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378cb2:	0008e0        	callx8	a8
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
40378cb5:	ef52a1        	l32r	a10, 40374a00 <_iram_text_start+0x5fc> (600081fc <RTCCNTL+0x1fc>)
40378cb8:	0020c0        	memw
40378cbb:	0a88      	l32i.n	a8, a10, 0
40378cbd:	ef5191        	l32r	a9, 40374a04 <_iram_text_start+0x600> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378cc0:	109890        	and	a9, a8, a9
40378cc3:	780c      	movi.n	a8, 7
40378cc5:	400700        	ssr	a7
40378cc8:	b18080        	sra	a8, a8
40378ccb:	118830        	slli	a8, a8, 13
40378cce:	548d80        	extui	a8, a8, 13, 6
40378cd1:	118830        	slli	a8, a8, 13
40378cd4:	208980        	or	a8, a9, a8
40378cd7:	0020c0        	memw
40378cda:	0a89      	s32i.n	a8, a10, 0
    switch (cpu_mhz) {
40378cdc:	a0a082        	movi	a8, 160
40378cdf:	211287        	beq	a2, a8, 40378d04 <rtc_clk_cpu_freq_to_pll_mhz+0xa4>
40378ce2:	f0a082        	movi	a8, 240
40378ce5:	371287        	beq	a2, a8, 40378d20 <rtc_clk_cpu_freq_to_pll_mhz+0xc0>
40378ce8:	085c      	movi.n	a8, 80
40378cea:	4f9287        	bne	a2, a8, 40378d3d <rtc_clk_cpu_freq_to_pll_mhz+0xdd>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 0);
40378ced:	ef2091        	l32r	a9, 40374970 <_iram_text_start+0x56c> (600c0010 <SYSTEM+0x10>)
40378cf0:	0020c0        	memw
40378cf3:	0988      	l32i.n	a8, a9, 0
40378cf5:	ca7c      	movi.n	a10, -4
40378cf7:	1088a0        	and	a8, a8, a10
40378cfa:	0020c0        	memw
40378cfd:	0989      	s32i.n	a8, a9, 0
        break;
40378cff:	000f46        	j	40378d40 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378d02:	910000        	srl	a0, a0
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 1);
40378d05:	ef1b      	addi.n	a14, a15, 1
40378d07:	0020c0        	memw
40378d0a:	0988      	l32i.n	a8, a9, 0
40378d0c:	ca7c      	movi.n	a10, -4
40378d0e:	1088a0        	and	a8, a8, a10
40378d11:	1a0c      	movi.n	a10, 1
40378d13:	2088a0        	or	a8, a8, a10
40378d16:	0020c0        	memw
40378d19:	0989      	s32i.n	a8, a9, 0
        break;
40378d1b:	000846        	j	40378d40 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378d1e:	910000        	srl	a0, a0
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 2);
40378d21:	c0ef14        	lsi	f1, a15, 0x300
40378d24:	880020        	lsi	f2, a0, 0x220
40378d27:	7c09      	s32i.n	a0, a12, 28
40378d29:	a0ca      	add.n	a10, a0, a12
40378d2b:	1088      	l32i.n	a8, a0, 4
40378d2d:	2a0c      	movi.n	a10, 2
40378d2f:	2088a0        	or	a8, a8, a10
40378d32:	0020c0        	memw
40378d35:	0989      	s32i.n	a8, a9, 0
        break;
40378d37:	000146        	j	40378d40 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378d3a:	000000        	ill
        abort();
40378d3d:	06f565        	call8	4037fc94 <abort>
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378d40:	ef2a91        	l32r	a9, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378d43:	0020c0        	memw
40378d46:	0988      	l32i.n	a8, a9, 0
40378d48:	00aca2        	movi	a10, 0xfffffc00
40378d4b:	1088a0        	and	a8, a8, a10
40378d4e:	0020c0        	memw
40378d51:	0989      	s32i.n	a8, a9, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 1);
40378d53:	0020c0        	memw
40378d56:	0988      	l32i.n	a8, a9, 0
40378d58:	ef2ca1        	l32r	a10, 40374a08 <_iram_text_start+0x604> (fffff3ff <_rtc_reserved_end+0x9feff3ff>)
40378d5b:	1088a0        	and	a8, a8, a10
40378d5e:	00a4a2        	movi	a10, 0x400
40378d61:	2088a0        	or	a8, a8, a10
40378d64:	0020c0        	memw
40378d67:	006982        	s32i	a8, a9, 0
    rtc_clk_apb_freq_update(80 * MHZ);
40378d6a:	ef28a1        	l32r	a10, 40374a0c <_iram_text_start+0x608> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
40378d6d:	ffee65        	call8	40378c54 <rtc_clk_apb_freq_update>
    esp_rom_set_cpu_ticks_per_us(cpu_freq_mhz);
40378d70:	02ad      	mov.n	a10, a2
40378d72:	ef2981        	l32r	a8, 40374a18 <_iram_text_start+0x614> (40001a4c <esp_rom_set_cpu_ticks_per_us>)
40378d75:	0008e0        	callx8	a8
    if (cpu_freq_mhz < cur_config.freq_mhz) {
40378d78:	3188      	l32i.n	a8, a1, 12
40378d7a:	5eb687        	bgeu	a6, a8, 40378ddc <rtc_clk_cpu_freq_to_pll_mhz+0x17c>
        if (cur_config.freq_mhz == 240) {
40378d7d:	f0a092        	movi	a9, 240
40378d80:	319897        	bne	a8, a9, 40378db5 <rtc_clk_cpu_freq_to_pll_mhz+0x155>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378d83:	ef2381        	l32r	a8, 40374a10 <_iram_text_start+0x60c> (3fc91f68 <g_rtc_dbias_pvt_non_240m>)
40378d86:	0008f2        	l8ui	a15, a8, 0
40378d89:	0e0c      	movi.n	a14, 0
40378d8b:	4d0c      	movi.n	a13, 4
40378d8d:	0dcd      	mov.n	a12, a13
40378d8f:	01a0b2        	movi	a11, 1
40378d92:	6da0a2        	movi	a10, 109
40378d95:	fda965        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
40378d98:	ef1f81        	l32r	a8, 40374a14 <_iram_text_start+0x610> (3fc91f6c <g_dig_dbias_pvt_non_240m>)
40378d9b:	0008f2        	l8ui	a15, a8, 0
40378d9e:	0e0c      	movi.n	a14, 0
40378da0:	4d0c      	movi.n	a13, 4
40378da2:	6c0c      	movi.n	a12, 6
40378da4:	01a0b2        	movi	a11, 1
40378da7:	6da0a2        	movi	a10, 109
40378daa:	fda825        	call8	4037682c <regi2c_ctrl_write_reg_mask>
            esp_rom_delay_us(40);
40378dad:	8a2c      	movi.n	a10, 40
40378daf:	eda181        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378db2:	0008e0        	callx8	a8
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
40378db5:	ef12a1        	l32r	a10, 40374a00 <_iram_text_start+0x5fc> (600081fc <RTCCNTL+0x1fc>)
40378db8:	0020c0        	memw
40378dbb:	0a88      	l32i.n	a8, a10, 0
40378dbd:	ef1191        	l32r	a9, 40374a04 <_iram_text_start+0x600> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378dc0:	109890        	and	a9, a8, a9
40378dc3:	780c      	movi.n	a8, 7
40378dc5:	400700        	ssr	a7
40378dc8:	b18080        	sra	a8, a8
40378dcb:	118830        	slli	a8, a8, 13
40378dce:	548d80        	extui	a8, a8, 13, 6
40378dd1:	118830        	slli	a8, a8, 13
40378dd4:	208980        	or	a8, a9, a8
40378dd7:	0020c0        	memw
40378dda:	0a89      	s32i.n	a8, a10, 0
}
40378ddc:	f01d      	retw.n
	...

40378de0 <rtc_clk_cpu_freq_to_xtal>:
{
40378de0:	006136        	entry	a1, 48
    rtc_clk_cpu_freq_get_config(&cur_config);
40378de3:	01ad      	mov.n	a10, a1
40378de5:	ffd5e5        	call8	40378b44 <rtc_clk_cpu_freq_get_config>
    esp_rom_set_cpu_ticks_per_us(cpu_freq);
40378de8:	02ad      	mov.n	a10, a2
40378dea:	ef0b81        	l32r	a8, 40374a18 <_iram_text_start+0x614> (40001a4c <esp_rom_set_cpu_ticks_per_us>)
40378ded:	0008e0        	callx8	a8
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378df0:	eefe91        	l32r	a9, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378df3:	0020c0        	memw
40378df6:	0988      	l32i.n	a8, a9, 0
40378df8:	00aca2        	movi	a10, 0xfffffc00
40378dfb:	1088a0        	and	a8, a8, a10
40378dfe:	0020c0        	memw
40378e01:	0989      	s32i.n	a8, a9, 0
    HAL_ASSERT(divider > 0);
40378e03:	00e356        	bnez	a3, 40378e15 <rtc_clk_cpu_freq_to_xtal+0x35>
40378e06:	ef05d1        	l32r	a13, 40374a1c <_iram_text_start+0x618> (3fc93974 <__FUNCTION__$0+0x1dc>)
40378e09:	ef05c1        	l32r	a12, 40374a20 <_iram_text_start+0x61c> (3fc93768 <__func__$1>)
40378e0c:	e4a1b2        	movi	a11, 0x1e4
40378e0f:	eeeea1        	l32r	a10, 403749c8 <_iram_text_start+0x5c4> (3fc938c4 <__FUNCTION__$0+0x12c>)
40378e12:	06f3e5        	call8	4037fd50 <__assert_func>
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378e15:	eef491        	l32r	a9, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378e18:	0020c0        	memw
40378e1b:	002982        	l32i	a8, a9, 0
40378e1e:	00aca2        	movi	a10, 0xfffffc00
40378e21:	1088a0        	and	a8, a8, a10
40378e24:	330b      	addi.n	a3, a3, -1
40378e26:	943030        	extui	a3, a3, 0, 10
40378e29:	208830        	or	a8, a8, a3
40378e2c:	0020c0        	memw
40378e2f:	0989      	s32i.n	a8, a9, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 0);
40378e31:	0020c0        	memw
40378e34:	0988      	l32i.n	a8, a9, 0
40378e36:	eef4a1        	l32r	a10, 40374a08 <_iram_text_start+0x604> (fffff3ff <_rtc_reserved_end+0x9feff3ff>)
40378e39:	1088a0        	and	a8, a8, a10
40378e3c:	0020c0        	memw
40378e3f:	006982        	s32i	a8, a9, 0
    rtc_clk_apb_freq_update(cpu_freq * MHZ);
40378e42:	ee23a1        	l32r	a10, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40378e45:	82a2a0        	mull	a10, a2, a10
40378e48:	ffe0a5        	call8	40378c54 <rtc_clk_apb_freq_update>
    if (cur_config.freq_mhz == 240) {
40378e4b:	3198      	l32i.n	a9, a1, 12
40378e4d:	f0a082        	movi	a8, 240
40378e50:	309987        	bne	a9, a8, 40378e84 <rtc_clk_cpu_freq_to_xtal+0xa4>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378e53:	eeef81        	l32r	a8, 40374a10 <_iram_text_start+0x60c> (3fc91f68 <g_rtc_dbias_pvt_non_240m>)
40378e56:	0008f2        	l8ui	a15, a8, 0
40378e59:	0e0c      	movi.n	a14, 0
40378e5b:	4d0c      	movi.n	a13, 4
40378e5d:	0dcd      	mov.n	a12, a13
40378e5f:	01a0b2        	movi	a11, 1
40378e62:	6da0a2        	movi	a10, 109
40378e65:	fd9c65        	call8	4037682c <regi2c_ctrl_write_reg_mask>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
40378e68:	eeeb81        	l32r	a8, 40374a14 <_iram_text_start+0x610> (3fc91f6c <g_dig_dbias_pvt_non_240m>)
40378e6b:	0008f2        	l8ui	a15, a8, 0
40378e6e:	0e0c      	movi.n	a14, 0
40378e70:	4d0c      	movi.n	a13, 4
40378e72:	6c0c      	movi.n	a12, 6
40378e74:	1b0c      	movi.n	a11, 1
40378e76:	6da0a2        	movi	a10, 109
40378e79:	fd9b25        	call8	4037682c <regi2c_ctrl_write_reg_mask>
        esp_rom_delay_us(40);
40378e7c:	8a2c      	movi.n	a10, 40
40378e7e:	ed6d81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
40378e81:	0008e0        	callx8	a8
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
40378e84:	eedf91        	l32r	a9, 40374a00 <_iram_text_start+0x5fc> (600081fc <RTCCNTL+0x1fc>)
40378e87:	0020c0        	memw
40378e8a:	0988      	l32i.n	a8, a9, 0
40378e8c:	eedea1        	l32r	a10, 40374a04 <_iram_text_start+0x600> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378e8f:	1088a0        	and	a8, a8, a10
40378e92:	eee4a1        	l32r	a10, 40374a24 <_iram_text_start+0x620> (e000 <UserFrameTotalSize+0xdf00>)
40378e95:	2088a0        	or	a8, a8, a10
40378e98:	0020c0        	memw
40378e9b:	0989      	s32i.n	a8, a9, 0
}
40378e9d:	f01d      	retw.n
	...

40378ea0 <rtc_clk_cpu_freq_set_config>:
{
40378ea0:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
40378ea3:	eed181        	l32r	a8, 403749e8 <_iram_text_start+0x5e4> (600c0060 <SYSTEM+0x60>)
40378ea6:	0020c0        	memw
40378ea9:	002872        	l32i	a7, a8, 0
40378eac:	147a70        	extui	a7, a7, 10, 2
    switch (clk_sel) {
40378eaf:	081726        	beqi	a7, 1, 40378ebb <rtc_clk_cpu_freq_set_config+0x1b>
40378eb2:	052726        	beqi	a7, 2, 40378ebb <rtc_clk_cpu_freq_set_config+0x1b>
40378eb5:	002716        	beqz	a7, 40378ebb <rtc_clk_cpu_freq_set_config+0x1b>
        return SOC_CPU_CLK_SRC_INVALID;
40378eb8:	03a072        	movi	a7, 3
    if (config->source == SOC_CPU_CLK_SRC_XTAL) {
40378ebb:	002282        	l32i	a8, a2, 0
40378ebe:	68dc      	bnez.n	a8, 40378ed8 <rtc_clk_cpu_freq_set_config+0x38>
        rtc_clk_cpu_freq_to_xtal(config->freq_mhz, config->div);
40378ec0:	22b8      	l32i.n	a11, a2, 8
40378ec2:	32a8      	l32i.n	a10, a2, 12
40378ec4:	fff1a5        	call8	40378de0 <rtc_clk_cpu_freq_to_xtal>
        if ((old_cpu_clk_src == SOC_CPU_CLK_SRC_PLL) && !s_bbpll_digi_consumers_ref_count) {
40378ec7:	331766        	bnei	a7, 1, 40378efe <rtc_clk_cpu_freq_set_config+0x5e>
40378eca:	eeab81        	l32r	a8, 40374978 <_iram_text_start+0x574> (3fc94b00 <s_bbpll_digi_consumers_ref_count>)
40378ecd:	0888      	l32i.n	a8, a8, 0
40378ecf:	b8ec      	bnez.n	a8, 40378efe <rtc_clk_cpu_freq_set_config+0x5e>
            rtc_clk_bbpll_disable();
40378ed1:	ff6765        	call8	40378548 <rtc_clk_bbpll_disable>
40378ed4:	000986        	j	40378efe <rtc_clk_cpu_freq_set_config+0x5e>
40378ed7:	186600        	lsxp	f6, a6, a0
    } else if (config->source == SOC_CPU_CLK_SRC_PLL) {
40378eda:	2619      	s32i.n	a1, a6, 8
        if (old_cpu_clk_src != SOC_CPU_CLK_SRC_PLL) {
40378edc:	a50b17        	bnone	a11, a1, 40378e85 <rtc_clk_cpu_freq_to_xtal+0xa5>
            rtc_clk_bbpll_enable();
40378edf:	ff68      	l32i.n	a6, a15, 60
            rtc_clk_bbpll_configure(rtc_clk_xtal_freq_get(), config->source_freq_mhz);
40378ee1:	ffbba5        	call8	40378a9c <rtc_clk_xtal_freq_get>
40378ee4:	0122b2        	l32i	a11, a2, 4
40378ee7:	ff6ae5        	call8	40378594 <rtc_clk_bbpll_configure>
        rtc_clk_cpu_freq_to_pll_mhz(config->freq_mhz);
40378eea:	32a8      	l32i.n	a10, a2, 12
40378eec:	ffd725        	call8	40378c60 <rtc_clk_cpu_freq_to_pll_mhz>
40378eef:	0002c6        	j	40378efe <rtc_clk_cpu_freq_set_config+0x5e>
40378ef2:	000000        	ill
    } else if (config->source == SOC_CPU_CLK_SRC_RC_FAST) {
40378ef5:	052866        	bnei	a8, 2, 40378efe <rtc_clk_cpu_freq_set_config+0x5e>
        rtc_clk_cpu_freq_to_8m();
40378ef8:	201110        	or	a1, a1, a1
40378efb:	ff6865        	call8	40378580 <rtc_clk_cpu_freq_to_8m>
}
40378efe:	f01d      	retw.n

40378f00 <rtc_clk_cpu_set_to_default_config>:
{
40378f00:	004136        	entry	a1, 32
    int freq_mhz = (int)rtc_clk_xtal_freq_get();
40378f03:	ffb9a5        	call8	40378a9c <rtc_clk_xtal_freq_get>
    rtc_clk_cpu_freq_to_xtal(freq_mhz, 1);
40378f06:	01a0b2        	movi	a11, 1
40378f09:	ffed65        	call8	40378de0 <rtc_clk_cpu_freq_to_xtal>
}
40378f0c:	000090        	retw
	...

40378f10 <rtc_clk_cpu_freq_set_xtal>:
{
40378f10:	004136        	entry	a1, 32
    rtc_clk_cpu_set_to_default_config();
40378f13:	fffee5        	call8	40378f00 <rtc_clk_cpu_set_to_default_config>
    rtc_clk_bbpll_disable();
40378f16:	ff6325        	call8	40378548 <rtc_clk_bbpll_disable>
}
40378f19:	f01d      	retw.n
	...

40378f1c <rtc_sleep_pu>:
/**
 * Configure whether certain peripherals are powered up in sleep
 * @param cfg power down flags as rtc_sleep_pu_config_t structure
 */
void rtc_sleep_pu(rtc_sleep_pu_config_t cfg)
{
40378f1c:	004136        	entry	a1, 32
    REG_SET_FIELD(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_LSLP_MEM_FORCE_PU, cfg.dig_fpu);
40378f1f:	eec2b1        	l32r	a11, 40374a28 <_iram_text_start+0x624> (60008090 <RTCCNTL+0x90>)
40378f22:	0020c0        	memw
40378f25:	0b88      	l32i.n	a8, a11, 0
40378f27:	fa6c      	movi.n	a10, -17
40378f29:	1088a0        	and	a8, a8, a10
40378f2c:	049020        	extui	a9, a2, 0, 1
40378f2f:	1199c0        	slli	a9, a9, 4
40378f32:	208890        	or	a8, a8, a9
40378f35:	0020c0        	memw
40378f38:	0b89      	s32i.n	a8, a11, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_FASTMEM_FORCE_LPU, cfg.rtc_fpu);
40378f3a:	eebc91        	l32r	a9, 40374a2c <_iram_text_start+0x628> (60008088 <RTCCNTL+0x88>)
40378f3d:	0020c0        	memw
40378f40:	0988      	l32i.n	a8, a9, 0
40378f42:	ffaeb2        	movi	a11, 0xfffffeff
40378f45:	1088b0        	and	a8, a8, a11
40378f48:	04b120        	extui	a11, a2, 1, 1
40378f4b:	11bb80        	slli	a11, a11, 8
40378f4e:	2088b0        	or	a8, a8, a11
40378f51:	0020c0        	memw
40378f54:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_LPU, cfg.rtc_fpu);
40378f56:	0020c0        	memw
40378f59:	0988      	l32i.n	a8, a9, 0
40378f5b:	eeb5b1        	l32r	a11, 40374a30 <_iram_text_start+0x62c> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
40378f5e:	1088b0        	and	a8, a8, a11
40378f61:	04b120        	extui	a11, a2, 1, 1
40378f64:	11bb50        	slli	a11, a11, 11
40378f67:	2088b0        	or	a8, a8, a11
40378f6a:	0020c0        	memw
40378f6d:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_DC_MEM_FORCE_PU, cfg.fe_fpu);
40378f6f:	eeb181        	l32r	a8, 40374a34 <_iram_text_start+0x630> (6002609c <SYSCON+0x9c>)
40378f72:	0020c0        	memw
40378f75:	0898      	l32i.n	a9, a8, 0
40378f77:	1099a0        	and	a9, a9, a10
40378f7a:	04a620        	extui	a10, a2, 6, 1
40378f7d:	11aac0        	slli	a10, a10, 4
40378f80:	2099a0        	or	a9, a9, a10
40378f83:	0020c0        	memw
40378f86:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_PBUS_MEM_FORCE_PU, cfg.fe_fpu);
40378f88:	0020c0        	memw
40378f8b:	0898      	l32i.n	a9, a8, 0
40378f8d:	ba7c      	movi.n	a10, -5
40378f8f:	1099a0        	and	a9, a9, a10
40378f92:	04a620        	extui	a10, a2, 6, 1
40378f95:	11aae0        	slli	a10, a10, 2
40378f98:	2099a0        	or	a9, a9, a10
40378f9b:	0020c0        	memw
40378f9e:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_AGC_MEM_FORCE_PU, cfg.fe_fpu);
40378fa0:	0020c0        	memw
40378fa3:	0898      	l32i.n	a9, a8, 0
40378fa5:	ea7c      	movi.n	a10, -2
40378fa7:	1099a0        	and	a9, a9, a10
40378faa:	04a620        	extui	a10, a2, 6, 1
40378fad:	2099a0        	or	a9, a9, a10
40378fb0:	0020c0        	memw
40378fb3:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(BBPD_CTRL, BB_FFT_FORCE_PU, cfg.bb_fpu);
40378fb5:	eea091        	l32r	a9, 40374a38 <_iram_text_start+0x634> (6001d054 <SENS+0x14854>)
40378fb8:	0020c0        	memw
40378fbb:	0988      	l32i.n	a8, a9, 0
40378fbd:	7c7c      	movi.n	a12, -9
40378fbf:	1088c0        	and	a8, a8, a12
40378fc2:	04a420        	extui	a10, a2, 4, 1
40378fc5:	11aad0        	slli	a10, a10, 3
40378fc8:	2088a0        	or	a8, a8, a10
40378fcb:	0020c0        	memw
40378fce:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(BBPD_CTRL, BB_DC_EST_FORCE_PU, cfg.bb_fpu);
40378fd0:	0020c0        	memw
40378fd3:	0988      	l32i.n	a8, a9, 0
40378fd5:	db7c      	movi.n	a11, -3
40378fd7:	1088b0        	and	a8, a8, a11
40378fda:	04a420        	extui	a10, a2, 4, 1
40378fdd:	aaaa      	add.n	a10, a10, a10
40378fdf:	2088a0        	or	a8, a8, a10
40378fe2:	0020c0        	memw
40378fe5:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_RX_ROT_FORCE_PU, cfg.nrx_fpu);
40378fe7:	ee9581        	l32r	a8, 40374a3c <_iram_text_start+0x638> (6001ccd4 <SENS+0x144d4>)
40378fea:	0020c0        	memw
40378fed:	0898      	l32i.n	a9, a8, 0
40378fef:	dfafa2        	movi	a10, -33
40378ff2:	1099a0        	and	a9, a9, a10
40378ff5:	04d520        	extui	a13, a2, 5, 1
40378ff8:	11ddb0        	slli	a13, a13, 5
40378ffb:	2099d0        	or	a9, a9, a13
40378ffe:	0020c0        	memw
40379001:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_VIT_FORCE_PU, cfg.nrx_fpu);
40379003:	0020c0        	memw
40379006:	0898      	l32i.n	a9, a8, 0
40379008:	1099c0        	and	a9, a9, a12
4037900b:	04c520        	extui	a12, a2, 5, 1
4037900e:	11ccd0        	slli	a12, a12, 3
40379011:	2099c0        	or	a9, a9, a12
40379014:	0020c0        	memw
40379017:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_DEMAP_FORCE_PU, cfg.nrx_fpu);
40379019:	0020c0        	memw
4037901c:	0898      	l32i.n	a9, a8, 0
4037901e:	1099b0        	and	a9, a9, a11
40379021:	04b520        	extui	a11, a2, 5, 1
40379024:	bbba      	add.n	a11, a11, a11
40379026:	2099b0        	or	a9, a9, a11
40379029:	0020c0        	memw
4037902c:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(FE_GEN_CTRL, FE_IQ_EST_FORCE_PU, cfg.fe_fpu);
4037902e:	ee84b1        	l32r	a11, 40374a40 <_iram_text_start+0x63c> (60006090 <GPIO+0x2090>)
40379031:	0020c0        	memw
40379034:	0b88      	l32i.n	a8, a11, 0
40379036:	1088a0        	and	a8, a8, a10
40379039:	049620        	extui	a9, a2, 6, 1
4037903c:	1199b0        	slli	a9, a9, 5
4037903f:	208890        	or	a8, a8, a9
40379042:	0020c0        	memw
40379045:	0b89      	s32i.n	a8, a11, 0
    REG_SET_FIELD(FE2_TX_INTERP_CTRL, FE2_TX_INF_FORCE_PU, cfg.fe_fpu);
40379047:	ee7fa1        	l32r	a10, 40374a44 <_iram_text_start+0x640> (600050f0 <GPIO+0x10f0>)
4037904a:	0020c0        	memw
4037904d:	0a88      	l32i.n	a8, a10, 0
4037904f:	ffab92        	movi	a9, 0xfffffbff
40379052:	108890        	and	a8, a8, a9
40379055:	049620        	extui	a9, a2, 6, 1
40379058:	119960        	slli	a9, a9, 10
4037905b:	208890        	or	a8, a8, a9
4037905e:	0020c0        	memw
40379061:	0a89      	s32i.n	a8, a10, 0
    if (cfg.sram_fpu) {
40379063:	80a082        	movi	a8, 128
40379066:	108280        	and	a8, a2, a8
40379069:	f48080        	extui	a8, a8, 0, 16
4037906c:	489c      	beqz.n	a8, 40379084 <rtc_sleep_pu+0x168>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, SYSCON_SRAM_POWER_UP);
4037906e:	ee7691        	l32r	a9, 40374a48 <_iram_text_start+0x644> (600260b0 <SYSCON+0xb0>)
40379071:	0020c0        	memw
40379074:	0988      	l32i.n	a8, a9, 0
40379076:	ee75a1        	l32r	a10, 40374a4c <_iram_text_start+0x648> (3ff8 <UserFrameTotalSize+0x3ef8>)
40379079:	2088a0        	or	a8, a8, a10
4037907c:	0020c0        	memw
4037907f:	0989      	s32i.n	a8, a9, 0
40379081:	000486        	j	40379097 <rtc_sleep_pu+0x17b>
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, 0);
40379084:	ee7191        	l32r	a9, 40374a48 <_iram_text_start+0x644> (600260b0 <SYSCON+0xb0>)
40379087:	0020c0        	memw
4037908a:	0988      	l32i.n	a8, a9, 0
4037908c:	ee71a1        	l32r	a10, 40374a50 <_iram_text_start+0x64c> (ffffc007 <_rtc_reserved_end+0x9fefc007>)
4037908f:	1088a0        	and	a8, a8, a10
40379092:	0020c0        	memw
40379095:	0989      	s32i.n	a8, a9, 0
    }
    if (cfg.rom_ram_fpu) {
40379097:	00a182        	movi	a8, 0x100
4037909a:	102280        	and	a2, a2, a8
4037909d:	f42020        	extui	a2, a2, 0, 16
403790a0:	429c      	beqz.n	a2, 403790b8 <rtc_sleep_pu+0x19c>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, SYSCON_ROM_POWER_UP);
403790a2:	ee6991        	l32r	a9, 40374a48 <_iram_text_start+0x644> (600260b0 <SYSCON+0xb0>)
403790a5:	0020c0        	memw
403790a8:	0988      	l32i.n	a8, a9, 0
403790aa:	7a0c      	movi.n	a10, 7
403790ac:	2088a0        	or	a8, a8, a10
403790af:	0020c0        	memw
403790b2:	0989      	s32i.n	a8, a9, 0
403790b4:	000486        	j	403790ca <rtc_sleep_pu+0x1ae>
403790b7:	649100        	extui	a9, a0, 1, 7
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, 0);
403790ba:	ee          	.byte	0xee
403790bb:	0020c0        	memw
403790be:	0988      	l32i.n	a8, a9, 0
403790c0:	8a7c      	movi.n	a10, -8
403790c2:	1088a0        	and	a8, a8, a10
403790c5:	0020c0        	memw
403790c8:	0989      	s32i.n	a8, a9, 0
    }
}
403790ca:	f01d      	retw.n

403790cc <rtc_clk_cal_internal>:
 * @param cal_clk which clock to calibrate
 * @param slowclk_cycles number of slow clock cycles to count
 * @return number of XTAL clock cycles within the given number of slow clock cycles
 */
uint32_t rtc_clk_cal_internal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
403790cc:	004136        	entry	a1, 32
403790cf:	027d      	mov.n	a7, a2
    /* On ESP32S3, choosing RTC_CAL_RTC_MUX results in calibration of
     * the 150k RTC clock regardless of the currently selected SLOW_CLK.
     * On the ESP32, it used the currently selected SLOW_CLK.
     * The following code emulates ESP32 behavior:
     */
    if (cal_clk == RTC_CAL_RTC_MUX) {
403790d1:	b2cc      	bnez.n	a2, 403790e0 <rtc_clk_cal_internal+0x14>
        soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
403790d3:	ff9325        	call8	40378a04 <rtc_clk_slow_src_get>
        if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
403790d6:	0c1a26        	beqi	a10, 1, 403790e6 <rtc_clk_cal_internal+0x1a>
            cal_clk = RTC_CAL_32K_XTAL;
        } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
403790d9:	172a66        	bnei	a10, 2, 403790f4 <rtc_clk_cal_internal+0x28>
403790dc:	000346        	j	403790ed <rtc_clk_cal_internal+0x21>
403790df:	326600        	orbc	b6, b6, b0
            cal_clk = RTC_CAL_8MD256;
        }
    } else if (cal_clk == RTC_CAL_INTERNAL_OSC) {
403790e2:	02c610        	andb	b12, b6, b1
403790e5:	270c00        	lsi	f0, a12, 156
            cal_clk = RTC_CAL_32K_XTAL;
403790e8:	000206        	j	403790f4 <rtc_clk_cal_internal+0x28>
403790eb:	0c0000        	lsi	f0, a0, 48
            cal_clk = RTC_CAL_8MD256;
403790ee:	004617        	ball	a6, a1, 403790f2 <rtc_clk_cal_internal+0x26>
403790f1:	070c00        	lsi	f0, a12, 28
    return REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN);
403790f4:	ee3081        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403790f7:	0020c0        	memw
403790fa:	08a8      	l32i.n	a10, a8, 0
        cal_clk = RTC_CAL_RTC_MUX;
    }

    /* Enable requested clock (150k clock is always on) */
    bool dig_32k_xtal_enabled = clk_ll_xtal32k_digi_is_enabled();
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
403790fc:	fec782        	addi	a8, a7, -2
403790ff:	40f880        	nsau	a8, a8
40379102:	418580        	srli	a8, a8, 5
40379105:	04a8a0        	extui	a10, a10, 8, 1
40379108:	190c      	movi.n	a9, 1
4037910a:	3099a0        	xor	a9, a9, a10
4037910d:	104980        	and	a4, a9, a8
40379110:	130987        	bnone	a9, a8, 40379127 <rtc_clk_cal_internal+0x5b>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40379113:	ee2891        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40379116:	0020c0        	memw
40379119:	0988      	l32i.n	a8, a9, 0
4037911b:	00a1a2        	movi	a10, 0x100
4037911e:	2088a0        	or	a8, a8, a10
40379121:	0020c0        	memw
40379124:	006982        	s32i	a8, a9, 0
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M) == 0;
40379127:	ee2381        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
4037912a:	0020c0        	memw
4037912d:	0868      	l32i.n	a6, a8, 0
4037912f:	094c      	movi.n	a9, 64
40379131:	106690        	and	a6, a6, a9
40379134:	40f660        	nsau	a6, a6
40379137:	416560        	srli	a6, a6, 5
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
4037913a:	0020c0        	memw
4037913d:	0858      	l32i.n	a5, a8, 0
4037913f:	80a082        	movi	a8, 128
40379142:	105580        	and	a5, a5, a8
40379145:	40f550        	nsau	a5, a5
40379148:	415550        	srli	a5, a5, 5
        clk_ll_xtal32k_digi_enable();
    }

    bool rc_fast_enabled = clk_ll_rc_fast_is_enabled();
    bool rc_fast_d256_enabled = clk_ll_rc_fast_d256_is_enabled();
    if (cal_clk == RTC_CAL_8MD256) {
4037914b:	191766        	bnei	a7, 1, 40379168 <rtc_clk_cal_internal+0x9c>
        rtc_clk_8m_enable(true, true);
4037914e:	1b0c      	movi.n	a11, 1
40379150:	0bad      	mov.n	a10, a11
40379152:	ff6fe5        	call8	40378850 <rtc_clk_8m_enable>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
40379155:	ee1791        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
40379158:	0020c0        	memw
4037915b:	0988      	l32i.n	a8, a9, 0
4037915d:	00a2a2        	movi	a10, 0x200
40379160:	2088a0        	or	a8, a8, a10
40379163:	0020c0        	memw
40379166:	0989      	s32i.n	a8, a9, 0
        clk_ll_rc_fast_d256_digi_enable();
    }
    /* There may be another calibration process already running during we call this function,
     * so we should wait the last process is done.
     */
    if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING)) {
40379168:	ee3b81        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
4037916b:	0020c0        	memw
4037916e:	0888      	l32i.n	a8, a8, 0
40379170:	2c68c7        	bbci	a8, 12, 403791a0 <rtc_clk_cal_internal+0xd4>
        /**
         * Set a small timeout threshold to accelerate the generation of timeout.
         * The internal circuit will be reset when the timeout occurs and will not affect the next calibration.
         */
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, 1);
40379173:	ee3991        	l32r	a9, 40374a58 <_iram_text_start+0x654> (6001f080 <TIMERG0+0x80>)
40379176:	0020c0        	memw
40379179:	0988      	l32i.n	a8, a9, 0
4037917b:	748080        	extui	a8, a8, 0, 8
4037917e:	80a0a2        	movi	a10, 128
40379181:	2088a0        	or	a8, a8, a10
40379184:	0020c0        	memw
40379187:	0989      	s32i.n	a8, a9, 0
        while (!GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)
40379189:	ee3281        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
4037918c:	0020c0        	memw
4037918f:	0888      	l32i.n	a8, a8, 0
                && !GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT));
40379191:	0be8f7        	bbsi	a8, 15, 403791a0 <rtc_clk_cal_internal+0xd4>
40379194:	ee3181        	l32r	a8, 40374a58 <_iram_text_start+0x654> (6001f080 <TIMERG0+0x80>)
40379197:	0020c0        	memw
4037919a:	002882        	l32i	a8, a8, 0
4037919d:	e86807        	bbci	a8, 0, 40379189 <rtc_clk_cal_internal+0xbd>
    }

    /* Prepare calibration */
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_CLK_SEL, cal_clk);
403791a0:	ee2d81        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
403791a3:	0020c0        	memw
403791a6:	0898      	l32i.n	a9, a8, 0
403791a8:	ee2da1        	l32r	a10, 40374a5c <_iram_text_start+0x658> (ffff9fff <_rtc_reserved_end+0x9fef9fff>)
403791ab:	1099a0        	and	a9, a9, a10
403791ae:	11a730        	slli	a10, a7, 13
403791b1:	14ada0        	extui	a10, a10, 13, 2
403791b4:	11aa30        	slli	a10, a10, 13
403791b7:	2099a0        	or	a9, a9, a10
403791ba:	0020c0        	memw
403791bd:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING);
403791bf:	0020c0        	memw
403791c2:	0898      	l32i.n	a9, a8, 0
403791c4:	ee27a1        	l32r	a10, 40374a60 <_iram_text_start+0x65c> (ffffefff <_rtc_reserved_end+0x9fefefff>)
403791c7:	1099a0        	and	a9, a9, a10
403791ca:	0020c0        	memw
403791cd:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_MAX, slowclk_cycles);
403791cf:	0020c0        	memw
403791d2:	0898      	l32i.n	a9, a8, 0
403791d4:	ee24a1        	l32r	a10, 40374a64 <_iram_text_start+0x660> (8000ffff <_rtc_reserved_end+0x1ff0ffff>)
403791d7:	1099a0        	and	a9, a9, a10
403791da:	11a300        	slli	a10, a3, 16
403791dd:	e5a0a0        	extui	a10, a10, 16, 15
403791e0:	11aa00        	slli	a10, a10, 16
403791e3:	2099a0        	or	a9, a9, a10
403791e6:	0020c0        	memw
403791e9:	0899      	s32i.n	a9, a8, 0
    /* Figure out how long to wait for calibration to finish */

    /* Set timeout reg and expect time delay*/
    uint32_t expected_freq;
    if (cal_clk == RTC_CAL_32K_XTAL) {
403791eb:	1d2766        	bnei	a7, 2, 4037920c <rtc_clk_cal_internal+0x140>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_X32K_CAL_TIMEOUT_THRES(slowclk_cycles));
403791ee:	ee1a91        	l32r	a9, 40374a58 <_iram_text_start+0x654> (6001f080 <TIMERG0+0x80>)
403791f1:	0020c0        	memw
403791f4:	0988      	l32i.n	a8, a9, 0
403791f6:	648080        	extui	a8, a8, 0, 7
403791f9:	01a3d0        	slli	a10, a3, 19
403791fc:	2088a0        	or	a8, a8, a10
403791ff:	0020c0        	memw
40379202:	0989      	s32i.n	a8, a9, 0
        expected_freq = SOC_CLK_XTAL32K_FREQ_APPROX;
40379204:	ec94c1        	l32r	a12, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
40379207:	000ec6        	j	40379246 <rtc_clk_cal_internal+0x17a>
4037920a:	660000        	lsi	f0, a0, 0x198
    } else if (cal_clk == RTC_CAL_8MD256) {
4037920d:	911c17        	beq	a12, a1, 403791a2 <rtc_clk_cal_internal+0xd6>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_8MD256_CAL_TIMEOUT_THRES(slowclk_cycles));
40379210:	c0ee12        	s32c1i	a1, a14, 0x300
40379213:	880020        	lsi	f2, a0, 0x220
40379216:	8009      	s32i.n	a0, a0, 32
40379218:	d06480        	subx2	a6, a4, a8
4037921b:	a001a3        	lsi	f10, a1, 0x280
4037921e:	2088      	l32i.n	a8, a0, 8
40379220:	0020c0        	memw
40379223:	0989      	s32i.n	a8, a9, 0
        expected_freq = SOC_CLK_RC_FAST_D256_FREQ_APPROX;
40379225:	edebc1        	l32r	a12, 403749d4 <_iram_text_start+0x5d0> (10b07 <UserFrameTotalSize+0x10a07>)
40379228:	000686        	j	40379246 <rtc_clk_cal_internal+0x17a>
4037922b:	0b9100        	lsi	f0, a1, 44
    } else {
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_150K_CAL_TIMEOUT_THRES(slowclk_cycles));
4037922e:	ee          	.byte	0xee
4037922f:	0020c0        	memw
40379232:	0988      	l32i.n	a8, a9, 0
40379234:	648080        	extui	a8, a8, 0, 7
40379237:	01a3f0        	slli	a10, a3, 17
4037923a:	2088a0        	or	a8, a8, a10
4037923d:	0020c0        	memw
40379240:	006982        	s32i	a8, a9, 0
        expected_freq = SOC_CLK_RC_SLOW_FREQ_APPROX;
40379243:	ede3c1        	l32r	a12, 403749d0 <_iram_text_start+0x5cc> (21340 <UserFrameTotalSize+0x21240>)
    }
    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);
40379246:	ed22a1        	l32r	a10, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40379249:	a2b3a0        	muluh	a11, a3, a10
4037924c:	00a0d2        	movi	a13, 0
4037924f:	82a3a0        	mull	a10, a3, a10
40379252:	ecc381        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
40379255:	0008e0        	callx8	a8
    /* Start calibration */
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
40379258:	edff91        	l32r	a9, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
4037925b:	0020c0        	memw
4037925e:	0988      	l32i.n	a8, a9, 0
40379260:	888a      	add.n	a8, a8, a8
40379262:	418180        	srli	a8, a8, 1
40379265:	0020c0        	memw
40379268:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
4037926a:	0020c0        	memw
4037926d:	0988      	l32i.n	a8, a9, 0
4037926f:	ecabb1        	l32r	a11, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
40379272:	2088b0        	or	a8, a8, a11
40379275:	0020c0        	memw
40379278:	0989      	s32i.n	a8, a9, 0

    /* Wait for calibration to finish up to another us_time_estimate */
    esp_rom_delay_us(us_time_estimate);
4037927a:	ec6e81        	l32r	a8, 40374434 <_iram_text_start+0x30> (40000600 <esp_rom_delay_us>)
4037927d:	0008e0        	callx8	a8
    uint32_t cal_val;
    while (true) {
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)) {
40379280:	edf581        	l32r	a8, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
40379283:	0020c0        	memw
40379286:	0888      	l32i.n	a8, a8, 0
40379288:	042f80        	extui	a2, a8, 15, 1
4037928b:	112210        	slli	a2, a2, 15
4037928e:	0e68f7        	bbci	a8, 15, 403792a0 <rtc_clk_cal_internal+0x1d4>
            cal_val = REG_GET_FIELD(TIMG_RTCCALICFG1_REG(0), TIMG_RTC_CALI_VALUE);
40379291:	edf581        	l32r	a8, 40374a68 <_iram_text_start+0x664> (6001f06c <TIMERG0+0x6c>)
40379294:	0020c0        	memw
40379297:	0828      	l32i.n	a2, a8, 0
40379299:	412720        	srli	a2, a2, 7
            break;
4037929c:	0002c6        	j	403792ab <rtc_clk_cal_internal+0x1df>
4037929f:	ee8100        	f64iter	a8, a1, a0, 2, 1
        }
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT)) {
403792a2:	c0ed      	lsi	f14, a0, 0
403792a4:	880020        	lsi	f2, a0, 0x220
403792a7:	0708      	l32i.n	a0, a7, 0
403792a9:	d468      	l32i.n	a6, a4, 52
            cal_val = 0;
            break;
        }
    }
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
403792ab:	edea91        	l32r	a9, 40374a54 <_iram_text_start+0x650> (6001f068 <TIMERG0+0x68>)
403792ae:	0020c0        	memw
403792b1:	0988      	l32i.n	a8, a9, 0
403792b3:	888a      	add.n	a8, a8, a8
403792b5:	418180        	srli	a8, a8, 1
403792b8:	0020c0        	memw
403792bb:	0989      	s32i.n	a8, a9, 0

    /* if dig_32k_xtal was originally off and enabled due to calibration, then set back to off state */
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
403792bd:	249c      	beqz.n	a4, 403792d3 <rtc_clk_cal_internal+0x207>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
403792bf:	edbd91        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403792c2:	0020c0        	memw
403792c5:	0988      	l32i.n	a8, a9, 0
403792c7:	ffaea2        	movi	a10, 0xfffffeff
403792ca:	1088a0        	and	a8, a8, a10
403792cd:	0020c0        	memw
403792d0:	006982        	s32i	a8, a9, 0
        clk_ll_xtal32k_digi_disable();
    }

    if (cal_clk == RTC_CAL_8MD256) {
403792d3:	191766        	bnei	a7, 1, 403792f0 <rtc_clk_cal_internal+0x224>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
403792d6:	edb791        	l32r	a9, 403749b4 <_iram_text_start+0x5b0> (60008074 <RTCCNTL+0x74>)
403792d9:	0020c0        	memw
403792dc:	0988      	l32i.n	a8, a9, 0
403792de:	ffada2        	movi	a10, 0xfffffdff
403792e1:	1088a0        	and	a8, a8, a10
403792e4:	0020c0        	memw
403792e7:	0989      	s32i.n	a8, a9, 0
        clk_ll_rc_fast_d256_digi_disable();
        rtc_clk_8m_enable(rc_fast_enabled, rc_fast_d256_enabled);
403792e9:	05bd      	mov.n	a11, a5
403792eb:	06ad      	mov.n	a10, a6
403792ed:	ff5625        	call8	40378850 <rtc_clk_8m_enable>
    }

    return cal_val;
}
403792f0:	f01d      	retw.n
	...

403792f4 <rtc_clk_cal>:
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
}

uint32_t rtc_clk_cal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
403792f4:	004136        	entry	a1, 32
    assert(slowclk_cycles);
403792f7:	011356        	bnez	a3, 4037930c <rtc_clk_cal+0x18>
403792fa:	eddcd1        	l32r	a13, 40374a6c <_iram_text_start+0x668> (3c023758 <_flash_rodata_start+0x3638>)
403792fd:	eddcc1        	l32r	a12, 40374a70 <_iram_text_start+0x66c> (3c027c34 <__func__$1>)
40379300:	93a0b2        	movi	a11, 147
40379303:	eddca1        	l32r	a10, 40374a74 <_iram_text_start+0x670> (3c023795 <_flash_rodata_start+0x3675>)
40379306:	201110        	or	a1, a1, a1
40379309:	06a465        	call8	4037fd50 <__assert_func>
    soc_xtal_freq_t xtal_freq = rtc_clk_xtal_freq_get();
4037930c:	ff78e5        	call8	40378a9c <rtc_clk_xtal_freq_get>
4037930f:	0a6d      	mov.n	a6, a10
    uint64_t xtal_cycles = rtc_clk_cal_internal(cal_clk, slowclk_cycles);
40379311:	03bd      	mov.n	a11, a3
40379313:	02ad      	mov.n	a10, a2
40379315:	ffdb65        	call8	403790cc <rtc_clk_cal_internal>
40379318:	0a7d      	mov.n	a7, a10
4037931a:	050c      	movi.n	a5, 0

    if ((cal_clk == RTC_CAL_32K_XTAL) && !rtc_clk_cal_32k_valid((uint32_t)xtal_freq, slowclk_cycles, xtal_cycles)) {
4037931c:	562266        	bnei	a2, 2, 40379376 <rtc_clk_cal+0x82>
    uint64_t expected_xtal_cycles = (xtal_freq * 1000000ULL * slowclk_cycles) >> 15; // xtal_freq(hz) * slowclk_cycles / 32768
4037931f:	828630        	mull	a8, a6, a3
40379322:	a22630        	muluh	a2, a6, a3
40379325:	ecea91        	l32r	a9, 403746d0 <_iram_text_start+0x2cc> (f4240 <UserFrameTotalSize+0xf4140>)
40379328:	822290        	mull	a2, a2, a9
4037932b:	824890        	mull	a4, a8, a9
4037932e:	a28890        	muluh	a8, a8, a9
40379331:	228a      	add.n	a2, a2, a8
40379333:	0182f0        	slli	a8, a2, 17
40379336:	414f40        	srli	a4, a4, 15
40379339:	204840        	or	a4, a8, a4
4037933c:	412f20        	srli	a2, a2, 15
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
4037933f:	d0a7c2        	movi	a12, 0x7d0
40379342:	05dd      	mov.n	a13, a5
40379344:	04ad      	mov.n	a10, a4
40379346:	02bd      	mov.n	a11, a2
40379348:	ec8681        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
4037934b:	0008e0        	callx8	a8
4037934e:	0a9d      	mov.n	a9, a10
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
40379350:	c082b0        	sub	a8, a2, a11
40379353:	01b4a7        	bgeu	a4, a10, 40379358 <rtc_clk_cal+0x64>
40379356:	880b      	addi.n	a8, a8, -1
40379358:	c0c4a0        	sub	a12, a4, a10
4037935b:	513587        	bltu	a5, a8, 403793b0 <rtc_clk_cal+0xbc>
4037935e:	029857        	bne	a8, a5, 40379364 <rtc_clk_cal+0x70>
40379361:	4b37c7        	bltu	a7, a12, 403793b0 <rtc_clk_cal+0xbc>
40379364:	22ba      	add.n	a2, a2, a11
40379366:	44aa      	add.n	a4, a4, a10
40379368:	01b497        	bgeu	a4, a9, 4037936d <rtc_clk_cal+0x79>
4037936b:	221b      	addi.n	a2, a2, 1
4037936d:	443257        	bltu	a2, a5, 403793b5 <rtc_clk_cal+0xc1>
40379370:	029527        	bne	a5, a2, 40379376 <rtc_clk_cal+0x82>
40379373:	3e3477        	bltu	a4, a7, 403793b5 <rtc_clk_cal+0xc1>
        return 0;
    }

    uint64_t divider = ((uint64_t)xtal_freq) * slowclk_cycles;
40379376:	82c630        	mull	a12, a6, a3
40379379:	a2d630        	muluh	a13, a6, a3
    uint64_t period_64 = ((xtal_cycles << RTC_CLK_CAL_FRACT) + divider / 2 - 1) / divider;
4037937c:	418d70        	srli	a8, a7, 13
4037937f:	01a7d0        	slli	a10, a7, 19
40379382:	01bd10        	slli	a11, a13, 31
40379385:	4191c0        	srli	a9, a12, 1
40379388:	209b90        	or	a9, a11, a9
4037938b:	41b1d0        	srli	a11, a13, 1
4037938e:	88ba      	add.n	a8, a8, a11
40379390:	80aa90        	add	a10, a10, a9
40379393:	02ba97        	bgeu	a10, a9, 40379399 <rtc_clk_cal+0xa5>
40379396:	01c882        	addi	a8, a8, 1
40379399:	f97c      	movi.n	a9, -1
4037939b:	b89a      	add.n	a11, a8, a9
4037939d:	aa9a      	add.n	a10, a10, a9
4037939f:	01ba97        	bgeu	a10, a9, 403793a4 <rtc_clk_cal+0xb0>
403793a2:	08bd      	mov.n	a11, a8
403793a4:	ec6f81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
403793a7:	0008e0        	callx8	a8
    uint32_t period = (uint32_t)(period_64 & UINT32_MAX);
403793aa:	0a2d      	mov.n	a2, a10
    return period;
403793ac:	0001c6        	j	403793b7 <rtc_clk_cal+0xc3>
403793af:	020c00        	andb	b0, b12, b0
        return 0;
403793b2:	000046        	j	403793b7 <rtc_clk_cal+0xc3>
403793b5:	020c      	movi.n	a2, 0
}
403793b7:	f01d      	retw.n
403793b9:	000000        	ill

403793bc <rtc_time_us_to_slowclk>:

uint64_t rtc_time_us_to_slowclk(uint64_t time_in_us, uint32_t period)
{
403793bc:	004136        	entry	a1, 32
403793bf:	04cd      	mov.n	a12, a4
    assert(period);
403793c1:	04dc      	bnez.n	a4, 403793d5 <rtc_time_us_to_slowclk+0x19>
403793c3:	edadd1        	l32r	a13, 40374a78 <_iram_text_start+0x674> (3c0237a0 <_flash_rodata_start+0x3680>)
403793c6:	edadc1        	l32r	a12, 40374a7c <_iram_text_start+0x678> (3c027c1c <__func__$0>)
403793c9:	a3a0b2        	movi	a11, 163
403793cc:	edaaa1        	l32r	a10, 40374a74 <_iram_text_start+0x670> (3c023795 <_flash_rodata_start+0x3675>)
403793cf:	201110        	or	a1, a1, a1
403793d2:	0697e5        	call8	4037fd50 <__assert_func>
    /* Overflow will happen in this function if time_in_us >= 2^45, which is about 400 days.
     * TODO: fix overflow.
     */
    return (time_in_us << RTC_CLK_CAL_FRACT) / period;
403793d5:	41bd20        	srli	a11, a2, 13
403793d8:	0133d0        	slli	a3, a3, 19
403793db:	0d0c      	movi.n	a13, 0
403793dd:	01a2d0        	slli	a10, a2, 19
403793e0:	20bb30        	or	a11, a11, a3
403793e3:	ec5f81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
403793e6:	0008e0        	callx8	a8
}
403793e9:	0a2d      	mov.n	a2, a10
403793eb:	0b3d      	mov.n	a3, a11
403793ed:	f01d      	retw.n
	...

403793f0 <rtc_time_get>:
{
    return (rtc_cycles * period) >> RTC_CLK_CAL_FRACT;
}

uint64_t rtc_time_get(void)
{
403793f0:	004136        	entry	a1, 32
    SET_PERI_REG_MASK(RTC_CNTL_STATE0_REG, RTC_CNTL_SLEEP_EN);
}

FORCE_INLINE_ATTR uint64_t rtc_cntl_ll_get_rtc_time(void)
{
    SET_PERI_REG_MASK(RTC_CNTL_TIME_UPDATE_REG, RTC_CNTL_TIME_UPDATE);
403793f3:	eda391        	l32r	a9, 40374a80 <_iram_text_start+0x67c> (6000800c <RTCCNTL+0xc>)
403793f6:	0020c0        	memw
403793f9:	0988      	l32i.n	a8, a9, 0
403793fb:	ec48a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
403793fe:	2088a0        	or	a8, a8, a10
40379401:	0020c0        	memw
40379404:	0989      	s32i.n	a8, a9, 0
    uint64_t t = READ_PERI_REG(RTC_CNTL_TIME0_REG);
40379406:	ed9f81        	l32r	a8, 40374a84 <_iram_text_start+0x680> (60008010 <RTCCNTL+0x10>)
40379409:	0020c0        	memw
4037940c:	0828      	l32i.n	a2, a8, 0
    t |= ((uint64_t) READ_PERI_REG(RTC_CNTL_TIME1_REG)) << 32;
4037940e:	ed9e81        	l32r	a8, 40374a88 <_iram_text_start+0x684> (60008014 <RTCCNTL+0x14>)
40379411:	0020c0        	memw
40379414:	0838      	l32i.n	a3, a8, 0
    return rtc_cntl_ll_get_rtc_time();
}
40379416:	f01d      	retw.n

40379418 <enable_timer_group0_for_calibration>:
}

/// @brief if the calibration is used, we need to enable the timer group0 first
__attribute__((constructor))
static void enable_timer_group0_for_calibration(void)
{
40379418:	004136        	entry	a1, 32
#ifndef BOOTLOADER_BUILD
    PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_TIMG0_MODULE, ref_count) {
4037941b:	170c      	movi.n	a7, 1
4037941d:	001406        	j	40379471 <enable_timer_group0_for_calibration+0x59>
 * @param enable true to enable, false to disable
 */
static inline void _timer_ll_enable_bus_clock(int group_id, bool enable)
{
    if (group_id == 0) {
        SYSTEM.perip_clk_en0.timergroup_clk_en = enable;
40379420:	ed9b81        	l32r	a8, 40374a8c <_iram_text_start+0x688> (600c0000 <SYSTEM>)
40379423:	0020c0        	memw
40379426:	062892        	l32i	a9, a8, 24
40379429:	ed99a1        	l32r	a10, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037942c:	2099a0        	or	a9, a9, a10
4037942f:	0020c0        	memw
40379432:	066892        	s32i	a9, a8, 24
 * @param group_id Group ID
 */
static inline void _timer_ll_reset_register(int group_id)
{
    if (group_id == 0) {
        SYSTEM.perip_rst_en0.timergroup_rst = 1;
40379435:	0020c0        	memw
40379438:	8898      	l32i.n	a9, a8, 32
4037943a:	2099a0        	or	a9, a9, a10
4037943d:	0020c0        	memw
40379440:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup_rst = 0;
40379442:	0020c0        	memw
40379445:	8898      	l32i.n	a9, a8, 32
40379447:	ed93a1        	l32r	a10, 40374a94 <_iram_text_start+0x690> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4037944a:	1099a0        	and	a9, a9, a10
4037944d:	0020c0        	memw
40379450:	8899      	s32i.n	a9, a8, 32
        TIMERG0.wdtconfig0.wdt_flashboot_mod_en = 0;
40379452:	ed9191        	l32r	a9, 40374a98 <_iram_text_start+0x694> (6001f000 <TIMERG0>)
40379455:	0020c0        	memw
40379458:	122982        	l32i	a8, a9, 72
4037945b:	ed90a1        	l32r	a10, 40374a9c <_iram_text_start+0x698> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
4037945e:	1088a0        	and	a8, a8, a10
40379461:	0020c0        	memw
40379464:	126982        	s32i	a8, a9, 72
40379467:	aa0c      	movi.n	a10, 10
40379469:	fd2625        	call8	403766cc <periph_rcc_acquire_exit>
4037946c:	770b      	addi.n	a7, a7, -1
4037946e:	747070        	extui	a7, a7, 0, 8
40379471:	b78c      	beqz.n	a7, 40379480 <enable_timer_group0_for_calibration+0x68>
40379473:	aa0c      	movi.n	a10, 10
40379475:	fd2465        	call8	403766bc <periph_rcc_acquire_enter>
40379478:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
4037947a:	fa2a16        	beqz	a10, 40379420 <enable_timer_group0_for_calibration+0x8>
4037947d:	fff986        	j	40379467 <enable_timer_group0_for_calibration+0x4f>
    }
#else
    _timer_ll_enable_bus_clock(0, true);
    _timer_ll_reset_register(0);
#endif
}
40379480:	f01d      	retw.n
	...

40379484 <systimer_ticks_to_us>:
 * @brief systimer's clock source is fixed to XTAL (40MHz), and has a fixed fractional divider (2.5).
 *        So the resolution of the systimer is 40MHz/2.5 = 16MHz.
 */

uint64_t systimer_ticks_to_us(uint64_t ticks)
{
40379484:	004136        	entry	a1, 32
    return ticks / 16;
40379487:	018340        	slli	a8, a3, 28
4037948a:	412420        	srli	a2, a2, 4
}
4037948d:	202820        	or	a2, a8, a2
40379490:	413430        	srli	a3, a3, 4
40379493:	f01d      	retw.n
40379495:	000000        	ill

40379498 <systimer_us_to_ticks>:

uint64_t systimer_us_to_ticks(uint64_t us)
{
40379498:	004136        	entry	a1, 32
    return us * 16;
4037949b:	358c20        	extui	a8, a2, 28, 4
4037949e:	1133c0        	slli	a3, a3, 4
}
403794a1:	1122c0        	slli	a2, a2, 4
403794a4:	203830        	or	a3, a8, a3
403794a7:	f01d      	retw.n
403794a9:	000000        	ill

403794ac <esp_cache_get_alignment>:

    return ret;
}

esp_err_t esp_cache_get_alignment(uint32_t heap_caps, size_t *out_alignment)
{
403794ac:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(out_alignment, ESP_ERR_INVALID_ARG, TAG, "null pointer");
403794af:	022356        	bnez	a3, 403794d5 <esp_cache_get_alignment+0x29>
403794b2:	0672e5        	call8	4037fbe0 <esp_log_timestamp>
403794b5:	ed7bb1        	l32r	a11, 40374aa4 <_iram_text_start+0x6a0> (3fc93a74 <__FUNCTION__$0+0x2dc>)
403794b8:	0fa182        	movi	a8, 0x10f
403794bb:	0189      	s32i.n	a8, a1, 0
403794bd:	ed78f1        	l32r	a15, 40374aa0 <_iram_text_start+0x69c> (3fc93798 <__FUNCTION__$0>)
403794c0:	0bed      	mov.n	a14, a11
403794c2:	0add      	mov.n	a13, a10
403794c4:	ed79c1        	l32r	a12, 40374aa8 <_iram_text_start+0x6a4> (3fc93a7c <__FUNCTION__$0+0x2e4>)
403794c7:	1a0c      	movi.n	a10, 1
403794c9:	0675e5        	call8	4037fc28 <esp_log_write>
403794cc:	02a122        	movi	a2, 0x102
403794cf:	000646        	j	403794ec <esp_cache_get_alignment+0x40>
403794d2:	000000        	ill

    uint32_t cache_level = CACHE_LL_LEVEL_INT_MEM;
    uint32_t data_cache_line_size = 0;

    if (heap_caps & MALLOC_CAP_SPIRAM) {
403794d5:	00a482        	movi	a8, 0x400
403794d8:	10a280        	and	a10, a2, a8
403794db:	020287        	bnone	a2, a8, 403794e1 <esp_cache_get_alignment+0x35>
        cache_level = CACHE_LL_LEVEL_EXT_MEM;
403794de:	01a0a2        	movi	a10, 1
    }

    data_cache_line_size = cache_hal_get_cache_line_size(cache_level, CACHE_TYPE_DATA);
403794e1:	00a0b2        	movi	a11, 0
403794e4:	036f25        	call8	4037cbd8 <cache_hal_get_cache_line_size>

    *out_alignment = data_cache_line_size;
403794e7:	0063a2        	s32i	a10, a3, 0

    return ESP_OK;
403794ea:	020c      	movi.n	a2, 0
}
403794ec:	f01d      	retw.n
	...

403794f0 <xRingbufferGetCurFreeSize>:
    configASSERT(pxRingbuffer);
    return pxRingbuffer->xMaxItemSize;
}

size_t xRingbufferGetCurFreeSize(RingbufHandle_t xRingbuffer)
{
403794f0:	004136        	entry	a1, 32
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
403794f3:	00e256        	bnez	a2, 40379505 <xRingbufferGetCurFreeSize+0x15>
403794f6:	ed6dd1        	l32r	a13, 40374aac <_iram_text_start+0x6a8> (3c026c3c <_flash_rodata_start+0x6b1c>)
403794f9:	ed6dc1        	l32r	a12, 40374ab0 <_iram_text_start+0x6ac> (3c0290c8 <__func__$7>)
403794fc:	f3a4b2        	movi	a11, 0x4f3
403794ff:	ed6da1        	l32r	a10, 40374ab4 <_iram_text_start+0x6b0> (3c026c05 <_flash_rodata_start+0x6ae5>)
40379502:	0684e5        	call8	4037fd50 <__assert_func>

    size_t xFreeSize;
    portENTER_CRITICAL(&pxRingbuffer->mux);
40379505:	68c272        	addi	a7, a2, 104
40379508:	fb7c      	movi.n	a11, -1
4037950a:	20a770        	or	a10, a7, a7
4037950d:	00c225        	call8	4037a130 <xPortEnterCriticalTimeout>
    xFreeSize = pxRingbuffer->xGetCurMaxSize(pxRingbuffer);
40379510:	7288      	l32i.n	a8, a2, 28
40379512:	02ad      	mov.n	a10, a2
40379514:	0008e0        	callx8	a8
40379517:	0a2d      	mov.n	a2, a10
    portEXIT_CRITICAL(&pxRingbuffer->mux);
40379519:	07ad      	mov.n	a10, a7
4037951b:	00d665        	call8	4037a280 <vPortExitCritical>
    return xFreeSize;
}
4037951e:	f01d      	retw.n

40379520 <vRingbufferGetInfo>:
                        UBaseType_t *uxFree,
                        UBaseType_t *uxRead,
                        UBaseType_t *uxWrite,
                        UBaseType_t *uxAcquire,
                        UBaseType_t *uxItemsWaiting)
{
40379520:	006136        	entry	a1, 48
40379523:	1179      	s32i.n	a7, a1, 4
40379525:	0179      	s32i.n	a7, a1, 0
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379527:	00e256        	bnez	a2, 40379539 <vRingbufferGetInfo+0x19>
4037952a:	ed60d1        	l32r	a13, 40374aac <_iram_text_start+0x6a8> (3c026c3c <_flash_rodata_start+0x6b1c>)
4037952d:	ed62c1        	l32r	a12, 40374ab8 <_iram_text_start+0x6b4> (3c0290b4 <__func__$4>)
40379530:	34a5b2        	movi	a11, 0x534
40379533:	ed60a1        	l32r	a10, 40374ab4 <_iram_text_start+0x6b0> (3c026c05 <_flash_rodata_start+0x6ae5>)
40379536:	0681a5        	call8	4037fd50 <__assert_func>

    portENTER_CRITICAL(&pxRingbuffer->mux);
40379539:	68c272        	addi	a7, a2, 104
4037953c:	fb7c      	movi.n	a11, -1
4037953e:	07ad      	mov.n	a10, a7
40379540:	00bee5        	call8	4037a130 <xPortEnterCriticalTimeout>
    if (uxFree != NULL) {
40379543:	738c      	beqz.n	a3, 4037954e <vRingbufferGetInfo+0x2e>
        *uxFree = (UBaseType_t)(pxRingbuffer->pucFree - pxRingbuffer->pucHead);
40379545:	b288      	l32i.n	a8, a2, 44
40379547:	c298      	l32i.n	a9, a2, 48
40379549:	c08890        	sub	a8, a8, a9
4037954c:	0389      	s32i.n	a8, a3, 0
    }
    if (uxRead != NULL) {
4037954e:	848c      	beqz.n	a4, 4037955a <vRingbufferGetInfo+0x3a>
        *uxRead = (UBaseType_t)(pxRingbuffer->pucRead - pxRingbuffer->pucHead);
40379550:	a288      	l32i.n	a8, a2, 40
40379552:	c298      	l32i.n	a9, a2, 48
40379554:	c08890        	sub	a8, a8, a9
40379557:	006482        	s32i	a8, a4, 0
    }
    if (uxWrite != NULL) {
4037955a:	858c      	beqz.n	a5, 40379566 <vRingbufferGetInfo+0x46>
        *uxWrite = (UBaseType_t)(pxRingbuffer->pucWrite - pxRingbuffer->pucHead);
4037955c:	9288      	l32i.n	a8, a2, 36
4037955e:	c298      	l32i.n	a9, a2, 48
40379560:	c08890        	sub	a8, a8, a9
40379563:	006582        	s32i	a8, a5, 0
    }
    if (uxAcquire != NULL) {
40379566:	868c      	beqz.n	a6, 40379572 <vRingbufferGetInfo+0x52>
        *uxAcquire = (UBaseType_t)(pxRingbuffer->pucAcquire - pxRingbuffer->pucHead);
40379568:	8288      	l32i.n	a8, a2, 32
4037956a:	c298      	l32i.n	a9, a2, 48
4037956c:	c08890        	sub	a8, a8, a9
4037956f:	006682        	s32i	a8, a6, 0
    }
    if (uxItemsWaiting != NULL) {
40379572:	0188      	l32i.n	a8, a1, 0
40379574:	488c      	beqz.n	a8, 4037957c <vRingbufferGetInfo+0x5c>
        *uxItemsWaiting = (UBaseType_t)(pxRingbuffer->xItemsWaiting);
40379576:	e288      	l32i.n	a8, a2, 56
40379578:	1198      	l32i.n	a9, a1, 4
4037957a:	0989      	s32i.n	a8, a9, 0
    }
    portEXIT_CRITICAL(&pxRingbuffer->mux);
4037957c:	07ad      	mov.n	a10, a7
4037957e:	00d025        	call8	4037a280 <vPortExitCritical>
}
40379581:	f01d      	retw.n
	...

40379584 <Cache_Suspend_ICache>:
    }
}
// renamed for patch
extern uint32_t rom_Cache_Suspend_ICache(void);
uint32_t Cache_Suspend_ICache(void)
{
40379584:	004136        	entry	a1, 32
    uint32_t ret = rom_Cache_Suspend_ICache();
40379587:	ed4e81        	l32r	a8, 40374ac0 <_iram_text_start+0x6bc> (4000189c <rom_Cache_Suspend_ICache>)
4037958a:	0008e0        	callx8	a8
4037958d:	202aa0        	or	a2, a10, a10
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_ICACHE_STATE) != 1) {
40379590:	ed4b81        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
40379593:	0020c0        	memw
40379596:	0888      	l32i.n	a8, a8, 0
40379598:	b48080        	extui	a8, a8, 0, 12
4037959b:	f11866        	bnei	a8, 1, 40379590 <Cache_Suspend_ICache+0xc>
    Cache_Wait_Idle(1);
    return ret;
}
4037959e:	f01d      	retw.n

403795a0 <Cache_Suspend_DCache>:
extern uint32_t Cache_Suspend_ICache(void);

// renamed for patch
extern uint32_t rom_Cache_Suspend_DCache(void);
uint32_t Cache_Suspend_DCache(void)
{
403795a0:	004136        	entry	a1, 32
    uint32_t ret = rom_Cache_Suspend_DCache();
403795a3:	ed4881        	l32r	a8, 40374ac4 <_iram_text_start+0x6c0> (400018b4 <rom_Cache_Suspend_DCache>)
403795a6:	0008e0        	callx8	a8
403795a9:	202aa0        	or	a2, a10, a10
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_DCACHE_STATE) != 1) {
403795ac:	ed4481        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
403795af:	0020c0        	memw
403795b2:	0888      	l32i.n	a8, a8, 0
403795b4:	b48c80        	extui	a8, a8, 12, 12
403795b7:	118840        	slli	a8, a8, 12
403795ba:	ec2d91        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
403795bd:	eb9897        	bne	a8, a9, 403795ac <Cache_Suspend_DCache+0xc>
    Cache_Wait_Idle(0);
    return ret;
}
403795c0:	f01d      	retw.n
	...

403795c4 <Cache_Freeze_ICache_Enable>:

#if SOC_CACHE_FREEZE_SUPPORTED
// renamed for patch
extern void rom_Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode);
void Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode)
{
403795c4:	004136        	entry	a1, 32
403795c7:	20a220        	or	a10, a2, a2
    rom_Cache_Freeze_ICache_Enable(mode);
403795ca:	ed3f81        	l32r	a8, 40374ac8 <_iram_text_start+0x6c4> (400018e4 <rom_Cache_Freeze_ICache_Enable>)
403795cd:	0008e0        	callx8	a8
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_ICACHE_STATE) != 1) {
403795d0:	ed3b81        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
403795d3:	0020c0        	memw
403795d6:	0888      	l32i.n	a8, a8, 0
403795d8:	b48080        	extui	a8, a8, 0, 12
403795db:	f11866        	bnei	a8, 1, 403795d0 <Cache_Freeze_ICache_Enable+0xc>
    Cache_Wait_Idle(1);
}
403795de:	f01d      	retw.n

403795e0 <Cache_Freeze_DCache_Enable>:
extern void Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode);

// renamed for patch
extern void rom_Cache_Freeze_DCache_Enable(cache_freeze_mode_t mode);
void Cache_Freeze_DCache_Enable(cache_freeze_mode_t mode)
{
403795e0:	004136        	entry	a1, 32
403795e3:	20a220        	or	a10, a2, a2
    rom_Cache_Freeze_DCache_Enable(mode);
403795e6:	ed3981        	l32r	a8, 40374acc <_iram_text_start+0x6c8> (400018fc <rom_Cache_Freeze_DCache_Enable>)
403795e9:	0008e0        	callx8	a8
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_DCACHE_STATE) != 1) {
403795ec:	ed3481        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (600c4130 <SYSTEM+0x4130>)
403795ef:	0020c0        	memw
403795f2:	0888      	l32i.n	a8, a8, 0
403795f4:	b48c80        	extui	a8, a8, 12, 12
403795f7:	118840        	slli	a8, a8, 12
403795fa:	ec1d91        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
403795fd:	eb9897        	bne	a8, a9, 403795ec <Cache_Freeze_DCache_Enable+0xc>
    Cache_Wait_Idle(0);
}
40379600:	f01d      	retw.n
	...

40379604 <esp_rom_opiflash_cache_mode_config>:
}

#elif CONFIG_IDF_TARGET_ESP32S3
extern void esp_rom_spi_set_address_bit_len(int spi, int addr_bits);
void esp_rom_opiflash_cache_mode_config(esp_rom_spiflash_read_mode_t mode, const esp_rom_opiflash_spi0rd_t *cache)
{
40379604:	004136        	entry	a1, 32
40379607:	02bd      	mov.n	a11, a2
    esp_rom_spi_set_op_mode(0, mode);
40379609:	0a0c      	movi.n	a10, 0
4037960b:	ed3681        	l32r	a8, 40374ae4 <_iram_text_start+0x6e0> (400008a0 <esp_rom_spi_set_op_mode>)
4037960e:	0008e0        	callx8	a8
    REG_CLR_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_MOSI);
40379611:	ed2f81        	l32r	a8, 40374ad0 <_iram_text_start+0x6cc> (60003018 <SPIMEM0+0x18>)
40379614:	0020c0        	memw
40379617:	0898      	l32i.n	a9, a8, 0
40379619:	ec77a1        	l32r	a10, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037961c:	1099a0        	and	a9, a9, a10
4037961f:	0020c0        	memw
40379622:	0899      	s32i.n	a9, a8, 0
    REG_SET_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_MISO | SPI_MEM_USR_ADDR);
40379624:	0020c0        	memw
40379627:	0898      	l32i.n	a9, a8, 0
40379629:	ed2aa1        	l32r	a10, 40374ad4 <_iram_text_start+0x6d0> (50000000 <_coredump_rtc_end>)
4037962c:	2099a0        	or	a9, a9, a10
4037962f:	0020c0        	memw
40379632:	006892        	s32i	a9, a8, 0

    if (cache) {
40379635:	0b5316        	beqz	a3, 403796ee <esp_rom_opiflash_cache_mode_config+0xea>
        esp_rom_spi_set_address_bit_len(0, cache->addr_bit_len);
40379638:	0003b2        	l8ui	a11, a3, 0
4037963b:	00a0a2        	movi	a10, 0
4037963e:	ed2a81        	l32r	a8, 40374ae8 <_iram_text_start+0x6e4> (40000c60 <esp_rom_spi_set_address_bit_len>)
40379641:	0008e0        	callx8	a8
        // Patch for ROM function `esp_rom_opiflash_cache_mode_config`, because when dummy is 0,
        // `SPI_MEM_USR_DUMMY` should be 0. `esp_rom_opiflash_cache_mode_config` doesn't handle this
        // properly.
        if (cache->dummy_bit_len == 0) {
40379644:	010382        	l8ui	a8, a3, 1
40379647:	58dc      	bnez.n	a8, 40379660 <esp_rom_opiflash_cache_mode_config+0x5c>
            REG_CLR_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_DUMMY);
40379649:	ed2191        	l32r	a9, 40374ad0 <_iram_text_start+0x6cc> (60003018 <SPIMEM0+0x18>)
4037964c:	0020c0        	memw
4037964f:	0988      	l32i.n	a8, a9, 0
40379651:	ec68a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
40379654:	1088a0        	and	a8, a8, a10
40379657:	0020c0        	memw
4037965a:	0989      	s32i.n	a8, a9, 0
4037965c:	000ec6        	j	4037969b <esp_rom_opiflash_cache_mode_config+0x97>
4037965f:	1c9100        	lsi	f0, a1, 112
        } else {
            REG_SET_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_DUMMY);
40379662:	c0ed      	lsi	f14, a0, 0
40379664:	880020        	lsi	f2, a0, 0x220
40379667:	a109      	s32i.n	a0, a1, 40
40379669:	ecdc      	bnez.n	a12, 4037968b <esp_rom_opiflash_cache_mode_config+0x87>
4037966b:	2088a0        	or	a8, a8, a10
4037966e:	0020c0        	memw
40379671:	0989      	s32i.n	a8, a9, 0
            REG_SET_FIELD(SPI_MEM_USER1_REG(0), SPI_MEM_USR_DUMMY_CYCLELEN, cache->dummy_bit_len - 1 + rom_spiflash_legacy_data->dummy_len_plus[0]);
40379673:	ed19a1        	l32r	a10, 40374ad8 <_iram_text_start+0x6d4> (6000301c <SPIMEM0+0x1c>)
40379676:	0020c0        	memw
40379679:	0a88      	l32i.n	a8, a10, 0
4037967b:	c0af92        	movi	a9, -64
4037967e:	109890        	and	a9, a8, a9
40379681:	010382        	l8ui	a8, a3, 1
40379684:	880b      	addi.n	a8, a8, -1
40379686:	ec5ab1        	l32r	a11, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40379689:	0bb8      	l32i.n	a11, a11, 0
4037968b:	180bb2        	l8ui	a11, a11, 24
4037968e:	88ba      	add.n	a8, a8, a11
40379690:	548080        	extui	a8, a8, 0, 6
40379693:	208980        	or	a8, a9, a8
40379696:	0020c0        	memw
40379699:	0a89      	s32i.n	a8, a10, 0
        }
        REG_SET_FIELD(SPI_MEM_USER2_REG(0), SPI_MEM_USR_COMMAND_VALUE, cache->cmd);
4037969b:	ed10a1        	l32r	a10, 40374adc <_iram_text_start+0x6d8> (60003020 <SPIMEM0+0x20>)
4037969e:	0020c0        	memw
403796a1:	0a88      	l32i.n	a8, a10, 0
403796a3:	f58080        	extui	a8, a8, 16, 16
403796a6:	118800        	slli	a8, a8, 16
403796a9:	011392        	l16ui	a9, a3, 2
403796ac:	208890        	or	a8, a8, a9
403796af:	0020c0        	memw
403796b2:	0a89      	s32i.n	a8, a10, 0
        REG_SET_FIELD(SPI_MEM_USER2_REG(0), SPI_MEM_USR_COMMAND_BITLEN, cache->cmd_bit_len - 1);
403796b4:	0020c0        	memw
403796b7:	0a88      	l32i.n	a8, a10, 0
403796b9:	1188c0        	slli	a8, a8, 4
403796bc:	418480        	srli	a8, a8, 4
403796bf:	040392        	l8ui	a9, a3, 4
403796c2:	990b      	addi.n	a9, a9, -1
403796c4:	019940        	slli	a9, a9, 28
403796c7:	208890        	or	a8, a8, a9
403796ca:	0020c0        	memw
403796cd:	0a89      	s32i.n	a8, a10, 0
        REG_SET_FIELD(SPI_MEM_DDR_REG(0), SPI_MEM_SPI_FMEM_VAR_DUMMY, cache->var_dummy_en);
403796cf:	ed04a1        	l32r	a10, 40374ae0 <_iram_text_start+0x6dc> (600030e0 <SPIMEM0+0xe0>)
403796d2:	0020c0        	memw
403796d5:	0a88      	l32i.n	a8, a10, 0
403796d7:	d97c      	movi.n	a9, -3
403796d9:	109890        	and	a9, a8, a9
403796dc:	050382        	l8ui	a8, a3, 5
403796df:	888a      	add.n	a8, a8, a8
403796e1:	2b0c      	movi.n	a11, 2
403796e3:	1088b0        	and	a8, a8, a11
403796e6:	208980        	or	a8, a9, a8
403796e9:	0020c0        	memw
403796ec:	0a89      	s32i.n	a8, a10, 0
    }
}
403796ee:	f01d      	retw.n

403796f0 <esp_rom_install_uart_printf>:
    }
}

#if ESP_ROM_HAS_ETS_PRINTF_BUG
void esp_rom_install_uart_printf(void)
{
403796f0:	004136        	entry	a1, 32
#if !ESP_ROM_HAS_OUTPUT_TO_CHANNELS_FUNC
    _putc1 = esp_rom_output_putc;
403796f3:	ecfe81        	l32r	a8, 40374aec <_iram_text_start+0x6e8> (3fc91f34 <_putc1>)
403796f6:	ecfe91        	l32r	a9, 40374af0 <_iram_text_start+0x6ec> (400006b4 <esp_rom_output_putc>)
403796f9:	0899      	s32i.n	a9, a8, 0
    extern void ets_install_uart_printf(void);
    extern bool g_uart_print;
    extern bool g_usb_print;
    // If ROM log is disabled permanently via eFuse or temporarily via RTC storage register,
    // this ROM symbol will be set to false, and cause ``esp_rom_printf`` can't work on esp-idf side.
    g_uart_print = true;
403796fb:	01a082        	movi	a8, 1
403796fe:	ecfd91        	l32r	a9, 40374af4 <_iram_text_start+0x6f0> (3fceffb9 <g_uart_print>)
40379701:	004982        	s8i	a8, a9, 0
    g_usb_print = true;
40379704:	ecfd91        	l32r	a9, 40374af8 <_iram_text_start+0x6f4> (3fceffb8 <g_usb_print>)
40379707:	004982        	s8i	a8, a9, 0
    ets_install_uart_printf();
4037970a:	ecfc81        	l32r	a8, 40374afc <_iram_text_start+0x6f8> (400005e8 <ets_install_uart_printf>)
4037970d:	0008e0        	callx8	a8
#endif // !CONFIG_IDF_TARGET_LINUX
}
40379710:	f01d      	retw.n
	...

40379714 <esp_error_check_failed_print>:
    return return_address;
}
#endif

static void esp_error_check_failed_print(const char *msg, esp_err_t rc, const char *file, int line, const char *function, const char *expression, intptr_t addr)
{
40379714:	004136        	entry	a1, 32
40379717:	02bd      	mov.n	a11, a2
    esp_rom_printf("%s failed: esp_err_t 0x%x", msg, rc);
40379719:	03cd      	mov.n	a12, a3
4037971b:	ecf9a1        	l32r	a10, 40374b00 <_iram_text_start+0x6fc> (3fc93dc8 <__FUNCTION__$0+0x630>)
4037971e:	eb6581        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40379721:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" (%s)", esp_err_to_name(rc));
40379724:	20a330        	or	a10, a3, a3
40379727:	eb6d81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (420027bc <esp_err_to_name>)
4037972a:	0008e0        	callx8	a8
4037972d:	20baa0        	or	a11, a10, a10
40379730:	ecf5a1        	l32r	a10, 40374b04 <_iram_text_start+0x700> (3fc93de4 <__FUNCTION__$0+0x64c>)
40379733:	eb6081        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40379736:	0008e0        	callx8	a8
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" at 0x%08x\n", esp_cpu_get_call_addr(addr));
40379739:	81b8      	l32i.n	a11, a1, 32
4037973b:	fdcbb2        	addi	a11, a11, -3
4037973e:	ecf2a1        	l32r	a10, 40374b08 <_iram_text_start+0x704> (3fc93dec <__FUNCTION__$0+0x654>)
40379741:	eb5c81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40379744:	0008e0        	callx8	a8
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    if (spi_flash_cache_enabled())  // strings may be in flash cache
40379747:	fe3165        	call8	40377a5c <spi_flash_cache_enabled>
4037974a:	fa8c      	beqz.n	a10, 4037975d <esp_error_check_failed_print+0x49>
#endif
    {
        esp_rom_printf("file: \"%s\" line %d\nfunc: %s\nexpression: %s\n", file, line, function, expression);
4037974c:	07ed      	mov.n	a14, a7
4037974e:	06dd      	mov.n	a13, a6
40379750:	05cd      	mov.n	a12, a5
40379752:	04bd      	mov.n	a11, a4
40379754:	eceea1        	l32r	a10, 40374b0c <_iram_text_start+0x708> (3fc93df8 <__FUNCTION__$0+0x660>)
40379757:	eb5781        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4037975a:	0008e0        	callx8	a8
    }
}
4037975d:	f01d      	retw.n
	...

40379760 <_esp_error_check_failed>:
{
    esp_error_check_failed_print("ESP_ERROR_CHECK_WITHOUT_ABORT", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
}

void _esp_error_check_failed(esp_err_t rc, const char *file, int line, const char *function, const char *expression)
{
40379760:	006136        	entry	a1, 48
40379763:	02bd      	mov.n	a11, a2
40379765:	03cd      	mov.n	a12, a3
40379767:	04dd      	mov.n	a13, a4
40379769:	05ed      	mov.n	a14, a5
4037976b:	06fd      	mov.n	a15, a6
    esp_error_check_failed_print("ESP_ERROR_CHECK", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
4037976d:	ece891        	l32r	a9, 40374b10 <_iram_text_start+0x70c> (4037976d <_esp_error_check_failed+0xd>)
40379770:	159e90        	extui	a9, a9, 30, 2
40379773:	019920        	slli	a9, a9, 30
40379776:	1180e0        	slli	a8, a0, 2
40379779:	418280        	srli	a8, a8, 2
4037977c:	208890        	or	a8, a8, a9
4037977f:	0189      	s32i.n	a8, a1, 0
40379781:	ece4a1        	l32r	a10, 40374b14 <_iram_text_start+0x710> (3fc93e24 <__FUNCTION__$0+0x68c>)
40379784:	fff8e5        	call8	40379714 <esp_error_check_failed_print>
    abort();
40379787:	0650e5        	call8	4037fc94 <abort>
	...

4037978c <esp_system_abort>:
{
    return IDF_VER;
}

void __attribute__((noreturn)) esp_system_abort(const char *details)
{
4037978c:	004136        	entry	a1, 32
4037978f:	02ad      	mov.n	a10, a2
    panic_abort(details);
40379791:	fc1c65        	call8	40375958 <panic_abort>

40379794 <__ubsan_include>:
    __ubsan_default_handler(&data->loc, __func__);
}

/* Hook for the linker to include this object file */
void __ubsan_include(void)
{
40379794:	004136        	entry	a1, 32
}
40379797:	f01d      	retw.n
40379799:	000000        	ill

4037979c <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
4037979c:	004136        	entry	a1, 32
4037979f:	207220        	or	a7, a2, a2
403797a2:	20b330        	or	a11, a3, a3
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
403797a5:	0020c0        	memw
403797a8:	0e2262        	l32i	a6, a2, 56

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
403797ab:	1022c2        	l32i	a12, a2, 64
403797ae:	2cdc      	bnez.n	a12, 403797c4 <prvCopyDataToQueue+0x28>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
403797b0:	0288      	l32i.n	a8, a2, 0
403797b2:	05b856        	bnez	a8, 40379811 <prvCopyDataToQueue+0x75>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
403797b5:	22a8      	l32i.n	a10, a2, 8
403797b7:	026de5        	call8	4037be94 <xTaskPriorityDisinherit>
403797ba:	0a2d      	mov.n	a2, a10
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
403797bc:	080c      	movi.n	a8, 0
403797be:	2789      	s32i.n	a8, a7, 8
403797c0:	0017c6        	j	40379823 <prvCopyDataToQueue+0x87>
403797c3:	d4dc00        	extui	a13, a0, 12, 14
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
403797c6:	12a8      	l32i.n	a10, a2, 4
403797c8:	eb4381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403797cb:	0008e0        	callx8	a8
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
403797ce:	1288      	l32i.n	a8, a2, 4
403797d0:	102292        	l32i	a9, a2, 64
403797d3:	889a      	add.n	a8, a8, a9
403797d5:	1289      	s32i.n	a8, a2, 4

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
403797d7:	2298      	l32i.n	a9, a2, 8
403797d9:	393897        	bltu	a8, a9, 40379816 <prvCopyDataToQueue+0x7a>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
403797dc:	0288      	l32i.n	a8, a2, 0
403797de:	1289      	s32i.n	a8, a2, 4
    BaseType_t xReturn = pdFALSE;
403797e0:	042d      	mov.n	a2, a4
403797e2:	000f46        	j	40379823 <prvCopyDataToQueue+0x87>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
403797e5:	32a8      	l32i.n	a10, a2, 12
403797e7:	eb3b81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403797ea:	0008e0        	callx8	a8
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
403797ed:	3288      	l32i.n	a8, a2, 12
403797ef:	102292        	l32i	a9, a2, 64
403797f2:	60a090        	neg	a10, a9
403797f5:	c08890        	sub	a8, a8, a9
403797f8:	3289      	s32i.n	a8, a2, 12

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
403797fa:	0298      	l32i.n	a9, a2, 0
403797fc:	05b897        	bgeu	a8, a9, 40379805 <prvCopyDataToQueue+0x69>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
403797ff:	2288      	l32i.n	a8, a2, 8
40379801:	88aa      	add.n	a8, a8, a10
40379803:	3289      	s32i.n	a8, a2, 12
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
40379805:	132466        	bnei	a4, 2, 4037981c <prvCopyDataToQueue+0x80>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
40379808:	569c      	beqz.n	a6, 40379821 <prvCopyDataToQueue+0x85>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
4037980a:	660b      	addi.n	a6, a6, -1
    BaseType_t xReturn = pdFALSE;
4037980c:	020c      	movi.n	a2, 0
4037980e:	000446        	j	40379823 <prvCopyDataToQueue+0x87>
40379811:	020c      	movi.n	a2, 0
40379813:	000306        	j	40379823 <prvCopyDataToQueue+0x87>
40379816:	042d      	mov.n	a2, a4
40379818:	0001c6        	j	40379823 <prvCopyDataToQueue+0x87>
4037981b:	020c00        	andb	b0, b12, b0
4037981e:	000046        	j	40379823 <prvCopyDataToQueue+0x87>
40379821:	020c      	movi.n	a2, 0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
40379823:	661b      	addi.n	a6, a6, 1
40379825:	0020c0        	memw
40379828:	e769      	s32i.n	a6, a7, 56

    return xReturn;
}
4037982a:	f01d      	retw.n

4037982c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
4037982c:	004136        	entry	a1, 32
4037982f:	03ad      	mov.n	a10, a3
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
40379831:	1022c2        	l32i	a12, a2, 64
40379834:	5c9c      	beqz.n	a12, 4037984d <prvCopyDataFromQueue+0x21>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
40379836:	3288      	l32i.n	a8, a2, 12
40379838:	88ca      	add.n	a8, a8, a12
4037983a:	3289      	s32i.n	a8, a2, 12

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
4037983c:	2298      	l32i.n	a9, a2, 8
4037983e:	033897        	bltu	a8, a9, 40379845 <prvCopyDataFromQueue+0x19>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
40379841:	0288      	l32i.n	a8, a2, 0
40379843:	3289      	s32i.n	a8, a2, 12
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
40379845:	32b8      	l32i.n	a11, a2, 12
40379847:	eb2381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037984a:	0008e0        	callx8	a8
    }
}
4037984d:	f01d      	retw.n
	...

40379850 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
40379850:	006136        	entry	a1, 48
40379853:	0129      	s32i.n	a2, a1, 0
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
40379855:	122272        	l32i	a7, a2, 72
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
40379858:	d7cc      	bnez.n	a7, 40379869 <prvNotifyQueueSetContainer+0x19>
4037985a:	ecafd1        	l32r	a13, 40374b18 <_iram_text_start+0x714> (3c024180 <_flash_rodata_start+0x4060>)
4037985d:	ecafc1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c027f14 <__func__$13>)
40379860:	ecb0b1        	l32r	a11, 40374b20 <_iram_text_start+0x71c> (d21 <UserFrameTotalSize+0xc21>)
40379863:	ecb0a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379866:	064ea5        	call8	4037fd50 <__assert_func>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
40379869:	0020c0        	memw
4037986c:	e798      	l32i.n	a9, a7, 56
4037986e:	f788      	l32i.n	a8, a7, 60
40379870:	113987        	bltu	a9, a8, 40379885 <prvNotifyQueueSetContainer+0x35>
40379873:	ecadd1        	l32r	a13, 40374b28 <_iram_text_start+0x724> (3c0241c8 <_flash_rodata_start+0x40a8>)
40379876:	eca9c1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c027f14 <__func__$13>)
40379879:	ecacb1        	l32r	a11, 40374b2c <_iram_text_start+0x728> (d22 <UserFrameTotalSize+0xc22>)
4037987c:	ecaaa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
4037987f:	201110        	or	a1, a1, a1
40379882:	064ce5        	call8	4037fd50 <__assert_func>

        /* In SMP, queue sets have their own xQueueLock. Thus we need to also
         * acquire the queue set's xQueueLock before accessing it. */
        prvENTER_CRITICAL_SAFE_SMP_ONLY( &( pxQueueSetContainer->xQueueLock ) );
40379885:	4cc762        	addi	a6, a7, 76
    #define prvEXIT_CRITICAL_SAFE_SMP_ONLY( pxLock )     prvTaskExitCriticalSafeSMPOnly( pxLock )

    static inline __attribute__( ( always_inline ) )
    void prvTaskEnterCriticalSafeSMPOnly( portMUX_TYPE * pxLock )
    {
        if( portCHECK_IF_IN_ISR() == pdFALSE )
40379888:	008825        	call8	4037a10c <xPortInIsrContext>
4037988b:	bacc      	bnez.n	a10, 4037989a <prvNotifyQueueSetContainer+0x4a>
4037988d:	ffafb2        	movi	a11, -1
40379890:	06ad      	mov.n	a10, a6
40379892:	0089e5        	call8	4037a130 <xPortEnterCriticalTimeout>
}
40379895:	000246        	j	403798a2 <prvNotifyQueueSetContainer+0x52>
40379898:	b20000        	mulsh	a0, a0, a0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037989b:	af          	.byte	0xaf
4037989c:	ff          	.byte	0xff
4037989d:	06ad      	mov.n	a10, a6
4037989f:	008925        	call8	4037a130 <xPortEnterCriticalTimeout>
        {
            if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
403798a2:	0020c0        	memw
403798a5:	e798      	l32i.n	a9, a7, 56
403798a7:	f788      	l32i.n	a8, a7, 60
403798a9:	1cb987        	bgeu	a9, a8, 403798c9 <prvNotifyQueueSetContainer+0x79>
                #endif /* queueUSE_LOCKS == 1 */

                traceQUEUE_SET_SEND( pxQueueSetContainer );

                /* The data copied is the handle of the queue that contains data. */
                xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
403798ac:	0c0c      	movi.n	a12, 0
403798ae:	01bd      	mov.n	a11, a1
403798b0:	07ad      	mov.n	a10, a7
403798b2:	ffeea5        	call8	4037979c <prvCopyDataToQueue>
403798b5:	0a2d      	mov.n	a2, a10

                if( cTxLock == queueUNLOCKED )
                {
                    if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
403798b7:	0020c0        	memw
403798ba:	9788      	l32i.n	a8, a7, 36
403798bc:	189c      	beqz.n	a8, 403798d1 <prvNotifyQueueSetContainer+0x81>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
403798be:	24c7a2        	addi	a10, a7, 36
403798c1:	01cfe5        	call8	4037b5c0 <xTaskRemoveFromEventList>
403798c4:	6acc      	bnez.n	a10, 403798ce <prvNotifyQueueSetContainer+0x7e>
403798c6:	0001c6        	j	403798d1 <prvNotifyQueueSetContainer+0x81>
        BaseType_t xReturn = pdFALSE;
403798c9:	020c      	movi.n	a2, 0
403798cb:	000086        	j	403798d1 <prvNotifyQueueSetContainer+0x81>
                        {
                            /* The task waiting has a higher priority. */
                            xReturn = pdTRUE;
403798ce:	01a022        	movi	a2, 1
    }

    static inline __attribute__( ( always_inline ) )
    void prvTaskExitCriticalSafeSMPOnly( portMUX_TYPE * pxLock )
    {
        if( portCHECK_IF_IN_ISR() == pdFALSE )
403798d1:	0083a5        	call8	4037a10c <xPortInIsrContext>
403798d4:	008a56        	bnez	a10, 403798e0 <prvNotifyQueueSetContainer+0x90>
        {
            taskEXIT_CRITICAL( pxLock );
403798d7:	06ad      	mov.n	a10, a6
403798d9:	009a65        	call8	4037a280 <vPortExitCritical>
403798dc:	000146        	j	403798e5 <prvNotifyQueueSetContainer+0x95>
403798df:	06ad00        	lsi	f0, a13, 24
        {
            #ifdef __clang_analyzer__
                /* Teach clang-tidy that ISR version macro can be different */
                configASSERT( 1 );
            #endif
            taskEXIT_CRITICAL_ISR( pxLock );
403798e2:	0099e5        	call8	4037a280 <vPortExitCritical>
        }
        /* Release the previously acquired queue set's xQueueLock. */
        prvEXIT_CRITICAL_SAFE_SMP_ONLY( &( pxQueueSetContainer->xQueueLock ) );

        return xReturn;
    }
403798e5:	f01d      	retw.n
	...

403798e8 <xQueueGenericReset>:
{
403798e8:	004136        	entry	a1, 32
    configASSERT( pxQueue );
403798eb:	00e256        	bnez	a2, 403798fd <xQueueGenericReset+0x15>
403798ee:	ec90d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
403798f1:	ec90c1        	l32r	a12, 40374b34 <_iram_text_start+0x730> (3c027fd8 <__func__$25>)
403798f4:	4da1b2        	movi	a11, 0x14d
403798f7:	ec8ba1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
403798fa:	064565        	call8	4037fd50 <__assert_func>
    if( xNewQueue == pdTRUE )
403798fd:	101366        	bnei	a3, 1, 40379911 <xQueueGenericReset+0x29>
 */
static inline void __attribute__((always_inline)) spinlock_initialize(spinlock_t *lock)
{
    assert(lock);
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    lock->owner = SPINLOCK_FREE;
40379900:	ec8e81        	l32r	a8, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
40379903:	136282        	s32i	a8, a2, 76
    lock->count = 0;
40379906:	080c      	movi.n	a8, 0
40379908:	146282        	s32i	a8, a2, 80
    if( ( pxQueue != NULL ) &&
4037990b:	000146        	j	40379914 <xQueueGenericReset+0x2c>
4037990e:	000000        	ill
40379911:	06c216        	beqz	a2, 40379981 <xQueueGenericReset+0x99>
        ( pxQueue->uxLength >= 1U ) &&
40379914:	f288      	l32i.n	a8, a2, 60
    if( ( pxQueue != NULL ) &&
40379916:	067816        	beqz	a8, 40379981 <xQueueGenericReset+0x99>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
40379919:	1022a2        	l32i	a10, a2, 64
4037991c:	090c      	movi.n	a9, 0
4037991e:	a288a0        	muluh	a8, a8, a10
40379921:	088c      	beqz.n	a8, 40379925 <xQueueGenericReset+0x3d>
40379923:	190c      	movi.n	a9, 1
        ( pxQueue->uxLength >= 1U ) &&
40379925:	058956        	bnez	a9, 40379981 <xQueueGenericReset+0x99>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379928:	4cc272        	addi	a7, a2, 76
4037992b:	fb7c      	movi.n	a11, -1
4037992d:	07ad      	mov.n	a10, a7
4037992f:	008025        	call8	4037a130 <xPortEnterCriticalTimeout>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
40379932:	0288      	l32i.n	a8, a2, 0
40379934:	f2a8      	l32i.n	a10, a2, 60
40379936:	102292        	l32i	a9, a2, 64
40379939:	82ba90        	mull	a11, a10, a9
4037993c:	b8ba      	add.n	a11, a8, a11
4037993e:	22b9      	s32i.n	a11, a2, 8
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
40379940:	0b0c      	movi.n	a11, 0
40379942:	0020c0        	memw
40379945:	e2b9      	s32i.n	a11, a2, 56
            pxQueue->pcWriteTo = pxQueue->pcHead;
40379947:	1289      	s32i.n	a8, a2, 4
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
40379949:	aa0b      	addi.n	a10, a10, -1
4037994b:	8299a0        	mull	a9, a9, a10
4037994e:	889a      	add.n	a8, a8, a9
40379950:	3289      	s32i.n	a8, a2, 12
            if( xNewQueue == pdFALSE )
40379952:	a3dc      	bnez.n	a3, 40379970 <xQueueGenericReset+0x88>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379954:	0020c0        	memw
40379957:	4288      	l32i.n	a8, a2, 16
40379959:	033816        	beqz	a8, 40379990 <xQueueGenericReset+0xa8>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037995c:	10c2a2        	addi	a10, a2, 16
4037995f:	01c625        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379962:	aaac      	beqz.n	a10, 40379990 <xQueueGenericReset+0xa8>
    asm volatile (
40379964:	03eba0        	rsr.prid	a10
40379967:	04ada0        	extui	a10, a10, 13, 1
                        queueYIELD_IF_USING_PREEMPTION();
4037996a:	fe7625        	call8	403780cc <esp_crosscore_int_send_yield>
4037996d:	0007c6        	j	40379990 <xQueueGenericReset+0xa8>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
40379970:	10c2a2        	addi	a10, a2, 16
40379973:	00f5a5        	call8	4037a8cc <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
40379976:	24c2a2        	addi	a10, a2, 36
40379979:	00f525        	call8	4037a8cc <vListInitialise>
4037997c:	000406        	j	40379990 <xQueueGenericReset+0xa8>
4037997f:	d10000        	mul16s	a0, a0, a0
    configASSERT( xReturn != pdFAIL );
40379982:	6e          	.byte	0x6e
40379983:	c1ec      	bnez.n	a1, 403799b3 <prvInitialiseNewQueue+0x17>
40379985:	ec6c      	movi.n	a12, -18
40379987:	8ba1b2        	movi	a11, 0x18b
4037998a:	ec66a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
4037998d:	063c25        	call8	4037fd50 <__assert_func>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379990:	20a770        	or	a10, a7, a7
40379993:	008ee5        	call8	4037a280 <vPortExitCritical>
}
40379996:	01a022        	movi	a2, 1
40379999:	f01d      	retw.n
	...

4037999c <prvInitialiseNewQueue>:
{
4037999c:	004136        	entry	a1, 32
    if( uxItemSize == ( UBaseType_t ) 0 )
4037999f:	33cc      	bnez.n	a3, 403799a6 <prvInitialiseNewQueue+0xa>
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
403799a1:	0669      	s32i.n	a6, a6, 0
403799a3:	000046        	j	403799a8 <prvInitialiseNewQueue+0xc>
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
403799a6:	0649      	s32i.n	a4, a6, 0
    pxNewQueue->uxLength = uxQueueLength;
403799a8:	f629      	s32i.n	a2, a6, 60
    pxNewQueue->uxItemSize = uxItemSize;
403799aa:	106632        	s32i	a3, a6, 64
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
403799ad:	1b0c      	movi.n	a11, 1
403799af:	06ad      	mov.n	a10, a6
403799b1:	fff365        	call8	403798e8 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
403799b4:	080c      	movi.n	a8, 0
403799b6:	126682        	s32i	a8, a6, 72
}
403799b9:	f01d      	retw.n
	...

403799bc <xQueueGenericCreateStatic>:
    {
403799bc:	006136        	entry	a1, 48
403799bf:	02ad      	mov.n	a10, a2
403799c1:	03bd      	mov.n	a11, a3
403799c3:	04cd      	mov.n	a12, a4
403799c5:	052d      	mov.n	a2, a5
403799c7:	74d060        	extui	a13, a6, 0, 8
        configASSERT( pxStaticQueue );
403799ca:	180c      	movi.n	a8, 1
403799cc:	838550        	moveqz	a8, a5, a5
403799cf:	d5cc      	bnez.n	a5, 403799e0 <xQueueGenericCreateStatic+0x24>
403799d1:	ec5bd1        	l32r	a13, 40374b40 <_iram_text_start+0x73c> (3c02423c <_flash_rodata_start+0x411c>)
403799d4:	ec5cc1        	l32r	a12, 40374b44 <_iram_text_start+0x740> (3c027fa8 <__func__$23>)
403799d7:	9fa1b2        	movi	a11, 0x19f
403799da:	ec52a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
403799dd:	063725        	call8	4037fd50 <__assert_func>
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
403799e0:	01a092        	movi	a9, 1
403799e3:	839aa0        	moveqz	a9, a10, a10
403799e6:	400897        	bnone	a8, a9, 40379a2a <xQueueGenericCreateStatic+0x6e>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
403799e9:	40f480        	nsau	a8, a4
403799ec:	418580        	srli	a8, a8, 5
403799ef:	190c      	movi.n	a9, 1
403799f1:	839330        	moveqz	a9, a3, a3
403799f4:	208890        	or	a8, a8, a9
            ( pxStaticQueue != NULL ) &&
403799f7:	f8ac      	beqz.n	a8, 40379a2a <xQueueGenericCreateStatic+0x6e>
            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
403799f9:	180c      	movi.n	a8, 1
403799fb:	838440        	moveqz	a8, a4, a4
403799fe:	40f390        	nsau	a9, a3
40379a01:	419590        	srli	a9, a9, 5
40379a04:	208890        	or	a8, a8, a9
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
40379a07:	f89c      	beqz.n	a8, 40379a2a <xQueueGenericCreateStatic+0x6e>
                volatile size_t xSize = sizeof( StaticQueue_t );
40379a09:	485c      	movi.n	a8, 84
40379a0b:	0020c0        	memw
40379a0e:	0189      	s32i.n	a8, a1, 0
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
40379a10:	0020c0        	memw
40379a13:	002182        	l32i	a8, a1, 0
40379a16:	acc882        	addi	a8, a8, -84
40379a19:	c89c      	beqz.n	a8, 40379a39 <xQueueGenericCreateStatic+0x7d>
40379a1b:	ec4bd1        	l32r	a13, 40374b48 <_iram_text_start+0x744> (3c02424c <_flash_rodata_start+0x412c>)
40379a1e:	ec49c1        	l32r	a12, 40374b44 <_iram_text_start+0x740> (3c027fa8 <__func__$23>)
40379a21:	b1a1b2        	movi	a11, 0x1b1
40379a24:	ec40a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379a27:	0632a5        	call8	4037fd50 <__assert_func>
            configASSERT( pxNewQueue );
40379a2a:	ec48d1        	l32r	a13, 40374b4c <_iram_text_start+0x748> (3c024268 <_flash_rodata_start+0x4148>)
40379a2d:	ec45c1        	l32r	a12, 40374b44 <_iram_text_start+0x740> (3c027fa8 <__func__$23>)
40379a30:	c8a1b2        	movi	a11, 0x1c8
40379a33:	ec3ca1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379a36:	0631a5        	call8	4037fd50 <__assert_func>
                ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
40379a39:	0020c0        	memw
40379a3c:	0188      	l32i.n	a8, a1, 0
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
40379a3e:	180c      	movi.n	a8, 1
40379a40:	444582        	s8i	a8, a5, 68
            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
40379a43:	05ed      	mov.n	a14, a5
40379a45:	fff565        	call8	4037999c <prvInitialiseNewQueue>
    }
40379a48:	f01d      	retw.n
	...

40379a4c <xQueueGenericCreate>:
    {
40379a4c:	004136        	entry	a1, 32
40379a4f:	027d      	mov.n	a7, a2
40379a51:	744040        	extui	a4, a4, 0, 8
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
40379a54:	42bc      	beqz.n	a2, 40379a8c <xQueueGenericCreate+0x40>
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
40379a56:	080c      	movi.n	a8, 0
40379a58:	a29230        	muluh	a9, a2, a3
40379a5b:	001916        	beqz	a9, 40379a60 <xQueueGenericCreate+0x14>
40379a5e:	180c      	movi.n	a8, 1
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
40379a60:	88ec      	bnez.n	a8, 40379a8c <xQueueGenericCreate+0x40>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
40379a62:	82a730        	mull	a10, a7, a3
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
40379a65:	abaf82        	movi	a8, -85
40379a68:	2038a7        	bltu	a8, a10, 40379a8c <xQueueGenericCreate+0x40>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
40379a6b:	54caa2        	addi	a10, a10, 84
40379a6e:	00b265        	call8	4037a594 <pvPortMalloc>
40379a71:	0a2d      	mov.n	a2, a10
            if( pxNewQueue != NULL )
40379a73:	7aac      	beqz.n	a10, 40379a9e <xQueueGenericCreate+0x52>
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
40379a75:	080c      	movi.n	a8, 0
40379a77:	444a82        	s8i	a8, a10, 68
                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
40379a7a:	0aed      	mov.n	a14, a10
40379a7c:	04dd      	mov.n	a13, a4
40379a7e:	54cac2        	addi	a12, a10, 84
40379a81:	03bd      	mov.n	a11, a3
40379a83:	07ad      	mov.n	a10, a7
40379a85:	fff165        	call8	4037999c <prvInitialiseNewQueue>
40379a88:	000486        	j	40379a9e <xQueueGenericCreate+0x52>
40379a8b:	30d100        	xor	a13, a1, a0
            configASSERT( pxNewQueue );
40379a8e:	c1ec      	bnez.n	a1, 40379abe <xQueueGetMutexHolder+0x1e>
40379a90:	b2ec30        	mulsh	a14, a12, a3
40379a93:	a13da2        	lsi	f10, a13, 0x284
40379a96:	10ec23        	lsi	f2, a12, 64
40379a99:	652011        	l32r	a1, 40352f1c <rom_rx_gain_force+0x34caf0>
40379a9c:	062b      	addi.n	a0, a6, 2
    }
40379a9e:	f01d      	retw.n

40379aa0 <xQueueGetMutexHolder>:
    {
40379aa0:	004136        	entry	a1, 32
        configASSERT( xSemaphore );
40379aa3:	00e256        	bnez	a2, 40379ab5 <xQueueGetMutexHolder+0x15>
40379aa6:	ec2bd1        	l32r	a13, 40374b54 <_iram_text_start+0x750> (3c024274 <_flash_rodata_start+0x4154>)
40379aa9:	ec2bc1        	l32r	a12, 40374b58 <_iram_text_start+0x754> (3c027f7c <__func__$20>)
40379aac:	c2a2b2        	movi	a11, 0x2c2
40379aaf:	ec1da1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ab2:	0629e5        	call8	4037fd50 <__assert_func>
        taskENTER_CRITICAL( &( pxSemaphore->xQueueLock ) );
40379ab5:	4cc272        	addi	a7, a2, 76
40379ab8:	fb7c      	movi.n	a11, -1
40379aba:	20a770        	or	a10, a7, a7
40379abd:	006725        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
40379ac0:	002282        	l32i	a8, a2, 0
40379ac3:	38cc      	bnez.n	a8, 40379aca <xQueueGetMutexHolder+0x2a>
                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
40379ac5:	2228      	l32i.n	a2, a2, 8
40379ac7:	000086        	j	40379acd <xQueueGetMutexHolder+0x2d>
                pxReturn = NULL;
40379aca:	00a022        	movi	a2, 0
        taskEXIT_CRITICAL( &( pxSemaphore->xQueueLock ) );
40379acd:	20a770        	or	a10, a7, a7
40379ad0:	007ae5        	call8	4037a280 <vPortExitCritical>
    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
40379ad3:	000090        	retw
	...

40379ad8 <xQueueGenericSend>:
{
40379ad8:	008136        	entry	a1, 64
40379adb:	4149      	s32i.n	a4, a1, 16
    configASSERT( pxQueue );
40379add:	02dc      	bnez.n	a2, 40379af1 <xQueueGenericSend+0x19>
40379adf:	ec14d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379ae2:	ec1ec1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c027f30 <__func__$14>)
40379ae5:	a8a3b2        	movi	a11, 0x3a8
40379ae8:	ec0fa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379aeb:	201110        	or	a1, a1, a1
40379aee:	062625        	call8	4037fd50 <__assert_func>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
40379af1:	014356        	bnez	a3, 40379b09 <xQueueGenericSend+0x31>
40379af4:	102282        	l32i	a8, a2, 64
40379af7:	00e816        	beqz	a8, 40379b09 <xQueueGenericSend+0x31>
40379afa:	ec19d1        	l32r	a13, 40374b60 <_iram_text_start+0x75c> (3c024280 <_flash_rodata_start+0x4160>)
40379afd:	ec17c1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c027f30 <__func__$14>)
40379b00:	a9a3b2        	movi	a11, 0x3a9
40379b03:	ec08a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379b06:	0624a5        	call8	4037fd50 <__assert_func>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
40379b09:	132566        	bnei	a5, 2, 40379b20 <xQueueGenericSend+0x48>
40379b0c:	f288      	l32i.n	a8, a2, 60
40379b0e:	0e1826        	beqi	a8, 1, 40379b20 <xQueueGenericSend+0x48>
40379b11:	ec14d1        	l32r	a13, 40374b64 <_iram_text_start+0x760> (3c0242d8 <_flash_rodata_start+0x41b8>)
40379b14:	ec12c1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c027f30 <__func__$14>)
40379b17:	aaa3b2        	movi	a11, 0x3aa
40379b1a:	ec02a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379b1d:	062325        	call8	4037fd50 <__assert_func>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
40379b20:	01f0a5        	call8	4037ba2c <xTaskGetSchedulerState>
40379b23:	160c      	movi.n	a6, 1
40379b25:	836aa0        	moveqz	a6, a10, a10
40379b28:	2adc      	bnez.n	a10, 40379b3e <xQueueGenericSend+0x66>
40379b2a:	4188      	l32i.n	a8, a1, 16
40379b2c:	010816        	beqz	a8, 40379b40 <xQueueGenericSend+0x68>
40379b2f:	ec0ed1        	l32r	a13, 40374b68 <_iram_text_start+0x764> (3c024328 <_flash_rodata_start+0x4208>)
40379b32:	ec0ac1        	l32r	a12, 40374b5c <_iram_text_start+0x758> (3c027f30 <__func__$14>)
40379b35:	ada3b2        	movi	a11, 0x3ad
40379b38:	ebfba1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379b3b:	062165        	call8	4037fd50 <__assert_func>
40379b3e:	060c      	movi.n	a6, 0
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379b40:	4cc272        	addi	a7, a2, 76
40379b43:	fb7c      	movi.n	a11, -1
40379b45:	07ad      	mov.n	a10, a7
40379b47:	005ea5        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
40379b4a:	0020c0        	memw
40379b4d:	0e2292        	l32i	a9, a2, 56
40379b50:	0f2282        	l32i	a8, a2, 60
40379b53:	023987        	bltu	a9, a8, 40379b59 <xQueueGenericSend+0x81>
40379b56:	6e2566        	bnei	a5, 2, 40379bc8 <xQueueGenericSend+0xf0>
                    const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
40379b59:	0020c0        	memw
40379b5c:	e268      	l32i.n	a6, a2, 56
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
40379b5e:	05cd      	mov.n	a12, a5
40379b60:	03bd      	mov.n	a11, a3
40379b62:	02ad      	mov.n	a10, a2
40379b64:	ffc365        	call8	4037979c <prvCopyDataToQueue>
                    if( pxQueue->pxQueueSetContainer != NULL )
40379b67:	122282        	l32i	a8, a2, 72
40379b6a:	38ac      	beqz.n	a8, 40379b91 <xQueueGenericSend+0xb9>
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
40379b6c:	fec552        	addi	a5, a5, -2
40379b6f:	40f550        	nsau	a5, a5
40379b72:	415550        	srli	a5, a5, 5
40379b75:	01a082        	movi	a8, 1
40379b78:	838660        	moveqz	a8, a6, a6
40379b7b:	3d8587        	bany	a5, a8, 40379bbc <xQueueGenericSend+0xe4>
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
40379b7e:	02ad      	mov.n	a10, a2
40379b80:	ffcce5        	call8	40379850 <prvNotifyQueueSetContainer>
40379b83:	5abc      	beqz.n	a10, 40379bbc <xQueueGenericSend+0xe4>
40379b85:	03eba0        	rsr.prid	a10
40379b88:	04ada0        	extui	a10, a10, 13, 1
                            queueYIELD_IF_USING_PREEMPTION();
40379b8b:	fe5425        	call8	403780cc <esp_crosscore_int_send_yield>
40379b8e:	000a86        	j	40379bbc <xQueueGenericSend+0xe4>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
40379b91:	0020c0        	memw
40379b94:	092282        	l32i	a8, a2, 36
40379b97:	015816        	beqz	a8, 40379bb0 <xQueueGenericSend+0xd8>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
40379b9a:	24c2a2        	addi	a10, a2, 36
40379b9d:	01a225        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379ba0:	018a16        	beqz	a10, 40379bbc <xQueueGenericSend+0xe4>
40379ba3:	03eba0        	rsr.prid	a10
40379ba6:	04ada0        	extui	a10, a10, 13, 1
                                queueYIELD_IF_USING_PREEMPTION();
40379ba9:	fe5225        	call8	403780cc <esp_crosscore_int_send_yield>
40379bac:	000306        	j	40379bbc <xQueueGenericSend+0xe4>
40379baf:	8a1600        	round.s	a1, f6, 0
                        else if( xYieldRequired != pdFALSE )
40379bb2:	eba000        	f64cmpl	a10, a0, a0
40379bb5:	ada003        	lsi	f0, a0, 0x2b4
40379bb8:	512504        	lsi	f0, a5, 0x144
                            queueYIELD_IF_USING_PREEMPTION();
40379bbb:	fe          	.byte	0xfe
                taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379bbc:	20a770        	or	a10, a7, a7
40379bbf:	006c25        	call8	4037a280 <vPortExitCritical>
                return pdPASS;
40379bc2:	120c      	movi.n	a2, 1
40379bc4:	001246        	j	40379c11 <xQueueGenericSend+0x139>
40379bc7:	218200        	srai	a8, a0, 2
                if( xTicksToWait == ( TickType_t ) 0 )
40379bca:	b85604        	lsi	f0, a6, 0x2e0
40379bcd:	a77000        	lsi	f0, a0, 0x29c
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379bd0:	6ae520        	maddn.s	f14, f5, f2
40379bd3:	020c00        	andb	b0, b12, b0
                    return errQUEUE_FULL;
40379bd6:	000dc6        	j	40379c11 <xQueueGenericSend+0x139>
40379bd9:	765600        	lsi	f0, a6, 0x1d8
                else if( xEntryTimeSet == pdFALSE )
40379bdc:	01ad00        	slli	a10, a13, 32
                    vTaskInternalSetTimeOutState( &xTimeOut );
40379bdf:	01bde5        	call8	4037b7bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
40379be2:	01a062        	movi	a6, 1
                if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
40379be5:	10c1b2        	addi	a11, a1, 16
40379be8:	01ad      	mov.n	a10, a1
40379bea:	01bee5        	call8	4037b7d8 <xTaskCheckForTimeOut>
40379bed:	7adc      	bnez.n	a10, 40379c08 <xQueueGenericSend+0x130>
                    vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
40379bef:	41b8      	l32i.n	a11, a1, 16
40379bf1:	10c2a2        	addi	a10, a2, 16
40379bf4:	019825        	call8	4037b578 <vTaskPlaceOnEventList>
40379bf7:	03eba0        	rsr.prid	a10
40379bfa:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
40379bfd:	fe4ce5        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379c00:	07ad      	mov.n	a10, a7
40379c02:	0067e5        	call8	4037a280 <vPortExitCritical>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379c05:	ffcdc6        	j	40379b40 <xQueueGenericSend+0x68>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379c08:	20a770        	or	a10, a7, a7
40379c0b:	006765        	call8	4037a280 <vPortExitCritical>
                    return errQUEUE_FULL;
40379c0e:	00a022        	movi	a2, 0
}
40379c11:	000090        	retw

40379c14 <prvInitialiseMutex>:
    {
40379c14:	004136        	entry	a1, 32
40379c17:	20a220        	or	a10, a2, a2
        if( pxNewQueue != NULL )
40379c1a:	030216        	beqz	a2, 40379c4e <prvInitialiseMutex+0x3a>
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
40379c1d:	00a082        	movi	a8, 0
40379c20:	2289      	s32i.n	a8, a2, 8
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
40379c22:	0289      	s32i.n	a8, a2, 0
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
40379c24:	3289      	s32i.n	a8, a2, 12
            portMUX_INITIALIZE( &( pxNewQueue->xQueueLock ) );
40379c26:	4cc282        	addi	a8, a2, 76
    assert(lock);
40379c29:	c8cc      	bnez.n	a8, 40379c39 <prvInitialiseMutex+0x25>
40379c2b:	ebd0d1        	l32r	a13, 40374b6c <_iram_text_start+0x768> (3c022934 <_flash_rodata_start+0x2814>)
40379c2e:	ebd0c1        	l32r	a12, 40374b70 <_iram_text_start+0x76c> (3c027fc4 <__func__$24>)
40379c31:	5b3c      	movi.n	a11, 53
40379c33:	ebd0a1        	l32r	a10, 40374b74 <_iram_text_start+0x770> (3c022964 <_flash_rodata_start+0x2844>)
40379c36:	0611a5        	call8	4037fd50 <__assert_func>
    lock->owner = SPINLOCK_FREE;
40379c39:	ebbf81        	l32r	a8, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
40379c3c:	136282        	s32i	a8, a2, 76
    lock->count = 0;
40379c3f:	00a0b2        	movi	a11, 0
40379c42:	1462b2        	s32i	a11, a2, 80
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
40379c45:	20dbb0        	or	a13, a11, a11
40379c48:	20cbb0        	or	a12, a11, a11
40379c4b:	ffe8e5        	call8	40379ad8 <xQueueGenericSend>
    }
40379c4e:	f01d      	retw.n

40379c50 <xQueueCreateMutex>:
    {
40379c50:	004136        	entry	a1, 32
        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
40379c53:	74c020        	extui	a12, a2, 0, 8
40379c56:	00a0b2        	movi	a11, 0
40379c59:	01a0a2        	movi	a10, 1
40379c5c:	ffdee5        	call8	40379a4c <xQueueGenericCreate>
40379c5f:	0a2d      	mov.n	a2, a10
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
40379c61:	fffb25        	call8	40379c14 <prvInitialiseMutex>
    }
40379c64:	f01d      	retw.n
	...

40379c68 <xQueueCreateMutexStatic>:
    {
40379c68:	004136        	entry	a1, 32
40379c6b:	20d330        	or	a13, a3, a3
        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
40379c6e:	74e020        	extui	a14, a2, 0, 8
40379c71:	00a0c2        	movi	a12, 0
40379c74:	0cbd      	mov.n	a11, a12
40379c76:	1a0c      	movi.n	a10, 1
40379c78:	ffd425        	call8	403799bc <xQueueGenericCreateStatic>
40379c7b:	0a2d      	mov.n	a2, a10
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
40379c7d:	fff965        	call8	40379c14 <prvInitialiseMutex>
    }
40379c80:	f01d      	retw.n
	...

40379c84 <xQueueGiveMutexRecursive>:
    {
40379c84:	004136        	entry	a1, 32
        configASSERT( pxMutex );
40379c87:	00e256        	bnez	a2, 40379c99 <xQueueGiveMutexRecursive+0x15>
40379c8a:	ebbbd1        	l32r	a13, 40374b78 <_iram_text_start+0x774> (3c02437c <_flash_rodata_start+0x425c>)
40379c8d:	ebbbc1        	l32r	a12, 40374b7c <_iram_text_start+0x778> (3c027f60 <__func__$18>)
40379c90:	fda2b2        	movi	a11, 0x2fd
40379c93:	eba4a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379c96:	060ba5        	call8	4037fd50 <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
40379c99:	2278      	l32i.n	a7, a2, 8
40379c9b:	01bf65        	call8	4037b890 <xTaskGetCurrentTaskHandle>
40379c9e:	1897a7        	bne	a7, a10, 40379cba <xQueueGiveMutexRecursive+0x36>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
40379ca1:	032282        	l32i	a8, a2, 12
40379ca4:	880b      	addi.n	a8, a8, -1
40379ca6:	3289      	s32i.n	a8, a2, 12
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
40379ca8:	38dc      	bnez.n	a8, 40379cbf <xQueueGiveMutexRecursive+0x3b>
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
40379caa:	0d0c      	movi.n	a13, 0
40379cac:	0dcd      	mov.n	a12, a13
40379cae:	0dbd      	mov.n	a11, a13
40379cb0:	02ad      	mov.n	a10, a2
40379cb2:	ffe265        	call8	40379ad8 <xQueueGenericSend>
            xReturn = pdPASS;
40379cb5:	120c      	movi.n	a2, 1
40379cb7:	000186        	j	40379cc1 <xQueueGiveMutexRecursive+0x3d>
            xReturn = pdFAIL;
40379cba:	020c      	movi.n	a2, 0
40379cbc:	000046        	j	40379cc1 <xQueueGiveMutexRecursive+0x3d>
            xReturn = pdPASS;
40379cbf:	120c      	movi.n	a2, 1
    }
40379cc1:	f01d      	retw.n
	...

40379cc4 <xQueueGiveFromISR>:
{
40379cc4:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379cc7:	00e256        	bnez	a2, 40379cd9 <xQueueGiveFromISR+0x15>
40379cca:	eb99d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379ccd:	ebacc1        	l32r	a12, 40374b80 <_iram_text_start+0x77c> (3c027f00 <__func__$11>)
40379cd0:	4ea5b2        	movi	a11, 0x54e
40379cd3:	eb94a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379cd6:	0607a5        	call8	4037fd50 <__assert_func>
    configASSERT( pxQueue->uxItemSize == 0 );
40379cd9:	102282        	l32i	a8, a2, 64
40379cdc:	011816        	beqz	a8, 40379cf1 <xQueueGiveFromISR+0x2d>
40379cdf:	eba9d1        	l32r	a13, 40374b84 <_iram_text_start+0x780> (3c024384 <_flash_rodata_start+0x4264>)
40379ce2:	eba7c1        	l32r	a12, 40374b80 <_iram_text_start+0x77c> (3c027f00 <__func__$11>)
40379ce5:	52a5b2        	movi	a11, 0x552
40379ce8:	eb8fa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ceb:	201110        	or	a1, a1, a1
40379cee:	060625        	call8	4037fd50 <__assert_func>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
40379cf1:	0288      	l32i.n	a8, a2, 0
40379cf3:	016856        	bnez	a8, 40379d0d <xQueueGiveFromISR+0x49>
40379cf6:	2288      	l32i.n	a8, a2, 8
40379cf8:	011816        	beqz	a8, 40379d0d <xQueueGiveFromISR+0x49>
40379cfb:	eba3d1        	l32r	a13, 40374b88 <_iram_text_start+0x784> (3c0243a0 <_flash_rodata_start+0x4280>)
40379cfe:	eba0c1        	l32r	a12, 40374b80 <_iram_text_start+0x77c> (3c027f00 <__func__$11>)
40379d01:	57a5b2        	movi	a11, 0x557
40379d04:	eb88a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379d07:	201110        	or	a1, a1, a1
40379d0a:	060465        	call8	4037fd50 <__assert_func>
    prvENTER_CRITICAL_OR_MASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379d0d:	4cc272        	addi	a7, a2, 76
40379d10:	fb7c      	movi.n	a11, -1
40379d12:	20a770        	or	a10, a7, a7
40379d15:	0041a5        	call8	4037a130 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
40379d18:	0020c0        	memw
40379d1b:	e288      	l32i.n	a8, a2, 56
        if( uxMessagesWaiting < pxQueue->uxLength )
40379d1d:	f298      	l32i.n	a9, a2, 60
40379d1f:	35b897        	bgeu	a8, a9, 40379d58 <xQueueGiveFromISR+0x94>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
40379d22:	881b      	addi.n	a8, a8, 1
40379d24:	0020c0        	memw
40379d27:	e289      	s32i.n	a8, a2, 56
                    if( pxQueue->pxQueueSetContainer != NULL )
40379d29:	122282        	l32i	a8, a2, 72
40379d2c:	f88c      	beqz.n	a8, 40379d3f <xQueueGiveFromISR+0x7b>
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
40379d2e:	20a220        	or	a10, a2, a2
40379d31:	ffb1e5        	call8	40379850 <prvNotifyQueueSetContainer>
40379d34:	5aac      	beqz.n	a10, 40379d5d <xQueueGiveFromISR+0x99>
                            if( pxHigherPriorityTaskWoken != NULL )
40379d36:	83ac      	beqz.n	a3, 40379d62 <xQueueGiveFromISR+0x9e>
                                *pxHigherPriorityTaskWoken = pdTRUE;
40379d38:	120c      	movi.n	a2, 1
40379d3a:	0329      	s32i.n	a2, a3, 0
40379d3c:	000d46        	j	40379d75 <xQueueGiveFromISR+0xb1>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
40379d3f:	0020c0        	memw
40379d42:	9288      	l32i.n	a8, a2, 36
40379d44:	08ac      	beqz.n	a8, 40379d68 <xQueueGiveFromISR+0xa4>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
40379d46:	24c2a2        	addi	a10, a2, 36
40379d49:	018765        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379d4c:	da9c      	beqz.n	a10, 40379d6d <xQueueGiveFromISR+0xa9>
                                if( pxHigherPriorityTaskWoken != NULL )
40379d4e:	03ac      	beqz.n	a3, 40379d72 <xQueueGiveFromISR+0xae>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
40379d50:	120c      	movi.n	a2, 1
40379d52:	0329      	s32i.n	a2, a3, 0
40379d54:	000746        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d57:	020c00        	andb	b0, b12, b0
            xReturn = errQUEUE_FULL;
40379d5a:	0005c6        	j	40379d75 <xQueueGiveFromISR+0xb1>
            xReturn = pdPASS;
40379d5d:	120c      	movi.n	a2, 1
40379d5f:	000486        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d62:	120c      	movi.n	a2, 1
40379d64:	000346        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d67:	120c00        	andbc	b0, b12, b0
40379d6a:	0001c6        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d6d:	120c      	movi.n	a2, 1
40379d6f:	000086        	j	40379d75 <xQueueGiveFromISR+0xb1>
40379d72:	01a022        	movi	a2, 1
    prvEXIT_CRITICAL_OR_UNMASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379d75:	20a770        	or	a10, a7, a7
40379d78:	005065        	call8	4037a280 <vPortExitCritical>
}
40379d7b:	000090        	retw
	...

40379d80 <xQueueSemaphoreTake>:
{
40379d80:	008136        	entry	a1, 64
40379d83:	4139      	s32i.n	a3, a1, 16
    configASSERT( ( pxQueue ) );
40379d85:	02dc      	bnez.n	a2, 40379d99 <xQueueSemaphoreTake+0x19>
40379d87:	eb81d1        	l32r	a13, 40374b8c <_iram_text_start+0x788> (3c024404 <_flash_rodata_start+0x42e4>)
40379d8a:	eb81c1        	l32r	a12, 40374b90 <_iram_text_start+0x78c> (3c027eec <__func__$9>)
40379d8d:	ada6b2        	movi	a11, 0x6ad
40379d90:	eb65a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379d93:	201110        	or	a1, a1, a1
40379d96:	05fba5        	call8	4037fd50 <__assert_func>
    configASSERT( pxQueue->uxItemSize == 0 );
40379d99:	102282        	l32i	a8, a2, 64
40379d9c:	d88c      	beqz.n	a8, 40379dad <xQueueSemaphoreTake+0x2d>
40379d9e:	eb79d1        	l32r	a13, 40374b84 <_iram_text_start+0x780> (3c024384 <_flash_rodata_start+0x4264>)
40379da1:	eb7bc1        	l32r	a12, 40374b90 <_iram_text_start+0x78c> (3c027eec <__func__$9>)
40379da4:	b1a6b2        	movi	a11, 0x6b1
40379da7:	eb5fa1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379daa:	05fa65        	call8	4037fd50 <__assert_func>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
40379dad:	01c7e5        	call8	4037ba2c <xTaskGetSchedulerState>
40379db0:	160c      	movi.n	a6, 1
40379db2:	836aa0        	moveqz	a6, a10, a10
40379db5:	013a56        	bnez	a10, 40379dcc <xQueueSemaphoreTake+0x4c>
40379db8:	4188      	l32i.n	a8, a1, 16
40379dba:	017816        	beqz	a8, 40379dd5 <xQueueSemaphoreTake+0x55>
40379dbd:	eb6ad1        	l32r	a13, 40374b68 <_iram_text_start+0x764> (3c024328 <_flash_rodata_start+0x4208>)
40379dc0:	eb74c1        	l32r	a12, 40374b90 <_iram_text_start+0x78c> (3c027eec <__func__$9>)
40379dc3:	b6a6b2        	movi	a11, 0x6b6
40379dc6:	eb57a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379dc9:	05f865        	call8	4037fd50 <__assert_func>
40379dcc:	050c      	movi.n	a5, 0
40379dce:	056d      	mov.n	a6, a5
40379dd0:	000106        	j	40379dd8 <xQueueSemaphoreTake+0x58>
40379dd3:	600000        	neg	a0, a0
40379dd6:	722056        	bnez	a0, 4037a4fc <vPortYieldFromInt+0xc>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379dd9:	b24cc2        	s8i	a12, a12, 178
40379ddc:	af          	.byte	0xaf
40379ddd:	ff          	.byte	0xff
40379dde:	07ad      	mov.n	a10, a7
40379de0:	0034e5        	call8	4037a130 <xPortEnterCriticalTimeout>
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
40379de3:	0020c0        	memw
40379de6:	e288      	l32i.n	a8, a2, 56
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
40379de8:	48bc      	beqz.n	a8, 40379e20 <xQueueSemaphoreTake+0xa0>
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
40379dea:	880b      	addi.n	a8, a8, -1
40379dec:	0020c0        	memw
40379def:	e289      	s32i.n	a8, a2, 56
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
40379df1:	002282        	l32i	a8, a2, 0
40379df4:	004856        	bnez	a8, 40379dfc <xQueueSemaphoreTake+0x7c>
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
40379df7:	0227e5        	call8	4037c074 <pvTaskIncrementMutexHeldCount>
40379dfa:	22a9      	s32i.n	a10, a2, 8
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379dfc:	0020c0        	memw
40379dff:	042282        	l32i	a8, a2, 16
40379e02:	010816        	beqz	a8, 40379e16 <xQueueSemaphoreTake+0x96>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
40379e05:	10c2a2        	addi	a10, a2, 16
40379e08:	017b65        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379e0b:	7a8c      	beqz.n	a10, 40379e16 <xQueueSemaphoreTake+0x96>
40379e0d:	03eba0        	rsr.prid	a10
40379e10:	04ada0        	extui	a10, a10, 13, 1
                        queueYIELD_IF_USING_PREEMPTION();
40379e13:	fe2ba5        	call8	403780cc <esp_crosscore_int_send_yield>
                taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e16:	07ad      	mov.n	a10, a7
40379e18:	004665        	call8	4037a280 <vPortExitCritical>
                return pdPASS;
40379e1b:	120c      	movi.n	a2, 1
40379e1d:	001946        	j	40379e86 <xQueueSemaphoreTake+0x106>
                if( xTicksToWait == ( TickType_t ) 0 )
40379e20:	042182        	l32i	a8, a1, 16
40379e23:	00b856        	bnez	a8, 40379e32 <xQueueSemaphoreTake+0xb2>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e26:	20a770        	or	a10, a7, a7
40379e29:	004565        	call8	4037a280 <vPortExitCritical>
                    return errQUEUE_EMPTY;
40379e2c:	020c      	movi.n	a2, 0
40379e2e:	001506        	j	40379e86 <xQueueSemaphoreTake+0x106>
40379e31:	765600        	lsi	f0, a6, 0x1d8
                else if( xEntryTimeSet == pdFALSE )
40379e34:	01ad00        	slli	a10, a13, 32
                    vTaskInternalSetTimeOutState( &xTimeOut );
40379e37:	019865        	call8	4037b7bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
40379e3a:	01a062        	movi	a6, 1
                if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
40379e3d:	10c1b2        	addi	a11, a1, 16
40379e40:	20a110        	or	a10, a1, a1
40379e43:	019965        	call8	4037b7d8 <xTaskCheckForTimeOut>
40379e46:	026a56        	bnez	a10, 40379e70 <xQueueSemaphoreTake+0xf0>
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
40379e49:	0288      	l32i.n	a8, a2, 0
40379e4b:	007856        	bnez	a8, 40379e56 <xQueueSemaphoreTake+0xd6>
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
40379e4e:	0222a2        	l32i	a10, a2, 8
40379e51:	01f325        	call8	4037bd84 <xTaskPriorityInherit>
40379e54:	0a5d      	mov.n	a5, a10
                    vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
40379e56:	0421b2        	l32i	a11, a1, 16
40379e59:	24c2a2        	addi	a10, a2, 36
40379e5c:	0171a5        	call8	4037b578 <vTaskPlaceOnEventList>
40379e5f:	03eba0        	rsr.prid	a10
40379e62:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
40379e65:	fe2665        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e68:	07ad      	mov.n	a10, a7
40379e6a:	004165        	call8	4037a280 <vPortExitCritical>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379e6d:	ffd9c6        	j	40379dd8 <xQueueSemaphoreTake+0x58>
                        if( xInheritanceOccurred != pdFALSE )
40379e70:	00b516        	beqz	a5, 40379e7f <xQueueSemaphoreTake+0xff>
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
40379e73:	02ad      	mov.n	a10, a2
40379e75:	00a365        	call8	4037a8ac <prvGetDisinheritPriorityAfterTimeout>
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
40379e78:	0abd      	mov.n	a11, a10
40379e7a:	22a8      	l32i.n	a10, a2, 8
40379e7c:	020fe5        	call8	4037bf7c <vTaskPriorityDisinheritAfterTimeout>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379e7f:	07ad      	mov.n	a10, a7
40379e81:	003fe5        	call8	4037a280 <vPortExitCritical>
                    return errQUEUE_EMPTY;
40379e84:	020c      	movi.n	a2, 0
}
40379e86:	f01d      	retw.n

40379e88 <xQueueTakeMutexRecursive>:
    {
40379e88:	004136        	entry	a1, 32
40379e8b:	027d      	mov.n	a7, a2
        configASSERT( pxMutex );
40379e8d:	d2cc      	bnez.n	a2, 40379e9e <xQueueTakeMutexRecursive+0x16>
40379e8f:	eb3ad1        	l32r	a13, 40374b78 <_iram_text_start+0x774> (3c02437c <_flash_rodata_start+0x425c>)
40379e92:	eb40c1        	l32r	a12, 40374b94 <_iram_text_start+0x790> (3c027f44 <__func__$17>)
40379e95:	35a3b2        	movi	a11, 0x335
40379e98:	eb23a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379e9b:	05eb65        	call8	4037fd50 <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
40379e9e:	2228      	l32i.n	a2, a2, 8
40379ea0:	019ee5        	call8	4037b890 <xTaskGetCurrentTaskHandle>
40379ea3:	0d92a7        	bne	a2, a10, 40379eb4 <xQueueTakeMutexRecursive+0x2c>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
40379ea6:	032782        	l32i	a8, a7, 12
40379ea9:	01c882        	addi	a8, a8, 1
40379eac:	3789      	s32i.n	a8, a7, 12
            xReturn = pdPASS;
40379eae:	120c      	movi.n	a2, 1
40379eb0:	000506        	j	40379ec8 <xQueueTakeMutexRecursive+0x40>
40379eb3:	b33000        	movgez	a3, a0, a0
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
40379eb6:	a77020        	lsi	f2, a0, 0x29c
40379eb9:	ec6520        	lsi	f2, a5, 0x3b0
40379ebc:	ff          	.byte	0xff
40379ebd:	202aa0        	or	a2, a10, a10
            if( xReturn != pdFAIL )
40379ec0:	4a8c      	beqz.n	a10, 40379ec8 <xQueueTakeMutexRecursive+0x40>
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
40379ec2:	3788      	l32i.n	a8, a7, 12
40379ec4:	881b      	addi.n	a8, a8, 1
40379ec6:	3789      	s32i.n	a8, a7, 12
    }
40379ec8:	f01d      	retw.n
	...

40379ecc <xQueueReceiveFromISR>:
{
40379ecc:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379ecf:	011256        	bnez	a2, 40379ee4 <xQueueReceiveFromISR+0x18>
40379ed2:	eb17d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379ed5:	eb30c1        	l32r	a12, 40374b98 <_iram_text_start+0x794> (3c027ed4 <__func__$7>)
40379ed8:	eb31b1        	l32r	a11, 40374b9c <_iram_text_start+0x798> (86d <UserFrameTotalSize+0x76d>)
40379edb:	eb12a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ede:	201110        	or	a1, a1, a1
40379ee1:	05e6e5        	call8	4037fd50 <__assert_func>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
40379ee4:	53dc      	bnez.n	a3, 40379efd <xQueueReceiveFromISR+0x31>
40379ee6:	102282        	l32i	a8, a2, 64
40379ee9:	089c      	beqz.n	a8, 40379efd <xQueueReceiveFromISR+0x31>
40379eeb:	eb2dd1        	l32r	a13, 40374ba0 <_iram_text_start+0x79c> (3c02446c <_flash_rodata_start+0x434c>)
40379eee:	eb2ac1        	l32r	a12, 40374b98 <_iram_text_start+0x794> (3c027ed4 <__func__$7>)
40379ef1:	eb2cb1        	l32r	a11, 40374ba4 <_iram_text_start+0x7a0> (86e <UserFrameTotalSize+0x76e>)
40379ef4:	eb0ca1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379ef7:	201110        	or	a1, a1, a1
40379efa:	05e565        	call8	4037fd50 <__assert_func>
    prvENTER_CRITICAL_OR_MASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379efd:	4cc262        	addi	a6, a2, 76
40379f00:	ffafb2        	movi	a11, -1
40379f03:	20a660        	or	a10, a6, a6
40379f06:	0022a5        	call8	4037a130 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
40379f09:	0020c0        	memw
40379f0c:	0e2272        	l32i	a7, a2, 56
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
40379f0f:	57ac      	beqz.n	a7, 40379f38 <xQueueReceiveFromISR+0x6c>
            prvCopyDataFromQueue( pxQueue, pvBuffer );
40379f11:	03bd      	mov.n	a11, a3
40379f13:	02ad      	mov.n	a10, a2
40379f15:	ff9165        	call8	4037982c <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
40379f18:	770b      	addi.n	a7, a7, -1
40379f1a:	0020c0        	memw
40379f1d:	e279      	s32i.n	a7, a2, 56
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379f1f:	0020c0        	memw
40379f22:	4288      	l32i.n	a8, a2, 16
40379f24:	589c      	beqz.n	a8, 40379f3d <xQueueReceiveFromISR+0x71>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
40379f26:	10c2a2        	addi	a10, a2, 16
40379f29:	016965        	call8	4037b5c0 <xTaskRemoveFromEventList>
40379f2c:	2a9c      	beqz.n	a10, 40379f42 <xQueueReceiveFromISR+0x76>
                        if( pxHigherPriorityTaskWoken != NULL )
40379f2e:	649c      	beqz.n	a4, 40379f48 <xQueueReceiveFromISR+0x7c>
                            *pxHigherPriorityTaskWoken = pdTRUE;
40379f30:	120c      	movi.n	a2, 1
40379f32:	0429      	s32i.n	a2, a4, 0
40379f34:	0004c6        	j	40379f4b <xQueueReceiveFromISR+0x7f>
40379f37:	020c00        	andb	b0, b12, b0
            xReturn = pdFAIL;
40379f3a:	000346        	j	40379f4b <xQueueReceiveFromISR+0x7f>
            xReturn = pdPASS;
40379f3d:	120c      	movi.n	a2, 1
40379f3f:	000206        	j	40379f4b <xQueueReceiveFromISR+0x7f>
40379f42:	120c      	movi.n	a2, 1
40379f44:	0000c6        	j	40379f4b <xQueueReceiveFromISR+0x7f>
40379f47:	a02200        	addx4	a2, a2, a0
40379f4a:	a66001        	l32r	a0, 403638cc <rom_rx_gain_force+0x35d4a0>
    prvEXIT_CRITICAL_OR_UNMASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379f4d:	332520        	clamps	a2, a5, 9
40379f50:	009000        	all4	b0, b0:b1:b2:b3
	...

40379f54 <vQueueDelete>:
{
40379f54:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379f57:	00e256        	bnez	a2, 40379f69 <vQueueDelete+0x15>
40379f5a:	eaf5d1        	l32r	a13, 40374b30 <_iram_text_start+0x72c> (3c024210 <_flash_rodata_start+0x40f0>)
40379f5d:	eb12c1        	l32r	a12, 40374ba8 <_iram_text_start+0x7a4> (3c027ec4 <__func__$2>)
40379f60:	eb13b1        	l32r	a11, 40374bac <_iram_text_start+0x7a8> (933 <UserFrameTotalSize+0x833>)
40379f63:	eaf0a1        	l32r	a10, 40374b24 <_iram_text_start+0x720> (3c0241be <_flash_rodata_start+0x409e>)
40379f66:	05dea5        	call8	4037fd50 <__assert_func>
        if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
40379f69:	440282        	l8ui	a8, a2, 68
40379f6c:	68cc      	bnez.n	a8, 40379f76 <vQueueDelete+0x22>
            vPortFree( pxQueue );
40379f6e:	02ad      	mov.n	a10, a2
40379f70:	201110        	or	a1, a1, a1
40379f73:	006365        	call8	4037a5a8 <vPortFree>
}
40379f76:	f01d      	retw.n

40379f78 <vPortTaskWrapper>:
{
40379f78:	004136        	entry	a1, 32
40379f7b:	03ad      	mov.n	a10, a3
    pxCode(pvParameters);
40379f7d:	0002e0        	callx8	a2
    char *pcTaskName = pcTaskGetName(NULL);
40379f80:	0a0c      	movi.n	a10, 0
40379f82:	01a865        	call8	4037ba08 <pcTaskGetName>
40379f85:	0a7d      	mov.n	a7, a10
    ESP_LOGE("FreeRTOS", "FreeRTOS Task \"%s\" should not return, Aborting now!", pcTaskName);
40379f87:	05c5a5        	call8	4037fbe0 <esp_log_timestamp>
40379f8a:	eb09b1        	l32r	a11, 40374bb0 <_iram_text_start+0x7ac> (3c024a40 <_flash_rodata_start+0x4920>)
40379f8d:	07fd      	mov.n	a15, a7
40379f8f:	0bed      	mov.n	a14, a11
40379f91:	0add      	mov.n	a13, a10
40379f93:	eb08c1        	l32r	a12, 40374bb4 <_iram_text_start+0x7b0> (3c024a4c <_flash_rodata_start+0x492c>)
40379f96:	1a0c      	movi.n	a10, 1
40379f98:	05c8e5        	call8	4037fc28 <esp_log_write>
    abort();
40379f9b:	05cfa5        	call8	4037fc94 <abort>
	...

40379fa0 <vPortTLSPointersDelCb>:

// --------------------- TCB Cleanup -----------------------

#if ( CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS )
static void vPortTLSPointersDelCb( void *pxTCB )
{
40379fa0:	004136        	entry	a1, 32
     * pvDummy15 corresponds to pvThreadLocalStoragePointers member of the TCB.
     */
    StaticTask_t *tcb = ( StaticTask_t * )pxTCB;

    /* The TLSP deletion callbacks are stored at an offset of (configNUM_THREAD_LOCAL_STORAGE_POINTERS/2) */
    TlsDeleteCallbackFunction_t *pvThreadLocalStoragePointersDelCallback = ( TlsDeleteCallbackFunction_t * )( &( tcb->pvDummy15[ ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ) ] ) );
40379fa3:	58c252        	addi	a5, a2, 88

    /* We need to iterate over half the depth of the pvThreadLocalStoragePointers area
     * to access all TLS pointers and their respective TLS deletion callbacks.
     */
    for ( int x = 0; x < ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ); x++ ) {
40379fa6:	070c      	movi.n	a7, 0
40379fa8:	001dc6        	j	4037a023 <vPortTLSPointersDelCb+0x83>
40379fab:	675000        	lsi	f0, a0, 0x19c
        if ( pvThreadLocalStoragePointersDelCallback[ x ] != NULL ) {  //If del cb is set
40379fae:	06c8a0        	lsi	f10, a8, 24
40379fb1:	06cc16        	beqz	a12, 4037a021 <vPortTLSPointersDelCb+0x81>
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40379fb4:	eb0191        	l32r	a9, 40374bb8 <_iram_text_start+0x7b4> (be000000 <_rtc_reserved_end+0x5df00000>)
40379fb7:	9c9a      	add.n	a9, a12, a9
40379fb9:	e99081        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
40379fbc:	628890        	lsi	f9, a8, 0x188
40379fbf:	880b      	addi.n	a8, a8, -1
40379fc1:	608080        	neg	a8, a8
40379fc4:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40379fc7:	eafda1        	l32r	a10, 40374bbc <_iram_text_start+0x7b8> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
40379fca:	acaa      	add.n	a10, a12, a10
40379fcc:	e98e91        	l32r	a9, 40374604 <_iram_text_start+0x200> (6ffff <UserFrameTotalSize+0x6feff>)
40379fcf:	6299a0        	lsi	f10, a9, 0x188
40379fd2:	990b      	addi.n	a9, a9, -1
40379fd4:	609090        	neg	a9, a9
40379fd7:	749090        	extui	a9, a9, 0, 8
40379fda:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40379fdd:	38fc      	bnez.n	a8, 4037a014 <vPortTLSPointersDelCb+0x74>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40379fdf:	e9ec81        	l32r	a8, 40374790 <_iram_text_start+0x38c> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40379fe2:	8c8a      	add.n	a8, a12, a8
40379fe4:	e98a91        	l32r	a9, 4037460c <_iram_text_start+0x208> (5ffff <UserFrameTotalSize+0x5feff>)
40379fe7:	29b987        	bgeu	a9, a8, 4037a014 <vPortTLSPointersDelCb+0x74>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40379fea:	e98081        	l32r	a8, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40379fed:	8c8a      	add.n	a8, a12, a8
40379fef:	e98091        	l32r	a9, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
40379ff2:	1eb987        	bgeu	a9, a8, 4037a014 <vPortTLSPointersDelCb+0x74>
40379ff5:	e91d81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40379ff8:	0888      	l32i.n	a8, a8, 0
            /* In case the TLSP deletion callback has been overwritten by a TLS pointer, gracefully abort. */
            if ( !esp_ptr_executable( pvThreadLocalStoragePointersDelCallback[ x ] ) ) {
                // We call EARLY log here as currently portCLEAN_UP_TCB() is called in a critical section
                ESP_EARLY_LOGE("FreeRTOS", "Fatal error: TLSP deletion callback at index %d overwritten with non-excutable pointer %p", x, pvThreadLocalStoragePointersDelCallback[ x ]);
40379ffa:	389c      	beqz.n	a8, 4037a011 <vPortTLSPointersDelCb+0x71>
40379ffc:	05be25        	call8	4037fbe0 <esp_log_timestamp>
40379fff:	06e8      	l32i.n	a14, a6, 0
4037a001:	07dd      	mov.n	a13, a7
4037a003:	eaebc1        	l32r	a12, 40374bb0 <_iram_text_start+0x7ac> (3c024a40 <_flash_rodata_start+0x4920>)
4037a006:	0abd      	mov.n	a11, a10
4037a008:	eaeea1        	l32r	a10, 40374bc0 <_iram_text_start+0x7bc> (3c024a90 <_flash_rodata_start+0x4970>)
4037a00b:	e92a81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4037a00e:	0008e0        	callx8	a8
                abort();
4037a011:	05c825        	call8	4037fc94 <abort>
            }

            pvThreadLocalStoragePointersDelCallback[ x ]( x, tcb->pvDummy15[ x ] );   //Call del cb
4037a014:	14c782        	addi	a8, a7, 20
4037a017:	a08820        	addx4	a8, a8, a2
4037a01a:	18b8      	l32i.n	a11, a8, 4
4037a01c:	07ad      	mov.n	a10, a7
4037a01e:	000ce0        	callx8	a12
    for ( int x = 0; x < ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ); x++ ) {
4037a021:	771b      	addi.n	a7, a7, 1
4037a023:	0217e6        	bgei	a7, 1, 4037a029 <vPortTLSPointersDelCb+0x89>
4037a026:	ffe086        	j	40379fac <vPortTLSPointersDelCb+0xc>
        }
    }
}
4037a029:	f01d      	retw.n
	...

4037a02c <vPortCleanUpCoprocArea>:
#endif /* CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS */

#if ( XCHAL_CP_NUM > 0 )
static void vPortCleanUpCoprocArea(void *pvTCB)
{
4037a02c:	004136        	entry	a1, 32
    UBaseType_t uxCoprocArea;
    BaseType_t xTargetCoreID;

    /* Get a pointer to the task's coprocessor save area */
    uxCoprocArea = ( UBaseType_t ) ( ( ( StaticTask_t * ) pvTCB )->pxDummy8 );  /* Get TCB_t.pxEndOfStack */
4037a02f:	122282        	l32i	a8, a2, 72
    uxCoprocArea = STACKPTR_ALIGN_DOWN(16, uxCoprocArea - XT_CP_SIZE);
4037a032:	c4ae92        	movi	a9, 0xfffffec4
4037a035:	808890        	add	a8, a8, a9
        xTargetCoreID = 0;
    #endif /* configNUMBER_OF_CORES > 1 */

    /* If task has live floating point registers somewhere, release them */
    void _xt_coproc_release(volatile void *coproc_sa_base, BaseType_t xTargetCoreID);
    _xt_coproc_release( (void *)uxCoprocArea, xTargetCoreID );
4037a038:	1122b2        	l32i	a11, a2, 68
4037a03b:	f0afa2        	movi	a10, -16
4037a03e:	10a8a0        	and	a10, a8, a10
4037a041:	07dd25        	call8	40381e14 <_xt_coproc_release>
}
4037a044:	000090        	retw
	...

4037a048 <xPortStartScheduler>:
{
4037a048:	004136        	entry	a1, 32
    portDISABLE_INTERRUPTS();
4037a04b:	006380        	rsil	a8, 3
    _xt_coproc_init();
4037a04e:	07dae5        	call8	40381dfc <_xt_coproc_init>
    vPortSetupTimer();
4037a051:	007a65        	call8	4037a7f8 <vPortSetupTimer>
4037a054:	03eb80        	rsr.prid	a8
4037a057:	048d80        	extui	a8, a8, 13, 1
    port_xSchedulerRunning[xPortGetCoreID()] = 1;
4037a05a:	eada91        	l32r	a9, 40374bc4 <_iram_text_start+0x7c0> (3fc94de8 <port_xSchedulerRunning>)
4037a05d:	a08890        	addx4	a8, a8, a9
4037a060:	01a022        	movi	a2, 1
4037a063:	0020c0        	memw
4037a066:	0829      	s32i.n	a2, a8, 0
    xthal_window_spill();
4037a068:	07c265        	call8	40381c90 <xthal_window_spill>
    __asm__ volatile ("call0    _frxt_dispatch\n");
4037a06b:	003bc5        	call0	4037a428 <_frxt_dispatch>
}
4037a06e:	f01d      	retw.n

4037a070 <pxPortInitialiseStack>:
{
4037a070:	004136        	entry	a1, 32
    configASSERT((uxStackPointer & portBYTE_ALIGNMENT_MASK) == 0);
4037a073:	348020        	extui	a8, a2, 0, 4
4037a076:	d88c      	beqz.n	a8, 4037a087 <pxPortInitialiseStack+0x17>
4037a078:	ead4d1        	l32r	a13, 40374bc8 <_iram_text_start+0x7c4> (3c024af8 <_flash_rodata_start+0x49d8>)
4037a07b:	ead4c1        	l32r	a12, 40374bcc <_iram_text_start+0x7c8> (3c02822c <__func__$4>)
4037a07e:	a1a1b2        	movi	a11, 0x1a1
4037a081:	ead3a1        	l32r	a10, 40374bd0 <_iram_text_start+0x7cc> (3c024b56 <_flash_rodata_start+0x4a36>)
4037a084:	05cca5        	call8	4037fd50 <__assert_func>
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - XT_CP_SIZE);
4037a087:	c4ae82        	movi	a8, 0xfffffec4
4037a08a:	728a      	add.n	a7, a2, a8
4037a08c:	027c      	movi.n	a2, -16
4037a08e:	107720        	and	a7, a7, a2
    p[0] = 0;   // Clear XT_CPENABLE and XT_CPSTORED
4037a091:	050c      	movi.n	a5, 0
4037a093:	0759      	s32i.n	a5, a7, 0
    p[1] = 0;   // Clear XT_CP_CS_ST
4037a095:	1759      	s32i.n	a5, a7, 4
    p[2] = (uint32_t)ALIGNUP(XCHAL_TOTAL_SA_ALIGN, (uint32_t)uxStackPointer + 12);
4037a097:	1bc782        	addi	a8, a7, 27
4037a09a:	108820        	and	a8, a8, a2
4037a09d:	2789      	s32i.n	a8, a7, 8
    const uint32_t tls_area_size = ALIGNUP(16, (uint32_t)&_thread_local_end - (uint32_t)&_thread_local_start);
4037a09f:	eacd61        	l32r	a6, 40374bd4 <_iram_text_start+0x7d0> (3c029f74 <_esp_system_init_fn_array_end>)
4037a0a2:	ead1c1        	l32r	a12, 40374be8 <_iram_text_start+0x7e4> (3c029f83 <_esp_system_init_fn_array_end+0xf>)
4037a0a5:	c0cc60        	sub	a12, a12, a6
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - (UBaseType_t)tls_area_size);
4037a0a8:	10cc20        	and	a12, a12, a2
4037a0ab:	c077c0        	sub	a7, a7, a12
4037a0ae:	107720        	and	a7, a7, a2
    memcpy((void *)uxStackPointer, &_thread_local_start, tls_area_size);
4037a0b1:	06bd      	mov.n	a11, a6
4037a0b3:	20a770        	or	a10, a7, a7
4037a0b6:	e90781        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037a0b9:	0008e0        	callx8	a8
    const uint32_t base = ALIGNUP(tls_section_align, TCB_SIZE);
4037a0bc:	eac781        	l32r	a8, 40374bd8 <_iram_text_start+0x7d4> (10 <_flash_rodata_align>)
4037a0bf:	a87b      	addi.n	a10, a8, 7
4037a0c1:	609080        	neg	a9, a8
    *ret_threadptr_reg_init = (uint32_t)uxStackPointer - ((uint32_t)&_thread_local_start - (uint32_t)&_flash_rodata_start) - base;
4037a0c4:	c08760        	sub	a8, a7, a6
4037a0c7:	109a90        	and	a9, a10, a9
4037a0ca:	eac461        	l32r	a6, 40374bdc <_iram_text_start+0x7d8> (3c020120 <_flash_rodata_start>)
4037a0cd:	c06690        	sub	a6, a6, a9
4037a0d0:	668a      	add.n	a6, a6, a8
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - XT_STK_FRMSZ);
4037a0d2:	40af82        	movi	a8, -192
4037a0d5:	878a      	add.n	a8, a7, a8
4037a0d7:	102820        	and	a2, a8, a2
    memset((void *)uxStackPointer, 0, (size_t)(uxStackPointerPrevious - uxStackPointer));
4037a0da:	c0c720        	sub	a12, a7, a2
4037a0dd:	05bd      	mov.n	a11, a5
4037a0df:	20a220        	or	a10, a2, a2
4037a0e2:	e8eb81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037a0e5:	0008e0        	callx8	a8
    frame->a0 = 0;                                          // Set the return address to 0 terminate GDB backtrace
4037a0e8:	3259      	s32i.n	a5, a2, 12
    frame->a1 = uxStackPointer + XT_STK_FRMSZ;              // Saved stack pointer should point to physical top of stack frame
4037a0ea:	c0a082        	movi	a8, 192
4037a0ed:	828a      	add.n	a8, a2, a8
4037a0ef:	4289      	s32i.n	a8, a2, 16
    frame->exit = (UBaseType_t) _xt_user_exit;              // User exception exit dispatcher
4037a0f1:	e9a981        	l32r	a8, 40374798 <_iram_text_start+0x394> (40376da8 <_xt_user_exit>)
4037a0f4:	0289      	s32i.n	a8, a2, 0
        frame->pc = (UBaseType_t) vPortTaskWrapper;         // Task entry point is the wrapper function
4037a0f6:	eaba81        	l32r	a8, 40374be0 <_iram_text_start+0x7dc> (40379f78 <vPortTaskWrapper>)
4037a0f9:	1289      	s32i.n	a8, a2, 4
            frame->a6 = (UBaseType_t) pxCode;               // Wrapper function's argument 0 (which is the task function), passed as if we call4'd
4037a0fb:	9239      	s32i.n	a3, a2, 36
            frame->a7 = (UBaseType_t) pvParameters;         // Wrapper function's argument 1 (which is the task function's argument), passed as if we call4'd
4037a0fd:	a249      	s32i.n	a4, a2, 40
        frame->ps = PS_UM | PS_EXCM | PS_WOE | PS_CALLINC(1);
4037a0ff:	eab981        	l32r	a8, 40374be4 <_iram_text_start+0x7e0> (50030 <UserFrameTotalSize+0x4ff30>)
4037a102:	2289      	s32i.n	a8, a2, 8
    *threadptr_reg = threadptr_reg_init;
4037a104:	1c6262        	s32i	a6, a2, 112
}
4037a107:	f01d      	retw.n
4037a109:	000000        	ill

4037a10c <xPortInIsrContext>:
{
4037a10c:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a10f:	0063a0        	rsil	a10, 3
4037a112:	03eb80        	rsr.prid	a8
4037a115:	048d80        	extui	a8, a8, 13, 1
    ret = (port_interruptNesting[xPortGetCoreID()] != 0);
4037a118:	e98591        	l32r	a9, 4037472c <_iram_text_start+0x328> (3fc94de0 <port_interruptNesting>)
4037a11b:	a08890        	addx4	a8, a8, a9
4037a11e:	0888      	l32i.n	a8, a8, 0
4037a120:	01a022        	movi	a2, 1
4037a123:	832880        	moveqz	a2, a8, a8
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037a126:	eab181        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037a129:	0008e0        	callx8	a8
}
4037a12c:	f01d      	retw.n
	...

4037a130 <xPortEnterCriticalTimeout>:
{
4037a130:	006136        	entry	a1, 48
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a133:	006380        	rsil	a8, 3
4037a136:	006182        	s32i	a8, a1, 0
    // Unused if asserts are disabled
    uint32_t __attribute__((unused)) other_core_owner_id;
    bool lock_set;
    esp_cpu_cycle_count_t start_count;

    assert(lock);
4037a139:	00e256        	bnez	a2, 4037a14b <xPortEnterCriticalTimeout+0x1b>
4037a13c:	eaadd1        	l32r	a13, 40374bf0 <_iram_text_start+0x7ec> (3c022934 <_flash_rodata_start+0x2814>)
4037a13f:	eaadc1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028218 <__func__$2>)
4037a142:	eaada1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a145:	54a0b2        	movi	a11, 84
4037a148:	05c065        	call8	4037fd50 <__assert_func>
#if __XTENSA__
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a14b:	006350        	rsil	a5, 3
    asm volatile (
4037a14e:	03eb70        	rsr.prid	a7
     *  - If "our" core_owner_id, we can drop through immediately.
     *  - If "other_core_owner_id", we spin here.
     */

    // The caller is already the owner of the lock. Simply increment the nesting count
    if (lock->owner == core_owner_id) {
4037a151:	002292        	l32i	a9, a2, 0
4037a154:	259797        	bne	a7, a9, 4037a17d <xPortEnterCriticalTimeout+0x4d>
        assert(lock->count > 0 && lock->count < 0xFF);    // Bad count value implies memory corruption
4037a157:	1298      	l32i.n	a9, a2, 4
4037a159:	fda0b2        	movi	a11, 253
4037a15c:	a90b      	addi.n	a10, a9, -1
4037a15e:	0ebba7        	bgeu	a11, a10, 4037a170 <xPortEnterCriticalTimeout+0x40>
4037a161:	eaa6d1        	l32r	a13, 40374bfc <_iram_text_start+0x7f8> (3c024b60 <_flash_rodata_start+0x4a40>)
4037a164:	eaa4c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028218 <__func__$2>)
4037a167:	eaa4a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a16a:	6aa0b2        	movi	a11, 106
4037a16d:	05be25        	call8	4037fd50 <__assert_func>
        lock->count++;
4037a170:	991b      	addi.n	a9, a9, 1
4037a172:	1299      	s32i.n	a9, a2, 4
#if __XTENSA__
        XTOS_RESTORE_INTLEVEL(irq_status);
4037a174:	13e650        	wsr.ps	a5
4037a177:	002010        	rsync
#else
        rv_utils_restore_intlevel_regval(irq_status);
#endif
        return true;
4037a17a:	003346        	j	4037a24b <xPortEnterCriticalTimeout+0x11b>
     * Note: We do a first attempt separately (instead of putting this into a loop) in order to avoid call to
     * esp_cpu_get_cycle_count(). This doing a first attempt separately makes acquiring a free lock quicker, which
     * is the case for the majority of spinlock_acquire() calls (as spinlocks are free most of the time since they
     * aren't meant to be held for long).
     */
    lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a17d:	ea6eb1        	l32r	a11, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a180:	20c770        	or	a12, a7, a7
4037a183:	20a220        	or	a10, a2, a2
4037a186:	fe0225        	call8	403781a8 <esp_cpu_compare_and_set>
    if (lock_set || timeout == SPINLOCK_NO_WAIT) {
4037a189:	53bc      	beqz.n	a3, 4037a1c2 <xPortEnterCriticalTimeout+0x92>
4037a18b:	3afc      	bnez.n	a10, 4037a1c2 <xPortEnterCriticalTimeout+0x92>
    RSR(CCOUNT, ccount);
4037a18d:	03ea40        	rsr.ccount	a4
    }

    // First attempt to take the lock has failed. Retry until the lock is taken, or until we timeout.
    start_count = esp_cpu_get_cycle_count();
    do {
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a190:	ea6a61        	l32r	a6, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a193:	190326        	beqi	a3, -1, 4037a1b0 <xPortEnterCriticalTimeout+0x80>
4037a196:	07cd      	mov.n	a12, a7
4037a198:	06bd      	mov.n	a11, a6
4037a19a:	20a220        	or	a10, a2, a2
4037a19d:	fe00a5        	call8	403781a8 <esp_cpu_compare_and_set>
        if (lock_set) {
4037a1a0:	0d5a56        	bnez	a10, 4037a279 <xPortEnterCriticalTimeout+0x149>
4037a1a3:	03ea90        	rsr.ccount	a9
            break;
        }
        // Keep looping if we are waiting forever, or check if we have timed out
    } while ((timeout == SPINLOCK_WAIT_FOREVER) || (esp_cpu_get_cycle_count() - start_count) <= (esp_cpu_cycle_count_t)timeout);
4037a1a6:	c09940        	sub	a9, a9, a4
4037a1a9:	e9b397        	bgeu	a3, a9, 4037a196 <xPortEnterCriticalTimeout+0x66>
4037a1ac:	003106        	j	4037a274 <xPortEnterCriticalTimeout+0x144>
4037a1af:	c77000        	lsi	f0, a0, 0x31c
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a1b2:	b66020        	lsi	f2, a0, 0x2d8
4037a1b5:	a22020        	muluh	a2, a0, a2
4037a1b8:	fee520        	f64iter	a14, a5, a2, 3, 1
4037a1bb:	16fd      	lsi	f15, a6, 24
        if (lock_set) {
4037a1bd:	ff0a      	add.n	a15, a15, a0

exit:
4037a1bf:	002d86        	j	4037a279 <xPortEnterCriticalTimeout+0x149>
    if (lock_set) {
        assert(lock->owner == core_owner_id);
4037a1c2:	002292        	l32i	a9, a2, 0
    if (lock_set) {
4037a1c5:	034a16        	beqz	a10, 4037a1fd <xPortEnterCriticalTimeout+0xcd>
        assert(lock->owner == core_owner_id);
4037a1c8:	0e1797        	beq	a7, a9, 4037a1da <xPortEnterCriticalTimeout+0xaa>
4037a1cb:	ea8dd1        	l32r	a13, 40374c00 <_iram_text_start+0x7fc> (3c024b88 <_flash_rodata_start+0x4a68>)
4037a1ce:	ea89c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028218 <__func__$2>)
4037a1d1:	ea89a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a1d4:	8da0b2        	movi	a11, 141
4037a1d7:	05b7a5        	call8	4037fd50 <__assert_func>
        assert(lock->count == 0);   // This is the first time the lock is set, so count should still be 0
4037a1da:	1298      	l32i.n	a9, a2, 4
4037a1dc:	d98c      	beqz.n	a9, 4037a1ed <xPortEnterCriticalTimeout+0xbd>
4037a1de:	ea89d1        	l32r	a13, 40374c04 <_iram_text_start+0x800> (3c024ba8 <_flash_rodata_start+0x4a88>)
4037a1e1:	ea84c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028218 <__func__$2>)
4037a1e4:	ea85a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a1e7:	8ea0b2        	movi	a11, 142
4037a1ea:	05b665        	call8	4037fd50 <__assert_func>
        lock->count++;  // Finally, we increment the lock count
4037a1ed:	190c      	movi.n	a9, 1
4037a1ef:	1299      	s32i.n	a9, a2, 4
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_owner_id);
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
    }

#if __XTENSA__
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a1f1:	13e650        	wsr.ps	a5
4037a1f4:	002010        	rsync
#else
    rv_utils_restore_intlevel_regval(irq_status);
#endif
    return lock_set;
4037a1f7:	001406        	j	4037a24b <xPortEnterCriticalTimeout+0x11b>
4037a1fa:	000000        	ill
    other_core_owner_id = CORE_ID_REGVAL_XOR_SWAP ^ core_owner_id;
4037a1fd:	ea82a1        	l32r	a10, 40374c08 <_iram_text_start+0x804> (6666 <UserFrameTotalSize+0x6566>)
4037a200:	30a7a0        	xor	a10, a7, a10
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_owner_id);
4037a203:	171a97        	beq	a10, a9, 4037a21e <xPortEnterCriticalTimeout+0xee>
4037a206:	ea4ca1        	l32r	a10, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a209:	1119a7        	beq	a9, a10, 4037a21e <xPortEnterCriticalTimeout+0xee>
4037a20c:	ea80d1        	l32r	a13, 40374c0c <_iram_text_start+0x808> (3c024bbc <_flash_rodata_start+0x4a9c>)
4037a20f:	ea79c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028218 <__func__$2>)
4037a212:	ea79a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a215:	91a0b2        	movi	a11, 145
4037a218:	201110        	or	a1, a1, a1
4037a21b:	05b365        	call8	4037fd50 <__assert_func>
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
4037a21e:	012282        	l32i	a8, a2, 4
4037a221:	fea092        	movi	a9, 254
4037a224:	0eb987        	bgeu	a9, a8, 4037a236 <xPortEnterCriticalTimeout+0x106>
4037a227:	ea7ad1        	l32r	a13, 40374c10 <_iram_text_start+0x80c> (3c024c00 <_flash_rodata_start+0x4ae0>)
4037a22a:	ea72c1        	l32r	a12, 40374bf4 <_iram_text_start+0x7f0> (3c028218 <__func__$2>)
4037a22d:	ea72a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a230:	92a0b2        	movi	a11, 146
4037a233:	05b1e5        	call8	4037fd50 <__assert_func>
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a236:	13e650        	wsr.ps	a5
4037a239:	002010        	rsync
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037a23c:	0021a2        	l32i	a10, a1, 0
        return pdFAIL;
4037a23f:	00a022        	movi	a2, 0
4037a242:	ea6a81        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037a245:	0008e0        	callx8	a8
4037a248:	000c86        	j	4037a27e <xPortEnterCriticalTimeout+0x14e>
    asm volatile (
4037a24b:	03eb80        	rsr.prid	a8
4037a24e:	048d80        	extui	a8, a8, 13, 1
    BaseType_t newNesting = port_uxCriticalNesting[coreID] + 1;
4037a251:	ea7091        	l32r	a9, 40374c14 <_iram_text_start+0x810> (3fc94dd8 <port_uxCriticalNesting>)
4037a254:	11a8e0        	slli	a10, a8, 2
4037a257:	a08890        	addx4	a8, a8, a9
4037a25a:	0898      	l32i.n	a9, a8, 0
4037a25c:	991b      	addi.n	a9, a9, 1
    port_uxCriticalNesting[coreID] = newNesting;
4037a25e:	0899      	s32i.n	a9, a8, 0
    if ( newNesting == 1 ) {
4037a260:	041926        	beqi	a9, 1, 4037a268 <xPortEnterCriticalTimeout+0x138>
    return pdPASS;
4037a263:	120c      	movi.n	a2, 1
4037a265:	000546        	j	4037a27e <xPortEnterCriticalTimeout+0x14e>
        port_uxOldInterruptState[coreID] = xOldInterruptLevel;
4037a268:	ea6c81        	l32r	a8, 40374c18 <_iram_text_start+0x814> (3fc94dd0 <port_uxOldInterruptState>)
4037a26b:	0198      	l32i.n	a9, a1, 0
4037a26d:	88aa      	add.n	a8, a8, a10
4037a26f:	0899      	s32i.n	a9, a8, 0
4037a271:	fffb86        	j	4037a263 <xPortEnterCriticalTimeout+0x133>
        assert(lock->owner == core_owner_id);
4037a274:	0298      	l32i.n	a9, a2, 0
4037a276:	ffe0c6        	j	4037a1fd <xPortEnterCriticalTimeout+0xcd>
4037a279:	0298      	l32i.n	a9, a2, 0
4037a27b:	ffd246        	j	4037a1c8 <xPortEnterCriticalTimeout+0x98>
}
4037a27e:	f01d      	retw.n

4037a280 <vPortExitCritical>:
{
4037a280:	004136        	entry	a1, 32
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE && !BOOTLOADER_BUILD
    uint32_t irq_status;
    // Return value unused if asserts are disabled
    uint32_t __attribute__((unused)) core_owner_id;

    assert(lock);
4037a283:	00e256        	bnez	a2, 4037a295 <vPortExitCritical+0x15>
4037a286:	ea5ad1        	l32r	a13, 40374bf0 <_iram_text_start+0x7ec> (3c022934 <_flash_rodata_start+0x2814>)
4037a289:	ea64c1        	l32r	a12, 40374c1c <_iram_text_start+0x818> (3c0281f0 <__func__$0>)
4037a28c:	ea5ba1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a28f:	b5a0b2        	movi	a11, 181
4037a292:	05abe5        	call8	4037fd50 <__assert_func>
#if __XTENSA__
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a295:	0063a0        	rsil	a10, 3
    asm volatile (
4037a298:	03eb90        	rsr.prid	a9
    core_owner_id = xt_utils_get_raw_core_id();
#else
    irq_status = rv_utils_set_intlevel_regval(RVHAL_EXCM_LEVEL_CLIC);
    core_owner_id = rv_utils_get_core_id() == 0 ? SPINLOCK_OWNER_ID_0 : SPINLOCK_OWNER_ID_1;
#endif
    assert(core_owner_id == lock->owner); // This is a lock that we didn't acquire, or the lock is corrupt
4037a29b:	0288      	l32i.n	a8, a2, 0
4037a29d:	111987        	beq	a9, a8, 4037a2b2 <vPortExitCritical+0x32>
4037a2a0:	ea60d1        	l32r	a13, 40374c20 <_iram_text_start+0x81c> (3c024c14 <_flash_rodata_start+0x4af4>)
4037a2a3:	ea5ec1        	l32r	a12, 40374c1c <_iram_text_start+0x818> (3c0281f0 <__func__$0>)
4037a2a6:	ea54a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a2a9:	bea0b2        	movi	a11, 190
4037a2ac:	201110        	or	a1, a1, a1
4037a2af:	05aa25        	call8	4037fd50 <__assert_func>
    lock->count--;
4037a2b2:	1288      	l32i.n	a8, a2, 4
4037a2b4:	880b      	addi.n	a8, a8, -1
4037a2b6:	1289      	s32i.n	a8, a2, 4

    if (!lock->count) { // If this is the last recursive release of the lock, mark the lock as free
4037a2b8:	98cc      	bnez.n	a8, 4037a2c5 <vPortExitCritical+0x45>
        lock->owner = SPINLOCK_FREE;
4037a2ba:	ea1f81        	l32r	a8, 40374b38 <_iram_text_start+0x734> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a2bd:	0289      	s32i.n	a8, a2, 0
4037a2bf:	0005c6        	j	4037a2da <vPortExitCritical+0x5a>
4037a2c2:	000000        	ill
    } else {
        assert(lock->count < 0x100); // Indicates memory corruption
4037a2c5:	ffa092        	movi	a9, 255
4037a2c8:	0eb987        	bgeu	a9, a8, 4037a2da <vPortExitCritical+0x5a>
4037a2cb:	ea56d1        	l32r	a13, 40374c24 <_iram_text_start+0x820> (3c024c34 <_flash_rodata_start+0x4b14>)
4037a2ce:	ea53c1        	l32r	a12, 40374c1c <_iram_text_start+0x818> (3c0281f0 <__func__$0>)
4037a2d1:	ea49a1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3c022964 <_flash_rodata_start+0x2844>)
4037a2d4:	c4a0b2        	movi	a11, 196
4037a2d7:	05a7a5        	call8	4037fd50 <__assert_func>
    }

#if __XTENSA__
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a2da:	13e6a0        	wsr.ps	a10
4037a2dd:	002010        	rsync
    asm volatile (
4037a2e0:	03eb80        	rsr.prid	a8
4037a2e3:	048d80        	extui	a8, a8, 13, 1
    BaseType_t nesting = port_uxCriticalNesting[coreID];
4037a2e6:	ea4b91        	l32r	a9, 40374c14 <_iram_text_start+0x810> (3fc94dd8 <port_uxCriticalNesting>)
4037a2e9:	11a8e0        	slli	a10, a8, 2
4037a2ec:	a08890        	addx4	a8, a8, a9
4037a2ef:	0898      	l32i.n	a9, a8, 0
    configASSERT( nesting > 0 );
4037a2f1:	1119e6        	bgei	a9, 1, 4037a306 <vPortExitCritical+0x86>
4037a2f4:	ea4dd1        	l32r	a13, 40374c28 <_iram_text_start+0x824> (3c024c48 <_flash_rodata_start+0x4b28>)
4037a2f7:	ea4dc1        	l32r	a12, 40374c2c <_iram_text_start+0x828> (3c028204 <__func__$1>)
4037a2fa:	ea35a1        	l32r	a10, 40374bd0 <_iram_text_start+0x7cc> (3c024b56 <_flash_rodata_start+0x4a36>)
4037a2fd:	faa1b2        	movi	a11, 0x1fa
4037a300:	201110        	or	a1, a1, a1
4037a303:	05a4e5        	call8	4037fd50 <__assert_func>
        nesting--;
4037a306:	990b      	addi.n	a9, a9, -1
        port_uxCriticalNesting[coreID] = nesting;
4037a308:	0899      	s32i.n	a9, a8, 0
        if ( nesting == 0 ) {
4037a30a:	b9cc      	bnez.n	a9, 4037a319 <vPortExitCritical+0x99>
            portCLEAR_INTERRUPT_MASK_FROM_ISR(port_uxOldInterruptState[coreID]);
4037a30c:	ea4381        	l32r	a8, 40374c18 <_iram_text_start+0x814> (3fc94dd0 <port_uxOldInterruptState>)
4037a30f:	88aa      	add.n	a8, a8, a10
4037a311:	08a8      	l32i.n	a10, a8, 0
4037a313:	ea3681        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037a316:	0008e0        	callx8	a8
}
4037a319:	f01d      	retw.n
	...

4037a31c <vPortYieldOtherCore>:
{
4037a31c:	004136        	entry	a1, 32
4037a31f:	02ad      	mov.n	a10, a2
    esp_crosscore_int_send_yield( coreid );
4037a321:	fddaa5        	call8	403780cc <esp_crosscore_int_send_yield>
}
4037a324:	f01d      	retw.n
	...

4037a328 <vApplicationStackOverflowHook>:
{
4037a328:	010136        	entry	a1, 128
    const char *str[] = {ERR_STR1, pcTaskName, ERR_STR2};
4037a32b:	ea4181        	l32r	a8, 40374c30 <_iram_text_start+0x82c> (3c024c54 <_flash_rodata_start+0x4b34>)
4037a32e:	0189      	s32i.n	a8, a1, 0
4037a330:	1139      	s32i.n	a3, a1, 4
4037a332:	ea4081        	l32r	a8, 40374c34 <_iram_text_start+0x830> (3c024c7c <_flash_rodata_start+0x4b5c>)
4037a335:	2189      	s32i.n	a8, a1, 8
    char buf[sizeof(ERR_STR1) + CONFIG_FREERTOS_MAX_TASK_NAME_LEN + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037a337:	71cb      	addi.n	a7, a1, 12
4037a339:	bc4c      	movi.n	a12, 75
4037a33b:	0b0c      	movi.n	a11, 0
4037a33d:	07ad      	mov.n	a10, a7
4037a33f:	e85481        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037a342:	0008e0        	callx8	a8
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a345:	060c      	movi.n	a6, 0
    char *dest = buf;
4037a347:	07ad      	mov.n	a10, a7
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a349:	0003c6        	j	4037a35c <vApplicationStackOverflowHook+0x34>
4037a34c:	861000        	lsi	f0, a0, 0x218
        dest = strcat(dest, str[i]);
4037a34f:	28b2a0        	lsi	f10, a2, 160
4037a352:	398100        	lsi	f0, a1, 228
4037a355:	e0ea      	add.n	a14, a0, a14
4037a357:	0008      	l32i.n	a0, a0, 0
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a359:	01c662        	addi	a6, a6, 1
4037a35c:	ed36b6        	bltui	a6, 3, 4037a34d <vApplicationStackOverflowHook+0x25>
    esp_system_abort(buf);
4037a35f:	0cc1a2        	addi	a10, a1, 12
4037a362:	ff42a5        	call8	4037978c <esp_system_abort>
4037a365:	000000        	ill

4037a368 <vPortTCBPreDeleteHook>:
#endif /* XCHAL_CP_NUM > 0 */

void vPortTCBPreDeleteHook( void *pxTCB )
{
4037a368:	004136        	entry	a1, 32
        vPortCleanUpTCB( pxTCB );
    #endif /* CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP */

    #if ( CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS )
        /* Call TLS pointers deletion callbacks */
        vPortTLSPointersDelCb( pxTCB );
4037a36b:	20a220        	or	a10, a2, a2
4037a36e:	ffc325        	call8	40379fa0 <vPortTLSPointersDelCb>
    #endif /* CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS */

    #if ( XCHAL_CP_NUM > 0 )
        /* Cleanup coproc save area */
        vPortCleanUpCoprocArea( pxTCB );
4037a371:	20a220        	or	a10, a2, a2
4037a374:	ffcb65        	call8	4037a02c <vPortCleanUpCoprocArea>
    #endif /* XCHAL_CP_NUM > 0 */
}
4037a377:	000090        	retw
	...

4037a37c <_frxt_setup_switch>:
    .global     _frxt_setup_switch
    .type       _frxt_setup_switch,@function
    .align      4
_frxt_setup_switch:

    ENTRY(16)
4037a37c:	002136        	entry	a1, 16

    getcoreid a3
4037a37f:	03eb30        	rsr.prid	a3
4037a382:	043d30        	extui	a3, a3, 13, 1
    movi    a2, port_switch_flag
4037a385:	ea2d21        	l32r	a2, 40374c3c <_iram_text_start+0x838> (3fc94dc8 <port_switch_flag>)
    addx4   a2,  a3, a2
4037a388:	a02320        	addx4	a2, a3, a2
    movi    a3, 1
4037a38b:	130c      	movi.n	a3, 1
    s32i    a3, a2, 0
4037a38d:	0239      	s32i.n	a3, a2, 0

    RET(16)
4037a38f:	f01d      	retw.n
4037a391:	000000        	ill

4037a394 <_frxt_int_enter>:
    .type   _frxt_int_enter,@function
    .align  4
_frxt_int_enter:

    /* Save a12-13 in the stack frame as required by _xt_context_save. */
    s32i    a12, a1, XT_STK_A12
4037a394:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, a1, XT_STK_A13
4037a396:	1061d2        	s32i	a13, a1, 64

    /* Save return address in a safe place (free a0). */
    mov     a12, a0
4037a399:	00cd      	mov.n	a12, a0

    /* Save the rest of the interrupted context (preserves A12-13). */
    call0   _xt_context_save
4037a39b:	079785        	call0	40381d14 <_xt_context_save>
    /*
    Save interrupted task's SP in TCB only if not nesting.
    Manage nesting directly rather than call the generic IntEnter()
    (in windowed ABI we can't call a C function here anyway because PS.EXCM is still set).
    */
    getcoreid a4
4037a39e:	03eb40        	rsr.prid	a4
4037a3a1:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
4037a3a4:	ea0821        	l32r	a2, 40374bc4 <_iram_text_start+0x7c0> (3fc94de8 <port_xSchedulerRunning>)
    addx4   a2,  a4, a2
4037a3a7:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
4037a3aa:	e8e031        	l32r	a3, 4037472c <_iram_text_start+0x328> (3fc94de0 <port_interruptNesting>)
    addx4   a3,  a4, a3
4037a3ad:	a03430        	addx4	a3, a4, a3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
4037a3b0:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* scheduler not running, no tasks */
4037a3b2:	e29c      	beqz.n	a2, 4037a3d4 <_frxt_int_enter+0x40>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
4037a3b4:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, 1                  /* increment nesting count         */
4037a3b6:	221b      	addi.n	a2, a2, 1
    s32i    a2,  a3, 0                  /* save nesting count              */
4037a3b8:	0329      	s32i.n	a2, a3, 0
    bnei    a2,  1, .Lnested            /* !=0 before incr, so nested      */
4037a3ba:	161266        	bnei	a2, 1, 4037a3d4 <_frxt_int_enter+0x40>

    movi    a2,  pxCurrentTCBs
4037a3bd:	ea2021        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    addx4   a2,  a4, a2
4037a3c0:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
4037a3c3:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f
4037a3c5:	b28c      	beqz.n	a2, 4037a3d4 <_frxt_int_enter+0x40>
    s32i    a1,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCBs->pxTopOfStack = SP */
4037a3c7:	0219      	s32i.n	a1, a2, 0
    movi    a1,  port_IntStack+configISR_STACK_SIZE   /* a1 = top of intr stack for CPU 0  */
4037a3c9:	ea1e11        	l32r	a1, 40374c44 <_iram_text_start+0x840> (3fc92f40 <port_IntStack+0x600>)
    movi    a2,  configISR_STACK_SIZE   /* add configISR_STACK_SIZE * cpu_num to arrive at top of stack for cpu_num */
4037a3cc:	00a622        	movi	a2, 0x600
    mull    a2,  a4, a2
4037a3cf:	822420        	mull	a2, a4, a2
    add     a1,  a1, a2                 /* for current proc */
4037a3d2:	112a      	add.n	a1, a1, a2
    movi    a3,  0              /* whilst ISRs pending keep CPENABLE exception active */
    wsr     a3,  CPENABLE
    rsync
    #endif

    mov     a0,  a12                    /* restore return addr and return  */
4037a3d4:	0c0d      	mov.n	a0, a12
    ret
4037a3d6:	f00d      	ret.n

4037a3d8 <_frxt_int_exit>:
    .globl  _frxt_int_exit
    .type   _frxt_int_exit,@function
    .align  4
_frxt_int_exit:

    getcoreid a4
4037a3d8:	03eb40        	rsr.prid	a4
4037a3db:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
4037a3de:	e9f921        	l32r	a2, 40374bc4 <_iram_text_start+0x7c0> (3fc94de8 <port_xSchedulerRunning>)
    addx4   a2,  a4, a2
4037a3e1:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
4037a3e4:	e8d231        	l32r	a3, 4037472c <_iram_text_start+0x328> (3fc94de0 <port_interruptNesting>)
    addx4   a3,  a4, a3
4037a3e7:	a03430        	addx4	a3, a4, a3
    rsil    a0,  XCHAL_EXCM_LEVEL       /* lock out interrupts             */
4037a3ea:	006300        	rsil	a0, 3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
4037a3ed:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  .Lnoswitch             /* scheduler not running, no tasks */
4037a3ef:	e2ac      	beqz.n	a2, 4037a421 <_frxt_int_exit+0x49>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
4037a3f1:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, -1                 /* decrement nesting count         */
4037a3f3:	220b      	addi.n	a2, a2, -1
    s32i    a2,  a3, 0                  /* save nesting count              */
4037a3f5:	0329      	s32i.n	a2, a3, 0
    bnez    a2,  .Lnesting              /* !=0 after decr so still nested  */
4037a3f7:	62ec      	bnez.n	a2, 4037a421 <_frxt_int_exit+0x49>
    addi    sp,  sp, 4
    wsr     a3, CPENABLE
    rsync                               /* ensure CPENABLE was modified */
    #endif

    movi    a2,  pxCurrentTCBs
4037a3f9:	ea1121        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    addx4   a2,  a4, a2
4037a3fc:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
4037a3ff:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* no task ? go to dispatcher      */
4037a401:	029c      	beqz.n	a2, 4037a415 <_frxt_int_exit+0x3d>
    l32i    a1,  a2, TOPOFSTACK_OFFS    /* SP = pxCurrentTCBs->pxTopOfStack */
4037a403:	0218      	l32i.n	a1, a2, 0

    movi    a2,  port_switch_flag       /* address of switch flag          */
4037a405:	ea0d21        	l32r	a2, 40374c3c <_iram_text_start+0x838> (3fc94dc8 <port_switch_flag>)
    addx4   a2,  a4, a2                 /* point to flag for this cpu      */
4037a408:	a02420        	addx4	a2, a4, a2
    l32i    a3,  a2, 0                  /* a3 = port_switch_flag           */
4037a40b:	0238      	l32i.n	a3, a2, 0
    beqz    a3,  .Lnoswitch             /* flag = 0 means no switch reqd   */
4037a40d:	039c      	beqz.n	a3, 4037a421 <_frxt_int_exit+0x49>
    movi    a3,  0
4037a40f:	00a032        	movi	a3, 0
    s32i    a3,  a2, 0                  /* zero out the flag for next time */
4037a412:	006232        	s32i	a3, a2, 0
    #endif

    #ifdef __XTENSA_CALL0_ABI__
    call0   vPortYieldFromInt       /* call dispatch inside the function; never returns */
    #else
    call4   vPortYieldFromInt       /* this one returns */
4037a415:	201110        	or	a1, a1, a1
4037a418:	000d55        	call4	4037a4f0 <vPortYieldFromInt>
    call0   _frxt_dispatch          /* tail-call dispatcher */
4037a41b:	201110        	or	a1, a1, a1
4037a41e:	000085        	call0	4037a428 <_frxt_dispatch>
    is a nested interrupt, or the interrupted task was not preempted.
    In either case there's no need to load the SP.
    */

    /* Restore full context from interrupt stack frame */
    call0   _xt_context_restore
4037a421:	079945        	call0	40381db8 <_xt_context_restore>
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0,  a1, XT_STK_EXIT
4037a424:	0108      	l32i.n	a0, a1, 0
    ret
4037a426:	f00d      	ret.n

4037a428 <_frxt_dispatch>:
    call0   vTaskSwitchContext  // Get next TCB to resume
    movi    a2, pxCurrentTCBs
    getcoreid a3
    addx4   a2,  a3, a2
    #else
    call4   vTaskSwitchContext  // Get next TCB to resume
4037a428:	010a55        	call4	4037b4d0 <vTaskSwitchContext>
    movi    a2, pxCurrentTCBs
4037a42b:	ea0521        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    getcoreid a3
4037a42e:	03eb30        	rsr.prid	a3
4037a431:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
4037a434:	a02320        	addx4	a2, a3, a2
    #endif
    l32i    a3,  a2, 0
4037a437:	002232        	l32i	a3, a2, 0
    l32i    sp,  a3, TOPOFSTACK_OFFS     /* SP = next_TCB->pxTopOfStack;  */
4037a43a:	002312        	l32i	a1, a3, 0
    s32i    a3,  a2, 0
4037a43d:	006232        	s32i	a3, a2, 0

    /* Determine the type of stack frame. */
    l32i    a2,  sp, XT_STK_EXIT        /* exit dispatcher or solicited flag */
4037a440:	0128      	l32i.n	a2, a1, 0
    bnez    a2,  .L_frxt_dispatch_stk
4037a442:	f2cc      	bnez.n	a2, 4037a455 <_frxt_dispatch+0x2d>

.L_frxt_dispatch_sol:

    /* Solicited stack frame. Restore minimal context and return from vPortYield(). */
    #if XCHAL_HAVE_THREADPTR
    l32i    a2,  sp, XT_SOL_THREADPTR
4037a444:	3128      	l32i.n	a2, a1, 12
    wur.threadptr a2
4037a446:	f3e720        	wur.threadptr	a2
    #endif
    l32i    a3,  sp, XT_SOL_PS
4037a449:	2138      	l32i.n	a3, a1, 8
    l32i    a12, sp, XT_SOL_A12
    l32i    a13, sp, XT_SOL_A13
    l32i    a14, sp, XT_SOL_A14
    l32i    a15, sp, XT_SOL_A15
    #endif
    l32i    a0,  sp, XT_SOL_PC
4037a44b:	1108      	l32i.n	a0, a1, 4
    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE is complete (should be, it was cleared on entry). */
    rsync
4037a44d:	002010        	rsync
    #endif
    /* As soons as PS is restored, interrupts can happen. No need to sync PS. */
    wsr     a3,  PS
4037a450:	13e630        	wsr.ps	a3
    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, XT_SOL_FRMSZ
    ret
    #else
    retw
4037a453:	f01d      	retw.n

.L_frxt_dispatch_stk:

    #if XCHAL_CP_NUM > 0
    /* Restore CPENABLE from task's co-processor save area. */
    movi    a2, pxCurrentTCBs           /* cp_state =                       */
4037a455:	e9fa21        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    getcoreid a3
4037a458:	03eb30        	rsr.prid	a3
4037a45b:	043d30        	extui	a3, a3, 13, 1
    addx4   a2, a3, a2
4037a45e:	a02320        	addx4	a2, a3, a2
    l32i    a2, a2, 0
4037a461:	002222        	l32i	a2, a2, 0
    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a464:	e9f931        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93548 <offset_pxEndOfStack>)
4037a467:	002332        	l32i	a3, a3, 0
4037a46a:	802230        	add	a2, a2, a3
4037a46d:	0228      	l32i.n	a2, a2, 0
4037a46f:	e9f731        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93544 <offset_cpsa>)
4037a472:	0338      	l32i.n	a3, a3, 0
4037a474:	c02230        	sub	a2, a2, a3
4037a477:	037c      	movi.n	a3, -16
4037a479:	102230        	and	a2, a2, a3
    l16ui   a3, a2, XT_CPENABLE         /* CPENABLE = cp_state->cpenable;   */
4037a47c:	001232        	l16ui	a3, a2, 0
    wsr     a3, CPENABLE
4037a47f:	13e030        	wsr.cpenable	a3
    #endif

    /* Interrupt stack frame. Restore full context and return to exit dispatcher. */
    call0   _xt_context_restore
4037a482:	079345        	call0	40381db8 <_xt_context_restore>
    l32i    a15, sp, XT_STK_A15
    #endif

    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE has completed. */
    rsync
4037a485:	002010        	rsync
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0, sp, XT_STK_EXIT
4037a488:	0108      	l32i.n	a0, a1, 0
    ret
4037a48a:	f00d      	ret.n

4037a48c <vPortYield>:
vPortYield:

    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, -XT_SOL_FRMSZ
    #else
    entry   sp,  XT_SOL_FRMSZ
4037a48c:	004136        	entry	a1, 32
    #endif

    rsr     a2,  PS
4037a48f:	03e620        	rsr.ps	a2
    s32i    a0,  sp, XT_SOL_PC
4037a492:	1109      	s32i.n	a0, a1, 4
    s32i    a2,  sp, XT_SOL_PS
4037a494:	2129      	s32i.n	a2, a1, 8
    #if XCHAL_HAVE_THREADPTR
    rur.threadptr a2
4037a496:	e32e70        	rur.threadptr	a2
    s32i    a2,  sp, XT_SOL_THREADPTR
4037a499:	3129      	s32i.n	a2, a1, 12
    s32i    a15, sp, XT_SOL_A15
    #else
    /* Spill register windows. Calling xthal_window_spill() causes extra    */
    /* spills and reloads, so we will set things up to call the _nw version */
    /* instead to save cycles.                                              */
    movi    a6,  ~(PS_WOE_MASK|PS_INTLEVEL_MASK)  /* spills a4-a7 if needed */
4037a49b:	e9ed61        	l32r	a6, 40374c50 <_iram_text_start+0x84c> (fffbfff0 <_rtc_reserved_end+0x9febfff0>)
    and     a2,  a2, a6                           /* clear WOE, INTLEVEL    */
4037a49e:	102260        	and	a2, a2, a6
    addi    a2,  a2, XCHAL_EXCM_LEVEL             /* set INTLEVEL           */
4037a4a1:	03c222        	addi	a2, a2, 3
    wsr     a2,  PS
4037a4a4:	13e620        	wsr.ps	a2
    rsync
4037a4a7:	002010        	rsync
    call0   xthal_window_spill_nw
4037a4aa:	076d05        	call0	40381b7c <xthal_window_spill_nw>
    l32i    a2,  sp, XT_SOL_PS                    /* restore PS             */
4037a4ad:	2128      	l32i.n	a2, a1, 8
    wsr     a2,  PS
4037a4af:	13e620        	wsr.ps	a2
    #endif

    rsil    a2,  XCHAL_EXCM_LEVEL       /* disable low/med interrupts       */
4037a4b2:	006320        	rsil	a2, 3

    #if XCHAL_CP_NUM > 0
    /* Save coprocessor callee-saved state (if any). At this point CPENABLE */
    /* should still reflect which CPs were in use (enabled).                */
    call0   _xt_coproc_savecs
4037a4b5:	079a05        	call0	40381e58 <_xt_coproc_savecs>
    #endif

    movi    a2,  pxCurrentTCBs
4037a4b8:	e9e221        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    getcoreid a3
4037a4bb:	03eb30        	rsr.prid	a3
4037a4be:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
4037a4c1:	a02320        	addx4	a2, a3, a2
    l32i    a2,  a2, 0                  /* a2 = pxCurrentTCBs                */
4037a4c4:	0228      	l32i.n	a2, a2, 0
    movi    a3,  0
4037a4c6:	030c      	movi.n	a3, 0
    s32i    a3,  sp, XT_SOL_EXIT        /* 0 to flag as solicited frame     */
4037a4c8:	0139      	s32i.n	a3, a1, 0
    s32i    sp,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCBs->pxTopOfStack = SP  */
4037a4ca:	0219      	s32i.n	a1, a2, 0

    #if XCHAL_CP_NUM > 0
    /* Clear CPENABLE, also in task's co-processor state save area. */
    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a4cc:	e9df31        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93548 <offset_pxEndOfStack>)
4037a4cf:	0338      	l32i.n	a3, a3, 0
4037a4d1:	223a      	add.n	a2, a2, a3
4037a4d3:	0228      	l32i.n	a2, a2, 0
4037a4d5:	e9dd31        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93544 <offset_cpsa>)
4037a4d8:	0338      	l32i.n	a3, a3, 0
4037a4da:	c02230        	sub	a2, a2, a3
4037a4dd:	037c      	movi.n	a3, -16
4037a4df:	102230        	and	a2, a2, a3
    movi    a3,  0
4037a4e2:	030c      	movi.n	a3, 0
    wsr     a3,  CPENABLE
4037a4e4:	13e030        	wsr.cpenable	a3
    beqz    a2,  1f
4037a4e7:	002216        	beqz	a2, 4037a4ed <vPortYield+0x61>
    s16i    a3,  a2, XT_CPENABLE        /* clear saved cpenable             */
4037a4ea:	005232        	s16i	a3, a2, 0
1:
    #endif

    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
4037a4ed:	fff385        	call0	4037a428 <_frxt_dispatch>

4037a4f0 <vPortYieldFromInt>:
    .globl  vPortYieldFromInt
    .type   vPortYieldFromInt,@function
    .align  4
vPortYieldFromInt:

    ENTRY(16)
4037a4f0:	002136        	entry	a1, 16

    #if XCHAL_CP_NUM > 0
    /* Save CPENABLE in task's co-processor save area, and clear CPENABLE.  */
    movi    a2, pxCurrentTCBs           /* cp_state =                       */
4037a4f3:	e9d321        	l32r	a2, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    getcoreid a3
4037a4f6:	03eb30        	rsr.prid	a3
4037a4f9:	043d30        	extui	a3, a3, 13, 1
    addx4   a2, a3, a2
4037a4fc:	a02320        	addx4	a2, a3, a2
    l32i    a2, a2, 0
4037a4ff:	0228      	l32i.n	a2, a2, 0

    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a501:	e9d131        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93548 <offset_pxEndOfStack>)
4037a504:	0338      	l32i.n	a3, a3, 0
4037a506:	223a      	add.n	a2, a2, a3
4037a508:	0228      	l32i.n	a2, a2, 0
4037a50a:	e9d031        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93544 <offset_cpsa>)
4037a50d:	0338      	l32i.n	a3, a3, 0
4037a50f:	c02230        	sub	a2, a2, a3
4037a512:	037c      	movi.n	a3, -16
4037a514:	102230        	and	a2, a2, a3

    rsr     a3, CPENABLE
4037a517:	03e030        	rsr.cpenable	a3
    s16i    a3, a2, XT_CPENABLE         /* cp_state->cpenable = CPENABLE;   */
4037a51a:	005232        	s16i	a3, a2, 0
    movi    a3, 0
4037a51d:	030c      	movi.n	a3, 0
    wsr     a3, CPENABLE                /* disable all co-processors        */
4037a51f:	13e030        	wsr.cpenable	a3
    #ifdef __XTENSA_CALL0_ABI__
    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
    /* Never reaches here. */
    #else
    RET(16)
4037a522:	f01d      	retw.n

4037a524 <_frxt_task_coproc_state>:
    .align  4
_frxt_task_coproc_state:


    /* We can use a3 as a scratchpad, the instances of code calling XT_RTOS_CP_STATE don't seem to need it saved. */
    getcoreid a3
4037a524:	03eb30        	rsr.prid	a3
4037a527:	043d30        	extui	a3, a3, 13, 1
    movi    a15, port_xSchedulerRunning /* if (port_xSchedulerRunning              */
4037a52a:	e9a6f1        	l32r	a15, 40374bc4 <_iram_text_start+0x7c0> (3fc94de8 <port_xSchedulerRunning>)
    addx4   a15, a3,a15
4037a52d:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a530:	0ff8      	l32i.n	a15, a15, 0
    beqz    a15, 1f
4037a532:	afac      	beqz.n	a15, 4037a560 <_frxt_task_coproc_state+0x3c>
    movi    a15, port_interruptNesting  /* && port_interruptNesting == 0           */
4037a534:	e87ef1        	l32r	a15, 4037472c <_iram_text_start+0x328> (3fc94de0 <port_interruptNesting>)
    addx4   a15, a3, a15
4037a537:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a53a:	0ff8      	l32i.n	a15, a15, 0
    bnez    a15, 1f
4037a53c:	0fec      	bnez.n	a15, 4037a560 <_frxt_task_coproc_state+0x3c>

    movi    a15, pxCurrentTCBs
4037a53e:	e9c0f1        	l32r	a15, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    addx4   a15, a3, a15
4037a541:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0                 /* && pxCurrentTCBs != 0) {                 */
4037a544:	0ff8      	l32i.n	a15, a15, 0

    beqz    a15, 2f
4037a546:	8f9c      	beqz.n	a15, 4037a562 <_frxt_task_coproc_state+0x3e>
    get_cpsa_from_tcb a15, a3           /* After this, pointer to CP save area is in a15, a3 is destroyed */
4037a548:	e9c031        	l32r	a3, 40374c48 <_iram_text_start+0x844> (3fc93548 <offset_pxEndOfStack>)
4037a54b:	0338      	l32i.n	a3, a3, 0
4037a54d:	ff3a      	add.n	a15, a15, a3
4037a54f:	0ff8      	l32i.n	a15, a15, 0
4037a551:	e9be31        	l32r	a3, 40374c4c <_iram_text_start+0x848> (3fc93544 <offset_cpsa>)
4037a554:	0338      	l32i.n	a3, a3, 0
4037a556:	c0ff30        	sub	a15, a15, a3
4037a559:	037c      	movi.n	a3, -16
4037a55b:	10ff30        	and	a15, a15, a3
    ret
4037a55e:	f00d      	ret.n

1:  movi    a15, 0
4037a560:	0f0c      	movi.n	a15, 0
2:  ret
4037a562:	f00d      	ret.n

4037a564 <_frxt_coproc_exc_hook>:
    .type   _frxt_coproc_exc_hook,@function
    .align  4
_frxt_coproc_exc_hook:

    #if configNUM_CORES > 1
    getcoreid a2                            /* a2 = xCurCoreID */
4037a564:	03eb20        	rsr.prid	a2
4037a567:	042d20        	extui	a2, a2, 13, 1
    /* if (port_xSchedulerRunning[xCurCoreID] == 0) */
    movi    a3, port_xSchedulerRunning
4037a56a:	e99631        	l32r	a3, 40374bc4 <_iram_text_start+0x7c0> (3fc94de8 <port_xSchedulerRunning>)
    addx4   a3, a2, a3
4037a56d:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
4037a570:	0338      	l32i.n	a3, a3, 0
    beqz    a3, 1f                          /* Scheduler hasn't started yet. Return. */
4037a572:	a39c      	beqz.n	a3, 4037a590 <_frxt_coproc_exc_hook+0x2c>
    /* if (port_interruptNesting[xCurCoreID] != 0) */
    movi    a3, port_interruptNesting
4037a574:	e86e31        	l32r	a3, 4037472c <_iram_text_start+0x328> (3fc94de0 <port_interruptNesting>)
    addx4   a3, a2, a3
4037a577:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
4037a57a:	0338      	l32i.n	a3, a3, 0
    bnez    a3, 1f                          /* We are in an interrupt. Return*/
4037a57c:	03dc      	bnez.n	a3, 4037a590 <_frxt_coproc_exc_hook+0x2c>
    /* CP operations are incompatible with unpinned tasks. Thus we pin the task
    to the current running core. */
    movi    a3, pxCurrentTCBs
4037a57e:	e9b031        	l32r	a3, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
    addx4   a3, a2, a3
4037a581:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0                       /* a3 = pxCurrentTCBs[xCurCoreID] */
4037a584:	0338      	l32i.n	a3, a3, 0
    movi    a4, offset_xCoreID
4037a586:	e9b341        	l32r	a4, 40374c54 <_iram_text_start+0x850> (3fc93540 <offset_xCoreID>)
    l32i    a4, a4, 0                       /* a4 = offset_xCoreID */
4037a589:	0448      	l32i.n	a4, a4, 0
    add     a3, a3, a4                      /* a3 = &TCB.xCoreID */
4037a58b:	334a      	add.n	a3, a3, a4
    s32i    a2, a3, 0                       /* TCB.xCoreID = xCurCoreID */
4037a58d:	006322        	s32i	a2, a3, 0
1:
    #endif /* configNUM_CORES > 1 */

    ret
4037a590:	f00d      	ret.n
	...

4037a594 <pvPortMalloc>:
#define portFREERTOS_HEAP_CAPS    ( MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT )

/*-----------------------------------------------------------*/

void * pvPortMalloc(size_t xWantedSize)
{
4037a594:	004136        	entry	a1, 32
4037a597:	20a220        	or	a10, a2, a2

    /* All dynamic allocation done by FreeRTOS goes through this function. If
     * users need to allocate FreeRTOS objects into external RAM, they should
     * use the "static" equivalents of FreeRTOS API to create FreeRTOS objects
     * (e.g., queues). */
    pvReturn = heap_caps_malloc(xWantedSize, portFREERTOS_HEAP_CAPS);
4037a59a:	e8d0b1        	l32r	a11, 403748dc <_iram_text_start+0x4d8> (804 <UserFrameTotalSize+0x704>)
4037a59d:	fb99a5        	call8	40375f38 <heap_caps_malloc>

    return pvReturn;
}
4037a5a0:	202aa0        	or	a2, a10, a10
4037a5a3:	000090        	retw
	...

4037a5a8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree(void * pv)
{
4037a5a8:	004136        	entry	a1, 32
4037a5ab:	02ad      	mov.n	a10, a2
    heap_caps_free(pv);
4037a5ad:	fbbca5        	call8	40376178 <heap_caps_free>
}
4037a5b0:	f01d      	retw.n
	...

4037a5b4 <xPortCheckValidTCBMem>:
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
#endif /* CONFIG_IDF_TARGET_LINUX */
}

bool xPortCheckValidTCBMem(const void * ptr)
{
4037a5b4:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037a5b7:	e83391        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
4037a5ba:	929a      	add.n	a9, a2, a9
4037a5bc:	e9a781        	l32r	a8, 40374c58 <_iram_text_start+0x854> (757fff <UserFrameTotalSize+0x757eff>)
4037a5bf:	628890        	lsi	f9, a8, 0x188
4037a5c2:	880b      	addi.n	a8, a8, -1
4037a5c4:	608080        	neg	a8, a8
4037a5c7:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037a5ca:	e9a491        	l32r	a9, 40374c5c <_iram_text_start+0x858> (b0000000 <_rtc_reserved_end+0x4ff00000>)
4037a5cd:	929a      	add.n	a9, a2, a9
4037a5cf:	e808b1        	l32r	a11, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
4037a5d2:	629b90        	lsi	f9, a11, 0x188
4037a5d5:	990b      	addi.n	a9, a9, -1
4037a5d7:	609090        	neg	a9, a9
4037a5da:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037a5dd:	e803c1        	l32r	a12, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4037a5e0:	c2ca      	add.n	a12, a2, a12
4037a5e2:	62bbc0        	lsi	f12, a11, 0x188
4037a5e5:	bb0b      	addi.n	a11, a11, -1
4037a5e7:	60b0b0        	neg	a11, a11
4037a5ea:	74b0b0        	extui	a11, a11, 0, 8
#if CONFIG_IDF_TARGET_LINUX
    return true;
#else /* CONFIG_IDF_TARGET_LINUX */
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037a5ed:	208890        	or	a8, a8, a9
4037a5f0:	08cc      	bnez.n	a8, 4037a5f4 <xPortCheckValidTCBMem+0x40>
4037a5f2:	eb8c      	beqz.n	a11, 4037a604 <xPortCheckValidTCBMem+0x50>
4037a5f4:	20a220        	or	a10, a2, a2
4037a5f7:	fdcaa5        	call8	403782a0 <esp_ptr_byte_accessible>
4037a5fa:	00ba16        	beqz	a10, 4037a609 <xPortCheckValidTCBMem+0x55>
4037a5fd:	01a022        	movi	a2, 1
4037a600:	0001c6        	j	4037a60b <xPortCheckValidTCBMem+0x57>
4037a603:	020c00        	andb	b0, b12, b0
4037a606:	000046        	j	4037a60b <xPortCheckValidTCBMem+0x57>
4037a609:	020c      	movi.n	a2, 0
#endif /* CONFIG_IDF_TARGET_LINUX */
}
4037a60b:	f01d      	retw.n
4037a60d:	000000        	ill

4037a610 <xPortcheckValidStackMem>:

bool xPortcheckValidStackMem(const void * ptr)
{
4037a610:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037a613:	e81c91        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
4037a616:	929a      	add.n	a9, a2, a9
4037a618:	e99081        	l32r	a8, 40374c58 <_iram_text_start+0x854> (757fff <UserFrameTotalSize+0x757eff>)
4037a61b:	628890        	lsi	f9, a8, 0x188
4037a61e:	880b      	addi.n	a8, a8, -1
4037a620:	608080        	neg	a8, a8
4037a623:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037a626:	e98d91        	l32r	a9, 40374c5c <_iram_text_start+0x858> (b0000000 <_rtc_reserved_end+0x4ff00000>)
4037a629:	929a      	add.n	a9, a2, a9
4037a62b:	e7f1b1        	l32r	a11, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
4037a62e:	629b90        	lsi	f9, a11, 0x188
4037a631:	990b      	addi.n	a9, a9, -1
4037a633:	609090        	neg	a9, a9
4037a636:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037a639:	e7ecc1        	l32r	a12, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4037a63c:	c2ca      	add.n	a12, a2, a12
4037a63e:	62bbc0        	lsi	f12, a11, 0x188
4037a641:	bb0b      	addi.n	a11, a11, -1
4037a643:	60b0b0        	neg	a11, a11
4037a646:	74b0b0        	extui	a11, a11, 0, 8
    return true;
#else /* CONFIG_IDF_TARGET_LINUX */
#ifdef CONFIG_FREERTOS_TASK_CREATE_ALLOW_EXT_MEM
    return esp_ptr_byte_accessible(ptr);
#else
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037a649:	208890        	or	a8, a8, a9
4037a64c:	08cc      	bnez.n	a8, 4037a650 <xPortcheckValidStackMem+0x40>
4037a64e:	db8c      	beqz.n	a11, 4037a65f <xPortcheckValidStackMem+0x4f>
4037a650:	20a220        	or	a10, a2, a2
4037a653:	fdc4e5        	call8	403782a0 <esp_ptr_byte_accessible>
4037a656:	00aa16        	beqz	a10, 4037a664 <xPortcheckValidStackMem+0x54>
4037a659:	01a022        	movi	a2, 1
4037a65c:	000186        	j	4037a666 <xPortcheckValidStackMem+0x56>
4037a65f:	020c      	movi.n	a2, 0
4037a661:	000046        	j	4037a666 <xPortcheckValidStackMem+0x56>
4037a664:	020c      	movi.n	a2, 0
#endif
#endif /* CONFIG_IDF_TARGET_LINUX */
}
4037a666:	f01d      	retw.n

4037a668 <vApplicationGetIdleTaskMemory>:
*/
#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
                                   StackType_t **ppxIdleTaskStackBuffer,
                                   uint32_t *pulIdleTaskStackSize)
{
4037a668:	004136        	entry	a1, 32
        pxTCBBufferTemp = pvPortMalloc(sizeof(StaticTask_t));
        pxStackBufferTemp = pvPortMalloc(configMINIMAL_STACK_SIZE);
    }
#else /* portSTACK_GROWTH */
    {
        pxStackBufferTemp = pvPortMalloc(configMINIMAL_STACK_SIZE);
4037a66b:	00a6a2        	movi	a10, 0x600
4037a66e:	fff265        	call8	4037a594 <pvPortMalloc>
4037a671:	0a7d      	mov.n	a7, a10
        pxTCBBufferTemp = pvPortMalloc(sizeof(StaticTask_t));
4037a673:	54a1a2        	movi	a10, 0x154
4037a676:	fff1e5        	call8	4037a594 <pvPortMalloc>
    }
#endif /* portSTACK_GROWTH */

    assert(pxTCBBufferTemp != NULL);
4037a679:	00da56        	bnez	a10, 4037a68a <vApplicationGetIdleTaskMemory+0x22>
4037a67c:	e979d1        	l32r	a13, 40374c60 <_iram_text_start+0x85c> (3c024c90 <_flash_rodata_start+0x4b70>)
4037a67f:	e979c1        	l32r	a12, 40374c64 <_iram_text_start+0x860> (3c028244 <__func__$1>)
4037a682:	4b3c      	movi.n	a11, 52
4037a684:	e979a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c024cc2 <_flash_rodata_start+0x4ba2>)
4037a687:	056ca5        	call8	4037fd50 <__assert_func>
    assert(pxStackBufferTemp != NULL);
4037a68a:	c7cc      	bnez.n	a7, 4037a69a <vApplicationGetIdleTaskMemory+0x32>
4037a68c:	e978d1        	l32r	a13, 40374c6c <_iram_text_start+0x868> (3c024cd0 <_flash_rodata_start+0x4bb0>)
4037a68f:	e975c1        	l32r	a12, 40374c64 <_iram_text_start+0x860> (3c028244 <__func__$1>)
4037a692:	5b3c      	movi.n	a11, 53
4037a694:	e975a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c024cc2 <_flash_rodata_start+0x4ba2>)
4037a697:	056ba5        	call8	4037fd50 <__assert_func>
    //Write back pointers
    *ppxIdleTaskTCBBuffer = pxTCBBufferTemp;
4037a69a:	02a9      	s32i.n	a10, a2, 0
    *ppxIdleTaskStackBuffer = pxStackBufferTemp;
4037a69c:	0379      	s32i.n	a7, a3, 0
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
4037a69e:	00a682        	movi	a8, 0x600
4037a6a1:	0489      	s32i.n	a8, a4, 0
}
4037a6a3:	f01d      	retw.n
4037a6a5:	000000        	ill

4037a6a8 <vSystimerSetup>:
 * Both timer alarms are configured in periodic mode.
 * It is done at the same time so SysTicks for both CPUs occur at the same time or very close.
 * Shifts a time of triggering interrupts for core 0 and core 1.
 */
void vSystimerSetup(void)
{
4037a6a8:	006136        	entry	a1, 48
4037a6ab:	03eb70        	rsr.prid	a7
4037a6ae:	047d70        	extui	a7, a7, 13, 1
#endif
    /* Systimer HAL layer object */
    static systimer_hal_context_t systimer_hal;
    /* set system timer interrupt vector */

    ESP_ERROR_CHECK(esp_intr_alloc(ETS_SYSTIMER_TARGET0_INTR_SOURCE + cpuid, ESP_INTR_FLAG_IRAM | level, SysTickIsrHandler, &systimer_hal, NULL));
4037a6b1:	00a0e2        	movi	a14, 0
4037a6b4:	e96fd1        	l32r	a13, 40374c70 <_iram_text_start+0x86c> (3fc94df0 <systimer_hal$1>)
4037a6b7:	e96fc1        	l32r	a12, 40374c74 <_iram_text_start+0x870> (4037a828 <SysTickIsrHandler>)
4037a6ba:	02a4b2        	movi	a11, 0x402
4037a6bd:	39c7a2        	addi	a10, a7, 57
4037a6c0:	e97481        	l32r	a8, 40374c90 <_iram_text_start+0x88c> (4200384c <esp_intr_alloc>)
4037a6c3:	0008e0        	callx8	a8
4037a6c6:	00ea16        	beqz	a10, 4037a6d8 <vSystimerSetup+0x30>
4037a6c9:	e96be1        	l32r	a14, 40374c78 <_iram_text_start+0x874> (3c024cec <_flash_rodata_start+0x4bcc>)
4037a6cc:	e96cd1        	l32r	a13, 40374c7c <_iram_text_start+0x878> (3c02826c <__func__$0>)
4037a6cf:	48a0c2        	movi	a12, 72
4037a6d2:	e96bb1        	l32r	a11, 40374c80 <_iram_text_start+0x87c> (3c024d6c <_flash_rodata_start+0x4c4c>)
4037a6d5:	ff08a5        	call8	40379760 <_esp_error_check_failed>

    if (cpuid == 0) {
4037a6d8:	044716        	beqz	a7, 4037a720 <vSystimerSetup+0x78>
4037a6db:	004386        	j	4037a7ed <vSystimerSetup+0x145>
4037a6de:	810000        	src	a0, a0, a0
 *
 * @param enable true to enable, false to disable
 */
static inline void systimer_ll_enable_bus_clock(bool enable)
{
    SYSTEM.perip_clk_en0.systimer_clk_en = enable;
4037a6e1:	e8eb      	addi.n	a14, a8, 14
4037a6e3:	0020c0        	memw
4037a6e6:	062892        	l32i	a9, a8, 24
4037a6e9:	e8bba1        	l32r	a10, 403749d8 <_iram_text_start+0x5d4> (20000000 <UserFrameTotalSize+0x1fffff00>)
4037a6ec:	2099a0        	or	a9, a9, a10
4037a6ef:	0020c0        	memw
4037a6f2:	066892        	s32i	a9, a8, 24
 *
 * @param group_id Group ID
 */
static inline void systimer_ll_reset_register(void)
{
    SYSTEM.perip_rst_en0.systimer_rst = 1;
4037a6f5:	0020c0        	memw
4037a6f8:	082892        	l32i	a9, a8, 32
4037a6fb:	2099a0        	or	a9, a9, a10
4037a6fe:	0020c0        	memw
4037a701:	8899      	s32i.n	a9, a8, 32
    SYSTEM.perip_rst_en0.systimer_rst = 0;
4037a703:	0020c0        	memw
4037a706:	8898      	l32i.n	a9, a8, 32
4037a708:	e83ba1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037a70b:	1099a0        	and	a9, a9, a10
4037a70e:	0020c0        	memw
4037a711:	8899      	s32i.n	a9, a8, 32
        PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_SYSTIMER_MODULE, ref_count) {
4037a713:	4a2c      	movi.n	a10, 36
4037a715:	fbfb65        	call8	403766cc <periph_rcc_acquire_exit>
4037a718:	660b      	addi.n	a6, a6, -1
4037a71a:	746060        	extui	a6, a6, 0, 8
4037a71d:	000086        	j	4037a723 <vSystimerSetup+0x7b>
4037a720:	01a062        	movi	a6, 1
4037a723:	00e616        	beqz	a6, 4037a735 <vSystimerSetup+0x8d>
4037a726:	24a0a2        	movi	a10, 36
4037a729:	fbf925        	call8	403766bc <periph_rcc_acquire_enter>
4037a72c:	0abd      	mov.n	a11, a10
            if (ref_count == 0) {
4037a72e:	faea16        	beqz	a10, 4037a6e0 <vSystimerSetup+0x38>
4037a731:	fff786        	j	4037a713 <vSystimerSetup+0x6b>
4037a734:	4e6100        	f64rnd	a6, a1, a0, 0
                systimer_ll_enable_bus_clock(true);
                systimer_ll_reset_register();
            }
        }
        systimer_hal_init(&systimer_hal);
4037a737:	60e9      	s32i.n	a14, a0, 24
4037a739:	e520a6        	blti	a0, 2, 4037a722 <vSystimerSetup+0x7a>
4037a73c:	8103c3        	lsi	f12, a3, 0x204
        systimer_hal_tick_rate_ops_t ops = {
4037a73f:	92e951        	l32r	a5, 4035f2e4 <rom_rx_gain_force+0x358eb8>
4037a742:	0028      	l32i.n	a2, a0, 0
4037a744:	1888      	l32i.n	a8, a8, 4
4037a746:	0199      	s32i.n	a9, a1, 0
4037a748:	1189      	s32i.n	a8, a1, 4
            .ticks_to_us = systimer_ticks_to_us,
            .us_to_ticks = systimer_us_to_ticks,
        };
        systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
4037a74a:	01bd      	mov.n	a11, a1
4037a74c:	06ad      	mov.n	a10, a6
4037a74e:	03dae5        	call8	4037e4fc <systimer_hal_set_tick_rate_ops>
        systimer_ll_set_counter_value(systimer_hal.dev, SYSTIMER_COUNTER_OS_TICK, 0);
4037a751:	0698      	l32i.n	a9, a6, 0
    return dev->unit_op[counter_id].timer_unit_value_valid;
}

__attribute__((always_inline)) static inline void systimer_ll_set_counter_value(systimer_dev_t *dev, uint32_t counter_id, uint64_t value)
{
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037a753:	0020c0        	memw
4037a756:	5988      	l32i.n	a8, a9, 20
4037a758:	b58480        	extui	a8, a8, 20, 12
4037a75b:	0188c0        	slli	a8, a8, 20
4037a75e:	0020c0        	memw
4037a761:	5989      	s32i.n	a8, a9, 20
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037a763:	080c      	movi.n	a8, 0
4037a765:	0020c0        	memw
4037a768:	6989      	s32i.n	a8, a9, 24
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
}

__attribute__((always_inline)) static inline void systimer_ll_apply_counter_value(systimer_dev_t *dev, uint32_t counter_id)
{
    dev->unit_load[counter_id].val = 0x01;
4037a76a:	180c      	movi.n	a8, 1
4037a76c:	0020c0        	memw
4037a76f:	186982        	s32i	a8, a9, 96
        systimer_ll_apply_counter_value(systimer_hal.dev, SYSTIMER_COUNTER_OS_TICK);

        for (cpuid = 0; cpuid < SOC_CPU_CORES_NUM; cpuid++) {
4037a772:	076d      	mov.n	a6, a7
4037a774:	0006c6        	j	4037a793 <vSystimerSetup+0xeb>
4037a777:	d20000        	quos	a0, a0, a0
            // Set stall option and alarm mode to default state. Below they will be set to a required state.
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, cpuid, false);
4037a77a:	6000a0        	neg	a0, a10
4037a77d:	0c20c6        	j	4037d804 <spimem_flash_ll_set_read_mode+0x114>
4037a780:	a11b      	addi.n	a10, a1, 1
4037a782:	e93b      	addi.n	a14, a9, 3
4037a784:	03dee5        	call8	4037e574 <systimer_hal_counter_can_stall_by_cpu>
            uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;
            systimer_hal_select_alarm_mode(&systimer_hal, alarm_id, SYSTIMER_ALARM_MODE_ONESHOT);
4037a787:	0c0c      	movi.n	a12, 0
4037a789:	06bd      	mov.n	a11, a6
4037a78b:	e939a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc94df0 <systimer_hal$1>)
4037a78e:	03d2e5        	call8	4037e4bc <systimer_hal_select_alarm_mode>
        for (cpuid = 0; cpuid < SOC_CPU_CORES_NUM; cpuid++) {
4037a791:	661b      	addi.n	a6, a6, 1
4037a793:	e226b6        	bltui	a6, 2, 4037a779 <vSystimerSetup+0xd1>
4037a796:	001306        	j	4037a7e6 <vSystimerSetup+0x13e>

        for (cpuid = 0; cpuid < configNUM_CORES; ++cpuid) {
            uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;

            /* configure the timer */
            systimer_hal_connect_alarm_counter(&systimer_hal, alarm_id, SYSTIMER_COUNTER_OS_TICK);
4037a799:	e93561        	l32r	a6, 40374c70 <_iram_text_start+0x86c> (3fc94df0 <systimer_hal$1>)
4037a79c:	1c0c      	movi.n	a12, 1
4037a79e:	07bd      	mov.n	a11, a7
4037a7a0:	06ad      	mov.n	a10, a6
4037a7a2:	03dae5        	call8	4037e550 <systimer_hal_connect_alarm_counter>
            systimer_hal_set_alarm_period(&systimer_hal, alarm_id, 1000000UL / CONFIG_FREERTOS_HZ);
4037a7a5:	e938c1        	l32r	a12, 40374c88 <_iram_text_start+0x884> (2710 <UserFrameTotalSize+0x2610>)
4037a7a8:	07bd      	mov.n	a11, a7
4037a7aa:	06ad      	mov.n	a10, a6
4037a7ac:	03c365        	call8	4037e3e4 <systimer_hal_set_alarm_period>
            systimer_hal_select_alarm_mode(&systimer_hal, alarm_id, SYSTIMER_ALARM_MODE_PERIOD);
4037a7af:	1c0c      	movi.n	a12, 1
4037a7b1:	07bd      	mov.n	a11, a7
4037a7b3:	06ad      	mov.n	a10, a6
4037a7b5:	03d065        	call8	4037e4bc <systimer_hal_select_alarm_mode>
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, cpuid, true);
4037a7b8:	1d0c      	movi.n	a13, 1
4037a7ba:	07cd      	mov.n	a12, a7
4037a7bc:	0dbd      	mov.n	a11, a13
4037a7be:	06ad      	mov.n	a10, a6
4037a7c0:	03db25        	call8	4037e574 <systimer_hal_counter_can_stall_by_cpu>
            if (cpuid == 0) {
4037a7c3:	d7dc      	bnez.n	a7, 4037a7e4 <vSystimerSetup+0x13c>
                systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a7c5:	e92a61        	l32r	a6, 40374c70 <_iram_text_start+0x86c> (3fc94df0 <systimer_hal$1>)
4037a7c8:	07bd      	mov.n	a11, a7
4037a7ca:	20a660        	or	a10, a6, a6
4037a7cd:	03d3e5        	call8	4037e50c <systimer_hal_enable_alarm_int>
                systimer_hal_enable_counter(&systimer_hal, SYSTIMER_COUNTER_OS_TICK);
4037a7d0:	1b0c      	movi.n	a11, 1
4037a7d2:	20a660        	or	a10, a6, a6
4037a7d5:	03d565        	call8	4037e52c <systimer_hal_enable_counter>
#ifndef CONFIG_FREERTOS_UNICORE
                // SysTick of core 0 and core 1 are shifted by half of period
                systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, 1000000UL / CONFIG_FREERTOS_HZ / 2);
4037a7d8:	e92dc1        	l32r	a12, 40374c8c <_iram_text_start+0x888> (1388 <UserFrameTotalSize+0x1288>)
4037a7db:	0d0c      	movi.n	a13, 0
4037a7dd:	1b0c      	movi.n	a11, 1
4037a7df:	06ad      	mov.n	a10, a6
4037a7e1:	03c865        	call8	4037e468 <systimer_hal_counter_value_advance>
        for (cpuid = 0; cpuid < configNUM_CORES; ++cpuid) {
4037a7e4:	771b      	addi.n	a7, a7, 1
4037a7e6:	af27b6        	bltui	a7, 2, 4037a799 <vSystimerSetup+0xf1>
4037a7e9:	000206        	j	4037a7f5 <vSystimerSetup+0x14d>
4037a7ec:	07bd00        	lsi	f0, a13, 28
#endif
            }
        }
    } else {
        uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;
        systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a7ef:	e920a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc94df0 <systimer_hal$1>)
4037a7f2:	03d1a5        	call8	4037e50c <systimer_hal_enable_alarm_int>
    }
}
4037a7f5:	f01d      	retw.n
	...

4037a7f8 <vPortSetupTimer>:
 *
 * - CCOUNT timer is used if CONFIG_FREERTOS_SYSTICK_USES_CCOUNT is set
 * - SYSTIMER is used if CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER is set
 */
void vPortSetupTimer(void)
{
4037a7f8:	004136        	entry	a1, 32
    extern void _xt_tick_divisor_init(void);
    /* Init the tick divisor value */
    _xt_tick_divisor_init();
    _frxt_tick_timer_init();
#else /* CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER */
    vSystimerSetup();
4037a7fb:	ffeae5        	call8	4037a6a8 <vSystimerSetup>
#endif /* CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER */
}
4037a7fe:	f01d      	retw.n

4037a800 <xPortSysTickHandler>:
 *  - _frxt_timer_int for xtensa with CONFIG_FREERTOS_SYSTICK_USES_CCOUNT
 *  - SysTickIsrHandler for xtensa with CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER
 *  - SysTickIsrHandler for riscv
 */
BaseType_t xPortSysTickHandler(void)
{
4037a800:	004136        	entry	a1, 32
#endif //configBENCHMARK
    traceISR_ENTER(SYSTICK_INTR_ID);

    // Call IDF Tick Hook
    extern void esp_vApplicationTickHook(void);
    esp_vApplicationTickHook();
4037a803:	fb5ce5        	call8	40375dd0 <esp_vApplicationTickHook>
4037a806:	03eb80        	rsr.prid	a8
4037a809:	048d80        	extui	a8, a8, 13, 1
    /*
    Multi-core IDF FreeRTOS requires that...
        - core 0 calls xTaskIncrementTick()
        - core 1 calls xTaskIncrementTickOtherCores()
    */
    if (xPortGetCoreID() == 0) {
4037a80c:	009856        	bnez	a8, 4037a819 <xPortSysTickHandler+0x19>
        xSwitchRequired = xTaskIncrementTick();
4037a80f:	009fa5        	call8	4037b208 <xTaskIncrementTick>
4037a812:	0a2d      	mov.n	a2, a10
4037a814:	0001c6        	j	4037a81f <xPortSysTickHandler+0x1f>
4037a817:	e50000        	extui	a0, a0, 16, 15
    } else {
        xSwitchRequired = xTaskIncrementTickOtherCores();
4037a81a:	a001d0        	addx4	a0, a1, a13
4037a81d:	202a      	add.n	a2, a0, a2
    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
#endif /* configNUM_CORES > 1 */
#endif /* !CONFIG_FREERTOS_SMP */

    // Check if yield is required
    if (xSwitchRequired != pdFALSE) {
4037a81f:	002216        	beqz	a2, 4037a825 <xPortSysTickHandler+0x25>
        portYIELD_FROM_ISR();
4037a822:	ffb5a5        	call8	4037a37c <_frxt_setup_switch>
    } else {
        traceISR_EXIT();
    }
    return xSwitchRequired;
}
4037a825:	f01d      	retw.n
	...

4037a828 <SysTickIsrHandler>:
{
4037a828:	004136        	entry	a1, 32
4037a82b:	03eb60        	rsr.prid	a6
4037a82e:	046d60        	extui	a6, a6, 13, 1
        systimer_ll_clear_alarm_int(systimer_hal->dev, alarm_id);
4037a831:	002292        	l32i	a9, a2, 0
    return dev->int_st.val & (1 << alarm_id);
}

__attribute__((always_inline)) static inline void systimer_ll_clear_alarm_int(systimer_dev_t *dev, uint32_t alarm_id)
{
    dev->int_clr.val |= 1 << alarm_id;
4037a834:	0020c0        	memw
4037a837:	1b2982        	l32i	a8, a9, 108
4037a83a:	01a0b2        	movi	a11, 1
4037a83d:	401600        	ssl	a6
4037a840:	a15b00        	sll	a5, a11
4037a843:	208850        	or	a8, a8, a5
4037a846:	0020c0        	memw
4037a849:	1b6982        	s32i	a8, a9, 108
        uint32_t diff = systimer_hal_get_counter_value(systimer_hal, SYSTIMER_COUNTER_OS_TICK) / systimer_ll_get_alarm_period(systimer_hal->dev, alarm_id) - s_handled_systicks[cpuid];
4037a84c:	20a220        	or	a10, a2, a2
4037a84f:	03b465        	call8	4037e394 <systimer_hal_get_counter_value>
4037a852:	0298      	l32i.n	a9, a2, 0
    return dev->target_conf[alarm_id].target_period;
4037a854:	86cb      	addi.n	a8, a6, 12
4037a856:	a08890        	addx4	a8, a8, a9
4037a859:	0020c0        	memw
4037a85c:	18c8      	l32i.n	a12, a8, 4
4037a85e:	11cca0        	slli	a12, a12, 6
4037a861:	41c6c0        	srli	a12, a12, 6
4037a864:	0d0c      	movi.n	a13, 0
4037a866:	e73e81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40002544 <__udivdi3>)
4037a869:	0008e0        	callx8	a8
4037a86c:	e90a81        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94dfc <s_handled_systicks>)
4037a86f:	a08680        	addx4	a8, a6, a8
4037a872:	0888      	l32i.n	a8, a8, 0
4037a874:	c07a80        	sub	a7, a10, a8
        if (diff > 0) {
4037a877:	1f1a87        	beq	a10, a8, 4037a89a <SysTickIsrHandler+0x72>
            if (s_handled_systicks[cpuid] == 0) {
4037a87a:	b8cc      	bnez.n	a8, 4037a889 <SysTickIsrHandler+0x61>
                s_handled_systicks[cpuid] = diff;
4037a87c:	e90681        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94dfc <s_handled_systicks>)
4037a87f:	a08680        	addx4	a8, a6, a8
4037a882:	0879      	s32i.n	a7, a8, 0
                diff = 1;
4037a884:	170c      	movi.n	a7, 1
4037a886:	0001c6        	j	4037a891 <SysTickIsrHandler+0x69>
                s_handled_systicks[cpuid] += diff;
4037a889:	e90281        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94dfc <s_handled_systicks>)
4037a88c:	a08680        	addx4	a8, a6, a8
4037a88f:	08a9      	s32i.n	a10, a8, 0
                xPortSysTickHandler();
4037a891:	fff6e5        	call8	4037a800 <xPortSysTickHandler>
            } while (--diff);
4037a894:	ffc772        	addi	a7, a7, -1
4037a897:	ff6756        	bnez	a7, 4037a891 <SysTickIsrHandler+0x69>
    } while (systimer_ll_is_alarm_int_fired(systimer_hal->dev, alarm_id));
4037a89a:	002282        	l32i	a8, a2, 0
    return dev->int_st.val & (1 << alarm_id);
4037a89d:	0020c0        	memw
4037a8a0:	1c2882        	l32i	a8, a8, 112
4037a8a3:	8a8587        	bany	a5, a8, 4037a831 <SysTickIsrHandler+0x9>
}
4037a8a6:	000090        	retw
4037a8a9:	000000        	ill

4037a8ac <prvGetDisinheritPriorityAfterTimeout>:
    {
4037a8ac:	004136        	entry	a1, 32
4037a8af:	028d      	mov.n	a8, a2
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
4037a8b1:	0020c0        	memw
4037a8b4:	9228      	l32i.n	a2, a2, 36
4037a8b6:	e28c      	beqz.n	a2, 4037a8c8 <prvGetDisinheritPriorityAfterTimeout+0x1c>
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
4037a8b8:	0020c0        	memw
4037a8bb:	c888      	l32i.n	a8, a8, 48
4037a8bd:	0020c0        	memw
4037a8c0:	0828      	l32i.n	a2, a8, 0
4037a8c2:	e7c222        	addi	a2, a2, -25
4037a8c5:	602020        	neg	a2, a2
    }
4037a8c8:	f01d      	retw.n
	...

4037a8cc <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
4037a8cc:	004136        	entry	a1, 32
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a8cf:	828b      	addi.n	a8, a2, 8
4037a8d1:	0020c0        	memw
4037a8d4:	1289      	s32i.n	a8, a2, 4

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
4037a8d6:	f97c      	movi.n	a9, -1
4037a8d8:	0020c0        	memw
4037a8db:	2299      	s32i.n	a9, a2, 8

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a8dd:	0020c0        	memw
4037a8e0:	3289      	s32i.n	a8, a2, 12
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a8e2:	0020c0        	memw
4037a8e5:	4289      	s32i.n	a8, a2, 16
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
4037a8e7:	080c      	movi.n	a8, 0
4037a8e9:	0020c0        	memw
4037a8ec:	0289      	s32i.n	a8, a2, 0

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
4037a8ee:	f01d      	retw.n

4037a8f0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
4037a8f0:	004136        	entry	a1, 32
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
4037a8f3:	080c      	movi.n	a8, 0
4037a8f5:	0020c0        	memw
4037a8f8:	4289      	s32i.n	a8, a2, 16

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
4037a8fa:	f01d      	retw.n

4037a8fc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
4037a8fc:	004136        	entry	a1, 32
    ListItem_t * const pxIndex = pxList->pxIndex;
4037a8ff:	0020c0        	memw
4037a902:	1288      	l32i.n	a8, a2, 4
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
4037a904:	0020c0        	memw
4037a907:	1389      	s32i.n	a8, a3, 4
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
4037a909:	0020c0        	memw
4037a90c:	2898      	l32i.n	a9, a8, 8
4037a90e:	0020c0        	memw
4037a911:	2399      	s32i.n	a9, a3, 8

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
4037a913:	0020c0        	memw
4037a916:	2898      	l32i.n	a9, a8, 8
4037a918:	0020c0        	memw
4037a91b:	1939      	s32i.n	a3, a9, 4
    pxIndex->pxPrevious = pxNewListItem;
4037a91d:	0020c0        	memw
4037a920:	2839      	s32i.n	a3, a8, 8

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
4037a922:	0020c0        	memw
4037a925:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037a927:	0020c0        	memw
4037a92a:	0288      	l32i.n	a8, a2, 0
4037a92c:	881b      	addi.n	a8, a8, 1
4037a92e:	0020c0        	memw
4037a931:	0289      	s32i.n	a8, a2, 0
}
4037a933:	f01d      	retw.n
4037a935:	000000        	ill

4037a938 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
4037a938:	004136        	entry	a1, 32
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
4037a93b:	0020c0        	memw
4037a93e:	03a8      	l32i.n	a10, a3, 0
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
4037a940:	080a66        	bnei	a10, -1, 4037a94c <vListInsert+0x14>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
4037a943:	0020c0        	memw
4037a946:	4288      	l32i.n	a8, a2, 16
4037a948:	0005c6        	j	4037a963 <vListInsert+0x2b>
4037a94b:	828b00        	mull	a8, a11, a0
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
4037a94e:	000106        	j	4037a956 <vListInsert+0x1e>
4037a951:	0020c0        	memw
4037a954:	1888      	l32i.n	a8, a8, 4
4037a956:	0020c0        	memw
4037a959:	1898      	l32i.n	a9, a8, 4
4037a95b:	0020c0        	memw
4037a95e:	0998      	l32i.n	a9, a9, 0
4037a960:	edba97        	bgeu	a10, a9, 4037a951 <vListInsert+0x19>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
4037a963:	0020c0        	memw
4037a966:	1898      	l32i.n	a9, a8, 4
4037a968:	0020c0        	memw
4037a96b:	1399      	s32i.n	a9, a3, 4
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
4037a96d:	0020c0        	memw
4037a970:	1398      	l32i.n	a9, a3, 4
4037a972:	0020c0        	memw
4037a975:	2939      	s32i.n	a3, a9, 8
    pxNewListItem->pxPrevious = pxIterator;
4037a977:	0020c0        	memw
4037a97a:	2389      	s32i.n	a8, a3, 8
    pxIterator->pxNext = pxNewListItem;
4037a97c:	0020c0        	memw
4037a97f:	1839      	s32i.n	a3, a8, 4

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
4037a981:	0020c0        	memw
4037a984:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037a986:	0020c0        	memw
4037a989:	0288      	l32i.n	a8, a2, 0
4037a98b:	881b      	addi.n	a8, a8, 1
4037a98d:	0020c0        	memw
4037a990:	0289      	s32i.n	a8, a2, 0
}
4037a992:	f01d      	retw.n

4037a994 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
4037a994:	004136        	entry	a1, 32
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
4037a997:	0020c0        	memw
4037a99a:	4288      	l32i.n	a8, a2, 16

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
4037a99c:	0020c0        	memw
4037a99f:	1298      	l32i.n	a9, a2, 4
4037a9a1:	0020c0        	memw
4037a9a4:	22a8      	l32i.n	a10, a2, 8
4037a9a6:	0020c0        	memw
4037a9a9:	29a9      	s32i.n	a10, a9, 8
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
4037a9ab:	0020c0        	memw
4037a9ae:	2298      	l32i.n	a9, a2, 8
4037a9b0:	0020c0        	memw
4037a9b3:	12a8      	l32i.n	a10, a2, 4
4037a9b5:	0020c0        	memw
4037a9b8:	19a9      	s32i.n	a10, a9, 4

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
4037a9ba:	0020c0        	memw
4037a9bd:	1898      	l32i.n	a9, a8, 4
4037a9bf:	099927        	bne	a9, a2, 4037a9cc <uxListRemove+0x38>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
4037a9c2:	0020c0        	memw
4037a9c5:	2298      	l32i.n	a9, a2, 8
4037a9c7:	0020c0        	memw
4037a9ca:	1899      	s32i.n	a9, a8, 4
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
4037a9cc:	090c      	movi.n	a9, 0
4037a9ce:	0020c0        	memw
4037a9d1:	4299      	s32i.n	a9, a2, 16
    ( pxList->uxNumberOfItems )--;
4037a9d3:	0020c0        	memw
4037a9d6:	0898      	l32i.n	a9, a8, 0
4037a9d8:	990b      	addi.n	a9, a9, -1
4037a9da:	0020c0        	memw
4037a9dd:	0899      	s32i.n	a9, a8, 0

    return pxList->uxNumberOfItems;
4037a9df:	0020c0        	memw
4037a9e2:	0828      	l32i.n	a2, a8, 0
}
4037a9e4:	f01d      	retw.n
	...

4037a9e8 <prvCheckTaskCanBeScheduledSMP>:
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

    static BaseType_t prvCheckTaskCanBeScheduledSMP( TCB_t * pxTCB )
    {
4037a9e8:	004136        	entry	a1, 32
        /* This function must be called from a critical section (where the kernel
         * lock is taken). */

        BaseType_t xReturn;

        if( pxTCB->xCoreID == tskNO_AFFINITY )
4037a9eb:	112282        	l32i	a8, a2, 68
4037a9ee:	e78691        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037a9f1:	189897        	bne	a8, a9, 4037aa0d <prvCheckTaskCanBeScheduledSMP+0x25>
        {
            /* Task is unpinned. As long as one core has not suspended
             * scheduling, the task can be scheduled. */
            if( ( uxSchedulerSuspended[ 0 ] == ( UBaseType_t ) 0U ) || ( uxSchedulerSuspended[ 1 ] == ( UBaseType_t ) 0U ) )
4037a9f4:	e8a981        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037a9f7:	0020c0        	memw
4037a9fa:	0888      	l32i.n	a8, a8, 0
4037a9fc:	08ac      	beqz.n	a8, 4037aa20 <prvCheckTaskCanBeScheduledSMP+0x38>
4037a9fe:	e8a681        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037aa01:	0020c0        	memw
4037aa04:	1888      	l32i.n	a8, a8, 4
4037aa06:	b8dc      	bnez.n	a8, 4037aa25 <prvCheckTaskCanBeScheduledSMP+0x3d>
            {
                xReturn = pdTRUE;
4037aa08:	120c      	movi.n	a2, 1
4037aa0a:	000786        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
            else
            {
                xReturn = pdFALSE;
            }
        }
        else if( uxSchedulerSuspended[ pxTCB->xCoreID ] == ( UBaseType_t ) 0U )
4037aa0d:	e8a291        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037aa10:	a08890        	addx4	a8, a8, a9
4037aa13:	0020c0        	memw
4037aa16:	0888      	l32i.n	a8, a8, 0
4037aa18:	e8cc      	bnez.n	a8, 4037aa2a <prvCheckTaskCanBeScheduledSMP+0x42>
        {
            /* The task is pinned to a core. If it's pinned core has not
             * suspended scheduling, the task can be scheduled. */
            xReturn = pdTRUE;
4037aa1a:	120c      	movi.n	a2, 1
4037aa1c:	000306        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
4037aa1f:	120c00        	andbc	b0, b12, b0
                xReturn = pdTRUE;
4037aa22:	000186        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
                xReturn = pdFALSE;
4037aa25:	020c      	movi.n	a2, 0
4037aa27:	000046        	j	4037aa2c <prvCheckTaskCanBeScheduledSMP+0x44>
        }
        else
        {
            xReturn = pdFALSE;
4037aa2a:	020c      	movi.n	a2, 0
        }

        return xReturn;
    }
4037aa2c:	f01d      	retw.n
	...

4037aa30 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
4037aa30:	004136        	entry	a1, 32
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037aa33:	e89a81        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94ba0 <pxDelayedTaskList>)
4037aa36:	0020c0        	memw
4037aa39:	0888      	l32i.n	a8, a8, 0
4037aa3b:	0020c0        	memw
4037aa3e:	0888      	l32i.n	a8, a8, 0
4037aa40:	c8cc      	bnez.n	a8, 4037aa50 <prvResetNextTaskUnblockTime+0x20>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
4037aa42:	e89781        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94b20 <xNextTaskUnblockTime>)
4037aa45:	f97c      	movi.n	a9, -1
4037aa47:	0020c0        	memw
4037aa4a:	0899      	s32i.n	a9, a8, 0
4037aa4c:	000686        	j	4037aa6a <prvResetNextTaskUnblockTime+0x3a>
4037aa4f:	938100        	movnez	a8, a1, a0
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
4037aa52:	c0e8      	l32i.n	a14, a0, 48
4037aa54:	880020        	lsi	f2, a0, 0x220
4037aa57:	c008      	l32i.n	a0, a0, 48
4037aa59:	880020        	lsi	f2, a0, 0x220
4037aa5c:	c038      	l32i.n	a3, a0, 48
4037aa5e:	980020        	lsi	f2, a0, 0x260
4037aa61:	8108      	l32i.n	a0, a1, 32
4037aa63:	8f          	.byte	0x8f
4037aa64:	c0e8      	l32i.n	a14, a0, 48
4037aa66:	990020        	lsi	f2, a0, 0x264
4037aa69:	1d08      	l32i.n	a0, a13, 4
    }
}
4037aa6b:	f0          	.byte	0xf0

4037aa6c <prvIsYieldRequiredSMP>:
    {
4037aa6c:	004136        	entry	a1, 32
        configASSERT( uxTaskPriority < configMAX_PRIORITIES );
4037aa6f:	881c      	movi.n	a8, 24
4037aa71:	0eb837        	bgeu	a8, a3, 4037aa83 <prvIsYieldRequiredSMP+0x17>
4037aa74:	e88cd1        	l32r	a13, 40374ca4 <_iram_text_start+0x8a0> (3c0244c0 <_flash_rodata_start+0x43a0>)
4037aa77:	e88cc1        	l32r	a12, 40374ca8 <_iram_text_start+0x8a4> (3c028198 <__func__$37>)
4037aa7a:	1fa3b2        	movi	a11, 0x31f
4037aa7d:	e88ba1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037aa80:	052ce5        	call8	4037fd50 <__assert_func>
4037aa83:	03eba0        	rsr.prid	a10
4037aa86:	04ada0        	extui	a10, a10, 13, 1
4037aa89:	0a9d      	mov.n	a9, a10
        if( xYieldEqualPriority == pdTRUE )
4037aa8b:	011466        	bnei	a4, 1, 4037aa90 <prvIsYieldRequiredSMP+0x24>
            uxTaskPriority++;
4037aa8e:	331b      	addi.n	a3, a3, 1
        if( ( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aa90:	112282        	l32i	a8, a2, 68
4037aa93:	051897        	beq	a8, a9, 4037aa9c <prvIsYieldRequiredSMP+0x30>
4037aa96:	e75c91        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037aa99:	1c9897        	bne	a8, a9, 4037aab9 <prvIsYieldRequiredSMP+0x4d>
            ( uxTaskPriority > pxCurrentTCBs[ xCurCoreID ]->uxPriority ) &&
4037aa9c:	e86991        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037aa9f:	a09a90        	addx4	a9, a10, a9
4037aaa2:	0020c0        	memw
4037aaa5:	0998      	l32i.n	a9, a9, 0
4037aaa7:	b998      	l32i.n	a9, a9, 44
        if( ( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aaa9:	0cb937        	bgeu	a9, a3, 4037aab9 <prvIsYieldRequiredSMP+0x4d>
            ( uxSchedulerSuspended[ xCurCoreID ] == ( UBaseType_t ) 0U ) )
4037aaac:	e87b91        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037aaaf:	a09a90        	addx4	a9, a10, a9
4037aab2:	0020c0        	memw
4037aab5:	0998      	l32i.n	a9, a9, 0
            ( uxTaskPriority > pxCurrentTCBs[ xCurCoreID ]->uxPriority ) &&
4037aab7:	69bc      	beqz.n	a9, 4037aaf1 <prvIsYieldRequiredSMP+0x85>
        else if( ( taskIS_AFFINITY_COMPATIBLE( !xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aab9:	40faa0        	nsau	a10, a10
4037aabc:	41a5a0        	srli	a10, a10, 5
4037aabf:	0518a7        	beq	a8, a10, 4037aac8 <prvIsYieldRequiredSMP+0x5c>
4037aac2:	e75191        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037aac5:	2d9897        	bne	a8, a9, 4037aaf6 <prvIsYieldRequiredSMP+0x8a>
                 ( uxTaskPriority > pxCurrentTCBs[ !xCurCoreID ]->uxPriority ) &&
4037aac8:	e85e81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037aacb:	a08a80        	addx4	a8, a10, a8
4037aace:	0020c0        	memw
4037aad1:	002882        	l32i	a8, a8, 0
4037aad4:	0b2882        	l32i	a8, a8, 44
        else if( ( taskIS_AFFINITY_COMPATIBLE( !xCurCoreID, pxTCB ) == pdTRUE ) &&
4037aad7:	21b837        	bgeu	a8, a3, 4037aafc <prvIsYieldRequiredSMP+0x90>
                 ( uxSchedulerSuspended[ !xCurCoreID ] == ( UBaseType_t ) 0U ) )
4037aada:	e86f81        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037aadd:	a08a80        	addx4	a8, a10, a8
4037aae0:	0020c0        	memw
4037aae3:	002882        	l32i	a8, a8, 0
                 ( uxTaskPriority > pxCurrentTCBs[ !xCurCoreID ]->uxPriority ) &&
4037aae6:	017856        	bnez	a8, 4037ab01 <prvIsYieldRequiredSMP+0x95>
            taskYIELD_CORE( !xCurCoreID );
4037aae9:	ff8325        	call8	4037a31c <vPortYieldOtherCore>
            xYieldRequiredCurrentCore = pdFALSE;
4037aaec:	020c      	movi.n	a2, 0
4037aaee:	000446        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
            xYieldRequiredCurrentCore = pdTRUE;
4037aaf1:	120c      	movi.n	a2, 1
4037aaf3:	000306        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
            xYieldRequiredCurrentCore = pdFALSE;
4037aaf6:	020c      	movi.n	a2, 0
4037aaf8:	0001c6        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
4037aafb:	020c00        	andb	b0, b12, b0
4037aafe:	000046        	j	4037ab03 <prvIsYieldRequiredSMP+0x97>
4037ab01:	020c      	movi.n	a2, 0
    }
4037ab03:	f01d      	retw.n
4037ab05:	000000        	ill

4037ab08 <prvSelectHighestPriorityTaskSMP>:
    {
4037ab08:	004136        	entry	a1, 32
4037ab0b:	03ebc0        	rsr.prid	a12
4037ab0e:	04cdc0        	extui	a12, a12, 13, 1
4037ab11:	0cfd      	mov.n	a15, a12
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037ab13:	e86781        	l32r	a8, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037ab16:	0020c0        	memw
4037ab19:	0898      	l32i.n	a9, a8, 0
        BaseType_t xNewTopPrioritySet = pdFALSE;
4037ab1b:	060c      	movi.n	a6, 0
        BaseType_t xTaskScheduled = pdFALSE;
4037ab1d:	067d      	mov.n	a7, a6
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037ab1f:	006a06        	j	4037accb <prvSelectHighestPriorityTaskSMP+0x1c3>
4037ab22:	000000        	ill
            if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxCurPriority ] ) ) )
4037ab25:	a08990        	addx4	a8, a9, a9
4037ab28:	11a8e0        	slli	a10, a8, 2
4037ab2b:	e86281        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037ab2e:	88aa      	add.n	a8, a8, a10
4037ab30:	0020c0        	memw
4037ab33:	0888      	l32i.n	a8, a8, 0
4037ab35:	190816        	beqz	a8, 4037acc9 <prvSelectHighestPriorityTaskSMP+0x1c1>
            if( xNewTopPrioritySet == pdFALSE )
4037ab38:	96cc      	bnez.n	a6, 4037ab45 <prvSelectHighestPriorityTaskSMP+0x3d>
                uxTopReadyPriority = uxCurPriority;
4037ab3a:	e85d81        	l32r	a8, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037ab3d:	0020c0        	memw
4037ab40:	0899      	s32i.n	a9, a8, 0
                xNewTopPrioritySet = pdTRUE;
4037ab42:	01a062        	movi	a6, 1
            pxReadyTasksLists[ uxCurPriority ].pxIndex = ( ListItem_t * ) &( pxReadyTasksLists[ uxCurPriority ].xListEnd );
4037ab45:	a0a990        	addx4	a10, a9, a9
4037ab48:	118ae0        	slli	a8, a10, 2
4037ab4b:	e85aa1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037ab4e:	88aa      	add.n	a8, a8, a10
4037ab50:	d88b      	addi.n	a13, a8, 8
4037ab52:	0020c0        	memw
4037ab55:	18d9      	s32i.n	a13, a8, 4
            listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037ab57:	0020c0        	memw
4037ab5a:	18a8      	l32i.n	a10, a8, 4
4037ab5c:	0020c0        	memw
4037ab5f:	1aa8      	l32i.n	a10, a10, 4
4037ab61:	0020c0        	memw
4037ab64:	18a9      	s32i.n	a10, a8, 4
4037ab66:	0020c0        	memw
4037ab69:	1888      	l32i.n	a8, a8, 4
4037ab6b:	199d87        	bne	a13, a8, 4037ab88 <prvSelectHighestPriorityTaskSMP+0x80>
4037ab6e:	a08990        	addx4	a8, a9, a9
4037ab71:	11a8e0        	slli	a10, a8, 2
4037ab74:	e85081        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037ab77:	88aa      	add.n	a8, a8, a10
4037ab79:	0020c0        	memw
4037ab7c:	18a8      	l32i.n	a10, a8, 4
4037ab7e:	0020c0        	memw
4037ab81:	1aa8      	l32i.n	a10, a10, 4
4037ab83:	0020c0        	memw
4037ab86:	18a9      	s32i.n	a10, a8, 4
4037ab88:	a08990        	addx4	a8, a9, a9
4037ab8b:	11a8e0        	slli	a10, a8, 2
4037ab8e:	e84981        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037ab91:	88aa      	add.n	a8, a8, a10
4037ab93:	0020c0        	memw
4037ab96:	1888      	l32i.n	a8, a8, 4
4037ab98:	38e8      	l32i.n	a14, a8, 12
4037ab9a:	0ebd      	mov.n	a11, a14
                for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037ab9c:	080c      	movi.n	a8, 0
4037ab9e:	000546        	j	4037abb7 <prvSelectHighestPriorityTaskSMP+0xaf>
                    if( x == xCurCoreID )
4037aba1:	1018c7        	beq	a8, a12, 4037abb5 <prvSelectHighestPriorityTaskSMP+0xad>
                    else if( pxCurrentTCBs[ x ] == pxTCBCur )
4037aba4:	e827a1        	l32r	a10, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037aba7:	a0a8a0        	addx4	a10, a8, a10
4037abaa:	0020c0        	memw
4037abad:	0aa8      	l32i.n	a10, a10, 0
4037abaf:	029ab7        	bne	a10, a11, 4037abb5 <prvSelectHighestPriorityTaskSMP+0xad>
4037abb2:	002f86        	j	4037ac74 <prvSelectHighestPriorityTaskSMP+0x16c>
                for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037abb5:	881b      	addi.n	a8, a8, 1
4037abb7:	e628b6        	bltui	a8, 2, 4037aba1 <prvSelectHighestPriorityTaskSMP+0x99>
                if( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCBCur ) == pdFALSE )
4037abba:	112b82        	l32i	a8, a11, 68
4037abbd:	0818f7        	beq	a8, a15, 4037abc9 <prvSelectHighestPriorityTaskSMP+0xc1>
4037abc0:	e712a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037abc3:	0218a7        	beq	a8, a10, 4037abc9 <prvSelectHighestPriorityTaskSMP+0xc1>
4037abc6:	002a86        	j	4037ac74 <prvSelectHighestPriorityTaskSMP+0x16c>
                pxCurrentTCBs[ xCurCoreID ] = pxTCBCur;
4037abc9:	e81d81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037abcc:	a08c80        	addx4	a8, a12, a8
4037abcf:	0020c0        	memw
4037abd2:	08b9      	s32i.n	a11, a8, 0
                pxReadyTasksLists[ uxCurPriority ].pxIndex = ( ListItem_t * ) &( pxReadyTasksLists[ uxCurPriority ].xListEnd );
4037abd4:	a08990        	addx4	a8, a9, a9
4037abd7:	11a8e0        	slli	a10, a8, 2
4037abda:	e83681        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037abdd:	88aa      	add.n	a8, a8, a10
4037abdf:	0020c0        	memw
4037abe2:	18d9      	s32i.n	a13, a8, 4
                listREMOVE_ITEM( &( pxTCBCur->xStateListItem ) );
4037abe4:	0020c0        	memw
4037abe7:	5b88      	l32i.n	a8, a11, 20
4037abe9:	0020c0        	memw
4037abec:	2ba8      	l32i.n	a10, a11, 8
4037abee:	0020c0        	memw
4037abf1:	3bd8      	l32i.n	a13, a11, 12
4037abf3:	0020c0        	memw
4037abf6:	2ad9      	s32i.n	a13, a10, 8
4037abf8:	0020c0        	memw
4037abfb:	3ba8      	l32i.n	a10, a11, 12
4037abfd:	0020c0        	memw
4037ac00:	2bd8      	l32i.n	a13, a11, 8
4037ac02:	0020c0        	memw
4037ac05:	1ad9      	s32i.n	a13, a10, 4
4037ac07:	0020c0        	memw
4037ac0a:	18a8      	l32i.n	a10, a8, 4
4037ac0c:	db4b      	addi.n	a13, a11, 4
4037ac0e:	0a9ad7        	bne	a10, a13, 4037ac1c <prvSelectHighestPriorityTaskSMP+0x114>
4037ac11:	0020c0        	memw
4037ac14:	3ba8      	l32i.n	a10, a11, 12
4037ac16:	0020c0        	memw
4037ac19:	0168a2        	s32i	a10, a8, 4
4037ac1c:	0a0c      	movi.n	a10, 0
4037ac1e:	0020c0        	memw
4037ac21:	5ba9      	s32i.n	a10, a11, 20
4037ac23:	0020c0        	memw
4037ac26:	08a8      	l32i.n	a10, a8, 0
4037ac28:	aa0b      	addi.n	a10, a10, -1
4037ac2a:	0020c0        	memw
4037ac2d:	08a9      	s32i.n	a10, a8, 0
                listINSERT_END( &( pxReadyTasksLists[ uxCurPriority ] ), &( pxTCBCur->xStateListItem ) );
4037ac2f:	a08990        	addx4	a8, a9, a9
4037ac32:	11a8e0        	slli	a10, a8, 2
4037ac35:	e81f81        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037ac38:	88aa      	add.n	a8, a8, a10
4037ac3a:	0020c0        	memw
4037ac3d:	18a8      	l32i.n	a10, a8, 4
4037ac3f:	0020c0        	memw
4037ac42:	2ba9      	s32i.n	a10, a11, 8
4037ac44:	0020c0        	memw
4037ac47:	2ae8      	l32i.n	a14, a10, 8
4037ac49:	0020c0        	memw
4037ac4c:	3be9      	s32i.n	a14, a11, 12
4037ac4e:	0020c0        	memw
4037ac51:	2ae8      	l32i.n	a14, a10, 8
4037ac53:	0020c0        	memw
4037ac56:	1ed9      	s32i.n	a13, a14, 4
4037ac58:	0020c0        	memw
4037ac5b:	2ad9      	s32i.n	a13, a10, 8
4037ac5d:	0020c0        	memw
4037ac60:	5b89      	s32i.n	a8, a11, 20
4037ac62:	0020c0        	memw
4037ac65:	08a8      	l32i.n	a10, a8, 0
4037ac67:	aa1b      	addi.n	a10, a10, 1
4037ac69:	0020c0        	memw
4037ac6c:	08a9      	s32i.n	a10, a8, 0
                xTaskScheduled = pdTRUE;
4037ac6e:	170c      	movi.n	a7, 1
                break;
4037ac70:	001546        	j	4037acc9 <prvSelectHighestPriorityTaskSMP+0x1c1>
4037ac73:	899000        	lsi	f0, a0, 0x224
                listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037ac76:	a8e0a0        	lsi	f10, a0, 0x2a0
4037ac79:	0e8111        	l32r	a1, 4033e680 <rom_rx_gain_force+0x338254>
4037ac7c:	aae8      	l32i.n	a14, a10, 40
4037ac7e:	c088      	l32i.n	a8, a0, 48
4037ac80:	a80020        	lsi	f2, a0, 0x2a0
4037ac83:	c018      	l32i.n	a1, a0, 48
4037ac85:	a80020        	lsi	f2, a0, 0x2a0
4037ac88:	c01a      	add.n	a12, a0, a1
4037ac8a:	a90020        	lsi	f2, a0, 0x2a4
4037ac8d:	c018      	l32i.n	a1, a0, 48
4037ac8f:	880020        	lsi	f2, a0, 0x220
4037ac92:	8718      	l32i.n	a1, a7, 32
4037ac94:	1a9d      	lsi	f9, a10, 40
4037ac96:	a08990        	addx4	a8, a9, a9
4037ac99:	11a8e0        	slli	a10, a8, 2
4037ac9c:	e80681        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037ac9f:	88aa      	add.n	a8, a8, a10
4037aca1:	0020c0        	memw
4037aca4:	18a8      	l32i.n	a10, a8, 4
4037aca6:	0020c0        	memw
4037aca9:	1aa8      	l32i.n	a10, a10, 4
4037acab:	0020c0        	memw
4037acae:	0168a2        	s32i	a10, a8, 4
4037acb1:	a08990        	addx4	a8, a9, a9
4037acb4:	11a8e0        	slli	a10, a8, 2
4037acb7:	e7ff81        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037acba:	88aa      	add.n	a8, a8, a10
4037acbc:	0020c0        	memw
4037acbf:	1888      	l32i.n	a8, a8, 4
4037acc1:	38b8      	l32i.n	a11, a8, 12
            } while( pxTCBCur != pxTCBFirst ); /* Check to see if we've walked the entire list */
4037acc3:	021eb7        	beq	a14, a11, 4037acc9 <prvSelectHighestPriorityTaskSMP+0x1c1>
4037acc6:	ffb486        	j	4037ab9c <prvSelectHighestPriorityTaskSMP+0x94>
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037acc9:	990b      	addi.n	a9, a9, -1
4037accb:	048070        	extui	a8, a7, 0, 1
4037acce:	1a0c      	movi.n	a10, 1
4037acd0:	3088a0        	xor	a8, a8, a10
4037acd3:	748080        	extui	a8, a8, 0, 8
4037acd6:	002996        	bltz	a9, 4037acdc <prvSelectHighestPriorityTaskSMP+0x1d4>
4037acd9:	e48856        	bnez	a8, 4037ab25 <prvSelectHighestPriorityTaskSMP+0x1d>
        configASSERT( xTaskScheduled == pdTRUE ); /* At this point, a task MUST have been scheduled */
4037acdc:	d7cc      	bnez.n	a7, 4037aced <prvSelectHighestPriorityTaskSMP+0x1e5>
4037acde:	e7f6d1        	l32r	a13, 40374cb8 <_iram_text_start+0x8b4> (3c02450c <_flash_rodata_start+0x43ec>)
4037ace1:	e7f6c1        	l32r	a12, 40374cbc <_iram_text_start+0x8b8> (3c028130 <__func__$24>)
4037ace4:	e7f7b1        	l32r	a11, 40374cc0 <_iram_text_start+0x8bc> (e2e <UserFrameTotalSize+0xd2e>)
4037ace7:	e7f1a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037acea:	050665        	call8	4037fd50 <__assert_func>
    }
4037aced:	f01d      	retw.n
	...

4037acf0 <prvDeleteTCB>:
    {
4037acf0:	004136        	entry	a1, 32
        portCLEAN_UP_TCB( pxTCB );
4037acf3:	20a220        	or	a10, a2, a2
4037acf6:	ff6725        	call8	4037a368 <vPortTCBPreDeleteHook>
            configDEINIT_TLS_BLOCK( pxTCB->xTLSBlock );
4037acf9:	5cc2a2        	addi	a10, a2, 92
4037acfc:	e7f581        	l32r	a8, 40374cd0 <_iram_text_start+0x8cc> (4200b3c8 <_reclaim_reent>)
4037acff:	0008e0        	callx8	a8
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
4037ad02:	01d282        	addmi	a8, a2, 0x100
4037ad05:	510882        	l8ui	a8, a8, 81
4037ad08:	00d856        	bnez	a8, 4037ad19 <prvDeleteTCB+0x29>
                vPortFreeStack( pxTCB->pxStack );
4037ad0b:	c2a8      	l32i.n	a10, a2, 48
4037ad0d:	ff89a5        	call8	4037a5a8 <vPortFree>
                vPortFree( pxTCB );
4037ad10:	02ad      	mov.n	a10, a2
4037ad12:	ff8965        	call8	4037a5a8 <vPortFree>
4037ad15:	000746        	j	4037ad36 <prvDeleteTCB+0x46>
4037ad18:	186600        	lsxp	f6, a6, a0
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
4037ad1b:	02ad07        	bge	a13, a0, 4037ad21 <prvDeleteTCB+0x31>
                vPortFree( pxTCB );
4037ad1e:	ff88a5        	call8	4037a5a8 <vPortFree>
4037ad21:	000446        	j	4037ad36 <prvDeleteTCB+0x46>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
4037ad24:	0e2826        	beqi	a8, 2, 4037ad36 <prvDeleteTCB+0x46>
4037ad27:	e7e7d1        	l32r	a13, 40374cc4 <_iram_text_start+0x8c0> (3c024534 <_flash_rodata_start+0x4414>)
4037ad2a:	e7e7c1        	l32r	a12, 40374cc8 <_iram_text_start+0x8c4> (3c0281d0 <__func__$42>)
4037ad2d:	e7e7b1        	l32r	a11, 40374ccc <_iram_text_start+0x8c8> (1339 <UserFrameTotalSize+0x1239>)
4037ad30:	e7dfa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037ad33:	0501e5        	call8	4037fd50 <__assert_func>
    }
4037ad36:	f01d      	retw.n

4037ad38 <prvCheckTasksWaitingTermination>:
{
4037ad38:	004136        	entry	a1, 32
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
4037ad3b:	002086        	j	4037adc1 <prvCheckTasksWaitingTermination+0x89>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037ad3e:	ffafb2        	movi	a11, -1
4037ad41:	e7e4a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037ad44:	ff3ea5        	call8	4037a130 <xPortEnterCriticalTimeout>
                    if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
4037ad47:	e7e481        	l32r	a8, 40374cd8 <_iram_text_start+0x8d4> (3fc94b60 <xTasksWaitingTermination>)
4037ad4a:	0020c0        	memw
4037ad4d:	002882        	l32i	a8, a8, 0
4037ad50:	05e816        	beqz	a8, 4037adb2 <prvCheckTasksWaitingTermination+0x7a>
                        for( xEntry = listGET_HEAD_ENTRY( &xTasksWaitingTermination ); xEntry != listGET_END_MARKER( &xTasksWaitingTermination ); xEntry = listGET_NEXT( xEntry ) )
4037ad53:	e7e181        	l32r	a8, 40374cd8 <_iram_text_start+0x8d4> (3fc94b60 <xTasksWaitingTermination>)
4037ad56:	0020c0        	memw
4037ad59:	032882        	l32i	a8, a8, 12
4037ad5c:	001186        	j	4037ada6 <prvCheckTasksWaitingTermination+0x6e>
4037ad5f:	287200        	lsi	f0, a2, 160
                            if( taskIS_CURRENTLY_RUNNING( ( ( TCB_t * ) listGET_LIST_ITEM_OWNER( xEntry ) ) ) == pdFALSE )
4037ad62:	b79103        	lsi	f0, a1, 0x2dc
4037ad65:	20c0e7        	bnall	a0, a14, 4037ad89 <prvCheckTasksWaitingTermination+0x51>
4037ad68:	299200        	lsi	f0, a2, 164
4037ad6b:	179700        	lsi	f0, a7, 92
4037ad6e:	b49131        	l32r	a3, 40367fb4 <rom_rx_gain_force+0x361b88>
4037ad71:	20c0e7        	bnall	a0, a14, 4037ad95 <prvCheckTasksWaitingTermination+0x5d>
4037ad74:	299200        	lsi	f0, a2, 164
4037ad77:	179701        	l32r	a0, 40340bd4 <rom_rx_gain_force+0x33a7a8>
4037ad7a:	a74b25        	call8	4032222c <rom_rx_gain_force+0x31be00>
                                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4037ad7d:	ffc165        	call8	4037a994 <uxListRemove>
                                --uxCurrentNumberOfTasks;
4037ad80:	e7d791        	l32r	a9, 40374cdc <_iram_text_start+0x8d8> (3fc94b44 <uxCurrentNumberOfTasks>)
4037ad83:	0020c0        	memw
4037ad86:	0988      	l32i.n	a8, a9, 0
4037ad88:	880b      	addi.n	a8, a8, -1
4037ad8a:	0020c0        	memw
4037ad8d:	0989      	s32i.n	a8, a9, 0
                                --uxDeletedTasksWaitingCleanUp;
4037ad8f:	e7d491        	l32r	a9, 40374ce0 <_iram_text_start+0x8dc> (3fc94b5c <uxDeletedTasksWaitingCleanUp>)
4037ad92:	0020c0        	memw
4037ad95:	0988      	l32i.n	a8, a9, 0
4037ad97:	880b      	addi.n	a8, a8, -1
4037ad99:	0020c0        	memw
4037ad9c:	0989      	s32i.n	a8, a9, 0
                                break;
4037ad9e:	000486        	j	4037adb4 <prvCheckTasksWaitingTermination+0x7c>
                        for( xEntry = listGET_HEAD_ENTRY( &xTasksWaitingTermination ); xEntry != listGET_END_MARKER( &xTasksWaitingTermination ); xEntry = listGET_NEXT( xEntry ) )
4037ada1:	0020c0        	memw
4037ada4:	1888      	l32i.n	a8, a8, 4
4037ada6:	e7cf91        	l32r	a9, 40374ce4 <_iram_text_start+0x8e0> (3fc94b68 <xTasksWaitingTermination+0x8>)
4037ada9:	b39897        	bne	a8, a9, 4037ad60 <prvCheckTasksWaitingTermination+0x28>
                pxTCB = NULL;
4037adac:	070c      	movi.n	a7, 0
4037adae:	000086        	j	4037adb4 <prvCheckTasksWaitingTermination+0x7c>
4037adb1:	070c00        	lsi	f0, a12, 28
                taskEXIT_CRITICAL( &xKernelLock );
4037adb4:	e7c8a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037adb7:	ff4ca5        	call8	4037a280 <vPortExitCritical>
                if( pxTCB != NULL )
4037adba:	e78c      	beqz.n	a7, 4037adcc <prvCheckTasksWaitingTermination+0x94>
                    prvDeleteTCB( pxTCB );
4037adbc:	07ad      	mov.n	a10, a7
4037adbe:	fff325        	call8	4037acf0 <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
4037adc1:	e7c781        	l32r	a8, 40374ce0 <_iram_text_start+0x8dc> (3fc94b5c <uxDeletedTasksWaitingCleanUp>)
4037adc4:	0020c0        	memw
4037adc7:	0888      	l32i.n	a8, a8, 0
4037adc9:	f71856        	bnez	a8, 4037ad3e <prvCheckTasksWaitingTermination+0x6>
}
4037adcc:	f01d      	retw.n
	...

4037add0 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
4037add0:	004136        	entry	a1, 32
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
4037add3:	e7c581        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037add6:	0020c0        	memw
4037add9:	002862        	l32i	a6, a8, 0
4037addc:	03eb70        	rsr.prid	a7
4037addf:	047d70        	extui	a7, a7, 13, 1
    /* Get current core ID as we can no longer be preempted. */
    const BaseType_t xCurCoreID = portGET_CORE_ID();

    #if ( configNUMBER_OF_CORES > 1 )
    {
        if( listIS_CONTAINED_WITHIN( &xTasksWaitingTermination, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) ) == pdTRUE )
4037ade2:	e79781        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037ade5:	a08780        	addx4	a8, a7, a8
4037ade8:	0020c0        	memw
4037adeb:	002882        	l32i	a8, a8, 0
4037adee:	0020c0        	memw
4037adf1:	052892        	l32i	a9, a8, 20
4037adf4:	e7b981        	l32r	a8, 40374cd8 <_iram_text_start+0x8d4> (3fc94b60 <xTasksWaitingTermination>)
4037adf7:	029987        	bne	a9, a8, 4037adfd <prvAddCurrentTaskToDelayedList+0x2d>
4037adfa:	003a86        	j	4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
    #if ( INCLUDE_xTaskAbortDelay == 1 )
    {
        /* About to enter a delayed list, so ensure the ucDelayAborted flag is
         * reset to pdFALSE so it can be detected as having been set to pdTRUE
         * when the task leaves the Blocked state. */
        pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted = pdFALSE;
4037adfd:	e79081        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037ae00:	a08780        	addx4	a8, a7, a8
4037ae03:	0020c0        	memw
4037ae06:	0898      	l32i.n	a9, a8, 0
4037ae08:	01d992        	addmi	a9, a9, 0x100
4037ae0b:	0a0c      	movi.n	a10, 0
4037ae0d:	5249a2        	s8i	a10, a9, 82
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037ae10:	0020c0        	memw
4037ae13:	08a8      	l32i.n	a10, a8, 0
4037ae15:	aa4b      	addi.n	a10, a10, 4
4037ae17:	ffb7e5        	call8	4037a994 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
4037ae1a:	821b      	addi.n	a8, a2, 1
4037ae1c:	40f880        	nsau	a8, a8
4037ae1f:	418580        	srli	a8, a8, 5
4037ae22:	190c      	movi.n	a9, 1
4037ae24:	839330        	moveqz	a9, a3, a3
4037ae27:	5d0897        	bnone	a8, a9, 4037ae88 <prvAddCurrentTaskToDelayedList+0xb8>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037ae2a:	e7b091        	l32r	a9, 40374cec <_iram_text_start+0x8e8> (3fc94b48 <xSuspendedTaskList>)
4037ae2d:	0020c0        	memw
4037ae30:	19a8      	l32i.n	a10, a9, 4
4037ae32:	e78381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037ae35:	a08780        	addx4	a8, a7, a8
4037ae38:	0020c0        	memw
4037ae3b:	08b8      	l32i.n	a11, a8, 0
4037ae3d:	0020c0        	memw
4037ae40:	2ba9      	s32i.n	a10, a11, 8
4037ae42:	0020c0        	memw
4037ae45:	08b8      	l32i.n	a11, a8, 0
4037ae47:	0020c0        	memw
4037ae4a:	2ac8      	l32i.n	a12, a10, 8
4037ae4c:	0020c0        	memw
4037ae4f:	3bc9      	s32i.n	a12, a11, 12
4037ae51:	0020c0        	memw
4037ae54:	08b8      	l32i.n	a11, a8, 0
4037ae56:	0020c0        	memw
4037ae59:	2ac8      	l32i.n	a12, a10, 8
4037ae5b:	bb4b      	addi.n	a11, a11, 4
4037ae5d:	0020c0        	memw
4037ae60:	1cb9      	s32i.n	a11, a12, 4
4037ae62:	0020c0        	memw
4037ae65:	08b8      	l32i.n	a11, a8, 0
4037ae67:	bb4b      	addi.n	a11, a11, 4
4037ae69:	0020c0        	memw
4037ae6c:	2ab9      	s32i.n	a11, a10, 8
4037ae6e:	0020c0        	memw
4037ae71:	0888      	l32i.n	a8, a8, 0
4037ae73:	0020c0        	memw
4037ae76:	5899      	s32i.n	a9, a8, 20
4037ae78:	0020c0        	memw
4037ae7b:	0988      	l32i.n	a8, a9, 0
4037ae7d:	881b      	addi.n	a8, a8, 1
4037ae7f:	0020c0        	memw
4037ae82:	0989      	s32i.n	a8, a9, 0
4037ae84:	001806        	j	4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
4037ae87:	262000        	lsi	f0, a0, 152
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
4037ae8a:	6d8180        	lsi	f8, a1, 0x1b4

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ), xTimeToWake );
4037ae8d:	8780e7        	bany	a0, a14, 4037ae18 <prvAddCurrentTaskToDelayedList+0x48>
4037ae90:	20c0a0        	or	a12, a0, a10
4037ae93:	288200        	lsi	f0, a2, 160
4037ae96:	20c000        	or	a12, a0, a0
4037ae99:	682200        	lsi	f0, a2, 0x1a0
4037ae9c:	b26701        	l32r	a0, 40367838 <rom_rx_gain_force+0x36140c>

            if( xTimeToWake < xConstTickCount )
4037ae9f:	811c      	movi.n	a1, 24
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037aea1:	c0e794        	lsi	f9, a7, 0x300
4037aea4:	a80020        	lsi	f2, a0, 0x2a0
4037aea7:	8108      	l32i.n	a0, a1, 32
4037aea9:	80e766        	bnei	a7, 128, 4037ae2d <prvAddCurrentTaskToDelayedList+0x5d>
4037aeac:	c0a087        	bge	a0, a8, 4037ae70 <prvAddCurrentTaskToDelayedList+0xa0>
4037aeaf:	b80020        	lsi	f2, a0, 0x2e0
4037aeb2:	4b08      	l32i.n	a0, a11, 16
4037aeb4:	25bb      	addi.n	a2, a5, 11
4037aeb6:	ffa8      	l32i.n	a10, a15, 60
4037aeb8:	000b06        	j	4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
4037aebb:	810000        	src	a0, a0, a0
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037aebe:	c0e777        	bbsi	a7, 7, 4037ae82 <prvAddCurrentTaskToDelayedList+0xb2>
4037aec1:	a80020        	lsi	f2, a0, 0x2a0
4037aec4:	8108      	l32i.n	a0, a1, 32
4037aec6:	5e          	.byte	0x5e
4037aec7:	7780e7        	bany	a0, a14, 4037af42 <prvInitialiseNewTask+0x46>
4037aeca:	20c0a0        	or	a12, a0, a10
4037aecd:	07b800        	lsi	f0, a8, 28
4037aed0:	bb4b      	addi.n	a11, a11, 4
4037aed2:	ffa665        	call8	4037a938 <vListInsert>

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
4037aed5:	e77281        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94b20 <xNextTaskUnblockTime>)
4037aed8:	0020c0        	memw
4037aedb:	0888      	l32i.n	a8, a8, 0
4037aedd:	07b287        	bgeu	a2, a8, 4037aee8 <prvAddCurrentTaskToDelayedList+0x118>
                {
                    xNextTaskUnblockTime = xTimeToWake;
4037aee0:	e77081        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94b20 <xNextTaskUnblockTime>)
4037aee3:	0020c0        	memw
4037aee6:	0829      	s32i.n	a2, a8, 0

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
4037aee8:	f01d      	retw.n
	...

4037aeec <prvIdleTask>:
{
4037aeec:	004136        	entry	a1, 32
        prvCheckTasksWaitingTermination();
4037aeef:	ffe4a5        	call8	4037ad38 <prvCheckTasksWaitingTermination>
        esp_vApplicationIdleHook();
4037aef2:	e78081        	l32r	a8, 40374cf4 <_iram_text_start+0x8f0> (4200267c <esp_vApplicationIdleHook>)
4037aef5:	0008e0        	callx8	a8
    for( ; ; )
4037aef8:	fffcc6        	j	4037aeef <prvIdleTask+0x3>
	...

4037aefc <prvInitialiseNewTask>:
{
4037aefc:	006136        	entry	a1, 48
4037aeff:	1179      	s32i.n	a7, a1, 4
4037af01:	0179      	s32i.n	a7, a1, 0
4037af03:	c178      	l32i.n	a7, a1, 48
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
4037af05:	04cd      	mov.n	a12, a4
4037af07:	a5a0b2        	movi	a11, 165
4037af0a:	c7a8      	l32i.n	a10, a7, 48
4037af0c:	e56181        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037af0f:	0008e0        	callx8	a8
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
4037af12:	c788      	l32i.n	a8, a7, 48
4037af14:	440b      	addi.n	a4, a4, -1
4037af16:	484a      	add.n	a4, a8, a4
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
4037af18:	087c      	movi.n	a8, -16
4037af1a:	104480        	and	a4, a4, a8
            pxNewTCB->pxEndOfStack = pxTopOfStack;
4037af1d:	126742        	s32i	a4, a7, 72
    if( pcName != NULL )
4037af20:	23dc      	bnez.n	a3, 4037af36 <prvInitialiseNewTask+0x3a>
4037af22:	000746        	j	4037af43 <prvInitialiseNewTask+0x47>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
4037af25:	938a      	add.n	a9, a3, a8
4037af27:	000992        	l8ui	a9, a9, 0
4037af2a:	a78a      	add.n	a10, a7, a8
4037af2c:	344a92        	s8i	a9, a10, 52
            if( pcName[ x ] == ( char ) 0x00 )
4037af2f:	b98c      	beqz.n	a9, 4037af3e <prvInitialiseNewTask+0x42>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
4037af31:	881b      	addi.n	a8, a8, 1
4037af33:	000046        	j	4037af38 <prvInitialiseNewTask+0x3c>
4037af36:	080c      	movi.n	a8, 0
4037af38:	0fa092        	movi	a9, 15
4037af3b:	e6b987        	bgeu	a9, a8, 4037af25 <prvInitialiseNewTask+0x29>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
4037af3e:	080c      	movi.n	a8, 0
4037af40:	434782        	s8i	a8, a7, 67
    configASSERT( uxPriority < configMAX_PRIORITIES );
4037af43:	881c      	movi.n	a8, 24
4037af45:	11b867        	bgeu	a8, a6, 4037af5a <prvInitialiseNewTask+0x5e>
4037af48:	e76cd1        	l32r	a13, 40374cf8 <_iram_text_start+0x8f4> (3c024568 <_flash_rodata_start+0x4448>)
4037af4b:	e76cc1        	l32r	a12, 40374cfc <_iram_text_start+0x8f8> (3c02800c <__func__$5>)
4037af4e:	40a4b2        	movi	a11, 0x440
4037af51:	e756a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037af54:	201110        	or	a1, a1, a1
4037af57:	04dfa5        	call8	4037fd50 <__assert_func>
    pxNewTCB->uxPriority = uxPriority;
4037af5a:	b769      	s32i.n	a6, a7, 44
        pxNewTCB->xCoreID = xCoreID;
4037af5c:	e188      	l32i.n	a8, a1, 56
4037af5e:	116782        	s32i	a8, a7, 68
        pxNewTCB->uxBasePriority = uxPriority;
4037af61:	136762        	s32i	a6, a7, 76
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
4037af64:	04c7a2        	addi	a10, a7, 4
4037af67:	ff98a5        	call8	4037a8f0 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
4037af6a:	18c7a2        	addi	a10, a7, 24
4037af6d:	ff9825        	call8	4037a8f0 <vListInitialiseItem>
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
4037af70:	4779      	s32i.n	a7, a7, 16
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037af72:	e7c662        	addi	a6, a6, -25
4037af75:	606060        	neg	a6, a6
4037af78:	0020c0        	memw
4037af7b:	6769      	s32i.n	a6, a7, 24
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
4037af7d:	9779      	s32i.n	a7, a7, 36
        configINIT_TLS_BLOCK( pxNewTCB->xTLSBlock );
4037af7f:	5cc7a2        	addi	a10, a7, 92
4037af82:	fbc6e5        	call8	40376bf0 <esp_reent_init>
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
4037af85:	05cd      	mov.n	a12, a5
4037af87:	02bd      	mov.n	a11, a2
4037af89:	04ad      	mov.n	a10, a4
4037af8b:	ff0e65        	call8	4037a070 <pxPortInitialiseStack>
4037af8e:	07a9      	s32i.n	a10, a7, 0
    if( pxCreatedTask != NULL )
4037af90:	0188      	l32i.n	a8, a1, 0
4037af92:	288c      	beqz.n	a8, 4037af98 <prvInitialiseNewTask+0x9c>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
4037af94:	1188      	l32i.n	a8, a1, 4
4037af96:	0879      	s32i.n	a7, a8, 0
}
4037af98:	f01d      	retw.n
	...

4037af9c <prvInitialiseTaskLists>:
{
4037af9c:	004136        	entry	a1, 32
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037af9f:	070c      	movi.n	a7, 0
4037afa1:	000406        	j	4037afb5 <prvInitialiseTaskLists+0x19>
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
4037afa4:	a09770        	addx4	a9, a7, a7
4037afa7:	1189e0        	slli	a8, a9, 2
4037afaa:	e742a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037afad:	80aa80        	add	a10, a10, a8
4037afb0:	ff91a5        	call8	4037a8cc <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037afb3:	771b      	addi.n	a7, a7, 1
4037afb5:	881c      	movi.n	a8, 24
4037afb7:	e9b877        	bgeu	a8, a7, 4037afa4 <prvInitialiseTaskLists+0x8>
    vListInitialise( &xDelayedTaskList1 );
4037afba:	e751a1        	l32r	a10, 40374d00 <_iram_text_start+0x8fc> (3fc94bb8 <xDelayedTaskList1>)
4037afbd:	ff90e5        	call8	4037a8cc <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
4037afc0:	e751a1        	l32r	a10, 40374d04 <_iram_text_start+0x900> (3fc94ba4 <xDelayedTaskList2>)
4037afc3:	ff90a5        	call8	4037a8cc <vListInitialise>
    for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037afc6:	070c      	movi.n	a7, 0
4037afc8:	000406        	j	4037afdc <prvInitialiseTaskLists+0x40>
        vListInitialise( &xPendingReadyList[ x ] );
4037afcb:	a09770        	addx4	a9, a7, a7
4037afce:	1189e0        	slli	a8, a9, 2
4037afd1:	e74da1        	l32r	a10, 40374d08 <_iram_text_start+0x904> (3fc94b74 <xPendingReadyList>)
4037afd4:	80aa80        	add	a10, a10, a8
4037afd7:	ff8f65        	call8	4037a8cc <vListInitialise>
    for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037afda:	771b      	addi.n	a7, a7, 1
4037afdc:	eb27b6        	bltui	a7, 2, 4037afcb <prvInitialiseTaskLists+0x2f>
        vListInitialise( &xTasksWaitingTermination );
4037afdf:	e73ea1        	l32r	a10, 40374cd8 <_iram_text_start+0x8d4> (3fc94b60 <xTasksWaitingTermination>)
4037afe2:	ff8ea5        	call8	4037a8cc <vListInitialise>
        vListInitialise( &xSuspendedTaskList );
4037afe5:	e741a1        	l32r	a10, 40374cec <_iram_text_start+0x8e8> (3fc94b48 <xSuspendedTaskList>)
4037afe8:	ff8e25        	call8	4037a8cc <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
4037afeb:	e72c81        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94ba0 <pxDelayedTaskList>)
4037afee:	e74491        	l32r	a9, 40374d00 <_iram_text_start+0x8fc> (3fc94bb8 <xDelayedTaskList1>)
4037aff1:	0020c0        	memw
4037aff4:	0899      	s32i.n	a9, a8, 0
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
4037aff6:	e73e81        	l32r	a8, 40374cf0 <_iram_text_start+0x8ec> (3fc94b9c <pxOverflowDelayedTaskList>)
4037aff9:	e74291        	l32r	a9, 40374d04 <_iram_text_start+0x900> (3fc94ba4 <xDelayedTaskList2>)
4037affc:	0020c0        	memw
4037afff:	0899      	s32i.n	a9, a8, 0
}
4037b001:	f01d      	retw.n
	...

4037b004 <prvAddNewTaskToReadyList>:
{
4037b004:	004136        	entry	a1, 32
4037b007:	ffafb2        	movi	a11, -1
4037b00a:	e732a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b00d:	ff1225        	call8	4037a130 <xPortEnterCriticalTimeout>
        uxCurrentNumberOfTasks++;
4037b010:	e73381        	l32r	a8, 40374cdc <_iram_text_start+0x8d8> (3fc94b44 <uxCurrentNumberOfTasks>)
4037b013:	0020c0        	memw
4037b016:	002892        	l32i	a9, a8, 0
4037b019:	991b      	addi.n	a9, a9, 1
4037b01b:	0020c0        	memw
4037b01e:	0899      	s32i.n	a9, a8, 0
        if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
4037b020:	0020c0        	memw
4037b023:	002882        	l32i	a8, a8, 0
4037b026:	021866        	bnei	a8, 1, 4037b02c <prvAddNewTaskToReadyList+0x28>
            prvInitialiseTaskLists();
4037b029:	fff725        	call8	4037af9c <prvInitialiseTaskLists>
        if( ( pxCurrentTCBs[ 0 ] == NULL ) && ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) )
4037b02c:	e70581        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b02f:	0020c0        	memw
4037b032:	0888      	l32i.n	a8, a8, 0
4037b034:	48ec      	bnez.n	a8, 4037b05c <prvAddNewTaskToReadyList+0x58>
4037b036:	112282        	l32i	a8, a2, 68
4037b039:	40f890        	nsau	a9, a8
4037b03c:	419590        	srli	a9, a9, 5
4037b03f:	e5f2a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b042:	c088a0        	sub	a8, a8, a10
4037b045:	40f880        	nsau	a8, a8
4037b048:	418580        	srli	a8, a8, 5
4037b04b:	209980        	or	a9, a9, a8
4037b04e:	a98c      	beqz.n	a9, 4037b05c <prvAddNewTaskToReadyList+0x58>
            pxCurrentTCBs[ 0 ] = pxNewTCB;
4037b050:	e6fc81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b053:	0020c0        	memw
4037b056:	0829      	s32i.n	a2, a8, 0
4037b058:	002e46        	j	4037b115 <prvAddNewTaskToReadyList+0x111>
4037b05b:	f98100        	lsi	f0, a1, 0x3e4
            else if( ( pxCurrentTCBs[ 1 ] == NULL ) && ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) )
4037b05e:	20c0e6        	bgei	a0, 32, 4037b082 <prvAddNewTaskToReadyList+0x7e>
4037b061:	188800        	lsxp	f8, a8, a0
4037b064:	58ec      	bnez.n	a8, 4037b08d <prvAddNewTaskToReadyList+0x89>
4037b066:	112282        	l32i	a8, a2, 68
4037b069:	980b      	addi.n	a9, a8, -1
4037b06b:	40f990        	nsau	a9, a9
4037b06e:	419590        	srli	a9, a9, 5
4037b071:	e5e5a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b074:	c088a0        	sub	a8, a8, a10
4037b077:	40f880        	nsau	a8, a8
4037b07a:	418580        	srli	a8, a8, 5
4037b07d:	209980        	or	a9, a9, a8
4037b080:	998c      	beqz.n	a9, 4037b08d <prvAddNewTaskToReadyList+0x89>
                pxCurrentTCBs[ 1 ] = pxNewTCB;
4037b082:	e6ef81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b085:	0020c0        	memw
4037b088:	1829      	s32i.n	a2, a8, 4
4037b08a:	0021c6        	j	4037b115 <prvAddNewTaskToReadyList+0x111>
            if( xSchedulerRunning == pdFALSE )
4037b08d:	e71f81        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94b38 <xSchedulerRunning>)
4037b090:	0020c0        	memw
4037b093:	0888      	l32i.n	a8, a8, 0
4037b095:	07c856        	bnez	a8, 4037b115 <prvAddNewTaskToReadyList+0x111>
                if( ( pxCurrentTCBs[ 0 ] != NULL ) &&
4037b098:	e6ea81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b09b:	0020c0        	memw
4037b09e:	0888      	l32i.n	a8, a8, 0
4037b0a0:	48bc      	beqz.n	a8, 4037b0d8 <prvAddNewTaskToReadyList+0xd4>
                    ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) &&
4037b0a2:	112282        	l32i	a8, a2, 68
4037b0a5:	40f890        	nsau	a9, a8
4037b0a8:	419590        	srli	a9, a9, 5
4037b0ab:	e5d7a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b0ae:	c088a0        	sub	a8, a8, a10
4037b0b1:	40f880        	nsau	a8, a8
4037b0b4:	418580        	srli	a8, a8, 5
4037b0b7:	209980        	or	a9, a9, a8
                if( ( pxCurrentTCBs[ 0 ] != NULL ) &&
4037b0ba:	a99c      	beqz.n	a9, 4037b0d8 <prvAddNewTaskToReadyList+0xd4>
                    ( pxCurrentTCBs[ 0 ]->uxPriority <= pxNewTCB->uxPriority ) )
4037b0bc:	e6e181        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b0bf:	0020c0        	memw
4037b0c2:	0888      	l32i.n	a8, a8, 0
4037b0c4:	b888      	l32i.n	a8, a8, 44
4037b0c6:	b298      	l32i.n	a9, a2, 44
                    ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) &&
4037b0c8:	0c3987        	bltu	a9, a8, 4037b0d8 <prvAddNewTaskToReadyList+0xd4>
                    pxCurrentTCBs[ 0 ] = pxNewTCB;
4037b0cb:	e6dd81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b0ce:	0020c0        	memw
4037b0d1:	0829      	s32i.n	a2, a8, 0
4037b0d3:	000f86        	j	4037b115 <prvAddNewTaskToReadyList+0x111>
4037b0d6:	810000        	src	a0, a0, a0
                    else if( ( pxCurrentTCBs[ 1 ] != NULL ) &&
4037b0d9:	e6da      	add.n	a14, a6, a13
4037b0db:	0020c0        	memw
4037b0de:	1888      	l32i.n	a8, a8, 4
4037b0e0:	18bc      	beqz.n	a8, 4037b115 <prvAddNewTaskToReadyList+0x111>
                             ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) &&
4037b0e2:	112282        	l32i	a8, a2, 68
4037b0e5:	980b      	addi.n	a9, a8, -1
4037b0e7:	40f990        	nsau	a9, a9
4037b0ea:	419590        	srli	a9, a9, 5
4037b0ed:	e5c6a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b0f0:	c088a0        	sub	a8, a8, a10
4037b0f3:	40f880        	nsau	a8, a8
4037b0f6:	418580        	srli	a8, a8, 5
4037b0f9:	209980        	or	a9, a9, a8
                    else if( ( pxCurrentTCBs[ 1 ] != NULL ) &&
4037b0fc:	599c      	beqz.n	a9, 4037b115 <prvAddNewTaskToReadyList+0x111>
                             ( pxCurrentTCBs[ 1 ]->uxPriority <= pxNewTCB->uxPriority ) )
4037b0fe:	e6d081        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b101:	0020c0        	memw
4037b104:	1888      	l32i.n	a8, a8, 4
4037b106:	b888      	l32i.n	a8, a8, 44
4037b108:	b298      	l32i.n	a9, a2, 44
                             ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) &&
4037b10a:	073987        	bltu	a9, a8, 4037b115 <prvAddNewTaskToReadyList+0x111>
                        pxCurrentTCBs[ 1 ] = pxNewTCB;
4037b10d:	e6cc81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b110:	0020c0        	memw
4037b113:	1829      	s32i.n	a2, a8, 4
        uxTaskNumber++;
4037b115:	e6fe91        	l32r	a9, 40374d10 <_iram_text_start+0x90c> (3fc94b24 <uxTaskNumber>)
4037b118:	0988      	l32i.n	a8, a9, 0
4037b11a:	881b      	addi.n	a8, a8, 1
4037b11c:	0989      	s32i.n	a8, a9, 0
        prvAddTaskToReadyList( pxNewTCB );
4037b11e:	b288      	l32i.n	a8, a2, 44
4037b120:	e6e491        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b123:	0020c0        	memw
4037b126:	0998      	l32i.n	a9, a9, 0
4037b128:	07b987        	bgeu	a9, a8, 4037b133 <prvAddNewTaskToReadyList+0x12f>
4037b12b:	e6e191        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b12e:	0020c0        	memw
4037b131:	0989      	s32i.n	a8, a9, 0
4037b133:	e6e0a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037b136:	a08880        	addx4	a8, a8, a8
4037b139:	a088a0        	addx4	a8, a8, a10
4037b13c:	0020c0        	memw
4037b13f:	1888      	l32i.n	a8, a8, 4
4037b141:	0020c0        	memw
4037b144:	2289      	s32i.n	a8, a2, 8
4037b146:	0020c0        	memw
4037b149:	2898      	l32i.n	a9, a8, 8
4037b14b:	0020c0        	memw
4037b14e:	3299      	s32i.n	a9, a2, 12
4037b150:	0020c0        	memw
4037b153:	28b8      	l32i.n	a11, a8, 8
4037b155:	924b      	addi.n	a9, a2, 4
4037b157:	0020c0        	memw
4037b15a:	1b99      	s32i.n	a9, a11, 4
4037b15c:	0020c0        	memw
4037b15f:	2899      	s32i.n	a9, a8, 8
4037b161:	b288      	l32i.n	a8, a2, 44
4037b163:	a09880        	addx4	a9, a8, a8
4037b166:	a099a0        	addx4	a9, a9, a10
4037b169:	0020c0        	memw
4037b16c:	5299      	s32i.n	a9, a2, 20
4037b16e:	0020c0        	memw
4037b171:	0998      	l32i.n	a9, a9, 0
4037b173:	991b      	addi.n	a9, a9, 1
4037b175:	a08880        	addx4	a8, a8, a8
4037b178:	a088a0        	addx4	a8, a8, a10
4037b17b:	0020c0        	memw
4037b17e:	0899      	s32i.n	a9, a8, 0
        if( xSchedulerRunning != pdFALSE )
4037b180:	e6e381        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94b38 <xSchedulerRunning>)
4037b183:	0020c0        	memw
4037b186:	0888      	l32i.n	a8, a8, 0
4037b188:	489c      	beqz.n	a8, 4037b1a0 <prvAddNewTaskToReadyList+0x19c>
            if( taskIS_YIELD_REQUIRED( pxNewTCB, pdTRUE ) == pdTRUE )
4037b18a:	1c0c      	movi.n	a12, 1
4037b18c:	b2b8      	l32i.n	a11, a2, 44
4037b18e:	20a220        	or	a10, a2, a2
4037b191:	ff8da5        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037b194:	081a66        	bnei	a10, 1, 4037b1a0 <prvAddNewTaskToReadyList+0x19c>
4037b197:	03eba0        	rsr.prid	a10
4037b19a:	04ada0        	extui	a10, a10, 13, 1
                taskYIELD_IF_USING_PREEMPTION();
4037b19d:	fcf2e5        	call8	403780cc <esp_crosscore_int_send_yield>
    taskEXIT_CRITICAL( &xKernelLock );
4037b1a0:	e6cda1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b1a3:	ff0de5        	call8	4037a280 <vPortExitCritical>
}
4037b1a6:	f01d      	retw.n

4037b1a8 <vTaskSuspendAll>:
{
4037b1a8:	004136        	entry	a1, 32
4037b1ab:	ffafb2        	movi	a11, -1
4037b1ae:	e6c9a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b1b1:	fef7e5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b1b4:	03eb80        	rsr.prid	a8
4037b1b7:	048d80        	extui	a8, a8, 13, 1
        ++uxSchedulerSuspended[ portGET_CORE_ID() ];
4037b1ba:	e6b791        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037b1bd:	a08890        	addx4	a8, a8, a9
4037b1c0:	0020c0        	memw
4037b1c3:	002892        	l32i	a9, a8, 0
4037b1c6:	991b      	addi.n	a9, a9, 1
4037b1c8:	0020c0        	memw
4037b1cb:	006892        	s32i	a9, a8, 0
    prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037b1ce:	e6c1a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b1d1:	ff0ae5        	call8	4037a280 <vPortExitCritical>
}
4037b1d4:	f01d      	retw.n
	...

4037b1d8 <xTaskGetTickCount>:
{
4037b1d8:	004136        	entry	a1, 32
        xTicks = xTickCount;
4037b1db:	e6c381        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037b1de:	0020c0        	memw
4037b1e1:	0828      	l32i.n	a2, a8, 0
}
4037b1e3:	f01d      	retw.n
4037b1e5:	000000        	ill

4037b1e8 <xTaskGetTickCountFromISR>:
{
4037b1e8:	004136        	entry	a1, 32
4037b1eb:	ffafb2        	movi	a11, -1
4037b1ee:	e6b9a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b1f1:	fef3e5        	call8	4037a130 <xPortEnterCriticalTimeout>
            xReturn = xTickCount;
4037b1f4:	e6bd81        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037b1f7:	0020c0        	memw
4037b1fa:	002822        	l32i	a2, a8, 0
    prvEXIT_CRITICAL_ISR_SMP_ONLY( &xKernelLock );
4037b1fd:	e6b5a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b200:	ff07e5        	call8	4037a280 <vPortExitCritical>
}
4037b203:	000090        	retw
	...

4037b208 <xTaskIncrementTick>:
{
4037b208:	004136        	entry	a1, 32
4037b20b:	03eb80        	rsr.prid	a8
4037b20e:	048d80        	extui	a8, a8, 13, 1
        configASSERT( portGET_CORE_ID() == 0 );
4037b211:	00e816        	beqz	a8, 4037b223 <xTaskIncrementTick+0x1b>
4037b214:	e6c0d1        	l32r	a13, 40374d14 <_iram_text_start+0x910> (3c024584 <_flash_rodata_start+0x4464>)
4037b217:	e6c0c1        	l32r	a12, 40374d18 <_iram_text_start+0x914> (3c028150 <__func__$25>)
4037b21a:	e6c0b1        	l32r	a11, 40374d1c <_iram_text_start+0x918> (c7b <UserFrameTotalSize+0xb7b>)
4037b21d:	e6a3a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b220:	04b2e5        	call8	4037fd50 <__assert_func>
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b223:	feeea5        	call8	4037a10c <xPortInIsrContext>
4037b226:	9acc      	bnez.n	a10, 4037b233 <xTaskIncrementTick+0x2b>
4037b228:	fb7c      	movi.n	a11, -1
4037b22a:	e6aaa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b22d:	fef025        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037b230:	000206        	j	4037b23c <xTaskIncrementTick+0x34>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b233:	ffafb2        	movi	a11, -1
4037b236:	e6a7a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b239:	feef65        	call8	4037a130 <xPortEnterCriticalTimeout>
        if( uxSchedulerSuspended[ 0 ] == ( UBaseType_t ) pdFALSE )
4037b23c:	e69781        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037b23f:	0020c0        	memw
4037b242:	002882        	l32i	a8, a8, 0
4037b245:	257856        	bnez	a8, 4037b4a0 <xTaskIncrementTick+0x298>
            const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
4037b248:	e6a881        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037b24b:	0020c0        	memw
4037b24e:	0878      	l32i.n	a7, a8, 0
4037b250:	771b      	addi.n	a7, a7, 1
            xTickCount = xConstTickCount;
4037b252:	0020c0        	memw
4037b255:	0879      	s32i.n	a7, a8, 0
            if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
4037b257:	04d756        	bnez	a7, 4037b2a8 <xTaskIncrementTick+0xa0>
                taskSWITCH_DELAYED_LISTS();
4037b25a:	e69081        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94ba0 <pxDelayedTaskList>)
4037b25d:	0020c0        	memw
4037b260:	0888      	l32i.n	a8, a8, 0
4037b262:	0020c0        	memw
4037b265:	0888      	l32i.n	a8, a8, 0
4037b267:	00e816        	beqz	a8, 4037b279 <xTaskIncrementTick+0x71>
4037b26a:	e6add1        	l32r	a13, 40374d20 <_iram_text_start+0x91c> (3c02459c <_flash_rodata_start+0x447c>)
4037b26d:	e6aac1        	l32r	a12, 40374d18 <_iram_text_start+0x914> (3c028150 <__func__$25>)
4037b270:	e6adb1        	l32r	a11, 40374d24 <_iram_text_start+0x920> (c9b <UserFrameTotalSize+0xb9b>)
4037b273:	e68ea1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b276:	04ada5        	call8	4037fd50 <__assert_func>
4037b279:	e68891        	l32r	a9, 40374c9c <_iram_text_start+0x898> (3fc94ba0 <pxDelayedTaskList>)
4037b27c:	0020c0        	memw
4037b27f:	0029a2        	l32i	a10, a9, 0
4037b282:	e69b81        	l32r	a8, 40374cf0 <_iram_text_start+0x8ec> (3fc94b9c <pxOverflowDelayedTaskList>)
4037b285:	0020c0        	memw
4037b288:	0028b2        	l32i	a11, a8, 0
4037b28b:	0020c0        	memw
4037b28e:	0069b2        	s32i	a11, a9, 0
4037b291:	0020c0        	memw
4037b294:	08a9      	s32i.n	a10, a8, 0
4037b296:	e6a491        	l32r	a9, 40374d28 <_iram_text_start+0x924> (3fc94b28 <xNumOfOverflows>)
4037b299:	0020c0        	memw
4037b29c:	0988      	l32i.n	a8, a9, 0
4037b29e:	881b      	addi.n	a8, a8, 1
4037b2a0:	0020c0        	memw
4037b2a3:	0989      	s32i.n	a8, a9, 0
4037b2a5:	ff78a5        	call8	4037aa30 <prvResetNextTaskUnblockTime>
            if( xConstTickCount >= xNextTaskUnblockTime )
4037b2a8:	e67e81        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94b20 <xNextTaskUnblockTime>)
4037b2ab:	0020c0        	memw
4037b2ae:	0888      	l32i.n	a8, a8, 0
4037b2b0:	0ab787        	bgeu	a7, a8, 4037b2be <xTaskIncrementTick+0xb6>
    BaseType_t xSwitchRequired = pdFALSE;
4037b2b3:	020c      	movi.n	a2, 0
4037b2b5:	006ec6        	j	4037b474 <xTaskIncrementTick+0x26c>
                                    xSwitchRequired = pdTRUE;
4037b2b8:	120c      	movi.n	a2, 1
4037b2ba:	000086        	j	4037b2c0 <xTaskIncrementTick+0xb8>
4037b2bd:	020c00        	andb	b0, b12, b0
                    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037b2c0:	e67781        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94ba0 <pxDelayedTaskList>)
4037b2c3:	0020c0        	memw
4037b2c6:	0888      	l32i.n	a8, a8, 0
4037b2c8:	0020c0        	memw
4037b2cb:	0888      	l32i.n	a8, a8, 0
4037b2cd:	b8cc      	bnez.n	a8, 4037b2dc <xTaskIncrementTick+0xd4>
                        xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037b2cf:	e67481        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94b20 <xNextTaskUnblockTime>)
4037b2d2:	f97c      	movi.n	a9, -1
4037b2d4:	0020c0        	memw
4037b2d7:	0899      	s32i.n	a9, a8, 0
                        break;
4037b2d9:	0065c6        	j	4037b474 <xTaskIncrementTick+0x26c>
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b2dc:	e67081        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94ba0 <pxDelayedTaskList>)
4037b2df:	0020c0        	memw
4037b2e2:	0888      	l32i.n	a8, a8, 0
4037b2e4:	0020c0        	memw
4037b2e7:	3888      	l32i.n	a8, a8, 12
4037b2e9:	3888      	l32i.n	a8, a8, 12
                        xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
4037b2eb:	0020c0        	memw
4037b2ee:	1898      	l32i.n	a9, a8, 4
                        if( xConstTickCount < xItemValue )
4037b2f0:	0db797        	bgeu	a7, a9, 4037b301 <xTaskIncrementTick+0xf9>
                            xNextTaskUnblockTime = xItemValue;
4037b2f3:	e66b81        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94b20 <xNextTaskUnblockTime>)
4037b2f6:	0020c0        	memw
4037b2f9:	0899      	s32i.n	a9, a8, 0
                            break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
4037b2fb:	005d46        	j	4037b474 <xTaskIncrementTick+0x26c>
4037b2fe:	000000        	ill
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037b301:	0020c0        	memw
4037b304:	5898      	l32i.n	a9, a8, 20
4037b306:	0020c0        	memw
4037b309:	28a8      	l32i.n	a10, a8, 8
4037b30b:	0020c0        	memw
4037b30e:	38b8      	l32i.n	a11, a8, 12
4037b310:	0020c0        	memw
4037b313:	2ab9      	s32i.n	a11, a10, 8
4037b315:	0020c0        	memw
4037b318:	38a8      	l32i.n	a10, a8, 12
4037b31a:	0020c0        	memw
4037b31d:	28b8      	l32i.n	a11, a8, 8
4037b31f:	0020c0        	memw
4037b322:	1ab9      	s32i.n	a11, a10, 4
4037b324:	0020c0        	memw
4037b327:	19b8      	l32i.n	a11, a9, 4
4037b329:	a84b      	addi.n	a10, a8, 4
4037b32b:	0a9ba7        	bne	a11, a10, 4037b339 <xTaskIncrementTick+0x131>
4037b32e:	0020c0        	memw
4037b331:	0328b2        	l32i	a11, a8, 12
4037b334:	0020c0        	memw
4037b337:	19b9      	s32i.n	a11, a9, 4
4037b339:	0b0c      	movi.n	a11, 0
4037b33b:	0020c0        	memw
4037b33e:	58b9      	s32i.n	a11, a8, 20
4037b340:	0020c0        	memw
4037b343:	09b8      	l32i.n	a11, a9, 0
4037b345:	bb0b      	addi.n	a11, a11, -1
4037b347:	0020c0        	memw
4037b34a:	09b9      	s32i.n	a11, a9, 0
                        if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037b34c:	0020c0        	memw
4037b34f:	a898      	l32i.n	a9, a8, 40
4037b351:	04c916        	beqz	a9, 4037b3a1 <xTaskIncrementTick+0x199>
                            listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
4037b354:	0020c0        	memw
4037b357:	a898      	l32i.n	a9, a8, 40
4037b359:	0020c0        	memw
4037b35c:	78b8      	l32i.n	a11, a8, 28
4037b35e:	0020c0        	memw
4037b361:	88c8      	l32i.n	a12, a8, 32
4037b363:	0020c0        	memw
4037b366:	2bc9      	s32i.n	a12, a11, 8
4037b368:	0020c0        	memw
4037b36b:	88b8      	l32i.n	a11, a8, 32
4037b36d:	0020c0        	memw
4037b370:	78c8      	l32i.n	a12, a8, 28
4037b372:	0020c0        	memw
4037b375:	1bc9      	s32i.n	a12, a11, 4
4037b377:	0020c0        	memw
4037b37a:	19c8      	l32i.n	a12, a9, 4
4037b37c:	18c8b2        	addi	a11, a8, 24
4037b37f:	0a9cb7        	bne	a12, a11, 4037b38d <xTaskIncrementTick+0x185>
4037b382:	0020c0        	memw
4037b385:	0828b2        	l32i	a11, a8, 32
4037b388:	0020c0        	memw
4037b38b:	19b9      	s32i.n	a11, a9, 4
4037b38d:	0b0c      	movi.n	a11, 0
4037b38f:	0020c0        	memw
4037b392:	a8b9      	s32i.n	a11, a8, 40
4037b394:	0020c0        	memw
4037b397:	09b8      	l32i.n	a11, a9, 0
4037b399:	ffcbb2        	addi	a11, a11, -1
4037b39c:	0020c0        	memw
4037b39f:	09b9      	s32i.n	a11, a9, 0
                        prvAddTaskToReadyList( pxTCB );
4037b3a1:	b898      	l32i.n	a9, a8, 44
4037b3a3:	e643b1        	l32r	a11, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b3a6:	0020c0        	memw
4037b3a9:	002bb2        	l32i	a11, a11, 0
4037b3ac:	08bb97        	bgeu	a11, a9, 4037b3b8 <xTaskIncrementTick+0x1b0>
4037b3af:	e640b1        	l32r	a11, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b3b2:	0020c0        	memw
4037b3b5:	006b92        	s32i	a9, a11, 0
4037b3b8:	e63fb1        	l32r	a11, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037b3bb:	a09990        	addx4	a9, a9, a9
4037b3be:	a099b0        	addx4	a9, a9, a11
4037b3c1:	0020c0        	memw
4037b3c4:	1998      	l32i.n	a9, a9, 4
4037b3c6:	0020c0        	memw
4037b3c9:	2899      	s32i.n	a9, a8, 8
4037b3cb:	0020c0        	memw
4037b3ce:	29c8      	l32i.n	a12, a9, 8
4037b3d0:	0020c0        	memw
4037b3d3:	38c9      	s32i.n	a12, a8, 12
4037b3d5:	0020c0        	memw
4037b3d8:	29c8      	l32i.n	a12, a9, 8
4037b3da:	0020c0        	memw
4037b3dd:	1ca9      	s32i.n	a10, a12, 4
4037b3df:	0020c0        	memw
4037b3e2:	29a9      	s32i.n	a10, a9, 8
4037b3e4:	b898      	l32i.n	a9, a8, 44
4037b3e6:	a0a990        	addx4	a10, a9, a9
4037b3e9:	a0aab0        	addx4	a10, a10, a11
4037b3ec:	0020c0        	memw
4037b3ef:	58a9      	s32i.n	a10, a8, 20
4037b3f1:	0020c0        	memw
4037b3f4:	0aa8      	l32i.n	a10, a10, 0
4037b3f6:	aa1b      	addi.n	a10, a10, 1
4037b3f8:	a09990        	addx4	a9, a9, a9
4037b3fb:	a099b0        	addx4	a9, a9, a11
4037b3fe:	0020c0        	memw
4037b401:	09a9      	s32i.n	a10, a9, 0
                            if( taskIS_AFFINITY_COMPATIBLE( 0, pxTCB ) == pdTRUE )
4037b403:	1128b2        	l32i	a11, a8, 68
4037b406:	40fba0        	nsau	a10, a11
4037b409:	41a5a0        	srli	a10, a10, 5
4037b40c:	e4ff91        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b40f:	c09b90        	sub	a9, a11, a9
4037b412:	40f990        	nsau	a9, a9
4037b415:	419590        	srli	a9, a9, 5
4037b418:	20aa90        	or	a10, a10, a9
4037b41b:	6abc      	beqz.n	a10, 4037b455 <xTaskIncrementTick+0x24d>
                                if( pxTCB->uxPriority > pxCurrentTCBs[ 0 ]->uxPriority )
4037b41d:	b888      	l32i.n	a8, a8, 44
4037b41f:	e60891        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b422:	0020c0        	memw
4037b425:	0998      	l32i.n	a9, a9, 0
4037b427:	b998      	l32i.n	a9, a9, 44
4037b429:	02b987        	bgeu	a9, a8, 4037b42f <xTaskIncrementTick+0x227>
4037b42c:	ffa206        	j	4037b2b8 <xTaskIncrementTick+0xb0>
                                    else if( pxTCB->xCoreID == tskNO_AFFINITY )
4037b42f:	e4f691        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b432:	021b97        	beq	a11, a9, 4037b438 <xTaskIncrementTick+0x230>
4037b435:	ffa1c6        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                        if( pxTCB->uxPriority > pxCurrentTCBs[ 1 ]->uxPriority )
4037b438:	e60291        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b43b:	0020c0        	memw
4037b43e:	1998      	l32i.n	a9, a9, 4
4037b440:	b998      	l32i.n	a9, a9, 44
4037b442:	023987        	bltu	a9, a8, 4037b448 <xTaskIncrementTick+0x240>
4037b445:	ff9dc6        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                            xYieldPending[ 1 ] = pdTRUE;
4037b448:	e63981        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037b44b:	190c      	movi.n	a9, 1
4037b44d:	0020c0        	memw
4037b450:	1899      	s32i.n	a9, a8, 4
4037b452:	ff9a86        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                    if( pxTCB->uxPriority > pxCurrentTCBs[ 1 ]->uxPriority )
4037b455:	b888      	l32i.n	a8, a8, 44
4037b457:	e5fa91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b45a:	0020c0        	memw
4037b45d:	1998      	l32i.n	a9, a9, 4
4037b45f:	b998      	l32i.n	a9, a9, 44
4037b461:	023987        	bltu	a9, a8, 4037b467 <xTaskIncrementTick+0x25f>
4037b464:	ff9606        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                                        xYieldPending[ 1 ] = pdTRUE;
4037b467:	e63181        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037b46a:	190c      	movi.n	a9, 1
4037b46c:	0020c0        	memw
4037b46f:	1899      	s32i.n	a9, a8, 4
4037b471:	ff92c6        	j	4037b2c0 <xTaskIncrementTick+0xb8>
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCBs[ 0 ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037b474:	e5f381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b477:	0020c0        	memw
4037b47a:	0888      	l32i.n	a8, a8, 0
4037b47c:	b888      	l32i.n	a8, a8, 44
4037b47e:	a08880        	addx4	a8, a8, a8
4037b481:	e60c91        	l32r	a9, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037b484:	a08890        	addx4	a8, a8, a9
4037b487:	0020c0        	memw
4037b48a:	0888      	l32i.n	a8, a8, 0
4037b48c:	0128b6        	bltui	a8, 2, 4037b491 <xTaskIncrementTick+0x289>
                    xSwitchRequired = pdTRUE;
4037b48f:	120c      	movi.n	a2, 1
                if( xYieldPending[ 0 ] != pdFALSE )
4037b491:	e62681        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037b494:	0020c0        	memw
4037b497:	0888      	l32i.n	a8, a8, 0
4037b499:	88dc      	bnez.n	a8, 4037b4b5 <xTaskIncrementTick+0x2ad>
4037b49b:	000646        	j	4037b4b8 <xTaskIncrementTick+0x2b0>
4037b49e:	910000        	srl	a0, a0
            ++xPendedTicks;
4037b4a1:	c0e624        	lsi	f2, a6, 0x300
4037b4a4:	880020        	lsi	f2, a0, 0x220
4037b4a7:	1b09      	s32i.n	a0, a11, 4
4037b4a9:	c088      	l32i.n	a8, a0, 48
4037b4ab:	890020        	lsi	f2, a0, 0x224
4037b4ae:	0c09      	s32i.n	a0, a12, 0
    BaseType_t xSwitchRequired = pdFALSE;
4037b4b0:	00c602        	addi	a0, a6, 0
4037b4b3:	220000        	orb	b0, b0, b0
                    xSwitchRequired = pdTRUE;
4037b4b6:	2501a0        	extui	a0, a10, 17, 3
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b4b9:	56fec5        	call0	403d24a8 <_coredump_iram_end+0x505a8>
4037b4bc:	009a      	add.n	a0, a0, a9
            taskEXIT_CRITICAL( pxLock );
4037b4be:	e605a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b4c1:	fedbe5        	call8	4037a280 <vPortExitCritical>
4037b4c4:	000186        	j	4037b4ce <xTaskIncrementTick+0x2c6>
4037b4c7:	03a100        	rsr.dbreakc1	a0
            taskEXIT_CRITICAL_ISR( pxLock );
4037b4ca:	db65e6        	bgei	a5, 6, 4037b4a9 <xTaskIncrementTick+0x2a1>
4037b4cd:	fe          	.byte	0xfe
}
4037b4ce:	f01d      	retw.n

4037b4d0 <vTaskSwitchContext>:
{
4037b4d0:	004136        	entry	a1, 32
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b4d3:	fec3a5        	call8	4037a10c <xPortInIsrContext>
4037b4d6:	00ba56        	bnez	a10, 4037b4e5 <vTaskSwitchContext+0x15>
4037b4d9:	ffafb2        	movi	a11, -1
4037b4dc:	e5fea1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b4df:	fec525        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037b4e2:	000206        	j	4037b4ee <vTaskSwitchContext+0x1e>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b4e5:	ffafb2        	movi	a11, -1
4037b4e8:	e5fba1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b4eb:	fec465        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b4ee:	03eb80        	rsr.prid	a8
4037b4f1:	048d80        	extui	a8, a8, 13, 1
        if( uxSchedulerSuspended[ xCurCoreID ] != ( UBaseType_t ) pdFALSE )
4037b4f4:	e5e991        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037b4f7:	a09890        	addx4	a9, a8, a9
4037b4fa:	0020c0        	memw
4037b4fd:	002992        	l32i	a9, a9, 0
4037b500:	010916        	beqz	a9, 4037b514 <vTaskSwitchContext+0x44>
            xYieldPending[ xCurCoreID ] = pdTRUE;
4037b503:	e60a91        	l32r	a9, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037b506:	a08890        	addx4	a8, a8, a9
4037b509:	190c      	movi.n	a9, 1
4037b50b:	0020c0        	memw
4037b50e:	0899      	s32i.n	a9, a8, 0
4037b510:	001346        	j	4037b561 <vTaskSwitchContext+0x91>
4037b513:	069100        	lsi	f0, a1, 24
            xYieldPending[ xCurCoreID ] = pdFALSE;
4037b516:	9890e6        	bgei	a0, 10, 4037b4b2 <xTaskIncrementTick+0x2aa>
4037b519:	0a0ca0        	add.s	f0, f12, f10
4037b51c:	0020c0        	memw
4037b51f:	09a9      	s32i.n	a10, a9, 0
            taskCHECK_FOR_STACK_OVERFLOW( xCurCoreID );
4037b521:	e5c791        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b524:	a09890        	addx4	a9, a8, a9
4037b527:	0020c0        	memw
4037b52a:	0998      	l32i.n	a9, a9, 0
4037b52c:	c998      	l32i.n	a9, a9, 48
4037b52e:	09b8      	l32i.n	a11, a9, 0
4037b530:	e601a1        	l32r	a10, 40374d34 <_iram_text_start+0x930> (a5a5a5a5 <_rtc_reserved_end+0x4595a5a5>)
4037b533:	119ba7        	bne	a11, a10, 4037b548 <vTaskSwitchContext+0x78>
4037b536:	19b8      	l32i.n	a11, a9, 4
4037b538:	0c9ba7        	bne	a11, a10, 4037b548 <vTaskSwitchContext+0x78>
4037b53b:	29b8      	l32i.n	a11, a9, 8
4037b53d:	079ba7        	bne	a11, a10, 4037b548 <vTaskSwitchContext+0x78>
4037b540:	39a8      	l32i.n	a10, a9, 12
4037b542:	e5fc91        	l32r	a9, 40374d34 <_iram_text_start+0x930> (a5a5a5a5 <_rtc_reserved_end+0x4595a5a5>)
4037b545:	151a97        	beq	a10, a9, 4037b55e <vTaskSwitchContext+0x8e>
4037b548:	e5be91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b54b:	a08890        	addx4	a8, a8, a9
4037b54e:	0020c0        	memw
4037b551:	08a8      	l32i.n	a10, a8, 0
4037b553:	0020c0        	memw
4037b556:	08b8      	l32i.n	a11, a8, 0
4037b558:	34cbb2        	addi	a11, a11, 52
4037b55b:	fedce5        	call8	4037a328 <vApplicationStackOverflowHook>
            taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b55e:	ff5aa5        	call8	4037ab08 <prvSelectHighestPriorityTaskSMP>
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b561:	febaa5        	call8	4037a10c <xPortInIsrContext>
4037b564:	8acc      	bnez.n	a10, 4037b570 <vTaskSwitchContext+0xa0>
            taskEXIT_CRITICAL( pxLock );
4037b566:	e5dba1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b569:	fed165        	call8	4037a280 <vPortExitCritical>
4037b56c:	000186        	j	4037b576 <vTaskSwitchContext+0xa6>
4037b56f:	d9a100        	lsi	f0, a1, 0x364
            taskEXIT_CRITICAL_ISR( pxLock );
4037b572:	d0e5e5        	call8	4034c3d0 <rom_rx_gain_force+0x345fa4>
4037b575:	fe          	.byte	0xfe
}
4037b576:	f01d      	retw.n

4037b578 <vTaskPlaceOnEventList>:
{
4037b578:	004136        	entry	a1, 32
    configASSERT( pxEventList );
4037b57b:	00e256        	bnez	a2, 4037b58d <vTaskPlaceOnEventList+0x15>
4037b57e:	e5eed1        	l32r	a13, 40374d38 <_iram_text_start+0x934> (3c024614 <_flash_rodata_start+0x44f4>)
4037b581:	e5eec1        	l32r	a12, 40374d3c <_iram_text_start+0x938> (3c028118 <__func__$23>)
4037b584:	e5efb1        	l32r	a11, 40374d40 <_iram_text_start+0x93c> (e95 <UserFrameTotalSize+0xd95>)
4037b587:	e5c9a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b58a:	047c65        	call8	4037fd50 <__assert_func>
4037b58d:	fb7c      	movi.n	a11, -1
4037b58f:	e5d1a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b592:	feb9e5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b595:	03eb80        	rsr.prid	a8
4037b598:	048d80        	extui	a8, a8, 13, 1
        vListInsert( pxEventList, &( pxCurrentTCBs[ portGET_CORE_ID() ]->xEventListItem ) );
4037b59b:	e5a991        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b59e:	a08890        	addx4	a8, a8, a9
4037b5a1:	0020c0        	memw
4037b5a4:	0028b2        	l32i	a11, a8, 0
4037b5a7:	18cbb2        	addi	a11, a11, 24
4037b5aa:	20a220        	or	a10, a2, a2
4037b5ad:	ff38a5        	call8	4037a938 <vListInsert>
        prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4037b5b0:	1b0c      	movi.n	a11, 1
4037b5b2:	03ad      	mov.n	a10, a3
4037b5b4:	ff81a5        	call8	4037add0 <prvAddCurrentTaskToDelayedList>
    prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037b5b7:	e5c7a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b5ba:	fecc65        	call8	4037a280 <vPortExitCritical>
}
4037b5bd:	f01d      	retw.n
	...

4037b5c0 <xTaskRemoveFromEventList>:
    {
4037b5c0:	004136        	entry	a1, 32
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b5c3:	feb4a5        	call8	4037a10c <xPortInIsrContext>
4037b5c6:	00ca56        	bnez	a10, 4037b5d6 <xTaskRemoveFromEventList+0x16>
4037b5c9:	fb7c      	movi.n	a11, -1
4037b5cb:	e5c2a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b5ce:	feb625        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037b5d1:	000286        	j	4037b5df <xTaskRemoveFromEventList+0x1f>
4037b5d4:	b20000        	mulsh	a0, a0, a0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b5d7:	af          	.byte	0xaf
4037b5d8:	ff          	.byte	0xff
4037b5d9:	e5bea1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b5dc:	feb525        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( listLIST_IS_EMPTY( pxEventList ) == pdFALSE )
4037b5df:	0020c0        	memw
4037b5e2:	002282        	l32i	a8, a2, 0
4037b5e5:	1b4816        	beqz	a8, 4037b79d <xTaskRemoveFromEventList+0x1dd>
4037b5e8:	03eb60        	rsr.prid	a6
4037b5eb:	046d60        	extui	a6, a6, 13, 1
4037b5ee:	065d      	mov.n	a5, a6
                pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
4037b5f0:	0020c0        	memw
4037b5f3:	3288      	l32i.n	a8, a2, 12
4037b5f5:	3878      	l32i.n	a7, a8, 12
                configASSERT( pxUnblockedTCB );
4037b5f7:	00e756        	bnez	a7, 4037b609 <xTaskRemoveFromEventList+0x49>
4037b5fa:	e5d2d1        	l32r	a13, 40374d44 <_iram_text_start+0x940> (3c024620 <_flash_rodata_start+0x4500>)
4037b5fd:	e5d2c1        	l32r	a12, 40374d48 <_iram_text_start+0x944> (3c0280fc <__func__$20>)
4037b600:	e5d3b1        	l32r	a11, 40374d4c <_iram_text_start+0x948> (f2a <UserFrameTotalSize+0xe2a>)
4037b603:	e5aaa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b606:	0474a5        	call8	4037fd50 <__assert_func>
                listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
4037b609:	0020c0        	memw
4037b60c:	a788      	l32i.n	a8, a7, 40
4037b60e:	0020c0        	memw
4037b611:	7798      	l32i.n	a9, a7, 28
4037b613:	0020c0        	memw
4037b616:	87a8      	l32i.n	a10, a7, 32
4037b618:	0020c0        	memw
4037b61b:	29a9      	s32i.n	a10, a9, 8
4037b61d:	0020c0        	memw
4037b620:	8798      	l32i.n	a9, a7, 32
4037b622:	0020c0        	memw
4037b625:	77a8      	l32i.n	a10, a7, 28
4037b627:	0020c0        	memw
4037b62a:	19a9      	s32i.n	a10, a9, 4
4037b62c:	0020c0        	memw
4037b62f:	1898      	l32i.n	a9, a8, 4
4037b631:	18c722        	addi	a2, a7, 24
4037b634:	099927        	bne	a9, a2, 4037b641 <xTaskRemoveFromEventList+0x81>
4037b637:	0020c0        	memw
4037b63a:	8798      	l32i.n	a9, a7, 32
4037b63c:	0020c0        	memw
4037b63f:	1899      	s32i.n	a9, a8, 4
4037b641:	00a092        	movi	a9, 0
4037b644:	0020c0        	memw
4037b647:	0a6792        	s32i	a9, a7, 40
4037b64a:	0020c0        	memw
4037b64d:	002892        	l32i	a9, a8, 0
4037b650:	990b      	addi.n	a9, a9, -1
4037b652:	0020c0        	memw
4037b655:	0899      	s32i.n	a9, a8, 0
                if( taskCAN_BE_SCHEDULED( pxUnblockedTCB ) == pdTRUE )
4037b657:	07ad      	mov.n	a10, a7
4037b659:	ff38e5        	call8	4037a9e8 <prvCheckTaskCanBeScheduledSMP>
4037b65c:	021a26        	beqi	a10, 1, 4037b662 <xTaskRemoveFromEventList+0xa2>
4037b65f:	002b86        	j	4037b711 <xTaskRemoveFromEventList+0x151>
                    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
4037b662:	0020c0        	memw
4037b665:	5788      	l32i.n	a8, a7, 20
4037b667:	0020c0        	memw
4037b66a:	2798      	l32i.n	a9, a7, 8
4037b66c:	0020c0        	memw
4037b66f:	37a8      	l32i.n	a10, a7, 12
4037b671:	0020c0        	memw
4037b674:	29a9      	s32i.n	a10, a9, 8
4037b676:	0020c0        	memw
4037b679:	3798      	l32i.n	a9, a7, 12
4037b67b:	0020c0        	memw
4037b67e:	27a8      	l32i.n	a10, a7, 8
4037b680:	0020c0        	memw
4037b683:	19a9      	s32i.n	a10, a9, 4
4037b685:	0020c0        	memw
4037b688:	18a8      	l32i.n	a10, a8, 4
4037b68a:	974b      	addi.n	a9, a7, 4
4037b68c:	099a97        	bne	a10, a9, 4037b699 <xTaskRemoveFromEventList+0xd9>
4037b68f:	0020c0        	memw
4037b692:	37a8      	l32i.n	a10, a7, 12
4037b694:	0020c0        	memw
4037b697:	18a9      	s32i.n	a10, a8, 4
4037b699:	0a0c      	movi.n	a10, 0
4037b69b:	0020c0        	memw
4037b69e:	57a9      	s32i.n	a10, a7, 20
4037b6a0:	0020c0        	memw
4037b6a3:	08a8      	l32i.n	a10, a8, 0
4037b6a5:	aa0b      	addi.n	a10, a10, -1
4037b6a7:	0020c0        	memw
4037b6aa:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxUnblockedTCB );
4037b6ac:	b788      	l32i.n	a8, a7, 44
4037b6ae:	e580a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b6b1:	0020c0        	memw
4037b6b4:	0aa8      	l32i.n	a10, a10, 0
4037b6b6:	07ba87        	bgeu	a10, a8, 4037b6c1 <xTaskRemoveFromEventList+0x101>
4037b6b9:	e57da1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b6bc:	0020c0        	memw
4037b6bf:	0a89      	s32i.n	a8, a10, 0
4037b6c1:	e57ca1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037b6c4:	a08880        	addx4	a8, a8, a8
4037b6c7:	a088a0        	addx4	a8, a8, a10
4037b6ca:	0020c0        	memw
4037b6cd:	1888      	l32i.n	a8, a8, 4
4037b6cf:	0020c0        	memw
4037b6d2:	2789      	s32i.n	a8, a7, 8
4037b6d4:	0020c0        	memw
4037b6d7:	28b8      	l32i.n	a11, a8, 8
4037b6d9:	0020c0        	memw
4037b6dc:	37b9      	s32i.n	a11, a7, 12
4037b6de:	0020c0        	memw
4037b6e1:	28b8      	l32i.n	a11, a8, 8
4037b6e3:	0020c0        	memw
4037b6e6:	1b99      	s32i.n	a9, a11, 4
4037b6e8:	0020c0        	memw
4037b6eb:	2899      	s32i.n	a9, a8, 8
4037b6ed:	b788      	l32i.n	a8, a7, 44
4037b6ef:	a09880        	addx4	a9, a8, a8
4037b6f2:	a099a0        	addx4	a9, a9, a10
4037b6f5:	0020c0        	memw
4037b6f8:	5799      	s32i.n	a9, a7, 20
4037b6fa:	0020c0        	memw
4037b6fd:	0998      	l32i.n	a9, a9, 0
4037b6ff:	991b      	addi.n	a9, a9, 1
4037b701:	a08880        	addx4	a8, a8, a8
4037b704:	a088a0        	addx4	a8, a8, a10
4037b707:	0020c0        	memw
4037b70a:	0899      	s32i.n	a9, a8, 0
4037b70c:	001bc6        	j	4037b77f <xTaskRemoveFromEventList+0x1bf>
4037b70f:	820000        	mull	a0, a0, a0
                    UBaseType_t uxPendCore = ( ( pxUnblockedTCB->xCoreID == tskNO_AFFINITY ) ? xCurCoreID : pxUnblockedTCB->xCoreID );
4037b712:	911127        	beq	a1, a2, 4037b6a7 <xTaskRemoveFromEventList+0xe7>
4037b715:	e43d      	lsi	f3, a4, 16
4037b717:	021897        	beq	a8, a9, 4037b71d <xTaskRemoveFromEventList+0x15d>
4037b71a:	206880        	or	a6, a8, a8
                    configASSERT( uxSchedulerSuspended[ uxPendCore ] != ( UBaseType_t ) 0U );
4037b71d:	e55e81        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037b720:	a08680        	addx4	a8, a6, a8
4037b723:	0020c0        	memw
4037b726:	002882        	l32i	a8, a8, 0
4037b729:	00e856        	bnez	a8, 4037b73b <xTaskRemoveFromEventList+0x17b>
4037b72c:	e589d1        	l32r	a13, 40374d50 <_iram_text_start+0x94c> (3c024630 <_flash_rodata_start+0x4510>)
4037b72f:	e586c1        	l32r	a12, 40374d48 <_iram_text_start+0x944> (3c0280fc <__func__$20>)
4037b732:	e588b1        	l32r	a11, 40374d54 <_iram_text_start+0x950> (f4d <UserFrameTotalSize+0xe4d>)
4037b735:	e55da1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b738:	046165        	call8	4037fd50 <__assert_func>
                    listINSERT_END( &( xPendingReadyList[ uxPendCore ] ), &( pxUnblockedTCB->xEventListItem ) );
4037b73b:	e573a1        	l32r	a10, 40374d08 <_iram_text_start+0x904> (3fc94b74 <xPendingReadyList>)
4037b73e:	a08660        	addx4	a8, a6, a6
4037b741:	a088a0        	addx4	a8, a8, a10
4037b744:	0020c0        	memw
4037b747:	012892        	l32i	a9, a8, 4
4037b74a:	0020c0        	memw
4037b74d:	7799      	s32i.n	a9, a7, 28
4037b74f:	0020c0        	memw
4037b752:	29b8      	l32i.n	a11, a9, 8
4037b754:	0020c0        	memw
4037b757:	87b9      	s32i.n	a11, a7, 32
4037b759:	0020c0        	memw
4037b75c:	29b8      	l32i.n	a11, a9, 8
4037b75e:	0020c0        	memw
4037b761:	1b29      	s32i.n	a2, a11, 4
4037b763:	0020c0        	memw
4037b766:	2929      	s32i.n	a2, a9, 8
4037b768:	0020c0        	memw
4037b76b:	a789      	s32i.n	a8, a7, 40
4037b76d:	0020c0        	memw
4037b770:	0888      	l32i.n	a8, a8, 0
4037b772:	881b      	addi.n	a8, a8, 1
4037b774:	a06660        	addx4	a6, a6, a6
4037b777:	a066a0        	addx4	a6, a6, a10
4037b77a:	0020c0        	memw
4037b77d:	0689      	s32i.n	a8, a6, 0
                if( taskIS_YIELD_REQUIRED( pxUnblockedTCB, pdFALSE ) == pdTRUE )
4037b77f:	0c0c      	movi.n	a12, 0
4037b781:	b7b8      	l32i.n	a11, a7, 44
4037b783:	07ad      	mov.n	a10, a7
4037b785:	ff2e65        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037b788:	0a2d      	mov.n	a2, a10
4037b78a:	141a66        	bnei	a10, 1, 4037b7a2 <xTaskRemoveFromEventList+0x1e2>
                    xYieldPending[ xCurCoreID ] = pdTRUE;
4037b78d:	e56781        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037b790:	a05580        	addx4	a5, a5, a8
4037b793:	180c      	movi.n	a8, 1
4037b795:	0020c0        	memw
4037b798:	0589      	s32i.n	a8, a5, 0
4037b79a:	0001c6        	j	4037b7a5 <xTaskRemoveFromEventList+0x1e5>
                xReturn = pdFALSE;
4037b79d:	020c      	movi.n	a2, 0
4037b79f:	000086        	j	4037b7a5 <xTaskRemoveFromEventList+0x1e5>
                    xReturn = pdFALSE;
4037b7a2:	00a022        	movi	a2, 0
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b7a5:	fe9665        	call8	4037a10c <xPortInIsrContext>
4037b7a8:	008a56        	bnez	a10, 4037b7b4 <xTaskRemoveFromEventList+0x1f4>
            taskEXIT_CRITICAL( &xKernelLock );
4037b7ab:	e54aa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b7ae:	fead25        	call8	4037a280 <vPortExitCritical>
4037b7b1:	000146        	j	4037b7ba <xTaskRemoveFromEventList+0x1fa>
            taskEXIT_CRITICAL_ISR( &xKernelLock );
4037b7b4:	e548a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b7b7:	feaca5        	call8	4037a280 <vPortExitCritical>
    }
4037b7ba:	f01d      	retw.n

4037b7bc <vTaskInternalSetTimeOutState>:
{
4037b7bc:	004136        	entry	a1, 32
    pxTimeOut->xOverflowCount = xNumOfOverflows;
4037b7bf:	e55a81        	l32r	a8, 40374d28 <_iram_text_start+0x924> (3fc94b28 <xNumOfOverflows>)
4037b7c2:	0020c0        	memw
4037b7c5:	0888      	l32i.n	a8, a8, 0
4037b7c7:	0289      	s32i.n	a8, a2, 0
    pxTimeOut->xTimeOnEntering = xTickCount;
4037b7c9:	e54781        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037b7cc:	0020c0        	memw
4037b7cf:	0888      	l32i.n	a8, a8, 0
4037b7d1:	1289      	s32i.n	a8, a2, 4
}
4037b7d3:	f01d      	retw.n
4037b7d5:	000000        	ill

4037b7d8 <xTaskCheckForTimeOut>:
{
4037b7d8:	004136        	entry	a1, 32
    configASSERT( pxTimeOut );
4037b7db:	00e256        	bnez	a2, 4037b7ed <xTaskCheckForTimeOut+0x15>
4037b7de:	e55ed1        	l32r	a13, 40374d58 <_iram_text_start+0x954> (3c02466c <_flash_rodata_start+0x454c>)
4037b7e1:	e55ec1        	l32r	a12, 40374d5c <_iram_text_start+0x958> (3c0280e4 <__func__$17>)
4037b7e4:	e55fb1        	l32r	a11, 40374d60 <_iram_text_start+0x95c> (103a <UserFrameTotalSize+0xf3a>)
4037b7e7:	e531a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b7ea:	045665        	call8	4037fd50 <__assert_func>
    configASSERT( pxTicksToWait );
4037b7ed:	00e356        	bnez	a3, 4037b7ff <xTaskCheckForTimeOut+0x27>
4037b7f0:	e55dd1        	l32r	a13, 40374d64 <_iram_text_start+0x960> (3c024678 <_flash_rodata_start+0x4558>)
4037b7f3:	e55ac1        	l32r	a12, 40374d5c <_iram_text_start+0x958> (3c0280e4 <__func__$17>)
4037b7f6:	e55cb1        	l32r	a11, 40374d68 <_iram_text_start+0x964> (103b <UserFrameTotalSize+0xf3b>)
4037b7f9:	e52ca1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b7fc:	045525        	call8	4037fd50 <__assert_func>
4037b7ff:	fb7c      	movi.n	a11, -1
4037b801:	e534a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b804:	fe92a5        	call8	4037a130 <xPortEnterCriticalTimeout>
        const TickType_t xConstTickCount = xTickCount;
4037b807:	e53881        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037b80a:	0020c0        	memw
4037b80d:	0028b2        	l32i	a11, a8, 0
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
4037b810:	12a8      	l32i.n	a10, a2, 4
4037b812:	c0cba0        	sub	a12, a11, a10
4037b815:	03eb90        	rsr.prid	a9
4037b818:	049d90        	extui	a9, a9, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted != ( uint8_t ) pdFALSE )
4037b81b:	e50981        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b81e:	a08980        	addx4	a8, a9, a8
4037b821:	0020c0        	memw
4037b824:	0888      	l32i.n	a8, a8, 0
4037b826:	01d882        	addmi	a8, a8, 0x100
4037b829:	520882        	l8ui	a8, a8, 82
4037b82c:	689c      	beqz.n	a8, 4037b846 <xTaskCheckForTimeOut+0x6e>
                pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted = pdFALSE;
4037b82e:	e50481        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b831:	a09980        	addx4	a9, a9, a8
4037b834:	0020c0        	memw
4037b837:	0988      	l32i.n	a8, a9, 0
4037b839:	01d882        	addmi	a8, a8, 0x100
4037b83c:	090c      	movi.n	a9, 0
4037b83e:	524892        	s8i	a9, a8, 82
                xReturn = pdTRUE;
4037b841:	120c      	movi.n	a2, 1
4037b843:	001006        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
            if( *pxTicksToWait == portMAX_DELAY )
4037b846:	0388      	l32i.n	a8, a3, 0
4037b848:	390826        	beqi	a8, -1, 4037b885 <xTaskCheckForTimeOut+0xad>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
4037b84b:	02d8      	l32i.n	a13, a2, 0
4037b84d:	e53691        	l32r	a9, 40374d28 <_iram_text_start+0x924> (3fc94b28 <xNumOfOverflows>)
4037b850:	0020c0        	memw
4037b853:	0998      	l32i.n	a9, a9, 0
4037b855:	0b1d97        	beq	a13, a9, 4037b864 <xTaskCheckForTimeOut+0x8c>
4037b858:	083ba7        	bltu	a11, a10, 4037b864 <xTaskCheckForTimeOut+0x8c>
            *pxTicksToWait = ( TickType_t ) 0;
4037b85b:	080c      	movi.n	a8, 0
4037b85d:	0389      	s32i.n	a8, a3, 0
            xReturn = pdTRUE;
4037b85f:	120c      	movi.n	a2, 1
            *pxTicksToWait = ( TickType_t ) 0;
4037b861:	000886        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
4037b864:	14bc87        	bgeu	a12, a8, 4037b87c <xTaskCheckForTimeOut+0xa4>
            *pxTicksToWait -= xElapsedTime;
4037b867:	c0aab0        	sub	a10, a10, a11
4037b86a:	80aa80        	add	a10, a10, a8
4037b86d:	0063a2        	s32i	a10, a3, 0
            vTaskInternalSetTimeOutState( pxTimeOut );
4037b870:	20a220        	or	a10, a2, a2
4037b873:	fff4a5        	call8	4037b7bc <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
4037b876:	020c      	movi.n	a2, 0
4037b878:	0002c6        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
4037b87b:	080c00        	lsx	f0, a12, a0
            *pxTicksToWait = ( TickType_t ) 0;
4037b87e:	0389      	s32i.n	a8, a3, 0
            xReturn = pdTRUE;
4037b880:	120c      	movi.n	a2, 1
4037b882:	000046        	j	4037b887 <xTaskCheckForTimeOut+0xaf>
                xReturn = pdFALSE;
4037b885:	020c      	movi.n	a2, 0
    taskEXIT_CRITICAL( &xKernelLock );
4037b887:	e513a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b88a:	fe9f65        	call8	4037a280 <vPortExitCritical>
}
4037b88d:	f01d      	retw.n
	...

4037b890 <xTaskGetCurrentTaskHandle>:
    {
4037b890:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037b893:	0063a0        	rsil	a10, 3
4037b896:	03eb80        	rsr.prid	a8
4037b899:	048d80        	extui	a8, a8, 13, 1
            xReturn = pxCurrentTCBs[ portGET_CORE_ID() ];
4037b89c:	e4e991        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b89f:	a08890        	addx4	a8, a8, a9
4037b8a2:	0020c0        	memw
4037b8a5:	0828      	l32i.n	a2, a8, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037b8a7:	e4d181        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037b8aa:	0008e0        	callx8	a8
    }
4037b8ad:	f01d      	retw.n
	...

4037b8b0 <vTaskPrioritySet>:
    {
4037b8b0:	004136        	entry	a1, 32
        configASSERT( uxNewPriority < configMAX_PRIORITIES );
4037b8b3:	881c      	movi.n	a8, 24
4037b8b5:	0eb837        	bgeu	a8, a3, 4037b8c7 <vTaskPrioritySet+0x17>
4037b8b8:	e52dd1        	l32r	a13, 40374d6c <_iram_text_start+0x968> (3c024688 <_flash_rodata_start+0x4568>)
4037b8bb:	e52dc1        	l32r	a12, 40374d70 <_iram_text_start+0x96c> (3c0281b0 <__func__$38>)
4037b8be:	e9a6b2        	movi	a11, 0x6e9
4037b8c1:	e4faa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037b8c4:	0448a5        	call8	4037fd50 <__assert_func>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b8c7:	fb7c      	movi.n	a11, -1
4037b8c9:	e502a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037b8cc:	fe8625        	call8	4037a130 <xPortEnterCriticalTimeout>
4037b8cf:	03eb70        	rsr.prid	a7
4037b8d2:	047d70        	extui	a7, a7, 13, 1
            pxTCB = prvGetTCBFromHandle( xTask );
4037b8d5:	004256        	bnez	a2, 4037b8dd <vTaskPrioritySet+0x2d>
4037b8d8:	fffb65        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037b8db:	0a2d      	mov.n	a2, a10
                uxCurrentBasePriority = pxTCB->uxBasePriority;
4037b8dd:	132282        	l32i	a8, a2, 76
            if( uxCurrentBasePriority != uxNewPriority )
4037b8e0:	029387        	bne	a3, a8, 4037b8e6 <vTaskPrioritySet+0x36>
4037b8e3:	0045c6        	j	4037b9fe <vTaskPrioritySet+0x14e>
                if( uxNewPriority > uxCurrentBasePriority )
4037b8e6:	2ab837        	bgeu	a8, a3, 4037b914 <vTaskPrioritySet+0x64>
                    if( taskIS_CURRENTLY_RUNNING( pxTCB ) == pdFALSE )
4037b8e9:	e4d581        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b8ec:	0020c0        	memw
4037b8ef:	0888      	l32i.n	a8, a8, 0
4037b8f1:	4c1827        	beq	a8, a2, 4037b941 <vTaskPrioritySet+0x91>
4037b8f4:	e4d381        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b8f7:	0020c0        	memw
4037b8fa:	1888      	l32i.n	a8, a8, 4
4037b8fc:	461827        	beq	a8, a2, 4037b946 <vTaskPrioritySet+0x96>
                        if( taskIS_YIELD_REQUIRED_USING_PRIORITY( pxTCB, uxNewPriority, pdTRUE ) == pdTRUE )
4037b8ff:	1c0c      	movi.n	a12, 1
4037b901:	03bd      	mov.n	a11, a3
4037b903:	02ad      	mov.n	a10, a2
4037b905:	ff1665        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037b908:	0a7d      	mov.n	a7, a10
4037b90a:	471a26        	beqi	a10, 1, 4037b955 <vTaskPrioritySet+0xa5>
        BaseType_t xYieldRequired = pdFALSE;
4037b90d:	070c      	movi.n	a7, 0
4037b90f:	001086        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b912:	810000        	src	a0, a0, a0
                else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, xCurCoreID ) == pdTRUE )
4037b915:	e4cb      	addi.n	a14, a4, 12
4037b917:	a08780        	addx4	a8, a7, a8
4037b91a:	0020c0        	memw
4037b91d:	002882        	l32i	a8, a8, 0
4037b920:	281827        	beq	a8, a2, 4037b94c <vTaskPrioritySet+0x9c>
                    else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, !xCurCoreID ) == pdTRUE )
4037b923:	40f7a0        	nsau	a10, a7
4037b926:	41a5a0        	srli	a10, a10, 5
4037b929:	e4c581        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037b92c:	a08a80        	addx4	a8, a10, a8
4037b92f:	0020c0        	memw
4037b932:	002882        	l32i	a8, a8, 0
4037b935:	199827        	bne	a8, a2, 4037b952 <vTaskPrioritySet+0xa2>
                        taskYIELD_CORE( !xCurCoreID );
4037b938:	fe9e25        	call8	4037a31c <vPortYieldOtherCore>
        BaseType_t xYieldRequired = pdFALSE;
4037b93b:	00a072        	movi	a7, 0
4037b93e:	0004c6        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b941:	070c      	movi.n	a7, 0
4037b943:	000386        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b946:	070c      	movi.n	a7, 0
4037b948:	000246        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b94b:	170c00        	lsi	f0, a12, 92
                    xYieldRequired = pdTRUE;
4037b94e:	0000c6        	j	4037b955 <vTaskPrioritySet+0xa5>
4037b951:	a07200        	addx4	a7, a2, a0
        BaseType_t xYieldRequired = pdFALSE;
4037b954:	228200        	orb	b8, b2, b0
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
4037b957:	920b      	addi.n	a9, a2, -1
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
4037b959:	871322        	l16ui	a2, a3, 0x10e
4037b95c:	0299      	s32i.n	a9, a2, 0
                        pxTCB->uxPriority = uxNewPriority;
4037b95e:	0b6232        	s32i	a3, a2, 44
                    pxTCB->uxBasePriority = uxNewPriority;
4037b961:	136232        	s32i	a3, a2, 76
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037b964:	0020c0        	memw
4037b967:	062292        	l32i	a9, a2, 24
4037b96a:	00b996        	bltz	a9, 4037b979 <vTaskPrioritySet+0xc9>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037b96d:	e7c332        	addi	a3, a3, -25
4037b970:	603030        	neg	a3, a3
4037b973:	0020c0        	memw
4037b976:	066232        	s32i	a3, a2, 24
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037b979:	0020c0        	memw
4037b97c:	5298      	l32i.n	a9, a2, 20
4037b97e:	a08880        	addx4	a8, a8, a8
4037b981:	e4cca1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037b984:	a088a0        	addx4	a8, a8, a10
4037b987:	679987        	bne	a9, a8, 4037b9f2 <vTaskPrioritySet+0x142>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037b98a:	324b      	addi.n	a3, a2, 4
4037b98c:	03ad      	mov.n	a10, a3
4037b98e:	ff0065        	call8	4037a994 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
4037b991:	b288      	l32i.n	a8, a2, 44
4037b993:	e4c791        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b996:	0020c0        	memw
4037b999:	0998      	l32i.n	a9, a9, 0
4037b99b:	07b987        	bgeu	a9, a8, 4037b9a6 <vTaskPrioritySet+0xf6>
4037b99e:	e4c491        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037b9a1:	0020c0        	memw
4037b9a4:	0989      	s32i.n	a8, a9, 0
4037b9a6:	e4c3a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037b9a9:	a08880        	addx4	a8, a8, a8
4037b9ac:	a088a0        	addx4	a8, a8, a10
4037b9af:	0020c0        	memw
4037b9b2:	1888      	l32i.n	a8, a8, 4
4037b9b4:	0020c0        	memw
4037b9b7:	2289      	s32i.n	a8, a2, 8
4037b9b9:	0020c0        	memw
4037b9bc:	2898      	l32i.n	a9, a8, 8
4037b9be:	0020c0        	memw
4037b9c1:	3299      	s32i.n	a9, a2, 12
4037b9c3:	0020c0        	memw
4037b9c6:	2898      	l32i.n	a9, a8, 8
4037b9c8:	0020c0        	memw
4037b9cb:	1939      	s32i.n	a3, a9, 4
4037b9cd:	0020c0        	memw
4037b9d0:	2839      	s32i.n	a3, a8, 8
4037b9d2:	b288      	l32i.n	a8, a2, 44
4037b9d4:	a09880        	addx4	a9, a8, a8
4037b9d7:	a099a0        	addx4	a9, a9, a10
4037b9da:	0020c0        	memw
4037b9dd:	5299      	s32i.n	a9, a2, 20
4037b9df:	0020c0        	memw
4037b9e2:	0998      	l32i.n	a9, a9, 0
4037b9e4:	991b      	addi.n	a9, a9, 1
4037b9e6:	a08880        	addx4	a8, a8, a8
4037b9e9:	a088a0        	addx4	a8, a8, a10
4037b9ec:	0020c0        	memw
4037b9ef:	006892        	s32i	a9, a8, 0
                if( xYieldRequired != pdFALSE )
4037b9f2:	008716        	beqz	a7, 4037b9fe <vTaskPrioritySet+0x14e>
4037b9f5:	03eba0        	rsr.prid	a10
4037b9f8:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037b9fb:	fc6d25        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &xKernelLock );
4037b9fe:	e4b5a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037ba01:	fe87e5        	call8	4037a280 <vPortExitCritical>
    }
4037ba04:	000090        	retw
	...

4037ba08 <pcTaskGetName>:
{
4037ba08:	004136        	entry	a1, 32
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
4037ba0b:	016256        	bnez	a2, 4037ba25 <pcTaskGetName+0x1d>
4037ba0e:	ffe825        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037ba11:	0a2d      	mov.n	a2, a10
    configASSERT( pxTCB );
4037ba13:	00ea56        	bnez	a10, 4037ba25 <pcTaskGetName+0x1d>
4037ba16:	e4d7d1        	l32r	a13, 40374d74 <_iram_text_start+0x970> (3c02457c <_flash_rodata_start+0x445c>)
4037ba19:	e4d7c1        	l32r	a12, 40374d78 <_iram_text_start+0x974> (3c028164 <__func__$30>)
4037ba1c:	e4d8b1        	l32r	a11, 40374d7c <_iram_text_start+0x978> (ac4 <UserFrameTotalSize+0x9c4>)
4037ba1f:	e4a3a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037ba22:	0432e5        	call8	4037fd50 <__assert_func>
}
4037ba25:	34c222        	addi	a2, a2, 52
4037ba28:	f01d      	retw.n
	...

4037ba2c <xTaskGetSchedulerState>:
    {
4037ba2c:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037ba2f:	0063a0        	rsil	a10, 3
            if( xSchedulerRunning == pdFALSE )
4037ba32:	e4b681        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94b38 <xSchedulerRunning>)
4037ba35:	0020c0        	memw
4037ba38:	0888      	l32i.n	a8, a8, 0
4037ba3a:	689c      	beqz.n	a8, 4037ba54 <xTaskGetSchedulerState+0x28>
4037ba3c:	03eb80        	rsr.prid	a8
4037ba3f:	048d80        	extui	a8, a8, 13, 1
                if( uxSchedulerSuspended[ portGET_CORE_ID() ] == ( UBaseType_t ) pdFALSE )
4037ba42:	e49591        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037ba45:	a08890        	addx4	a8, a8, a9
4037ba48:	0020c0        	memw
4037ba4b:	0888      	l32i.n	a8, a8, 0
4037ba4d:	88cc      	bnez.n	a8, 4037ba59 <xTaskGetSchedulerState+0x2d>
                    xReturn = taskSCHEDULER_RUNNING;
4037ba4f:	220c      	movi.n	a2, 2
4037ba51:	000186        	j	4037ba5b <xTaskGetSchedulerState+0x2f>
                xReturn = taskSCHEDULER_NOT_STARTED;
4037ba54:	120c      	movi.n	a2, 1
4037ba56:	000046        	j	4037ba5b <xTaskGetSchedulerState+0x2f>
                    xReturn = taskSCHEDULER_SUSPENDED;
4037ba59:	020c      	movi.n	a2, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037ba5b:	e46481        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (40001c38 <_xtos_set_intlevel>)
4037ba5e:	0008e0        	callx8	a8
    }
4037ba61:	f01d      	retw.n
	...

4037ba64 <vTaskDelete>:
    {
4037ba64:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037ba67:	ffafb2        	movi	a11, -1
4037ba6a:	e49aa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037ba6d:	fe6c25        	call8	4037a130 <xPortEnterCriticalTimeout>
4037ba70:	03eb70        	rsr.prid	a7
4037ba73:	047d70        	extui	a7, a7, 13, 1
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
4037ba76:	004256        	bnez	a2, 4037ba7e <vTaskDelete+0x1a>
4037ba79:	ffe165        	call8	4037b890 <xTaskGetCurrentTaskHandle>
4037ba7c:	0a2d      	mov.n	a2, a10
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037ba7e:	04c262        	addi	a6, a2, 4
4037ba81:	20a660        	or	a10, a6, a6
4037ba84:	fef0e5        	call8	4037a994 <uxListRemove>
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037ba87:	0020c0        	memw
4037ba8a:	a288      	l32i.n	a8, a2, 40
4037ba8c:	488c      	beqz.n	a8, 4037ba94 <vTaskDelete+0x30>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
4037ba8e:	18c2a2        	addi	a10, a2, 24
4037ba91:	fef025        	call8	4037a994 <uxListRemove>
            uxTaskNumber++;
4037ba94:	e49f91        	l32r	a9, 40374d10 <_iram_text_start+0x90c> (3fc94b24 <uxTaskNumber>)
4037ba97:	002982        	l32i	a8, a9, 0
4037ba9a:	01c882        	addi	a8, a8, 1
4037ba9d:	006982        	s32i	a8, a9, 0
            if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, xCurCoreID ) == pdTRUE )
4037baa0:	e46881        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037baa3:	a08780        	addx4	a8, a7, a8
4037baa6:	0020c0        	memw
4037baa9:	0888      	l32i.n	a8, a8, 0
4037baab:	2d1827        	beq	a8, a2, 4037badc <vTaskDelete+0x78>
                else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, !xCurCoreID ) == pdTRUE )
4037baae:	40f780        	nsau	a8, a7
4037bab1:	418580        	srli	a8, a8, 5
4037bab4:	e46391        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037bab7:	a08890        	addx4	a8, a8, a9
4037baba:	0020c0        	memw
4037babd:	0888      	l32i.n	a8, a8, 0
4037babf:	1f1827        	beq	a8, a2, 4037bae2 <vTaskDelete+0x7e>
                --uxCurrentNumberOfTasks;
4037bac2:	e48691        	l32r	a9, 40374cdc <_iram_text_start+0x8d8> (3fc94b44 <uxCurrentNumberOfTasks>)
4037bac5:	0020c0        	memw
4037bac8:	0988      	l32i.n	a8, a9, 0
4037baca:	880b      	addi.n	a8, a8, -1
4037bacc:	0020c0        	memw
4037bacf:	0989      	s32i.n	a8, a9, 0
                prvResetNextTaskUnblockTime();
4037bad1:	fef5e5        	call8	4037aa30 <prvResetNextTaskUnblockTime>
                xIsCurRunning = pdFALSE;
4037bad4:	070c      	movi.n	a7, 0
                xSelfDelete = pdFALSE;
4037bad6:	075d      	mov.n	a5, a7
4037bad8:	000d06        	j	4037bb10 <vTaskDelete+0xac>
4037badb:	150c00        	extui	a0, a0, 28, 2
                xSelfDelete = pdTRUE;
4037bade:	0000c6        	j	4037bae5 <vTaskDelete+0x81>
4037bae1:	a05200        	addx4	a5, a2, a0
                    xSelfDelete = pdFALSE;
4037bae4:	b66000        	lsi	f0, a0, 0x2d8
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
4037bae7:	7ca120        	lsi	f2, a1, 0x1f0
4037baea:	e125e4        	lsi	f14, a5, 0x384
4037baed:	fe          	.byte	0xfe
                ++uxDeletedTasksWaitingCleanUp;
4037baee:	e47c91        	l32r	a9, 40374ce0 <_iram_text_start+0x8dc> (3fc94b5c <uxDeletedTasksWaitingCleanUp>)
4037baf1:	0020c0        	memw
4037baf4:	002982        	l32i	a8, a9, 0
4037baf7:	881b      	addi.n	a8, a8, 1
4037baf9:	0020c0        	memw
4037bafc:	0989      	s32i.n	a8, a9, 0
                    if( xSelfDelete == pdFALSE )
4037bafe:	c5cc      	bnez.n	a5, 4037bb0e <vTaskDelete+0xaa>
                        taskYIELD_CORE( !xCurCoreID );
4037bb00:	40f7a0        	nsau	a10, a7
4037bb03:	41a5a0        	srli	a10, a10, 5
4037bb06:	fe8165        	call8	4037a31c <vPortYieldOtherCore>
4037bb09:	170c      	movi.n	a7, 1
4037bb0b:	000046        	j	4037bb10 <vTaskDelete+0xac>
4037bb0e:	057d      	mov.n	a7, a5
        taskEXIT_CRITICAL( &xKernelLock );
4037bb10:	e471a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bb13:	fe76e5        	call8	4037a280 <vPortExitCritical>
        if( xIsCurRunning == pdFALSE )
4037bb16:	37cc      	bnez.n	a7, 4037bb1d <vTaskDelete+0xb9>
            prvDeleteTCB( pxTCB );
4037bb18:	02ad      	mov.n	a10, a2
4037bb1a:	ff1d65        	call8	4037acf0 <prvDeleteTCB>
4037bb1d:	fb7c      	movi.n	a11, -1
4037bb1f:	e46da1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bb22:	fe60e5        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( xSchedulerRunning != pdFALSE )
4037bb25:	e47981        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94b38 <xSchedulerRunning>)
4037bb28:	0020c0        	memw
4037bb2b:	002882        	l32i	a8, a8, 0
4037bb2e:	e89c      	beqz.n	a8, 4037bb50 <vTaskDelete+0xec>
                if( xSelfDelete == pdTRUE )
4037bb30:	1c1566        	bnei	a5, 1, 4037bb50 <vTaskDelete+0xec>
                    configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdFALSE );
4037bb33:	ffefa5        	call8	4037ba2c <xTaskGetSchedulerState>
4037bb36:	dacc      	bnez.n	a10, 4037bb47 <vTaskDelete+0xe3>
4037bb38:	e492d1        	l32r	a13, 40374d80 <_iram_text_start+0x97c> (3c0246a0 <_flash_rodata_start+0x4580>)
4037bb3b:	e492c1        	l32r	a12, 40374d84 <_iram_text_start+0x980> (3c0281e0 <__func__$43>)
4037bb3e:	aba5b2        	movi	a11, 0x5ab
4037bb41:	e45aa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bb44:	0420a5        	call8	4037fd50 <__assert_func>
4037bb47:	03eba0        	rsr.prid	a10
4037bb4a:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037bb4d:	fc57e5        	call8	403780cc <esp_crosscore_int_send_yield>
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bb50:	e461a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bb53:	fe72e5        	call8	4037a280 <vPortExitCritical>
    }
4037bb56:	f01d      	retw.n

4037bb58 <vTaskDelay>:
    {
4037bb58:	004136        	entry	a1, 32
        if( xTicksToDelay > ( TickType_t ) 0U )
4037bb5b:	92ac      	beqz.n	a2, 4037bb88 <vTaskDelay+0x30>
            configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdFALSE );
4037bb5d:	ffece5        	call8	4037ba2c <xTaskGetSchedulerState>
4037bb60:	00ea56        	bnez	a10, 4037bb72 <vTaskDelay+0x1a>
4037bb63:	e487d1        	l32r	a13, 40374d80 <_iram_text_start+0x97c> (3c0246a0 <_flash_rodata_start+0x4580>)
4037bb66:	e488c1        	l32r	a12, 40374d88 <_iram_text_start+0x984> (3c0281c4 <__func__$40>)
4037bb69:	1ba6b2        	movi	a11, 0x61b
4037bb6c:	e450a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bb6f:	041e25        	call8	4037fd50 <__assert_func>
4037bb72:	fb7c      	movi.n	a11, -1
4037bb74:	e458a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bb77:	fe5ba5        	call8	4037a130 <xPortEnterCriticalTimeout>
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
4037bb7a:	0b0c      	movi.n	a11, 0
4037bb7c:	20a220        	or	a10, a2, a2
4037bb7f:	ff2525        	call8	4037add0 <prvAddCurrentTaskToDelayedList>
            xAlreadyYielded = prvEXIT_CRITICAL_OR_RESUME_ALL( &xKernelLock );
4037bb82:	e454a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bb85:	fe6fa5        	call8	4037a280 <vPortExitCritical>
4037bb88:	03eba0        	rsr.prid	a10
4037bb8b:	04ada0        	extui	a10, a10, 13, 1
            portYIELD_WITHIN_API();
4037bb8e:	fc53e5        	call8	403780cc <esp_crosscore_int_send_yield>
    }
4037bb91:	f01d      	retw.n
	...

4037bb94 <xTaskResumeAll>:
{
4037bb94:	004136        	entry	a1, 32
    configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdTRUE );
4037bb97:	ffe965        	call8	4037ba2c <xTaskGetSchedulerState>
4037bb9a:	00ea16        	beqz	a10, 4037bbac <xTaskResumeAll+0x18>
4037bb9d:	e47bd1        	l32r	a13, 40374d8c <_iram_text_start+0x988> (3c024720 <_flash_rodata_start+0x4600>)
4037bba0:	e47cc1        	l32r	a12, 40374d90 <_iram_text_start+0x98c> (3c028174 <__func__$31>)
4037bba3:	e47cb1        	l32r	a11, 40374d94 <_iram_text_start+0x990> (a0d <UserFrameTotalSize+0x90d>)
4037bba6:	e441a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bba9:	041a65        	call8	4037fd50 <__assert_func>
4037bbac:	fb7c      	movi.n	a11, -1
4037bbae:	e449a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bbb1:	fe57e5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037bbb4:	03eb60        	rsr.prid	a6
4037bbb7:	046d60        	extui	a6, a6, 13, 1
4037bbba:	065d      	mov.n	a5, a6
        --uxSchedulerSuspended[ xCurCoreID ];
4037bbbc:	e43781        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037bbbf:	a08680        	addx4	a8, a6, a8
4037bbc2:	0020c0        	memw
4037bbc5:	0898      	l32i.n	a9, a8, 0
4037bbc7:	990b      	addi.n	a9, a9, -1
4037bbc9:	0020c0        	memw
4037bbcc:	0899      	s32i.n	a9, a8, 0
        if( uxSchedulerSuspended[ xCurCoreID ] == ( UBaseType_t ) pdFALSE )
4037bbce:	0020c0        	memw
4037bbd1:	0888      	l32i.n	a8, a8, 0
4037bbd3:	1a3856        	bnez	a8, 4037bd7a <xTaskResumeAll+0x1e6>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
4037bbd6:	e44181        	l32r	a8, 40374cdc <_iram_text_start+0x8d8> (3fc94b44 <uxCurrentNumberOfTasks>)
4037bbd9:	0020c0        	memw
4037bbdc:	0888      	l32i.n	a8, a8, 0
4037bbde:	12c856        	bnez	a8, 4037bd0e <xTaskResumeAll+0x17a>
    BaseType_t xAlreadyYielded = pdFALSE;
4037bbe1:	020c      	movi.n	a2, 0
4037bbe3:	006546        	j	4037bd7c <xTaskResumeAll+0x1e8>
4037bbe6:	600000        	neg	a0, a0
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList[ xCurCoreID ] ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037bbe9:	91a086        	j	4036026f <rom_rx_gain_force+0x359e43>
4037bbec:	90e447        	bbsi	a4, 4, 4037bb80 <vTaskDelay+0x28>
4037bbef:	a088      	l32i.n	a8, a0, 40
4037bbf1:	0020c0        	memw
4037bbf4:	3888      	l32i.n	a8, a8, 12
4037bbf6:	3878      	l32i.n	a7, a8, 12
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
4037bbf8:	0020c0        	memw
4037bbfb:	a788      	l32i.n	a8, a7, 40
4037bbfd:	0020c0        	memw
4037bc00:	7798      	l32i.n	a9, a7, 28
4037bc02:	0020c0        	memw
4037bc05:	87a8      	l32i.n	a10, a7, 32
4037bc07:	0020c0        	memw
4037bc0a:	29a9      	s32i.n	a10, a9, 8
4037bc0c:	0020c0        	memw
4037bc0f:	8798      	l32i.n	a9, a7, 32
4037bc11:	0020c0        	memw
4037bc14:	77a8      	l32i.n	a10, a7, 28
4037bc16:	0020c0        	memw
4037bc19:	19a9      	s32i.n	a10, a9, 4
4037bc1b:	0020c0        	memw
4037bc1e:	18a8      	l32i.n	a10, a8, 4
4037bc20:	18c792        	addi	a9, a7, 24
4037bc23:	099a97        	bne	a10, a9, 4037bc30 <xTaskResumeAll+0x9c>
4037bc26:	0020c0        	memw
4037bc29:	8798      	l32i.n	a9, a7, 32
4037bc2b:	0020c0        	memw
4037bc2e:	1899      	s32i.n	a9, a8, 4
4037bc30:	090c      	movi.n	a9, 0
4037bc32:	0020c0        	memw
4037bc35:	a799      	s32i.n	a9, a7, 40
4037bc37:	0020c0        	memw
4037bc3a:	0898      	l32i.n	a9, a8, 0
4037bc3c:	990b      	addi.n	a9, a9, -1
4037bc3e:	0020c0        	memw
4037bc41:	0899      	s32i.n	a9, a8, 0
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037bc43:	0020c0        	memw
4037bc46:	5788      	l32i.n	a8, a7, 20
4037bc48:	0020c0        	memw
4037bc4b:	2798      	l32i.n	a9, a7, 8
4037bc4d:	0020c0        	memw
4037bc50:	37a8      	l32i.n	a10, a7, 12
4037bc52:	0020c0        	memw
4037bc55:	29a9      	s32i.n	a10, a9, 8
4037bc57:	0020c0        	memw
4037bc5a:	3798      	l32i.n	a9, a7, 12
4037bc5c:	0020c0        	memw
4037bc5f:	27a8      	l32i.n	a10, a7, 8
4037bc61:	0020c0        	memw
4037bc64:	19a9      	s32i.n	a10, a9, 4
4037bc66:	0020c0        	memw
4037bc69:	18a8      	l32i.n	a10, a8, 4
4037bc6b:	974b      	addi.n	a9, a7, 4
4037bc6d:	099a97        	bne	a10, a9, 4037bc7a <xTaskResumeAll+0xe6>
4037bc70:	0020c0        	memw
4037bc73:	37a8      	l32i.n	a10, a7, 12
4037bc75:	0020c0        	memw
4037bc78:	18a9      	s32i.n	a10, a8, 4
4037bc7a:	0a0c      	movi.n	a10, 0
4037bc7c:	0020c0        	memw
4037bc7f:	57a9      	s32i.n	a10, a7, 20
4037bc81:	0020c0        	memw
4037bc84:	08a8      	l32i.n	a10, a8, 0
4037bc86:	aa0b      	addi.n	a10, a10, -1
4037bc88:	0020c0        	memw
4037bc8b:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxTCB );
4037bc8d:	b788      	l32i.n	a8, a7, 44
4037bc8f:	e408a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037bc92:	0020c0        	memw
4037bc95:	0aa8      	l32i.n	a10, a10, 0
4037bc97:	08ba87        	bgeu	a10, a8, 4037bca3 <xTaskResumeAll+0x10f>
4037bc9a:	e405a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037bc9d:	0020c0        	memw
4037bca0:	006a82        	s32i	a8, a10, 0
4037bca3:	e404a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037bca6:	a08880        	addx4	a8, a8, a8
4037bca9:	a088a0        	addx4	a8, a8, a10
4037bcac:	0020c0        	memw
4037bcaf:	1888      	l32i.n	a8, a8, 4
4037bcb1:	0020c0        	memw
4037bcb4:	2789      	s32i.n	a8, a7, 8
4037bcb6:	0020c0        	memw
4037bcb9:	28b8      	l32i.n	a11, a8, 8
4037bcbb:	0020c0        	memw
4037bcbe:	37b9      	s32i.n	a11, a7, 12
4037bcc0:	0020c0        	memw
4037bcc3:	28b8      	l32i.n	a11, a8, 8
4037bcc5:	0020c0        	memw
4037bcc8:	1b99      	s32i.n	a9, a11, 4
4037bcca:	0020c0        	memw
4037bccd:	2899      	s32i.n	a9, a8, 8
4037bccf:	b788      	l32i.n	a8, a7, 44
4037bcd1:	a09880        	addx4	a9, a8, a8
4037bcd4:	a099a0        	addx4	a9, a9, a10
4037bcd7:	0020c0        	memw
4037bcda:	5799      	s32i.n	a9, a7, 20
4037bcdc:	0020c0        	memw
4037bcdf:	0998      	l32i.n	a9, a9, 0
4037bce1:	991b      	addi.n	a9, a9, 1
4037bce3:	a08880        	addx4	a8, a8, a8
4037bce6:	a088a0        	addx4	a8, a8, a10
4037bce9:	0020c0        	memw
4037bcec:	0899      	s32i.n	a9, a8, 0
                    if( taskIS_YIELD_REQUIRED( pxTCB, pdTRUE ) == pdTRUE )
4037bcee:	1c0c      	movi.n	a12, 1
4037bcf0:	b7b8      	l32i.n	a11, a7, 44
4037bcf2:	20a770        	or	a10, a7, a7
4037bcf5:	fed765        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037bcf8:	151a66        	bnei	a10, 1, 4037bd11 <xTaskResumeAll+0x17d>
                        xYieldPending[ xCurCoreID ] = pdTRUE;
4037bcfb:	e40c81        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037bcfe:	a08680        	addx4	a8, a6, a8
4037bd01:	190c      	movi.n	a9, 1
4037bd03:	0020c0        	memw
4037bd06:	0899      	s32i.n	a9, a8, 0
4037bd08:	000146        	j	4037bd11 <xTaskResumeAll+0x17d>
4037bd0b:	000000        	ill
    TCB_t * pxTCB = NULL;
4037bd0e:	00a072        	movi	a7, 0
                while( listLIST_IS_EMPTY( &xPendingReadyList[ xCurCoreID ] ) == pdFALSE )
4037bd11:	a08660        	addx4	a8, a6, a6
4037bd14:	e3fd91        	l32r	a9, 40374d08 <_iram_text_start+0x904> (3fc94b74 <xPendingReadyList>)
4037bd17:	a08890        	addx4	a8, a8, a9
4037bd1a:	0020c0        	memw
4037bd1d:	002882        	l32i	a8, a8, 0
4037bd20:	ec4856        	bnez	a8, 4037bbe8 <xTaskResumeAll+0x54>
                if( pxTCB != NULL )
4037bd23:	002716        	beqz	a7, 4037bd29 <xTaskResumeAll+0x195>
                    prvResetNextTaskUnblockTime();
4037bd26:	fed0a5        	call8	4037aa30 <prvResetNextTaskUnblockTime>
                    if( xCurCoreID == 0 )
4037bd29:	f5ec      	bnez.n	a5, 4037bd5c <xTaskResumeAll+0x1c8>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
4037bd2b:	e40181        	l32r	a8, 40374d30 <_iram_text_start+0x92c> (3fc94b34 <xPendedTicks>)
4037bd2e:	0020c0        	memw
4037bd31:	0878      	l32i.n	a7, a8, 0
                    if( xPendedCounts > ( TickType_t ) 0U )
4037bd33:	57ac      	beqz.n	a7, 4037bd5c <xTaskResumeAll+0x1c8>
                            if( xTaskIncrementTick() != pdFALSE )
4037bd35:	ff4d25        	call8	4037b208 <xTaskIncrementTick>
4037bd38:	00ea16        	beqz	a10, 4037bd4a <xTaskResumeAll+0x1b6>
                                xYieldPending[ xCurCoreID ] = pdTRUE;
4037bd3b:	e3fc81        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037bd3e:	a08680        	addx4	a8, a6, a8
4037bd41:	01a092        	movi	a9, 1
4037bd44:	0020c0        	memw
4037bd47:	006892        	s32i	a9, a8, 0
                            --xPendedCounts;
4037bd4a:	ffc772        	addi	a7, a7, -1
                        } while( xPendedCounts > ( TickType_t ) 0U );
4037bd4d:	fe4756        	bnez	a7, 4037bd35 <xTaskResumeAll+0x1a1>
                        xPendedTicks = 0;
4037bd50:	e3f881        	l32r	a8, 40374d30 <_iram_text_start+0x92c> (3fc94b34 <xPendedTicks>)
4037bd53:	00a092        	movi	a9, 0
4037bd56:	0020c0        	memw
4037bd59:	006892        	s32i	a9, a8, 0
                if( xYieldPending[ xCurCoreID ] != pdFALSE )
4037bd5c:	e3f481        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037bd5f:	a06680        	addx4	a6, a6, a8
4037bd62:	0020c0        	memw
4037bd65:	0628      	l32i.n	a2, a6, 0
4037bd67:	129c      	beqz.n	a2, 4037bd7c <xTaskResumeAll+0x1e8>
4037bd69:	03eba0        	rsr.prid	a10
4037bd6c:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037bd6f:	fc35e5        	call8	403780cc <esp_crosscore_int_send_yield>
                        xAlreadyYielded = pdTRUE;
4037bd72:	120c      	movi.n	a2, 1
4037bd74:	000106        	j	4037bd7c <xTaskResumeAll+0x1e8>
4037bd77:	000000        	ill
    BaseType_t xAlreadyYielded = pdFALSE;
4037bd7a:	020c      	movi.n	a2, 0
    taskEXIT_CRITICAL( &xKernelLock );
4037bd7c:	e3d6a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bd7f:	fe5025        	call8	4037a280 <vPortExitCritical>
}
4037bd82:	f01d      	retw.n

4037bd84 <xTaskPriorityInherit>:
    {
4037bd84:	004136        	entry	a1, 32
4037bd87:	fb7c      	movi.n	a11, -1
4037bd89:	e3d2a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bd8c:	fe3a25        	call8	4037a130 <xPortEnterCriticalTimeout>
4037bd8f:	03eb70        	rsr.prid	a7
4037bd92:	047d70        	extui	a7, a7, 13, 1
            if( pxMutexHolder != NULL )
4037bd95:	0eb216        	beqz	a2, 4037be84 <xTaskPriorityInherit+0x100>
                if( pxMutexHolderTCB->uxPriority < pxCurrentTCBs[ xCurCoreID ]->uxPriority )
4037bd98:	b288      	l32i.n	a8, a2, 44
4037bd9a:	e3a991        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037bd9d:	a09790        	addx4	a9, a7, a9
4037bda0:	0020c0        	memw
4037bda3:	0998      	l32i.n	a9, a9, 0
4037bda5:	b998      	l32i.n	a9, a9, 44
4037bda7:	023897        	bltu	a8, a9, 4037bdad <xTaskPriorityInherit+0x29>
4037bdaa:	002f86        	j	4037be6c <xTaskPriorityInherit+0xe8>
                    if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bdad:	0020c0        	memw
4037bdb0:	6298      	l32i.n	a9, a2, 24
4037bdb2:	017996        	bltz	a9, 4037bdcd <xTaskPriorityInherit+0x49>
                        listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCBs[ xCurCoreID ]->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bdb5:	e3a291        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037bdb8:	a09790        	addx4	a9, a7, a9
4037bdbb:	0020c0        	memw
4037bdbe:	0998      	l32i.n	a9, a9, 0
4037bdc0:	b998      	l32i.n	a9, a9, 44
4037bdc2:	e7c992        	addi	a9, a9, -25
4037bdc5:	609090        	neg	a9, a9
4037bdc8:	0020c0        	memw
4037bdcb:	6299      	s32i.n	a9, a2, 24
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
4037bdcd:	0020c0        	memw
4037bdd0:	5298      	l32i.n	a9, a2, 20
4037bdd2:	a08880        	addx4	a8, a8, a8
4037bdd5:	e3b7a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037bdd8:	a088a0        	addx4	a8, a8, a10
4037bddb:	799987        	bne	a9, a8, 4037be58 <xTaskPriorityInherit+0xd4>
                        if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bdde:	624b      	addi.n	a6, a2, 4
4037bde0:	06ad      	mov.n	a10, a6
4037bde2:	febb25        	call8	4037a994 <uxListRemove>
                        pxMutexHolderTCB->uxPriority = pxCurrentTCBs[ xCurCoreID ]->uxPriority;
4037bde5:	e39681        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037bde8:	a08780        	addx4	a8, a7, a8
4037bdeb:	0020c0        	memw
4037bdee:	0888      	l32i.n	a8, a8, 0
4037bdf0:	b888      	l32i.n	a8, a8, 44
4037bdf2:	b289      	s32i.n	a8, a2, 44
                        prvAddTaskToReadyList( pxMutexHolderTCB );
4037bdf4:	e3af91        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037bdf7:	0020c0        	memw
4037bdfa:	0998      	l32i.n	a9, a9, 0
4037bdfc:	08b987        	bgeu	a9, a8, 4037be08 <xTaskPriorityInherit+0x84>
4037bdff:	e3ac91        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037be02:	0020c0        	memw
4037be05:	006982        	s32i	a8, a9, 0
4037be08:	e3aba1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037be0b:	a08880        	addx4	a8, a8, a8
4037be0e:	a088a0        	addx4	a8, a8, a10
4037be11:	0020c0        	memw
4037be14:	1888      	l32i.n	a8, a8, 4
4037be16:	0020c0        	memw
4037be19:	2289      	s32i.n	a8, a2, 8
4037be1b:	0020c0        	memw
4037be1e:	2898      	l32i.n	a9, a8, 8
4037be20:	0020c0        	memw
4037be23:	3299      	s32i.n	a9, a2, 12
4037be25:	0020c0        	memw
4037be28:	2898      	l32i.n	a9, a8, 8
4037be2a:	0020c0        	memw
4037be2d:	1969      	s32i.n	a6, a9, 4
4037be2f:	0020c0        	memw
4037be32:	2869      	s32i.n	a6, a8, 8
4037be34:	b288      	l32i.n	a8, a2, 44
4037be36:	a09880        	addx4	a9, a8, a8
4037be39:	a099a0        	addx4	a9, a9, a10
4037be3c:	0020c0        	memw
4037be3f:	5299      	s32i.n	a9, a2, 20
4037be41:	0020c0        	memw
4037be44:	0998      	l32i.n	a9, a9, 0
4037be46:	991b      	addi.n	a9, a9, 1
4037be48:	a08880        	addx4	a8, a8, a8
4037be4b:	a088a0        	addx4	a8, a8, a10
4037be4e:	0020c0        	memw
4037be51:	0899      	s32i.n	a9, a8, 0
                    xReturn = pdTRUE;
4037be53:	120c      	movi.n	a2, 1
4037be55:	000c86        	j	4037be8b <xTaskPriorityInherit+0x107>
                        pxMutexHolderTCB->uxPriority = pxCurrentTCBs[ xCurCoreID ]->uxPriority;
4037be58:	e37a81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037be5b:	a08780        	addx4	a8, a7, a8
4037be5e:	0020c0        	memw
4037be61:	0888      	l32i.n	a8, a8, 0
4037be63:	b888      	l32i.n	a8, a8, 44
4037be65:	b289      	s32i.n	a8, a2, 44
                    xReturn = pdTRUE;
4037be67:	120c      	movi.n	a2, 1
4037be69:	000786        	j	4037be8b <xTaskPriorityInherit+0x107>
                    if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCBs[ xCurCoreID ]->uxPriority )
4037be6c:	132292        	l32i	a9, a2, 76
4037be6f:	e37481        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037be72:	a07780        	addx4	a7, a7, a8
4037be75:	0020c0        	memw
4037be78:	0788      	l32i.n	a8, a7, 0
4037be7a:	b888      	l32i.n	a8, a8, 44
4037be7c:	093987        	bltu	a9, a8, 4037be89 <xTaskPriorityInherit+0x105>
        BaseType_t xReturn = pdFALSE;
4037be7f:	020c      	movi.n	a2, 0
4037be81:	000186        	j	4037be8b <xTaskPriorityInherit+0x107>
4037be84:	020c      	movi.n	a2, 0
4037be86:	000046        	j	4037be8b <xTaskPriorityInherit+0x107>
                        xReturn = pdTRUE;
4037be89:	120c      	movi.n	a2, 1
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037be8b:	e392a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037be8e:	fe3f25        	call8	4037a280 <vPortExitCritical>
    }
4037be91:	f01d      	retw.n
	...

4037be94 <xTaskPriorityDisinherit>:
    {
4037be94:	004136        	entry	a1, 32
4037be97:	fb7c      	movi.n	a11, -1
4037be99:	e38ea1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037be9c:	fe2925        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pxMutexHolder != NULL )
4037be9f:	0c5216        	beqz	a2, 4037bf68 <xTaskPriorityDisinherit+0xd4>
4037bea2:	03eb80        	rsr.prid	a8
4037bea5:	048d80        	extui	a8, a8, 13, 1
                configASSERT( pxTCB == pxCurrentTCBs[ portGET_CORE_ID() ] );
4037bea8:	e36691        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037beab:	a08890        	addx4	a8, a8, a9
4037beae:	0020c0        	memw
4037beb1:	0888      	l32i.n	a8, a8, 0
4037beb3:	0e1827        	beq	a8, a2, 4037bec5 <xTaskPriorityDisinherit+0x31>
4037beb6:	e3b8d1        	l32r	a13, 40374d98 <_iram_text_start+0x994> (3c0247a0 <_flash_rodata_start+0x4680>)
4037beb9:	e3b8c1        	l32r	a12, 40374d9c <_iram_text_start+0x998> (3c0280cc <__func__$15>)
4037bebc:	e3b9b1        	l32r	a11, 40374da0 <_iram_text_start+0x99c> (1412 <UserFrameTotalSize+0x1312>)
4037bebf:	e37ba1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bec2:	03e8e5        	call8	4037fd50 <__assert_func>
                configASSERT( pxTCB->uxMutexesHeld );
4037bec5:	142282        	l32i	a8, a2, 80
4037bec8:	00e856        	bnez	a8, 4037beda <xTaskPriorityDisinherit+0x46>
4037becb:	e3b6d1        	l32r	a13, 40374da4 <_iram_text_start+0x9a0> (3c0247cc <_flash_rodata_start+0x46ac>)
4037bece:	e3b3c1        	l32r	a12, 40374d9c <_iram_text_start+0x998> (3c0280cc <__func__$15>)
4037bed1:	e3b5b1        	l32r	a11, 40374da8 <_iram_text_start+0x9a4> (1413 <UserFrameTotalSize+0x1313>)
4037bed4:	e376a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bed7:	03e7a5        	call8	4037fd50 <__assert_func>
                ( pxTCB->uxMutexesHeld )--;
4037beda:	880b      	addi.n	a8, a8, -1
4037bedc:	146282        	s32i	a8, a2, 80
                if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4037bedf:	b2a8      	l32i.n	a10, a2, 44
4037bee1:	132292        	l32i	a9, a2, 76
4037bee4:	029a97        	bne	a10, a9, 4037beea <xTaskPriorityDisinherit+0x56>
4037bee7:	002086        	j	4037bf6d <xTaskPriorityDisinherit+0xd9>
                    if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4037beea:	084856        	bnez	a8, 4037bf72 <xTaskPriorityDisinherit+0xde>
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037beed:	04c272        	addi	a7, a2, 4
4037bef0:	07ad      	mov.n	a10, a7
4037bef2:	feaa25        	call8	4037a994 <uxListRemove>
                        pxTCB->uxPriority = pxTCB->uxBasePriority;
4037bef5:	132282        	l32i	a8, a2, 76
4037bef8:	b289      	s32i.n	a8, a2, 44
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037befa:	e7c892        	addi	a9, a8, -25
4037befd:	609090        	neg	a9, a9
4037bf00:	0020c0        	memw
4037bf03:	6299      	s32i.n	a9, a2, 24
                        prvAddTaskToReadyList( pxTCB );
4037bf05:	e36a91        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037bf08:	0020c0        	memw
4037bf0b:	0998      	l32i.n	a9, a9, 0
4037bf0d:	07b987        	bgeu	a9, a8, 4037bf18 <xTaskPriorityDisinherit+0x84>
4037bf10:	e36891        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037bf13:	0020c0        	memw
4037bf16:	0989      	s32i.n	a8, a9, 0
4037bf18:	e367a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037bf1b:	a08880        	addx4	a8, a8, a8
4037bf1e:	a088a0        	addx4	a8, a8, a10
4037bf21:	0020c0        	memw
4037bf24:	1888      	l32i.n	a8, a8, 4
4037bf26:	0020c0        	memw
4037bf29:	2289      	s32i.n	a8, a2, 8
4037bf2b:	0020c0        	memw
4037bf2e:	2898      	l32i.n	a9, a8, 8
4037bf30:	0020c0        	memw
4037bf33:	3299      	s32i.n	a9, a2, 12
4037bf35:	0020c0        	memw
4037bf38:	2898      	l32i.n	a9, a8, 8
4037bf3a:	0020c0        	memw
4037bf3d:	1979      	s32i.n	a7, a9, 4
4037bf3f:	0020c0        	memw
4037bf42:	2879      	s32i.n	a7, a8, 8
4037bf44:	b288      	l32i.n	a8, a2, 44
4037bf46:	a09880        	addx4	a9, a8, a8
4037bf49:	a099a0        	addx4	a9, a9, a10
4037bf4c:	0020c0        	memw
4037bf4f:	5299      	s32i.n	a9, a2, 20
4037bf51:	0020c0        	memw
4037bf54:	0998      	l32i.n	a9, a9, 0
4037bf56:	991b      	addi.n	a9, a9, 1
4037bf58:	a08880        	addx4	a8, a8, a8
4037bf5b:	a088a0        	addx4	a8, a8, a10
4037bf5e:	0020c0        	memw
4037bf61:	0899      	s32i.n	a9, a8, 0
                        xReturn = pdTRUE;
4037bf63:	120c      	movi.n	a2, 1
4037bf65:	0002c6        	j	4037bf74 <xTaskPriorityDisinherit+0xe0>
        BaseType_t xReturn = pdFALSE;
4037bf68:	020c      	movi.n	a2, 0
4037bf6a:	000186        	j	4037bf74 <xTaskPriorityDisinherit+0xe0>
4037bf6d:	020c      	movi.n	a2, 0
4037bf6f:	000046        	j	4037bf74 <xTaskPriorityDisinherit+0xe0>
4037bf72:	020c      	movi.n	a2, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bf74:	e358a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bf77:	fe30a5        	call8	4037a280 <vPortExitCritical>
    }
4037bf7a:	f01d      	retw.n

4037bf7c <vTaskPriorityDisinheritAfterTimeout>:
    {
4037bf7c:	004136        	entry	a1, 32
4037bf7f:	ffafb2        	movi	a11, -1
4037bf82:	e354a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037bf85:	fe1aa5        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pxMutexHolder != NULL )
4037bf88:	0e0216        	beqz	a2, 4037c06c <vTaskPriorityDisinheritAfterTimeout+0xf0>
                configASSERT( pxTCB->uxMutexesHeld );
4037bf8b:	1422a2        	l32i	a10, a2, 80
4037bf8e:	00ea56        	bnez	a10, 4037bfa0 <vTaskPriorityDisinheritAfterTimeout+0x24>
4037bf91:	e384d1        	l32r	a13, 40374da4 <_iram_text_start+0x9a0> (3c0247cc <_flash_rodata_start+0x46ac>)
4037bf94:	e386c1        	l32r	a12, 40374dac <_iram_text_start+0x9a8> (3c0280a8 <__func__$14>)
4037bf97:	e386b1        	l32r	a11, 40374db0 <_iram_text_start+0x9ac> (1469 <UserFrameTotalSize+0x1369>)
4037bf9a:	e344a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bf9d:	03db25        	call8	4037fd50 <__assert_func>
                if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4037bfa0:	132282        	l32i	a8, a2, 76
4037bfa3:	02b837        	bgeu	a8, a3, 4037bfa9 <vTaskPriorityDisinheritAfterTimeout+0x2d>
                    uxPriorityToUse = uxHighestPriorityWaitingTask;
4037bfa6:	208330        	or	a8, a3, a3
                if( pxTCB->uxPriority != uxPriorityToUse )
4037bfa9:	0b2292        	l32i	a9, a2, 44
4037bfac:	029987        	bne	a9, a8, 4037bfb2 <vTaskPriorityDisinheritAfterTimeout+0x36>
4037bfaf:	002e46        	j	4037c06c <vTaskPriorityDisinheritAfterTimeout+0xf0>
                    if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4037bfb2:	021a26        	beqi	a10, 1, 4037bfb8 <vTaskPriorityDisinheritAfterTimeout+0x3c>
4037bfb5:	002cc6        	j	4037c06c <vTaskPriorityDisinheritAfterTimeout+0xf0>
4037bfb8:	03eba0        	rsr.prid	a10
4037bfbb:	04ada0        	extui	a10, a10, 13, 1
                        configASSERT( pxTCB != pxCurrentTCBs[ portGET_CORE_ID() ] );
4037bfbe:	e320b1        	l32r	a11, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037bfc1:	a0aab0        	addx4	a10, a10, a11
4037bfc4:	0020c0        	memw
4037bfc7:	002aa2        	l32i	a10, a10, 0
4037bfca:	0e9a27        	bne	a10, a2, 4037bfdc <vTaskPriorityDisinheritAfterTimeout+0x60>
4037bfcd:	e379d1        	l32r	a13, 40374db4 <_iram_text_start+0x9b0> (3c0247e4 <_flash_rodata_start+0x46c4>)
4037bfd0:	e377c1        	l32r	a12, 40374dac <_iram_text_start+0x9a8> (3c0280a8 <__func__$14>)
4037bfd3:	e379b1        	l32r	a11, 40374db8 <_iram_text_start+0x9b4> (1484 <UserFrameTotalSize+0x1384>)
4037bfd6:	e335a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037bfd9:	03d765        	call8	4037fd50 <__assert_func>
                        pxTCB->uxPriority = uxPriorityToUse;
4037bfdc:	b289      	s32i.n	a8, a2, 44
                        if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bfde:	0020c0        	memw
4037bfe1:	62a8      	l32i.n	a10, a2, 24
4037bfe3:	00aa96        	bltz	a10, 4037bff1 <vTaskPriorityDisinheritAfterTimeout+0x75>
                            listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bfe6:	e7c882        	addi	a8, a8, -25
4037bfe9:	608080        	neg	a8, a8
4037bfec:	0020c0        	memw
4037bfef:	6289      	s32i.n	a8, a2, 24
                        if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037bff1:	0020c0        	memw
4037bff4:	052282        	l32i	a8, a2, 20
4037bff7:	a09990        	addx4	a9, a9, a9
4037bffa:	e32ea1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037bffd:	a099a0        	addx4	a9, a9, a10
4037c000:	689897        	bne	a8, a9, 4037c06c <vTaskPriorityDisinheritAfterTimeout+0xf0>
                            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037c003:	04c232        	addi	a3, a2, 4
4037c006:	20a330        	or	a10, a3, a3
4037c009:	fe98a5        	call8	4037a994 <uxListRemove>
                            prvAddTaskToReadyList( pxTCB );
4037c00c:	b288      	l32i.n	a8, a2, 44
4037c00e:	e32891        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037c011:	0020c0        	memw
4037c014:	0998      	l32i.n	a9, a9, 0
4037c016:	07b987        	bgeu	a9, a8, 4037c021 <vTaskPriorityDisinheritAfterTimeout+0xa5>
4037c019:	e32591        	l32r	a9, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037c01c:	0020c0        	memw
4037c01f:	0989      	s32i.n	a8, a9, 0
4037c021:	e324a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037c024:	a08880        	addx4	a8, a8, a8
4037c027:	a088a0        	addx4	a8, a8, a10
4037c02a:	0020c0        	memw
4037c02d:	1888      	l32i.n	a8, a8, 4
4037c02f:	0020c0        	memw
4037c032:	2289      	s32i.n	a8, a2, 8
4037c034:	0020c0        	memw
4037c037:	2898      	l32i.n	a9, a8, 8
4037c039:	0020c0        	memw
4037c03c:	3299      	s32i.n	a9, a2, 12
4037c03e:	0020c0        	memw
4037c041:	2898      	l32i.n	a9, a8, 8
4037c043:	0020c0        	memw
4037c046:	1939      	s32i.n	a3, a9, 4
4037c048:	0020c0        	memw
4037c04b:	2839      	s32i.n	a3, a8, 8
4037c04d:	b288      	l32i.n	a8, a2, 44
4037c04f:	a09880        	addx4	a9, a8, a8
4037c052:	a099a0        	addx4	a9, a9, a10
4037c055:	0020c0        	memw
4037c058:	5299      	s32i.n	a9, a2, 20
4037c05a:	0020c0        	memw
4037c05d:	0998      	l32i.n	a9, a9, 0
4037c05f:	991b      	addi.n	a9, a9, 1
4037c061:	a08880        	addx4	a8, a8, a8
4037c064:	a088a0        	addx4	a8, a8, a10
4037c067:	0020c0        	memw
4037c06a:	0899      	s32i.n	a9, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037c06c:	e31aa1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c06f:	fe2125        	call8	4037a280 <vPortExitCritical>
    }
4037c072:	f01d      	retw.n

4037c074 <pvTaskIncrementMutexHeldCount>:
    {
4037c074:	004136        	entry	a1, 32
4037c077:	ffafb2        	movi	a11, -1
4037c07a:	e316a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c07d:	fe0b25        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c080:	03eb80        	rsr.prid	a8
4037c083:	048d80        	extui	a8, a8, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ] != NULL )
4037c086:	e2ee91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c089:	a09890        	addx4	a9, a8, a9
4037c08c:	0020c0        	memw
4037c08f:	002992        	l32i	a9, a9, 0
4037c092:	012916        	beqz	a9, 4037c0a8 <pvTaskIncrementMutexHeldCount+0x34>
                ( pxCurrentTCBs[ xCurCoreID ]->uxMutexesHeld )++;
4037c095:	e2ea91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c098:	a09890        	addx4	a9, a8, a9
4037c09b:	0020c0        	memw
4037c09e:	09a8      	l32i.n	a10, a9, 0
4037c0a0:	142a92        	l32i	a9, a10, 80
4037c0a3:	991b      	addi.n	a9, a9, 1
4037c0a5:	146a92        	s32i	a9, a10, 80
            xReturn = pxCurrentTCBs[ xCurCoreID ];
4037c0a8:	e2e691        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c0ab:	a08890        	addx4	a8, a8, a9
4037c0ae:	0020c0        	memw
4037c0b1:	0828      	l32i.n	a2, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037c0b3:	e308a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c0b6:	fe1ca5        	call8	4037a280 <vPortExitCritical>
    }
4037c0b9:	f01d      	retw.n
	...

4037c0bc <ulTaskGenericNotifyTake>:
    {
4037c0bc:	004136        	entry	a1, 32
4037c0bf:	027d      	mov.n	a7, a2
        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c0c1:	d28c      	beqz.n	a2, 4037c0d2 <ulTaskGenericNotifyTake+0x16>
4037c0c3:	e33ed1        	l32r	a13, 40374dbc <_iram_text_start+0x9b8> (3c024810 <_flash_rodata_start+0x46f0>)
4037c0c6:	e33ec1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc> (3c028090 <__func__$13>)
4037c0c9:	e33eb1        	l32r	a11, 40374dc4 <_iram_text_start+0x9c0> (1654 <UserFrameTotalSize+0x1554>)
4037c0cc:	e2f8a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c0cf:	03c825        	call8	4037fd50 <__assert_func>
4037c0d2:	fb7c      	movi.n	a11, -1
4037c0d4:	e300a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c0d7:	fe05a5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c0da:	03eb90        	rsr.prid	a9
4037c0dd:	049d90        	extui	a9, a9, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] == 0UL )
4037c0e0:	e2d881        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c0e3:	a08980        	addx4	a8, a9, a8
4037c0e6:	0020c0        	memw
4037c0e9:	08a8      	l32i.n	a10, a8, 0
4037c0eb:	50c282        	addi	a8, a2, 80
4037c0ee:	a088a0        	addx4	a8, a8, a10
4037c0f1:	0020c0        	memw
4037c0f4:	3888      	l32i.n	a8, a8, 12
4037c0f6:	a8ec      	bnez.n	a8, 4037c124 <ulTaskGenericNotifyTake+0x68>
                pxCurrentTCBs[ xCurCoreID ]->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4037c0f8:	e2d281        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c0fb:	a09980        	addx4	a9, a9, a8
4037c0fe:	0020c0        	memw
4037c101:	0988      	l32i.n	a8, a9, 0
4037c103:	882a      	add.n	a8, a8, a2
4037c105:	50a192        	movi	a9, 0x150
4037c108:	889a      	add.n	a8, a8, a9
4037c10a:	190c      	movi.n	a9, 1
4037c10c:	0020c0        	memw
4037c10f:	004892        	s8i	a9, a8, 0
                if( xTicksToWait > ( TickType_t ) 0 )
4037c112:	e48c      	beqz.n	a4, 4037c124 <ulTaskGenericNotifyTake+0x68>
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4037c114:	1b0c      	movi.n	a11, 1
4037c116:	04ad      	mov.n	a10, a4
4037c118:	fecb65        	call8	4037add0 <prvAddCurrentTaskToDelayedList>
4037c11b:	03eba0        	rsr.prid	a10
4037c11e:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037c121:	fbfaa5        	call8	403780cc <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &xKernelLock );
4037c124:	e2ec41        	l32r	a4, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c127:	04ad      	mov.n	a10, a4
4037c129:	fe1565        	call8	4037a280 <vPortExitCritical>
4037c12c:	fb7c      	movi.n	a11, -1
4037c12e:	20a440        	or	a10, a4, a4
4037c131:	fdffe5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c134:	03eb80        	rsr.prid	a8
4037c137:	048d80        	extui	a8, a8, 13, 1
            ulReturn = pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ];
4037c13a:	e2c191        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c13d:	a09890        	addx4	a9, a8, a9
4037c140:	0020c0        	memw
4037c143:	09a8      	l32i.n	a10, a9, 0
4037c145:	50c792        	addi	a9, a7, 80
4037c148:	a099a0        	addx4	a9, a9, a10
4037c14b:	0020c0        	memw
4037c14e:	3928      	l32i.n	a2, a9, 12
            if( ulReturn != 0UL )
4037c150:	52bc      	beqz.n	a2, 4037c189 <ulTaskGenericNotifyTake+0xcd>
                if( xClearCountOnExit != pdFALSE )
4037c152:	b39c      	beqz.n	a3, 4037c171 <ulTaskGenericNotifyTake+0xb5>
                    pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] = 0UL;
4037c154:	e2bb91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c157:	a09890        	addx4	a9, a8, a9
4037c15a:	0020c0        	memw
4037c15d:	09a8      	l32i.n	a10, a9, 0
4037c15f:	50c792        	addi	a9, a7, 80
4037c162:	a099a0        	addx4	a9, a9, a10
4037c165:	0a0c      	movi.n	a10, 0
4037c167:	0020c0        	memw
4037c16a:	39a9      	s32i.n	a10, a9, 12
4037c16c:	000646        	j	4037c189 <ulTaskGenericNotifyTake+0xcd>
4037c16f:	910000        	srl	a0, a0
                    pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
4037c172:	90e2b3        	lsi	f11, a2, 0x240
4037c175:	a098      	l32i.n	a9, a0, 40
4037c177:	0020c0        	memw
4037c17a:	09b8      	l32i.n	a11, a9, 0
4037c17c:	a20b      	addi.n	a10, a2, -1
4037c17e:	50c792        	addi	a9, a7, 80
4037c181:	a099b0        	addx4	a9, a9, a11
4037c184:	0020c0        	memw
4037c187:	39a9      	s32i.n	a10, a9, 12
            pxCurrentTCBs[ xCurCoreID ]->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4037c189:	e2ad91        	l32r	a9, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c18c:	a08890        	addx4	a8, a8, a9
4037c18f:	0020c0        	memw
4037c192:	002882        	l32i	a8, a8, 0
4037c195:	808870        	add	a8, a8, a7
4037c198:	50a192        	movi	a9, 0x150
4037c19b:	808890        	add	a8, a8, a9
4037c19e:	090c      	movi.n	a9, 0
4037c1a0:	0020c0        	memw
4037c1a3:	004892        	s8i	a9, a8, 0
        taskEXIT_CRITICAL( &xKernelLock );
4037c1a6:	e2cba1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c1a9:	fe0d65        	call8	4037a280 <vPortExitCritical>
    }
4037c1ac:	f01d      	retw.n
	...

4037c1b0 <xTaskGenericNotify>:
    {
4037c1b0:	004136        	entry	a1, 32
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c1b3:	00e316        	beqz	a3, 4037c1c5 <xTaskGenericNotify+0x15>
4037c1b6:	e304d1        	l32r	a13, 40374dc8 <_iram_text_start+0x9c4> (3c024824 <_flash_rodata_start+0x4704>)
4037c1b9:	e304c1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c02807c <__func__$11>)
4037c1bc:	e305b1        	l32r	a11, 40374dd0 <_iram_text_start+0x9cc> (1702 <UserFrameTotalSize+0x1602>)
4037c1bf:	e2bba1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c1c2:	03b8e5        	call8	4037fd50 <__assert_func>
        configASSERT( xTaskToNotify );
4037c1c5:	00e256        	bnez	a2, 4037c1d7 <xTaskGenericNotify+0x27>
4037c1c8:	e303d1        	l32r	a13, 40374dd4 <_iram_text_start+0x9d0> (3c024838 <_flash_rodata_start+0x4718>)
4037c1cb:	e300c1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c02807c <__func__$11>)
4037c1ce:	e302b1        	l32r	a11, 40374dd8 <_iram_text_start+0x9d4> (1703 <UserFrameTotalSize+0x1603>)
4037c1d1:	e2b6a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c1d4:	03b7a5        	call8	4037fd50 <__assert_func>
4037c1d7:	fb7c      	movi.n	a11, -1
4037c1d9:	e2bea1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c1dc:	fdf525        	call8	4037a130 <xPortEnterCriticalTimeout>
            if( pulPreviousNotificationValue != NULL )
4037c1df:	00d616        	beqz	a6, 4037c1f0 <xTaskGenericNotify+0x40>
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
4037c1e2:	50c382        	addi	a8, a3, 80
4037c1e5:	a08820        	addx4	a8, a8, a2
4037c1e8:	0020c0        	memw
4037c1eb:	032882        	l32i	a8, a8, 12
4037c1ee:	0689      	s32i.n	a8, a6, 0
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c1f0:	823a      	add.n	a8, a2, a3
4037c1f2:	50a192        	movi	a9, 0x150
4037c1f5:	889a      	add.n	a8, a8, a9
4037c1f7:	0020c0        	memw
4037c1fa:	000892        	l8ui	a9, a8, 0
4037c1fd:	749090        	extui	a9, a9, 0, 8
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c200:	2a0c      	movi.n	a10, 2
4037c202:	0020c0        	memw
4037c205:	0048a2        	s8i	a10, a8, 0
            switch( eAction )
4037c208:	2c2526        	beqi	a5, 2, 4037c238 <xTaskGenericNotify+0x88>
4037c20b:	0935f6        	bgeui	a5, 3, 4037c218 <xTaskGenericNotify+0x68>
4037c20e:	077516        	beqz	a5, 4037c289 <xTaskGenericNotify+0xd9>
4037c211:	0c1526        	beqi	a5, 1, 4037c221 <xTaskGenericNotify+0x71>
4037c214:	001606        	j	4037c270 <xTaskGenericNotify+0xc0>
4037c217:	352600        	extui	a2, a0, 22, 4
4037c21a:	452631        	l32r	a3, 4034d6b4 <rom_rx_gain_force+0x347288>
4037c21d:	863d      	lsi	f3, a6, 24
4037c21f:	320013        	lsi	f1, a0, 200
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
4037c222:	2050c3        	lsi	f12, a0, 128
4037c225:	c0a033        	lsi	f3, a0, 0x300
4037c228:	880020        	lsi	f2, a0, 0x220
4037c22b:	884033        	ssi	f3, a0, 0x220
4037c22e:	20c020        	or	a12, a0, a2
4037c231:	338900        	clamps	a8, a9, 7
                    break;
4037c234:	001446        	j	4037c289 <xTaskGenericNotify+0xd9>
4037c237:	c33200        	movf	a3, a2, b0
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c23a:	332050        	clamps	a2, a0, 12
4037c23d:	20c0a0        	or	a12, a0, a10
4037c240:	338800        	clamps	a8, a8, 7
4037c243:	881b      	addi.n	a8, a8, 1
4037c245:	0020c0        	memw
4037c248:	3389      	s32i.n	a8, a3, 12
                    break;
4037c24a:	000ec6        	j	4037c289 <xTaskGenericNotify+0xd9>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4037c24d:	50c332        	addi	a3, a3, 80
4037c250:	a03320        	addx4	a3, a3, a2
4037c253:	0020c0        	memw
4037c256:	3349      	s32i.n	a4, a3, 12
                    break;
4037c258:	000b46        	j	4037c289 <xTaskGenericNotify+0xd9>
4037c25b:	296600        	lsi	f0, a6, 164
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4037c25e:	428602        	lsi	f0, a6, 0x108
4037c261:	c33200        	movf	a3, a2, b0
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4037c264:	332050        	clamps	a2, a0, 12
4037c267:	20c0a0        	or	a12, a0, a10
4037c26a:	334900        	clamps	a4, a9, 7
4037c26d:	000606        	j	4037c289 <xTaskGenericNotify+0xd9>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
4037c270:	e29e81        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037c273:	0020c0        	memw
4037c276:	0888      	l32i.n	a8, a8, 0
4037c278:	d88c      	beqz.n	a8, 4037c289 <xTaskGenericNotify+0xd9>
4037c27a:	e2d8d1        	l32r	a13, 40374ddc <_iram_text_start+0x9d8> (3c024848 <_flash_rodata_start+0x4728>)
4037c27d:	e2d3c1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c02807c <__func__$11>)
4037c280:	e2d8b1        	l32r	a11, 40374de0 <_iram_text_start+0x9dc> (1738 <UserFrameTotalSize+0x1638>)
4037c283:	e28aa1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c286:	03aca5        	call8	4037fd50 <__assert_func>
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4037c289:	021926        	beqi	a9, 1, 4037c28f <xTaskGenericNotify+0xdf>
4037c28c:	003886        	j	4037c372 <xTaskGenericNotify+0x1c2>
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037c28f:	0020c0        	memw
4037c292:	5288      	l32i.n	a8, a2, 20
4037c294:	0020c0        	memw
4037c297:	2298      	l32i.n	a9, a2, 8
4037c299:	0020c0        	memw
4037c29c:	32a8      	l32i.n	a10, a2, 12
4037c29e:	0020c0        	memw
4037c2a1:	29a9      	s32i.n	a10, a9, 8
4037c2a3:	0020c0        	memw
4037c2a6:	3298      	l32i.n	a9, a2, 12
4037c2a8:	0020c0        	memw
4037c2ab:	22a8      	l32i.n	a10, a2, 8
4037c2ad:	0020c0        	memw
4037c2b0:	19a9      	s32i.n	a10, a9, 4
4037c2b2:	0020c0        	memw
4037c2b5:	18a8      	l32i.n	a10, a8, 4
4037c2b7:	924b      	addi.n	a9, a2, 4
4037c2b9:	099a97        	bne	a10, a9, 4037c2c6 <xTaskGenericNotify+0x116>
4037c2bc:	0020c0        	memw
4037c2bf:	32a8      	l32i.n	a10, a2, 12
4037c2c1:	0020c0        	memw
4037c2c4:	18a9      	s32i.n	a10, a8, 4
4037c2c6:	0a0c      	movi.n	a10, 0
4037c2c8:	0020c0        	memw
4037c2cb:	0562a2        	s32i	a10, a2, 20
4037c2ce:	0020c0        	memw
4037c2d1:	0028a2        	l32i	a10, a8, 0
4037c2d4:	aa0b      	addi.n	a10, a10, -1
4037c2d6:	0020c0        	memw
4037c2d9:	08a9      	s32i.n	a10, a8, 0
                prvAddTaskToReadyList( pxTCB );
4037c2db:	b288      	l32i.n	a8, a2, 44
4037c2dd:	e274a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037c2e0:	0020c0        	memw
4037c2e3:	0aa8      	l32i.n	a10, a10, 0
4037c2e5:	07ba87        	bgeu	a10, a8, 4037c2f0 <xTaskGenericNotify+0x140>
4037c2e8:	e272a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037c2eb:	0020c0        	memw
4037c2ee:	0a89      	s32i.n	a8, a10, 0
4037c2f0:	e271a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037c2f3:	a08880        	addx4	a8, a8, a8
4037c2f6:	a088a0        	addx4	a8, a8, a10
4037c2f9:	0020c0        	memw
4037c2fc:	1888      	l32i.n	a8, a8, 4
4037c2fe:	0020c0        	memw
4037c301:	2289      	s32i.n	a8, a2, 8
4037c303:	0020c0        	memw
4037c306:	28b8      	l32i.n	a11, a8, 8
4037c308:	0020c0        	memw
4037c30b:	32b9      	s32i.n	a11, a2, 12
4037c30d:	0020c0        	memw
4037c310:	28b8      	l32i.n	a11, a8, 8
4037c312:	0020c0        	memw
4037c315:	1b99      	s32i.n	a9, a11, 4
4037c317:	0020c0        	memw
4037c31a:	2899      	s32i.n	a9, a8, 8
4037c31c:	b288      	l32i.n	a8, a2, 44
4037c31e:	a09880        	addx4	a9, a8, a8
4037c321:	a099a0        	addx4	a9, a9, a10
4037c324:	0020c0        	memw
4037c327:	5299      	s32i.n	a9, a2, 20
4037c329:	0020c0        	memw
4037c32c:	0998      	l32i.n	a9, a9, 0
4037c32e:	991b      	addi.n	a9, a9, 1
4037c330:	a08880        	addx4	a8, a8, a8
4037c333:	a088a0        	addx4	a8, a8, a10
4037c336:	0020c0        	memw
4037c339:	0899      	s32i.n	a9, a8, 0
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4037c33b:	0020c0        	memw
4037c33e:	a288      	l32i.n	a8, a2, 40
4037c340:	d88c      	beqz.n	a8, 4037c351 <xTaskGenericNotify+0x1a1>
4037c342:	e2a8d1        	l32r	a13, 40374de4 <_iram_text_start+0x9e0> (3c024868 <_flash_rodata_start+0x4748>)
4037c345:	e2a1c1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c02807c <__func__$11>)
4037c348:	e2a8b1        	l32r	a11, 40374de8 <_iram_text_start+0x9e4> (1747 <UserFrameTotalSize+0x1647>)
4037c34b:	e258a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c34e:	03a025        	call8	4037fd50 <__assert_func>
                if( taskIS_YIELD_REQUIRED( pxTCB, pdFALSE ) == pdTRUE )
4037c351:	00a0c2        	movi	a12, 0
4037c354:	0b22b2        	l32i	a11, a2, 44
4037c357:	02ad      	mov.n	a10, a2
4037c359:	fe7125        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037c35c:	0a2d      	mov.n	a2, a10
4037c35e:	171a66        	bnei	a10, 1, 4037c379 <xTaskGenericNotify+0x1c9>
4037c361:	03eba0        	rsr.prid	a10
4037c364:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037c367:	fbd665        	call8	403780cc <esp_crosscore_int_send_yield>
4037c36a:	000346        	j	4037c37b <xTaskGenericNotify+0x1cb>
                        xReturn = pdFAIL;
4037c36d:	020c      	movi.n	a2, 0
4037c36f:	000206        	j	4037c37b <xTaskGenericNotify+0x1cb>
4037c372:	120c      	movi.n	a2, 1
4037c374:	0000c6        	j	4037c37b <xTaskGenericNotify+0x1cb>
4037c377:	0c0000        	lsi	f0, a0, 48
4037c37a:	56a112        	movi	a1, 0x156
        taskEXIT_CRITICAL( &xKernelLock );
4037c37d:	f025e2        	l32i	a14, a5, 0x3c0
4037c380:	1dfd      	lsi	f15, a13, 52
    }
4037c382:	f0          	.byte	0xf0
	...

4037c384 <vTaskGenericNotifyGiveFromISR>:
    {
4037c384:	004136        	entry	a1, 32
        configASSERT( xTaskToNotify );
4037c387:	00e256        	bnez	a2, 4037c399 <vTaskGenericNotifyGiveFromISR+0x15>
4037c38a:	e292d1        	l32r	a13, 40374dd4 <_iram_text_start+0x9d0> (3c024838 <_flash_rodata_start+0x4718>)
4037c38d:	e297c1        	l32r	a12, 40374dec <_iram_text_start+0x9e8> (3c02805c <__func__$9>)
4037c390:	e298b1        	l32r	a11, 40374df0 <_iram_text_start+0x9ec> (1809 <UserFrameTotalSize+0x1709>)
4037c393:	e246a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c396:	039ba5        	call8	4037fd50 <__assert_func>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c399:	00e316        	beqz	a3, 4037c3ab <vTaskGenericNotifyGiveFromISR+0x27>
4037c39c:	e28bd1        	l32r	a13, 40374dc8 <_iram_text_start+0x9c4> (3c024824 <_flash_rodata_start+0x4704>)
4037c39f:	e293c1        	l32r	a12, 40374dec <_iram_text_start+0x9e8> (3c02805c <__func__$9>)
4037c3a2:	e294b1        	l32r	a11, 40374df4 <_iram_text_start+0x9f0> (180a <UserFrameTotalSize+0x170a>)
4037c3a5:	e241a1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c3a8:	039a65        	call8	4037fd50 <__assert_func>
4037c3ab:	fb7c      	movi.n	a11, -1
4037c3ad:	e249a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c3b0:	fdd7e5        	call8	4037a130 <xPortEnterCriticalTimeout>
4037c3b3:	03eb70        	rsr.prid	a7
4037c3b6:	047d70        	extui	a7, a7, 13, 1
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c3b9:	808230        	add	a8, a2, a3
4037c3bc:	50a192        	movi	a9, 0x150
4037c3bf:	889a      	add.n	a8, a8, a9
4037c3c1:	0020c0        	memw
4037c3c4:	000892        	l8ui	a9, a8, 0
4037c3c7:	749090        	extui	a9, a9, 0, 8
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c3ca:	2a0c      	movi.n	a10, 2
4037c3cc:	0020c0        	memw
4037c3cf:	0048a2        	s8i	a10, a8, 0
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c3d2:	50c332        	addi	a3, a3, 80
4037c3d5:	a03320        	addx4	a3, a3, a2
4037c3d8:	0020c0        	memw
4037c3db:	3388      	l32i.n	a8, a3, 12
4037c3dd:	881b      	addi.n	a8, a8, 1
4037c3df:	0020c0        	memw
4037c3e2:	3389      	s32i.n	a8, a3, 12
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4037c3e4:	021926        	beqi	a9, 1, 4037c3ea <vTaskGenericNotifyGiveFromISR+0x66>
4037c3e7:	004d06        	j	4037c51f <vTaskGenericNotifyGiveFromISR+0x19b>
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4037c3ea:	0020c0        	memw
4037c3ed:	a288      	l32i.n	a8, a2, 40
4037c3ef:	d88c      	beqz.n	a8, 4037c400 <vTaskGenericNotifyGiveFromISR+0x7c>
4037c3f1:	e27cd1        	l32r	a13, 40374de4 <_iram_text_start+0x9e0> (3c024868 <_flash_rodata_start+0x4748>)
4037c3f4:	e27ec1        	l32r	a12, 40374dec <_iram_text_start+0x9e8> (3c02805c <__func__$9>)
4037c3f7:	e280b1        	l32r	a11, 40374df8 <_iram_text_start+0x9f4> (1833 <UserFrameTotalSize+0x1733>)
4037c3fa:	e22ca1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c3fd:	039525        	call8	4037fd50 <__assert_func>
                if( taskCAN_BE_SCHEDULED( pxTCB ) == pdTRUE )
4037c400:	20a220        	or	a10, a2, a2
4037c403:	fe5e65        	call8	4037a9e8 <prvCheckTaskCanBeScheduledSMP>
4037c406:	021a26        	beqi	a10, 1, 4037c40c <vTaskGenericNotifyGiveFromISR+0x88>
4037c409:	002bc6        	j	4037c4bc <vTaskGenericNotifyGiveFromISR+0x138>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037c40c:	0020c0        	memw
4037c40f:	052282        	l32i	a8, a2, 20
4037c412:	0020c0        	memw
4037c415:	022292        	l32i	a9, a2, 8
4037c418:	0020c0        	memw
4037c41b:	32a8      	l32i.n	a10, a2, 12
4037c41d:	0020c0        	memw
4037c420:	29a9      	s32i.n	a10, a9, 8
4037c422:	0020c0        	memw
4037c425:	3298      	l32i.n	a9, a2, 12
4037c427:	0020c0        	memw
4037c42a:	22a8      	l32i.n	a10, a2, 8
4037c42c:	0020c0        	memw
4037c42f:	19a9      	s32i.n	a10, a9, 4
4037c431:	0020c0        	memw
4037c434:	18a8      	l32i.n	a10, a8, 4
4037c436:	924b      	addi.n	a9, a2, 4
4037c438:	099a97        	bne	a10, a9, 4037c445 <vTaskGenericNotifyGiveFromISR+0xc1>
4037c43b:	0020c0        	memw
4037c43e:	32a8      	l32i.n	a10, a2, 12
4037c440:	0020c0        	memw
4037c443:	18a9      	s32i.n	a10, a8, 4
4037c445:	0a0c      	movi.n	a10, 0
4037c447:	0020c0        	memw
4037c44a:	52a9      	s32i.n	a10, a2, 20
4037c44c:	0020c0        	memw
4037c44f:	08a8      	l32i.n	a10, a8, 0
4037c451:	aa0b      	addi.n	a10, a10, -1
4037c453:	0020c0        	memw
4037c456:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxTCB );
4037c458:	b288      	l32i.n	a8, a2, 44
4037c45a:	e215a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037c45d:	0020c0        	memw
4037c460:	0aa8      	l32i.n	a10, a10, 0
4037c462:	07ba87        	bgeu	a10, a8, 4037c46d <vTaskGenericNotifyGiveFromISR+0xe9>
4037c465:	e212a1        	l32r	a10, 40374cb0 <_iram_text_start+0x8ac> (3fc94b3c <uxTopReadyPriority>)
4037c468:	0020c0        	memw
4037c46b:	0a89      	s32i.n	a8, a10, 0
4037c46d:	e211a1        	l32r	a10, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037c470:	a08880        	addx4	a8, a8, a8
4037c473:	a088a0        	addx4	a8, a8, a10
4037c476:	0020c0        	memw
4037c479:	1888      	l32i.n	a8, a8, 4
4037c47b:	0020c0        	memw
4037c47e:	2289      	s32i.n	a8, a2, 8
4037c480:	0020c0        	memw
4037c483:	28b8      	l32i.n	a11, a8, 8
4037c485:	0020c0        	memw
4037c488:	32b9      	s32i.n	a11, a2, 12
4037c48a:	0020c0        	memw
4037c48d:	28b8      	l32i.n	a11, a8, 8
4037c48f:	0020c0        	memw
4037c492:	1b99      	s32i.n	a9, a11, 4
4037c494:	0020c0        	memw
4037c497:	2899      	s32i.n	a9, a8, 8
4037c499:	b288      	l32i.n	a8, a2, 44
4037c49b:	a09880        	addx4	a9, a8, a8
4037c49e:	a099a0        	addx4	a9, a9, a10
4037c4a1:	0020c0        	memw
4037c4a4:	5299      	s32i.n	a9, a2, 20
4037c4a6:	0020c0        	memw
4037c4a9:	0998      	l32i.n	a9, a9, 0
4037c4ab:	991b      	addi.n	a9, a9, 1
4037c4ad:	a08880        	addx4	a8, a8, a8
4037c4b0:	a088a0        	addx4	a8, a8, a10
4037c4b3:	0020c0        	memw
4037c4b6:	0899      	s32i.n	a9, a8, 0
4037c4b8:	0010c6        	j	4037c4ff <vTaskGenericNotifyGiveFromISR+0x17b>
4037c4bb:	877000        	lsi	f0, a0, 0x21c
                    listINSERT_END( &( xPendingReadyList[ xCurCoreID ] ), &( pxTCB->xEventListItem ) );
4037c4be:	1291a0        	andbc	b9, b1, b10
4037c4c1:	8890e2        	l16si	a14, a0, 0x110
4037c4c4:	20c0a0        	or	a12, a0, a10
4037c4c7:	289200        	lsi	f0, a2, 160
4037c4ca:	20c001        	l32r	a0, 403447cc <rom_rx_gain_force+0x33e3a0>
4037c4cd:	629200        	lsi	f0, a2, 0x188
4037c4d0:	20c007        	bnall	a0, a0, 4037c4f4 <vTaskGenericNotifyGiveFromISR+0x170>
4037c4d3:	29a200        	lsi	f0, a2, 164
4037c4d6:	20c002        	addi	a0, a0, 32
4037c4d9:	82a900        	mull	a10, a9, a0
4037c4dc:	0020c0        	memw
4037c4df:	29b8      	l32i.n	a11, a9, 8
4037c4e1:	18c2a2        	addi	a10, a2, 24
4037c4e4:	0020c0        	memw
4037c4e7:	1ba9      	s32i.n	a10, a11, 4
4037c4e9:	0020c0        	memw
4037c4ec:	29a9      	s32i.n	a10, a9, 8
4037c4ee:	0020c0        	memw
4037c4f1:	a289      	s32i.n	a8, a2, 40
4037c4f3:	0020c0        	memw
4037c4f6:	0898      	l32i.n	a9, a8, 0
4037c4f8:	991b      	addi.n	a9, a9, 1
4037c4fa:	0020c0        	memw
4037c4fd:	0899      	s32i.n	a9, a8, 0
                if( taskIS_YIELD_REQUIRED( pxTCB, pdFALSE ) == pdTRUE )
4037c4ff:	0c0c      	movi.n	a12, 0
4037c501:	b2b8      	l32i.n	a11, a2, 44
4037c503:	02ad      	mov.n	a10, a2
4037c505:	fe5665        	call8	4037aa6c <prvIsYieldRequiredSMP>
4037c508:	131a66        	bnei	a10, 1, 4037c51f <vTaskGenericNotifyGiveFromISR+0x19b>
                    if( pxHigherPriorityTaskWoken != NULL )
4037c50b:	248c      	beqz.n	a4, 4037c511 <vTaskGenericNotifyGiveFromISR+0x18d>
                        *pxHigherPriorityTaskWoken = pdTRUE;
4037c50d:	180c      	movi.n	a8, 1
4037c50f:	0489      	s32i.n	a8, a4, 0
                    xYieldPending[ xCurCoreID ] = pdTRUE;
4037c511:	e20681        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037c514:	a07780        	addx4	a7, a7, a8
4037c517:	180c      	movi.n	a8, 1
4037c519:	0020c0        	memw
4037c51c:	006782        	s32i	a8, a7, 0
        prvEXIT_CRITICAL_OR_UNMASK_ISR( &xKernelLock, uxSavedInterruptStatus );
4037c51f:	e1eda1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c522:	fdd5e5        	call8	4037a280 <vPortExitCritical>
    }
4037c525:	f01d      	retw.n
	...

4037c528 <xTaskIncrementTickOtherCores>:
/*----------------------------------------------------------*/

#if ( !CONFIG_FREERTOS_SMP && ( configNUM_CORES > 1 ) )

    BaseType_t xTaskIncrementTickOtherCores( void )
    {
4037c528:	004136        	entry	a1, 32
4037c52b:	03eb70        	rsr.prid	a7
4037c52e:	047d70        	extui	a7, a7, 13, 1
         * execution */
        BaseType_t xCoreID = portGET_CORE_ID();
        BaseType_t xSwitchRequired = pdFALSE;

        /* This function should never be called by Core 0. */
        configASSERT( xCoreID != 0 );
4037c531:	c7cc      	bnez.n	a7, 4037c541 <xTaskIncrementTickOtherCores+0x19>
4037c533:	e232d1        	l32r	a13, 40374dfc <_iram_text_start+0x9f8> (3c0248a8 <_flash_rodata_start+0x4788>)
4037c536:	e232c1        	l32r	a12, 40374e00 <_iram_text_start+0x9fc> (3c02803c <__func__$7>)
4037c539:	bb5c      	movi.n	a11, 91
4037c53b:	e232a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c53e:	038125        	call8	4037fd50 <__assert_func>

        /* Called by the portable layer each time a tick interrupt occurs
         * on a core other than core 0. */
        traceTASK_INCREMENT_TICK( xTickCount );

        if( uxSchedulerSuspended[ xCoreID ] == ( UBaseType_t ) 0U )
4037c541:	e1d581        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94b10 <uxSchedulerSuspended>)
4037c544:	a08780        	addx4	a8, a7, a8
4037c547:	0020c0        	memw
4037c54a:	0888      	l32i.n	a8, a8, 0
4037c54c:	049856        	bnez	a8, 4037c599 <xTaskIncrementTickOtherCores+0x71>
4037c54f:	ffafb2        	movi	a11, -1
4037c552:	e1e0a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c555:	fdbda5        	call8	4037a130 <xPortEnterCriticalTimeout>
            /* Tasks of equal priority to the currently running task will share
             * processing time (time slice) if preemption is on, and the application
             * writer has not explicitly turned time slicing off. */
            #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCBs[ xCoreID ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037c558:	e1ba81        	l32r	a8, 40374c40 <_iram_text_start+0x83c> (3fc94dc0 <pxCurrentTCBs>)
4037c55b:	a08780        	addx4	a8, a7, a8
4037c55e:	0020c0        	memw
4037c561:	002882        	l32i	a8, a8, 0
4037c564:	b888      	l32i.n	a8, a8, 44
4037c566:	a08880        	addx4	a8, a8, a8
4037c569:	1198e0        	slli	a9, a8, 2
4037c56c:	e1d281        	l32r	a8, 40374cb4 <_iram_text_start+0x8b0> (3fc94bcc <pxReadyTasksLists>)
4037c56f:	889a      	add.n	a8, a8, a9
4037c571:	0020c0        	memw
4037c574:	0888      	l32i.n	a8, a8, 0
4037c576:	0428f6        	bgeui	a8, 2, 4037c57e <xTaskIncrementTickOtherCores+0x56>
        BaseType_t xSwitchRequired = pdFALSE;
4037c579:	020c      	movi.n	a2, 0
4037c57b:	000086        	j	4037c581 <xTaskIncrementTickOtherCores+0x59>
                {
                    xSwitchRequired = pdTRUE;
4037c57e:	01a022        	movi	a2, 1
            }
            #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */

            /* Release the previously taken kernel lock as we have finished
             * accessing the kernel data structures. */
            taskEXIT_CRITICAL_ISR( &xKernelLock );
4037c581:	e1d4a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c584:	fdcfa5        	call8	4037a280 <vPortExitCritical>

            #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending[ xCoreID ] != pdFALSE )
4037c587:	e1e981        	l32r	a8, 40374d2c <_iram_text_start+0x928> (3fc94b2c <xYieldPending>)
4037c58a:	a07780        	addx4	a7, a7, a8
4037c58d:	0020c0        	memw
4037c590:	002782        	l32i	a8, a7, 0
4037c593:	007856        	bnez	a8, 4037c59e <xTaskIncrementTickOtherCores+0x76>
4037c596:	000186        	j	4037c5a0 <xTaskIncrementTickOtherCores+0x78>
        BaseType_t xSwitchRequired = pdFALSE;
4037c599:	020c      	movi.n	a2, 0
4037c59b:	000046        	j	4037c5a0 <xTaskIncrementTickOtherCores+0x78>
                {
                    xSwitchRequired = pdTRUE;
4037c59e:	120c      	movi.n	a2, 1
            vApplicationTickHook();
        }
        #endif

        return xSwitchRequired;
    }
4037c5a0:	f01d      	retw.n
	...

4037c5a4 <xTaskCreatePinnedToCore>:
                                        const uint32_t usStackDepth,
                                        void * const pvParameters,
                                        UBaseType_t uxPriority,
                                        TaskHandle_t * const pxCreatedTask,
                                        const BaseType_t xCoreID )
    {
4037c5a4:	008136        	entry	a1, 64
4037c5a7:	066172        	s32i	a7, a1, 24
4037c5aa:	046152        	s32i	a5, a1, 16
4037c5ad:	056162        	s32i	a6, a1, 20
4037c5b0:	102152        	l32i	a5, a1, 64
        BaseType_t xReturn;

        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE || xCoreID == tskNO_AFFINITY );
4037c5b3:	180c      	movi.n	a8, 1
4037c5b5:	628850        	lsi	f5, a8, 0x188
4037c5b8:	880b      	addi.n	a8, a8, -1
4037c5ba:	608080        	neg	a8, a8
4037c5bd:	748080        	extui	a8, a8, 0, 8
4037c5c0:	e09291        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037c5c3:	c09590        	sub	a9, a5, a9
4037c5c6:	40f990        	nsau	a9, a9
4037c5c9:	419590        	srli	a9, a9, 5
4037c5cc:	208890        	or	a8, a8, a9
4037c5cf:	d8cc      	bnez.n	a8, 4037c5e0 <xTaskCreatePinnedToCore+0x3c>
4037c5d1:	e20dd1        	l32r	a13, 40374e08 <_iram_text_start+0xa04> (3c024900 <_flash_rodata_start+0x47e0>)
4037c5d4:	e20ec1        	l32r	a12, 40374e0c <_iram_text_start+0xa08> (3c028024 <__func__$6>)
4037c5d7:	a3a0b2        	movi	a11, 163
4037c5da:	e20aa1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c5dd:	037725        	call8	4037fd50 <__assert_func>
            #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
4037c5e0:	04ad      	mov.n	a10, a4
4037c5e2:	fdfb25        	call8	4037a594 <pvPortMalloc>
4037c5e5:	0a7d      	mov.n	a7, a10

                if( pxStack != NULL )
4037c5e7:	049a16        	beqz	a10, 4037c634 <xTaskCreatePinnedToCore+0x90>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
4037c5ea:	54a1a2        	movi	a10, 0x154
4037c5ed:	fdfa65        	call8	4037a594 <pvPortMalloc>
4037c5f0:	0a6d      	mov.n	a6, a10

                    if( pxNewTCB != NULL )
4037c5f2:	4abc      	beqz.n	a10, 4037c62a <xTaskCreatePinnedToCore+0x86>
                    {
                        memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
4037c5f4:	54a1c2        	movi	a12, 0x154
4037c5f7:	0b0c      	movi.n	a11, 0
4037c5f9:	dfa581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037c5fc:	0008e0        	callx8	a8

                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
4037c5ff:	c679      	s32i.n	a7, a6, 48
            {
                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
                {
                    /* Tasks can be created statically or dynamically, so note this
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
4037c601:	01d682        	addmi	a8, a6, 0x100
4037c604:	090c      	movi.n	a9, 0
4037c606:	514892        	s8i	a9, a8, 81
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL, xCoreID );
4037c609:	2159      	s32i.n	a5, a1, 8
4037c60b:	080c      	movi.n	a8, 0
4037c60d:	1189      	s32i.n	a8, a1, 4
4037c60f:	0169      	s32i.n	a6, a1, 0
4037c611:	61f8      	l32i.n	a15, a1, 24
4037c613:	51e8      	l32i.n	a14, a1, 20
4037c615:	41d8      	l32i.n	a13, a1, 16
4037c617:	04cd      	mov.n	a12, a4
4037c619:	03bd      	mov.n	a11, a3
4037c61b:	02ad      	mov.n	a10, a2
4037c61d:	fe8de5        	call8	4037aefc <prvInitialiseNewTask>
                prvAddNewTaskToReadyList( pxNewTCB );
4037c620:	06ad      	mov.n	a10, a6
4037c622:	fe9e25        	call8	4037b004 <prvAddNewTaskToReadyList>
                xReturn = pdPASS;
4037c625:	120c      	movi.n	a2, 1
4037c627:	0002c6        	j	4037c636 <xTaskCreatePinnedToCore+0x92>
                        vPortFreeStack( pxStack );
4037c62a:	07ad      	mov.n	a10, a7
4037c62c:	fdf7a5        	call8	4037a5a8 <vPortFree>
            }
            else
            {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
4037c62f:	f27c      	movi.n	a2, -1
4037c631:	000046        	j	4037c636 <xTaskCreatePinnedToCore+0x92>
4037c634:	f27c      	movi.n	a2, -1
            }
        }
        #endif /* CONFIG_FREERTOS_SMP */

        return xReturn;
    }
4037c636:	f01d      	retw.n

4037c638 <xTaskCreateStaticPinnedToCore>:
                                                void * const pvParameters,
                                                UBaseType_t uxPriority,
                                                StackType_t * const puxStackBuffer,
                                                StaticTask_t * const pxTaskBuffer,
                                                const BaseType_t xCoreID )
    {
4037c638:	00a136        	entry	a1, 80
4037c63b:	8169      	s32i.n	a6, a1, 32
4037c63d:	142162        	l32i	a6, a1, 80
        TaskHandle_t xReturn;

        configASSERT( portVALID_STACK_MEM( puxStackBuffer ) );
4037c640:	07ad      	mov.n	a10, a7
4037c642:	fdfce5        	call8	4037a610 <xPortcheckValidStackMem>
4037c645:	dacc      	bnez.n	a10, 4037c656 <xTaskCreateStaticPinnedToCore+0x1e>
4037c647:	e1f2d1        	l32r	a13, 40374e10 <_iram_text_start+0xa0c> (3c0249bc <_flash_rodata_start+0x489c>)
4037c64a:	e1f2c1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c027fec <__func__$4>)
4037c64d:	2ba1b2        	movi	a11, 0x12b
4037c650:	e1eda1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c653:	036fe5        	call8	4037fd50 <__assert_func>
        configASSERT( portVALID_TCB_MEM( pxTaskBuffer ) );
4037c656:	20a660        	or	a10, a6, a6
4037c659:	fdf5a5        	call8	4037a5b4 <xPortCheckValidTCBMem>
4037c65c:	00ea56        	bnez	a10, 4037c66e <xTaskCreateStaticPinnedToCore+0x36>
4037c65f:	e1eed1        	l32r	a13, 40374e18 <_iram_text_start+0xa14> (3c0249e4 <_flash_rodata_start+0x48c4>)
4037c662:	e1ecc1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c027fec <__func__$4>)
4037c665:	2ca1b2        	movi	a11, 0x12c
4037c668:	e1e7a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c66b:	036e65        	call8	4037fd50 <__assert_func>
        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE || xCoreID == tskNO_AFFINITY );
4037c66e:	01a082        	movi	a8, 1
4037c671:	152192        	l32i	a9, a1, 84
4037c674:	628890        	lsi	f9, a8, 0x188
4037c677:	ffc882        	addi	a8, a8, -1
4037c67a:	608080        	neg	a8, a8
4037c67d:	748080        	extui	a8, a8, 0, 8
4037c680:	e06291        	l32r	a9, 40374808 <_iram_text_start+0x404> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037c683:	1521a2        	l32i	a10, a1, 84
4037c686:	c09a90        	sub	a9, a10, a9
4037c689:	40f990        	nsau	a9, a9
4037c68c:	419590        	srli	a9, a9, 5
4037c68f:	208890        	or	a8, a8, a9
4037c692:	00e856        	bnez	a8, 4037c6a4 <xTaskCreateStaticPinnedToCore+0x6c>
4037c695:	e1dcd1        	l32r	a13, 40374e08 <_iram_text_start+0xa04> (3c024900 <_flash_rodata_start+0x47e0>)
4037c698:	e1dfc1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c027fec <__func__$4>)
4037c69b:	2da1b2        	movi	a11, 0x12d
4037c69e:	e1d9a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c6a1:	036ae5        	call8	4037fd50 <__assert_func>
            #if ( configASSERT_DEFINED == 1 )
            {
                /* Sanity check that the size of the structure used to declare a
                 * variable of type StaticTask_t equals the size of the real task
                 * structure. */
                volatile size_t xSize = sizeof( StaticTask_t );
4037c6a4:	54a182        	movi	a8, 0x154
4037c6a7:	0020c0        	memw
4037c6aa:	5189      	s32i.n	a8, a1, 20
                configASSERT( xSize == sizeof( TCB_t ) );
4037c6ac:	0020c0        	memw
4037c6af:	052192        	l32i	a9, a1, 20
4037c6b2:	0e1987        	beq	a9, a8, 4037c6c4 <xTaskCreateStaticPinnedToCore+0x8c>
4037c6b5:	e1d9d1        	l32r	a13, 40374e1c <_iram_text_start+0xa18> (3c024a08 <_flash_rodata_start+0x48e8>)
4037c6b8:	e1d7c1        	l32r	a12, 40374e14 <_iram_text_start+0xa10> (3c027fec <__func__$4>)
4037c6bb:	57a1b2        	movi	a11, 0x157
4037c6be:	e1d1a1        	l32r	a10, 40374e04 <_iram_text_start+0xa00> (3c0248e0 <_flash_rodata_start+0x47c0>)
4037c6c1:	0368e5        	call8	4037fd50 <__assert_func>
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
4037c6c4:	0020c0        	memw
4037c6c7:	052182        	l32i	a8, a1, 20
            }
            #endif /* configASSERT_DEFINED */

            if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
4037c6ca:	01a092        	movi	a9, 1
4037c6cd:	839660        	moveqz	a9, a6, a6
4037c6d0:	180c      	movi.n	a8, 1
4037c6d2:	838770        	moveqz	a8, a7, a7
4037c6d5:	3b0987        	bnone	a9, a8, 4037c714 <xTaskCreateStaticPinnedToCore+0xdc>
            {
                /* The memory used for the task's TCB and stack are passed into this
                 * function - use them. */
                pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
                memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
4037c6d8:	54a1c2        	movi	a12, 0x154
4037c6db:	0b0c      	movi.n	a11, 0
4037c6dd:	20a660        	or	a10, a6, a6
4037c6e0:	df6c81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037c6e3:	0008e0        	callx8	a8
                pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
4037c6e6:	c679      	s32i.n	a7, a6, 48

                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
                {
                    /* Tasks can be created statically or dynamically, so note this
                     * task was created statically in case the task is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
4037c6e8:	01d682        	addmi	a8, a6, 0x100
4037c6eb:	290c      	movi.n	a9, 2
4037c6ed:	514892        	s8i	a9, a8, 81
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL, xCoreID );
4037c6f0:	152182        	l32i	a8, a1, 84
4037c6f3:	2189      	s32i.n	a8, a1, 8
4037c6f5:	080c      	movi.n	a8, 0
4037c6f7:	1189      	s32i.n	a8, a1, 4
4037c6f9:	0169      	s32i.n	a6, a1, 0
4037c6fb:	10c1f2        	addi	a15, a1, 16
4037c6fe:	81e8      	l32i.n	a14, a1, 32
4037c700:	05dd      	mov.n	a13, a5
4037c702:	04cd      	mov.n	a12, a4
4037c704:	03bd      	mov.n	a11, a3
4037c706:	02ad      	mov.n	a10, a2
4037c708:	fe7f25        	call8	4037aefc <prvInitialiseNewTask>
                prvAddNewTaskToReadyList( pxNewTCB );
4037c70b:	06ad      	mov.n	a10, a6
4037c70d:	fe8f65        	call8	4037b004 <prvAddNewTaskToReadyList>
4037c710:	000106        	j	4037c718 <xTaskCreateStaticPinnedToCore+0xe0>
4037c713:	080c00        	lsx	f0, a12, a0
            }
            else
            {
                xReturn = NULL;
4037c716:	4189      	s32i.n	a8, a1, 16
            }
        }
        #endif /* CONFIG_FREERTOS_SMP */

        return xReturn;
    }
4037c718:	4128      	l32i.n	a2, a1, 16
4037c71a:	f01d      	retw.n

4037c71c <prvCreateIdleTasks>:
{
4037c71c:	00a136        	entry	a1, 80
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
4037c71f:	0c1c      	movi.n	a12, 16
4037c721:	0b0c      	movi.n	a11, 0
4037c723:	80a1c0        	add	a10, a1, a12
4037c726:	df5a81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037c729:	0008e0        	callx8	a8
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c72c:	070c      	movi.n	a7, 0
    BaseType_t xReturn = pdPASS;
4037c72e:	120c      	movi.n	a2, 1
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c730:	001a86        	j	4037c79e <prvCreateIdleTasks+0x82>
4037c733:	921600        	lsi	f0, a6, 0x248
            if( xReturn == pdFAIL )
4037c736:	080c06        	j	4037e76a <multi_heap_realloc+0x1e>
            for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < xCopyLen; xIdleTaskNameIndex++ )
4037c739:	0004c6        	j	4037c750 <prvCreateIdleTasks+0x34>
                cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
4037c73c:	e1b991        	l32r	a9, 40374e20 <_iram_text_start+0xa1c> (3c024a24 <_flash_rodata_start+0x4904>)
4037c73f:	809980        	add	a9, a9, a8
4037c742:	0009a2        	l8ui	a10, a9, 0
4037c745:	10c192        	addi	a9, a1, 16
4037c748:	809980        	add	a9, a9, a8
4037c74b:	0049a2        	s8i	a10, a9, 0
            for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < xCopyLen; xIdleTaskNameIndex++ )
4037c74e:	881b      	addi.n	a8, a8, 1
4037c750:	e848a6        	blti	a8, 4, 4037c73c <prvCreateIdleTasks+0x20>
            cIdleName[ xIdleTaskNameIndex ] = ( char ) ( xCoreID + '0' );
4037c753:	30c792        	addi	a9, a7, 48
4037c756:	10c162        	addi	a6, a1, 16
4037c759:	a68a      	add.n	a10, a6, a8
4037c75b:	004a92        	s8i	a9, a10, 0
            cIdleName[ xIdleTaskNameIndex + 1 ] = '\0';
4037c75e:	881b      	addi.n	a8, a8, 1
4037c760:	868a      	add.n	a8, a6, a8
4037c762:	090c      	movi.n	a9, 0
4037c764:	004892        	s8i	a9, a8, 0
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
4037c767:	050c      	movi.n	a5, 0
4037c769:	a159      	s32i.n	a5, a1, 40
            StackType_t * pxIdleTaskStackBuffer = NULL;
4037c76b:	9159      	s32i.n	a5, a1, 36
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
4037c76d:	20c1c2        	addi	a12, a1, 32
4037c770:	24c1b2        	addi	a11, a1, 36
4037c773:	28c1a2        	addi	a10, a1, 40
4037c776:	fdef25        	call8	4037a668 <vApplicationGetIdleTaskMemory>
            xIdleTaskHandle[ xCoreID ] = xTaskCreateStaticPinnedToCore( prvIdleTask,
4037c779:	1179      	s32i.n	a7, a1, 4
4037c77b:	a188      	l32i.n	a8, a1, 40
4037c77d:	0189      	s32i.n	a8, a1, 0
4037c77f:	91f8      	l32i.n	a15, a1, 36
4037c781:	05ed      	mov.n	a14, a5
4037c783:	05dd      	mov.n	a13, a5
4037c785:	81c8      	l32i.n	a12, a1, 32
4037c787:	20b660        	or	a11, a6, a6
4037c78a:	e1a6a1        	l32r	a10, 40374e24 <_iram_text_start+0xa20> (4037aeec <prvIdleTask>)
4037c78d:	ffeaa5        	call8	4037c638 <xTaskCreateStaticPinnedToCore>
4037c790:	e1a681        	l32r	a8, 40374e28 <_iram_text_start+0xa24> (3fc94b18 <xIdleTaskHandle>)
4037c793:	a08780        	addx4	a8, a7, a8
4037c796:	08a9      	s32i.n	a10, a8, 0
            if( xIdleTaskHandle[ xCoreID ] != NULL )
4037c798:	0acc      	bnez.n	a10, 4037c79c <prvCreateIdleTasks+0x80>
                xReturn = pdFAIL;
4037c79a:	052d      	mov.n	a2, a5
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c79c:	771b      	addi.n	a7, a7, 1
4037c79e:	9227a6        	blti	a7, 2, 4037c734 <prvCreateIdleTasks+0x18>
}
4037c7a1:	f01d      	retw.n
	...

4037c7a4 <vTaskStartScheduler>:
{
4037c7a4:	004136        	entry	a1, 32
    xReturn = prvCreateIdleTasks();
4037c7a7:	fff765        	call8	4037c71c <prvCreateIdleTasks>
        if( xReturn == pdPASS )
4037c7aa:	3b1a66        	bnei	a10, 1, 4037c7e9 <vTaskStartScheduler+0x45>
            xReturn = xTimerCreateTimerTask();
4037c7ad:	000725        	call8	4037c820 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
4037c7b0:	351a66        	bnei	a10, 1, 4037c7e9 <vTaskStartScheduler+0x45>
        portDISABLE_INTERRUPTS();
4037c7b3:	006380        	rsil	a8, 3
4037c7b6:	fb7c      	movi.n	a11, -1
4037c7b8:	e147a1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c7bb:	fd9765        	call8	4037a130 <xPortEnterCriticalTimeout>
            xNextTaskUnblockTime = portMAX_DELAY;
4037c7be:	e13881        	l32r	a8, 40374ca0 <_iram_text_start+0x89c> (3fc94b20 <xNextTaskUnblockTime>)
4037c7c1:	f97c      	movi.n	a9, -1
4037c7c3:	0020c0        	memw
4037c7c6:	0899      	s32i.n	a9, a8, 0
            xSchedulerRunning = pdTRUE;
4037c7c8:	e15181        	l32r	a8, 40374d0c <_iram_text_start+0x908> (3fc94b38 <xSchedulerRunning>)
4037c7cb:	190c      	movi.n	a9, 1
4037c7cd:	0020c0        	memw
4037c7d0:	0899      	s32i.n	a9, a8, 0
            xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
4037c7d2:	e14581        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94b40 <xTickCount>)
4037c7d5:	00a092        	movi	a9, 0
4037c7d8:	0020c0        	memw
4037c7db:	0899      	s32i.n	a9, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037c7dd:	e13da1        	l32r	a10, 40374cd4 <_iram_text_start+0x8d0> (3fc91ff8 <xKernelLock>)
4037c7e0:	fda9e5        	call8	4037a280 <vPortExitCritical>
        xPortStartScheduler();
4037c7e3:	fd8665        	call8	4037a048 <xPortStartScheduler>
4037c7e6:	000446        	j	4037c7fb <vTaskStartScheduler+0x57>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
4037c7e9:	0e0a66        	bnei	a10, -1, 4037c7fb <vTaskStartScheduler+0x57>
4037c7ec:	e190d1        	l32r	a13, 40374e2c <_iram_text_start+0xa28> (3c024a2c <_flash_rodata_start+0x490c>)
4037c7ef:	e190c1        	l32r	a12, 40374e30 <_iram_text_start+0xa2c> (3c028184 <__func__$32>)
4037c7f2:	e190b1        	l32r	a11, 40374e34 <_iram_text_start+0xa30> (98b <UserFrameTotalSize+0x88b>)
4037c7f5:	e12da1        	l32r	a10, 40374cac <_iram_text_start+0x8a8> (3c024502 <_flash_rodata_start+0x43e2>)
4037c7f8:	035565        	call8	4037fd50 <__assert_func>
    ( void ) uxTopUsedPriority;
4037c7fb:	e18f81        	l32r	a8, 40374e38 <_iram_text_start+0xa34> (3c0281ec <uxTopUsedPriority>)
4037c7fe:	0020c0        	memw
4037c801:	0888      	l32i.n	a8, a8, 0
}
4037c803:	f01d      	retw.n
4037c805:	000000        	ill

4037c808 <__getreent>:
 * - If FreeRTOS is not running, it will return the global reent struct
 *
 * @return Pointer to a the (current taks's)/(global) reent struct
 */
    struct _reent * __getreent( void )
    {
4037c808:	004136        	entry	a1, 32
        /* No lock needed because if this changes, we won't be running anymore. */
        TCB_t * pxCurTask = ( TCB_t * ) xTaskGetCurrentTaskHandle();
4037c80b:	ff0865        	call8	4037b890 <xTaskGetCurrentTaskHandle>
        struct _reent * ret;

        if( pxCurTask == NULL )
4037c80e:	7a8c      	beqz.n	a10, 4037c819 <__getreent+0x11>
            ret = _GLOBAL_REENT;
        }
        else
        {
            /* We have a currently executing task. Return its reentrant struct. */
            ret = &pxCurTask->xTLSBlock;
4037c810:	5cca22        	addi	a2, a10, 92
4037c813:	000146        	j	4037c81c <__getreent+0x14>
4037c816:	000000        	ill
            ret = _GLOBAL_REENT;
4037c819:	dfd521        	l32r	a2, 40374770 <_iram_text_start+0x36c> (3fc926a4 <_impure_data>)
        }

        return ret;
    }
4037c81c:	f01d      	retw.n
	...

4037c820 <xTimerCreateTimerTask>:
    {
4037c820:	004136        	entry	a1, 32
    }
4037c823:	120c      	movi.n	a2, 1
4037c825:	f01d      	retw.n
	...

4037c828 <s_cache_hal_init_ctx>:

static cache_hal_context_t ctx;


void s_cache_hal_init_ctx(void)
{
4037c828:	004136        	entry	a1, 32
    if (REG_GET_BIT(EXTMEM_DCACHE_AUTOLOAD_CTRL_REG, EXTMEM_DCACHE_AUTOLOAD_ENA)) {
4037c82b:	e18481        	l32r	a8, 40374e3c <_iram_text_start+0xa38> (600c404c <SYSTEM+0x404c>)
4037c82e:	0020c0        	memw
4037c831:	0888      	l32i.n	a8, a8, 0
4037c833:	05e827        	bbsi	a8, 2, 4037c83c <s_cache_hal_init_ctx+0x14>
    bool enabled = false;
4037c836:	090c      	movi.n	a9, 0
4037c838:	000086        	j	4037c83e <s_cache_hal_init_ctx+0x16>
4037c83b:	190c00        	lsi	f0, a12, 100
    ctx.l1.d_autoload_en = cache_ll_is_cache_autoload_enabled(1, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
4037c83e:	e18081        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc9499c <ctx>)
4037c841:	014892        	s8i	a9, a8, 1
    if (REG_GET_BIT(EXTMEM_ICACHE_AUTOLOAD_CTRL_REG, EXTMEM_ICACHE_AUTOLOAD_ENA)) {
4037c844:	e18081        	l32r	a8, 40374e44 <_iram_text_start+0xa40> (600c40a0 <SYSTEM+0x40a0>)
4037c847:	0020c0        	memw
4037c84a:	0888      	l32i.n	a8, a8, 0
4037c84c:	04e827        	bbsi	a8, 2, 4037c854 <s_cache_hal_init_ctx+0x2c>
    bool enabled = false;
4037c84f:	090c      	movi.n	a9, 0
4037c851:	000046        	j	4037c856 <s_cache_hal_init_ctx+0x2e>
        enabled = true;
4037c854:	190c      	movi.n	a9, 1
    ctx.l1.i_autoload_en = cache_ll_is_cache_autoload_enabled(1, CACHE_TYPE_INSTRUCTION, CACHE_LL_ID_ALL);
4037c856:	e17a81        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc9499c <ctx>)
4037c859:	004892        	s8i	a9, a8, 0
    if (REG_GET_BIT(EXTMEM_DCACHE_AUTOLOAD_CTRL_REG, EXTMEM_DCACHE_AUTOLOAD_ENA)) {
4037c85c:	e17881        	l32r	a8, 40374e3c <_iram_text_start+0xa38> (600c404c <SYSTEM+0x404c>)
4037c85f:	0020c0        	memw
4037c862:	0888      	l32i.n	a8, a8, 0
4037c864:	04e827        	bbsi	a8, 2, 4037c86c <s_cache_hal_init_ctx+0x44>
    bool enabled = false;
4037c867:	090c      	movi.n	a9, 0
4037c869:	000046        	j	4037c86e <s_cache_hal_init_ctx+0x46>
        enabled = true;
4037c86c:	190c      	movi.n	a9, 1
    ctx.l2.d_autoload_en = cache_ll_is_cache_autoload_enabled(2, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
4037c86e:	e17481        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc9499c <ctx>)
4037c871:	034892        	s8i	a9, a8, 3
    if (REG_GET_BIT(EXTMEM_ICACHE_AUTOLOAD_CTRL_REG, EXTMEM_ICACHE_AUTOLOAD_ENA)) {
4037c874:	e17481        	l32r	a8, 40374e44 <_iram_text_start+0xa40> (600c40a0 <SYSTEM+0x40a0>)
4037c877:	0020c0        	memw
4037c87a:	0888      	l32i.n	a8, a8, 0
4037c87c:	04e827        	bbsi	a8, 2, 4037c884 <s_cache_hal_init_ctx+0x5c>
    bool enabled = false;
4037c87f:	090c      	movi.n	a9, 0
4037c881:	000046        	j	4037c886 <s_cache_hal_init_ctx+0x5e>
        enabled = true;
4037c884:	190c      	movi.n	a9, 1
    ctx.l2.i_autoload_en = cache_ll_is_cache_autoload_enabled(2, CACHE_TYPE_INSTRUCTION, CACHE_LL_ID_ALL);
4037c886:	e16e81        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc9499c <ctx>)
4037c889:	024892        	s8i	a9, a8, 2
}
4037c88c:	f01d      	retw.n
	...

4037c890 <cache_hal_init>:

void cache_hal_init(void)
{
4037c890:	004136        	entry	a1, 32
    s_cache_hal_init_ctx();
4037c893:	fff965        	call8	4037c828 <s_cache_hal_init_ctx>

    if (CACHE_LL_LEVEL_EXT_MEM == 1) {
        cache_ll_enable_cache(1, CACHE_TYPE_ALL, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037c896:	e16a81        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc9499c <ctx>)
4037c899:	000892        	l8ui	a9, a8, 0
4037c89c:	010872        	l8ui	a7, a8, 1
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c89f:	698c      	beqz.n	a9, 4037c8a9 <cache_hal_init+0x19>
4037c8a1:	4a0c      	movi.n	a10, 4
4037c8a3:	000106        	j	4037c8ab <cache_hal_init+0x1b>
4037c8a6:	000000        	ill
4037c8a9:	0a0c      	movi.n	a10, 0
4037c8ab:	e16781        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (40001878 <Cache_Enable_ICache>)
4037c8ae:	0008e0        	callx8	a8
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c8b1:	378c      	beqz.n	a7, 4037c8b8 <cache_hal_init+0x28>
4037c8b3:	4a0c      	movi.n	a10, 4
4037c8b5:	000046        	j	4037c8ba <cache_hal_init+0x2a>
4037c8b8:	0a0c      	movi.n	a10, 0
4037c8ba:	e16481        	l32r	a8, 40374e4c <_iram_text_start+0xa48> (40001890 <Cache_Enable_DCache>)
4037c8bd:	0008e0        	callx8	a8
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c8c0:	dede91        	l32r	a9, 40374438 <_iram_text_start+0x34> (600c4064 <SYSTEM+0x4064>)
4037c8c3:	0020c0        	memw
4037c8c6:	0988      	l32i.n	a8, a9, 0
4037c8c8:	0020c0        	memw
4037c8cb:	0989      	s32i.n	a8, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c8cd:	dedb81        	l32r	a8, 4037443c <_iram_text_start+0x38> (600c4004 <SYSTEM+0x4004>)
4037c8d0:	0020c0        	memw
4037c8d3:	08a8      	l32i.n	a10, a8, 0
4037c8d5:	db7c      	movi.n	a11, -3
4037c8d7:	10aab0        	and	a10, a10, a11
4037c8da:	0020c0        	memw
4037c8dd:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c8df:	0020c0        	memw
4037c8e2:	09a8      	l32i.n	a10, a9, 0
4037c8e4:	ec7c      	movi.n	a12, -2
4037c8e6:	10aac0        	and	a10, a10, a12
4037c8e9:	0020c0        	memw
4037c8ec:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c8ee:	0020c0        	memw
4037c8f1:	08a8      	l32i.n	a10, a8, 0
4037c8f3:	0020c0        	memw
4037c8f6:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c8f8:	0020c0        	memw
4037c8fb:	09a8      	l32i.n	a10, a9, 0
4037c8fd:	0020c0        	memw
4037c900:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c902:	0020c0        	memw
4037c905:	08a8      	l32i.n	a10, a8, 0
4037c907:	10aac0        	and	a10, a10, a12
4037c90a:	0020c0        	memw
4037c90d:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c90f:	0020c0        	memw
4037c912:	09a8      	l32i.n	a10, a9, 0
4037c914:	10aab0        	and	a10, a10, a11
4037c917:	0020c0        	memw
4037c91a:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c91c:	0020c0        	memw
4037c91f:	0898      	l32i.n	a9, a8, 0
4037c921:	0020c0        	memw
4037c924:	0899      	s32i.n	a9, a8, 0
    ctx.l1.i_cache_enabled = 1;
    ctx.l1.d_cache_enabled = 1;
    ctx.l2.i_cache_enabled = 1;
    ctx.l2.d_cache_enabled = 1;
#endif
}
4037c926:	f01d      	retw.n

4037c928 <cache_hal_disable>:
    return enabled;
}
#endif  //#if CACHE_LL_ENABLE_DISABLE_STATE_SW

void cache_hal_disable(uint32_t cache_level, cache_type_t type)
{
4037c928:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c92b:	0e1226        	beqi	a2, 1, 4037c93d <cache_hal_disable+0x15>
4037c92e:	e148d1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc937b0 <__FUNCTION__$0+0x18>)
4037c931:	e148c1        	l32r	a12, 40374e54 <_iram_text_start+0xa50> (3fc94180 <__func__$9>)
4037c934:	aca0b2        	movi	a11, 172
4037c937:	e148a1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc937e4 <__FUNCTION__$0+0x4c>)
4037c93a:	034165        	call8	4037fd50 <__assert_func>
    switch (type)
4037c93d:	00b316        	beqz	a3, 4037c94c <cache_hal_disable+0x24>
4037c940:	111366        	bnei	a3, 1, 4037c955 <cache_hal_disable+0x2d>
    Cache_Disable_ICache();
4037c943:	df0d81        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
4037c946:	0008e0        	callx8	a8
}
4037c949:	000506        	j	4037c961 <cache_hal_disable+0x39>
    Cache_Disable_DCache();
4037c94c:	df0c81        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
4037c94f:	0008e0        	callx8	a8
}
4037c952:	0002c6        	j	4037c961 <cache_hal_disable+0x39>
    Cache_Disable_ICache();
4037c955:	df0881        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
4037c958:	0008e0        	callx8	a8
    Cache_Disable_DCache();
4037c95b:	df0881        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
4037c95e:	0008e0        	callx8	a8
    cache_ll_disable_cache(cache_level, type, CACHE_LL_ID_ALL);

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, false);
#endif
}
4037c961:	f01d      	retw.n
	...

4037c964 <cache_hal_enable>:

void cache_hal_enable(uint32_t cache_level, cache_type_t type)
{
4037c964:	004136        	entry	a1, 32
4037c967:	20a330        	or	a10, a3, a3
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c96a:	0e1226        	beqi	a2, 1, 4037c97c <cache_hal_enable+0x18>
4037c96d:	e138d1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc937b0 <__FUNCTION__$0+0x18>)
4037c970:	e13bc1        	l32r	a12, 40374e5c <_iram_text_start+0xa58> (3fc9416c <__func__$8>)
4037c973:	b7a0b2        	movi	a11, 183
4037c976:	e138a1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc937e4 <__FUNCTION__$0+0x4c>)
4037c979:	033d65        	call8	4037fd50 <__assert_func>

    if (cache_level == 1) {
        cache_ll_enable_cache(1, type, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037c97c:	e13181        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc9499c <ctx>)
4037c97f:	000892        	l8ui	a9, a8, 0
4037c982:	010832        	l8ui	a3, a8, 1
    switch (type)
4037c985:	017a16        	beqz	a10, 4037c9a0 <cache_hal_enable+0x3c>
4037c988:	211a66        	bnei	a10, 1, 4037c9ad <cache_hal_enable+0x49>
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c98b:	005916        	beqz	a9, 4037c994 <cache_hal_enable+0x30>
4037c98e:	4a0c      	movi.n	a10, 4
4037c990:	000086        	j	4037c996 <cache_hal_enable+0x32>
4037c993:	0a0c00        	add.s	f0, f12, f0
4037c996:	e12c81        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (40001878 <Cache_Enable_ICache>)
4037c999:	0008e0        	callx8	a8
}
4037c99c:	000b06        	j	4037c9cc <cache_hal_enable+0x68>
4037c99f:	038c00        	lsi	f0, a12, 12
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c9a2:	4a0c      	movi.n	a10, 4
4037c9a4:	e12a81        	l32r	a8, 40374e4c <_iram_text_start+0xa48> (40001890 <Cache_Enable_DCache>)
4037c9a7:	0008e0        	callx8	a8
}
4037c9aa:	000786        	j	4037c9cc <cache_hal_enable+0x68>
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c9ad:	398c      	beqz.n	a9, 4037c9b4 <cache_hal_enable+0x50>
4037c9af:	4a0c      	movi.n	a10, 4
4037c9b1:	000046        	j	4037c9b6 <cache_hal_enable+0x52>
4037c9b4:	0a0c      	movi.n	a10, 0
4037c9b6:	e12481        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (40001878 <Cache_Enable_ICache>)
4037c9b9:	0008e0        	callx8	a8
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c9bc:	438c      	beqz.n	a3, 4037c9c4 <cache_hal_enable+0x60>
4037c9be:	4a0c      	movi.n	a10, 4
4037c9c0:	000086        	j	4037c9c6 <cache_hal_enable+0x62>
4037c9c3:	0a0c00        	add.s	f0, f12, f0
4037c9c6:	e12181        	l32r	a8, 40374e4c <_iram_text_start+0xa48> (40001890 <Cache_Enable_DCache>)
4037c9c9:	0008e0        	callx8	a8
    }

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, true);
#endif
}
4037c9cc:	f01d      	retw.n
	...

4037c9d0 <cache_hal_suspend>:

void cache_hal_suspend(uint32_t cache_level, cache_type_t type)
{
4037c9d0:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c9d3:	0e1226        	beqi	a2, 1, 4037c9e5 <cache_hal_suspend+0x15>
4037c9d6:	e11ed1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc937b0 <__FUNCTION__$0+0x18>)
4037c9d9:	e121c1        	l32r	a12, 40374e60 <_iram_text_start+0xa5c> (3fc94158 <__func__$7>)
4037c9dc:	c6a0b2        	movi	a11, 198
4037c9df:	e11ea1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc937e4 <__FUNCTION__$0+0x4c>)
4037c9e2:	0336e5        	call8	4037fd50 <__assert_func>
    switch (type)
4037c9e5:	00b316        	beqz	a3, 4037c9f4 <cache_hal_suspend+0x24>
4037c9e8:	111366        	bnei	a3, 1, 4037c9fd <cache_hal_suspend+0x2d>
    Cache_Suspend_ICache();
4037c9eb:	fcb9a5        	call8	40379584 <Cache_Suspend_ICache>
}
4037c9ee:	000446        	j	4037ca03 <cache_hal_suspend+0x33>
4037c9f1:	000000        	ill
    Cache_Suspend_DCache();
4037c9f4:	fcbaa5        	call8	403795a0 <Cache_Suspend_DCache>
}
4037c9f7:	000206        	j	4037ca03 <cache_hal_suspend+0x33>
4037c9fa:	000000        	ill
    Cache_Suspend_ICache();
4037c9fd:	fcb865        	call8	40379584 <Cache_Suspend_ICache>
    Cache_Suspend_DCache();
4037ca00:	fcb9e5        	call8	403795a0 <Cache_Suspend_DCache>
    cache_ll_suspend_cache(cache_level, type, CACHE_LL_ID_ALL);

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, false);
#endif
}
4037ca03:	f01d      	retw.n
4037ca05:	000000        	ill

4037ca08 <cache_hal_resume>:

void cache_hal_resume(uint32_t cache_level, cache_type_t type)
{
4037ca08:	004136        	entry	a1, 32
4037ca0b:	20a330        	or	a10, a3, a3
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037ca0e:	0e1226        	beqi	a2, 1, 4037ca20 <cache_hal_resume+0x18>
4037ca11:	e10fd1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc937b0 <__FUNCTION__$0+0x18>)
4037ca14:	e114c1        	l32r	a12, 40374e64 <_iram_text_start+0xa60> (3fc94144 <__func__$6>)
4037ca17:	d1a0b2        	movi	a11, 209
4037ca1a:	e10fa1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc937e4 <__FUNCTION__$0+0x4c>)
4037ca1d:	033325        	call8	4037fd50 <__assert_func>

    if (cache_level == 1) {
        cache_ll_resume_cache(1, type, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037ca20:	e10881        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (3fc9499c <ctx>)
4037ca23:	000892        	l8ui	a9, a8, 0
4037ca26:	010832        	l8ui	a3, a8, 1
    switch (type)
4037ca29:	016a16        	beqz	a10, 4037ca43 <cache_hal_resume+0x3b>
4037ca2c:	211a66        	bnei	a10, 1, 4037ca51 <cache_hal_resume+0x49>
    Cache_Resume_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037ca2f:	005916        	beqz	a9, 4037ca38 <cache_hal_resume+0x30>
4037ca32:	4a0c      	movi.n	a10, 4
4037ca34:	000086        	j	4037ca3a <cache_hal_resume+0x32>
4037ca37:	0a0c00        	add.s	f0, f12, f0
4037ca3a:	e10b81        	l32r	a8, 40374e68 <_iram_text_start+0xa64> (400018a8 <Cache_Resume_ICache>)
4037ca3d:	0008e0        	callx8	a8
}
4037ca40:	000b06        	j	4037ca70 <cache_hal_resume+0x68>
    Cache_Resume_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037ca43:	001316        	beqz	a3, 4037ca48 <cache_hal_resume+0x40>
4037ca46:	4a0c      	movi.n	a10, 4
4037ca48:	de9581        	l32r	a8, 4037449c <_iram_text_start+0x98> (400018c0 <Cache_Resume_DCache>)
4037ca4b:	0008e0        	callx8	a8
}
4037ca4e:	000786        	j	4037ca70 <cache_hal_resume+0x68>
    Cache_Resume_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037ca51:	398c      	beqz.n	a9, 4037ca58 <cache_hal_resume+0x50>
4037ca53:	4a0c      	movi.n	a10, 4
4037ca55:	000046        	j	4037ca5a <cache_hal_resume+0x52>
4037ca58:	0a0c      	movi.n	a10, 0
4037ca5a:	e10381        	l32r	a8, 40374e68 <_iram_text_start+0xa64> (400018a8 <Cache_Resume_ICache>)
4037ca5d:	0008e0        	callx8	a8
    Cache_Resume_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037ca60:	438c      	beqz.n	a3, 4037ca68 <cache_hal_resume+0x60>
4037ca62:	4a0c      	movi.n	a10, 4
4037ca64:	000086        	j	4037ca6a <cache_hal_resume+0x62>
4037ca67:	0a0c00        	add.s	f0, f12, f0
4037ca6a:	de8c81        	l32r	a8, 4037449c <_iram_text_start+0x98> (400018c0 <Cache_Resume_DCache>)
4037ca6d:	0008e0        	callx8	a8
    }

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, true);
#endif
}
4037ca70:	f01d      	retw.n
	...

4037ca74 <cache_hal_is_cache_enabled>:

bool cache_hal_is_cache_enabled(uint32_t cache_level, cache_type_t type)
{
4037ca74:	004136        	entry	a1, 32
    switch (type)
4037ca77:	538c      	beqz.n	a3, 4037ca80 <cache_hal_is_cache_enabled+0xc>
4037ca79:	131326        	beqi	a3, 1, 4037ca90 <cache_hal_is_cache_enabled+0x1c>
4037ca7c:	000786        	j	4037ca9e <cache_hal_is_cache_enabled+0x2a>
4037ca7f:	fb8100        	f64subc	a0, a1, 0, 0
    return REG_GET_BIT(EXTMEM_DCACHE_CTRL_REG, EXTMEM_DCACHE_ENABLE);
4037ca82:	20c0e0        	or	a12, a0, a14
4037ca85:	082800        	lsx	f2, a8, a0
4037ca88:	042020        	extui	a2, a2, 0, 1
        break;
4037ca8b:	000c46        	j	4037cac0 <cache_hal_is_cache_enabled+0x4c>
4037ca8e:	810000        	src	a0, a0, a0
    return REG_GET_BIT(EXTMEM_ICACHE_CTRL_REG, EXTMEM_ICACHE_ENABLE);
4037ca91:	e0f8      	l32i.n	a15, a0, 56
4037ca93:	0020c0        	memw
4037ca96:	0828      	l32i.n	a2, a8, 0
4037ca98:	042020        	extui	a2, a2, 0, 1
        break;
4037ca9b:	000846        	j	4037cac0 <cache_hal_is_cache_enabled+0x4c>
    return REG_GET_BIT(EXTMEM_DCACHE_CTRL_REG, EXTMEM_DCACHE_ENABLE);
4037ca9e:	e0f381        	l32r	a8, 40374e6c <_iram_text_start+0xa68> (600c4000 <SYSTEM+0x4000>)
4037caa1:	0020c0        	memw
4037caa4:	0888      	l32i.n	a8, a8, 0
        enabled = cache_ll_l1_is_dcache_enabled(0) && cache_ll_l1_is_icache_enabled(0);
4037caa6:	0f6807        	bbci	a8, 0, 4037cab9 <cache_hal_is_cache_enabled+0x45>
    return REG_GET_BIT(EXTMEM_ICACHE_CTRL_REG, EXTMEM_ICACHE_ENABLE);
4037caa9:	e0f181        	l32r	a8, 40374e70 <_iram_text_start+0xa6c> (600c4060 <SYSTEM+0x4060>)
4037caac:	0020c0        	memw
4037caaf:	0888      	l32i.n	a8, a8, 0
        enabled = cache_ll_l1_is_dcache_enabled(0) && cache_ll_l1_is_icache_enabled(0);
4037cab1:	096807        	bbci	a8, 0, 4037cabe <cache_hal_is_cache_enabled+0x4a>
4037cab4:	120c      	movi.n	a2, 1
4037cab6:	000186        	j	4037cac0 <cache_hal_is_cache_enabled+0x4c>
4037cab9:	020c      	movi.n	a2, 0
4037cabb:	000046        	j	4037cac0 <cache_hal_is_cache_enabled+0x4c>
4037cabe:	020c      	movi.n	a2, 0
    enabled = s_get_cache_state(cache_level, type);
#else
    enabled = cache_ll_is_cache_enabled(type);
#endif //CACHE_LL_ENABLE_DISABLE_STATE_SW
    return enabled;
}
4037cac0:	f01d      	retw.n
	...

4037cac4 <cache_hal_vaddr_to_cache_level_id>:

bool cache_hal_vaddr_to_cache_level_id(uint32_t vaddr_start, uint32_t len, uint32_t *out_level, uint32_t *out_id)
{
4037cac4:	004136        	entry	a1, 32
    if (!out_level || !out_id) {
4037cac7:	40f480        	nsau	a8, a4
4037caca:	418580        	srli	a8, a8, 5
4037cacd:	40f590        	nsau	a9, a5
4037cad0:	419590        	srli	a9, a9, 5
4037cad3:	208890        	or	a8, a8, a9
4037cad6:	054856        	bnez	a8, 4037cb2e <cache_hal_vaddr_to_cache_level_id+0x6a>
 */
__attribute__((always_inline))
static inline bool cache_ll_vaddr_to_cache_level_id(uint32_t vaddr_start, uint32_t len, uint32_t *out_level, uint32_t *out_id)
{
    bool valid = false;
    uint32_t vaddr_end = vaddr_start + len - 1;
4037cad9:	323a      	add.n	a3, a2, a3

    valid |= (SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_end));
4037cadb:	e03781        	l32r	a8, 40374bb8 <_iram_text_start+0x7b4> (be000000 <_rtc_reserved_end+0x5df00000>)
4037cade:	828a      	add.n	a8, a2, a8
4037cae0:	dec791        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cae3:	0c3987        	bltu	a9, a8, 4037caf3 <cache_hal_vaddr_to_cache_level_id+0x2f>
4037cae6:	e0e381        	l32r	a8, 40374e74 <_iram_text_start+0xa70> (bdffffff <_rtc_reserved_end+0x5defffff>)
4037cae9:	838a      	add.n	a8, a3, a8
4037caeb:	09b987        	bgeu	a9, a8, 4037caf8 <cache_hal_vaddr_to_cache_level_id+0x34>
4037caee:	080c      	movi.n	a8, 0
4037caf0:	000186        	j	4037cafa <cache_hal_vaddr_to_cache_level_id+0x36>
4037caf3:	080c      	movi.n	a8, 0
4037caf5:	000046        	j	4037cafa <cache_hal_vaddr_to_cache_level_id+0x36>
4037caf8:	180c      	movi.n	a8, 1
    valid |= (SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_end));
4037cafa:	e0df91        	l32r	a9, 40374e78 <_iram_text_start+0xa74> (c4000000 <_rtc_reserved_end+0x63f00000>)
4037cafd:	229a      	add.n	a2, a2, a9
4037caff:	debf91        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cb02:	0f3927        	bltu	a9, a2, 4037cb15 <cache_hal_vaddr_to_cache_level_id+0x51>
4037cb05:	e0dd91        	l32r	a9, 40374e7c <_iram_text_start+0xa78> (c3ffffff <_rtc_reserved_end+0x63efffff>)
4037cb08:	339a      	add.n	a3, a3, a9
4037cb0a:	debc91        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cb0d:	09b937        	bgeu	a9, a3, 4037cb1a <cache_hal_vaddr_to_cache_level_id+0x56>
4037cb10:	090c      	movi.n	a9, 0
4037cb12:	000186        	j	4037cb1c <cache_hal_vaddr_to_cache_level_id+0x58>
4037cb15:	090c      	movi.n	a9, 0
4037cb17:	000046        	j	4037cb1c <cache_hal_vaddr_to_cache_level_id+0x58>
4037cb1a:	190c      	movi.n	a9, 1
4037cb1c:	208890        	or	a8, a8, a9
4037cb1f:	082d      	mov.n	a2, a8

    if (valid) {
4037cb21:	b88c      	beqz.n	a8, 4037cb30 <cache_hal_vaddr_to_cache_level_id+0x6c>
        *out_level = 1;
4037cb23:	180c      	movi.n	a8, 1
4037cb25:	0489      	s32i.n	a8, a4, 0
        *out_id = 0;
4037cb27:	080c      	movi.n	a8, 0
4037cb29:	0589      	s32i.n	a8, a5, 0
4037cb2b:	000046        	j	4037cb30 <cache_hal_vaddr_to_cache_level_id+0x6c>
        return false;
4037cb2e:	020c      	movi.n	a2, 0
    }
    return cache_ll_vaddr_to_cache_level_id(vaddr_start, len, out_level, out_id);
}
4037cb30:	f01d      	retw.n
	...

4037cb34 <cache_hal_invalidate_addr>:

bool cache_hal_invalidate_addr(uint32_t vaddr, uint32_t size)
{
4037cb34:	006136        	entry	a1, 48
4037cb37:	027d      	mov.n	a7, a2
    bool valid = false;
    uint32_t cache_level = 0;
4037cb39:	080c      	movi.n	a8, 0
4037cb3b:	0189      	s32i.n	a8, a1, 0
    uint32_t cache_id = 0;
4037cb3d:	1189      	s32i.n	a8, a1, 4

    valid = cache_hal_vaddr_to_cache_level_id(vaddr, size, &cache_level, &cache_id);
4037cb3f:	d14b      	addi.n	a13, a1, 4
4037cb41:	01cd      	mov.n	a12, a1
4037cb43:	03bd      	mov.n	a11, a3
4037cb45:	02ad      	mov.n	a10, a2
4037cb47:	fff7e5        	call8	4037cac4 <cache_hal_vaddr_to_cache_level_id>
4037cb4a:	0a2d      	mov.n	a2, a10
    if (valid) {
4037cb4c:	8a8c      	beqz.n	a10, 4037cb58 <cache_hal_invalidate_addr+0x24>
    Cache_Invalidate_Addr(vaddr, size);
4037cb4e:	03bd      	mov.n	a11, a3
4037cb50:	07ad      	mov.n	a10, a7
4037cb52:	e0cb81        	l32r	a8, 40374e80 <_iram_text_start+0xa7c> (400016b0 <Cache_Invalidate_Addr>)
4037cb55:	0008e0        	callx8	a8
        cache_ll_invalidate_addr(cache_level, CACHE_TYPE_ALL, cache_id, vaddr, size);
    }

    return valid;
}
4037cb58:	f01d      	retw.n
	...

4037cb5c <cache_hal_freeze>:
}
#endif  //#if SOC_CACHE_WRITEBACK_SUPPORTED

#if SOC_CACHE_FREEZE_SUPPORTED
void cache_hal_freeze(uint32_t cache_level, cache_type_t type)
{
4037cb5c:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037cb5f:	0e1226        	beqi	a2, 1, 4037cb71 <cache_hal_freeze+0x15>
4037cb62:	e0bbd1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc937b0 <__FUNCTION__$0+0x18>)
4037cb65:	e0c7c1        	l32r	a12, 40374e84 <_iram_text_start+0xa80> (3fc94130 <__func__$3>)
4037cb68:	12a1b2        	movi	a11, 0x112
4037cb6b:	e0bba1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc937e4 <__FUNCTION__$0+0x4c>)
4037cb6e:	031e25        	call8	4037fd50 <__assert_func>
    switch (type)
4037cb71:	00b316        	beqz	a3, 4037cb80 <cache_hal_freeze+0x24>
4037cb74:	101366        	bnei	a3, 1, 4037cb88 <cache_hal_freeze+0x2c>
    Cache_Freeze_ICache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb77:	00a0a2        	movi	a10, 0
4037cb7a:	fca4a5        	call8	403795c4 <Cache_Freeze_ICache_Enable>
}
4037cb7d:	0004c6        	j	4037cb94 <cache_hal_freeze+0x38>
    Cache_Freeze_DCache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb80:	0a0c      	movi.n	a10, 0
4037cb82:	fca5e5        	call8	403795e0 <Cache_Freeze_DCache_Enable>
}
4037cb85:	0002c6        	j	4037cb94 <cache_hal_freeze+0x38>
    Cache_Freeze_ICache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb88:	00a0a2        	movi	a10, 0
4037cb8b:	fca3a5        	call8	403795c4 <Cache_Freeze_ICache_Enable>
    Cache_Freeze_DCache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb8e:	00a0a2        	movi	a10, 0
4037cb91:	fca4e5        	call8	403795e0 <Cache_Freeze_DCache_Enable>

    cache_ll_freeze_cache(cache_level, type, CACHE_LL_ID_ALL);
}
4037cb94:	f01d      	retw.n
	...

4037cb98 <cache_hal_unfreeze>:

void cache_hal_unfreeze(uint32_t cache_level, cache_type_t type)
{
4037cb98:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037cb9b:	0e1226        	beqi	a2, 1, 4037cbad <cache_hal_unfreeze+0x15>
4037cb9e:	e0acd1        	l32r	a13, 40374e50 <_iram_text_start+0xa4c> (3fc937b0 <__FUNCTION__$0+0x18>)
4037cba1:	e0b9c1        	l32r	a12, 40374e88 <_iram_text_start+0xa84> (3fc9411c <__func__$2>)
4037cba4:	19a1b2        	movi	a11, 0x119
4037cba7:	e0aca1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc937e4 <__FUNCTION__$0+0x4c>)
4037cbaa:	031a65        	call8	4037fd50 <__assert_func>
    switch (type)
4037cbad:	d38c      	beqz.n	a3, 4037cbbe <cache_hal_unfreeze+0x26>
4037cbaf:	151366        	bnei	a3, 1, 4037cbc8 <cache_hal_unfreeze+0x30>
    Cache_Freeze_ICache_Disable();
4037cbb2:	e0b681        	l32r	a8, 40374e8c <_iram_text_start+0xa88> (400018f0 <Cache_Freeze_ICache_Disable>)
4037cbb5:	0008e0        	callx8	a8
}
4037cbb8:	000606        	j	4037cbd4 <cache_hal_unfreeze+0x3c>
4037cbbb:	000000        	ill
    Cache_Freeze_DCache_Disable();
4037cbbe:	e0b481        	l32r	a8, 40374e90 <_iram_text_start+0xa8c> (40001908 <Cache_Freeze_DCache_Disable>)
4037cbc1:	0008e0        	callx8	a8
}
4037cbc4:	000306        	j	4037cbd4 <cache_hal_unfreeze+0x3c>
4037cbc7:	b18100        	lsi	f0, a1, 0x2c4
    Cache_Freeze_ICache_Disable();
4037cbca:	08e0e0        	lsx	f14, a0, a14
4037cbcd:	b08100        	addx8	a8, a1, a0
    Cache_Freeze_DCache_Disable();
4037cbd0:	08e0e0        	lsx	f14, a0, a14
4037cbd3:	f01d00        	subx8	a1, a13, a0
	...

4037cbd8 <cache_hal_get_cache_line_size>:
    cache_ll_unfreeze_cache(cache_level, type, CACHE_LL_ID_ALL);
}
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

uint32_t cache_hal_get_cache_line_size(uint32_t cache_level, cache_type_t type)
{
4037cbd8:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level <= CACHE_LL_LEVEL_NUMS);
4037cbdb:	01a082        	movi	a8, 1
4037cbde:	0eb827        	bgeu	a8, a2, 4037cbf0 <cache_hal_get_cache_line_size+0x18>
4037cbe1:	e0acd1        	l32r	a13, 40374e94 <_iram_text_start+0xa90> (3fc93804 <__FUNCTION__$0+0x6c>)
4037cbe4:	e0adc1        	l32r	a12, 40374e98 <_iram_text_start+0xa94> (3fc940fc <__func__$1>)
4037cbe7:	21a1b2        	movi	a11, 0x121
4037cbea:	e09ba1        	l32r	a10, 40374e58 <_iram_text_start+0xa54> (3fc937e4 <__FUNCTION__$0+0x4c>)
4037cbed:	031625        	call8	4037fd50 <__assert_func>
    uint32_t line_size = 0;

#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE
    line_size = cache_ll_get_line_size(cache_level, type, CACHE_LL_ID_ALL);
#else
    if (cache_level == CACHE_LL_LEVEL_EXT_MEM) {
4037cbf0:	2b1266        	bnei	a2, 1, 4037cc1f <cache_hal_get_cache_line_size+0x47>
    switch (type)
4037cbf3:	00e316        	beqz	a3, 4037cc05 <cache_hal_get_cache_line_size+0x2d>
4037cbf6:	161366        	bnei	a3, 1, 4037cc10 <cache_hal_get_cache_line_size+0x38>
    size = Cache_Get_ICache_Line_Size();
4037cbf9:	e0ab81        	l32r	a8, 40374ea8 <_iram_text_start+0xaa4> (400015fc <Cache_Get_ICache_Line_Size>)
4037cbfc:	0008e0        	callx8	a8
4037cbff:	202aa0        	or	a2, a10, a10
        break;
4037cc02:	0006c6        	j	4037cc21 <cache_hal_get_cache_line_size+0x49>
    size = Cache_Get_DCache_Line_Size();
4037cc05:	e0a981        	l32r	a8, 40374eac <_iram_text_start+0xaa8> (40001608 <Cache_Get_DCache_Line_Size>)
4037cc08:	0008e0        	callx8	a8
4037cc0b:	0a2d      	mov.n	a2, a10
        break;
4037cc0d:	000406        	j	4037cc21 <cache_hal_get_cache_line_size+0x49>
        HAL_ASSERT(false);
4037cc10:	e0a3d1        	l32r	a13, 40374e9c <_iram_text_start+0xa98> (3fc9382c <__FUNCTION__$0+0x94>)
4037cc13:	e0a3c1        	l32r	a12, 40374ea0 <_iram_text_start+0xa9c> (3fc940e4 <__func__$0>)
4037cc16:	1ca2b2        	movi	a11, 0x21c
4037cc19:	e0a2a1        	l32r	a10, 40374ea4 <_iram_text_start+0xaa0> (3fc93834 <__FUNCTION__$0+0x9c>)
4037cc1c:	031325        	call8	4037fd50 <__assert_func>
    uint32_t line_size = 0;
4037cc1f:	020c      	movi.n	a2, 0
        line_size = cache_ll_get_line_size(cache_level, type, CACHE_LL_ID_ALL);
    }
#endif

    return line_size;
}
4037cc21:	f01d      	retw.n
	...

4037cc24 <mmu_ll_check_entry_valid>:
 * @param entry_id MMU entry ID
 *
 * @return         True for MMU entry is valid; False for invalid
 */
static inline bool mmu_ll_check_entry_valid(uint32_t mmu_id, uint32_t entry_id)
{
4037cc24:	004136        	entry	a1, 32
    (void)mmu_id;
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cc27:	ffa182        	movi	a8, 0x1ff
4037cc2a:	0eb837        	bgeu	a8, a3, 4037cc3c <mmu_ll_check_entry_valid+0x18>
4037cc2d:	e0a0d1        	l32r	a13, 40374eb0 <_iram_text_start+0xaac> (3fc93e34 <__FUNCTION__$0+0x69c>)
4037cc30:	e0a1c1        	l32r	a12, 40374eb4 <_iram_text_start+0xab0> (3fc941e4 <__func__$3>)
4037cc33:	f0a0b2        	movi	a11, 240
4037cc36:	e0a0a1        	l32r	a10, 40374eb8 <_iram_text_start+0xab4> (3fc93e54 <__FUNCTION__$0+0x6bc>)
4037cc39:	031165        	call8	4037fd50 <__assert_func>

    return (*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) & SOC_MMU_INVALID) ? false : true;
4037cc3c:	e0a081        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037cc3f:	803380        	add	a3, a3, a8
4037cc42:	1133e0        	slli	a3, a3, 2
4037cc45:	002322        	l32i	a2, a3, 0
4037cc48:	042e20        	extui	a2, a2, 14, 1
4037cc4b:	112220        	slli	a2, a2, 14
}
4037cc4e:	40f220        	nsau	a2, a2
4037cc51:	412520        	srli	a2, a2, 5
4037cc54:	000090        	retw
	...

4037cc58 <mmu_ll_get_entry_target>:
 * @param entry_id MMU entry ID
 *
 * @return         Target, see `mmu_target_t`
 */
static inline mmu_target_t mmu_ll_get_entry_target(uint32_t mmu_id, uint32_t entry_id)
{
4037cc58:	004136        	entry	a1, 32
    (void)mmu_id;
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cc5b:	ffa182        	movi	a8, 0x1ff
4037cc5e:	0eb837        	bgeu	a8, a3, 4037cc70 <mmu_ll_get_entry_target+0x18>
4037cc61:	e093d1        	l32r	a13, 40374eb0 <_iram_text_start+0xaac> (3fc93e34 <__FUNCTION__$0+0x69c>)
4037cc64:	e097c1        	l32r	a12, 40374ec0 <_iram_text_start+0xabc> (3fc941cc <__func__$2>)
4037cc67:	00a1b2        	movi	a11, 0x100
4037cc6a:	e093a1        	l32r	a10, 40374eb8 <_iram_text_start+0xab4> (3fc93e54 <__FUNCTION__$0+0x6bc>)
4037cc6d:	030e25        	call8	4037fd50 <__assert_func>

    bool target_code = (*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4)) & SOC_MMU_TYPE;
4037cc70:	e09381        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037cc73:	803380        	add	a3, a3, a8
4037cc76:	1133e0        	slli	a3, a3, 2
4037cc79:	002382        	l32i	a8, a3, 0
    return (target_code == SOC_MMU_ACCESS_FLASH) ? MMU_TARGET_FLASH0 : MMU_TARGET_PSRAM0;
4037cc7c:	05e8f7        	bbsi	a8, 15, 4037cc85 <mmu_ll_get_entry_target+0x2d>
4037cc7f:	01a022        	movi	a2, 1
4037cc82:	000046        	j	4037cc87 <mmu_ll_get_entry_target+0x2f>
4037cc85:	220c      	movi.n	a2, 2
}
4037cc87:	f01d      	retw.n
4037cc89:	000000        	ill

4037cc8c <mmu_ll_find_entry_id_based_on_map_value>:
 * @param target   physical memory target, see `mmu_target_t`
 *
 * @return         MMU entry ID, -1 for invalid
 */
static inline int mmu_ll_find_entry_id_based_on_map_value(uint32_t mmu_id, uint32_t mmu_val, mmu_target_t target)
{
4037cc8c:	004136        	entry	a1, 32
4037cc8f:	027d      	mov.n	a7, a2
    (void)mmu_id;
    for (int i = 0; i < SOC_MMU_ENTRY_NUM; i++) {
4037cc91:	020c      	movi.n	a2, 0
4037cc93:	0009c6        	j	4037ccbe <mmu_ll_find_entry_id_based_on_map_value+0x32>
        if (mmu_ll_check_entry_valid(mmu_id, i)) {
4037cc96:	20b220        	or	a11, a2, a2
4037cc99:	20a770        	or	a10, a7, a7
4037cc9c:	fff865        	call8	4037cc24 <mmu_ll_check_entry_valid>
4037cc9f:	019a16        	beqz	a10, 4037ccbc <mmu_ll_find_entry_id_based_on_map_value+0x30>
            if (mmu_ll_get_entry_target(mmu_id, i) == target) {
4037cca2:	02bd      	mov.n	a11, a2
4037cca4:	07ad      	mov.n	a10, a7
4037cca6:	fffb25        	call8	4037cc58 <mmu_ll_get_entry_target>
4037cca9:	0f9a47        	bne	a10, a4, 4037ccbc <mmu_ll_find_entry_id_based_on_map_value+0x30>
                if (((*(uint32_t *)(DR_REG_MMU_TABLE + i * 4)) & SOC_MMU_VALID_VAL_MASK) == mmu_val) {
4037ccac:	e08481        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037ccaf:	828a      	add.n	a8, a2, a8
4037ccb1:	1188e0        	slli	a8, a8, 2
4037ccb4:	0888      	l32i.n	a8, a8, 0
4037ccb6:	d48080        	extui	a8, a8, 0, 14
4037ccb9:	091837        	beq	a8, a3, 4037ccc6 <mmu_ll_find_entry_id_based_on_map_value+0x3a>
    for (int i = 0; i < SOC_MMU_ENTRY_NUM; i++) {
4037ccbc:	221b      	addi.n	a2, a2, 1
4037ccbe:	ffa182        	movi	a8, 0x1ff
4037ccc1:	d1a827        	bge	a8, a2, 4037cc96 <mmu_ll_find_entry_id_based_on_map_value+0xa>
                }
            }
        }
    }

    return -1;
4037ccc4:	f27c      	movi.n	a2, -1
}
4037ccc6:	f01d      	retw.n

4037ccc8 <mmu_ll_entry_id_to_paddr_base>:
{
4037ccc8:	004136        	entry	a1, 32
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cccb:	ffa182        	movi	a8, 0x1ff
4037ccce:	0eb837        	bgeu	a8, a3, 4037cce0 <mmu_ll_entry_id_to_paddr_base+0x18>
4037ccd1:	e077d1        	l32r	a13, 40374eb0 <_iram_text_start+0xaac> (3fc93e34 <__FUNCTION__$0+0x69c>)
4037ccd4:	e07cc1        	l32r	a12, 40374ec4 <_iram_text_start+0xac0> (3fc941ac <__func__$1>)
4037ccd7:	11a1b2        	movi	a11, 0x111
4037ccda:	e077a1        	l32r	a10, 40374eb8 <_iram_text_start+0xab4> (3fc93e54 <__FUNCTION__$0+0x6bc>)
4037ccdd:	030725        	call8	4037fd50 <__assert_func>
    return ((*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4)) & SOC_MMU_VALID_VAL_MASK) << 16;
4037cce0:	e07781        	l32r	a8, 40374ebc <_iram_text_start+0xab8> (18031400 <UserFrameTotalSize+0x18031300>)
4037cce3:	803380        	add	a3, a3, a8
4037cce6:	1133e0        	slli	a3, a3, 2
4037cce9:	002322        	l32i	a2, a3, 0
4037ccec:	112200        	slli	a2, a2, 16
}
4037ccef:	d52020        	extui	a2, a2, 16, 14
4037ccf2:	112200        	slli	a2, a2, 16
4037ccf5:	000090        	retw

4037ccf8 <mmu_hal_paddr_to_vaddr>:

    return true;
}

bool mmu_hal_paddr_to_vaddr(uint32_t mmu_id, uint32_t paddr, mmu_target_t target, mmu_vaddr_t type, uint32_t *out_vaddr)
{
4037ccf8:	004136        	entry	a1, 32
4037ccfb:	20c440        	or	a12, a4, a4
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037ccfe:	e07281        	l32r	a8, 40374ec8 <_iram_text_start+0xac4> (3fffffff <ets_rom_layout_p+0xe0003>)
4037cd01:	0eb837        	bgeu	a8, a3, 4037cd13 <mmu_hal_paddr_to_vaddr+0x1b>
    HAL_ASSERT(mmu_ll_check_valid_paddr_region(mmu_id, paddr, 1));
4037cd04:	e072d1        	l32r	a13, 40374ecc <_iram_text_start+0xac8> (3fc93e88 <__FUNCTION__$0+0x6f0>)
4037cd07:	e072c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc> (3fc94194 <__func__$0>)
4037cd0a:	8da0b2        	movi	a11, 141
4037cd0d:	e071a1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037cd10:	0303e5        	call8	4037fd50 <__assert_func>

    uint32_t mmu_val = mmu_ll_format_paddr(mmu_id, paddr, target);
    int entry_id = mmu_ll_find_entry_id_based_on_map_value(mmu_id, mmu_val, target);
4037cd13:	f5b030        	extui	a11, a3, 16, 16
4037cd16:	20a220        	or	a10, a2, a2
4037cd19:	fff725        	call8	4037cc8c <mmu_ll_find_entry_id_based_on_map_value>
4037cd1c:	0a7d      	mov.n	a7, a10
    if (entry_id == -1) {
4037cd1e:	2a0a26        	beqi	a10, -1, 4037cd4c <mmu_hal_paddr_to_vaddr+0x54>
        return false;
    }

    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037cd21:	1b0c      	movi.n	a11, 1
4037cd23:	02ad      	mov.n	a10, a2
4037cd25:	001fa5        	call8	4037cf20 <mmu_hal_pages_to_bytes>
    uint32_t offset = paddr % page_size_in_bytes;
4037cd28:	e233a0        	remu	a3, a3, a10
 * @param type     virtual address type, could be instruction type or data type. See `mmu_vaddr_t`
 */
static inline uint32_t mmu_ll_entry_id_to_vaddr_base(uint32_t mmu_id, uint32_t entry_id, mmu_vaddr_t type)
{
    (void)mmu_id;
    uint32_t laddr = entry_id << 16;
4037cd2b:	117700        	slli	a7, a7, 16
    if (vaddr_type == MMU_VADDR_DATA) {
4037cd2e:	0a1526        	beqi	a5, 1, 4037cd3c <mmu_hal_paddr_to_vaddr+0x44>
    return vaddr_base | laddr;
4037cd31:	e06981        	l32r	a8, 40374ed8 <_iram_text_start+0xad4> (42000000 <_coredump_iram_end+0x1c7e100>)
4037cd34:	207780        	or	a7, a7, a8
    uint32_t vaddr_base = mmu_ll_entry_id_to_vaddr_base(mmu_id, entry_id, type);
    if (vaddr_base == 0) {
4037cd37:	0001c6        	j	4037cd42 <mmu_hal_paddr_to_vaddr+0x4a>
4037cd3a:	810000        	src	a0, a0, a0
4037cd3d:	e068      	l32i.n	a6, a0, 56
4037cd3f:	207780        	or	a7, a7, a8
        return false;
    }
    *out_vaddr = vaddr_base | offset;
4037cd42:	203370        	or	a3, a3, a7
4037cd45:	0639      	s32i.n	a3, a6, 0

    return true;
4037cd47:	120c      	movi.n	a2, 1
4037cd49:	000046        	j	4037cd4e <mmu_hal_paddr_to_vaddr+0x56>
        return false;
4037cd4c:	020c      	movi.n	a2, 0
}
4037cd4e:	f01d      	retw.n

4037cd50 <mmu_hal_check_valid_ext_vaddr_region>:

bool mmu_hal_check_valid_ext_vaddr_region(uint32_t mmu_id, uint32_t vaddr_start, uint32_t len, mmu_vaddr_t type)
{
4037cd50:	004136        	entry	a1, 32
    uint32_t vaddr_end = vaddr_start + len - 1;
4037cd53:	434a      	add.n	a4, a3, a4
    if (type & MMU_VADDR_INSTRUCTION) {
4037cd55:	216517        	bbci	a5, 1, 4037cd7a <mmu_hal_check_valid_ext_vaddr_region+0x2a>
        valid |= (SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_end));
4037cd58:	df9881        	l32r	a8, 40374bb8 <_iram_text_start+0x7b4> (be000000 <_rtc_reserved_end+0x5df00000>)
4037cd5b:	838a      	add.n	a8, a3, a8
4037cd5d:	de2791        	l32r	a9, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cd60:	0c3987        	bltu	a9, a8, 4037cd70 <mmu_hal_check_valid_ext_vaddr_region+0x20>
4037cd63:	e04481        	l32r	a8, 40374e74 <_iram_text_start+0xa70> (bdffffff <_rtc_reserved_end+0x5defffff>)
4037cd66:	848a      	add.n	a8, a4, a8
4037cd68:	09b987        	bgeu	a9, a8, 4037cd75 <mmu_hal_check_valid_ext_vaddr_region+0x25>
4037cd6b:	020c      	movi.n	a2, 0
4037cd6d:	0002c6        	j	4037cd7c <mmu_hal_check_valid_ext_vaddr_region+0x2c>
4037cd70:	020c      	movi.n	a2, 0
4037cd72:	000186        	j	4037cd7c <mmu_hal_check_valid_ext_vaddr_region+0x2c>
4037cd75:	120c      	movi.n	a2, 1
4037cd77:	000046        	j	4037cd7c <mmu_hal_check_valid_ext_vaddr_region+0x2c>
    bool valid = false;
4037cd7a:	020c      	movi.n	a2, 0
    if (type & MMU_VADDR_DATA) {
4037cd7c:	256507        	bbci	a5, 0, 4037cda5 <mmu_hal_check_valid_ext_vaddr_region+0x55>
        valid |= (SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_end));
4037cd7f:	e03e81        	l32r	a8, 40374e78 <_iram_text_start+0xa74> (c4000000 <_rtc_reserved_end+0x63f00000>)
4037cd82:	338a      	add.n	a3, a3, a8
4037cd84:	de1e81        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cd87:	0f3837        	bltu	a8, a3, 4037cd9a <mmu_hal_check_valid_ext_vaddr_region+0x4a>
4037cd8a:	e03c81        	l32r	a8, 40374e7c <_iram_text_start+0xa78> (c3ffffff <_rtc_reserved_end+0x63efffff>)
4037cd8d:	448a      	add.n	a4, a4, a8
4037cd8f:	de1b81        	l32r	a8, 403745fc <_iram_text_start+0x1f8> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cd92:	0ab847        	bgeu	a8, a4, 4037cda0 <mmu_hal_check_valid_ext_vaddr_region+0x50>
4037cd95:	080c      	movi.n	a8, 0
4037cd97:	0001c6        	j	4037cda2 <mmu_hal_check_valid_ext_vaddr_region+0x52>
4037cd9a:	080c      	movi.n	a8, 0
4037cd9c:	000086        	j	4037cda2 <mmu_hal_check_valid_ext_vaddr_region+0x52>
4037cd9f:	180c00        	lsxp	f0, a12, a0
4037cda2:	202280        	or	a2, a2, a8
    return mmu_ll_check_valid_ext_vaddr_region(mmu_id, vaddr_start, len, type);
}
4037cda5:	f01d      	retw.n
	...

4037cda8 <mmu_hal_map_region>:
{
4037cda8:	006136        	entry	a1, 48
4037cdab:	006172        	s32i	a7, a1, 0
4037cdae:	207660        	or	a7, a6, a6
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037cdb1:	1b0c      	movi.n	a11, 1
4037cdb3:	02ad      	mov.n	a10, a2
4037cdb5:	0016a5        	call8	4037cf20 <mmu_hal_pages_to_bytes>
4037cdb8:	0a6d      	mov.n	a6, a10
    HAL_ASSERT(vaddr % page_size_in_bytes == 0);
4037cdba:	e284a0        	remu	a8, a4, a10
4037cdbd:	c88c      	beqz.n	a8, 4037cdcd <mmu_hal_map_region+0x25>
4037cdbf:	e048d1        	l32r	a13, 40374ee0 <_iram_text_start+0xadc> (3fc93edc <__FUNCTION__$0+0x744>)
4037cdc2:	e048c1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94230 <__func__$7>)
4037cdc5:	4b5c      	movi.n	a11, 84
4037cdc7:	e043a1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037cdca:	02f865        	call8	4037fd50 <__assert_func>
    HAL_ASSERT(paddr % page_size_in_bytes == 0);
4037cdcd:	e285a0        	remu	a8, a5, a10
4037cdd0:	00e816        	beqz	a8, 4037cde2 <mmu_hal_map_region+0x3a>
4037cdd3:	e045d1        	l32r	a13, 40374ee8 <_iram_text_start+0xae4> (3fc93efc <__FUNCTION__$0+0x764>)
4037cdd6:	e043c1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94230 <__func__$7>)
4037cdd9:	55a0b2        	movi	a11, 85
4037cddc:	e03ea1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037cddf:	02f725        	call8	4037fd50 <__assert_func>
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cde2:	e03981        	l32r	a8, 40374ec8 <_iram_text_start+0xac4> (3fffffff <ets_rom_layout_p+0xe0003>)
4037cde5:	1d3857        	bltu	a8, a5, 4037ce06 <mmu_hal_map_region+0x5e>
    return (paddr_start < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cde8:	1a3877        	bltu	a8, a7, 4037ce06 <mmu_hal_map_region+0x5e>
           ((paddr_start + len - 1) < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM));
4037cdeb:	808570        	add	a8, a5, a7
4037cdee:	880b      	addi.n	a8, a8, -1
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cdf0:	e03691        	l32r	a9, 40374ec8 <_iram_text_start+0xac4> (3fffffff <ets_rom_layout_p+0xe0003>)
4037cdf3:	0f3987        	bltu	a9, a8, 4037ce06 <mmu_hal_map_region+0x5e>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037cdf6:	3d0c      	movi.n	a13, 3
4037cdf8:	07cd      	mov.n	a12, a7
4037cdfa:	04bd      	mov.n	a11, a4
4037cdfc:	02ad      	mov.n	a10, a2
4037cdfe:	fff525        	call8	4037cd50 <mmu_hal_check_valid_ext_vaddr_region>
4037ce01:	dadc      	bnez.n	a10, 4037ce22 <mmu_hal_map_region+0x7a>
4037ce03:	000346        	j	4037ce14 <mmu_hal_map_region+0x6c>
    HAL_ASSERT(mmu_ll_check_valid_paddr_region(mmu_id, paddr, len));
4037ce06:	e039d1        	l32r	a13, 40374eec <_iram_text_start+0xae8> (3fc93f1c <__FUNCTION__$0+0x784>)
4037ce09:	e036c1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94230 <__func__$7>)
4037ce0c:	6b5c      	movi.n	a11, 86
4037ce0e:	e031a1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037ce11:	02f3e5        	call8	4037fd50 <__assert_func>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ce14:	e037d1        	l32r	a13, 40374ef0 <_iram_text_start+0xaec> (3fc93f50 <__FUNCTION__$0+0x7b8>)
4037ce17:	e033c1        	l32r	a12, 40374ee4 <_iram_text_start+0xae0> (3fc94230 <__func__$7>)
4037ce1a:	7b5c      	movi.n	a11, 87
4037ce1c:	e02ea1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037ce1f:	02f325        	call8	4037fd50 <__assert_func>
    uint32_t page_num = (len + page_size_in_bytes - 1) / page_size_in_bytes;
4037ce22:	767a      	add.n	a7, a6, a7
4037ce24:	ffc772        	addi	a7, a7, -1
4037ce27:	c27760        	quou	a7, a7, a6
    *out_len = mmu_hal_pages_to_bytes(mmu_id, page_num);
4037ce2a:	20b770        	or	a11, a7, a7
4037ce2d:	02ad      	mov.n	a10, a2
4037ce2f:	000f25        	call8	4037cf20 <mmu_hal_pages_to_bytes>
4037ce32:	0188      	l32i.n	a8, a1, 0
4037ce34:	08a9      	s32i.n	a10, a8, 0
    return paddr >> 16;
4037ce36:	f55050        	extui	a5, a5, 16, 16
    while (page_num) {
4037ce39:	000846        	j	4037ce5e <mmu_hal_map_region+0xb6>
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037ce3c:	858040        	extui	a8, a4, 16, 9
    uint32_t target_code = (target == MMU_TARGET_FLASH0) ? SOC_MMU_ACCESS_FLASH : SOC_MMU_ACCESS_SPIRAM;
4037ce3f:	051366        	bnei	a3, 1, 4037ce48 <mmu_hal_map_region+0xa0>
4037ce42:	090c      	movi.n	a9, 0
4037ce44:	0000c6        	j	4037ce4b <mmu_hal_map_region+0xa3>
4037ce47:	839100        	moveqz	a9, a1, a0
4037ce4a:	a1dd      	lsi	f13, a1, 4
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = mmu_val | target_code | SOC_MMU_VALID;
4037ce4c:	e01c      	movi.n	a0, 30
4037ce4e:	88aa      	add.n	a8, a8, a10
4037ce50:	1188e0        	slli	a8, a8, 2
4037ce53:	209590        	or	a9, a5, a9
4037ce56:	0899      	s32i.n	a9, a8, 0
        vaddr += page_size_in_bytes;
4037ce58:	446a      	add.n	a4, a4, a6
        mmu_val++;
4037ce5a:	551b      	addi.n	a5, a5, 1
        page_num--;
4037ce5c:	770b      	addi.n	a7, a7, -1
    while (page_num) {
4037ce5e:	fda756        	bnez	a7, 4037ce3c <mmu_hal_map_region+0x94>
}
4037ce61:	f01d      	retw.n
	...

4037ce64 <mmu_hal_unmap_region>:
{
4037ce64:	004136        	entry	a1, 32
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037ce67:	01a0b2        	movi	a11, 1
4037ce6a:	20a220        	or	a10, a2, a2
4037ce6d:	000b25        	call8	4037cf20 <mmu_hal_pages_to_bytes>
4037ce70:	0a7d      	mov.n	a7, a10
    HAL_ASSERT(vaddr % page_size_in_bytes == 0);
4037ce72:	e283a0        	remu	a8, a3, a10
4037ce75:	d88c      	beqz.n	a8, 4037ce86 <mmu_hal_unmap_region+0x22>
4037ce77:	e01ad1        	l32r	a13, 40374ee0 <_iram_text_start+0xadc> (3fc93edc <__FUNCTION__$0+0x744>)
4037ce7a:	e01ec1        	l32r	a12, 40374ef4 <_iram_text_start+0xaf0> (3fc94218 <__func__$5>)
4037ce7d:	6ca0b2        	movi	a11, 108
4037ce80:	e015a1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037ce83:	02ece5        	call8	4037fd50 <__assert_func>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ce86:	03a0d2        	movi	a13, 3
4037ce89:	20c440        	or	a12, a4, a4
4037ce8c:	03bd      	mov.n	a11, a3
4037ce8e:	02ad      	mov.n	a10, a2
4037ce90:	ffebe5        	call8	4037cd50 <mmu_hal_check_valid_ext_vaddr_region>
4037ce93:	dacc      	bnez.n	a10, 4037cea4 <mmu_hal_unmap_region+0x40>
4037ce95:	e016d1        	l32r	a13, 40374ef0 <_iram_text_start+0xaec> (3fc93f50 <__FUNCTION__$0+0x7b8>)
4037ce98:	e017c1        	l32r	a12, 40374ef4 <_iram_text_start+0xaf0> (3fc94218 <__func__$5>)
4037ce9b:	6da0b2        	movi	a11, 109
4037ce9e:	e00da1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037cea1:	02eae5        	call8	4037fd50 <__assert_func>
    uint32_t page_num = (len + page_size_in_bytes - 1) / page_size_in_bytes;
4037cea4:	974a      	add.n	a9, a7, a4
4037cea6:	990b      	addi.n	a9, a9, -1
4037cea8:	c29970        	quou	a9, a9, a7
    while (page_num) {
4037ceab:	000546        	j	4037cec4 <mmu_hal_unmap_region+0x60>
4037ceae:	300000        	xor	a0, a0, a0
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037ceb1:	a18580        	lsi	f8, a5, 0x284
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = SOC_MMU_INVALID;
4037ceb4:	aae002        	s32c1i	a0, a0, 0x2a8
4037ceb7:	e088      	l32i.n	a8, a0, 56
4037ceb9:	1188      	l32i.n	a8, a1, 4
4037cebb:	dd65a1        	l32r	a10, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
4037cebe:	08a9      	s32i.n	a10, a8, 0
        vaddr += page_size_in_bytes;
4037cec0:	337a      	add.n	a3, a3, a7
        page_num--;
4037cec2:	990b      	addi.n	a9, a9, -1
    while (page_num) {
4037cec4:	fe8956        	bnez	a9, 4037ceb0 <mmu_hal_unmap_region+0x4c>
}
4037cec7:	f01d      	retw.n
4037cec9:	000000        	ill

4037cecc <mmu_hal_vaddr_to_paddr>:
{
4037cecc:	004136        	entry	a1, 32
4037cecf:	207220        	or	a7, a2, a2
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, 1, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ced2:	03a0d2        	movi	a13, 3
4037ced5:	1c0c      	movi.n	a12, 1
4037ced7:	03bd      	mov.n	a11, a3
4037ced9:	20a220        	or	a10, a2, a2
4037cedc:	ffe725        	call8	4037cd50 <mmu_hal_check_valid_ext_vaddr_region>
4037cedf:	00ea56        	bnez	a10, 4037cef1 <mmu_hal_vaddr_to_paddr+0x25>
4037cee2:	e005d1        	l32r	a13, 40374ef8 <_iram_text_start+0xaf4> (3fc93fb4 <__FUNCTION__$0+0x81c>)
4037cee5:	e005c1        	l32r	a12, 40374efc <_iram_text_start+0xaf8> (3fc94200 <__func__$4>)
4037cee8:	7ba0b2        	movi	a11, 123
4037ceeb:	dffaa1        	l32r	a10, 40374ed4 <_iram_text_start+0xad0> (3fc93ebc <__FUNCTION__$0+0x724>)
4037ceee:	02e625        	call8	4037fd50 <__assert_func>
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037cef1:	856030        	extui	a6, a3, 16, 9
    if (!mmu_ll_check_entry_valid(mmu_id, entry_id)) {
4037cef4:	06bd      	mov.n	a11, a6
4037cef6:	02ad      	mov.n	a10, a2
4037cef8:	ffd2a5        	call8	4037cc24 <mmu_ll_check_entry_valid>
4037cefb:	0a2d      	mov.n	a2, a10
4037cefd:	da9c      	beqz.n	a10, 4037cf1e <mmu_hal_vaddr_to_paddr+0x52>
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037ceff:	1b0c      	movi.n	a11, 1
4037cf01:	07ad      	mov.n	a10, a7
4037cf03:	0001e5        	call8	4037cf20 <mmu_hal_pages_to_bytes>
    uint32_t offset = (uint32_t)vaddr % page_size_in_bytes;
4037cf06:	e233a0        	remu	a3, a3, a10
    *out_target = mmu_ll_get_entry_target(mmu_id, entry_id);
4037cf09:	06bd      	mov.n	a11, a6
4037cf0b:	07ad      	mov.n	a10, a7
4037cf0d:	ffd4a5        	call8	4037cc58 <mmu_ll_get_entry_target>
4037cf10:	05a9      	s32i.n	a10, a5, 0
    uint32_t paddr_base = mmu_ll_entry_id_to_paddr_base(mmu_id, entry_id);
4037cf12:	06bd      	mov.n	a11, a6
4037cf14:	07ad      	mov.n	a10, a7
4037cf16:	ffdb25        	call8	4037ccc8 <mmu_ll_entry_id_to_paddr_base>
    *out_paddr = paddr_base | offset;
4037cf19:	2033a0        	or	a3, a3, a10
4037cf1c:	0439      	s32i.n	a3, a4, 0
}
4037cf1e:	f01d      	retw.n

4037cf20 <mmu_hal_pages_to_bytes>:
{
4037cf20:	004136        	entry	a1, 32
}
4037cf23:	112300        	slli	a2, a3, 16
4037cf26:	f01d      	retw.n

4037cf28 <spi_flash_encrypt_ll_plaintext_save>:
 * @param buffer Buffer to store the input data.
 * @param size Buffer size.
 *
 */
static inline void spi_flash_encrypt_ll_plaintext_save(uint32_t address, const uint32_t* buffer, uint32_t size)
{
4037cf28:	004136        	entry	a1, 32
4037cf2b:	03bd      	mov.n	a11, a3
4037cf2d:	04cd      	mov.n	a12, a4
    uint32_t plaintext_offs = (address % SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX);
4037cf2f:	542020        	extui	a2, a2, 0, 6
    HAL_ASSERT(plaintext_offs + size <= SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX);
4037cf32:	824a      	add.n	a8, a2, a4
4037cf34:	40a092        	movi	a9, 64
4037cf37:	0eb987        	bgeu	a9, a8, 4037cf49 <spi_flash_encrypt_ll_plaintext_save+0x21>
4037cf3a:	dff1d1        	l32r	a13, 40374f00 <_iram_text_start+0xafc> (3fc94014 <__FUNCTION__$0+0x87c>)
4037cf3d:	dff1c1        	l32r	a12, 40374f04 <_iram_text_start+0xb00> (3fc94244 <__func__$0>)
4037cf40:	59a0b2        	movi	a11, 89
4037cf43:	dff1a1        	l32r	a10, 40374f08 <_iram_text_start+0xb04> (3fc94054 <__FUNCTION__$0+0x8bc>)
4037cf46:	02e0a5        	call8	4037fd50 <__assert_func>
    memcpy((void *)(AES_XTS_PLAIN_BASE + plaintext_offs), buffer, size);
4037cf49:	dff0a1        	l32r	a10, 40374f0c <_iram_text_start+0xb08> (600cc000 <SYSTEM+0xc000>)
4037cf4c:	a2aa      	add.n	a10, a2, a10
4037cf4e:	dd6181        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037cf51:	0008e0        	callx8	a8
}
4037cf54:	f01d      	retw.n
	...

4037cf58 <spi_flash_encryption_hal_enable>:

#include "hal/spi_flash_encrypted_ll.h"
#include "soc/soc_caps.h"

void spi_flash_encryption_hal_enable(void)
{
4037cf58:	004136        	entry	a1, 32
    REG_SET_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037cf5b:	dfed91        	l32r	a9, 40374f10 <_iram_text_start+0xb0c> (600c004c <SYSTEM+0x4c>)
4037cf5e:	0020c0        	memw
4037cf61:	0988      	l32i.n	a8, a9, 0
4037cf63:	9a0c      	movi.n	a10, 9
4037cf65:	2088a0        	or	a8, a8, a10
4037cf68:	0020c0        	memw
4037cf6b:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(AES_XTS_DESTINATION_REG, type);
4037cf6d:	dfe981        	l32r	a8, 40374f14 <_iram_text_start+0xb10> (600cc044 <SYSTEM+0xc044>)
4037cf70:	090c      	movi.n	a9, 0
4037cf72:	0020c0        	memw
4037cf75:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_aes_accelerator_enable();
#endif //CONFIG_IDF_TARGET_ESP32S2
#if !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_type(FLASH_ENCRYPTION_MANU);
#endif // !CONFIG_IDF_TARGET_ESP32
}
4037cf77:	f01d      	retw.n
4037cf79:	000000        	ill

4037cf7c <spi_flash_encryption_hal_disable>:

void spi_flash_encryption_hal_disable(void)
{
4037cf7c:	004136        	entry	a1, 32
    REG_CLR_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037cf7f:	dfe491        	l32r	a9, 40374f10 <_iram_text_start+0xb0c> (600c004c <SYSTEM+0x4c>)
4037cf82:	0020c0        	memw
4037cf85:	0988      	l32i.n	a8, a9, 0
4037cf87:	ea7c      	movi.n	a10, -2
4037cf89:	1088a0        	and	a8, a8, a10
4037cf8c:	0020c0        	memw
4037cf8f:	0989      	s32i.n	a8, a9, 0
    spi_flash_encrypt_ll_disable();
}
4037cf91:	f01d      	retw.n
	...

4037cf94 <spi_flash_encryption_hal_prepare>:

void spi_flash_encryption_hal_prepare(uint32_t address, const uint32_t* buffer, uint32_t size)
{
4037cf94:	004136        	entry	a1, 32
4037cf97:	02ad      	mov.n	a10, a2
4037cf99:	03bd      	mov.n	a11, a3
4037cf9b:	04cd      	mov.n	a12, a4
    REG_WRITE(AES_XTS_SIZE_REG, size >> 5);
4037cf9d:	419540        	srli	a9, a4, 5
4037cfa0:	dfde81        	l32r	a8, 40374f18 <_iram_text_start+0xb14> (600cc040 <SYSTEM+0xc040>)
4037cfa3:	0020c0        	memw
4037cfa6:	0899      	s32i.n	a9, a8, 0
 *
 * @param flash_addr flash address to write.
 */
static inline void spi_flash_encrypt_ll_address_save(uint32_t flash_addr)
{
    REG_WRITE(AES_XTS_PHYSICAL_ADDR_REG, flash_addr);
4037cfa8:	dfdd81        	l32r	a8, 40374f1c <_iram_text_start+0xb18> (600cc048 <SYSTEM+0xc048>)
4037cfab:	0020c0        	memw
4037cfae:	006822        	s32i	a2, a8, 0
#if !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_buffer_length(size);
#endif // !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_address_save(address);
    spi_flash_encrypt_ll_plaintext_save(address, buffer, size);
4037cfb1:	fff765        	call8	4037cf28 <spi_flash_encrypt_ll_plaintext_save>
/**
 * Start flash encryption
 */
static inline void spi_flash_encrypt_ll_calculate_start(void)
{
    REG_WRITE(AES_XTS_TRIGGER_REG, 1);
4037cfb4:	dfdb81        	l32r	a8, 40374f20 <_iram_text_start+0xb1c> (600cc04c <SYSTEM+0xc04c>)
4037cfb7:	190c      	movi.n	a9, 1
4037cfb9:	0020c0        	memw
4037cfbc:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_calculate_start();
}
4037cfbe:	f01d      	retw.n

4037cfc0 <spi_flash_encryption_hal_done>:

void spi_flash_encryption_hal_done(void)
{
4037cfc0:	004136        	entry	a1, 32
/**
 * Wait for flash encryption termination
 */
static inline void spi_flash_encrypt_ll_calculate_wait_idle(void)
{
    while(REG_READ(AES_XTS_STATE_REG) == 0x1) {
4037cfc3:	dfd881        	l32r	a8, 40374f24 <_iram_text_start+0xb20> (600cc058 <SYSTEM+0xc058>)
4037cfc6:	0020c0        	memw
4037cfc9:	0888      	l32i.n	a8, a8, 0
4037cfcb:	f41826        	beqi	a8, 1, 4037cfc3 <spi_flash_encryption_hal_done+0x3>
/**
 * Finish the flash encryption and make encrypted result accessible to SPI.
 */
static inline void spi_flash_encrypt_ll_done(void)
{
    REG_WRITE(AES_XTS_RELEASE_REG, 1);
4037cfce:	dfd681        	l32r	a8, 40374f28 <_iram_text_start+0xb24> (600cc050 <SYSTEM+0xc050>)
4037cfd1:	190c      	movi.n	a9, 1
4037cfd3:	0020c0        	memw
4037cfd6:	0899      	s32i.n	a9, a8, 0
    while(REG_READ(AES_XTS_STATE_REG) != 0x3) {
4037cfd8:	dfd381        	l32r	a8, 40374f24 <_iram_text_start+0xb20> (600cc058 <SYSTEM+0xc058>)
4037cfdb:	0020c0        	memw
4037cfde:	0888      	l32i.n	a8, a8, 0
4037cfe0:	f43866        	bnei	a8, 3, 4037cfd8 <spi_flash_encryption_hal_done+0x18>
    spi_flash_encrypt_ll_calculate_wait_idle();
    spi_flash_encrypt_ll_done();
}
4037cfe3:	f01d      	retw.n
4037cfe5:	000000        	ill

4037cfe8 <spi_flash_encryption_hal_destroy>:

void spi_flash_encryption_hal_destroy(void)
{
4037cfe8:	004136        	entry	a1, 32
/**
 * Set to destroy encrypted result
 */
static inline void spi_flash_encrypt_ll_destroy(void)
{
    REG_WRITE(AES_XTS_DESTROY_REG, 1);
4037cfeb:	dfd081        	l32r	a8, 40374f2c <_iram_text_start+0xb28> (600cc054 <SYSTEM+0xc054>)
4037cfee:	190c      	movi.n	a9, 1
4037cff0:	0020c0        	memw
4037cff3:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_destroy();
}
4037cff5:	f01d      	retw.n
	...

4037cff8 <spi_flash_encryption_hal_check>:

bool spi_flash_encryption_hal_check(uint32_t address, uint32_t length)
{
4037cff8:	004136        	entry	a1, 32
 * @param address the address of written flash partition.
 * @param length Buffer size.
 */
static inline bool spi_flash_encrypt_ll_check(uint32_t address, uint32_t length)
{
    return ((address % length) == 0) ? true : false;
4037cffb:	e22230        	remu	a2, a2, a3
    return spi_flash_encrypt_ll_check(address, length);
}
4037cffe:	40f220        	nsau	a2, a2
4037d001:	412520        	srli	a2, a2, 5
4037d004:	f01d      	retw.n
	...

4037d008 <gpspi_flash_ll_set_read_mode>:
 *
 * @param dev Beginning address of the peripheral registers.
 * @param read_mode I/O mode to use in the following transactions.
 */
static inline void gpspi_flash_ll_set_read_mode(spi_dev_t *dev, esp_flash_io_mode_t read_mode)
{
4037d008:	006136        	entry	a1, 48
    typeof(dev->ctrl) ctrl;
    ctrl.val = dev->ctrl.val;
4037d00b:	0020c0        	memw
4037d00e:	2288      	l32i.n	a8, a2, 8
4037d010:	0020c0        	memw
4037d013:	0189      	s32i.n	a8, a1, 0
    typeof(dev->user) user;
    user.val = dev->user.val;
4037d015:	0020c0        	memw
4037d018:	4288      	l32i.n	a8, a2, 16
4037d01a:	0020c0        	memw
4037d01d:	1189      	s32i.n	a8, a1, 4

    ctrl.val &= ~(SPI_FCMD_QUAD_M | SPI_FADDR_QUAD_M | SPI_FREAD_QUAD_M | SPI_FCMD_DUAL_M | SPI_FADDR_DUAL_M | SPI_FREAD_DUAL_M);
4037d01f:	0020c0        	memw
4037d022:	0188      	l32i.n	a8, a1, 0
4037d024:	dfc391        	l32r	a9, 40374f30 <_iram_text_start+0xb2c> (ffff3c9f <_rtc_reserved_end+0x9fef3c9f>)
4037d027:	108890        	and	a8, a8, a9
4037d02a:	0020c0        	memw
4037d02d:	0189      	s32i.n	a8, a1, 0
    user.val &= ~(SPI_FWRITE_QUAD_M | SPI_FWRITE_DUAL_M);
4037d02f:	0020c0        	memw
4037d032:	1188      	l32i.n	a8, a1, 4
4037d034:	dfc091        	l32r	a9, 40374f34 <_iram_text_start+0xb30> (ffffcfff <_rtc_reserved_end+0x9fefcfff>)
4037d037:	108890        	and	a8, a8, a9
4037d03a:	0020c0        	memw
4037d03d:	1189      	s32i.n	a8, a1, 4

    switch (read_mode) {
4037d03f:	713326        	beqi	a3, 3, 4037d0b4 <gpspi_flash_ll_set_read_mode+0xac>
4037d042:	0e43f6        	bgeui	a3, 4, 4037d054 <gpspi_flash_ll_set_read_mode+0x4c>
4037d045:	0223f6        	bgeui	a3, 2, 4037d04b <gpspi_flash_ll_set_read_mode+0x43>
4037d048:	0030c6        	j	4037d10f <gpspi_flash_ll_set_read_mode+0x107>
4037d04b:	022366        	bnei	a3, 2, 4037d051 <gpspi_flash_ll_set_read_mode+0x49>
4037d04e:	002586        	j	4037d0e8 <gpspi_flash_ll_set_read_mode+0xe0>
4037d051:	002dc6        	j	4037d10c <gpspi_flash_ll_set_read_mode+0x104>
4037d054:	384326        	beqi	a3, 4, 4037d090 <gpspi_flash_ll_set_read_mode+0x88>
4037d057:	025326        	beqi	a3, 5, 4037d05d <gpspi_flash_ll_set_read_mode+0x55>
4037d05a:	002b86        	j	4037d10c <gpspi_flash_ll_set_read_mode+0x104>
    case SPI_FLASH_FASTRD:
    //the default option
    case SPI_FLASH_SLOWRD:
        break;
    case SPI_FLASH_QIO:
        ctrl.fread_quad = 1;
4037d05d:	0020c0        	memw
4037d060:	0188      	l32i.n	a8, a1, 0
4037d062:	dcfc91        	l32r	a9, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
4037d065:	208890        	or	a8, a8, a9
4037d068:	0020c0        	memw
4037d06b:	0189      	s32i.n	a8, a1, 0
        ctrl.faddr_quad = 1;
4037d06d:	0020c0        	memw
4037d070:	0188      	l32i.n	a8, a1, 0
4037d072:	094c      	movi.n	a9, 64
4037d074:	208890        	or	a8, a8, a9
4037d077:	0020c0        	memw
4037d07a:	0189      	s32i.n	a8, a1, 0
        user.fwrite_quad = 1;
4037d07c:	0020c0        	memw
4037d07f:	1188      	l32i.n	a8, a1, 4
4037d081:	de8391        	l32r	a9, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037d084:	208890        	or	a8, a8, a9
4037d087:	0020c0        	memw
4037d08a:	1189      	s32i.n	a8, a1, 4
        break;
4037d08c:	001fc6        	j	4037d10f <gpspi_flash_ll_set_read_mode+0x107>
4037d08f:	20c000        	or	a12, a0, a0
    case SPI_FLASH_QOUT:
        ctrl.fread_quad = 1;
4037d092:	018800        	slli	a8, a8, 32
4037d095:	dcef91        	l32r	a9, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
4037d098:	208890        	or	a8, a8, a9
4037d09b:	0020c0        	memw
4037d09e:	0189      	s32i.n	a8, a1, 0
        user.fwrite_quad = 1;
4037d0a0:	0020c0        	memw
4037d0a3:	1188      	l32i.n	a8, a1, 4
4037d0a5:	de7a91        	l32r	a9, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037d0a8:	208890        	or	a8, a8, a9
4037d0ab:	0020c0        	memw
4037d0ae:	1189      	s32i.n	a8, a1, 4
        break;
4037d0b0:	0016c6        	j	4037d10f <gpspi_flash_ll_set_read_mode+0x107>
4037d0b3:	20c000        	or	a12, a0, a0
    case SPI_FLASH_DIO:
        ctrl.fread_dual = 1;
4037d0b6:	018800        	slli	a8, a8, 32
4037d0b9:	dce591        	l32r	a9, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
4037d0bc:	208890        	or	a8, a8, a9
4037d0bf:	0020c0        	memw
4037d0c2:	0189      	s32i.n	a8, a1, 0
        ctrl.faddr_dual = 1;
4037d0c4:	0020c0        	memw
4037d0c7:	0188      	l32i.n	a8, a1, 0
4037d0c9:	092c      	movi.n	a9, 32
4037d0cb:	208890        	or	a8, a8, a9
4037d0ce:	0020c0        	memw
4037d0d1:	0189      	s32i.n	a8, a1, 0
        user.fwrite_dual = 1;
4037d0d3:	0020c0        	memw
4037d0d6:	1188      	l32i.n	a8, a1, 4
4037d0d8:	dd6691        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037d0db:	208890        	or	a8, a8, a9
4037d0de:	0020c0        	memw
4037d0e1:	1189      	s32i.n	a8, a1, 4
        break;
4037d0e3:	000a06        	j	4037d10f <gpspi_flash_ll_set_read_mode+0x107>
4037d0e6:	c00000        	sub	a0, a0, a0
    case SPI_FLASH_DOUT:
        ctrl.fread_dual = 1;
4037d0e9:	880020        	lsi	f2, a0, 0x220
4037d0ec:	d89101        	l32r	a0, 40373330 <rom_rx_gain_force+0x36cf04>
4037d0ef:	90dc      	bnez.n	a0, 4037d10c <gpspi_flash_ll_set_read_mode+0x104>
4037d0f1:	2088      	l32i.n	a8, a0, 8
4037d0f3:	0020c0        	memw
4037d0f6:	0189      	s32i.n	a8, a1, 0
        user.fwrite_dual = 1;
4037d0f8:	0020c0        	memw
4037d0fb:	1188      	l32i.n	a8, a1, 4
4037d0fd:	dd5c91        	l32r	a9, 40374670 <_iram_text_start+0x26c> (1000 <UserFrameTotalSize+0xf00>)
4037d100:	208890        	or	a8, a8, a9
4037d103:	0020c0        	memw
4037d106:	1189      	s32i.n	a8, a1, 4
        break;
4037d108:	0000c6        	j	4037d10f <gpspi_flash_ll_set_read_mode+0x107>
4037d10b:	b86500        	lsi	f0, a5, 0x2e0
    default:
        abort();
4037d10e:	20c002        	addi	a0, a0, 32
    }

    dev->ctrl.val = ctrl.val;
4037d111:	218200        	srai	a8, a0, 2
4037d114:	20c000        	or	a12, a0, a0
4037d117:	628200        	lsi	f0, a2, 0x188
4037d11a:	20c002        	addi	a0, a0, 32
    dev->user.val = user.val;
4037d11d:	218200        	srai	a8, a0, 2
4037d120:	20c001        	l32r	a0, 40345420 <rom_rx_gain_force+0x33eff4>
4037d123:	428900        	xorb	b8, b9, b0
}
4037d126:	f01d      	retw.n

4037d128 <gpspi_flash_ll_set_buffer_data>:
{
4037d128:	006136        	entry	a1, 48
    int num_words = (length + 3) / 4;
4037d12b:	543b      	addi.n	a5, a4, 3
4037d12d:	415250        	srli	a5, a5, 2
    for (int i = 0; i < num_words; i++) {
4037d130:	060c      	movi.n	a6, 0
4037d132:	000a86        	j	4037d160 <gpspi_flash_ll_set_buffer_data+0x38>
        uint32_t word = 0;
4037d135:	080c      	movi.n	a8, 0
4037d137:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037d139:	470c      	movi.n	a7, 4
4037d13b:	637470        	minu	a7, a4, a7
        memcpy(&word, buffer, word_len);
4037d13e:	07cd      	mov.n	a12, a7
4037d140:	20b330        	or	a11, a3, a3
4037d143:	20a110        	or	a10, a1, a1
4037d146:	dce381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d149:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037d14c:	24c682        	addi	a8, a6, 36
4037d14f:	a08820        	addx4	a8, a8, a2
4037d152:	0198      	l32i.n	a9, a1, 0
4037d154:	0020c0        	memw
4037d157:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037d159:	c04470        	sub	a4, a4, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037d15c:	337a      	add.n	a3, a3, a7
    for (int i = 0; i < num_words; i++) {
4037d15e:	661b      	addi.n	a6, a6, 1
4037d160:	d12657        	blt	a6, a5, 4037d135 <gpspi_flash_ll_set_buffer_data+0xd>
}
4037d163:	f01d      	retw.n
4037d165:	000000        	ill

4037d168 <gpspi_flash_ll_get_buffer_data>:
{
4037d168:	006136        	entry	a1, 48
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037d16b:	148030        	extui	a8, a3, 0, 2
4037d16e:	68dc      	bnez.n	a8, 4037d188 <gpspi_flash_ll_get_buffer_data+0x20>
4037d170:	148040        	extui	a8, a4, 0, 2
4037d173:	18dc      	bnez.n	a8, 4037d188 <gpspi_flash_ll_get_buffer_data+0x20>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037d175:	04cd      	mov.n	a12, a4
4037d177:	98a0b2        	movi	a11, 152
4037d17a:	b2ba      	add.n	a11, a2, a11
4037d17c:	03ad      	mov.n	a10, a3
4037d17e:	dcd581        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d181:	0008e0        	callx8	a8
4037d184:	000d46        	j	4037d1bd <gpspi_flash_ll_get_buffer_data+0x55>
4037d187:	045d00        	extui	a5, a0, 13, 1
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d18a:	060c      	movi.n	a6, 0
4037d18c:	000946        	j	4037d1b5 <gpspi_flash_ll_get_buffer_data+0x4d>
4037d18f:	470c00        	lsi	f0, a12, 0x11c
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037d192:	637570        	minu	a7, a5, a7
            uint32_t word = dev->data_buf[i];
4037d195:	24c682        	addi	a8, a6, 36
4037d198:	a08820        	addx4	a8, a8, a2
4037d19b:	0020c0        	memw
4037d19e:	2888      	l32i.n	a8, a8, 8
4037d1a0:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037d1a2:	07cd      	mov.n	a12, a7
4037d1a4:	01bd      	mov.n	a11, a1
4037d1a6:	03ad      	mov.n	a10, a3
4037d1a8:	dccb81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d1ab:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037d1ae:	337a      	add.n	a3, a3, a7
            copy_len -= word_len;
4037d1b0:	c05570        	sub	a5, a5, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d1b3:	661b      	addi.n	a6, a6, 1
4037d1b5:	843b      	addi.n	a8, a4, 3
4037d1b7:	418280        	srli	a8, a8, 2
4037d1ba:	d23687        	bltu	a6, a8, 4037d190 <gpspi_flash_ll_get_buffer_data+0x28>
}
4037d1bd:	f01d      	retw.n
	...

4037d1c0 <spi_flash_hal_gpspi_device_config>:
        //nop
    }
}

esp_err_t spi_flash_hal_device_config(spi_flash_host_inst_t *host)
{
4037d1c0:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d1c3:	1288      	l32i.n	a8, a2, 4
    dev->user.val = 0;
4037d1c5:	090c      	movi.n	a9, 0
4037d1c7:	0020c0        	memw
4037d1ca:	4899      	s32i.n	a9, a8, 16
    dev->ctrl.val = 0;
4037d1cc:	0020c0        	memw
4037d1cf:	2899      	s32i.n	a9, a8, 8
    dev->clk_gate.clk_en = 1;
4037d1d1:	0020c0        	memw
4037d1d4:	3a28a2        	l32i	a10, a8, 232
4037d1d7:	1b0c      	movi.n	a11, 1
4037d1d9:	20aab0        	or	a10, a10, a11
4037d1dc:	0020c0        	memw
4037d1df:	3a68a2        	s32i	a10, a8, 232
    dev->clk_gate.mst_clk_active = 1;
4037d1e2:	0020c0        	memw
4037d1e5:	3a28a2        	l32i	a10, a8, 232
4037d1e8:	2b0c      	movi.n	a11, 2
4037d1ea:	20aab0        	or	a10, a10, a11
4037d1ed:	0020c0        	memw
4037d1f0:	3a68a2        	s32i	a10, a8, 232
    dev->clk_gate.mst_clk_sel = 1;
4037d1f3:	0020c0        	memw
4037d1f6:	3a28a2        	l32i	a10, a8, 232
4037d1f9:	4b0c      	movi.n	a11, 4
4037d1fb:	20aab0        	or	a10, a10, a11
4037d1fe:	0020c0        	memw
4037d201:	3a68a2        	s32i	a10, a8, 232
    dev->dma_conf.val = 0;
4037d204:	0020c0        	memw
4037d207:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.tx_seg_trans_clr_en = 1;
4037d209:	0020c0        	memw
4037d20c:	c898      	l32i.n	a9, a8, 48
4037d20e:	df4aa1        	l32r	a10, 40374f38 <_iram_text_start+0xb34> (100000 <UserFrameTotalSize+0xfff00>)
4037d211:	2099a0        	or	a9, a9, a10
4037d214:	0020c0        	memw
4037d217:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.rx_seg_trans_clr_en = 1;
4037d219:	0020c0        	memw
4037d21c:	c898      	l32i.n	a9, a8, 48
4037d21e:	ddd8a1        	l32r	a10, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
4037d221:	2099a0        	or	a9, a9, a10
4037d224:	0020c0        	memw
4037d227:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.dma_seg_trans_en = 0;
4037d229:	0020c0        	memw
4037d22c:	c898      	l32i.n	a9, a8, 48
4037d22e:	df43a1        	l32r	a10, 40374f3c <_iram_text_start+0xb38> (fffbffff <_rtc_reserved_end+0x9febffff>)
4037d231:	1099a0        	and	a9, a9, a10
4037d234:	0020c0        	memw
4037d237:	c899      	s32i.n	a9, a8, 48
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    spi_dev_t *dev = get_spi_dev(host);

    spi_flash_ll_reset(dev);
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037d239:	22a8      	l32i.n	a10, a2, 8
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037d23b:	0020c0        	memw
4037d23e:	8898      	l32i.n	a9, a8, 32
4037d240:	1b0c      	movi.n	a11, 1
4037d242:	83baa0        	moveqz	a11, a10, a10
4037d245:	ec7c      	movi.n	a12, -2
4037d247:	1099c0        	and	a9, a9, a12
4037d24a:	2099b0        	or	a9, a9, a11
4037d24d:	0020c0        	memw
4037d250:	8899      	s32i.n	a9, a8, 32
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037d252:	ba0b      	addi.n	a11, a10, -1
4037d254:	0020c0        	memw
4037d257:	8898      	l32i.n	a9, a8, 32
4037d259:	1a0c      	movi.n	a10, 1
4037d25b:	83abb0        	moveqz	a10, a11, a11
4037d25e:	aaaa      	add.n	a10, a10, a10
4037d260:	db7c      	movi.n	a11, -3
4037d262:	1099b0        	and	a9, a9, a11
4037d265:	2099a0        	or	a9, a9, a10
4037d268:	0020c0        	memw
4037d26b:	8899      	s32i.n	a9, a8, 32
 * @param dev Beginning address of the peripheral registers.
 * @param clock_val pointer to the clock value to set
 */
static inline void gpspi_flash_ll_set_clock(spi_dev_t *dev, gpspi_flash_ll_clock_reg_t *clock_val)
{
    dev->clock.val = *clock_val;
4037d26d:	0020c0        	memw
4037d270:	4298      	l32i.n	a9, a2, 16
4037d272:	0020c0        	memw
4037d275:	3899      	s32i.n	a9, a8, 12
    spi_flash_ll_set_clock(dev, &ctx->clock_conf);
    int cs_hold = ctx->cs_hold;
4037d277:	0f0292        	l8ui	a9, a2, 15
 * @param dev Beginning address of the peripheral registers.
 * @param hold_n Cycles of clocks before CS is inactive
 */
static inline void gpspi_flash_ll_set_hold(spi_dev_t *dev, uint32_t hold_n)
{
    dev->user.cs_hold = (hold_n > 0 ? 1 : 0);
4037d27a:	0020c0        	memw
4037d27d:	48a8      	l32i.n	a10, a8, 16
4037d27f:	1b0c      	movi.n	a11, 1
4037d281:	83b990        	moveqz	a11, a9, a9
4037d284:	11bba0        	slli	a11, a11, 6
4037d287:	bfafc2        	movi	a12, -65
4037d28a:	10aac0        	and	a10, a10, a12
4037d28d:	20aab0        	or	a10, a10, a11
4037d290:	0020c0        	memw
4037d293:	48a9      	s32i.n	a10, a8, 16
    if (hold_n > 0) {
4037d295:	b99c      	beqz.n	a9, 4037d2b4 <spi_flash_hal_gpspi_device_config+0xf4>
        dev->user1.cs_hold_time = hold_n - 1;
4037d297:	990b      	addi.n	a9, a9, -1
4037d299:	0020c0        	memw
4037d29c:	0528a2        	l32i	a10, a8, 20
4037d29f:	449090        	extui	a9, a9, 0, 5
4037d2a2:	0199a0        	slli	a9, a9, 22
4037d2a5:	df26b1        	l32r	a11, 40374f40 <_iram_text_start+0xb3c> (f83fffff <_rtc_reserved_end+0x982fffff>)
4037d2a8:	10aab0        	and	a10, a10, a11
4037d2ab:	209a90        	or	a9, a10, a9
4037d2ae:	0020c0        	memw
4037d2b1:	056892        	s32i	a9, a8, 20
    spi_flash_ll_set_hold(dev, cs_hold);
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037d2b4:	0e0292        	l8ui	a9, a2, 14
 * @param dev Beginning address of the peripheral registers.
 * @param cs_setup_time Delay of SPI clocks after the CS active edge, 0 to disable the setup phase.
 */
static inline void gpspi_flash_ll_set_cs_setup(spi_dev_t *dev, uint32_t cs_setup_time)
{
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037d2b7:	0020c0        	memw
4037d2ba:	48a8      	l32i.n	a10, a8, 16
4037d2bc:	1b0c      	movi.n	a11, 1
4037d2be:	83b990        	moveqz	a11, a9, a9
4037d2c1:	11bb90        	slli	a11, a11, 7
4037d2c4:	7fafc2        	movi	a12, -129
4037d2c7:	10aac0        	and	a10, a10, a12
4037d2ca:	20aab0        	or	a10, a10, a11
4037d2cd:	0020c0        	memw
4037d2d0:	48a9      	s32i.n	a10, a8, 16
    if (cs_setup_time > 0) {
4037d2d2:	a99c      	beqz.n	a9, 4037d2f0 <spi_flash_hal_gpspi_device_config+0x130>
        dev->user1.cs_setup_time = cs_setup_time - 1;
4037d2d4:	990b      	addi.n	a9, a9, -1
4037d2d6:	0020c0        	memw
4037d2d9:	58a8      	l32i.n	a10, a8, 20
4037d2db:	449090        	extui	a9, a9, 0, 5
4037d2de:	0199f0        	slli	a9, a9, 17
4037d2e1:	df18b1        	l32r	a11, 40374f44 <_iram_text_start+0xb40> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
4037d2e4:	10aab0        	and	a10, a10, a11
4037d2e7:	209a90        	or	a9, a10, a9
4037d2ea:	0020c0        	memw
4037d2ed:	056892        	s32i	a9, a8, 20
    dev->ctrl.hold_pol = pol_val;
4037d2f0:	0020c0        	memw
4037d2f3:	2898      	l32i.n	a9, a8, 8
4037d2f5:	df10a1        	l32r	a10, 40374f38 <_iram_text_start+0xb34> (100000 <UserFrameTotalSize+0xfff00>)
4037d2f8:	2099a0        	or	a9, a9, a10
4037d2fb:	0020c0        	memw
4037d2fe:	2899      	s32i.n	a9, a8, 8
#else
    gpspi_flash_ll_set_hold_pol(dev, 1);
#endif //GPSPI_BUILD

    return ESP_OK;
}
4037d300:	020c      	movi.n	a2, 0
4037d302:	f01d      	retw.n

4037d304 <spi_flash_hal_gpspi_configure_host_io_mode>:
    spi_flash_host_inst_t *host,
    uint32_t command,
    uint32_t addr_bitlen,
    int dummy_cyclelen_base,
    esp_flash_io_mode_t io_mode)
{
4037d304:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d307:	12a8      	l32i.n	a10, a2, 4
    spi_dev_t *dev = get_spi_dev(host);
    int host_id = spi_flash_ll_hw_get_id(dev);

    uint32_t extra_bits = io_mode & 0xFFFF0000;
    io_mode = io_mode & 0xFFFF;
4037d309:	f4b060        	extui	a11, a6, 0, 16
    dev->ctrl.dummy_out = out_en;
4037d30c:	0020c0        	memw
4037d30f:	2a88      	l32i.n	a8, a10, 8
4037d311:	056f60        	extui	a6, a6, 31, 1
4037d314:	1166d0        	slli	a6, a6, 3
4037d317:	797c      	movi.n	a9, -9
4037d319:	108890        	and	a8, a8, a9
4037d31c:	208860        	or	a8, a8, a6
4037d31f:	0020c0        	memw
4037d322:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.q_pol = out_lev;
4037d324:	0020c0        	memw
4037d327:	2a88      	l32i.n	a8, a10, 8
4037d329:	dd3591        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037d32c:	208890        	or	a8, a8, a9
4037d32f:	0020c0        	memw
4037d332:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.d_pol = out_lev;
4037d334:	0020c0        	memw
4037d337:	2a88      	l32i.n	a8, a10, 8
4037d339:	dd9191        	l32r	a9, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
4037d33c:	208890        	or	a8, a8, a9
4037d33f:	0020c0        	memw
4037d342:	2a89      	s32i.n	a8, a10, 8
            spi_flash_ll_set_extra_address(dev, 0);
        }
    }
#endif

    if (command >= 0x100) {
4037d344:	ffa082        	movi	a8, 255
4037d347:	49b837        	bgeu	a8, a3, 4037d394 <spi_flash_hal_gpspi_configure_host_io_mode+0x90>
    dev->user.usr_command = 1;
4037d34a:	0020c0        	memw
4037d34d:	4a88      	l32i.n	a8, a10, 16
4037d34f:	dc7391        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d352:	208890        	or	a8, a8, a9
4037d355:	0020c0        	memw
4037d358:	4a89      	s32i.n	a8, a10, 16
    typeof(dev->user2) user2 = {
4037d35a:	080c      	movi.n	a8, 0
4037d35c:	0020c0        	memw
4037d35f:	2189      	s32i.n	a8, a1, 8
4037d361:	0020c0        	memw
4037d364:	2188      	l32i.n	a8, a1, 8
4037d366:	743030        	extui	a3, a3, 0, 8
4037d369:	f58080        	extui	a8, a8, 16, 16
4037d36c:	118800        	slli	a8, a8, 16
4037d36f:	208830        	or	a8, a8, a3
4037d372:	0020c0        	memw
4037d375:	2189      	s32i.n	a8, a1, 8
4037d377:	0020c0        	memw
4037d37a:	2188      	l32i.n	a8, a1, 8
4037d37c:	def391        	l32r	a9, 40374f48 <_iram_text_start+0xb44> (f0000000 <_rtc_reserved_end+0x8ff00000>)
4037d37f:	208890        	or	a8, a8, a9
4037d382:	0020c0        	memw
4037d385:	2189      	s32i.n	a8, a1, 8
    dev->user2.val = user2.val;
4037d387:	0020c0        	memw
4037d38a:	2188      	l32i.n	a8, a1, 8
4037d38c:	0020c0        	memw
4037d38f:	6a89      	s32i.n	a8, a10, 24
}
4037d391:	001306        	j	4037d3e1 <spi_flash_hal_gpspi_configure_host_io_mode+0xdd>
    dev->user.usr_command = 1;
4037d394:	0020c0        	memw
4037d397:	4a88      	l32i.n	a8, a10, 16
4037d399:	dc6091        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d39c:	208890        	or	a8, a8, a9
4037d39f:	0020c0        	memw
4037d3a2:	4a89      	s32i.n	a8, a10, 16
    typeof(dev->user2) user2 = {
4037d3a4:	080c      	movi.n	a8, 0
4037d3a6:	0020c0        	memw
4037d3a9:	1189      	s32i.n	a8, a1, 4
4037d3ab:	0020c0        	memw
4037d3ae:	1188      	l32i.n	a8, a1, 4
4037d3b0:	743030        	extui	a3, a3, 0, 8
4037d3b3:	f58080        	extui	a8, a8, 16, 16
4037d3b6:	118800        	slli	a8, a8, 16
4037d3b9:	208830        	or	a8, a8, a3
4037d3bc:	0020c0        	memw
4037d3bf:	1189      	s32i.n	a8, a1, 4
4037d3c1:	0020c0        	memw
4037d3c4:	1188      	l32i.n	a8, a1, 4
4037d3c6:	1188c0        	slli	a8, a8, 4
4037d3c9:	418480        	srli	a8, a8, 4
4037d3cc:	dd0791        	l32r	a9, 403747e8 <_iram_text_start+0x3e4> (70000000 <_rtc_reserved_end+0xff00000>)
4037d3cf:	208890        	or	a8, a8, a9
4037d3d2:	0020c0        	memw
4037d3d5:	1189      	s32i.n	a8, a1, 4
    dev->user2.val = user2.val;
4037d3d7:	0020c0        	memw
4037d3da:	1188      	l32i.n	a8, a1, 4
4037d3dc:	0020c0        	memw
4037d3df:	6a89      	s32i.n	a8, a10, 24
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d3e1:	940b      	addi.n	a9, a4, -1
4037d3e3:	0020c0        	memw
4037d3e6:	5a88      	l32i.n	a8, a10, 20
4037d3e8:	019950        	slli	a9, a9, 27
4037d3eb:	1188b0        	slli	a8, a8, 5
4037d3ee:	418580        	srli	a8, a8, 5
4037d3f1:	208890        	or	a8, a8, a9
4037d3f4:	0020c0        	memw
4037d3f7:	5a89      	s32i.n	a8, a10, 20
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d3f9:	0020c0        	memw
4037d3fc:	4a88      	l32i.n	a8, a10, 16
4037d3fe:	190c      	movi.n	a9, 1
4037d400:	839440        	moveqz	a9, a4, a4
4037d403:	019920        	slli	a9, a9, 30
4037d406:	dcf9c1        	l32r	a12, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037d409:	1088c0        	and	a8, a8, a12
4037d40c:	208890        	or	a8, a8, a9
4037d40f:	0020c0        	memw
4037d412:	4a89      	s32i.n	a8, a10, 16
    } else {
        spi_flash_ll_set_command(dev, command, 8);
    }
    spi_flash_ll_set_addr_bitlen(dev, addr_bitlen);
    // Add dummy cycles to compensate for latency of GPIO matrix and external delay, if necessary...
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037d414:	0c0282        	l8ui	a8, a2, 12
4037d417:	585a      	add.n	a5, a8, a5
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d419:	0020c0        	memw
4037d41c:	4a88      	l32i.n	a8, a10, 16
4037d41e:	190c      	movi.n	a9, 1
4037d420:	839550        	moveqz	a9, a5, a5
4037d423:	019930        	slli	a9, a9, 29
4037d426:	dcf3c1        	l32r	a12, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d429:	1088c0        	and	a8, a8, a12
4037d42c:	208890        	or	a8, a8, a9
4037d42f:	0020c0        	memw
4037d432:	4a89      	s32i.n	a8, a10, 16
    if (dummy_n > 0) {
4037d434:	b5ac      	beqz.n	a5, 4037d463 <spi_flash_hal_gpspi_configure_host_io_mode+0x15f>
        HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037d436:	0020c0        	memw
4037d439:	5a88      	l32i.n	a8, a10, 20
4037d43b:	0020c0        	memw
4037d43e:	0189      	s32i.n	a8, a1, 0
4037d440:	550b      	addi.n	a5, a5, -1
4037d442:	0020c0        	memw
4037d445:	0188      	l32i.n	a8, a1, 0
4037d447:	745050        	extui	a5, a5, 0, 8
4037d44a:	00af92        	movi	a9, 0xffffff00
4037d44d:	108890        	and	a8, a8, a9
4037d450:	208850        	or	a8, a8, a5
4037d453:	0020c0        	memw
4037d456:	0189      	s32i.n	a8, a1, 0
4037d458:	0020c0        	memw
4037d45b:	0188      	l32i.n	a8, a1, 0
4037d45d:	0020c0        	memw
4037d460:	056a82        	s32i	a8, a10, 20
    dev->user.usr_miso = bitlen > 0;
4037d463:	0020c0        	memw
4037d466:	4a88      	l32i.n	a8, a10, 16
4037d468:	dce591        	l32r	a9, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d46b:	108890        	and	a8, a8, a9
4037d46e:	0020c0        	memw
4037d471:	4a89      	s32i.n	a8, a10, 16
    dev->user.usr_mosi = bitlen > 0;
4037d473:	0020c0        	memw
4037d476:	4a88      	l32i.n	a8, a10, 16
4037d478:	dce091        	l32r	a9, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037d47b:	108890        	and	a8, a8, a9
4037d47e:	0020c0        	memw
4037d481:	4a89      	s32i.n	a8, a10, 16
    //disable all data phases, enable them later if needed
    spi_flash_ll_set_miso_bitlen(dev, 0);
    spi_flash_ll_set_mosi_bitlen(dev, 0);
    spi_flash_ll_set_read_mode(dev, io_mode);
4037d483:	ffb865        	call8	4037d008 <gpspi_flash_ll_set_read_mode>
    if (ctx->fdummy_rin) {
        spimem_flash_ll_set_fdummy_rin((spi_mem_dev_t*)dev, ctx->fdummy_rin);
    }
#endif
    return ESP_OK;
}
4037d486:	020c      	movi.n	a2, 0
4037d488:	f01d      	retw.n
	...

4037d48c <spi_flash_hal_gpspi_common_command>:

esp_err_t spi_flash_hal_common_command(spi_flash_host_inst_t *host, spi_flash_trans_t *trans)
{
4037d48c:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d48f:	1278      	l32i.n	a7, a2, 4
    spi_dev_t *dev = get_spi_dev(host);
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037d491:	52e8      	l32i.n	a14, a2, 20
    uint16_t command;
    uint8_t dummy_bitlen;
    bool pe_ops = false;

    command = trans->command;
4037d493:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037d496:	160362        	l8ui	a6, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037d499:	4388      	l32i.n	a8, a3, 16
4037d49b:	016817        	bbci	a8, 1, 4037d4a0 <spi_flash_hal_gpspi_common_command+0x14>
        io_mode = trans->io_mode;
4037d49e:	63e8      	l32i.n	a14, a3, 24
    }

    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037d4a0:	0288      	l32i.n	a8, a2, 0
4037d4a2:	f888      	l32i.n	a8, a8, 60
4037d4a4:	06dd      	mov.n	a13, a6
4037d4a6:	0303c2        	l8ui	a12, a3, 3
4037d4a9:	02ad      	mov.n	a10, a2
4037d4ab:	0008e0        	callx8	a8

    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037d4ae:	1398      	l32i.n	a9, a3, 4
4037d4b0:	030382        	l8ui	a8, a3, 3
    uint32_t padding_ones = (bitlen == 32 ? 0 : UINT32_MAX >> bitlen);
4037d4b3:	0ac826        	beqi	a8, 32, 4037d4c1 <spi_flash_hal_gpspi_common_command+0x35>
4037d4b6:	fa7c      	movi.n	a10, -1
4037d4b8:	400800        	ssr	a8
4037d4bb:	91a0a0        	srl	a10, a10
4037d4be:	000046        	j	4037d4c3 <spi_flash_hal_gpspi_common_command+0x37>
4037d4c1:	0a0c      	movi.n	a10, 0
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037d4c3:	e0c882        	addi	a8, a8, -32
4037d4c6:	608080        	neg	a8, a8
4037d4c9:	401800        	ssl	a8
4037d4cc:	a18900        	sll	a8, a9
4037d4cf:	2088a0        	or	a8, a8, a10
4037d4d2:	0020c0        	memw
4037d4d5:	1789      	s32i.n	a8, a7, 4
    //No extra dummy cycles for compensation if no input data
    if (trans->miso_len == 0) {
4037d4d7:	020382        	l8ui	a8, a3, 2
4037d4da:	048856        	bnez	a8, 4037d526 <spi_flash_hal_gpspi_common_command+0x9a>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d4dd:	0020c0        	memw
4037d4e0:	4788      	l32i.n	a8, a7, 16
4037d4e2:	190c      	movi.n	a9, 1
4037d4e4:	839660        	moveqz	a9, a6, a6
4037d4e7:	019930        	slli	a9, a9, 29
4037d4ea:	dcc2a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d4ed:	1088a0        	and	a8, a8, a10
4037d4f0:	208890        	or	a8, a8, a9
4037d4f3:	0020c0        	memw
4037d4f6:	4789      	s32i.n	a8, a7, 16
    if (dummy_n > 0) {
4037d4f8:	a6ac      	beqz.n	a6, 4037d526 <spi_flash_hal_gpspi_common_command+0x9a>
        HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037d4fa:	0020c0        	memw
4037d4fd:	5788      	l32i.n	a8, a7, 20
4037d4ff:	0020c0        	memw
4037d502:	0189      	s32i.n	a8, a1, 0
4037d504:	660b      	addi.n	a6, a6, -1
4037d506:	0020c0        	memw
4037d509:	0188      	l32i.n	a8, a1, 0
4037d50b:	746060        	extui	a6, a6, 0, 8
4037d50e:	00af92        	movi	a9, 0xffffff00
4037d511:	108890        	and	a8, a8, a9
4037d514:	208860        	or	a8, a8, a6
4037d517:	0020c0        	memw
4037d51a:	0189      	s32i.n	a8, a1, 0
4037d51c:	0020c0        	memw
4037d51f:	0188      	l32i.n	a8, a1, 0
4037d521:	0020c0        	memw
4037d524:	5789      	s32i.n	a8, a7, 20
        spi_flash_ll_set_dummy(dev, dummy_bitlen);
    }

    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037d526:	0103a2        	l8ui	a10, a3, 1
4037d529:	119ad0        	slli	a9, a10, 3
    dev->user.usr_mosi = bitlen > 0;
4037d52c:	0020c0        	memw
4037d52f:	4788      	l32i.n	a8, a7, 16
4037d531:	1b0c      	movi.n	a11, 1
4037d533:	83baa0        	moveqz	a11, a10, a10
4037d536:	01bb50        	slli	a11, a11, 27
4037d539:	dcafc1        	l32r	a12, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037d53c:	1088c0        	and	a8, a8, a12
4037d53f:	2088b0        	or	a8, a8, a11
4037d542:	0020c0        	memw
4037d545:	4789      	s32i.n	a8, a7, 16
    if (bitlen) {
4037d547:	9a9c      	beqz.n	a10, 4037d564 <spi_flash_hal_gpspi_common_command+0xd8>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d549:	890b      	addi.n	a8, a9, -1
4037d54b:	0020c0        	memw
4037d54e:	7798      	l32i.n	a9, a7, 28
4037d550:	118820        	slli	a8, a8, 14
4037d553:	418e80        	srli	a8, a8, 14
4037d556:	d59290        	extui	a9, a9, 18, 14
4037d559:	0199e0        	slli	a9, a9, 18
4037d55c:	209980        	or	a9, a9, a8
4037d55f:	0020c0        	memw
4037d562:	7799      	s32i.n	a9, a7, 28
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037d564:	0103c2        	l8ui	a12, a3, 1
4037d567:	23b8      	l32i.n	a11, a3, 8
4037d569:	07ad      	mov.n	a10, a7
4037d56b:	ffbbe5        	call8	4037d128 <gpspi_flash_ll_set_buffer_data>

    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037d56e:	0203a2        	l8ui	a10, a3, 2
4037d571:	119ad0        	slli	a9, a10, 3
    dev->user.usr_miso = bitlen > 0;
4037d574:	0020c0        	memw
4037d577:	4788      	l32i.n	a8, a7, 16
4037d579:	1b0c      	movi.n	a11, 1
4037d57b:	83baa0        	moveqz	a11, a10, a10
4037d57e:	01bb40        	slli	a11, a11, 28
4037d581:	dc9ec1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d584:	1088c0        	and	a8, a8, a12
4037d587:	2088b0        	or	a8, a8, a11
4037d58a:	0020c0        	memw
4037d58d:	4789      	s32i.n	a8, a7, 16
    if (bitlen) {
4037d58f:	9a9c      	beqz.n	a10, 4037d5ac <spi_flash_hal_gpspi_common_command+0x120>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d591:	890b      	addi.n	a8, a9, -1
4037d593:	0020c0        	memw
4037d596:	7798      	l32i.n	a9, a7, 28
4037d598:	118820        	slli	a8, a8, 14
4037d59b:	418e80        	srli	a8, a8, 14
4037d59e:	d59290        	extui	a9, a9, 18, 14
4037d5a1:	0199e0        	slli	a9, a9, 18
4037d5a4:	209980        	or	a9, a9, a8
4037d5a7:	0020c0        	memw
4037d5aa:	7799      	s32i.n	a9, a7, 28
    dev->cmd.update = 1;
4037d5ac:	0020c0        	memw
4037d5af:	0788      	l32i.n	a8, a7, 0
4037d5b1:	dcff91        	l32r	a9, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037d5b4:	208890        	or	a8, a8, a9
4037d5b7:	0020c0        	memw
4037d5ba:	0789      	s32i.n	a8, a7, 0
    while (dev->cmd.update);
4037d5bc:	0020c0        	memw
4037d5bf:	0788      	l32i.n	a8, a7, 0
4037d5c1:	f7f877        	bbsi	a8, 23, 4037d5bc <spi_flash_hal_gpspi_common_command+0x130>
    dev->cmd.usr = 1;
4037d5c4:	0020c0        	memw
4037d5c7:	0788      	l32i.n	a8, a7, 0
4037d5c9:	dcba91        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037d5cc:	208890        	or	a8, a8, a9
4037d5cf:	0020c0        	memw
4037d5d2:	0789      	s32i.n	a8, a7, 0
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_PE_CMD) != 0) {
        pe_ops = true;
    }
    spi_flash_ll_user_start(dev, pe_ops);
    host->driver->poll_cmd_done(host);
4037d5d4:	002282        	l32i	a8, a2, 0
4037d5d7:	102882        	l32i	a8, a8, 64
4037d5da:	20a220        	or	a10, a2, a2
4037d5dd:	0008e0        	callx8	a8
    if (trans->miso_len > 0) {
4037d5e0:	0203c2        	l8ui	a12, a3, 2
4037d5e3:	5c8c      	beqz.n	a12, 4037d5ec <spi_flash_hal_gpspi_common_command+0x160>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037d5e5:	33b8      	l32i.n	a11, a3, 12
4037d5e7:	07ad      	mov.n	a10, a7
4037d5e9:	ffb7e5        	call8	4037d168 <gpspi_flash_ll_get_buffer_data>
    }
#if SOC_SPI_MEM_SUPPORT_WB_MODE_INDEPENDENT_CONTROL
    spi_flash_ll_wb_mode_enable(dev, false);
#endif
    return ESP_OK;
}
4037d5ec:	020c      	movi.n	a2, 0
4037d5ee:	f01d      	retw.n

4037d5f0 <spi_flash_hal_gpspi_read>:

esp_err_t spi_flash_hal_read(spi_flash_host_inst_t *host, void *buffer, uint32_t address, uint32_t read_len)
{
4037d5f0:	004136        	entry	a1, 32
4037d5f3:	02ad      	mov.n	a10, a2
    return ((spi_flash_hal_context_t*)host)->spi;
4037d5f5:	1278      	l32i.n	a7, a2, 4
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037d5f7:	0020c0        	memw
4037d5fa:	4788      	l32i.n	a8, a7, 16
4037d5fc:	1478e7        	bbci	a8, 30, 4037d614 <spi_flash_hal_gpspi_read+0x24>
4037d5ff:	0020c0        	memw
4037d602:	5788      	l32i.n	a8, a7, 20
4037d604:	458b80        	extui	a8, a8, 27, 5
4037d607:	881b      	addi.n	a8, a8, 1
    spi_dev_t *dev = get_spi_dev(host);
    int bitlen = spi_flash_ll_get_addr_bitlen(dev);
    //Only 24-bit and 32-bit address are supported. The extra length are for M7-M0, which should be
    //filled with ones by the function below
    spi_flash_ll_set_usr_address(dev, address, bitlen & (~7));
4037d609:	897c      	movi.n	a9, -8
4037d60b:	108890        	and	a8, a8, a9
    uint32_t padding_ones = (bitlen == 32 ? 0 : UINT32_MAX >> bitlen);
4037d60e:	04c866        	bnei	a8, 32, 4037d616 <spi_flash_hal_gpspi_read+0x26>
4037d611:	000306        	j	4037d621 <spi_flash_hal_gpspi_read+0x31>
4037d614:	080c      	movi.n	a8, 0
4037d616:	f97c      	movi.n	a9, -1
4037d618:	400800        	ssr	a8
4037d61b:	919090        	srl	a9, a9
4037d61e:	000046        	j	4037d623 <spi_flash_hal_gpspi_read+0x33>
4037d621:	090c      	movi.n	a9, 0
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037d623:	e0c882        	addi	a8, a8, -32
4037d626:	608080        	neg	a8, a8
4037d629:	401800        	ssl	a8
4037d62c:	a14400        	sll	a4, a4
4037d62f:	204490        	or	a4, a4, a9
4037d632:	0020c0        	memw
4037d635:	1749      	s32i.n	a4, a7, 4
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037d637:	1185d0        	slli	a8, a5, 3
    dev->user.usr_miso = bitlen > 0;
4037d63a:	0020c0        	memw
4037d63d:	4798      	l32i.n	a9, a7, 16
4037d63f:	1b0c      	movi.n	a11, 1
4037d641:	83b880        	moveqz	a11, a8, a8
4037d644:	01bb40        	slli	a11, a11, 28
4037d647:	dc6dc1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d64a:	1099c0        	and	a9, a9, a12
4037d64d:	2099b0        	or	a9, a9, a11
4037d650:	0020c0        	memw
4037d653:	4799      	s32i.n	a9, a7, 16
    if (bitlen) {
4037d655:	b89c      	beqz.n	a8, 4037d674 <spi_flash_hal_gpspi_read+0x84>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d657:	880b      	addi.n	a8, a8, -1
4037d659:	0020c0        	memw
4037d65c:	072792        	l32i	a9, a7, 28
4037d65f:	118820        	slli	a8, a8, 14
4037d662:	418e80        	srli	a8, a8, 14
4037d665:	d59290        	extui	a9, a9, 18, 14
4037d668:	0199e0        	slli	a9, a9, 18
4037d66b:	209980        	or	a9, a9, a8
4037d66e:	0020c0        	memw
4037d671:	076792        	s32i	a9, a7, 28
    dev->cmd.update = 1;
4037d674:	0020c0        	memw
4037d677:	0788      	l32i.n	a8, a7, 0
4037d679:	dccd91        	l32r	a9, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037d67c:	208890        	or	a8, a8, a9
4037d67f:	0020c0        	memw
4037d682:	0789      	s32i.n	a8, a7, 0
    while (dev->cmd.update);
4037d684:	0020c0        	memw
4037d687:	002782        	l32i	a8, a7, 0
4037d68a:	f6f877        	bbsi	a8, 23, 4037d684 <spi_flash_hal_gpspi_read+0x94>
    dev->cmd.usr = 1;
4037d68d:	0020c0        	memw
4037d690:	002782        	l32i	a8, a7, 0
4037d693:	dc8891        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037d696:	208890        	or	a8, a8, a9
4037d699:	0020c0        	memw
4037d69c:	006782        	s32i	a8, a7, 0
    spi_flash_ll_user_start(dev, false);
    host->driver->poll_cmd_done(host);
4037d69f:	0a88      	l32i.n	a8, a10, 0
4037d6a1:	102882        	l32i	a8, a8, 64
4037d6a4:	0008e0        	callx8	a8
    if (read_len > 0) {
4037d6a7:	758c      	beqz.n	a5, 4037d6b2 <spi_flash_hal_gpspi_read+0xc2>
        spi_flash_ll_get_buffer_data(dev, buffer, read_len);
4037d6a9:	05cd      	mov.n	a12, a5
4037d6ab:	03bd      	mov.n	a11, a3
4037d6ad:	07ad      	mov.n	a10, a7
4037d6af:	ffaba5        	call8	4037d168 <gpspi_flash_ll_get_buffer_data>
    }
    return ESP_OK;
}
4037d6b2:	020c      	movi.n	a2, 0
4037d6b4:	f01d      	retw.n
	...

4037d6b8 <spi_flash_hal_gpspi_poll_cmd_done>:
{
4037d6b8:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d6bb:	1288      	l32i.n	a8, a2, 4
    return (dev->cmd.usr == 0);
4037d6bd:	0020c0        	memw
4037d6c0:	0888      	l32i.n	a8, a8, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037d6c2:	f5f887        	bbsi	a8, 24, 4037d6bb <spi_flash_hal_gpspi_poll_cmd_done+0x3>
}
4037d6c5:	f01d      	retw.n
	...

4037d6c8 <spi_flash_hal_gpspi_supports_direct_write>:
#define spi_flash_hal_read                      spi_flash_hal_gpspi_read

#include "spi_flash_hal_common.inc"

bool spi_flash_hal_gpspi_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
4037d6c8:	004136        	entry	a1, 32
    return true;
}
4037d6cb:	120c      	movi.n	a2, 1
4037d6cd:	f01d      	retw.n
	...

4037d6d0 <spi_flash_hal_gpspi_supports_direct_read>:

bool spi_flash_hal_gpspi_supports_direct_read(spi_flash_host_inst_t *host, const void *p)
{
4037d6d0:	004136        	entry	a1, 32
    return true;
}
4037d6d3:	120c      	movi.n	a2, 1
4037d6d5:	f01d      	retw.n
	...

4037d6d8 <spi_flash_hal_gpspi_check_status>:

uint32_t spi_flash_hal_gpspi_check_status(spi_flash_host_inst_t *host)
{
4037d6d8:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d6db:	1288      	l32i.n	a8, a2, 4
    return dev->cmd.usr == 0;
4037d6dd:	0020c0        	memw
4037d6e0:	0828      	l32i.n	a2, a8, 0
4037d6e2:	052820        	extui	a2, a2, 24, 1
4037d6e5:	180c      	movi.n	a8, 1
4037d6e7:	302280        	xor	a2, a2, a8
    spi_dev_t *dev = get_spi_dev(host);
    return spi_flash_ll_host_idle(dev);
}
4037d6ea:	042020        	extui	a2, a2, 0, 1
4037d6ed:	f01d      	retw.n
	...

4037d6f0 <spimem_flash_ll_set_read_mode>:
{
4037d6f0:	006136        	entry	a1, 48
    ctrl.val = dev->ctrl.val;
4037d6f3:	0020c0        	memw
4037d6f6:	2288      	l32i.n	a8, a2, 8
4037d6f8:	0020c0        	memw
4037d6fb:	0189      	s32i.n	a8, a1, 0
    ctrl.val &= ~(SPI_MEM_FREAD_QIO_M | SPI_MEM_FREAD_QUAD_M | SPI_MEM_FREAD_DIO_M | SPI_MEM_FREAD_DUAL_M | SPI_MEM_FCMD_OCT | SPI_MEM_FADDR_OCT | SPI_MEM_FDIN_OCT | SPI_MEM_FDOUT_OCT);
4037d6fd:	0020c0        	memw
4037d700:	0188      	l32i.n	a8, a1, 0
4037d702:	de1291        	l32r	a9, 40374f4c <_iram_text_start+0xb48> (fe6fbd8f <_rtc_reserved_end+0x9e5fbd8f>)
4037d705:	108890        	and	a8, a8, a9
4037d708:	0020c0        	memw
4037d70b:	0189      	s32i.n	a8, a1, 0
    dev->ddr.fmem_ddr_en = 0;
4037d70d:	0020c0        	memw
4037d710:	382282        	l32i	a8, a2, 224
4037d713:	e97c      	movi.n	a9, -2
4037d715:	108890        	and	a8, a8, a9
4037d718:	0020c0        	memw
4037d71b:	386282        	s32i	a8, a2, 224
    ctrl.val |= SPI_MEM_FASTRD_MODE_M;
4037d71e:	0020c0        	memw
4037d721:	0188      	l32i.n	a8, a1, 0
4037d723:	dcdb91        	l32r	a9, 40374a90 <_iram_text_start+0x68c> (2000 <UserFrameTotalSize+0x1f00>)
4037d726:	208890        	or	a8, a8, a9
4037d729:	0020c0        	memw
4037d72c:	0189      	s32i.n	a8, a1, 0
    switch (read_mode) {
4037d72e:	424326        	beqi	a3, 4, 4037d774 <spimem_flash_ll_set_read_mode+0x84>
4037d731:	1b53f6        	bgeui	a3, 5, 4037d750 <spimem_flash_ll_set_read_mode+0x60>
4037d734:	642326        	beqi	a3, 2, 4037d79c <spimem_flash_ll_set_read_mode+0xac>
4037d737:	0d33f6        	bgeui	a3, 3, 4037d748 <spimem_flash_ll_set_read_mode+0x58>
4037d73a:	072316        	beqz	a3, 4037d7b0 <spimem_flash_ll_set_read_mode+0xc0>
4037d73d:	021366        	bnei	a3, 1, 4037d743 <spimem_flash_ll_set_read_mode+0x53>
4037d740:	004506        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
4037d743:	004386        	j	4037d855 <spimem_flash_ll_set_read_mode+0x165>
4037d746:	260000        	lsi	f0, a0, 152
4037d749:	863c33        	lsi	f3, a12, 0x218
4037d74c:	000041        	l32r	a4, 4033d74c <rom_rx_gain_force+0x337320>
4037d74f:	b32600        	movgez	a2, a6, a0
4037d752:	181c70        	lsxp	f1, a12, a7
4037d755:	029387        	bne	a3, a8, 4037d75b <spimem_flash_ll_set_read_mode+0x6b>
4037d758:	002a06        	j	4037d804 <spimem_flash_ll_set_read_mode+0x114>
4037d75b:	025326        	beqi	a3, 5, 4037d761 <spimem_flash_ll_set_read_mode+0x71>
4037d75e:	003cc6        	j	4037d855 <spimem_flash_ll_set_read_mode+0x165>
        ctrl.fread_qio = 1;
4037d761:	0020c0        	memw
4037d764:	0188      	l32i.n	a8, a1, 0
4037d766:	dc5391        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037d769:	208890        	or	a8, a8, a9
4037d76c:	0020c0        	memw
4037d76f:	0189      	s32i.n	a8, a1, 0
        break;
4037d771:	0038c6        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
        ctrl.fread_quad = 1;
4037d774:	0020c0        	memw
4037d777:	0188      	l32i.n	a8, a1, 0
4037d779:	ddef91        	l32r	a9, 40374f38 <_iram_text_start+0xb34> (100000 <UserFrameTotalSize+0xfff00>)
4037d77c:	208890        	or	a8, a8, a9
4037d77f:	0020c0        	memw
4037d782:	0189      	s32i.n	a8, a1, 0
        break;
4037d784:	003406        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
4037d787:	20c000        	or	a12, a0, a0
        ctrl.fread_dio = 1;
4037d78a:	018800        	slli	a8, a8, 32
4037d78d:	dc8891        	l32r	a9, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037d790:	208890        	or	a8, a8, a9
4037d793:	0020c0        	memw
4037d796:	0189      	s32i.n	a8, a1, 0
        break;
4037d798:	002f06        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
4037d79b:	20c000        	or	a12, a0, a0
        ctrl.fread_dual = 1;
4037d79e:	018800        	slli	a8, a8, 32
4037d7a1:	db2b91        	l32r	a9, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
4037d7a4:	208890        	or	a8, a8, a9
4037d7a7:	0020c0        	memw
4037d7aa:	0189      	s32i.n	a8, a1, 0
        break;
4037d7ac:	002a06        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
4037d7af:	20c000        	or	a12, a0, a0
        ctrl.fastrd_mode = 0;
4037d7b2:	018800        	slli	a8, a8, 32
4037d7b5:	dcb791        	l32r	a9, 40374a94 <_iram_text_start+0x690> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4037d7b8:	108890        	and	a8, a8, a9
4037d7bb:	0020c0        	memw
4037d7be:	0189      	s32i.n	a8, a1, 0
        break;
4037d7c0:	002506        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
4037d7c3:	20c000        	or	a12, a0, a0
        ctrl.faddr_oct = 1;
4037d7c6:	018800        	slli	a8, a8, 32
4037d7c9:	094c      	movi.n	a9, 64
4037d7cb:	208890        	or	a8, a8, a9
4037d7ce:	0020c0        	memw
4037d7d1:	0189      	s32i.n	a8, a1, 0
        ctrl.fcmd_oct = 1;
4037d7d3:	0020c0        	memw
4037d7d6:	0188      	l32i.n	a8, a1, 0
4037d7d8:	00a292        	movi	a9, 0x200
4037d7db:	208890        	or	a8, a8, a9
4037d7de:	0020c0        	memw
4037d7e1:	0189      	s32i.n	a8, a1, 0
        ctrl.fdin_oct = 1;
4037d7e3:	0020c0        	memw
4037d7e6:	0188      	l32i.n	a8, a1, 0
4037d7e8:	092c      	movi.n	a9, 32
4037d7ea:	208890        	or	a8, a8, a9
4037d7ed:	0020c0        	memw
4037d7f0:	0189      	s32i.n	a8, a1, 0
        ctrl.fdout_oct = 1;
4037d7f2:	0020c0        	memw
4037d7f5:	0188      	l32i.n	a8, a1, 0
4037d7f7:	091c      	movi.n	a9, 16
4037d7f9:	208890        	or	a8, a8, a9
4037d7fc:	0020c0        	memw
4037d7ff:	0189      	s32i.n	a8, a1, 0
        break;
4037d801:	0014c6        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
        ctrl.faddr_oct = 1;
4037d804:	0020c0        	memw
4037d807:	0188      	l32i.n	a8, a1, 0
4037d809:	094c      	movi.n	a9, 64
4037d80b:	208890        	or	a8, a8, a9
4037d80e:	0020c0        	memw
4037d811:	0189      	s32i.n	a8, a1, 0
        ctrl.fcmd_oct = 1;
4037d813:	0020c0        	memw
4037d816:	0188      	l32i.n	a8, a1, 0
4037d818:	00a292        	movi	a9, 0x200
4037d81b:	208890        	or	a8, a8, a9
4037d81e:	0020c0        	memw
4037d821:	0189      	s32i.n	a8, a1, 0
        ctrl.fdin_oct = 1;
4037d823:	0020c0        	memw
4037d826:	0188      	l32i.n	a8, a1, 0
4037d828:	092c      	movi.n	a9, 32
4037d82a:	208890        	or	a8, a8, a9
4037d82d:	0020c0        	memw
4037d830:	0189      	s32i.n	a8, a1, 0
        ctrl.fdout_oct = 1;
4037d832:	0020c0        	memw
4037d835:	0188      	l32i.n	a8, a1, 0
4037d837:	091c      	movi.n	a9, 16
4037d839:	208890        	or	a8, a8, a9
4037d83c:	0020c0        	memw
4037d83f:	0189      	s32i.n	a8, a1, 0
        dev->ddr.fmem_ddr_en = 1;
4037d841:	0020c0        	memw
4037d844:	382282        	l32i	a8, a2, 224
4037d847:	190c      	movi.n	a9, 1
4037d849:	208890        	or	a8, a8, a9
4037d84c:	0020c0        	memw
4037d84f:	386282        	s32i	a8, a2, 224
        break;
4037d852:	000086        	j	4037d858 <spimem_flash_ll_set_read_mode+0x168>
        abort();
4037d855:	0243e5        	call8	4037fc94 <abort>
    dev->ctrl.val = ctrl.val;
4037d858:	0020c0        	memw
4037d85b:	002182        	l32i	a8, a1, 0
4037d85e:	0020c0        	memw
4037d861:	026282        	s32i	a8, a2, 8
}
4037d864:	000090        	retw
	...

4037d868 <spimem_flash_ll_get_source_freq_mhz>:
{
4037d868:	004136        	entry	a1, 32
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4037d86b:	dbe881        	l32r	a8, 4037480c <_iram_text_start+0x408> (60003000 <SPIMEM0>)
4037d86e:	0020c0        	memw
4037d871:	3b2882        	l32i	a8, a8, 236
4037d874:	148080        	extui	a8, a8, 0, 2
4037d877:	102826        	beqi	a8, 2, 4037d88b <spimem_flash_ll_get_source_freq_mhz+0x23>
4037d87a:	0738f6        	bgeui	a8, 3, 4037d885 <spimem_flash_ll_get_source_freq_mhz+0x1d>
4037d87d:	389c      	beqz.n	a8, 4037d894 <spimem_flash_ll_get_source_freq_mhz+0x2c>
4037d87f:	161826        	beqi	a8, 1, 4037d899 <spimem_flash_ll_get_source_freq_mhz+0x31>
4037d882:	000086        	j	4037d888 <spimem_flash_ll_get_source_freq_mhz+0x20>
4037d885:	173826        	beqi	a8, 3, 4037d8a0 <spimem_flash_ll_get_source_freq_mhz+0x38>
        abort();
4037d888:	0240a5        	call8	4037fc94 <abort>
        clock_val = 160;
4037d88b:	a0a022        	movi	a2, 160
4037d88e:	000446        	j	4037d8a3 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4037d891:	000000        	ill
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4037d894:	025c      	movi.n	a2, 80
4037d896:	000246        	j	4037d8a3 <spimem_flash_ll_get_source_freq_mhz+0x3b>
        clock_val = 120;
4037d899:	78a022        	movi	a2, 120
4037d89c:	0000c6        	j	4037d8a3 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4037d89f:	a02200        	addx4	a2, a2, a0
        clock_val = 240;
4037d8a2:	f01df0        	subx8	a1, a13, a15
4037d8a5:	000000        	ill

4037d8a8 <spimem_flash_ll_program_page>:
{
4037d8a8:	006136        	entry	a1, 48
    dev->user.usr_dummy = 0;
4037d8ab:	0020c0        	memw
4037d8ae:	6288      	l32i.n	a8, a2, 24
4037d8b0:	dbd191        	l32r	a9, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d8b3:	108890        	and	a8, a8, a9
4037d8b6:	0020c0        	memw
4037d8b9:	6289      	s32i.n	a8, a2, 24
    int num_words = (length + 3) / 4;
4037d8bb:	543b      	addi.n	a5, a4, 3
4037d8bd:	415250        	srli	a5, a5, 2
    for (int i = 0; i < num_words; i++) {
4037d8c0:	060c      	movi.n	a6, 0
4037d8c2:	000a86        	j	4037d8f0 <spimem_flash_ll_program_page+0x48>
        uint32_t word = 0;
4037d8c5:	080c      	movi.n	a8, 0
4037d8c7:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037d8c9:	470c      	movi.n	a7, 4
4037d8cb:	637470        	minu	a7, a4, a7
        memcpy(&word, buffer, word_len);
4037d8ce:	07cd      	mov.n	a12, a7
4037d8d0:	20b330        	or	a11, a3, a3
4037d8d3:	20a110        	or	a10, a1, a1
4037d8d6:	daff81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037d8d9:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037d8dc:	14c682        	addi	a8, a6, 20
4037d8df:	a08820        	addx4	a8, a8, a2
4037d8e2:	0198      	l32i.n	a9, a1, 0
4037d8e4:	0020c0        	memw
4037d8e7:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037d8e9:	c04470        	sub	a4, a4, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037d8ec:	373a      	add.n	a3, a7, a3
    for (int i = 0; i < num_words; i++) {
4037d8ee:	661b      	addi.n	a6, a6, 1
4037d8f0:	d12657        	blt	a6, a5, 4037d8c5 <spimem_flash_ll_program_page+0x1d>
    dev->cmd.flash_pp = 1;
4037d8f3:	0020c0        	memw
4037d8f6:	0288      	l32i.n	a8, a2, 0
4037d8f8:	db7291        	l32r	a9, 403746c0 <_iram_text_start+0x2bc> (2000000 <UserFrameTotalSize+0x1ffff00>)
4037d8fb:	208890        	or	a8, a8, a9
4037d8fe:	0020c0        	memw
4037d901:	0289      	s32i.n	a8, a2, 0
}
4037d903:	f01d      	retw.n
4037d905:	000000        	ill

4037d908 <spi_flash_hal_configure_host_io_mode>:
{
4037d908:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d90b:	12a8      	l32i.n	a10, a2, 4
    io_mode = io_mode & 0xFFFF;
4037d90d:	f4b060        	extui	a11, a6, 0, 16
    dev->ctrl.fdummy_out = out_en;
4037d910:	0020c0        	memw
4037d913:	2a88      	l32i.n	a8, a10, 8
4037d915:	056f60        	extui	a6, a6, 31, 1
4037d918:	1166d0        	slli	a6, a6, 3
4037d91b:	797c      	movi.n	a9, -9
4037d91d:	108890        	and	a8, a8, a9
4037d920:	208860        	or	a8, a8, a6
4037d923:	0020c0        	memw
4037d926:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.q_pol = out_lev;
4037d928:	0020c0        	memw
4037d92b:	2a88      	l32i.n	a8, a10, 8
4037d92d:	dbb491        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037d930:	208890        	or	a8, a8, a9
4037d933:	0020c0        	memw
4037d936:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.d_pol = out_lev;
4037d938:	0020c0        	memw
4037d93b:	2a88      	l32i.n	a8, a10, 8
4037d93d:	dc1091        	l32r	a9, 40374980 <_iram_text_start+0x57c> (80000 <UserFrameTotalSize+0x7ff00>)
4037d940:	208890        	or	a8, a8, a9
4037d943:	0020c0        	memw
4037d946:	2a89      	s32i.n	a8, a10, 8
    if (command >= 0x100) {
4037d948:	ffa082        	movi	a8, 255
4037d94b:	62b837        	bgeu	a8, a3, 4037d9b1 <spi_flash_hal_configure_host_io_mode+0xa9>
    dev->user.usr_command = 1;
4037d94e:	0020c0        	memw
4037d951:	6a88      	l32i.n	a8, a10, 24
4037d953:	daf291        	l32r	a9, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d956:	208890        	or	a8, a8, a9
4037d959:	0020c0        	memw
4037d95c:	6a89      	s32i.n	a8, a10, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
4037d95e:	0020c0        	memw
4037d961:	8a88      	l32i.n	a8, a10, 32
4037d963:	0020c0        	memw
4037d966:	3189      	s32i.n	a8, a1, 12
4037d968:	0020c0        	memw
4037d96b:	3188      	l32i.n	a8, a1, 12
4037d96d:	f43030        	extui	a3, a3, 0, 16
4037d970:	f58080        	extui	a8, a8, 16, 16
4037d973:	118800        	slli	a8, a8, 16
4037d976:	208830        	or	a8, a8, a3
4037d979:	0020c0        	memw
4037d97c:	3189      	s32i.n	a8, a1, 12
4037d97e:	0020c0        	memw
4037d981:	3188      	l32i.n	a8, a1, 12
4037d983:	0020c0        	memw
4037d986:	8a89      	s32i.n	a8, a10, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037d988:	0020c0        	memw
4037d98b:	8a88      	l32i.n	a8, a10, 32
4037d98d:	0020c0        	memw
4037d990:	2189      	s32i.n	a8, a1, 8
4037d992:	0020c0        	memw
4037d995:	2188      	l32i.n	a8, a1, 8
4037d997:	dd6c91        	l32r	a9, 40374f48 <_iram_text_start+0xb44> (f0000000 <_rtc_reserved_end+0x8ff00000>)
4037d99a:	208890        	or	a8, a8, a9
4037d99d:	0020c0        	memw
4037d9a0:	2189      	s32i.n	a8, a1, 8
4037d9a2:	0020c0        	memw
4037d9a5:	2188      	l32i.n	a8, a1, 8
4037d9a7:	0020c0        	memw
4037d9aa:	8a89      	s32i.n	a8, a10, 32
}
4037d9ac:	001946        	j	4037da15 <spi_flash_hal_configure_host_io_mode+0x10d>
4037d9af:	c00000        	sub	a0, a0, a0
    dev->user.usr_command = 1;
4037d9b2:	880020        	lsi	f2, a0, 0x220
4037d9b5:	916a      	add.n	a9, a1, a6
4037d9b7:	dad9      	s32i.n	a13, a10, 52
4037d9b9:	208890        	or	a8, a8, a9
4037d9bc:	0020c0        	memw
4037d9bf:	6a89      	s32i.n	a8, a10, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
4037d9c1:	0020c0        	memw
4037d9c4:	8a88      	l32i.n	a8, a10, 32
4037d9c6:	0020c0        	memw
4037d9c9:	1189      	s32i.n	a8, a1, 4
4037d9cb:	0020c0        	memw
4037d9ce:	1188      	l32i.n	a8, a1, 4
4037d9d0:	f43030        	extui	a3, a3, 0, 16
4037d9d3:	f58080        	extui	a8, a8, 16, 16
4037d9d6:	118800        	slli	a8, a8, 16
4037d9d9:	208830        	or	a8, a8, a3
4037d9dc:	0020c0        	memw
4037d9df:	1189      	s32i.n	a8, a1, 4
4037d9e1:	0020c0        	memw
4037d9e4:	1188      	l32i.n	a8, a1, 4
4037d9e6:	0020c0        	memw
4037d9e9:	8a89      	s32i.n	a8, a10, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037d9eb:	0020c0        	memw
4037d9ee:	8a88      	l32i.n	a8, a10, 32
4037d9f0:	0020c0        	memw
4037d9f3:	0189      	s32i.n	a8, a1, 0
4037d9f5:	0020c0        	memw
4037d9f8:	0188      	l32i.n	a8, a1, 0
4037d9fa:	1188c0        	slli	a8, a8, 4
4037d9fd:	418480        	srli	a8, a8, 4
4037da00:	db7a91        	l32r	a9, 403747e8 <_iram_text_start+0x3e4> (70000000 <_rtc_reserved_end+0xff00000>)
4037da03:	208890        	or	a8, a8, a9
4037da06:	0020c0        	memw
4037da09:	0189      	s32i.n	a8, a1, 0
4037da0b:	0020c0        	memw
4037da0e:	0188      	l32i.n	a8, a1, 0
4037da10:	0020c0        	memw
4037da13:	8a89      	s32i.n	a8, a10, 32
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037da15:	e0c482        	addi	a8, a4, -32
4037da18:	0020c0        	memw
4037da1b:	fa98      	l32i.n	a9, a10, 60
4037da1d:	40f880        	nsau	a8, a8
4037da20:	418580        	srli	a8, a8, 5
4037da23:	888a      	add.n	a8, a8, a8
4037da25:	dc7c      	movi.n	a12, -3
4037da27:	1099c0        	and	a9, a9, a12
4037da2a:	208980        	or	a8, a9, a8
4037da2d:	0020c0        	memw
4037da30:	fa89      	s32i.n	a8, a10, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037da32:	940b      	addi.n	a9, a4, -1
4037da34:	0020c0        	memw
4037da37:	7a88      	l32i.n	a8, a10, 28
4037da39:	019960        	slli	a9, a9, 26
4037da3c:	1188a0        	slli	a8, a8, 6
4037da3f:	418680        	srli	a8, a8, 6
4037da42:	208890        	or	a8, a8, a9
4037da45:	0020c0        	memw
4037da48:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037da4a:	0020c0        	memw
4037da4d:	6a88      	l32i.n	a8, a10, 24
4037da4f:	190c      	movi.n	a9, 1
4037da51:	839440        	moveqz	a9, a4, a4
4037da54:	019920        	slli	a9, a9, 30
4037da57:	db65c1        	l32r	a12, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037da5a:	1088c0        	and	a8, a8, a12
4037da5d:	208890        	or	a8, a8, a9
4037da60:	0020c0        	memw
4037da63:	6a89      	s32i.n	a8, a10, 24
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037da65:	0c0282        	l8ui	a8, a2, 12
4037da68:	585a      	add.n	a5, a8, a5
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037da6a:	0020c0        	memw
4037da6d:	6a88      	l32i.n	a8, a10, 24
4037da6f:	190c      	movi.n	a9, 1
4037da71:	839550        	moveqz	a9, a5, a5
4037da74:	019930        	slli	a9, a9, 29
4037da77:	db5fc1        	l32r	a12, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037da7a:	1088c0        	and	a8, a8, a12
4037da7d:	208890        	or	a8, a8, a9
4037da80:	0020c0        	memw
4037da83:	6a89      	s32i.n	a8, a10, 24
    if (dummy_n > 0) {
4037da85:	659c      	beqz.n	a5, 4037da9f <spi_flash_hal_configure_host_io_mode+0x197>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037da87:	550b      	addi.n	a5, a5, -1
4037da89:	0020c0        	memw
4037da8c:	7a88      	l32i.n	a8, a10, 28
4037da8e:	545050        	extui	a5, a5, 0, 6
4037da91:	c0af92        	movi	a9, -64
4037da94:	108890        	and	a8, a8, a9
4037da97:	208850        	or	a8, a8, a5
4037da9a:	0020c0        	memw
4037da9d:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_miso = bitlen > 0;
4037da9f:	0020c0        	memw
4037daa2:	6a88      	l32i.n	a8, a10, 24
4037daa4:	db5691        	l32r	a9, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037daa7:	108890        	and	a8, a8, a9
4037daaa:	0020c0        	memw
4037daad:	6a89      	s32i.n	a8, a10, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037daaf:	0020c0        	memw
4037dab2:	aa88      	l32i.n	a8, a10, 40
4037dab4:	00ac92        	movi	a9, 0xfffffc00
4037dab7:	108890        	and	a8, a8, a9
4037daba:	0020c0        	memw
4037dabd:	aa89      	s32i.n	a8, a10, 40
    dev->user.usr_mosi = bitlen > 0;
4037dabf:	0020c0        	memw
4037dac2:	6a88      	l32i.n	a8, a10, 24
4037dac4:	db4dc1        	l32r	a12, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037dac7:	1088c0        	and	a8, a8, a12
4037daca:	0020c0        	memw
4037dacd:	6a89      	s32i.n	a8, a10, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037dacf:	0020c0        	memw
4037dad2:	9a88      	l32i.n	a8, a10, 36
4037dad4:	108890        	and	a8, a8, a9
4037dad7:	0020c0        	memw
4037dada:	096a82        	s32i	a8, a10, 36
    spi_flash_ll_set_read_mode(dev, io_mode);
4037dadd:	ffc125        	call8	4037d6f0 <spimem_flash_ll_set_read_mode>
}
4037dae0:	020c      	movi.n	a2, 0
4037dae2:	f01d      	retw.n

4037dae4 <spi_flash_hal_common_command>:
{
4037dae4:	008136        	entry	a1, 64
4037dae7:	028d      	mov.n	a8, a2
4037dae9:	5129      	s32i.n	a2, a1, 20
    return ((spi_flash_hal_context_t*)host)->spi;
4037daeb:	1228      	l32i.n	a2, a2, 4
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037daed:	58e8      	l32i.n	a14, a8, 20
    command = trans->command;
4037daef:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037daf2:	160372        	l8ui	a7, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037daf5:	4388      	l32i.n	a8, a3, 16
4037daf7:	016817        	bbci	a8, 1, 4037dafc <spi_flash_hal_common_command+0x18>
        io_mode = trans->io_mode;
4037dafa:	63e8      	l32i.n	a14, a3, 24
    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037dafc:	51a8      	l32i.n	a10, a1, 20
4037dafe:	0a88      	l32i.n	a8, a10, 0
4037db00:	f888      	l32i.n	a8, a8, 60
4037db02:	07dd      	mov.n	a13, a7
4037db04:	0303c2        	l8ui	a12, a3, 3
4037db07:	0008e0        	callx8	a8
    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037db0a:	1388      	l32i.n	a8, a3, 4
    dev->addr = addr;
4037db0c:	0020c0        	memw
4037db0f:	1289      	s32i.n	a8, a2, 4
    if (trans->miso_len == 0) {
4037db11:	020382        	l8ui	a8, a3, 2
4037db14:	48fc      	bnez.n	a8, 4037db4c <spi_flash_hal_common_command+0x68>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037db16:	0020c0        	memw
4037db19:	6288      	l32i.n	a8, a2, 24
4037db1b:	190c      	movi.n	a9, 1
4037db1d:	839770        	moveqz	a9, a7, a7
4037db20:	019930        	slli	a9, a9, 29
4037db23:	db34a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037db26:	1088a0        	and	a8, a8, a10
4037db29:	208890        	or	a8, a8, a9
4037db2c:	0020c0        	memw
4037db2f:	6289      	s32i.n	a8, a2, 24
    if (dummy_n > 0) {
4037db31:	779c      	beqz.n	a7, 4037db4c <spi_flash_hal_common_command+0x68>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037db33:	770b      	addi.n	a7, a7, -1
4037db35:	0020c0        	memw
4037db38:	7288      	l32i.n	a8, a2, 28
4037db3a:	547070        	extui	a7, a7, 0, 6
4037db3d:	c0af92        	movi	a9, -64
4037db40:	108890        	and	a8, a8, a9
4037db43:	208870        	or	a8, a8, a7
4037db46:	0020c0        	memw
4037db49:	076282        	s32i	a8, a2, 28
    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037db4c:	0103a2        	l8ui	a10, a3, 1
4037db4f:	118ad0        	slli	a8, a10, 3
    dev->user.usr_mosi = bitlen > 0;
4037db52:	0020c0        	memw
4037db55:	6298      	l32i.n	a9, a2, 24
4037db57:	1b0c      	movi.n	a11, 1
4037db59:	83baa0        	moveqz	a11, a10, a10
4037db5c:	01bb50        	slli	a11, a11, 27
4037db5f:	db26c1        	l32r	a12, 403747f8 <_iram_text_start+0x3f4> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037db62:	1099c0        	and	a9, a9, a12
4037db65:	2099b0        	or	a9, a9, a11
4037db68:	0020c0        	memw
4037db6b:	6299      	s32i.n	a9, a2, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037db6d:	7a8c      	beqz.n	a10, 4037db78 <spi_flash_hal_common_command+0x94>
4037db6f:	880b      	addi.n	a8, a8, -1
4037db71:	948080        	extui	a8, a8, 0, 10
4037db74:	000086        	j	4037db7a <spi_flash_hal_common_command+0x96>
4037db77:	080c00        	lsx	f0, a12, a0
4037db7a:	0020c0        	memw
4037db7d:	9298      	l32i.n	a9, a2, 36
4037db7f:	00aca2        	movi	a10, 0xfffffc00
4037db82:	1099a0        	and	a9, a9, a10
4037db85:	208890        	or	a8, a8, a9
4037db88:	0020c0        	memw
4037db8b:	9289      	s32i.n	a8, a2, 36
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037db8d:	2348      	l32i.n	a4, a3, 8
4037db8f:	010352        	l8ui	a5, a3, 1
    int num_words = (length + 3) / 4;
4037db92:	853b      	addi.n	a8, a5, 3
4037db94:	418280        	srli	a8, a8, 2
4037db97:	4189      	s32i.n	a8, a1, 16
    for (int i = 0; i < num_words; i++) {
4037db99:	060c      	movi.n	a6, 0
4037db9b:	000a46        	j	4037dbc8 <spi_flash_hal_common_command+0xe4>
        uint32_t word = 0;
4037db9e:	080c      	movi.n	a8, 0
4037dba0:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037dba2:	470c      	movi.n	a7, 4
4037dba4:	637570        	minu	a7, a5, a7
        memcpy(&word, buffer, word_len);
4037dba7:	07cd      	mov.n	a12, a7
4037dba9:	04bd      	mov.n	a11, a4
4037dbab:	20a110        	or	a10, a1, a1
4037dbae:	da4981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dbb1:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037dbb4:	14c682        	addi	a8, a6, 20
4037dbb7:	a08820        	addx4	a8, a8, a2
4037dbba:	0198      	l32i.n	a9, a1, 0
4037dbbc:	0020c0        	memw
4037dbbf:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037dbc1:	c05570        	sub	a5, a5, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037dbc4:	474a      	add.n	a4, a7, a4
    for (int i = 0; i < num_words; i++) {
4037dbc6:	661b      	addi.n	a6, a6, 1
4037dbc8:	4188      	l32i.n	a8, a1, 16
4037dbca:	d02687        	blt	a6, a8, 4037db9e <spi_flash_hal_common_command+0xba>
    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037dbcd:	0203a2        	l8ui	a10, a3, 2
4037dbd0:	118ad0        	slli	a8, a10, 3
    dev->user.usr_miso = bitlen > 0;
4037dbd3:	0020c0        	memw
4037dbd6:	6298      	l32i.n	a9, a2, 24
4037dbd8:	1b0c      	movi.n	a11, 1
4037dbda:	83baa0        	moveqz	a11, a10, a10
4037dbdd:	01bb40        	slli	a11, a11, 28
4037dbe0:	db07c1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037dbe3:	1099c0        	and	a9, a9, a12
4037dbe6:	2099b0        	or	a9, a9, a11
4037dbe9:	0020c0        	memw
4037dbec:	6299      	s32i.n	a9, a2, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037dbee:	6a8c      	beqz.n	a10, 4037dbf8 <spi_flash_hal_common_command+0x114>
4037dbf0:	880b      	addi.n	a8, a8, -1
4037dbf2:	948080        	extui	a8, a8, 0, 10
4037dbf5:	000046        	j	4037dbfa <spi_flash_hal_common_command+0x116>
4037dbf8:	080c      	movi.n	a8, 0
4037dbfa:	0020c0        	memw
4037dbfd:	a298      	l32i.n	a9, a2, 40
4037dbff:	00aca2        	movi	a10, 0xfffffc00
4037dc02:	1099a0        	and	a9, a9, a10
4037dc05:	208890        	or	a8, a8, a9
4037dc08:	0020c0        	memw
4037dc0b:	a289      	s32i.n	a8, a2, 40
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_PE_CMD) != 0) {
4037dc0d:	4388      	l32i.n	a8, a3, 16
4037dc0f:	06e837        	bbsi	a8, 3, 4037dc19 <spi_flash_hal_common_command+0x135>
    uint32_t usr_pe = (pe_ops ? 0x60000 : 0x40000);
4037dc12:	dafb91        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037dc15:	0000c6        	j	4037dc1c <spi_flash_hal_common_command+0x138>
4037dc18:	5e9100        	f64rnd	a9, a1, a0, 1
4037dc1b:	c0db      	addi.n	a12, a0, 13
    dev->cmd.val |= usr_pe;
4037dc1d:	880020        	lsi	f2, a0, 0x220
4037dc20:	889002        	l16si	a0, a0, 0x110
4037dc23:	20c020        	or	a12, a0, a2
4037dc26:	028900        	andb	b8, b9, b0
    host->driver->poll_cmd_done(host);
4037dc29:	51a8      	l32i.n	a10, a1, 20
4037dc2b:	002a82        	l32i	a8, a10, 0
4037dc2e:	102882        	l32i	a8, a8, 64
4037dc31:	0008e0        	callx8	a8
    if (trans->miso_len > 0) {
4037dc34:	020342        	l8ui	a4, a3, 2
4037dc37:	052416        	beqz	a4, 4037dc8d <spi_flash_hal_common_command+0x1a9>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037dc3a:	3358      	l32i.n	a5, a3, 12
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037dc3c:	148050        	extui	a8, a5, 0, 2
4037dc3f:	58dc      	bnez.n	a8, 4037dc58 <spi_flash_hal_common_command+0x174>
4037dc41:	148040        	extui	a8, a4, 0, 2
4037dc44:	08dc      	bnez.n	a8, 4037dc58 <spi_flash_hal_common_command+0x174>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037dc46:	04cd      	mov.n	a12, a4
4037dc48:	58c2b2        	addi	a11, a2, 88
4037dc4b:	20a550        	or	a10, a5, a5
4037dc4e:	da2181        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dc51:	0008e0        	callx8	a8
4037dc54:	000d46        	j	4037dc8d <spi_flash_hal_common_command+0x1a9>
4037dc57:	043d00        	extui	a3, a0, 13, 1
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dc5a:	060c      	movi.n	a6, 0
4037dc5c:	000946        	j	4037dc85 <spi_flash_hal_common_command+0x1a1>
4037dc5f:	470c00        	lsi	f0, a12, 0x11c
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037dc62:	637370        	minu	a7, a3, a7
            uint32_t word = dev->data_buf[i];
4037dc65:	14c682        	addi	a8, a6, 20
4037dc68:	a08820        	addx4	a8, a8, a2
4037dc6b:	0020c0        	memw
4037dc6e:	2888      	l32i.n	a8, a8, 8
4037dc70:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037dc72:	07cd      	mov.n	a12, a7
4037dc74:	01bd      	mov.n	a11, a1
4037dc76:	05ad      	mov.n	a10, a5
4037dc78:	da1781        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dc7b:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037dc7e:	575a      	add.n	a5, a7, a5
            copy_len -= word_len;
4037dc80:	c03370        	sub	a3, a3, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dc83:	661b      	addi.n	a6, a6, 1
4037dc85:	843b      	addi.n	a8, a4, 3
4037dc87:	418280        	srli	a8, a8, 2
4037dc8a:	d23687        	bltu	a6, a8, 4037dc60 <spi_flash_hal_common_command+0x17c>
}
4037dc8d:	020c      	movi.n	a2, 0
4037dc8f:	f01d      	retw.n
4037dc91:	000000        	ill

4037dc94 <spi_flash_hal_read>:
{
4037dc94:	006136        	entry	a1, 48
4037dc97:	02ad      	mov.n	a10, a2
4037dc99:	052d      	mov.n	a2, a5
    return ((spi_flash_hal_context_t*)host)->spi;
4037dc9b:	1a58      	l32i.n	a5, a10, 4
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037dc9d:	0020c0        	memw
4037dca0:	062582        	l32i	a8, a5, 24
4037dca3:	0578e7        	bbci	a8, 30, 4037dcac <spi_flash_hal_read+0x18>
4037dca6:	0020c0        	memw
4037dca9:	072582        	l32i	a8, a5, 28
    dev->addr = addr;
4037dcac:	0020c0        	memw
4037dcaf:	1549      	s32i.n	a4, a5, 4
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037dcb1:	1182d0        	slli	a8, a2, 3
    dev->user.usr_miso = bitlen > 0;
4037dcb4:	0020c0        	memw
4037dcb7:	6598      	l32i.n	a9, a5, 24
4037dcb9:	1b0c      	movi.n	a11, 1
4037dcbb:	83b880        	moveqz	a11, a8, a8
4037dcbe:	01bb40        	slli	a11, a11, 28
4037dcc1:	dacec1        	l32r	a12, 403747fc <_iram_text_start+0x3f8> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037dcc4:	1099c0        	and	a9, a9, a12
4037dcc7:	2099b0        	or	a9, a9, a11
4037dcca:	0020c0        	memw
4037dccd:	6599      	s32i.n	a9, a5, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037dccf:	688c      	beqz.n	a8, 4037dcd9 <spi_flash_hal_read+0x45>
4037dcd1:	880b      	addi.n	a8, a8, -1
4037dcd3:	948080        	extui	a8, a8, 0, 10
4037dcd6:	000046        	j	4037dcdb <spi_flash_hal_read+0x47>
4037dcd9:	080c      	movi.n	a8, 0
4037dcdb:	0020c0        	memw
4037dcde:	a598      	l32i.n	a9, a5, 40
4037dce0:	00acb2        	movi	a11, 0xfffffc00
4037dce3:	1099b0        	and	a9, a9, a11
4037dce6:	208890        	or	a8, a8, a9
4037dce9:	0020c0        	memw
4037dcec:	a589      	s32i.n	a8, a5, 40
    dev->cmd.val |= usr_pe;
4037dcee:	0020c0        	memw
4037dcf1:	0588      	l32i.n	a8, a5, 0
4037dcf3:	dac391        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (40000 <UserFrameTotalSize+0x3ff00>)
4037dcf6:	208890        	or	a8, a8, a9
4037dcf9:	0020c0        	memw
4037dcfc:	006582        	s32i	a8, a5, 0
    host->driver->poll_cmd_done(host);
4037dcff:	002a82        	l32i	a8, a10, 0
4037dd02:	102882        	l32i	a8, a8, 64
4037dd05:	0008e0        	callx8	a8
    if (read_len > 0) {
4037dd08:	051216        	beqz	a2, 4037dd5d <spi_flash_hal_read+0xc9>
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037dd0b:	148030        	extui	a8, a3, 0, 2
4037dd0e:	68dc      	bnez.n	a8, 4037dd28 <spi_flash_hal_read+0x94>
4037dd10:	148020        	extui	a8, a2, 0, 2
4037dd13:	18dc      	bnez.n	a8, 4037dd28 <spi_flash_hal_read+0x94>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037dd15:	20c220        	or	a12, a2, a2
4037dd18:	58c5b2        	addi	a11, a5, 88
4037dd1b:	20a330        	or	a10, a3, a3
4037dd1e:	d9ed81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dd21:	0008e0        	callx8	a8
4037dd24:	000d46        	j	4037dd5d <spi_flash_hal_read+0xc9>
4037dd27:	024d00        	andb	b4, b13, b0
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dd2a:	060c      	movi.n	a6, 0
4037dd2c:	000946        	j	4037dd55 <spi_flash_hal_read+0xc1>
4037dd2f:	470c00        	lsi	f0, a12, 0x11c
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037dd32:	637470        	minu	a7, a4, a7
            uint32_t word = dev->data_buf[i];
4037dd35:	14c682        	addi	a8, a6, 20
4037dd38:	a08850        	addx4	a8, a8, a5
4037dd3b:	0020c0        	memw
4037dd3e:	2888      	l32i.n	a8, a8, 8
4037dd40:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037dd42:	07cd      	mov.n	a12, a7
4037dd44:	01bd      	mov.n	a11, a1
4037dd46:	03ad      	mov.n	a10, a3
4037dd48:	d9e381        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037dd4b:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037dd4e:	373a      	add.n	a3, a7, a3
            copy_len -= word_len;
4037dd50:	c04470        	sub	a4, a4, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dd53:	661b      	addi.n	a6, a6, 1
4037dd55:	823b      	addi.n	a8, a2, 3
4037dd57:	418280        	srli	a8, a8, 2
4037dd5a:	d23687        	bltu	a6, a8, 4037dd30 <spi_flash_hal_read+0x9c>
}
4037dd5d:	020c      	movi.n	a2, 0
4037dd5f:	f01d      	retw.n
4037dd61:	000000        	ill

4037dd64 <spi_flash_hal_erase_chip>:
//  - MEMSPI
//  - SPI1~3 on ESP32/S2/S3/C3/H4/C2
// The common part is in spi_flash_hal_common.inc

void spi_flash_hal_erase_chip(spi_flash_host_inst_t *host)
{
4037dd64:	004136        	entry	a1, 32
4037dd67:	02ad      	mov.n	a10, a2
    return ((spi_flash_hal_context_t*)host)->spi;
4037dd69:	1298      	l32i.n	a9, a2, 4
    dev->cmd.flash_ce = 1;
4037dd6b:	0020c0        	memw
4037dd6e:	0988      	l32i.n	a8, a9, 0
4037dd70:	dc78b1        	l32r	a11, 40374f50 <_iram_text_start+0xb4c> (400000 <UserFrameTotalSize+0x3fff00>)
4037dd73:	2088b0        	or	a8, a8, a11
4037dd76:	0020c0        	memw
4037dd79:	0989      	s32i.n	a8, a9, 0
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_erase_chip(dev);
#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037dd7b:	6288      	l32i.n	a8, a2, 24
4037dd7d:	07e807        	bbsi	a8, 0, 4037dd88 <spi_flash_hal_erase_chip+0x24>
        host->driver->poll_cmd_done(host);
4037dd80:	0288      	l32i.n	a8, a2, 0
4037dd82:	102882        	l32i	a8, a8, 64
4037dd85:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037dd88:	f01d      	retw.n
	...

4037dd8c <spi_flash_hal_erase_sector>:

// Only support 24bit address
void spi_flash_hal_erase_sector(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037dd8c:	004136        	entry	a1, 32
4037dd8f:	02ad      	mov.n	a10, a2
4037dd91:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037dd93:	0020c0        	memw
4037dd96:	f898      	l32i.n	a9, a8, 60
4037dd98:	db7c      	movi.n	a11, -3
4037dd9a:	1099b0        	and	a9, a9, a11
4037dd9d:	0020c0        	memw
4037dda0:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037dda2:	0020c0        	memw
4037dda5:	7898      	l32i.n	a9, a8, 28
4037dda7:	1199a0        	slli	a9, a9, 6
4037ddaa:	419690        	srli	a9, a9, 6
4037ddad:	dc69b1        	l32r	a11, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
4037ddb0:	2099b0        	or	a9, a9, a11
4037ddb3:	0020c0        	memw
4037ddb6:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037ddb8:	0020c0        	memw
4037ddbb:	6898      	l32i.n	a9, a8, 24
4037ddbd:	da0db1        	l32r	a11, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037ddc0:	2099b0        	or	a9, a9, a11
4037ddc3:	0020c0        	memw
4037ddc6:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037ddc8:	113380        	slli	a3, a3, 8
4037ddcb:	413830        	srli	a3, a3, 8
    dev->addr = addr;
4037ddce:	0020c0        	memw
4037ddd1:	1839      	s32i.n	a3, a8, 4
    dev->ctrl.val = 0;
4037ddd3:	090c      	movi.n	a9, 0
4037ddd5:	0020c0        	memw
4037ddd8:	2899      	s32i.n	a9, a8, 8
    dev->cmd.flash_se = 1;
4037ddda:	0020c0        	memw
4037dddd:	0898      	l32i.n	a9, a8, 0
4037dddf:	dab5b1        	l32r	a11, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4037dde2:	2099b0        	or	a9, a9, a11
4037dde5:	0020c0        	memw
4037dde8:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_sector(dev);

#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037ddea:	6288      	l32i.n	a8, a2, 24
4037ddec:	08e807        	bbsi	a8, 0, 4037ddf8 <spi_flash_hal_erase_sector+0x6c>
        host->driver->poll_cmd_done(host);
4037ddef:	002282        	l32i	a8, a2, 0
4037ddf2:	102882        	l32i	a8, a8, 64
4037ddf5:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037ddf8:	f01d      	retw.n
	...

4037ddfc <spi_flash_hal_erase_block>:

// Only support 24bit address
void spi_flash_hal_erase_block(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037ddfc:	004136        	entry	a1, 32
4037ddff:	02ad      	mov.n	a10, a2
4037de01:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037de03:	0020c0        	memw
4037de06:	f898      	l32i.n	a9, a8, 60
4037de08:	db7c      	movi.n	a11, -3
4037de0a:	1099b0        	and	a9, a9, a11
4037de0d:	0020c0        	memw
4037de10:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037de12:	0020c0        	memw
4037de15:	7898      	l32i.n	a9, a8, 28
4037de17:	1199a0        	slli	a9, a9, 6
4037de1a:	419690        	srli	a9, a9, 6
4037de1d:	dc4db1        	l32r	a11, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
4037de20:	2099b0        	or	a9, a9, a11
4037de23:	0020c0        	memw
4037de26:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037de28:	0020c0        	memw
4037de2b:	6898      	l32i.n	a9, a8, 24
4037de2d:	d9f1b1        	l32r	a11, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037de30:	2099b0        	or	a9, a9, a11
4037de33:	0020c0        	memw
4037de36:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037de38:	113380        	slli	a3, a3, 8
4037de3b:	413830        	srli	a3, a3, 8
    dev->addr = addr;
4037de3e:	0020c0        	memw
4037de41:	1839      	s32i.n	a3, a8, 4
    dev->cmd.flash_be = 1;
4037de43:	0020c0        	memw
4037de46:	0898      	l32i.n	a9, a8, 0
4037de48:	dadab1        	l32r	a11, 403749b0 <_iram_text_start+0x5ac> (800000 <UserFrameTotalSize+0x7fff00>)
4037de4b:	2099b0        	or	a9, a9, a11
4037de4e:	0020c0        	memw
4037de51:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_block(dev);
#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037de53:	6288      	l32i.n	a8, a2, 24
4037de55:	07e807        	bbsi	a8, 0, 4037de60 <spi_flash_hal_erase_block+0x64>
        host->driver->poll_cmd_done(host);
4037de58:	0288      	l32i.n	a8, a2, 0
4037de5a:	102882        	l32i	a8, a8, 64
4037de5d:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037de60:	f01d      	retw.n
	...

4037de64 <spi_flash_hal_program_page>:

// Only support 24bit address
void spi_flash_hal_program_page(spi_flash_host_inst_t *host, const void *buffer, uint32_t address, uint32_t length)
{
4037de64:	004136        	entry	a1, 32
4037de67:	03bd      	mov.n	a11, a3
4037de69:	05cd      	mov.n	a12, a5
4037de6b:	12a8      	l32i.n	a10, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037de6d:	0020c0        	memw
4037de70:	fa88      	l32i.n	a8, a10, 60
4037de72:	d97c      	movi.n	a9, -3
4037de74:	108890        	and	a8, a8, a9
4037de77:	0020c0        	memw
4037de7a:	fa89      	s32i.n	a8, a10, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037de7c:	0020c0        	memw
4037de7f:	7a88      	l32i.n	a8, a10, 28
4037de81:	1188a0        	slli	a8, a8, 6
4037de84:	418680        	srli	a8, a8, 6
4037de87:	dc3391        	l32r	a9, 40374f54 <_iram_text_start+0xb50> (5c000000 <_coredump_rtc_end+0xc000000>)
4037de8a:	208890        	or	a8, a8, a9
4037de8d:	0020c0        	memw
4037de90:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037de92:	0020c0        	memw
4037de95:	6a88      	l32i.n	a8, a10, 24
4037de97:	d9d791        	l32r	a9, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037de9a:	208890        	or	a8, a8, a9
4037de9d:	0020c0        	memw
4037dea0:	6a89      	s32i.n	a8, a10, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, (address & ADDRESS_MASK_24BIT) | (length << 24));
4037dea2:	114480        	slli	a4, a4, 8
4037dea5:	414840        	srli	a4, a4, 8
4037dea8:	018580        	slli	a8, a5, 24
4037deab:	204480        	or	a4, a4, a8
    dev->addr = addr;
4037deae:	0020c0        	memw
4037deb1:	1a49      	s32i.n	a4, a10, 4
    spi_flash_ll_program_page(dev, buffer, length);
4037deb3:	ff9f65        	call8	4037d8a8 <spimem_flash_ll_program_page>
    host->driver->poll_cmd_done(host);
4037deb6:	0288      	l32i.n	a8, a2, 0
4037deb8:	102882        	l32i	a8, a8, 64
4037debb:	02ad      	mov.n	a10, a2
4037debd:	0008e0        	callx8	a8
}
4037dec0:	f01d      	retw.n
	...

4037dec4 <spi_flash_hal_set_write_protect>:

esp_err_t spi_flash_hal_set_write_protect(spi_flash_host_inst_t *host, bool wp)
{
4037dec4:	004136        	entry	a1, 32
4037dec7:	02ad      	mov.n	a10, a2
4037dec9:	743030        	extui	a3, a3, 0, 8
4037decc:	1288      	l32i.n	a8, a2, 4
    if (wp) {
4037dece:	239c      	beqz.n	a3, 4037dee4 <spi_flash_hal_set_write_protect+0x20>
        dev->cmd.flash_wrdi = 1;
4037ded0:	0020c0        	memw
4037ded3:	0898      	l32i.n	a9, a8, 0
4037ded5:	dac0b1        	l32r	a11, 403749d8 <_iram_text_start+0x5d4> (20000000 <UserFrameTotalSize+0x1fffff00>)
4037ded8:	2099b0        	or	a9, a9, a11
4037dedb:	0020c0        	memw
4037dede:	0899      	s32i.n	a9, a8, 0
4037dee0:	000406        	j	4037def4 <spi_flash_hal_set_write_protect+0x30>
4037dee3:	20c000        	or	a12, a0, a0
        dev->cmd.flash_wren = 1;
4037dee6:	089800        	lsx	f9, a8, a0
4037dee9:	d9c2b1        	l32r	a11, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037deec:	2099b0        	or	a9, a9, a11
4037deef:	0020c0        	memw
4037def2:	0899      	s32i.n	a9, a8, 0
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_write_protect(dev, wp);
    host->driver->poll_cmd_done(host);
4037def4:	0a88      	l32i.n	a8, a10, 0
4037def6:	102882        	l32i	a8, a8, 64
4037def9:	0008e0        	callx8	a8
    return ESP_OK;
}
4037defc:	020c      	movi.n	a2, 0
4037defe:	f01d      	retw.n

4037df00 <spi_flash_hal_setup_read_suspend>:
    //status and sus_status should be mutual exclusion
    return (status | sus_status);
}

esp_err_t spi_flash_hal_setup_read_suspend(spi_flash_host_inst_t *host, const spi_flash_sus_cmd_conf *sus_conf)
{
4037df00:	006136        	entry	a1, 48
#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
    spi_mem_dev_t *dev = (spi_mem_dev_t *)spi_flash_ll_get_hw(SPI1_HOST);
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    memcpy(&(ctx->sus_cfg), sus_conf, sizeof(spi_flash_sus_cmd_conf));
4037df03:	8c0c      	movi.n	a12, 8
4037df05:	03bd      	mov.n	a11, a3
4037df07:	1cc2a2        	addi	a10, a2, 28
4037df0a:	d97281        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037df0d:	0008e0        	callx8	a8
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_sus_ctrl, flash_pes_command, sus_cmd);
4037df10:	da3491        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037df13:	0020c0        	memw
4037df16:	282982        	l32i	a8, a9, 160
4037df19:	0020c0        	memw
4037df1c:	0189      	s32i.n	a8, a1, 0
4037df1e:	0020c0        	memw
4037df21:	0188      	l32i.n	a8, a1, 0
4037df23:	0503a2        	l8ui	a10, a3, 5
4037df26:	11aa70        	slli	a10, a10, 9
4037df29:	dc0bb1        	l32r	a11, 40374f58 <_iram_text_start+0xb54> (fffe01ff <_rtc_reserved_end+0x9fee01ff>)
4037df2c:	1088b0        	and	a8, a8, a11
4037df2f:	2088a0        	or	a8, a8, a10
4037df32:	0020c0        	memw
4037df35:	0189      	s32i.n	a8, a1, 0
4037df37:	0020c0        	memw
4037df3a:	0188      	l32i.n	a8, a1, 0
4037df3c:	0020c0        	memw
4037df3f:	286982        	s32i	a8, a9, 160
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_sus_ctrl, flash_per_command, res_cmd);
4037df42:	0020c0        	memw
4037df45:	282982        	l32i	a8, a9, 160
4037df48:	0020c0        	memw
4037df4b:	1189      	s32i.n	a8, a1, 4
4037df4d:	0020c0        	memw
4037df50:	1188      	l32i.n	a8, a1, 4
4037df52:	0603a2        	l8ui	a10, a3, 6
4037df55:	aaaa      	add.n	a10, a10, a10
4037df57:	01aeb2        	movi	a11, 0xfffffe01
4037df5a:	1088b0        	and	a8, a8, a11
4037df5d:	2088a0        	or	a8, a8, a10
4037df60:	0020c0        	memw
4037df63:	1189      	s32i.n	a8, a1, 4
4037df65:	0020c0        	memw
4037df68:	1188      	l32i.n	a8, a1, 4
4037df6a:	0020c0        	memw
4037df6d:	286982        	s32i	a8, a9, 160
    spimem_flash_ll_set_read_sus_status(dev, sus_conf->sus_mask);
    spimem_flash_ll_rd_sus_cmd_setup(dev, sus_conf->cmd_rdsr);
#endif // SOC_SPI_MEM_SUPPORT_CHECK_SUS
#endif // SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
    return ESP_OK;
}
4037df70:	020c      	movi.n	a2, 0
4037df72:	f01d      	retw.n

4037df74 <spi_flash_hal_setup_auto_suspend_mode>:

#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
void spi_flash_hal_setup_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037df74:	006136        	entry	a1, 48
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    bool pes_waiti_delay = ctx->auto_waiti_pes ? false : true;
4037df77:	2d02a2        	l8ui	a10, a2, 45
4037df7a:	180c      	movi.n	a8, 1
4037df7c:	30aa80        	xor	a10, a10, a8
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05);
4037df7f:	da1881        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037df82:	0020c0        	memw
4037df85:	262892        	l32i	a9, a8, 152
4037df88:	0020c0        	memw
4037df8b:	0199      	s32i.n	a9, a1, 0
4037df8d:	0020c0        	memw
4037df90:	0198      	l32i.n	a9, a1, 0
4037df92:	03acb2        	movi	a11, 0xfffffc03
4037df95:	1099b0        	and	a9, a9, a11
4037df98:	4b1c      	movi.n	a11, 20
4037df9a:	2099b0        	or	a9, a9, a11
4037df9d:	0020c0        	memw
4037dfa0:	0199      	s32i.n	a9, a1, 0
4037dfa2:	0020c0        	memw
4037dfa5:	0198      	l32i.n	a9, a1, 0
4037dfa7:	0020c0        	memw
4037dfaa:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = (per_waiti | pes_waiti);  // enable auto wait-idle function.
4037dfad:	0020c0        	memw
4037dfb0:	262892        	l32i	a9, a8, 152
4037dfb3:	1b0c      	movi.n	a11, 1
4037dfb5:	2099b0        	or	a9, a9, a11
4037dfb8:	0020c0        	memw
4037dfbb:	266892        	s32i	a9, a8, 152
    dev->flash_sus_cmd.flash_per_wait_en = per_waiti;
4037dfbe:	0020c0        	memw
4037dfc1:	272892        	l32i	a9, a8, 156
4037dfc4:	4b0c      	movi.n	a11, 4
4037dfc6:	2099b0        	or	a9, a9, a11
4037dfc9:	0020c0        	memw
4037dfcc:	276892        	s32i	a9, a8, 156
    dev->flash_sus_cmd.flash_pes_wait_en = pes_waiti;
4037dfcf:	0020c0        	memw
4037dfd2:	272892        	l32i	a9, a8, 156
4037dfd5:	04a0a0        	extui	a10, a10, 0, 1
4037dfd8:	11aad0        	slli	a10, a10, 3
4037dfdb:	7b7c      	movi.n	a11, -9
4037dfdd:	1099b0        	and	a9, a9, a11
4037dfe0:	2099a0        	or	a9, a9, a10
4037dfe3:	0020c0        	memw
4037dfe6:	276892        	s32i	a9, a8, 156
    spimem_flash_ll_auto_wait_idle_init(dev, true, pes_waiti_delay);
    if (ctx->freq_mhz == 120) {
4037dfe9:	a298      	l32i.n	a9, a2, 40
4037dfeb:	78a082        	movi	a8, 120
4037dfee:	4e9987        	bne	a9, a8, 4037e040 <spi_flash_hal_setup_auto_suspend_mode+0xcc>
        spimem_flash_ll_set_wait_idle_dummy_phase(dev, ctx->extra_dummy);
4037dff1:	0c0282        	l8ui	a8, a2, 12
    if (extra_dummy > 0) {
4037dff4:	48bc      	beqz.n	a8, 4037e02c <spi_flash_hal_setup_auto_suspend_mode+0xb8>
        dev->flash_waiti_ctrl.waiti_dummy_cyclelen = extra_dummy - 1;
4037dff6:	880b      	addi.n	a8, a8, -1
4037dff8:	d9faa1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037dffb:	0020c0        	memw
4037dffe:	262a92        	l32i	a9, a10, 152
4037e001:	548080        	extui	a8, a8, 0, 6
4037e004:	118860        	slli	a8, a8, 10
4037e007:	dbd5b1        	l32r	a11, 40374f5c <_iram_text_start+0xb58> (ffff03ff <_rtc_reserved_end+0x9fef03ff>)
4037e00a:	1099b0        	and	a9, a9, a11
4037e00d:	208980        	or	a8, a9, a8
4037e010:	0020c0        	memw
4037e013:	266a82        	s32i	a8, a10, 152
        dev->flash_waiti_ctrl.waiti_dummy = 1;
4037e016:	0020c0        	memw
4037e019:	262a82        	l32i	a8, a10, 152
4037e01c:	290c      	movi.n	a9, 2
4037e01e:	208890        	or	a8, a8, a9
4037e021:	0020c0        	memw
4037e024:	266a82        	s32i	a8, a10, 152
4037e027:	000546        	j	4037e040 <spi_flash_hal_setup_auto_suspend_mode+0xcc>
4037e02a:	910000        	srl	a0, a0
        dev->flash_waiti_ctrl.waiti_dummy = 0;
4037e02d:	d9ed      	lsi	f14, a9, 36
4037e02f:	0020c0        	memw
4037e032:	262982        	l32i	a8, a9, 152
4037e035:	da7c      	movi.n	a10, -3
4037e037:	1088a0        	and	a8, a8, a10
4037e03a:	0020c0        	memw
4037e03d:	266982        	s32i	a8, a9, 152
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037e040:	d9e881        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e043:	0020c0        	memw
4037e046:	282892        	l32i	a9, a8, 160
4037e049:	1a0c      	movi.n	a10, 1
4037e04b:	2099a0        	or	a9, a9, a10
4037e04e:	0020c0        	memw
4037e051:	286892        	s32i	a9, a8, 160
    dev->flash_sus_cmd.pes_per_en = auto_sus;
4037e054:	0020c0        	memw
4037e057:	272892        	l32i	a9, a8, 156
4037e05a:	0a1c      	movi.n	a10, 16
4037e05c:	2099a0        	or	a9, a9, a10
4037e05f:	0020c0        	memw
4037e062:	276892        	s32i	a9, a8, 156
    }
    spimem_flash_ll_auto_suspend_init(dev, true);
    // tsus = ceil(ctx->tsus_val * ctx->freq_mhz / spimem_flash_ll_get_tsus_unit_in_cycles);
    uint32_t tsus = (ctx->tsus_val * ctx->freq_mhz / spimem_flash_ll_get_tsus_unit_in_cycles(dev)) + ((ctx->tsus_val * ctx->freq_mhz) % spimem_flash_ll_get_tsus_unit_in_cycles(dev) != 0);
4037e065:	2c0292        	l8ui	a9, a2, 44
4037e068:	a2a8      	l32i.n	a10, a2, 40
4037e06a:	8299a0        	mull	a9, a9, a10
    if (dev->sus_status.flash_pes_dly_256 == 1) {
4037e06d:	0020c0        	memw
4037e070:	292882        	l32i	a8, a8, 164
4037e073:	056867        	bbci	a8, 6, 4037e07c <spi_flash_hal_setup_auto_suspend_mode+0x108>
        tsus_unit = 256;
4037e076:	00a182        	movi	a8, 0x100
4037e079:	000046        	j	4037e07e <spi_flash_hal_setup_auto_suspend_mode+0x10a>
        tsus_unit = 4;
4037e07c:	480c      	movi.n	a8, 4
4037e07e:	c28980        	quou	a8, a9, a8
    if (dev->sus_status.flash_pes_dly_256 == 1) {
4037e081:	d9d7a1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e084:	0020c0        	memw
4037e087:	292aa2        	l32i	a10, a10, 164
4037e08a:	066a67        	bbci	a10, 6, 4037e094 <spi_flash_hal_setup_auto_suspend_mode+0x120>
        tsus_unit = 256;
4037e08d:	00a1a2        	movi	a10, 0x100
4037e090:	0000c6        	j	4037e097 <spi_flash_hal_setup_auto_suspend_mode+0x123>
4037e093:	a0a200        	addx4	a10, a2, a0
        tsus_unit = 4;
4037e096:	99a004        	lsi	f0, a0, 0x264
4037e099:	a052e2        	s16i	a14, a2, 0x140
4037e09c:	040c01        	l32r	a0, 4033f0cc <rom_rx_gain_force+0x338ca0>
4037e09f:	04ad      	mov.n	a10, a4
4037e0a1:	93a590        	movnez	a10, a5, a9
4037e0a4:	88aa      	add.n	a8, a8, a10
    dev->ctrl1.cs_hold_dly_res = dly_val;
4037e0a6:	d9cea1        	l32r	a10, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e0a9:	0020c0        	memw
4037e0ac:	3a98      	l32i.n	a9, a10, 12
4037e0ae:	948080        	extui	a8, a8, 0, 10
4037e0b1:	1188e0        	slli	a8, a8, 2
4037e0b4:	dbabb1        	l32r	a11, 40374f60 <_iram_text_start+0xb5c> (fffff003 <_rtc_reserved_end+0x9feff003>)
4037e0b7:	1099b0        	and	a9, a9, a11
4037e0ba:	208980        	or	a8, a9, a8
4037e0bd:	0020c0        	memw
4037e0c0:	3a89      	s32i.n	a8, a10, 12
    dev->sus_status.flash_per_dly_256 = 1;
4037e0c2:	0020c0        	memw
4037e0c5:	292a82        	l32i	a8, a10, 164
4037e0c8:	092c      	movi.n	a9, 32
4037e0ca:	208890        	or	a8, a8, a9
4037e0cd:	0020c0        	memw
4037e0d0:	296a82        	s32i	a8, a10, 164
    dev->sus_status.flash_pes_dly_256 = 1;
4037e0d3:	0020c0        	memw
4037e0d6:	292a82        	l32i	a8, a10, 164
4037e0d9:	094c      	movi.n	a9, 64
4037e0db:	208890        	or	a8, a8, a9
4037e0de:	0020c0        	memw
4037e0e1:	296a82        	s32i	a8, a10, 164
    spimem_flash_ll_set_sus_delay(dev, tsus);
    // tshsl2 = ceil(SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz() * 0.001);
    uint32_t tshsl2 = (SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz() / 1000) + ((SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz()) % 1000 != 0);
4037e0e4:	ff7825        	call8	4037d868 <spimem_flash_ll_get_source_freq_mhz>
4037e0e7:	118ac0        	slli	a8, a10, 4
4037e0ea:	c0a8a0        	sub	a10, a8, a10
4037e0ed:	aaaa      	add.n	a10, a10, a10
4037e0ef:	db9d71        	l32r	a7, 40374f64 <_iram_text_start+0xb60> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
4037e0f2:	b26a70        	mulsh	a6, a10, a7
4037e0f5:	216660        	srai	a6, a6, 6
4037e0f8:	31afa0        	srai	a10, a10, 31
4037e0fb:	c066a0        	sub	a6, a6, a10
4037e0fe:	ff76a5        	call8	4037d868 <spimem_flash_ll_get_source_freq_mhz>
4037e101:	118ac0        	slli	a8, a10, 4
4037e104:	c0a8a0        	sub	a10, a8, a10
4037e107:	aaaa      	add.n	a10, a10, a10
4037e109:	b28a70        	mulsh	a8, a10, a7
4037e10c:	218680        	srai	a8, a8, 6
4037e10f:	319fa0        	srai	a9, a10, 31
4037e112:	c08890        	sub	a8, a8, a9
4037e115:	1198b0        	slli	a9, a8, 5
4037e118:	c09980        	sub	a9, a9, a8
4037e11b:	a08980        	addx4	a8, a9, a8
4037e11e:	1188d0        	slli	a8, a8, 3
4037e121:	c08a80        	sub	a8, a10, a8
4037e124:	835480        	moveqz	a5, a4, a8
4037e127:	665a      	add.n	a6, a6, a5
    SPIMEM0.ctrl2.cs_hold_delay = cs_hold_delay;
4037e129:	d9b891        	l32r	a9, 4037480c <_iram_text_start+0x408> (60003000 <SPIMEM0>)
4037e12c:	0020c0        	memw
4037e12f:	4988      	l32i.n	a8, a9, 16
4037e131:	546060        	extui	a6, a6, 0, 6
4037e134:	016670        	slli	a6, a6, 25
4037e137:	db8ca1        	l32r	a10, 40374f68 <_iram_text_start+0xb64> (81ffffff <_rtc_reserved_end+0x21efffff>)
4037e13a:	1088a0        	and	a8, a8, a10
4037e13d:	208860        	or	a8, a8, a6
4037e140:	0020c0        	memw
4037e143:	4989      	s32i.n	a8, a9, 16
    spimem_flash_ll_sus_set_spi0_lock_trans(dev, SPIMEM_FLASH_LL_SPI0_MAX_LOCK_VAL_MSPI_TICKS);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, true);
    spimem_flash_ll_res_check_sus_setup(dev, true);
#endif
}
4037e145:	f01d      	retw.n
	...

4037e148 <spi_flash_hal_setup_auto_resume_mode>:

void spi_flash_hal_setup_auto_resume_mode(spi_flash_host_inst_t *host)
{
4037e148:	004136        	entry	a1, 32
    dev->misc.auto_per = auto_res;
4037e14b:	d9a591        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e14e:	0020c0        	memw
4037e151:	d9a8      	l32i.n	a10, a9, 52
4037e153:	db8681        	l32r	a8, 40374f6c <_iram_text_start+0xb68> (800 <UserFrameTotalSize+0x700>)
4037e156:	208a80        	or	a8, a10, a8
4037e159:	0020c0        	memw
4037e15c:	d989      	s32i.n	a8, a9, 52
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spimem_flash_ll_auto_resume_init(dev, true);
}
4037e15e:	f01d      	retw.n

4037e160 <spi_flash_hal_disable_auto_suspend_mode>:

void spi_flash_hal_disable_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037e160:	006136        	entry	a1, 48
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05);
4037e163:	d99f81        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e166:	0020c0        	memw
4037e169:	262892        	l32i	a9, a8, 152
4037e16c:	0020c0        	memw
4037e16f:	0199      	s32i.n	a9, a1, 0
4037e171:	0020c0        	memw
4037e174:	01a8      	l32i.n	a10, a1, 0
4037e176:	03ac92        	movi	a9, 0xfffffc03
4037e179:	10aa90        	and	a10, a10, a9
4037e17c:	491c      	movi.n	a9, 20
4037e17e:	209a90        	or	a9, a10, a9
4037e181:	0020c0        	memw
4037e184:	0199      	s32i.n	a9, a1, 0
4037e186:	0020c0        	memw
4037e189:	0198      	l32i.n	a9, a1, 0
4037e18b:	0020c0        	memw
4037e18e:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = (per_waiti | pes_waiti);  // enable auto wait-idle function.
4037e191:	0020c0        	memw
4037e194:	2628b2        	l32i	a11, a8, 152
4037e197:	e97c      	movi.n	a9, -2
4037e199:	10ab90        	and	a10, a11, a9
4037e19c:	0020c0        	memw
4037e19f:	2668a2        	s32i	a10, a8, 152
    dev->flash_sus_cmd.flash_per_wait_en = per_waiti;
4037e1a2:	0020c0        	memw
4037e1a5:	2728b2        	l32i	a11, a8, 156
4037e1a8:	ba7c      	movi.n	a10, -5
4037e1aa:	10aba0        	and	a10, a11, a10
4037e1ad:	0020c0        	memw
4037e1b0:	2768a2        	s32i	a10, a8, 156
    dev->flash_sus_cmd.flash_pes_wait_en = pes_waiti;
4037e1b3:	0020c0        	memw
4037e1b6:	2728b2        	l32i	a11, a8, 156
4037e1b9:	7a7c      	movi.n	a10, -9
4037e1bb:	10aba0        	and	a10, a11, a10
4037e1be:	0020c0        	memw
4037e1c1:	2768a2        	s32i	a10, a8, 156
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037e1c4:	0020c0        	memw
4037e1c7:	2828a2        	l32i	a10, a8, 160
4037e1ca:	109a90        	and	a9, a10, a9
4037e1cd:	0020c0        	memw
4037e1d0:	286892        	s32i	a9, a8, 160
    dev->flash_sus_cmd.pes_per_en = auto_sus;
4037e1d3:	0020c0        	memw
4037e1d6:	2728a2        	l32i	a10, a8, 156
4037e1d9:	f96c      	movi.n	a9, -17
4037e1db:	109a90        	and	a9, a10, a9
4037e1de:	0020c0        	memw
4037e1e1:	276892        	s32i	a9, a8, 156
    spimem_flash_ll_auto_suspend_init(dev, false);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, false);
    spimem_flash_ll_res_check_sus_setup(dev, false);
#endif
}
4037e1e4:	f01d      	retw.n
	...

4037e1e8 <spi_flash_hal_disable_auto_resume_mode>:

void spi_flash_hal_disable_auto_resume_mode(spi_flash_host_inst_t *host)
{
4037e1e8:	004136        	entry	a1, 32
    dev->misc.auto_per = auto_res;
4037e1eb:	d97d91        	l32r	a9, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
4037e1ee:	0020c0        	memw
4037e1f1:	d9a8      	l32i.n	a10, a9, 52
4037e1f3:	da0f81        	l32r	a8, 40374a30 <_iram_text_start+0x62c> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
4037e1f6:	108a80        	and	a8, a10, a8
4037e1f9:	0020c0        	memw
4037e1fc:	d989      	s32i.n	a8, a9, 52
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spimem_flash_ll_auto_resume_init(dev, false);
}
4037e1fe:	f01d      	retw.n

4037e200 <spi_flash_hal_device_config>:
{
4037e200:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e203:	1278      	l32i.n	a7, a2, 4
    dev->user.val = 0;
4037e205:	080c      	movi.n	a8, 0
4037e207:	0020c0        	memw
4037e20a:	6789      	s32i.n	a8, a7, 24
    dev->ctrl.val = 0;
4037e20c:	0020c0        	memw
4037e20f:	2789      	s32i.n	a8, a7, 8
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037e211:	2298      	l32i.n	a9, a2, 8
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037e213:	0020c0        	memw
4037e216:	d788      	l32i.n	a8, a7, 52
4037e218:	1a0c      	movi.n	a10, 1
4037e21a:	83a990        	moveqz	a10, a9, a9
4037e21d:	eb7c      	movi.n	a11, -2
4037e21f:	1088b0        	and	a8, a8, a11
4037e222:	2088a0        	or	a8, a8, a10
4037e225:	0020c0        	memw
4037e228:	d789      	s32i.n	a8, a7, 52
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037e22a:	a90b      	addi.n	a10, a9, -1
4037e22c:	0020c0        	memw
4037e22f:	d788      	l32i.n	a8, a7, 52
4037e231:	190c      	movi.n	a9, 1
4037e233:	839aa0        	moveqz	a9, a10, a10
4037e236:	999a      	add.n	a9, a9, a9
4037e238:	da7c      	movi.n	a10, -3
4037e23a:	1088a0        	and	a8, a8, a10
4037e23d:	208890        	or	a8, a8, a9
4037e240:	0020c0        	memw
4037e243:	d789      	s32i.n	a8, a7, 52
    dev->clock.val = *clock_val;
4037e245:	0020c0        	memw
4037e248:	4288      	l32i.n	a8, a2, 16
4037e24a:	0020c0        	memw
4037e24d:	5789      	s32i.n	a8, a7, 20
    int cs_hold = ctx->cs_hold;
4037e24f:	0f02a2        	l8ui	a10, a2, 15
    dev->ctrl2.cs_hold_time = hold_n - 1;
4037e252:	9a0b      	addi.n	a9, a10, -1
4037e254:	0020c0        	memw
4037e257:	4788      	l32i.n	a8, a7, 16
4037e259:	449090        	extui	a9, a9, 0, 5
4037e25c:	1199b0        	slli	a9, a9, 5
4037e25f:	1facb2        	movi	a11, 0xfffffc1f
4037e262:	1088b0        	and	a8, a8, a11
4037e265:	208890        	or	a8, a8, a9
4037e268:	0020c0        	memw
4037e26b:	4789      	s32i.n	a8, a7, 16
    dev->user.cs_hold = (hold_n > 0 ? 1 : 0);
4037e26d:	0020c0        	memw
4037e270:	6788      	l32i.n	a8, a7, 24
4037e272:	190c      	movi.n	a9, 1
4037e274:	839aa0        	moveqz	a9, a10, a10
4037e277:	1199a0        	slli	a9, a9, 6
4037e27a:	bfafa2        	movi	a10, -65
4037e27d:	1088a0        	and	a8, a8, a10
4037e280:	208890        	or	a8, a8, a9
4037e283:	0020c0        	memw
4037e286:	6789      	s32i.n	a8, a7, 24
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037e288:	0e0282        	l8ui	a8, a2, 14
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037e28b:	0020c0        	memw
4037e28e:	6798      	l32i.n	a9, a7, 24
4037e290:	1a0c      	movi.n	a10, 1
4037e292:	83a880        	moveqz	a10, a8, a8
4037e295:	11aa90        	slli	a10, a10, 7
4037e298:	7fafb2        	movi	a11, -129
4037e29b:	1099b0        	and	a9, a9, a11
4037e29e:	2099a0        	or	a9, a9, a10
4037e2a1:	0020c0        	memw
4037e2a4:	6799      	s32i.n	a9, a7, 24
    dev->ctrl2.cs_setup_time = cs_setup_time - 1;
4037e2a6:	880b      	addi.n	a8, a8, -1
4037e2a8:	0020c0        	memw
4037e2ab:	4798      	l32i.n	a9, a7, 16
4037e2ad:	448080        	extui	a8, a8, 0, 5
4037e2b0:	0a6c      	movi.n	a10, -32
4037e2b2:	1099a0        	and	a9, a9, a10
4037e2b5:	208980        	or	a8, a9, a8
4037e2b8:	0020c0        	memw
4037e2bb:	4789      	s32i.n	a8, a7, 16
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) != 0) {
4037e2bd:	6288      	l32i.n	a8, a2, 24
4037e2bf:	096807        	bbci	a8, 0, 4037e2cc <spi_flash_hal_device_config+0xcc>
        spi_flash_hal_setup_auto_suspend_mode(host);
4037e2c2:	20a220        	or	a10, a2, a2
4037e2c5:	ffcae5        	call8	4037df74 <spi_flash_hal_setup_auto_suspend_mode>
4037e2c8:	000186        	j	4037e2d2 <spi_flash_hal_device_config+0xd2>
4037e2cb:	a22000        	muluh	a2, a0, a0
        spi_flash_hal_disable_auto_suspend_mode(host);
4037e2ce:	e92520        	lsi	f2, a5, 0x3a4
4037e2d1:	ff          	.byte	0xff
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME) != 0) {
4037e2d2:	062282        	l32i	a8, a2, 24
4037e2d5:	076817        	bbci	a8, 1, 4037e2e0 <spi_flash_hal_device_config+0xe0>
        spi_flash_hal_setup_auto_resume_mode(host);
4037e2d8:	02ad      	mov.n	a10, a2
4037e2da:	ffe6e5        	call8	4037e148 <spi_flash_hal_setup_auto_resume_mode>
4037e2dd:	000146        	j	4037e2e6 <spi_flash_hal_device_config+0xe6>
        spi_flash_hal_disable_auto_resume_mode(host);
4037e2e0:	20a220        	or	a10, a2, a2
4037e2e3:	fff065        	call8	4037e1e8 <spi_flash_hal_disable_auto_resume_mode>
    dev->timing_cali.extra_dummy_cyclelen = extra_dummy;
4037e2e6:	0020c0        	memw
4037e2e9:	2a2782        	l32i	a8, a7, 168
4037e2ec:	e3af92        	movi	a9, -29
4037e2ef:	108890        	and	a8, a8, a9
4037e2f2:	0020c0        	memw
4037e2f5:	2a6782        	s32i	a8, a7, 168
}
4037e2f8:	00a022        	movi	a2, 0
4037e2fb:	f01d      	retw.n
4037e2fd:	000000        	ill

4037e300 <spi_flash_hal_poll_cmd_done>:
{
4037e300:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e303:	1288      	l32i.n	a8, a2, 4
    return (dev->cmd.val == 0);
4037e305:	0020c0        	memw
4037e308:	0888      	l32i.n	a8, a8, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037e30a:	ff5856        	bnez	a8, 4037e303 <spi_flash_hal_poll_cmd_done+0x3>
}
4037e30d:	f01d      	retw.n
	...

4037e310 <spi_flash_hal_check_status>:
{
4037e310:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e313:	1288      	l32i.n	a8, a2, 4
    return dev->cmd.val == 0;
4037e315:	0020c0        	memw
4037e318:	0828      	l32i.n	a2, a8, 0
4037e31a:	40f220        	nsau	a2, a2
4037e31d:	412520        	srli	a2, a2, 5
    return dev->sus_status.flash_sus;
4037e320:	0020c0        	memw
4037e323:	292882        	l32i	a8, a8, 164
    uint32_t sus_status = spimem_flash_ll_sus_status((spi_mem_dev_t*)dev) << 1;
4037e326:	048080        	extui	a8, a8, 0, 1
4037e329:	888a      	add.n	a8, a8, a8
}
4037e32b:	202280        	or	a2, a2, a8
4037e32e:	f01d      	retw.n

4037e330 <spi_flash_hal_resume>:
#endif // SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

void spi_flash_hal_resume(spi_flash_host_inst_t *host)
{
4037e330:	004136        	entry	a1, 32
4037e333:	02ad      	mov.n	a10, a2
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_resume((spi_mem_dev_t*)(((spi_flash_hal_context_t *)host)->spi));
4037e335:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_per = 1;
4037e337:	0020c0        	memw
4037e33a:	272982        	l32i	a8, a9, 156
4037e33d:	1b0c      	movi.n	a11, 1
4037e33f:	2088b0        	or	a8, a8, a11
4037e342:	0020c0        	memw
4037e345:	276982        	s32i	a8, a9, 156
    host->driver->poll_cmd_done(host);
4037e348:	0288      	l32i.n	a8, a2, 0
4037e34a:	102882        	l32i	a8, a8, 64
4037e34d:	0008e0        	callx8	a8
#else
    abort();
#endif
}
4037e350:	f01d      	retw.n
	...

4037e354 <spi_flash_hal_suspend>:

void spi_flash_hal_suspend(spi_flash_host_inst_t *host)
{
4037e354:	004136        	entry	a1, 32
4037e357:	02ad      	mov.n	a10, a2
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_suspend((spi_mem_dev_t *)(((spi_flash_hal_context_t *)host)->spi));
4037e359:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_pes = 1;
4037e35b:	0020c0        	memw
4037e35e:	272982        	l32i	a8, a9, 156
4037e361:	2b0c      	movi.n	a11, 2
4037e363:	2088b0        	or	a8, a8, a11
4037e366:	0020c0        	memw
4037e369:	276982        	s32i	a8, a9, 156
    host->driver->poll_cmd_done(host);
4037e36c:	0288      	l32i.n	a8, a2, 0
4037e36e:	102882        	l32i	a8, a8, 64
4037e371:	0008e0        	callx8	a8
#else
    abort();
#endif
}
4037e374:	f01d      	retw.n
	...

4037e378 <systimer_hal_init>:
#include "hal/systimer_types.h"
#include "hal/assert.h"


void systimer_hal_init(systimer_hal_context_t *hal)
{
4037e378:	004136        	entry	a1, 32
    hal->dev = &SYSTIMER;
4037e37b:	dafd81        	l32r	a8, 40374f70 <_iram_text_start+0xb6c> (60023000 <SYSTIMER>)
4037e37e:	0289      	s32i.n	a8, a2, 0
    dev->conf.clk_en = en;
4037e380:	0020c0        	memw
4037e383:	0898      	l32i.n	a9, a8, 0
4037e385:	d865a1        	l32r	a10, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037e388:	2099a0        	or	a9, a9, a10
4037e38b:	0020c0        	memw
4037e38e:	0899      	s32i.n	a9, a8, 0
    systimer_ll_enable_clock(hal->dev, true);
#if SOC_SYSTIMER_SUPPORT_ETM
    systimer_ll_enable_etm(&SYSTIMER, true);
#endif
}
4037e390:	f01d      	retw.n
	...

4037e394 <systimer_hal_get_counter_value>:
    hal->ticks_to_us = ops->ticks_to_us;
    hal->us_to_ticks = ops->us_to_ticks;
}

uint64_t systimer_hal_get_counter_value(systimer_hal_context_t *hal, uint32_t counter_id)
{
4037e394:	004136        	entry	a1, 32
4037e397:	03bd      	mov.n	a11, a3
    uint32_t lo, lo_start, hi;
    /* Set the "update" bit and wait for acknowledgment */
    systimer_ll_counter_snapshot(hal->dev, counter_id);
4037e399:	0288      	l32i.n	a8, a2, 0
    dev->unit_op[counter_id].timer_unit_update = 1;
4037e39b:	a08380        	addx4	a8, a3, a8
4037e39e:	0020c0        	memw
4037e3a1:	1898      	l32i.n	a9, a8, 4
4037e3a3:	d894a1        	l32r	a10, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037e3a6:	2099a0        	or	a9, a9, a10
4037e3a9:	0020c0        	memw
4037e3ac:	1899      	s32i.n	a9, a8, 4
    while (!systimer_ll_is_counter_value_valid(hal->dev, counter_id));
4037e3ae:	02a8      	l32i.n	a10, a2, 0
    return dev->unit_op[counter_id].timer_unit_value_valid;
4037e3b0:	a08ba0        	addx4	a8, a11, a10
4037e3b3:	0020c0        	memw
4037e3b6:	1888      	l32i.n	a8, a8, 4
4037e3b8:	f278d7        	bbci	a8, 29, 4037e3ae <systimer_hal_get_counter_value+0x1a>
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037e3bb:	8b8b      	addi.n	a8, a11, 8
4037e3bd:	b088a0        	addx8	a8, a8, a10
4037e3c0:	0020c0        	memw
4037e3c3:	1898      	l32i.n	a9, a8, 4
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
4037e3c5:	8b8b      	addi.n	a8, a11, 8
4037e3c7:	b088a0        	addx8	a8, a8, a10
4037e3ca:	0020c0        	memw
4037e3cd:	0838      	l32i.n	a3, a8, 0
4037e3cf:	113340        	slli	a3, a3, 12
4037e3d2:	413c30        	srli	a3, a3, 12
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037e3d5:	092d      	mov.n	a2, a9
4037e3d7:	0020c0        	memw
4037e3da:	1898      	l32i.n	a9, a8, 4
    lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    do {
        lo = lo_start;
        hi = systimer_ll_get_counter_value_high(hal->dev, counter_id);
        lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    } while (lo_start != lo);
4037e3dc:	e59297        	bne	a2, a9, 4037e3c5 <systimer_hal_get_counter_value+0x31>
        .lo = lo,
        .hi = hi
    };

    return result.val;
}
4037e3df:	f01d      	retw.n
4037e3e1:	000000        	ill

4037e3e4 <systimer_hal_set_alarm_period>:
    } while (1);
}
#endif // SOC_SYSTIMER_ALARM_MISS_COMPENSATE

void systimer_hal_set_alarm_period(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t period)
{
4037e3e4:	004136        	entry	a1, 32
4037e3e7:	04ad      	mov.n	a10, a4
    systimer_ll_enable_alarm(hal->dev, alarm_id, false);
4037e3e9:	0298      	l32i.n	a9, a2, 0
        dev->conf.val &= ~(1 << (24 - alarm_id));
4037e3eb:	0020c0        	memw
4037e3ee:	09b8      	l32i.n	a11, a9, 0
4037e3f0:	e8c382        	addi	a8, a3, -24
4037e3f3:	608080        	neg	a8, a8
4037e3f6:	170c      	movi.n	a7, 1
4037e3f8:	401800        	ssl	a8
4037e3fb:	a17700        	sll	a7, a7
4037e3fe:	1087b0        	and	a8, a7, a11
4037e401:	3088b0        	xor	a8, a8, a11
4037e404:	0020c0        	memw
4037e407:	0989      	s32i.n	a8, a9, 0
    systimer_ll_set_alarm_period(hal->dev, alarm_id, hal->us_to_ticks(period));
4037e409:	0268      	l32i.n	a6, a2, 0
4037e40b:	2288      	l32i.n	a8, a2, 8
4037e40d:	00a0b2        	movi	a11, 0
4037e410:	0008e0        	callx8	a8
    HAL_ASSERT(period < (1 << 26));
4037e413:	dad881        	l32r	a8, 40374f74 <_iram_text_start+0xb70> (3ffffff <UserFrameTotalSize+0x3fffeff>)
4037e416:	0eb8a7        	bgeu	a8, a10, 4037e428 <systimer_hal_set_alarm_period+0x44>
4037e419:	dad7d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3fc94098 <__FUNCTION__$0+0x900>)
4037e41c:	dad8c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3fc94268 <__func__$0>)
4037e41f:	95a0b2        	movi	a11, 149
4037e422:	dad7a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3fc940ac <__FUNCTION__$0+0x914>)
4037e425:	0192a5        	call8	4037fd50 <__assert_func>
    dev->target_conf[alarm_id].target_period = period;
4037e428:	93cb      	addi.n	a9, a3, 12
4037e42a:	a09960        	addx4	a9, a9, a6
4037e42d:	0020c0        	memw
4037e430:	1988      	l32i.n	a8, a9, 4
4037e432:	11aaa0        	slli	a10, a10, 6
4037e435:	41a6a0        	srli	a10, a10, 6
4037e438:	558a80        	extui	a8, a8, 26, 6
4037e43b:	018860        	slli	a8, a8, 26
4037e43e:	2088a0        	or	a8, a8, a10
4037e441:	0020c0        	memw
4037e444:	1989      	s32i.n	a8, a9, 4
    systimer_ll_apply_alarm_value(hal->dev, alarm_id);
4037e446:	0288      	l32i.n	a8, a2, 0
    dev->comp_load[alarm_id].val = 0x01;
4037e448:	14c332        	addi	a3, a3, 20
4037e44b:	a03380        	addx4	a3, a3, a8
4037e44e:	180c      	movi.n	a8, 1
4037e450:	0020c0        	memw
4037e453:	0389      	s32i.n	a8, a3, 0
    systimer_ll_enable_alarm(hal->dev, alarm_id, true);
4037e455:	0298      	l32i.n	a9, a2, 0
        dev->conf.val |= 1 << (24 - alarm_id);
4037e457:	0020c0        	memw
4037e45a:	0988      	l32i.n	a8, a9, 0
4037e45c:	208870        	or	a8, a8, a7
4037e45f:	0020c0        	memw
4037e462:	0989      	s32i.n	a8, a9, 0
}
4037e464:	f01d      	retw.n
	...

4037e468 <systimer_hal_counter_value_advance>:
{
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
}

void systimer_hal_counter_value_advance(systimer_hal_context_t *hal, uint32_t counter_id, int64_t time_us)
{
4037e468:	004136        	entry	a1, 32
    systimer_counter_value_t new_count = {
        .val = systimer_hal_get_counter_value(hal, counter_id) + hal->us_to_ticks(time_us),
4037e46b:	03bd      	mov.n	a11, a3
4037e46d:	02ad      	mov.n	a10, a2
4037e46f:	fff265        	call8	4037e394 <systimer_hal_get_counter_value>
4037e472:	0a6d      	mov.n	a6, a10
4037e474:	0b7d      	mov.n	a7, a11
4037e476:	2288      	l32i.n	a8, a2, 8
4037e478:	04ad      	mov.n	a10, a4
4037e47a:	05bd      	mov.n	a11, a5
4037e47c:	0008e0        	callx8	a8
4037e47f:	b7ba      	add.n	a11, a7, a11
4037e481:	c6aa      	add.n	a12, a6, a10
4037e483:	01bca7        	bgeu	a12, a10, 4037e488 <systimer_hal_counter_value_advance+0x20>
4037e486:	bb1b      	addi.n	a11, a11, 1
    };
    systimer_ll_set_counter_value(hal->dev, counter_id, new_count.val);
4037e488:	0298      	l32i.n	a9, a2, 0
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037e48a:	b09390        	addx8	a9, a3, a9
4037e48d:	0020c0        	memw
4037e490:	3988      	l32i.n	a8, a9, 12
4037e492:	11bb40        	slli	a11, a11, 12
4037e495:	41bcb0        	srli	a11, a11, 12
4037e498:	b58480        	extui	a8, a8, 20, 12
4037e49b:	0188c0        	slli	a8, a8, 20
4037e49e:	2088b0        	or	a8, a8, a11
4037e4a1:	0020c0        	memw
4037e4a4:	3989      	s32i.n	a8, a9, 12
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037e4a6:	0020c0        	memw
4037e4a9:	49c9      	s32i.n	a12, a9, 16
    systimer_ll_apply_counter_value(hal->dev, counter_id);
4037e4ab:	0288      	l32i.n	a8, a2, 0
    dev->unit_load[counter_id].val = 0x01;
4037e4ad:	14c332        	addi	a3, a3, 20
4037e4b0:	a03380        	addx4	a3, a3, a8
4037e4b3:	180c      	movi.n	a8, 1
4037e4b5:	0020c0        	memw
4037e4b8:	3389      	s32i.n	a8, a3, 12
}
4037e4ba:	f01d      	retw.n

4037e4bc <systimer_hal_select_alarm_mode>:
{
    systimer_ll_enable_counter(hal->dev, counter_id, true);
}

void systimer_hal_select_alarm_mode(systimer_hal_context_t *hal, uint32_t alarm_id, systimer_alarm_mode_t mode)
{
4037e4bc:	004136        	entry	a1, 32
    switch (mode) {
4037e4bf:	548c      	beqz.n	a4, 4037e4c8 <systimer_hal_select_alarm_mode+0xc>
4037e4c1:	1d1426        	beqi	a4, 1, 4037e4e2 <systimer_hal_select_alarm_mode+0x26>
4037e4c4:	000c46        	j	4037e4f9 <systimer_hal_select_alarm_mode+0x3d>
4037e4c7:	028800        	andb	b8, b8, b0
    dev->target_conf[alarm_id].target_period_mode = 0;
4037e4ca:	33cb      	addi.n	a3, a3, 12
4037e4cc:	a03380        	addx4	a3, a3, a8
4037e4cf:	0020c0        	memw
4037e4d2:	1388      	l32i.n	a8, a3, 4
4037e4d4:	d8c691        	l32r	a9, 403747ec <_iram_text_start+0x3e8> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037e4d7:	108890        	and	a8, a8, a9
4037e4da:	0020c0        	memw
4037e4dd:	1389      	s32i.n	a8, a3, 4
}
4037e4df:	000586        	j	4037e4f9 <systimer_hal_select_alarm_mode+0x3d>
    case SYSTIMER_ALARM_MODE_ONESHOT:
        systimer_ll_enable_alarm_oneshot(hal->dev, alarm_id);
        break;
    case SYSTIMER_ALARM_MODE_PERIOD:
        systimer_ll_enable_alarm_period(hal->dev, alarm_id);
4037e4e2:	0288      	l32i.n	a8, a2, 0
    dev->target_conf[alarm_id].target_period_mode = 1;
4037e4e4:	33cb      	addi.n	a3, a3, 12
4037e4e6:	a03380        	addx4	a3, a3, a8
4037e4e9:	0020c0        	memw
4037e4ec:	1388      	l32i.n	a8, a3, 4
4037e4ee:	d84191        	l32r	a9, 403745f4 <_iram_text_start+0x1f0> (40000000 <_heap_end>)
4037e4f1:	208890        	or	a8, a8, a9
4037e4f4:	0020c0        	memw
4037e4f7:	1389      	s32i.n	a8, a3, 4
        break;
    default:
        break;
    }
}
4037e4f9:	f01d      	retw.n
	...

4037e4fc <systimer_hal_set_tick_rate_ops>:
{
4037e4fc:	004136        	entry	a1, 32
    hal->ticks_to_us = ops->ticks_to_us;
4037e4ff:	0388      	l32i.n	a8, a3, 0
4037e501:	1289      	s32i.n	a8, a2, 4
    hal->us_to_ticks = ops->us_to_ticks;
4037e503:	1388      	l32i.n	a8, a3, 4
4037e505:	2289      	s32i.n	a8, a2, 8
}
4037e507:	f01d      	retw.n
4037e509:	000000        	ill

4037e50c <systimer_hal_enable_alarm_int>:
{
4037e50c:	004136        	entry	a1, 32
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
4037e50f:	02a8      	l32i.n	a10, a2, 0
        dev->int_ena.val |= 1 << alarm_id;
4037e511:	0020c0        	memw
4037e514:	192a82        	l32i	a8, a10, 100
4037e517:	190c      	movi.n	a9, 1
4037e519:	401300        	ssl	a3
4037e51c:	a19900        	sll	a9, a9
4037e51f:	208890        	or	a8, a8, a9
4037e522:	0020c0        	memw
4037e525:	196a82        	s32i	a8, a10, 100
}
4037e528:	f01d      	retw.n
	...

4037e52c <systimer_hal_enable_counter>:
{
4037e52c:	004136        	entry	a1, 32
    systimer_ll_enable_counter(hal->dev, counter_id, true);
4037e52f:	02a8      	l32i.n	a10, a2, 0
        dev->conf.val |= 1 << (30 - counter_id);
4037e531:	0020c0        	memw
4037e534:	0a88      	l32i.n	a8, a10, 0
4037e536:	e2c332        	addi	a3, a3, -30
4037e539:	603030        	neg	a3, a3
4037e53c:	190c      	movi.n	a9, 1
4037e53e:	401300        	ssl	a3
4037e541:	a19900        	sll	a9, a9
4037e544:	208890        	or	a8, a8, a9
4037e547:	0020c0        	memw
4037e54a:	0a89      	s32i.n	a8, a10, 0
}
4037e54c:	f01d      	retw.n
	...

4037e550 <systimer_hal_connect_alarm_counter>:

void systimer_hal_connect_alarm_counter(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t counter_id)
{
4037e550:	004136        	entry	a1, 32
    systimer_ll_connect_alarm_counter(hal->dev, alarm_id, counter_id);
4037e553:	0288      	l32i.n	a8, a2, 0
    dev->target_conf[alarm_id].target_timer_unit_sel = counter_id;
4037e555:	33cb      	addi.n	a3, a3, 12
4037e557:	a03380        	addx4	a3, a3, a8
4037e55a:	0020c0        	memw
4037e55d:	1388      	l32i.n	a8, a3, 4
4037e55f:	014410        	slli	a4, a4, 31
4037e562:	888a      	add.n	a8, a8, a8
4037e564:	418180        	srli	a8, a8, 1
4037e567:	208840        	or	a8, a8, a4
4037e56a:	0020c0        	memw
4037e56d:	1389      	s32i.n	a8, a3, 4
}
4037e56f:	f01d      	retw.n
4037e571:	000000        	ill

4037e574 <systimer_hal_counter_can_stall_by_cpu>:

void systimer_hal_counter_can_stall_by_cpu(systimer_hal_context_t *hal, uint32_t counter_id, uint32_t cpu_id, bool can)
{
4037e574:	004136        	entry	a1, 32
4037e577:	745050        	extui	a5, a5, 0, 8
    systimer_ll_counter_can_stall_by_cpu(hal->dev, counter_id, cpu_id, can);
4037e57a:	0298      	l32i.n	a9, a2, 0
    if (can) {
4037e57c:	05ac      	beqz.n	a5, 4037e5a0 <systimer_hal_counter_can_stall_by_cpu+0x2c>
        dev->conf.val |= 1 << ((28 - counter_id * 2) - cpu_id);
4037e57e:	0020c0        	memw
4037e581:	0988      	l32i.n	a8, a9, 0
4037e583:	f2c332        	addi	a3, a3, -14
4037e586:	603030        	neg	a3, a3
4037e589:	d03340        	subx2	a3, a3, a4
4037e58c:	1a0c      	movi.n	a10, 1
4037e58e:	401300        	ssl	a3
4037e591:	a1aa00        	sll	a10, a10
4037e594:	2088a0        	or	a8, a8, a10
4037e597:	0020c0        	memw
4037e59a:	0989      	s32i.n	a8, a9, 0
4037e59c:	000846        	j	4037e5c1 <systimer_hal_counter_can_stall_by_cpu+0x4d>
4037e59f:	20c000        	or	a12, a0, a0
        dev->conf.val &= ~(1 << ((28 - counter_id * 2) - cpu_id));
4037e5a2:	09a800        	l32e	a0, a8, -24
4037e5a5:	f2c332        	addi	a3, a3, -14
4037e5a8:	603030        	neg	a3, a3
4037e5ab:	d03340        	subx2	a3, a3, a4
4037e5ae:	180c      	movi.n	a8, 1
4037e5b0:	401300        	ssl	a3
4037e5b3:	a18800        	sll	a8, a8
4037e5b6:	1088a0        	and	a8, a8, a10
4037e5b9:	3088a0        	xor	a8, a8, a10
4037e5bc:	0020c0        	memw
4037e5bf:	0989      	s32i.n	a8, a9, 0
}
4037e5c1:	f01d      	retw.n
	...

4037e5c4 <assert_valid_block>:

#else // CONFIG_HEAP_TLSF_USE_ROM_IMPL

/* Check a block is valid for this heap. Used to verify parameters. */
__attribute__((noinline)) NOCLONE_ATTR static void assert_valid_block(const heap_t *heap, const multi_heap_block_handle_t block)
{
4037e5c4:	004136        	entry	a1, 32
    pool_t pool = tlsf_get_pool(heap->heap_data);
4037e5c7:	42a8      	l32i.n	a10, a2, 16
4037e5c9:	006025        	call8	4037ebcc <tlsf_get_pool>
		tlsf_cast(unsigned char*, ptr) - block_start_offset);
}

static inline __attribute__((always_inline)) void* block_to_ptr(const block_header_t* block)
{
	return tlsf_cast(void*,
4037e5cc:	338b      	addi.n	a3, a3, 8
    void *ptr = block_to_ptr(block);

    MULTI_HEAP_ASSERT((ptr >= pool) &&
4037e5ce:	0733a7        	bltu	a3, a10, 4037e5d9 <assert_valid_block+0x15>
4037e5d1:	3288      	l32i.n	a8, a2, 12
4037e5d3:	80aa80        	add	a10, a10, a8
4037e5d6:	1033a7        	bltu	a3, a10, 4037e5ea <assert_valid_block+0x26>
       Also, it's useful to be able to print the memory address where corruption was detected.
    */
#ifndef NDEBUG
    if(!condition) {
#ifndef CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        esp_rom_printf(format, line, address);
4037e5d9:	03cd      	mov.n	a12, a3
4037e5db:	74a0b2        	movi	a11, 116
4037e5de:	da69a1        	l32r	a10, 40374f84 <_iram_text_start+0xb80> (3c0229e8 <_flash_rodata_start+0x28c8>)
4037e5e1:	d7b481        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4037e5e4:	0008e0        	callx8	a8
#endif  // CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        abort();
4037e5e7:	016ae5        	call8	4037fc94 <abort>
                    (ptr < pool + heap->pool_size),
                    (uintptr_t)ptr);
}
4037e5ea:	f01d      	retw.n

4037e5ec <multi_heap_aligned_alloc_impl_offs>:

    return result;
}

void *multi_heap_aligned_alloc_impl_offs(multi_heap_handle_t heap, size_t size, size_t alignment, size_t offset)
{
4037e5ec:	004136        	entry	a1, 32
4037e5ef:	027d      	mov.n	a7, a2
    if(heap == NULL) {
4037e5f1:	043216        	beqz	a2, 4037e638 <multi_heap_aligned_alloc_impl_offs+0x4c>
        return NULL;
    }

    if(!size) {
4037e5f4:	044316        	beqz	a3, 4037e63c <multi_heap_aligned_alloc_impl_offs+0x50>
        return NULL;
    }

    //Alignment must be a power of two:
    if(((alignment & (alignment - 1)) != 0) ||(!alignment)) {
4037e5f7:	ffc482        	addi	a8, a4, -1
4037e5fa:	438847        	bany	a8, a4, 4037e641 <multi_heap_aligned_alloc_impl_offs+0x55>
4037e5fd:	045416        	beqz	a4, 4037e646 <multi_heap_aligned_alloc_impl_offs+0x5a>
        return NULL;
    }

    multi_heap_internal_lock(heap);
4037e600:	02ad      	mov.n	a10, a2
4037e602:	000b65        	call8	4037e6b8 <multi_heap_internal_lock>
    void *result = tlsf_memalign_offs(heap->heap_data, alignment, size, offset);
4037e605:	05dd      	mov.n	a13, a5
4037e607:	03cd      	mov.n	a12, a3
4037e609:	04bd      	mov.n	a11, a4
4037e60b:	42a8      	l32i.n	a10, a2, 16
4037e60d:	0099a5        	call8	4037efa8 <tlsf_memalign_offs>
4037e610:	0a2d      	mov.n	a2, a10
    if(result) {
4037e612:	01aa16        	beqz	a10, 4037e630 <multi_heap_aligned_alloc_impl_offs+0x44>
        heap->free_bytes -= tlsf_block_size(result);
4037e615:	001ba5        	call8	4037e7d0 <tlsf_block_size>
4037e618:	1788      	l32i.n	a8, a7, 4
4037e61a:	c088a0        	sub	a8, a8, a10
4037e61d:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_alloc_overhead();
4037e61f:	001aa5        	call8	4037e7c8 <tlsf_alloc_overhead>
4037e622:	1788      	l32i.n	a8, a7, 4
4037e624:	c0a8a0        	sub	a10, a8, a10
4037e627:	17a9      	s32i.n	a10, a7, 4
        if(heap->free_bytes < heap->minimum_free_bytes) {
4037e629:	2788      	l32i.n	a8, a7, 8
4037e62b:	01ba87        	bgeu	a10, a8, 4037e630 <multi_heap_aligned_alloc_impl_offs+0x44>
            heap->minimum_free_bytes = heap->free_bytes;
4037e62e:	27a9      	s32i.n	a10, a7, 8
        }
    }
    multi_heap_internal_unlock(heap);
4037e630:	07ad      	mov.n	a10, a7
4037e632:	000aa5        	call8	4037e6dc <multi_heap_internal_unlock>

    return result;
4037e635:	0003c6        	j	4037e648 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e638:	000306        	j	4037e648 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e63b:	020c00        	andb	b0, b12, b0
        return NULL;
4037e63e:	000186        	j	4037e648 <multi_heap_aligned_alloc_impl_offs+0x5c>
        return NULL;
4037e641:	020c      	movi.n	a2, 0
4037e643:	000046        	j	4037e648 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e646:	020c      	movi.n	a2, 0
}
4037e648:	f01d      	retw.n
	...

4037e64c <multi_heap_aligned_alloc_offs>:
{
4037e64c:	004136        	entry	a1, 32
4037e64f:	20a220        	or	a10, a2, a2
4037e652:	20b330        	or	a11, a3, a3
4037e655:	20c440        	or	a12, a4, a4
4037e658:	05dd      	mov.n	a13, a5
    return multi_heap_aligned_alloc_impl_offs(heap, size, alignment, offset);
4037e65a:	fff925        	call8	4037e5ec <multi_heap_aligned_alloc_impl_offs>
}
4037e65d:	0a2d      	mov.n	a2, a10
4037e65f:	f01d      	retw.n
4037e661:	000000        	ill

4037e664 <multi_heap_aligned_free>:
{
4037e664:	004136        	entry	a1, 32
    if (heap == NULL || p == NULL) {
4037e667:	40f280        	nsau	a8, a2
4037e66a:	418580        	srli	a8, a8, 5
4037e66d:	40f390        	nsau	a9, a3
4037e670:	419590        	srli	a9, a9, 5
4037e673:	208890        	or	a8, a8, a9
4037e676:	02e856        	bnez	a8, 4037e6a8 <multi_heap_aligned_free+0x44>
    assert_valid_block(heap, block_from_ptr(p));
4037e679:	f8c3b2        	addi	a11, a3, -8
4037e67c:	20a220        	or	a10, a2, a2
4037e67f:	fff465        	call8	4037e5c4 <assert_valid_block>
    multi_heap_internal_lock(heap);
4037e682:	20a220        	or	a10, a2, a2
4037e685:	000325        	call8	4037e6b8 <multi_heap_internal_lock>
    heap->free_bytes += tlsf_block_size(p);
4037e688:	03ad      	mov.n	a10, a3
4037e68a:	001465        	call8	4037e7d0 <tlsf_block_size>
4037e68d:	1288      	l32i.n	a8, a2, 4
4037e68f:	88aa      	add.n	a8, a8, a10
4037e691:	1289      	s32i.n	a8, a2, 4
    heap->free_bytes += tlsf_alloc_overhead();
4037e693:	001365        	call8	4037e7c8 <tlsf_alloc_overhead>
4037e696:	1288      	l32i.n	a8, a2, 4
4037e698:	88aa      	add.n	a8, a8, a10
4037e69a:	1289      	s32i.n	a8, a2, 4
    tlsf_free(heap->heap_data, p);
4037e69c:	03bd      	mov.n	a11, a3
4037e69e:	42a8      	l32i.n	a10, a2, 16
4037e6a0:	001465        	call8	4037e7e8 <tlsf_free>
    multi_heap_internal_unlock(heap);
4037e6a3:	02ad      	mov.n	a10, a2
4037e6a5:	000365        	call8	4037e6dc <multi_heap_internal_unlock>
}
4037e6a8:	f01d      	retw.n
	...

4037e6ac <multi_heap_get_allocated_size>:
{
4037e6ac:	004136        	entry	a1, 32
4037e6af:	03ad      	mov.n	a10, a3
    return tlsf_block_size(p);
4037e6b1:	0011e5        	call8	4037e7d0 <tlsf_block_size>
}
4037e6b4:	0a2d      	mov.n	a2, a10
4037e6b6:	f01d      	retw.n

4037e6b8 <multi_heap_internal_lock>:
{
4037e6b8:	004136        	entry	a1, 32
    MULTI_HEAP_LOCK(heap->lock);
4037e6bb:	002272        	l32i	a7, a2, 0
4037e6be:	018716        	beqz	a7, 4037e6da <multi_heap_internal_lock+0x22>
    if (xPortInIsrContext()) {
4037e6c1:	fba4a5        	call8	4037a10c <xPortInIsrContext>
4037e6c4:	8a8c      	beqz.n	a10, 4037e6d0 <multi_heap_internal_lock+0x18>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037e6c6:	fb7c      	movi.n	a11, -1
4037e6c8:	07ad      	mov.n	a10, a7
4037e6ca:	fba665        	call8	4037a130 <xPortEnterCriticalTimeout>
4037e6cd:	000246        	j	4037e6da <multi_heap_internal_lock+0x22>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037e6d0:	fb7c      	movi.n	a11, -1
4037e6d2:	07ad      	mov.n	a10, a7
4037e6d4:	201110        	or	a1, a1, a1
4037e6d7:	fba5a5        	call8	4037a130 <xPortEnterCriticalTimeout>
}
4037e6da:	f01d      	retw.n

4037e6dc <multi_heap_internal_unlock>:
{
4037e6dc:	004136        	entry	a1, 32
    MULTI_HEAP_UNLOCK(heap->lock);
4037e6df:	002272        	l32i	a7, a2, 0
4037e6e2:	013716        	beqz	a7, 4037e6f9 <multi_heap_internal_unlock+0x1d>
    if (xPortInIsrContext()) {
4037e6e5:	fba265        	call8	4037a10c <xPortInIsrContext>
4037e6e8:	008a16        	beqz	a10, 4037e6f4 <multi_heap_internal_unlock+0x18>
        portEXIT_CRITICAL_ISR(mux);
4037e6eb:	07ad      	mov.n	a10, a7
4037e6ed:	fbb925        	call8	4037a280 <vPortExitCritical>
4037e6f0:	000146        	j	4037e6f9 <multi_heap_internal_unlock+0x1d>
4037e6f3:	07ad00        	lsi	f0, a13, 28
        portEXIT_CRITICAL(mux);
4037e6f6:	fbb8a5        	call8	4037a280 <vPortExitCritical>
}
4037e6f9:	f01d      	retw.n
	...

4037e6fc <multi_heap_malloc>:
{
4037e6fc:	004136        	entry	a1, 32
4037e6ff:	207220        	or	a7, a2, a2
    if (size == 0 || heap == NULL) {
4037e702:	40f380        	nsau	a8, a3
4037e705:	418580        	srli	a8, a8, 5
4037e708:	40f290        	nsau	a9, a2
4037e70b:	419590        	srli	a9, a9, 5
4037e70e:	208890        	or	a8, a8, a9
4037e711:	033856        	bnez	a8, 4037e748 <multi_heap_malloc+0x4c>
    multi_heap_internal_lock(heap);
4037e714:	02ad      	mov.n	a10, a2
4037e716:	fffa25        	call8	4037e6b8 <multi_heap_internal_lock>
    void *result = tlsf_malloc(heap->heap_data, size);
4037e719:	03bd      	mov.n	a11, a3
4037e71b:	42a8      	l32i.n	a10, a2, 16
4037e71d:	004ba5        	call8	4037ebd8 <tlsf_malloc>
4037e720:	0a2d      	mov.n	a2, a10
    if(result) {
4037e722:	01aa16        	beqz	a10, 4037e740 <multi_heap_malloc+0x44>
        heap->free_bytes -= tlsf_block_size(result);
4037e725:	000aa5        	call8	4037e7d0 <tlsf_block_size>
4037e728:	1788      	l32i.n	a8, a7, 4
4037e72a:	c088a0        	sub	a8, a8, a10
4037e72d:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_alloc_overhead();
4037e72f:	0009a5        	call8	4037e7c8 <tlsf_alloc_overhead>
4037e732:	1788      	l32i.n	a8, a7, 4
4037e734:	c0a8a0        	sub	a10, a8, a10
4037e737:	17a9      	s32i.n	a10, a7, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037e739:	2788      	l32i.n	a8, a7, 8
4037e73b:	01ba87        	bgeu	a10, a8, 4037e740 <multi_heap_malloc+0x44>
            heap->minimum_free_bytes = heap->free_bytes;
4037e73e:	27a9      	s32i.n	a10, a7, 8
    multi_heap_internal_unlock(heap);
4037e740:	07ad      	mov.n	a10, a7
4037e742:	fff9a5        	call8	4037e6dc <multi_heap_internal_unlock>
    return result;
4037e745:	000046        	j	4037e74a <multi_heap_malloc+0x4e>
        return NULL;
4037e748:	020c      	movi.n	a2, 0
}
4037e74a:	f01d      	retw.n

4037e74c <multi_heap_realloc>:
{
4037e74c:	004136        	entry	a1, 32
4037e74f:	027d      	mov.n	a7, a2
    assert(heap != NULL);
4037e751:	d2cc      	bnez.n	a2, 4037e762 <multi_heap_realloc+0x16>
4037e753:	da0dd1        	l32r	a13, 40374f88 <_iram_text_start+0xb84> (3c022a4c <_flash_rodata_start+0x292c>)
4037e756:	da0dc1        	l32r	a12, 40374f8c <_iram_text_start+0xb88> (3c027820 <__func__$4>)
4037e759:	efa0b2        	movi	a11, 239
4037e75c:	da0da1        	l32r	a10, 40374f90 <_iram_text_start+0xb8c> (3c022a3e <_flash_rodata_start+0x291e>)
4037e75f:	015f25        	call8	4037fd50 <__assert_func>
    if (p == NULL) {
4037e762:	f3cc      	bnez.n	a3, 4037e775 <multi_heap_realloc+0x29>
        return multi_heap_malloc_impl(heap, size);
4037e764:	20b440        	or	a11, a4, a4
4037e767:	20a220        	or	a10, a2, a2
4037e76a:	fff925        	call8	4037e6fc <multi_heap_malloc>
4037e76d:	0a2d      	mov.n	a2, a10
4037e76f:	001206        	j	4037e7bb <multi_heap_realloc+0x6f>
4037e772:	000000        	ill
    assert_valid_block(heap, block_from_ptr(p));
4037e775:	f8c3b2        	addi	a11, a3, -8
4037e778:	02ad      	mov.n	a10, a2
4037e77a:	ffe4a5        	call8	4037e5c4 <assert_valid_block>
    if (heap == NULL) {
4037e77d:	03a216        	beqz	a2, 4037e7bb <multi_heap_realloc+0x6f>
    multi_heap_internal_lock(heap);
4037e780:	02ad      	mov.n	a10, a2
4037e782:	fff365        	call8	4037e6b8 <multi_heap_internal_lock>
    size_t previous_block_size =  tlsf_block_size(p);
4037e785:	03ad      	mov.n	a10, a3
4037e787:	0004a5        	call8	4037e7d0 <tlsf_block_size>
4037e78a:	0a6d      	mov.n	a6, a10
    void *result = tlsf_realloc(heap->heap_data, p, size);
4037e78c:	04cd      	mov.n	a12, a4
4037e78e:	03bd      	mov.n	a11, a3
4037e790:	42a8      	l32i.n	a10, a2, 16
4037e792:	00e665        	call8	4037f5f8 <tlsf_realloc>
4037e795:	0a2d      	mov.n	a2, a10
    if(result) {
4037e797:	5a9c      	beqz.n	a10, 4037e7b0 <multi_heap_realloc+0x64>
        heap->free_bytes += previous_block_size;
4037e799:	1788      	l32i.n	a8, a7, 4
4037e79b:	886a      	add.n	a8, a8, a6
4037e79d:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_block_size(result);
4037e79f:	000325        	call8	4037e7d0 <tlsf_block_size>
4037e7a2:	1788      	l32i.n	a8, a7, 4
4037e7a4:	c0a8a0        	sub	a10, a8, a10
4037e7a7:	17a9      	s32i.n	a10, a7, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037e7a9:	2788      	l32i.n	a8, a7, 8
4037e7ab:	01ba87        	bgeu	a10, a8, 4037e7b0 <multi_heap_realloc+0x64>
            heap->minimum_free_bytes = heap->free_bytes;
4037e7ae:	27a9      	s32i.n	a10, a7, 8
    multi_heap_internal_unlock(heap);
4037e7b0:	07ad      	mov.n	a10, a7
4037e7b2:	fff2a5        	call8	4037e6dc <multi_heap_internal_unlock>
    return result;
4037e7b5:	000086        	j	4037e7bb <multi_heap_realloc+0x6f>
4037e7b8:	000000        	ill
}
4037e7bb:	f01d      	retw.n
4037e7bd:	000000        	ill

4037e7c0 <multi_heap_set_lock>:
{
4037e7c0:	004136        	entry	a1, 32
    heap->lock = lock;
4037e7c3:	0239      	s32i.n	a3, a2, 0
}
4037e7c5:	f01d      	retw.n
	...

4037e7c8 <tlsf_alloc_overhead>:
{
	return 2 * block_header_overhead;
}

size_t tlsf_alloc_overhead(void)
{
4037e7c8:	004136        	entry	a1, 32
	return block_header_overhead;
}
4037e7cb:	420c      	movi.n	a2, 4
4037e7cd:	f01d      	retw.n
	...

4037e7d0 <tlsf_block_size>:
{
4037e7d0:	004136        	entry	a1, 32
	if (ptr)
4037e7d3:	b28c      	beqz.n	a2, 4037e7e2 <tlsf_block_size+0x12>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e7d5:	f8c222        	addi	a2, a2, -8
4037e7d8:	1228      	l32i.n	a2, a2, 4
4037e7da:	c87c      	movi.n	a8, -4
4037e7dc:	102280        	and	a2, a2, a8
4037e7df:	000046        	j	4037e7e4 <tlsf_block_size+0x14>
	size_t size = 0;
4037e7e2:	020c      	movi.n	a2, 0
}
4037e7e4:	f01d      	retw.n
	...

4037e7e8 <tlsf_free>:
	return tlsf_memalign_offs(tlsf, align, size, 0);
}


void tlsf_free(tlsf_t tlsf, void* ptr)
{
4037e7e8:	004136        	entry	a1, 32
	/* Don't attempt to free a NULL pointer. */
	if (ptr)
4037e7eb:	3d9316        	beqz	a3, 4037ebc8 <tlsf_free+0x3e0>
	return tlsf_cast(block_header_t*,
4037e7ee:	f8c372        	addi	a7, a3, -8
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e7f1:	1798      	l32i.n	a9, a7, 4
	{
		control_t* control = tlsf_cast(control_t*, tlsf);
		block_header_t* block = block_from_ptr(ptr);
		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037e7f3:	0e6907        	bbci	a9, 0, 4037e805 <tlsf_free+0x1d>
4037e7f6:	d9e7d1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c023074 <_flash_rodata_start+0x2f54>)
4037e7f9:	d9e7c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0278ac <__func__$6>)
4037e7fc:	75a2b2        	movi	a11, 0x275
4037e7ff:	d9e7a1        	l32r	a10, 40374f9c <_iram_text_start+0xb98> (3c022adb <_flash_rodata_start+0x29bb>)
4037e802:	0154e5        	call8	4037fd50 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e805:	c87c      	movi.n	a8, -4
4037e807:	108980        	and	a8, a9, a8
}

/* Return location of next existing block. */
static inline __attribute__((always_inline)) block_header_t* block_next(const block_header_t* block)
{
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e80a:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e80d:	883a      	add.n	a8, a8, a3
		block_size(block) - block_header_overhead);
	tlsf_assert(!block_is_last(block));
4037e80f:	3a0c      	movi.n	a10, 3
4037e811:	0e3a97        	bltu	a10, a9, 4037e823 <tlsf_free+0x3b>
4037e814:	d9e3d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037e817:	d9e3c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037e81a:	a1a0b2        	movi	a11, 161
4037e81d:	d9e2a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037e820:	0152e5        	call8	4037fd50 <__assert_func>

/* Link a new block with its physical neighbor, return the neighbor. */
static inline __attribute__((always_inline)) block_header_t* block_link_next(block_header_t* block)
{
	block_header_t* next = block_next(block);
	next->prev_phys_block = block;
4037e823:	0879      	s32i.n	a7, a8, 0
	block->size |= block_header_prev_free_bit;
4037e825:	1898      	l32i.n	a9, a8, 4
4037e827:	2a0c      	movi.n	a10, 2
4037e829:	2099a0        	or	a9, a9, a10
4037e82c:	1899      	s32i.n	a9, a8, 4
	block->size |= block_header_free_bit;
4037e82e:	f8c3b2        	addi	a11, a3, -8
4037e831:	1b98      	l32i.n	a9, a11, 4
4037e833:	180c      	movi.n	a8, 1
4037e835:	208980        	or	a8, a9, a8
4037e838:	1b89      	s32i.n	a8, a11, 4
}

/* Merge a just-freed block with an adjacent previous free block. */
tlsf_decl block_header_t* block_merge_prev(control_t* control, block_header_t* block)
{
	if (block_is_prev_free(block))
4037e83a:	0289a7        	bany	a9, a10, 4037e840 <tlsf_free+0x58>
4037e83d:	005506        	j	4037e995 <tlsf_free+0x1ad>
	return block->prev_phys_block;
4037e840:	0b68      	l32i.n	a6, a11, 0
	{
		block_header_t* prev = block_prev(block);
		tlsf_assert(prev && "prev physical block can't be null");
4037e842:	00e656        	bnez	a6, 4037e854 <tlsf_free+0x6c>
4037e845:	d9d9d1        	l32r	a13, 40374fac <_iram_text_start+0xba8> (3c0230ac <_flash_rodata_start+0x2f8c>)
4037e848:	d9dac1        	l32r	a12, 40374fb0 <_iram_text_start+0xbac> (3c027898 <__func__$5>)
4037e84b:	08a2b2        	movi	a11, 0x208
4037e84e:	d9d9a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e851:	014fe5        	call8	4037fd50 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e854:	1688      	l32i.n	a8, a6, 4
		tlsf_assert(block_is_free(prev) && "prev block is not free though marked as such");
4037e856:	0ee807        	bbsi	a8, 0, 4037e868 <tlsf_free+0x80>
4037e859:	d9d7d1        	l32r	a13, 40374fb8 <_iram_text_start+0xbb4> (3c0230d8 <_flash_rodata_start+0x2fb8>)
4037e85c:	d9d5c1        	l32r	a12, 40374fb0 <_iram_text_start+0xbac> (3c027898 <__func__$5>)
4037e85f:	09a2b2        	movi	a11, 0x209
4037e862:	d9d4a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e865:	014ea5        	call8	4037fd50 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e868:	c97c      	movi.n	a9, -4
4037e86a:	108890        	and	a8, a8, a9
	if (size < control->small_block_size)
4037e86d:	4298      	l32i.n	a9, a2, 16
4037e86f:	759790        	extui	a9, a9, 23, 8
4037e872:	0fb897        	bgeu	a8, a9, 4037e885 <tlsf_free+0x9d>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e875:	42a8      	l32i.n	a10, a2, 16
4037e877:	54aea0        	extui	a10, a10, 14, 6
4037e87a:	d299a0        	quos	a9, a9, a10
4037e87d:	d2a890        	quos	a10, a8, a9
		fl = 0;
4037e880:	0b0c      	movi.n	a11, 0
4037e882:	000d86        	j	4037e8bc <tlsf_free+0xd4>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e885:	d88c      	beqz.n	a8, 4037e896 <tlsf_free+0xae>
4037e887:	40f8b0        	nsau	a11, a8
4037e88a:	e0cbb2        	addi	a11, a11, -32
4037e88d:	60b0b0        	neg	a11, a11
4037e890:	000146        	j	4037e899 <tlsf_free+0xb1>
4037e893:	000000        	ill
4037e896:	00a0b2        	movi	a11, 0
	return bit - 1;
4037e899:	ffcba2        	addi	a10, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e89c:	042292        	l32i	a9, a2, 16
4037e89f:	25c490        	extui	a12, a9, 20, 3
4037e8a2:	c0aac0        	sub	a10, a10, a12
4037e8a5:	400a00        	ssr	a10
4037e8a8:	918080        	srl	a8, a8
4037e8ab:	1a0c      	movi.n	a10, 1
4037e8ad:	401c00        	ssl	a12
4037e8b0:	a1aa00        	sll	a10, a10
4037e8b3:	30a8a0        	xor	a10, a8, a10
		fl -= (control->fl_index_shift - 1);
4037e8b6:	249590        	extui	a9, a9, 5, 3
4037e8b9:	c0bb90        	sub	a11, a11, a9
	block_header_t* prev = block->prev_free;
4037e8bc:	3698      	l32i.n	a9, a6, 12
	block_header_t* next = block->next_free;
4037e8be:	26c8      	l32i.n	a12, a6, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037e8c0:	00e956        	bnez	a9, 4037e8d2 <tlsf_free+0xea>
4037e8c3:	d9bed1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037e8c6:	d9bec1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037e8c9:	74a1b2        	movi	a11, 0x174
4037e8cc:	d9baa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e8cf:	014825        	call8	4037fd50 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037e8d2:	0cdc      	bnez.n	a12, 4037e8e6 <tlsf_free+0xfe>
4037e8d4:	d9bcd1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037e8d7:	d9bac1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037e8da:	75a1b2        	movi	a11, 0x175
4037e8dd:	d9b5a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e8e0:	201110        	or	a1, a1, a1
4037e8e3:	0146e5        	call8	4037fd50 <__assert_func>
	next->prev_free = prev;
4037e8e6:	3c99      	s32i.n	a9, a12, 12
	prev->next_free = next;
4037e8e8:	29c9      	s32i.n	a12, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037e8ea:	8298      	l32i.n	a9, a2, 32
4037e8ec:	4288      	l32i.n	a8, a2, 16
4037e8ee:	548e80        	extui	a8, a8, 14, 6
4037e8f1:	8288b0        	mull	a8, a8, a11
4037e8f4:	88aa      	add.n	a8, a8, a10
4037e8f6:	a08890        	addx4	a8, a8, a9
4037e8f9:	0898      	l32i.n	a9, a8, 0
4037e8fb:	369697        	bne	a6, a9, 4037e935 <tlsf_free+0x14d>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037e8fe:	08c9      	s32i.n	a12, a8, 0
		if (next == &control->block_null)
4037e900:	319c27        	bne	a12, a2, 4037e935 <tlsf_free+0x14d>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037e903:	7298      	l32i.n	a9, a2, 28
4037e905:	a09b90        	addx4	a9, a11, a9
4037e908:	09c8      	l32i.n	a12, a9, 0
4037e90a:	180c      	movi.n	a8, 1
4037e90c:	401a00        	ssl	a10
4037e90f:	a18800        	sll	a8, a8
4037e912:	1088c0        	and	a8, a8, a12
4037e915:	3088c0        	xor	a8, a8, a12
4037e918:	0989      	s32i.n	a8, a9, 0
			if (!control->sl_bitmap[fl])
4037e91a:	7288      	l32i.n	a8, a2, 28
4037e91c:	a08b80        	addx4	a8, a11, a8
4037e91f:	0888      	l32i.n	a8, a8, 0
4037e921:	08dc      	bnez.n	a8, 4037e935 <tlsf_free+0x14d>
				control->fl_bitmap &= ~(1U << fl);
4037e923:	6298      	l32i.n	a9, a2, 24
4037e925:	180c      	movi.n	a8, 1
4037e927:	401b00        	ssl	a11
4037e92a:	a18800        	sll	a8, a8
4037e92d:	108890        	and	a8, a8, a9
4037e930:	308890        	xor	a8, a8, a9
4037e933:	6289      	s32i.n	a8, a2, 24
4037e935:	1698      	l32i.n	a9, a6, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037e937:	380c      	movi.n	a8, 3
4037e939:	0e3897        	bltu	a8, a9, 4037e94b <tlsf_free+0x163>
4037e93c:	d9a3d1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037e93f:	d9a3c1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027888 <__func__$3>)
4037e942:	f5a1b2        	movi	a11, 0x1f5
4037e945:	d99ba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e948:	014065        	call8	4037fd50 <__assert_func>
4037e94b:	f8c332        	addi	a3, a3, -8
4037e94e:	13a8      	l32i.n	a10, a3, 4
4037e950:	c87c      	movi.n	a8, -4
4037e952:	10aa80        	and	a10, a10, a8
	prev->size += block_size(block) + block_header_overhead;
4037e955:	aa4b      	addi.n	a10, a10, 4
4037e957:	99aa      	add.n	a9, a9, a10
4037e959:	1699      	s32i.n	a9, a6, 4
	return tlsf_cast(void*,
4037e95b:	a68b      	addi.n	a10, a6, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e95d:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e960:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e963:	88aa      	add.n	a8, a8, a10
	tlsf_assert(!block_is_last(block));
4037e965:	3a0c      	movi.n	a10, 3
4037e967:	0e3a97        	bltu	a10, a9, 4037e979 <tlsf_free+0x191>
4037e96a:	d98dd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037e96d:	d98dc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037e970:	a1a0b2        	movi	a11, 161
4037e973:	d98da1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037e976:	013da5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037e979:	0869      	s32i.n	a6, a8, 0
	if (block_absorb_post_hook != NULL)
4037e97b:	d99581        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037e97e:	089c      	beqz.n	a8, 4037e992 <tlsf_free+0x1aa>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037e980:	1c0c      	movi.n	a12, 1
4037e982:	0b1c      	movi.n	a11, 16
4037e984:	07ad      	mov.n	a10, a7
4037e986:	d99281        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037e989:	0008e0        	callx8	a8
		block_remove(control, prev);
		block = block_absorb(prev, block);
4037e98c:	067d      	mov.n	a7, a6
4037e98e:	0000c6        	j	4037e995 <tlsf_free+0x1ad>
4037e991:	766000        	lsi	f0, a0, 0x1d8
4037e994:	c73220        	lsi	f2, a2, 0x31c
	return tlsf_cast(void*,
4037e997:	8808      	l32i.n	a0, a8, 32
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e999:	ca7c17        	bbci	a12, 17, 4037e967 <tlsf_free+0x17f>
4037e99c:	10a8a0        	and	a10, a8, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e99f:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e9a2:	aa3a      	add.n	a10, a10, a3
4037e9a4:	0a9d      	mov.n	a9, a10
	tlsf_assert(!block_is_last(block));
4037e9a6:	03a0b2        	movi	a11, 3
4037e9a9:	0e3b87        	bltu	a11, a8, 4037e9bb <tlsf_free+0x1d3>
4037e9ac:	d97dd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037e9af:	d97dc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037e9b2:	a1a0b2        	movi	a11, 161
4037e9b5:	d97ca1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037e9b8:	013965        	call8	4037fd50 <__assert_func>

/* Merge a just-freed block with an adjacent free block. */
tlsf_decl block_header_t* block_merge_next(control_t* control, block_header_t* block)
{
	block_header_t* next = block_next(block);
	tlsf_assert(next && "next physical block can't be null");
4037e9bb:	dacc      	bnez.n	a10, 4037e9cc <tlsf_free+0x1e4>
4037e9bd:	d985d1        	l32r	a13, 40374fd4 <_iram_text_start+0xbd0> (3c023158 <_flash_rodata_start+0x3038>)
4037e9c0:	d986c1        	l32r	a12, 40374fd8 <_iram_text_start+0xbd4> (3c027874 <__func__$2>)
4037e9c3:	15a2b2        	movi	a11, 0x215
4037e9c6:	d97ba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037e9c9:	013865        	call8	4037fd50 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e9cc:	1a88      	l32i.n	a8, a10, 4

	if (block_is_free(next))
4037e9ce:	02e807        	bbsi	a8, 0, 4037e9d4 <tlsf_free+0x1ec>
4037e9d1:	004646        	j	4037eaee <tlsf_free+0x306>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e9d4:	cb7c      	movi.n	a11, -4
4037e9d6:	10c8b0        	and	a12, a8, a11
	if (size < control->small_block_size)
4037e9d9:	4288      	l32i.n	a8, a2, 16
4037e9db:	758780        	extui	a8, a8, 23, 8
4037e9de:	0fbc87        	bgeu	a12, a8, 4037e9f1 <tlsf_free+0x209>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e9e1:	42b8      	l32i.n	a11, a2, 16
4037e9e3:	54beb0        	extui	a11, a11, 14, 6
4037e9e6:	d288b0        	quos	a8, a8, a11
4037e9e9:	d2cc80        	quos	a12, a12, a8
		fl = 0;
4037e9ec:	0b0c      	movi.n	a11, 0
4037e9ee:	000d46        	j	4037ea27 <tlsf_free+0x23f>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e9f1:	cc8c      	beqz.n	a12, 4037ea01 <tlsf_free+0x219>
4037e9f3:	40fcd0        	nsau	a13, a12
4037e9f6:	e0cdd2        	addi	a13, a13, -32
4037e9f9:	60d0d0        	neg	a13, a13
4037e9fc:	000106        	j	4037ea04 <tlsf_free+0x21c>
4037e9ff:	d20000        	quos	a0, a0, a0
4037ea02:	8200a0        	mull	a0, a0, a10
	return bit - 1;
4037ea05:	ffcd      	lsi	f12, a15, 60
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037ea07:	0422b2        	l32i	a11, a2, 16
4037ea0a:	25e4b0        	extui	a14, a11, 20, 3
4037ea0d:	c088e0        	sub	a8, a8, a14
4037ea10:	400800        	ssr	a8
4037ea13:	9180c0        	srl	a8, a12
4037ea16:	1c0c      	movi.n	a12, 1
4037ea18:	401e00        	ssl	a14
4037ea1b:	a1cc00        	sll	a12, a12
4037ea1e:	30c8c0        	xor	a12, a8, a12
		fl -= (control->fl_index_shift - 1);
4037ea21:	24b5b0        	extui	a11, a11, 5, 3
4037ea24:	c0bdb0        	sub	a11, a13, a11
	block_header_t* prev = block->prev_free;
4037ea27:	3a88      	l32i.n	a8, a10, 12
	block_header_t* next = block->next_free;
4037ea29:	2ad8      	l32i.n	a13, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037ea2b:	00e856        	bnez	a8, 4037ea3d <tlsf_free+0x255>
4037ea2e:	d963d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037ea31:	d963c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037ea34:	74a1b2        	movi	a11, 0x174
4037ea37:	d95fa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ea3a:	013165        	call8	4037fd50 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037ea3d:	ddcc      	bnez.n	a13, 4037ea4e <tlsf_free+0x266>
4037ea3f:	d961d1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037ea42:	d95fc1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037ea45:	75a1b2        	movi	a11, 0x175
4037ea48:	d95ba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ea4b:	013065        	call8	4037fd50 <__assert_func>
	next->prev_free = prev;
4037ea4e:	3d89      	s32i.n	a8, a13, 12
	prev->next_free = next;
4037ea50:	0268d2        	s32i	a13, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037ea53:	82e8      	l32i.n	a14, a2, 32
4037ea55:	4288      	l32i.n	a8, a2, 16
4037ea57:	548e80        	extui	a8, a8, 14, 6
4037ea5a:	8288b0        	mull	a8, a8, a11
4037ea5d:	88ca      	add.n	a8, a8, a12
4037ea5f:	a088e0        	addx4	a8, a8, a14
4037ea62:	08e8      	l32i.n	a14, a8, 0
4037ea64:	3699e7        	bne	a9, a14, 4037ea9e <tlsf_free+0x2b6>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037ea67:	08d9      	s32i.n	a13, a8, 0
		if (next == &control->block_null)
4037ea69:	319d27        	bne	a13, a2, 4037ea9e <tlsf_free+0x2b6>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037ea6c:	7298      	l32i.n	a9, a2, 28
4037ea6e:	a09b90        	addx4	a9, a11, a9
4037ea71:	09d8      	l32i.n	a13, a9, 0
4037ea73:	180c      	movi.n	a8, 1
4037ea75:	401c00        	ssl	a12
4037ea78:	a18800        	sll	a8, a8
4037ea7b:	1088d0        	and	a8, a8, a13
4037ea7e:	3088d0        	xor	a8, a8, a13
4037ea81:	0989      	s32i.n	a8, a9, 0
			if (!control->sl_bitmap[fl])
4037ea83:	7288      	l32i.n	a8, a2, 28
4037ea85:	a08b80        	addx4	a8, a11, a8
4037ea88:	0888      	l32i.n	a8, a8, 0
4037ea8a:	08dc      	bnez.n	a8, 4037ea9e <tlsf_free+0x2b6>
				control->fl_bitmap &= ~(1U << fl);
4037ea8c:	6298      	l32i.n	a9, a2, 24
4037ea8e:	180c      	movi.n	a8, 1
4037ea90:	401b00        	ssl	a11
4037ea93:	a18800        	sll	a8, a8
4037ea96:	108890        	and	a8, a8, a9
4037ea99:	308890        	xor	a8, a8, a9
4037ea9c:	6289      	s32i.n	a8, a2, 24
4037ea9e:	1798      	l32i.n	a9, a7, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037eaa0:	380c      	movi.n	a8, 3
4037eaa2:	0e3897        	bltu	a8, a9, 4037eab4 <tlsf_free+0x2cc>
4037eaa5:	d948d1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037eaa8:	d949c1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027888 <__func__$3>)
4037eaab:	f5a1b2        	movi	a11, 0x1f5
4037eaae:	d941a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037eab1:	0129e5        	call8	4037fd50 <__assert_func>
4037eab4:	1ab8      	l32i.n	a11, a10, 4
4037eab6:	c87c      	movi.n	a8, -4
4037eab8:	10bb80        	and	a11, a11, a8
	prev->size += block_size(block) + block_header_overhead;
4037eabb:	bb4b      	addi.n	a11, a11, 4
4037eabd:	99ba      	add.n	a9, a9, a11
4037eabf:	1799      	s32i.n	a9, a7, 4
4037eac1:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037eac4:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037eac7:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037eac9:	3b0c      	movi.n	a11, 3
4037eacb:	0e3b97        	bltu	a11, a9, 4037eadd <tlsf_free+0x2f5>
4037eace:	d934d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037ead1:	d934c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037ead4:	a1a0b2        	movi	a11, 161
4037ead7:	d934a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037eada:	012765        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037eadd:	0879      	s32i.n	a7, a8, 0
	if (block_absorb_post_hook != NULL)
4037eadf:	d93c81        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037eae2:	888c      	beqz.n	a8, 4037eaee <tlsf_free+0x306>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037eae4:	1c0c      	movi.n	a12, 1
4037eae6:	0b1c      	movi.n	a11, 16
4037eae8:	d93a81        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037eaeb:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037eaee:	1798      	l32i.n	a9, a7, 4
4037eaf0:	c87c      	movi.n	a8, -4
4037eaf2:	109980        	and	a9, a9, a8
	if (size < control->small_block_size)
4037eaf5:	4288      	l32i.n	a8, a2, 16
4037eaf7:	758780        	extui	a8, a8, 23, 8
4037eafa:	0fb987        	bgeu	a9, a8, 4037eb0d <tlsf_free+0x325>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037eafd:	42a8      	l32i.n	a10, a2, 16
4037eaff:	54aea0        	extui	a10, a10, 14, 6
4037eb02:	d288a0        	quos	a8, a8, a10
4037eb05:	d29980        	quos	a9, a9, a8
		fl = 0;
4037eb08:	0a0c      	movi.n	a10, 0
4037eb0a:	000d06        	j	4037eb42 <tlsf_free+0x35a>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037eb0d:	b98c      	beqz.n	a9, 4037eb1c <tlsf_free+0x334>
4037eb0f:	40f9a0        	nsau	a10, a9
4037eb12:	e0caa2        	addi	a10, a10, -32
4037eb15:	60a0a0        	neg	a10, a10
4037eb18:	0000c6        	j	4037eb1f <tlsf_free+0x337>
4037eb1b:	a0a200        	addx4	a10, a2, a0
4037eb1e:	cab200        	float.s	f11, a2, 0
	return bit - 1;
4037eb21:	ff          	.byte	0xff
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037eb22:	042282        	l32i	a8, a2, 16
4037eb25:	25c480        	extui	a12, a8, 20, 3
4037eb28:	c0bbc0        	sub	a11, a11, a12
4037eb2b:	400b00        	ssr	a11
4037eb2e:	919090        	srl	a9, a9
4037eb31:	1b0c      	movi.n	a11, 1
4037eb33:	401c00        	ssl	a12
4037eb36:	a1bb00        	sll	a11, a11
4037eb39:	3099b0        	xor	a9, a9, a11
		fl -= (control->fl_index_shift - 1);
4037eb3c:	248580        	extui	a8, a8, 5, 3
4037eb3f:	c0aa80        	sub	a10, a10, a8
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037eb42:	82b8      	l32i.n	a11, a2, 32
4037eb44:	4288      	l32i.n	a8, a2, 16
4037eb46:	548e80        	extui	a8, a8, 14, 6
4037eb49:	8288a0        	mull	a8, a8, a10
4037eb4c:	889a      	add.n	a8, a8, a9
4037eb4e:	a088b0        	addx4	a8, a8, a11
4037eb51:	0888      	l32i.n	a8, a8, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037eb53:	d8cc      	bnez.n	a8, 4037eb64 <tlsf_free+0x37c>
4037eb55:	d921d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037eb58:	d922c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037eb5b:	90a1b2        	movi	a11, 0x190
4037eb5e:	d915a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037eb61:	011ee5        	call8	4037fd50 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037eb64:	d7cc      	bnez.n	a7, 4037eb75 <tlsf_free+0x38d>
4037eb66:	d91fd1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037eb69:	d91dc1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037eb6c:	91a1b2        	movi	a11, 0x191
4037eb6f:	d911a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037eb72:	011de5        	call8	4037fd50 <__assert_func>
	block->next_free = current;
4037eb75:	2789      	s32i.n	a8, a7, 8
	block->prev_free = &control->block_null;
4037eb77:	036722        	s32i	a2, a7, 12
	current->prev_free = block;
4037eb7a:	036872        	s32i	a7, a8, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037eb7d:	833b      	addi.n	a8, a3, 3
4037eb7f:	cb7c      	movi.n	a11, -4
4037eb81:	1088b0        	and	a8, a8, a11
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037eb84:	0e1387        	beq	a3, a8, 4037eb96 <tlsf_free+0x3ae>
4037eb87:	d918d1        	l32r	a13, 40374fe8 <_iram_text_start+0xbe4> (3c022cb0 <_flash_rodata_start+0x2b90>)
4037eb8a:	d915c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037eb8d:	96a1b2        	movi	a11, 0x196
4037eb90:	d909a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037eb93:	011be5        	call8	4037fd50 <__assert_func>
	control->blocks[fl * control->sl_index_count + sl] = block;
4037eb96:	82b8      	l32i.n	a11, a2, 32
4037eb98:	4288      	l32i.n	a8, a2, 16
4037eb9a:	548e80        	extui	a8, a8, 14, 6
4037eb9d:	828a80        	mull	a8, a10, a8
4037eba0:	898a      	add.n	a8, a9, a8
4037eba2:	a088b0        	addx4	a8, a8, a11
4037eba5:	0879      	s32i.n	a7, a8, 0
	control->fl_bitmap |= (1U << fl);
4037eba7:	62b8      	l32i.n	a11, a2, 24
4037eba9:	180c      	movi.n	a8, 1
4037ebab:	401a00        	ssl	a10
4037ebae:	a1c800        	sll	a12, a8
4037ebb1:	20bbc0        	or	a11, a11, a12
4037ebb4:	62b9      	s32i.n	a11, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037ebb6:	72b8      	l32i.n	a11, a2, 28
4037ebb8:	a0aab0        	addx4	a10, a10, a11
4037ebbb:	0ab8      	l32i.n	a11, a10, 0
4037ebbd:	401900        	ssl	a9
4037ebc0:	a18800        	sll	a8, a8
4037ebc3:	208b80        	or	a8, a11, a8
4037ebc6:	0a89      	s32i.n	a8, a10, 0
		block_mark_as_free(block);
		block = block_merge_prev(control, block);
		block = block_merge_next(control, block);
		block_insert(control, block);
	}
}
4037ebc8:	f01d      	retw.n
	...

4037ebcc <tlsf_get_pool>:
{
4037ebcc:	004136        	entry	a1, 32
	return tlsf_cast(pool_t, (char*)tlsf + tlsf_size(tlsf));
4037ebcf:	02ad      	mov.n	a10, a2
4037ebd1:	00f625        	call8	4037fb34 <tlsf_size>
}
4037ebd4:	22aa      	add.n	a2, a2, a10
4037ebd6:	f01d      	retw.n

4037ebd8 <tlsf_malloc>:
{
4037ebd8:	004136        	entry	a1, 32
4037ebdb:	028d      	mov.n	a8, a2
	if (size)
4037ebdd:	3af316        	beqz	a3, 4037ef90 <tlsf_malloc+0x3b8>
	return (x + (align - 1)) & ~(align - 1);
4037ebe0:	333b      	addi.n	a3, a3, 3
4037ebe2:	c97c      	movi.n	a9, -4
4037ebe4:	103390        	and	a3, a3, a9
	if (control == NULL)
4037ebe7:	3aa216        	beqz	a2, 4037ef95 <tlsf_malloc+0x3bd>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037ebea:	42a8      	l32i.n	a10, a2, 16
4037ebec:	54a8a0        	extui	a10, a10, 8, 6
4037ebef:	190c      	movi.n	a9, 1
4037ebf1:	401a00        	ssl	a10
4037ebf4:	a19900        	sll	a9, a9
		if (aligned < tlsf_block_size_max(control)) 
4037ebf7:	023397        	bltu	a3, a9, 4037ebfd <tlsf_malloc+0x25>
4037ebfa:	00e686        	j	4037ef98 <tlsf_malloc+0x3c0>
			adjust = tlsf_max(aligned, block_size_min);
4037ebfd:	c90c      	movi.n	a9, 12
4037ebff:	733390        	maxu	a3, a3, a9
	if (*size >= control->small_block_size)
4037ec02:	4298      	l32i.n	a9, a2, 16
4037ec04:	759790        	extui	a9, a9, 23, 8
4037ec07:	09cd      	mov.n	a12, a9
4037ec09:	373397        	bltu	a3, a9, 4037ec44 <tlsf_malloc+0x6c>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ec0c:	40f3a0        	nsau	a10, a3
	return bit - 1;
4037ec0f:	e1caa2        	addi	a10, a10, -31
4037ec12:	60a0a0        	neg	a10, a10
		const size_t round = (1 << (tlsf_fls_sizet(*size) - control->sl_index_count_log2));
4037ec15:	42b8      	l32i.n	a11, a2, 16
4037ec17:	25b4b0        	extui	a11, a11, 20, 3
4037ec1a:	c0bab0        	sub	a11, a10, a11
4037ec1d:	1a0c      	movi.n	a10, 1
4037ec1f:	401b00        	ssl	a11
4037ec22:	a1aa00        	sll	a10, a10
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037ec25:	ffcab2        	addi	a11, a10, -1
4037ec28:	0e0ab7        	bnone	a10, a11, 4037ec3a <tlsf_malloc+0x62>
4037ec2b:	d8f0d1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037ec2e:	d8f0c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c027970 <__func__$19>)
4037ec31:	f3a0b2        	movi	a11, 243
4037ec34:	d8e0a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ec37:	0111a5        	call8	4037fd50 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037ec3a:	33aa      	add.n	a3, a3, a10
4037ec3c:	330b      	addi.n	a3, a3, -1
4037ec3e:	60a0a0        	neg	a10, a10
4037ec41:	1033a0        	and	a3, a3, a10
	if (size < control->small_block_size)
4037ec44:	10b3c7        	bgeu	a3, a12, 4037ec58 <tlsf_malloc+0x80>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037ec47:	48a8      	l32i.n	a10, a8, 16
4037ec49:	54aea0        	extui	a10, a10, 14, 6
4037ec4c:	d299a0        	quos	a9, a9, a10
4037ec4f:	d29390        	quos	a9, a3, a9
		fl = 0;
4037ec52:	0a0c      	movi.n	a10, 0
4037ec54:	000c86        	j	4037ec8a <tlsf_malloc+0xb2>
4037ec57:	a38c00        	movltz	a8, a12, a0
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ec5a:	40f3a0        	nsau	a10, a3
4037ec5d:	e0caa2        	addi	a10, a10, -32
4037ec60:	60a0a0        	neg	a10, a10
4037ec63:	000086        	j	4037ec69 <tlsf_malloc+0x91>
4037ec66:	00a0a2        	movi	a10, 0
	return bit - 1;
4037ec69:	9a0b      	addi.n	a9, a10, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037ec6b:	48b8      	l32i.n	a11, a8, 16
4037ec6d:	25d4b0        	extui	a13, a11, 20, 3
4037ec70:	c099d0        	sub	a9, a9, a13
4037ec73:	400900        	ssr	a9
4037ec76:	919030        	srl	a9, a3
4037ec79:	1c0c      	movi.n	a12, 1
4037ec7b:	401d00        	ssl	a13
4037ec7e:	a1cc00        	sll	a12, a12
4037ec81:	3099c0        	xor	a9, a9, a12
		fl -= (control->fl_index_shift - 1);
4037ec84:	24b5b0        	extui	a11, a11, 5, 3
4037ec87:	c0aab0        	sub	a10, a10, a11
		** mapping_search can futz with the size, so for excessively large sizes it can sometimes wind up 
		** with indices that are off the end of the block array.
		** So, we protect against that here, since this is the only callsite of mapping_search.
		** Note that we don't need to check sl, since it comes from a modulo operation that guarantees it's always in range.
		*/
		if (fl < control->fl_index_count)
4037ec8a:	48b8      	l32i.n	a11, a8, 16
4037ec8c:	44b0b0        	extui	a11, a11, 0, 5
4037ec8f:	022ab7        	blt	a10, a11, 4037ec95 <tlsf_malloc+0xbd>
4037ec92:	00c1c6        	j	4037ef9d <tlsf_malloc+0x3c5>
	unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
4037ec95:	78c8      	l32i.n	a12, a8, 28
4037ec97:	a0bac0        	addx4	a11, a10, a12
4037ec9a:	0bd8      	l32i.n	a13, a11, 0
4037ec9c:	fb7c      	movi.n	a11, -1
4037ec9e:	401900        	ssl	a9
4037eca1:	a19b00        	sll	a9, a11
4037eca4:	10bd90        	and	a11, a13, a9
	if (!sl_map)
4037eca7:	3b8d97        	bany	a13, a9, 4037ece6 <tlsf_malloc+0x10e>
		const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
4037ecaa:	68b8      	l32i.n	a11, a8, 24
4037ecac:	aa1b      	addi.n	a10, a10, 1
4037ecae:	f97c      	movi.n	a9, -1
4037ecb0:	401a00        	ssl	a10
4037ecb3:	a19900        	sll	a9, a9
4037ecb6:	10db90        	and	a13, a11, a9
		if (!fl_map)
4037ecb9:	028b97        	bany	a11, a9, 4037ecbf <tlsf_malloc+0xe7>
4037ecbc:	00b886        	j	4037efa2 <tlsf_malloc+0x3ca>
	return __builtin_ffs(word) - 1;
4037ecbf:	60a0d0        	neg	a10, a13
4037ecc2:	10aad0        	and	a10, a10, a13
4037ecc5:	40faa0        	nsau	a10, a10
4037ecc8:	e1caa2        	addi	a10, a10, -31
4037eccb:	60a0a0        	neg	a10, a10
		sl_map = control->sl_bitmap[fl];
4037ecce:	a0cac0        	addx4	a12, a10, a12
4037ecd1:	002cb2        	l32i	a11, a12, 0
	tlsf_assert(sl_map && "internal error - second level bitmap is null");
4037ecd4:	00eb56        	bnez	a11, 4037ece6 <tlsf_malloc+0x10e>
4037ecd7:	d8c7d1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c022ea0 <_flash_rodata_start+0x2d80>)
4037ecda:	d8c7c1        	l32r	a12, 40374ff8 <_iram_text_start+0xbf4> (3c0278fc <__func__$11>)
4037ecdd:	67a1b2        	movi	a11, 0x167
4037ece0:	d8b5a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ece3:	0106e5        	call8	4037fd50 <__assert_func>
	return __builtin_ffs(word) - 1;
4037ece6:	6090b0        	neg	a9, a11
4037ece9:	1099b0        	and	a9, a9, a11
4037ecec:	40f990        	nsau	a9, a9
4037ecef:	e1c9b2        	addi	a11, a9, -31
4037ecf2:	60b0b0        	neg	a11, a11
	return control->blocks[fl * control->sl_index_count + sl];
4037ecf5:	88c8      	l32i.n	a12, a8, 32
4037ecf7:	4898      	l32i.n	a9, a8, 16
4037ecf9:	549e90        	extui	a9, a9, 14, 6
4037ecfc:	8299a0        	mull	a9, a9, a10
4037ecff:	9b9a      	add.n	a9, a11, a9
4037ed01:	a099c0        	addx4	a9, a9, a12
4037ed04:	0928      	l32i.n	a2, a9, 0
		{
			block = search_suitable_block(control, &fl, &sl);
		}
	}

	if (block)
4037ed06:	29a216        	beqz	a2, 4037efa4 <tlsf_malloc+0x3cc>
4037ed09:	1298      	l32i.n	a9, a2, 4
4037ed0b:	fcafc2        	movi	a12, -4
4037ed0e:	1099c0        	and	a9, a9, a12
	{
		tlsf_assert(block_size(block) >= *size);
4037ed11:	0eb937        	bgeu	a9, a3, 4037ed23 <tlsf_malloc+0x14b>
4037ed14:	d8bad1        	l32r	a13, 40374ffc <_iram_text_start+0xbf8> (3c022edc <_flash_rodata_start+0x2dbc>)
4037ed17:	d8bac1        	l32r	a12, 40375000 <_iram_text_start+0xbfc> (3c027914 <__func__$12>)
4037ed1a:	6aa2b2        	movi	a11, 0x26a
4037ed1d:	d8a5a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ed20:	0102e5        	call8	4037fd50 <__assert_func>
	block_header_t* prev = block->prev_free;
4037ed23:	3298      	l32i.n	a9, a2, 12
	block_header_t* next = block->next_free;
4037ed25:	22c8      	l32i.n	a12, a2, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037ed27:	00e956        	bnez	a9, 4037ed39 <tlsf_malloc+0x161>
4037ed2a:	d8a4d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037ed2d:	d8a4c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037ed30:	74a1b2        	movi	a11, 0x174
4037ed33:	d8a0a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ed36:	0101a5        	call8	4037fd50 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037ed39:	dccc      	bnez.n	a12, 4037ed4a <tlsf_malloc+0x172>
4037ed3b:	d8a2d1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037ed3e:	d8a0c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037ed41:	75a1b2        	movi	a11, 0x175
4037ed44:	d89ca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ed47:	0100a5        	call8	4037fd50 <__assert_func>
	next->prev_free = prev;
4037ed4a:	3c99      	s32i.n	a9, a12, 12
	prev->next_free = next;
4037ed4c:	29c9      	s32i.n	a12, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037ed4e:	88d8      	l32i.n	a13, a8, 32
4037ed50:	4898      	l32i.n	a9, a8, 16
4037ed52:	549e90        	extui	a9, a9, 14, 6
4037ed55:	829a90        	mull	a9, a10, a9
4037ed58:	9b9a      	add.n	a9, a11, a9
4037ed5a:	a099d0        	addx4	a9, a9, a13
4037ed5d:	09d8      	l32i.n	a13, a9, 0
4037ed5f:	3792d7        	bne	a2, a13, 4037ed9a <tlsf_malloc+0x1c2>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037ed62:	09c9      	s32i.n	a12, a9, 0
		if (next == &control->block_null)
4037ed64:	329c87        	bne	a12, a8, 4037ed9a <tlsf_malloc+0x1c2>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037ed67:	78c8      	l32i.n	a12, a8, 28
4037ed69:	a0cac0        	addx4	a12, a10, a12
4037ed6c:	0cd8      	l32i.n	a13, a12, 0
4037ed6e:	190c      	movi.n	a9, 1
4037ed70:	401b00        	ssl	a11
4037ed73:	a19900        	sll	a9, a9
4037ed76:	1099d0        	and	a9, a9, a13
4037ed79:	3099d0        	xor	a9, a9, a13
4037ed7c:	0c99      	s32i.n	a9, a12, 0
			if (!control->sl_bitmap[fl])
4037ed7e:	7898      	l32i.n	a9, a8, 28
4037ed80:	a09a90        	addx4	a9, a10, a9
4037ed83:	0998      	l32i.n	a9, a9, 0
4037ed85:	19dc      	bnez.n	a9, 4037ed9a <tlsf_malloc+0x1c2>
				control->fl_bitmap &= ~(1U << fl);
4037ed87:	68b8      	l32i.n	a11, a8, 24
4037ed89:	190c      	movi.n	a9, 1
4037ed8b:	401a00        	ssl	a10
4037ed8e:	a19900        	sll	a9, a9
4037ed91:	1099b0        	and	a9, a9, a11
4037ed94:	3099b0        	xor	a9, a9, a11
4037ed97:	066892        	s32i	a9, a8, 24
tlsf_decl void* block_prepare_used(control_t* control, block_header_t* block, size_t size)
{
	void* p = 0;
	if (block)
	{
		tlsf_assert(size && "size must be non-zero");
4037ed9a:	00e356        	bnez	a3, 4037edac <tlsf_malloc+0x1d4>
4037ed9d:	d899d1        	l32r	a13, 40375004 <_iram_text_start+0xc00> (3c022ef8 <_flash_rodata_start+0x2dd8>)
4037eda0:	d89ac1        	l32r	a12, 40375008 <_iram_text_start+0xc04> (3c0278e8 <__func__$10>)
4037eda3:	76a2b2        	movi	a11, 0x276
4037eda6:	d883a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037eda9:	00fa65        	call8	4037fd50 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037edac:	1298      	l32i.n	a9, a2, 4
	tlsf_assert(block_is_free(block) && "block must be free");
4037edae:	0ee907        	bbsi	a9, 0, 4037edc0 <tlsf_malloc+0x1e8>
4037edb1:	d896d1        	l32r	a13, 4037500c <_iram_text_start+0xc08> (3c022f18 <_flash_rodata_start+0x2df8>)
4037edb4:	d897c1        	l32r	a12, 40375010 <_iram_text_start+0xc0c> (3c0278d8 <__func__$9>)
4037edb7:	24a2b2        	movi	a11, 0x224
4037edba:	d87ea1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037edbd:	00f925        	call8	4037fd50 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037edc0:	ca7c      	movi.n	a10, -4
4037edc2:	10b9a0        	and	a11, a9, a10
	return block_size(block) >= sizeof(block_header_t) + size;
4037edc5:	10c392        	addi	a9, a3, 16
	if (block_can_split(block, size))
4037edc8:	02bb97        	bgeu	a11, a9, 4037edce <tlsf_malloc+0x1f6>
4037edcb:	0061c6        	j	4037ef56 <tlsf_malloc+0x37e>
	return tlsf_cast(void*,
4037edce:	d28b      	addi.n	a13, a2, 8
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037edd0:	93aa      	add.n	a9, a3, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037edd2:	9d9a      	add.n	a9, a13, a9
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037edd4:	c0ab30        	sub	a10, a11, a3
4037edd7:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(void*,
4037edda:	c98b      	addi.n	a12, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037eddc:	e9bb      	addi.n	a14, a9, 11
4037edde:	cf7c      	movi.n	a15, -4
4037ede0:	10eef0        	and	a14, a14, a15
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037ede3:	0e1ce7        	beq	a12, a14, 4037edf5 <tlsf_malloc+0x21d>
4037ede6:	d88bd1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037ede9:	d88bc1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037edec:	c4a1b2        	movi	a11, 0x1c4
4037edef:	d871a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037edf2:	00f5e5        	call8	4037fd50 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037edf5:	ea3a      	add.n	a14, a10, a3
4037edf7:	ee4b      	addi.n	a14, a14, 4
4037edf9:	0e1be7        	beq	a11, a14, 4037ee0b <tlsf_malloc+0x233>
4037edfc:	d888d1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037edff:	d886c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037ee02:	c7a1b2        	movi	a11, 0x1c7
4037ee05:	d86ba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ee08:	00f465        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037ee0b:	19b8      	l32i.n	a11, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037ee0d:	14b0b0        	extui	a11, a11, 0, 2
4037ee10:	20aab0        	or	a10, a10, a11
4037ee13:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee15:	cb7c      	movi.n	a11, -4
4037ee17:	10aab0        	and	a10, a10, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037ee1a:	bb0c      	movi.n	a11, 11
4037ee1c:	0e3ba7        	bltu	a11, a10, 4037ee2e <tlsf_malloc+0x256>
4037ee1f:	d880d1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037ee22:	d87dc1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037ee25:	c9a1b2        	movi	a11, 0x1c9
4037ee28:	d863a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ee2b:	00f265        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037ee2e:	12a8      	l32i.n	a10, a2, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037ee30:	14a0a0        	extui	a10, a10, 0, 2
4037ee33:	20aa30        	or	a10, a10, a3
4037ee36:	12a9      	s32i.n	a10, a2, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee38:	19b8      	l32i.n	a11, a9, 4
4037ee3a:	ca7c      	movi.n	a10, -4
4037ee3c:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037ee3f:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ee42:	acaa      	add.n	a10, a12, a10
	tlsf_assert(!block_is_last(block));
4037ee44:	3c0c      	movi.n	a12, 3
4037ee46:	0e3cb7        	bltu	a12, a11, 4037ee58 <tlsf_malloc+0x280>
4037ee49:	d855d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037ee4c:	d856c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037ee4f:	a1a0b2        	movi	a11, 161
4037ee52:	d855a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037ee55:	00efa5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037ee58:	0a99      	s32i.n	a9, a10, 0
	block->size |= block_header_prev_free_bit;
4037ee5a:	1ab8      	l32i.n	a11, a10, 4
4037ee5c:	2c0c      	movi.n	a12, 2
4037ee5e:	20bbc0        	or	a11, a11, a12
4037ee61:	1ab9      	s32i.n	a11, a10, 4
	block->size |= block_header_free_bit;
4037ee63:	19a8      	l32i.n	a10, a9, 4
4037ee65:	1b0c      	movi.n	a11, 1
4037ee67:	20aab0        	or	a10, a10, a11
4037ee6a:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee6c:	12b8      	l32i.n	a11, a2, 4
4037ee6e:	ca7c      	movi.n	a10, -4
4037ee70:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037ee73:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ee76:	ddaa      	add.n	a13, a13, a10
	tlsf_assert(!block_is_last(block));
4037ee78:	3a0c      	movi.n	a10, 3
4037ee7a:	0e3ab7        	bltu	a10, a11, 4037ee8c <tlsf_malloc+0x2b4>
4037ee7d:	d848d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037ee80:	d849c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037ee83:	a1a0b2        	movi	a11, 161
4037ee86:	d848a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037ee89:	00ec65        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037ee8c:	0d29      	s32i.n	a2, a13, 0
	block->size |= block_header_prev_free_bit;
4037ee8e:	19a8      	l32i.n	a10, a9, 4
4037ee90:	2b0c      	movi.n	a11, 2
4037ee92:	20bab0        	or	a11, a10, a11
4037ee95:	19b9      	s32i.n	a11, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
4037ee97:	cb7c      	movi.n	a11, -4
4037ee99:	10aab0        	and	a10, a10, a11
	if (size < control->small_block_size)
4037ee9c:	48b8      	l32i.n	a11, a8, 16
4037ee9e:	75b7b0        	extui	a11, a11, 23, 8
4037eea1:	0fbab7        	bgeu	a10, a11, 4037eeb4 <tlsf_malloc+0x2dc>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037eea4:	48c8      	l32i.n	a12, a8, 16
4037eea6:	54cec0        	extui	a12, a12, 14, 6
4037eea9:	d2bbc0        	quos	a11, a11, a12
4037eeac:	d2aab0        	quos	a10, a10, a11
		fl = 0;
4037eeaf:	0c0c      	movi.n	a12, 0
4037eeb1:	000cc6        	j	4037eee8 <tlsf_malloc+0x310>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037eeb4:	aa8c      	beqz.n	a10, 4037eec2 <tlsf_malloc+0x2ea>
4037eeb6:	40fac0        	nsau	a12, a10
4037eeb9:	e0ccc2        	addi	a12, a12, -32
4037eebc:	60c0c0        	neg	a12, a12
4037eebf:	000086        	j	4037eec5 <tlsf_malloc+0x2ed>
4037eec2:	00a0c2        	movi	a12, 0
	return bit - 1;
4037eec5:	ffccd2        	addi	a13, a12, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037eec8:	0428b2        	l32i	a11, a8, 16
4037eecb:	25e4b0        	extui	a14, a11, 20, 3
4037eece:	c0dde0        	sub	a13, a13, a14
4037eed1:	400d00        	ssr	a13
4037eed4:	91a0a0        	srl	a10, a10
4037eed7:	1d0c      	movi.n	a13, 1
4037eed9:	401e00        	ssl	a14
4037eedc:	a1dd00        	sll	a13, a13
4037eedf:	30aad0        	xor	a10, a10, a13
		fl -= (control->fl_index_shift - 1);
4037eee2:	24b5b0        	extui	a11, a11, 5, 3
4037eee5:	c0ccb0        	sub	a12, a12, a11
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037eee8:	88d8      	l32i.n	a13, a8, 32
4037eeea:	48b8      	l32i.n	a11, a8, 16
4037eeec:	54beb0        	extui	a11, a11, 14, 6
4037eeef:	82bbc0        	mull	a11, a11, a12
4037eef2:	bbaa      	add.n	a11, a11, a10
4037eef4:	a0bbd0        	addx4	a11, a11, a13
4037eef7:	0bb8      	l32i.n	a11, a11, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037eef9:	dbcc      	bnez.n	a11, 4037ef0a <tlsf_malloc+0x332>
4037eefb:	d838d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037eefe:	d838c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037ef01:	90a1b2        	movi	a11, 0x190
4037ef04:	d82ca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ef07:	00e4a5        	call8	4037fd50 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037ef0a:	09dc      	bnez.n	a9, 4037ef1e <tlsf_malloc+0x346>
4037ef0c:	d836d1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037ef0f:	d834c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037ef12:	91a1b2        	movi	a11, 0x191
4037ef15:	d827a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037ef18:	201110        	or	a1, a1, a1
4037ef1b:	00e365        	call8	4037fd50 <__assert_func>
	block->next_free = current;
4037ef1e:	29b9      	s32i.n	a11, a9, 8
	block->prev_free = &control->block_null;
4037ef20:	3989      	s32i.n	a8, a9, 12
	current->prev_free = block;
4037ef22:	3b99      	s32i.n	a9, a11, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037ef24:	88d8      	l32i.n	a13, a8, 32
4037ef26:	48b8      	l32i.n	a11, a8, 16
4037ef28:	54beb0        	extui	a11, a11, 14, 6
4037ef2b:	82bcb0        	mull	a11, a12, a11
4037ef2e:	baba      	add.n	a11, a10, a11
4037ef30:	a0bbd0        	addx4	a11, a11, a13
4037ef33:	0b99      	s32i.n	a9, a11, 0
	control->fl_bitmap |= (1U << fl);
4037ef35:	68b8      	l32i.n	a11, a8, 24
4037ef37:	190c      	movi.n	a9, 1
4037ef39:	401c00        	ssl	a12
4037ef3c:	a1d900        	sll	a13, a9
4037ef3f:	20bbd0        	or	a11, a11, a13
4037ef42:	68b9      	s32i.n	a11, a8, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037ef44:	7888      	l32i.n	a8, a8, 28
4037ef46:	a0cc80        	addx4	a12, a12, a8
4037ef49:	0c88      	l32i.n	a8, a12, 0
4037ef4b:	401a00        	ssl	a10
4037ef4e:	a19900        	sll	a9, a9
4037ef51:	208890        	or	a8, a8, a9
4037ef54:	0c89      	s32i.n	a8, a12, 0
	return tlsf_cast(void*,
4037ef56:	a28b      	addi.n	a10, a2, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ef58:	1298      	l32i.n	a9, a2, 4
4037ef5a:	c87c      	movi.n	a8, -4
4037ef5c:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037ef5f:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ef62:	88aa      	add.n	a8, a8, a10
	tlsf_assert(!block_is_last(block));
4037ef64:	3b0c      	movi.n	a11, 3
4037ef66:	0e3b97        	bltu	a11, a9, 4037ef78 <tlsf_malloc+0x3a0>
4037ef69:	d80dd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037ef6c:	d80ec1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037ef6f:	a1a0b2        	movi	a11, 161
4037ef72:	d80da1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037ef75:	00dda5        	call8	4037fd50 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037ef78:	1898      	l32i.n	a9, a8, 4
4037ef7a:	db7c      	movi.n	a11, -3
4037ef7c:	1099b0        	and	a9, a9, a11
4037ef7f:	1899      	s32i.n	a9, a8, 4
	block->size &= ~block_header_free_bit;
4037ef81:	1288      	l32i.n	a8, a2, 4
4037ef83:	e97c      	movi.n	a9, -2
4037ef85:	108890        	and	a8, a8, a9
4037ef88:	1289      	s32i.n	a8, a2, 4
		block_trim_free(control, block, size);
		block_mark_as_used(block);
		p = block_to_ptr(block);
4037ef8a:	0a2d      	mov.n	a2, a10
4037ef8c:	000506        	j	4037efa4 <tlsf_malloc+0x3cc>
4037ef8f:	020c00        	andb	b0, b12, b0
		return NULL;
4037ef92:	000386        	j	4037efa4 <tlsf_malloc+0x3cc>
4037ef95:	0002c6        	j	4037efa4 <tlsf_malloc+0x3cc>
4037ef98:	020c      	movi.n	a2, 0
4037ef9a:	000186        	j	4037efa4 <tlsf_malloc+0x3cc>
	void* p = 0;
4037ef9d:	020c      	movi.n	a2, 0
4037ef9f:	000046        	j	4037efa4 <tlsf_malloc+0x3cc>
4037efa2:	020c      	movi.n	a2, 0
}
4037efa4:	f01d      	retw.n
	...

4037efa8 <tlsf_memalign_offs>:
{
4037efa8:	004136        	entry	a1, 32
4037efab:	02cd      	mov.n	a12, a2
	if (size)
4037efad:	74ac      	beqz.n	a4, 4037efd8 <tlsf_memalign_offs+0x30>
	return (x + (align - 1)) & ~(align - 1);
4037efaf:	443b      	addi.n	a4, a4, 3
4037efb1:	c87c      	movi.n	a8, -4
4037efb3:	104480        	and	a4, a4, a8
	if (control == NULL)
4037efb6:	629c      	beqz.n	a2, 4037efd0 <tlsf_memalign_offs+0x28>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037efb8:	4298      	l32i.n	a9, a2, 16
4037efba:	549890        	extui	a9, a9, 8, 6
4037efbd:	180c      	movi.n	a8, 1
4037efbf:	401900        	ssl	a9
4037efc2:	a18800        	sll	a8, a8
		if (aligned < tlsf_block_size_max(control)) 
4037efc5:	0db487        	bgeu	a4, a8, 4037efd6 <tlsf_memalign_offs+0x2e>
			adjust = tlsf_max(aligned, block_size_min);
4037efc8:	c80c      	movi.n	a8, 12
4037efca:	734480        	maxu	a4, a4, a8
4037efcd:	0001c6        	j	4037efd8 <tlsf_memalign_offs+0x30>
	size_t adjust = 0;
4037efd0:	040c      	movi.n	a4, 0
4037efd2:	000086        	j	4037efd8 <tlsf_memalign_offs+0x30>
4037efd5:	040c00        	extui	a0, a0, 12, 1
	return (x + (align - 1)) & ~(align - 1);
4037efd8:	953b      	addi.n	a9, a5, 3
4037efda:	c87c      	movi.n	a8, -4
4037efdc:	109980        	and	a9, a9, a8
	const size_t gap_minimum = sizeof(block_header_t) + off_adjust;
4037efdf:	10c9d2        	addi	a13, a9, 16
	const size_t size_with_gap = adjust_request_size(tlsf, adjust + align + gap_minimum - off_adjust, align);
4037efe2:	a34a      	add.n	a10, a3, a4
4037efe4:	aada      	add.n	a10, a10, a13
4037efe6:	c08a90        	sub	a8, a10, a9
	if (size)
4037efe9:	3f1a97        	beq	a10, a9, 4037f02c <tlsf_memalign_offs+0x84>
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037efec:	a30b      	addi.n	a10, a3, -1
4037efee:	0e03a7        	bnone	a3, a10, 4037f000 <tlsf_memalign_offs+0x58>
4037eff1:	d7fed1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037eff4:	d7ffc1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c027970 <__func__$19>)
4037eff7:	f3a0b2        	movi	a11, 243
4037effa:	d7eea1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037effd:	00d525        	call8	4037fd50 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037f000:	883a      	add.n	a8, a8, a3
4037f002:	880b      	addi.n	a8, a8, -1
4037f004:	60a030        	neg	a10, a3
4037f007:	1088a0        	and	a8, a8, a10
	if (control == NULL)
4037f00a:	6c9c      	beqz.n	a12, 4037f024 <tlsf_memalign_offs+0x7c>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037f00c:	4cb8      	l32i.n	a11, a12, 16
4037f00e:	54b8b0        	extui	a11, a11, 8, 6
4037f011:	1a0c      	movi.n	a10, 1
4037f013:	401b00        	ssl	a11
4037f016:	a1aa00        	sll	a10, a10
		if (aligned < tlsf_block_size_max(control)) 
4037f019:	0db8a7        	bgeu	a8, a10, 4037f02a <tlsf_memalign_offs+0x82>
			adjust = tlsf_max(aligned, block_size_min);
4037f01c:	ca0c      	movi.n	a10, 12
4037f01e:	7388a0        	maxu	a8, a8, a10
4037f021:	0001c6        	j	4037f02c <tlsf_memalign_offs+0x84>
	size_t adjust = 0;
4037f024:	080c      	movi.n	a8, 0
4037f026:	000086        	j	4037f02c <tlsf_memalign_offs+0x84>
4037f029:	080c00        	lsx	f0, a12, a0
	size_t aligned_size = (adjust && align > ALIGN_SIZE) ? size_with_gap : adjust;
4037f02c:	1e0c      	movi.n	a14, 1
4037f02e:	83e440        	moveqz	a14, a4, a4
4037f031:	4a0c      	movi.n	a10, 4
4037f033:	62aa30        	lsi	f3, a10, 0x188
4037f036:	018ea7        	bany	a14, a10, 4037f03b <tlsf_memalign_offs+0x93>
4037f039:	048d      	mov.n	a8, a4
	if (*size)
4037f03b:	3a9816        	beqz	a8, 4037f3e8 <tlsf_memalign_offs+0x440>
	if (*size >= control->small_block_size)
4037f03e:	4ca8      	l32i.n	a10, a12, 16
4037f040:	75a7a0        	extui	a10, a10, 23, 8
4037f043:	0a5d      	mov.n	a5, a10
4037f045:	3738a7        	bltu	a8, a10, 4037f080 <tlsf_memalign_offs+0xd8>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f048:	40f8b0        	nsau	a11, a8
	return bit - 1;
4037f04b:	e1cbb2        	addi	a11, a11, -31
4037f04e:	60b0b0        	neg	a11, a11
		const size_t round = (1 << (tlsf_fls_sizet(*size) - control->sl_index_count_log2));
4037f051:	4cf8      	l32i.n	a15, a12, 16
4037f053:	25f4f0        	extui	a15, a15, 20, 3
4037f056:	c0fbf0        	sub	a15, a11, a15
4037f059:	1b0c      	movi.n	a11, 1
4037f05b:	401f00        	ssl	a15
4037f05e:	a1bb00        	sll	a11, a11
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037f061:	ffcbf2        	addi	a15, a11, -1
4037f064:	0e0bf7        	bnone	a11, a15, 4037f076 <tlsf_memalign_offs+0xce>
4037f067:	d7e1d1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037f06a:	d7e1c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c027970 <__func__$19>)
4037f06d:	f3a0b2        	movi	a11, 243
4037f070:	d7d1a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f073:	00cde5        	call8	4037fd50 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037f076:	88ba      	add.n	a8, a8, a11
4037f078:	880b      	addi.n	a8, a8, -1
4037f07a:	60b0b0        	neg	a11, a11
4037f07d:	1088b0        	and	a8, a8, a11
	if (size < control->small_block_size)
4037f080:	10b857        	bgeu	a8, a5, 4037f094 <tlsf_memalign_offs+0xec>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f083:	4cb8      	l32i.n	a11, a12, 16
4037f085:	54beb0        	extui	a11, a11, 14, 6
4037f088:	d2aab0        	quos	a10, a10, a11
4037f08b:	d2a8a0        	quos	a10, a8, a10
		fl = 0;
4037f08e:	0b0c      	movi.n	a11, 0
4037f090:	000c86        	j	4037f0c6 <tlsf_memalign_offs+0x11e>
4037f093:	a88c00        	lsi	f0, a12, 0x2a0
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f096:	40f8b0        	nsau	a11, a8
4037f099:	e0cbb2        	addi	a11, a11, -32
4037f09c:	60b0b0        	neg	a11, a11
4037f09f:	000086        	j	4037f0a5 <tlsf_memalign_offs+0xfd>
4037f0a2:	00a0b2        	movi	a11, 0
	return bit - 1;
4037f0a5:	ab0b      	addi.n	a10, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f0a7:	4cf8      	l32i.n	a15, a12, 16
4037f0a9:	2554f0        	extui	a5, a15, 20, 3
4037f0ac:	c0aa50        	sub	a10, a10, a5
4037f0af:	400a00        	ssr	a10
4037f0b2:	91a080        	srl	a10, a8
4037f0b5:	170c      	movi.n	a7, 1
4037f0b7:	401500        	ssl	a5
4037f0ba:	a17700        	sll	a7, a7
4037f0bd:	30aa70        	xor	a10, a10, a7
		fl -= (control->fl_index_shift - 1);
4037f0c0:	24f5f0        	extui	a15, a15, 5, 3
4037f0c3:	c0bbf0        	sub	a11, a11, a15
		if (fl < control->fl_index_count)
4037f0c6:	4cf8      	l32i.n	a15, a12, 16
4037f0c8:	44f0f0        	extui	a15, a15, 0, 5
4037f0cb:	022bf7        	blt	a11, a15, 4037f0d1 <tlsf_memalign_offs+0x129>
4037f0ce:	0145c6        	j	4037f5e9 <tlsf_memalign_offs+0x641>
	unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
4037f0d1:	7c28      	l32i.n	a2, a12, 28
4037f0d3:	a0fb20        	addx4	a15, a11, a2
4037f0d6:	0f78      	l32i.n	a7, a15, 0
4037f0d8:	ff7c      	movi.n	a15, -1
4037f0da:	401a00        	ssl	a10
4037f0dd:	a1af00        	sll	a10, a15
4037f0e0:	1057a0        	and	a5, a7, a10
	if (!sl_map)
4037f0e3:	3b87a7        	bany	a7, a10, 4037f122 <tlsf_memalign_offs+0x17a>
		const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
4037f0e6:	6cf8      	l32i.n	a15, a12, 24
4037f0e8:	bb1b      	addi.n	a11, a11, 1
4037f0ea:	ffafa2        	movi	a10, -1
4037f0ed:	401b00        	ssl	a11
4037f0f0:	a1aa00        	sll	a10, a10
4037f0f3:	107fa0        	and	a7, a15, a10
		if (!fl_map)
4037f0f6:	028fa7        	bany	a15, a10, 4037f0fc <tlsf_memalign_offs+0x154>
4037f0f9:	013c46        	j	4037f5ee <tlsf_memalign_offs+0x646>
	return __builtin_ffs(word) - 1;
4037f0fc:	60b070        	neg	a11, a7
4037f0ff:	10bb70        	and	a11, a11, a7
4037f102:	40fbb0        	nsau	a11, a11
4037f105:	e1cbb2        	addi	a11, a11, -31
4037f108:	60b0b0        	neg	a11, a11
		sl_map = control->sl_bitmap[fl];
4037f10b:	a02b20        	addx4	a2, a11, a2
4037f10e:	0258      	l32i.n	a5, a2, 0
	tlsf_assert(sl_map && "internal error - second level bitmap is null");
4037f110:	00e556        	bnez	a5, 4037f122 <tlsf_memalign_offs+0x17a>
4037f113:	d7b8d1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c022ea0 <_flash_rodata_start+0x2d80>)
4037f116:	d7b8c1        	l32r	a12, 40374ff8 <_iram_text_start+0xbf4> (3c0278fc <__func__$11>)
4037f119:	67a1b2        	movi	a11, 0x167
4037f11c:	d7a6a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f11f:	00c325        	call8	4037fd50 <__assert_func>
	return __builtin_ffs(word) - 1;
4037f122:	60f050        	neg	a15, a5
4037f125:	10ff50        	and	a15, a15, a5
4037f128:	40fff0        	nsau	a15, a15
4037f12b:	e1cff2        	addi	a15, a15, -31
4037f12e:	60f0f0        	neg	a15, a15
	return control->blocks[fl * control->sl_index_count + sl];
4037f131:	8c78      	l32i.n	a7, a12, 32
4037f133:	4ca8      	l32i.n	a10, a12, 16
4037f135:	54aea0        	extui	a10, a10, 14, 6
4037f138:	82aab0        	mull	a10, a10, a11
4037f13b:	afaa      	add.n	a10, a15, a10
4037f13d:	a0aa70        	addx4	a10, a10, a7
4037f140:	0a28      	l32i.n	a2, a10, 0
	if (block)
4037f142:	4af216        	beqz	a2, 4037f5f5 <tlsf_memalign_offs+0x64d>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f145:	12a8      	l32i.n	a10, a2, 4
4037f147:	fcaf72        	movi	a7, -4
4037f14a:	10aa70        	and	a10, a10, a7
		tlsf_assert(block_size(block) >= *size);
4037f14d:	0eba87        	bgeu	a10, a8, 4037f15f <tlsf_memalign_offs+0x1b7>
4037f150:	d7abd1        	l32r	a13, 40374ffc <_iram_text_start+0xbf8> (3c022edc <_flash_rodata_start+0x2dbc>)
4037f153:	d7abc1        	l32r	a12, 40375000 <_iram_text_start+0xbfc> (3c027914 <__func__$12>)
4037f156:	6aa2b2        	movi	a11, 0x26a
4037f159:	d796a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f15c:	00bf25        	call8	4037fd50 <__assert_func>
	block_header_t* prev = block->prev_free;
4037f15f:	3288      	l32i.n	a8, a2, 12
	block_header_t* next = block->next_free;
4037f161:	22a8      	l32i.n	a10, a2, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f163:	00e856        	bnez	a8, 4037f175 <tlsf_memalign_offs+0x1cd>
4037f166:	d795d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037f169:	d795c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037f16c:	74a1b2        	movi	a11, 0x174
4037f16f:	d791a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f172:	00bde5        	call8	4037fd50 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f175:	011a56        	bnez	a10, 4037f18a <tlsf_memalign_offs+0x1e2>
4037f178:	d793d1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037f17b:	d791c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037f17e:	75a1b2        	movi	a11, 0x175
4037f181:	d78ca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f184:	201110        	or	a1, a1, a1
4037f187:	00bca5        	call8	4037fd50 <__assert_func>
	next->prev_free = prev;
4037f18a:	3a89      	s32i.n	a8, a10, 12
	prev->next_free = next;
4037f18c:	28a9      	s32i.n	a10, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f18e:	8c58      	l32i.n	a5, a12, 32
4037f190:	4c88      	l32i.n	a8, a12, 16
4037f192:	548e80        	extui	a8, a8, 14, 6
4037f195:	828b80        	mull	a8, a11, a8
4037f198:	8f8a      	add.n	a8, a15, a8
4037f19a:	a08850        	addx4	a8, a8, a5
4037f19d:	0878      	l32i.n	a7, a8, 0
4037f19f:	369277        	bne	a2, a7, 4037f1d9 <tlsf_memalign_offs+0x231>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f1a2:	08a9      	s32i.n	a10, a8, 0
		if (next == &control->block_null)
4037f1a4:	319ac7        	bne	a10, a12, 4037f1d9 <tlsf_memalign_offs+0x231>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f1a7:	7ca8      	l32i.n	a10, a12, 28
4037f1a9:	a0aba0        	addx4	a10, a11, a10
4037f1ac:	0a78      	l32i.n	a7, a10, 0
4037f1ae:	180c      	movi.n	a8, 1
4037f1b0:	401f00        	ssl	a15
4037f1b3:	a18800        	sll	a8, a8
4037f1b6:	108870        	and	a8, a8, a7
4037f1b9:	308870        	xor	a8, a8, a7
4037f1bc:	0a89      	s32i.n	a8, a10, 0
			if (!control->sl_bitmap[fl])
4037f1be:	7c88      	l32i.n	a8, a12, 28
4037f1c0:	a08b80        	addx4	a8, a11, a8
4037f1c3:	0888      	l32i.n	a8, a8, 0
4037f1c5:	08dc      	bnez.n	a8, 4037f1d9 <tlsf_memalign_offs+0x231>
				control->fl_bitmap &= ~(1U << fl);
4037f1c7:	6ca8      	l32i.n	a10, a12, 24
4037f1c9:	180c      	movi.n	a8, 1
4037f1cb:	401b00        	ssl	a11
4037f1ce:	a18800        	sll	a8, a8
4037f1d1:	1088a0        	and	a8, a8, a10
4037f1d4:	3088a0        	xor	a8, a8, a10
4037f1d7:	6c89      	s32i.n	a8, a12, 24
	return tlsf_cast(void*,
4037f1d9:	a28b      	addi.n	a10, a2, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f1db:	f3aa      	add.n	a15, a3, a10
4037f1dd:	ff0b      	addi.n	a15, a15, -1
4037f1df:	60b030        	neg	a11, a3
4037f1e2:	10ffb0        	and	a15, a15, a11
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037f1e5:	830b      	addi.n	a8, a3, -1
4037f1e7:	0e0387        	bnone	a3, a8, 4037f1f9 <tlsf_memalign_offs+0x251>
4037f1ea:	d780d1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c022e60 <_flash_rodata_start+0x2d40>)
4037f1ed:	d78dc1        	l32r	a12, 40375024 <_iram_text_start+0xc20> (3c027950 <__func__$16>)
4037f1f0:	01a1b2        	movi	a11, 0x101
4037f1f3:	d770a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f1f6:	00b5a5        	call8	4037fd50 <__assert_func>
		size_t gap = tlsf_cast(size_t,
4037f1f9:	c08fa0        	sub	a8, a15, a10
		if ((gap && gap < gap_minimum) || (!gap && off_adjust && align > ALIGN_SIZE))
4037f1fc:	150c      	movi.n	a5, 1
4037f1fe:	835880        	moveqz	a5, a8, a8
4037f201:	6278d0        	lsi	f13, a8, 0x188
4037f204:	108577        	bany	a5, a7, 4037f218 <tlsf_memalign_offs+0x270>
4037f207:	40f870        	nsau	a7, a8
4037f20a:	417570        	srli	a7, a7, 5
4037f20d:	150c      	movi.n	a5, 1
4037f20f:	835990        	moveqz	a5, a9, a9
4037f212:	150757        	bnone	a7, a5, 4037f22b <tlsf_memalign_offs+0x283>
4037f215:	1253b6        	bltui	a3, 5, 4037f22b <tlsf_memalign_offs+0x283>
			const size_t gap_remain = gap_minimum - gap;
4037f218:	c08d80        	sub	a8, a13, a8
			const size_t offset = tlsf_max(gap_remain, align);
4037f21b:	738380        	maxu	a8, a3, a8
			const void* next_aligned = tlsf_cast(void*,
4037f21e:	88fa      	add.n	a8, a8, a15
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f220:	883a      	add.n	a8, a8, a3
4037f222:	ffc882        	addi	a8, a8, -1
4037f225:	10bb80        	and	a11, a11, a8
			gap = tlsf_cast(size_t,
4037f228:	c08ba0        	sub	a8, a11, a10
		if (gap)
4037f22b:	1be816        	beqz	a8, 4037f3ed <tlsf_memalign_offs+0x445>
			tlsf_assert(gap >= gap_minimum && "gap size too small");
4037f22e:	0eb8d7        	bgeu	a8, a13, 4037f240 <tlsf_memalign_offs+0x298>
4037f231:	d77dd1        	l32r	a13, 40375028 <_iram_text_start+0xc24> (3c023048 <_flash_rodata_start+0x2f28>)
4037f234:	d77ec1        	l32r	a12, 4037502c <_iram_text_start+0xc28> (3c0278b8 <__func__$7>)
4037f237:	5ba2b2        	movi	a11, 0x25b
4037f23a:	d758a1        	l32r	a10, 40374f9c <_iram_text_start+0xb98> (3c022adb <_flash_rodata_start+0x29bb>)
4037f23d:	00b125        	call8	4037fd50 <__assert_func>
			block = block_trim_free_leading(control, block, gap - off_adjust);
4037f240:	c08890        	sub	a8, a8, a9
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f243:	12b8      	l32i.n	a11, a2, 4
4037f245:	c97c      	movi.n	a9, -4
4037f247:	10bb90        	and	a11, a11, a9
	return block_size(block) >= sizeof(block_header_t) + size;
4037f24a:	10c892        	addi	a9, a8, 16
	if (block_can_split(block, size))
4037f24d:	02bb97        	bgeu	a11, a9, 4037f253 <tlsf_memalign_offs+0x2ab>
4037f250:	006806        	j	4037f3f4 <tlsf_memalign_offs+0x44c>
		remaining_block = block_split(block, size - block_header_overhead);
4037f253:	fcc8f2        	addi	a15, a8, -4
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f256:	f8c882        	addi	a8, a8, -8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f259:	8a8a      	add.n	a8, a10, a8
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f25b:	c09bf0        	sub	a9, a11, a15
4037f25e:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(void*,
4037f261:	d88b      	addi.n	a13, a8, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f263:	78bb      	addi.n	a7, a8, 11
4037f265:	c57c      	movi.n	a5, -4
4037f267:	107750        	and	a7, a7, a5
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f26a:	0e1d77        	beq	a13, a7, 4037f27c <tlsf_memalign_offs+0x2d4>
4037f26d:	d769d1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037f270:	d76ac1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f273:	c4a1b2        	movi	a11, 0x1c4
4037f276:	d74fa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f279:	00ad65        	call8	4037fd50 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f27c:	7f9a      	add.n	a7, a15, a9
4037f27e:	04c772        	addi	a7, a7, 4
4037f281:	0e1b77        	beq	a11, a7, 4037f293 <tlsf_memalign_offs+0x2eb>
4037f284:	d766d1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037f287:	d764c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f28a:	c7a1b2        	movi	a11, 0x1c7
4037f28d:	d749a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f290:	00abe5        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037f293:	18b8      	l32i.n	a11, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f295:	14b0b0        	extui	a11, a11, 0, 2
4037f298:	2099b0        	or	a9, a9, a11
4037f29b:	1899      	s32i.n	a9, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f29d:	cb7c      	movi.n	a11, -4
4037f29f:	1099b0        	and	a9, a9, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f2a2:	bb0c      	movi.n	a11, 11
4037f2a4:	0e3b97        	bltu	a11, a9, 4037f2b6 <tlsf_memalign_offs+0x30e>
4037f2a7:	d75ed1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037f2aa:	d75bc1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f2ad:	c9a1b2        	movi	a11, 0x1c9
4037f2b0:	d741a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f2b3:	00a9e5        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037f2b6:	1298      	l32i.n	a9, a2, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f2b8:	149090        	extui	a9, a9, 0, 2
4037f2bb:	20ff90        	or	a15, a15, a9
4037f2be:	12f9      	s32i.n	a15, a2, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f2c0:	18b8      	l32i.n	a11, a8, 4
4037f2c2:	c97c      	movi.n	a9, -4
4037f2c4:	109b90        	and	a9, a11, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f2c7:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f2ca:	dd9a      	add.n	a13, a13, a9
	tlsf_assert(!block_is_last(block));
4037f2cc:	390c      	movi.n	a9, 3
4037f2ce:	0e39b7        	bltu	a9, a11, 4037f2e0 <tlsf_memalign_offs+0x338>
4037f2d1:	d733d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f2d4:	d734c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f2d7:	a1a0b2        	movi	a11, 161
4037f2da:	d733a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f2dd:	00a725        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037f2e0:	0d89      	s32i.n	a8, a13, 0
	block->size |= block_header_prev_free_bit;
4037f2e2:	1d98      	l32i.n	a9, a13, 4
4037f2e4:	2b0c      	movi.n	a11, 2
4037f2e6:	2099b0        	or	a9, a9, a11
4037f2e9:	1d99      	s32i.n	a9, a13, 4
	block->size |= block_header_free_bit;
4037f2eb:	1898      	l32i.n	a9, a8, 4
4037f2ed:	1b0c      	movi.n	a11, 1
4037f2ef:	20b9b0        	or	a11, a9, a11
4037f2f2:	18b9      	s32i.n	a11, a8, 4
	block->size |= block_header_prev_free_bit;
4037f2f4:	3d0c      	movi.n	a13, 3
4037f2f6:	2099d0        	or	a9, a9, a13
4037f2f9:	1899      	s32i.n	a9, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f2fb:	12b8      	l32i.n	a11, a2, 4
4037f2fd:	c97c      	movi.n	a9, -4
4037f2ff:	109b90        	and	a9, a11, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f302:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f305:	9a9a      	add.n	a9, a10, a9
	tlsf_assert(!block_is_last(block));
4037f307:	0e3db7        	bltu	a13, a11, 4037f319 <tlsf_memalign_offs+0x371>
4037f30a:	d725d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f30d:	d725c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f310:	a1a0b2        	movi	a11, 161
4037f313:	d725a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f316:	00a3a5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037f319:	0929      	s32i.n	a2, a9, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f31b:	1298      	l32i.n	a9, a2, 4
4037f31d:	cb7c      	movi.n	a11, -4
4037f31f:	1099b0        	and	a9, a9, a11
	if (size < control->small_block_size)
4037f322:	4cb8      	l32i.n	a11, a12, 16
4037f324:	75b7b0        	extui	a11, a11, 23, 8
4037f327:	0fb9b7        	bgeu	a9, a11, 4037f33a <tlsf_memalign_offs+0x392>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f32a:	4cd8      	l32i.n	a13, a12, 16
4037f32c:	54ded0        	extui	a13, a13, 14, 6
4037f32f:	d2bbd0        	quos	a11, a11, a13
4037f332:	d299b0        	quos	a9, a9, a11
		fl = 0;
4037f335:	0d0c      	movi.n	a13, 0
4037f337:	000cc6        	j	4037f36e <tlsf_memalign_offs+0x3c6>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f33a:	a98c      	beqz.n	a9, 4037f348 <tlsf_memalign_offs+0x3a0>
4037f33c:	40f9d0        	nsau	a13, a9
4037f33f:	e0cdd2        	addi	a13, a13, -32
4037f342:	60d0d0        	neg	a13, a13
4037f345:	000086        	j	4037f34b <tlsf_memalign_offs+0x3a3>
4037f348:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f34b:	ffcdf2        	addi	a15, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f34e:	042cb2        	l32i	a11, a12, 16
4037f351:	2574b0        	extui	a7, a11, 20, 3
4037f354:	c0ff70        	sub	a15, a15, a7
4037f357:	400f00        	ssr	a15
4037f35a:	919090        	srl	a9, a9
4037f35d:	1f0c      	movi.n	a15, 1
4037f35f:	401700        	ssl	a7
4037f362:	a1ff00        	sll	a15, a15
4037f365:	3099f0        	xor	a9, a9, a15
		fl -= (control->fl_index_shift - 1);
4037f368:	24b5b0        	extui	a11, a11, 5, 3
4037f36b:	c0ddb0        	sub	a13, a13, a11
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037f36e:	8cf8      	l32i.n	a15, a12, 32
4037f370:	4cb8      	l32i.n	a11, a12, 16
4037f372:	54beb0        	extui	a11, a11, 14, 6
4037f375:	82bbd0        	mull	a11, a11, a13
4037f378:	bb9a      	add.n	a11, a11, a9
4037f37a:	a0bbf0        	addx4	a11, a11, a15
4037f37d:	0bb8      	l32i.n	a11, a11, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037f37f:	dbcc      	bnez.n	a11, 4037f390 <tlsf_memalign_offs+0x3e8>
4037f381:	d716d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037f384:	d717c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037f387:	90a1b2        	movi	a11, 0x190
4037f38a:	d70aa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f38d:	009c25        	call8	4037fd50 <__assert_func>
	block->next_free = current;
4037f390:	0262b2        	s32i	a11, a2, 8
	block->prev_free = &control->block_null;
4037f393:	0362c2        	s32i	a12, a2, 12
	current->prev_free = block;
4037f396:	036b22        	s32i	a2, a11, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f399:	ba3b      	addi.n	a11, a10, 3
4037f39b:	cf7c      	movi.n	a15, -4
4037f39d:	10bbf0        	and	a11, a11, a15
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037f3a0:	0e1ab7        	beq	a10, a11, 4037f3b2 <tlsf_memalign_offs+0x40a>
4037f3a3:	d711d1        	l32r	a13, 40374fe8 <_iram_text_start+0xbe4> (3c022cb0 <_flash_rodata_start+0x2b90>)
4037f3a6:	d70ec1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037f3a9:	96a1b2        	movi	a11, 0x196
4037f3ac:	d702a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f3af:	009a25        	call8	4037fd50 <__assert_func>
	control->blocks[fl * control->sl_index_count + sl] = block;
4037f3b2:	8cb8      	l32i.n	a11, a12, 32
4037f3b4:	4ca8      	l32i.n	a10, a12, 16
4037f3b6:	54aea0        	extui	a10, a10, 14, 6
4037f3b9:	82ada0        	mull	a10, a13, a10
4037f3bc:	a9aa      	add.n	a10, a9, a10
4037f3be:	a0aab0        	addx4	a10, a10, a11
4037f3c1:	0a29      	s32i.n	a2, a10, 0
	control->fl_bitmap |= (1U << fl);
4037f3c3:	6cb8      	l32i.n	a11, a12, 24
4037f3c5:	1a0c      	movi.n	a10, 1
4037f3c7:	401d00        	ssl	a13
4037f3ca:	a1fa00        	sll	a15, a10
4037f3cd:	20bbf0        	or	a11, a11, a15
4037f3d0:	6cb9      	s32i.n	a11, a12, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037f3d2:	7cb8      	l32i.n	a11, a12, 28
4037f3d4:	a0ddb0        	addx4	a13, a13, a11
4037f3d7:	0db8      	l32i.n	a11, a13, 0
4037f3d9:	401900        	ssl	a9
4037f3dc:	a1aa00        	sll	a10, a10
4037f3df:	209ba0        	or	a9, a11, a10
4037f3e2:	0d99      	s32i.n	a9, a13, 0
	return remaining_block;
4037f3e4:	0001c6        	j	4037f3ef <tlsf_memalign_offs+0x447>
4037f3e7:	080c00        	lsx	f0, a12, a0
	block_header_t* block = block_locate_free(control, &aligned_size);
4037f3ea:	000046        	j	4037f3ef <tlsf_memalign_offs+0x447>
4037f3ed:	028d      	mov.n	a8, a2
	if (block)
4037f3ef:	48cc      	bnez.n	a8, 4037f3f7 <tlsf_memalign_offs+0x44f>
4037f3f1:	007f86        	j	4037f5f3 <tlsf_memalign_offs+0x64b>
			block = block_trim_free_leading(control, block, gap - off_adjust);
4037f3f4:	208220        	or	a8, a2, a2
		tlsf_assert(size && "size must be non-zero");
4037f3f7:	decc      	bnez.n	a14, 4037f408 <tlsf_memalign_offs+0x460>
4037f3f9:	d702d1        	l32r	a13, 40375004 <_iram_text_start+0xc00> (3c022ef8 <_flash_rodata_start+0x2dd8>)
4037f3fc:	d703c1        	l32r	a12, 40375008 <_iram_text_start+0xc04> (3c0278e8 <__func__$10>)
4037f3ff:	76a2b2        	movi	a11, 0x276
4037f402:	d6eca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f405:	0094a5        	call8	4037fd50 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f408:	1898      	l32i.n	a9, a8, 4
	tlsf_assert(block_is_free(block) && "block must be free");
4037f40a:	0ee907        	bbsi	a9, 0, 4037f41c <tlsf_memalign_offs+0x474>
4037f40d:	d6ffd1        	l32r	a13, 4037500c <_iram_text_start+0xc08> (3c022f18 <_flash_rodata_start+0x2df8>)
4037f410:	d700c1        	l32r	a12, 40375010 <_iram_text_start+0xc0c> (3c0278d8 <__func__$9>)
4037f413:	24a2b2        	movi	a11, 0x224
4037f416:	d6e7a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f419:	009365        	call8	4037fd50 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f41c:	ca7c      	movi.n	a10, -4
4037f41e:	10b9a0        	and	a11, a9, a10
	return block_size(block) >= sizeof(block_header_t) + size;
4037f421:	10c492        	addi	a9, a4, 16
	if (block_can_split(block, size))
4037f424:	02bb97        	bgeu	a11, a9, 4037f42a <tlsf_memalign_offs+0x482>
4037f427:	0061c6        	j	4037f5b2 <tlsf_memalign_offs+0x60a>
	return tlsf_cast(void*,
4037f42a:	e88b      	addi.n	a14, a8, 8
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f42c:	94aa      	add.n	a9, a4, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f42e:	9e9a      	add.n	a9, a14, a9
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f430:	c0ab40        	sub	a10, a11, a4
4037f433:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(void*,
4037f436:	d98b      	addi.n	a13, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f438:	f9bb      	addi.n	a15, a9, 11
4037f43a:	c77c      	movi.n	a7, -4
4037f43c:	10ff70        	and	a15, a15, a7
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f43f:	0e1df7        	beq	a13, a15, 4037f451 <tlsf_memalign_offs+0x4a9>
4037f442:	d6f4d1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037f445:	d6f4c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f448:	c4a1b2        	movi	a11, 0x1c4
4037f44b:	d6daa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f44e:	009025        	call8	4037fd50 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f451:	f4aa      	add.n	a15, a4, a10
4037f453:	ff4b      	addi.n	a15, a15, 4
4037f455:	0e1bf7        	beq	a11, a15, 4037f467 <tlsf_memalign_offs+0x4bf>
4037f458:	d6f1d1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037f45b:	d6efc1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f45e:	c7a1b2        	movi	a11, 0x1c7
4037f461:	d6d4a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f464:	008ea5        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037f467:	19b8      	l32i.n	a11, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f469:	14b0b0        	extui	a11, a11, 0, 2
4037f46c:	20aab0        	or	a10, a10, a11
4037f46f:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f471:	cb7c      	movi.n	a11, -4
4037f473:	10aab0        	and	a10, a10, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f476:	bb0c      	movi.n	a11, 11
4037f478:	0e3ba7        	bltu	a11, a10, 4037f48a <tlsf_memalign_offs+0x4e2>
4037f47b:	d6e9d1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037f47e:	d6e6c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f481:	c9a1b2        	movi	a11, 0x1c9
4037f484:	d6cca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f487:	008ca5        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037f48a:	18a8      	l32i.n	a10, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f48c:	14a0a0        	extui	a10, a10, 0, 2
4037f48f:	2044a0        	or	a4, a4, a10
4037f492:	1849      	s32i.n	a4, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f494:	19b8      	l32i.n	a11, a9, 4
4037f496:	ca7c      	movi.n	a10, -4
4037f498:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f49b:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f49e:	adaa      	add.n	a10, a13, a10
	tlsf_assert(!block_is_last(block));
4037f4a0:	3d0c      	movi.n	a13, 3
4037f4a2:	0e3db7        	bltu	a13, a11, 4037f4b4 <tlsf_memalign_offs+0x50c>
4037f4a5:	d6bed1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f4a8:	d6bfc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f4ab:	a1a0b2        	movi	a11, 161
4037f4ae:	d6bea1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f4b1:	0089e5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037f4b4:	0a99      	s32i.n	a9, a10, 0
	block->size |= block_header_prev_free_bit;
4037f4b6:	1ab8      	l32i.n	a11, a10, 4
4037f4b8:	2d0c      	movi.n	a13, 2
4037f4ba:	20bbd0        	or	a11, a11, a13
4037f4bd:	1ab9      	s32i.n	a11, a10, 4
	block->size |= block_header_free_bit;
4037f4bf:	19a8      	l32i.n	a10, a9, 4
4037f4c1:	1b0c      	movi.n	a11, 1
4037f4c3:	20aab0        	or	a10, a10, a11
4037f4c6:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f4c8:	18b8      	l32i.n	a11, a8, 4
4037f4ca:	ca7c      	movi.n	a10, -4
4037f4cc:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f4cf:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f4d2:	eeaa      	add.n	a14, a14, a10
	tlsf_assert(!block_is_last(block));
4037f4d4:	3a0c      	movi.n	a10, 3
4037f4d6:	0e3ab7        	bltu	a10, a11, 4037f4e8 <tlsf_memalign_offs+0x540>
4037f4d9:	d6b1d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f4dc:	d6b2c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f4df:	a1a0b2        	movi	a11, 161
4037f4e2:	d6b1a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f4e5:	0086a5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037f4e8:	0e89      	s32i.n	a8, a14, 0
	block->size |= block_header_prev_free_bit;
4037f4ea:	19b8      	l32i.n	a11, a9, 4
4037f4ec:	2a0c      	movi.n	a10, 2
4037f4ee:	20aba0        	or	a10, a11, a10
4037f4f1:	19a9      	s32i.n	a10, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
4037f4f3:	ca7c      	movi.n	a10, -4
4037f4f5:	10bba0        	and	a11, a11, a10
	if (size < control->small_block_size)
4037f4f8:	4ca8      	l32i.n	a10, a12, 16
4037f4fa:	75a7a0        	extui	a10, a10, 23, 8
4037f4fd:	0fbba7        	bgeu	a11, a10, 4037f510 <tlsf_memalign_offs+0x568>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f500:	4cd8      	l32i.n	a13, a12, 16
4037f502:	54ded0        	extui	a13, a13, 14, 6
4037f505:	d2aad0        	quos	a10, a10, a13
4037f508:	d2bba0        	quos	a11, a11, a10
		fl = 0;
4037f50b:	0d0c      	movi.n	a13, 0
4037f50d:	000cc6        	j	4037f544 <tlsf_memalign_offs+0x59c>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f510:	ab8c      	beqz.n	a11, 4037f51e <tlsf_memalign_offs+0x576>
4037f512:	40fbd0        	nsau	a13, a11
4037f515:	e0cdd2        	addi	a13, a13, -32
4037f518:	60d0d0        	neg	a13, a13
4037f51b:	000086        	j	4037f521 <tlsf_memalign_offs+0x579>
4037f51e:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f521:	ffcde2        	addi	a14, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f524:	042ca2        	l32i	a10, a12, 16
4037f527:	25f4a0        	extui	a15, a10, 20, 3
4037f52a:	c0eef0        	sub	a14, a14, a15
4037f52d:	400e00        	ssr	a14
4037f530:	91b0b0        	srl	a11, a11
4037f533:	1e0c      	movi.n	a14, 1
4037f535:	401f00        	ssl	a15
4037f538:	a1ee00        	sll	a14, a14
4037f53b:	30bbe0        	xor	a11, a11, a14
		fl -= (control->fl_index_shift - 1);
4037f53e:	24a5a0        	extui	a10, a10, 5, 3
4037f541:	c0dda0        	sub	a13, a13, a10
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037f544:	8ce8      	l32i.n	a14, a12, 32
4037f546:	4ca8      	l32i.n	a10, a12, 16
4037f548:	54aea0        	extui	a10, a10, 14, 6
4037f54b:	82aad0        	mull	a10, a10, a13
4037f54e:	aaba      	add.n	a10, a10, a11
4037f550:	a0aae0        	addx4	a10, a10, a14
4037f553:	0aa8      	l32i.n	a10, a10, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037f555:	dacc      	bnez.n	a10, 4037f566 <tlsf_memalign_offs+0x5be>
4037f557:	d6a1d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037f55a:	d6a1c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037f55d:	90a1b2        	movi	a11, 0x190
4037f560:	d695a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f563:	007ee5        	call8	4037fd50 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037f566:	09dc      	bnez.n	a9, 4037f57a <tlsf_memalign_offs+0x5d2>
4037f568:	d69fd1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037f56b:	d69dc1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037f56e:	91a1b2        	movi	a11, 0x191
4037f571:	d690a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f574:	201110        	or	a1, a1, a1
4037f577:	007da5        	call8	4037fd50 <__assert_func>
	block->next_free = current;
4037f57a:	29a9      	s32i.n	a10, a9, 8
	block->prev_free = &control->block_null;
4037f57c:	39c9      	s32i.n	a12, a9, 12
	current->prev_free = block;
4037f57e:	3a99      	s32i.n	a9, a10, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037f580:	8ce8      	l32i.n	a14, a12, 32
4037f582:	4ca8      	l32i.n	a10, a12, 16
4037f584:	54aea0        	extui	a10, a10, 14, 6
4037f587:	82ada0        	mull	a10, a13, a10
4037f58a:	abaa      	add.n	a10, a11, a10
4037f58c:	a0aae0        	addx4	a10, a10, a14
4037f58f:	0a99      	s32i.n	a9, a10, 0
	control->fl_bitmap |= (1U << fl);
4037f591:	6ca8      	l32i.n	a10, a12, 24
4037f593:	190c      	movi.n	a9, 1
4037f595:	401d00        	ssl	a13
4037f598:	a1e900        	sll	a14, a9
4037f59b:	20aae0        	or	a10, a10, a14
4037f59e:	6ca9      	s32i.n	a10, a12, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037f5a0:	7ca8      	l32i.n	a10, a12, 28
4037f5a2:	a0dda0        	addx4	a13, a13, a10
4037f5a5:	0da8      	l32i.n	a10, a13, 0
4037f5a7:	401b00        	ssl	a11
4037f5aa:	a19900        	sll	a9, a9
4037f5ad:	209a90        	or	a9, a10, a9
4037f5b0:	0d99      	s32i.n	a9, a13, 0
	return tlsf_cast(void*,
4037f5b2:	288b      	addi.n	a2, a8, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f5b4:	18a8      	l32i.n	a10, a8, 4
4037f5b6:	c97c      	movi.n	a9, -4
4037f5b8:	109a90        	and	a9, a10, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f5bb:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f5be:	992a      	add.n	a9, a9, a2
	tlsf_assert(!block_is_last(block));
4037f5c0:	3b0c      	movi.n	a11, 3
4037f5c2:	0e3ba7        	bltu	a11, a10, 4037f5d4 <tlsf_memalign_offs+0x62c>
4037f5c5:	d676d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f5c8:	d677c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f5cb:	a1a0b2        	movi	a11, 161
4037f5ce:	d676a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f5d1:	0077e5        	call8	4037fd50 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037f5d4:	19a8      	l32i.n	a10, a9, 4
4037f5d6:	db7c      	movi.n	a11, -3
4037f5d8:	10aab0        	and	a10, a10, a11
4037f5db:	19a9      	s32i.n	a10, a9, 4
	block->size &= ~block_header_free_bit;
4037f5dd:	1898      	l32i.n	a9, a8, 4
4037f5df:	ea7c      	movi.n	a10, -2
4037f5e1:	1099a0        	and	a9, a9, a10
4037f5e4:	1899      	s32i.n	a9, a8, 4
		p = block_to_ptr(block);
4037f5e6:	0002c6        	j	4037f5f5 <tlsf_memalign_offs+0x64d>
	void* p = 0;
4037f5e9:	020c      	movi.n	a2, 0
4037f5eb:	000186        	j	4037f5f5 <tlsf_memalign_offs+0x64d>
4037f5ee:	020c      	movi.n	a2, 0
4037f5f0:	000046        	j	4037f5f5 <tlsf_memalign_offs+0x64d>
4037f5f3:	082d      	mov.n	a2, a8
}
4037f5f5:	f01d      	retw.n
	...

4037f5f8 <tlsf_realloc>:
**   untouched
** - an extended buffer size will leave the newly-allocated area with
**   contents undefined
*/
void* tlsf_realloc(tlsf_t tlsf, void* ptr, size_t size)
{
4037f5f8:	004136        	entry	a1, 32
4037f5fb:	207220        	or	a7, a2, a2
	control_t* control = tlsf_cast(control_t*, tlsf);
	void* p = 0;

	/* Zero-size requests are treated as free. */
	if (ptr && size == 0)
4037f5fe:	01a092        	movi	a9, 1
4037f601:	839330        	moveqz	a9, a3, a3
4037f604:	40f480        	nsau	a8, a4
4037f607:	418580        	srli	a8, a8, 5
4037f60a:	0c0987        	bnone	a9, a8, 4037f61a <tlsf_realloc+0x22>
	{
		tlsf_free(tlsf, ptr);
4037f60d:	20b330        	or	a11, a3, a3
4037f610:	02ad      	mov.n	a10, a2
4037f612:	ff1d65        	call8	4037e7e8 <tlsf_free>
	void* p = 0;
4037f615:	020c      	movi.n	a2, 0
4037f617:	014546        	j	4037fb30 <tlsf_realloc+0x538>
	}
	/* Requests with NULL pointers are treated as malloc. */
	else if (!ptr)
4037f61a:	00e356        	bnez	a3, 4037f62c <tlsf_realloc+0x34>
	{
		p = tlsf_malloc(tlsf, size);
4037f61d:	20b440        	or	a11, a4, a4
4037f620:	20a220        	or	a10, a2, a2
4037f623:	ff5b65        	call8	4037ebd8 <tlsf_malloc>
4037f626:	0a2d      	mov.n	a2, a10
4037f628:	014106        	j	4037fb30 <tlsf_realloc+0x538>
4037f62b:	c3b200        	movf	a11, a2, b0
	return tlsf_cast(block_header_t*,
4037f62e:	92f8      	l32i.n	a15, a2, 36
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f630:	012b      	addi.n	a0, a1, 2
4037f632:	fcaf62        	movi	a6, -4
4037f635:	106960        	and	a6, a9, a6
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f638:	fcc6a2        	addi	a10, a6, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f63b:	aa3a      	add.n	a10, a10, a3
4037f63d:	0acd      	mov.n	a12, a10
	tlsf_assert(!block_is_last(block));
4037f63f:	380c      	movi.n	a8, 3
4037f641:	0e3897        	bltu	a8, a9, 4037f653 <tlsf_realloc+0x5b>
4037f644:	d657d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f647:	d657c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f64a:	a1a0b2        	movi	a11, 161
4037f64d:	d656a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f650:	006fe5        	call8	4037fd50 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f653:	1ae8      	l32i.n	a14, a10, 4
4037f655:	c87c      	movi.n	a8, -4
4037f657:	108e80        	and	a8, a14, a8
	{
		block_header_t* block = block_from_ptr(ptr);
		block_header_t* next = block_next(block);

		const size_t cursize = block_size(block);
		const size_t combined = cursize + block_size(next) + block_header_overhead;
4037f65a:	d86a      	add.n	a13, a8, a6
4037f65c:	dd4b      	addi.n	a13, a13, 4
	if (size)
4037f65e:	4bb416        	beqz	a4, 4037fb1d <tlsf_realloc+0x525>
	return (x + (align - 1)) & ~(align - 1);
4037f661:	543b      	addi.n	a5, a4, 3
4037f663:	cf7c      	movi.n	a15, -4
4037f665:	1055f0        	and	a5, a5, a15
	if (control == NULL)
4037f668:	4b8216        	beqz	a2, 4037fb24 <tlsf_realloc+0x52c>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037f66b:	4228      	l32i.n	a2, a2, 16
4037f66d:	542820        	extui	a2, a2, 8, 6
4037f670:	1f0c      	movi.n	a15, 1
4037f672:	401200        	ssl	a2
4037f675:	a1ff00        	sll	a15, a15
		if (aligned < tlsf_block_size_max(control)) 
4037f678:	0235f7        	bltu	a5, a15, 4037f67e <tlsf_realloc+0x86>
4037f67b:	012a46        	j	4037fb28 <tlsf_realloc+0x530>
			adjust = tlsf_max(aligned, block_size_min);
4037f67e:	cf0c      	movi.n	a15, 12
4037f680:	7355f0        	maxu	a5, a5, a15
		if (adjust == 0)
		{
			return p;
		}

		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037f683:	0e6907        	bbci	a9, 0, 4037f695 <tlsf_realloc+0x9d>
4037f686:	d643d1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c023074 <_flash_rodata_start+0x2f54>)
4037f689:	d669c1        	l32r	a12, 40375030 <_iram_text_start+0xc2c> (3c027864 <__func__$1>)
4037f68c:	a8a2b2        	movi	a11, 0x2a8
4037f68f:	d643a1        	l32r	a10, 40374f9c <_iram_text_start+0xb98> (3c022adb <_flash_rodata_start+0x29bb>)
4037f692:	006be5        	call8	4037fd50 <__assert_func>

		/*
		** If the next block is used, or when combined with the current
		** block, does not offer enough space, we must reallocate and copy.
		*/
		if (adjust > cursize && (!block_is_free(next) || adjust > combined))
4037f695:	27b657        	bgeu	a6, a5, 4037f6c0 <tlsf_realloc+0xc8>
4037f698:	026e07        	bbci	a14, 0, 4037f69e <tlsf_realloc+0xa6>
4037f69b:	21bd57        	bgeu	a13, a5, 4037f6c0 <tlsf_realloc+0xc8>
		{
			p = tlsf_malloc(tlsf, size);
4037f69e:	04bd      	mov.n	a11, a4
4037f6a0:	07ad      	mov.n	a10, a7
4037f6a2:	ff5365        	call8	4037ebd8 <tlsf_malloc>
4037f6a5:	0a2d      	mov.n	a2, a10
			if (p)
4037f6a7:	485a16        	beqz	a10, 4037fb30 <tlsf_realloc+0x538>
			{
				const size_t minsize = tlsf_min(cursize, size);
				memcpy(p, ptr, minsize);
4037f6aa:	63c460        	minu	a12, a4, a6
4037f6ad:	03bd      	mov.n	a11, a3
4037f6af:	d38981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037f6b2:	0008e0        	callx8	a8
				tlsf_free(tlsf, ptr);
4037f6b5:	03bd      	mov.n	a11, a3
4037f6b7:	07ad      	mov.n	a10, a7
4037f6b9:	ff12e5        	call8	4037e7e8 <tlsf_free>
4037f6bc:	011c06        	j	4037fb30 <tlsf_realloc+0x538>
4037f6bf:	365700        	lsi	f0, a7, 216
			}
		}
		else
		{
			/* Do we need to expand to the next block? */
			if (adjust > cursize)
4037f6c2:	5b0602        	l8ui	a0, a6, 91
4037f6c5:	ea5600        	utrunc.s	a5, f6, 0
	tlsf_assert(next && "next physical block can't be null");
4037f6c8:	42d100        	xorb	b13, b1, b0
4037f6cb:	43c1d6        	bgez	a1, 4037fb0b <tlsf_realloc+0x513>
4037f6ce:	a2b2d6        	bgez	a2, 4037f0fd <tlsf_memalign_offs+0x155>
4037f6d1:	38a115        	call4	403b80e4 <_coredump_iram_end+0x361e4>
4037f6d4:	67a5d6        	bgez	a5, 4037fd52 <__assert_func+0x2>
4037f6d7:	ee0700        	f64iter	a0, a7, a0, 2, 1
	if (block_is_free(next))
4037f6da:	470602        	l8ui	a0, a6, 71
4037f6dd:	279200        	lsi	f0, a2, 156
	if (size < control->small_block_size)
4037f6e0:	979004        	lsi	f0, a0, 0x25c
4037f6e3:	b89775        	call12	40338058 <rom_rx_gain_force+0x331c2c>
4037f6e6:	27d210        	lsi	f1, a2, 156
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f6e9:	ded004        	lsi	f0, a0, 0x378
4037f6ec:	99d054        	lsi	f5, a0, 0x264
4037f6ef:	8890d2        	l16si	a13, a0, 0x110
4037f6f2:	0d0cd2        	l8ui	a13, a12, 13
		fl = 0;
4037f6f5:	000cc6        	j	4037f72c <tlsf_realloc+0x134>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f6f8:	a88c      	beqz.n	a8, 4037f706 <tlsf_realloc+0x10e>
4037f6fa:	40f8d0        	nsau	a13, a8
4037f6fd:	e0cdd2        	addi	a13, a13, -32
4037f700:	60d0d0        	neg	a13, a13
4037f703:	000086        	j	4037f709 <tlsf_realloc+0x111>
4037f706:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f709:	ffcde2        	addi	a14, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f70c:	042792        	l32i	a9, a7, 16
4037f70f:	25f490        	extui	a15, a9, 20, 3
4037f712:	c0eef0        	sub	a14, a14, a15
4037f715:	400e00        	ssr	a14
4037f718:	918080        	srl	a8, a8
4037f71b:	1e0c      	movi.n	a14, 1
4037f71d:	401f00        	ssl	a15
4037f720:	a1ee00        	sll	a14, a14
4037f723:	3088e0        	xor	a8, a8, a14
		fl -= (control->fl_index_shift - 1);
4037f726:	249590        	extui	a9, a9, 5, 3
4037f729:	c0dd90        	sub	a13, a13, a9
	block_header_t* prev = block->prev_free;
4037f72c:	3a98      	l32i.n	a9, a10, 12
	block_header_t* next = block->next_free;
4037f72e:	2ae8      	l32i.n	a14, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f730:	00e956        	bnez	a9, 4037f742 <tlsf_realloc+0x14a>
4037f733:	d622d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037f736:	d622c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037f739:	74a1b2        	movi	a11, 0x174
4037f73c:	d61ea1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f73f:	006125        	call8	4037fd50 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f742:	0edc      	bnez.n	a14, 4037f756 <tlsf_realloc+0x15e>
4037f744:	d620d1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037f747:	d61ec1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037f74a:	75a1b2        	movi	a11, 0x175
4037f74d:	d619a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f750:	201110        	or	a1, a1, a1
4037f753:	005fe5        	call8	4037fd50 <__assert_func>
	next->prev_free = prev;
4037f756:	3e99      	s32i.n	a9, a14, 12
	prev->next_free = next;
4037f758:	29e9      	s32i.n	a14, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f75a:	87f8      	l32i.n	a15, a7, 32
4037f75c:	4798      	l32i.n	a9, a7, 16
4037f75e:	549e90        	extui	a9, a9, 14, 6
4037f761:	8299d0        	mull	a9, a9, a13
4037f764:	998a      	add.n	a9, a9, a8
4037f766:	a099f0        	addx4	a9, a9, a15
4037f769:	09f8      	l32i.n	a15, a9, 0
4037f76b:	369cf7        	bne	a12, a15, 4037f7a5 <tlsf_realloc+0x1ad>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f76e:	09e9      	s32i.n	a14, a9, 0
		if (next == &control->block_null)
4037f770:	319e77        	bne	a14, a7, 4037f7a5 <tlsf_realloc+0x1ad>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f773:	77c8      	l32i.n	a12, a7, 28
4037f775:	a0cdc0        	addx4	a12, a13, a12
4037f778:	0ce8      	l32i.n	a14, a12, 0
4037f77a:	190c      	movi.n	a9, 1
4037f77c:	401800        	ssl	a8
4037f77f:	a18900        	sll	a8, a9
4037f782:	1088e0        	and	a8, a8, a14
4037f785:	3088e0        	xor	a8, a8, a14
4037f788:	0c89      	s32i.n	a8, a12, 0
			if (!control->sl_bitmap[fl])
4037f78a:	7788      	l32i.n	a8, a7, 28
4037f78c:	a08d80        	addx4	a8, a13, a8
4037f78f:	0888      	l32i.n	a8, a8, 0
4037f791:	08dc      	bnez.n	a8, 4037f7a5 <tlsf_realloc+0x1ad>
				control->fl_bitmap &= ~(1U << fl);
4037f793:	6798      	l32i.n	a9, a7, 24
4037f795:	180c      	movi.n	a8, 1
4037f797:	401d00        	ssl	a13
4037f79a:	a18800        	sll	a8, a8
4037f79d:	108890        	and	a8, a8, a9
4037f7a0:	308890        	xor	a8, a8, a9
4037f7a3:	6789      	s32i.n	a8, a7, 24
4037f7a5:	f8c382        	addi	a8, a3, -8
4037f7a8:	1898      	l32i.n	a9, a8, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037f7aa:	380c      	movi.n	a8, 3
4037f7ac:	0e3897        	bltu	a8, a9, 4037f7be <tlsf_realloc+0x1c6>
4037f7af:	d606d1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037f7b2:	d606c1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027888 <__func__$3>)
4037f7b5:	f5a1b2        	movi	a11, 0x1f5
4037f7b8:	d5ffa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f7bb:	005965        	call8	4037fd50 <__assert_func>
4037f7be:	1ac8      	l32i.n	a12, a10, 4
4037f7c0:	c87c      	movi.n	a8, -4
4037f7c2:	10cc80        	and	a12, a12, a8
	prev->size += block_size(block) + block_header_overhead;
4037f7c5:	cc4b      	addi.n	a12, a12, 4
4037f7c7:	99ca      	add.n	a9, a9, a12
4037f7c9:	f8c3c2        	addi	a12, a3, -8
4037f7cc:	1c99      	s32i.n	a9, a12, 4
4037f7ce:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f7d1:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f7d4:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037f7d6:	3c0c      	movi.n	a12, 3
4037f7d8:	0e3c97        	bltu	a12, a9, 4037f7ea <tlsf_realloc+0x1f2>
4037f7db:	d5f1d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f7de:	d5f1c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f7e1:	a1a0b2        	movi	a11, 161
4037f7e4:	d5f1a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f7e7:	0056a5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037f7ea:	08b9      	s32i.n	a11, a8, 0
	if (block_absorb_post_hook != NULL)
4037f7ec:	d5f981        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037f7ef:	888c      	beqz.n	a8, 4037f7fb <tlsf_realloc+0x203>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037f7f1:	1c0c      	movi.n	a12, 1
4037f7f3:	0b1c      	movi.n	a11, 16
4037f7f5:	d5f681        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037f7f8:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f7fb:	f8c382        	addi	a8, a3, -8
4037f7fe:	1898      	l32i.n	a9, a8, 4
4037f800:	c87c      	movi.n	a8, -4
4037f802:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f805:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f808:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037f80a:	3a0c      	movi.n	a10, 3
4037f80c:	0e3a97        	bltu	a10, a9, 4037f81e <tlsf_realloc+0x226>
4037f80f:	d5e4d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f812:	d5e4c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f815:	a1a0b2        	movi	a11, 161
4037f818:	d5e4a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f81b:	005365        	call8	4037fd50 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037f81e:	1898      	l32i.n	a9, a8, 4
4037f820:	da7c      	movi.n	a10, -3
4037f822:	1099a0        	and	a9, a9, a10
4037f825:	1899      	s32i.n	a9, a8, 4
	block->size &= ~block_header_free_bit;
4037f827:	f8c392        	addi	a9, a3, -8
4037f82a:	1988      	l32i.n	a8, a9, 4
4037f82c:	ea7c      	movi.n	a10, -2
4037f82e:	1088a0        	and	a8, a8, a10
4037f831:	1989      	s32i.n	a8, a9, 4
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f833:	f8c382        	addi	a8, a3, -8
4037f836:	1888      	l32i.n	a8, a8, 4
	tlsf_assert(!block_is_free(block) && "block must be used");
4037f838:	0e6807        	bbci	a8, 0, 4037f84a <tlsf_realloc+0x252>
4037f83b:	d5fed1        	l32r	a13, 40375034 <_iram_text_start+0xc30> (3c023184 <_flash_rodata_start+0x3064>)
4037f83e:	d5fec1        	l32r	a12, 40375038 <_iram_text_start+0xc34> (3c027854 <__func__$0>)
4037f841:	31a2b2        	movi	a11, 0x231
4037f844:	d5dca1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f847:	0050a5        	call8	4037fd50 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f84a:	c97c      	movi.n	a9, -4
4037f84c:	10a890        	and	a10, a8, a9
	return block_size(block) >= sizeof(block_header_t) + size;
4037f84f:	10c582        	addi	a8, a5, 16
	if (block_can_split(block, size))
4037f852:	02ba87        	bgeu	a10, a8, 4037f858 <tlsf_realloc+0x260>
4037f855:	00b546        	j	4037fb2e <tlsf_realloc+0x536>
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f858:	659a      	add.n	a6, a5, a9
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f85a:	636a      	add.n	a6, a3, a6
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f85c:	c08a50        	sub	a8, a10, a5
4037f85f:	889a      	add.n	a8, a8, a9
	return tlsf_cast(void*,
4037f861:	968b      	addi.n	a9, a6, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f863:	b6bb      	addi.n	a11, a6, 11
4037f865:	fcafc2        	movi	a12, -4
4037f868:	10bbc0        	and	a11, a11, a12
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f86b:	0e19b7        	beq	a9, a11, 4037f87d <tlsf_realloc+0x285>
4037f86e:	d5e9d1        	l32r	a13, 40375014 <_iram_text_start+0xc10> (3c022f48 <_flash_rodata_start+0x2e28>)
4037f871:	d5e9c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f874:	c4a1b2        	movi	a11, 0x1c4
4037f877:	d5cfa1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f87a:	004d65        	call8	4037fd50 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f87d:	80b580        	add	a11, a5, a8
4037f880:	04cbb2        	addi	a11, a11, 4
4037f883:	0e1ab7        	beq	a10, a11, 4037f895 <tlsf_realloc+0x29d>
4037f886:	d5e5d1        	l32r	a13, 4037501c <_iram_text_start+0xc18> (3c022fbc <_flash_rodata_start+0x2e9c>)
4037f889:	d5e3c1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f88c:	c7a1b2        	movi	a11, 0x1c7
4037f88f:	d5c9a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f892:	004be5        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037f895:	0126a2        	l32i	a10, a6, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f898:	14a0a0        	extui	a10, a10, 0, 2
4037f89b:	2088a0        	or	a8, a8, a10
4037f89e:	1689      	s32i.n	a8, a6, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f8a0:	ca7c      	movi.n	a10, -4
4037f8a2:	1088a0        	and	a8, a8, a10
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f8a5:	ba0c      	movi.n	a10, 11
4037f8a7:	0e3a87        	bltu	a10, a8, 4037f8b9 <tlsf_realloc+0x2c1>
4037f8aa:	d5ddd1        	l32r	a13, 40375020 <_iram_text_start+0xc1c> (3c022ffc <_flash_rodata_start+0x2edc>)
4037f8ad:	d5dac1        	l32r	a12, 40375018 <_iram_text_start+0xc14> (3c0278cc <__func__$8>)
4037f8b0:	c9a1b2        	movi	a11, 0x1c9
4037f8b3:	d5c0a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f8b6:	0049a5        	call8	4037fd50 <__assert_func>
	const size_t oldsize = block->size;
4037f8b9:	f8c3a2        	addi	a10, a3, -8
4037f8bc:	1a88      	l32i.n	a8, a10, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f8be:	148080        	extui	a8, a8, 0, 2
4037f8c1:	205580        	or	a5, a5, a8
4037f8c4:	1a59      	s32i.n	a5, a10, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f8c6:	16a8      	l32i.n	a10, a6, 4
4037f8c8:	c87c      	movi.n	a8, -4
4037f8ca:	108a80        	and	a8, a10, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f8cd:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f8d0:	898a      	add.n	a8, a9, a8
	tlsf_assert(!block_is_last(block));
4037f8d2:	3b0c      	movi.n	a11, 3
4037f8d4:	0e3ba7        	bltu	a11, a10, 4037f8e6 <tlsf_realloc+0x2ee>
4037f8d7:	d5b2d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f8da:	d5b2c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f8dd:	a1a0b2        	movi	a11, 161
4037f8e0:	d5b2a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f8e3:	0046e5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037f8e6:	0869      	s32i.n	a6, a8, 0
	block->size |= block_header_prev_free_bit;
4037f8e8:	18a8      	l32i.n	a10, a8, 4
4037f8ea:	2b0c      	movi.n	a11, 2
4037f8ec:	20aab0        	or	a10, a10, a11
4037f8ef:	18a9      	s32i.n	a10, a8, 4
	block->size |= block_header_free_bit;
4037f8f1:	1688      	l32i.n	a8, a6, 4
4037f8f3:	1a0c      	movi.n	a10, 1
4037f8f5:	20b8a0        	or	a11, a8, a10
4037f8f8:	16b9      	s32i.n	a11, a6, 4
	block->size &= ~block_header_prev_free_bit;
4037f8fa:	db7c      	movi.n	a11, -3
4037f8fc:	10b8b0        	and	a11, a8, a11
4037f8ff:	20bba0        	or	a11, a11, a10
4037f902:	16b9      	s32i.n	a11, a6, 4
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f904:	ca7c      	movi.n	a10, -4
4037f906:	10a8a0        	and	a10, a8, a10
4037f909:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f90c:	a9aa      	add.n	a10, a9, a10
4037f90e:	0acd      	mov.n	a12, a10
	tlsf_assert(!block_is_last(block));
4037f910:	380c      	movi.n	a8, 3
4037f912:	0e38b7        	bltu	a8, a11, 4037f924 <tlsf_realloc+0x32c>
4037f915:	d5a2d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037f918:	d5a3c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037f91b:	a1a0b2        	movi	a11, 161
4037f91e:	d5a2a1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037f921:	0042e5        	call8	4037fd50 <__assert_func>
	tlsf_assert(next && "next physical block can't be null");
4037f924:	dacc      	bnez.n	a10, 4037f935 <tlsf_realloc+0x33d>
4037f926:	d5abd1        	l32r	a13, 40374fd4 <_iram_text_start+0xbd0> (3c023158 <_flash_rodata_start+0x3038>)
4037f929:	d5abc1        	l32r	a12, 40374fd8 <_iram_text_start+0xbd4> (3c027874 <__func__$2>)
4037f92c:	15a2b2        	movi	a11, 0x215
4037f92f:	d5a1a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f932:	0041e5        	call8	4037fd50 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f935:	1a88      	l32i.n	a8, a10, 4
	if (block_is_free(next))
4037f937:	02e807        	bbsi	a8, 0, 4037f93d <tlsf_realloc+0x345>
4037f93a:	004606        	j	4037fa56 <tlsf_realloc+0x45e>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f93d:	cb7c      	movi.n	a11, -4
4037f93f:	10b8b0        	and	a11, a8, a11
	if (size < control->small_block_size)
4037f942:	4788      	l32i.n	a8, a7, 16
4037f944:	758780        	extui	a8, a8, 23, 8
4037f947:	0fbb87        	bgeu	a11, a8, 4037f95a <tlsf_realloc+0x362>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f94a:	47d8      	l32i.n	a13, a7, 16
4037f94c:	54ded0        	extui	a13, a13, 14, 6
4037f94f:	d288d0        	quos	a8, a8, a13
4037f952:	d2bb80        	quos	a11, a11, a8
		fl = 0;
4037f955:	0e0c      	movi.n	a14, 0
4037f957:	000d06        	j	4037f98f <tlsf_realloc+0x397>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f95a:	bb8c      	beqz.n	a11, 4037f969 <tlsf_realloc+0x371>
4037f95c:	40fbe0        	nsau	a14, a11
4037f95f:	e0cee2        	addi	a14, a14, -32
4037f962:	60e0e0        	neg	a14, a14
4037f965:	0000c6        	j	4037f96c <tlsf_realloc+0x374>
4037f968:	a0e200        	addx4	a14, a2, a0
4037f96b:	ced200        	f64iter	a13, a2, a0, 0, 1
	return bit - 1;
4037f96e:	ff          	.byte	0xff
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f96f:	042782        	l32i	a8, a7, 16
4037f972:	25f480        	extui	a15, a8, 20, 3
4037f975:	c0ddf0        	sub	a13, a13, a15
4037f978:	400d00        	ssr	a13
4037f97b:	91b0b0        	srl	a11, a11
4037f97e:	1d0c      	movi.n	a13, 1
4037f980:	401f00        	ssl	a15
4037f983:	a1dd00        	sll	a13, a13
4037f986:	30bbd0        	xor	a11, a11, a13
		fl -= (control->fl_index_shift - 1);
4037f989:	248580        	extui	a8, a8, 5, 3
4037f98c:	c0ee80        	sub	a14, a14, a8
	block_header_t* prev = block->prev_free;
4037f98f:	3a88      	l32i.n	a8, a10, 12
	block_header_t* next = block->next_free;
4037f991:	2ad8      	l32i.n	a13, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f993:	d8cc      	bnez.n	a8, 4037f9a4 <tlsf_realloc+0x3ac>
4037f995:	d589d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c022dd4 <_flash_rodata_start+0x2cb4>)
4037f998:	d58ac1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037f99b:	74a1b2        	movi	a11, 0x174
4037f99e:	d585a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f9a1:	003ae5        	call8	4037fd50 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f9a4:	ddcc      	bnez.n	a13, 4037f9b5 <tlsf_realloc+0x3bd>
4037f9a6:	d587d1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c022e00 <_flash_rodata_start+0x2ce0>)
4037f9a9:	d585c1        	l32r	a12, 40374fc0 <_iram_text_start+0xbbc> (3c02793c <__func__$14>)
4037f9ac:	75a1b2        	movi	a11, 0x175
4037f9af:	d581a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037f9b2:	0039e5        	call8	4037fd50 <__assert_func>
	next->prev_free = prev;
4037f9b5:	3d89      	s32i.n	a8, a13, 12
	prev->next_free = next;
4037f9b7:	0268d2        	s32i	a13, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f9ba:	87f8      	l32i.n	a15, a7, 32
4037f9bc:	4788      	l32i.n	a8, a7, 16
4037f9be:	548e80        	extui	a8, a8, 14, 6
4037f9c1:	8288e0        	mull	a8, a8, a14
4037f9c4:	88ba      	add.n	a8, a8, a11
4037f9c6:	a088f0        	addx4	a8, a8, a15
4037f9c9:	08f8      	l32i.n	a15, a8, 0
4037f9cb:	379cf7        	bne	a12, a15, 4037fa06 <tlsf_realloc+0x40e>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f9ce:	08d9      	s32i.n	a13, a8, 0
		if (next == &control->block_null)
4037f9d0:	329d77        	bne	a13, a7, 4037fa06 <tlsf_realloc+0x40e>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f9d3:	77c8      	l32i.n	a12, a7, 28
4037f9d5:	11dee0        	slli	a13, a14, 2
4037f9d8:	ccda      	add.n	a12, a12, a13
4037f9da:	0cf8      	l32i.n	a15, a12, 0
4037f9dc:	180c      	movi.n	a8, 1
4037f9de:	401b00        	ssl	a11
4037f9e1:	a18800        	sll	a8, a8
4037f9e4:	1088f0        	and	a8, a8, a15
4037f9e7:	3088f0        	xor	a8, a8, a15
4037f9ea:	0c89      	s32i.n	a8, a12, 0
			if (!control->sl_bitmap[fl])
4037f9ec:	7788      	l32i.n	a8, a7, 28
4037f9ee:	88da      	add.n	a8, a8, a13
4037f9f0:	0888      	l32i.n	a8, a8, 0
4037f9f2:	08dc      	bnez.n	a8, 4037fa06 <tlsf_realloc+0x40e>
				control->fl_bitmap &= ~(1U << fl);
4037f9f4:	67b8      	l32i.n	a11, a7, 24
4037f9f6:	180c      	movi.n	a8, 1
4037f9f8:	401e00        	ssl	a14
4037f9fb:	a18800        	sll	a8, a8
4037f9fe:	1088b0        	and	a8, a8, a11
4037fa01:	3088b0        	xor	a8, a8, a11
4037fa04:	6789      	s32i.n	a8, a7, 24
4037fa06:	1688      	l32i.n	a8, a6, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037fa08:	3b0c      	movi.n	a11, 3
4037fa0a:	0e3b87        	bltu	a11, a8, 4037fa1c <tlsf_realloc+0x424>
4037fa0d:	d56ed1        	l32r	a13, 40374fc8 <_iram_text_start+0xbc4> (3c023120 <_flash_rodata_start+0x3000>)
4037fa10:	d56fc1        	l32r	a12, 40374fcc <_iram_text_start+0xbc8> (3c027888 <__func__$3>)
4037fa13:	f5a1b2        	movi	a11, 0x1f5
4037fa16:	d567a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037fa19:	003365        	call8	4037fd50 <__assert_func>
4037fa1c:	1ac8      	l32i.n	a12, a10, 4
4037fa1e:	cb7c      	movi.n	a11, -4
4037fa20:	10ccb0        	and	a12, a12, a11
	prev->size += block_size(block) + block_header_overhead;
4037fa23:	cc4b      	addi.n	a12, a12, 4
4037fa25:	88ca      	add.n	a8, a8, a12
4037fa27:	1689      	s32i.n	a8, a6, 4
4037fa29:	10b8b0        	and	a11, a8, a11
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037fa2c:	fccbb2        	addi	a11, a11, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037fa2f:	99ba      	add.n	a9, a9, a11
	tlsf_assert(!block_is_last(block));
4037fa31:	3b0c      	movi.n	a11, 3
4037fa33:	0e3b87        	bltu	a11, a8, 4037fa45 <tlsf_realloc+0x44d>
4037fa36:	d55ad1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c022b50 <_flash_rodata_start+0x2a30>)
4037fa39:	d55ac1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c02797c <__func__$20>)
4037fa3c:	a1a0b2        	movi	a11, 161
4037fa3f:	d55aa1        	l32r	a10, 40374fa8 <_iram_text_start+0xba4> (3c022b83 <_flash_rodata_start+0x2a63>)
4037fa42:	0030e5        	call8	4037fd50 <__assert_func>
	next->prev_phys_block = block;
4037fa45:	0969      	s32i.n	a6, a9, 0
	if (block_absorb_post_hook != NULL)
4037fa47:	d56281        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037fa4a:	888c      	beqz.n	a8, 4037fa56 <tlsf_realloc+0x45e>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037fa4c:	1c0c      	movi.n	a12, 1
4037fa4e:	0b1c      	movi.n	a11, 16
4037fa50:	d56081        	l32r	a8, 40374fd0 <_iram_text_start+0xbcc> (0 <IDF_TARGET_ESP32S3>)
4037fa53:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037fa56:	1688      	l32i.n	a8, a6, 4
4037fa58:	c97c      	movi.n	a9, -4
4037fa5a:	108890        	and	a8, a8, a9
	if (size < control->small_block_size)
4037fa5d:	4798      	l32i.n	a9, a7, 16
4037fa5f:	759790        	extui	a9, a9, 23, 8
4037fa62:	0fb897        	bgeu	a8, a9, 4037fa75 <tlsf_realloc+0x47d>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037fa65:	47a8      	l32i.n	a10, a7, 16
4037fa67:	54aea0        	extui	a10, a10, 14, 6
4037fa6a:	d299a0        	quos	a9, a9, a10
4037fa6d:	d28890        	quos	a8, a8, a9
		fl = 0;
4037fa70:	0a0c      	movi.n	a10, 0
4037fa72:	000d06        	j	4037faaa <tlsf_realloc+0x4b2>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037fa75:	b88c      	beqz.n	a8, 4037fa84 <tlsf_realloc+0x48c>
4037fa77:	40f8a0        	nsau	a10, a8
4037fa7a:	e0caa2        	addi	a10, a10, -32
4037fa7d:	60a0a0        	neg	a10, a10
4037fa80:	0000c6        	j	4037fa87 <tlsf_realloc+0x48f>
4037fa83:	a0a200        	addx4	a10, a2, a0
4037fa86:	cab200        	float.s	f11, a2, 0
	return bit - 1;
4037fa89:	ff          	.byte	0xff
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037fa8a:	042792        	l32i	a9, a7, 16
4037fa8d:	25c490        	extui	a12, a9, 20, 3
4037fa90:	c0bbc0        	sub	a11, a11, a12
4037fa93:	400b00        	ssr	a11
4037fa96:	918080        	srl	a8, a8
4037fa99:	1b0c      	movi.n	a11, 1
4037fa9b:	401c00        	ssl	a12
4037fa9e:	a1bb00        	sll	a11, a11
4037faa1:	3088b0        	xor	a8, a8, a11
		fl -= (control->fl_index_shift - 1);
4037faa4:	249590        	extui	a9, a9, 5, 3
4037faa7:	c0aa90        	sub	a10, a10, a9
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037faaa:	87b8      	l32i.n	a11, a7, 32
4037faac:	4798      	l32i.n	a9, a7, 16
4037faae:	549e90        	extui	a9, a9, 14, 6
4037fab1:	8299a0        	mull	a9, a9, a10
4037fab4:	998a      	add.n	a9, a9, a8
4037fab6:	a099b0        	addx4	a9, a9, a11
4037fab9:	0998      	l32i.n	a9, a9, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037fabb:	d9cc      	bnez.n	a9, 4037facc <tlsf_realloc+0x4d4>
4037fabd:	d547d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c022c10 <_flash_rodata_start+0x2af0>)
4037fac0:	d548c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037fac3:	90a1b2        	movi	a11, 0x190
4037fac6:	d53ba1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037fac9:	002865        	call8	4037fd50 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037facc:	d6cc      	bnez.n	a6, 4037fadd <tlsf_realloc+0x4e5>
4037face:	d545d1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c022c74 <_flash_rodata_start+0x2b54>)
4037fad1:	d543c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02795c <__func__$17>)
4037fad4:	91a1b2        	movi	a11, 0x191
4037fad7:	d537a1        	l32r	a10, 40374fb4 <_iram_text_start+0xbb0> (3c022c5b <_flash_rodata_start+0x2b3b>)
4037fada:	002765        	call8	4037fd50 <__assert_func>
	block->next_free = current;
4037fadd:	2699      	s32i.n	a9, a6, 8
	block->prev_free = &control->block_null;
4037fadf:	3679      	s32i.n	a7, a6, 12
	current->prev_free = block;
4037fae1:	3969      	s32i.n	a6, a9, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037fae3:	87b8      	l32i.n	a11, a7, 32
4037fae5:	4798      	l32i.n	a9, a7, 16
4037fae7:	549e90        	extui	a9, a9, 14, 6
4037faea:	829a90        	mull	a9, a10, a9
4037faed:	989a      	add.n	a9, a8, a9
4037faef:	a099b0        	addx4	a9, a9, a11
4037faf2:	0969      	s32i.n	a6, a9, 0
	control->fl_bitmap |= (1U << fl);
4037faf4:	67b8      	l32i.n	a11, a7, 24
4037faf6:	190c      	movi.n	a9, 1
4037faf8:	401a00        	ssl	a10
4037fafb:	a1c900        	sll	a12, a9
4037fafe:	20bbc0        	or	a11, a11, a12
4037fb01:	67b9      	s32i.n	a11, a7, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037fb03:	77b8      	l32i.n	a11, a7, 28
4037fb05:	a0aab0        	addx4	a10, a10, a11
4037fb08:	0ab8      	l32i.n	a11, a10, 0
4037fb0a:	401800        	ssl	a8
4037fb0d:	a19900        	sll	a9, a9
4037fb10:	208b90        	or	a8, a11, a9
4037fb13:	0a89      	s32i.n	a8, a10, 0
				block_mark_as_used(block);
			}

			/* Trim the resulting block and return the original pointer. */
			block_trim_used(control, block, adjust);
			p = ptr;
4037fb15:	032d      	mov.n	a2, a3
}
4037fb17:	000546        	j	4037fb30 <tlsf_realloc+0x538>
4037fb1a:	000000        	ill
			return p;
4037fb1d:	020c      	movi.n	a2, 0
4037fb1f:	000346        	j	4037fb30 <tlsf_realloc+0x538>
4037fb22:	060000        	lsi	f0, a0, 24
4037fb25:	000002        	l8ui	a0, a0, 0
4037fb28:	020c      	movi.n	a2, 0
4037fb2a:	000086        	j	4037fb30 <tlsf_realloc+0x538>
4037fb2d:	032d00        	lsi	f0, a13, 12
		}
	}

	return p;
}
4037fb30:	f01d      	retw.n
	...

4037fb34 <tlsf_size>:
{
4037fb34:	004136        	entry	a1, 32
	if (tlsf == NULL)
4037fb37:	328c      	beqz.n	a2, 4037fb3e <tlsf_size+0xa>
	return control->size;
4037fb39:	5228      	l32i.n	a2, a2, 20
4037fb3b:	000046        	j	4037fb40 <tlsf_size+0xc>
		return 0;
4037fb3e:	020c      	movi.n	a2, 0
}
4037fb40:	f01d      	retw.n
	...

4037fb44 <esp_log_impl_lock>:
#define MAX_MUTEX_WAIT_TICKS ((MAX_MUTEX_WAIT_MS + portTICK_PERIOD_MS - 1) / portTICK_PERIOD_MS)

static SemaphoreHandle_t s_log_mutex = NULL;

void esp_log_impl_lock(void)
{
4037fb44:	004136        	entry	a1, 32
    if (unlikely(!s_log_mutex)) {
4037fb47:	d53d81        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94aac <s_log_mutex>)
4037fb4a:	0888      	l32i.n	a8, a8, 0
4037fb4c:	98cc      	bnez.n	a8, 4037fb59 <esp_log_impl_lock+0x15>
        s_log_mutex = xSemaphoreCreateMutex();
4037fb4e:	01a0a2        	movi	a10, 1
4037fb51:	fa0fe5        	call8	40379c50 <xQueueCreateMutex>
4037fb54:	d53a81        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94aac <s_log_mutex>)
4037fb57:	08a9      	s32i.n	a10, a8, 0
    }
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fb59:	fbed25        	call8	4037ba2c <xTaskGetSchedulerState>
4037fb5c:	091a26        	beqi	a10, 1, 4037fb69 <esp_log_impl_lock+0x25>
        return;
    }
    xSemaphoreTake(s_log_mutex, portMAX_DELAY);
4037fb5f:	fb7c      	movi.n	a11, -1
4037fb61:	d53681        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94aac <s_log_mutex>)
4037fb64:	08a8      	l32i.n	a10, a8, 0
4037fb66:	fa21a5        	call8	40379d80 <xQueueSemaphoreTake>
}
4037fb69:	f01d      	retw.n
	...

4037fb6c <esp_log_impl_lock_timeout>:

bool esp_log_impl_lock_timeout(void)
{
4037fb6c:	004136        	entry	a1, 32
    if (unlikely(!s_log_mutex)) {
4037fb6f:	d53381        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94aac <s_log_mutex>)
4037fb72:	0888      	l32i.n	a8, a8, 0
4037fb74:	98cc      	bnez.n	a8, 4037fb81 <esp_log_impl_lock_timeout+0x15>
        s_log_mutex = xSemaphoreCreateMutex();
4037fb76:	01a0a2        	movi	a10, 1
4037fb79:	fa0d65        	call8	40379c50 <xQueueCreateMutex>
4037fb7c:	d53081        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94aac <s_log_mutex>)
4037fb7f:	08a9      	s32i.n	a10, a8, 0
    }
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fb81:	fbeaa5        	call8	4037ba2c <xTaskGetSchedulerState>
4037fb84:	181a26        	beqi	a10, 1, 4037fba0 <esp_log_impl_lock_timeout+0x34>
        return true;
    }
    return xSemaphoreTake(s_log_mutex, MAX_MUTEX_WAIT_TICKS) == pdTRUE;
4037fb87:	01a0b2        	movi	a11, 1
4037fb8a:	d52c81        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94aac <s_log_mutex>)
4037fb8d:	0028a2        	l32i	a10, a8, 0
4037fb90:	fa1ee5        	call8	40379d80 <xQueueSemaphoreTake>
4037fb93:	ffca22        	addi	a2, a10, -1
4037fb96:	40f220        	nsau	a2, a2
4037fb99:	412520        	srli	a2, a2, 5
4037fb9c:	000086        	j	4037fba2 <esp_log_impl_lock_timeout+0x36>
4037fb9f:	120c00        	andbc	b0, b12, b0
}
4037fba2:	f01d      	retw.n

4037fba4 <esp_log_impl_unlock>:

void esp_log_impl_unlock(void)
{
4037fba4:	004136        	entry	a1, 32
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fba7:	fbe865        	call8	4037ba2c <xTaskGetSchedulerState>
4037fbaa:	0f1a26        	beqi	a10, 1, 4037fbbd <esp_log_impl_unlock+0x19>
        return;
    }
    xSemaphoreGive(s_log_mutex);
4037fbad:	00a0d2        	movi	a13, 0
4037fbb0:	20cdd0        	or	a12, a13, a13
4037fbb3:	0dbd      	mov.n	a11, a13
4037fbb5:	d52181        	l32r	a8, 4037503c <_iram_text_start+0xc38> (3fc94aac <s_log_mutex>)
4037fbb8:	08a8      	l32i.n	a10, a8, 0
4037fbba:	f9f1e5        	call8	40379ad8 <xQueueGenericSend>
}
4037fbbd:	f01d      	retw.n
	...

4037fbc0 <esp_log_early_timestamp>:
    return base + tick_count * (1000 / configTICK_RATE_HZ);
}

/* FIXME: define an API for getting the timestamp in soc/hal IDF-2351 */
uint32_t esp_log_early_timestamp(void)
{
4037fbc0:	004136        	entry	a1, 32
    RSR(CCOUNT, ccount);
4037fbc3:	03ea20        	rsr.ccount	a2
#if CONFIG_IDF_TARGET_ESP32
    /* ESP32 ROM stores separate clock rate values for each CPU, but we want the PRO CPU value always */
    extern uint32_t g_ticks_per_us_pro;
    return esp_cpu_get_cycle_count() / (g_ticks_per_us_pro * 1000);
#else
    return esp_cpu_get_cycle_count() / (esp_rom_get_cpu_ticks_per_us() * 1000);
4037fbc6:	d2c381        	l32r	a8, 403746d4 <_iram_text_start+0x2d0> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
4037fbc9:	0008e0        	callx8	a8
4037fbcc:	118ab0        	slli	a8, a10, 5
4037fbcf:	c088a0        	sub	a8, a8, a10
4037fbd2:	a088a0        	addx4	a8, a8, a10
4037fbd5:	1188d0        	slli	a8, a8, 3
#endif
}
4037fbd8:	c22280        	quou	a2, a2, a8
4037fbdb:	f01d      	retw.n
4037fbdd:	000000        	ill

4037fbe0 <esp_log_timestamp>:
{
4037fbe0:	004136        	entry	a1, 32
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fbe3:	fbe4a5        	call8	4037ba2c <xTaskGetSchedulerState>
4037fbe6:	0a1a66        	bnei	a10, 1, 4037fbf4 <esp_log_timestamp+0x14>
        return esp_log_early_timestamp();
4037fbe9:	fffd65        	call8	4037fbc0 <esp_log_early_timestamp>
4037fbec:	0a2d      	mov.n	a2, a10
4037fbee:	000d06        	j	4037fc26 <esp_log_timestamp+0x46>
4037fbf1:	000000        	ill
    if (base == 0 && xPortGetCoreID() == 0) {
4037fbf4:	d51381        	l32r	a8, 40375040 <_iram_text_start+0xc3c> (3fc949a0 <base$0>)
4037fbf7:	002882        	l32i	a8, a8, 0
4037fbfa:	e8cc      	bnez.n	a8, 4037fc0c <esp_log_timestamp+0x2c>
    asm volatile (
4037fbfc:	03eb80        	rsr.prid	a8
4037fbff:	048d80        	extui	a8, a8, 13, 1
4037fc02:	68cc      	bnez.n	a8, 4037fc0c <esp_log_timestamp+0x2c>
        base = esp_log_early_timestamp();
4037fc04:	fffba5        	call8	4037fbc0 <esp_log_early_timestamp>
4037fc07:	d50e81        	l32r	a8, 40375040 <_iram_text_start+0xc3c> (3fc949a0 <base$0>)
4037fc0a:	08a9      	s32i.n	a10, a8, 0
    TickType_t tick_count = xPortInIsrContext() ? xTaskGetTickCountFromISR() : xTaskGetTickCount();
4037fc0c:	fa4fe5        	call8	4037a10c <xPortInIsrContext>
4037fc0f:	5a8c      	beqz.n	a10, 4037fc18 <esp_log_timestamp+0x38>
4037fc11:	fb5d65        	call8	4037b1e8 <xTaskGetTickCountFromISR>
4037fc14:	0000c6        	j	4037fc1b <esp_log_timestamp+0x3b>
4037fc17:	5be500        	ult.s	b14, f5, f0
4037fc1a:	a0fb      	addi.n	a10, a0, 15
    return base + tick_count * (1000 / configTICK_RATE_HZ);
4037fc1c:	a0aa      	add.n	a10, a0, a10
4037fc1e:	d50881        	l32r	a8, 40375040 <_iram_text_start+0xc3c> (3fc949a0 <base$0>)
4037fc21:	0888      	l32i.n	a8, a8, 0
4037fc23:	902a80        	addx2	a2, a10, a8
}
4037fc26:	f01d      	retw.n

4037fc28 <esp_log_write>:
}

void esp_log_write(esp_log_level_t level,
                   const char *tag,
                   const char *format, ...)
{
4037fc28:	00a136        	entry	a1, 80
    va_list list;
    va_start(list, format);
4037fc2b:	7159      	s32i.n	a5, a1, 28
4037fc2d:	8169      	s32i.n	a6, a1, 32
4037fc2f:	9179      	s32i.n	a7, a1, 36
{
4037fc31:	02ad      	mov.n	a10, a2
4037fc33:	03bd      	mov.n	a11, a3
4037fc35:	04cd      	mov.n	a12, a4
    va_start(list, format);
4037fc37:	10c1e2        	addi	a14, a1, 16
4037fc3a:	11e9      	s32i.n	a14, a1, 4
4037fc3c:	30c1d2        	addi	a13, a1, 48
4037fc3f:	01d9      	s32i.n	a13, a1, 0
4037fc41:	cf0c      	movi.n	a15, 12
4037fc43:	21f9      	s32i.n	a15, a1, 8
    esp_log_writev(level, tag, format, list);
4037fc45:	000065        	call8	4037fc4c <esp_log_writev>
    va_end(list);
}
4037fc48:	f01d      	retw.n
	...

4037fc4c <esp_log_writev>:
{
4037fc4c:	006136        	entry	a1, 48
4037fc4f:	20a330        	or	a10, a3, a3
4037fc52:	006152        	s32i	a5, a1, 0
4037fc55:	016162        	s32i	a6, a1, 4
4037fc58:	2179      	s32i.n	a7, a1, 8
    esp_log_level_t level_for_tag = esp_log_level_get_timeout(tag);
4037fc5a:	000265        	call8	4037fc80 <esp_log_level_get_timeout>
    if (ESP_LOG_NONE != level_for_tag && level <= level_for_tag) {
4037fc5d:	180c      	movi.n	a8, 1
4037fc5f:	838aa0        	moveqz	a8, a10, a10
4037fc62:	622a20        	lsi	f2, a10, 0x188
4037fc65:	220b      	addi.n	a2, a2, -1
4037fc67:	602020        	neg	a2, a2
4037fc6a:	0f0287        	bnone	a2, a8, 4037fc7d <esp_log_writev+0x31>
        (*s_log_print_func)(format, args);
4037fc6d:	d4f581        	l32r	a8, 40375044 <_iram_text_start+0xc40> (3fc91f38 <s_log_print_func>)
4037fc70:	0888      	l32i.n	a8, a8, 0
4037fc72:	01b8      	l32i.n	a11, a1, 0
4037fc74:	11c8      	l32i.n	a12, a1, 4
4037fc76:	21d8      	l32i.n	a13, a1, 8
4037fc78:	04ad      	mov.n	a10, a4
4037fc7a:	0008e0        	callx8	a8
}
4037fc7d:	f01d      	retw.n
	...

4037fc80 <esp_log_level_get_timeout>:
    log_level_set(tag, level);
#endif
}

esp_log_level_t esp_log_level_get_timeout(const char *tag)
{
4037fc80:	004136        	entry	a1, 32
4037fc83:	02ad      	mov.n	a10, a2
#if CONFIG_LOG_TAG_LEVEL_IMPL_NONE
    (void)tag;
    return esp_log_get_default_level();
#else
    return log_level_get(tag, true);
4037fc85:	1b0c      	movi.n	a11, 1
4037fc87:	d4f081        	l32r	a8, 40375048 <_iram_text_start+0xc44> (42016194 <log_level_get>)
4037fc8a:	0008e0        	callx8	a8
#endif
}
4037fc8d:	0a2d      	mov.n	a2, a10
4037fc8f:	f01d      	retw.n
4037fc91:	000000        	ill

4037fc94 <abort>:
#include "esp_cpu.h"

#include "soc/soc_caps.h"

void __attribute__((noreturn)) abort(void)
{
4037fc94:	00e136        	entry	a1, 112
#define ERR_STR2  " on core "

    _Static_assert(UINTPTR_MAX == 0xffffffff, "abort() assumes 32-bit addresses");
    _Static_assert(SOC_CPU_CORES_NUM < 10, "abort() assumes number of cores is 1 to 9");

    char addr_buf[9] = { 0 };
4037fc97:	9c0c      	movi.n	a12, 9
4037fc99:	00a0b2        	movi	a11, 0
4037fc9c:	01ad      	mov.n	a10, a1
4037fc9e:	d1fc81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fca1:	0008e0        	callx8	a8
    char core_buf[2] = { 0 };
4037fca4:	719b      	addi.n	a7, a1, 9
4037fca6:	2c0c      	movi.n	a12, 2
4037fca8:	00a0b2        	movi	a11, 0
4037fcab:	20a770        	or	a10, a7, a7
4037fcae:	d1f881        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fcb1:	0008e0        	callx8	a8

    char buf[sizeof(ERR_STR1) + sizeof(addr_buf) + sizeof(core_buf) + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037fcb4:	2c3c      	movi.n	a12, 50
4037fcb6:	0b0c      	movi.n	a11, 0
4037fcb8:	0bc1a2        	addi	a10, a1, 11
4037fcbb:	d1f581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fcbe:	0008e0        	callx8	a8

    itoa((uint32_t)(__builtin_return_address(0) - 3), addr_buf, 16);
4037fcc1:	d4e281        	l32r	a8, 4037504c <_iram_text_start+0xc48> (4037fcc1 <abort+0x2d>)
4037fcc4:	158e80        	extui	a8, a8, 30, 2
4037fcc7:	018820        	slli	a8, a8, 30
4037fcca:	11a0e0        	slli	a10, a0, 2
4037fccd:	41a2a0        	srli	a10, a10, 2
4037fcd0:	20aa80        	or	a10, a10, a8
4037fcd3:	0c1c      	movi.n	a12, 16
4037fcd5:	01bd      	mov.n	a11, a1
4037fcd7:	fdcaa2        	addi	a10, a10, -3
4037fcda:	d4df81        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fcdd:	0008e0        	callx8	a8
4037fce0:	03eba0        	rsr.prid	a10
4037fce3:	04ada0        	extui	a10, a10, 13, 1
    itoa(esp_cpu_get_core_id(), core_buf, 10);
4037fce6:	ac0c      	movi.n	a12, 10
4037fce8:	07bd      	mov.n	a11, a7
4037fcea:	d4db81        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fced:	0008e0        	callx8	a8

    const char *str[] = { ERR_STR1, addr_buf, ERR_STR2, core_buf };
4037fcf0:	d4d881        	l32r	a8, 40375050 <_iram_text_start+0xc4c> (3fc93a18 <__FUNCTION__$0+0x280>)
4037fcf3:	106182        	s32i	a8, a1, 64
4037fcf6:	116112        	s32i	a1, a1, 68
4037fcf9:	d4d681        	l32r	a8, 40375054 <_iram_text_start+0xc50> (3fc93a34 <__FUNCTION__$0+0x29c>)
4037fcfc:	126182        	s32i	a8, a1, 72
4037fcff:	136172        	s32i	a7, a1, 76

    char *dest = buf;

    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fd02:	070c      	movi.n	a7, 0
4037fd04:	000406        	j	4037fd18 <abort+0x84>
4037fd07:	871000        	lsi	f0, a0, 0x21c
        strcat(dest, str[i]);
4037fd0a:	28b2a0        	lsi	f10, a2, 160
4037fd0d:	a1bb10        	lsi	f1, a11, 0x284
4037fd10:	d3ca81        	l32r	a8, 40374c38 <_iram_text_start+0x834> (40001374 <strcat>)
4037fd13:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fd16:	771b      	addi.n	a7, a7, 1
4037fd18:	ec47b6        	bltui	a7, 4, 4037fd08 <abort+0x74>
    }

    esp_system_abort(buf);
4037fd1b:	a1bb      	addi.n	a10, a1, 11
4037fd1d:	f9a6e5        	call8	4037978c <esp_system_abort>

4037fd20 <ra_to_str>:
#elif __riscv
#define INST_LEN         4
#endif

static inline void ra_to_str(char *addr)
{
4037fd20:	004136        	entry	a1, 32
    addr[0] = '0';
4037fd23:	083c      	movi.n	a8, 48
4037fd25:	004282        	s8i	a8, a2, 0
    addr[1] = 'x';
4037fd28:	78a082        	movi	a8, 120
4037fd2b:	014282        	s8i	a8, a2, 1
    itoa((uint32_t)(__builtin_return_address(0) - INST_LEN), addr + 2, 16);
4037fd2e:	d4cb81        	l32r	a8, 4037505c <_iram_text_start+0xc58> (4037fd2e <ra_to_str+0xe>)
4037fd31:	158e80        	extui	a8, a8, 30, 2
4037fd34:	018820        	slli	a8, a8, 30
4037fd37:	11a0e0        	slli	a10, a0, 2
4037fd3a:	41a2a0        	srli	a10, a10, 2
4037fd3d:	20aa80        	or	a10, a10, a8
4037fd40:	0c1c      	movi.n	a12, 16
4037fd42:	b22b      	addi.n	a11, a2, 2
4037fd44:	fdcaa2        	addi	a10, a10, -3
4037fd47:	d4c481        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fd4a:	0008e0        	callx8	a8
}
4037fd4d:	f01d      	retw.n
	...

4037fd50 <__assert_func>:

/* Overriding assert function so that whenever assert is called from critical section,
 * it does not lead to a crash of its own.
 */
void __attribute__((noreturn)) __assert_func(const char *file, int line, const char *func, const char *expr)
{
4037fd50:	024136        	entry	a1, 0x120

    ra_to_str(&buff[sizeof(ASSERT_STR) - 1]);

    esp_system_abort(buff);
#else
    char addr[11] = { 0 };
4037fd53:	bc0c      	movi.n	a12, 11
4037fd55:	0b0c      	movi.n	a11, 0
4037fd57:	01ad      	mov.n	a10, a1
4037fd59:	d1cd81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037fd5c:	0008e0        	callx8	a8
    char buff[200];
    char lbuf[5];
    uint32_t rem_len = sizeof(buff) - 1;
    uint32_t off = 0;

    itoa(line, lbuf, 10);
4037fd5f:	ac0c      	movi.n	a12, 10
4037fd61:	d3a0b2        	movi	a11, 211
4037fd64:	b1ba      	add.n	a11, a1, a11
4037fd66:	03ad      	mov.n	a10, a3
4037fd68:	d4bc81        	l32r	a8, 40375058 <_iram_text_start+0xc54> (400014c4 <itoa>)
4037fd6b:	0008e0        	callx8	a8

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    if (!spi_flash_cache_enabled())
4037fd6e:	f7cee5        	call8	40377a5c <spi_flash_cache_enabled>
4037fd71:	048a56        	bnez	a10, 4037fdbd <__assert_func+0x6d>
    return ((intptr_t)p >= drom_start_addr && (intptr_t)p < SOC_DROM_HIGH);
4037fd74:	d2a991        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fd77:	729920        	lsi	f2, a9, 0x1c8
4037fd7a:	d2a881        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd608b>)
4037fd7d:	728820        	lsi	f2, a8, 0x1c8
4037fd80:	880b      	addi.n	a8, a8, -1
4037fd82:	608080        	neg	a8, a8
#endif
    {
        if (esp_ptr_in_drom(file)) {
4037fd85:	020897        	bnone	a8, a9, 4037fd8b <__assert_func+0x3b>
            file = CACHE_DISABLED_STR;
4037fd88:	d4b621        	l32r	a2, 40375060 <_iram_text_start+0xc5c> (3fc93a40 <__FUNCTION__$0+0x2a8>)
4037fd8b:	d2a391        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fd8e:	729940        	lsi	f4, a9, 0x1c8
4037fd91:	d2a281        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd608b>)
4037fd94:	728840        	lsi	f4, a8, 0x1c8
4037fd97:	880b      	addi.n	a8, a8, -1
4037fd99:	608080        	neg	a8, a8
        }

        if (esp_ptr_in_drom(func)) {
4037fd9c:	060897        	bnone	a8, a9, 4037fda6 <__assert_func+0x56>
            ra_to_str(addr);
4037fd9f:	01ad      	mov.n	a10, a1
4037fda1:	fff7e5        	call8	4037fd20 <ra_to_str>
            func = addr;
4037fda4:	014d      	mov.n	a4, a1
4037fda6:	d29c91        	l32r	a9, 40374818 <_iram_text_start+0x414> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fda9:	729950        	lsi	f5, a9, 0x1c8
4037fdac:	d29c81        	l32r	a8, 4037481c <_iram_text_start+0x418> (3dffffff <_esp_system_init_fn_array_end+0x1fd608b>)
4037fdaf:	728850        	lsi	f5, a8, 0x1c8
4037fdb2:	880b      	addi.n	a8, a8, -1
4037fdb4:	608080        	neg	a8, a8
        }

        if (esp_ptr_in_drom(expr)) {
4037fdb7:	020897        	bnone	a8, a9, 4037fdbd <__assert_func+0x6d>
            expr = CACHE_DISABLED_STR;
4037fdba:	d4a951        	l32r	a5, 40375060 <_iram_text_start+0xc5c> (3fc93a40 <__FUNCTION__$0+0x2a8>)
        }
    }

    const char *str[] = {ASSERT_STR, func ? func : "\b", " ", file, ":", lbuf, " (", expr, ")"};
4037fdbd:	d4aa81        	l32r	a8, 40375068 <_iram_text_start+0xc64> (3fc93a58 <__FUNCTION__$0+0x2c0>)
4037fdc0:	366182        	s32i	a8, a1, 216
4037fdc3:	14cc      	bnez.n	a4, 4037fdc8 <__assert_func+0x78>
4037fdc5:	d4a741        	l32r	a4, 40375064 <_iram_text_start+0xc60> (3fc93a54 <__FUNCTION__$0+0x2bc>)
4037fdc8:	d8a082        	movi	a8, 216
4037fdcb:	818a      	add.n	a8, a1, a8
4037fdcd:	1849      	s32i.n	a4, a8, 4
4037fdcf:	d4a791        	l32r	a9, 4037506c <_iram_text_start+0xc68> (3fc93a68 <__FUNCTION__$0+0x2d0>)
4037fdd2:	2899      	s32i.n	a9, a8, 8
4037fdd4:	3829      	s32i.n	a2, a8, 12
4037fdd6:	d4a691        	l32r	a9, 40375070 <_iram_text_start+0xc6c> (3fc93a6c <__FUNCTION__$0+0x2d4>)
4037fdd9:	4899      	s32i.n	a9, a8, 16
4037fddb:	d3a092        	movi	a9, 211
4037fdde:	919a      	add.n	a9, a1, a9
4037fde0:	5899      	s32i.n	a9, a8, 20
4037fde2:	d4a491        	l32r	a9, 40375074 <_iram_text_start+0xc70> (3fc93a70 <__FUNCTION__$0+0x2d8>)
4037fde5:	6899      	s32i.n	a9, a8, 24
4037fde7:	7859      	s32i.n	a5, a8, 28
4037fde9:	d4a391        	l32r	a9, 40375078 <_iram_text_start+0xc74> (3fc93eb8 <__FUNCTION__$0+0x720>)
4037fdec:	8899      	s32i.n	a9, a8, 32

    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fdee:	060c      	movi.n	a6, 0
    uint32_t off = 0;
4037fdf0:	064d      	mov.n	a4, a6
    uint32_t rem_len = sizeof(buff) - 1;
4037fdf2:	c7a052        	movi	a5, 199
    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fdf5:	000b46        	j	4037fe26 <__assert_func+0xd6>
        uint32_t len = strlen(str[i]);
4037fdf8:	d8a082        	movi	a8, 216
4037fdfb:	818a      	add.n	a8, a1, a8
4037fdfd:	a08680        	addx4	a8, a6, a8
4037fe00:	0838      	l32i.n	a3, a8, 0
4037fe02:	20a330        	or	a10, a3, a3
4037fe05:	d49d81        	l32r	a8, 4037507c <_iram_text_start+0xc78> (40001248 <strlen>)
4037fe08:	0008e0        	callx8	a8
        uint32_t cpy_len = MIN(len, rem_len);
4037fe0b:	6375a0        	minu	a7, a5, a10
        memcpy(buff + off, str[i], cpy_len);
4037fe0e:	07cd      	mov.n	a12, a7
4037fe10:	03bd      	mov.n	a11, a3
4037fe12:	a1bb      	addi.n	a10, a1, 11
4037fe14:	aa4a      	add.n	a10, a10, a4
4037fe16:	d1af81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
4037fe19:	0008e0        	callx8	a8
        rem_len -= cpy_len;
4037fe1c:	c05570        	sub	a5, a5, a7
        off += cpy_len;
4037fe1f:	447a      	add.n	a4, a4, a7
        if (rem_len == 0) {
4037fe21:	758c      	beqz.n	a5, 4037fe2c <__assert_func+0xdc>
    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fe23:	01c662        	addi	a6, a6, 1
4037fe26:	08a082        	movi	a8, 8
4037fe29:	cbb867        	bgeu	a8, a6, 4037fdf8 <__assert_func+0xa8>
            break;
        }
    }
    buff[off] = '\0';
4037fe2c:	a1bb      	addi.n	a10, a1, 11
4037fe2e:	4a4a      	add.n	a4, a10, a4
4037fe30:	080c      	movi.n	a8, 0
4037fe32:	004482        	s8i	a8, a4, 0
    esp_system_abort(buff);
4037fe35:	f99565        	call8	4037978c <esp_system_abort>

4037fe38 <esp_libc_include_assert_impl>:
    __assert_func(file, line, NULL, failedexpr);
}

/* No-op function, used to force linker to include these changes */
void esp_libc_include_assert_impl(void)
{
4037fe38:	004136        	entry	a1, 32
}
4037fe3b:	f01d      	retw.n
4037fe3d:	000000        	ill

4037fe40 <malloc>:
extern void *heap_caps_malloc_default(size_t size);
extern void *heap_caps_realloc_default(void *ptr, size_t size);
extern void *heap_caps_aligned_alloc_default(size_t alignment, size_t size);

void* malloc(size_t size)
{
4037fe40:	004136        	entry	a1, 32
4037fe43:	02ad      	mov.n	a10, a2
    return heap_caps_malloc_default(size);
4037fe45:	f611e5        	call8	40375f64 <heap_caps_malloc_default>
}
4037fe48:	0a2d      	mov.n	a2, a10
4037fe4a:	f01d      	retw.n

4037fe4c <cfree>:
{
    return heap_caps_realloc_default(ptr, size);
}

void free(void *ptr)
{
4037fe4c:	004136        	entry	a1, 32
4037fe4f:	02ad      	mov.n	a10, a2
    heap_caps_free(ptr);
4037fe51:	f63265        	call8	40376178 <heap_caps_free>
}
4037fe54:	f01d      	retw.n
	...

4037fe58 <calloc>:

ESP_COMPILER_DIAGNOSTIC_PUSH_IGNORE("-Wanalyzer-malloc-leak")
void* calloc(size_t nmemb, size_t size)
{
4037fe58:	004136        	entry	a1, 32
    void *result;
    size_t size_bytes;
    if (__builtin_mul_overflow(nmemb, size, &size_bytes)) {
4037fe5b:	080c      	movi.n	a8, 0
4037fe5d:	827230        	mull	a7, a2, a3
4037fe60:	a22230        	muluh	a2, a2, a3
4037fe63:	001216        	beqz	a2, 4037fe68 <calloc+0x10>
4037fe66:	180c      	movi.n	a8, 1
4037fe68:	48dc      	bnez.n	a8, 4037fe80 <calloc+0x28>
        return NULL;
    }

    result = heap_caps_malloc_default(size_bytes);
4037fe6a:	07ad      	mov.n	a10, a7
4037fe6c:	f60f65        	call8	40375f64 <heap_caps_malloc_default>
4037fe6f:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
4037fe71:	00da16        	beqz	a10, 4037fe82 <calloc+0x2a>
        bzero(result, size_bytes);
4037fe74:	07bd      	mov.n	a11, a7
4037fe76:	d48281        	l32r	a8, 40375080 <_iram_text_start+0xc7c> (40001260 <bzero>)
4037fe79:	0008e0        	callx8	a8
4037fe7c:	000086        	j	4037fe82 <calloc+0x2a>
4037fe7f:	020c00        	andb	b0, b12, b0
    }
    return result;
}
4037fe82:	f01d      	retw.n

4037fe84 <_free_r>:
ESP_COMPILER_DIAGNOSTIC_POP("-Wanalyzer-malloc-leak")

#if CONFIG_LIBC_NEWLIB
void _free_r(struct _reent *r, void* ptr)
{
4037fe84:	004136        	entry	a1, 32
4037fe87:	03ad      	mov.n	a10, a3
    heap_caps_free(ptr);
4037fe89:	f62ee5        	call8	40376178 <heap_caps_free>
}
4037fe8c:	f01d      	retw.n
	...

4037fe90 <_realloc_r>:

void* _realloc_r(struct _reent *r, void* ptr, size_t size)
{
4037fe90:	004136        	entry	a1, 32
4037fe93:	20a330        	or	a10, a3, a3
4037fe96:	20b440        	or	a11, a4, a4
    return heap_caps_realloc_default(ptr, size);
4037fe99:	f615e5        	call8	40375ff8 <heap_caps_realloc_default>
}
4037fe9c:	202aa0        	or	a2, a10, a10
4037fe9f:	f01d      	retw.n
4037fea1:	000000        	ill

4037fea4 <_malloc_r>:

void* _malloc_r(struct _reent *r, size_t size)
{
4037fea4:	004136        	entry	a1, 32
4037fea7:	03ad      	mov.n	a10, a3
    return heap_caps_malloc_default(size);
4037fea9:	f60ba5        	call8	40375f64 <heap_caps_malloc_default>
}
4037feac:	0a2d      	mov.n	a2, a10
4037feae:	f01d      	retw.n

4037feb0 <_calloc_r>:

void* _calloc_r(struct _reent *r, size_t nmemb, size_t size)
{
4037feb0:	004136        	entry	a1, 32
4037feb3:	20a330        	or	a10, a3, a3
4037feb6:	20b440        	or	a11, a4, a4
    return calloc(nmemb, size);
4037feb9:	fff9e5        	call8	4037fe58 <calloc>
}
4037febc:	202aa0        	or	a2, a10, a10
4037febf:	f01d      	retw.n
4037fec1:	000000        	ill

4037fec4 <esp_libc_include_heap_impl>:

/* No-op function, used to force linking this file,
   instead of the heap implementation from newlib.
 */
void esp_libc_include_heap_impl(void)
{
4037fec4:	004136        	entry	a1, 32
}
4037fec7:	f01d      	retw.n
4037fec9:	000000        	ill

4037fecc <__atomic_fetch_or_8>:
#define _ATOMIC_HW_STUB_SYNC_LOCK_RELEASE(n, type)
#endif // CONFIG_STDATOMIC_S32C1I_SPIRAM_WORKAROUND

_Static_assert(sizeof(long long unsigned int) == 8, "atomics require a 8-bytes type");

ATOMIC_FUNCTIONS(8, long long unsigned int)
4037fecc:	004136        	entry	a1, 32
4037fecf:	207220        	or	a7, a2, a2
    if (xPortInIsrContext()) {
4037fed2:	fa23a5        	call8	4037a10c <xPortInIsrContext>
4037fed5:	00ca16        	beqz	a10, 4037fee5 <__atomic_fetch_or_8+0x19>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037fed8:	ffafb2        	movi	a11, -1
4037fedb:	d46aa1        	l32r	a10, 40375084 <_iram_text_start+0xc80> (3fc92688 <s_atomic_lock>)
4037fede:	fa2525        	call8	4037a130 <xPortEnterCriticalTimeout>
4037fee1:	000246        	j	4037feee <__atomic_fetch_or_8+0x22>
4037fee4:	afb200        	f64cmph	a11, a2, a0, 10
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037fee7:	ff          	.byte	0xff
4037fee8:	d467a1        	l32r	a10, 40375084 <_iram_text_start+0xc80> (3fc92688 <s_atomic_lock>)
4037feeb:	fa2465        	call8	4037a130 <xPortEnterCriticalTimeout>
4037feee:	0020c0        	memw
4037fef1:	0728      	l32i.n	a2, a7, 0
4037fef3:	0020c0        	memw
4037fef6:	1738      	l32i.n	a3, a7, 4
4037fef8:	208240        	or	a8, a2, a4
4037fefb:	209350        	or	a9, a3, a5
4037fefe:	0020c0        	memw
4037ff01:	0789      	s32i.n	a8, a7, 0
4037ff03:	0020c0        	memw
4037ff06:	016792        	s32i	a9, a7, 4
    if (xPortInIsrContext()) {
4037ff09:	fa2025        	call8	4037a10c <xPortInIsrContext>
4037ff0c:	8a8c      	beqz.n	a10, 4037ff18 <__atomic_fetch_or_8+0x4c>
        portEXIT_CRITICAL_ISR(mux);
4037ff0e:	d45da1        	l32r	a10, 40375084 <_iram_text_start+0xc80> (3fc92688 <s_atomic_lock>)
4037ff11:	fa36e5        	call8	4037a280 <vPortExitCritical>
4037ff14:	000186        	j	4037ff1e <__atomic_fetch_or_8+0x52>
4037ff17:	5ba100        	ult.s	b10, f1, f0
        portEXIT_CRITICAL(mux);
4037ff1a:	3665d4        	lsi	f13, a5, 216
4037ff1d:	1dfa      	add.n	a1, a13, a15
4037ff1f:	f0          	.byte	0xf0

4037ff20 <spi_flash_needs_reset_check>:
static bool flash_brownout_needs_reset = false;
static bool flash_erasing = false;

// This function could be called in startup
void spi_flash_needs_reset_check(void)
{
4037ff20:	004136        	entry	a1, 32
    // Currently only XMC is suggested to reset when brownout
#if CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC
    if ((g_rom_flashchip.device_id >> 16) == 0x20) {
4037ff23:	d23381        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
4037ff26:	0888      	l32i.n	a8, a8, 0
4037ff28:	011882        	l16ui	a8, a8, 2
4037ff2b:	07c866        	bnei	a8, 32, 4037ff36 <spi_flash_needs_reset_check+0x16>
        flash_brownout_needs_reset = true;
4037ff2e:	d45681        	l32r	a8, 40375088 <_iram_text_start+0xc84> (3fc95ed9 <flash_brownout_needs_reset>)
4037ff31:	190c      	movi.n	a9, 1
4037ff33:	004892        	s8i	a9, a8, 0
    }
#endif
}
4037ff36:	f01d      	retw.n

4037ff38 <spi_flash_set_erasing_flag>:

void spi_flash_set_erasing_flag(bool status)
{
4037ff38:	004136        	entry	a1, 32
    flash_erasing = status;
4037ff3b:	d45481        	l32r	a8, 4037508c <_iram_text_start+0xc88> (3fc95ed8 <flash_erasing>)
4037ff3e:	004822        	s8i	a2, a8, 0
}
4037ff41:	f01d      	retw.n
	...

4037ff44 <spi_flash_brownout_need_reset>:

bool spi_flash_brownout_need_reset(void)
{
4037ff44:	004136        	entry	a1, 32
    return (flash_brownout_needs_reset && flash_erasing);
4037ff47:	d45081        	l32r	a8, 40375088 <_iram_text_start+0xc84> (3fc95ed9 <flash_brownout_needs_reset>)
4037ff4a:	000882        	l8ui	a8, a8, 0
4037ff4d:	b88c      	beqz.n	a8, 4037ff5c <spi_flash_brownout_need_reset+0x18>
4037ff4f:	d44f81        	l32r	a8, 4037508c <_iram_text_start+0xc88> (3fc95ed8 <flash_erasing>)
4037ff52:	000882        	l8ui	a8, a8, 0
4037ff55:	88cc      	bnez.n	a8, 4037ff61 <spi_flash_brownout_need_reset+0x1d>
4037ff57:	020c      	movi.n	a2, 0
4037ff59:	000186        	j	4037ff63 <spi_flash_brownout_need_reset+0x1f>
4037ff5c:	020c      	movi.n	a2, 0
4037ff5e:	000046        	j	4037ff63 <spi_flash_brownout_need_reset+0x1f>
4037ff61:	120c      	movi.n	a2, 1
}
4037ff63:	f01d      	retw.n
4037ff65:	000000        	ill

4037ff68 <memspi_host_read_status_hs>:
    ESP_EARLY_LOGV(TAG, "chip_id: %X\n", *id);
    return ESP_OK;
}

esp_err_t memspi_host_read_status_hs(spi_flash_host_inst_t *host, uint8_t *out_sr)
{
4037ff68:	008136        	entry	a1, 64
    //NOTE: we do have a read id function, however it doesn't work in high freq
    uint32_t stat_buf = 0;
4037ff6b:	0b0c      	movi.n	a11, 0
4037ff6d:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
4037ff6f:	714b      	addi.n	a7, a1, 4
4037ff71:	cc1c      	movi.n	a12, 28
4037ff73:	20a770        	or	a10, a7, a7
4037ff76:	d14681        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037ff79:	0008e0        	callx8	a8
4037ff7c:	180c      	movi.n	a8, 1
4037ff7e:	064182        	s8i	a8, a1, 6
4037ff81:	4119      	s32i.n	a1, a1, 16
4037ff83:	580c      	movi.n	a8, 5
4037ff85:	0c5182        	s16i	a8, a1, 24
        .command = CMD_RDSR,
        .miso_data = ((uint8_t*) &stat_buf),
        .miso_len = 1
    };
    esp_err_t err = host->driver->common_command(host, &t);
4037ff88:	0288      	l32i.n	a8, a2, 0
4037ff8a:	1888      	l32i.n	a8, a8, 4
4037ff8c:	07bd      	mov.n	a11, a7
4037ff8e:	20a220        	or	a10, a2, a2
4037ff91:	0008e0        	callx8	a8
4037ff94:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4037ff96:	3acc      	bnez.n	a10, 4037ff9d <memspi_host_read_status_hs+0x35>
        return err;
    }
    *out_sr = stat_buf;
4037ff98:	0188      	l32i.n	a8, a1, 0
4037ff9a:	004382        	s8i	a8, a3, 0
    return ESP_OK;
}
4037ff9d:	f01d      	retw.n
	...

4037ffa0 <memspi_host_erase_chip>:
    }
    return ESP_OK;
}

void memspi_host_erase_chip(spi_flash_host_inst_t *host)
{
4037ffa0:	008136        	entry	a1, 64
    spi_flash_trans_t t = { 0 };
4037ffa3:	cc1c      	movi.n	a12, 28
4037ffa5:	0b0c      	movi.n	a11, 0
4037ffa7:	20a110        	or	a10, a1, a1
4037ffaa:	d13981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037ffad:	0008e0        	callx8	a8
    t.command = CMD_CHIP_ERASE;
4037ffb0:	c7a082        	movi	a8, 199
4037ffb3:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
4037ffb6:	0288      	l32i.n	a8, a2, 0
4037ffb8:	1888      	l32i.n	a8, a8, 4
4037ffba:	01bd      	mov.n	a11, a1
4037ffbc:	02ad      	mov.n	a10, a2
4037ffbe:	0008e0        	callx8	a8
}
4037ffc1:	f01d      	retw.n
	...

4037ffc4 <memspi_host_set_write_protect>:
    host->driver->common_command(host, &t);
    return ESP_OK;
}

esp_err_t memspi_host_set_write_protect(spi_flash_host_inst_t *host, bool wp)
{
4037ffc4:	008136        	entry	a1, 64
4037ffc7:	743030        	extui	a3, a3, 0, 8
    spi_flash_trans_t t = {
4037ffca:	cc1c      	movi.n	a12, 28
4037ffcc:	0b0c      	movi.n	a11, 0
4037ffce:	01ad      	mov.n	a10, a1
4037ffd0:	d13081        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4037ffd3:	0008e0        	callx8	a8
4037ffd6:	338c      	beqz.n	a3, 4037ffdd <memspi_host_set_write_protect+0x19>
4037ffd8:	480c      	movi.n	a8, 4
4037ffda:	000046        	j	4037ffdf <memspi_host_set_write_protect+0x1b>
4037ffdd:	680c      	movi.n	a8, 6
4037ffdf:	0a5182        	s16i	a8, a1, 20
        .command = wp ? CMD_WRDI : CMD_WREN
    };
    host->driver->common_command(host, &t);
4037ffe2:	0288      	l32i.n	a8, a2, 0
4037ffe4:	1888      	l32i.n	a8, a8, 4
4037ffe6:	01bd      	mov.n	a11, a1
4037ffe8:	02ad      	mov.n	a10, a2
4037ffea:	0008e0        	callx8	a8
    return ESP_OK;
}
4037ffed:	020c      	movi.n	a2, 0
4037ffef:	f01d      	retw.n
4037fff1:	000000        	ill

4037fff4 <memspi_host_read_id_hs>:
{
4037fff4:	008136        	entry	a1, 64
    uint32_t id_buf = 0;
4037fff7:	0b0c      	movi.n	a11, 0
4037fff9:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
4037fffb:	714b      	addi.n	a7, a1, 4
4037fffd:	cc1c      	movi.n	a12, 28
4037ffff:	07ad      	mov.n	a10, a7
40380001:	d12381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380004:	0008e0        	callx8	a8
40380007:	380c      	movi.n	a8, 3
40380009:	064182        	s8i	a8, a1, 6
4038000c:	4119      	s32i.n	a1, a1, 16
4038000e:	9fa082        	movi	a8, 159
40380011:	0c5182        	s16i	a8, a1, 24
    host->driver->common_command(host, &t);
40380014:	0288      	l32i.n	a8, a2, 0
40380016:	1888      	l32i.n	a8, a8, 4
40380018:	20b770        	or	a11, a7, a7
4038001b:	20a220        	or	a10, a2, a2
4038001e:	0008e0        	callx8	a8
    uint32_t raw_flash_id = id_buf;
40380021:	0198      	l32i.n	a9, a1, 0
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
40380023:	d41b81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
40380026:	c08980        	sub	a8, a9, a8
40380029:	40f880        	nsau	a8, a8
4038002c:	418580        	srli	a8, a8, 5
4038002f:	40f9a0        	nsau	a10, a9
40380032:	41a5a0        	srli	a10, a10, 5
40380035:	2088a0        	or	a8, a8, a10
40380038:	c89c      	beqz.n	a8, 40380058 <memspi_host_read_id_hs+0x64>
4038003a:	d10c81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
4038003d:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "no response\n");
4038003f:	f88c      	beqz.n	a8, 40380052 <memspi_host_read_id_hs+0x5e>
40380041:	ffb9e5        	call8	4037fbe0 <esp_log_timestamp>
40380044:	d414c1        	l32r	a12, 40375094 <_iram_text_start+0xc90> (3fc942d8 <TAG>)
40380047:	0abd      	mov.n	a11, a10
40380049:	d413a1        	l32r	a10, 40375098 <_iram_text_start+0xc94> (3fc93d24 <__FUNCTION__$0+0x58c>)
4038004c:	d11a81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
4038004f:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_NO_RESPONSE;
40380052:	08a122        	movi	a2, 0x108
40380055:	0006c6        	j	40380074 <memspi_host_read_id_hs+0x80>
    uint16_t flash_id = (raw_flash_id >> 16) | (raw_flash_id & 0xFF00);
40380058:	f58090        	extui	a8, a9, 16, 16
4038005b:	00afa2        	movi	a10, 0xffffff00
4038005e:	10a9a0        	and	a10, a9, a10
40380061:	f4a0a0        	extui	a10, a10, 0, 16
40380064:	2088a0        	or	a8, a8, a10
    *id = ((uint32_t)mfg_id << 16) | flash_id;
40380067:	749090        	extui	a9, a9, 0, 8
4038006a:	119900        	slli	a9, a9, 16
4038006d:	208890        	or	a8, a8, a9
40380070:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380072:	020c      	movi.n	a2, 0
}
40380074:	f01d      	retw.n
	...

40380078 <memspi_host_flush_cache>:
{
40380078:	004136        	entry	a1, 32
    if ((void*)((memspi_host_inst_t*)host)->spi == (void*) spi_flash_ll_get_hw(SPI1_HOST)) {
4038007b:	012292        	l32i	a9, a2, 4
4038007e:	d1d881        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (60002000 <SPIMEM1>)
40380081:	089987        	bne	a9, a8, 4038008d <memspi_host_flush_cache+0x15>
        spi_flash_check_and_flush_cache(addr, size);
40380084:	20b440        	or	a11, a4, a4
40380087:	20a330        	or	a10, a3, a3
4038008a:	f7a325        	call8	40377abc <spi_flash_check_and_flush_cache>
}
4038008d:	020c      	movi.n	a2, 0
4038008f:	f01d      	retw.n
40380091:	000000        	ill

40380094 <memspi_host_erase_sector>:
{
40380094:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
40380097:	d3fe81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
4038009a:	0eb837        	bgeu	a8, a3, 403800ac <memspi_host_erase_sector+0x18>
4038009d:	d3ffd1        	l32r	a13, 4037509c <_iram_text_start+0xc98> (3fc93d5c <__FUNCTION__$0+0x5c4>)
403800a0:	d400c1        	l32r	a12, 403750a0 <_iram_text_start+0xc9c> (3fc942bc <__func__$2>)
403800a3:	96a0b2        	movi	a11, 150
403800a6:	d3ffa1        	l32r	a10, 403750a4 <_iram_text_start+0xca0> (3fc93d93 <__FUNCTION__$0+0x5fb>)
403800a9:	ffca65        	call8	4037fd50 <__assert_func>
    spi_flash_trans_t t = {
403800ac:	cc1c      	movi.n	a12, 28
403800ae:	0b0c      	movi.n	a11, 0
403800b0:	01ad      	mov.n	a10, a1
403800b2:	d0f781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403800b5:	0008e0        	callx8	a8
403800b8:	881c      	movi.n	a8, 24
403800ba:	034182        	s8i	a8, a1, 3
403800bd:	1139      	s32i.n	a3, a1, 4
403800bf:	082c      	movi.n	a8, 32
403800c1:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
403800c4:	0288      	l32i.n	a8, a2, 0
403800c6:	1888      	l32i.n	a8, a8, 4
403800c8:	01bd      	mov.n	a11, a1
403800ca:	20a220        	or	a10, a2, a2
403800cd:	0008e0        	callx8	a8
}
403800d0:	f01d      	retw.n
	...

403800d4 <memspi_host_erase_block>:
{
403800d4:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
403800d7:	d3ee81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403800da:	0eb837        	bgeu	a8, a3, 403800ec <memspi_host_erase_block+0x18>
403800dd:	d3efd1        	l32r	a13, 4037509c <_iram_text_start+0xc98> (3fc93d5c <__FUNCTION__$0+0x5c4>)
403800e0:	d3f2c1        	l32r	a12, 403750a8 <_iram_text_start+0xca4> (3fc942a4 <__func__$1>)
403800e3:	a2a0b2        	movi	a11, 162
403800e6:	d3efa1        	l32r	a10, 403750a4 <_iram_text_start+0xca0> (3fc93d93 <__FUNCTION__$0+0x5fb>)
403800e9:	ffc665        	call8	4037fd50 <__assert_func>
    spi_flash_trans_t t = {
403800ec:	cc1c      	movi.n	a12, 28
403800ee:	0b0c      	movi.n	a11, 0
403800f0:	01ad      	mov.n	a10, a1
403800f2:	d0e781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403800f5:	0008e0        	callx8	a8
403800f8:	881c      	movi.n	a8, 24
403800fa:	034182        	s8i	a8, a1, 3
403800fd:	1139      	s32i.n	a3, a1, 4
403800ff:	d8a082        	movi	a8, 216
40380102:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
40380105:	0288      	l32i.n	a8, a2, 0
40380107:	1888      	l32i.n	a8, a8, 4
40380109:	01bd      	mov.n	a11, a1
4038010b:	02ad      	mov.n	a10, a2
4038010d:	0008e0        	callx8	a8
}
40380110:	f01d      	retw.n
	...

40380114 <memspi_host_program_page>:
{
40380114:	008136        	entry	a1, 64
    assert(address + length <= 0x1000000);
40380117:	845a      	add.n	a8, a4, a5
40380119:	d1e691        	l32r	a9, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
4038011c:	0eb987        	bgeu	a9, a8, 4038012e <memspi_host_program_page+0x1a>
4038011f:	d3e3d1        	l32r	a13, 403750ac <_iram_text_start+0xca8> (3fc93da8 <__FUNCTION__$0+0x610>)
40380122:	d3e3c1        	l32r	a12, 403750b0 <_iram_text_start+0xcac> (3fc94288 <__func__$0>)
40380125:	aea0b2        	movi	a11, 174
40380128:	d3dfa1        	l32r	a10, 403750a4 <_iram_text_start+0xca0> (3fc93d93 <__FUNCTION__$0+0x5fb>)
4038012b:	ffc265        	call8	4037fd50 <__assert_func>
    spi_flash_trans_t t = {
4038012e:	cc1c      	movi.n	a12, 28
40380130:	0b0c      	movi.n	a11, 0
40380132:	01ad      	mov.n	a10, a1
40380134:	d0d781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380137:	0008e0        	callx8	a8
4038013a:	014152        	s8i	a5, a1, 1
4038013d:	881c      	movi.n	a8, 24
4038013f:	034182        	s8i	a8, a1, 3
40380142:	1149      	s32i.n	a4, a1, 4
40380144:	2139      	s32i.n	a3, a1, 8
40380146:	280c      	movi.n	a8, 2
40380148:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
4038014b:	0288      	l32i.n	a8, a2, 0
4038014d:	1888      	l32i.n	a8, a8, 4
4038014f:	01bd      	mov.n	a11, a1
40380151:	02ad      	mov.n	a10, a2
40380153:	0008e0        	callx8	a8
}
40380156:	f01d      	retw.n

40380158 <memspi_host_init_pointers>:
{
40380158:	004136        	entry	a1, 32
4038015b:	02ad      	mov.n	a10, a2
4038015d:	03bd      	mov.n	a11, a3
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4038015f:	d14991        	l32r	a9, 40374684 <_iram_text_start+0x280> (c0378000 <_rtc_reserved_end+0x60278000>)
40380162:	929a      	add.n	a9, a2, a9
40380164:	d2bd81        	l32r	a8, 40374c58 <_iram_text_start+0x854> (757fff <UserFrameTotalSize+0x757eff>)
40380167:	628890        	lsi	f9, a8, 0x188
4038016a:	880b      	addi.n	a8, a8, -1
4038016c:	608080        	neg	a8, a8
4038016f:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
40380172:	d2ba91        	l32r	a9, 40374c5c <_iram_text_start+0x858> (b0000000 <_rtc_reserved_end+0x4ff00000>)
40380175:	929a      	add.n	a9, a2, a9
40380177:	d11ec1        	l32r	a12, 403745f0 <_iram_text_start+0x1ec> (1fff <UserFrameTotalSize+0x1eff>)
4038017a:	629c90        	lsi	f9, a12, 0x188
4038017d:	990b      	addi.n	a9, a9, -1
4038017f:	609090        	neg	a9, a9
40380182:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40380185:	d119d1        	l32r	a13, 403745ec <_iram_text_start+0x1e8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40380188:	d2da      	add.n	a13, a2, a13
4038018a:	62ccd0        	lsi	f13, a12, 0x188
4038018d:	cc0b      	addi.n	a12, a12, -1
4038018f:	60c0c0        	neg	a12, a12
40380192:	74c0c0        	extui	a12, a12, 0, 8
    if (!esp_ptr_internal(host) && cfg->host_id == SPI1_HOST) {
40380195:	208890        	or	a8, a8, a9
40380198:	48cc      	bnez.n	a8, 403801a0 <memspi_host_init_pointers+0x48>
4038019a:	2ccc      	bnez.n	a12, 403801a0 <memspi_host_init_pointers+0x48>
4038019c:	8388      	l32i.n	a8, a3, 32
4038019e:	b89c      	beqz.n	a8, 403801bd <memspi_host_init_pointers+0x65>
    if (cfg->host_id == SPI1_HOST)
403801a0:	8b88      	l32i.n	a8, a11, 32
403801a2:	78cc      	bnez.n	a8, 403801ad <memspi_host_init_pointers+0x55>
        host->inst.driver = &esp_flash_default_host;
403801a4:	d3c481        	l32r	a8, 403750b4 <_iram_text_start+0xcb0> (3fc9366c <esp_flash_default_host>)
403801a7:	0a89      	s32i.n	a8, a10, 0
403801a9:	000146        	j	403801b2 <memspi_host_init_pointers+0x5a>
403801ac:	c28100        	quou	a8, a1, a0
        host->inst.driver = &esp_flash_gpspi_host;
403801af:	0a89d3        	lsip	f13, a9, 40
    esp_err_t err = spi_flash_hal_init(host, cfg);
403801b2:	d3c281        	l32r	a8, 403750bc <_iram_text_start+0xcb8> (42009f78 <spi_flash_hal_init>)
403801b5:	0008e0        	callx8	a8
403801b8:	0a2d      	mov.n	a2, a10
    return err;
403801ba:	000086        	j	403801c0 <memspi_host_init_pointers+0x68>
        return ESP_ERR_INVALID_ARG;
403801bd:	02a122        	movi	a2, 0x102
}
403801c0:	f01d      	retw.n
	...

403801c4 <memspi_host_write_data_slicer>:

// When encryption is enabled, etc. the data slicer may be complicated
// This is the simple case where the hardware has no other requirements than the size and page boundary
int memspi_host_write_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
403801c4:	004136        	entry	a1, 32
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
403801c7:	9288      	l32i.n	a8, a2, 36
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
403801c9:	186807        	bbci	a8, 0, 403801e5 <memspi_host_write_data_slicer+0x21>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
403801cc:	106307        	bbci	a3, 0, 403801e0 <memspi_host_write_data_slicer+0x1c>
403801cf:	066407        	bbci	a4, 0, 403801d9 <memspi_host_write_data_slicer+0x15>
            align_addr -= 1;
403801d2:	330b      	addi.n	a3, a3, -1
            len += 1;
403801d4:	441b      	addi.n	a4, a4, 1
403801d6:	0002c6        	j	403801e5 <memspi_host_write_data_slicer+0x21>
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
403801d9:	330b      	addi.n	a3, a3, -1
            len += 2;
403801db:	442b      	addi.n	a4, a4, 2
403801dd:	000106        	j	403801e5 <memspi_host_write_data_slicer+0x21>
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
403801e0:	016407        	bbci	a4, 0, 403801e5 <memspi_host_write_data_slicer+0x21>
            len += 1;
403801e3:	441b      	addi.n	a4, a4, 1
        }
    }

    uint32_t end_bound = (align_addr/page_size + 1) * page_size;
    // Shouldn't program cross the page, or longer than SPI_FLASH_HAL_MAX_WRITE_BYTES
    uint32_t max_len = MIN(end_bound - align_addr, SPI_FLASH_HAL_MAX_WRITE_BYTES);
403801e5:	e28360        	remu	a8, a3, a6
403801e8:	c06680        	sub	a6, a6, a8
403801eb:	084c      	movi.n	a8, 64
403801ed:	636680        	minu	a6, a6, a8
    *align_address = align_addr;
403801f0:	0539      	s32i.n	a3, a5, 0
    return MIN(max_len, len);
}
403801f2:	632460        	minu	a2, a4, a6
403801f5:	f01d      	retw.n
	...

403801f8 <memspi_host_read_data_slicer>:

int memspi_host_read_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
403801f8:	004136        	entry	a1, 32
    // Shouldn't read longer than SPI_FLASH_HAL_MAX_READ_BYTES
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
403801fb:	9288      	l32i.n	a8, a2, 36
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
403801fd:	186807        	bbci	a8, 0, 40380219 <memspi_host_read_data_slicer+0x21>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
40380200:	106307        	bbci	a3, 0, 40380214 <memspi_host_read_data_slicer+0x1c>
40380203:	066407        	bbci	a4, 0, 4038020d <memspi_host_read_data_slicer+0x15>
            align_addr -= 1;
40380206:	330b      	addi.n	a3, a3, -1
            len += 1;
40380208:	441b      	addi.n	a4, a4, 1
4038020a:	0002c6        	j	40380219 <memspi_host_read_data_slicer+0x21>
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
4038020d:	330b      	addi.n	a3, a3, -1
            len += 2;
4038020f:	442b      	addi.n	a4, a4, 2
40380211:	000106        	j	40380219 <memspi_host_read_data_slicer+0x21>
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
40380214:	016407        	bbci	a4, 0, 40380219 <memspi_host_read_data_slicer+0x21>
            len += 1;
40380217:	441b      	addi.n	a4, a4, 1
        }
    }
    uint32_t max_len = SPI_FLASH_HAL_MAX_READ_BYTES;
    *align_address = align_addr;
40380219:	0539      	s32i.n	a3, a5, 0
    return MIN(max_len, len);
}
4038021b:	024c      	movi.n	a2, 64
4038021d:	632420        	minu	a2, a4, a2
40380220:	f01d      	retw.n
	...

40380224 <spi_flash_chip_boya_probe>:
#include "spi_flash_chip_generic.h"
#include "spi_flash_chip_gd.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_boya_probe(esp_flash_t *chip, uint32_t flash_id)
{
40380224:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0x68;
    if (flash_id >> 16 != MFG_ID) {
40380227:	f59030        	extui	a9, a3, 16, 16
4038022a:	68a082        	movi	a8, 104
4038022d:	109987        	bne	a9, a8, 40380241 <spi_flash_chip_boya_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x4000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
40380230:	743830        	extui	a3, a3, 8, 8
40380233:	113380        	slli	a3, a3, 8
40380236:	d08681        	l32r	a8, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
40380239:	0b9387        	bne	a3, a8, 40380248 <spi_flash_chip_boya_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
4038023c:	020c      	movi.n	a2, 0
4038023e:	000246        	j	4038024b <spi_flash_chip_boya_probe+0x27>
        return ESP_ERR_NOT_FOUND;
40380241:	05a122        	movi	a2, 0x105
40380244:	0000c6        	j	4038024b <spi_flash_chip_boya_probe+0x27>
40380247:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
4038024a:	f01d05        	call0	4037041c <rom_rx_gain_force+0x369ff0>
4038024d:	000000        	ill

40380250 <spi_flash_chip_boya_get_caps>:
}

spi_flash_caps_t spi_flash_chip_boya_get_caps(esp_flash_t *chip)
{
40380250:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
40380253:	420c      	movi.n	a2, 4
40380255:	f01d      	retw.n
	...

40380258 <spi_flash_chip_gd_detect_size>:
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}

esp_err_t spi_flash_chip_gd_detect_size(esp_flash_t *chip, uint32_t *size)
{
40380258:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
4038025b:	62c8      	l32i.n	a12, a2, 24
    *size = 0;
4038025d:	0b0c      	movi.n	a11, 0
4038025f:	03b9      	s32i.n	a11, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
40380261:	f490c0        	extui	a9, a12, 0, 16
40380264:	180c      	movi.n	a8, 1
40380266:	0bad      	mov.n	a10, a11
40380268:	83a890        	moveqz	a10, a8, a9
4038026b:	d07dd1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
4038026e:	c099d0        	sub	a9, a9, a13
40380271:	938b90        	movnez	a8, a11, a9
40380274:	208a80        	or	a8, a10, a8
40380277:	d8cc      	bnez.n	a8, 40380288 <spi_flash_chip_gd_detect_size+0x30>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    *size = 1 << (id & 0xFF);
40380279:	180c      	movi.n	a8, 1
4038027b:	401c00        	ssl	a12
4038027e:	a18800        	sll	a8, a8
40380281:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380283:	0b2d      	mov.n	a2, a11
40380285:	000086        	j	4038028b <spi_flash_chip_gd_detect_size+0x33>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
40380288:	d18821        	l32r	a2, 403748a8 <_iram_text_start+0x4a4> (6005 <UserFrameTotalSize+0x5f05>)
}
4038028b:	f01d      	retw.n
4038028d:	000000        	ill

40380290 <spi_flash_chip_gd_suspend_cmd_conf>:
    return ret;
}
#endif //CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_gd_suspend_cmd_conf(esp_flash_t *chip)
{
40380290:	006136        	entry	a1, 48
    spi_flash_sus_cmd_conf sus_conf = {
40380293:	8c0c      	movi.n	a12, 8
40380295:	00a0b2        	movi	a11, 0
40380298:	01ad      	mov.n	a10, a1
4038029a:	d07d81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4038029d:	0008e0        	callx8	a8
403802a0:	84a082        	movi	a8, 132
403802a3:	0189      	s32i.n	a8, a1, 0
403802a5:	583c      	movi.n	a8, 53
403802a7:	044182        	s8i	a8, a1, 4
403802aa:	75a082        	movi	a8, 117
403802ad:	054182        	s8i	a8, a1, 5
403802b0:	7aa082        	movi	a8, 122
403802b3:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
403802b6:	02a8      	l32i.n	a10, a2, 0
403802b8:	0a88      	l32i.n	a8, a10, 0
403802ba:	152882        	l32i	a8, a8, 84
403802bd:	01bd      	mov.n	a11, a1
403802bf:	0008e0        	callx8	a8
}
403802c2:	0a2d      	mov.n	a2, a10
403802c4:	f01d      	retw.n
	...

403802c8 <spi_flash_chip_gd_set_io_mode>:
{
403802c8:	004136        	entry	a1, 32
403802cb:	02ad      	mov.n	a10, a2
    if (WRSR_16B_REQUIRED(chip->chip_id)) {
403802cd:	6288      	l32i.n	a8, a2, 24
403802cf:	749880        	extui	a9, a8, 8, 8
403802d2:	119980        	slli	a9, a9, 8
403802d5:	d37ab1        	l32r	a11, 403750c0 <_iram_text_start+0xcbc> (6000 <UserFrameTotalSize+0x5f00>)
403802d8:	0819b7        	beq	a9, a11, 403802e4 <spi_flash_chip_gd_set_io_mode+0x1c>
403802db:	748080        	extui	a8, a8, 0, 8
403802de:	15a092        	movi	a9, 21
403802e1:	113987        	bltu	a9, a8, 403802f6 <spi_flash_chip_gd_set_io_mode+0x2e>
        return spi_flash_common_set_io_mode(chip,
403802e4:	00a2d2        	movi	a13, 0x200
403802e7:	d377c1        	l32r	a12, 403750c4 <_iram_text_start+0xcc0> (4038071c <spi_flash_common_read_status_16b_rdsr_rdsr2>)
403802ea:	d377b1        	l32r	a11, 403750c8 <_iram_text_start+0xcc4> (40380754 <spi_flash_common_write_status_16b_wrsr>)
403802ed:	00afa5        	call8	40380de8 <spi_flash_common_set_io_mode>
403802f0:	0a2d      	mov.n	a2, a10
403802f2:	0003c6        	j	40380305 <spi_flash_chip_gd_set_io_mode+0x3d>
403802f5:	a0d200        	addx4	a13, a2, a0
        return spi_flash_common_set_io_mode(chip,
403802f8:	74c102        	addi	a0, a1, 116
403802fb:	75b1d3        	lsi	f13, a1, 0x1d4
403802fe:	aea5d3        	lsi	f13, a5, 0x2b8
40380301:	2aa000        	mul.s	f10, f0, f0
40380304:	009020        	all4	b2, b0:b1:b2:b3
	...

40380308 <spi_flash_chip_gd_get_io_mode>:
{
40380308:	006136        	entry	a1, 48
4038030b:	20a220        	or	a10, a2, a2
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
4038030e:	20b110        	or	a11, a1, a1
40380311:	0071e5        	call8	40380a30 <spi_flash_common_read_status_8b_rdsr2>
40380314:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380317:	9acc      	bnez.n	a10, 40380324 <spi_flash_chip_gd_get_io_mode+0x1c>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380319:	0188      	l32i.n	a8, a1, 0
4038031b:	888a      	add.n	a8, a8, a8
4038031d:	490c      	movi.n	a9, 4
4038031f:	108890        	and	a8, a8, a9
40380322:	0389      	s32i.n	a8, a3, 0
}
40380324:	f01d      	retw.n
	...

40380328 <spi_flash_chip_gd_get_caps>:
{
40380328:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
4038032b:	180282        	l8ui	a8, a2, 24
4038032e:	891c      	movi.n	a9, 24
40380330:	043987        	bltu	a9, a8, 40380338 <spi_flash_chip_gd_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
40380333:	020c      	movi.n	a2, 0
40380335:	000046        	j	4038033a <spi_flash_chip_gd_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_32MB_SUPPORT;
40380338:	220c      	movi.n	a2, 2
}
4038033a:	480c      	movi.n	a8, 4
4038033c:	202280        	or	a2, a2, a8
4038033f:	f01d      	retw.n
40380341:	000000        	ill

40380344 <spi_flash_chip_gd_probe>:
{
40380344:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40380347:	f59030        	extui	a9, a3, 16, 16
4038034a:	c8a082        	movi	a8, 200
4038034d:	1f9987        	bne	a9, a8, 40380370 <spi_flash_chip_gd_probe+0x2c>
    uint32_t product_id = flash_id & FLASH_ID_MASK;
40380350:	743830        	extui	a3, a3, 8, 8
40380353:	113380        	slli	a3, a3, 8
    if (product_id != GD25Q_PRODUCT_ID && product_id != GD25LQ_PRODUCT_ID) {
40380356:	c0d382        	addmi	a8, a3, 0xffffc000
40380359:	190c      	movi.n	a9, 1
4038035b:	839880        	moveqz	a9, a8, a8
4038035e:	a0d332        	addmi	a3, a3, 0xffffa000
40380361:	180c      	movi.n	a8, 1
40380363:	838330        	moveqz	a8, a3, a3
40380366:	0e8987        	bany	a9, a8, 40380378 <spi_flash_chip_gd_probe+0x34>
    return ESP_OK;
40380369:	020c      	movi.n	a2, 0
4038036b:	000306        	j	4038037b <spi_flash_chip_gd_probe+0x37>
4038036e:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
40380371:	0605a1        	l32r	a10, 40341b88 <rom_rx_gain_force+0x33b75c>
40380374:	000001        	l32r	a0, 40340374 <rom_rx_gain_force+0x339f48>
40380377:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
4038037a:	f01d05        	call0	4037054c <rom_rx_gain_force+0x36a120>
4038037d:	000000        	ill

40380380 <spi_flash_chip_generic_detect_size>:
} while(0)

static const char TAG[] = "chip_generic";

esp_err_t spi_flash_chip_generic_detect_size(esp_flash_t *chip, uint32_t *size)
{
40380380:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
40380383:	6288      	l32i.n	a8, a2, 24
    *size = 0;
40380385:	0c0c      	movi.n	a12, 0
40380387:	03c9      	s32i.n	a12, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
40380389:	f4a080        	extui	a10, a8, 0, 16
4038038c:	190c      	movi.n	a9, 1
4038038e:	0cbd      	mov.n	a11, a12
40380390:	83b9a0        	moveqz	a11, a9, a10
40380393:	d033d1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40380396:	c0aad0        	sub	a10, a10, a13
40380399:	939ca0        	movnez	a9, a12, a10
4038039c:	209b90        	or	a9, a11, a9
4038039f:	99dc      	bnez.n	a9, 403803bc <spi_flash_chip_generic_detect_size+0x3c>

    /* Get flash capacity from flash chip id depends on different vendors. According to majority of flash datasheets,
       Flash 256Mb to 512Mb directly from 0x19 to 0x20, instead of from 0x19 to 0x1a. So here we leave the common behavior.
       However, some other flash vendors also have their own rule, we will add them in chip specific files.
     */
    uint32_t mem_density = (id & 0xFF);
403803a1:	748080        	extui	a8, a8, 0, 8
    if (mem_density > SPI_FLASH_LINEAR_DENSITY_LAST_VALUE ) {
403803a4:	991c      	movi.n	a9, 25
403803a6:	02b987        	bgeu	a9, a8, 403803ac <spi_flash_chip_generic_detect_size+0x2c>
        mem_density -= SPI_FLASH_HEX_A_F_RANGE;
403803a9:	fac882        	addi	a8, a8, -6
    }

    *size = 1 << mem_density;
403803ac:	190c      	movi.n	a9, 1
403803ae:	401800        	ssl	a8
403803b1:	a18900        	sll	a8, a9
403803b4:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
403803b6:	020c      	movi.n	a2, 0
403803b8:	0000c6        	j	403803bf <spi_flash_chip_generic_detect_size+0x3f>
403803bb:	3b2100        	ueq.s	b2, f1, f0
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
403803be:	f01dd1        	l32r	a13, 4037c434 <vTaskGenericNotifyGiveFromISR+0xb0> (924b18a8 <_rtc_reserved_end+0x323b18a8>)
403803c1:	000000        	ill

403803c4 <spi_flash_chip_generic_reset>:
    // else has claimed it yet.
    return ESP_OK;
}

esp_err_t spi_flash_chip_generic_reset(esp_flash_t *chip)
{
403803c4:	008136        	entry	a1, 64
    //this is written following the winbond spec..
    spi_flash_trans_t t;
    t = (spi_flash_trans_t) {
403803c7:	cc1c      	movi.n	a12, 28
403803c9:	0b0c      	movi.n	a11, 0
403803cb:	20a110        	or	a10, a1, a1
403803ce:	d03081        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403803d1:	0008e0        	callx8	a8
403803d4:	66a082        	movi	a8, 102
403803d7:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RST_EN,
    };
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
403803da:	02a8      	l32i.n	a10, a2, 0
403803dc:	0a88      	l32i.n	a8, a10, 0
403803de:	1888      	l32i.n	a8, a8, 4
403803e0:	20b110        	or	a11, a1, a1
403803e3:	0008e0        	callx8	a8
    if (err != ESP_OK) {
403803e6:	baec      	bnez.n	a10, 40380415 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    t = (spi_flash_trans_t) {
403803e8:	cc1c      	movi.n	a12, 28
403803ea:	0b0c      	movi.n	a11, 0
403803ec:	01ad      	mov.n	a10, a1
403803ee:	d02881        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403803f1:	0008e0        	callx8	a8
403803f4:	99a082        	movi	a8, 153
403803f7:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RST_DEV,
    };
    err = chip->host->driver->common_command(chip->host, &t);
403803fa:	02a8      	l32i.n	a10, a2, 0
403803fc:	0a88      	l32i.n	a8, a10, 0
403803fe:	1888      	l32i.n	a8, a8, 4
40380400:	01bd      	mov.n	a11, a1
40380402:	0008e0        	callx8	a8
    if (err != ESP_OK) {
40380405:	cacc      	bnez.n	a10, 40380415 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380407:	1288      	l32i.n	a8, a2, 4
40380409:	152892        	l32i	a9, a8, 84
4038040c:	1888      	l32i.n	a8, a8, 4
4038040e:	08b8      	l32i.n	a11, a8, 0
40380410:	02ad      	mov.n	a10, a2
40380412:	0009e0        	callx8	a9
    return err;
}
40380415:	0a2d      	mov.n	a2, a10
40380417:	f01d      	retw.n
40380419:	000000        	ill

4038041c <spi_flash_chip_generic_config_host_io_mode>:
    }
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
}

esp_err_t spi_flash_chip_generic_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
4038041c:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    bool conf_required = false;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4038041f:	42e8      	l32i.n	a14, a2, 16
    bool addr_32bit = (flags & SPI_FLASH_CONFIG_IO_MODE_32B_ADDR);
40380421:	043030        	extui	a3, a3, 0, 1

    switch (read_mode & 0xFFFF) {
40380424:	f480e0        	extui	a8, a14, 0, 16
40380427:	6c3826        	beqi	a8, 3, 40380497 <spi_flash_chip_generic_config_host_io_mode+0x7b>
4038042a:	1648f6        	bgeui	a8, 4, 40380444 <spi_flash_chip_generic_config_host_io_mode+0x28>
4038042d:	021866        	bnei	a8, 1, 40380433 <spi_flash_chip_generic_config_host_io_mode+0x17>
40380430:	002b06        	j	403804e0 <spi_flash_chip_generic_config_host_io_mode+0xc4>
40380433:	022866        	bnei	a8, 2, 40380439 <spi_flash_chip_generic_config_host_io_mode+0x1d>
40380436:	0020c6        	j	403804bd <spi_flash_chip_generic_config_host_io_mode+0xa1>
40380439:	0c5816        	beqz	a8, 40380502 <spi_flash_chip_generic_config_host_io_mode+0xe6>
4038043c:	d11621        	l32r	a2, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
4038043f:	004c06        	j	40380573 <spi_flash_chip_generic_config_host_io_mode+0x157>
40380442:	260000        	lsi	f0, a0, 152
40380445:	2a48      	l32i.n	a4, a10, 8
40380447:	025826        	beqi	a8, 5, 4038044d <spi_flash_chip_generic_config_host_io_mode+0x31>
4038044a:	004886        	j	40380570 <spi_flash_chip_generic_config_host_io_mode+0x154>
    case SPI_FLASH_QIO:
        //for QIO mode, the 4 bit right after the address are used for continuous mode, should be set to 0 to avoid that.
        addr_bitlen = SPI_FLASH_QIO_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qio_dummy_bitlen : rom_flash_chip_dummy->qio_dummy_bitlen);
4038044d:	7288      	l32i.n	a8, a2, 28
4038044f:	0a6817        	bbci	a8, 1, 4038045d <spi_flash_chip_generic_config_host_io_mode+0x41>
40380452:	d32081        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93654 <rom_flash_chip_dummy_hpm>)
40380455:	0888      	l32i.n	a8, a8, 0
40380457:	0108d2        	l8ui	a13, a8, 1
4038045a:	0001c6        	j	40380465 <spi_flash_chip_generic_config_host_io_mode+0x49>
4038045d:	d31e81        	l32r	a8, 403750d8 <_iram_text_start+0xcd4> (3fc93658 <rom_flash_chip_dummy>)
40380460:	0888      	l32i.n	a8, a8, 0
40380462:	0108d2        	l8ui	a13, a8, 1
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
40380465:	0bc356        	bnez	a3, 40380525 <spi_flash_chip_generic_config_host_io_mode+0x109>
        conf_required = true;
40380468:	130c      	movi.n	a3, 1
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
4038046a:	eba0b2        	movi	a11, 235
4038046d:	8c1c      	movi.n	a12, 24
4038046f:	003946        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_QOUT:
        addr_bitlen = SPI_FLASH_QOUT_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qout_dummy_bitlen : rom_flash_chip_dummy->qout_dummy_bitlen);
40380472:	7288      	l32i.n	a8, a2, 28
40380474:	0c6817        	bbci	a8, 1, 40380484 <spi_flash_chip_generic_config_host_io_mode+0x68>
40380477:	d31781        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93654 <rom_flash_chip_dummy_hpm>)
4038047a:	0888      	l32i.n	a8, a8, 0
4038047c:	0208d2        	l8ui	a13, a8, 2
4038047f:	000246        	j	4038048c <spi_flash_chip_generic_config_host_io_mode+0x70>
40380482:	810000        	src	a0, a0, a0
40380485:	88d315        	call4	403091b8 <rom_rx_gain_force+0x302d8c>
40380488:	d208      	l32i.n	a0, a2, 52
4038048a:	0208      	l32i.n	a0, a2, 0
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
4038048c:	09d356        	bnez	a3, 4038052d <spi_flash_chip_generic_config_host_io_mode+0x111>
4038048f:	6ba0b2        	movi	a11, 107
40380492:	8c1c      	movi.n	a12, 24
40380494:	003006        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_DIO:
        //for DIO mode, the 4 bit right after the address are used for continuous mode, should be set to 0 to avoid that.
        addr_bitlen = SPI_FLASH_DIO_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dio_dummy_bitlen : rom_flash_chip_dummy->dio_dummy_bitlen);
40380497:	7288      	l32i.n	a8, a2, 28
40380499:	0b6817        	bbci	a8, 1, 403804a8 <spi_flash_chip_generic_config_host_io_mode+0x8c>
4038049c:	d30e81        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93654 <rom_flash_chip_dummy_hpm>)
4038049f:	0888      	l32i.n	a8, a8, 0
403804a1:	0008d2        	l8ui	a13, a8, 0
403804a4:	000206        	j	403804b0 <spi_flash_chip_generic_config_host_io_mode+0x94>
403804a7:	0c8100        	lsi	f0, a1, 48
403804aa:	0888d3        	lsip	f13, a8, 32
403804ad:	0008d2        	l8ui	a13, a8, 0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
403804b0:	084356        	bnez	a3, 40380538 <spi_flash_chip_generic_config_host_io_mode+0x11c>
        conf_required = true;
403804b3:	130c      	movi.n	a3, 1
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
403804b5:	bba0b2        	movi	a11, 187
403804b8:	8c1c      	movi.n	a12, 24
403804ba:	002686        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_DOUT:
        addr_bitlen = SPI_FLASH_DOUT_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dout_dummy_bitlen : rom_flash_chip_dummy->dout_dummy_bitlen);
403804bd:	7288      	l32i.n	a8, a2, 28
403804bf:	0a6817        	bbci	a8, 1, 403804cd <spi_flash_chip_generic_config_host_io_mode+0xb1>
403804c2:	d30481        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93654 <rom_flash_chip_dummy_hpm>)
403804c5:	0888      	l32i.n	a8, a8, 0
403804c7:	0308d2        	l8ui	a13, a8, 3
403804ca:	0001c6        	j	403804d5 <spi_flash_chip_generic_config_host_io_mode+0xb9>
403804cd:	d30281        	l32r	a8, 403750d8 <_iram_text_start+0xcd4> (3fc93658 <rom_flash_chip_dummy>)
403804d0:	0888      	l32i.n	a8, a8, 0
403804d2:	0308d2        	l8ui	a13, a8, 3
        read_command = (addr_32bit? CMD_FASTRD_DUAL_4B: CMD_FASTRD_DUAL);
403804d5:	067356        	bnez	a3, 40380540 <spi_flash_chip_generic_config_host_io_mode+0x124>
403804d8:	bb3c      	movi.n	a11, 59
403804da:	8c1c      	movi.n	a12, 24
403804dc:	001e06        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
403804df:	728800        	lsi	f0, a8, 0x1c8
        break;
    case SPI_FLASH_FASTRD:
        addr_bitlen = SPI_FLASH_FASTRD_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->fastrd_dummy_bitlen : rom_flash_chip_dummy->fastrd_dummy_bitlen);
403804e2:	0a6817        	bbci	a8, 1, 403804f0 <spi_flash_chip_generic_config_host_io_mode+0xd4>
403804e5:	d2fb81        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93654 <rom_flash_chip_dummy_hpm>)
403804e8:	0888      	l32i.n	a8, a8, 0
403804ea:	0408d2        	l8ui	a13, a8, 4
403804ed:	0001c6        	j	403804f8 <spi_flash_chip_generic_config_host_io_mode+0xdc>
403804f0:	d2fa81        	l32r	a8, 403750d8 <_iram_text_start+0xcd4> (3fc93658 <rom_flash_chip_dummy>)
403804f3:	0888      	l32i.n	a8, a8, 0
403804f5:	0408d2        	l8ui	a13, a8, 4
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
403804f8:	04d356        	bnez	a3, 40380549 <spi_flash_chip_generic_config_host_io_mode+0x12d>
403804fb:	bb0c      	movi.n	a11, 11
403804fd:	8c1c      	movi.n	a12, 24
403804ff:	001546        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_SLOWRD:
        addr_bitlen = SPI_FLASH_SLOWRD_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->slowrd_dummy_bitlen : rom_flash_chip_dummy->slowrd_dummy_bitlen);
40380502:	7288      	l32i.n	a8, a2, 28
40380504:	0c6817        	bbci	a8, 1, 40380514 <spi_flash_chip_generic_config_host_io_mode+0xf8>
40380507:	d2f381        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc93654 <rom_flash_chip_dummy_hpm>)
4038050a:	0888      	l32i.n	a8, a8, 0
4038050c:	0508d2        	l8ui	a13, a8, 5
4038050f:	000246        	j	4038051c <spi_flash_chip_generic_config_host_io_mode+0x100>
40380512:	810000        	src	a0, a0, a0
40380515:	88d2f1        	l32r	a15, 40362860 <rom_rx_gain_force+0x35c434>
40380518:	d208      	l32i.n	a0, a2, 52
4038051a:	0508      	l32i.n	a0, a5, 0
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
4038051c:	23fc      	bnez.n	a3, 40380552 <spi_flash_chip_generic_config_host_io_mode+0x136>
4038051e:	3b0c      	movi.n	a11, 3
40380520:	8c1c      	movi.n	a12, 24
40380522:	000c86        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
40380525:	eca0b2        	movi	a11, 236
    default:
        return ESP_ERR_FLASH_NOT_INITIALISED;
    }
    //For W25Q256 chip, the only difference between 4-Byte address command and 3-Byte version is the command value and the address bit length.
    if (addr_32bit) {
        addr_bitlen += 8;
40380528:	0c2c      	movi.n	a12, 32
4038052a:	000a86        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
4038052d:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
4038052f:	6ca0b2        	movi	a11, 108
        addr_bitlen += 8;
40380532:	0c2c      	movi.n	a12, 32
40380534:	000806        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
40380537:	a0b200        	addx4	a11, a2, a0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
4038053a:	2cbc      	beqz.n	a12, 40380570 <spi_flash_chip_generic_config_host_io_mode+0x154>
        addr_bitlen += 8;
4038053c:	c60c      	movi.n	a6, 12
4038053e:	0c0005        	call0	4038c540 <_coredump_iram_end+0xa640>
    bool conf_required = false;
40380541:	cb3c03        	lsi	f0, a12, 0x32c
        addr_bitlen += 8;
40380544:	0c2c      	movi.n	a12, 32
40380546:	000386        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
40380549:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
4038054b:	cb0c      	movi.n	a11, 12
        addr_bitlen += 8;
4038054d:	0c2c      	movi.n	a12, 32
4038054f:	000146        	j	40380558 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
40380552:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
40380554:	3b1c      	movi.n	a11, 19
        addr_bitlen += 8;
40380556:	0c2c      	movi.n	a12, 32
    }

    if (conf_required) {
40380558:	438c      	beqz.n	a3, 40380560 <spi_flash_chip_generic_config_host_io_mode+0x144>
        read_mode |= SPI_FLASH_CONFIG_CONF_BITS;
4038055a:	cff081        	l32r	a8, 4037451c <_iram_text_start+0x118> (80000000 <_rtc_reserved_end+0x1ff00000>)
4038055d:	20ee80        	or	a14, a14, a8
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
40380560:	02a8      	l32i.n	a10, a2, 0
40380562:	0a88      	l32i.n	a8, a10, 0
40380564:	f888      	l32i.n	a8, a8, 60
40380566:	0008e0        	callx8	a8
40380569:	0a2d      	mov.n	a2, a10
4038056b:	000106        	j	40380573 <spi_flash_chip_generic_config_host_io_mode+0x157>
4038056e:	210000        	srai	a0, a0, 0
    switch (read_mode & 0xFFFF) {
40380571:	d0c9      	s32i.n	a12, a0, 52
}
40380573:	f01d      	retw.n
40380575:	000000        	ill

40380578 <spi_flash_chip_generic_write_encrypted>:
}
#endif // CONFIG_SPI_FLASH_ROM_IMPL

#if !CONFIG_SPI_FLASH_ROM_IMPL || ESP_ROM_HAS_ENCRYPTED_WRITES_USING_LEGACY_DRV
esp_err_t spi_flash_chip_generic_write_encrypted(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
40380578:	004136        	entry	a1, 32
4038057b:	027d      	mov.n	a7, a2
    spi_flash_encryption_t *esp_flash_encryption = &esp_flash_encryption_default;
    esp_err_t err = ESP_OK;
    // Encryption must happen on main flash.
    if (chip != esp_flash_default_chip) {
4038057d:	d0c681        	l32r	a8, 40374898 <_iram_text_start+0x494> (3fc95eec <esp_flash_default_chip>)
40380580:	0888      	l32i.n	a8, a8, 0
40380582:	021827        	beq	a8, a2, 40380588 <spi_flash_chip_generic_write_encrypted+0x10>
40380585:	002bc6        	j	40380638 <spi_flash_chip_generic_write_encrypted+0xc0>
        return ESP_ERR_NOT_SUPPORTED;
    }

    /* Check if the buffer and length can qualify the requirements */
    if (esp_flash_encryption->flash_encryption_check(address, length) != true) {
40380588:	d2d581        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9363c <esp_flash_encryption_default>)
4038058b:	5888      	l32i.n	a8, a8, 20
4038058d:	05bd      	mov.n	a11, a5
4038058f:	20a440        	or	a10, a4, a4
40380592:	0008e0        	callx8	a8
40380595:	0a8a16        	beqz	a10, 40380641 <spi_flash_chip_generic_write_encrypted+0xc9>
        return ESP_ERR_NOT_SUPPORTED;
    }

    const uint8_t *data_bytes = (const uint8_t *)buffer;
    esp_flash_encryption->flash_encryption_enable();
40380598:	d2d181        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9363c <esp_flash_encryption_default>)
4038059b:	0888      	l32i.n	a8, a8, 0
4038059d:	0008e0        	callx8	a8
    esp_err_t err = ESP_OK;
403805a0:	020c      	movi.n	a2, 0

#if SOC_FLASH_ENCRYPTION_XTS_AES_SUPPORT_PSEUDO_ROUND
    spi_flash_encryption_hal_enable_pseudo_rounds(ESP_XTS_AES_PSEUDO_ROUNDS_LOW, XTS_AES_PSEUDO_ROUNDS_BASE, XTS_AES_PSEUDO_ROUNDS_INC, XTS_AES_PSEUDO_ROUNDS_RNG_CNT);
#endif /* SOC_FLASH_ENCRYPTION_XTS_AES_SUPPORT_PSEUDO_ROUND */

    while (length > 0) {
403805a2:	002086        	j	40380628 <spi_flash_chip_generic_write_encrypted+0xb0>
        int block_size;
        /* Write the largest block if possible */
        if (address % 64 == 0 && length >= 64) {
403805a5:	548040        	extui	a8, a4, 0, 6
403805a8:	48cc      	bnez.n	a8, 403805b0 <spi_flash_chip_generic_write_encrypted+0x38>
403805aa:	3fa082        	movi	a8, 63
403805ad:	0f3857        	bltu	a8, a5, 403805c0 <spi_flash_chip_generic_write_encrypted+0x48>
            block_size = 64;
        } else if (address % 32 == 0 && length >= 32) {
403805b0:	448040        	extui	a8, a4, 0, 5
403805b3:	e8cc      	bnez.n	a8, 403805c5 <spi_flash_chip_generic_write_encrypted+0x4d>
403805b5:	f81c      	movi.n	a8, 31
403805b7:	0f3857        	bltu	a8, a5, 403805ca <spi_flash_chip_generic_write_encrypted+0x52>
            block_size = 32;
        } else {
            block_size = 16;
403805ba:	061c      	movi.n	a6, 16
403805bc:	000306        	j	403805cc <spi_flash_chip_generic_write_encrypted+0x54>
403805bf:	064c00        	lsi	f0, a12, 24
            block_size = 64;
403805c2:	000186        	j	403805cc <spi_flash_chip_generic_write_encrypted+0x54>
            block_size = 16;
403805c5:	061c      	movi.n	a6, 16
403805c7:	000046        	j	403805cc <spi_flash_chip_generic_write_encrypted+0x54>
            block_size = 32;
403805ca:	062c      	movi.n	a6, 32
        }
        // Prepare the flash chip (same time as AES operation, for performance)
        esp_flash_encryption->flash_encryption_data_prepare(address, (uint32_t *)data_bytes, block_size);
403805cc:	d2c481        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9363c <esp_flash_encryption_default>)
403805cf:	2888      	l32i.n	a8, a8, 8
403805d1:	06cd      	mov.n	a12, a6
403805d3:	03bd      	mov.n	a11, a3
403805d5:	04ad      	mov.n	a10, a4
403805d7:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
403805da:	1788      	l32i.n	a8, a7, 4
403805dc:	b888      	l32i.n	a8, a8, 44
403805de:	0b0c      	movi.n	a11, 0
403805e0:	07ad      	mov.n	a10, a7
403805e2:	0008e0        	callx8	a8
403805e5:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
403805e7:	059a56        	bnez	a10, 40380644 <spi_flash_chip_generic_write_encrypted+0xcc>
            return err;
        }
        // Waiting for encrypting buffer to finish and making result visible for SPI1
        esp_flash_encryption->flash_encryption_done();
403805ea:	d2bc81        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9363c <esp_flash_encryption_default>)
403805ed:	3888      	l32i.n	a8, a8, 12
403805ef:	0008e0        	callx8	a8

        // Note: For encryption function, after write flash command is sent. The hardware will write the encrypted buffer
        // prepared in XTS_FLASH_ENCRYPTION register in function `flash_encryption_data_prepare`, instead of the origin
        // buffer named `data_bytes`.

        err = chip->chip_drv->write(chip, (uint32_t *)data_bytes, address, length);
403805f2:	1788      	l32i.n	a8, a7, 4
403805f4:	112882        	l32i	a8, a8, 68
403805f7:	05dd      	mov.n	a13, a5
403805f9:	04cd      	mov.n	a12, a4
403805fb:	03bd      	mov.n	a11, a3
403805fd:	07ad      	mov.n	a10, a7
403805ff:	0008e0        	callx8	a8
40380602:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380604:	cafc      	bnez.n	a10, 40380644 <spi_flash_chip_generic_write_encrypted+0xcc>
            return err;
        }
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40380606:	1788      	l32i.n	a8, a7, 4
40380608:	152892        	l32i	a9, a8, 84
4038060b:	1888      	l32i.n	a8, a8, 4
4038060d:	48b8      	l32i.n	a11, a8, 16
4038060f:	07ad      	mov.n	a10, a7
40380611:	0009e0        	callx8	a9
40380614:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380616:	aaec      	bnez.n	a10, 40380644 <spi_flash_chip_generic_write_encrypted+0xcc>

        // Note: we don't wait for idle status here, because this way
        // the AES peripheral can start encrypting the next
        // block while the SPI flash chip is busy completing the write

        esp_flash_encryption->flash_encryption_destroy();
40380618:	d2b181        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9363c <esp_flash_encryption_default>)
4038061b:	4888      	l32i.n	a8, a8, 16
4038061d:	0008e0        	callx8	a8

        length -= block_size;
40380620:	c05560        	sub	a5, a5, a6
        data_bytes += block_size;
40380623:	336a      	add.n	a3, a3, a6
        address += block_size;
40380625:	804460        	add	a4, a4, a6
    while (length > 0) {
40380628:	f79556        	bnez	a5, 403805a5 <spi_flash_chip_generic_write_encrypted+0x2d>
    }

    esp_flash_encryption->flash_encryption_disable();
4038062b:	d2ac81        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (3fc9363c <esp_flash_encryption_default>)
4038062e:	012882        	l32i	a8, a8, 4
40380631:	0008e0        	callx8	a8
    return err;
40380634:	000306        	j	40380644 <spi_flash_chip_generic_write_encrypted+0xcc>
40380637:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
4038063a:	014606        	j	40380b56 <spi_flash_chip_generic_erase_chip+0x86>
4038063d:	000000        	ill
40380640:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
40380643:	f01d06        	j	4037c6bb <xTaskCreateStaticPinnedToCore+0x83>
	...

40380648 <spi_flash_chip_generic_get_caps>:
    // For flash doesn't support read unique id.
    return ESP_ERR_NOT_SUPPORTED;
}

spi_flash_caps_t spi_flash_chip_generic_get_caps(esp_flash_t *chip)
{
40380648:	008136        	entry	a1, 64
    spi_flash_caps_t caps_flags = 0;
    // 32M-bits address support

    // flash suspend support
    // XMC-D support suspend
    if (chip->chip_id >> 16 == 0x46) {
4038064b:	0d1282        	l16ui	a8, a2, 26
4038064e:	694c      	movi.n	a9, 70
40380650:	041897        	beq	a8, a9, 40380658 <spi_flash_chip_generic_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
40380653:	070c      	movi.n	a7, 0
40380655:	000046        	j	4038065a <spi_flash_chip_generic_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
40380658:	170c      	movi.n	a7, 1
    }

    // XMC-D support suspend (some D series flash chip begin with 0x20, difference checked by SFDP)
    if (chip->chip_id >> 16 == 0x20) {
4038065a:	42c866        	bnei	a8, 32, 403806a0 <spi_flash_chip_generic_get_caps+0x58>
        uint8_t data = 0;
4038065d:	080c      	movi.n	a8, 0
4038065f:	1c4182        	s8i	a8, a1, 28
        spi_flash_trans_t t = {
40380662:	cc1c      	movi.n	a12, 28
40380664:	0b0c      	movi.n	a11, 0
40380666:	01ad      	mov.n	a10, a1
40380668:	cf8a81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4038066b:	0008e0        	callx8	a8
4038066e:	180c      	movi.n	a8, 1
40380670:	024182        	s8i	a8, a1, 2
40380673:	881c      	movi.n	a8, 24
40380675:	034182        	s8i	a8, a1, 3
40380678:	283c      	movi.n	a8, 50
4038067a:	1189      	s32i.n	a8, a1, 4
4038067c:	1cc182        	addi	a8, a1, 28
4038067f:	3189      	s32i.n	a8, a1, 12
40380681:	a85c      	movi.n	a8, 90
40380683:	0a5182        	s16i	a8, a1, 20
40380686:	860c      	movi.n	a6, 8
40380688:	164162        	s8i	a6, a1, 22
            .mosi_data = 0,
            .miso_len = 1,
            .miso_data = &data,
            .dummy_bitlen = 8,
        };
        chip->host->driver->common_command(chip->host, &t);
4038068b:	02a8      	l32i.n	a10, a2, 0
4038068d:	0a88      	l32i.n	a8, a10, 0
4038068f:	012882        	l32i	a8, a8, 4
40380692:	20b110        	or	a11, a1, a1
40380695:	0008e0        	callx8	a8
        if((data & 0x8) == 0x8) {
40380698:	1c0182        	l8ui	a8, a1, 28
4038069b:	010867        	bnone	a8, a6, 403806a0 <spi_flash_chip_generic_get_caps+0x58>
            caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
4038069e:	170c      	movi.n	a7, 1
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
    }
#endif

    // FM support suspend
    if (chip->chip_id >> 16 == 0xa1) {
403806a0:	0d1292        	l16ui	a9, a2, 26
403806a3:	a1a082        	movi	a8, 161
403806a6:	049987        	bne	a9, a8, 403806ae <spi_flash_chip_generic_get_caps+0x66>
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
403806a9:	180c      	movi.n	a8, 1
403806ab:	207780        	or	a7, a7, a8
    }
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
403806ae:	420c      	movi.n	a2, 4
403806b0:	202720        	or	a2, a7, a2
403806b3:	f01d      	retw.n
403806b5:	000000        	ill

403806b8 <spi_flash_common_read_qe_sr>:
/*******************************************************************************
 * Utility functions
 ******************************************************************************/

static esp_err_t spi_flash_common_read_qe_sr(esp_flash_t *chip, uint8_t qe_rdsr_command, uint8_t qe_sr_bitwidth, uint32_t *sr)
{
403806b8:	008136        	entry	a1, 64
    uint32_t sr_buf = 0;
403806bb:	0b0c      	movi.n	a11, 0
403806bd:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
403806bf:	714b      	addi.n	a7, a1, 4
403806c1:	1ca0c2        	movi	a12, 28
403806c4:	07ad      	mov.n	a10, a7
403806c6:	cf7281        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403806c9:	0008e0        	callx8	a8
403806cc:	414340        	srli	a4, a4, 3
403806cf:	064142        	s8i	a4, a1, 6
403806d2:	4119      	s32i.n	a1, a1, 16
403806d4:	0c5132        	s16i	a3, a1, 24
        .command = qe_rdsr_command,
        .miso_data = (uint8_t*) &sr_buf,
        .miso_len = qe_sr_bitwidth / 8,
    };
    esp_err_t ret = chip->host->driver->common_command(chip->host, &t);
403806d7:	02a8      	l32i.n	a10, a2, 0
403806d9:	0a88      	l32i.n	a8, a10, 0
403806db:	1888      	l32i.n	a8, a8, 4
403806dd:	07bd      	mov.n	a11, a7
403806df:	0008e0        	callx8	a8
    *sr = sr_buf;
403806e2:	0188      	l32i.n	a8, a1, 0
403806e4:	0589      	s32i.n	a8, a5, 0
    return ret;
}
403806e6:	0a2d      	mov.n	a2, a10
403806e8:	f01d      	retw.n
	...

403806ec <spi_flash_common_write_qe_sr>:

static esp_err_t spi_flash_common_write_qe_sr(esp_flash_t *chip, uint8_t qe_wrsr_command, uint8_t qe_sr_bitwidth, uint32_t qe)
{
403806ec:	00a136        	entry	a1, 80
403806ef:	8159      	s32i.n	a5, a1, 32
    spi_flash_trans_t t = {
403806f1:	cc1c      	movi.n	a12, 28
403806f3:	0b0c      	movi.n	a11, 0
403806f5:	01ad      	mov.n	a10, a1
403806f7:	cf6681        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403806fa:	0008e0        	callx8	a8
403806fd:	414340        	srli	a4, a4, 3
40380700:	014142        	s8i	a4, a1, 1
40380703:	20c182        	addi	a8, a1, 32
40380706:	2189      	s32i.n	a8, a1, 8
40380708:	0a5132        	s16i	a3, a1, 20
        .command = qe_wrsr_command,
        .mosi_data = ((uint8_t*) &qe),
        .mosi_len = qe_sr_bitwidth / 8,
        .miso_len = 0,
    };
    return chip->host->driver->common_command(chip->host, &t);
4038070b:	02a8      	l32i.n	a10, a2, 0
4038070d:	0a88      	l32i.n	a8, a10, 0
4038070f:	1888      	l32i.n	a8, a8, 4
40380711:	01bd      	mov.n	a11, a1
40380713:	0008e0        	callx8	a8
}
40380716:	0a2d      	mov.n	a2, a10
40380718:	f01d      	retw.n
	...

4038071c <spi_flash_common_read_status_16b_rdsr_rdsr2>:

esp_err_t spi_flash_common_read_status_16b_rdsr_rdsr2(esp_flash_t* chip, uint32_t* out_sr)
{
4038071c:	006136        	entry	a1, 48
4038071f:	207220        	or	a7, a2, a2
    uint32_t sr, sr2;
    esp_err_t ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, &sr2);
40380722:	04c1d2        	addi	a13, a1, 4
40380725:	8c0c      	movi.n	a12, 8
40380727:	35a0b2        	movi	a11, 53
4038072a:	02ad      	mov.n	a10, a2
4038072c:	fff8a5        	call8	403806b8 <spi_flash_common_read_qe_sr>
4038072f:	0a2d      	mov.n	a2, a10
    if (ret == ESP_OK) {
40380731:	dadc      	bnez.n	a10, 40380752 <spi_flash_common_read_status_16b_rdsr_rdsr2+0x36>
        ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, &sr);
40380733:	01dd      	mov.n	a13, a1
40380735:	8c0c      	movi.n	a12, 8
40380737:	5b0c      	movi.n	a11, 5
40380739:	07ad      	mov.n	a10, a7
4038073b:	fff7e5        	call8	403806b8 <spi_flash_common_read_qe_sr>
4038073e:	0a2d      	mov.n	a2, a10
    }
    if (ret == ESP_OK) {
40380740:	eacc      	bnez.n	a10, 40380752 <spi_flash_common_read_status_16b_rdsr_rdsr2+0x36>
        *out_sr = (sr & 0xff) | ((sr2 & 0xff) << 8);
40380742:	000192        	l8ui	a9, a1, 0
40380745:	1188      	l32i.n	a8, a1, 4
40380747:	118880        	slli	a8, a8, 8
4038074a:	f48080        	extui	a8, a8, 0, 16
4038074d:	208980        	or	a8, a9, a8
40380750:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
40380752:	f01d      	retw.n

40380754 <spi_flash_common_write_status_16b_wrsr>:
{
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, out_sr);
}

esp_err_t spi_flash_common_write_status_16b_wrsr(esp_flash_t* chip, uint32_t sr)
{
40380754:	004136        	entry	a1, 32
40380757:	20a220        	or	a10, a2, a2
4038075a:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 16, sr);
4038075d:	10a0c2        	movi	a12, 16
40380760:	1b0c      	movi.n	a11, 1
40380762:	fff8a5        	call8	403806ec <spi_flash_common_write_qe_sr>
}
40380765:	0a2d      	mov.n	a2, a10
40380767:	f01d      	retw.n
40380769:	000000        	ill

4038076c <spi_flash_chip_generic_read>:
{
4038076c:	010136        	entry	a1, 128
    const uint32_t page_size = chip->chip_drv->page_size;
4038076f:	012282        	l32i	a8, a2, 4
40380772:	132892        	l32i	a9, a8, 76
40380775:	176192        	s32i	a9, a1, 92
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
40380778:	1e2882        	l32i	a8, a8, 120
4038077b:	00a0b2        	movi	a11, 0
4038077e:	02ad      	mov.n	a10, a2
40380780:	0008e0        	callx8	a8
40380783:	1561a2        	s32i	a10, a1, 84
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380786:	06a182        	movi	a8, 0x106
40380789:	021a87        	beq	a10, a8, 4038078f <spi_flash_chip_generic_read+0x23>
4038078c:	001e06        	j	40380808 <spi_flash_chip_generic_read+0x9c>
        ESP_LOGE(TAG, "configure host io mode failed - unsupported");
4038078f:	ff4525        	call8	4037fbe0 <esp_log_timestamp>
40380792:	d253b1        	l32r	a11, 403750e0 <_iram_text_start+0xcdc> (3fc944ec <TAG>)
40380795:	0bed      	mov.n	a14, a11
40380797:	0add      	mov.n	a13, a10
40380799:	d252c1        	l32r	a12, 403750e4 <_iram_text_start+0xce0> (3fc93b80 <__FUNCTION__$0+0x3e8>)
4038079c:	1a0c      	movi.n	a10, 1
4038079e:	ff48a5        	call8	4037fc28 <esp_log_write>
        return err;
403807a1:	001c06        	j	40380815 <spi_flash_chip_generic_read+0xa9>
403807a4:	614b00        	lsi	f0, a11, 0x184
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
403807a7:	0c4c      	movi.n	a12, 64
403807a9:	ffa0b2        	movi	a11, 255
403807ac:	06ad      	mov.n	a10, a6
403807ae:	cf3881        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403807b1:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
403807b4:	02a8      	l32i.n	a10, a2, 0
403807b6:	0a88      	l32i.n	a8, a10, 0
403807b8:	d888      	l32i.n	a8, a8, 52
403807ba:	1721e2        	l32i	a14, a1, 92
403807bd:	01dd      	mov.n	a13, a1
403807bf:	05cd      	mov.n	a12, a5
403807c1:	04bd      	mov.n	a11, a4
403807c3:	0008e0        	callx8	a8
403807c6:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
403807c8:	01c8      	l32i.n	a12, a1, 0
403807ca:	c084c0        	sub	a8, a4, a12
403807cd:	166182        	s32i	a8, a1, 88
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
403807d0:	754a      	add.n	a7, a5, a4
403807d2:	8caa      	add.n	a8, a12, a10
403807d4:	637780        	minu	a7, a7, a8
403807d7:	c08740        	sub	a8, a7, a4
403807da:	146182        	s32i	a8, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
403807dd:	02a8      	l32i.n	a10, a2, 0
403807df:	0a88      	l32i.n	a8, a10, 0
403807e1:	b888      	l32i.n	a8, a8, 44
403807e3:	20b660        	or	a11, a6, a6
403807e6:	0008e0        	callx8	a8
403807e9:	1561a2        	s32i	a10, a1, 84
        memcpy(buffer, temp_buffer + left_off, data_len);
403807ec:	1421c2        	l32i	a12, a1, 80
403807ef:	162192        	l32i	a9, a1, 88
403807f2:	b69a      	add.n	a11, a6, a9
403807f4:	03ad      	mov.n	a10, a3
403807f6:	cf3781        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403807f9:	0008e0        	callx8	a8
        buffer = (void *)((intptr_t)buffer + data_len);
403807fc:	142182        	l32i	a8, a1, 80
403807ff:	338a      	add.n	a3, a3, a8
        length = length - data_len;
40380801:	c04470        	sub	a4, a4, a7
40380804:	554a      	add.n	a5, a5, a4
        address += data_len;
40380806:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
40380808:	180c      	movi.n	a8, 1
4038080a:	838550        	moveqz	a8, a5, a5
4038080d:	152192        	l32i	a9, a1, 84
40380810:	19cc      	bnez.n	a9, 40380815 <spi_flash_chip_generic_read+0xa9>
40380812:	f8f856        	bnez	a8, 403807a5 <spi_flash_chip_generic_read+0x39>
}
40380815:	152122        	l32i	a2, a1, 84
40380818:	f01d      	retw.n
	...

4038081c <spi_flash_chip_generic_write>:
{
4038081c:	010136        	entry	a1, 128
4038081f:	026d      	mov.n	a6, a2
40380821:	146132        	s32i	a3, a1, 80
    const uint32_t page_size = chip->chip_drv->page_size;
40380824:	1288      	l32i.n	a8, a2, 4
40380826:	132882        	l32i	a8, a8, 76
40380829:	156182        	s32i	a8, a1, 84
    esp_err_t err = ESP_OK;
4038082c:	0a0c      	movi.n	a10, 0
    while (err == ESP_OK && length > 0) {
4038082e:	001f06        	j	403808ae <spi_flash_chip_generic_write+0x92>
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
40380831:	214b      	addi.n	a2, a1, 4
40380833:	0c4c      	movi.n	a12, 64
40380835:	ffa0b2        	movi	a11, 255
40380838:	02ad      	mov.n	a10, a2
4038083a:	cf1581        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4038083d:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
40380840:	06a8      	l32i.n	a10, a6, 0
40380842:	0a88      	l32i.n	a8, a10, 0
40380844:	a888      	l32i.n	a8, a8, 40
40380846:	1521e2        	l32i	a14, a1, 84
40380849:	01dd      	mov.n	a13, a1
4038084b:	05cd      	mov.n	a12, a5
4038084d:	04bd      	mov.n	a11, a4
4038084f:	0008e0        	callx8	a8
40380852:	0a9d      	mov.n	a9, a10
40380854:	1661a2        	s32i	a10, a1, 88
        uint32_t left_off = address - align_address;
40380857:	0188      	l32i.n	a8, a1, 0
40380859:	c0a480        	sub	a10, a4, a8
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
4038085c:	745a      	add.n	a7, a4, a5
4038085e:	889a      	add.n	a8, a8, a9
40380860:	637780        	minu	a7, a7, a8
40380863:	c08740        	sub	a8, a7, a4
40380866:	176182        	s32i	a8, a1, 92
        memcpy(temp_buffer + left_off, buffer, write_len);
40380869:	08cd      	mov.n	a12, a8
4038086b:	1421b2        	l32i	a11, a1, 80
4038086e:	a2aa      	add.n	a10, a2, a10
40380870:	cf1981        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
40380873:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
40380876:	1688      	l32i.n	a8, a6, 4
40380878:	b888      	l32i.n	a8, a8, 44
4038087a:	0b0c      	movi.n	a11, 0
4038087c:	06ad      	mov.n	a10, a6
4038087e:	0008e0        	callx8	a8
        if (err == ESP_OK && length > 0) {
40380881:	40fa80        	nsau	a8, a10
40380884:	418580        	srli	a8, a8, 5
40380887:	230837        	bnone	a8, a3, 403808ae <spi_flash_chip_generic_write+0x92>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
4038088a:	1688      	l32i.n	a8, a6, 4
4038088c:	122882        	l32i	a8, a8, 72
4038088f:	1621d2        	l32i	a13, a1, 88
40380892:	01c8      	l32i.n	a12, a1, 0
40380894:	20b220        	or	a11, a2, a2
40380897:	06ad      	mov.n	a10, a6
40380899:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + write_len);
4038089c:	142182        	l32i	a8, a1, 80
4038089f:	172192        	l32i	a9, a1, 92
403808a2:	889a      	add.n	a8, a8, a9
403808a4:	146182        	s32i	a8, a1, 80
            length -= write_len;
403808a7:	c04470        	sub	a4, a4, a7
403808aa:	554a      	add.n	a5, a5, a4
            address += write_len;
403808ac:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
403808ae:	130c      	movi.n	a3, 1
403808b0:	833550        	moveqz	a3, a5, a5
403808b3:	1acc      	bnez.n	a10, 403808b8 <spi_flash_chip_generic_write+0x9c>
403808b5:	f78356        	bnez	a3, 40380831 <spi_flash_chip_generic_write+0x15>
}
403808b8:	0a2d      	mov.n	a2, a10
403808ba:	f01d      	retw.n

403808bc <spi_flash_chip_generic_get_write_protect>:
{
403808bc:	006136        	entry	a1, 48
403808bf:	02ad      	mov.n	a10, a2
    assert(out_write_protect!=NULL);
403808c1:	d3cc      	bnez.n	a3, 403808d2 <spi_flash_chip_generic_get_write_protect+0x16>
403808c3:	d209d1        	l32r	a13, 403750e8 <_iram_text_start+0xce4> (3fc93bbc <__FUNCTION__$0+0x424>)
403808c6:	d209c1        	l32r	a12, 403750ec <_iram_text_start+0xce8> (3fc9443c <__func__$0>)
403808c9:	4aa1b2        	movi	a11, 0x14a
403808cc:	d209a1        	l32r	a10, 403750f0 <_iram_text_start+0xcec> (3fc93bef <__FUNCTION__$0+0x457>)
403808cf:	ff4825        	call8	4037fd50 <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
403808d2:	1288      	l32i.n	a8, a2, 4
403808d4:	192882        	l32i	a8, a8, 100
403808d7:	01cd      	mov.n	a12, a1
403808d9:	1b0c      	movi.n	a11, 1
403808db:	0008e0        	callx8	a8
403808de:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
403808e0:	eacc      	bnez.n	a10, 403808f2 <spi_flash_chip_generic_get_write_protect+0x36>
    *out_write_protect = ((status & SR_WREN) == 0);
403808e2:	280c      	movi.n	a8, 2
403808e4:	0198      	l32i.n	a9, a1, 0
403808e6:	108890        	and	a8, a8, a9
403808e9:	40f880        	nsau	a8, a8
403808ec:	418580        	srli	a8, a8, 5
403808ef:	004382        	s8i	a8, a3, 0
}
403808f2:	f01d      	retw.n

403808f4 <spi_flash_chip_generic_yield>:
{
403808f4:	006136        	entry	a1, 48
403808f7:	027d      	mov.n	a7, a2
    uint32_t flags = wip? 1: 0; //check_yield() and yield() impls should not issue suspend/resume if this flag is zero
403808f9:	1b0c      	movi.n	a11, 1
403808fb:	83b330        	moveqz	a11, a3, a3
    if (chip->os_func->check_yield) {
403808fe:	2288      	l32i.n	a8, a2, 8
40380900:	6888      	l32i.n	a8, a8, 24
40380902:	08bc      	beqz.n	a8, 40380936 <spi_flash_chip_generic_yield+0x42>
        err = chip->os_func->check_yield(chip->os_func_data, flags, &request);
40380904:	c14b      	addi.n	a12, a1, 4
40380906:	0322a2        	l32i	a10, a2, 12
40380909:	0008e0        	callx8	a8
4038090c:	0a2d      	mov.n	a2, a10
        if (err == ESP_OK) {
4038090e:	3adc      	bnez.n	a10, 40380925 <spi_flash_chip_generic_yield+0x31>
            if (err == ESP_OK && (request & SPI_FLASH_YIELD_REQ_YIELD) != 0) {
40380910:	1188      	l32i.n	a8, a1, 4
40380912:	226807        	bbci	a8, 0, 40380938 <spi_flash_chip_generic_yield+0x44>
                err = chip->os_func->yield(chip->os_func_data, &status);
40380915:	2788      	l32i.n	a8, a7, 8
40380917:	7888      	l32i.n	a8, a8, 28
40380919:	01bd      	mov.n	a11, a1
4038091b:	37a8      	l32i.n	a10, a7, 12
4038091d:	0008e0        	callx8	a8
40380920:	0a2d      	mov.n	a2, a10
40380922:	000486        	j	40380938 <spi_flash_chip_generic_yield+0x44>
        } else if (err == ESP_ERR_TIMEOUT) {
40380925:	07a182        	movi	a8, 0x107
40380928:	021a87        	beq	a10, a8, 4038092e <spi_flash_chip_generic_yield+0x3a>
            abort();
4038092b:	ff36a5        	call8	4037fc94 <abort>
            err = ESP_OK;
4038092e:	020c      	movi.n	a2, 0
40380930:	000106        	j	40380938 <spi_flash_chip_generic_yield+0x44>
40380933:	000000        	ill
    esp_err_t err = ESP_OK;
40380936:	020c      	movi.n	a2, 0
}
40380938:	f01d      	retw.n
	...

4038093c <spi_flash_chip_generic_suspend_cmd_conf>:
}

#endif // !CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_generic_suspend_cmd_conf(esp_flash_t *chip)
{
4038093c:	006136        	entry	a1, 48
    // chips which support auto-suspend
    if (chip->chip_id >> 16 != 0x20 && chip->chip_id >> 16 != 0xa1 && chip->chip_id >> 16 != 0x46) {
4038093f:	0d12a2        	l16ui	a10, a2, 26
40380942:	e0ca92        	addi	a9, a10, -32
40380945:	180c      	movi.n	a8, 1
40380947:	0b0c      	movi.n	a11, 0
40380949:	0bcd      	mov.n	a12, a11
4038094b:	93c890        	movnez	a12, a8, a9
4038094e:	5faf92        	movi	a9, -161
40380951:	9a9a      	add.n	a9, a10, a9
40380953:	838b90        	moveqz	a8, a11, a9
40380956:	220c87        	bnone	a12, a8, 4038097c <spi_flash_chip_generic_suspend_cmd_conf+0x40>
40380959:	684c      	movi.n	a8, 70
4038095b:	1d1a87        	beq	a10, a8, 4038097c <spi_flash_chip_generic_suspend_cmd_conf+0x40>
4038095e:	cec381        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40380961:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "The flash you use doesn't support auto suspend, only \'XMC\' is supported");
40380963:	f88c      	beqz.n	a8, 40380976 <spi_flash_chip_generic_suspend_cmd_conf+0x3a>
40380965:	ff27a5        	call8	4037fbe0 <esp_log_timestamp>
40380968:	d1dec1        	l32r	a12, 403750e0 <_iram_text_start+0xcdc> (3fc944ec <TAG>)
4038096b:	0abd      	mov.n	a11, a10
4038096d:	d1e1a1        	l32r	a10, 403750f4 <_iram_text_start+0xcf0> (3fc93c08 <__FUNCTION__$0+0x470>)
40380970:	ced181        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40380973:	0008e0        	callx8	a8
        return ESP_ERR_NOT_SUPPORTED;
40380976:	06a122        	movi	a2, 0x106
40380979:	000bc6        	j	403809ac <spi_flash_chip_generic_suspend_cmd_conf+0x70>
    }
    spi_flash_sus_cmd_conf sus_conf = {
4038097c:	8c0c      	movi.n	a12, 8
4038097e:	0b0c      	movi.n	a11, 0
40380980:	01ad      	mov.n	a10, a1
40380982:	cec381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380985:	0008e0        	callx8	a8
40380988:	80a082        	movi	a8, 128
4038098b:	0189      	s32i.n	a8, a1, 0
4038098d:	583c      	movi.n	a8, 53
4038098f:	044182        	s8i	a8, a1, 4
40380992:	75a082        	movi	a8, 117
40380995:	054182        	s8i	a8, a1, 5
40380998:	7aa082        	movi	a8, 122
4038099b:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
4038099e:	02a8      	l32i.n	a10, a2, 0
403809a0:	0a88      	l32i.n	a8, a10, 0
403809a2:	152882        	l32i	a8, a8, 84
403809a5:	01bd      	mov.n	a11, a1
403809a7:	0008e0        	callx8	a8
403809aa:	0a2d      	mov.n	a2, a10
}
403809ac:	f01d      	retw.n
	...

403809b0 <spi_flash_chip_generic_read_unique_id>:
{
403809b0:	00a136        	entry	a1, 80
    uint64_t unique_id_buf = 0;
403809b3:	080c      	movi.n	a8, 0
403809b5:	0189      	s32i.n	a8, a1, 0
403809b7:	1189      	s32i.n	a8, a1, 4
    spi_flash_trans_t transfer = {
403809b9:	718b      	addi.n	a7, a1, 8
403809bb:	cc1c      	movi.n	a12, 28
403809bd:	20b880        	or	a11, a8, a8
403809c0:	07ad      	mov.n	a10, a7
403809c2:	ceb381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403809c5:	0008e0        	callx8	a8
403809c8:	880c      	movi.n	a8, 8
403809ca:	0a4182        	s8i	a8, a1, 10
403809cd:	5119      	s32i.n	a1, a1, 20
403809cf:	b84c      	movi.n	a8, 75
403809d1:	0e5182        	s16i	a8, a1, 28
403809d4:	082c      	movi.n	a8, 32
403809d6:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &transfer);
403809d9:	02a8      	l32i.n	a10, a2, 0
403809db:	0a88      	l32i.n	a8, a10, 0
403809dd:	1888      	l32i.n	a8, a8, 4
403809df:	07bd      	mov.n	a11, a7
403809e1:	0008e0        	callx8	a8
403809e4:	0a2d      	mov.n	a2, a10
    if (unique_id_buf == 0 || unique_id_buf == UINT64_MAX) {
403809e6:	01a8      	l32i.n	a10, a1, 0
403809e8:	11b8      	l32i.n	a11, a1, 4
403809ea:	fc7c      	movi.n	a12, -1
403809ec:	8bca      	add.n	a8, a11, a12
403809ee:	9aca      	add.n	a9, a10, a12
403809f0:	01b9c7        	bgeu	a9, a12, 403809f5 <spi_flash_chip_generic_read_unique_id+0x45>
403809f3:	0b8d      	mov.n	a8, a11
403809f5:	2b0866        	bnei	a8, -1, 40380a24 <spi_flash_chip_generic_read_unique_id+0x74>
403809f8:	d87c      	movi.n	a8, -3
403809fa:	26b897        	bgeu	a8, a9, 40380a24 <spi_flash_chip_generic_read_unique_id+0x74>
403809fd:	ce9b81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40380a00:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "No response from device when trying to retrieve Unique ID\n");
40380a02:	010816        	beqz	a8, 40380a16 <spi_flash_chip_generic_read_unique_id+0x66>
40380a05:	ff1da5        	call8	4037fbe0 <esp_log_timestamp>
40380a08:	d1b6c1        	l32r	a12, 403750e0 <_iram_text_start+0xcdc> (3fc944ec <TAG>)
40380a0b:	0abd      	mov.n	a11, a10
40380a0d:	d1baa1        	l32r	a10, 403750f8 <_iram_text_start+0xcf4> (3fc93c60 <__FUNCTION__$0+0x4c8>)
40380a10:	cea981        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40380a13:	0008e0        	callx8	a8
        *flash_unique_id = unique_id_buf;
40380a16:	0188      	l32i.n	a8, a1, 0
40380a18:	1198      	l32i.n	a9, a1, 4
40380a1a:	0389      	s32i.n	a8, a3, 0
40380a1c:	1399      	s32i.n	a9, a3, 4
        return ESP_ERR_NOT_SUPPORTED;
40380a1e:	06a122        	movi	a2, 0x106
40380a21:	000246        	j	40380a2e <spi_flash_chip_generic_read_unique_id+0x7e>
    *flash_unique_id = __builtin_bswap64(unique_id_buf);
40380a24:	d1b681        	l32r	a8, 403750fc <_iram_text_start+0xcf8> (400021cc <__bswapdi2>)
40380a27:	0008e0        	callx8	a8
40380a2a:	03a9      	s32i.n	a10, a3, 0
40380a2c:	13b9      	s32i.n	a11, a3, 4
}
40380a2e:	f01d      	retw.n

40380a30 <spi_flash_common_read_status_8b_rdsr2>:
{
40380a30:	004136        	entry	a1, 32
40380a33:	20a220        	or	a10, a2, a2
40380a36:	20d330        	or	a13, a3, a3
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, out_sr);
40380a39:	08a0c2        	movi	a12, 8
40380a3c:	5b3c      	movi.n	a11, 53
40380a3e:	ffc7a5        	call8	403806b8 <spi_flash_common_read_qe_sr>
}
40380a41:	0a2d      	mov.n	a2, a10
40380a43:	f01d      	retw.n
40380a45:	000000        	ill

40380a48 <spi_flash_chip_generic_get_io_mode>:
{
40380a48:	006136        	entry	a1, 48
40380a4b:	20a220        	or	a10, a2, a2
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
40380a4e:	20b110        	or	a11, a1, a1
40380a51:	fffde5        	call8	40380a30 <spi_flash_common_read_status_8b_rdsr2>
40380a54:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380a57:	9acc      	bnez.n	a10, 40380a64 <spi_flash_chip_generic_get_io_mode+0x1c>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380a59:	0188      	l32i.n	a8, a1, 0
40380a5b:	888a      	add.n	a8, a8, a8
40380a5d:	490c      	movi.n	a9, 4
40380a5f:	108890        	and	a8, a8, a9
40380a62:	0389      	s32i.n	a8, a3, 0
}
40380a64:	f01d      	retw.n
	...

40380a68 <spi_flash_common_read_status_8b_rdsr>:
{
40380a68:	004136        	entry	a1, 32
40380a6b:	20a220        	or	a10, a2, a2
40380a6e:	20d330        	or	a13, a3, a3
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, out_sr);
40380a71:	08a0c2        	movi	a12, 8
40380a74:	5b0c      	movi.n	a11, 5
40380a76:	ffc425        	call8	403806b8 <spi_flash_common_read_qe_sr>
}
40380a79:	0a2d      	mov.n	a2, a10
40380a7b:	f01d      	retw.n
40380a7d:	000000        	ill

40380a80 <spi_flash_common_write_status_8b_wrsr>:
{
40380a80:	004136        	entry	a1, 32
40380a83:	20a220        	or	a10, a2, a2
40380a86:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 8, sr);
40380a89:	08a0c2        	movi	a12, 8
40380a8c:	1b0c      	movi.n	a11, 1
40380a8e:	ffc5e5        	call8	403806ec <spi_flash_common_write_qe_sr>
}
40380a91:	0a2d      	mov.n	a2, a10
40380a93:	f01d      	retw.n
40380a95:	000000        	ill

40380a98 <spi_flash_common_write_status_8b_wrsr2>:
{
40380a98:	004136        	entry	a1, 32
40380a9b:	20a220        	or	a10, a2, a2
40380a9e:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR2, 8, sr);
40380aa1:	08a0c2        	movi	a12, 8
40380aa4:	1b3c      	movi.n	a11, 49
40380aa6:	ffc465        	call8	403806ec <spi_flash_common_write_qe_sr>
}
40380aa9:	0a2d      	mov.n	a2, a10
40380aab:	f01d      	retw.n
40380aad:	000000        	ill

40380ab0 <spi_flash_chip_generic_set_io_mode>:
{
40380ab0:	004136        	entry	a1, 32
40380ab3:	20a220        	or	a10, a2, a2
    return spi_flash_common_set_io_mode(chip,
40380ab6:	00a2d2        	movi	a13, 0x200
40380ab9:	d182c1        	l32r	a12, 403750c4 <_iram_text_start+0xcc0> (4038071c <spi_flash_common_read_status_16b_rdsr_rdsr2>)
40380abc:	d183b1        	l32r	a11, 403750c8 <_iram_text_start+0xcc4> (40380754 <spi_flash_common_write_status_16b_wrsr>)
40380abf:	0032a5        	call8	40380de8 <spi_flash_common_set_io_mode>
}
40380ac2:	202aa0        	or	a2, a10, a10
40380ac5:	000090        	retw

40380ac8 <spi_flash_chip_generic_probe>:
{
40380ac8:	004136        	entry	a1, 32
}
40380acb:	020c      	movi.n	a2, 0
40380acd:	f01d      	retw.n
	...

40380ad0 <spi_flash_chip_generic_erase_chip>:
{
40380ad0:	004136        	entry	a1, 32
40380ad3:	027d      	mov.n	a7, a2
    err = chip->chip_drv->set_chip_write_protect(chip, false);
40380ad5:	1288      	l32i.n	a8, a2, 4
40380ad7:	b888      	l32i.n	a8, a8, 44
40380ad9:	0b0c      	movi.n	a11, 0
40380adb:	02ad      	mov.n	a10, a2
40380add:	0008e0        	callx8	a8
40380ae0:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380ae2:	eacc      	bnez.n	a10, 40380af4 <spi_flash_chip_generic_erase_chip+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380ae4:	1788      	l32i.n	a8, a7, 4
40380ae6:	152892        	l32i	a9, a8, 84
40380ae9:	1888      	l32i.n	a8, a8, 4
40380aeb:	08b8      	l32i.n	a11, a8, 0
40380aed:	07ad      	mov.n	a10, a7
40380aef:	0009e0        	callx8	a9
40380af2:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380af4:	40f290        	nsau	a9, a2
40380af7:	419590        	srli	a9, a9, 5
40380afa:	faae82        	movi	a8, 0xfffffefa
40380afd:	828a      	add.n	a8, a2, a8
40380aff:	40f880        	nsau	a8, a8
40380b02:	418580        	srli	a8, a8, 5
40380b05:	209980        	or	a9, a9, a8
40380b08:	050916        	beqz	a9, 40380b5c <spi_flash_chip_generic_erase_chip+0x8c>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380b0b:	2788      	l32i.n	a8, a7, 8
40380b0d:	9888      	l32i.n	a8, a8, 36
40380b0f:	388c      	beqz.n	a8, 40380b16 <spi_flash_chip_generic_erase_chip+0x46>
40380b11:	1a0c      	movi.n	a10, 1
40380b13:	0008e0        	callx8	a8
        chip->host->driver->erase_chip(chip->host);
40380b16:	07a8      	l32i.n	a10, a7, 0
40380b18:	002a82        	l32i	a8, a10, 0
40380b1b:	3888      	l32i.n	a8, a8, 12
40380b1d:	0008e0        	callx8	a8
        chip->busy = 1;
40380b20:	7788      	l32i.n	a8, a7, 28
40380b22:	190c      	movi.n	a9, 1
40380b24:	208890        	or	a8, a8, a9
40380b27:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
40380b29:	1788      	l32i.n	a8, a7, 4
40380b2b:	152892        	l32i	a9, a8, 84
40380b2e:	012882        	l32i	a8, a8, 4
40380b31:	0128b2        	l32i	a11, a8, 4
40380b34:	20a770        	or	a10, a7, a7
40380b37:	0009e0        	callx8	a9
40380b3a:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380b3c:	2788      	l32i.n	a8, a7, 8
40380b3e:	9888      	l32i.n	a8, a8, 36
40380b40:	005816        	beqz	a8, 40380b49 <spi_flash_chip_generic_erase_chip+0x79>
40380b43:	00a0a2        	movi	a10, 0
40380b46:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380b49:	06a182        	movi	a8, 0x106
40380b4c:	0c9287        	bne	a2, a8, 40380b5c <spi_flash_chip_generic_erase_chip+0x8c>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380b4f:	1788      	l32i.n	a8, a7, 4
40380b51:	b888      	l32i.n	a8, a8, 44
40380b53:	1b0c      	movi.n	a11, 1
40380b55:	07ad      	mov.n	a10, a7
40380b57:	0008e0        	callx8	a8
40380b5a:	0a2d      	mov.n	a2, a10
}
40380b5c:	f01d      	retw.n
	...

40380b60 <spi_flash_chip_generic_erase_sector>:
{
40380b60:	004136        	entry	a1, 32
40380b63:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40380b65:	1288      	l32i.n	a8, a2, 4
40380b67:	b888      	l32i.n	a8, a8, 44
40380b69:	0b0c      	movi.n	a11, 0
40380b6b:	02ad      	mov.n	a10, a2
40380b6d:	0008e0        	callx8	a8
40380b70:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380b72:	eacc      	bnez.n	a10, 40380b84 <spi_flash_chip_generic_erase_sector+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380b74:	1788      	l32i.n	a8, a7, 4
40380b76:	152892        	l32i	a9, a8, 84
40380b79:	1888      	l32i.n	a8, a8, 4
40380b7b:	08b8      	l32i.n	a11, a8, 0
40380b7d:	07ad      	mov.n	a10, a7
40380b7f:	0009e0        	callx8	a9
40380b82:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380b84:	40f290        	nsau	a9, a2
40380b87:	419590        	srli	a9, a9, 5
40380b8a:	faae82        	movi	a8, 0xfffffefa
40380b8d:	828a      	add.n	a8, a2, a8
40380b8f:	40f880        	nsau	a8, a8
40380b92:	418580        	srli	a8, a8, 5
40380b95:	209980        	or	a9, a9, a8
40380b98:	04c916        	beqz	a9, 40380be8 <spi_flash_chip_generic_erase_sector+0x88>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380b9b:	2788      	l32i.n	a8, a7, 8
40380b9d:	9888      	l32i.n	a8, a8, 36
40380b9f:	388c      	beqz.n	a8, 40380ba6 <spi_flash_chip_generic_erase_sector+0x46>
40380ba1:	1a0c      	movi.n	a10, 1
40380ba3:	0008e0        	callx8	a8
        chip->host->driver->erase_sector(chip->host, start_address);
40380ba6:	07a8      	l32i.n	a10, a7, 0
40380ba8:	0a88      	l32i.n	a8, a10, 0
40380baa:	4888      	l32i.n	a8, a8, 16
40380bac:	03bd      	mov.n	a11, a3
40380bae:	0008e0        	callx8	a8
        chip->busy = 1;
40380bb1:	7788      	l32i.n	a8, a7, 28
40380bb3:	190c      	movi.n	a9, 1
40380bb5:	208890        	or	a8, a8, a9
40380bb8:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
40380bba:	1788      	l32i.n	a8, a7, 4
40380bbc:	152892        	l32i	a9, a8, 84
40380bbf:	1888      	l32i.n	a8, a8, 4
40380bc1:	38b8      	l32i.n	a11, a8, 12
40380bc3:	07ad      	mov.n	a10, a7
40380bc5:	0009e0        	callx8	a9
40380bc8:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380bca:	2788      	l32i.n	a8, a7, 8
40380bcc:	9888      	l32i.n	a8, a8, 36
40380bce:	388c      	beqz.n	a8, 40380bd5 <spi_flash_chip_generic_erase_sector+0x75>
40380bd0:	0a0c      	movi.n	a10, 0
40380bd2:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380bd5:	06a182        	movi	a8, 0x106
40380bd8:	0c9287        	bne	a2, a8, 40380be8 <spi_flash_chip_generic_erase_sector+0x88>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380bdb:	1788      	l32i.n	a8, a7, 4
40380bdd:	b888      	l32i.n	a8, a8, 44
40380bdf:	1b0c      	movi.n	a11, 1
40380be1:	07ad      	mov.n	a10, a7
40380be3:	0008e0        	callx8	a8
40380be6:	0a2d      	mov.n	a2, a10
}
40380be8:	f01d      	retw.n
	...

40380bec <spi_flash_chip_generic_erase_block>:
{
40380bec:	004136        	entry	a1, 32
40380bef:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40380bf1:	1288      	l32i.n	a8, a2, 4
40380bf3:	b888      	l32i.n	a8, a8, 44
40380bf5:	0b0c      	movi.n	a11, 0
40380bf7:	02ad      	mov.n	a10, a2
40380bf9:	0008e0        	callx8	a8
40380bfc:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380bfe:	eacc      	bnez.n	a10, 40380c10 <spi_flash_chip_generic_erase_block+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380c00:	1788      	l32i.n	a8, a7, 4
40380c02:	152892        	l32i	a9, a8, 84
40380c05:	1888      	l32i.n	a8, a8, 4
40380c07:	08b8      	l32i.n	a11, a8, 0
40380c09:	07ad      	mov.n	a10, a7
40380c0b:	0009e0        	callx8	a9
40380c0e:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380c10:	40f290        	nsau	a9, a2
40380c13:	419590        	srli	a9, a9, 5
40380c16:	faae82        	movi	a8, 0xfffffefa
40380c19:	828a      	add.n	a8, a2, a8
40380c1b:	40f880        	nsau	a8, a8
40380c1e:	418580        	srli	a8, a8, 5
40380c21:	209980        	or	a9, a9, a8
40380c24:	04c916        	beqz	a9, 40380c74 <spi_flash_chip_generic_erase_block+0x88>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380c27:	2788      	l32i.n	a8, a7, 8
40380c29:	9888      	l32i.n	a8, a8, 36
40380c2b:	388c      	beqz.n	a8, 40380c32 <spi_flash_chip_generic_erase_block+0x46>
40380c2d:	1a0c      	movi.n	a10, 1
40380c2f:	0008e0        	callx8	a8
        chip->host->driver->erase_block(chip->host, start_address);
40380c32:	07a8      	l32i.n	a10, a7, 0
40380c34:	0a88      	l32i.n	a8, a10, 0
40380c36:	5888      	l32i.n	a8, a8, 20
40380c38:	03bd      	mov.n	a11, a3
40380c3a:	0008e0        	callx8	a8
        chip->busy = 1;
40380c3d:	7788      	l32i.n	a8, a7, 28
40380c3f:	190c      	movi.n	a9, 1
40380c41:	208890        	or	a8, a8, a9
40380c44:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
40380c46:	1788      	l32i.n	a8, a7, 4
40380c48:	152892        	l32i	a9, a8, 84
40380c4b:	1888      	l32i.n	a8, a8, 4
40380c4d:	28b8      	l32i.n	a11, a8, 8
40380c4f:	07ad      	mov.n	a10, a7
40380c51:	0009e0        	callx8	a9
40380c54:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380c56:	2788      	l32i.n	a8, a7, 8
40380c58:	9888      	l32i.n	a8, a8, 36
40380c5a:	388c      	beqz.n	a8, 40380c61 <spi_flash_chip_generic_erase_block+0x75>
40380c5c:	0a0c      	movi.n	a10, 0
40380c5e:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380c61:	06a182        	movi	a8, 0x106
40380c64:	0c9287        	bne	a2, a8, 40380c74 <spi_flash_chip_generic_erase_block+0x88>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380c67:	1788      	l32i.n	a8, a7, 4
40380c69:	b888      	l32i.n	a8, a8, 44
40380c6b:	1b0c      	movi.n	a11, 1
40380c6d:	07ad      	mov.n	a10, a7
40380c6f:	0008e0        	callx8	a8
40380c72:	0a2d      	mov.n	a2, a10
}
40380c74:	f01d      	retw.n
	...

40380c78 <spi_flash_chip_generic_page_program>:
{
40380c78:	004136        	entry	a1, 32
40380c7b:	027d      	mov.n	a7, a2
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380c7d:	1288      	l32i.n	a8, a2, 4
40380c7f:	152892        	l32i	a9, a8, 84
40380c82:	1888      	l32i.n	a8, a8, 4
40380c84:	0028b2        	l32i	a11, a8, 0
40380c87:	02ad      	mov.n	a10, a2
40380c89:	0009e0        	callx8	a9
40380c8c:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380c8e:	40fa90        	nsau	a9, a10
40380c91:	419590        	srli	a9, a9, 5
40380c94:	faae82        	movi	a8, 0xfffffefa
40380c97:	8a8a      	add.n	a8, a10, a8
40380c99:	40f880        	nsau	a8, a8
40380c9c:	418580        	srli	a8, a8, 5
40380c9f:	209980        	or	a9, a9, a8
40380ca2:	c9bc      	beqz.n	a9, 40380ce2 <spi_flash_chip_generic_page_program+0x6a>
        chip->host->driver->program_page(chip->host, buffer, address, length);
40380ca4:	07a8      	l32i.n	a10, a7, 0
40380ca6:	0a88      	l32i.n	a8, a10, 0
40380ca8:	8888      	l32i.n	a8, a8, 32
40380caa:	05dd      	mov.n	a13, a5
40380cac:	20c440        	or	a12, a4, a4
40380caf:	03bd      	mov.n	a11, a3
40380cb1:	0008e0        	callx8	a8
        chip->busy = 1;
40380cb4:	7788      	l32i.n	a8, a7, 28
40380cb6:	190c      	movi.n	a9, 1
40380cb8:	208890        	or	a8, a8, a9
40380cbb:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40380cbd:	1788      	l32i.n	a8, a7, 4
40380cbf:	152892        	l32i	a9, a8, 84
40380cc2:	1888      	l32i.n	a8, a8, 4
40380cc4:	0428b2        	l32i	a11, a8, 16
40380cc7:	07ad      	mov.n	a10, a7
40380cc9:	0009e0        	callx8	a9
40380ccc:	0a2d      	mov.n	a2, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380cce:	06a182        	movi	a8, 0x106
40380cd1:	0d9a87        	bne	a10, a8, 40380ce2 <spi_flash_chip_generic_page_program+0x6a>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380cd4:	1788      	l32i.n	a8, a7, 4
40380cd6:	b888      	l32i.n	a8, a8, 44
40380cd8:	01a0b2        	movi	a11, 1
40380cdb:	07ad      	mov.n	a10, a7
40380cdd:	0008e0        	callx8	a8
40380ce0:	0a2d      	mov.n	a2, a10
}
40380ce2:	f01d      	retw.n

40380ce4 <spi_flash_chip_generic_set_write_protect>:
{
40380ce4:	006136        	entry	a1, 48
40380ce7:	743030        	extui	a3, a3, 0, 8
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380cea:	1288      	l32i.n	a8, a2, 4
40380cec:	152892        	l32i	a9, a8, 84
40380cef:	1888      	l32i.n	a8, a8, 4
40380cf1:	08b8      	l32i.n	a11, a8, 0
40380cf3:	02ad      	mov.n	a10, a2
40380cf5:	0009e0        	callx8	a9
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380cf8:	40fa90        	nsau	a9, a10
40380cfb:	419590        	srli	a9, a9, 5
40380cfe:	faae82        	movi	a8, 0xfffffefa
40380d01:	8a8a      	add.n	a8, a10, a8
40380d03:	40f880        	nsau	a8, a8
40380d06:	418580        	srli	a8, a8, 5
40380d09:	209980        	or	a9, a9, a8
40380d0c:	998c      	beqz.n	a9, 40380d19 <spi_flash_chip_generic_set_write_protect+0x35>
        chip->host->driver->set_write_protect(chip->host, write_protect);
40380d0e:	02a8      	l32i.n	a10, a2, 0
40380d10:	0a88      	l32i.n	a8, a10, 0
40380d12:	7888      	l32i.n	a8, a8, 28
40380d14:	03bd      	mov.n	a11, a3
40380d16:	0008e0        	callx8	a8
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
40380d19:	1288      	l32i.n	a8, a2, 4
40380d1b:	a888      	l32i.n	a8, a8, 40
40380d1d:	01bd      	mov.n	a11, a1
40380d1f:	02ad      	mov.n	a10, a2
40380d21:	0008e0        	callx8	a8
40380d24:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
40380d26:	7acc      	bnez.n	a10, 40380d31 <spi_flash_chip_generic_set_write_protect+0x4d>
40380d28:	000182        	l8ui	a8, a1, 0
40380d2b:	021837        	beq	a8, a3, 40380d31 <spi_flash_chip_generic_set_write_protect+0x4d>
        err = ESP_ERR_NOT_FOUND;
40380d2e:	05a122        	movi	a2, 0x105
}
40380d31:	f01d      	retw.n
	...

40380d34 <spi_flash_chip_generic_read_reg>:
{
40380d34:	004136        	entry	a1, 32
40380d37:	04bd      	mov.n	a11, a4
    return chip->host->driver->read_status(chip->host, (uint8_t*)out_reg);
40380d39:	02a8      	l32i.n	a10, a2, 0
40380d3b:	0a88      	l32i.n	a8, a10, 0
40380d3d:	6888      	l32i.n	a8, a8, 24
40380d3f:	0008e0        	callx8	a8
}
40380d42:	0a2d      	mov.n	a2, a10
40380d44:	f01d      	retw.n
	...

40380d48 <spi_flash_chip_generic_wait_idle>:
{
40380d48:	006136        	entry	a1, 48
    if (timeout_us == ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT) {
40380d4b:	040326        	beqi	a3, -1, 40380d53 <spi_flash_chip_generic_wait_idle+0xb>
40380d4e:	037d      	mov.n	a7, a3
40380d50:	000046        	j	40380d55 <spi_flash_chip_generic_wait_idle+0xd>
        timeout_us = 0;// In order to go into while
40380d53:	070c      	movi.n	a7, 0
    timeout_us++; // allow at least one pass before timeout, last one has no sleep cycle
40380d55:	771b      	addi.n	a7, a7, 1
    while (timeout_us > 0) {
40380d57:	001c86        	j	40380dcd <spi_flash_chip_generic_wait_idle+0x85>
40380d5a:	000000        	ill
            if (timeout_us > 1) {
40380d5d:	1327b6        	bltui	a7, 2, 40380d74 <spi_flash_chip_generic_wait_idle+0x2c>
                int delay = MIN(HOST_DELAY_INTERVAL_US, timeout_us);
40380d60:	150c      	movi.n	a5, 1
40380d62:	635750        	minu	a5, a7, a5
                chip->os_func->delay_us(chip->os_func_data, delay);
40380d65:	2288      	l32i.n	a8, a2, 8
40380d67:	3888      	l32i.n	a8, a8, 12
40380d69:	05bd      	mov.n	a11, a5
40380d6b:	0322a2        	l32i	a10, a2, 12
40380d6e:	0008e0        	callx8	a8
                timeout_us -= delay;
40380d71:	c07750        	sub	a7, a7, a5
        while (!chip->host->driver->host_status(chip->host) && timeout_us > 0) {
40380d74:	02a8      	l32i.n	a10, a2, 0
40380d76:	0a88      	l32i.n	a8, a10, 0
40380d78:	e888      	l32i.n	a8, a8, 56
40380d7a:	0008e0        	callx8	a8
40380d7d:	1acc      	bnez.n	a10, 40380d82 <spi_flash_chip_generic_wait_idle+0x3a>
40380d7f:	fda756        	bnez	a7, 40380d5d <spi_flash_chip_generic_wait_idle+0x15>
        esp_err_t err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &read);
40380d82:	1288      	l32i.n	a8, a2, 4
40380d84:	192882        	l32i	a8, a8, 100
40380d87:	01cd      	mov.n	a12, a1
40380d89:	1b0c      	movi.n	a11, 1
40380d8b:	02ad      	mov.n	a10, a2
40380d8d:	0008e0        	callx8	a8
        if (err != ESP_OK) {
40380d90:	048a56        	bnez	a10, 40380ddc <spi_flash_chip_generic_wait_idle+0x94>
        status = read;
40380d93:	0188      	l32i.n	a8, a1, 0
        if ((status & SR_WIP) == 0 && (suspend_state == false)) { // Verify write in progress is complete
40380d95:	11e807        	bbsi	a8, 0, 40380daa <spi_flash_chip_generic_wait_idle+0x62>
            if (chip->busy == 1) {
40380d98:	7298      	l32i.n	a9, a2, 28
40380d9a:	326907        	bbci	a9, 0, 40380dd0 <spi_flash_chip_generic_wait_idle+0x88>
                chip->busy = 0;
40380d9d:	ea7c      	movi.n	a10, -2
40380d9f:	1099a0        	and	a9, a9, a10
40380da2:	7299      	s32i.n	a9, a2, 28
                if ((status & SR_WREN) != 0) { // The previous command is not accepted, leaving the WEL still set.
40380da4:	286817        	bbci	a8, 1, 40380dd0 <spi_flash_chip_generic_wait_idle+0x88>
40380da7:	000706        	j	40380dc7 <spi_flash_chip_generic_wait_idle+0x7f>
        if (timeout_us > 0 && interval > 0) {
40380daa:	f79c      	beqz.n	a7, 40380dcd <spi_flash_chip_generic_wait_idle+0x85>
            int delay = MIN(interval, timeout_us);
40380dac:	451c      	movi.n	a5, 20
40380dae:	635750        	minu	a5, a7, a5
            chip->os_func->delay_us(chip->os_func_data, delay);
40380db1:	2288      	l32i.n	a8, a2, 8
40380db3:	3888      	l32i.n	a8, a8, 12
40380db5:	05bd      	mov.n	a11, a5
40380db7:	32a8      	l32i.n	a10, a2, 12
40380db9:	0008e0        	callx8	a8
            if (timeout_en) {
40380dbc:	0d0326        	beqi	a3, -1, 40380dcd <spi_flash_chip_generic_wait_idle+0x85>
                timeout_us -= delay;
40380dbf:	c07750        	sub	a7, a7, a5
40380dc2:	0001c6        	j	40380dcd <spi_flash_chip_generic_wait_idle+0x85>
40380dc5:	a20000        	muluh	a0, a0, a0
                    return ESP_ERR_NOT_SUPPORTED;
40380dc8:	8606a1        	l32r	a10, 403625e0 <rom_rx_gain_force+0x35c1b4>
40380dcb:	560003        	lsi	f0, a0, 0x158
    while (timeout_us > 0) {
40380dce:	8cfa37        	bbsi	a10, 19, 40380d5e <spi_flash_chip_generic_wait_idle+0x16>
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
40380dd1:	0a0c57        	bnone	a12, a5, 40380ddf <spi_flash_chip_generic_wait_idle+0x97>
40380dd4:	000106        	j	40380ddc <spi_flash_chip_generic_wait_idle+0x94>
40380dd7:	a20000        	muluh	a0, a0, a0
40380dda:	2d07a1        	l32r	a10, 4034c1f8 <rom_rx_gain_force+0x345dcc>
}
40380ddd:	1d0a      	add.n	a1, a13, a0
40380ddf:	f0          	.byte	0xf0

40380de0 <spi_flash_chip_generic_read_unique_id_none>:
{
40380de0:	004136        	entry	a1, 32
}
40380de3:	06a122        	movi	a2, 0x106
40380de6:	f01d      	retw.n

40380de8 <spi_flash_common_set_io_mode>:
{
40380de8:	006136        	entry	a1, 48
40380deb:	027d      	mov.n	a7, a2
40380ded:	4288      	l32i.n	a8, a2, 16
40380def:	fcc882        	addi	a8, a8, -4
    if (need_check) {
40380df2:	0228b6        	bltui	a8, 2, 40380df8 <spi_flash_common_set_io_mode+0x10>
40380df5:	002146        	j	40380e7e <spi_flash_common_set_io_mode+0x96>
        ret = (*rdsr_func)(chip, &sr);
40380df8:	01bd      	mov.n	a11, a1
40380dfa:	20a220        	or	a10, a2, a2
40380dfd:	0004e0        	callx8	a4
40380e00:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40380e02:	07aa56        	bnez	a10, 40380e80 <spi_flash_common_set_io_mode+0x98>
            sr_update = sr | qe_sr_bit;
40380e05:	0188      	l32i.n	a8, a1, 0
40380e07:	206850        	or	a6, a8, a5
        if (sr != sr_update) {
40380e0a:	724857        	ball	a8, a5, 40380e80 <spi_flash_common_set_io_mode+0x98>
        chip->chip_drv->set_chip_write_protect(chip, false);
40380e0d:	1788      	l32i.n	a8, a7, 4
40380e0f:	b888      	l32i.n	a8, a8, 44
40380e11:	0b0c      	movi.n	a11, 0
40380e13:	20a770        	or	a10, a7, a7
40380e16:	0008e0        	callx8	a8
        ret = (*wrsr_func)(chip, sr_update);
40380e19:	06bd      	mov.n	a11, a6
40380e1b:	20a770        	or	a10, a7, a7
40380e1e:	0003e0        	callx8	a3
40380e21:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40380e23:	da8c      	beqz.n	a10, 40380e34 <spi_flash_common_set_io_mode+0x4c>
            chip->chip_drv->set_chip_write_protect(chip, true);
40380e25:	1788      	l32i.n	a8, a7, 4
40380e27:	b888      	l32i.n	a8, a8, 44
40380e29:	1b0c      	movi.n	a11, 1
40380e2b:	07ad      	mov.n	a10, a7
40380e2d:	0008e0        	callx8	a8
            return ret;
40380e30:	001306        	j	40380e80 <spi_flash_common_set_io_mode+0x98>
40380e33:	178800        	lsi	f0, a8, 92
        ret = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380e36:	152892        	l32i	a9, a8, 84
40380e39:	1888      	l32i.n	a8, a8, 4
40380e3b:	08b8      	l32i.n	a11, a8, 0
40380e3d:	07ad      	mov.n	a10, a7
40380e3f:	0009e0        	callx8	a9
40380e42:	0a2d      	mov.n	a2, a10
        if (ret == ESP_ERR_NOT_SUPPORTED) {
40380e44:	06a182        	movi	a8, 0x106
40380e47:	0a9a87        	bne	a10, a8, 40380e55 <spi_flash_common_set_io_mode+0x6d>
            chip->chip_drv->set_chip_write_protect(chip, true);
40380e4a:	1788      	l32i.n	a8, a7, 4
40380e4c:	b888      	l32i.n	a8, a8, 44
40380e4e:	1b0c      	movi.n	a11, 1
40380e50:	07ad      	mov.n	a10, a7
40380e52:	0008e0        	callx8	a8
        if (ret != ESP_OK && ret != ESP_ERR_NOT_SUPPORTED) {
40380e55:	180c      	movi.n	a8, 1
40380e57:	838220        	moveqz	a8, a2, a2
40380e5a:	faae92        	movi	a9, 0xfffffefa
40380e5d:	929a      	add.n	a9, a2, a9
40380e5f:	1a0c      	movi.n	a10, 1
40380e61:	83a990        	moveqz	a10, a9, a9
40380e64:	1888a7        	bany	a8, a10, 40380e80 <spi_flash_common_set_io_mode+0x98>
        ret = (*rdsr_func)(chip, &sr);
40380e67:	01bd      	mov.n	a11, a1
40380e69:	07ad      	mov.n	a10, a7
40380e6b:	0004e0        	callx8	a4
40380e6e:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40380e70:	cacc      	bnez.n	a10, 40380e80 <spi_flash_common_set_io_mode+0x98>
        if (sr != sr_update) {
40380e72:	0188      	l32i.n	a8, a1, 0
40380e74:	081867        	beq	a8, a6, 40380e80 <spi_flash_common_set_io_mode+0x98>
            ret = ESP_ERR_FLASH_NO_RESPONSE;
40380e77:	08a122        	movi	a2, 0x108
40380e7a:	000086        	j	40380e80 <spi_flash_common_set_io_mode+0x98>
40380e7d:	020c00        	andb	b0, b12, b0
}
40380e80:	f01d      	retw.n
	...

40380e84 <spi_flash_chip_issi_probe>:
#include "spi_flash_defs.h"

/* Driver for ISSI flash chip, as used in ESP32 D2WD */

esp_err_t spi_flash_chip_issi_probe(esp_flash_t *chip, uint32_t flash_id)
{
40380e84:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0x9D;
    if (flash_id >> 16 != MFG_ID) {
40380e87:	f59030        	extui	a9, a3, 16, 16
40380e8a:	9da082        	movi	a8, 157
40380e8d:	109987        	bne	a9, a8, 40380ea1 <spi_flash_chip_issi_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xCF00;
    const uint16_t FLASH_ID_VALUE = 0x4000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
40380e90:	d09c81        	l32r	a8, 40375100 <_iram_text_start+0xcfc> (cf00 <UserFrameTotalSize+0xce00>)
40380e93:	103380        	and	a3, a3, a8
40380e96:	cd6e81        	l32r	a8, 40374450 <_iram_text_start+0x4c> (4000 <UserFrameTotalSize+0x3f00>)
40380e99:	0b9387        	bne	a3, a8, 40380ea8 <spi_flash_chip_issi_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
40380e9c:	020c      	movi.n	a2, 0
40380e9e:	000246        	j	40380eab <spi_flash_chip_issi_probe+0x27>
        return ESP_ERR_NOT_FOUND;
40380ea1:	05a122        	movi	a2, 0x105
40380ea4:	0000c6        	j	40380eab <spi_flash_chip_issi_probe+0x27>
40380ea7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40380eaa:	f01d05        	call0	4037107c <rom_rx_gain_force+0x36ac50>
40380ead:	000000        	ill

40380eb0 <spi_flash_chip_issi_set_io_mode>:
}

esp_err_t spi_flash_chip_issi_set_io_mode(esp_flash_t *chip)
{
40380eb0:	004136        	entry	a1, 32
40380eb3:	02ad      	mov.n	a10, a2
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    return spi_flash_common_set_io_mode(chip,
40380eb5:	0d4c      	movi.n	a13, 64
40380eb7:	d093c1        	l32r	a12, 40375104 <_iram_text_start+0xd00> (40380a68 <spi_flash_common_read_status_8b_rdsr>)
40380eba:	d093b1        	l32r	a11, 40375108 <_iram_text_start+0xd04> (40380a80 <spi_flash_common_write_status_8b_wrsr>)
40380ebd:	fff2a5        	call8	40380de8 <spi_flash_common_set_io_mode>
                                        spi_flash_common_write_status_8b_wrsr,
                                        spi_flash_common_read_status_8b_rdsr,
                                        BIT_QE);
}
40380ec0:	0a2d      	mov.n	a2, a10
40380ec2:	f01d      	retw.n

40380ec4 <spi_flash_chip_issi_get_io_mode>:

esp_err_t spi_flash_chip_issi_get_io_mode(esp_flash_t *chip, esp_flash_io_mode_t* out_io_mode)
{
40380ec4:	006136        	entry	a1, 48
40380ec7:	20a220        	or	a10, a2, a2
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    uint32_t sr;
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr(chip, &sr);
40380eca:	20b110        	or	a11, a1, a1
40380ecd:	ffb9a5        	call8	40380a68 <spi_flash_common_read_status_8b_rdsr>
40380ed0:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380ed3:	aacc      	bnez.n	a10, 40380ee1 <spi_flash_chip_issi_get_io_mode+0x1d>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380ed5:	0188      	l32i.n	a8, a1, 0
40380ed7:	418480        	srli	a8, a8, 4
40380eda:	490c      	movi.n	a9, 4
40380edc:	108890        	and	a8, a8, a9
40380edf:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
40380ee1:	f01d      	retw.n
	...

40380ee4 <spi_flash_chip_issi_get_caps>:

spi_flash_caps_t spi_flash_chip_issi_get_caps(esp_flash_t *chip)
{
40380ee4:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
40380ee7:	420c      	movi.n	a2, 4
40380ee9:	f01d      	retw.n
	...

40380eec <spi_flash_chip_mxic_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_detect_size(esp_flash_t *chip, uint32_t *size)
{
40380eec:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
40380eef:	6288      	l32i.n	a8, a2, 24
    *size = 0;
40380ef1:	0c0c      	movi.n	a12, 0
40380ef3:	03c9      	s32i.n	a12, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
40380ef5:	f4a080        	extui	a10, a8, 0, 16
40380ef8:	190c      	movi.n	a9, 1
40380efa:	0cbd      	mov.n	a11, a12
40380efc:	83b9a0        	moveqz	a11, a9, a10
40380eff:	cd58d1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40380f02:	c0aad0        	sub	a10, a10, a13
40380f05:	939ca0        	movnez	a9, a12, a10
40380f08:	209b90        	or	a9, a11, a9
40380f0b:	99dc      	bnez.n	a9, 40380f28 <spi_flash_chip_mxic_detect_size+0x3c>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    uint32_t mem_density = (id & 0xFF);
40380f0d:	748080        	extui	a8, a8, 0, 8
    if (mem_density > 0x30) { // For OPI chips
40380f10:	093c      	movi.n	a9, 48
40380f12:	02b987        	bgeu	a9, a8, 40380f18 <spi_flash_chip_mxic_detect_size+0x2c>
        mem_density -= 0x20;
40380f15:	e0c882        	addi	a8, a8, -32
    }

    *size = 1 << mem_density;
40380f18:	190c      	movi.n	a9, 1
40380f1a:	401800        	ssl	a8
40380f1d:	a18900        	sll	a8, a9
40380f20:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380f22:	020c      	movi.n	a2, 0
40380f24:	0000c6        	j	40380f2b <spi_flash_chip_mxic_detect_size+0x3f>
40380f27:	602100        	abs	a2, a0
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
40380f2a:	ce          	.byte	0xce
}
40380f2b:	f01d      	retw.n
40380f2d:	000000        	ill

40380f30 <spi_flash_chip_mxic_probe>:
{
40380f30:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40380f33:	f53030        	extui	a3, a3, 16, 16
40380f36:	c2a082        	movi	a8, 194
40380f39:	0b9387        	bne	a3, a8, 40380f48 <spi_flash_chip_mxic_probe+0x18>
    if (chip->read_mode >= SPI_FLASH_OPI_FLAG) {
40380f3c:	4288      	l32i.n	a8, a2, 16
40380f3e:	f90c      	movi.n	a9, 15
40380f40:	0c3987        	bltu	a9, a8, 40380f50 <spi_flash_chip_mxic_probe+0x20>
    return ESP_OK;
40380f43:	020c      	movi.n	a2, 0
40380f45:	000286        	j	40380f53 <spi_flash_chip_mxic_probe+0x23>
        return ESP_ERR_NOT_FOUND;
40380f48:	05a122        	movi	a2, 0x105
40380f4b:	000106        	j	40380f53 <spi_flash_chip_mxic_probe+0x23>
40380f4e:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
40380f51:	1d05a1        	l32r	a10, 40348368 <rom_rx_gain_force+0x341f3c>
}
40380f54:	0000f0        	callx12	a0
	...

40380f58 <spi_flash_chip_mxic_get_caps>:
#define spi_flash_chip_mxic_read_reg        spi_flash_chip_generic_read_reg

static const char chip_name[] = "mxic";

spi_flash_caps_t spi_flash_chip_mxic_get_caps(esp_flash_t *chip)
{
40380f58:	004136        	entry	a1, 32
    spi_flash_caps_t caps_flags = 0;
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // reading unique id is not supported.
    return caps_flags;
}
40380f5b:	020c      	movi.n	a2, 0
40380f5d:	f01d      	retw.n
	...

40380f60 <spi_flash_chip_mxic_opi_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_opi_detect_size(esp_flash_t *chip, uint32_t *size)
{
40380f60:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
40380f63:	62c8      	l32i.n	a12, a2, 24
    *size = 0;
40380f65:	0b0c      	movi.n	a11, 0
40380f67:	03b9      	s32i.n	a11, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
40380f69:	f490c0        	extui	a9, a12, 0, 16
40380f6c:	180c      	movi.n	a8, 1
40380f6e:	0bad      	mov.n	a10, a11
40380f70:	83a890        	moveqz	a10, a8, a9
40380f73:	cd3bd1        	l32r	a13, 40374460 <_iram_text_start+0x5c> (ffff <UserFrameTotalSize+0xfeff>)
40380f76:	c099d0        	sub	a9, a9, a13
40380f79:	938b90        	movnez	a8, a11, a9
40380f7c:	208a80        	or	a8, a10, a8
40380f7f:	d8cc      	bnez.n	a8, 40380f90 <spi_flash_chip_mxic_opi_detect_size+0x30>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    *size = 1 << ((id & 0xFF) - 0x20);
40380f81:	180c      	movi.n	a8, 1
40380f83:	401c00        	ssl	a12
40380f86:	a18800        	sll	a8, a8
40380f89:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380f8b:	0b2d      	mov.n	a2, a11
40380f8d:	000086        	j	40380f93 <spi_flash_chip_mxic_opi_detect_size+0x33>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
40380f90:	ce4621        	l32r	a2, 403748a8 <_iram_text_start+0x4a4> (6005 <UserFrameTotalSize+0x5f05>)
}
40380f93:	f01d      	retw.n
40380f95:	000000        	ill

40380f98 <spi_flash_chip_mxic_opi_set_write_protect>:
    // reading unique id is not supported.
    return caps_flags;
}

esp_err_t spi_flash_chip_mxic_opi_set_write_protect(esp_flash_t *chip, bool write_protect)
{
40380f98:	008136        	entry	a1, 64
40380f9b:	743030        	extui	a3, a3, 0, 8
    esp_err_t err = ESP_OK;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380f9e:	1288      	l32i.n	a8, a2, 4
40380fa0:	152892        	l32i	a9, a8, 84
40380fa3:	1888      	l32i.n	a8, a8, 4
40380fa5:	0028b2        	l32i	a11, a8, 0
40380fa8:	20a220        	or	a10, a2, a2
40380fab:	0009e0        	callx8	a9
40380fae:	0a7d      	mov.n	a7, a10
    spi_flash_trans_t t = {};
40380fb0:	cc1c      	movi.n	a12, 28
40380fb2:	0b0c      	movi.n	a11, 0
40380fb4:	01ad      	mov.n	a10, a1
40380fb6:	cd3681        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40380fb9:	0008e0        	callx8	a8
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380fbc:	40f790        	nsau	a9, a7
40380fbf:	419590        	srli	a9, a9, 5
40380fc2:	faae82        	movi	a8, 0xfffffefa
40380fc5:	878a      	add.n	a8, a7, a8
40380fc7:	40f880        	nsau	a8, a8
40380fca:	418580        	srli	a8, a8, 5
40380fcd:	209980        	or	a9, a9, a8
40380fd0:	a99c      	beqz.n	a9, 40380fee <spi_flash_chip_mxic_opi_set_write_protect+0x56>
        if(write_protect) {
40380fd2:	738c      	beqz.n	a3, 40380fdd <spi_flash_chip_mxic_opi_set_write_protect+0x45>
            t.command = CMD_OPI_FLASH_MXIC(CMD_WRDI);
40380fd4:	04ab82        	movi	a8, 0xfffffb04
40380fd7:	0a5182        	s16i	a8, a1, 20
40380fda:	000146        	j	40380fe3 <spi_flash_chip_mxic_opi_set_write_protect+0x4b>
        } else {
            t.command = CMD_OPI_FLASH_MXIC(CMD_WREN);
40380fdd:	06a982        	movi	a8, 0xfffff906
40380fe0:	0a5182        	s16i	a8, a1, 20
        }
        err = chip->host->driver->common_command(chip->host, &t);
40380fe3:	02a8      	l32i.n	a10, a2, 0
40380fe5:	0a88      	l32i.n	a8, a10, 0
40380fe7:	1888      	l32i.n	a8, a8, 4
40380fe9:	01bd      	mov.n	a11, a1
40380feb:	0008e0        	callx8	a8
    }

    bool wp_read;
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
40380fee:	1288      	l32i.n	a8, a2, 4
40380ff0:	a888      	l32i.n	a8, a8, 40
40380ff2:	1cc1b2        	addi	a11, a1, 28
40380ff5:	02ad      	mov.n	a10, a2
40380ff7:	0008e0        	callx8	a8
40380ffa:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
40380ffc:	008a56        	bnez	a10, 40381008 <spi_flash_chip_mxic_opi_set_write_protect+0x70>
40380fff:	1c0182        	l8ui	a8, a1, 28
40381002:	021837        	beq	a8, a3, 40381008 <spi_flash_chip_mxic_opi_set_write_protect+0x70>
        err = ESP_ERR_NOT_FOUND;
40381005:	05a122        	movi	a2, 0x105
    }
    return err;
}
40381008:	f01d      	retw.n
	...

4038100c <spi_flash_chip_mxic_opi_erase_chip>:
    *out_write_protected = ((status & SR_WREN) == 0);
    return err;
}

esp_err_t spi_flash_chip_mxic_opi_erase_chip(esp_flash_t *chip)
{
4038100c:	008136        	entry	a1, 64
4038100f:	027d      	mov.n	a7, a2
    esp_err_t err;

    err = chip->chip_drv->set_chip_write_protect(chip, false);
40381011:	1288      	l32i.n	a8, a2, 4
40381013:	b888      	l32i.n	a8, a8, 44
40381015:	00a0b2        	movi	a11, 0
40381018:	20a220        	or	a10, a2, a2
4038101b:	0008e0        	callx8	a8
4038101e:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40381020:	0adc      	bnez.n	a10, 40381034 <spi_flash_chip_mxic_opi_erase_chip+0x28>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381022:	1788      	l32i.n	a8, a7, 4
40381024:	152892        	l32i	a9, a8, 84
40381027:	1888      	l32i.n	a8, a8, 4
40381029:	08b8      	l32i.n	a11, a8, 0
4038102b:	20a770        	or	a10, a7, a7
4038102e:	0009e0        	callx8	a9
40381031:	202aa0        	or	a2, a10, a10
    }

    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381034:	40f290        	nsau	a9, a2
40381037:	419590        	srli	a9, a9, 5
4038103a:	faae82        	movi	a8, 0xfffffefa
4038103d:	828a      	add.n	a8, a2, a8
4038103f:	40f880        	nsau	a8, a8
40381042:	418580        	srli	a8, a8, 5
40381045:	209980        	or	a9, a9, a8
40381048:	048916        	beqz	a9, 40381094 <spi_flash_chip_mxic_opi_erase_chip+0x88>
        // Do erase chip here.
        spi_flash_trans_t t = {
4038104b:	cc1c      	movi.n	a12, 28
4038104d:	0b0c      	movi.n	a11, 0
4038104f:	20a110        	or	a10, a1, a1
40381052:	cd0f81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381055:	0008e0        	callx8	a8
40381058:	d02d81        	l32r	a8, 4037510c <_iram_text_start+0xd08> (ffff9f60 <_rtc_reserved_end+0x9fef9f60>)
4038105b:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC_CHIP_ERASE,
        };
        err = chip->host->driver->common_command(chip->host, &t);
4038105e:	07a8      	l32i.n	a10, a7, 0
40381060:	0a88      	l32i.n	a8, a10, 0
40381062:	1888      	l32i.n	a8, a8, 4
40381064:	20b110        	or	a11, a1, a1
40381067:	0008e0        	callx8	a8
        chip->busy = 1;
4038106a:	7788      	l32i.n	a8, a7, 28
4038106c:	190c      	movi.n	a9, 1
4038106e:	208890        	or	a8, a8, a9
40381071:	7789      	s32i.n	a8, a7, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
40381073:	1788      	l32i.n	a8, a7, 4
40381075:	152892        	l32i	a9, a8, 84
40381078:	1888      	l32i.n	a8, a8, 4
4038107a:	18b8      	l32i.n	a11, a8, 4
4038107c:	07ad      	mov.n	a10, a7
4038107e:	0009e0        	callx8	a9
40381081:	0a2d      	mov.n	a2, a10
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381083:	06a182        	movi	a8, 0x106
40381086:	0a9a87        	bne	a10, a8, 40381094 <spi_flash_chip_mxic_opi_erase_chip+0x88>
        chip->chip_drv->set_chip_write_protect(chip, true);
40381089:	1788      	l32i.n	a8, a7, 4
4038108b:	b888      	l32i.n	a8, a8, 44
4038108d:	1b0c      	movi.n	a11, 1
4038108f:	07ad      	mov.n	a10, a7
40381091:	0008e0        	callx8	a8
    }

    return err;

}
40381094:	f01d      	retw.n
	...

40381098 <spi_flash_chip_mxic_opi_erase_sector>:

esp_err_t spi_flash_chip_mxic_opi_erase_sector(esp_flash_t *chip, uint32_t start_address)
{
40381098:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4038109b:	1288      	l32i.n	a8, a2, 4
4038109d:	b888      	l32i.n	a8, a8, 44
4038109f:	0b0c      	movi.n	a11, 0
403810a1:	02ad      	mov.n	a10, a2
403810a3:	0008e0        	callx8	a8
    if (err == ESP_OK) {
403810a6:	eacc      	bnez.n	a10, 403810b8 <spi_flash_chip_mxic_opi_erase_sector+0x20>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403810a8:	1288      	l32i.n	a8, a2, 4
403810aa:	152892        	l32i	a9, a8, 84
403810ad:	1888      	l32i.n	a8, a8, 4
403810af:	0028b2        	l32i	a11, a8, 0
403810b2:	20a220        	or	a10, a2, a2
403810b5:	0009e0        	callx8	a9
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403810b8:	40fa90        	nsau	a9, a10
403810bb:	419590        	srli	a9, a9, 5
403810be:	faae82        	movi	a8, 0xfffffefa
403810c1:	8a8a      	add.n	a8, a10, a8
403810c3:	40f880        	nsau	a8, a8
403810c6:	418580        	srli	a8, a8, 5
403810c9:	209980        	or	a9, a9, a8
403810cc:	04d916        	beqz	a9, 4038111d <spi_flash_chip_mxic_opi_erase_sector+0x85>
        spi_flash_trans_t t = {
403810cf:	cc1c      	movi.n	a12, 28
403810d1:	0b0c      	movi.n	a11, 0
403810d3:	20a110        	or	a10, a1, a1
403810d6:	ccee81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403810d9:	0008e0        	callx8	a8
403810dc:	082c      	movi.n	a8, 32
403810de:	034182        	s8i	a8, a1, 3
403810e1:	1139      	s32i.n	a3, a1, 4
403810e3:	d00b81        	l32r	a8, 40375110 <_iram_text_start+0xd0c> (ffffde21 <_rtc_reserved_end+0x9fefde21>)
403810e6:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC(CMD_SECTOR_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
403810e9:	02a8      	l32i.n	a10, a2, 0
403810eb:	0a88      	l32i.n	a8, a10, 0
403810ed:	1888      	l32i.n	a8, a8, 4
403810ef:	20b110        	or	a11, a1, a1
403810f2:	0008e0        	callx8	a8
        chip->busy = 1;
403810f5:	7288      	l32i.n	a8, a2, 28
403810f7:	190c      	movi.n	a9, 1
403810f9:	208890        	or	a8, a8, a9
403810fc:	7289      	s32i.n	a8, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
403810fe:	1288      	l32i.n	a8, a2, 4
40381100:	152892        	l32i	a9, a8, 84
40381103:	1888      	l32i.n	a8, a8, 4
40381105:	38b8      	l32i.n	a11, a8, 12
40381107:	02ad      	mov.n	a10, a2
40381109:	0009e0        	callx8	a9
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
4038110c:	06a182        	movi	a8, 0x106
4038110f:	0a9a87        	bne	a10, a8, 4038111d <spi_flash_chip_mxic_opi_erase_sector+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381112:	1288      	l32i.n	a8, a2, 4
40381114:	b888      	l32i.n	a8, a8, 44
40381116:	1b0c      	movi.n	a11, 1
40381118:	02ad      	mov.n	a10, a2
4038111a:	0008e0        	callx8	a8
    }

    return err;
}
4038111d:	0a2d      	mov.n	a2, a10
4038111f:	f01d      	retw.n
40381121:	000000        	ill

40381124 <spi_flash_chip_mxic_opi_erase_block>:

esp_err_t spi_flash_chip_mxic_opi_erase_block(esp_flash_t *chip, uint32_t start_address)
{
40381124:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40381127:	1288      	l32i.n	a8, a2, 4
40381129:	b888      	l32i.n	a8, a8, 44
4038112b:	0b0c      	movi.n	a11, 0
4038112d:	02ad      	mov.n	a10, a2
4038112f:	0008e0        	callx8	a8
    if (err == ESP_OK) {
40381132:	eacc      	bnez.n	a10, 40381144 <spi_flash_chip_mxic_opi_erase_block+0x20>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381134:	1288      	l32i.n	a8, a2, 4
40381136:	152892        	l32i	a9, a8, 84
40381139:	1888      	l32i.n	a8, a8, 4
4038113b:	0028b2        	l32i	a11, a8, 0
4038113e:	20a220        	or	a10, a2, a2
40381141:	0009e0        	callx8	a9
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381144:	40fa90        	nsau	a9, a10
40381147:	419590        	srli	a9, a9, 5
4038114a:	faae82        	movi	a8, 0xfffffefa
4038114d:	8a8a      	add.n	a8, a10, a8
4038114f:	40f880        	nsau	a8, a8
40381152:	418580        	srli	a8, a8, 5
40381155:	209980        	or	a9, a9, a8
40381158:	04d916        	beqz	a9, 403811a9 <spi_flash_chip_mxic_opi_erase_block+0x85>
        spi_flash_trans_t t = {
4038115b:	cc1c      	movi.n	a12, 28
4038115d:	0b0c      	movi.n	a11, 0
4038115f:	20a110        	or	a10, a1, a1
40381162:	cccb81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381165:	0008e0        	callx8	a8
40381168:	082c      	movi.n	a8, 32
4038116a:	034182        	s8i	a8, a1, 3
4038116d:	1139      	s32i.n	a3, a1, 4
4038116f:	cfe981        	l32r	a8, 40375114 <_iram_text_start+0xd10> (23dc <UserFrameTotalSize+0x22dc>)
40381172:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC(CMD_LARGE_BLOCK_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
40381175:	02a8      	l32i.n	a10, a2, 0
40381177:	0a88      	l32i.n	a8, a10, 0
40381179:	1888      	l32i.n	a8, a8, 4
4038117b:	20b110        	or	a11, a1, a1
4038117e:	0008e0        	callx8	a8
        chip->busy = 1;
40381181:	7288      	l32i.n	a8, a2, 28
40381183:	190c      	movi.n	a9, 1
40381185:	208890        	or	a8, a8, a9
40381188:	7289      	s32i.n	a8, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
4038118a:	1288      	l32i.n	a8, a2, 4
4038118c:	152892        	l32i	a9, a8, 84
4038118f:	1888      	l32i.n	a8, a8, 4
40381191:	28b8      	l32i.n	a11, a8, 8
40381193:	02ad      	mov.n	a10, a2
40381195:	0009e0        	callx8	a9
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381198:	06a182        	movi	a8, 0x106
4038119b:	0a9a87        	bne	a10, a8, 403811a9 <spi_flash_chip_mxic_opi_erase_block+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038119e:	1288      	l32i.n	a8, a2, 4
403811a0:	b888      	l32i.n	a8, a8, 44
403811a2:	1b0c      	movi.n	a11, 1
403811a4:	02ad      	mov.n	a10, a2
403811a6:	0008e0        	callx8	a8
    }

    return err;
}
403811a9:	0a2d      	mov.n	a2, a10
403811ab:	f01d      	retw.n
403811ad:	000000        	ill

403811b0 <spi_flash_chip_mxic_opi_page_program>:

esp_err_t spi_flash_chip_mxic_opi_page_program(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
403811b0:	008136        	entry	a1, 64
403811b3:	027d      	mov.n	a7, a2
    esp_err_t err;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403811b5:	1288      	l32i.n	a8, a2, 4
403811b7:	152892        	l32i	a9, a8, 84
403811ba:	012882        	l32i	a8, a8, 4
403811bd:	0028b2        	l32i	a11, a8, 0
403811c0:	20a220        	or	a10, a2, a2
403811c3:	0009e0        	callx8	a9
403811c6:	0a2d      	mov.n	a2, a10
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403811c8:	40fa90        	nsau	a9, a10
403811cb:	419590        	srli	a9, a9, 5
403811ce:	faae82        	movi	a8, 0xfffffefa
403811d1:	8a8a      	add.n	a8, a10, a8
403811d3:	40f880        	nsau	a8, a8
403811d6:	418580        	srli	a8, a8, 5
403811d9:	209980        	or	a9, a9, a8
403811dc:	056916        	beqz	a9, 40381236 <spi_flash_chip_mxic_opi_page_program+0x86>
        // Perform the actual Page Program command
        spi_flash_trans_t t = {
403811df:	cc1c      	movi.n	a12, 28
403811e1:	00a0b2        	movi	a11, 0
403811e4:	20a110        	or	a10, a1, a1
403811e7:	ccaa81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403811ea:	0008e0        	callx8	a8
403811ed:	014152        	s8i	a5, a1, 1
403811f0:	082c      	movi.n	a8, 32
403811f2:	034182        	s8i	a8, a1, 3
403811f5:	1149      	s32i.n	a4, a1, 4
403811f7:	2139      	s32i.n	a3, a1, 8
403811f9:	cfc781        	l32r	a8, 40375118 <_iram_text_start+0xd14> (ffffed12 <_rtc_reserved_end+0x9fefed12>)
403811fc:	0a5182        	s16i	a8, a1, 20
            .address_bitlen = 32,
            .address = address,
            .mosi_len = length,
            .mosi_data = buffer,
        };
        chip->host->driver->common_command(chip->host, &t);
403811ff:	07a8      	l32i.n	a10, a7, 0
40381201:	0a88      	l32i.n	a8, a10, 0
40381203:	1888      	l32i.n	a8, a8, 4
40381205:	01bd      	mov.n	a11, a1
40381207:	0008e0        	callx8	a8
        chip->busy = 1;
4038120a:	7788      	l32i.n	a8, a7, 28
4038120c:	190c      	movi.n	a9, 1
4038120e:	208890        	or	a8, a8, a9
40381211:	7789      	s32i.n	a8, a7, 28

        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40381213:	1788      	l32i.n	a8, a7, 4
40381215:	152892        	l32i	a9, a8, 84
40381218:	1888      	l32i.n	a8, a8, 4
4038121a:	48b8      	l32i.n	a11, a8, 16
4038121c:	07ad      	mov.n	a10, a7
4038121e:	0009e0        	callx8	a9
40381221:	0a2d      	mov.n	a2, a10
    }
    // Ensure WEL is 0, even if the page program failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381223:	06a182        	movi	a8, 0x106
40381226:	0c9a87        	bne	a10, a8, 40381236 <spi_flash_chip_mxic_opi_page_program+0x86>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381229:	1788      	l32i.n	a8, a7, 4
4038122b:	b888      	l32i.n	a8, a8, 44
4038122d:	1b0c      	movi.n	a11, 1
4038122f:	07ad      	mov.n	a10, a7
40381231:	0008e0        	callx8	a8
40381234:	0a2d      	mov.n	a2, a10
    }
    return err;
}
40381236:	f01d      	retw.n

40381238 <spi_flash_chip_xmic_opi_config_host_io_mode>:
}

// This function should only be called after opi mode initialization. So, only configure for OPI-STR/OPI-DTR mode
// not support other mode in this file, return `ESP_ERR_FLASH_NOT_INITIALISED` directely.
esp_err_t spi_flash_chip_xmic_opi_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
40381238:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4038123b:	42e8      	l32i.n	a14, a2, 16

    switch (read_mode & 0xFFFF) {
4038123d:	f480e0        	extui	a8, a14, 0, 16
40381240:	0cb826        	beqi	a8, 16, 40381250 <spi_flash_chip_xmic_opi_config_host_io_mode+0x18>
40381243:	191c      	movi.n	a9, 17
40381245:	1c9897        	bne	a8, a9, 40381265 <spi_flash_chip_xmic_opi_config_host_io_mode+0x2d>
        read_command = CMD_OPI_FLASH_MXIC_READ_STR;
        break;
    case SPI_FLASH_OPI_DTR:
        addr_bitlen = SPI_FLASH_OPIDTR_ADDR_BITLEN;
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
        read_command = CMD_OPI_FLASH_MXIC_READ_DTR;
40381248:	cfb6b1        	l32r	a11, 40375120 <_iram_text_start+0xd1c> (11ee <UserFrameTotalSize+0x10ee>)
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
4038124b:	8d2c      	movi.n	a13, 40
4038124d:	000106        	j	40381255 <spi_flash_chip_xmic_opi_config_host_io_mode+0x1d>
    switch (read_mode & 0xFFFF) {
40381250:	cfb3b1        	l32r	a11, 4037511c <_iram_text_start+0xd18> (13ec <UserFrameTotalSize+0x12ec>)
40381253:	4d1c      	movi.n	a13, 20
        break;
    default:
        return ESP_ERR_FLASH_NOT_INITIALISED;
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
40381255:	02a8      	l32i.n	a10, a2, 0
40381257:	0a88      	l32i.n	a8, a10, 0
40381259:	f888      	l32i.n	a8, a8, 60
4038125b:	0c2c      	movi.n	a12, 32
4038125d:	0008e0        	callx8	a8
40381260:	0a2d      	mov.n	a2, a10
40381262:	000086        	j	40381268 <spi_flash_chip_xmic_opi_config_host_io_mode+0x30>
    switch (read_mode & 0xFFFF) {
40381265:	cd8b21        	l32r	a2, 40374894 <_iram_text_start+0x490> (6003 <UserFrameTotalSize+0x5f03>)
}
40381268:	f01d      	retw.n
	...

4038126c <spi_flash_chip_mxic_opi_get_data_length_zoom>:
{
4038126c:	004136        	entry	a1, 32
    assert((io_mode == SPI_FLASH_OPI_STR) || (io_mode == SPI_FLASH_OPI_DTR));
4038126f:	f0c282        	addi	a8, a2, -16
40381272:	190c      	movi.n	a9, 1
40381274:	0db987        	bgeu	a9, a8, 40381285 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x19>
40381277:	cfabd1        	l32r	a13, 40375124 <_iram_text_start+0xd20> (3fc93ca8 <__FUNCTION__$0+0x510>)
4038127a:	cfabc1        	l32r	a12, 40375128 <_iram_text_start+0xd24> (3fc94630 <__func__$1>)
4038127d:	db5c      	movi.n	a11, 93
4038127f:	cfaba1        	l32r	a10, 4037512c <_iram_text_start+0xd28> (3fc93d07 <__FUNCTION__$0+0x56f>)
40381282:	feace5        	call8	4037fd50 <__assert_func>
    *length_zoom = (io_mode == SPI_FLASH_OPI_STR) ? 1 : 2;
40381285:	07b266        	bnei	a2, 16, 40381290 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x24>
40381288:	180c      	movi.n	a8, 1
4038128a:	000106        	j	40381292 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x26>
4038128d:	000000        	ill
40381290:	280c      	movi.n	a8, 2
40381292:	0389      	s32i.n	a8, a3, 0
}
40381294:	f01d      	retw.n
	...

40381298 <spi_flash_chip_mxic_opi_read_id>:
{
40381298:	00a136        	entry	a1, 80
    uint64_t id_buf = 0;
4038129b:	080c      	movi.n	a8, 0
4038129d:	0189      	s32i.n	a8, a1, 0
4038129f:	1189      	s32i.n	a8, a1, 4
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
403812a1:	b18b      	addi.n	a11, a1, 8
403812a3:	42a8      	l32i.n	a10, a2, 16
403812a5:	fffc65        	call8	4038126c <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
403812a8:	71cb      	addi.n	a7, a1, 12
403812aa:	cc1c      	movi.n	a12, 28
403812ac:	0b0c      	movi.n	a11, 0
403812ae:	07ad      	mov.n	a10, a7
403812b0:	cc7881        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403812b3:	0008e0        	callx8	a8
403812b6:	080182        	l8ui	a8, a1, 8
403812b9:	909880        	addx2	a9, a8, a8
403812bc:	0e4192        	s8i	a9, a1, 14
403812bf:	092c      	movi.n	a9, 32
403812c1:	0f4192        	s8i	a9, a1, 15
403812c4:	6119      	s32i.n	a1, a1, 24
403812c6:	cf9a91        	l32r	a9, 40375130 <_iram_text_start+0xd2c> (609f <UserFrameTotalSize+0x5f9f>)
403812c9:	105192        	s16i	a9, a1, 32
403812cc:	1188e0        	slli	a8, a8, 2
403812cf:	224182        	s8i	a8, a1, 34
    chip->host->driver->common_command(chip->host, &t);
403812d2:	02a8      	l32i.n	a10, a2, 0
403812d4:	0a88      	l32i.n	a8, a10, 0
403812d6:	1888      	l32i.n	a8, a8, 4
403812d8:	20b770        	or	a11, a7, a7
403812db:	0008e0        	callx8	a8
    if(chip->read_mode == SPI_FLASH_OPI_DTR) {
403812de:	4298      	l32i.n	a9, a2, 16
403812e0:	181c      	movi.n	a8, 17
403812e2:	2c9987        	bne	a9, a8, 40381312 <spi_flash_chip_mxic_opi_read_id+0x7a>
        id_buf = (id_buf & 0xff) | ((id_buf & 0xff0000) >> 8) | ((id_buf & 0xff00000000) >> 16);
403812e5:	0188      	l32i.n	a8, a1, 0
403812e7:	749080        	extui	a9, a8, 0, 8
403812ea:	41a880        	srli	a10, a8, 8
403812ed:	74a8a0        	extui	a10, a10, 8, 8
403812f0:	11aa80        	slli	a10, a10, 8
403812f3:	2099a0        	or	a9, a9, a10
403812f6:	11a8      	l32i.n	a10, a1, 4
403812f8:	11aa00        	slli	a10, a10, 16
403812fb:	f58080        	extui	a8, a8, 16, 16
403812fe:	208a80        	or	a8, a10, a8
40381301:	758080        	extui	a8, a8, 16, 8
40381304:	118800        	slli	a8, a8, 16
40381307:	208980        	or	a8, a9, a8
4038130a:	0189      	s32i.n	a8, a1, 0
4038130c:	00a082        	movi	a8, 0
4038130f:	016182        	s32i	a8, a1, 4
    uint32_t raw_flash_id = __builtin_bswap32(id_buf);
40381312:	0178      	l32i.n	a7, a1, 0
40381314:	07ad      	mov.n	a10, a7
40381316:	cf8981        	l32r	a8, 4037513c <_iram_text_start+0xd38> (400021d8 <__bswapsi2>)
40381319:	0008e0        	callx8	a8
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
4038131c:	01d782        	addmi	a8, a7, 0x100
4038131f:	40f880        	nsau	a8, a8
40381322:	418580        	srli	a8, a8, 5
40381325:	40f770        	nsau	a7, a7
40381328:	417570        	srli	a7, a7, 5
4038132b:	208870        	or	a8, a8, a7
4038132e:	e89c      	beqz.n	a8, 40381350 <spi_flash_chip_mxic_opi_read_id+0xb8>
40381330:	cc4f81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40381333:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(chip_name, "no response\n");
40381335:	f88c      	beqz.n	a8, 40381348 <spi_flash_chip_mxic_opi_read_id+0xb0>
40381337:	fe8aa5        	call8	4037fbe0 <esp_log_timestamp>
4038133a:	cf7ec1        	l32r	a12, 40375134 <_iram_text_start+0xd30> (3fc946dc <chip_name>)
4038133d:	0abd      	mov.n	a11, a10
4038133f:	cf7ea1        	l32r	a10, 40375138 <_iram_text_start+0xd34> (3fc93d24 <__FUNCTION__$0+0x58c>)
40381342:	cc5c81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40381345:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_NO_RESPONSE;
40381348:	08a122        	movi	a2, 0x108
4038134b:	000206        	j	40381357 <spi_flash_chip_mxic_opi_read_id+0xbf>
4038134e:	a00000        	addx4	a0, a0, a0
    *out_chip_id = (raw_flash_id >> 8);
40381351:	41a8      	l32i.n	a10, a1, 16
40381353:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
40381355:	020c      	movi.n	a2, 0
}
40381357:	f01d      	retw.n
40381359:	000000        	ill

4038135c <spi_flash_chip_mxic_opi_read_reg>:
{
4038135c:	00a136        	entry	a1, 80
    uint32_t stat_buf = 0;
4038135f:	060c      	movi.n	a6, 0
40381361:	0169      	s32i.n	a6, a1, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
40381363:	b14b      	addi.n	a11, a1, 4
40381365:	42a8      	l32i.n	a10, a2, 16
40381367:	fff065        	call8	4038126c <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
4038136a:	718b      	addi.n	a7, a1, 8
4038136c:	cc1c      	movi.n	a12, 28
4038136e:	06bd      	mov.n	a11, a6
40381370:	07ad      	mov.n	a10, a7
40381372:	cc4781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381375:	0008e0        	callx8	a8
40381378:	040182        	l8ui	a8, a1, 4
4038137b:	0a4182        	s8i	a8, a1, 10
4038137e:	092c      	movi.n	a9, 32
40381380:	0b4192        	s8i	a9, a1, 11
40381383:	5119      	s32i.n	a1, a1, 20
40381385:	05aa92        	movi	a9, 0xfffffa05
40381388:	0e5192        	s16i	a9, a1, 28
4038138b:	1188e0        	slli	a8, a8, 2
4038138e:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
40381391:	02a8      	l32i.n	a10, a2, 0
40381393:	0a88      	l32i.n	a8, a10, 0
40381395:	1888      	l32i.n	a8, a8, 4
40381397:	07bd      	mov.n	a11, a7
40381399:	0008e0        	callx8	a8
4038139c:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4038139e:	3acc      	bnez.n	a10, 403813a5 <spi_flash_chip_mxic_opi_read_reg+0x49>
    *out_reg = (stat_buf & 0xff);
403813a0:	000182        	l8ui	a8, a1, 0
403813a3:	0489      	s32i.n	a8, a4, 0
}
403813a5:	f01d      	retw.n
	...

403813a8 <spi_flash_chip_mxic_opi_get_io_mode>:
{
403813a8:	00a136        	entry	a1, 80
403813ab:	027d      	mov.n	a7, a2
    uint32_t stat_buf = 0;
403813ad:	060c      	movi.n	a6, 0
403813af:	0169      	s32i.n	a6, a1, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
403813b1:	b14b      	addi.n	a11, a1, 4
403813b3:	42a8      	l32i.n	a10, a2, 16
403813b5:	ffeb65        	call8	4038126c <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
403813b8:	218b      	addi.n	a2, a1, 8
403813ba:	cc1c      	movi.n	a12, 28
403813bc:	20b660        	or	a11, a6, a6
403813bf:	20a220        	or	a10, a2, a2
403813c2:	cc3381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403813c5:	0008e0        	callx8	a8
403813c8:	040182        	l8ui	a8, a1, 4
403813cb:	0a4182        	s8i	a8, a1, 10
403813ce:	092c      	movi.n	a9, 32
403813d0:	0b4192        	s8i	a9, a1, 11
403813d3:	5119      	s32i.n	a1, a1, 20
403813d5:	cf5a91        	l32r	a9, 40375140 <_iram_text_start+0xd3c> (ffff8e71 <_rtc_reserved_end+0x9fef8e71>)
403813d8:	0e5192        	s16i	a9, a1, 28
403813db:	1188e0        	slli	a8, a8, 2
403813de:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
403813e1:	07a8      	l32i.n	a10, a7, 0
403813e3:	0a88      	l32i.n	a8, a10, 0
403813e5:	1888      	l32i.n	a8, a8, 4
403813e7:	02bd      	mov.n	a11, a2
403813e9:	0008e0        	callx8	a8
403813ec:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
403813ee:	8aec      	bnez.n	a10, 4038141a <spi_flash_chip_mxic_opi_get_io_mode+0x72>
    switch (stat_buf & 0xff)
403813f0:	000182        	l8ui	a8, a1, 0
403813f3:	051826        	beqi	a8, 1, 403813fc <spi_flash_chip_mxic_opi_get_io_mode+0x54>
403813f6:	0a2826        	beqi	a8, 2, 40381404 <spi_flash_chip_mxic_opi_get_io_mode+0x5c>
403813f9:	000386        	j	4038140b <spi_flash_chip_mxic_opi_get_io_mode+0x63>
        *out_io_mode = SPI_FLASH_OPI_STR;
403813fc:	081c      	movi.n	a8, 16
403813fe:	0389      	s32i.n	a8, a3, 0
        break;
40381400:	0002c6        	j	4038140f <spi_flash_chip_mxic_opi_get_io_mode+0x67>
40381403:	181c00        	lsxp	f1, a12, a0
        *out_io_mode = SPI_FLASH_OPI_DTR;
40381406:	0389      	s32i.n	a8, a3, 0
        break;
40381408:	0000c6        	j	4038140f <spi_flash_chip_mxic_opi_get_io_mode+0x67>
        *out_io_mode = 0;
4038140b:	080c      	movi.n	a8, 0
4038140d:	0389      	s32i.n	a8, a3, 0
    if (*out_io_mode != chip->read_mode) {
4038140f:	0398      	l32i.n	a9, a3, 0
40381411:	4788      	l32i.n	a8, a7, 16
40381413:	031987        	beq	a9, a8, 4038141a <spi_flash_chip_mxic_opi_get_io_mode+0x72>
        *out_io_mode = 0;
40381416:	080c      	movi.n	a8, 0
40381418:	0389      	s32i.n	a8, a3, 0
}
4038141a:	f01d      	retw.n

4038141c <spi_flash_chip_mxic_opi_get_write_protect>:
{
4038141c:	006136        	entry	a1, 48
4038141f:	02ad      	mov.n	a10, a2
    assert(out_write_protected!=NULL);
40381421:	d3cc      	bnez.n	a3, 40381432 <spi_flash_chip_mxic_opi_get_write_protect+0x16>
40381423:	cf48d1        	l32r	a13, 40375144 <_iram_text_start+0xd40> (3fc93d40 <__FUNCTION__$0+0x5a8>)
40381426:	cf48c1        	l32r	a12, 40375148 <_iram_text_start+0xd44> (3fc94604 <__func__$0>)
40381429:	9ea0b2        	movi	a11, 158
4038142c:	cf40a1        	l32r	a10, 4037512c <_iram_text_start+0xd28> (3fc93d07 <__FUNCTION__$0+0x56f>)
4038142f:	fe9225        	call8	4037fd50 <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
40381432:	1288      	l32i.n	a8, a2, 4
40381434:	192882        	l32i	a8, a8, 100
40381437:	01cd      	mov.n	a12, a1
40381439:	1b0c      	movi.n	a11, 1
4038143b:	0008e0        	callx8	a8
4038143e:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40381440:	eacc      	bnez.n	a10, 40381452 <spi_flash_chip_mxic_opi_get_write_protect+0x36>
    *out_write_protected = ((status & SR_WREN) == 0);
40381442:	280c      	movi.n	a8, 2
40381444:	0198      	l32i.n	a9, a1, 0
40381446:	108890        	and	a8, a8, a9
40381449:	40f880        	nsau	a8, a8
4038144c:	418580        	srli	a8, a8, 5
4038144f:	004382        	s8i	a8, a3, 0
}
40381452:	f01d      	retw.n

40381454 <spi_flash_chip_mxic_opi_write>:
{
40381454:	010136        	entry	a1, 128
40381457:	026d      	mov.n	a6, a2
40381459:	146132        	s32i	a3, a1, 80
    const uint32_t page_size = chip->chip_drv->page_size;
4038145c:	1288      	l32i.n	a8, a2, 4
4038145e:	132882        	l32i	a8, a8, 76
40381461:	156182        	s32i	a8, a1, 84
    esp_err_t err = ESP_OK;
40381464:	0a0c      	movi.n	a10, 0
    while (err == ESP_OK && length > 0) {
40381466:	001f06        	j	403814e6 <spi_flash_chip_mxic_opi_write+0x92>
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
40381469:	214b      	addi.n	a2, a1, 4
4038146b:	0c4c      	movi.n	a12, 64
4038146d:	ffa0b2        	movi	a11, 255
40381470:	02ad      	mov.n	a10, a2
40381472:	cc0781        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381475:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
40381478:	06a8      	l32i.n	a10, a6, 0
4038147a:	0a88      	l32i.n	a8, a10, 0
4038147c:	a888      	l32i.n	a8, a8, 40
4038147e:	1521e2        	l32i	a14, a1, 84
40381481:	01dd      	mov.n	a13, a1
40381483:	05cd      	mov.n	a12, a5
40381485:	04bd      	mov.n	a11, a4
40381487:	0008e0        	callx8	a8
4038148a:	0a9d      	mov.n	a9, a10
4038148c:	1661a2        	s32i	a10, a1, 88
        uint32_t left_off = address - align_address;
4038148f:	0188      	l32i.n	a8, a1, 0
40381491:	c0a480        	sub	a10, a4, a8
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
40381494:	745a      	add.n	a7, a4, a5
40381496:	889a      	add.n	a8, a8, a9
40381498:	637780        	minu	a7, a7, a8
4038149b:	c08740        	sub	a8, a7, a4
4038149e:	176182        	s32i	a8, a1, 92
        memcpy(temp_buffer + left_off, buffer, write_len);
403814a1:	08cd      	mov.n	a12, a8
403814a3:	1421b2        	l32i	a11, a1, 80
403814a6:	a2aa      	add.n	a10, a2, a10
403814a8:	cc0b81        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403814ab:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
403814ae:	1688      	l32i.n	a8, a6, 4
403814b0:	b888      	l32i.n	a8, a8, 44
403814b2:	0b0c      	movi.n	a11, 0
403814b4:	06ad      	mov.n	a10, a6
403814b6:	0008e0        	callx8	a8
        if (err == ESP_OK && length > 0) {
403814b9:	40fa80        	nsau	a8, a10
403814bc:	418580        	srli	a8, a8, 5
403814bf:	230837        	bnone	a8, a3, 403814e6 <spi_flash_chip_mxic_opi_write+0x92>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
403814c2:	1688      	l32i.n	a8, a6, 4
403814c4:	122882        	l32i	a8, a8, 72
403814c7:	1621d2        	l32i	a13, a1, 88
403814ca:	01c8      	l32i.n	a12, a1, 0
403814cc:	20b220        	or	a11, a2, a2
403814cf:	06ad      	mov.n	a10, a6
403814d1:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + write_len);
403814d4:	142182        	l32i	a8, a1, 80
403814d7:	172192        	l32i	a9, a1, 92
403814da:	889a      	add.n	a8, a8, a9
403814dc:	146182        	s32i	a8, a1, 80
            length -= write_len;
403814df:	c04470        	sub	a4, a4, a7
403814e2:	554a      	add.n	a5, a5, a4
            address += write_len;
403814e4:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
403814e6:	130c      	movi.n	a3, 1
403814e8:	833550        	moveqz	a3, a5, a5
403814eb:	1acc      	bnez.n	a10, 403814f0 <spi_flash_chip_mxic_opi_write+0x9c>
403814ed:	f78356        	bnez	a3, 40381469 <spi_flash_chip_mxic_opi_write+0x15>
}
403814f0:	0a2d      	mov.n	a2, a10
403814f2:	f01d      	retw.n

403814f4 <spi_flash_chip_mxic_opi_probe>:
{
403814f4:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
403814f7:	f53030        	extui	a3, a3, 16, 16
403814fa:	c2a082        	movi	a8, 194
403814fd:	0b9387        	bne	a3, a8, 4038150c <spi_flash_chip_mxic_opi_probe+0x18>
    if (chip->read_mode < SPI_FLASH_OPI_FLAG) {
40381500:	4288      	l32i.n	a8, a2, 16
40381502:	f90c      	movi.n	a9, 15
40381504:	0cb987        	bgeu	a9, a8, 40381514 <spi_flash_chip_mxic_opi_probe+0x20>
    return ESP_OK;
40381507:	020c      	movi.n	a2, 0
40381509:	000286        	j	40381517 <spi_flash_chip_mxic_opi_probe+0x23>
        return ESP_ERR_NOT_FOUND;
4038150c:	05a122        	movi	a2, 0x105
4038150f:	000106        	j	40381517 <spi_flash_chip_mxic_opi_probe+0x23>
40381512:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
40381515:	1d05a1        	l32r	a10, 4034892c <rom_rx_gain_force+0x342500>
}
40381518:	0000f0        	callx12	a0
	...

4038151c <spi_flash_chip_mxic_opi_get_caps>:
{
4038151c:	004136        	entry	a1, 32
}
4038151f:	220c      	movi.n	a2, 2
40381521:	f01d      	retw.n
	...

40381524 <spi_flash_chip_xmic_opi_set_io_mode>:
{
40381524:	004136        	entry	a1, 32
}
40381527:	020c      	movi.n	a2, 0
40381529:	f01d      	retw.n
	...

4038152c <spi_flash_chip_th_probe>:
#include <stdlib.h>
#include "spi_flash_chip_generic.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_th_probe(esp_flash_t *chip, uint32_t flash_id)
{
4038152c:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0xcd;
    if (flash_id >> 16 != MFG_ID) {
4038152f:	f59030        	extui	a9, a3, 16, 16
40381532:	cda082        	movi	a8, 205
40381535:	109987        	bne	a9, a8, 40381549 <spi_flash_chip_th_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x6000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
40381538:	743830        	extui	a3, a3, 8, 8
4038153b:	113380        	slli	a3, a3, 8
4038153e:	cee081        	l32r	a8, 403750c0 <_iram_text_start+0xcbc> (6000 <UserFrameTotalSize+0x5f00>)
40381541:	0b9387        	bne	a3, a8, 40381550 <spi_flash_chip_th_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
40381544:	020c      	movi.n	a2, 0
40381546:	000246        	j	40381553 <spi_flash_chip_th_probe+0x27>
        return ESP_ERR_NOT_FOUND;
40381549:	05a122        	movi	a2, 0x105
4038154c:	0000c6        	j	40381553 <spi_flash_chip_th_probe+0x27>
4038154f:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40381552:	f01d05        	call0	40371724 <rom_rx_gain_force+0x36b2f8>
40381555:	000000        	ill

40381558 <spi_flash_chip_th_get_caps>:
}

spi_flash_caps_t spi_flash_chip_th_get_caps(esp_flash_t *chip)
{
40381558:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
4038155b:	420c      	movi.n	a2, 4
4038155d:	f01d      	retw.n
	...

40381560 <spi_flash_chip_winbond_suspend_cmd_conf>:
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}

esp_err_t spi_flash_chip_winbond_suspend_cmd_conf(esp_flash_t *chip)
{
40381560:	006136        	entry	a1, 48
    spi_flash_sus_cmd_conf sus_conf = {
40381563:	8c0c      	movi.n	a12, 8
40381565:	00a0b2        	movi	a11, 0
40381568:	01ad      	mov.n	a10, a1
4038156a:	cbc981        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
4038156d:	0008e0        	callx8	a8
40381570:	80a082        	movi	a8, 128
40381573:	0189      	s32i.n	a8, a1, 0
40381575:	583c      	movi.n	a8, 53
40381577:	044182        	s8i	a8, a1, 4
4038157a:	75a082        	movi	a8, 117
4038157d:	054182        	s8i	a8, a1, 5
40381580:	7aa082        	movi	a8, 122
40381583:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
40381586:	02a8      	l32i.n	a10, a2, 0
40381588:	0a88      	l32i.n	a8, a10, 0
4038158a:	152882        	l32i	a8, a8, 84
4038158d:	01bd      	mov.n	a11, a1
4038158f:	0008e0        	callx8	a8
}
40381592:	0a2d      	mov.n	a2, a10
40381594:	f01d      	retw.n
	...

40381598 <spi_flash_command_winbond_program_4B>:
    .config_host_io_mode = spi_flash_chip_generic_config_host_io_mode,
};


static esp_err_t spi_flash_command_winbond_program_4B(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
40381598:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(address);
    spi_flash_trans_t t = {
4038159b:	cc1c      	movi.n	a12, 28
4038159d:	0b0c      	movi.n	a11, 0
4038159f:	20a110        	or	a10, a1, a1
403815a2:	cbbb81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
403815a5:	0008e0        	callx8	a8
403815a8:	014152        	s8i	a5, a1, 1
403815ab:	ceb981        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403815ae:	04b847        	bgeu	a8, a4, 403815b6 <spi_flash_command_winbond_program_4B+0x1e>
403815b1:	082c      	movi.n	a8, 32
403815b3:	000046        	j	403815b8 <spi_flash_command_winbond_program_4B+0x20>
403815b6:	881c      	movi.n	a8, 24
403815b8:	034182        	s8i	a8, a1, 3
403815bb:	1149      	s32i.n	a4, a1, 4
403815bd:	2139      	s32i.n	a3, a1, 8
403815bf:	880c      	movi.n	a8, 8
403815c1:	4189      	s32i.n	a8, a1, 16
403815c3:	ceb381        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
403815c6:	04b847        	bgeu	a8, a4, 403815ce <spi_flash_command_winbond_program_4B+0x36>
403815c9:	281c      	movi.n	a8, 18
403815cb:	000046        	j	403815d0 <spi_flash_command_winbond_program_4B+0x38>
403815ce:	280c      	movi.n	a8, 2
403815d0:	0a5182        	s16i	a8, a1, 20
        .address = address,
        .mosi_len = length,
        .mosi_data = buffer,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
403815d3:	02a8      	l32i.n	a10, a2, 0
403815d5:	0a88      	l32i.n	a8, a10, 0
403815d7:	1888      	l32i.n	a8, a8, 4
403815d9:	01bd      	mov.n	a11, a1
403815db:	0008e0        	callx8	a8
}
403815de:	0a2d      	mov.n	a2, a10
403815e0:	f01d      	retw.n
	...

403815e4 <spi_flash_chip_winbond_page_program>:
{
403815e4:	004136        	entry	a1, 32
403815e7:	027d      	mov.n	a7, a2
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403815e9:	1288      	l32i.n	a8, a2, 4
403815eb:	152892        	l32i	a9, a8, 84
403815ee:	1888      	l32i.n	a8, a8, 4
403815f0:	08b8      	l32i.n	a11, a8, 0
403815f2:	02ad      	mov.n	a10, a2
403815f4:	0009e0        	callx8	a9
403815f7:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403815f9:	40fa90        	nsau	a9, a10
403815fc:	419590        	srli	a9, a9, 5
403815ff:	faae82        	movi	a8, 0xfffffefa
40381602:	8a8a      	add.n	a8, a10, a8
40381604:	40f880        	nsau	a8, a8
40381607:	418580        	srli	a8, a8, 5
4038160a:	209980        	or	a9, a9, a8
4038160d:	99bc      	beqz.n	a9, 4038164a <spi_flash_chip_winbond_page_program+0x66>
        err = spi_flash_command_winbond_program_4B(chip, buffer, address, length);
4038160f:	05dd      	mov.n	a13, a5
40381611:	04cd      	mov.n	a12, a4
40381613:	03bd      	mov.n	a11, a3
40381615:	07ad      	mov.n	a10, a7
40381617:	fff825        	call8	40381598 <spi_flash_command_winbond_program_4B>
4038161a:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
4038161c:	aaec      	bnez.n	a10, 4038164a <spi_flash_chip_winbond_page_program+0x66>
        chip->busy = 1;
4038161e:	7788      	l32i.n	a8, a7, 28
40381620:	190c      	movi.n	a9, 1
40381622:	208890        	or	a8, a8, a9
40381625:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40381627:	1788      	l32i.n	a8, a7, 4
40381629:	152892        	l32i	a9, a8, 84
4038162c:	1888      	l32i.n	a8, a8, 4
4038162e:	48b8      	l32i.n	a11, a8, 16
40381630:	07ad      	mov.n	a10, a7
40381632:	0009e0        	callx8	a9
40381635:	0a2d      	mov.n	a2, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381637:	06a182        	movi	a8, 0x106
4038163a:	0c9a87        	bne	a10, a8, 4038164a <spi_flash_chip_winbond_page_program+0x66>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038163d:	1788      	l32i.n	a8, a7, 4
4038163f:	b888      	l32i.n	a8, a8, 44
40381641:	1b0c      	movi.n	a11, 1
40381643:	07ad      	mov.n	a10, a7
40381645:	0008e0        	callx8	a8
40381648:	0a2d      	mov.n	a2, a10
}
4038164a:	f01d      	retw.n

4038164c <spi_flash_command_winbond_erase_sector_4B>:

esp_err_t spi_flash_command_winbond_erase_sector_4B(esp_flash_t *chip, uint32_t start_address)
{
4038164c:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(start_address);
    spi_flash_trans_t t = {
4038164f:	cc1c      	movi.n	a12, 28
40381651:	0b0c      	movi.n	a11, 0
40381653:	20a110        	or	a10, a1, a1
40381656:	cb8e81        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381659:	0008e0        	callx8	a8
4038165c:	ce8d81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
4038165f:	05b837        	bgeu	a8, a3, 40381668 <spi_flash_command_winbond_erase_sector_4B+0x1c>
40381662:	082c      	movi.n	a8, 32
40381664:	000086        	j	4038166a <spi_flash_command_winbond_erase_sector_4B+0x1e>
40381667:	881c00        	lsi	f0, a12, 0x220
4038166a:	034182        	s8i	a8, a1, 3
4038166d:	1139      	s32i.n	a3, a1, 4
4038166f:	880c      	movi.n	a8, 8
40381671:	4189      	s32i.n	a8, a1, 16
40381673:	ce8781        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
40381676:	04b837        	bgeu	a8, a3, 4038167e <spi_flash_command_winbond_erase_sector_4B+0x32>
40381679:	182c      	movi.n	a8, 33
4038167b:	000046        	j	40381680 <spi_flash_command_winbond_erase_sector_4B+0x34>
4038167e:	082c      	movi.n	a8, 32
40381680:	0a5182        	s16i	a8, a1, 20
        .command = (addr_4b? CMD_SECTOR_ERASE_4B: CMD_SECTOR_ERASE),
        .address_bitlen = (addr_4b? 32: 24),
        .address = start_address,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
40381683:	02a8      	l32i.n	a10, a2, 0
40381685:	0a88      	l32i.n	a8, a10, 0
40381687:	1888      	l32i.n	a8, a8, 4
40381689:	01bd      	mov.n	a11, a1
4038168b:	0008e0        	callx8	a8
}
4038168e:	0a2d      	mov.n	a2, a10
40381690:	f01d      	retw.n
	...

40381694 <spi_flash_chip_winbond_erase_sector>:
{
40381694:	004136        	entry	a1, 32
40381697:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40381699:	1288      	l32i.n	a8, a2, 4
4038169b:	b888      	l32i.n	a8, a8, 44
4038169d:	0b0c      	movi.n	a11, 0
4038169f:	02ad      	mov.n	a10, a2
403816a1:	0008e0        	callx8	a8
403816a4:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
403816a6:	eacc      	bnez.n	a10, 403816b8 <spi_flash_chip_winbond_erase_sector+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403816a8:	1788      	l32i.n	a8, a7, 4
403816aa:	152892        	l32i	a9, a8, 84
403816ad:	1888      	l32i.n	a8, a8, 4
403816af:	08b8      	l32i.n	a11, a8, 0
403816b1:	07ad      	mov.n	a10, a7
403816b3:	0009e0        	callx8	a9
403816b6:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403816b8:	40f290        	nsau	a9, a2
403816bb:	419590        	srli	a9, a9, 5
403816be:	faae82        	movi	a8, 0xfffffefa
403816c1:	828a      	add.n	a8, a2, a8
403816c3:	40f880        	nsau	a8, a8
403816c6:	418580        	srli	a8, a8, 5
403816c9:	209980        	or	a9, a9, a8
403816cc:	068916        	beqz	a9, 40381738 <spi_flash_chip_winbond_erase_sector+0xa4>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
403816cf:	2788      	l32i.n	a8, a7, 8
403816d1:	9888      	l32i.n	a8, a8, 36
403816d3:	388c      	beqz.n	a8, 403816da <spi_flash_chip_winbond_erase_sector+0x46>
403816d5:	1a0c      	movi.n	a10, 1
403816d7:	0008e0        	callx8	a8
        err = spi_flash_command_winbond_erase_sector_4B(chip, start_address);
403816da:	20b330        	or	a11, a3, a3
403816dd:	20a770        	or	a10, a7, a7
403816e0:	fff6a5        	call8	4038164c <spi_flash_command_winbond_erase_sector_4B>
403816e3:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
403816e6:	04ea56        	bnez	a10, 40381738 <spi_flash_chip_winbond_erase_sector+0xa4>
        chip->busy = 1;
403816e9:	7788      	l32i.n	a8, a7, 28
403816eb:	190c      	movi.n	a9, 1
403816ed:	208890        	or	a8, a8, a9
403816f0:	7789      	s32i.n	a8, a7, 28
        if (chip->host->driver->flush_cache) {
403816f2:	07a8      	l32i.n	a10, a7, 0
403816f4:	0a88      	l32i.n	a8, a10, 0
403816f6:	112882        	l32i	a8, a8, 68
403816f9:	b88c      	beqz.n	a8, 40381708 <spi_flash_chip_winbond_erase_sector+0x74>
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->sector_size);
403816fb:	1798      	l32i.n	a9, a7, 4
403816fd:	89c8      	l32i.n	a12, a9, 32
403816ff:	03bd      	mov.n	a11, a3
40381701:	0008e0        	callx8	a8
40381704:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
40381706:	eaec      	bnez.n	a10, 40381738 <spi_flash_chip_winbond_erase_sector+0xa4>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
40381708:	1788      	l32i.n	a8, a7, 4
4038170a:	152892        	l32i	a9, a8, 84
4038170d:	1888      	l32i.n	a8, a8, 4
4038170f:	38b8      	l32i.n	a11, a8, 12
40381711:	07ad      	mov.n	a10, a7
40381713:	0009e0        	callx8	a9
40381716:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40381718:	2788      	l32i.n	a8, a7, 8
4038171a:	9888      	l32i.n	a8, a8, 36
4038171c:	488c      	beqz.n	a8, 40381724 <spi_flash_chip_winbond_erase_sector+0x90>
4038171e:	00a0a2        	movi	a10, 0
40381721:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381724:	06a182        	movi	a8, 0x106
40381727:	0d9287        	bne	a2, a8, 40381738 <spi_flash_chip_winbond_erase_sector+0xa4>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038172a:	1788      	l32i.n	a8, a7, 4
4038172c:	b888      	l32i.n	a8, a8, 44
4038172e:	1b0c      	movi.n	a11, 1
40381730:	20a770        	or	a10, a7, a7
40381733:	0008e0        	callx8	a8
40381736:	0a2d      	mov.n	a2, a10
}
40381738:	f01d      	retw.n
	...

4038173c <spi_flash_command_erase_block_4B>:

esp_err_t spi_flash_command_erase_block_4B(esp_flash_t *chip, uint32_t start_address)
{
4038173c:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(start_address);
    spi_flash_trans_t t = {
4038173f:	cc1c      	movi.n	a12, 28
40381741:	0b0c      	movi.n	a11, 0
40381743:	20a110        	or	a10, a1, a1
40381746:	cb5281        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381749:	0008e0        	callx8	a8
4038174c:	ce5181        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
4038174f:	05b837        	bgeu	a8, a3, 40381758 <spi_flash_command_erase_block_4B+0x1c>
40381752:	082c      	movi.n	a8, 32
40381754:	000086        	j	4038175a <spi_flash_command_erase_block_4B+0x1e>
40381757:	881c00        	lsi	f0, a12, 0x220
4038175a:	034182        	s8i	a8, a1, 3
4038175d:	1139      	s32i.n	a3, a1, 4
4038175f:	880c      	movi.n	a8, 8
40381761:	4189      	s32i.n	a8, a1, 16
40381763:	ce4b81        	l32r	a8, 40375090 <_iram_text_start+0xc8c> (ffffff <UserFrameTotalSize+0xfffeff>)
40381766:	06b837        	bgeu	a8, a3, 40381770 <spi_flash_command_erase_block_4B+0x34>
40381769:	dca082        	movi	a8, 220
4038176c:	0000c6        	j	40381773 <spi_flash_command_erase_block_4B+0x37>
4038176f:	a08200        	addx4	a8, a2, a0
40381772:	82d8      	l32i.n	a13, a2, 32
40381774:	a80a51        	l32r	a5, 4036b79c <rom_rx_gain_force+0x365370>
        .command = (addr_4b? CMD_LARGE_BLOCK_ERASE_4B: CMD_LARGE_BLOCK_ERASE),
        .address_bitlen = (addr_4b? 32: 24),
        .address = start_address,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
40381777:	0a8802        	lsi	f0, a8, 40
4038177a:	1888      	l32i.n	a8, a8, 4
4038177c:	01bd      	mov.n	a11, a1
4038177e:	0008e0        	callx8	a8
}
40381781:	0a2d      	mov.n	a2, a10
40381783:	f01d      	retw.n
40381785:	000000        	ill

40381788 <spi_flash_chip_winbond_erase_block>:
{
40381788:	004136        	entry	a1, 32
4038178b:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4038178d:	1288      	l32i.n	a8, a2, 4
4038178f:	b888      	l32i.n	a8, a8, 44
40381791:	0b0c      	movi.n	a11, 0
40381793:	02ad      	mov.n	a10, a2
40381795:	0008e0        	callx8	a8
40381798:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
4038179a:	eacc      	bnez.n	a10, 403817ac <spi_flash_chip_winbond_erase_block+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4038179c:	1788      	l32i.n	a8, a7, 4
4038179e:	152892        	l32i	a9, a8, 84
403817a1:	1888      	l32i.n	a8, a8, 4
403817a3:	08b8      	l32i.n	a11, a8, 0
403817a5:	07ad      	mov.n	a10, a7
403817a7:	0009e0        	callx8	a9
403817aa:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403817ac:	40f290        	nsau	a9, a2
403817af:	419590        	srli	a9, a9, 5
403817b2:	faae82        	movi	a8, 0xfffffefa
403817b5:	828a      	add.n	a8, a2, a8
403817b7:	40f880        	nsau	a8, a8
403817ba:	418580        	srli	a8, a8, 5
403817bd:	209980        	or	a9, a9, a8
403817c0:	068916        	beqz	a9, 4038182c <spi_flash_chip_winbond_erase_block+0xa4>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
403817c3:	2788      	l32i.n	a8, a7, 8
403817c5:	9888      	l32i.n	a8, a8, 36
403817c7:	388c      	beqz.n	a8, 403817ce <spi_flash_chip_winbond_erase_block+0x46>
403817c9:	1a0c      	movi.n	a10, 1
403817cb:	0008e0        	callx8	a8
        err = spi_flash_command_erase_block_4B(chip, start_address);
403817ce:	20b330        	or	a11, a3, a3
403817d1:	20a770        	or	a10, a7, a7
403817d4:	fff665        	call8	4038173c <spi_flash_command_erase_block_4B>
403817d7:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
403817da:	04ea56        	bnez	a10, 4038182c <spi_flash_chip_winbond_erase_block+0xa4>
        chip->busy = 1;
403817dd:	7788      	l32i.n	a8, a7, 28
403817df:	190c      	movi.n	a9, 1
403817e1:	208890        	or	a8, a8, a9
403817e4:	7789      	s32i.n	a8, a7, 28
        if (chip->host->driver->flush_cache) {
403817e6:	07a8      	l32i.n	a10, a7, 0
403817e8:	0a88      	l32i.n	a8, a10, 0
403817ea:	112882        	l32i	a8, a8, 68
403817ed:	b88c      	beqz.n	a8, 403817fc <spi_flash_chip_winbond_erase_block+0x74>
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->block_erase_size);
403817ef:	1798      	l32i.n	a9, a7, 4
403817f1:	99c8      	l32i.n	a12, a9, 36
403817f3:	03bd      	mov.n	a11, a3
403817f5:	0008e0        	callx8	a8
403817f8:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
403817fa:	eaec      	bnez.n	a10, 4038182c <spi_flash_chip_winbond_erase_block+0xa4>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
403817fc:	1788      	l32i.n	a8, a7, 4
403817fe:	152892        	l32i	a9, a8, 84
40381801:	1888      	l32i.n	a8, a8, 4
40381803:	28b8      	l32i.n	a11, a8, 8
40381805:	07ad      	mov.n	a10, a7
40381807:	0009e0        	callx8	a9
4038180a:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
4038180c:	2788      	l32i.n	a8, a7, 8
4038180e:	9888      	l32i.n	a8, a8, 36
40381810:	488c      	beqz.n	a8, 40381818 <spi_flash_chip_winbond_erase_block+0x90>
40381812:	00a0a2        	movi	a10, 0
40381815:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381818:	06a182        	movi	a8, 0x106
4038181b:	0d9287        	bne	a2, a8, 4038182c <spi_flash_chip_winbond_erase_block+0xa4>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038181e:	1788      	l32i.n	a8, a7, 4
40381820:	b888      	l32i.n	a8, a8, 44
40381822:	1b0c      	movi.n	a11, 1
40381824:	20a770        	or	a10, a7, a7
40381827:	0008e0        	callx8	a8
4038182a:	0a2d      	mov.n	a2, a10
}
4038182c:	f01d      	retw.n
	...

40381830 <spi_flash_chip_winbond_read>:
{
40381830:	010136        	entry	a1, 128
    const uint32_t page_size = chip->chip_drv->page_size;
40381833:	1288      	l32i.n	a8, a2, 4
40381835:	132892        	l32i	a9, a8, 76
40381838:	176192        	s32i	a9, a1, 92
    if (REGION_32BIT(address, length)) {
4038183b:	945a      	add.n	a9, a4, a5
4038183d:	cc1da1        	l32r	a10, 403748b4 <_iram_text_start+0x4b0> (1000000 <UserFrameTotalSize+0xffff00>)
40381840:	063a97        	bltu	a10, a9, 4038184a <spi_flash_chip_winbond_read+0x1a>
    uint32_t config_io_flags = 0;
40381843:	0b0c      	movi.n	a11, 0
40381845:	000106        	j	4038184d <spi_flash_chip_winbond_read+0x1d>
40381848:	b20000        	mulsh	a0, a0, a0
        config_io_flags |= SPI_FLASH_CONFIG_IO_MODE_32B_ADDR;
4038184b:	8201a0        	mull	a0, a1, a10
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
4038184e:	1e28      	l32i.n	a2, a14, 4
40381850:	20a220        	or	a10, a2, a2
40381853:	0008e0        	callx8	a8
40381856:	1561a2        	s32i	a10, a1, 84
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381859:	06a182        	movi	a8, 0x106
4038185c:	021a87        	beq	a10, a8, 40381862 <spi_flash_chip_winbond_read+0x32>
4038185f:	001e46        	j	403818dc <spi_flash_chip_winbond_read+0xac>
        ESP_LOGE(TAG, "configure host io mode failed - unsupported");
40381862:	fe37e5        	call8	4037fbe0 <esp_log_timestamp>
40381865:	ce39b1        	l32r	a11, 4037514c <_iram_text_start+0xd48> (3fc947ec <TAG>)
40381868:	20ebb0        	or	a14, a11, a11
4038186b:	0add      	mov.n	a13, a10
4038186d:	ce38c1        	l32r	a12, 40375150 <_iram_text_start+0xd4c> (3fc93b80 <__FUNCTION__$0+0x3e8>)
40381870:	1a0c      	movi.n	a10, 1
40381872:	fe3b65        	call8	4037fc28 <esp_log_write>
        return err;
40381875:	001c06        	j	403818e9 <spi_flash_chip_winbond_read+0xb9>
40381878:	614b00        	lsi	f0, a11, 0x184
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
4038187b:	0c4c      	movi.n	a12, 64
4038187d:	ffa0b2        	movi	a11, 255
40381880:	06ad      	mov.n	a10, a6
40381882:	cb0381        	l32r	a8, 40374490 <_iram_text_start+0x8c> (400011e8 <memset>)
40381885:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
40381888:	02a8      	l32i.n	a10, a2, 0
4038188a:	0a88      	l32i.n	a8, a10, 0
4038188c:	d888      	l32i.n	a8, a8, 52
4038188e:	1721e2        	l32i	a14, a1, 92
40381891:	01dd      	mov.n	a13, a1
40381893:	05cd      	mov.n	a12, a5
40381895:	04bd      	mov.n	a11, a4
40381897:	0008e0        	callx8	a8
4038189a:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
4038189c:	01c8      	l32i.n	a12, a1, 0
4038189e:	c084c0        	sub	a8, a4, a12
403818a1:	166182        	s32i	a8, a1, 88
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
403818a4:	754a      	add.n	a7, a5, a4
403818a6:	8caa      	add.n	a8, a12, a10
403818a8:	637780        	minu	a7, a7, a8
403818ab:	c08740        	sub	a8, a7, a4
403818ae:	146182        	s32i	a8, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
403818b1:	02a8      	l32i.n	a10, a2, 0
403818b3:	0a88      	l32i.n	a8, a10, 0
403818b5:	b888      	l32i.n	a8, a8, 44
403818b7:	20b660        	or	a11, a6, a6
403818ba:	0008e0        	callx8	a8
403818bd:	1561a2        	s32i	a10, a1, 84
        memcpy(buffer, temp_buffer + left_off, data_len);
403818c0:	1421c2        	l32i	a12, a1, 80
403818c3:	162192        	l32i	a9, a1, 88
403818c6:	b69a      	add.n	a11, a6, a9
403818c8:	03ad      	mov.n	a10, a3
403818ca:	cb0281        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (400011f4 <memcpy>)
403818cd:	0008e0        	callx8	a8
        buffer = (void *)((intptr_t)buffer + data_len);
403818d0:	142182        	l32i	a8, a1, 80
403818d3:	338a      	add.n	a3, a3, a8
        length = length - data_len;
403818d5:	c04470        	sub	a4, a4, a7
403818d8:	554a      	add.n	a5, a5, a4
        address += data_len;
403818da:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
403818dc:	180c      	movi.n	a8, 1
403818de:	838550        	moveqz	a8, a5, a5
403818e1:	152192        	l32i	a9, a1, 84
403818e4:	19cc      	bnez.n	a9, 403818e9 <spi_flash_chip_winbond_read+0xb9>
403818e6:	f8f856        	bnez	a8, 40381879 <spi_flash_chip_winbond_read+0x49>
}
403818e9:	152122        	l32i	a2, a1, 84
403818ec:	f01d      	retw.n
	...

403818f0 <spi_flash_chip_winbond_probe>:
{
403818f0:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
403818f3:	f53030        	extui	a3, a3, 16, 16
403818f6:	efa082        	movi	a8, 239
403818f9:	049387        	bne	a3, a8, 40381901 <spi_flash_chip_winbond_probe+0x11>
    return ESP_OK;
403818fc:	020c      	movi.n	a2, 0
403818fe:	000086        	j	40381904 <spi_flash_chip_winbond_probe+0x14>
        return ESP_ERR_NOT_FOUND;
40381901:	05a122        	movi	a2, 0x105
}
40381904:	f01d      	retw.n
	...

40381908 <spi_flash_chip_winbond_get_caps>:
{
40381908:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
4038190b:	180282        	l8ui	a8, a2, 24
4038190e:	891c      	movi.n	a9, 24
40381910:	043987        	bltu	a9, a8, 40381918 <spi_flash_chip_winbond_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
40381913:	020c      	movi.n	a2, 0
40381915:	000046        	j	4038191a <spi_flash_chip_winbond_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_32MB_SUPPORT;
40381918:	220c      	movi.n	a2, 2
}
4038191a:	480c      	movi.n	a8, 4
4038191c:	202280        	or	a2, a2, a8
4038191f:	f01d      	retw.n
40381921:	000000        	ill

40381924 <spi_flash_enable_high_performance_mode>:
//!CONFIG_SPI_FLASH_UNDER_HIGH_FREQ

static spi_flash_hpm_dummy_conf_t s_dummy_conf;

esp_err_t spi_flash_enable_high_performance_mode(void)
{
40381924:	004136        	entry	a1, 32
    return ESP_OK;
}
40381927:	020c      	movi.n	a2, 0
40381929:	f01d      	retw.n
	...

4038192c <s_register_rom_function>:
extern const spiflash_legacy_funcs_t *rom_spiflash_legacy_funcs;
static uint32_t s_chip_id;


static void s_register_rom_function(void)
{
4038192c:	004136        	entry	a1, 32
        .write = esp_rom_opiflash_write,
        .wait_idle = esp_rom_opiflash_wait_idle,
        .wren = esp_rom_opiflash_wren,
        .erase_area = esp_rom_opiflash_erase_area,
    };
    rom_spiflash_legacy_funcs = &rom_func;
4038192f:	ce0981        	l32r	a8, 40375154 <_iram_text_start+0xd50> (3fceffe8 <rom_spiflash_legacy_funcs>)
40381932:	ce0991        	l32r	a9, 40375158 <_iram_text_start+0xd54> (3fc92610 <rom_func$0>)
40381935:	0899      	s32i.n	a9, a8, 0
}
40381937:	f01d      	retw.n
40381939:	000000        	ill

4038193c <s_set_pin_drive_capability>:
                              ESP_ROM_OPIFLASH_SEL_CS0,
                              false);
}

static void s_set_pin_drive_capability(uint8_t drv)
{
4038193c:	004136        	entry	a1, 32
    //flash clock
    REG_SET_FIELD(SPI_MEM_DATE_REG(0), SPI_MEM_SPI_FMEM_SPICLK_FUN_DRV, 3);
4038193f:	cc0591        	l32r	a9, 40374954 <_iram_text_start+0x550> (600033fc <SPIMEM0+0x3fc>)
40381942:	0020c0        	memw
40381945:	0988      	l32i.n	a8, a9, 0
40381947:	ca0c      	movi.n	a10, 12
40381949:	2088a0        	or	a8, a8, a10
4038194c:	0020c0        	memw
4038194f:	0989      	s32i.n	a8, a9, 0
    //cs0
    PIN_SET_DRV(IO_MUX_GPIO29_REG, 3);
40381951:	ce0291        	l32r	a9, 4037515c <_iram_text_start+0xd58> (60009078 <SENS+0x878>)
40381954:	0020c0        	memw
40381957:	0988      	l32i.n	a8, a9, 0
40381959:	cc00a1        	l32r	a10, 4037495c <_iram_text_start+0x558> (c00 <UserFrameTotalSize+0xb00>)
4038195c:	2088a0        	or	a8, a8, a10
4038195f:	0020c0        	memw
40381962:	0989      	s32i.n	a8, a9, 0
}
40381964:	f01d      	retw.n
	...

40381968 <s_probe_mxic_chip>:
{
40381968:	004136        	entry	a1, 32
    if (chip_id >> 16 != ESP_FLASH_CHIP_MXIC_OCT) {
4038196b:	f59020        	extui	a9, a2, 16, 16
4038196e:	c2a082        	movi	a8, 194
40381971:	379987        	bne	a9, a8, 403819ac <s_probe_mxic_chip+0x44>
    if (((chip_id >> 8) & 0xf0) != 0x80) {
40381974:	342c20        	extui	a2, a2, 12, 4
40381977:	112240        	slli	a2, a2, 12
4038197a:	cab681        	l32r	a8, 40374454 <_iram_text_start+0x50> (8000 <UserFrameTotalSize+0x7f00>)
4038197d:	1f1287        	beq	a2, a8, 403819a0 <s_probe_mxic_chip+0x38>
40381980:	cabb81        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40381983:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Detected MXIC Flash, but memory type is not Octal");
40381985:	f88c      	beqz.n	a8, 40381998 <s_probe_mxic_chip+0x30>
40381987:	fe25a5        	call8	4037fbe0 <esp_log_timestamp>
4038198a:	cdf5c1        	l32r	a12, 40375160 <_iram_text_start+0xd5c> (3fc93ad0 <__FUNCTION__$0+0x338>)
4038198d:	0abd      	mov.n	a11, a10
4038198f:	cdf5a1        	l32r	a10, 40375164 <_iram_text_start+0xd60> (3fc93adc <__FUNCTION__$0+0x344>)
40381992:	cac881        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40381995:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
40381998:	05a122        	movi	a2, 0x105
4038199b:	000406        	j	403819af <s_probe_mxic_chip+0x47>
4038199e:	820000        	mull	a0, a0, a0
    *out_vendor_id = ESP_FLASH_CHIP_MXIC_OCT;
403819a1:	af          	.byte	0xaf
403819a2:	4382c2        	lsi	f12, a2, 0x10c
403819a5:	020c00        	andb	b0, b12, b0
    return ESP_OK;
403819a8:	0000c6        	j	403819af <s_probe_mxic_chip+0x47>
403819ab:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
403819ae:	f01d05        	call0	40371b80 <rom_rx_gain_force+0x36b754>
403819b1:	000000        	ill

403819b4 <s_mxic_set_required_regs>:
    esp_rom_opiflash_wait_idle();
}
#endif   // #if CONFIG_SPI_FLASH_SUPPORT_MXIC_OPI_CHIP

static void s_mxic_set_required_regs(uint32_t chip_id)
{
403819b4:	004136        	entry	a1, 32
#if CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_DTR
    is_swap = true;
#else
    //STR mode does not need to enable ddr_swap registers
#endif
    esp_rom_spi_set_dtr_swap_mode(0, is_swap, is_swap);
403819b7:	0c0c      	movi.n	a12, 0
403819b9:	0cbd      	mov.n	a11, a12
403819bb:	20acc0        	or	a10, a12, a12
403819be:	cdea81        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
403819c1:	0008e0        	callx8	a8
    esp_rom_spi_set_dtr_swap_mode(1, is_swap, is_swap);
403819c4:	0c0c      	movi.n	a12, 0
403819c6:	0cbd      	mov.n	a11, a12
403819c8:	1a0c      	movi.n	a10, 1
403819ca:	cde781        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
403819cd:	0008e0        	callx8	a8
}
403819d0:	f01d      	retw.n
	...

403819d4 <s_set_flash_ouput_driver_strength>:
{
403819d4:	00a136        	entry	a1, 80
    uint16_t reg_val = 0;
403819d7:	080c      	movi.n	a8, 0
403819d9:	105182        	s16i	a8, a1, 32
    uint8_t sr_reg_val = 0;
403819dc:	224182        	s8i	a8, a1, 34
    uint8_t cr_reg_val = 0;
403819df:	234182        	s8i	a8, a1, 35
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
403819e2:	070c      	movi.n	a7, 0
403819e4:	6179      	s32i.n	a7, a1, 24
403819e6:	150c      	movi.n	a5, 1
403819e8:	5159      	s32i.n	a5, a1, 20
403819ea:	860c      	movi.n	a6, 8
403819ec:	4169      	s32i.n	a6, a1, 16
403819ee:	22c182        	addi	a8, a1, 34
403819f1:	3189      	s32i.n	a8, a1, 12
403819f3:	2179      	s32i.n	a7, a1, 8
403819f5:	1179      	s32i.n	a7, a1, 4
403819f7:	0179      	s32i.n	a7, a1, 0
403819f9:	07fd      	mov.n	a15, a7
403819fb:	07ed      	mov.n	a14, a7
403819fd:	06dd      	mov.n	a13, a6
403819ff:	5c0c      	movi.n	a12, 5
40381a01:	4b0c      	movi.n	a11, 4
40381a03:	20a220        	or	a10, a2, a2
40381a06:	cdd981        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381a09:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381a0c:	6179      	s32i.n	a7, a1, 24
40381a0e:	5159      	s32i.n	a5, a1, 20
40381a10:	4169      	s32i.n	a6, a1, 16
40381a12:	23c182        	addi	a8, a1, 35
40381a15:	3189      	s32i.n	a8, a1, 12
40381a17:	2179      	s32i.n	a7, a1, 8
40381a19:	1179      	s32i.n	a7, a1, 4
40381a1b:	0179      	s32i.n	a7, a1, 0
40381a1d:	07fd      	mov.n	a15, a7
40381a1f:	07ed      	mov.n	a14, a7
40381a21:	06dd      	mov.n	a13, a6
40381a23:	5c1c      	movi.n	a12, 21
40381a25:	4b0c      	movi.n	a11, 4
40381a27:	20a220        	or	a10, a2, a2
40381a2a:	cdd081        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381a2d:	0008e0        	callx8	a8
    reg_val = (((cr_reg_val & 0xf8) | strength) << 8) | sr_reg_val;
40381a30:	230182        	l8ui	a8, a1, 35
40381a33:	897c      	movi.n	a9, -8
40381a35:	108890        	and	a8, a8, a9
40381a38:	203380        	or	a3, a3, a8
40381a3b:	401600        	ssl	a6
40381a3e:	a13300        	sll	a3, a3
40381a41:	220182        	l8ui	a8, a1, 34
40381a44:	208830        	or	a8, a8, a3
40381a47:	105182        	s16i	a8, a1, 32
    esp_rom_spiflash_write_enable(&g_rom_flashchip);
40381a4a:	cb6981        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40381a4d:	08a8      	l32i.n	a10, a8, 0
40381a4f:	cdc881        	l32r	a8, 40375170 <_iram_text_start+0xd6c> (40000a44 <SPI_write_enable>)
40381a52:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381a55:	6179      	s32i.n	a7, a1, 24
40381a57:	5159      	s32i.n	a5, a1, 20
40381a59:	4179      	s32i.n	a7, a1, 16
40381a5b:	3179      	s32i.n	a7, a1, 12
40381a5d:	081c      	movi.n	a8, 16
40381a5f:	2189      	s32i.n	a8, a1, 8
40381a61:	20c182        	addi	a8, a1, 32
40381a64:	1189      	s32i.n	a8, a1, 4
40381a66:	0179      	s32i.n	a7, a1, 0
40381a68:	07fd      	mov.n	a15, a7
40381a6a:	07ed      	mov.n	a14, a7
40381a6c:	06dd      	mov.n	a13, a6
40381a6e:	05cd      	mov.n	a12, a5
40381a70:	4b0c      	movi.n	a11, 4
40381a72:	02ad      	mov.n	a10, a2
40381a74:	cdbe81        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381a77:	0008e0        	callx8	a8
}
40381a7a:	f01d      	retw.n

40381a7c <s_set_flash_dtr_str_opi_mode>:
{
40381a7c:	00a136        	entry	a1, 80
40381a7f:	204132        	s8i	a3, a1, 32
    esp_rom_spiflash_write_enable(&g_rom_flashchip);
40381a82:	cb5b81        	l32r	a8, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40381a85:	0028a2        	l32i	a10, a8, 0
40381a88:	cdba81        	l32r	a8, 40375170 <_iram_text_start+0xd6c> (40000a44 <SPI_write_enable>)
40381a8b:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381a8e:	0e0c      	movi.n	a14, 0
40381a90:	61e9      	s32i.n	a14, a1, 24
40381a92:	180c      	movi.n	a8, 1
40381a94:	5189      	s32i.n	a8, a1, 20
40381a96:	41e9      	s32i.n	a14, a1, 16
40381a98:	31e9      	s32i.n	a14, a1, 12
40381a9a:	8d0c      	movi.n	a13, 8
40381a9c:	21d9      	s32i.n	a13, a1, 8
40381a9e:	20c182        	addi	a8, a1, 32
40381aa1:	1189      	s32i.n	a8, a1, 4
40381aa3:	01e9      	s32i.n	a14, a1, 0
40381aa5:	0f2c      	movi.n	a15, 32
40381aa7:	72a0c2        	movi	a12, 114
40381aaa:	4b0c      	movi.n	a11, 4
40381aac:	02ad      	mov.n	a10, a2
40381aae:	cdaf81        	l32r	a8, 4037516c <_iram_text_start+0xd68> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381ab1:	0008e0        	callx8	a8
}
40381ab4:	f01d      	retw.n
	...

40381ab8 <s_flash_init_mxic>:
{
40381ab8:	004136        	entry	a1, 32
    esp_rom_opiflash_legacy_driver_init(&opiflash_cmd_def_mxic);
40381abb:	cdaea1        	l32r	a10, 40375174 <_iram_text_start+0xd70> (3fc947f4 <opiflash_cmd_def_mxic$1>)
40381abe:	cdaf81        	l32r	a8, 4037517c <_iram_text_start+0xd78> (40000954 <esp_rom_opiflash_legacy_driver_init>)
40381ac1:	0008e0        	callx8	a8
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
40381ac4:	cb4b71        	l32r	a7, 403747f0 <_iram_text_start+0x3ec> (3fceffe4 <rom_spiflash_legacy_data>)
40381ac7:	0027a2        	l32i	a10, a7, 0
40381aca:	cdad81        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (40000960 <esp_rom_spiflash_wait_idle>)
40381acd:	0008e0        	callx8	a8
    s_set_flash_ouput_driver_strength(1, 7);
40381ad0:	7b0c      	movi.n	a11, 7
40381ad2:	1a0c      	movi.n	a10, 1
40381ad4:	ffefe5        	call8	403819d4 <s_set_flash_ouput_driver_strength>
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
40381ad7:	07a8      	l32i.n	a10, a7, 0
40381ad9:	cda981        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (40000960 <esp_rom_spiflash_wait_idle>)
40381adc:	0008e0        	callx8	a8
    s_set_pin_drive_capability(3);
40381adf:	3a0c      	movi.n	a10, 3
40381ae1:	ffe5a5        	call8	4038193c <s_set_pin_drive_capability>
    s_set_flash_dtr_str_opi_mode(1, 0x1);
40381ae4:	1b0c      	movi.n	a11, 1
40381ae6:	0bad      	mov.n	a10, a11
40381ae8:	fff925        	call8	40381a7c <s_set_flash_dtr_str_opi_mode>
    esp_rom_opiflash_cache_mode_config(mode, &rom_opiflash_cmd_def->cache_rd_cmd);
40381aeb:	cda381        	l32r	a8, 40375178 <_iram_text_start+0xd74> (3fcefff4 <rom_opiflash_cmd_def>)
40381aee:	08b8      	l32i.n	a11, a8, 0
40381af0:	54cbb2        	addi	a11, a11, 84
40381af3:	02ad      	mov.n	a10, a2
40381af5:	f7b0e5        	call8	40379604 <esp_rom_opiflash_cache_mode_config>
    esp_rom_spi_set_dtr_swap_mode(0, false, false);
40381af8:	0c0c      	movi.n	a12, 0
40381afa:	0cbd      	mov.n	a11, a12
40381afc:	0cad      	mov.n	a10, a12
40381afe:	cd9a81        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381b01:	0008e0        	callx8	a8
    esp_rom_spi_set_dtr_swap_mode(1, false, false);
40381b04:	0c0c      	movi.n	a12, 0
40381b06:	0cbd      	mov.n	a11, a12
40381b08:	1a0c      	movi.n	a10, 1
40381b0a:	cd9781        	l32r	a8, 40375168 <_iram_text_start+0xd64> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381b0d:	0008e0        	callx8	a8
    esp_rom_opiflash_wait_idle();
40381b10:	cd9d81        	l32r	a8, 40375184 <_iram_text_start+0xd80> (400008e8 <esp_rom_opiflash_wait_idle>)
40381b13:	0008e0        	callx8	a8
}
40381b16:	f01d      	retw.n

40381b18 <esp_opiflash_init>:

//To check which Flash chip is used
static const opi_flash_func_t **s_chip_func = NULL;

esp_err_t esp_opiflash_init(uint32_t chip_id)
{
40381b18:	006136        	entry	a1, 48
    mode = ESP_ROM_SPIFLASH_FASTRD_MODE;
#endif

    const opi_flash_func_t **chip_func = &registered_chip_funcs[0];

    uint8_t vendor_id = 0;
40381b1b:	080c      	movi.n	a8, 0
40381b1d:	004182        	s8i	a8, a1, 0
    const opi_flash_func_t **chip_func = &registered_chip_funcs[0];
40381b20:	cd9a61        	l32r	a6, 40375188 <_iram_text_start+0xd84> (3fc92644 <registered_chip_funcs>)
    esp_err_t ret = ESP_FAIL;
40381b23:	f77c      	movi.n	a7, -1
    while (*chip_func) {
40381b25:	0009c6        	j	40381b50 <esp_opiflash_init+0x38>
40381b28:	288200        	lsi	f0, a2, 160
        ret = (*chip_func)->probe(chip_id, &vendor_id);
40381b2b:	b11000        	sra	a1, a0
40381b2e:	a22020        	muluh	a2, a0, a2
40381b31:	08e020        	lsx	f14, a0, a2
40381b34:	0a7d00        	add.s	f7, f13, f0
        if (ret == ESP_OK) {
40381b37:	2adc      	bnez.n	a10, 40381b4d <esp_opiflash_init+0x35>
            // Detect this is the supported chip type
            s_chip_id = chip_id;
40381b39:	cd9481        	l32r	a8, 4037518c <_iram_text_start+0xd88> (3fc95ef4 <s_chip_id>)
40381b3c:	0829      	s32i.n	a2, a8, 0
            (*chip_func)->init(mode);
40381b3e:	0688      	l32i.n	a8, a6, 0
40381b40:	1888      	l32i.n	a8, a8, 4
40381b42:	6a0c      	movi.n	a10, 6
40381b44:	0008e0        	callx8	a8
            s_register_rom_function();
40381b47:	ffde65        	call8	4038192c <s_register_rom_function>
            break;
40381b4a:	000206        	j	40381b56 <esp_opiflash_init+0x3e>
        }
        chip_func++;
40381b4d:	04c662        	addi	a6, a6, 4
    while (*chip_func) {
40381b50:	002682        	l32i	a8, a6, 0
40381b53:	fd2856        	bnez	a8, 40381b29 <esp_opiflash_init+0x11>
    }
    s_chip_func = chip_func;
40381b56:	cd8e81        	l32r	a8, 40375190 <_iram_text_start+0xd8c> (3fc95ef0 <s_chip_func>)
40381b59:	0869      	s32i.n	a6, a8, 0

    if (ret != ESP_OK) {
40381b5b:	979c      	beqz.n	a7, 40381b78 <esp_opiflash_init+0x60>
40381b5d:	ca4381        	l32r	a8, 4037446c <_iram_text_start+0x68> (3fc91f3c <esp_log_default_level>)
40381b60:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "No detected Flash chip, please check the menuconfig to see if the chip is supported");
40381b62:	f88c      	beqz.n	a8, 40381b75 <esp_opiflash_init+0x5d>
40381b64:	fe07a5        	call8	4037fbe0 <esp_log_timestamp>
40381b67:	cd7ec1        	l32r	a12, 40375160 <_iram_text_start+0xd5c> (3fc93ad0 <__FUNCTION__$0+0x338>)
40381b6a:	0abd      	mov.n	a11, a10
40381b6c:	cd8aa1        	l32r	a10, 40375194 <_iram_text_start+0xd90> (3fc93b1c <__FUNCTION__$0+0x384>)
40381b6f:	ca5181        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (400005d0 <esp_rom_printf>)
40381b72:	0008e0        	callx8	a8
        abort();
40381b75:	fe11e5        	call8	4037fc94 <abort>
    }

    return ESP_OK;
}
40381b78:	020c      	movi.n	a2, 0
40381b7a:	f01d      	retw.n

40381b7c <xthal_window_spill_nw>:
40381b7c:	034820        	rsr.windowbase	a2
40381b7f:	221b      	addi.n	a2, a2, 1
40381b81:	400200        	ssr	a2
40381b84:	034930        	rsr.windowstart	a3
40381b87:	912030        	srl	a2, a3
40381b8a:	a13300        	sll	a3, a3
40381b8d:	0bf3d6        	bgez	a3, 40381c50 <xthal_window_spill_nw+0xd4>
40381b90:	f53030        	extui	a3, a3, 16, 16
40381b93:	202230        	or	a2, a2, a3
40381b96:	603020        	neg	a3, a2
40381b99:	103320        	and	a3, a3, a2
40381b9c:	40f330        	nsau	a3, a3
40381b9f:	401300        	ssl	a3
40381ba2:	912020        	srl	a2, a2
40381ba5:	134920        	wsr.windowstart	a2
40381ba8:	034820        	rsr.windowbase	a2
40381bab:	1fc222        	addi	a2, a2, 31
40381bae:	c03230        	sub	a3, a2, a3
40381bb1:	134830        	wsr.windowbase	a3
40381bb4:	002010        	rsync
40381bb7:	034920        	rsr.windowstart	a2
40381bba:	07a216        	beqz	a2, 40381c38 <xthal_window_spill_nw+0xbc>
40381bbd:	08e207        	bbsi	a2, 0, 40381bc9 <xthal_window_spill_nw+0x4d>
40381bc0:	19e217        	bbsi	a2, 1, 40381bdd <xthal_window_spill_nw+0x61>
40381bc3:	3ae227        	bbsi	a2, 2, 40381c01 <xthal_window_spill_nw+0x85>
40381bc6:	002306        	j	40381c56 <xthal_window_spill_nw+0xda>
40381bc9:	f0c932        	addi	a3, a9, -16
40381bcc:	0349      	s32i.n	a4, a3, 0
40381bce:	1359      	s32i.n	a5, a3, 4
40381bd0:	2369      	s32i.n	a6, a3, 8
40381bd2:	3379      	s32i.n	a7, a3, 12
40381bd4:	416120        	srli	a6, a2, 1
40381bd7:	408010        	rotw	1
40381bda:	fff706        	j	40381bba <xthal_window_spill_nw+0x3e>
40381bdd:	f0cd32        	addi	a3, a13, -16
40381be0:	0349      	s32i.n	a4, a3, 0
40381be2:	1359      	s32i.n	a5, a3, 4
40381be4:	2369      	s32i.n	a6, a3, 8
40381be6:	3379      	s32i.n	a7, a3, 12
40381be8:	f4c532        	addi	a3, a5, -12
40381beb:	0338      	l32i.n	a3, a3, 0
40381bed:	e0c332        	addi	a3, a3, -32
40381bf0:	0389      	s32i.n	a8, a3, 0
40381bf2:	1399      	s32i.n	a9, a3, 4
40381bf4:	23a9      	s32i.n	a10, a3, 8
40381bf6:	33b9      	s32i.n	a11, a3, 12
40381bf8:	41a220        	srli	a10, a2, 2
40381bfb:	408020        	rotw	2
40381bfe:	ffee06        	j	40381bba <xthal_window_spill_nw+0x3e>
40381c01:	408010        	rotw	1
40381c04:	f0cdd2        	addi	a13, a13, -16
40381c07:	0d09      	s32i.n	a0, a13, 0
40381c09:	1d19      	s32i.n	a1, a13, 4
40381c0b:	2d29      	s32i.n	a2, a13, 8
40381c0d:	3d39      	s32i.n	a3, a13, 12
40381c0f:	f4c132        	addi	a3, a1, -12
40381c12:	0338      	l32i.n	a3, a3, 0
40381c14:	10cdd2        	addi	a13, a13, 16
40381c17:	d0c332        	addi	a3, a3, -48
40381c1a:	0349      	s32i.n	a4, a3, 0
40381c1c:	1359      	s32i.n	a5, a3, 4
40381c1e:	2369      	s32i.n	a6, a3, 8
40381c20:	3379      	s32i.n	a7, a3, 12
40381c22:	4389      	s32i.n	a8, a3, 16
40381c24:	5399      	s32i.n	a9, a3, 20
40381c26:	63a9      	s32i.n	a10, a3, 24
40381c28:	73b9      	s32i.n	a11, a3, 28
40381c2a:	4080f0        	rotw	-1
40381c2d:	41e320        	srli	a14, a2, 3
40381c30:	408030        	rotw	3
40381c33:	ffe0c6        	j	40381bba <xthal_window_spill_nw+0x3e>
40381c36:	100000        	and	a0, a0, a0
40381c39:	204080        	or	a4, a0, a8
40381c3c:	0348      	l32i.n	a4, a3, 0
40381c3e:	401200        	ssl	a2
40381c41:	120c      	movi.n	a2, 1
40381c43:	a12200        	sll	a2, a2
40381c46:	134920        	wsr.windowstart	a2
40381c49:	002010        	rsync
40381c4c:	020c      	movi.n	a2, 0
40381c4e:	f00d      	ret.n
40381c50:	120c      	movi.n	a2, 1
40381c52:	f00d      	ret.n
40381c54:	f00000        	subx8	a0, a0, a0
40381c57:	1b1122        	l16ui	a2, a1, 54
40381c5a:	483022        	lsi	f2, a0, 0x120
40381c5d:	e2f703        	lsi	f0, a7, 0x388
40381c60:	0b0a      	add.n	a0, a11, a0
40381c62:	22f033        	lsi	f3, a0, 136
40381c65:	62f711        	l32r	a1, 4035a844 <rom_rx_gain_force+0x354418>
40381c68:	3030f7        	bltu	a0, a15, 40381c9c <xthal_window_spill+0xc>
40381c6b:	130034        	lsi	f3, a0, 76
40381c6e:	320040        	orbc	b0, b0, b4
40381c71:	223011        	l32r	a1, 4034a534 <rom_rx_gain_force+0x344108>
40381c74:	202081        	l32r	a8, 40349cf4 <rom_rx_gain_force+0x3438c8>
40381c77:	4920f4        	mula.da.hl.ldinc	m2, a0, m0, a15
40381c7a:	033013        	lsi	f1, a0, 12
40381c7d:	022c03        	lsi	f0, a12, 8
40381c80:	c03230        	sub	a3, a2, a3
40381c83:	134830        	wsr.windowbase	a3
40381c86:	002010        	rsync
40381c89:	220c      	movi.n	a2, 2
40381c8b:	f00d      	ret.n
40381c8d:	000000        	ill

40381c90 <xthal_window_spill>:
40381c90:	002136        	entry	a1, 16
40381c93:	cbef61        	l32r	a6, 40374c50 <_iram_text_start+0x84c> (fffbfff0 <_rtc_reserved_end+0x9febfff0>)
40381c96:	03e650        	rsr.ps	a5
40381c99:	004d      	mov.n	a4, a0
40381c9b:	102560        	and	a2, a5, a6
40381c9e:	223b      	addi.n	a2, a2, 3
40381ca0:	13e620        	wsr.ps	a2
40381ca3:	002010        	rsync
40381ca6:	ffed45        	call0	40381b7c <xthal_window_spill_nw>
40381ca9:	040d      	mov.n	a0, a4
40381cab:	13e650        	wsr.ps	a5
40381cae:	002010        	rsync
40381cb1:	f01d      	retw.n
	...

40381cb4 <xthal_restore_extra_nw>:
40381cb4:	0238      	l32i.n	a3, a2, 0
40381cb6:	f3e730        	wur.threadptr	a3
40381cb9:	1238      	l32i.n	a3, a2, 4
40381cbb:	131030        	wsr.acclo	a3
40381cbe:	2238      	l32i.n	a3, a2, 8
40381cc0:	131130        	wsr.acchi	a3
40381cc3:	3238      	l32i.n	a3, a2, 12
40381cc5:	130430        	wsr.br	a3
40381cc8:	4238      	l32i.n	a3, a2, 16
40381cca:	130c30        	wsr.scompare1	a3
40381ccd:	5238      	l32i.n	a3, a2, 20
40381ccf:	132030        	wsr.m0	a3
40381cd2:	6238      	l32i.n	a3, a2, 24
40381cd4:	132130        	wsr.m1	a3
40381cd7:	7238      	l32i.n	a3, a2, 28
40381cd9:	132230        	wsr.m2	a3
40381cdc:	8238      	l32i.n	a3, a2, 32
40381cde:	132330        	wsr.m3	a3
40381ce1:	f00d      	ret.n
	...

40381ce4 <xthal_save_extra_nw>:
40381ce4:	e33e70        	rur.threadptr	a3
40381ce7:	0239      	s32i.n	a3, a2, 0
40381ce9:	031030        	rsr.acclo	a3
40381cec:	1239      	s32i.n	a3, a2, 4
40381cee:	031130        	rsr.acchi	a3
40381cf1:	2239      	s32i.n	a3, a2, 8
40381cf3:	030430        	rsr.br	a3
40381cf6:	3239      	s32i.n	a3, a2, 12
40381cf8:	030c30        	rsr.scompare1	a3
40381cfb:	4239      	s32i.n	a3, a2, 16
40381cfd:	032030        	rsr.m0	a3
40381d00:	5239      	s32i.n	a3, a2, 20
40381d02:	032130        	rsr.m1	a3
40381d05:	6239      	s32i.n	a3, a2, 24
40381d07:	032230        	rsr.m2	a3
40381d0a:	7239      	s32i.n	a3, a2, 28
40381d0c:	032330        	rsr.m3	a3
40381d0f:	8239      	s32i.n	a3, a2, 32
40381d11:	f00d      	ret.n
	...

40381d14 <_xt_context_save>:
    .literal_position
    .align  4

_xt_context_save:

    s32i    a2,  sp, XT_STK_A2
40381d14:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
40381d16:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
40381d18:	7149      	s32i.n	a4, a1, 28
    s32i    a5,  sp, XT_STK_A5
40381d1a:	8159      	s32i.n	a5, a1, 32
    s32i    a6,  sp, XT_STK_A6
40381d1c:	9169      	s32i.n	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
40381d1e:	a179      	s32i.n	a7, a1, 40
    s32i    a8,  sp, XT_STK_A8
40381d20:	b189      	s32i.n	a8, a1, 44
    s32i    a9,  sp, XT_STK_A9
40381d22:	c199      	s32i.n	a9, a1, 48
    s32i    a10, sp, XT_STK_A10
40381d24:	d1a9      	s32i.n	a10, a1, 52
    s32i    a11, sp, XT_STK_A11
40381d26:	e1b9      	s32i.n	a11, a1, 56
    Call0 ABI callee-saved regs a12-15 do not need to be saved here.
    a12-13 are the caller's responsibility so it can use them as scratch.
    So only need to save a14-a15 here for Windowed ABI (not Call0).
    */
    #ifndef __XTENSA_CALL0_ABI__
    s32i    a14, sp, XT_STK_A14
40381d28:	1161e2        	s32i	a14, a1, 68
    s32i    a15, sp, XT_STK_A15
40381d2b:	1261f2        	s32i	a15, a1, 72
    #endif

    rsr     a3,  SAR
40381d2e:	030330        	rsr.sar	a3
    s32i    a3,  sp, XT_STK_SAR
40381d31:	136132        	s32i	a3, a1, 76

    #if XCHAL_HAVE_LOOPS
    rsr     a3,  LBEG
40381d34:	030030        	rsr.lbeg	a3
    s32i    a3,  sp, XT_STK_LBEG
40381d37:	166132        	s32i	a3, a1, 88
    rsr     a3,  LEND
40381d3a:	030130        	rsr.lend	a3
    s32i    a3,  sp, XT_STK_LEND
40381d3d:	176132        	s32i	a3, a1, 92
    rsr     a3,  LCOUNT
40381d40:	030230        	rsr.lcount	a3
    s32i    a3,  sp, XT_STK_LCOUNT
40381d43:	186132        	s32i	a3, a1, 96
    l32i    a3,  a3, 0
    s32i    a3,  sp, XT_STK_VPRI
    #endif

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a9,  a0                     /* preserve ret addr */
40381d46:	009d      	mov.n	a9, a0
    #endif

    s32i    a12, sp, XT_STK_TMP0        /* temp. save stuff in stack frame */
40381d48:	1961c2        	s32i	a12, a1, 100
    s32i    a13, sp, XT_STK_TMP1
40381d4b:	1a61d2        	s32i	a13, a1, 104
    s32i    a9,  sp, XT_STK_TMP2
40381d4e:	1b6192        	s32i	a9, a1, 108

    l32i    a12, sp, XT_STK_A12         /* recover original a9,12,13 */
40381d51:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
40381d53:	1021d2        	l32i	a13, a1, 64
    l32i    a9,  sp, XT_STK_A9
40381d56:	c198      	l32i.n	a9, a1, 48

    #if XCHAL_EXTRA_SA_SIZE > 0
    addi    a2,  sp, XT_STK_EXTRA       /* where to save it */
40381d58:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_save_extra_nw         /* destroys a0,2,3 */
40381d5b:	fff885        	call0	40381ce4 <xthal_save_extra_nw>
     * may contain live windows belonging to previous frames in the call stack.
     * These frames will be spilled by SPILL_ALL_WINDOWS, and if the register was
     * used as a temporary by this code, the temporary value would get stored
     * onto the stack, instead of the real value.
     */
    rsr     a2, PS                     /* to be restored after SPILL_ALL_WINDOWS */
40381d5e:	03e620        	rsr.ps	a2
    movi    a0, PS_INTLEVEL_MASK
40381d61:	f00c      	movi.n	a0, 15
    and     a3, a2, a0                 /* get the current INTLEVEL */
40381d63:	103200        	and	a3, a2, a0
    bgeui   a3, XCHAL_EXCM_LEVEL, 1f   /* calculate max(INTLEVEL, XCHAL_EXCM_LEVEL) */
40381d66:	0233f6        	bgeui	a3, 3, 40381d6c <_xt_context_save+0x58>
    movi    a3, XCHAL_EXCM_LEVEL
40381d69:	03a032        	movi	a3, 3
1:
    movi    a0, PS_UM | PS_WOE         /* clear EXCM, enable window overflow, set new INTLEVEL */
40381d6c:	cd0b01        	l32r	a0, 40375198 <_iram_text_start+0xd94> (40020 <UserFrameTotalSize+0x3ff20>)
    or      a3, a3, a0
40381d6f:	203300        	or	a3, a3, a0
    wsr     a3, ps
40381d72:	13e630        	wsr.ps	a3
    rsr     a0, EPC1                   /* to be restored after SPILL_ALL_WINDOWS */
40381d75:	03b100        	rsr.epc1	a0

    addi    sp,  sp, XT_STK_FRMSZ      /* go back to spill register region */
40381d78:	01d112        	addmi	a1, a1, 0x100
40381d7b:	c0c112        	addi	a1, a1, -64
    SPILL_ALL_WINDOWS                  /* place the live register windows there */
40381d7e:	10ccc0        	and	a12, a12, a12
40381d81:	408030        	rotw	3
40381d84:	10ccc0        	and	a12, a12, a12
40381d87:	408030        	rotw	3
40381d8a:	10ccc0        	and	a12, a12, a12
40381d8d:	408030        	rotw	3
40381d90:	10ccc0        	and	a12, a12, a12
40381d93:	408030        	rotw	3
40381d96:	10ccc0        	and	a12, a12, a12
40381d99:	408040        	rotw	4
    addi    sp,  sp, -XT_STK_FRMSZ     /* return the current stack pointer and proceed with context save*/
40381d9c:	ffd112        	addmi	a1, a1, 0xffffff00
40381d9f:	40c112        	addi	a1, a1, 64

    wsr     a2, PS                     /* restore to the value at entry */
40381da2:	13e620        	wsr.ps	a2
    rsync
40381da5:	002010        	rsync
    wsr     a0, EPC1                   /* likewise */
40381da8:	13b100        	wsr.epc1	a0

    #endif /* __XTENSA_CALL0_ABI__ */

    l32i    a12, sp, XT_STK_TMP0       /* restore the temp saved registers */
40381dab:	1921c2        	l32i	a12, a1, 100
    l32i    a13, sp, XT_STK_TMP1       /* our return address is there */
40381dae:	1a21d2        	l32i	a13, a1, 104
    l32i    a9,  sp, XT_STK_TMP2
40381db1:	1b2192        	l32i	a9, a1, 108

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a0, a9                      /* retrieve ret addr */
40381db4:	090d      	mov.n	a0, a9
    #endif

    ret
40381db6:	f00d      	ret.n

40381db8 <_xt_context_restore>:
    affected, but it is generally unlikely. If that ever happens,
    more registers need to be saved/restored around this macro invocation.
    Here we only assume a13 is preserved.
    Future Xtensa tools releases might limit the regs that can be affected.
    */
    mov     a13, a0                     /* preserve ret addr */
40381db8:	00dd      	mov.n	a13, a0
    addi    a2,  sp, XT_STK_EXTRA       /* where to find it */
40381dba:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_restore_extra_nw      /* destroys a0,2,3,4,5 */
40381dbd:	ffef45        	call0	40381cb4 <xthal_restore_extra_nw>
    mov     a0,  a13                    /* retrieve ret addr */
40381dc0:	0d0d      	mov.n	a0, a13
    #endif

    #if XCHAL_HAVE_LOOPS
    l32i    a2,  sp, XT_STK_LBEG
40381dc2:	162122        	l32i	a2, a1, 88
    l32i    a3,  sp, XT_STK_LEND
40381dc5:	172132        	l32i	a3, a1, 92
    wsr     a2,  LBEG
40381dc8:	130020        	wsr.lbeg	a2
    l32i    a2,  sp, XT_STK_LCOUNT
40381dcb:	182122        	l32i	a2, a1, 96
    wsr     a3,  LEND
40381dce:	130130        	wsr.lend	a3
    wsr     a2,  LCOUNT
40381dd1:	130220        	wsr.lcount	a2
    and     a4,  a4, a5
    wsr     a4,  INTENABLE              /* update INTENABLE */
    s32i    a5,  a3, 4                  /* restore _xt_vpri_mask */
    #endif

    l32i    a3,  sp, XT_STK_SAR
40381dd4:	132132        	l32i	a3, a1, 76
    l32i    a2,  sp, XT_STK_A2
40381dd7:	5128      	l32i.n	a2, a1, 20
    wsr     a3,  SAR
40381dd9:	130330        	wsr.sar	a3
    l32i    a3,  sp, XT_STK_A3
40381ddc:	6138      	l32i.n	a3, a1, 24
    l32i    a4,  sp, XT_STK_A4
40381dde:	7148      	l32i.n	a4, a1, 28
    l32i    a5,  sp, XT_STK_A5
40381de0:	8158      	l32i.n	a5, a1, 32
    l32i    a6,  sp, XT_STK_A6
40381de2:	9168      	l32i.n	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
40381de4:	a178      	l32i.n	a7, a1, 40
    l32i    a8,  sp, XT_STK_A8
40381de6:	b188      	l32i.n	a8, a1, 44
    l32i    a9,  sp, XT_STK_A9
40381de8:	c198      	l32i.n	a9, a1, 48
    l32i    a10, sp, XT_STK_A10
40381dea:	d1a8      	l32i.n	a10, a1, 52
    l32i    a11, sp, XT_STK_A11
40381dec:	e1b8      	l32i.n	a11, a1, 56
    /*
    Call0 ABI callee-saved regs a12-15 do not need to be restored here.
    However a12-13 were saved for scratch before XT_RTOS_INT_ENTER(),
    so need to be restored anyway, despite being callee-saved in Call0.
    */
    l32i    a12, sp, XT_STK_A12
40381dee:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
40381df0:	1021d2        	l32i	a13, a1, 64
    #ifndef __XTENSA_CALL0_ABI__
    l32i    a14, sp, XT_STK_A14
40381df3:	1121e2        	l32i	a14, a1, 68
    l32i    a15, sp, XT_STK_A15
40381df6:	1221f2        	l32i	a15, a1, 72
    #endif

    ret
40381df9:	f00d      	ret.n
	...

40381dfc <_xt_coproc_init>:
    .type   _xt_coproc_init,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_init:
    ENTRY0
40381dfc:	002136        	entry	a1, 16

    /* Initialize thread co-processor ownerships to 0 (unowned). */
    movi    a2, _xt_coproc_owner_sa         /* a2 = base of owner array */
40381dff:	ca6821        	l32r	a2, 403747a0 <_iram_text_start+0x39c> (3fc925c0 <_xt_coproc_owner_sa>)
    addi    a3, a2, (XCHAL_CP_MAX*portNUM_PROCESSORS) << 2       /* a3 = top+1 of owner array */
40381e02:	20c232        	addi	a3, a2, 32
    movi    a4, 0                           /* a4 = 0 (unowned) */
40381e05:	00a042        	movi	a4, 0
1:  s32i    a4, a2, 0
40381e08:	0249      	s32i.n	a4, a2, 0
    addi    a2, a2, 4
40381e0a:	224b      	addi.n	a2, a2, 4
    bltu    a2, a3, 1b
40381e0c:	f83237        	bltu	a2, a3, 40381e08 <_xt_coproc_init+0xc>

    RET0
40381e0f:	f01d      	retw.n
40381e11:	000000        	ill

40381e14 <_xt_coproc_release>:
    .type   _xt_coproc_release,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_release:
    ENTRY0                                  /* a2 = base of save area */
40381e14:	002136        	entry	a1, 16
                                            /* a3 = xTargetCoreID */

    movi    a4, XCHAL_CP_MAX << 2           /* a4 = size of an owner array */
40381e17:	041c      	movi.n	a4, 16
    mull    a4, a3, a4                      /* a4 = offset to the owner array of the target core */
40381e19:	824340        	mull	a4, a3, a4
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of all owner arrays */
40381e1c:	ca6131        	l32r	a3, 403747a0 <_iram_text_start+0x39c> (3fc925c0 <_xt_coproc_owner_sa>)
    add     a3, a3, a4                      /* a3 = base of owner array of the target core */
40381e1f:	334a      	add.n	a3, a3, a4
    addi    a4, a3, XCHAL_CP_MAX << 2       /* a4 = top+1 of owner array of the target core */
40381e21:	10c342        	addi	a4, a3, 16
    movi    a5, 0                           /* a5 = 0 (unowned) */
40381e24:	050c      	movi.n	a5, 0

    rsil    a6, XCHAL_EXCM_LEVEL            /* lock interrupts */
40381e26:	006360        	rsil	a6, 3
#if portNUM_PROCESSORS > 1
    /* If multicore, we must also acquire the _xt_coproc_owner_sa_lock spinlock
     * to ensure thread safe access of _xt_coproc_owner_sa between cores. */
    spinlock_take a7 a8 _xt_coproc_owner_sa_lock
40381e29:	ca5e71        	l32r	a7, 403747a4 <_iram_text_start+0x3a0> (3fc925e0 <_xt_coproc_owner_sa_lock>)
40381e2c:	080c      	movi.n	a8, 0
40381e2e:	130c80        	wsr.scompare1	a8
40381e31:	002010        	rsync
40381e34:	03eb80        	rsr.prid	a8
40381e37:	00e782        	s32c1i	a8, a7, 0
40381e3a:	fee856        	bnez	a8, 40381e2c <_xt_coproc_release+0x18>
#endif /* portNUM_PROCESSORS > 1 */

1:  l32i    a7, a3, 0                       /* a7 = owner at a3 */
40381e3d:	0378      	l32i.n	a7, a3, 0
    bne     a2, a7, 2f                      /* if (coproc_sa_base == owner) */
40381e3f:	019277        	bne	a2, a7, 40381e44 <_xt_coproc_release+0x30>
    s32i    a5, a3, 0                       /*   owner = unowned */
40381e42:	0359      	s32i.n	a5, a3, 0
2:  addi    a3, a3, 1<<2                    /* a3 = next entry in owner array */
40381e44:	334b      	addi.n	a3, a3, 4
    bltu    a3, a4, 1b                      /* repeat until end of array */
40381e46:	f33347        	bltu	a3, a4, 40381e3d <_xt_coproc_release+0x29>

#if portNUM_PROCESSORS > 1
    /* Release previously taken spinlock */
    spinlock_release a7 a8 _xt_coproc_owner_sa_lock
40381e49:	ca5671        	l32r	a7, 403747a4 <_iram_text_start+0x3a0> (3fc925e0 <_xt_coproc_owner_sa_lock>)
40381e4c:	080c      	movi.n	a8, 0
40381e4e:	0789      	s32i.n	a8, a7, 0
#endif /* portNUM_PROCESSORS > 1 */
    wsr     a6, PS                          /* restore interrupts */
40381e50:	13e660        	wsr.ps	a6

    RET0
40381e53:	f01d      	retw.n
40381e55:	000000        	ill

40381e58 <_xt_coproc_savecs>:
    .align      4
_xt_coproc_savecs:

    /* At entry, CPENABLE should be showing which CPs are enabled. */

    rsr     a2, CPENABLE                /* a2 = which CPs are enabled      */
40381e58:	03e020        	rsr.cpenable	a2
    beqz    a2, .Ldone                  /* quick exit if none              */
40381e5b:	d29c      	beqz.n	a2, 40381e7c <_xt_coproc_savecs+0x24>
    mov     a14, a0                     /* save return address             */
40381e5d:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
40381e5f:	f86c45        	call0	4037a524 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
40381e62:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone                 /* if none then nothing to do      */
40381e64:	4f9c      	beqz.n	a15, 40381e7c <_xt_coproc_savecs+0x24>
    s16i    a2, a15, XT_CP_CS_ST        /* save mask of CPs being stored   */
40381e66:	025f22        	s16i	a2, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
40381e69:	ca4fd1        	l32r	a13, 403747a8 <_iram_text_start+0x3a4> (3c0284b0 <_xt_coproc_sa_offset>)
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
40381e6c:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
40381e6e:	036207        	bbci	a2, 0, 40381e75 <_xt_coproc_savecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
40381e71:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
40381e73:	3efa      	add.n	a3, a14, a15
    xchal_cp2_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
40381e75:	036237        	bbci	a2, 3, 40381e7c <_xt_coproc_savecs+0x24>
    l32i    a14, a13, 12
40381e78:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
40381e7a:	3efa      	add.n	a3, a14, a15
    xchal_cp7_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone:
    ret
40381e7c:	f00d      	ret.n
	...

40381e80 <_xt_coproc_restorecs>:
    .align  4
    .literal_position
    .align      4
_xt_coproc_restorecs:

    mov     a14, a0                     /* save return address             */
40381e80:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
40381e82:	f86a05        	call0	4037a524 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
40381e85:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone2                /* if none then nothing to do      */
40381e87:	9f9c      	beqz.n	a15, 40381ea4 <_xt_coproc_restorecs+0x24>
    l16ui   a3, a15, XT_CP_CS_ST        /* a3 = which CPs have been saved  */
40381e89:	021f32        	l16ui	a3, a15, 4
    xor     a3, a3, a2                  /* clear the ones being restored   */
40381e8c:	303320        	xor	a3, a3, a2
    s32i    a3, a15, XT_CP_CS_ST        /* update saved CP mask            */
40381e8f:	1f39      	s32i.n	a3, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
40381e91:	ca45d1        	l32r	a13, 403747a8 <_iram_text_start+0x3a4> (3c0284b0 <_xt_coproc_sa_offset>)
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
40381e94:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
40381e96:	036207        	bbci	a2, 0, 40381e9d <_xt_coproc_restorecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
40381e99:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
40381e9b:	3efa      	add.n	a3, a14, a15
    xchal_cp2_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
40381e9d:	036237        	bbci	a2, 3, 40381ea4 <_xt_coproc_restorecs+0x24>
    l32i    a14, a13, 12
40381ea0:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
40381ea2:	3efa      	add.n	a3, a14, a15
    xchal_cp7_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone2:
    ret
40381ea4:	f00d      	ret.n
	...

40381ea8 <xt_ints_on>:
    .global xt_ints_on
    .type   xt_ints_on,@function

xt_ints_on:

    ENTRY0
40381ea8:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable |= mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts       */
    mov     a2, a3               /* Previous mask             */
#else
    movi    a3, 0
40381eab:	030c      	movi.n	a3, 0
    xsr     a3, INTENABLE        /* Disables all interrupts   */
40381ead:	61e430        	xsr.intenable	a3
    rsync
40381eb0:	002010        	rsync
    or      a2, a3, a2           /* set bits in mask */
40381eb3:	202320        	or	a2, a3, a2
    wsr     a2, INTENABLE        /* Re-enable ints */
40381eb6:	13e420        	wsr.intenable	a2
    rsync
40381eb9:	002010        	rsync
    mov     a2, a3               /* return prev mask */
40381ebc:	032d      	mov.n	a2, a3
#endif
#else
    movi    a2, 0                /* Return zero */
#endif
    RET0
40381ebe:	f01d      	retw.n

40381ec0 <xt_ints_off>:
    .global xt_ints_off
    .type   xt_ints_off,@function

xt_ints_off:

    ENTRY0
40381ec0:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable &= ~mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts        */
    mov     a2, a3               /* Previous mask              */
#else
    movi    a4, 0
40381ec3:	040c      	movi.n	a4, 0
    xsr     a4, INTENABLE        /* Disables all interrupts   */
40381ec5:	61e440        	xsr.intenable	a4
    rsync
40381ec8:	002010        	rsync
    or      a3, a4, a2           /* set bits in mask */
40381ecb:	203420        	or	a3, a4, a2
    xor     a3, a3, a2           /* invert bits in mask set in mask, essentially clearing them */
40381ece:	303320        	xor	a3, a3, a2
    wsr     a3, INTENABLE        /* Re-enable ints */
40381ed1:	13e430        	wsr.intenable	a3
    rsync
40381ed4:	002010        	rsync
    mov     a2, a4               /* return prev mask */
40381ed7:	042d      	mov.n	a2, a4
#endif
#else
    movi    a2, 0                /* return zero */
#endif
    RET0
40381ed9:	f01d      	retw.n

Disassembly of section .flash.text:

42000020 <_stext>:
42000020:	3fc94860 	
42000024:	3c0200b0 	
42000028:	400011f4 	
4200002c:	3fc91f3c 	
42000030:	3c020120 	
42000034:	3c02012c 	
42000038:	3c020050 	
4200003c:	3c020154 	
42000040:	3c020030 	
42000044:	3c020178 	
42000048:	3c020070 	
4200004c:	3c020080 	
42000050:	3c02019c 	
42000054:	3c0201c4 	
42000058:	3c020090 	
4200005c:	3c0201ec 	
42000060:	4037fbe0 	
42000064:	400005d0 	
42000068:	3c020210 	
4200006c:	3c020eb0 	
42000070:	3c020228 	
42000074:	3c020234 	
42000078:	3c02025c 	
4200007c:	51eb851f 	
42000080:	3c020288 	
42000084:	40375e10 	
42000088:	40375df8 	
4200008c:	3c026e14 	
42000090:	3c0202b0 	
42000094:	4037fc28 	
42000098:	3fc9486c 	
4200009c:	4037b1a8 	
420000a0:	40375760 	
420000a4:	3c0202e4 	
420000a8:	3c0202f0 	
420000ac:	3c020318 	
420000b0:	40376440 	
420000b4:	3c020338 	
420000b8:	3c026e34 	
420000bc:	3c020368 	
420000c0:	4037fd50 	
420000c4:	4037ff20 	
420000c8:	60008000 	
420000cc:	40000de0 	
420000d0:	40000e04 	
420000d4:	40000dec 	
420000d8:	40001b54 	
420000dc:	3c0202e4 	
420000e0:	3c020378 	
420000e4:	3c0203dc 	
420000e8:	600c0000 	
420000ec:	4037519c 	
420000f0:	3fc94888 	
420000f4:	4037fc94 	
420000f8:	40378240 	
420000fc:	40000720 	
42000100:	40000600 	
42000104:	3fc94880 	
42000108:	3c026e6c 	
4200010c:	4037550c 	
42000110:	3c0205a0 	
42000114:	3c0205a4 	
42000118:	4037870c 	
4200011c:	403787fc 	
42000120:	403792f4 	
42000124:	40378850 	
42000128:	4037890c 	
4200012c:	3c026e74 	
42000130:	40000000 	
42000134:	4037564c 	
42000138:	4000057c 	
4200013c:	3c0205f4 	
42000140:	3c026e78 	
42000144:	3c020651 	
42000148:	00002328 	
4200014c:	3c020658 	
42000150:	40378a9c 	
42000154:	403788f0 	
42000158:	40378a58 	
4200015c:	40378a30 	
42000160:	40002544 	
42000164:	40000e1c 	
42000168:	40000dd4 	
4200016c:	40378b44 	
42000170:	40378adc 	
42000174:	4000069c 	
42000178:	40378ea0 	
4200017c:	00003020 	
42000180:	8efb8ffc 	
42000184:	600c0018 	
42000188:	600c001c 	
4200018c:	60026014 	
42000190:	88e513f4 	
42000194:	600c0020 	
42000198:	600c0024 	
4200019c:	00fb9fcf 	
420001a0:	600c0028 	
420001a4:	600c002c 	
420001a8:	f0ffffff 	
420001ac:	01000000 	
420001b0:	600080c8 	
420001b4:	3fc9488c 	
420001b8:	600c40e4 	
420001bc:	3c026ec4 	
420001c0:	3fc94898 	
420001c4:	3c026eb4 	
420001c8:	600c40f0 	
420001cc:	3fc94890 	
420001d0:	600c40fc 	
420001d4:	600c4104 	
420001d8:	600c4114 	
420001dc:	3fc94894 	
420001e0:	600c40ec 	
420001e4:	600c40f8 	
420001e8:	600c40e0 	
420001ec:	600c40dc 	
420001f0:	600c40e8 	
420001f4:	600c40f4 	
420001f8:	60026000 	
420001fc:	ffff0000 	
42000200:	00004000 	
42000204:	40376578 	
42000208:	40376568 	
4200020c:	403758a8 	
42000210:	403758c4 	
42000214:	40000630 	
42000218:	600c0000 	
4200021c:	00008000 	
42000220:	ffff7fff 	
42000224:	60020000 	
42000228:	ffffbfff 	
4200022c:	00009c40 	
42000230:	3fc948a0 	
42000234:	00002710 	
42000238:	403766cc 	
4200023c:	403766bc 	
42000240:	40000dbc 	
42000244:	40000df8 	
42000248:	403758e4 	
4200024c:	3fc948a8 	
42000250:	60038000 	
42000254:	3c026f24 	
42000258:	3c026f2c 	
4200025c:	3fc948ac 	
42000260:	66666667 	
42000264:	10624dd3 	
42000268:	42001ca4 	
4200026c:	3fc948b0 	
42000270:	3c020844 	
42000274:	3c020864 	
42000278:	3c020870 	
4200027c:	3c0208c4 	
42000280:	0010200c 	
42000284:	3c020874 	
42000288:	3c020890 	
4200028c:	3fc91f08 	
42000290:	00001b58 	
42000294:	3c0208a4 	
42000298:	3c0208b8 	
4200029c:	40001248 	
420002a0:	40000e34 	
420002a4:	40375668 	
420002a8:	3c029ea8 	
420002ac:	3c029e94 	
420002b0:	3c029ed4 	
420002b4:	3c0202e4 	
420002b8:	3c0208c8 	
420002bc:	3c029f74 	
420002c0:	3fc948b4 	
420002c4:	3fc948b1 	
420002c8:	3c020904 	
420002cc:	4200221c 	
420002d0:	3fc948c0 	
420002d4:	3fffffff 	
420002d8:	be000000 	
420002dc:	01ffffff 	
420002e0:	bfc90000 	
420002e4:	0006ffff 	
420002e8:	c0000000 	
420002ec:	0005ffff 	
420002f0:	9ff02000 	
420002f4:	00001fff 	
420002f8:	40374400 	
420002fc:	3fc91f10 	
42000300:	400011e8 	
42000304:	403781bc 	
42000308:	403759e8 	
4200030c:	40000e10 	
42000310:	3c0208c4 	
42000314:	3fc948c8 	
42000318:	3c02090c 	
4200031c:	3c020928 	
42000320:	3c020934 	
42000324:	3c020944 	
42000328:	3c02095c 	
4200032c:	3c020974 	
42000330:	3c020984 	
42000334:	3c020994 	
42000338:	bffffffc 	
4200033c:	03ffffff 	
42000340:	3c0209a0 	
42000344:	3c0209b4 	
42000348:	3c020a18 	
4200034c:	3c0209b8 	
42000350:	3c0209cc 	
42000354:	3c0209e0 	
42000358:	3c0208c4 	
4200035c:	3c026f3c 	
42000360:	3c020a14 	
42000364:	3c020a1c 	
42000368:	3c020a58 	
4200036c:	3c020a2c 	
42000370:	3c020a30 	
42000374:	3c020a50 	
42000378:	3c020a60 	
4200037c:	3c020a70 	
42000380:	3c020a80 	
42000384:	40376888 	
42000388:	3c026fbc 	
4200038c:	3c020904 	
42000390:	3c020bb0 	
42000394:	42002300 	
42000398:	3c020bcc 	
4200039c:	3c026f9c 	
420003a0:	420022b0 	
420003a4:	42002354 	
420003a8:	40375b50 	
420003ac:	3c020f74 	
420003b0:	3fc92874 	
420003b4:	3fc9490c 	
420003b8:	3fc927cc 	
420003bc:	3fc94904 	
420003c0:	3fc94914 	
420003c4:	40375ce8 	
420003c8:	3c020f64 	
420003cc:	3c027068 	
420003d0:	3c020f58 	
420003d4:	40379c68 	
420003d8:	403799bc 	
420003dc:	4037c5a4 	
420003e0:	3fc948e4 	
420003e4:	3fc948d8 	
420003e8:	3fc948e0 	
420003ec:	4037ba2c 	
420003f0:	403781a8 	
420003f4:	4037a10c 	
420003f8:	4037c384 	
420003fc:	4037b8b0 	
42000400:	4037c1b0 	
42000404:	3fc9495c 	
42000408:	40378298 	
4200040c:	3fc91f2c 	
42000410:	4037a130 	
42000414:	4037a280 	
42000418:	3fc9491c 	
4200041c:	3c027078 	
42000420:	3c027080 	
42000424:	4037682c 	
42000428:	efffffff 	
4200042c:	ffffc00f 	
42000430:	20000000 	
42000434:	dfffffff 	
42000438:	03ff0000 	
4200043c:	fbffffff 	
42000440:	08000000 	
42000444:	bfffffff 	
42000448:	3fc949a4 	
4200044c:	40001230 	
42000450:	3fc949b4 	
42000454:	3fc949ac 	
42000458:	3fc949b0 	
4200045c:	3c0227c0 	
42000460:	3c027760 	
42000464:	3c022843 	
42000468:	3fc949a8 	
4200046c:	1fffffff 	
42000470:	3fc94ab4 	
42000474:	02000000 	
42000478:	3c022888 	
4200047c:	3c027810 	
42000480:	3c0228ba 	
42000484:	4037e7c0 	
42000488:	3c0228cc 	
4200048c:	3c0228d8 	
42000490:	3c02291c 	
42000494:	3c027800 	
42000498:	3c027a70 	
4200049c:	3c022934 	
420004a0:	3c0277ec 	
420004a4:	3c022964 	
420004a8:	b33fffff 	
420004ac:	3c022970 	
420004b0:	3c02299c 	
420004b4:	3c0229b4 	
420004b8:	00000804 	
420004bc:	3c0229d4 	
420004c0:	4037e6fc 	
420004c4:	3c029ed4 	
420004c8:	3c029eac 	
420004cc:	3ff1fffc 	
420004d0:	3fcf0000 	
420004d4:	420148f0 	
420004d8:	3c0231b4 	
420004dc:	3c027988 	
420004e0:	3c0231f7 	
420004e4:	3c023210 	
420004e8:	3c02323c 	
420004ec:	3c02324c 	
420004f0:	40001488 	
420004f4:	3c0279a4 	
420004f8:	3c0279a8 	
420004fc:	cccccccd 	
42000500:	600fffe8 	
42000504:	60008054 	
42000508:	3fc91f48 	
4200050c:	3fc91f44 	
42000510:	403793f0 	
42000514:	3fc94acc 	
42000518:	ffc1ffff 	
4200051c:	fffeffff 	
42000520:	40375f38 	
42000524:	3c0234a4 	
42000528:	3c027b7c 	
4200052c:	3c0234d0 	
42000530:	3c0234e0 	
42000534:	3c027b68 	
42000538:	7fffffff 	
4200053c:	3fc91f50 	
42000540:	3c0288b8 	
42000544:	3c02352c 	
42000548:	3c023538 	
4200054c:	3c02357c 	
42000550:	3c027b4c 	
42000554:	3c0235d4 	
42000558:	40376454 	
4200055c:	3c027b34 	
42000560:	c03fffff 	
42000564:	3fc94ac4 	
42000568:	4037fe4c 	
4200056c:	40001be4 	
42000570:	40376588 	
42000574:	3fc92930 	
42000578:	3fc9291c 	
4200057c:	3fc94afc 	
42000580:	60008040 	
42000584:	6000804c 	
42000588:	403766e4 	
4200058c:	3fc92928 	
42000590:	00000800 	
42000594:	3fc92924 	
42000598:	3c02362c 	
4200059c:	3c023638 	
420005a0:	0003fffe 	
420005a4:	fc3fffff 	
420005a8:	0001ffff 	
420005ac:	40377670 	
420005b0:	3c023678 	
420005b4:	3c023680 	
420005b8:	3c023688 	
420005bc:	600080e0 	
420005c0:	3c028fd8 	
420005c4:	600080d8 	
420005c8:	3c028b08 	
420005cc:	600c10e0 	
420005d0:	ffff8fff 	
420005d4:	fffc7fff 	
420005d8:	3c027c40 	
420005dc:	3c027c5c 	
420005e0:	bfc88000 	
420005e4:	00067fff 	
420005e8:	fffff1ff 	
420005ec:	600c10e4 	
420005f0:	600c10f0 	
420005f4:	600c10e8 	
420005f8:	600c10f4 	
420005fc:	600c1124 	
42000600:	600c11d0 	
42000604:	003ff800 	
42000608:	600c1148 	
4200060c:	600c11f4 	
42000610:	00000e00 	
42000614:	600c114c 	
42000618:	600c11f8 	
4200061c:	600c119c 	
42000620:	600c1248 	
42000624:	600c11a0 	
42000628:	600c124c 	
4200062c:	ff910000 	
42000630:	c0378000 	
42000634:	600c1100 	
42000638:	600c1104 	
4200063c:	600c1114 	
42000640:	600c1108 	
42000644:	600c1118 	
42000648:	0000d008 	
4200064c:	3fc91f78 	
42000650:	40381f00 	
42000654:	600fe000 	
42000658:	0000d001 	
4200065c:	0000d002 	
42000660:	600c10c4 	
42000664:	600c10c8 	
42000668:	600c10cc 	
4200066c:	600c10d0 	
42000670:	600c10d4 	
42000674:	600c10c0 	
42000678:	600c10d8 	
4200067c:	600c10fc 	
42000680:	3c0237a8 	
42000684:	3c023808 	
42000688:	3c023868 	
4200068c:	3c0238c8 	
42000690:	3c023928 	
42000694:	3c023988 	
42000698:	3c0239e4 	
4200069c:	3c023a40 	
420006a0:	3c023a9c 	
420006a4:	3c023af8 	
420006a8:	3c023b54 	
420006ac:	3c023bb0 	
420006b0:	3c023c0c 	
420006b4:	3c023c68 	
420006b8:	3c023cc4 	
420006bc:	3c023d20 	
420006c0:	3c023d84 	
420006c4:	3c023de8 	
420006c8:	3c023e54 	
420006cc:	3c023eb8 	
420006d0:	3c023f1c 	
420006d4:	400006d8 	
420006d8:	0000d003 	
420006dc:	0000d004 	
420006e0:	0000d005 	
420006e4:	0000d006 	
420006e8:	0000d007 	
420006ec:	3c023f88 	
420006f0:	3c027c78 	
420006f4:	3c023ffd 	
420006f8:	3c027c90 	
420006fc:	3fc91fc0 	
42000700:	600fe000 	
42000704:	3c0240b8 	
42000708:	3c027e90 	
4200070c:	000008ca 	
42000710:	3c02407c 	
42000714:	3c024d94 	
42000718:	bb10c433 	
4200071c:	400011dc 	
42000720:	3fc94e58 	
42000724:	3c024e38 	
42000728:	3c02827c 	
4200072c:	3c024dec 	
42000730:	3fc94e04 	
42000734:	3c024e68 	
42000738:	3fc94eb8 	
4200073c:	3fc94eb0 	
42000740:	3fc94eac 	
42000744:	40376a1c 	
42000748:	40376a5c 	
4200074c:	000f4240 	
42000750:	4037c808 	
42000754:	3fc94ec8 	
42000758:	40376c1c 	
4200075c:	3fc94ec0 	
42000760:	60008058 	
42000764:	6000805c 	
42000768:	3fc926a4 	
4200076c:	3fceffd4 	
42000770:	3fc92008 	
42000774:	3fc92694 	
42000778:	3fceffd0 	
4200077c:	42005d48 	
42000780:	3fc92690 	
42000784:	4037fe40 	
42000788:	3c020d4c 	
4200078c:	3c024ea0 	
42000790:	3fc920a4 	
42000794:	3fc94ed0 	
42000798:	3fc948b8 	
4200079c:	3fc94ed8 	
420007a0:	42005cf4 	
420007a4:	3c024ea4 	
420007a8:	3c024eb0 	
420007ac:	40376c38 	
420007b0:	3c0282e0 	
420007b4:	3fc94ee0 	
420007b8:	4037e378 	
420007bc:	4037e4fc 	
420007c0:	4037e52c 	
420007c4:	4037e4bc 	
420007c8:	4037e550 	
420007cc:	4037e574 	
420007d0:	3fc94ef0 	
420007d4:	3fc94eec 	
420007d8:	40376c50 	
420007dc:	403786ec 	
420007e0:	3fc920b8 	
420007e4:	0000c34f 	
420007e8:	3fc920ac 	
420007ec:	3fc94ef8 	
420007f0:	00001000 	
420007f4:	3fc94ef4 	
420007f8:	40375fcc 	
420007fc:	42006304 	
42000800:	00004002 	
42000804:	00002000 	
42000808:	3fc920c0 	
4200080c:	40376a2c 	
42000810:	40376a6c 	
42000814:	3c024eec 	
42000818:	3c0282e8 	
4200081c:	3c024f34 	
42000820:	3fc920bc 	
42000824:	3c028304 	
42000828:	3c024f4c 	
4200082c:	3fc94efc 	
42000830:	40379520 	
42000834:	403794f0 	
42000838:	3fc94f0c 	
4200083c:	3fc94f00 	
42000840:	3c024f4c 	
42000844:	3fc94f04 	
42000848:	3c024f5c 	
4200084c:	3c028370 	
42000850:	3c024d94 	
42000854:	3fc94f18 	
42000858:	3fc94f14 	
4200085c:	40001218 	
42000860:	40001260 	
42000864:	3c024f94 	
42000868:	3c024f98 	
4200086c:	3c02841c 	
42000870:	3c024f8d 	
42000874:	4000123c 	
42000878:	3fc920e8 	
4200087c:	4000120c 	
42000880:	3fc94f10 	
42000884:	40379ad8 	
42000888:	40379cc4 	
4200088c:	3fc94f38 	
42000890:	3c024f94 	
42000894:	000021b6 	
42000898:	3c02842c 	
4200089c:	3c024fd8 	
420008a0:	3c024fe4 	
420008a4:	3c024ff4 	
420008a8:	3fc94f3c 	
420008ac:	3fc921b4 	
420008b0:	3fc95d98 	
420008b4:	3fc94ed4 	
420008b8:	42007824 	
420008bc:	3fc921b0 	
420008c0:	3fc95c84 	
420008c4:	3fc921ac 	
420008c8:	3fc95b70 	
420008cc:	3fc95b68 	
420008d0:	3fc921a8 	
420008d4:	3fc95554 	
420008d8:	42007830 	
420008dc:	3fc94f40 	
420008e0:	3fc94f50 	
420008e4:	3c025018 	
420008e8:	40001200 	
420008ec:	001387        	beq	a3, a8, 420008f0 <_stext+0x8d0>
420008ef:	175900        	lsi	f0, a9, 92
420008f2:	20d1b7        	bbs	a1, a11, 42000916 <_stext+0x8f6>
420008f5:	3c0250        	lsi	f5, a2, 240
420008f8:	025034        	lsi	f3, a0, 8
420008fb:	543c      	movi.n	a4, 53
420008fd:	3c0250        	lsi	f5, a2, 240
42000900:	025074        	lsi	f7, a0, 8
42000903:	983c      	movi.n	a8, 57
42000905:	3c0250        	lsi	f5, a2, 240
42000908:	50bc      	beqz.n	a0, 42000941 <_stext+0x921>
4200090a:	dc3c02        	lsi	f0, a12, 0x370
4200090d:	3c0250        	lsi	f5, a2, 240
42000910:	0250f0        	andb	b5, b0, b15
42000913:	083c      	movi.n	a8, 48
42000915:	3c0251        	l32r	a5, 41fcf920 <_coredump_iram_end+0x1c4da20>
42000918:	511c      	movi.n	a1, 21
4200091a:	303c02        	lsi	f0, a12, 192
4200091d:	3c0251        	l32r	a5, 41fcf928 <_coredump_iram_end+0x1c4da28>
42000920:	5148      	l32i.n	a4, a1, 20
42000922:	603c02        	lsi	f0, a12, 0x180
42000925:	3c0251        	l32r	a5, 41fcf930 <_coredump_iram_end+0x1c4da30>
42000928:	5178      	l32i.n	a7, a1, 20
4200092a:	903c02        	lsi	f0, a12, 0x240
4200092d:	3c0251        	l32r	a5, 41fcf938 <_coredump_iram_end+0x1c4da38>
42000930:	51ac      	beqz.n	a1, 42000959 <_stext+0x939>
42000932:	c83c02        	lsi	f0, a12, 0x320
42000935:	3c0251        	l32r	a5, 41fcf940 <_coredump_iram_end+0x1c4da40>
42000938:	0251e4        	lsi	f14, a1, 8
4200093b:	003c      	movi.n	a0, 48
4200093d:	3c0252        	l8ui	a5, a2, 60
42000940:	521c      	movi.n	a2, 21
42000942:	383c02        	lsi	f0, a12, 224
42000945:	3c0252        	l8ui	a5, a2, 60
42000948:	025254        	lsi	f5, a2, 8
4200094b:	703c      	movi.n	a0, 55
4200094d:	3c0252        	l8ui	a5, a2, 60
42000950:	528c      	beqz.n	a2, 42000959 <_stext+0x939>
42000952:	ac3c02        	lsi	f0, a12, 0x2b0
42000955:	3c0252        	l8ui	a5, a2, 60
42000958:	52cc      	bnez.n	a2, 42000961 <_stext+0x941>
4200095a:	e83c02        	lsi	f0, a12, 0x3a0
4200095d:	3c0252        	l8ui	a5, a2, 60
42000960:	530c      	movi.n	a3, 5
42000962:	443c02        	lsi	f0, a12, 0x110
42000965:	3c0253        	lsi	f5, a2, 240
42000968:	5348      	l32i.n	a4, a3, 20
4200096a:	643c02        	lsi	f0, a12, 0x190
4200096d:	3c0253        	lsi	f5, a2, 240
42000970:	025380        	andb	b5, b3, b8
42000973:	9c3c      	movi.n	a12, 57
42000975:	3c0253        	lsi	f5, a2, 240
42000978:	53b8      	l32i.n	a11, a3, 20
4200097a:	cc3c02        	lsi	f0, a12, 0x330
4200097d:	3c0253        	lsi	f5, a2, 240
42000980:	0253d0        	andb	b5, b3, b13
42000983:	e43c      	movi.n	a4, 62
42000985:	3c0253        	lsi	f5, a2, 240
42000988:	025400        	andb	b5, b4, b0
4200098b:	243c      	movi.n	a4, 50
4200098d:	3c0254        	lsi	f5, a2, 240
42000990:	5448      	l32i.n	a4, a4, 20
42000992:	503c02        	lsi	f0, a12, 0x140
42000995:	3c0254        	lsi	f5, a2, 240
42000998:	5478      	l32i.n	a7, a4, 20
4200099a:	a03c02        	lsi	f0, a12, 0x280
4200099d:	3c0254        	lsi	f5, a2, 240
420009a0:	54dc      	bnez.n	a4, 420009b9 <_stext+0x999>
420009a2:	e43c02        	lsi	f0, a12, 0x390
420009a5:	3c0254        	lsi	f5, a2, 240
420009a8:	025504        	lsi	f0, a5, 8
420009ab:	383c      	movi.n	a8, 51
420009ad:	3c0255        	call4	4203c9d4 <_etext+0x2677e>
420009b0:	025544        	lsi	f4, a5, 8
420009b3:	7c3c      	movi.n	a12, 55
420009b5:	3c0255        	call4	4203c9dc <_etext+0x26786>
420009b8:	025584        	lsi	f8, a5, 8
420009bb:	f83c      	movi.n	a8, 63
420009bd:	400013        	lsi	f1, a0, 0x100
420009c0:	85d8      	l32i.n	a13, a5, 32
420009c2:	403c02        	lsi	f0, a12, 0x100
420009c5:	025b      	addi.n	a0, a2, 5
420009c7:	483c      	movi.n	a8, 52
420009c9:	025b      	addi.n	a0, a2, 5
420009cb:	603c      	movi.n	a0, 54
420009cd:	025b      	addi.n	a0, a2, 5
420009cf:	443c      	movi.n	a4, 52
420009d1:	028a      	add.n	a0, a2, a8
420009d3:	bc3c      	movi.n	a12, 59
420009d5:	3c0285        	call0	4203ca00 <_etext+0x267aa>
420009d8:	0285a0        	andb	b8, b5, b10
420009db:	743c      	movi.n	a4, 55
420009dd:	025b      	addi.n	a0, a2, 5
420009df:	843c      	movi.n	a4, 56
420009e1:	3c0285        	call0	4203ca0c <_etext+0x267b6>
420009e4:	028550        	andb	b8, b5, b5
420009e7:	ec3c      	movi.n	a12, 62
420009e9:	3fc925        	call8	4204067c <_etext+0x2a426>
420009ec:	8538      	l32i.n	a3, a5, 32
420009ee:	203c02        	lsi	f0, a12, 128
420009f1:	3c0285        	call0	4203ca1c <_etext+0x267c6>
420009f4:	8508      	l32i.n	a0, a5, 32
420009f6:	f03c02        	lsi	f0, a12, 0x3c0
420009f9:	3c0285        	call0	4203ca24 <_etext+0x267ce>
420009fc:	8568      	l32i.n	a6, a5, 32
420009fe:	903c02        	lsi	f0, a12, 0x240
42000a01:	025b      	addi.n	a0, a2, 5
42000a03:	a83c      	movi.n	a8, 58
42000a05:	025b      	addi.n	a0, a2, 5
42000a07:	f43c      	movi.n	a4, 63
42000a09:	3c0284        	lsi	f8, a2, 240
42000a0c:	0284e0        	andb	b8, b4, b14
42000a0f:	e43c      	movi.n	a4, 62
42000a11:	ff          	.byte	0xff
42000a12:	ce          	.byte	0xce
42000a13:	3f          	.byte	0x3f
42000a14:	3775b0        	lsi	f11, a5, 220
42000a17:	ffff40        	f64cmph	a15, a15, a4, 15
42000a1a:	ff          	.byte	0xff
42000a1b:	ffff41        	l32r	a4, 42000a18 <_stext+0x9f8> (41ffffff <_coredump_iram_end+0x1c7e0ff>)
42000a1e:	ff          	.byte	0xff
42000a1f:	ffff43        	lsi	f4, a15, 0x3fc
42000a22:	ff          	.byte	0xff
42000a23:	ff3b      	addi.n	a15, a15, 3
42000a25:	ff          	.byte	0xff
42000a26:	ff          	.byte	0xff
42000a27:	983d      	lsi	f3, a8, 32
42000a29:	3c0245        	call0	4203ca50 <_etext+0x267fa>
42000a2c:	868c      	beqz.n	a6, 42000a38 <_stext+0xa18>
42000a2e:	803c02        	lsi	f0, a12, 0x200
42000a31:	3c0204        	muls.ad.ll	a2, m2
42000a34:	016256        	bnez	a2, 42000a4e <_stext+0xa2e>
42000a37:	002042        	l32i	a4, a0, 0
42000a3a:	644200        	extui	a4, a0, 2, 7
42000a3d:	025c      	movi.n	a2, 80
42000a3f:	a03c      	movi.n	a0, 58
42000a41:	3c0286        	j	4200fa4f <_vfiprintf_r+0xd93>
42000a44:	025d14        	lsi	f1, a13, 8
42000a47:	ff3c      	movi.n	a15, 63
42000a49:	ff          	.byte	0xff
42000a4a:	740000        	extui	a0, a0, 0, 8
42000a4d:	9f          	.byte	0x9f
42000a4e:	203c02        	lsi	f0, a12, 128
42000a51:	3c0200        	lsi	f0, a2, 240
42000a54:	025d24        	lsi	f2, a13, 8
42000a57:	743c      	movi.n	a4, 55
42000a59:	3c0286        	j	4200fa67 <_vfiprintf_r+0xdab>
42000a5c:	86cc      	bnez.n	a6, 42000a68 <_stext+0xa48>
42000a5e:	b83c02        	lsi	f0, a12, 0x2e0
42000a61:	025d      	mov.n	a5, a2
42000a63:	b83c      	movi.n	a8, 59
42000a65:	3c0286        	j	4200fa73 <_vfiprintf_r+0xdb7>
42000a68:	5eac      	beqz.n	a14, 42000a91 <_stext+0xa71>
42000a6a:	3fc9      	s32i.n	a12, a15, 12
42000a6c:	025df4        	lsi	f15, a13, 8
42000a6f:	4c3c      	movi.n	a12, 52
42000a71:	3fc935        	call12	42040704 <_etext+0x2a4ae>
42000a74:	8668      	l32i.n	a6, a6, 32
42000a76:	183c02        	lsi	f0, a12, 96
42000a79:	5e          	.byte	0x5e
42000a7a:	843c02        	lsi	f0, a12, 0x210
42000a7d:	5e          	.byte	0x5e
42000a7e:	3c3c02        	lsi	f0, a12, 240
42000a81:	5e          	.byte	0x5e
42000a82:	b03c02        	lsi	f0, a12, 0x2c0
42000a85:	5e          	.byte	0x5e
42000a86:	3fc9      	s32i.n	a12, a15, 12
42000a88:	025e60        	andb	b5, b14, b6
42000a8b:	e43c      	movi.n	a4, 62
42000a8d:	5e          	.byte	0x5e
42000a8e:	003c02        	lsi	f0, a12, 0
42000a91:	5f          	.byte	0x5f
42000a92:	483c02        	lsi	f0, a12, 0x120
42000a95:	5f          	.byte	0x5f
42000a96:	943c02        	lsi	f0, a12, 0x250
42000a99:	5f          	.byte	0x5f
42000a9a:	5c3c02        	lsi	f0, a12, 0x170
42000a9d:	3c0286        	j	4200faab <_vfiprintf_r+0xdef>
42000aa0:	000000        	ill
42000aa3:	000042        	l8ui	a4, a0, 0
42000aa6:	6c3c00        	lsi	f0, a12, 0x1b0
42000aa9:	403760        	lsi	f6, a7, 0x100
42000aac:	769c      	beqz.n	a6, 42000ac7 <_stext+0xaa7>
42000aae:	4c4037        	ball	a0, a3, 42000afe <_stext+0xade>
42000ab1:	3c0286        	j	4200fabf <_vfiprintf_r+0xe03>
42000ab4:	5f9c      	beqz.n	a15, 42000acd <_stext+0xaad>
42000ab6:	ec3c02        	lsi	f0, a12, 0x3b0
42000ab9:	5f          	.byte	0x5f
42000aba:	883c02        	lsi	f0, a12, 0x220
42000abd:	403777        	bltu	a7, a7, 42000b01 <_stext+0xae1>
42000ac0:	028634        	lsi	f3, a6, 8
42000ac3:	283c      	movi.n	a8, 50
42000ac5:	3c0260        	lsi	f6, a2, 240
42000ac8:	026064        	lsi	f6, a0, 8
42000acb:	503c      	movi.n	a0, 53
42000acd:	37cd      	lsi	f12, a7, 28
42000acf:	77a040        	lsi	f4, a0, 0x1dc
42000ad2:	dc4037        	ball	a0, a3, 42000ab2 <_stext+0xa92>
42000ad5:	5e          	.byte	0x5e
42000ad6:	3fc9      	s32i.n	a12, a15, 12
42000ad8:	608c      	beqz.n	a0, 42000ae2 <_stext+0xac2>
42000ada:	4c3c02        	lsi	f0, a12, 0x130
42000add:	3c0287        	bnone	a2, a8, 42000b1d <_stext+0xafd>
42000ae0:	0260c3        	lsi	f12, a0, 8
42000ae3:	503c      	movi.n	a0, 53
42000ae5:	379c      	beqz.n	a7, 42000afc <_stext+0xadc>
42000ae7:	9e8840        	f64iter	a8, a8, a4, 1, 0
42000aea:	844037        	ball	a0, a3, 42000a72 <_stext+0xa52>
42000aed:	379c      	beqz.n	a7, 42000b04 <_stext+0xae4>
42000aef:	622040        	lsi	f4, a0, 0x188
42000af2:	603c02        	lsi	f0, a12, 0x180
42000af5:	3c0287        	bnone	a2, a8, 42000b35 <_stext+0xb15>
42000af8:	026213        	lsi	f1, a2, 8
42000afb:	543c      	movi.n	a4, 53
42000afd:	3c0262        	l8ui	a6, a2, 60
42000b00:	028774        	lsi	f7, a7, 8
42000b03:	873c      	movi.n	a7, 56
42000b05:	3c0262        	l8ui	a6, a2, 60
42000b08:	028784        	lsi	f8, a7, 8
42000b0b:	a43c      	movi.n	a4, 58
42000b0d:	1f          	.byte	0x1f
42000b0e:	744000        	extui	a4, a0, 0, 8
42000b11:	1f          	.byte	0x1f
42000b12:	544000        	extui	a4, a0, 0, 6
42000b15:	377c      	movi.n	a7, -13
42000b17:	300040        	xor	a0, a0, a4
42000b1a:	786000        	lsi	f0, a0, 0x1e0
42000b1d:	3c0264        	lsi	f6, a2, 240
42000b20:	028860        	andb	b8, b8, b6
42000b23:	7c3c      	movi.n	a12, 55
42000b25:	3c0264        	lsi	f6, a2, 240
42000b28:	3578      	l32i.n	a7, a5, 12
42000b2a:	3fc9      	s32i.n	a12, a15, 12
42000b2c:	3598      	l32i.n	a9, a5, 12
42000b2e:	3fc9      	s32i.n	a12, a15, 12
42000b30:	0264e4        	lsi	f14, a4, 8
42000b33:	4c3c      	movi.n	a12, 52
42000b35:	3c0265        	call8	4203cb5c <_etext+0x26906>
42000b38:	028844        	lsi	f4, a8, 8
42000b3b:	d03c      	movi.n	a0, 61
42000b3d:	3c0265        	call8	4203cb64 <_etext+0x2690e>
42000b40:	5eec      	bnez.n	a14, 42000b69 <_stext+0xb49>
42000b42:	3fc9      	s32i.n	a12, a15, 12
42000b44:	378540        	lsi	f4, a5, 220
42000b47:	84cc40        	extui	a12, a4, 12, 9
42000b4a:	584037        	ball	a0, a3, 42000ba6 <_stext+0xb86>
42000b4d:	403801        	l32r	a0, 41fd0c30 <_coredump_iram_end+0x1c4ed30>
42000b50:	377d30        	lsi	f3, a13, 220
42000b53:	815040        	src	a5, a0, a4
42000b56:	504037        	ball	a0, a3, 42000baa <_stext+0xb8a>
42000b59:	3fc935        	call12	420407ec <_etext+0x2a596>
42000b5c:	377b14        	lsi	f1, a11, 220
42000b5f:	90b040        	addx2	a11, a0, a4
42000b62:	f03c02        	lsi	f0, a12, 0x3c0
42000b65:	3fc935        	call12	420407f8 <_etext+0x2a5a2>
42000b68:	35c8      	l32i.n	a12, a5, 12
42000b6a:	3fc9      	s32i.n	a12, a15, 12
42000b6c:	c92674        	lsi	f7, a6, 0x324
42000b6f:	3f          	.byte	0x3f
42000b70:	5ef8      	l32i.n	a15, a14, 20
42000b72:	3fc9      	s32i.n	a12, a15, 12
42000b74:	8028      	l32i.n	a2, a0, 32
42000b76:	fc4037        	ball	a0, a3, 42000b76 <_stext+0xb56>
42000b79:	5e          	.byte	0x5e
42000b7a:	3fc9      	s32i.n	a12, a15, 12
42000b7c:	66a8      	l32i.n	a10, a6, 24
42000b7e:	a03c02        	lsi	f0, a12, 0x280
42000b81:	0288      	l32i.n	a8, a2, 0
42000b83:	ac3c      	movi.n	a12, 58
42000b85:	3c0266        	bnei	a2, -1, 42000bc5 <_stext+0xba5>
42000b88:	379760        	lsi	f6, a7, 220
42000b8b:	704c40        	lsi	f4, a12, 0x1c0
42000b8e:	506000        	witlb	a0, a0
42000b91:	600070        	neg	a0, a7
42000b94:	000000        	ill
42000b97:	66d880        	lsi	f8, a8, 0x198
42000b9a:	e43c02        	lsi	f0, a12, 0x390
42000b9d:	3c0266        	bnei	a2, -1, 42000bdd <_stext+0xbbd>
42000ba0:	026720        	andb	b6, b7, b2
42000ba3:	643c      	movi.n	a4, 54
42000ba5:	400014        	lsi	f1, a0, 0x100
42000ba8:	002000        	isync
42000bab:	400060        	lsi	f6, a0, 0x100
42000bae:	006002        	s32i	a0, a0, 0
42000bb1:	600250        	lsi	f5, a2, 0x180
42000bb4:	c4b400        	extui	a11, a0, 4, 13
42000bb7:	909c04        	lsi	f0, a12, 0x240
42000bba:	803c02        	lsi	f0, a12, 0x200
42000bbd:	3fc926        	beqi	a9, 32, 42000c00 <_stext+0xbe0>
42000bc0:	fecc      	bnez.n	a14, 42000bd3 <_stext+0xbb3>
42000bc2:	004037        	ball	a0, a3, 42000bc6 <_stext+0xba6>
42000bc5:	5f          	.byte	0x5f
42000bc6:	3fc9      	s32i.n	a12, a15, 12
42000bc8:	377680        	lsi	f8, a6, 220
42000bcb:	900040        	addx2	a0, a0, a4
42000bce:	c00000        	sub	a0, a0, a0
42000bd1:	026c      	movi.n	a2, -32
42000bd3:	cc3c      	movi.n	a12, 60
42000bd5:	026c      	movi.n	a2, -32
42000bd7:	fc3c      	movi.n	a12, 63
42000bd9:	026c      	movi.n	a2, -32
42000bdb:	083c      	movi.n	a8, 48
42000bdd:	5f          	.byte	0x5f
42000bde:	3fc9      	s32i.n	a12, a15, 12
42000be0:	50aa      	add.n	a5, a0, a10
42000be2:	eb0000        	f64cmpl	a0, a0, a0
42000be5:	00eb      	addi.n	a0, a0, 14
42000be7:	1c5c00        	lsi	f0, a12, 112
42000bea:	684000        	lsi	f0, a0, 0x1a0
42000bed:	001c      	movi.n	a0, 16
42000bef:	fe5840        	f64iter	a5, a8, a4, 3, 1
42000bf2:	244037        	ball	a0, a3, 42000c1a <_stext+0xbfa>
42000bf5:	400012        	l8ui	a1, a0, 64
42000bf8:	001c74        	lsi	f7, a12, 0
42000bfb:	5f0440        	f64cmph	a0, a4, a4, 5
42000bfe:	3fc9      	s32i.n	a12, a15, 12
42000c00:	6d28      	l32i.n	a2, a13, 24
42000c02:	303c02        	lsi	f0, a12, 192
42000c05:	3c0202        	l8ui	a0, a2, 60
42000c08:	90f8      	l32i.n	a15, a0, 36
42000c0a:	933c02        	lsi	f0, a12, 0x24c
42000c0d:	026d      	mov.n	a6, a2
42000c0f:	a03c      	movi.n	a0, 58
42000c11:	026d      	mov.n	a6, a2
42000c13:	e43c      	movi.n	a4, 62
42000c15:	3c0290        	lsi	f9, a2, 240
42000c18:	008c00        	any4	b0, b12:b13:b14:b15
42000c1b:	5f0c00        	f64cmph	a0, a12, a0, 5
42000c1e:	3fc9      	s32i.n	a12, a15, 12
42000c20:	00a4e0        	any8	b14, b0:b1:b2:b3:b4:b5:b6:b7
42000c23:	6db442        	l32ai	a4, a4, 0x1b4
42000c26:	0c3c02        	lsi	f0, a12, 48
42000c29:	3c0291        	l32r	a9, 41fcfc34 <_coredump_iram_end+0x1c4dd34>
42000c2c:	6df8      	l32i.n	a15, a13, 24
42000c2e:	083c02        	lsi	f0, a12, 32
42000c31:	6e          	.byte	0x6e
42000c32:	603c02        	lsi	f0, a12, 0x180
42000c35:	4200a5        	call8	42042c40 <_etext+0x2c9ea>
42000c38:	c95f10        	lsi	f1, a15, 0x324
42000c3b:	3f          	.byte	0x3f
42000c3c:	c95f14        	lsi	f1, a15, 0x324
42000c3f:	3f          	.byte	0x3f
42000c40:	376ae4        	lsi	f14, a10, 220
42000c43:	6b6840        	ole.s	b6, f8, f4
42000c46:	844037        	ball	a0, a3, 42000bce <_stext+0xbae>
42000c49:	fe          	.byte	0xfe
42000c4a:	b44037        	ball	a0, a3, 42000c02 <_stext+0xbe2>
42000c4d:	376a      	add.n	a3, a7, a6
42000c4f:	000140        	lsi	f4, a1, 0
42000c52:	ec2040        	lsi	f4, a0, 0x3b0
42000c55:	4200a7        	bnone	a0, a10, 42000c9b <_stext+0xc7b>
42000c58:	af38      	l32i.n	a3, a15, 40
42000c5a:	744200        	extui	a4, a0, 2, 8
42000c5d:	af          	.byte	0xaf
42000c5e:	b04200        	addx8	a4, a2, a0
42000c61:	af          	.byte	0xaf
42000c62:	ec4200        	lsi	f0, a2, 0x3b0
42000c65:	af          	.byte	0xaf
42000c66:	844200        	extui	a4, a0, 2, 9
42000c69:	5f          	.byte	0x5f
42000c6a:	3fc9      	s32i.n	a12, a15, 12
42000c6c:	5f1c      	movi.n	a15, 21
42000c6e:	3fc9      	s32i.n	a12, a15, 12
42000c70:	5fec      	bnez.n	a15, 42000c99 <_stext+0xc79>
42000c72:	3fc9      	s32i.n	a12, a15, 12
42000c74:	376a90        	lsi	f9, a10, 220
42000c77:	a5dc40        	extui	a13, a4, 28, 11
42000c7a:	544200        	extui	a4, a0, 2, 6
42000c7d:	3fc960        	f64cmph	a12, a9, a6, 3
42000c80:	a8dc      	bnez.n	a8, 42000c9e <_stext+0xc7e>
42000c82:	014200        	slli	a4, a2, 32
42000c85:	ffff00        	f64cmph	a15, a15, a0, 15
42000c88:	37fea4        	lsi	f10, a14, 220
42000c8b:	a8f040        	lsi	f4, a0, 0x2a0
42000c8e:	284200        	lsi	f0, a2, 160
42000c91:	00a9      	s32i.n	a10, a0, 0
42000c93:	a94442        	s8i	a4, a4, 169
42000c96:	804200        	add	a4, a2, a0
42000c99:	ff          	.byte	0xff
42000c9a:	ff          	.byte	0xff
42000c9b:	7f          	.byte	0x7f
42000c9c:	37fe90        	lsi	f9, a14, 220
42000c9f:	134440        	lsi	f4, a4, 76
42000ca2:	4c4000        	lsi	f0, a0, 0x130
42000ca5:	3c0291        	l32r	a9, 41fcfcb0 <_coredump_iram_end+0x1c4ddb0>
42000ca8:	c926a0        	lsi	f10, a6, 0x324
42000cab:	3f          	.byte	0x3f
42000cac:	6b7c      	movi.n	a11, -10
42000cae:	584037        	ball	a0, a3, 42000d0a <_stext+0xcea>
42000cb1:	3fc960        	f64cmph	a12, a9, a6, 3
42000cb4:	c92794        	lsi	f9, a7, 0x324
42000cb7:	3f          	.byte	0x3f
42000cb8:	c960e4        	lsi	f14, a0, 0x324
42000cbb:	3f          	.byte	0x3f
42000cbc:	926c      	movi.n	a2, -23
42000cbe:	243c02        	lsi	f0, a12, 144
42000cc1:	029b      	addi.n	a0, a2, 9
42000cc3:	b83c      	movi.n	a8, 59
42000cc5:	029a      	add.n	a0, a2, a9
42000cc7:	4c3c      	movi.n	a12, 52
42000cc9:	029a      	add.n	a0, a2, a9
42000ccb:	703c      	movi.n	a0, 55
42000ccd:	3c0292        	l8ui	a9, a2, 60
42000cd0:	120821        	l32r	a2, 41fc54f0 <_coredump_iram_end+0x1c435f0>
42000cd3:	929000        	lsi	f0, a0, 0x248
42000cd6:	f03c02        	lsi	f0, a12, 0x3c0
42000cd9:	3c0292        	l8ui	a9, a2, 60
42000cdc:	9308      	l32i.n	a0, a3, 36
42000cde:	4e3c02        	lsi	f0, a12, 0x138
42000ce1:	3c0291        	l32r	a9, 41fcfcec <_coredump_iram_end+0x1c4ddec>
42000ce4:	029152        	l16si	a5, a1, 4
42000ce7:	563c      	movi.n	a6, 53
42000ce9:	3c0291        	l32r	a9, 41fcfcf4 <_coredump_iram_end+0x1c4ddf4>
42000cec:	915a      	add.n	a9, a1, a5
42000cee:	5e3c02        	lsi	f0, a12, 0x178
42000cf1:	3c0291        	l32r	a9, 41fcfcfc <_coredump_iram_end+0x1c4ddfc>
42000cf4:	6f          	.byte	0x6f
42000cf5:	3c0291        	l32r	a9, 41fcfd00 <_coredump_iram_end+0x1c4de00>
42000cf8:	029320        	andb	b9, b3, b2
42000cfb:	9c3c      	movi.n	a12, 57
42000cfd:	3c0294        	lsi	f9, a2, 240
42000d00:	948c      	beqz.n	a4, 42000d0d <_stext+0xced>
42000d02:	803c02        	lsi	f0, a12, 0x200
42000d05:	3c0291        	l32r	a9, 41fcfd10 <_coredump_iram_end+0x1c4de10>
42000d08:	e00000        	subx4	a0, a0, a0
42000d0b:	3f          	.byte	0x3f
42000d0c:	ff          	.byte	0xff
42000d0d:	ff          	.byte	0xff
42000d0e:	ef          	.byte	0xef
42000d0f:	7f          	.byte	0x7f
42000d10:	258c      	beqz.n	a5, 42000d16 <_stext+0xcf6>
42000d12:	b84000        	lsi	f0, a0, 0x2e0
42000d15:	400023        	lsi	f2, a0, 0x100
42000d18:	23dc      	bnez.n	a3, 42000d2e <_stext+0xd0e>
42000d1a:	184000        	lsxp	f4, a0, a0
42000d1d:	400024        	lsi	f2, a0, 0x100
42000d20:	228c      	beqz.n	a2, 42000d26 <_stext+0xd06>
42000d22:	d44000        	extui	a4, a0, 0, 14
42000d25:	400022        	l8ui	a2, a0, 64
42000d28:	002334        	lsi	f3, a3, 0
42000d2b:	24fc40        	extui	a15, a4, 12, 3
42000d2e:	6c4000        	lsi	f0, a0, 0x1b0
42000d31:	400024        	lsi	f2, a0, 0x100
42000d34:	0023a0        	lsi	f10, a3, 0
42000d37:	257440        	extui	a7, a4, 20, 3
42000d3a:	ac4000        	lsi	f0, a0, 0x2b0
42000d3d:	3c0294        	lsi	f9, a2, 240
42000d40:	94cc      	bnez.n	a4, 42000d4d <_stext+0xd2d>
42000d42:	2c3c02        	lsi	f0, a12, 176
42000d45:	3c0295        	call4	4203cd70 <_etext+0x26b1a>
42000d48:	029544        	lsi	f4, a5, 8
42000d4b:	6f3c      	movi.n	a15, 54
42000d4d:	3c0291        	l32r	a9, 41fcfd58 <_coredump_iram_end+0x1c4de58>
42000d50:	5e          	.byte	0x5e
42000d51:	3c0291        	l32r	a9, 41fcfd5c <_coredump_iram_end+0x1c4de5c>
42000d54:	955c      	movi.n	a5, 89
42000d56:	d83c02        	lsi	f0, a12, 0x360
42000d59:	3c0296        	bltz	a2, 4200111d <__esp_system_init_fn_init_show_app_info+0x3d>
42000d5c:	96c8      	l32i.n	a12, a6, 36
42000d5e:	cc3c02        	lsi	f0, a12, 0x330
42000d61:	010a      	add.n	a0, a1, a0
42000d63:	279842        	l16si	a4, a8, 78
42000d66:	3fc9      	s32i.n	a12, a15, 12
42000d68:	ff          	.byte	0xff
42000d69:	ff          	.byte	0xff
42000d6a:	0f          	.byte	0xf
42000d6b:	918280        	lsi	f8, a2, 0x244
42000d6e:	8a3c02        	lsi	f0, a12, 0x228
42000d71:	3c0291        	l32r	a9, 41fcfd7c <_coredump_iram_end+0x1c4de7c>
42000d74:	918b      	addi.n	a9, a1, 8
42000d76:	8e3c02        	lsi	f0, a12, 0x238
42000d79:	3c0291        	l32r	a9, 41fcfd84 <_coredump_iram_end+0x1c4de84>
42000d7c:	029180        	andb	b9, b1, b8
42000d7f:	8f3c      	movi.n	a15, 56
42000d81:	3c0291        	l32r	a9, 41fcfd8c <_coredump_iram_end+0x1c4de8c>
42000d84:	0291a6        	blti	a1, 10, 42000d8a <_stext+0xd6a>
42000d87:	813c      	movi.n	a1, 56
42000d89:	3c0291        	l32r	a9, 41fcfd94 <_coredump_iram_end+0x1c4de94>
42000d8c:	f00000        	subx8	a0, a0, a0
42000d8f:	3f          	.byte	0x3f
42000d90:	9748      	l32i.n	a4, a7, 36
42000d92:	fa3c02        	lsi	f0, a12, 0x3e8
42000d95:	3c0291        	l32r	a9, 41fcfda0 <_coredump_iram_end+0x1c4dea0>
42000d98:	029720        	andb	b9, b7, b2
42000d9b:	003c      	movi.n	a0, 48
42000d9d:	402400        	ssa8l	a4
42000da0:	140000        	extui	a0, a0, 0, 2
42000da3:	000040        	lsi	f4, a0, 0
42000da6:	401c      	movi.n	a0, 20
42000da8:	6f4361        	l32r	a6, 41fdcab4 <_coredump_iram_end+0x1c5abb4>
42000dab:	87a763        	lsi	f6, a7, 0x21c
42000dae:	b33fd2        	lsi	f13, a15, 0x2cc
42000db1:	60c8      	l32i.n	a12, a0, 24
42000db3:	288b      	addi.n	a2, a8, 8
42000db5:	c68a      	add.n	a12, a6, a8
42000db7:	3f          	.byte	0x3f
42000db8:	79fb      	addi.n	a7, a9, 15
42000dba:	9f          	.byte	0x9f
42000dbb:	441350        	extui	a1, a5, 3, 5
42000dbe:	643fd3        	lsi	f13, a15, 0x190
42000dc1:	400023        	lsi	f2, a0, 0x100
42000dc4:	002184        	lsi	f8, a1, 0
42000dc7:	225040        	orb	b5, b0, b4
42000dca:	8f4000        	f64cmph	a4, a0, a0, 8
42000dcd:	3c0291        	l32r	a9, 41fcfdd8 <_coredump_iram_end+0x1c4ded8>
42000dd0:	920b      	addi.n	a9, a2, -1
42000dd2:	b03c02        	lsi	f0, a12, 0x2c0
42000dd5:	fe          	.byte	0xfe
42000dd6:	fa4037        	ball	a0, a3, 42000dd4 <_stext+0xdb4>
42000dd9:	3c0291        	l32r	a9, 41fcfde4 <_coredump_iram_end+0x1c4dee4>
42000ddc:	8e39      	s32i.n	a3, a14, 32
42000dde:	e838e3        	lsi	f14, a8, 0x3a0
42000de1:	3c0296        	bltz	a2, 420011a5 <__esp_system_init_fn_init_show_app_info+0xc5>
42000de4:	029810        	andb	b9, b8, b1
42000de7:	303c      	movi.n	a0, 51
42000de9:	0298      	l32i.n	a9, a2, 0
42000deb:	903c      	movi.n	a0, 57
42000ded:	0298      	l32i.n	a9, a2, 0
42000def:	a83c      	movi.n	a8, 58
42000df1:	0298      	l32i.n	a9, a2, 0
42000df3:	6f3c      	movi.n	a15, 54
42000df5:	3c0291        	l32r	a9, 41fcfe00 <_coredump_iram_end+0x1c4df00>
42000df8:	5e          	.byte	0x5e
42000df9:	3c0291        	l32r	a9, 41fcfe04 <_coredump_iram_end+0x1c4df04>
42000dfc:	0298c0        	andb	b9, b8, b12
42000dff:	3c3c      	movi.n	a12, 51
42000e01:	029a      	add.n	a0, a2, a9
42000e03:	2c3c      	movi.n	a12, 50
42000e05:	029a      	add.n	a0, a2, a9
42000e07:	003c      	movi.n	a0, 48
42000e09:	100000        	and	a0, a0, a0
42000e0c:	800000        	add	a0, a0, a0
42000e0f:	000000        	ill
42000e12:	000004        	lsi	f0, a0, 0
42000e15:	002000        	isync
42000e18:	020000        	andb	b0, b0, b0
42000e1b:	000000        	ill
42000e1e:	000010        	lsi	f1, a0, 0
42000e21:	000100        	lsi	f0, a1, 0
42000e24:	080000        	lsx	f0, a0, a0
42000e27:	078f00        	lsi	f0, a15, 28
42000e2a:	0078      	l32i.n	a7, a0, 0
42000e2c:	030000        	rsr.lbeg	a0
42000e2f:	3e0800        	f64norm	a0, a8, a0, 1
42000e32:	080000        	lsx	f0, a0, a0
42000e35:	600c00        	lsi	f0, a12, 0x180
42000e38:	c04001        	l32r	a0, 41ff0f38 <_coredump_iram_end+0x1c6f038>
42000e3b:	601817        	beq	a8, a1, 42000e9f <_stext+0xe7f>
42000e3e:	0c6002        	s32i	a0, a0, 48
42000e41:	600c00        	lsi	f0, a12, 0x180
42000e44:	0235e0        	andb	b3, b5, b14
42000e47:	943c      	movi.n	a4, 57
42000e49:	027b      	addi.n	a0, a2, 7
42000e4b:	1c3c      	movi.n	a12, 49
42000e4d:	3c0236        	entry	a2, 0x1e00
42000e50:	1f58      	l32i.n	a5, a15, 4
42000e52:	3fc9      	s32i.n	a12, a15, 12
42000e54:	c94ad0        	lsi	f13, a10, 0x324
42000e57:	3f          	.byte	0x3f
42000e58:	36c8      	l32i.n	a12, a6, 12
42000e5a:	083c02        	lsi	f0, a12, 32
42000e5d:	027c      	movi.n	a2, -16
42000e5f:	093c      	movi.n	a9, 48
42000e61:	3c0237        	bnone	a2, a3, 42000ea1 <_stext+0xe81>
42000e64:	007000        	waiti	0
42000e67:	371460        	lsi	f6, a4, 220
42000e6a:	ec3c02        	lsi	f0, a12, 0x3b0
42000e6d:	027b      	addi.n	a0, a2, 7
42000e6f:	593c      	movi.n	a9, 53
42000e71:	002a      	add.n	a0, a0, a2
42000e73:	32c700        	orbc	b12, b7, b0
42000e76:	d40000        	extui	a0, a0, 0, 14
42000e79:	027b      	addi.n	a0, a2, 7
42000e7b:	bc3c      	movi.n	a12, 59
42000e7d:	027b      	addi.n	a0, a2, 7
42000e7f:	c53c      	movi.n	a5, 60
42000e81:	000027        	bnone	a0, a2, 42000e85 <_stext+0xe65>
42000e84:	c91f74        	lsi	f7, a15, 0x324
42000e87:	3f          	.byte	0x3f
42000e88:	1f6c      	movi.n	a15, -31
42000e8a:	3fc9      	s32i.n	a12, a15, 12
42000e8c:	c91f70        	lsi	f7, a15, 0x324
42000e8f:	3f          	.byte	0x3f
42000e90:	1f68      	l32i.n	a6, a15, 4
42000e92:	3fc9      	s32i.n	a12, a15, 12
42000e94:	3728      	l32i.n	a2, a7, 12
42000e96:	303c02        	lsi	f0, a12, 192
42000e99:	3c0237        	bnone	a2, a3, 42000ed9 <_stext+0xeb9>
42000e9c:	3784a4        	lsi	f10, a4, 220
42000e9f:	8a0440        	round.s	a0, f4, 4
42000ea2:	bc4037        	ball	a0, a3, 42000e62 <_stext+0xe42>
42000ea5:	403793        	lsi	f9, a7, 0x100
42000ea8:	378f10        	lsi	f1, a15, 220
42000eab:	678440        	lsi	f4, a4, 0x19c
42000eae:	904037        	ball	a0, a3, 42000e42 <_stext+0xe22>
42000eb1:	600080        	neg	a0, a8
42000eb4:	ff          	.byte	0xff
42000eb5:	ff          	.byte	0xff
42000eb6:	fffd      	lsi	f15, a15, 60
42000eb8:	008094        	lsi	f9, a0, 0
42000ebb:	803460        	add	a3, a4, a6
42000ebe:	1c6000        	lsi	f0, a0, 112
42000ec1:	600080        	neg	a0, a8
42000ec4:	3f          	.byte	0x3f
42000ec5:	ffffc0        	f64cmph	a15, a15, a12, 15
42000ec8:	802c      	movi.n	a0, 40
42000eca:	ff6000        	f64cmph	a6, a0, a0, 15
42000ecd:	ffff00        	f64cmph	a15, a15, a0, 15
42000ed0:	7bac      	beqz.n	a11, 42000efb <_stext+0xedb>
42000ed2:	243c02        	lsi	f0, a12, 144
42000ed5:	600080        	neg	a0, a8
42000ed8:	ff          	.byte	0xff
42000ed9:	ffff01        	l32r	a0, 42000ed8 <_stext+0xeb8> (ffff01ff <_rtc_reserved_end+0x9fef01ff>)
42000edc:	ff          	.byte	0xff
42000edd:	ff          	.byte	0xff
42000ede:	30fe00        	xor	a15, a14, a0
42000ee1:	600080        	neg	a0, a8
42000ee4:	8028      	l32i.n	a2, a0, 32
42000ee6:	206000        	or	a6, a0, a0
42000ee9:	600080        	neg	a0, a8
42000eec:	ff          	.byte	0xff
42000eed:	7f          	.byte	0x7f
42000eee:	2cff00        	lsi	f0, a15, 176
42000ef1:	600c41        	l32r	a4, 41fd8f24 <_coredump_iram_end+0x1c57024>
42000ef4:	60a8      	l32i.n	a10, a0, 24
42000ef6:	086002        	s32i	a0, a0, 32
42000ef9:	600c40        	lsi	f4, a12, 0x180
42000efc:	4068      	l32i.n	a6, a0, 16
42000efe:	600c      	movi.n	a0, 6
42000f00:	30e8      	l32i.n	a14, a0, 12
42000f02:	e86000        	lsi	f0, a0, 0x3a0
42000f05:	600020        	neg	a0, a2
42000f08:	008074        	lsi	f7, a0, 0
42000f0b:	800060        	add	a0, a0, a6
42000f0e:	ff6000        	f64cmph	a6, a0, a0, 15
42000f11:	df          	.byte	0xdf
42000f12:	ff          	.byte	0xff
42000f13:	ff          	.byte	0xff
42000f14:	ff          	.byte	0xff
42000f15:	ff          	.byte	0xff
42000f16:	fffb      	addi.n	a15, a15, 15
42000f18:	ff          	.byte	0xff
42000f19:	fffff7        	bbsi	a15, 31, 42000f1c <_stext+0xefc>
42000f1c:	8088      	l32i.n	a8, a0, 32
42000f1e:	ff6000        	f64cmph	a6, a0, a0, 15
42000f21:	ff          	.byte	0xff
42000f22:	84fff7        	bbsi	a15, 31, 42000eaa <_stext+0xe8a>
42000f25:	600080        	neg	a0, a8
42000f28:	0c0014        	lsi	f1, a0, 48
42000f2b:	ffff60        	f64cmph	a15, a15, a6, 15
42000f2e:	ef          	.byte	0xef
42000f2f:	ff          	.byte	0xff
42000f30:	ff          	.byte	0xff
42000f31:	ff          	.byte	0xff
42000f32:	ff          	.byte	0xff
42000f33:	cf          	.byte	0xcf
42000f34:	ff          	.byte	0xff
42000f35:	ff          	.byte	0xff
42000f36:	3f          	.byte	0x3f
42000f37:	ff          	.byte	0xff
42000f38:	ff          	.byte	0xff
42000f39:	ef          	.byte	0xef
42000f3a:	ff          	.byte	0xff
42000f3b:	ff          	.byte	0xff
42000f3c:	ff          	.byte	0xff
42000f3d:	ff          	.byte	0xff
42000f3e:	ff          	.byte	0xff
42000f3f:	fffff3        	lsi	f15, a15, 0x3fc
42000f42:	bf          	.byte	0xbf
42000f43:	ff          	.byte	0xff
42000f44:	ff          	.byte	0xff
42000f45:	ff          	.byte	0xff
42000f46:	ff          	.byte	0xff
42000f47:	10fc      	bnez.n	a0, 42000f7c <_stext+0xf5c>
42000f49:	600c00        	lsi	f0, a12, 0x180
42000f4c:	8f1c      	movi.n	a15, 24
42000f4e:	004037        	ball	a0, a3, 42000f52 <_stext+0xf32>
42000f51:	0088      	l32i.n	a8, a0, 0
42000f53:	ffff60        	f64cmph	a15, a15, a6, 15
42000f56:	ff          	.byte	0xff
42000f57:	9f          	.byte	0x9f
42000f58:	4b0c      	movi.n	a11, 4
42000f5a:	3fc9      	s32i.n	a12, a15, 12
42000f5c:	40dc      	bnez.n	a0, 42000f74 <_stext+0xf54>
42000f5e:	e83c02        	lsi	f0, a12, 0x3a0
42000f61:	3c0240        	lsi	f4, a2, 240
42000f64:	5b38      	l32i.n	a3, a11, 20
42000f66:	084201        	l32r	a0, 41fc3070 <_coredump_iram_end+0x1c41170>
42000f69:	3c0241        	l32r	a4, 41fcff74 <_coredump_iram_end+0x1c4e074>
42000f6c:	4128      	l32i.n	a2, a1, 16
42000f6e:	643c02        	lsi	f0, a12, 0x190
42000f71:	37ba      	add.n	a3, a7, a11
42000f73:	220040        	orb	b0, b0, b4
42000f76:	500000        	lsi	f0, a0, 0x140
42000f79:	3c0241        	l32r	a4, 41fcff84 <_coredump_iram_end+0x1c4e084>
42000f7c:	5b4c      	movi.n	a11, 69
42000f7e:	644201        	l32r	a0, 41fda088 <_coredump_iram_end+0x1c58188>
42000f81:	0f          	.byte	0xf
42000f82:	ac3c02        	lsi	f0, a12, 0x2b0
42000f85:	7e          	.byte	0x7e
42000f86:	723c02        	lsi	f0, a12, 0x1c8
42000f89:	3c0241        	l32r	a4, 41fcff94 <_coredump_iram_end+0x1c4e094>
42000f8c:	000000        	ill
42000f8f:	c7a400        	lsi	f0, a4, 0x31c
42000f92:	e84037        	ball	a0, a3, 42000f7e <_stext+0xf5e>
42000f95:	c94d      	lsi	f4, a9, 36
42000f97:	3f          	.byte	0x3f
42000f98:	a048      	l32i.n	a4, a0, 40
42000f9a:	1c4037        	ball	a0, a3, 42000fba <_stext+0xf9a>
42000f9d:	022a      	add.n	a0, a2, a2
42000f9f:	383c      	movi.n	a8, 51
42000fa1:	0278      	l32i.n	a7, a2, 0
42000fa3:	3e3c      	movi.n	a14, 51
42000fa5:	022a      	add.n	a0, a2, a2
42000fa7:	343c      	movi.n	a4, 51
42000fa9:	37fb      	addi.n	a3, a7, 15
42000fab:	5d1840        	lsi	f4, a8, 0x174
42000fae:	b84201        	l32r	a0, 41fef0b8 <_coredump_iram_end+0x1c6d1b8>
42000fb1:	4037e6        	bgei	a7, 3, 42000ff5 <_stext+0xfd5>
42000fb4:	ebcc      	bnez.n	a11, 42000fc6 <_stext+0xfa6>
42000fb6:	c84037        	ball	a0, a3, 42000f82 <_stext+0xf62>
42000fb9:	4037e7        	bltu	a7, a14, 42000ffd <_stext+0xfdd>
42000fbc:	e6dc      	bnez.n	a6, 42000fde <_stext+0xfbe>
42000fbe:	ff4037        	ball	a0, a3, 42000fc1 <_stext+0xfa1>
42000fc1:	ffffc0        	f64cmph	a15, a15, a12, 15
42000fc4:	ff          	.byte	0xff
42000fc5:	ff          	.byte	0xff
42000fc6:	8f          	.byte	0x8f
42000fc7:	ff          	.byte	0xff
42000fc8:	300000        	xor	a0, a0, a0
42000fcb:	000000        	ill
42000fce:	000040        	lsi	f4, a0, 0
42000fd1:	005000        	syscall
42000fd4:	ff          	.byte	0xff
42000fd5:	3f          	.byte	0x3f
42000fd6:	fffff0        	f64cmph	a15, a15, a15, 15
42000fd9:	ff          	.byte	0xff
42000fda:	7f          	.byte	0x7f
42000fdb:	2a5c80        	mul.s	f5, f12, f8
42000fde:	283c02        	lsi	f0, a12, 160
42000fe1:	0279      	s32i.n	a7, a2, 0
42000fe3:	db3c      	movi.n	a11, 61
42000fe5:	022a      	add.n	a0, a2, a2
42000fe7:	e43c      	movi.n	a4, 62
42000fe9:	022a      	add.n	a0, a2, a2
42000feb:	283c      	movi.n	a8, 50
42000fed:	022b      	addi.n	a0, a2, 2
42000fef:	303c      	movi.n	a0, 51
42000ff1:	022b      	addi.n	a0, a2, 2
42000ff3:	383c      	movi.n	a8, 51
42000ff5:	022b      	addi.n	a0, a2, 2
42000ff7:	b03c      	movi.n	a0, 59
42000ff9:	5e          	.byte	0x5e
42000ffa:	504201        	l32r	a0, 41fd5104 <_coredump_iram_end+0x1c53204>
42000ffd:	022b      	addi.n	a0, a2, 2
42000fff:	7c3c      	movi.n	a12, 55
42001001:	0279      	s32i.n	a7, a2, 0
42001003:	833c      	movi.n	a3, 56
42001005:	022b      	addi.n	a0, a2, 2
42001007:	9c3c      	movi.n	a12, 57
42001009:	022b      	addi.n	a0, a2, 2
4200100b:	d03c      	movi.n	a0, 61
4200100d:	022b      	addi.n	a0, a2, 2
4200100f:	103c      	movi.n	a0, 49
42001011:	022c      	movi.n	a2, 32
42001013:	5c3c      	movi.n	a12, 53
42001015:	0279      	s32i.n	a7, a2, 0
42001017:	5b3c      	movi.n	a11, 53
42001019:	022c      	movi.n	a2, 32
4200101b:	743c      	movi.n	a4, 55
4200101d:	022c      	movi.n	a2, 32
4200101f:	b03c      	movi.n	a0, 59
42001021:	022c      	movi.n	a2, 32
42001023:	2c3c      	movi.n	a12, 50
42001025:	2e          	.byte	0x2e
42001026:	6c3c02        	lsi	f0, a12, 0x1b0
42001029:	37fb      	addi.n	a3, a7, 15
4200102b:	fb4440        	f64addc	a4, a4, 2, 0
4200102e:	a44037        	ball	a0, a3, 42000fd6 <_stext+0xfb6>
42001031:	37fb      	addi.n	a3, a7, 15
42001033:	21b840        	srai	a11, a4, 8
42001036:	3fc9      	s32i.n	a12, a15, 12
42001038:	6cbc      	beqz.n	a12, 42001072 <esp_app_format_init_elf_sha256+0x32>
4200103a:	2c4037        	ball	a0, a3, 4200106a <esp_app_format_init_elf_sha256+0x2a>
4200103d:	3c0291        	l32r	a9, 41fd0048 <_coredump_iram_end+0x1c4e148>

42001040 <esp_app_format_init_elf_sha256>:
 * can lead to a complete lock-up of the CPU.
 * For this reason we do a reading of esp_app_desc.app_elf_sha256 and convert to string while start up in esp_system_init_app_elf_sha256()
 * and keep it in the static app_elf_sha256_str variable.
 */
static void esp_app_format_init_elf_sha256(void)
{
42001040:	004136        	entry	a1, 32
    if (*((int *)&app_elf_sha256_str) != 0) {
42001043:	fbf781        	l32r	a8, 42000020 <_stext> (3fc94860 <app_elf_sha256_str>)
42001046:	0888      	l32i.n	a8, a8, 0
42001048:	04e856        	bnez	a8, 4200109a <esp_app_format_init_elf_sha256+0x5a>
    }
    // At -O2 optimization level, GCC optimizes out the copying of the first byte of the app_elf_sha256,
    // because it is zero at compile time, and only modified afterwards by esptool.
    // Casting to volatile disables the optimization.
    const volatile char* src = (const volatile char*)esp_app_desc.app_elf_sha256;
    for (size_t i = 0; i < sizeof(app_elf_sha256_str) / 2; ++i) {
4200104b:	0c0c      	movi.n	a12, 0
4200104d:	000f86        	j	4200108f <esp_app_format_init_elf_sha256+0x4f>
        char c = src[i];
42001050:	fbf581        	l32r	a8, 42000024 <_stext+0x4> (3c0200b0 <esp_app_desc+0x90>)
42001053:	8c8a      	add.n	a8, a12, a8
42001055:	0020c0        	memw
42001058:	000882        	l8ui	a8, a8, 0
4200105b:	748080        	extui	a8, a8, 0, 8
        for (size_t s = 0; s < 2; ++s) {
4200105e:	090c      	movi.n	a9, 0
42001060:	000986        	j	4200108a <esp_app_format_init_elf_sha256+0x4a>
42001063:	a48000        	extui	a8, a0, 0, 11
            char val = (c >> 4) & 0xF;
42001066:	9b0c41        	l32r	a4, 41fe7c98 <_coredump_iram_end+0x1c65d98>
            app_elf_sha256_str[2 * i + s] = (val < 10) ? ('0' + val) : ('a' + val - 10);
42001069:	073ba7        	bltu	a11, a10, 42001074 <esp_app_format_init_elf_sha256+0x34>
4200106c:	30caa2        	addi	a10, a10, 48
4200106f:	000106        	j	42001077 <esp_app_format_init_elf_sha256+0x37>
42001072:	a20000        	muluh	a0, a0, a0
42001075:	57ca      	add.n	a5, a7, a12
42001077:	90dc90        	addx2	a13, a12, a9
4200107a:	fbe9b1        	l32r	a11, 42000020 <_stext> (3fc94860 <app_elf_sha256_str>)
4200107d:	bbda      	add.n	a11, a11, a13
4200107f:	004ba2        	s8i	a10, a11, 0
            c <<= 4;
42001082:	1188c0        	slli	a8, a8, 4
42001085:	748080        	extui	a8, a8, 0, 8
        for (size_t s = 0; s < 2; ++s) {
42001088:	991b      	addi.n	a9, a9, 1
4200108a:	d629b6        	bltui	a9, 2, 42001064 <esp_app_format_init_elf_sha256+0x24>
    for (size_t i = 0; i < sizeof(app_elf_sha256_str) / 2; ++i) {
4200108d:	cc1b      	addi.n	a12, a12, 1
4200108f:	bd5cb6        	bltui	a12, 5, 42001050 <esp_app_format_init_elf_sha256+0x10>
        }
    }
    app_elf_sha256_str[sizeof(app_elf_sha256_str) - 1] = 0;
42001092:	fbe381        	l32r	a8, 42000020 <_stext> (3fc94860 <app_elf_sha256_str>)
42001095:	090c      	movi.n	a9, 0
42001097:	094892        	s8i	a9, a8, 9
}
4200109a:	f01d      	retw.n

4200109c <esp_app_get_elf_sha256>:

int esp_app_get_elf_sha256(char* dst, size_t size)
{
4200109c:	004136        	entry	a1, 32
4200109f:	027d      	mov.n	a7, a2
    if (dst == NULL || size < 2) {
420010a1:	40f290        	nsau	a9, a2
420010a4:	419590        	srli	a9, a9, 5
420010a7:	180c      	movi.n	a8, 1
420010a9:	628830        	lsi	f3, a8, 0x188
420010ac:	880b      	addi.n	a8, a8, -1
420010ae:	608080        	neg	a8, a8
420010b1:	748080        	extui	a8, a8, 0, 8
420010b4:	209980        	or	a9, a9, a8
420010b7:	f9dc      	bnez.n	a9, 420010da <esp_app_get_elf_sha256+0x3e>
        return 0;
    }
    esp_app_format_init_elf_sha256();
420010b9:	fff865        	call8	42001040 <esp_app_format_init_elf_sha256>
    size_t n = MIN(size, sizeof(app_elf_sha256_str));
420010bc:	a80c      	movi.n	a8, 10
420010be:	632380        	minu	a2, a3, a8
    memcpy(dst, app_elf_sha256_str, n);
420010c1:	02cd      	mov.n	a12, a2
420010c3:	fbd7b1        	l32r	a11, 42000020 <_stext> (3fc94860 <app_elf_sha256_str>)
420010c6:	07ad      	mov.n	a10, a7
420010c8:	fbd881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420010cb:	0008e0        	callx8	a8
    dst[n - 1] = 0;
420010ce:	820b      	addi.n	a8, a2, -1
420010d0:	778a      	add.n	a7, a7, a8
420010d2:	080c      	movi.n	a8, 0
420010d4:	004782        	s8i	a8, a7, 0
    return n;
420010d7:	000046        	j	420010dc <esp_app_get_elf_sha256+0x40>
        return 0;
420010da:	020c      	movi.n	a2, 0
}
420010dc:	f01d      	retw.n
	...

420010e0 <__esp_system_init_fn_init_show_app_info>:

// startup function definition and execution does not exist on the Linux target
// (TODO: IDF-9950)
#if !CONFIG_IDF_TARGET_LINUX && !ESP_TEE_BUILD
ESP_SYSTEM_INIT_FN(init_show_app_info, CORE, BIT(0), 20)
{
420010e0:	008136        	entry	a1, 64
    // Load the current ELF SHA256
    esp_app_format_init_elf_sha256();
420010e3:	fff5e5        	call8	42001040 <esp_app_format_init_elf_sha256>
420010e6:	fbd181        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
420010e9:	0888      	l32i.n	a8, a8, 0

    // Display information about the current running image.
    if (LOG_LOCAL_LEVEL >= ESP_LOG_INFO) {
        ESP_EARLY_LOGI(TAG, "Application information:");
420010eb:	1338b6        	bltui	a8, 3, 42001102 <__esp_system_init_fn_init_show_app_info+0x22>
420010ee:	fbdc81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420010f1:	0008e0        	callx8	a8
420010f4:	fbcfc1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
420010f7:	0abd      	mov.n	a11, a10
420010f9:	fbcea1        	l32r	a10, 42000034 <_stext+0x14> (3c02012c <_flash_rodata_start+0xc>)
420010fc:	fbda81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420010ff:	0008e0        	callx8	a8
42001102:	fbca81        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42001105:	0888      	l32i.n	a8, a8, 0
#ifndef CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR
        ESP_EARLY_LOGI(TAG, "Project name:     %s", esp_app_desc.project_name);
42001107:	1638b6        	bltui	a8, 3, 42001121 <__esp_system_init_fn_init_show_app_info+0x41>
4200110a:	fbd581        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200110d:	0008e0        	callx8	a8
42001110:	fbcad1        	l32r	a13, 42000038 <_stext+0x18> (3c020050 <esp_app_desc+0x30>)
42001113:	fbc7c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
42001116:	0abd      	mov.n	a11, a10
42001118:	fbc9a1        	l32r	a10, 4200003c <_stext+0x1c> (3c020154 <_flash_rodata_start+0x34>)
4200111b:	fbd281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200111e:	0008e0        	callx8	a8
42001121:	fbc281        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42001124:	002882        	l32i	a8, a8, 0
#endif
#ifndef CONFIG_APP_EXCLUDE_PROJECT_VER_VAR
        ESP_EARLY_LOGI(TAG, "App version:      %s", esp_app_desc.version);
42001127:	1638b6        	bltui	a8, 3, 42001141 <__esp_system_init_fn_init_show_app_info+0x61>
4200112a:	fbcd81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200112d:	0008e0        	callx8	a8
42001130:	fbc4d1        	l32r	a13, 42000040 <_stext+0x20> (3c020030 <esp_app_desc+0x10>)
42001133:	fbbfc1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
42001136:	0abd      	mov.n	a11, a10
42001138:	fbc3a1        	l32r	a10, 42000044 <_stext+0x24> (3c020178 <_flash_rodata_start+0x58>)
4200113b:	fbca81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200113e:	0008e0        	callx8	a8
42001141:	fbba81        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42001144:	002882        	l32i	a8, a8, 0
#endif
#ifdef CONFIG_BOOTLOADER_APP_SECURE_VERSION
        ESP_EARLY_LOGI(TAG, "Secure version:   %" PRIu32, esp_app_desc.secure_version);
#endif
#ifdef CONFIG_APP_COMPILE_TIME_DATE
        ESP_EARLY_LOGI(TAG, "Compile time:     %s %s", esp_app_desc.date, esp_app_desc.time);
42001147:	1938b6        	bltui	a8, 3, 42001164 <__esp_system_init_fn_init_show_app_info+0x84>
4200114a:	fbc581        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200114d:	0008e0        	callx8	a8
42001150:	fbbee1        	l32r	a14, 42000048 <_stext+0x28> (3c020070 <esp_app_desc+0x50>)
42001153:	fbbed1        	l32r	a13, 4200004c <_stext+0x2c> (3c020080 <esp_app_desc+0x60>)
42001156:	fbb6c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
42001159:	0abd      	mov.n	a11, a10
4200115b:	fbbda1        	l32r	a10, 42000050 <_stext+0x30> (3c02019c <_flash_rodata_start+0x7c>)
4200115e:	fbc181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001161:	0008e0        	callx8	a8
#endif
        char buf[17];
        esp_app_get_elf_sha256(buf, sizeof(buf));
42001164:	1b1c      	movi.n	a11, 17
42001166:	01ad      	mov.n	a10, a1
42001168:	fff325        	call8	4200109c <esp_app_get_elf_sha256>
4200116b:	fbb081        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
4200116e:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "ELF file SHA256:  %s...", buf);
42001170:	1538b6        	bltui	a8, 3, 42001189 <__esp_system_init_fn_init_show_app_info+0xa9>
42001173:	fbbb81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001176:	0008e0        	callx8	a8
42001179:	01dd      	mov.n	a13, a1
4200117b:	fbadc1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
4200117e:	0abd      	mov.n	a11, a10
42001180:	fbb5a1        	l32r	a10, 42000054 <_stext+0x34> (3c0201c4 <_flash_rodata_start+0xa4>)
42001183:	fbb881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001186:	0008e0        	callx8	a8
42001189:	fba881        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
4200118c:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "ESP-IDF:          %s", esp_app_desc.idf_ver);
4200118f:	1638b6        	bltui	a8, 3, 420011a9 <__esp_system_init_fn_init_show_app_info+0xc9>
42001192:	fbb381        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001195:	0008e0        	callx8	a8
42001198:	fbb0d1        	l32r	a13, 42000058 <_stext+0x38> (3c020090 <esp_app_desc+0x70>)
4200119b:	fba5c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
4200119e:	0abd      	mov.n	a11, a10
420011a0:	fbafa1        	l32r	a10, 4200005c <_stext+0x3c> (3c0201ec <_flash_rodata_start+0xcc>)
420011a3:	fbb081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420011a6:	0008e0        	callx8	a8
    }
    return ESP_OK;
}
420011a9:	020c      	movi.n	a2, 0
420011ab:	f01d      	retw.n
420011ad:	000000        	ill

420011b0 <__esp_system_init_fn_init_efuse_check>:
#endif

static __attribute__((unused)) const char *TAG = "efuse_init";

ESP_SYSTEM_INIT_FN(init_efuse_check, CORE, BIT(0), 1)
{
420011b0:	004136        	entry	a1, 32
    // (Only for C3): We check if the efuse BLOCK0 has certain coding errors then reset the chip.
    if (esp_efuse_check_errors() != ESP_OK) {
420011b3:	000da5        	call8	4200128c <esp_efuse_check_errors>
420011b6:	4a8c      	beqz.n	a10, 420011be <__esp_system_init_fn_init_efuse_check+0xe>
        esp_restart();
420011b8:	201110        	or	a1, a1, a1
420011bb:	001125        	call8	420012cc <esp_restart>
    }
    return ESP_OK;
}
420011be:	020c      	movi.n	a2, 0
420011c0:	f01d      	retw.n
	...

420011c4 <__esp_system_init_fn_init_efuse_show_app_info>:

// It comes after init_show_app_info to print the consistent application information.
ESP_SYSTEM_INIT_FN(init_efuse_show_app_info, CORE, BIT(0), 21)
{
420011c4:	004136        	entry	a1, 32
420011c7:	fb9981        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
420011ca:	002882        	l32i	a8, a8, 0
    if (LOG_LOCAL_LEVEL >= ESP_LOG_INFO) {
        ESP_EARLY_LOGI(TAG, "Min chip rev:     v%d.%d", CONFIG_ESP_REV_MIN_FULL / 100, CONFIG_ESP_REV_MIN_FULL % 100);
420011cd:	1738b6        	bltui	a8, 3, 420011e8 <__esp_system_init_fn_init_efuse_show_app_info+0x24>
420011d0:	fba481        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420011d3:	0008e0        	callx8	a8
420011d6:	0e0c      	movi.n	a14, 0
420011d8:	0edd      	mov.n	a13, a14
420011da:	fba5c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
420011dd:	0abd      	mov.n	a11, a10
420011df:	fba5a1        	l32r	a10, 42000074 <_stext+0x54> (3c020234 <_flash_rodata_start+0x114>)
420011e2:	fba081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420011e5:	0008e0        	callx8	a8
420011e8:	fb9181        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
420011eb:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "Max chip rev:     v%d.%d %s", CONFIG_ESP_REV_MAX_FULL / 100, CONFIG_ESP_REV_MAX_FULL % 100,
420011ed:	3038b6        	bltui	a8, 3, 42001221 <__esp_system_init_fn_init_efuse_show_app_info+0x5d>
420011f0:	fb9c81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420011f3:	0008e0        	callx8	a8
420011f6:	0a7d      	mov.n	a7, a10
420011f8:	fba381        	l32r	a8, 42000084 <_stext+0x64> (40375e10 <efuse_hal_get_disable_wafer_version_major>)
420011fb:	0008e0        	callx8	a8
420011fe:	7a8c      	beqz.n	a10, 42001209 <__esp_system_init_fn_init_efuse_show_app_info+0x45>
42001200:	fb9af1        	l32r	a15, 42000068 <_stext+0x48> (3c020210 <_flash_rodata_start+0xf0>)
42001203:	000146        	j	4200120c <__esp_system_init_fn_init_efuse_show_app_info+0x48>
42001206:	000000        	ill
42001209:	fb98f1        	l32r	a15, 4200006c <_stext+0x4c> (3c020eb0 <_flash_rodata_start+0xd90>)
4200120c:	63a0e2        	movi	a14, 99
4200120f:	00a0d2        	movi	a13, 0
42001212:	fb97c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
42001215:	20b770        	or	a11, a7, a7
42001218:	fb98a1        	l32r	a10, 42000078 <_stext+0x58> (3c02025c <_flash_rodata_start+0x13c>)
4200121b:	fb9281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200121e:	0008e0        	callx8	a8
                        efuse_hal_get_disable_wafer_version_major() ? "(constraint ignored)" : "");
        unsigned revision = efuse_hal_chip_revision();
42001221:	fb9981        	l32r	a8, 42000088 <_stext+0x68> (40375df8 <efuse_hal_chip_revision>)
42001224:	0008e0        	callx8	a8
42001227:	0a7d      	mov.n	a7, a10
42001229:	fb8081        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
4200122c:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "Chip rev:         v%d.%d", revision / 100, revision % 100);
4200122f:	2938b6        	bltui	a8, 3, 4200125c <__esp_system_init_fn_init_efuse_show_app_info+0x98>
42001232:	fb8b81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001235:	0008e0        	callx8	a8
42001238:	fb91d1        	l32r	a13, 4200007c <_stext+0x5c> (51eb851f <_coredump_rtc_end+0x1eb851f>)
4200123b:	a2d7d0        	muluh	a13, a7, a13
4200123e:	41d5d0        	srli	a13, a13, 5
42001241:	a0edd0        	addx4	a14, a13, a13
42001244:	a0eee0        	addx4	a14, a14, a14
42001247:	11eee0        	slli	a14, a14, 2
4200124a:	c0e7e0        	sub	a14, a7, a14
4200124d:	fb88c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
42001250:	20baa0        	or	a11, a10, a10
42001253:	fb8ba1        	l32r	a10, 42000080 <_stext+0x60> (3c020288 <_flash_rodata_start+0x168>)
42001256:	fb8381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001259:	0008e0        	callx8	a8
    }
    return ESP_OK;
}
4200125c:	020c      	movi.n	a2, 0
4200125e:	f01d      	retw.n

42001260 <__esp_system_init_fn_init_efuse>:
    return ESP_OK;
}
#endif // ROM_LOG_MODE

ESP_SYSTEM_INIT_FN(init_efuse, CORE, BIT(0), 140)
{
42001260:	006136        	entry	a1, 48

#ifdef CONFIG_EFUSE_VIRTUAL
    init_efuse_virtual();
#endif

    error = init_efuse_secure();
42001263:	1351e5        	call8	42014780 <init_efuse_secure>
42001266:	0a2d      	mov.n	a2, a10
    ESP_RETURN_ON_ERROR(error, TAG, "Failed in secure eFuse init");
42001268:	ea9c      	beqz.n	a10, 4200128a <__esp_system_init_fn_init_efuse+0x2a>
4200126a:	fb7d81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200126d:	0008e0        	callx8	a8
42001270:	fb80b1        	l32r	a11, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
42001273:	a6a082        	movi	a8, 166
42001276:	0189      	s32i.n	a8, a1, 0
42001278:	fb85f1        	l32r	a15, 4200008c <_stext+0x6c> (3c026e14 <__FUNCTION__$0>)
4200127b:	0bed      	mov.n	a14, a11
4200127d:	0add      	mov.n	a13, a10
4200127f:	fb84c1        	l32r	a12, 42000090 <_stext+0x70> (3c0202b0 <_flash_rodata_start+0x190>)
42001282:	1a0c      	movi.n	a10, 1
42001284:	fb8481        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42001287:	0008e0        	callx8	a8
#ifdef ROM_LOG_MODE
    error = init_efuse_rom_log();
#endif

    return error;
}
4200128a:	f01d      	retw.n

4200128c <esp_efuse_check_errors>:
    }
    return ESP_OK;
}

esp_err_t esp_efuse_check_errors(void)
{
4200128c:	004136        	entry	a1, 32
    return esp_efuse_utility_check_errors();
4200128f:	135025        	call8	42014790 <esp_efuse_utility_check_errors>
}
42001292:	0a2d      	mov.n	a2, a10
42001294:	f01d      	retw.n
	...

42001298 <esp_register_shutdown_handler>:
#define SHUTDOWN_HANDLERS_NO 5

static shutdown_handler_t shutdown_handlers[SHUTDOWN_HANDLERS_NO];

esp_err_t esp_register_shutdown_handler(shutdown_handler_t handler)
{
42001298:	004136        	entry	a1, 32
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
4200129b:	080c      	movi.n	a8, 0
4200129d:	0006c6        	j	420012bc <esp_register_shutdown_handler+0x24>
        if (shutdown_handlers[i] == handler) {
420012a0:	fb7e91        	l32r	a9, 42000098 <_stext+0x78> (3fc9486c <shutdown_handlers>)
420012a3:	a09890        	addx4	a9, a8, a9
420012a6:	0998      	l32i.n	a9, a9, 0
420012a8:	191927        	beq	a9, a2, 420012c5 <esp_register_shutdown_handler+0x2d>
            return ESP_ERR_INVALID_STATE;
        } else if (shutdown_handlers[i] == NULL) {
420012ab:	b9cc      	bnez.n	a9, 420012ba <esp_register_shutdown_handler+0x22>
            shutdown_handlers[i] = handler;
420012ad:	fb7a91        	l32r	a9, 42000098 <_stext+0x78> (3fc9486c <shutdown_handlers>)
420012b0:	a08890        	addx4	a8, a8, a9
420012b3:	0829      	s32i.n	a2, a8, 0
            return ESP_OK;
420012b5:	020c      	movi.n	a2, 0
420012b7:	000346        	j	420012c8 <esp_register_shutdown_handler+0x30>
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
420012ba:	881b      	addi.n	a8, a8, 1
420012bc:	e058a6        	blti	a8, 5, 420012a0 <esp_register_shutdown_handler+0x8>
        }
    }
    return ESP_ERR_NO_MEM;
420012bf:	01a122        	movi	a2, 0x101
420012c2:	000086        	j	420012c8 <esp_register_shutdown_handler+0x30>
            return ESP_ERR_INVALID_STATE;
420012c5:	03a122        	movi	a2, 0x103
}
420012c8:	f01d      	retw.n
	...

420012cc <esp_restart>:
    }
    return ESP_ERR_INVALID_STATE;
}

void esp_restart(void)
{
420012cc:	004136        	entry	a1, 32
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
420012cf:	470c      	movi.n	a7, 4
420012d1:	000386        	j	420012e3 <esp_restart+0x17>
        if (shutdown_handlers[i]) {
420012d4:	fb7181        	l32r	a8, 42000098 <_stext+0x78> (3fc9486c <shutdown_handlers>)
420012d7:	a08780        	addx4	a8, a7, a8
420012da:	0888      	l32i.n	a8, a8, 0
420012dc:	188c      	beqz.n	a8, 420012e1 <esp_restart+0x15>
            shutdown_handlers[i]();
420012de:	0008e0        	callx8	a8
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
420012e1:	770b      	addi.n	a7, a7, -1
420012e3:	fed7d6        	bgez	a7, 420012d4 <esp_restart+0x8>
#if ( ( CONFIG_FREERTOS_SMP ) && ( !CONFIG_FREERTOS_UNICORE ) )
    //Note: Scheduler suspension behavior changed in FreeRTOS SMP
    vTaskPreemptionDisable(NULL);
#else
    // Disable scheduler on this core.
    vTaskSuspendAll();
420012e6:	fb6d81        	l32r	a8, 4200009c <_stext+0x7c> (4037b1a8 <vTaskSuspendAll>)
420012e9:	0008e0        	callx8	a8
#endif // #if ( ( CONFIG_FREERTOS_SMP ) && ( !CONFIG_FREERTOS_UNICORE ) )

    esp_restart_noos();
420012ec:	fb6d81        	l32r	a8, 420000a0 <_stext+0x80> (40375760 <esp_restart_noos>)
420012ef:	0008e0        	callx8	a8
	...

420012f4 <__esp_system_init_fn_init_show_cpu_freq>:
}

// [refactor-todo] Most of these init functions should be moved to the respective components.

ESP_SYSTEM_INIT_FN(init_show_cpu_freq, CORE, BIT(0), 10)
{
420012f4:	004136        	entry	a1, 32
420012f7:	fb4d81        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
420012fa:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "Pro cpu start user code");
420012fc:	1438b6        	bltui	a8, 3, 42001314 <__esp_system_init_fn_init_show_cpu_freq+0x20>
420012ff:	fb5881        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001302:	0008e0        	callx8	a8
42001305:	fb67c1        	l32r	a12, 420000a4 <_stext+0x84> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001308:	20baa0        	or	a11, a10, a10
4200130b:	fb67a1        	l32r	a10, 420000a8 <_stext+0x88> (3c0202f0 <_flash_rodata_start+0x1d0>)
4200130e:	fb5581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001311:	0008e0        	callx8	a8
    int cpu_freq = esp_clk_cpu_freq();
42001314:	fb6781        	l32r	a8, 420000b0 <_stext+0x90> (40376440 <esp_clk_cpu_freq>)
42001317:	0008e0        	callx8	a8
4200131a:	0a7d      	mov.n	a7, a10
4200131c:	fb4481        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
4200131f:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "cpu freq: %d Hz", cpu_freq);
42001321:	1538b6        	bltui	a8, 3, 4200133a <__esp_system_init_fn_init_show_cpu_freq+0x46>
42001324:	fb4f81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001327:	0008e0        	callx8	a8
4200132a:	07dd      	mov.n	a13, a7
4200132c:	fb5ec1        	l32r	a12, 420000a4 <_stext+0x84> (3c0202e4 <_flash_rodata_start+0x1c4>)
4200132f:	0abd      	mov.n	a11, a10
42001331:	fb5ea1        	l32r	a10, 420000ac <_stext+0x8c> (3c020318 <_flash_rodata_start+0x1f8>)
42001334:	fb4c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001337:	0008e0        	callx8	a8

    return ESP_OK;
}
4200133a:	020c      	movi.n	a2, 0
4200133c:	f01d      	retw.n
	...

42001340 <__esp_system_init_fn_init_brownout>:
 * It is protected from all REE accesses through memory protection mechanisms,
 * as it is a critical module for device functioning.
 */
#if !CONFIG_SECURE_ENABLE_TEE
ESP_SYSTEM_INIT_FN(init_brownout, CORE, BIT(0), 104)
{
42001340:	004136        	entry	a1, 32
    // [refactor-todo] leads to call chain rtc_is_register (driver) -> esp_intr_alloc (esp32/esp32s2) ->
    // malloc (newlib) -> heap_caps_malloc (heap), so heap must be at least initialized
#if CONFIG_ESP_BROWNOUT_DET
    esp_brownout_init();
42001343:	001865        	call8	420014c8 <esp_brownout_init>
#if SOC_CAPS_NO_RESET_BY_ANA_BOD
    brownout_ll_ana_reset_enable(false);
#endif // SOC_CAPS_NO_RESET_BY_ANA_BOD
#endif // CONFIG_ESP_BROWNOUT_DET
    return ESP_OK;
}
42001346:	020c      	movi.n	a2, 0
42001348:	f01d      	retw.n
	...

4200134c <__esp_system_init_fn_init_newlib_time>:
#endif

ESP_SYSTEM_INIT_FN(init_newlib_time, CORE, BIT(0), 105)
{
4200134c:	004136        	entry	a1, 32
    esp_libc_time_init();
4200134f:	048ee5        	call8	42005c3c <esp_libc_time_init>
    return ESP_OK;
}
42001352:	020c      	movi.n	a2, 0
42001354:	f01d      	retw.n
	...

42001358 <__esp_system_init_fn_init_flash>:

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
ESP_SYSTEM_INIT_FN(init_flash, CORE, BIT(0), 130)
{
42001358:	004136        	entry	a1, 32
#if CONFIG_SPI_FLASH_ROM_IMPL
    spi_flash_rom_impl_init();
#endif

    esp_flash_app_init();
4200135b:	08a225        	call8	42009d7c <esp_flash_app_init>
    esp_err_t flash_ret = esp_flash_init_default_chip();
4200135e:	201110        	or	a1, a1, a1
42001361:	088f25        	call8	42009c54 <esp_flash_init_default_chip>
    assert(flash_ret == ESP_OK);
42001364:	011a16        	beqz	a10, 42001379 <__esp_system_init_fn_init_flash+0x21>
42001367:	fb53d1        	l32r	a13, 420000b4 <_stext+0x94> (3c020338 <_flash_rodata_start+0x218>)
4200136a:	fb53c1        	l32r	a12, 420000b8 <_stext+0x98> (3c026e34 <__func__$0>)
4200136d:	69a0b2        	movi	a11, 105
42001370:	fb53a1        	l32r	a10, 420000bc <_stext+0x9c> (3c020368 <_flash_rodata_start+0x248>)
42001373:	fb5381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42001376:	0008e0        	callx8	a8
    (void)flash_ret;
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    spi_flash_needs_reset_check();
42001379:	fb5281        	l32r	a8, 420000c4 <_stext+0xa4> (4037ff20 <spi_flash_needs_reset_check>)
4200137c:	0008e0        	callx8	a8
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET
    return ESP_OK;
}
4200137f:	020c      	movi.n	a2, 0
42001381:	f01d      	retw.n
	...

42001384 <__esp_system_init_fn_init_apb_dma>:
}
#endif // CONFIG_PM_ENABLE

#if SOC_APB_BACKUP_DMA
ESP_SYSTEM_INIT_FN(init_apb_dma, SECONDARY, BIT(0), 203)
{
42001384:	004136        	entry	a1, 32
    extern void esp_apb_backup_dma_lock_init(void);
    esp_apb_backup_dma_lock_init();
42001387:	0073a5        	call8	42001ac0 <esp_apb_backup_dma_lock_init>
    return ESP_OK;
}
4200138a:	020c      	movi.n	a2, 0
4200138c:	f01d      	retw.n
	...

42001390 <__esp_system_init_fn_init_disable_rtc_wdt>:
}
#endif // CONFIG_SW_COEXIST_ENABLE || CONFIG_EXTERNAL_COEX_ENABLE

#ifndef CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE
ESP_SYSTEM_INIT_FN(init_disable_rtc_wdt, SECONDARY, BIT(0), 999)
{
42001390:	006136        	entry	a1, 48
    wdt_hal_context_t rtc_wdt_ctx = RWDT_HAL_CONTEXT_DEFAULT();
42001393:	020c      	movi.n	a2, 0
42001395:	0129      	s32i.n	a2, a1, 0
42001397:	fb4c81        	l32r	a8, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
4200139a:	1189      	s32i.n	a8, a1, 4
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
4200139c:	01ad      	mov.n	a10, a1
4200139e:	fb4b81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
420013a1:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
420013a4:	01ad      	mov.n	a10, a1
420013a6:	fb4a81        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
420013a9:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
420013ac:	01ad      	mov.n	a10, a1
420013ae:	fb4981        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
420013b1:	0008e0        	callx8	a8
    return ESP_OK;
}
420013b4:	f01d      	retw.n
	...

420013b8 <core_intr_matrix_clear>:
{
420013b8:	004136        	entry	a1, 32
420013bb:	03eb60        	rsr.prid	a6
420013be:	046d60        	extui	a6, a6, 13, 1
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
420013c1:	070c      	movi.n	a7, 0
420013c3:	000346        	j	420013d4 <core_intr_matrix_clear+0x1c>
        esp_rom_route_intr_matrix(core_id, i, ETS_INVALID_INUM);
420013c6:	6c0c      	movi.n	a12, 6
420013c8:	07bd      	mov.n	a11, a7
420013ca:	06ad      	mov.n	a10, a6
420013cc:	fb4381        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420013cf:	0008e0        	callx8	a8
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
420013d2:	771b      	addi.n	a7, a7, 1
420013d4:	62a082        	movi	a8, 98
420013d7:	eba877        	bge	a8, a7, 420013c6 <core_intr_matrix_clear+0xe>
}
420013da:	f01d      	retw.n

420013dc <start_other_core>:
{
420013dc:	006136        	entry	a1, 48
    esp_chip_info(&chip_info);
420013df:	01ad      	mov.n	a10, a1
420013e1:	027a25        	call8	42003b84 <esp_chip_info>
    if (!(chip_info.cores > 1)) {
420013e4:	0a0182        	l8ui	a8, a1, 10
420013e7:	3f28f6        	bgeui	a8, 2, 4200142a <start_other_core+0x4e>
420013ea:	fb1081        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
420013ed:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Running on single core variant of a chip, but app is built with multi-core support.");
420013f0:	014816        	beqz	a8, 42001408 <start_other_core+0x2c>
420013f3:	fb1b81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420013f6:	0008e0        	callx8	a8
420013f9:	fb38c1        	l32r	a12, 420000dc <_stext+0xbc> (3c0202e4 <_flash_rodata_start+0x1c4>)
420013fc:	20baa0        	or	a11, a10, a10
420013ff:	fb38a1        	l32r	a10, 420000e0 <_stext+0xc0> (3c020378 <_flash_rodata_start+0x258>)
42001402:	fb1881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001405:	0008e0        	callx8	a8
42001408:	fb0981        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
4200140b:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Check that CONFIG_FREERTOS_UNICORE is enabled in menuconfig");
4200140d:	389c      	beqz.n	a8, 42001424 <start_other_core+0x48>
4200140f:	fb1481        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001412:	0008e0        	callx8	a8
42001415:	fb31c1        	l32r	a12, 420000dc <_stext+0xbc> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001418:	20baa0        	or	a11, a10, a10
4200141b:	fb32a1        	l32r	a10, 420000e4 <_stext+0xc4> (3c0203dc <_flash_rodata_start+0x2bc>)
4200141e:	fb1181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001421:	0008e0        	callx8	a8
        abort();
42001424:	fb3481        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42001427:	0008e0        	callx8	a8
    esp_cpu_unstall(1);
4200142a:	1a0c      	movi.n	a10, 1
4200142c:	fb3381        	l32r	a8, 420000f8 <_stext+0xd8> (40378240 <esp_cpu_unstall>)
4200142f:	0008e0        	callx8	a8
    if (!REG_GET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN)) {
42001432:	fb2d81        	l32r	a8, 420000e8 <_stext+0xc8> (600c0000 <SYSTEM>)
42001435:	0020c0        	memw
42001438:	0888      	l32i.n	a8, a8, 0
4200143a:	3ee817        	bbsi	a8, 1, 4200147c <start_other_core+0xa0>
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN);
4200143d:	fb2a81        	l32r	a8, 420000e8 <_stext+0xc8> (600c0000 <SYSTEM>)
42001440:	0020c0        	memw
42001443:	0898      	l32i.n	a9, a8, 0
42001445:	2a0c      	movi.n	a10, 2
42001447:	2099a0        	or	a9, a9, a10
4200144a:	0020c0        	memw
4200144d:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RUNSTALL);
4200144f:	0020c0        	memw
42001452:	0898      	l32i.n	a9, a8, 0
42001454:	ea7c      	movi.n	a10, -2
42001456:	1099a0        	and	a9, a9, a10
42001459:	0020c0        	memw
4200145c:	0899      	s32i.n	a9, a8, 0
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
4200145e:	0020c0        	memw
42001461:	0898      	l32i.n	a9, a8, 0
42001463:	4a0c      	movi.n	a10, 4
42001465:	2099a0        	or	a9, a9, a10
42001468:	0020c0        	memw
4200146b:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
4200146d:	0020c0        	memw
42001470:	0898      	l32i.n	a9, a8, 0
42001472:	ba7c      	movi.n	a10, -5
42001474:	1099a0        	and	a9, a9, a10
42001477:	0020c0        	memw
4200147a:	0899      	s32i.n	a9, a8, 0
    ets_set_appcpu_boot_addr((uint32_t)call_start_cpu1);
4200147c:	fb1ca1        	l32r	a10, 420000ec <_stext+0xcc> (4037519c <call_start_cpu1>)
4200147f:	fb1f81        	l32r	a8, 420000fc <_stext+0xdc> (40000720 <ets_set_appcpu_boot_addr>)
42001482:	0008e0        	callx8	a8
    bool cpus_up = false;
42001485:	070c      	movi.n	a7, 0
    while (!cpus_up) {
42001487:	000946        	j	420014b0 <start_other_core+0xd4>
4200148a:	910000        	srl	a0, a0
            cpus_up &= s_cpu_up[i];
4200148d:	fb19      	s32i.n	a1, a11, 60
4200148f:	998a      	add.n	a9, a9, a8
42001491:	0020c0        	memw
42001494:	000992        	l8ui	a9, a9, 0
42001497:	107790        	and	a7, a7, a9
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
4200149a:	881b      	addi.n	a8, a8, 1
4200149c:	000106        	j	420014a4 <start_other_core+0xc8>
4200149f:	080c00        	lsx	f0, a12, a0
        cpus_up = true;
420014a2:	170c      	movi.n	a7, 1
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420014a4:	e428a6        	blti	a8, 2, 4200148c <start_other_core+0xb0>
        esp_rom_delay_us(100);
420014a7:	64a0a2        	movi	a10, 100
420014aa:	fb1581        	l32r	a8, 42000100 <_stext+0xe0> (40000600 <esp_rom_delay_us>)
420014ad:	0008e0        	callx8	a8
    while (!cpus_up) {
420014b0:	fec716        	beqz	a7, 420014a0 <start_other_core+0xc4>
}
420014b3:	f01d      	retw.n
420014b5:	000000        	ill

420014b8 <startup_resume_other_cores>:
{
420014b8:	004136        	entry	a1, 32
    s_resume_cores = true;
420014bb:	fb1281        	l32r	a8, 42000104 <_stext+0xe4> (3fc94880 <s_resume_cores>)
420014be:	190c      	movi.n	a9, 1
420014c0:	0020c0        	memw
420014c3:	004892        	s8i	a9, a8, 0
}
420014c6:	f01d      	retw.n

420014c8 <esp_brownout_init>:
}
#endif // CONFIG_ESP_SYSTEM_BROWNOUT_INTR

void esp_brownout_init(void)
{
420014c8:	006136        	entry	a1, 48
#if CONFIG_ESP_SYSTEM_BROWNOUT_INTR
    brownout_hal_config_t cfg = {
420014cb:	fb0f81        	l32r	a8, 42000108 <_stext+0xe8> (3c026e6c <__func__$0+0x38>)
420014ce:	002892        	l32i	a9, a8, 0
420014d1:	040882        	l8ui	a8, a8, 4
420014d4:	006192        	s32i	a9, a1, 0
420014d7:	044182        	s8i	a8, a1, 4
        .reset_enabled = false,
        .flash_power_down = true,
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
420014da:	01ad      	mov.n	a10, a1
420014dc:	013225        	call8	42002800 <brownout_hal_config>
420014df:	fafa61        	l32r	a6, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
420014e2:	0020c0        	memw
420014e5:	132692        	l32i	a9, a6, 76
420014e8:	00a272        	movi	a7, 0x200
420014eb:	208970        	or	a8, a9, a7
420014ee:	0020c0        	memw
420014f1:	136682        	s32i	a8, a6, 76
    // is not used now. An interrupt allocator is needed when lp_timer intr gets supported.
    esp_intr_alloc_intrstatus(ETS_LP_RTC_TIMER_INTR_SOURCE, ESP_INTR_FLAG_IRAM | ESP_INTR_FLAG_SHARED, (uint32_t)brownout_ll_intr_get_status_reg(), BROWNOUT_DETECTOR_LL_INTERRUPT_MASK, &rtc_brownout_isr_handler, NULL, NULL);
#elif CONFIG_IDF_TARGET_ESP32P4
    esp_intr_alloc(ETS_LP_ANAPERI_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_brownout_isr_handler, NULL, NULL);
#else
    rtc_isr_register(rtc_brownout_isr_handler, NULL, RTC_CNTL_BROWN_OUT_INT_ENA_M, RTC_INTR_FLAG_IRAM);
420014f4:	1d0c      	movi.n	a13, 1
420014f6:	07cd      	mov.n	a12, a7
420014f8:	0b0c      	movi.n	a11, 0
420014fa:	fb04a1        	l32r	a10, 4200010c <_stext+0xec> (4037550c <rtc_brownout_isr_handler>)
420014fd:	023e65        	call8	420038e4 <rtc_isr_register>
    RTCCNTL.int_ena.rtc_brown_out = enable;
42001500:	0020c0        	memw
42001503:	102682        	l32i	a8, a6, 64
42001506:	207870        	or	a7, a8, a7
42001509:	0020c0        	memw
4200150c:	106672        	s32i	a7, a6, 64
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
#endif
}
4200150f:	f01d      	retw.n
42001511:	000000        	ill

42001514 <select_rtc_slow_clk>:
{
42001514:	004136        	entry	a1, 32
    soc_rtc_slow_clk_src_t rtc_slow_clk_src = slow_clk & RTC_CNTL_ANA_CLK_RTC_SEL_V;
42001517:	146020        	extui	a6, a2, 0, 2
    int retry_32k_xtal = RTC_XTAL_CAL_RETRY;
4200151a:	150c      	movi.n	a5, 1
        if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
4200151c:	511666        	bnei	a6, 1, 42001571 <select_rtc_slow_clk+0x5d>
            if (slow_clk == SLOW_CLK_32K_XTAL) {
4200151f:	0b1266        	bnei	a2, 1, 4200152e <select_rtc_slow_clk+0x1a>
                rtc_clk_32k_enable(true);
42001522:	1a0c      	movi.n	a10, 1
42001524:	fafd81        	l32r	a8, 42000118 <_stext+0xf8> (4037870c <rtc_clk_32k_enable>)
42001527:	0008e0        	callx8	a8
4200152a:	0002c6        	j	42001539 <select_rtc_slow_clk+0x25>
4200152d:	980c00        	lsi	f0, a12, 0x260
            } else if (slow_clk == SLOW_CLK_32K_EXT_OSC) {
42001530:	059287        	bne	a2, a8, 42001539 <select_rtc_slow_clk+0x25>
                rtc_clk_32k_enable_external();
42001533:	fafa81        	l32r	a8, 4200011c <_stext+0xfc> (403787fc <rtc_clk_32k_enable_external>)
42001536:	0008e0        	callx8	a8
                cal_val = rtc_clk_cal(RTC_CAL_32K_XTAL, SLOW_CLK_CAL_CYCLES);
42001539:	00a4b2        	movi	a11, 0x400
4200153c:	02a0a2        	movi	a10, 2
4200153f:	faf881        	l32r	a8, 42000120 <_stext+0x100> (403792f4 <rtc_clk_cal>)
42001542:	0008e0        	callx8	a8
42001545:	0a7d      	mov.n	a7, a10
                if (cal_val == 0) {
42001547:	eafc      	bnez.n	a10, 42001589 <select_rtc_slow_clk+0x75>
                    if (retry_32k_xtal-- > 0) {
42001549:	450b      	addi.n	a4, a5, -1
4200154b:	5215e6        	bgei	a5, 1, 420015a1 <select_rtc_slow_clk+0x8d>
4200154e:	fab781        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42001551:	0888      	l32i.n	a8, a8, 0
                    ESP_EARLY_LOGW(TAG, "32 kHz XTAL not found, switching to internal 150 kHz oscillator");
42001553:	2e28b6        	bltui	a8, 2, 42001585 <select_rtc_slow_clk+0x71>
42001556:	fac281        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001559:	0008e0        	callx8	a8
4200155c:	faedc1        	l32r	a12, 42000110 <_stext+0xf0> (3c0205a0 <_flash_rodata_start+0x480>)
4200155f:	0abd      	mov.n	a11, a10
42001561:	faeca1        	l32r	a10, 42000114 <_stext+0xf4> (3c0205a4 <_flash_rodata_start+0x484>)
42001564:	fac081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001567:	0008e0        	callx8	a8
                    if (retry_32k_xtal-- > 0) {
4200156a:	045d      	mov.n	a5, a4
                    rtc_slow_clk_src = SOC_RTC_SLOW_CLK_SRC_RC_SLOW;
4200156c:	076d      	mov.n	a6, a7
4200156e:	0005c6        	j	42001589 <select_rtc_slow_clk+0x75>
        } else if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
42001571:	142666        	bnei	a6, 2, 42001589 <select_rtc_slow_clk+0x75>
            rtc_clk_8m_enable(true, true);
42001574:	01a0b2        	movi	a11, 1
42001577:	20abb0        	or	a10, a11, a11
4200157a:	faea81        	l32r	a8, 42000124 <_stext+0x104> (40378850 <rtc_clk_8m_enable>)
4200157d:	0008e0        	callx8	a8
42001580:	000146        	j	42001589 <select_rtc_slow_clk+0x75>
42001583:	5d0000        	lsi	f0, a0, 0x174
                    if (retry_32k_xtal-- > 0) {
42001586:	0a6d04        	mula.dd.lh.ldinc	m2, a13, m1, m2
        rtc_clk_slow_src_set(rtc_slow_clk_src);
42001589:	06ad      	mov.n	a10, a6
4200158b:	fae781        	l32r	a8, 42000128 <_stext+0x108> (4037890c <rtc_clk_slow_src_set>)
4200158e:	0008e0        	callx8	a8
            cal_val = rtc_clk_cal(RTC_CAL_RTC_MUX, SLOW_CLK_CAL_CYCLES);
42001591:	00a4b2        	movi	a11, 0x400
42001594:	0a0c      	movi.n	a10, 0
42001596:	fae281        	l32r	a8, 42000120 <_stext+0x100> (403792f4 <rtc_clk_cal>)
42001599:	0008e0        	callx8	a8
4200159c:	0a7d      	mov.n	a7, a10
4200159e:	000086        	j	420015a4 <select_rtc_slow_clk+0x90>
                    if (retry_32k_xtal-- > 0) {
420015a1:	205440        	or	a5, a4, a4
    } while (cal_val == 0);
420015a4:	f74716        	beqz	a7, 4200151c <select_rtc_slow_clk+0x8>
    esp_clk_slowclk_cal_set(cal_val);
420015a7:	20a770        	or	a10, a7, a7
420015aa:	01c1e5        	call8	420031c8 <esp_clk_slowclk_cal_set>
}
420015ad:	000090        	retw

420015b0 <esp_rtc_init>:
{
420015b0:	004136        	entry	a1, 32
    recalib_bbpll();
420015b3:	fae081        	l32r	a8, 42000134 <_stext+0x114> (4037564c <recalib_bbpll>)
420015b6:	0008e0        	callx8	a8
    rtc_config_t cfg = RTC_CONFIG_DEFAULT();
420015b9:	fadc81        	l32r	a8, 4200012c <_stext+0x10c> (3c026e74 <__func__$0+0x40>)
420015bc:	002872        	l32i	a7, a8, 0
    rst_reas = esp_rom_get_reset_reason(0);
420015bf:	00a0a2        	movi	a10, 0
420015c2:	fadd81        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
420015c5:	0008e0        	callx8	a8
    if (rst_reas == RESET_REASON_CHIP_POWER_ON) {
420015c8:	051a66        	bnei	a10, 1, 420015d1 <esp_rtc_init+0x21>
        cfg.cali_ocode = 1;
420015cb:	fad981        	l32r	a8, 42000130 <_stext+0x110> (40000000 <_heap_end>)
420015ce:	207780        	or	a7, a7, a8
    rtc_init(cfg);
420015d1:	07ad      	mov.n	a10, a7
420015d3:	13f925        	call8	42015564 <rtc_init>
}
420015d6:	f01d      	retw.n

420015d8 <esp_clk_init>:
{
420015d8:	00a136        	entry	a1, 80
    assert(rtc_clk_xtal_freq_get() == SOC_XTAL_FREQ_40M);
420015db:	fadd81        	l32r	a8, 42000150 <_stext+0x130> (40378a9c <rtc_clk_xtal_freq_get>)
420015de:	0008e0        	callx8	a8
420015e1:	d8caa2        	addi	a10, a10, -40
420015e4:	010a16        	beqz	a10, 420015f8 <esp_clk_init+0x20>
420015e7:	fad5d1        	l32r	a13, 4200013c <_stext+0x11c> (3c0205f4 <_flash_rodata_start+0x4d4>)
420015ea:	fad5c1        	l32r	a12, 42000140 <_stext+0x120> (3c026e78 <__func__$0>)
420015ed:	fb4c      	movi.n	a11, 79
420015ef:	fad5a1        	l32r	a10, 42000144 <_stext+0x124> (3c020651 <_flash_rodata_start+0x531>)
420015f2:	fab381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420015f5:	0008e0        	callx8	a8
    bool rc_fast_d256_is_enabled = rtc_clk_8md256_enabled();
420015f8:	fad781        	l32r	a8, 42000154 <_stext+0x134> (403788f0 <rtc_clk_8md256_enabled>)
420015fb:	0008e0        	callx8	a8
    rtc_clk_8m_enable(true, rc_fast_d256_is_enabled);
420015fe:	0abd      	mov.n	a11, a10
42001600:	1a0c      	movi.n	a10, 1
42001602:	fac881        	l32r	a8, 42000124 <_stext+0x104> (40378850 <rtc_clk_8m_enable>)
42001605:	0008e0        	callx8	a8
    rtc_clk_fast_src_set(SOC_RTC_FAST_CLK_SRC_RC_FAST);
42001608:	1a0c      	movi.n	a10, 1
4200160a:	fad381        	l32r	a8, 42000158 <_stext+0x138> (40378a58 <rtc_clk_fast_src_set>)
4200160d:	0008e0        	callx8	a8
    wdt_hal_context_t rtc_wdt_ctx = {.inst = WDT_RWDT, .rwdt_dev = &RTCCNTL};
42001610:	070c      	movi.n	a7, 0
42001612:	0179      	s32i.n	a7, a1, 0
42001614:	faad81        	l32r	a8, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
42001617:	1189      	s32i.n	a8, a1, 4
    uint32_t stage_timeout_ticks = (uint32_t)(1600ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001619:	fad081        	l32r	a8, 4200015c <_stext+0x13c> (40378a30 <rtc_clk_slow_freq_get_hz>)
4200161c:	0008e0        	callx8	a8
4200161f:	40a682        	movi	a8, 0x640
42001622:	a2b8a0        	muluh	a11, a8, a10
42001625:	e8a3c2        	movi	a12, 0x3e8
42001628:	07dd      	mov.n	a13, a7
4200162a:	82a8a0        	mull	a10, a8, a10
4200162d:	facc81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
42001630:	0008e0        	callx8	a8
42001633:	0a6d      	mov.n	a6, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001635:	01ad      	mov.n	a10, a1
42001637:	faa581        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
4200163a:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
4200163d:	01ad      	mov.n	a10, a1
4200163f:	fac981        	l32r	a8, 42000164 <_stext+0x144> (40000e1c <wdt_hal_feed>)
42001642:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
42001645:	4d0c      	movi.n	a13, 4
42001647:	06cd      	mov.n	a12, a6
42001649:	07bd      	mov.n	a11, a7
4200164b:	01ad      	mov.n	a10, a1
4200164d:	fac681        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001650:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001653:	01ad      	mov.n	a10, a1
42001655:	fa9f81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001658:	0008e0        	callx8	a8
    select_rtc_slow_clk(SLOW_CLK_RTC);
4200165b:	07ad      	mov.n	a10, a7
4200165d:	ffeb65        	call8	42001514 <select_rtc_slow_clk>
    stage_timeout_ticks = (uint32_t)((uint64_t)CONFIG_BOOTLOADER_WDT_TIME_MS * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001660:	fabf81        	l32r	a8, 4200015c <_stext+0x13c> (40378a30 <rtc_clk_slow_freq_get_hz>)
42001663:	0008e0        	callx8	a8
42001666:	fab881        	l32r	a8, 42000148 <_stext+0x128> (2328 <UserFrameTotalSize+0x2228>)
42001669:	a2ba80        	muluh	a11, a10, a8
4200166c:	e8a3c2        	movi	a12, 0x3e8
4200166f:	07dd      	mov.n	a13, a7
42001671:	82aa80        	mull	a10, a10, a8
42001674:	fabb81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
42001677:	0008e0        	callx8	a8
4200167a:	0a6d      	mov.n	a6, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
4200167c:	01ad      	mov.n	a10, a1
4200167e:	fa9381        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001681:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
42001684:	01ad      	mov.n	a10, a1
42001686:	fab781        	l32r	a8, 42000164 <_stext+0x144> (40000e1c <wdt_hal_feed>)
42001689:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
4200168c:	4d0c      	movi.n	a13, 4
4200168e:	06cd      	mov.n	a12, a6
42001690:	07bd      	mov.n	a11, a7
42001692:	01ad      	mov.n	a10, a1
42001694:	fab581        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001697:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
4200169a:	01ad      	mov.n	a10, a1
4200169c:	fa8e81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
4200169f:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_get_config(&old_config);
420016a2:	a18b      	addi.n	a10, a1, 8
420016a4:	fab281        	l32r	a8, 4200016c <_stext+0x14c> (40378b44 <rtc_clk_cpu_freq_get_config>)
420016a7:	0008e0        	callx8	a8
    const uint32_t old_freq_mhz = old_config.freq_mhz;
420016aa:	5168      	l32i.n	a6, a1, 20
    bool res = rtc_clk_cpu_freq_mhz_to_config(new_freq_mhz, &new_config);
420016ac:	18c1b2        	addi	a11, a1, 24
420016af:	a0a0a2        	movi	a10, 160
420016b2:	faaf81        	l32r	a8, 42000170 <_stext+0x150> (40378adc <rtc_clk_cpu_freq_mhz_to_config>)
420016b5:	0008e0        	callx8	a8
420016b8:	0a7d      	mov.n	a7, a10
    assert(res);
420016ba:	0adc      	bnez.n	a10, 420016ce <esp_clk_init+0xf6>
420016bc:	faa4d1        	l32r	a13, 4200014c <_stext+0x12c> (3c020658 <_flash_rodata_start+0x538>)
420016bf:	faa0c1        	l32r	a12, 42000140 <_stext+0x120> (3c026e78 <__func__$0>)
420016c2:	7da0b2        	movi	a11, 125
420016c5:	fa9fa1        	l32r	a10, 42000144 <_stext+0x124> (3c020651 <_flash_rodata_start+0x531>)
420016c8:	fa7e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420016cb:	0008e0        	callx8	a8
        esp_rom_output_tx_wait_idle(CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM);
420016ce:	4a0c      	movi.n	a10, 4
420016d0:	faa981        	l32r	a8, 42000174 <_stext+0x154> (4000069c <esp_rom_output_tx_wait_idle>)
420016d3:	0008e0        	callx8	a8
    if (res) {
420016d6:	778c      	beqz.n	a7, 420016e1 <esp_clk_init+0x109>
        rtc_clk_cpu_freq_set_config(&new_config);
420016d8:	18c1a2        	addi	a10, a1, 24
420016db:	faa781        	l32r	a8, 42000178 <_stext+0x158> (40378ea0 <rtc_clk_cpu_freq_set_config>)
420016de:	0008e0        	callx8	a8
    RSR(CCOUNT, ccount);
420016e1:	03ea80        	rsr.ccount	a8
    esp_cpu_set_cycle_count((uint64_t)esp_cpu_get_cycle_count() * new_freq_mhz / old_freq_mhz);
420016e4:	a0a0a2        	movi	a10, 160
420016e7:	a2ba80        	muluh	a11, a10, a8
420016ea:	06cd      	mov.n	a12, a6
420016ec:	00a0d2        	movi	a13, 0
420016ef:	82aa80        	mull	a10, a10, a8
420016f2:	fa9b81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
420016f5:	0008e0        	callx8	a8
    WSR(CCOUNT, ccount);
420016f8:	13eaa0        	wsr.ccount	a10
}
420016fb:	f01d      	retw.n
420016fd:	000000        	ill

42001700 <esp_perip_clk_init>:
{
42001700:	006136        	entry	a1, 48
    rst_reas[0] = esp_rom_get_reset_reason(0);
42001703:	00a0a2        	movi	a10, 0
42001706:	fa8c81        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
42001709:	0008e0        	callx8	a8
4200170c:	0a7d      	mov.n	a7, a10
4200170e:	0061a2        	s32i	a10, a1, 0
    rst_reas[1] = esp_rom_get_reset_reason(1);
42001711:	01a0a2        	movi	a10, 1
42001714:	fa8981        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
42001717:	0008e0        	callx8	a8
4200171a:	11a9      	s32i.n	a10, a1, 4
            rst_reas[0] == RESET_REASON_CPU0_RTC_WDT || rst_reas[0] == RESET_REASON_CPU0_MWDT1)
4200171c:	f5c792        	addi	a9, a7, -11
4200171f:	280c      	movi.n	a8, 2
42001721:	628890        	lsi	f9, a8, 0x188
42001724:	880b      	addi.n	a8, a8, -1
42001726:	608080        	neg	a8, a8
42001729:	efc772        	addi	a7, a7, -17
4200172c:	40f770        	nsau	a7, a7
4200172f:	417570        	srli	a7, a7, 5
42001732:	208870        	or	a8, a8, a7
42001735:	748080        	extui	a8, a8, 0, 8
    if ((rst_reas[0] == RESET_REASON_CPU0_MWDT0 || rst_reas[0] == RESET_REASON_CPU0_SW ||
42001738:	c8dc      	bnez.n	a8, 42001758 <esp_perip_clk_init+0x58>
                rst_reas[1] == RESET_REASON_CPU1_RTC_WDT || rst_reas[1] == RESET_REASON_CPU1_MWDT1)
4200173a:	f5ca92        	addi	a9, a10, -11
4200173d:	280c      	movi.n	a8, 2
4200173f:	628890        	lsi	f9, a8, 0x188
42001742:	880b      	addi.n	a8, a8, -1
42001744:	608080        	neg	a8, a8
42001747:	efcaa2        	addi	a10, a10, -17
4200174a:	40faa0        	nsau	a10, a10
4200174d:	41a5a0        	srli	a10, a10, 5
42001750:	2088a0        	or	a8, a8, a10
42001753:	748080        	extui	a8, a8, 0, 8
            || (rst_reas[1] == RESET_REASON_CPU1_MWDT0 || rst_reas[1] == RESET_REASON_CPU1_SW ||
42001756:	a8ac      	beqz.n	a8, 42001784 <esp_perip_clk_init+0x84>
        common_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN0_REG);
42001758:	fa8b81        	l32r	a8, 42000184 <_stext+0x164> (600c0018 <SYSTEM+0x18>)
4200175b:	0020c0        	memw
4200175e:	0888      	l32i.n	a8, a8, 0
42001760:	f97c      	movi.n	a9, -1
42001762:	308890        	xor	a8, a8, a9
        hwcrypto_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN1_REG);
42001765:	fa8891        	l32r	a9, 42000188 <_stext+0x168> (600c001c <SYSTEM+0x1c>)
42001768:	0020c0        	memw
4200176b:	09b8      	l32i.n	a11, a9, 0
4200176d:	f97c      	movi.n	a9, -1
4200176f:	30bb90        	xor	a11, a11, a9
        wifi_bt_sdio_clk = ~READ_PERI_REG(SYSTEM_WIFI_CLK_EN_REG);
42001772:	fa8691        	l32r	a9, 4200018c <_stext+0x16c> (60026014 <SYSCON+0x14>)
42001775:	0020c0        	memw
42001778:	0998      	l32i.n	a9, a9, 0
4200177a:	fa7c      	movi.n	a10, -1
4200177c:	3099a0        	xor	a9, a9, a10
4200177f:	000286        	j	4200178d <esp_perip_clk_init+0x8d>
42001782:	910000        	srl	a0, a0
        wifi_bt_sdio_clk = SYSTEM_WIFI_CLK_WIFI_EN |
42001785:	7e          	.byte	0x7e
42001786:	b2fa      	add.n	a11, a2, a15
        hwcrypto_perip_clk = SYSTEM_CRYPTO_AES_CLK_EN |
42001788:	810ea0        	src	a0, a14, a10
        common_perip_clk = SYSTEM_WDG_CLK_EN |
4200178b:	fa7d      	lsi	f7, a10, 40
    common_perip_clk |= SYSTEM_I2S0_CLK_EN |
4200178d:	fa80a1        	l32r	a10, 42000190 <_stext+0x170> (88e513f4 <_rtc_reserved_end+0x28d513f4>)
42001790:	2088a0        	or	a8, a8, a10
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN0_REG, common_perip_clk);
42001793:	fa7cc1        	l32r	a12, 42000184 <_stext+0x164> (600c0018 <SYSTEM+0x18>)
42001796:	0020c0        	memw
42001799:	002cd2        	l32i	a13, a12, 0
4200179c:	10a8d0        	and	a10, a8, a13
4200179f:	30aad0        	xor	a10, a10, a13
420017a2:	0020c0        	memw
420017a5:	006ca2        	s32i	a10, a12, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG, common_perip_clk);
420017a8:	fa7bc1        	l32r	a12, 42000194 <_stext+0x174> (600c0020 <SYSTEM+0x20>)
420017ab:	0020c0        	memw
420017ae:	0ca8      	l32i.n	a10, a12, 0
420017b0:	208a80        	or	a8, a10, a8
420017b3:	0020c0        	memw
420017b6:	0c89      	s32i.n	a8, a12, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, common_perip_clk1);
420017b8:	fa74a1        	l32r	a10, 42000188 <_stext+0x168> (600c001c <SYSTEM+0x1c>)
420017bb:	0020c0        	memw
420017be:	0a88      	l32i.n	a8, a10, 0
420017c0:	0020c0        	memw
420017c3:	0a89      	s32i.n	a8, a10, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, common_perip_clk1);
420017c5:	fa7481        	l32r	a8, 42000198 <_stext+0x178> (600c0024 <SYSTEM+0x24>)
420017c8:	0020c0        	memw
420017cb:	08c8      	l32i.n	a12, a8, 0
420017cd:	0020c0        	memw
420017d0:	08c9      	s32i.n	a12, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, hwcrypto_perip_clk);
420017d2:	0020c0        	memw
420017d5:	0ad8      	l32i.n	a13, a10, 0
420017d7:	10cbd0        	and	a12, a11, a13
420017da:	30ccd0        	xor	a12, a12, a13
420017dd:	0020c0        	memw
420017e0:	0ac9      	s32i.n	a12, a10, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, hwcrypto_perip_clk);
420017e2:	0020c0        	memw
420017e5:	08a8      	l32i.n	a10, a8, 0
420017e7:	20aab0        	or	a10, a10, a11
420017ea:	0020c0        	memw
420017ed:	08a9      	s32i.n	a10, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_PERI_BACKUP_RST);
420017ef:	0020c0        	memw
420017f2:	08a8      	l32i.n	a10, a8, 0
420017f4:	eb7c      	movi.n	a11, -2
420017f6:	10aab0        	and	a10, a10, a11
420017f9:	0020c0        	memw
420017fc:	08a9      	s32i.n	a10, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, wifi_bt_sdio_clk);
420017fe:	fa63a1        	l32r	a10, 4200018c <_stext+0x16c> (60026014 <SYSCON+0x14>)
42001801:	0020c0        	memw
42001804:	0ab8      	l32i.n	a11, a10, 0
42001806:	1089b0        	and	a8, a9, a11
42001809:	3088b0        	xor	a8, a8, a11
4200180c:	0020c0        	memw
4200180f:	0a89      	s32i.n	a8, a10, 0
    SET_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, SYSTEM_WIFI_CLK_EN);
42001811:	0020c0        	memw
42001814:	0a88      	l32i.n	a8, a10, 0
42001816:	fa6191        	l32r	a9, 4200019c <_stext+0x17c> (fb9fcf <UserFrameTotalSize+0xfb9ecf>)
42001819:	208890        	or	a8, a8, a9
4200181c:	0020c0        	memw
4200181f:	0a89      	s32i.n	a8, a10, 0
    REG_SET_FIELD(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 0);
42001821:	fa5f91        	l32r	a9, 420001a0 <_stext+0x180> (600c0028 <SYSTEM+0x28>)
42001824:	0020c0        	memw
42001827:	0988      	l32i.n	a8, a9, 0
42001829:	418c80        	srli	a8, a8, 12
4200182c:	118840        	slli	a8, a8, 12
4200182f:	0020c0        	memw
42001832:	0989      	s32i.n	a8, a9, 0
    CLEAR_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_XTAL32K | SYSTEM_LPCLK_SEL_XTAL | SYSTEM_LPCLK_SEL_8M | SYSTEM_LPCLK_SEL_RTC_SLOW);
42001834:	fa5c81        	l32r	a8, 420001a4 <_stext+0x184> (600c002c <SYSTEM+0x2c>)
42001837:	0020c0        	memw
4200183a:	0898      	l32i.n	a9, a8, 0
4200183c:	fa5ba1        	l32r	a10, 420001a8 <_stext+0x188> (f0ffffff <_rtc_reserved_end+0x90efffff>)
4200183f:	1099a0        	and	a9, a9, a10
42001842:	0020c0        	memw
42001845:	0899      	s32i.n	a9, a8, 0
    SET_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_RTC_SLOW);
42001847:	0020c0        	memw
4200184a:	0898      	l32i.n	a9, a8, 0
4200184c:	fa58a1        	l32r	a10, 420001ac <_stext+0x18c> (1000000 <UserFrameTotalSize+0xffff00>)
4200184f:	2099a0        	or	a9, a9, a10
42001852:	0020c0        	memw
42001855:	0899      	s32i.n	a9, a8, 0
    periph_module_enable(PERIPH_RNG_MODULE);
42001857:	9a1c      	movi.n	a10, 25
42001859:	1397a5        	call8	420151d4 <periph_module_enable>
}
4200185c:	f01d      	retw.n
	...

42001860 <esp_reset_reason_clear_hint>:
        return ESP_RST_UNKNOWN;
    }
    return (esp_reset_reason_t) low;
}
static void esp_reset_reason_clear_hint(void)
{
42001860:	004136        	entry	a1, 32
    REG_WRITE(RTC_RESET_CAUSE_REG, 0);
42001863:	fa5381        	l32r	a8, 420001b0 <_stext+0x190> (600080c8 <RTCCNTL+0xc8>)
42001866:	090c      	movi.n	a9, 0
42001868:	0020c0        	memw
4200186b:	0899      	s32i.n	a9, a8, 0
}
4200186d:	f01d      	retw.n
	...

42001870 <esp_reset_reason_get_hint>:
{
42001870:	004136        	entry	a1, 32
    uint32_t reset_reason_hint = REG_READ(RTC_RESET_CAUSE_REG);
42001873:	fa4f81        	l32r	a8, 420001b0 <_stext+0x190> (600080c8 <RTCCNTL+0xc8>)
42001876:	0020c0        	memw
42001879:	0888      	l32i.n	a8, a8, 0
    uint32_t high = (reset_reason_hint >> RST_REASON_SHIFT) & RST_REASON_MASK;
4200187b:	e59080        	extui	a9, a8, 16, 15
    uint32_t low = reset_reason_hint & RST_REASON_MASK;
4200187e:	e42080        	extui	a2, a8, 0, 15
    if ((reset_reason_hint & RST_REASON_BIT) == 0 || high != low) {
42001881:	318f80        	srai	a8, a8, 31
42001884:	881b      	addi.n	a8, a8, 1
42001886:	c09920        	sub	a9, a9, a2
42001889:	1a0c      	movi.n	a10, 1
4200188b:	83a990        	moveqz	a10, a9, a9
4200188e:	2088a0        	or	a8, a8, a10
42001891:	088c      	beqz.n	a8, 42001895 <esp_reset_reason_get_hint+0x25>
        return ESP_RST_UNKNOWN;
42001893:	020c      	movi.n	a2, 0
}
42001895:	f01d      	retw.n
	...

42001898 <esp_reset_reason_init>:
{
42001898:	004136        	entry	a1, 32
    esp_reset_reason_t hint = esp_reset_reason_get_hint();
4200189b:	fffd65        	call8	42001870 <esp_reset_reason_get_hint>
4200189e:	207aa0        	or	a7, a10, a10
    s_reset_reason = get_reset_reason(esp_rom_get_reset_reason(PRO_CPU_NUM), hint);
420018a1:	00a0a2        	movi	a10, 0
420018a4:	fa2581        	l32r	a8, 42000138 <_stext+0x118> (4000057c <esp_rom_get_reset_reason>)
420018a7:	0008e0        	callx8	a8
420018aa:	07bd      	mov.n	a11, a7
420018ac:	12ef25        	call8	420147a0 <get_reset_reason>
420018af:	fa4181        	l32r	a8, 420001b4 <_stext+0x194> (3fc9488c <s_reset_reason>)
420018b2:	08a9      	s32i.n	a10, a8, 0
    if (hint != ESP_RST_UNKNOWN) {
420018b4:	178c      	beqz.n	a7, 420018b9 <esp_reset_reason_init+0x21>
        esp_reset_reason_clear_hint();
420018b6:	fffaa5        	call8	42001860 <esp_reset_reason_clear_hint>
}
420018b9:	f01d      	retw.n
	...

420018bc <esp_cache_err_get_panic_info>:
        }
    }
}

void esp_cache_err_get_panic_info(esp_cache_err_info_t *err_info)
{
420018bc:	004136        	entry	a1, 32
    if (err_info == NULL) {
420018bf:	029216        	beqz	a2, 420018ec <esp_cache_err_get_panic_info+0x30>
 *
 * @return            Status mask
 */
static inline uint32_t cache_ll_l1_get_illegal_error_intr_status(uint32_t cache_id, uint32_t mask)
{
    return GET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_ST_REG, mask);
420018c2:	fa3d81        	l32r	a8, 420001b8 <_stext+0x198> (600c40e4 <SYSTEM+0x40e4>)
420018c5:	0020c0        	memw
420018c8:	0028a2        	l32i	a10, a8, 0
    }
    /* Read the status register EXTMEM_CACHE_ILG_INT_ST_REG. This status
     * register is not equal to 0 when a cache access error occurred. */
    const uint32_t illegal_intr_status = cache_ll_l1_get_illegal_error_intr_status(0, CACHE_LL_L1_ILG_EVENT_MASK);

    get_cache_error(illegal_intr_status, ilg_int_st_bits, DIM(ilg_int_st_bits), err_info);
420018cb:	02dd      	mov.n	a13, a2
420018cd:	06a0c2        	movi	a12, 6
420018d0:	fa3bb1        	l32r	a11, 420001bc <_stext+0x19c> (3c026ec4 <ilg_int_st_bits>)
420018d3:	54a0a0        	extui	a10, a10, 0, 6
420018d6:	12f965        	call8	4201486c <get_cache_error>

    // If no error reported above we check if the error came from ACS
    if (err_info->err_str == NULL) {
420018d9:	0288      	l32i.n	a8, a2, 0
420018db:	d8cc      	bnez.n	a8, 420018ec <esp_cache_err_get_panic_info+0x30>
        uint32_t st = access_error_intr_status;
        get_cache_error(st, acs_int_st_bits, DIM(acs_int_st_bits), err_info);
420018dd:	02dd      	mov.n	a13, a2
420018df:	1c0c      	movi.n	a12, 1
420018e1:	fa38b1        	l32r	a11, 420001c4 <_stext+0x1a4> (3c026eb4 <acs_int_st_bits>)
420018e4:	fa3781        	l32r	a8, 420001c0 <_stext+0x1a0> (3fc94898 <access_error_intr_status>)
420018e7:	08a8      	l32i.n	a10, a8, 0
420018e9:	12f825        	call8	4201486c <get_cache_error>
    }
}
420018ec:	f01d      	retw.n
	...

420018f0 <esp_cache_err_acs_save_and_clr>:

void esp_cache_err_acs_save_and_clr(void)
{
420018f0:	004136        	entry	a1, 32
        return GET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ST_REG, mask);
420018f3:	fa3581        	l32r	a8, 420001c8 <_stext+0x1a8> (600c40f0 <SYSTEM+0x40f0>)
420018f6:	0020c0        	memw
420018f9:	0888      	l32i.n	a8, a8, 0
420018fb:	448080        	extui	a8, a8, 0, 5
    if (cache_ll_l1_get_access_error_intr_status(0, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
420018fe:	a88c      	beqz.n	a8, 4200190c <esp_cache_err_acs_save_and_clr+0x1c>
        cache_err_cpu_id = PRO_CPU_NUM;
42001900:	fa3381        	l32r	a8, 420001cc <_stext+0x1ac> (3fc94890 <cache_err_cpu_id>)
42001903:	090c      	movi.n	a9, 0
42001905:	0899      	s32i.n	a9, a8, 0
42001907:	000906        	j	4200192f <esp_cache_err_acs_save_and_clr+0x3f>
4200190a:	810000        	src	a0, a0, a0
        return GET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ST_REG, mask);
4200190d:	c0fa31        	l32r	a3, 41ff1cf8 <_coredump_iram_end+0x1c6fdf8>
42001910:	880020        	lsi	f2, a0, 0x220
42001913:	8008      	l32i.n	a0, a0, 32
42001915:	8c4480        	lsi	f8, a4, 0x230
    } else if (cache_ll_l1_get_access_error_intr_status(1, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
42001918:	8198      	l32i.n	a9, a1, 32
        cache_err_cpu_id = APP_CPU_NUM;
4200191a:	fa2c      	movi.n	a10, 47
4200191c:	190c      	movi.n	a9, 1
4200191e:	0899      	s32i.n	a9, a8, 0
42001920:	0002c6        	j	4200192f <esp_cache_err_acs_save_and_clr+0x3f>
42001923:	2a8100        	mul.s	f8, f1, f0
    } else {
        cache_err_cpu_id = -1;
42001926:	7cfa      	add.n	a7, a12, a15
42001928:	99f9      	s32i.n	a15, a9, 36
4200192a:	c608      	l32i.n	a0, a6, 48
        return;
4200192c:	001b      	addi.n	a0, a0, 1
4200192e:	278100        	lsi	f0, a1, 156

    // Certain errors needs to be cleared if the cache is to continue functioning properly.
    // E.g. for CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT errors the cache will sometimes end up in an invalid state
    // where the panic handler will then be unable to access rodata from flash
    // Store the error information before clearing, as it will be used later when reporting
    access_error_intr_status = cache_ll_l1_get_access_error_intr_status(cache_err_cpu_id, CACHE_LL_L1_ACCESS_EVENT_MASK);
42001931:	98fa      	add.n	a9, a8, a15
42001933:	cc08      	l32i.n	a0, a12, 48
    if (cache_id == 0) {
42001935:	81c9      	s32i.n	a12, a1, 32
        return GET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ST_REG, mask);
42001937:	c0fa24        	lsi	f2, a10, 0x300
4200193a:	880020        	lsi	f2, a0, 0x220
4200193d:	8008      	l32i.n	a0, a0, 32
4200193f:	864480        	lsi	f8, a4, 0x218
42001942:	810002        	l8ui	a0, a0, 129
        return GET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ST_REG, mask);
42001945:	c0fa23        	lsi	f2, a10, 0x300
42001948:	880020        	lsi	f2, a0, 0x220
4200194b:	8008      	l32i.n	a0, a0, 32
4200194d:	a14480        	lsi	f8, a4, 0x284
42001950:	fa1c      	movi.n	a10, 31
42001952:	0a89      	s32i.n	a8, a10, 0
    if (access_error_intr_status & CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT) {
42001954:	0a1c      	movi.n	a10, 16
42001956:	4408a7        	bnone	a8, a10, 4200199e <esp_cache_err_acs_save_and_clr+0xae>
 * @return vaddr that cause the acs dbus reject error
 */
__attribute__((always_inline))
static inline uint32_t cache_ll_get_acs_dbus_reject_vaddr(uint32_t cache_id)
{
    if (cache_id == 0) {
42001959:	b9cc      	bnez.n	a9, 42001968 <esp_cache_err_acs_save_and_clr+0x78>
        return REG_READ(EXTMEM_CORE0_DBUS_REJECT_VADDR_REG);
4200195b:	fa1e81        	l32r	a8, 420001d4 <_stext+0x1b4> (600c4104 <SYSTEM+0x4104>)
4200195e:	0020c0        	memw
42001961:	08a8      	l32i.n	a10, a8, 0
42001963:	000246        	j	42001970 <esp_cache_err_acs_save_and_clr+0x80>
42001966:	810000        	src	a0, a0, a0
    } else {
        return REG_READ(EXTMEM_CORE1_DBUS_REJECT_VADDR_REG);
42001969:	fa1c      	movi.n	a10, 31
4200196b:	0020c0        	memw
4200196e:	08a8      	l32i.n	a10, a8, 0
        acs_fault_addr = cache_ll_get_acs_dbus_reject_vaddr(cache_err_cpu_id);
42001970:	fa1b81        	l32r	a8, 420001dc <_stext+0x1bc> (3fc94894 <acs_fault_addr>)
42001973:	08a9      	s32i.n	a10, a8, 0
    if (cache_id == 0) {
42001975:	39dc      	bnez.n	a9, 4200198c <esp_cache_err_acs_save_and_clr+0x9c>
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_CLR_REG, mask);
42001977:	fa1a91        	l32r	a9, 420001e0 <_stext+0x1c0> (600c40ec <SYSTEM+0x40ec>)
4200197a:	0020c0        	memw
4200197d:	0988      	l32i.n	a8, a9, 0
4200197f:	0a1c      	movi.n	a10, 16
42001981:	2088a0        	or	a8, a8, a10
42001984:	0020c0        	memw
42001987:	0989      	s32i.n	a8, a9, 0
42001989:	000446        	j	4200199e <esp_cache_err_acs_save_and_clr+0xae>
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_CLR_REG, mask);
4200198c:	fa1691        	l32r	a9, 420001e4 <_stext+0x1c4> (600c40f8 <SYSTEM+0x40f8>)
4200198f:	0020c0        	memw
42001992:	0988      	l32i.n	a8, a9, 0
42001994:	0a1c      	movi.n	a10, 16
42001996:	2088a0        	or	a8, a8, a10
42001999:	0020c0        	memw
4200199c:	0989      	s32i.n	a8, a9, 0
        cache_ll_l1_clear_access_error_intr(cache_err_cpu_id, CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT);
    }
}
4200199e:	f01d      	retw.n

420019a0 <esp_cache_err_int_init>:

void esp_cache_err_int_init(void)
{
420019a0:	004136        	entry	a1, 32
    asm volatile (
420019a3:	03eb70        	rsr.prid	a7
420019a6:	047d70        	extui	a7, a7, 13, 1
    uint32_t core_id = esp_cpu_get_core_id();
    ESP_INTR_DISABLE(ETS_CACHEERR_INUM);
420019a9:	9a1c      	movi.n	a10, 25
420019ab:	fa1681        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
420019ae:	0008e0        	callx8	a8

    // We do not register a handler for the interrupt because it is interrupt
    // level 4 which is not serviceable from C. Instead, xtensa_vectors.S has
    // a call to the panic handler for this interrupt.
    esp_rom_route_intr_matrix(core_id, ETS_CACHE_IA_INTR_SOURCE, ETS_CACHEERR_INUM);
420019b1:	9c1c      	movi.n	a12, 25
420019b3:	8b3c      	movi.n	a11, 56
420019b5:	07ad      	mov.n	a10, a7
420019b7:	f9c881        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420019ba:	0008e0        	callx8	a8
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_CLR_REG, mask);
420019bd:	fa0a91        	l32r	a9, 420001e8 <_stext+0x1c8> (600c40e0 <SYSTEM+0x40e0>)
420019c0:	0020c0        	memw
420019c3:	0988      	l32i.n	a8, a9, 0
420019c5:	fa3c      	movi.n	a10, 63
420019c7:	2088a0        	or	a8, a8, a10
420019ca:	0020c0        	memw
420019cd:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_ENA_REG, mask);
420019cf:	fa0791        	l32r	a9, 420001ec <_stext+0x1cc> (600c40dc <SYSTEM+0x40dc>)
420019d2:	0020c0        	memw
420019d5:	0988      	l32i.n	a8, a9, 0
420019d7:	2088a0        	or	a8, a8, a10
420019da:	0020c0        	memw
420019dd:	0989      	s32i.n	a8, a9, 0
    ESP_DRAM_LOGV(TAG, "illegal error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ILG_EVENT_MASK);
    //illegal error intr doesn't depend on cache_id
    cache_ll_l1_clear_illegal_error_intr(0, CACHE_LL_L1_ILG_EVENT_MASK);
    cache_ll_l1_enable_illegal_error_intr(0, CACHE_LL_L1_ILG_EVENT_MASK);

    if (core_id == PRO_CPU_NUM) {
420019df:	f7ec      	bnez.n	a7, 42001a12 <esp_cache_err_int_init+0x72>
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE0_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
420019e1:	9c1c      	movi.n	a12, 25
420019e3:	eb5c      	movi.n	a11, 94
420019e5:	07ad      	mov.n	a10, a7
420019e7:	f9bc81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420019ea:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_CLR_REG, mask);
420019ed:	f9fc91        	l32r	a9, 420001e0 <_stext+0x1c0> (600c40ec <SYSTEM+0x40ec>)
420019f0:	0020c0        	memw
420019f3:	0988      	l32i.n	a8, a9, 0
420019f5:	fa1c      	movi.n	a10, 31
420019f7:	2088a0        	or	a8, a8, a10
420019fa:	0020c0        	memw
420019fd:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ENA_REG, mask);
420019ff:	f9fc91        	l32r	a9, 420001f0 <_stext+0x1d0> (600c40e8 <SYSTEM+0x40e8>)
42001a02:	0020c0        	memw
42001a05:	0988      	l32i.n	a8, a9, 0
42001a07:	2088a0        	or	a8, a8, a10
42001a0a:	0020c0        	memw
42001a0d:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
42001a0f:	000bc6        	j	42001a42 <esp_cache_err_int_init+0xa2>
         * enabling cache access error interrupts.  */
        ESP_DRAM_LOGV(TAG, "core 0 access error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_clear_access_error_intr(0, CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_enable_access_error_intr(0, CACHE_LL_L1_ACCESS_EVENT_MASK);
    } else {
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE1_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
42001a12:	9c1c      	movi.n	a12, 25
42001a14:	5fa0b2        	movi	a11, 95
42001a17:	20a770        	or	a10, a7, a7
42001a1a:	f9af81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
42001a1d:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_CLR_REG, mask);
42001a20:	f9f191        	l32r	a9, 420001e4 <_stext+0x1c4> (600c40f8 <SYSTEM+0x40f8>)
42001a23:	0020c0        	memw
42001a26:	0988      	l32i.n	a8, a9, 0
42001a28:	fa1c      	movi.n	a10, 31
42001a2a:	2088a0        	or	a8, a8, a10
42001a2d:	0020c0        	memw
42001a30:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
42001a32:	f9f091        	l32r	a9, 420001f4 <_stext+0x1d4> (600c40f4 <SYSTEM+0x40f4>)
42001a35:	0020c0        	memw
42001a38:	0988      	l32i.n	a8, a9, 0
42001a3a:	2088a0        	or	a8, a8, a10
42001a3d:	0020c0        	memw
42001a40:	0989      	s32i.n	a8, a9, 0
        ESP_DRAM_LOGV(TAG, "core 1 access error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_clear_access_error_intr(1, CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_enable_access_error_intr(1, CACHE_LL_L1_ACCESS_EVENT_MASK);
    }

    if (core_id == 0) {
42001a42:	064756        	bnez	a7, 42001aaa <esp_cache_err_int_init+0x10a>
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_addr(uint8_t spi_num, uint32_t region, uint32_t address)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_addr = address;
42001a45:	f9ec81        	l32r	a8, 420001f8 <_stext+0x1d8> (60026000 <SYSCON>)
42001a48:	090c      	movi.n	a9, 0
42001a4a:	0020c0        	memw
42001a4d:	e899      	s32i.n	a9, a8, 56
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_size(uint8_t spi_num, uint32_t region, uint32_t size)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_size.flash_ace0_size = size;
42001a4f:	0020c0        	memw
42001a52:	1228b2        	l32i	a11, a8, 72
42001a55:	f9e991        	l32r	a9, 420001fc <_stext+0x1dc> (ffff0000 <_rtc_reserved_end+0x9fef0000>)
42001a58:	10bb90        	and	a11, a11, a9
42001a5b:	f9e9a1        	l32r	a10, 42000200 <_stext+0x1e0> (4000 <UserFrameTotalSize+0x3f00>)
42001a5e:	20aba0        	or	a10, a11, a10
42001a61:	0020c0        	memw
42001a64:	1268a2        	s32i	a10, a8, 72
            break;
        case 1:
            SYSCON.flash_ace1_size.flash_ace1_size = size;
42001a67:	0020c0        	memw
42001a6a:	1328b2        	l32i	a11, a8, 76
42001a6d:	10ab90        	and	a10, a11, a9
42001a70:	0020c0        	memw
42001a73:	1368a2        	s32i	a10, a8, 76
            break;
        case 2:
            SYSCON.flash_ace2_size.flash_ace2_size = size;
42001a76:	0020c0        	memw
42001a79:	1428b2        	l32i	a11, a8, 80
42001a7c:	10ab90        	and	a10, a11, a9
42001a7f:	0020c0        	memw
42001a82:	1468a2        	s32i	a10, a8, 80
            break;
        case 3:
            SYSCON.flash_ace3_size.flash_ace3_size = size;
42001a85:	0020c0        	memw
42001a88:	1528a2        	l32i	a10, a8, 84
42001a8b:	109a90        	and	a9, a10, a9
42001a8e:	0020c0        	memw
42001a91:	156892        	s32i	a9, a8, 84
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_access(uint8_t spi_num, uint32_t region, mspi_ll_flash_ace_ctrl_t ctrl)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_attr.flash_ace0_attr = ctrl.val;
42001a94:	0020c0        	memw
42001a97:	a8a8      	l32i.n	a10, a8, 40
42001a99:	00ae92        	movi	a9, 0xfffffe00
42001a9c:	10aa90        	and	a10, a10, a9
42001a9f:	dba092        	movi	a9, 219
42001aa2:	209a90        	or	a9, a10, a9
42001aa5:	0020c0        	memw
42001aa8:	a899      	s32i.n	a9, a8, 40

        mspi_ll_set_flash_protection_access(0, 0, ctrl);

    }

    ESP_INTR_ENABLE(ETS_CACHEERR_INUM);
42001aaa:	9a1c      	movi.n	a10, 25
42001aac:	f9d781        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
42001aaf:	0008e0        	callx8	a8
}
42001ab2:	f01d      	retw.n

42001ab4 <esp_cache_err_get_cpuid>:

int esp_cache_err_get_cpuid(void)
{
42001ab4:	004136        	entry	a1, 32
    return cache_err_cpu_id;
}
42001ab7:	f9c581        	l32r	a8, 420001cc <_stext+0x1ac> (3fc94890 <cache_err_cpu_id>)
42001aba:	0828      	l32i.n	a2, a8, 0
42001abc:	f01d      	retw.n
	...

42001ac0 <esp_apb_backup_dma_lock_init>:

void esp_apb_backup_dma_lock_init(void)
{
42001ac0:	004136        	entry	a1, 32
    ets_apb_backup_init_lock_func(apb_backup_dma_lock, apb_backup_dma_unlock);
42001ac3:	f9d2b1        	l32r	a11, 4200020c <_stext+0x1ec> (403758a8 <apb_backup_dma_unlock>)
42001ac6:	f9d2a1        	l32r	a10, 42000210 <_stext+0x1f0> (403758c4 <apb_backup_dma_lock>)
42001ac9:	f9d281        	l32r	a8, 42000214 <_stext+0x1f4> (40000630 <ets_apb_backup_init_lock_func>)
42001acc:	0008e0        	callx8	a8
}
42001acf:	f01d      	retw.n
42001ad1:	000000        	ill

42001ad4 <esp_int_wdt_init>:

void esp_int_wdt_init(void)
{
42001ad4:	004136        	entry	a1, 32
    PERIPH_RCC_ACQUIRE_ATOMIC(IWDT_PERIPH, ref_count) {
42001ad7:	170c      	movi.n	a7, 1
42001ad9:	001446        	j	42001b2e <esp_int_wdt_init+0x5a>
        SYSTEM.perip_clk_en0.timergroup1_clk_en = enable;
42001adc:	f9cf81        	l32r	a8, 42000218 <_stext+0x1f8> (600c0000 <SYSTEM>)
42001adf:	0020c0        	memw
42001ae2:	6898      	l32i.n	a9, a8, 24
42001ae4:	f9cea1        	l32r	a10, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
42001ae7:	2099a0        	or	a9, a9, a10
42001aea:	0020c0        	memw
42001aed:	6899      	s32i.n	a9, a8, 24
    } else {
        SYSTEM.perip_rst_en0.timergroup1_rst = 1;
42001aef:	0020c0        	memw
42001af2:	8898      	l32i.n	a9, a8, 32
42001af4:	2099a0        	or	a9, a9, a10
42001af7:	0020c0        	memw
42001afa:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup1_rst = 0;
42001afc:	0020c0        	memw
42001aff:	8898      	l32i.n	a9, a8, 32
42001b01:	f9c7a1        	l32r	a10, 42000220 <_stext+0x200> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
42001b04:	1099a0        	and	a9, a9, a10
42001b07:	0020c0        	memw
42001b0a:	8899      	s32i.n	a9, a8, 32
        TIMERG1.wdtconfig0.wdt_flashboot_mod_en = 0;
42001b0c:	f9c691        	l32r	a9, 42000224 <_stext+0x204> (60020000 <TIMERG1>)
42001b0f:	0020c0        	memw
42001b12:	122982        	l32i	a8, a9, 72
42001b15:	f9c4a1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42001b18:	1088a0        	and	a8, a8, a10
42001b1b:	0020c0        	memw
42001b1e:	126982        	s32i	a8, a9, 72
42001b21:	ba0c      	movi.n	a10, 11
42001b23:	f9c581        	l32r	a8, 42000238 <_stext+0x218> (403766cc <periph_rcc_acquire_exit>)
42001b26:	0008e0        	callx8	a8
42001b29:	770b      	addi.n	a7, a7, -1
42001b2b:	747070        	extui	a7, a7, 0, 8
42001b2e:	e78c      	beqz.n	a7, 42001b40 <esp_int_wdt_init+0x6c>
42001b30:	ba0c      	movi.n	a10, 11
42001b32:	f9c281        	l32r	a8, 4200023c <_stext+0x21c> (403766bc <periph_rcc_acquire_enter>)
42001b35:	0008e0        	callx8	a8
42001b38:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
42001b3a:	f9ea16        	beqz	a10, 42001adc <esp_int_wdt_init+0x8>
42001b3d:	fff806        	j	42001b21 <esp_int_wdt_init+0x4d>
    /*
     * Initialize the WDT timeout stages. Note that the initial timeout is set to 5 seconds as variable startup times of
     * each CPU can lead to a timeout. The tick hooks will set the WDT timers to the actual timeout.
     * Todo: Fix this
     */
    wdt_hal_init(&iwdt_context, IWDT_INSTANCE, IWDT_PRESCALER, true);
42001b40:	f9bc71        	l32r	a7, 42000230 <_stext+0x210> (3fc948a0 <iwdt_context>)
42001b43:	1d0c      	movi.n	a13, 1
42001b45:	f9b9c1        	l32r	a12, 4200022c <_stext+0x20c> (9c40 <UserFrameTotalSize+0x9b40>)
42001b48:	2b0c      	movi.n	a11, 2
42001b4a:	07ad      	mov.n	a10, a7
42001b4c:	f9bd81        	l32r	a8, 42000240 <_stext+0x220> (40000dbc <wdt_hal_init>)
42001b4f:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&iwdt_context);
42001b52:	07ad      	mov.n	a10, a7
42001b54:	f95e81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001b57:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);
42001b5a:	f9b661        	l32r	a6, 42000234 <_stext+0x214> (2710 <UserFrameTotalSize+0x2610>)
42001b5d:	1d0c      	movi.n	a13, 1
42001b5f:	06cd      	mov.n	a12, a6
42001b61:	00a0b2        	movi	a11, 0
42001b64:	07ad      	mov.n	a10, a7
42001b66:	f98081        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001b69:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM);
42001b6c:	3d0c      	movi.n	a13, 3
42001b6e:	06cd      	mov.n	a12, a6
42001b70:	1b0c      	movi.n	a11, 1
42001b72:	07ad      	mov.n	a10, a7
42001b74:	f97d81        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001b77:	0008e0        	callx8	a8
    wdt_hal_enable(&iwdt_context);
42001b7a:	07ad      	mov.n	a10, a7
42001b7c:	f9b281        	l32r	a8, 42000244 <_stext+0x224> (40000df8 <wdt_hal_enable>)
42001b7f:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&iwdt_context);
42001b82:	07ad      	mov.n	a10, a7
42001b84:	f95481        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001b87:	0008e0        	callx8	a8
                : [ERI] "=r"(eriadrs), [REG] "+r"(scratch), [IMM] "+r"(immediate)
            );
        }
    }
#endif // (CONFIG_ESP32_ECO3_CACHE_LOCK_FIX && CONFIG_BTDM_CTRL_HLI)
}
42001b8a:	f01d      	retw.n

42001b8c <esp_int_wdt_cpu_init>:

void esp_int_wdt_cpu_init(void)
{
42001b8c:	004136        	entry	a1, 32
42001b8f:	03ebb0        	rsr.prid	a11
42001b92:	04bdb0        	extui	a11, a11, 13, 1
    assert((CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (portTICK_PERIOD_MS << 1)) && "Interrupt watchdog timeout needs to be at least twice the RTOS tick period!");
    // Register tick hook for current CPU to feed the INT WDT
    esp_register_freertos_tick_hook_for_cpu(tick_hook, esp_cpu_get_core_id());
42001b95:	f9aca1        	l32r	a10, 42000248 <_stext+0x228> (403758e4 <tick_hook>)
42001b98:	00b725        	call8	4200270c <esp_register_freertos_tick_hook_for_cpu>
    /*
     * Register INT WDT interrupt for current CPU. We do this manually as the timeout interrupt should call an assembly
     * panic handler (see riscv/vector.S and xtensa_vectors.S).
     */
    esp_intr_disable_source(ETS_INT_WDT_INUM);
42001b9b:	18a0a2        	movi	a10, 24
42001b9e:	f99981        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
42001ba1:	0008e0        	callx8	a8
42001ba4:	03eba0        	rsr.prid	a10
42001ba7:	04ada0        	extui	a10, a10, 13, 1
    esp_rom_route_intr_matrix(esp_cpu_get_core_id(), WDT_LEVEL_INTR_SOURCE, ETS_INT_WDT_INUM);
42001baa:	18a0c2        	movi	a12, 24
42001bad:	37a0b2        	movi	a11, 55
42001bb0:	f94a81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
42001bb3:	0008e0        	callx8	a8
        assert((portTICK_PERIOD_MS << 1) <= IWDT_LIVELOCK_TIMEOUT_MS);
        assert(CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (IWDT_LIVELOCK_TIMEOUT_MS * 3));
        _lx_intr_livelock_max = CONFIG_ESP_INT_WDT_TIMEOUT_MS / IWDT_LIVELOCK_TIMEOUT_MS - 1;
    }
#endif
    esp_intr_enable_source(ETS_INT_WDT_INUM);
42001bb6:	8a1c      	movi.n	a10, 24
42001bb8:	f99481        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
42001bbb:	0008e0        	callx8	a8
}
42001bbe:	f01d      	retw.n

42001bc0 <panic_print_char_usb_serial_jtag>:
{
42001bc0:	006136        	entry	a1, 48
42001bc3:	004122        	s8i	a2, a1, 0
    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
42001bc6:	000446        	j	42001bdb <panic_print_char_usb_serial_jtag+0x1b>
        esp_rom_delay_us(100);
42001bc9:	64a0a2        	movi	a10, 100
42001bcc:	f94d81        	l32r	a8, 42000100 <_stext+0xe0> (40000600 <esp_rom_delay_us>)
42001bcf:	0008e0        	callx8	a8
        s_usbserial_timeout++;
42001bd2:	f99e91        	l32r	a9, 4200024c <_stext+0x22c> (3fc948a8 <s_usbserial_timeout>)
42001bd5:	0988      	l32i.n	a8, a9, 0
42001bd7:	881b      	addi.n	a8, a8, 1
42001bd9:	0989      	s32i.n	a8, a9, 0
 *
 * @return 0 if no data available, 1 if data available
 */
static inline int usb_serial_jtag_ll_txfifo_writable(void)
{
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
42001bdb:	f99d81        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42001bde:	0020c0        	memw
42001be1:	1888      	l32i.n	a8, a8, 4
    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
42001be3:	0ae817        	bbsi	a8, 1, 42001bf1 <panic_print_char_usb_serial_jtag+0x31>
42001be6:	f99981        	l32r	a8, 4200024c <_stext+0x22c> (3fc948a8 <s_usbserial_timeout>)
42001be9:	0888      	l32i.n	a8, a8, 0
42001beb:	f3a192        	movi	a9, 0x1f3
42001bee:	d7a987        	bge	a9, a8, 42001bc9 <panic_print_char_usb_serial_jtag+0x9>
42001bf1:	f99781        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42001bf4:	0020c0        	memw
42001bf7:	1888      	l32i.n	a8, a8, 4
    if (usb_serial_jtag_ll_txfifo_writable()) {
42001bf9:	20e817        	bbsi	a8, 1, 42001c1d <panic_print_char_usb_serial_jtag+0x5d>
42001bfc:	000a46        	j	42001c29 <panic_print_char_usb_serial_jtag+0x69>
42001bff:	949100        	extui	a9, a0, 1, 10
        if (!USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free) break;
42001c02:	c0f9      	s32i.n	a15, a0, 48
42001c04:	980020        	lsi	f2, a0, 0x260
42001c07:	1719      	s32i.n	a1, a7, 4
42001c09:	1669      	s32i.n	a6, a6, 4
        USB_SERIAL_JTAG.ep1.rdwr_byte = buf[i];
42001c0b:	918a      	add.n	a9, a1, a8
42001c0d:	0009a2        	l8ui	a10, a9, 0
42001c10:	f99091        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42001c13:	0020c0        	memw
42001c16:	09a9      	s32i.n	a10, a9, 0
    for (i = 0; i < wr_len; i++) {
42001c18:	881b      	addi.n	a8, a8, 1
42001c1a:	000046        	j	42001c1f <panic_print_char_usb_serial_jtag+0x5f>
42001c1d:	080c      	movi.n	a8, 0
42001c1f:	fdd816        	beqz	a8, 42001c00 <panic_print_char_usb_serial_jtag+0x40>
        s_usbserial_timeout = 0;
42001c22:	f98a81        	l32r	a8, 4200024c <_stext+0x22c> (3fc948a8 <s_usbserial_timeout>)
42001c25:	090c      	movi.n	a9, 0
42001c27:	0899      	s32i.n	a9, a8, 0
}
42001c29:	f01d      	retw.n
	...

42001c2c <disable_all_wdts>:
{
42001c2c:	006136        	entry	a1, 48
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001c2f:	f98981        	l32r	a8, 42000254 <_stext+0x234> (3c026f24 <ilg_int_st_bits+0x60>)
42001c32:	0898      	l32i.n	a9, a8, 0
42001c34:	1888      	l32i.n	a8, a8, 4
42001c36:	0199      	s32i.n	a9, a1, 0
42001c38:	1189      	s32i.n	a8, a1, 4
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001c3a:	f98781        	l32r	a8, 42000258 <_stext+0x238> (3c026f2c <ilg_int_st_bits+0x68>)
42001c3d:	718b      	addi.n	a7, a1, 8
42001c3f:	0898      	l32i.n	a9, a8, 0
42001c41:	1888      	l32i.n	a8, a8, 4
42001c43:	2199      	s32i.n	a9, a1, 8
42001c45:	3189      	s32i.n	a8, a1, 12
    wdt_hal_write_protect_disable(&wdt0_context);
42001c47:	20a110        	or	a10, a1, a1
42001c4a:	f92081        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001c4d:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
42001c50:	01ad      	mov.n	a10, a1
42001c52:	f91f81        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42001c55:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
42001c58:	01ad      	mov.n	a10, a1
42001c5a:	f91e81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001c5d:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt1_context);
42001c60:	07ad      	mov.n	a10, a7
42001c62:	f91a81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001c65:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
42001c68:	07ad      	mov.n	a10, a7
42001c6a:	f91981        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42001c6d:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
42001c70:	07ad      	mov.n	a10, a7
42001c72:	f91881        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001c75:	0008e0        	callx8	a8
}
42001c78:	f01d      	retw.n
	...

42001c7c <panic_print_char>:
{
42001c7c:	004136        	entry	a1, 32
    panic_print_char_usb_serial_jtag(c);
42001c7f:	74a020        	extui	a10, a2, 0, 8
42001c82:	fff3e5        	call8	42001bc0 <panic_print_char_usb_serial_jtag>
}
42001c85:	f01d      	retw.n
	...

42001c88 <panic_print_str>:
{
42001c88:	004136        	entry	a1, 32
    for (int i = 0; str[i] != 0; i++) {
42001c8b:	070c      	movi.n	a7, 0
42001c8d:	000146        	j	42001c96 <panic_print_str+0xe>
        panic_print_char(str[i]);
42001c90:	fffea5        	call8	42001c7c <panic_print_char>
    for (int i = 0; str[i] != 0; i++) {
42001c93:	01c772        	addi	a7, a7, 1
42001c96:	808270        	add	a8, a2, a7
42001c99:	0008a2        	l8ui	a10, a8, 0
42001c9c:	ff0a56        	bnez	a10, 42001c90 <panic_print_str+0x8>
}
42001c9f:	000090        	retw
	...

42001ca4 <print_abort_details>:
{
42001ca4:	004136        	entry	a1, 32
    panic_print_str(g_panic_abort_details);
42001ca7:	f96d81        	l32r	a8, 4200025c <_stext+0x23c> (3fc948ac <g_panic_abort_details>)
42001caa:	08a8      	l32i.n	a10, a8, 0
42001cac:	fffda5        	call8	42001c88 <panic_print_str>
}
42001caf:	f01d      	retw.n
42001cb1:	000000        	ill

42001cb4 <panic_print_hex>:
{
42001cb4:	004136        	entry	a1, 32
    for (x = 0; x < 8; x++) {
42001cb7:	070c      	movi.n	a7, 0
42001cb9:	000786        	j	42001cdb <panic_print_hex+0x27>
        c = (h >> 28) & 0xf; // extract the leftmost byte
42001cbc:	35ac20        	extui	a10, a2, 28, 4
        if (c < 10) {
42001cbf:	980c      	movi.n	a8, 9
42001cc1:	0b28a7        	blt	a8, a10, 42001cd0 <panic_print_hex+0x1c>
            panic_print_char('0' + c);
42001cc4:	30caa2        	addi	a10, a10, 48
42001cc7:	fffb65        	call8	42001c7c <panic_print_char>
42001cca:	000206        	j	42001cd6 <panic_print_hex+0x22>
42001ccd:	000000        	ill
            panic_print_char('a' + c - 10);
42001cd0:	57caa2        	addi	a10, a10, 87
42001cd3:	fffaa5        	call8	42001c7c <panic_print_char>
        h <<= 4; // move the 2nd leftmost byte to the left, to be extracted next
42001cd6:	1122c0        	slli	a2, a2, 4
    for (x = 0; x < 8; x++) {
42001cd9:	771b      	addi.n	a7, a7, 1
42001cdb:	dd87a6        	blti	a7, 8, 42001cbc <panic_print_hex+0x8>
}
42001cde:	f01d      	retw.n

42001ce0 <panic_print_dec>:
{
42001ce0:	004136        	entry	a1, 32
    n1 = d % 10; // extract ones digit
42001ce3:	f95f71        	l32r	a7, 42000260 <_stext+0x240> (66666667 <_rtc_reserved_end+0x6566667>)
42001ce6:	b27270        	mulsh	a7, a2, a7
42001ce9:	217270        	srai	a7, a7, 2
42001cec:	318f20        	srai	a8, a2, 31
42001cef:	c07780        	sub	a7, a7, a8
42001cf2:	07ad      	mov.n	a10, a7
42001cf4:	a07770        	addx4	a7, a7, a7
42001cf7:	777a      	add.n	a7, a7, a7
42001cf9:	c07270        	sub	a7, a2, a7
    if (n2 == 0) {
42001cfc:	008a56        	bnez	a10, 42001d08 <panic_print_dec+0x28>
        panic_print_char(' ');
42001cff:	0a2c      	movi.n	a10, 32
42001d01:	fff7a5        	call8	42001c7c <panic_print_char>
42001d04:	000246        	j	42001d11 <panic_print_dec+0x31>
42001d07:	caa200        	float.s	f10, a2, 0
        panic_print_char(n2 + '0');
42001d0a:	a0a030        	addx4	a10, a0, a3
42001d0d:	f6e574        	lsi	f7, a5, 0x3d8
42001d10:	ff          	.byte	0xff
    panic_print_char(n1 + '0');
42001d11:	30c7a2        	addi	a10, a7, 48
42001d14:	74a0a0        	extui	a10, a10, 0, 8
42001d17:	fff665        	call8	42001c7c <panic_print_char>
}
42001d1a:	f01d      	retw.n

42001d1c <esp_panic_handler_reconfigure_wdts>:
{
42001d1c:	006136        	entry	a1, 48
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001d1f:	f94d81        	l32r	a8, 42000254 <_stext+0x234> (3c026f24 <ilg_int_st_bits+0x60>)
42001d22:	0898      	l32i.n	a9, a8, 0
42001d24:	1888      	l32i.n	a8, a8, 4
42001d26:	0199      	s32i.n	a9, a1, 0
42001d28:	1189      	s32i.n	a8, a1, 4
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001d2a:	f94b81        	l32r	a8, 42000258 <_stext+0x238> (3c026f2c <ilg_int_st_bits+0x68>)
42001d2d:	718b      	addi.n	a7, a1, 8
42001d2f:	0898      	l32i.n	a9, a8, 0
42001d31:	1888      	l32i.n	a8, a8, 4
42001d33:	2199      	s32i.n	a9, a1, 8
42001d35:	3189      	s32i.n	a8, a1, 12
    wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT_LL_DEFAULT_CLK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
42001d37:	0d0c      	movi.n	a13, 0
42001d39:	f93cc1        	l32r	a12, 4200022c <_stext+0x20c> (9c40 <UserFrameTotalSize+0x9b40>)
42001d3c:	1b0c      	movi.n	a11, 1
42001d3e:	01ad      	mov.n	a10, a1
42001d40:	f94081        	l32r	a8, 42000240 <_stext+0x220> (40000dbc <wdt_hal_init>)
42001d43:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt0_context);
42001d46:	01ad      	mov.n	a10, a1
42001d48:	f8e181        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001d4b:	0008e0        	callx8	a8
    wdt_hal_config_stage(&wdt0_context, 0, timeout_ms * 1000 / MWDT_DEFAULT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); //1 second before reset
42001d4e:	11c2b0        	slli	a12, a2, 5
42001d51:	c0cc20        	sub	a12, a12, a2
42001d54:	a0cc20        	addx4	a12, a12, a2
42001d57:	11ccd0        	slli	a12, a12, 3
42001d5a:	f94281        	l32r	a8, 42000264 <_stext+0x244> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
42001d5d:	a2cc80        	muluh	a12, a12, a8
42001d60:	3d0c      	movi.n	a13, 3
42001d62:	41c5c0        	srli	a12, a12, 5
42001d65:	0b0c      	movi.n	a11, 0
42001d67:	20a110        	or	a10, a1, a1
42001d6a:	f8ff81        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001d6d:	0008e0        	callx8	a8
    wdt_hal_enable(&wdt0_context);
42001d70:	01ad      	mov.n	a10, a1
42001d72:	f93481        	l32r	a8, 42000244 <_stext+0x224> (40000df8 <wdt_hal_enable>)
42001d75:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
42001d78:	01ad      	mov.n	a10, a1
42001d7a:	f8d681        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001d7d:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt1_context);
42001d80:	07ad      	mov.n	a10, a7
42001d82:	f8d281        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001d85:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
42001d88:	07ad      	mov.n	a10, a7
42001d8a:	f8d181        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42001d8d:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
42001d90:	07ad      	mov.n	a10, a7
42001d92:	f8d081        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001d95:	0008e0        	callx8	a8
}
42001d98:	f01d      	retw.n
	...

42001d9c <esp_panic_handler>:
{
42001d9c:	006136        	entry	a1, 48
42001d9f:	207220        	or	a7, a2, a2
    esp_panic_handler_reconfigure_wdts(1000);
42001da2:	e8a3a2        	movi	a10, 0x3e8
42001da5:	fff765        	call8	42001d1c <esp_panic_handler_reconfigure_wdts>
    if (g_panic_abort) {
42001da8:	f93181        	l32r	a8, 4200026c <_stext+0x24c> (3fc948b0 <g_panic_abort>)
42001dab:	000882        	l8ui	a8, a8, 0
42001dae:	01e816        	beqz	a8, 42001dd0 <esp_panic_handler+0x34>
        info->description = NULL;
42001db1:	00a082        	movi	a8, 0
42001db4:	3289      	s32i.n	a8, a2, 12
        info->details = g_panic_abort_details ? print_abort_details : NULL;
42001db6:	f92981        	l32r	a8, 4200025c <_stext+0x23c> (3fc948ac <g_panic_abort_details>)
42001db9:	0888      	l32i.n	a8, a8, 0
42001dbb:	588c      	beqz.n	a8, 42001dc4 <esp_panic_handler+0x28>
42001dbd:	f92a81        	l32r	a8, 42000268 <_stext+0x248> (42001ca4 <print_abort_details>)
42001dc0:	000086        	j	42001dc6 <esp_panic_handler+0x2a>
42001dc3:	080c00        	lsx	f0, a12, a0
42001dc6:	4789      	s32i.n	a8, a7, 16
        info->reason = NULL;
42001dc8:	080c      	movi.n	a8, 0
42001dca:	2789      	s32i.n	a8, a7, 8
        info->exception = PANIC_EXCEPTION_ABORT;
42001dcc:	380c      	movi.n	a8, 3
42001dce:	1789      	s32i.n	a8, a7, 4
    if (info->reason) {
42001dd0:	022782        	l32i	a8, a7, 8
42001dd3:	01b816        	beqz	a8, 42001df2 <esp_panic_handler+0x56>
        panic_print_str("Guru Meditation Error: Core ");
42001dd6:	f926a1        	l32r	a10, 42000270 <_stext+0x250> (3c020844 <_flash_rodata_start+0x724>)
42001dd9:	ffeae5        	call8	42001c88 <panic_print_str>
        panic_print_dec(info->core);
42001ddc:	07a8      	l32i.n	a10, a7, 0
42001dde:	fff025        	call8	42001ce0 <panic_print_dec>
        panic_print_str(" panic'ed (");
42001de1:	f924a1        	l32r	a10, 42000274 <_stext+0x254> (3c020864 <_flash_rodata_start+0x744>)
42001de4:	ffea25        	call8	42001c88 <panic_print_str>
        panic_print_str(info->reason);
42001de7:	27a8      	l32i.n	a10, a7, 8
42001de9:	ffe9e5        	call8	42001c88 <panic_print_str>
        panic_print_str("). ");
42001dec:	f923a1        	l32r	a10, 42000278 <_stext+0x258> (3c020870 <_flash_rodata_start+0x750>)
42001def:	ffe9a5        	call8	42001c88 <panic_print_str>
    if (info->description) {
42001df2:	37a8      	l32i.n	a10, a7, 12
42001df4:	1a8c      	beqz.n	a10, 42001df9 <esp_panic_handler+0x5d>
        panic_print_str(info->description);
42001df6:	ffe925        	call8	42001c88 <panic_print_str>
    panic_print_str("\r\n");
42001df9:	f920a1        	l32r	a10, 4200027c <_stext+0x25c> (3c0208c4 <_flash_rodata_start+0x7a4>)
42001dfc:	ffe8a5        	call8	42001c88 <panic_print_str>
    PANIC_INFO_DUMP(info, details);
42001dff:	4788      	l32i.n	a8, a7, 16
42001e01:	388c      	beqz.n	a8, 42001e08 <esp_panic_handler+0x6c>
42001e03:	77a8      	l32i.n	a10, a7, 28
42001e05:	0008e0        	callx8	a8
    panic_print_str("\r\n");
42001e08:	f91da1        	l32r	a10, 4200027c <_stext+0x25c> (3c0208c4 <_flash_rodata_start+0x7a4>)
42001e0b:	ffe7e5        	call8	42001c88 <panic_print_str>
    RER(reg, dcr);
42001e0e:	f91c81        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
42001e11:	406880        	rer	a8, a8
    if (esp_cpu_dbgr_is_attached()) {
42001e14:	486807        	bbci	a8, 0, 42001e60 <esp_panic_handler+0xc4>
        if (info->pseudo_excause) {
42001e17:	200782        	l8ui	a8, a7, 32
42001e1a:	388c      	beqz.n	a8, 42001e21 <esp_panic_handler+0x85>
            panic_reason_str = (char *)info->reason;
42001e1c:	27a8      	l32i.n	a10, a7, 8
42001e1e:	000306        	j	42001e2e <esp_panic_handler+0x92>
        } else if (g_panic_abort) {
42001e21:	f91281        	l32r	a8, 4200026c <_stext+0x24c> (3fc948b0 <g_panic_abort>)
42001e24:	000882        	l8ui	a8, a8, 0
42001e27:	889c      	beqz.n	a8, 42001e43 <esp_panic_handler+0xa7>
            panic_reason_str = g_panic_abort_details;
42001e29:	f90c81        	l32r	a8, 4200025c <_stext+0x23c> (3fc948ac <g_panic_abort_details>)
42001e2c:	08a8      	l32i.n	a10, a8, 0
        if (panic_reason_str) {
42001e2e:	011a16        	beqz	a10, 42001e43 <esp_panic_handler+0xa7>
            long args[] = {(long)panic_reason_str, strlen(panic_reason_str)};
42001e31:	01a9      	s32i.n	a10, a1, 0
42001e33:	f91a81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42001e36:	0008e0        	callx8	a8
42001e39:	11a9      	s32i.n	a10, a1, 4
 *
 * @return  return value from the host
 */
static inline long semihosting_call_noerrno(long id, long *data)
{
    register long a2 asm ("a2") = id;
42001e3b:	16a122        	movi	a2, 0x116
    register long a3 asm ("a3") = (long)data;
42001e3e:	013d      	mov.n	a3, a1

    __asm__ __volatile__ (
42001e40:	0041e0        	break	1, 14
        panic_print_str("Setting breakpoint at 0x");
42001e43:	f910a1        	l32r	a10, 42000284 <_stext+0x264> (3c020874 <_flash_rodata_start+0x754>)
42001e46:	ffe425        	call8	42001c88 <panic_print_str>
        panic_print_hex((uint32_t)info->addr);
42001e49:	67a8      	l32i.n	a10, a7, 24
42001e4b:	ffe6a5        	call8	42001cb4 <panic_print_hex>
        panic_print_str(" and returning...\r\n");
42001e4e:	f90ea1        	l32r	a10, 42000288 <_stext+0x268> (3c020890 <_flash_rodata_start+0x770>)
42001e51:	ffe365        	call8	42001c88 <panic_print_str>
        disable_all_wdts();
42001e54:	ffdd65        	call8	42001c2c <disable_all_wdts>
        esp_cpu_set_breakpoint(0, info->addr); // use breakpoint 0
42001e57:	67b8      	l32i.n	a11, a7, 24
42001e59:	0a0c      	movi.n	a10, 0
42001e5b:	12d825        	call8	42014bdc <esp_cpu_set_breakpoint>
}
42001e5e:	f01d      	retw.n
    if (!wdt_hal_is_enabled(&rtc_wdt_ctx)) {
42001e60:	f90ba1        	l32r	a10, 4200028c <_stext+0x26c> (3fc91f08 <rtc_wdt_ctx>)
42001e63:	f90f81        	l32r	a8, 420002a0 <_stext+0x280> (40000e34 <wdt_hal_is_enabled>)
42001e66:	0008e0        	callx8	a8
42001e69:	054a56        	bnez	a10, 42001ec1 <esp_panic_handler+0x125>
        wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
42001e6c:	f90821        	l32r	a2, 4200028c <_stext+0x26c> (3fc91f08 <rtc_wdt_ctx>)
42001e6f:	0d0c      	movi.n	a13, 0
42001e71:	0c0c      	movi.n	a12, 0
42001e73:	0b0c      	movi.n	a11, 0
42001e75:	02ad      	mov.n	a10, a2
42001e77:	f8f281        	l32r	a8, 42000240 <_stext+0x220> (40000dbc <wdt_hal_init>)
42001e7a:	0008e0        	callx8	a8
        uint32_t stage_timeout_ticks = (uint32_t)(7000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001e7d:	f8b781        	l32r	a8, 4200015c <_stext+0x13c> (40378a30 <rtc_clk_slow_freq_get_hz>)
42001e80:	0008e0        	callx8	a8
42001e83:	0a8d      	mov.n	a8, a10
42001e85:	f902a1        	l32r	a10, 42000290 <_stext+0x270> (1b58 <UserFrameTotalSize+0x1a58>)
42001e88:	a2b8a0        	muluh	a11, a8, a10
42001e8b:	e8a3c2        	movi	a12, 0x3e8
42001e8e:	0d0c      	movi.n	a13, 0
42001e90:	82a8a0        	mull	a10, a8, a10
42001e93:	f8b381        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
42001e96:	0008e0        	callx8	a8
42001e99:	0a3d      	mov.n	a3, a10
        wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001e9b:	02ad      	mov.n	a10, a2
42001e9d:	f88b81        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001ea0:	0008e0        	callx8	a8
        wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_SYSTEM);
42001ea3:	3d0c      	movi.n	a13, 3
42001ea5:	03cd      	mov.n	a12, a3
42001ea7:	0b0c      	movi.n	a11, 0
42001ea9:	02ad      	mov.n	a10, a2
42001eab:	f8af81        	l32r	a8, 42000168 <_stext+0x148> (40000dd4 <wdt_hal_config_stage>)
42001eae:	0008e0        	callx8	a8
        wdt_hal_enable(&rtc_wdt_ctx);
42001eb1:	02ad      	mov.n	a10, a2
42001eb3:	f8e481        	l32r	a8, 42000244 <_stext+0x224> (40000df8 <wdt_hal_enable>)
42001eb6:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001eb9:	02ad      	mov.n	a10, a2
42001ebb:	f88681        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001ebe:	0008e0        	callx8	a8
    esp_panic_handler_reconfigure_wdts(1000); // Restart WDT again
42001ec1:	e8a3a2        	movi	a10, 0x3e8
42001ec4:	ffe565        	call8	42001d1c <esp_panic_handler_reconfigure_wdts>
    PANIC_INFO_DUMP(info, state);
42001ec7:	5788      	l32i.n	a8, a7, 20
42001ec9:	488c      	beqz.n	a8, 42001ed1 <esp_panic_handler+0x135>
42001ecb:	0727a2        	l32i	a10, a7, 28
42001ece:	0008e0        	callx8	a8
    panic_print_str("\r\n");
42001ed1:	f8ea21        	l32r	a2, 4200027c <_stext+0x25c> (3c0208c4 <_flash_rodata_start+0x7a4>)
42001ed4:	20a220        	or	a10, a2, a2
42001ed7:	ffdb25        	call8	42001c88 <panic_print_str>
    g_panic_abort = false;
42001eda:	f8e481        	l32r	a8, 4200026c <_stext+0x24c> (3fc948b0 <g_panic_abort>)
42001edd:	00a092        	movi	a9, 0
42001ee0:	004892        	s8i	a9, a8, 0
    panic_print_str("\r\nELF file SHA256: ");
42001ee3:	f8eca1        	l32r	a10, 42000294 <_stext+0x274> (3c0208a4 <_flash_rodata_start+0x784>)
42001ee6:	ffda25        	call8	42001c88 <panic_print_str>
    panic_print_str(esp_app_get_elf_sha256_str());
42001ee9:	f84da1        	l32r	a10, 42000020 <_stext> (3fc94860 <app_elf_sha256_str>)
42001eec:	ffd9a5        	call8	42001c88 <panic_print_str>
    panic_print_str("\r\n");
42001eef:	02ad      	mov.n	a10, a2
42001ef1:	ffd965        	call8	42001c88 <panic_print_str>
    panic_print_str("\r\n");
42001ef4:	02ad      	mov.n	a10, a2
42001ef6:	ffd925        	call8	42001c88 <panic_print_str>
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001ef9:	f8e421        	l32r	a2, 4200028c <_stext+0x26c> (3fc91f08 <rtc_wdt_ctx>)
42001efc:	02ad      	mov.n	a10, a2
42001efe:	f87381        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
42001f01:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
42001f04:	02ad      	mov.n	a10, a2
42001f06:	f87281        	l32r	a8, 420000d0 <_stext+0xb0> (40000e04 <wdt_hal_disable>)
42001f09:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001f0c:	02ad      	mov.n	a10, a2
42001f0e:	f87181        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
42001f11:	0008e0        	callx8	a8
    if (esp_reset_reason_get_hint() == ESP_RST_UNKNOWN) {
42001f14:	ff95a5        	call8	42001870 <esp_reset_reason_get_hint>
42001f17:	9aec      	bnez.n	a10, 42001f44 <esp_panic_handler+0x1a8>
        switch (info->exception) {
42001f19:	1788      	l32i.n	a8, a7, 4
42001f1b:	051826        	beqi	a8, 1, 42001f24 <esp_panic_handler+0x188>
42001f1e:	0e2826        	beqi	a8, 2, 42001f30 <esp_panic_handler+0x194>
42001f21:	0005c6        	j	42001f3c <esp_panic_handler+0x1a0>
            esp_reset_reason_set_hint(ESP_RST_INT_WDT);
42001f24:	5a0c      	movi.n	a10, 5
42001f26:	f8df81        	l32r	a8, 420002a4 <_stext+0x284> (40375668 <esp_reset_reason_set_hint>)
42001f29:	0008e0        	callx8	a8
            break;
42001f2c:	000506        	j	42001f44 <esp_panic_handler+0x1a8>
42001f2f:	6a0c00        	maddn.s	f0, f12, f0
            esp_reset_reason_set_hint(ESP_RST_TASK_WDT);
42001f32:	f8dc81        	l32r	a8, 420002a4 <_stext+0x284> (40375668 <esp_reset_reason_set_hint>)
42001f35:	0008e0        	callx8	a8
            break;
42001f38:	000206        	j	42001f44 <esp_panic_handler+0x1a8>
42001f3b:	4a0c00        	madd.s	f0, f12, f0
            esp_reset_reason_set_hint(ESP_RST_PANIC);
42001f3e:	f8d981        	l32r	a8, 420002a4 <_stext+0x284> (40375668 <esp_reset_reason_set_hint>)
42001f41:	0008e0        	callx8	a8
    panic_print_str("Rebooting...\r\n");
42001f44:	f8d5a1        	l32r	a10, 42000298 <_stext+0x278> (3c0208b8 <_flash_rodata_start+0x798>)
42001f47:	ffd425        	call8	42001c88 <panic_print_str>
    panic_restart();
42001f4a:	003165        	call8	42002260 <panic_restart>
42001f4d:	000000        	ill

42001f50 <do_global_ctors>:
{
42001f50:	004136        	entry	a1, 32
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
42001f53:	f8d571        	l32r	a7, 420002a8 <_stext+0x288> (3c029ea8 <__XT_EXCEPTION_DESCS_+0x14>)
42001f56:	0001c6        	j	42001f61 <do_global_ctors+0x11>
        (*p)();
42001f59:	0788      	l32i.n	a8, a7, 0
42001f5b:	0008e0        	callx8	a8
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
42001f5e:	fcc772        	addi	a7, a7, -4
42001f61:	f8d281        	l32r	a8, 420002ac <_stext+0x28c> (3c029e94 <__XT_EXCEPTION_DESCS_>)
42001f64:	f1b787        	bgeu	a7, a8, 42001f59 <do_global_ctors+0x9>
}
42001f67:	f01d      	retw.n
42001f69:	000000        	ill

42001f6c <do_system_init_fn>:
{
42001f6c:	004136        	entry	a1, 32
    asm volatile (
42001f6f:	03eb60        	rsr.prid	a6
42001f72:	046d60        	extui	a6, a6, 13, 1
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
42001f75:	f8ce71        	l32r	a7, 420002b0 <_stext+0x290> (3c029ed4 <esp_system_init_fn_init_efuse_check>)
42001f78:	000f06        	j	42001fb8 <do_system_init_fn+0x4c>
42001f7b:	178200        	lsi	f0, a2, 92
        if (p->stage == stage_num && (p->cores & BIT(core_id)) != 0) {
42001f7e:	982703        	lsi	f0, a7, 0x260
42001f81:	178233        	lsip	f3, a2, 92
42001f84:	586702        	s32i	a0, a7, 0x160
42001f87:	a82d      	lsi	f2, a8, 32
            esp_err_t err = (*(p->fn))();
42001f89:	0ae007        	bbsi	a0, 0, 42001f97 <do_system_init_fn+0x2b>
42001f8c:	0a5d00        	add.s	f5, f13, f0
            if (err != ESP_OK) {
42001f8f:	3aac      	beqz.n	a10, 42001fb6 <do_system_init_fn+0x4a>
42001f91:	f82681        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42001f94:	0888      	l32i.n	a8, a8, 0
                ESP_EARLY_LOGE(TAG, "init function %p has failed (0x%x), aborting", p->fn, err);
42001f96:	689c      	beqz.n	a8, 42001fb0 <do_system_init_fn+0x44>
42001f98:	f83281        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42001f9b:	0008e0        	callx8	a8
42001f9e:	05ed      	mov.n	a14, a5
42001fa0:	07d8      	l32i.n	a13, a7, 0
42001fa2:	f8c4c1        	l32r	a12, 420002b4 <_stext+0x294> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001fa5:	0abd      	mov.n	a11, a10
42001fa7:	f8c4a1        	l32r	a10, 420002b8 <_stext+0x298> (3c0208c8 <_flash_rodata_start+0x7a8>)
42001faa:	f82e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001fad:	0008e0        	callx8	a8
                abort();
42001fb0:	f85181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42001fb3:	0008e0        	callx8	a8
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
42001fb6:	778b      	addi.n	a7, a7, 8
42001fb8:	f8c181        	l32r	a8, 420002bc <_stext+0x29c> (3c029f74 <_esp_system_init_fn_array_end>)
42001fbb:	bd3787        	bltu	a7, a8, 42001f7c <do_system_init_fn+0x10>
    s_system_inited[core_id] = true;
42001fbe:	f8c081        	l32r	a8, 420002c0 <_stext+0x2a0> (3fc948b4 <s_system_inited>)
42001fc1:	886a      	add.n	a8, a8, a6
42001fc3:	190c      	movi.n	a9, 1
42001fc5:	0020c0        	memw
42001fc8:	004892        	s8i	a9, a8, 0
}
42001fcb:	f01d      	retw.n
42001fcd:	000000        	ill

42001fd0 <do_core_init>:
}
#endif

static void do_core_init(void)
{
42001fd0:	004136        	entry	a1, 32
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_CORE);
42001fd3:	0a0c      	movi.n	a10, 0
42001fd5:	fff965        	call8	42001f6c <do_system_init_fn>
}
42001fd8:	f01d      	retw.n
	...

42001fdc <do_secondary_init>:

static void do_secondary_init(void)
{
42001fdc:	006136        	entry	a1, 48
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // The port layer transferred control to this function with other cores 'paused',
    // resume execution so that cores might execute component initialization functions.
    startup_resume_other_cores();
42001fdf:	ff4da5        	call8	420014b8 <startup_resume_other_cores>
#endif

    // Execute initialization functions esp_system_init_fn_t assigned to the main core. While
    // this is happening, all other cores are executing the initialization functions
    // assigned to them since they have been resumed already.
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_SECONDARY);
42001fe2:	01a0a2        	movi	a10, 1
42001fe5:	fff865        	call8	42001f6c <do_system_init_fn>

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // Wait for all cores to finish secondary init.
    volatile bool system_inited = false;
42001fe8:	00a082        	movi	a8, 0
42001feb:	0020c0        	memw
42001fee:	004182        	s8i	a8, a1, 0

    while (!system_inited) {
42001ff1:	000dc6        	j	4200202c <do_secondary_init+0x50>
        system_inited = true;
42001ff4:	180c      	movi.n	a8, 1
42001ff6:	0020c0        	memw
42001ff9:	004182        	s8i	a8, a1, 0
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42001ffc:	090c      	movi.n	a9, 0
42001ffe:	000786        	j	42002020 <do_secondary_init+0x44>
            system_inited &= s_system_inited[i];
42002001:	f8af81        	l32r	a8, 420002c0 <_stext+0x2a0> (3fc948b4 <s_system_inited>)
42002004:	889a      	add.n	a8, a8, a9
42002006:	0020c0        	memw
42002009:	0008a2        	l8ui	a10, a8, 0
4200200c:	0020c0        	memw
4200200f:	000182        	l8ui	a8, a1, 0
42002012:	748080        	extui	a8, a8, 0, 8
42002015:	1088a0        	and	a8, a8, a10
42002018:	0020c0        	memw
4200201b:	004182        	s8i	a8, a1, 0
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
4200201e:	991b      	addi.n	a9, a9, 1
42002020:	dd29a6        	blti	a9, 2, 42002001 <do_secondary_init+0x25>
        }
        esp_rom_delay_us(100);
42002023:	64a0a2        	movi	a10, 100
42002026:	f83681        	l32r	a8, 42000100 <_stext+0xe0> (40000600 <esp_rom_delay_us>)
42002029:	0008e0        	callx8	a8
    while (!system_inited) {
4200202c:	0020c0        	memw
4200202f:	000182        	l8ui	a8, a1, 0
42002032:	748080        	extui	a8, a8, 0, 8
42002035:	fbb816        	beqz	a8, 42001ff4 <do_secondary_init+0x18>
    }
#endif
}
42002038:	f01d      	retw.n
	...

4200203c <start_cpu0>:

static void start_cpu0_default(void)
{
4200203c:	004136        	entry	a1, 32
    // Initialize core components and services.
    do_core_init();
4200203f:	fff925        	call8	42001fd0 <do_core_init>

    // Execute constructors.
    do_global_ctors();
42002042:	fff0e5        	call8	42001f50 <do_global_ctors>

    // Execute init functions of other components; blocks
    // until all cores finish (when !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE).
    do_secondary_init();
42002045:	fff965        	call8	42001fdc <do_secondary_init>

#if SOC_CPU_CORES_NUM > 1 && !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_system_full_inited = true;
42002048:	f89f81        	l32r	a8, 420002c4 <_stext+0x2a4> (3fc948b1 <s_system_full_inited>)
4200204b:	190c      	movi.n	a9, 1
4200204d:	0020c0        	memw
42002050:	004892        	s8i	a9, a8, 0
#endif

    esp_startup_start_app();
42002053:	13b925        	call8	42015be4 <esp_startup_start_app>

    ESP_INFINITE_LOOP();
42002056:	ffff06        	j	42002056 <start_cpu0+0x1a>
42002059:	000000        	ill

4200205c <frame_to_panic_info>:
{
4200205c:	004136        	entry	a1, 32
4200205f:	03eb80        	rsr.prid	a8
42002062:	048d80        	extui	a8, a8, 13, 1
    info->core = esp_cpu_get_core_id();
42002065:	0389      	s32i.n	a8, a3, 0
    info->exception = PANIC_EXCEPTION_FAULT;
42002067:	480c      	movi.n	a8, 4
42002069:	1389      	s32i.n	a8, a3, 4
    info->details = NULL;
4200206b:	080c      	movi.n	a8, 0
4200206d:	4389      	s32i.n	a8, a3, 16
    info->reason = "Unknown";
4200206f:	f89681        	l32r	a8, 420002c8 <_stext+0x2a8> (3c020904 <_flash_rodata_start+0x7e4>)
42002072:	2389      	s32i.n	a8, a3, 8
    info->pseudo_excause = panic_soc_check_pseudo_cause(frame, info) | pseudo_excause;
42002074:	03bd      	mov.n	a11, a3
42002076:	02ad      	mov.n	a10, a2
42002078:	1282a5        	call8	420148a4 <panic_soc_check_pseudo_cause>
4200207b:	208a40        	or	a8, a10, a4
4200207e:	748080        	extui	a8, a8, 0, 8
42002081:	204382        	s8i	a8, a3, 32
    if (info->pseudo_excause) {
42002084:	a88c      	beqz.n	a8, 42002092 <frame_to_panic_info+0x36>
        panic_soc_fill_info(frame, info);
42002086:	03bd      	mov.n	a11, a3
42002088:	02ad      	mov.n	a10, a2
4200208a:	0042a5        	call8	420024b4 <panic_soc_fill_info>
4200208d:	000286        	j	4200209b <frame_to_panic_info+0x3f>
42002090:	300000        	xor	a0, a0, a0
        panic_arch_fill_info(frame, info);
42002093:	2020b3        	lsi	f11, a0, 128
42002096:	6520a2        	l32i	a10, a0, 0x194
42002099:	3e          	.byte	0x3e
4200209a:	8c8100        	lsi	f0, a1, 0x230
    info->state = print_state;
4200209d:	82f8      	l32i.n	a15, a2, 32
4200209f:	290563        	lsi	f6, a5, 164
    info->frame = frame;
420020a2:	f01d73        	lsi	f7, a13, 0x3c0
420020a5:	000000        	ill

420020a8 <panic_handler>:
{
420020a8:	00a136        	entry	a1, 80
    panic_info_t info = { 0 };
420020ab:	4c2c      	movi.n	a12, 36
420020ad:	0b0c      	movi.n	a11, 0
420020af:	01ad      	mov.n	a10, a1
420020b1:	f89381        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420020b4:	0008e0        	callx8	a8
420020b7:	03eb60        	rsr.prid	a6
420020ba:	046d60        	extui	a6, a6, 13, 1
420020bd:	067d      	mov.n	a7, a6
    g_exc_frames[core_id] = frame;
420020bf:	f88481        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc948c0 <g_exc_frames>)
420020c2:	a08680        	addx4	a8, a6, a8
420020c5:	006822        	s32i	a2, a8, 0
    if (pseudo_excause) {
420020c8:	048316        	beqz	a3, 42002114 <panic_handler+0x6c>
        if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU0 && core_id == 1) {
420020cb:	02ad      	mov.n	a10, a2
420020cd:	127e65        	call8	420148b4 <panic_get_cause>
420020d0:	055a66        	bnei	a10, 5, 420020d9 <panic_handler+0x31>
420020d3:	021666        	bnei	a6, 1, 420020d9 <panic_handler+0x31>
420020d6:	ffff06        	j	420020d6 <panic_handler+0x2e>
        } else if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU1 && core_id == 0) {
420020d9:	02ad      	mov.n	a10, a2
420020db:	127da5        	call8	420148b4 <panic_get_cause>
420020de:	076a66        	bnei	a10, 6, 420020e9 <panic_handler+0x41>
420020e1:	47cc      	bnez.n	a7, 420020e9 <panic_handler+0x41>
420020e3:	ffff06        	j	420020e3 <panic_handler+0x3b>
420020e6:	000000        	ill
        } else if (panic_get_cause(frame) == PANIC_RSN_CACHEERR) {
420020e9:	20a220        	or	a10, a2, a2
420020ec:	127c65        	call8	420148b4 <panic_get_cause>
420020ef:	217a66        	bnei	a10, 7, 42002114 <panic_handler+0x6c>
            if (esp_cache_err_get_cpuid() == -1) {
420020f2:	ff9c25        	call8	42001ab4 <esp_cache_err_get_cpuid>
420020f5:	070a66        	bnei	a10, -1, 42002100 <panic_handler+0x58>
                if (core_id != 0) {
420020f8:	018716        	beqz	a7, 42002114 <panic_handler+0x6c>
420020fb:	ffff06        	j	420020fb <panic_handler+0x53>
420020fe:	250000        	extui	a0, a0, 16, 3
            } else if (core_id != esp_cache_err_get_cpuid()) {
42002101:	ff9b      	addi.n	a15, a15, 9
42002103:	0d1a77        	beq	a10, a7, 42002114 <panic_handler+0x6c>
                g_exc_frames[core_id] = NULL; // Only print the backtrace for the offending core
42002106:	f87281        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc948c0 <g_exc_frames>)
42002109:	a08680        	addx4	a8, a6, a8
4200210c:	090c      	movi.n	a9, 0
4200210e:	0899      	s32i.n	a9, a8, 0
                busy_wait();
42002110:	ffff06        	j	42002110 <panic_handler+0x68>
42002113:	a3a200        	movltz	a10, a2, a0
    esp_panic_handler_reconfigure_wdts(1000);
42002116:	65e8      	l32i.n	a14, a5, 24
42002118:	0cffc0        	lsi	f12, a15, 48
    esp_rom_delay_us(1);
4200211b:	811a      	add.n	a8, a1, a1
4200211d:	f7f9      	s32i.n	a15, a7, 60
4200211f:	0008e0        	callx8	a8
    for (uint32_t i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002122:	070c      	movi.n	a7, 0
42002124:	000406        	j	42002138 <panic_handler+0x90>
42002127:	670000        	lsi	f0, a0, 0x19c
        if (i != core_id) {
4200212a:	700817        	bnone	a8, a1, 4200219e <panic_handler+0xf6>
            esp_cpu_stall(i);
4200212d:	8120a7        	blt	a0, a10, 420020b2 <panic_handler+0xa>
42002130:	e0f875        	call12	41fe30b8 <_coredump_iram_end+0x1c611b8>
42002133:	0008      	l32i.n	a0, a0, 0
    for (uint32_t i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002135:	01c772        	addi	a7, a7, 1
42002138:	ed27b6        	bltui	a7, 2, 42002129 <panic_handler+0x81>
    esp_ipc_isr_stall_abort();
4200213b:	f87381        	l32r	a8, 42000308 <_stext+0x2e8> (403759e8 <esp_ipc_isr_stall_abort>)
4200213e:	0008e0        	callx8	a8
    RER(reg, dcr);
42002141:	f84f81        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
42002144:	406880        	rer	a8, a8
    if (esp_cpu_dbgr_is_attached()) {
42002147:	02e807        	bbsi	a8, 0, 4200214d <panic_handler+0xa5>
4200214a:	002486        	j	420021e0 <panic_handler+0x138>
        if (!(esp_ptr_executable(esp_cpu_pc_to_addr(panic_get_address(frame))) && (panic_get_address(frame) & 0xC0000000U))) {
4200214d:	20a220        	or	a10, a2, a2
42002150:	1275a5        	call8	420148ac <panic_get_address>
    return (void *)((pc & 0x3fffffffU) | 0x40000000U);
42002153:	11aae0        	slli	a10, a10, 2
42002156:	41a2a0        	srli	a10, a10, 2
42002159:	f7f581        	l32r	a8, 42000130 <_stext+0x110> (40000000 <_heap_end>)
4200215c:	20aa80        	or	a10, a10, a8
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
4200215f:	f85e91        	l32r	a9, 420002d8 <_stext+0x2b8> (be000000 <_rtc_reserved_end+0x5df00000>)
42002162:	809a90        	add	a9, a10, a9
42002165:	f85d81        	l32r	a8, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
42002168:	628890        	lsi	f9, a8, 0x188
4200216b:	880b      	addi.n	a8, a8, -1
4200216d:	608080        	neg	a8, a8
42002170:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
42002173:	f85bb1        	l32r	a11, 420002e0 <_stext+0x2c0> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
42002176:	baba      	add.n	a11, a10, a11
42002178:	f85b91        	l32r	a9, 420002e4 <_stext+0x2c4> (6ffff <UserFrameTotalSize+0x6feff>)
4200217b:	6299b0        	lsi	f11, a9, 0x188
4200217e:	990b      	addi.n	a9, a9, -1
42002180:	609090        	neg	a9, a9
42002183:	749090        	extui	a9, a9, 0, 8
42002186:	208890        	or	a8, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
42002189:	48dc      	bnez.n	a8, 420021a1 <panic_handler+0xf9>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
4200218b:	f85781        	l32r	a8, 420002e8 <_stext+0x2c8> (c0000000 <_rtc_reserved_end+0x5ff00000>)
4200218e:	8a8a      	add.n	a8, a10, a8
42002190:	f85791        	l32r	a9, 420002ec <_stext+0x2cc> (5ffff <UserFrameTotalSize+0x5feff>)
42002193:	0ab987        	bgeu	a9, a8, 420021a1 <panic_handler+0xf9>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
42002196:	f85681        	l32r	a8, 420002f0 <_stext+0x2d0> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
42002199:	aa8a      	add.n	a10, a10, a8
4200219b:	f85681        	l32r	a8, 420002f4 <_stext+0x2d4> (1fff <UserFrameTotalSize+0x1eff>)
4200219e:	0a38a7        	bltu	a8, a10, 420021ac <panic_handler+0x104>
420021a1:	02ad      	mov.n	a10, a2
420021a3:	1270a5        	call8	420148ac <panic_get_address>
420021a6:	f84b81        	l32r	a8, 420002d4 <_stext+0x2b4> (3fffffff <ets_rom_layout_p+0xe0003>)
420021a9:	0738a7        	bltu	a8, a10, 420021b4 <panic_handler+0x10c>
            panic_set_address(frame, (uint32_t)&_invalid_pc_placeholder);
420021ac:	f853b1        	l32r	a11, 420002f8 <_stext+0x2d8> (40374400 <_invalid_pc_placeholder>)
420021af:	02ad      	mov.n	a10, a2
420021b1:	1270a5        	call8	420148bc <panic_set_address>
        if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU0
420021b4:	02ad      	mov.n	a10, a2
420021b6:	126fe5        	call8	420148b4 <panic_get_cause>
420021b9:	075a26        	beqi	a10, 5, 420021c4 <panic_handler+0x11c>
                || panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU1
420021bc:	02ad      	mov.n	a10, a2
420021be:	126f65        	call8	420148b4 <panic_get_cause>
420021c1:	1b6a66        	bnei	a10, 6, 420021e0 <panic_handler+0x138>
            wdt_hal_write_protect_disable(&wdt0_context);
420021c4:	f84e71        	l32r	a7, 420002fc <_stext+0x2dc> (3fc91f10 <wdt0_context>)
420021c7:	20a770        	or	a10, a7, a7
420021ca:	f7c081        	l32r	a8, 420000cc <_stext+0xac> (40000de0 <wdt_hal_write_protect_disable>)
420021cd:	0008e0        	callx8	a8
            wdt_hal_handle_intr(&wdt0_context);
420021d0:	07ad      	mov.n	a10, a7
420021d2:	f84e81        	l32r	a8, 4200030c <_stext+0x2ec> (40000e10 <wdt_hal_handle_intr>)
420021d5:	0008e0        	callx8	a8
            wdt_hal_write_protect_enable(&wdt0_context);
420021d8:	07ad      	mov.n	a10, a7
420021da:	f7be81        	l32r	a8, 420000d4 <_stext+0xb4> (40000dec <wdt_hal_write_protect_enable>)
420021dd:	0008e0        	callx8	a8
    frame_to_panic_info(frame, &info, pseudo_excause);
420021e0:	20c330        	or	a12, a3, a3
420021e3:	20b110        	or	a11, a1, a1
420021e6:	02ad      	mov.n	a10, a2
420021e8:	ffe725        	call8	4200205c <frame_to_panic_info>
    esp_panic_handler(&info);
420021eb:	01ad      	mov.n	a10, a1
420021ed:	ffbae5        	call8	42001d9c <esp_panic_handler>
}
420021f0:	f01d      	retw.n
	...

420021f4 <print_state_for_core>:
{
420021f4:	004136        	entry	a1, 32
    if (!g_panic_abort) {
420021f7:	f81d81        	l32r	a8, 4200026c <_stext+0x24c> (3fc948b0 <g_panic_abort>)
420021fa:	000882        	l8ui	a8, a8, 0
420021fd:	00d856        	bnez	a8, 4200220e <print_state_for_core+0x1a>
        panic_print_registers(f, core);
42002200:	20b330        	or	a11, a3, a3
42002203:	02ad      	mov.n	a10, a2
42002205:	001a25        	call8	420023a8 <panic_print_registers>
        panic_print_str("\r\n");
42002208:	f842a1        	l32r	a10, 42000310 <_stext+0x2f0> (3c0208c4 <_flash_rodata_start+0x7a4>)
4200220b:	ffa7e5        	call8	42001c88 <panic_print_str>
    panic_print_backtrace(f, core);
4200220e:	20b330        	or	a11, a3, a3
42002211:	20a220        	or	a10, a2, a2
42002214:	003025        	call8	42002518 <panic_print_backtrace>
}
42002217:	000090        	retw
	...

4200221c <print_state>:
{
4200221c:	004136        	entry	a1, 32
4200221f:	02ad      	mov.n	a10, a2
    int err_core = f == g_exc_frames[0] ? 0 : 1;
42002221:	f82b81        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc948c0 <g_exc_frames>)
42002224:	0888      	l32i.n	a8, a8, 0
42002226:	c08820        	sub	a8, a8, a2
42002229:	120c      	movi.n	a2, 1
4200222b:	832880        	moveqz	a2, a8, a8
    print_state_for_core(f, err_core);
4200222e:	02bd      	mov.n	a11, a2
42002230:	fffc25        	call8	420021f4 <print_state_for_core>
    panic_print_str("\r\n");
42002233:	f837a1        	l32r	a10, 42000310 <_stext+0x2f0> (3c0208c4 <_flash_rodata_start+0x7a4>)
42002236:	ffa525        	call8	42001c88 <panic_print_str>
    for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002239:	070c      	movi.n	a7, 0
4200223b:	000706        	j	4200225b <print_state+0x3f>
        if (err_core != i && g_exc_frames[i] != NULL) {
4200223e:	171727        	beq	a7, a2, 42002259 <print_state+0x3d>
42002241:	f82381        	l32r	a8, 420002d0 <_stext+0x2b0> (3fc948c0 <g_exc_frames>)
42002244:	a08780        	addx4	a8, a7, a8
42002247:	0028a2        	l32i	a10, a8, 0
4200224a:	00ba16        	beqz	a10, 42002259 <print_state+0x3d>
            print_state_for_core(g_exc_frames[i], i);
4200224d:	20b770        	or	a11, a7, a7
42002250:	fffa25        	call8	420021f4 <print_state_for_core>
            panic_print_str("\r\n");
42002253:	f82fa1        	l32r	a10, 42000310 <_stext+0x2f0> (3c0208c4 <_flash_rodata_start+0x7a4>)
42002256:	ffa325        	call8	42001c88 <panic_print_str>
    for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002259:	771b      	addi.n	a7, a7, 1
4200225b:	df27a6        	blti	a7, 2, 4200223e <print_state+0x22>
}
4200225e:	f01d      	retw.n

42002260 <panic_restart>:

void __attribute__((noreturn)) panic_restart(void)
{
42002260:	004136        	entry	a1, 32
    // On the ESP32, cache error status can only be cleared by system reset
    if (esp_cache_err_get_cpuid() != -1) {
        esp_restart_noos_dig();
    }
#endif
    esp_restart_noos();
42002263:	f78f81        	l32r	a8, 420000a0 <_stext+0x80> (40375760 <esp_restart_noos>)
42002266:	0008e0        	callx8	a8
42002269:	000000        	ill

4200226c <esp_ipc_isr_init>:
{
4200226c:	004136        	entry	a1, 32
    asm volatile (
4200226f:	03eb70        	rsr.prid	a7
42002272:	047d70        	extui	a7, a7, 13, 1
    esp_ipc_isr_port_init(cpuid);
42002275:	20a770        	or	a10, a7, a7
42002278:	000125        	call8	4200228c <esp_ipc_isr_port_init>
    if (cpuid != 0) {
4200227b:	00a716        	beqz	a7, 42002289 <esp_ipc_isr_init+0x1d>
        s_stall_state = STALL_STATE_RUNNING;
4200227e:	f82581        	l32r	a8, 42000314 <_stext+0x2f4> (3fc948c8 <s_stall_state>)
42002281:	01a092        	movi	a9, 1
42002284:	0020c0        	memw
42002287:	0899      	s32i.n	a9, a8, 0
}
42002289:	f01d      	retw.n
	...

4200228c <esp_ipc_isr_port_init>:
#include "esp_intr_alloc.h"
#include "esp_attr.h"
#include "sdkconfig.h"

void esp_ipc_isr_port_init(const int cpuid)
{
4200228c:	004136        	entry	a1, 32
    uint32_t intr_source = ETS_FROM_CPU_INTR2_SOURCE + cpuid; // ETS_FROM_CPU_INTR2_SOURCE and ETS_FROM_CPU_INTR3_SOURCE
4200228f:	51c272        	addi	a7, a2, 81
    ESP_INTR_DISABLE(ETS_IPC_ISR_INUM);
42002292:	ca1c      	movi.n	a10, 28
42002294:	f7dc81        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
42002297:	0008e0        	callx8	a8
    esp_rom_route_intr_matrix(cpuid, intr_source, ETS_IPC_ISR_INUM);
4200229a:	cc1c      	movi.n	a12, 28
4200229c:	07bd      	mov.n	a11, a7
4200229e:	02ad      	mov.n	a10, a2
420022a0:	f78e81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420022a3:	0008e0        	callx8	a8
    ESP_INTR_ENABLE(ETS_IPC_ISR_INUM);
420022a6:	ca1c      	movi.n	a10, 28
420022a8:	f7d881        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
420022ab:	0008e0        	callx8	a8
}
420022ae:	f01d      	retw.n

420022b0 <print_debug_exception_details>:
    panic_print_str(" ");
    panic_print_hex(*(pepc + 2));
}

static void print_debug_exception_details(const void *f)
{
420022b0:	004136        	entry	a1, 32
    int debug_rsn;
    asm("rsr.debugcause %0":"=r"(debug_rsn));
420022b3:	03e970        	rsr.debugcause	a7
    panic_print_str("Debug exception reason: ");
420022b6:	f818a1        	l32r	a10, 42000318 <_stext+0x2f8> (3c02090c <_flash_rodata_start+0x7ec>)
420022b9:	ff9ce5        	call8	42001c88 <panic_print_str>
    if (debug_rsn & XCHAL_DEBUGCAUSE_ICOUNT_MASK) {
420022bc:	056707        	bbci	a7, 0, 420022c5 <print_debug_exception_details+0x15>
        panic_print_str("SingleStep ");
420022bf:	f817a1        	l32r	a10, 4200031c <_stext+0x2fc> (3c020928 <_flash_rodata_start+0x808>)
420022c2:	ff9c65        	call8	42001c88 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_IBREAK_MASK) {
420022c5:	056717        	bbci	a7, 1, 420022ce <print_debug_exception_details+0x1e>
        panic_print_str("HwBreakpoint ");
420022c8:	f816a1        	l32r	a10, 42000320 <_stext+0x300> (3c020934 <_flash_rodata_start+0x814>)
420022cb:	ff9be5        	call8	42001c88 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DBREAK_MASK) {
420022ce:	116727        	bbci	a7, 2, 420022e3 <print_debug_exception_details+0x33>
        //Unlike what the ISA manual says, this core seemingly distinguishes from a DBREAK
        //reason caused by watchdog 0 and one caused by watchdog 1 by setting bit 8 of the
        //debugcause if the cause is watchpoint 1 and clearing it if it's watchpoint 0.
        if (debug_rsn & (1 << 8)) {
420022d1:	086787        	bbci	a7, 8, 420022dd <print_debug_exception_details+0x2d>
            const char *name = pcTaskGetName(xTaskGetCurrentTaskHandleForCore(core));
            panic_print_str("Stack canary watchpoint triggered (");
            panic_print_str(name);
            panic_print_str(") ");
#else
            panic_print_str("Watchpoint 1 triggered ");
420022d4:	f814a1        	l32r	a10, 42000324 <_stext+0x304> (3c020944 <_flash_rodata_start+0x824>)
420022d7:	ff9b25        	call8	42001c88 <panic_print_str>
420022da:	000146        	j	420022e3 <print_debug_exception_details+0x33>
#endif
        } else {
            panic_print_str("Watchpoint 0 triggered ");
420022dd:	f812a1        	l32r	a10, 42000328 <_stext+0x308> (3c02095c <_flash_rodata_start+0x83c>)
420022e0:	ff9a65        	call8	42001c88 <panic_print_str>
        }
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAK_MASK) {
420022e3:	056737        	bbci	a7, 3, 420022ec <print_debug_exception_details+0x3c>
        panic_print_str("BREAK instr ");
420022e6:	f811a1        	l32r	a10, 4200032c <_stext+0x30c> (3c020974 <_flash_rodata_start+0x854>)
420022e9:	ff99e5        	call8	42001c88 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAKN_MASK) {
420022ec:	056747        	bbci	a7, 4, 420022f5 <print_debug_exception_details+0x45>
        panic_print_str("BREAKN instr ");
420022ef:	f810a1        	l32r	a10, 42000330 <_stext+0x310> (3c020984 <_flash_rodata_start+0x864>)
420022f2:	ff9965        	call8	42001c88 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DEBUGINT_MASK) {
420022f5:	056757        	bbci	a7, 5, 420022fe <print_debug_exception_details+0x4e>
        panic_print_str("DebugIntr ");
420022f8:	f80fa1        	l32r	a10, 42000334 <_stext+0x314> (3c020994 <_flash_rodata_start+0x874>)
420022fb:	ff98e5        	call8	42001c88 <panic_print_str>
    }
}
420022fe:	f01d      	retw.n

42002300 <print_illegal_instruction_details>:
{
42002300:	004136        	entry	a1, 32
    uint32_t epc = frame->pc;
42002303:	1288      	l32i.n	a8, a2, 4
    epc = (epc & ~0x3) - 4;
42002305:	c97c      	movi.n	a9, -4
42002307:	108890        	and	a8, a8, a9
4200230a:	789a      	add.n	a7, a8, a9
    if (epc < SOC_IROM_MASK_LOW || epc >= SOC_IROM_HIGH) {
4200230c:	f80b91        	l32r	a9, 42000338 <_stext+0x318> (bffffffc <_rtc_reserved_end+0x5feffffc>)
4200230f:	889a      	add.n	a8, a8, a9
42002311:	f80a91        	l32r	a9, 4200033c <_stext+0x31c> (3ffffff <UserFrameTotalSize+0x3fffeff>)
42002314:	383987        	bltu	a9, a8, 42002350 <print_illegal_instruction_details+0x50>
    panic_print_str("Memory dump at 0x");
42002317:	f80aa1        	l32r	a10, 42000340 <_stext+0x320> (3c0209a0 <_flash_rodata_start+0x880>)
4200231a:	ff96e5        	call8	42001c88 <panic_print_str>
    panic_print_hex(epc);
4200231d:	07ad      	mov.n	a10, a7
4200231f:	ff9965        	call8	42001cb4 <panic_print_hex>
    panic_print_str(": ");
42002322:	f808a1        	l32r	a10, 42000344 <_stext+0x324> (3c0209b4 <_flash_rodata_start+0x894>)
42002325:	ff9625        	call8	42001c88 <panic_print_str>
    panic_print_hex(*pepc);
42002328:	0020c0        	memw
4200232b:	0027a2        	l32i	a10, a7, 0
4200232e:	ff9865        	call8	42001cb4 <panic_print_hex>
    panic_print_str(" ");
42002331:	f80521        	l32r	a2, 42000348 <_stext+0x328> (3c020a18 <_flash_rodata_start+0x8f8>)
42002334:	20a220        	or	a10, a2, a2
42002337:	ff9525        	call8	42001c88 <panic_print_str>
    panic_print_hex(*(pepc + 1));
4200233a:	0020c0        	memw
4200233d:	0127a2        	l32i	a10, a7, 4
42002340:	ff9725        	call8	42001cb4 <panic_print_hex>
    panic_print_str(" ");
42002343:	02ad      	mov.n	a10, a2
42002345:	ff9425        	call8	42001c88 <panic_print_str>
    panic_print_hex(*(pepc + 2));
42002348:	0020c0        	memw
4200234b:	27a8      	l32i.n	a10, a7, 8
4200234d:	ff9665        	call8	42001cb4 <panic_print_hex>
}
42002350:	f01d      	retw.n
	...

42002354 <print_cache_err_details>:
    panic_print_str(")\r\n");
}
#endif

static inline void print_cache_err_details(const void *f)
{
42002354:	006136        	entry	a1, 48
    esp_cache_err_info_t err = {};
42002357:	cc0c      	movi.n	a12, 12
42002359:	00a0b2        	movi	a11, 0
4200235c:	01ad      	mov.n	a10, a1
4200235e:	f7e881        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42002361:	0008e0        	callx8	a8
    esp_cache_err_get_panic_info(&err);
42002364:	01ad      	mov.n	a10, a1
42002366:	ff5565        	call8	420018bc <esp_cache_err_get_panic_info>

    if (err.err_str) {
42002369:	01a8      	l32i.n	a10, a1, 0
4200236b:	5aac      	beqz.n	a10, 42002394 <print_cache_err_details+0x40>
        panic_print_str(err.err_str);
4200236d:	ff91a5        	call8	42001c88 <panic_print_str>
        if (err.vaddr) {
42002370:	1188      	l32i.n	a8, a1, 4
42002372:	00a816        	beqz	a8, 42002380 <print_cache_err_details+0x2c>
            panic_print_str(", error address: 0x");
42002375:	f7f5a1        	l32r	a10, 4200034c <_stext+0x32c> (3c0209b8 <_flash_rodata_start+0x898>)
42002378:	ff90e5        	call8	42001c88 <panic_print_str>
            panic_print_hex(err.vaddr);
4200237b:	11a8      	l32i.n	a10, a1, 4
4200237d:	ff9365        	call8	42001cb4 <panic_print_hex>
        }
        if (err.size) {
42002380:	022182        	l32i	a8, a1, 8
42002383:	016816        	beqz	a8, 4200239d <print_cache_err_details+0x49>
            panic_print_str(", error size: 0x");
42002386:	f7f2a1        	l32r	a10, 42000350 <_stext+0x330> (3c0209cc <_flash_rodata_start+0x8ac>)
42002389:	ff8fe5        	call8	42001c88 <panic_print_str>
            panic_print_hex(err.size);
4200238c:	21a8      	l32i.n	a10, a1, 8
4200238e:	ff9265        	call8	42001cb4 <panic_print_hex>
42002391:	000206        	j	4200239d <print_cache_err_details+0x49>
        }
    } else {
        // Default to cache disabled message if no specific error is found
        panic_print_str("Cache disabled but cached memory region accessed");
42002394:	f7f0a1        	l32r	a10, 42000354 <_stext+0x334> (3c0209e0 <_flash_rodata_start+0x8c0>)
42002397:	201110        	or	a1, a1, a1
4200239a:	ff8ee5        	call8	42001c88 <panic_print_str>
    }
    panic_print_str("\r\n");
4200239d:	f7eea1        	l32r	a10, 42000358 <_stext+0x338> (3c0208c4 <_flash_rodata_start+0x7a4>)
420023a0:	ff8e65        	call8	42001c88 <panic_print_str>
}
420023a3:	f01d      	retw.n
420023a5:	000000        	ill

420023a8 <panic_print_registers>:
{
420023a8:	010136        	entry	a1, 128
    const char *sdesc[] = {
420023ab:	60a0c2        	movi	a12, 96
420023ae:	f7ebb1        	l32r	a11, 4200035c <_stext+0x33c> (3c026f3c <g_startup_fn+0x8>)
420023b1:	20a110        	or	a10, a1, a1
420023b4:	f71d81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420023b7:	0008e0        	callx8	a8
    panic_print_str("Core ");
420023ba:	f7e9a1        	l32r	a10, 42000360 <_stext+0x340> (3c020a14 <_flash_rodata_start+0x8f4>)
420023bd:	ff8ca5        	call8	42001c88 <panic_print_str>
    panic_print_dec(core);
420023c0:	03ad      	mov.n	a10, a3
420023c2:	ff91e5        	call8	42001ce0 <panic_print_dec>
    panic_print_str(" register dump:");
420023c5:	f7e7a1        	l32r	a10, 42000364 <_stext+0x344> (3c020a1c <_flash_rodata_start+0x8fc>)
420023c8:	ff8be5        	call8	42001c88 <panic_print_str>
    for (int x = 0; x < 24; x += 4) {
420023cb:	050c      	movi.n	a5, 0
420023cd:	000f06        	j	4200240d <panic_print_registers+0x65>
        panic_print_str("\r\n");
420023d0:	f7e2a1        	l32r	a10, 42000358 <_stext+0x338> (3c0208c4 <_flash_rodata_start+0x7a4>)
420023d3:	ff8b65        	call8	42001c88 <panic_print_str>
        for (int y = 0; y < 4; y++) {
420023d6:	070c      	movi.n	a7, 0
420023d8:	000b06        	j	42002408 <panic_print_registers+0x60>
420023db:	000000        	ill
            if (sdesc[x + y][0] != 0) {
420023de:	657a      	add.n	a6, a5, a7
420023e0:	a08610        	addx4	a8, a6, a1
420023e3:	08a8      	l32i.n	a10, a8, 0
420023e5:	000a82        	l8ui	a8, a10, 0
420023e8:	01a816        	beqz	a8, 42002406 <panic_print_registers+0x5e>
                panic_print_str(sdesc[x + y]);
420023eb:	ff89e5        	call8	42001c88 <panic_print_str>
                panic_print_str(": 0x");
420023ee:	f7dea1        	l32r	a10, 42000368 <_stext+0x348> (3c020a58 <_flash_rodata_start+0x938>)
420023f1:	ff8965        	call8	42001c88 <panic_print_str>
                panic_print_hex(regs[x + y + 1]);
420023f4:	01c662        	addi	a6, a6, 1
420023f7:	a06620        	addx4	a6, a6, a2
420023fa:	0026a2        	l32i	a10, a6, 0
420023fd:	ff8b65        	call8	42001cb4 <panic_print_hex>
                panic_print_str("  ");
42002400:	f7dba1        	l32r	a10, 4200036c <_stext+0x34c> (3c020a2c <_flash_rodata_start+0x90c>)
42002403:	ff8865        	call8	42001c88 <panic_print_str>
        for (int y = 0; y < 4; y++) {
42002406:	771b      	addi.n	a7, a7, 1
42002408:	d247a6        	blti	a7, 4, 420023de <panic_print_registers+0x36>
    for (int x = 0; x < 24; x += 4) {
4200240b:	554b      	addi.n	a5, a5, 4
4200240d:	17a082        	movi	a8, 23
42002410:	bca857        	bge	a8, a5, 420023d0 <panic_print_registers+0x28>
    if (xPortInterruptedFromISRContext()
42002413:	f7dc81        	l32r	a8, 42000384 <_stext+0x364> (40376888 <xPortInterruptedFromISRContext>)
42002416:	0008e0        	callx8	a8
42002419:	060a16        	beqz	a10, 4200247d <panic_print_registers+0xd5>
            && ((core == 0 && frame->exccause == PANIC_RSN_INTWDT_CPU0) ||
4200241c:	43cc      	bnez.n	a3, 42002424 <panic_print_registers+0x7c>
4200241e:	142282        	l32i	a8, a2, 80
42002421:	085826        	beqi	a8, 5, 4200242d <panic_print_registers+0x85>
42002424:	551366        	bnei	a3, 1, 4200247d <panic_print_registers+0xd5>
                (core == 1 && frame->exccause == PANIC_RSN_INTWDT_CPU1))
42002427:	142282        	l32i	a8, a2, 80
4200242a:	4f6866        	bnei	a8, 6, 4200247d <panic_print_registers+0xd5>
        panic_print_str("\r\n");
4200242d:	f7caa1        	l32r	a10, 42000358 <_stext+0x338> (3c0208c4 <_flash_rodata_start+0x7a4>)
42002430:	ff8565        	call8	42001c88 <panic_print_str>
        panic_print_str("Core ");
42002433:	f7cba1        	l32r	a10, 42000360 <_stext+0x340> (3c020a14 <_flash_rodata_start+0x8f4>)
42002436:	ff8525        	call8	42001c88 <panic_print_str>
        panic_print_dec(core);
42002439:	20a330        	or	a10, a3, a3
4200243c:	ff8a25        	call8	42001ce0 <panic_print_dec>
        panic_print_str(" was running in ISR context:\r\n");
4200243f:	f7cca1        	l32r	a10, 42000370 <_stext+0x350> (3c020a30 <_flash_rodata_start+0x910>)
42002442:	ff8465        	call8	42001c88 <panic_print_str>
        __asm__("rsr.epc1 %0" : "=a"(__value));
42002445:	03b170        	rsr.epc1	a7
        panic_print_str("EPC1    : 0x");
42002448:	f7cba1        	l32r	a10, 42000374 <_stext+0x354> (3c020a50 <_flash_rodata_start+0x930>)
4200244b:	ff83e5        	call8	42001c88 <panic_print_str>
        panic_print_hex(__value);
4200244e:	07ad      	mov.n	a10, a7
42002450:	ff8625        	call8	42001cb4 <panic_print_hex>
        __asm__("rsr.epc2 %0" : "=a"(__value));
42002453:	03b270        	rsr.epc2	a7
        panic_print_str("  EPC2    : 0x");
42002456:	f7c8a1        	l32r	a10, 42000378 <_stext+0x358> (3c020a60 <_flash_rodata_start+0x940>)
42002459:	ff82e5        	call8	42001c88 <panic_print_str>
        panic_print_hex(__value);
4200245c:	07ad      	mov.n	a10, a7
4200245e:	ff8565        	call8	42001cb4 <panic_print_hex>
        __asm__("rsr.epc3 %0" : "=a"(__value));
42002461:	03b370        	rsr.epc3	a7
        panic_print_str("  EPC3    : 0x");
42002464:	f7c6a1        	l32r	a10, 4200037c <_stext+0x35c> (3c020a70 <_flash_rodata_start+0x950>)
42002467:	ff8225        	call8	42001c88 <panic_print_str>
        panic_print_hex(__value);
4200246a:	07ad      	mov.n	a10, a7
4200246c:	ff8465        	call8	42001cb4 <panic_print_hex>
        __asm__("rsr.epc4 %0" : "=a"(__value));
4200246f:	03b470        	rsr.epc4	a7
        panic_print_str("  EPC4    : 0x");
42002472:	f7c3a1        	l32r	a10, 42000380 <_stext+0x360> (3c020a80 <_flash_rodata_start+0x960>)
42002475:	ff8125        	call8	42001c88 <panic_print_str>
        panic_print_hex(__value);
42002478:	07ad      	mov.n	a10, a7
4200247a:	ff83a5        	call8	42001cb4 <panic_print_hex>
}
4200247d:	f01d      	retw.n
	...

42002480 <panic_arch_fill_info>:

void panic_arch_fill_info(void *f, panic_info_t *info)
{
42002480:	004136        	entry	a1, 32
        "LoadProhibited", "StoreProhibited", "res", "res",
        "Cp0Dis", "Cp1Dis", "Cp2Dis", "Cp3Dis",
        "Cp4Dis", "Cp5Dis", "Cp6Dis", "Cp7Dis"
    };

    if (frame->exccause < (sizeof(reason) / sizeof(char *))) {
42002483:	142282        	l32i	a8, a2, 80
42002486:	792c      	movi.n	a9, 39
42002488:	0c3987        	bltu	a9, a8, 42002498 <panic_arch_fill_info+0x18>
        info->reason = (reason[frame->exccause]);
4200248b:	f7bf91        	l32r	a9, 42000388 <_stext+0x368> (3c026fbc <reason$1>)
4200248e:	a08890        	addx4	a8, a8, a9
42002491:	0888      	l32i.n	a8, a8, 0
42002493:	2389      	s32i.n	a8, a3, 8
42002495:	000106        	j	4200249d <panic_arch_fill_info+0x1d>
    } else {
        info->reason = "Unknown";
42002498:	f7bd81        	l32r	a8, 4200038c <_stext+0x36c> (3c020904 <_flash_rodata_start+0x7e4>)
4200249b:	2389      	s32i.n	a8, a3, 8
    }

    info->description = "Exception was unhandled.";
4200249d:	f7bc81        	l32r	a8, 42000390 <_stext+0x370> (3c020bb0 <_flash_rodata_start+0xa90>)
420024a0:	3389      	s32i.n	a8, a3, 12
    if (frame->exccause == EXCCAUSE_ILLEGAL) {
420024a2:	142282        	l32i	a8, a2, 80
420024a5:	38cc      	bnez.n	a8, 420024ac <panic_arch_fill_info+0x2c>
        info->details = print_illegal_instruction_details;
420024a7:	f7bb81        	l32r	a8, 42000394 <_stext+0x374> (42002300 <print_illegal_instruction_details>)
420024aa:	4389      	s32i.n	a8, a3, 16
    }

    info->addr = ((void *)((XtExcFrame *) frame)->pc);
420024ac:	1288      	l32i.n	a8, a2, 4
420024ae:	6389      	s32i.n	a8, a3, 24
}
420024b0:	f01d      	retw.n
	...

420024b4 <panic_soc_fill_info>:
    // Currently only needed on riscv targets
    return false;
}

void panic_soc_fill_info(void *f, panic_info_t *info)
{
420024b4:	004136        	entry	a1, 32
    // [refactor-todo] this should be in the common port panic_handler.c, once
    // these special exceptions are supported in there.
    XtExcFrame *frame = (XtExcFrame *) f;
    if (frame->exccause == PANIC_RSN_INTWDT_CPU0) {
420024b7:	142282        	l32i	a8, a2, 80
420024ba:	0a5866        	bnei	a8, 5, 420024c8 <panic_soc_fill_info+0x14>
        info->core = 0;
420024bd:	080c      	movi.n	a8, 0
420024bf:	0389      	s32i.n	a8, a3, 0
        info->exception = PANIC_EXCEPTION_IWDT;
420024c1:	180c      	movi.n	a8, 1
420024c3:	1389      	s32i.n	a8, a3, 4
420024c5:	0005c6        	j	420024e0 <panic_soc_fill_info+0x2c>
    } else if (frame->exccause == PANIC_RSN_INTWDT_CPU1) {
420024c8:	096866        	bnei	a8, 6, 420024d5 <panic_soc_fill_info+0x21>
        info->core = 1;
420024cb:	180c      	movi.n	a8, 1
420024cd:	0389      	s32i.n	a8, a3, 0
        info->exception = PANIC_EXCEPTION_IWDT;
420024cf:	1389      	s32i.n	a8, a3, 4
420024d1:	0002c6        	j	420024e0 <panic_soc_fill_info+0x2c>
420024d4:	786600        	lsi	f0, a6, 0x1e0
    } else if (frame->exccause == PANIC_RSN_CACHEERR) {
420024d7:	111007        	beq	a0, a0, 420024ec <panic_soc_fill_info+0x38>
        info->core =  esp_cache_err_get_cpuid();
420024da:	5da520        	lsi	f2, a5, 0x174
420024dd:	ff          	.byte	0xff
420024de:	03a9      	s32i.n	a10, a3, 0
        "Interrupt wdt timeout on CPU0",
        "Interrupt wdt timeout on CPU1",
        "Cache error",
    };

    info->reason = pseudo_reason[0];
420024e0:	f7ae81        	l32r	a8, 42000398 <_stext+0x378> (3c020bcc <_flash_rodata_start+0xaac>)
420024e3:	2389      	s32i.n	a8, a3, 8
    info->description = NULL;
420024e5:	080c      	movi.n	a8, 0
420024e7:	3389      	s32i.n	a8, a3, 12

    if (frame->exccause <= PANIC_RSN_MAX) {
420024e9:	142282        	l32i	a8, a2, 80
420024ec:	0988e6        	bgei	a8, 8, 420024f9 <panic_soc_fill_info+0x45>
        info->reason = pseudo_reason[frame->exccause];
420024ef:	f7ab91        	l32r	a9, 4200039c <_stext+0x37c> (3c026f9c <pseudo_reason$0>)
420024f2:	a08890        	addx4	a8, a8, a9
420024f5:	0888      	l32i.n	a8, a8, 0
420024f7:	2389      	s32i.n	a8, a3, 8
    }

    if (frame->exccause == PANIC_RSN_DEBUGEXCEPTION) {
420024f9:	142282        	l32i	a8, a2, 80
420024fc:	091866        	bnei	a8, 1, 42002509 <panic_soc_fill_info+0x55>
        info->details = print_debug_exception_details;
420024ff:	f7a881        	l32r	a8, 420003a0 <_stext+0x380> (420022b0 <print_debug_exception_details>)
42002502:	4389      	s32i.n	a8, a3, 16
        info->exception = PANIC_EXCEPTION_DEBUG;
42002504:	080c      	movi.n	a8, 0
42002506:	016382        	s32i	a8, a3, 4
    }

    //MV note: ESP32S3 PMS handling?
    if (frame->exccause == PANIC_RSN_CACHEERR) {
42002509:	142282        	l32i	a8, a2, 80
4200250c:	047866        	bnei	a8, 7, 42002514 <panic_soc_fill_info+0x60>
            info->details = print_memprot_err_details;
            info->reason = "Memory protection fault";
        } else
#endif
        {
            info->details = print_cache_err_details;
4200250f:	f7a581        	l32r	a8, 420003a4 <_stext+0x384> (42002354 <print_cache_err_details>)
42002512:	4389      	s32i.n	a8, a3, 16
        }
    }
}
42002514:	f01d      	retw.n
	...

42002518 <panic_print_backtrace>:
{
    ((XtExcFrame *)f)->pc = addr;
}

void panic_print_backtrace(const void *f, int core)
{
42002518:	006136        	entry	a1, 48
    XtExcFrame *xt_frame = (XtExcFrame *) f;
    esp_backtrace_frame_t frame = {.pc = xt_frame->pc, .sp = xt_frame->a1, .next_pc = xt_frame->a0, .exc_frame = xt_frame};
4200251b:	1288      	l32i.n	a8, a2, 4
4200251d:	0189      	s32i.n	a8, a1, 0
4200251f:	4288      	l32i.n	a8, a2, 16
42002521:	1189      	s32i.n	a8, a1, 4
42002523:	3288      	l32i.n	a8, a2, 12
42002525:	2189      	s32i.n	a8, a1, 8
42002527:	3129      	s32i.n	a2, a1, 12
    esp_backtrace_print_from_frame(100, &frame, true);
42002529:	1c0c      	movi.n	a12, 1
4200252b:	01bd      	mov.n	a11, a1
4200252d:	64a0a2        	movi	a10, 100
42002530:	f79e81        	l32r	a8, 420003a8 <_stext+0x388> (40375b50 <esp_backtrace_print_from_frame>)
42002533:	0008e0        	callx8	a8
}
42002536:	f01d      	retw.n

42002538 <esp_ipc_init>:
 * esp_ipc_call_blocking.
 */
static void esp_ipc_init(void) __attribute__((constructor));

static void esp_ipc_init(void)
{
42002538:	008136        	entry	a1, 64
    char task_name[] = "ipcX"; // up to 10 ipc tasks/cores (0-9)
4200253b:	f79c81        	l32r	a8, 420003ac <_stext+0x38c> (3c020f74 <_flash_rodata_start+0xe54>)
4200253e:	0898      	l32i.n	a9, a8, 0
42002540:	040882        	l8ui	a8, a8, 4
42002543:	4199      	s32i.n	a9, a1, 16
42002545:	144182        	s8i	a8, a1, 20

    for (int i = 0; i < CONFIG_FREERTOS_NUMBER_OF_CORES; ++i) {
42002548:	070c      	movi.n	a7, 0
4200254a:	001d86        	j	420025c4 <esp_ipc_init+0x8c>
        task_name[3] = i + (char)'0';
4200254d:	30c782        	addi	a8, a7, 48
42002550:	134182        	s8i	a8, a1, 19
        s_ipc_mutex[i] = xSemaphoreCreateMutexStatic(&s_ipc_mutex_buffer[i]);
42002553:	905770        	addx2	a5, a7, a7
42002556:	1145d0        	slli	a4, a5, 3
42002559:	f0b550        	subx8	a11, a5, a5
4200255c:	f79581        	l32r	a8, 420003b0 <_stext+0x390> (3fc92874 <s_ipc_mutex_buffer>)
4200255f:	a0bb80        	addx4	a11, a11, a8
42002562:	1a0c      	movi.n	a10, 1
42002564:	f79c81        	l32r	a8, 420003d4 <_stext+0x3b4> (40379c68 <xQueueCreateMutexStatic>)
42002567:	0008e0        	callx8	a8
4200256a:	1167e0        	slli	a6, a7, 2
4200256d:	f79181        	l32r	a8, 420003b4 <_stext+0x394> (3fc9490c <s_ipc_mutex>)
42002570:	a08780        	addx4	a8, a7, a8
42002573:	08a9      	s32i.n	a10, a8, 0
        s_ipc_ack[i] = xSemaphoreCreateBinaryStatic(&s_ipc_ack_buffer[i]);
42002575:	c04450        	sub	a4, a4, a5
42002578:	3e0c      	movi.n	a14, 3
4200257a:	f78fd1        	l32r	a13, 420003b8 <_stext+0x398> (3fc927cc <s_ipc_ack_buffer>)
4200257d:	a0d4d0        	addx4	a13, a4, a13
42002580:	0c0c      	movi.n	a12, 0
42002582:	0cbd      	mov.n	a11, a12
42002584:	1a0c      	movi.n	a10, 1
42002586:	f79481        	l32r	a8, 420003d8 <_stext+0x3b8> (403799bc <xQueueGenericCreateStatic>)
42002589:	0008e0        	callx8	a8
4200258c:	f78c81        	l32r	a8, 420003bc <_stext+0x39c> (3fc94904 <s_ipc_ack>)
4200258f:	886a      	add.n	a8, a8, a6
42002591:	08a9      	s32i.n	a10, a8, 0
        BaseType_t res = xTaskCreatePinnedToCore(ipc_task, task_name, IPC_STACK_SIZE, (void*) i,
42002593:	0179      	s32i.n	a7, a1, 0
42002595:	f78af1        	l32r	a15, 420003c0 <_stext+0x3a0> (3fc94914 <s_ipc_task_handle>)
42002598:	ff6a      	add.n	a15, a15, a6
4200259a:	8e1c      	movi.n	a14, 24
4200259c:	07dd      	mov.n	a13, a7
4200259e:	00a5c2        	movi	a12, 0x500
420025a1:	10c1b2        	addi	a11, a1, 16
420025a4:	f788a1        	l32r	a10, 420003c4 <_stext+0x3a4> (40375ce8 <ipc_task>)
420025a7:	f78d81        	l32r	a8, 420003dc <_stext+0x3bc> (4037c5a4 <xTaskCreatePinnedToCore>)
420025aa:	0008e0        	callx8	a8
                                                 IPC_MAX_PRIORITY, &s_ipc_task_handle[i], i);
        assert(res == pdTRUE);
420025ad:	111a26        	beqi	a10, 1, 420025c2 <esp_ipc_init+0x8a>
420025b0:	f786d1        	l32r	a13, 420003c8 <_stext+0x3a8> (3c020f64 <_flash_rodata_start+0xe44>)
420025b3:	f786c1        	l32r	a12, 420003cc <_stext+0x3ac> (3c027068 <__func__$1>)
420025b6:	74a0b2        	movi	a11, 116
420025b9:	f785a1        	l32r	a10, 420003d0 <_stext+0x3b0> (3c020f58 <_flash_rodata_start+0xe38>)
420025bc:	f6c181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420025bf:	0008e0        	callx8	a8
    for (int i = 0; i < CONFIG_FREERTOS_NUMBER_OF_CORES; ++i) {
420025c2:	771b      	addi.n	a7, a7, 1
420025c4:	8527a6        	blti	a7, 2, 4200254d <esp_ipc_init+0x15>
        (void)res;
    }
}
420025c7:	f01d      	retw.n
420025c9:	000000        	ill

420025cc <esp_ipc_call_nonblocking>:
{
    return esp_ipc_call_and_wait(cpu_id, func, arg, IPC_WAIT_FOR_END);
}

esp_err_t esp_ipc_call_nonblocking(uint32_t cpu_id, esp_ipc_func_t func, void* arg)
{
420025cc:	004136        	entry	a1, 32
    if (cpu_id >= portNUM_PROCESSORS || s_ipc_task_handle[cpu_id] == NULL) {
420025cf:	0222b6        	bltui	a2, 2, 420025d5 <esp_ipc_call_nonblocking+0x9>
420025d2:	0022c6        	j	42002661 <esp_ipc_call_nonblocking+0x95>
420025d5:	f77a81        	l32r	a8, 420003c0 <_stext+0x3a0> (3fc94914 <s_ipc_task_handle>)
420025d8:	a08280        	addx4	a8, a2, a8
420025db:	002882        	l32i	a8, a8, 0
420025de:	086816        	beqz	a8, 42002668 <esp_ipc_call_nonblocking+0x9c>
420025e1:	03eb80        	rsr.prid	a8
420025e4:	048d80        	extui	a8, a8, 13, 1
        return ESP_ERR_INVALID_ARG;
    }
    if (cpu_id == xPortGetCoreID() && xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
420025e7:	089287        	bne	a2, a8, 420025f3 <esp_ipc_call_nonblocking+0x27>
420025ea:	f78081        	l32r	a8, 420003ec <_stext+0x3cc> (4037ba2c <xTaskGetSchedulerState>)
420025ed:	0008e0        	callx8	a8
420025f0:	7c2a66        	bnei	a10, 2, 42002670 <esp_ipc_call_nonblocking+0xa4>
        return ESP_ERR_INVALID_STATE;
    }

    // Since it can be called from an interrupt or Scheduler is Suspened, it can not wait for a mutex to be released.
    if (esp_cpu_compare_and_set((volatile uint32_t *)&s_no_block_func[cpu_id], 0, (uint32_t)func)) {
420025f3:	03cd      	mov.n	a12, a3
420025f5:	00a0b2        	movi	a11, 0
420025f8:	f77aa1        	l32r	a10, 420003e0 <_stext+0x3c0> (3fc948e4 <s_no_block_func>)
420025fb:	a0a2a0        	addx4	a10, a2, a10
420025fe:	f77c81        	l32r	a8, 420003f0 <_stext+0x3d0> (403781a8 <esp_cpu_compare_and_set>)
42002601:	0008e0        	callx8	a8
42002604:	06ea16        	beqz	a10, 42002676 <esp_ipc_call_nonblocking+0xaa>
        s_no_block_func_arg[cpu_id] = arg;
42002607:	f77781        	l32r	a8, 420003e4 <_stext+0x3c4> (3fc948d8 <s_no_block_func_arg>)
4200260a:	a08280        	addx4	a8, a2, a8
4200260d:	0020c0        	memw
42002610:	0849      	s32i.n	a4, a8, 0
        s_no_block_func_and_arg_are_ready[cpu_id] = true;
42002612:	f77581        	l32r	a8, 420003e8 <_stext+0x3c8> (3fc948e0 <s_no_block_func_and_arg_are_ready>)
42002615:	882a      	add.n	a8, a8, a2
42002617:	190c      	movi.n	a9, 1
42002619:	0020c0        	memw
4200261c:	004892        	s8i	a9, a8, 0

        if (xPortInIsrContext()) {
4200261f:	f77581        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
42002622:	0008e0        	callx8	a8
42002625:	3a9c      	beqz.n	a10, 4200263c <esp_ipc_call_nonblocking+0x70>
            vTaskNotifyGiveFromISR(s_ipc_task_handle[cpu_id], NULL);
42002627:	f76681        	l32r	a8, 420003c0 <_stext+0x3a0> (3fc94914 <s_ipc_task_handle>)
4200262a:	a08280        	addx4	a8, a2, a8
4200262d:	0c0c      	movi.n	a12, 0
4200262f:	0cbd      	mov.n	a11, a12
42002631:	08a8      	l32i.n	a10, a8, 0
42002633:	f77181        	l32r	a8, 420003f8 <_stext+0x3d8> (4037c384 <vTaskGenericNotifyGiveFromISR>)
42002636:	0008e0        	callx8	a8
42002639:	0007c6        	j	4200265c <esp_ipc_call_nonblocking+0x90>
        } else {
#ifdef CONFIG_ESP_IPC_USES_CALLERS_PRIORITY
            vTaskPrioritySet(s_ipc_task_handle[cpu_id], IPC_MAX_PRIORITY);
4200263c:	f76181        	l32r	a8, 420003c0 <_stext+0x3a0> (3fc94914 <s_ipc_task_handle>)
4200263f:	a02280        	addx4	a2, a2, a8
42002642:	8b1c      	movi.n	a11, 24
42002644:	02a8      	l32i.n	a10, a2, 0
42002646:	f76d81        	l32r	a8, 420003fc <_stext+0x3dc> (4037b8b0 <vTaskPrioritySet>)
42002649:	0008e0        	callx8	a8
#endif
            xTaskNotifyGive(s_ipc_task_handle[cpu_id]);
4200264c:	0e0c      	movi.n	a14, 0
4200264e:	2d0c      	movi.n	a13, 2
42002650:	0ecd      	mov.n	a12, a14
42002652:	0ebd      	mov.n	a11, a14
42002654:	02a8      	l32i.n	a10, a2, 0
42002656:	f76a81        	l32r	a8, 42000400 <_stext+0x3e0> (4037c1b0 <xTaskGenericNotify>)
42002659:	0008e0        	callx8	a8
        }
        return ESP_OK;
4200265c:	020c      	movi.n	a2, 0
4200265e:	000586        	j	42002678 <esp_ipc_call_nonblocking+0xac>
        return ESP_ERR_INVALID_ARG;
42002661:	02a122        	movi	a2, 0x102
42002664:	000406        	j	42002678 <esp_ipc_call_nonblocking+0xac>
42002667:	a12200        	sll	a2, a2
4200266a:	024602        	s8i	a0, a6, 2
4200266d:	000000        	ill
        return ESP_ERR_INVALID_STATE;
42002670:	03a122        	movi	a2, 0x103
42002673:	000046        	j	42002678 <esp_ipc_call_nonblocking+0xac>
    }

    // the previous call was not completed
    return ESP_FAIL;
42002676:	f27c      	movi.n	a2, -1
}
42002678:	f01d      	retw.n
	...

4200267c <esp_vApplicationIdleHook>:

void esp_vApplicationIdleHook(void)
{
4200267c:	004136        	entry	a1, 32
4200267f:	03eb60        	rsr.prid	a6
42002682:	046d60        	extui	a6, a6, 13, 1
    bool can_go_idle = true;
    int core = xPortGetCoreID();
    for (int n = 0; n < MAX_HOOKS; n++) {
42002685:	070c      	movi.n	a7, 0
    bool can_go_idle = true;
42002687:	150c      	movi.n	a5, 1
    for (int n = 0; n < MAX_HOOKS; n++) {
42002689:	000546        	j	420026a2 <esp_vApplicationIdleHook+0x26>
        if (idle_cb[core][n] != NULL && !idle_cb[core][n]()) {
4200268c:	b08670        	addx8	a8, a6, a7
4200268f:	f75d91        	l32r	a9, 42000404 <_stext+0x3e4> (3fc9495c <idle_cb>)
42002692:	a08890        	addx4	a8, a8, a9
42002695:	08a8      	l32i.n	a10, a8, 0
42002697:	5a8c      	beqz.n	a10, 420026a0 <esp_vApplicationIdleHook+0x24>
42002699:	000ae0        	callx8	a10
4200269c:	0acc      	bnez.n	a10, 420026a0 <esp_vApplicationIdleHook+0x24>
            can_go_idle = false;
4200269e:	0a5d      	mov.n	a5, a10
    for (int n = 0; n < MAX_HOOKS; n++) {
420026a0:	771b      	addi.n	a7, a7, 1
420026a2:	e687a6        	blti	a7, 8, 4200268c <esp_vApplicationIdleHook+0x10>
        }
    }
    if (!can_go_idle) {
420026a5:	458c      	beqz.n	a5, 420026ad <esp_vApplicationIdleHook+0x31>

#ifdef CONFIG_PM_ENABLE
    esp_pm_impl_idle_hook();
    esp_pm_impl_waiti();
#else
    esp_cpu_wait_for_intr();
420026a7:	f75881        	l32r	a8, 42000408 <_stext+0x3e8> (40378298 <esp_cpu_wait_for_intr>)
420026aa:	0008e0        	callx8	a8
#endif

}
420026ad:	f01d      	retw.n
	...

420026b0 <esp_register_freertos_idle_hook_for_cpu>:

esp_err_t esp_register_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t new_idle_cb, UBaseType_t cpuid)
{
420026b0:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
420026b3:	4d23f6        	bgeui	a3, 2, 42002704 <esp_register_freertos_idle_hook_for_cpu+0x54>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
420026b6:	fb7c      	movi.n	a11, -1
420026b8:	f755a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
420026bb:	f75581        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420026be:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
420026c1:	090c      	movi.n	a9, 0
420026c3:	000a46        	j	420026f0 <esp_register_freertos_idle_hook_for_cpu+0x40>
420026c6:	900000        	addx2	a0, a0, a0
        if (idle_cb[cpuid][n] == NULL) {
420026c9:	a1b083        	lsi	f8, a0, 0x284
420026cc:	4e          	.byte	0x4e
420026cd:	88a0f7        	bge	a0, a15, 42002659 <esp_ipc_call_nonblocking+0x8d>
420026d0:	0888a0        	lsx	f8, a8, a10
420026d3:	78dc      	bnez.n	a8, 420026ee <esp_register_freertos_idle_hook_for_cpu+0x3e>
            idle_cb[cpuid][n] = new_idle_cb;
420026d5:	b03390        	addx8	a3, a3, a9
420026d8:	a033a0        	addx4	a3, a3, a10
420026db:	0329      	s32i.n	a2, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
420026dd:	f74ba1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
420026e0:	f74d81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420026e3:	0008e0        	callx8	a8
            return ESP_OK;
420026e6:	020c      	movi.n	a2, 0
420026e8:	0006c6        	j	42002707 <esp_register_freertos_idle_hook_for_cpu+0x57>
420026eb:	000000        	ill
    for (int n = 0; n < MAX_HOOKS; n++) {
420026ee:	991b      	addi.n	a9, a9, 1
420026f0:	d489a6        	blti	a9, 8, 420026c8 <esp_register_freertos_idle_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
420026f3:	f746a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
420026f6:	f74781        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420026f9:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
420026fc:	01a122        	movi	a2, 0x101
420026ff:	000106        	j	42002707 <esp_register_freertos_idle_hook_for_cpu+0x57>
42002702:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
42002705:	1d02a1        	l32r	a10, 41fc9b10 <_coredump_iram_end+0x1c47c10>
}
42002708:	0000f0        	callx12	a0
	...

4200270c <esp_register_freertos_tick_hook_for_cpu>:
{
    return esp_register_freertos_idle_hook_for_cpu(new_idle_cb, xPortGetCoreID());
}

esp_err_t esp_register_freertos_tick_hook_for_cpu(esp_freertos_tick_cb_t new_tick_cb, UBaseType_t cpuid)
{
4200270c:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
4200270f:	4923f6        	bgeui	a3, 2, 4200275c <esp_register_freertos_tick_hook_for_cpu+0x50>
42002712:	fb7c      	movi.n	a11, -1
42002714:	f73ea1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
42002717:	f73e81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200271a:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
4200271d:	090c      	movi.n	a9, 0
4200271f:	000986        	j	42002749 <esp_register_freertos_tick_hook_for_cpu+0x3d>
42002722:	900000        	addx2	a0, a0, a0
        if (tick_cb[cpuid][n] == NULL) {
42002725:	a1b083        	lsi	f8, a0, 0x284
42002728:	f73c      	movi.n	a7, 63
4200272a:	a088a0        	addx4	a8, a8, a10
4200272d:	0888      	l32i.n	a8, a8, 0
4200272f:	48dc      	bnez.n	a8, 42002747 <esp_register_freertos_tick_hook_for_cpu+0x3b>
            tick_cb[cpuid][n] = new_tick_cb;
42002731:	b03390        	addx8	a3, a3, a9
42002734:	a033a0        	addx4	a3, a3, a10
42002737:	0329      	s32i.n	a2, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
42002739:	f734a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
4200273c:	f73681        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200273f:	0008e0        	callx8	a8
            return ESP_OK;
42002742:	020c      	movi.n	a2, 0
42002744:	0005c6        	j	4200275f <esp_register_freertos_tick_hook_for_cpu+0x53>
    for (int n = 0; n < MAX_HOOKS; n++) {
42002747:	991b      	addi.n	a9, a9, 1
42002749:	d789a6        	blti	a9, 8, 42002724 <esp_register_freertos_tick_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
4200274c:	f730a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
4200274f:	f73181        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42002752:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
42002755:	01a122        	movi	a2, 0x101
42002758:	0000c6        	j	4200275f <esp_register_freertos_tick_hook_for_cpu+0x53>
4200275b:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4200275e:	f01d02        	l16ui	a0, a13, 0x1e0
42002761:	000000        	ill

42002764 <esp_register_freertos_tick_hook>:
}

esp_err_t esp_register_freertos_tick_hook(esp_freertos_tick_cb_t new_tick_cb)
{
42002764:	004136        	entry	a1, 32
42002767:	20a220        	or	a10, a2, a2
4200276a:	03ebb0        	rsr.prid	a11
4200276d:	04bdb0        	extui	a11, a11, 13, 1
    return esp_register_freertos_tick_hook_for_cpu(new_tick_cb, xPortGetCoreID());
42002770:	fff9a5        	call8	4200270c <esp_register_freertos_tick_hook_for_cpu>
}
42002773:	202aa0        	or	a2, a10, a10
42002776:	000090        	retw
42002779:	000000        	ill

4200277c <esp_deregister_freertos_idle_hook_for_cpu>:

void esp_deregister_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t old_idle_cb, UBaseType_t cpuid)
{
4200277c:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
4200277f:	3723f6        	bgeui	a3, 2, 420027ba <esp_deregister_freertos_idle_hook_for_cpu+0x3e>
42002782:	fb7c      	movi.n	a11, -1
42002784:	f722a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
42002787:	f72281        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200278a:	0008e0        	callx8	a8
        return;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
4200278d:	090c      	movi.n	a9, 0
4200278f:	0006c6        	j	420027ae <esp_deregister_freertos_idle_hook_for_cpu+0x32>
42002792:	900000        	addx2	a0, a0, a0
        if (idle_cb[cpuid][n] == old_idle_cb) {
42002795:	a1b083        	lsi	f8, a0, 0x284
42002798:	f71b      	addi.n	a15, a7, 1
4200279a:	a088a0        	addx4	a8, a8, a10
4200279d:	0888      	l32i.n	a8, a8, 0
4200279f:	099827        	bne	a8, a2, 420027ac <esp_deregister_freertos_idle_hook_for_cpu+0x30>
            idle_cb[cpuid][n] = NULL;
420027a2:	b08390        	addx8	a8, a3, a9
420027a5:	a088a0        	addx4	a8, a8, a10
420027a8:	0a0c      	movi.n	a10, 0
420027aa:	08a9      	s32i.n	a10, a8, 0
    for (int n = 0; n < MAX_HOOKS; n++) {
420027ac:	991b      	addi.n	a9, a9, 1
420027ae:	e289a6        	blti	a9, 8, 42002794 <esp_deregister_freertos_idle_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
420027b1:	f716a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc91f2c <hooks_spinlock>)
420027b4:	f71881        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420027b7:	0008e0        	callx8	a8
}
420027ba:	f01d      	retw.n

420027bc <esp_err_to_name>:
#else
    "UNKNOWN ERROR";
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

const char *esp_err_to_name(esp_err_t code)
{
420027bc:	004136        	entry	a1, 32
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    size_t i;

    for (i = 0; i < sizeof(esp_err_msg_table) / sizeof(esp_err_msg_table[0]); ++i) {
420027bf:	080c      	movi.n	a8, 0
420027c1:	0005c6        	j	420027dc <esp_err_to_name+0x20>
        if (esp_err_msg_table[i].code == code) {
420027c4:	f71791        	l32r	a9, 42000420 <_stext+0x400> (3c027080 <esp_err_msg_table>)
420027c7:	b09890        	addx8	a9, a8, a9
420027ca:	0998      	l32i.n	a9, a9, 0
420027cc:	0a9927        	bne	a9, a2, 420027da <esp_err_to_name+0x1e>
            return esp_err_msg_table[i].msg;
420027cf:	f71491        	l32r	a9, 42000420 <_stext+0x400> (3c027080 <esp_err_msg_table>)
420027d2:	b08890        	addx8	a8, a8, a9
420027d5:	1828      	l32i.n	a2, a8, 4
420027d7:	000286        	j	420027e5 <esp_err_to_name+0x29>
    for (i = 0; i < sizeof(esp_err_msg_table) / sizeof(esp_err_msg_table[0]); ++i) {
420027da:	881b      	addi.n	a8, a8, 1
420027dc:	dba092        	movi	a9, 219
420027df:	e1b987        	bgeu	a9, a8, 420027c4 <esp_err_to_name+0x8>
        }
    }
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

    return esp_unknown_msg;
420027e2:	f70e21        	l32r	a2, 4200041c <_stext+0x3fc> (3c027078 <esp_unknown_msg>)
}
420027e5:	f01d      	retw.n
	...

420027e8 <brownout_ll_set_threshold>:
{
420027e8:	004136        	entry	a1, 32
420027eb:	02fd      	mov.n	a15, a2
    REGI2C_WRITE_MASK(I2C_BOD, I2C_BOD_THRESHOLD, threshold);
420027ed:	0e0c      	movi.n	a14, 0
420027ef:	2d0c      	movi.n	a13, 2
420027f1:	5c0c      	movi.n	a12, 5
420027f3:	1b0c      	movi.n	a11, 1
420027f5:	61a0a2        	movi	a10, 97
420027f8:	f70b81        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420027fb:	0008e0        	callx8	a8
}
420027fe:	f01d      	retw.n

42002800 <brownout_hal_config>:

#include "hal/brownout_ll.h"
#include "hal/brownout_hal.h"

void brownout_hal_config(const brownout_hal_config_t *cfg)
{
42002800:	004136        	entry	a1, 32
    RTCCNTL.fib_sel.val &= ~BROWNOUT_DETECTOR_LL_FIB_ENABLE;
42002803:	f63171        	l32r	a7, 420000c8 <_stext+0xa8> (60008000 <RTCCNTL>)
42002806:	0020c0        	memw
42002809:	522782        	l32i	a8, a7, 0x148
4200280c:	d97c      	movi.n	a9, -3
4200280e:	108890        	and	a8, a8, a9
42002811:	0020c0        	memw
42002814:	526782        	s32i	a8, a7, 0x148
    RTCCNTL.brown_out.ana_rst_en = enable;
42002817:	0020c0        	memw
4200281a:	3a2782        	l32i	a8, a7, 232
4200281d:	f70291        	l32r	a9, 42000428 <_stext+0x408> (efffffff <_rtc_reserved_end+0x8fefffff>)
42002820:	108890        	and	a8, a8, a9
42002823:	0020c0        	memw
42002826:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.int_wait = cycle;
42002829:	0020c0        	memw
4200282c:	3a2782        	l32i	a8, a7, 232
4200282f:	f6ff91        	l32r	a9, 4200042c <_stext+0x40c> (ffffc00f <_rtc_reserved_end+0x9fefc00f>)
42002832:	108890        	and	a8, a8, a9
42002835:	092c      	movi.n	a9, 32
42002837:	208890        	or	a8, a8, a9
4200283a:	0020c0        	memw
4200283d:	3a6782        	s32i	a8, a7, 232
    // If brownout software control is enabled, hw ana reset should be disabled, because it always has the highest priority.
    brownout_ll_ana_reset_enable(false);
    brownout_ll_set_intr_wait_cycles(2);
    brownout_ll_enable_flash_suspend(cfg->flash_power_down);
42002840:	030292        	l8ui	a9, a2, 3
    RTCCNTL.brown_out.close_flash_ena = enable;
42002843:	0020c0        	memw
42002846:	3a2782        	l32i	a8, a7, 232
42002849:	049090        	extui	a9, a9, 0, 1
4200284c:	119920        	slli	a9, a9, 14
4200284f:	f676a1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42002852:	1088a0        	and	a8, a8, a10
42002855:	208890        	or	a8, a8, a9
42002858:	0020c0        	memw
4200285b:	3a6782        	s32i	a8, a7, 232
    brownout_ll_enable_rf_power_down(cfg->rf_power_down);
4200285e:	040292        	l8ui	a9, a2, 4
    RTCCNTL.brown_out.pd_rf_ena = enable;
42002861:	0020c0        	memw
42002864:	3a2782        	l32i	a8, a7, 232
42002867:	049090        	extui	a9, a9, 0, 1
4200286a:	119910        	slli	a9, a9, 15
4200286d:	f66ca1        	l32r	a10, 42000220 <_stext+0x200> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
42002870:	1088a0        	and	a8, a8, a10
42002873:	208890        	or	a8, a8, a9
42002876:	0020c0        	memw
42002879:	3a6782        	s32i	a8, a7, 232
/**
 * @brief Clear BOD internal count.
 */
static inline void brownout_ll_clear_count(void)
{
    RTCCNTL.brown_out.cnt_clr = 1;
4200287c:	0020c0        	memw
4200287f:	3a2782        	l32i	a8, a7, 232
42002882:	f6eb91        	l32r	a9, 42000430 <_stext+0x410> (20000000 <UserFrameTotalSize+0x1fffff00>)
42002885:	208890        	or	a8, a8, a9
42002888:	0020c0        	memw
4200288b:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.cnt_clr = 0;
4200288e:	0020c0        	memw
42002891:	3a2782        	l32i	a8, a7, 232
42002894:	f6e891        	l32r	a9, 42000434 <_stext+0x414> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42002897:	108890        	and	a8, a8, a9
4200289a:	0020c0        	memw
4200289d:	3a6782        	s32i	a8, a7, 232
    brownout_ll_clear_count();
    brownout_ll_reset_config(cfg->reset_enabled, 0x3ff, BROWNOUT_RESET_LEVEL_SYSTEM);
420028a0:	020292        	l8ui	a9, a2, 2
    RTCCNTL.brown_out.rst_wait = reset_wait;
420028a3:	0020c0        	memw
420028a6:	3a2782        	l32i	a8, a7, 232
420028a9:	f6e3a1        	l32r	a10, 42000438 <_stext+0x418> (3ff0000 <UserFrameTotalSize+0x3feff00>)
420028ac:	2088a0        	or	a8, a8, a10
420028af:	0020c0        	memw
420028b2:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.rst_ena = reset_ena;
420028b5:	0020c0        	memw
420028b8:	3a2782        	l32i	a8, a7, 232
420028bb:	049090        	extui	a9, a9, 0, 1
420028be:	019960        	slli	a9, a9, 26
420028c1:	f6dea1        	l32r	a10, 4200043c <_stext+0x41c> (fbffffff <_rtc_reserved_end+0x9befffff>)
420028c4:	1088a0        	and	a8, a8, a10
420028c7:	208890        	or	a8, a8, a9
420028ca:	0020c0        	memw
420028cd:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.rst_sel = reset_level;
420028d0:	0020c0        	memw
420028d3:	3a2782        	l32i	a8, a7, 232
420028d6:	f6da91        	l32r	a9, 42000440 <_stext+0x420> (8000000 <UserFrameTotalSize+0x7ffff00>)
420028d9:	208890        	or	a8, a8, a9
420028dc:	0020c0        	memw
420028df:	3a6782        	s32i	a8, a7, 232
    brownout_ll_set_threshold(cfg->threshold);
420028e2:	0002a2        	l8ui	a10, a2, 0
420028e5:	fff025        	call8	420027e8 <brownout_ll_set_threshold>
    brownout_ll_bod_enable(cfg->enabled);
420028e8:	010292        	l8ui	a9, a2, 1
    RTCCNTL.brown_out.ena = bod_enable;
420028eb:	0020c0        	memw
420028ee:	3a2782        	l32i	a8, a7, 232
420028f1:	049090        	extui	a9, a9, 0, 1
420028f4:	019920        	slli	a9, a9, 30
420028f7:	f6d3a1        	l32r	a10, 42000444 <_stext+0x424> (bfffffff <_rtc_reserved_end+0x5fefffff>)
420028fa:	1088a0        	and	a8, a8, a10
420028fd:	208890        	or	a8, a8, a9
42002900:	0020c0        	memw
42002903:	3a6782        	s32i	a8, a7, 232
}
42002906:	f01d      	retw.n

42002908 <esp_log_linked_list_get_level>:
}

// Getting the log level from linked list
// if tag is not found then returns false.
bool esp_log_linked_list_get_level(const char *tag, esp_log_level_t *level)
{
42002908:	004136        	entry	a1, 32
    // Walk the linked list of all tags and see if given tag is present in the list.
    // This is slow because tags are compared as strings.
    uncached_tag_entry_t *it;
    SLIST_FOREACH(it, &s_log_tags, entries) {
4200290b:	f6cf81        	l32r	a8, 42000448 <_stext+0x428> (3fc949a4 <s_log_tags>)
4200290e:	0878      	l32i.n	a7, a8, 0
42002910:	000606        	j	4200292c <esp_log_linked_list_get_level+0x24>
42002913:	b75b00        	lsi	f0, a11, 0x2dc
        if (strcmp(tag, it->tag) == 0) {
42002916:	02ad      	mov.n	a10, a2
42002918:	f6cd81        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
4200291b:	0008e0        	callx8	a8
4200291e:	8acc      	bnez.n	a10, 4200292a <esp_log_linked_list_get_level+0x22>
            *level = it->level;
42002920:	040782        	l8ui	a8, a7, 4
42002923:	0389      	s32i.n	a8, a3, 0
            return true;
42002925:	120c      	movi.n	a2, 1
42002927:	000186        	j	42002931 <esp_log_linked_list_get_level+0x29>
    SLIST_FOREACH(it, &s_log_tags, entries) {
4200292a:	0778      	l32i.n	a7, a7, 0
4200292c:	fe4756        	bnez	a7, 42002914 <esp_log_linked_list_get_level+0xc>
        }
    }
    return false;
4200292f:	020c      	movi.n	a2, 0
}
42002931:	f01d      	retw.n
	...

42002934 <fix_cache_generation_overflow>:
        fix_cache_generation_overflow();
    }
}

static void fix_cache_generation_overflow(void)
{
42002934:	004136        	entry	a1, 32
    // Fix generation count wrap
    for (uint32_t i = 0; i < s_log_cache_entry_count; ++i) {
42002937:	090c      	movi.n	a9, 0
42002939:	000506        	j	42002951 <fix_cache_generation_overflow+0x1d>
        s_log_cache[i].generation = i;
4200293c:	11b9d0        	slli	a11, a9, 3
4200293f:	f6c4a1        	l32r	a10, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
42002942:	b0a9a0        	addx8	a10, a9, a10
42002945:	1a88      	l32i.n	a8, a10, 4
42002947:	248080        	extui	a8, a8, 0, 3
4200294a:	2088b0        	or	a8, a8, a11
4200294d:	1a89      	s32i.n	a8, a10, 4
    for (uint32_t i = 0; i < s_log_cache_entry_count; ++i) {
4200294f:	991b      	addi.n	a9, a9, 1
42002951:	f6c081        	l32r	a8, 42000454 <_stext+0x434> (3fc949ac <s_log_cache_entry_count>)
42002954:	0888      	l32i.n	a8, a8, 0
42002956:	e23987        	bltu	a9, a8, 4200293c <fix_cache_generation_overflow+0x8>
    }
    s_log_cache_max_generation = s_log_cache_entry_count;
42002959:	f6bf91        	l32r	a9, 42000458 <_stext+0x438> (3fc949b0 <s_log_cache_max_generation>)
4200295c:	0989      	s32i.n	a8, a9, 0
}
4200295e:	f01d      	retw.n

42002960 <heap_swap>:
        index = next;
    }
}

static inline void heap_swap(int i, int j)
{
42002960:	006136        	entry	a1, 48
    cached_tag_entry_t tmp = s_log_cache[i];
42002963:	f6bba1        	l32r	a10, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
42002966:	b022a0        	addx8	a2, a2, a10
42002969:	0298      	l32i.n	a9, a2, 0
4200296b:	1288      	l32i.n	a8, a2, 4
4200296d:	0199      	s32i.n	a9, a1, 0
4200296f:	1189      	s32i.n	a8, a1, 4
    s_log_cache[i] = s_log_cache[j];
42002971:	b033a0        	addx8	a3, a3, a10
42002974:	03b8      	l32i.n	a11, a3, 0
42002976:	13a8      	l32i.n	a10, a3, 4
42002978:	02b9      	s32i.n	a11, a2, 0
4200297a:	12a9      	s32i.n	a10, a2, 4
    s_log_cache[j] = tmp;
4200297c:	0399      	s32i.n	a9, a3, 0
4200297e:	1389      	s32i.n	a8, a3, 4
}
42002980:	f01d      	retw.n
	...

42002984 <heap_bubble_down>:
{
42002984:	004136        	entry	a1, 32
42002987:	02ad      	mov.n	a10, a2
    while (index < TAG_CACHE_SIZE / 2) {
42002989:	000a86        	j	420029b7 <heap_bubble_down+0x33>
        int left_index = index * 2 + 1;
4200298c:	baaa      	add.n	a11, a10, a10
4200298e:	bb1b      	addi.n	a11, a11, 1
        int right_index = left_index + 1;
42002990:	8a1b      	addi.n	a8, a10, 1
42002992:	788a      	add.n	a7, a8, a8
        int next = (s_log_cache[left_index].generation < s_log_cache[right_index].generation) ? left_index : right_index;
42002994:	f6af91        	l32r	a9, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
42002997:	b0cb90        	addx8	a12, a11, a9
4200299a:	1cc8      	l32i.n	a12, a12, 4
4200299c:	41c3c0        	srli	a12, a12, 3
4200299f:	1188c0        	slli	a8, a8, 4
420029a2:	998a      	add.n	a9, a9, a8
420029a4:	1988      	l32i.n	a8, a9, 4
420029a6:	418380        	srli	a8, a8, 3
420029a9:	01bc87        	bgeu	a12, a8, 420029ae <heap_bubble_down+0x2a>
420029ac:	0b7d      	mov.n	a7, a11
        heap_swap(index, next);
420029ae:	20b770        	or	a11, a7, a7
420029b1:	fffae5        	call8	42002960 <heap_swap>
        index = next;
420029b4:	20a770        	or	a10, a7, a7
    while (index < TAG_CACHE_SIZE / 2) {
420029b7:	0ea082        	movi	a8, 14
420029ba:	cea8a7        	bge	a8, a10, 4200298c <heap_bubble_down+0x8>
}
420029bd:	f01d      	retw.n
	...

420029c0 <esp_log_cache_get_level>:
{
420029c0:	004136        	entry	a1, 32
    for (i = 0; i < s_log_cache_entry_count; ++i) {
420029c3:	0a0c      	movi.n	a10, 0
420029c5:	000f06        	j	42002a05 <esp_log_cache_get_level+0x45>
420029c8:	baac00        	ceil.s	a10, f12, 0
        assert(i == 0 || s_log_cache[(i - 1) / 2].generation < s_log_cache[i].generation);
420029cb:	8a0b      	addi.n	a8, a10, -1
420029cd:	418180        	srli	a8, a8, 1
420029d0:	f6a0b1        	l32r	a11, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
420029d3:	b088b0        	addx8	a8, a8, a11
420029d6:	18c8      	l32i.n	a12, a8, 4
420029d8:	41c3c0        	srli	a12, a12, 3
420029db:	b0bab0        	addx8	a11, a10, a11
420029de:	1b88      	l32i.n	a8, a11, 4
420029e0:	418380        	srli	a8, a8, 3
420029e3:	113c87        	bltu	a12, a8, 420029f8 <esp_log_cache_get_level+0x38>
420029e6:	f69dd1        	l32r	a13, 4200045c <_stext+0x43c> (3c0227c0 <_flash_rodata_start+0x26a0>)
420029e9:	f69dc1        	l32r	a12, 42000460 <_stext+0x440> (3c027760 <__func__$0>)
420029ec:	63a0b2        	movi	a11, 99
420029ef:	f69da1        	l32r	a10, 42000464 <_stext+0x444> (3c022843 <_flash_rodata_start+0x2723>)
420029f2:	f5b381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420029f5:	0008e0        	callx8	a8
        if (s_log_cache[i].tag == tag) {
420029f8:	f69681        	l32r	a8, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
420029fb:	b08a80        	addx8	a8, a10, a8
420029fe:	0888      	l32i.n	a8, a8, 0
42002a00:	091827        	beq	a8, a2, 42002a0d <esp_log_cache_get_level+0x4d>
    for (i = 0; i < s_log_cache_entry_count; ++i) {
42002a03:	aa1b      	addi.n	a10, a10, 1
42002a05:	f69381        	l32r	a8, 42000454 <_stext+0x434> (3fc949ac <s_log_cache_entry_count>)
42002a08:	0898      	l32i.n	a9, a8, 0
42002a0a:	bb3a97        	bltu	a10, a9, 420029c9 <esp_log_cache_get_level+0x9>
    if (i == s_log_cache_entry_count) { // Not found in cache
42002a0d:	0f99a7        	bne	a9, a10, 42002a20 <esp_log_cache_get_level+0x60>
        ++s_log_cache_misses;
42002a10:	f69691        	l32r	a9, 42000468 <_stext+0x448> (3fc949a8 <s_log_cache_misses>)
42002a13:	0988      	l32i.n	a8, a9, 0
42002a15:	881b      	addi.n	a8, a8, 1
42002a17:	0989      	s32i.n	a8, a9, 0
        return false;
42002a19:	020c      	movi.n	a2, 0
42002a1b:	0013c6        	j	42002a6e <esp_log_cache_get_level+0xae>
42002a1e:	810000        	src	a0, a0, a0
    *level = (esp_log_level_t) s_log_cache[i].level;
42002a21:	f68c      	beqz.n	a6, 42002a34 <esp_log_cache_get_level+0x74>
42002a23:	b08a80        	addx8	a8, a10, a8
42002a26:	012882        	l32i	a8, a8, 4
42002a29:	248080        	extui	a8, a8, 0, 3
42002a2c:	006382        	s32i	a8, a3, 0
    if (s_log_cache_entry_count == TAG_CACHE_SIZE) {
42002a2f:	f81c      	movi.n	a8, 31
42002a31:	319987        	bne	a9, a8, 42002a66 <esp_log_cache_get_level+0xa6>
        s_log_cache[i].generation = s_log_cache_max_generation++;
42002a34:	f68931        	l32r	a3, 42000458 <_stext+0x438> (3fc949b0 <s_log_cache_max_generation>)
42002a37:	0388      	l32i.n	a8, a3, 0
42002a39:	981b      	addi.n	a9, a8, 1
42002a3b:	0399      	s32i.n	a9, a3, 0
42002a3d:	f68b21        	l32r	a2, 4200046c <_stext+0x44c> (1fffffff <UserFrameTotalSize+0x1ffffeff>)
42002a40:	108820        	and	a8, a8, a2
42002a43:	f683b1        	l32r	a11, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
42002a46:	b0bab0        	addx8	a11, a10, a11
42002a49:	1188d0        	slli	a8, a8, 3
42002a4c:	1b98      	l32i.n	a9, a11, 4
42002a4e:	249090        	extui	a9, a9, 0, 3
42002a51:	208980        	or	a8, a9, a8
42002a54:	1b89      	s32i.n	a8, a11, 4
        heap_bubble_down(i);
42002a56:	fff2e5        	call8	42002984 <heap_bubble_down>
        if (s_log_cache_max_generation == MAX_GENERATION) {
42002a59:	0388      	l32i.n	a8, a3, 0
42002a5b:	0d9827        	bne	a8, a2, 42002a6c <esp_log_cache_get_level+0xac>
            fix_cache_generation_overflow();
42002a5e:	ffed65        	call8	42002934 <fix_cache_generation_overflow>
    return true;
42002a61:	120c      	movi.n	a2, 1
42002a63:	0001c6        	j	42002a6e <esp_log_cache_get_level+0xae>
42002a66:	120c      	movi.n	a2, 1
42002a68:	000086        	j	42002a6e <esp_log_cache_get_level+0xae>
42002a6b:	120c00        	andbc	b0, b12, b0
}
42002a6e:	f01d      	retw.n

42002a70 <esp_log_cache_add>:
{
42002a70:	004136        	entry	a1, 32
    uint32_t generation = s_log_cache_max_generation++;
42002a73:	f67981        	l32r	a8, 42000458 <_stext+0x438> (3fc949b0 <s_log_cache_max_generation>)
42002a76:	0898      	l32i.n	a9, a8, 0
42002a78:	a91b      	addi.n	a10, a9, 1
42002a7a:	08a9      	s32i.n	a10, a8, 0
    if (s_log_cache_entry_count < TAG_CACHE_SIZE) {
42002a7c:	f67681        	l32r	a8, 42000454 <_stext+0x434> (3fc949ac <s_log_cache_entry_count>)
42002a7f:	08b8      	l32i.n	a11, a8, 0
42002a81:	e81c      	movi.n	a8, 30
42002a83:	2e38b7        	bltu	a8, a11, 42002ab5 <esp_log_cache_add+0x45>
        s_log_cache[s_log_cache_entry_count] = (cached_tag_entry_t) {
42002a86:	f672a1        	l32r	a10, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
42002a89:	b0aba0        	addx8	a10, a11, a10
42002a8c:	0a29      	s32i.n	a2, a10, 0
42002a8e:	243030        	extui	a3, a3, 0, 3
42002a91:	1a88      	l32i.n	a8, a10, 4
42002a93:	8c7c      	movi.n	a12, -8
42002a95:	1088c0        	and	a8, a8, a12
42002a98:	208830        	or	a8, a8, a3
42002a9b:	1a89      	s32i.n	a8, a10, 4
42002a9d:	1199d0        	slli	a9, a9, 3
42002aa0:	248080        	extui	a8, a8, 0, 3
42002aa3:	208890        	or	a8, a8, a9
42002aa6:	1a89      	s32i.n	a8, a10, 4
        ++s_log_cache_entry_count;
42002aa8:	bb1b      	addi.n	a11, a11, 1
42002aaa:	f66a81        	l32r	a8, 42000454 <_stext+0x434> (3fc949ac <s_log_cache_entry_count>)
42002aad:	08b9      	s32i.n	a11, a8, 0
42002aaf:	000a06        	j	42002adb <esp_log_cache_add+0x6b>
42002ab2:	000000        	ill
        s_log_cache[0] = (cached_tag_entry_t) {
42002ab5:	f666a1        	l32r	a10, 42000450 <_stext+0x430> (3fc949b4 <s_log_cache>)
42002ab8:	006a22        	s32i	a2, a10, 0
42002abb:	243030        	extui	a3, a3, 0, 3
42002abe:	012a82        	l32i	a8, a10, 4
42002ac1:	8b7c      	movi.n	a11, -8
42002ac3:	1088b0        	and	a8, a8, a11
42002ac6:	208830        	or	a8, a8, a3
42002ac9:	1a89      	s32i.n	a8, a10, 4
42002acb:	1199d0        	slli	a9, a9, 3
42002ace:	248080        	extui	a8, a8, 0, 3
42002ad1:	208890        	or	a8, a8, a9
42002ad4:	1a89      	s32i.n	a8, a10, 4
        heap_bubble_down(0);
42002ad6:	0a0c      	movi.n	a10, 0
42002ad8:	ffeaa5        	call8	42002984 <heap_bubble_down>
    if (s_log_cache_max_generation == MAX_GENERATION) {
42002adb:	f65f81        	l32r	a8, 42000458 <_stext+0x438> (3fc949b0 <s_log_cache_max_generation>)
42002ade:	0898      	l32i.n	a9, a8, 0
42002ae0:	f66381        	l32r	a8, 4200046c <_stext+0x44c> (1fffffff <UserFrameTotalSize+0x1ffffeff>)
42002ae3:	029987        	bne	a9, a8, 42002ae9 <esp_log_cache_add+0x79>
        fix_cache_generation_overflow();
42002ae6:	ffe4e5        	call8	42002934 <fix_cache_generation_overflow>
}
42002ae9:	f01d      	retw.n
	...

42002aec <heap_caps_get_info>:
    return ESP_OK;
}


void heap_caps_get_info( multi_heap_info_t *info, uint32_t caps )
{
42002aec:	008136        	entry	a1, 64
    memset(info, 0, sizeof(multi_heap_info_t));
42002aef:	cc1c      	movi.n	a12, 28
42002af1:	0b0c      	movi.n	a11, 0
42002af3:	20a220        	or	a10, a2, a2
42002af6:	f60281        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42002af9:	0008e0        	callx8	a8

    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002afc:	f65d81        	l32r	a8, 42000470 <_stext+0x450> (3fc94ab4 <registered_heaps>)
42002aff:	0878      	l32i.n	a7, a8, 0
42002b01:	001346        	j	42002b52 <heap_caps_get_info+0x66>
42002b04:	bd0000        	lsi	f0, a0, 0x2f4
        if (heap_caps_match(heap, caps)) {
42002b07:	07ad03        	lsi	f0, a13, 28
42002b0a:	11dba5        	call8	420148c4 <heap_caps_match>
42002b0d:	03fa16        	beqz	a10, 42002b50 <heap_caps_get_info+0x64>
            multi_heap_info_t hinfo;
            multi_heap_get_info(heap->heap, &hinfo);
42002b10:	01bd      	mov.n	a11, a1
42002b12:	77a8      	l32i.n	a10, a7, 28
42002b14:	1319a5        	call8	42015cb0 <multi_heap_get_info>

            info->total_free_bytes += hinfo.total_free_bytes - MULTI_HEAP_BLOCK_OWNER_SIZE();
42002b17:	0288      	l32i.n	a8, a2, 0
42002b19:	0198      	l32i.n	a9, a1, 0
42002b1b:	889a      	add.n	a8, a8, a9
42002b1d:	0289      	s32i.n	a8, a2, 0
            info->total_allocated_bytes += (hinfo.total_allocated_bytes -
42002b1f:	1288      	l32i.n	a8, a2, 4
42002b21:	1198      	l32i.n	a9, a1, 4
42002b23:	889a      	add.n	a8, a8, a9
42002b25:	1289      	s32i.n	a8, a2, 4
                                           hinfo.allocated_blocks * MULTI_HEAP_BLOCK_OWNER_SIZE());
            info->largest_free_block = MAX(info->largest_free_block,
42002b27:	2298      	l32i.n	a9, a2, 8
42002b29:	2188      	l32i.n	a8, a1, 8
42002b2b:	738890        	maxu	a8, a8, a9
42002b2e:	2289      	s32i.n	a8, a2, 8
                                           hinfo.largest_free_block);
            info->largest_free_block -= info->largest_free_block ? MULTI_HEAP_BLOCK_OWNER_SIZE() : 0;
            info->minimum_free_bytes += hinfo.minimum_free_bytes - MULTI_HEAP_BLOCK_OWNER_SIZE();
42002b30:	3288      	l32i.n	a8, a2, 12
42002b32:	3198      	l32i.n	a9, a1, 12
42002b34:	889a      	add.n	a8, a8, a9
42002b36:	3289      	s32i.n	a8, a2, 12
            info->allocated_blocks += hinfo.allocated_blocks;
42002b38:	4288      	l32i.n	a8, a2, 16
42002b3a:	4198      	l32i.n	a9, a1, 16
42002b3c:	889a      	add.n	a8, a8, a9
42002b3e:	4289      	s32i.n	a8, a2, 16
            info->free_blocks += hinfo.free_blocks;
42002b40:	5288      	l32i.n	a8, a2, 20
42002b42:	5198      	l32i.n	a9, a1, 20
42002b44:	889a      	add.n	a8, a8, a9
42002b46:	5289      	s32i.n	a8, a2, 20
            info->total_blocks += hinfo.total_blocks;
42002b48:	6288      	l32i.n	a8, a2, 24
42002b4a:	6198      	l32i.n	a9, a1, 24
42002b4c:	889a      	add.n	a8, a8, a9
42002b4e:	6289      	s32i.n	a8, a2, 24
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002b50:	8778      	l32i.n	a7, a7, 32
42002b52:	fb0756        	bnez	a7, 42002b06 <heap_caps_get_info+0x1a>
        }
    }
}
42002b55:	f01d      	retw.n
	...

42002b58 <heap_caps_get_largest_free_block>:
{
42002b58:	008136        	entry	a1, 64
42002b5b:	20b220        	or	a11, a2, a2
    heap_caps_get_info(&info, caps);
42002b5e:	20a110        	or	a10, a1, a1
42002b61:	fff8a5        	call8	42002aec <heap_caps_get_info>
}
42002b64:	022122        	l32i	a2, a1, 8
42002b67:	f01d      	retw.n
42002b69:	000000        	ill

42002b6c <sorted_add_to_registered_heaps>:
 *
 * @param new_heap heap to be inserted in the list of registered
 * heaps
 */
static void sorted_add_to_registered_heaps(heap_t *new_heap)
{
42002b6c:	004136        	entry	a1, 32
    // if list empty, insert head and return
    if (SLIST_EMPTY(&registered_heaps)) {
42002b6f:	f64081        	l32r	a8, 42000470 <_stext+0x450> (3fc94ab4 <registered_heaps>)
42002b72:	08d8      	l32i.n	a13, a8, 0
42002b74:	5dcc      	bnez.n	a13, 42002b7d <sorted_add_to_registered_heaps+0x11>
        SLIST_INSERT_HEAD(&registered_heaps, new_heap, next);
42002b76:	82d9      	s32i.n	a13, a2, 32
42002b78:	0829      	s32i.n	a2, a8, 0
        return;
42002b7a:	000ec6        	j	42002bb9 <sorted_add_to_registered_heaps+0x4d>

    // else, go through the registered heaps and add the new one
    // so the registered heaps are sorted by increasing heap size.
    heap_t *cur_heap = NULL;
    heap_t *prev_heap = NULL;
    const size_t new_heap_size = new_heap->end - new_heap->start;
42002b7d:	42b8      	l32i.n	a11, a2, 16
42002b7f:	3288      	l32i.n	a8, a2, 12
42002b81:	c0bb80        	sub	a11, a11, a8
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002b84:	0d8d      	mov.n	a8, a13
    heap_t *prev_heap = NULL;
42002b86:	0c0c      	movi.n	a12, 0
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002b88:	000906        	j	42002bb0 <sorted_add_to_registered_heaps+0x44>
42002b8b:	489800        	ssx	f9, a8, a0
        const size_t cur_heap_size = cur_heap->end - cur_heap->start;
42002b8e:	38a8      	l32i.n	a10, a8, 12
42002b90:	c099a0        	sub	a9, a9, a10
        if (cur_heap_size >= new_heap_size) {
42002b93:	1539b7        	bltu	a9, a11, 42002bac <sorted_add_to_registered_heaps+0x40>
            if (prev_heap != NULL) {
42002b96:	7c8c      	beqz.n	a12, 42002ba1 <sorted_add_to_registered_heaps+0x35>
                SLIST_INSERT_AFTER(prev_heap, new_heap, next);
42002b98:	8c88      	l32i.n	a8, a12, 32
42002b9a:	8289      	s32i.n	a8, a2, 32
42002b9c:	8c29      	s32i.n	a2, a12, 32
42002b9e:	0005c6        	j	42002bb9 <sorted_add_to_registered_heaps+0x4d>
            } else {
                SLIST_INSERT_HEAD(&registered_heaps, new_heap, next);
42002ba1:	82d9      	s32i.n	a13, a2, 32
42002ba3:	f63381        	l32r	a8, 42000470 <_stext+0x450> (3fc94ab4 <registered_heaps>)
42002ba6:	0829      	s32i.n	a2, a8, 0
            }
            return;
42002ba8:	000346        	j	42002bb9 <sorted_add_to_registered_heaps+0x4d>
42002bab:	08cd00        	lsx	f12, a13, a0
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002bae:	8888      	l32i.n	a8, a8, 32
42002bb0:	fd8856        	bnez	a8, 42002b8c <sorted_add_to_registered_heaps+0x20>
        }
        prev_heap = cur_heap;
    }

    // new heap size if the biggest so far, insert it at the end
    SLIST_INSERT_AFTER(prev_heap, new_heap, next);
42002bb3:	8c88      	l32i.n	a8, a12, 32
42002bb5:	8289      	s32i.n	a8, a2, 32
42002bb7:	8c29      	s32i.n	a2, a12, 32
}
42002bb9:	f01d      	retw.n
	...

42002bbc <register_heap>:

static void register_heap(heap_t *region)
{
42002bbc:	004136        	entry	a1, 32
    size_t heap_size = region->end - region->start;
42002bbf:	42b8      	l32i.n	a11, a2, 16
42002bc1:	32a8      	l32i.n	a10, a2, 12
42002bc3:	c0bba0        	sub	a11, a11, a10
    assert(heap_size <= HEAP_SIZE_MAX);
42002bc6:	f62b81        	l32r	a8, 42000474 <_stext+0x454> (2000000 <UserFrameTotalSize+0x1ffff00>)
42002bc9:	10b8b7        	bgeu	a8, a11, 42002bdd <register_heap+0x21>
42002bcc:	f62bd1        	l32r	a13, 42000478 <_stext+0x458> (3c022888 <_flash_rodata_start+0x2768>)
42002bcf:	f62bc1        	l32r	a12, 4200047c <_stext+0x45c> (3c027810 <__func__$3>)
42002bd2:	6b4c      	movi.n	a11, 70
42002bd4:	f62ba1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002bd7:	f53a81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002bda:	0008e0        	callx8	a8
    region->heap = multi_heap_register((void *)region->start, heap_size);
42002bdd:	130825        	call8	42015c60 <multi_heap_register>
42002be0:	72a9      	s32i.n	a10, a2, 28
    if (region->heap != NULL) {
        ESP_EARLY_LOGD(TAG, "New heap initialised at %p", region->heap);
    }
}
42002be2:	f01d      	retw.n

42002be4 <heap_caps_enable_nonos_stack_heaps>:

void heap_caps_enable_nonos_stack_heaps(void)
{
42002be4:	004136        	entry	a1, 32
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002be7:	f62281        	l32r	a8, 42000470 <_stext+0x450> (3fc94ab4 <registered_heaps>)
42002bea:	0878      	l32i.n	a7, a8, 0
42002bec:	0006c6        	j	42002c0b <heap_caps_enable_nonos_stack_heaps+0x27>
42002bef:	278200        	lsi	f0, a2, 156
        // Assume any not-yet-registered heap is
        // a nonos-stack heap
        if (heap->heap == NULL) {
42002bf2:	285607        	bbc	a6, a0, 42002c1e <heap_caps_init+0xe>
42002bf5:	a77001        	l32r	a0, 41fec9b8 <_coredump_iram_end+0x1c6aab8>
            register_heap(heap);
42002bf8:	fc2520        	lsi	f2, a5, 0x3f0
42002bfb:	ff          	.byte	0xff
            if (heap->heap != NULL) {
42002bfc:	77a8      	l32i.n	a10, a7, 28
42002bfe:	7a8c      	beqz.n	a10, 42002c09 <heap_caps_enable_nonos_stack_heaps+0x25>
                multi_heap_set_lock(heap->heap, &heap->heap_mux);
42002c00:	14c7b2        	addi	a11, a7, 20
42002c03:	f62081        	l32r	a8, 42000484 <_stext+0x464> (4037e7c0 <multi_heap_set_lock>)
42002c06:	0008e0        	callx8	a8
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002c09:	8778      	l32i.n	a7, a7, 32
42002c0b:	fe1756        	bnez	a7, 42002bf0 <heap_caps_enable_nonos_stack_heaps+0xc>
            }
        }
    }
}
42002c0e:	f01d      	retw.n

42002c10 <heap_caps_init>:

/* Initialize the heap allocator to use all of the memory not
   used by static data or reserved for other purposes
 */
void heap_caps_init(void)
{
42002c10:	00a136        	entry	a1, 80
42002c13:	207110        	or	a7, a1, a1
    multi_heap_in_rom_init();
#endif
    /* Get the array of regions that we can use for heaps
       (with reserved memory removed already.)
     */
    size_t num_regions = soc_get_available_memory_region_max_count();
42002c16:	003725        	call8	42002f88 <soc_get_available_memory_region_max_count>
    soc_memory_region_t regions[num_regions];
42002c19:	a08aa0        	addx4	a8, a10, a10
42002c1c:	1188e0        	slli	a8, a8, 2
42002c1f:	0fc882        	addi	a8, a8, 15
42002c22:	418480        	srli	a8, a8, 4
42002c25:	1188c0        	slli	a8, a8, 4
42002c28:	c08180        	sub	a8, a1, a8
42002c2b:	001810        	movsp	a1, a8
42002c2e:	13c152        	addi	a5, a1, 19
42002c31:	415250        	srli	a5, a5, 2
42002c34:	1155e0        	slli	a5, a5, 2
    num_regions = soc_get_available_memory_regions(regions);
42002c37:	20a550        	or	a10, a5, a5
42002c3a:	003625        	call8	42002f9c <soc_get_available_memory_regions>
42002c3d:	0acd      	mov.n	a12, a10
42002c3f:	87a9      	s32i.n	a10, a7, 32

    // the following for loop will calculate the number of possible heaps
    // based on how many regions were coalesced.
    size_t num_heaps = num_regions;
42002c41:	67a9      	s32i.n	a10, a7, 24

    //The heap allocator will treat every region given to it as separate. In order to get bigger ranges of contiguous memory,
    //it's useful to coalesce adjacent regions that have the same type.
    for (size_t i = 1; i < num_regions; i++) {
42002c43:	180c      	movi.n	a8, 1
42002c45:	001886        	j	42002cab <heap_caps_init+0x9b>
42002c48:	a80b00        	lsi	f0, a11, 0x2a0
        soc_memory_region_t *a = &regions[i - 1];
        soc_memory_region_t *b = &regions[i];
        if (b->start == (intptr_t)(a->start + a->size) && b->type == a->type && b->startup_stack == a->startup_stack ) {
42002c4b:	a09880        	addx4	a9, a8, a8
42002c4e:	a09950        	addx4	a9, a9, a5
42002c51:	09e8      	l32i.n	a14, a9, 0
42002c53:	a09aa0        	addx4	a9, a10, a10
42002c56:	a09950        	addx4	a9, a9, a5
42002c59:	09b8      	l32i.n	a11, a9, 0
42002c5b:	1998      	l32i.n	a9, a9, 4
42002c5d:	db9a      	add.n	a13, a11, a9
42002c5f:	469ed7        	bne	a14, a13, 42002ca9 <heap_caps_init+0x99>
42002c62:	a0d880        	addx4	a13, a8, a8
42002c65:	a0dd50        	addx4	a13, a13, a5
42002c68:	2de8      	l32i.n	a14, a13, 8
42002c6a:	a0daa0        	addx4	a13, a10, a10
42002c6d:	a0dd50        	addx4	a13, a13, a5
42002c70:	2dd8      	l32i.n	a13, a13, 8
42002c72:	339ed7        	bne	a14, a13, 42002ca9 <heap_caps_init+0x99>
42002c75:	a0d880        	addx4	a13, a8, a8
42002c78:	a0dd50        	addx4	a13, a13, a5
42002c7b:	100de2        	l8ui	a14, a13, 16
42002c7e:	a0daa0        	addx4	a13, a10, a10
42002c81:	a0dd50        	addx4	a13, a13, a5
42002c84:	100dd2        	l8ui	a13, a13, 16
42002c87:	1e9ed7        	bne	a14, a13, 42002ca9 <heap_caps_init+0x99>
            a->type = -1;
42002c8a:	a0aaa0        	addx4	a10, a10, a10
42002c8d:	a0aa50        	addx4	a10, a10, a5
42002c90:	fd7c      	movi.n	a13, -1
42002c92:	2ad9      	s32i.n	a13, a10, 8
            b->start = a->start;
42002c94:	a0a880        	addx4	a10, a8, a8
42002c97:	a0aa50        	addx4	a10, a10, a5
42002c9a:	0ab9      	s32i.n	a11, a10, 0
            b->size += a->size;
42002c9c:	1ab8      	l32i.n	a11, a10, 4
42002c9e:	99ba      	add.n	a9, a9, a11
42002ca0:	1a99      	s32i.n	a9, a10, 4

            // remove one heap from the number of heaps as
            // 2 regions just got coalesced.
            num_heaps--;
42002ca2:	6798      	l32i.n	a9, a7, 24
42002ca4:	8099d0        	add	a9, a9, a13
42002ca7:	6799      	s32i.n	a9, a7, 24
    for (size_t i = 1; i < num_regions; i++) {
42002ca9:	881b      	addi.n	a8, a8, 1
42002cab:	9a38c7        	bltu	a8, a12, 42002c49 <heap_caps_init+0x39>

    /* Start by allocating the registered heap data on the stack.

       Once we have a heap to copy it to, we will copy it to a heap buffer.
    */
    heap_t temp_heaps[num_heaps];
42002cae:	6788      	l32i.n	a8, a7, 24
42002cb0:	b08880        	addx8	a8, a8, a8
42002cb3:	1128e0        	slli	a2, a8, 2
42002cb6:	0fc282        	addi	a8, a2, 15
42002cb9:	418480        	srli	a8, a8, 4
42002cbc:	1188c0        	slli	a8, a8, 4
42002cbf:	c08180        	sub	a8, a1, a8
42002cc2:	001810        	movsp	a1, a8
42002cc5:	13c182        	addi	a8, a1, 19
42002cc8:	418280        	srli	a8, a8, 2
42002ccb:	1138e0        	slli	a3, a8, 2
42002cce:	f4d781        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42002cd1:	002882        	l32i	a8, a8, 0
    size_t heap_idx = 0;

    ESP_EARLY_LOGI(TAG, "Initializing. RAM available for dynamic allocation:");
42002cd4:	0238f6        	bgeui	a8, 3, 42002cda <heap_caps_init+0xca>
42002cd7:	0046c6        	j	42002df6 <heap_caps_init+0x1e6>
42002cda:	f4e181        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42002cdd:	0008e0        	callx8	a8
42002ce0:	f5eac1        	l32r	a12, 42000488 <_stext+0x468> (3c0228cc <_flash_rodata_start+0x27ac>)
42002ce3:	0abd      	mov.n	a11, a10
42002ce5:	f5e9a1        	l32r	a10, 4200048c <_stext+0x46c> (3c0228d8 <_flash_rodata_start+0x27b8>)
42002ce8:	f4df81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42002ceb:	0008e0        	callx8	a8
42002cee:	004106        	j	42002df6 <heap_caps_init+0x1e6>
    for (size_t i = 0; i < num_regions; i++) {
        soc_memory_region_t *region = &regions[i];
        const soc_memory_type_desc_t *type = &soc_memory_types[region->type];
42002cf1:	a08440        	addx4	a8, a4, a4
42002cf4:	a08850        	addx4	a8, a8, a5
42002cf7:	2828      	l32i.n	a2, a8, 8
        heap_t *heap = &temp_heaps[heap_idx];
42002cf9:	b08660        	addx8	a8, a6, a6
42002cfc:	a08830        	addx4	a8, a8, a3
42002cff:	7789      	s32i.n	a8, a7, 28
        if (region->type == -1) {
42002d01:	100266        	bnei	a2, -1, 42002d15 <heap_caps_init+0x105>
            memset(heap, 0, sizeof(*heap));
42002d04:	4c2c      	movi.n	a12, 36
42002d06:	0b0c      	movi.n	a11, 0
42002d08:	08ad      	mov.n	a10, a8
42002d0a:	f57d81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42002d0d:	0008e0        	callx8	a8
            continue;
42002d10:	5769      	s32i.n	a6, a7, 20
42002d12:	003586        	j	42002dec <heap_caps_init+0x1dc>
        }
        heap_idx++;
42002d15:	861b      	addi.n	a8, a6, 1
42002d17:	5789      	s32i.n	a8, a7, 20
        assert(heap_idx <= num_heaps);
42002d19:	6798      	l32i.n	a9, a7, 24
42002d1b:	11b987        	bgeu	a9, a8, 42002d30 <heap_caps_init+0x120>
42002d1e:	f5dcd1        	l32r	a13, 42000490 <_stext+0x470> (3c02291c <_flash_rodata_start+0x27fc>)
42002d21:	f5dcc1        	l32r	a12, 42000494 <_stext+0x474> (3c027800 <__func__$2>)
42002d24:	91a0b2        	movi	a11, 145
42002d27:	f5d6a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002d2a:	f4e581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002d2d:	0008e0        	callx8	a8

        memcpy(heap->caps, type->caps, sizeof(heap->caps));
42002d30:	b08660        	addx8	a8, a6, a6
42002d33:	a0a830        	addx4	a10, a8, a3
42002d36:	11b2c0        	slli	a11, a2, 4
42002d39:	f5d781        	l32r	a8, 42000498 <_stext+0x478> (3c027a70 <soc_memory_types>)
42002d3c:	bb8a      	add.n	a11, a11, a8
42002d3e:	cc0c      	movi.n	a12, 12
42002d40:	04cbb2        	addi	a11, a11, 4
42002d43:	0467a2        	s32i	a10, a7, 16
42002d46:	f4b881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002d49:	0008e0        	callx8	a8
        heap->start = region->start;
42002d4c:	a09440        	addx4	a9, a4, a4
42002d4f:	a09950        	addx4	a9, a9, a5
42002d52:	0988      	l32i.n	a8, a9, 0
42002d54:	47a8      	l32i.n	a10, a7, 16
42002d56:	3a89      	s32i.n	a8, a10, 12
        heap->end = region->start + region->size;
42002d58:	1998      	l32i.n	a9, a9, 4
42002d5a:	889a      	add.n	a8, a8, a9
42002d5c:	4a89      	s32i.n	a8, a10, 16
        MULTI_HEAP_LOCK_INIT(&heap->heap_mux);
42002d5e:	1186d0        	slli	a8, a6, 3
42002d61:	886a      	add.n	a8, a8, a6
42002d63:	1188e0        	slli	a8, a8, 2
42002d66:	10c882        	addi	a8, a8, 16
42002d69:	838a      	add.n	a8, a3, a8
42002d6b:	884b      	addi.n	a8, a8, 4
    assert(lock);
42002d6d:	f8cc      	bnez.n	a8, 42002d80 <heap_caps_init+0x170>
42002d6f:	f5cbd1        	l32r	a13, 4200049c <_stext+0x47c> (3c022934 <_flash_rodata_start+0x2814>)
42002d72:	f5cbc1        	l32r	a12, 420004a0 <_stext+0x480> (3c0277ec <__func__$1>)
42002d75:	5b3c      	movi.n	a11, 53
42002d77:	f5cba1        	l32r	a10, 420004a4 <_stext+0x484> (3c022964 <_flash_rodata_start+0x2844>)
42002d7a:	f4d181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002d7d:	0008e0        	callx8	a8
    lock->owner = SPINLOCK_FREE;
42002d80:	b08660        	addx8	a8, a6, a6
42002d83:	a08830        	addx4	a8, a8, a3
42002d86:	f5c891        	l32r	a9, 420004a8 <_stext+0x488> (b33fffff <_rtc_reserved_end+0x532fffff>)
42002d89:	5899      	s32i.n	a9, a8, 20
    lock->count = 0;
42002d8b:	090c      	movi.n	a9, 0
42002d8d:	6899      	s32i.n	a9, a8, 24
        if (region->startup_stack) {
42002d8f:	a08440        	addx4	a8, a4, a4
42002d92:	a08850        	addx4	a8, a8, a5
42002d95:	100882        	l8ui	a8, a8, 16
42002d98:	988c      	beqz.n	a8, 42002da5 <heap_caps_init+0x195>
            /* Will be registered when OS scheduler starts */
            heap->heap = NULL;
42002d9a:	b08660        	addx8	a8, a6, a6
42002d9d:	a08830        	addx4	a8, a8, a3
42002da0:	7899      	s32i.n	a9, a8, 28
42002da2:	000146        	j	42002dab <heap_caps_init+0x19b>
        } else {
            register_heap(heap);
42002da5:	0727a2        	l32i	a10, a7, 28
42002da8:	ffe125        	call8	42002bbc <register_heap>
        }
        SLIST_NEXT(heap, next) = NULL;
42002dab:	b06660        	addx8	a6, a6, a6
42002dae:	a06630        	addx4	a6, a6, a3
42002db1:	00a082        	movi	a8, 0
42002db4:	086682        	s32i	a8, a6, 32
42002db7:	f49d81        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42002dba:	0888      	l32i.n	a8, a8, 0

        ESP_EARLY_LOGI(TAG, "At %08X len %08X (%d KiB): %s",
42002dbc:	2c38b6        	bltui	a8, 3, 42002dec <heap_caps_init+0x1dc>
42002dbf:	f4a881        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42002dc2:	0008e0        	callx8	a8
42002dc5:	a08440        	addx4	a8, a4, a4
42002dc8:	a08850        	addx4	a8, a8, a5
42002dcb:	18e8      	l32i.n	a14, a8, 4
42002dcd:	1122c0        	slli	a2, a2, 4
42002dd0:	f5b291        	l32r	a9, 42000498 <_stext+0x478> (3c027a70 <soc_memory_types>)
42002dd3:	992a      	add.n	a9, a9, a2
42002dd5:	0998      	l32i.n	a9, a9, 0
42002dd7:	0199      	s32i.n	a9, a1, 0
42002dd9:	41fae0        	srli	a15, a14, 10
42002ddc:	08d8      	l32i.n	a13, a8, 0
42002dde:	f5aac1        	l32r	a12, 42000488 <_stext+0x468> (3c0228cc <_flash_rodata_start+0x27ac>)
42002de1:	0abd      	mov.n	a11, a10
42002de3:	f5b2a1        	l32r	a10, 420004ac <_stext+0x48c> (3c022970 <_flash_rodata_start+0x2850>)
42002de6:	f49f81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42002de9:	0008e0        	callx8	a8
    for (size_t i = 0; i < num_regions; i++) {
42002dec:	441b      	addi.n	a4, a4, 1
42002dee:	5768      	l32i.n	a6, a7, 20
42002df0:	000206        	j	42002dfc <heap_caps_init+0x1ec>
42002df3:	000000        	ill
            continue;
42002df6:	040c      	movi.n	a4, 0
42002df8:	046d      	mov.n	a6, a4
42002dfa:	9729      	s32i.n	a2, a7, 36
    for (size_t i = 0; i < num_regions; i++) {
42002dfc:	8788      	l32i.n	a8, a7, 32
42002dfe:	02b487        	bgeu	a4, a8, 42002e04 <heap_caps_init+0x1f4>
42002e01:	ffbb06        	j	42002cf1 <heap_caps_init+0xe1>
                       region->start, region->size, region->size / 1024, type->name);
    }

    assert(heap_idx == num_heaps);
42002e04:	9728      	l32i.n	a2, a7, 36
42002e06:	6788      	l32i.n	a8, a7, 24
42002e08:	111867        	beq	a8, a6, 42002e1d <heap_caps_init+0x20d>
42002e0b:	f5a9d1        	l32r	a13, 420004b0 <_stext+0x490> (3c02299c <_flash_rodata_start+0x287c>)
42002e0e:	f5a1c1        	l32r	a12, 42000494 <_stext+0x474> (3c027800 <__func__$2>)
42002e11:	a3a0b2        	movi	a11, 163
42002e14:	f59ba1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002e17:	f4aa81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002e1a:	0008e0        	callx8	a8

    /* Allocate the permanent heap data that we'll use as a linked list at runtime.

       Allocate this part of data contiguously, even though it's a linked list... */
    assert(SLIST_EMPTY(&registered_heaps));
42002e1d:	f59481        	l32r	a8, 42000470 <_stext+0x450> (3fc94ab4 <registered_heaps>)
42002e20:	0888      	l32i.n	a8, a8, 0
42002e22:	78bc      	beqz.n	a8, 42002e5d <heap_caps_init+0x24d>
42002e24:	f5a4d1        	l32r	a13, 420004b4 <_stext+0x494> (3c0229b4 <_flash_rodata_start+0x2894>)
42002e27:	f59bc1        	l32r	a12, 42000494 <_stext+0x474> (3c027800 <__func__$2>)
42002e2a:	a8a0b2        	movi	a11, 168
42002e2d:	f594a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002e30:	f4a481        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002e33:	0008e0        	callx8	a8

    heap_t *heaps_array = NULL;
    for (size_t i = 0; i < num_heaps; i++) {
        if (heap_caps_match(&temp_heaps[i], MALLOC_CAP_8BIT|MALLOC_CAP_INTERNAL)) {
42002e36:	b0a660        	addx8	a10, a6, a6
42002e39:	f59fb1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42002e3c:	a0aa30        	addx4	a10, a10, a3
42002e3f:	11a865        	call8	420148c4 <heap_caps_match>
42002e42:	2a9c      	beqz.n	a10, 42002e58 <heap_caps_init+0x248>
            /* use the first DRAM heap which can fit the data.
             * the allocated block won't include the block owner bytes since this operation
             * is done by the top level API heap_caps_malloc(). So we need to add it manually
             * after successful allocation. Allocate extra 4 bytes for that purpose. */
            heaps_array = multi_heap_malloc(temp_heaps[i].heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(sizeof(heap_t) * num_heaps));
42002e44:	b08660        	addx8	a8, a6, a6
42002e47:	a08830        	addx4	a8, a8, a3
42002e4a:	02bd      	mov.n	a11, a2
42002e4c:	78a8      	l32i.n	a10, a8, 28
42002e4e:	f59c81        	l32r	a8, 420004c0 <_stext+0x4a0> (4037e6fc <multi_heap_malloc>)
42002e51:	0008e0        	callx8	a8
42002e54:	0a5d      	mov.n	a5, a10
            if (heaps_array != NULL) {
42002e56:	cacc      	bnez.n	a10, 42002e66 <heap_caps_init+0x256>
    for (size_t i = 0; i < num_heaps; i++) {
42002e58:	661b      	addi.n	a6, a6, 1
42002e5a:	000146        	j	42002e63 <heap_caps_init+0x253>
42002e5d:	060c      	movi.n	a6, 0
    heap_t *heaps_array = NULL;
42002e5f:	065d      	mov.n	a5, a6
42002e61:	6748      	l32i.n	a4, a7, 24
    for (size_t i = 0; i < num_heaps; i++) {
42002e63:	cf3647        	bltu	a6, a4, 42002e36 <heap_caps_init+0x226>
                break;
            }
        }
    }
    assert(heaps_array != NULL); /* if NULL, there's not enough free startup heap space */
42002e66:	05dc      	bnez.n	a5, 42002e7a <heap_caps_init+0x26a>
42002e68:	f595d1        	l32r	a13, 420004bc <_stext+0x49c> (3c0229d4 <_flash_rodata_start+0x28b4>)
42002e6b:	f58ac1        	l32r	a12, 42000494 <_stext+0x474> (3c027800 <__func__$2>)
42002e6e:	b7a0b2        	movi	a11, 183
42002e71:	f583a1        	l32r	a10, 42000480 <_stext+0x460> (3c0228ba <_flash_rodata_start+0x279a>)
42002e74:	f49381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002e77:	0008e0        	callx8	a8
    MULTI_HEAP_SET_BLOCK_OWNER(heaps_array);
    heaps_array = (heap_t *)MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(heaps_array);

    memcpy(heaps_array, temp_heaps, sizeof(heap_t)*num_heaps);
42002e7a:	02cd      	mov.n	a12, a2
42002e7c:	03bd      	mov.n	a11, a3
42002e7e:	05ad      	mov.n	a10, a5
42002e80:	f46a81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002e83:	0008e0        	callx8	a8

    /* Iterate the heaps and set their locks, also add them to the linked list. */
    for (size_t i = 0; i < num_heaps; i++) {
42002e86:	040c      	movi.n	a4, 0
42002e88:	6738      	l32i.n	a3, a7, 24
42002e8a:	0006c6        	j	42002ea9 <heap_caps_init+0x299>
        if (heaps_array[i].heap != NULL) {
42002e8d:	b06440        	addx8	a6, a4, a4
42002e90:	a06650        	addx4	a6, a6, a5
42002e93:	76a8      	l32i.n	a10, a6, 28
42002e95:	7a8c      	beqz.n	a10, 42002ea0 <heap_caps_init+0x290>
            multi_heap_set_lock(heaps_array[i].heap, &heaps_array[i].heap_mux);
42002e97:	14c6b2        	addi	a11, a6, 20
42002e9a:	f57a81        	l32r	a8, 42000484 <_stext+0x464> (4037e7c0 <multi_heap_set_lock>)
42002e9d:	0008e0        	callx8	a8
         * to tail when looking for a suitable heap when allocating memory, it is
         * best to place smaller heap first. In that way, if several heaps share
         * the same set of capabilities, the smallest heaps will be used first when
         * processing small allocation requests, leaving the bigger heaps untouched
         * until the smaller heaps are full. */
        sorted_add_to_registered_heaps(&heaps_array[i]);
42002ea0:	20a660        	or	a10, a6, a6
42002ea3:	ffcca5        	call8	42002b6c <sorted_add_to_registered_heaps>
    for (size_t i = 0; i < num_heaps; i++) {
42002ea6:	01c442        	addi	a4, a4, 1
42002ea9:	e03437        	bltu	a4, a3, 42002e8d <heap_caps_init+0x27d>
    }
}
42002eac:	000090        	retw
	...

42002eb0 <__esp_system_init_fn_init_heap>:
{
42002eb0:	004136        	entry	a1, 32
    heap_caps_init();
42002eb3:	ffd5e5        	call8	42002c10 <heap_caps_init>
}
42002eb6:	020c      	movi.n	a2, 0
42002eb8:	f01d      	retw.n
	...

42002ebc <s_get_num_reserved_regions>:
*/
extern soc_reserved_region_t soc_reserved_memory_region_start;
extern soc_reserved_region_t soc_reserved_memory_region_end;

static size_t s_get_num_reserved_regions(void)
{
42002ebc:	004136        	entry	a1, 32
    size_t result = ( &soc_reserved_memory_region_end
             - &soc_reserved_memory_region_start );
42002ebf:	f58121        	l32r	a2, 420004c4 <_stext+0x4a4> (3c029ed4 <esp_system_init_fn_init_efuse_check>)
42002ec2:	f58181        	l32r	a8, 420004c8 <_stext+0x4a8> (3c029eac <reserved_region_rtc_reserved_data>)
42002ec5:	c02280        	sub	a2, a2, a8
42002ec8:	212320        	srai	a2, a2, 3
#if ESP_ROM_HAS_LAYOUT_TABLE
    return result + 1; // ROM table means one entry needs to be added at runtime
#else
    return result;
#endif
}
42002ecb:	221b      	addi.n	a2, a2, 1
42002ecd:	f01d      	retw.n
	...

42002ed0 <s_prepare_reserved_regions>:
/* Initialize a mutable array of reserved regions in 'reserved',
   then sort it by start address and check for overlapping
   reserved regions (illegal).
*/
static void s_prepare_reserved_regions(soc_reserved_region_t *reserved, size_t count)
{
42002ed0:	006136        	entry	a1, 48
#if ESP_ROM_HAS_LAYOUT_TABLE
    /* Get the ROM layout to find which part of DRAM is reserved */
    const ets_rom_layout_t *layout = ets_rom_layout_p;
42002ed3:	f57e81        	l32r	a8, 420004cc <_stext+0x4ac> (3ff1fffc <ets_rom_layout_p>)
42002ed6:	0888      	l32i.n	a8, a8, 0
    reserved[0].start = (intptr_t)layout->dram0_rtos_reserved_start;
42002ed8:	1888      	l32i.n	a8, a8, 4
42002eda:	0289      	s32i.n	a8, a2, 0
#ifdef SOC_DIRAM_ROM_RESERVE_HIGH
    reserved[0].end = SOC_DIRAM_ROM_RESERVE_HIGH;
#else
    reserved[0].end = SOC_DIRAM_DRAM_HIGH;
42002edc:	f57d81        	l32r	a8, 420004d0 <_stext+0x4b0> (3fcf0000 <ets_ops_table_ptr+0x4>)
42002edf:	1289      	s32i.n	a8, a2, 4
#endif

    memcpy(reserved + 1, &soc_reserved_memory_region_start, (count - 1) * sizeof(soc_reserved_region_t));
42002ee1:	630b      	addi.n	a6, a3, -1
42002ee3:	11c6d0        	slli	a12, a6, 3
42002ee6:	f578b1        	l32r	a11, 420004c8 <_stext+0x4a8> (3c029eac <reserved_region_rtc_reserved_data>)
42002ee9:	a28b      	addi.n	a10, a2, 8
42002eeb:	f44f81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002eee:	0008e0        	callx8	a8
#else
    memcpy(reserved, &soc_reserved_memory_region_start, count * sizeof(soc_reserved_region_t));
#endif

    /* Sort by starting address */
    qsort(reserved, count, sizeof(soc_reserved_region_t), s_compare_reserved_regions);
42002ef1:	f578d1        	l32r	a13, 420004d4 <_stext+0x4b4> (420148f0 <s_compare_reserved_regions>)
42002ef4:	8c0c      	movi.n	a12, 8
42002ef6:	03bd      	mov.n	a11, a3
42002ef8:	02ad      	mov.n	a10, a2
42002efa:	f57d81        	l32r	a8, 420004f0 <_stext+0x4d0> (40001488 <qsort>)
42002efd:	0008e0        	callx8	a8
    /* Validity checks */
    ESP_EARLY_LOGV(TAG, "reserved range is %p - %p",
                   &soc_reserved_memory_region_start,
                   &soc_reserved_memory_region_end);
    ESP_EARLY_LOGD(TAG, "Checking %d reserved memory ranges:", count);
    for (size_t i = 0; i < count; i++) {
42002f00:	0a0c      	movi.n	a10, 0
42002f02:	001e86        	j	42002f80 <s_prepare_reserved_regions+0xb0>
        ESP_EARLY_LOGD(TAG, "Reserved memory range 0x%08x - 0x%08x",
                       reserved[i].start, reserved[i].end);
        reserved[i].start = reserved[i].start & ~3; /* expand all reserved areas to word boundaries */
42002f05:	b07a20        	addx8	a7, a10, a2
42002f08:	0798      	l32i.n	a9, a7, 0
42002f0a:	cb7c      	movi.n	a11, -4
42002f0c:	1099b0        	and	a9, a9, a11
42002f0f:	0799      	s32i.n	a9, a7, 0
        reserved[i].end = (reserved[i].end + 3) & ~3;
42002f11:	1788      	l32i.n	a8, a7, 4
42002f13:	883b      	addi.n	a8, a8, 3
42002f15:	1088b0        	and	a8, a8, a11
42002f18:	016782        	s32i	a8, a7, 4
        assert(reserved[i].start <= reserved[i].end);
42002f1b:	11a897        	bge	a8, a9, 42002f30 <s_prepare_reserved_regions+0x60>
42002f1e:	f56ed1        	l32r	a13, 420004d8 <_stext+0x4b8> (3c0231b4 <_flash_rodata_start+0x3094>)
42002f21:	f56ec1        	l32r	a12, 420004dc <_stext+0x4bc> (3c027988 <__func__$0>)
42002f24:	56a0b2        	movi	a11, 86
42002f27:	f56ea1        	l32r	a10, 420004e0 <_stext+0x4c0> (3c0231f7 <_flash_rodata_start+0x30d7>)
42002f2a:	f46581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002f2d:	0008e0        	callx8	a8
        if (i < count - 1) {
42002f30:	4aba67        	bgeu	a10, a6, 42002f7e <s_prepare_reserved_regions+0xae>
            assert(reserved[i + 1].start > reserved[i].start);
42002f33:	5a1b      	addi.n	a5, a10, 1
42002f35:	b05520        	addx8	a5, a5, a2
42002f38:	0025b2        	l32i	a11, a5, 0
42002f3b:	1129b7        	blt	a9, a11, 42002f50 <s_prepare_reserved_regions+0x80>
42002f3e:	f569d1        	l32r	a13, 420004e4 <_stext+0x4c4> (3c023210 <_flash_rodata_start+0x30f0>)
42002f41:	f566c1        	l32r	a12, 420004dc <_stext+0x4bc> (3c027988 <__func__$0>)
42002f44:	58a0b2        	movi	a11, 88
42002f47:	f566a1        	l32r	a10, 420004e0 <_stext+0x4c0> (3c0231f7 <_flash_rodata_start+0x30d7>)
42002f4a:	f45d81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42002f4d:	0008e0        	callx8	a8
            if (reserved[i].end > reserved[i + 1].start) {
42002f50:	2aab87        	bge	a11, a8, 42002f7e <s_prepare_reserved_regions+0xae>
42002f53:	f43681        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42002f56:	0888      	l32i.n	a8, a8, 0
                ESP_EARLY_LOGE(TAG, "SOC_RESERVE_MEMORY_REGION region range " \
42002f58:	c89c      	beqz.n	a8, 42002f78 <s_prepare_reserved_regions+0xa8>
42002f5a:	f44181        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42002f5d:	0008e0        	callx8	a8
42002f60:	1588      	l32i.n	a8, a5, 4
42002f62:	0189      	s32i.n	a8, a1, 0
42002f64:	05f8      	l32i.n	a15, a5, 0
42002f66:	17e8      	l32i.n	a14, a7, 4
42002f68:	07d8      	l32i.n	a13, a7, 0
42002f6a:	f55fc1        	l32r	a12, 420004e8 <_stext+0x4c8> (3c02323c <_flash_rodata_start+0x311c>)
42002f6d:	0abd      	mov.n	a11, a10
42002f6f:	f55fa1        	l32r	a10, 420004ec <_stext+0x4cc> (3c02324c <_flash_rodata_start+0x312c>)
42002f72:	f43c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42002f75:	0008e0        	callx8	a8
                               "0x%08x - 0x%08x overlaps with 0x%08x - 0x%08x",
                               reserved[i].start, reserved[i].end, reserved[i + 1].start,
                               reserved[i + 1].end);
                abort();
42002f78:	f45f81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42002f7b:	0008e0        	callx8	a8
    for (size_t i = 0; i < count; i++) {
42002f7e:	aa1b      	addi.n	a10, a10, 1
42002f80:	813a37        	bltu	a10, a3, 42002f05 <s_prepare_reserved_regions+0x35>
            }
        }
    }
}
42002f83:	f01d      	retw.n
42002f85:	000000        	ill

42002f88 <soc_get_available_memory_region_max_count>:
{
42002f88:	004136        	entry	a1, 32
    return soc_memory_region_count + s_get_num_reserved_regions();
42002f8b:	fff325        	call8	42002ebc <s_get_num_reserved_regions>
42002f8e:	f55981        	l32r	a8, 420004f4 <_stext+0x4d4> (3c0279a4 <soc_memory_region_count>)
42002f91:	002882        	l32i	a8, a8, 0
}
42002f94:	802a80        	add	a2, a10, a8
42002f97:	000090        	retw
	...

42002f9c <soc_get_available_memory_regions>:

size_t soc_get_available_memory_regions(soc_memory_region_t *regions)
{
42002f9c:	00a136        	entry	a1, 80
42002f9f:	207110        	or	a7, a1, a1
42002fa2:	203220        	or	a3, a2, a2
42002fa5:	a729      	s32i.n	a2, a7, 40
    soc_memory_region_t *out_region = regions;
    /* make a local copy of the "input" regions so we can modify them */
    soc_memory_region_t in_regions[soc_memory_region_count];
42002fa7:	f55381        	l32r	a8, 420004f4 <_stext+0x4d4> (3c0279a4 <soc_memory_region_count>)
42002faa:	0888      	l32i.n	a8, a8, 0
42002fac:	a08880        	addx4	a8, a8, a8
42002faf:	1128e0        	slli	a2, a8, 2
42002fb2:	82fb      	addi.n	a8, a2, 15
42002fb4:	418480        	srli	a8, a8, 4
42002fb7:	1188c0        	slli	a8, a8, 4
42002fba:	c08180        	sub	a8, a1, a8
42002fbd:	001810        	movsp	a1, a8
42002fc0:	014d      	mov.n	a4, a1
42002fc2:	8719      	s32i.n	a1, a7, 32
    memcpy(in_regions, soc_memory_regions, sizeof(in_regions));
42002fc4:	20c220        	or	a12, a2, a2
42002fc7:	f54cb1        	l32r	a11, 420004f8 <_stext+0x4d8> (3c0279a8 <soc_memory_regions>)
42002fca:	01ad      	mov.n	a10, a1
42002fcc:	f41781        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002fcf:	0008e0        	callx8	a8
    soc_memory_region_t *in_region = in_regions;

    size_t num_reserved = s_get_num_reserved_regions();
42002fd2:	ffeea5        	call8	42002ebc <s_get_num_reserved_regions>
42002fd5:	0a5d      	mov.n	a5, a10
    soc_reserved_region_t reserved[num_reserved];
42002fd7:	118ad0        	slli	a8, a10, 3
42002fda:	88fb      	addi.n	a8, a8, 15
42002fdc:	418480        	srli	a8, a8, 4
42002fdf:	1188c0        	slli	a8, a8, 4
42002fe2:	c08180        	sub	a8, a1, a8
42002fe5:	001810        	movsp	a1, a8
42002fe8:	016d      	mov.n	a6, a1

    s_prepare_reserved_regions(reserved, num_reserved);
42002fea:	0abd      	mov.n	a11, a10
42002fec:	01ad      	mov.n	a10, a1
42002fee:	ffee25        	call8	42002ed0 <s_prepare_reserved_regions>
    soc_memory_region_t *out_region = regions;
42002ff1:	9739      	s32i.n	a3, a7, 36
    /* Go through the "in" regions (full regions, with no reserved
       sections removed from them) one at a time, trim off each reserved
       region, and then copy them to an out_region once trimmed
    */
    ESP_EARLY_LOGD(TAG, "Building list of available memory regions:");
    while (in_region != in_regions + soc_memory_region_count) {
42002ff3:	0026c6        	j	42003092 <soc_get_available_memory_regions+0xf6>
        soc_memory_region_t in = *in_region;
42002ff6:	4c1c      	movi.n	a12, 20
42002ff8:	04bd      	mov.n	a11, a4
42002ffa:	07ad      	mov.n	a10, a7
42002ffc:	f40b81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002fff:	0008e0        	callx8	a8
        ESP_EARLY_LOGV(TAG, "Examining memory region 0x%08x - 0x%08x", in.start, in.start + in.size);
        intptr_t in_start = in.start;
42003002:	07a8      	l32i.n	a10, a7, 0
        intptr_t in_end = in_start + in.size;
42003004:	17c8      	l32i.n	a12, a7, 4
42003006:	caca      	add.n	a12, a10, a12
        bool copy_in_to_out = true;
        bool move_to_next = true;

        for (size_t i = 0; i < num_reserved; i++) {
42003008:	080c      	movi.n	a8, 0
4200300a:	001406        	j	4200305e <soc_get_available_memory_regions+0xc2>
            if (reserved[i].end <= in_start) {
4200300d:	b09860        	addx8	a9, a8, a6
42003010:	19b8      	l32i.n	a11, a9, 4
42003012:	46aab7        	bge	a10, a11, 4200305c <soc_get_available_memory_regions+0xc0>
                /* reserved region ends before 'in' starts */
                continue;
            } else if (reserved[i].start >= in_end) {
42003015:	0998      	l32i.n	a9, a9, 0
42003017:	4da9c7        	bge	a9, a12, 42003068 <soc_get_available_memory_regions+0xcc>
                /* reserved region starts after 'in' ends */
                break;
            } else if (reserved[i].start <= in_start &&
4200301a:	022a97        	blt	a10, a9, 42003020 <soc_get_available_memory_regions+0x84>
4200301d:	4eabc7        	bge	a11, a12, 4200306f <soc_get_available_memory_regions+0xd3>
                ESP_EARLY_LOGV(TAG, "Region 0x%08x - 0x%08x inside of reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                /* skip 'in' entirely */
                copy_in_to_out = false;
                break;
            } else if (in_start < reserved[i].start &&
42003020:	21aa97        	bge	a10, a9, 42003045 <soc_get_available_memory_regions+0xa9>
42003023:	1eabc7        	bge	a11, a12, 42003045 <soc_get_available_memory_regions+0xa9>
                assert(in_start < reserved[i].start);
                assert(in_end > reserved[i].end);

                /* shrink this region to end where the reserved section starts */
                in_end = reserved[i].start;
                in.size = in_end - in_start;
42003026:	c099a0        	sub	a9, a9, a10
42003029:	1799      	s32i.n	a9, a7, 4

                /* update in_region so the 'next' iteration uses the region
                   after the reserved section */
                in_region->size -= (reserved[i].end - in_region->start);
4200302b:	1498      	l32i.n	a9, a4, 4
4200302d:	04a8      	l32i.n	a10, a4, 0
4200302f:	c0bba0        	sub	a11, a11, a10
42003032:	c099b0        	sub	a9, a9, a11
42003035:	1499      	s32i.n	a9, a4, 4
                in_region->start = reserved[i].end;
42003037:	b08860        	addx8	a8, a8, a6
4200303a:	1888      	l32i.n	a8, a8, 4
4200303c:	0489      	s32i.n	a8, a4, 0

                /* add first region, then re-run while loop with the updated in_region */
                move_to_next = false;
4200303e:	030c      	movi.n	a3, 0
        bool copy_in_to_out = true;
42003040:	1a0c      	movi.n	a10, 1
                break;
42003042:	000b46        	j	42003073 <soc_get_available_memory_regions+0xd7>
            } else if (reserved[i].start <= in_start) { /* reserved overlaps start of 'in' */
42003045:	0c2a97        	blt	a10, a9, 42003055 <soc_get_available_memory_regions+0xb9>
                ESP_EARLY_LOGV(TAG, "Start of region 0x%08x - 0x%08x overlaps reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                in.start = reserved[i].end;
42003048:	07b9      	s32i.n	a11, a7, 0
                in_start = in.start;
                in.size = in_end - in_start;
4200304a:	c09cb0        	sub	a9, a12, a11
4200304d:	1799      	s32i.n	a9, a7, 4
                in_start = in.start;
4200304f:	0bad      	mov.n	a10, a11
42003051:	0001c6        	j	4200305c <soc_get_available_memory_regions+0xc0>
42003054:	b9a000        	lsi	f0, a0, 0x2e4
            } else { /* reserved overlaps end of 'in' */
                ESP_EARLY_LOGV(TAG, "End of region 0x%08x - 0x%08x overlaps reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                in_end = reserved[i].start;
                in.size = in_end - in_start;
42003057:	17b9c0        	lsi	f12, a9, 92
                in_end = reserved[i].start;
4200305a:	09cd      	mov.n	a12, a9
        for (size_t i = 0; i < num_reserved; i++) {
4200305c:	881b      	addi.n	a8, a8, 1
4200305e:	ab3857        	bltu	a8, a5, 4200300d <soc_get_available_memory_regions+0x71>
        bool move_to_next = true;
42003061:	130c      	movi.n	a3, 1
        bool copy_in_to_out = true;
42003063:	03ad      	mov.n	a10, a3
42003065:	000286        	j	42003073 <soc_get_available_memory_regions+0xd7>
        bool move_to_next = true;
42003068:	130c      	movi.n	a3, 1
        bool copy_in_to_out = true;
4200306a:	03ad      	mov.n	a10, a3
4200306c:	0000c6        	j	42003073 <soc_get_available_memory_regions+0xd7>
        bool move_to_next = true;
4200306f:	130c      	movi.n	a3, 1
                copy_in_to_out = false;
42003071:	0a0c      	movi.n	a10, 0
            }
        }

        /* ignore regions smaller than 16B */
        if (in.size <= 16) {
42003073:	1788      	l32i.n	a8, a7, 4
42003075:	091c      	movi.n	a9, 16
42003077:	12b987        	bgeu	a9, a8, 4200308d <soc_get_available_memory_regions+0xf1>
            copy_in_to_out = false;
        }

        if (copy_in_to_out) {
4200307a:	fa8c      	beqz.n	a10, 4200308d <soc_get_available_memory_regions+0xf1>
            ESP_EARLY_LOGD(TAG, "Available memory region 0x%08x - 0x%08x", in.start, in.start + in.size);
            *out_region++ = in;
4200307c:	97a8      	l32i.n	a10, a7, 36
4200307e:	14ca82        	addi	a8, a10, 20
42003081:	9789      	s32i.n	a8, a7, 36
42003083:	4c1c      	movi.n	a12, 20
42003085:	07bd      	mov.n	a11, a7
42003087:	f3e881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200308a:	0008e0        	callx8	a8
        }
        if (move_to_next) {
4200308d:	138c      	beqz.n	a3, 42003092 <soc_get_available_memory_regions+0xf6>
            in_region++;
4200308f:	14c442        	addi	a4, a4, 20
    while (in_region != in_regions + soc_memory_region_count) {
42003092:	8788      	l32i.n	a8, a7, 32
42003094:	882a      	add.n	a8, a8, a2
42003096:	021487        	beq	a4, a8, 4200309c <soc_get_available_memory_regions+0x100>
42003099:	ffd646        	j	42002ff6 <soc_get_available_memory_regions+0x5a>
        }
    }

    return (out_region - regions); /* return number of regions */
4200309c:	9788      	l32i.n	a8, a7, 36
4200309e:	a798      	l32i.n	a9, a7, 40
420030a0:	c08890        	sub	a8, a8, a9
420030a3:	218280        	srai	a8, a8, 2
}
420030a6:	f51521        	l32r	a2, 420004fc <_stext+0x4dc> (cccccccd <_rtc_reserved_end+0x6cbccccd>)
420030a9:	822820        	mull	a2, a8, a2
420030ac:	f01d      	retw.n
	...

420030b0 <calc_checksum>:
{
420030b0:	004136        	entry	a1, 32
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
420030b3:	080c      	movi.n	a8, 0
    uint32_t checksum = 0;
420030b5:	082d      	mov.n	a2, a8
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
420030b7:	000506        	j	420030cf <calc_checksum+0x1f>
420030ba:	b00000        	addx8	a0, a0, a0
        checksum = ((checksum << 5) - checksum) ^ data[i];
420030bd:	201192        	l16ui	a9, a1, 64
420030c0:	c029      	s32i.n	a2, a0, 48
420030c2:	f50f91        	l32r	a9, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
420030c5:	a09890        	addx4	a9, a8, a9
420030c8:	0998      	l32i.n	a9, a9, 0
420030ca:	302290        	xor	a2, a2, a9
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
420030cd:	881b      	addi.n	a8, a8, 1
420030cf:	e958b6        	bltui	a8, 5, 420030bc <calc_checksum+0xc>
}
420030d2:	f01d      	retw.n

420030d4 <esp_clk_slowclk_cal_get>:
#endif // CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    clk_ll_rtc_slow_store_cal(new_cal);
}

uint32_t esp_clk_slowclk_cal_get(void)
{
420030d4:	004136        	entry	a1, 32
 *
 * @return The calibration value of slow clock period in microseconds, in Q13.19 fixed point format
 */
static inline __attribute__((always_inline)) uint32_t clk_ll_rtc_slow_load_cal(void)
{
    return REG_READ(RTC_SLOW_CLK_CAL_REG);
420030d7:	f50b81        	l32r	a8, 42000504 <_stext+0x4e4> (60008054 <RTCCNTL+0x54>)
420030da:	0020c0        	memw
420030dd:	0828      	l32i.n	a2, a8, 0
    return clk_ll_rtc_slow_load_cal();
}
420030df:	f01d      	retw.n
420030e1:	000000        	ill

420030e4 <esp_rtc_get_time_us>:
{
420030e4:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
420030e7:	f4c381        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
420030ea:	0008e0        	callx8	a8
420030ed:	010a16        	beqz	a10, 42003101 <esp_rtc_get_time_us+0x1d>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
420030f0:	ffafb2        	movi	a11, -1
420030f3:	f505a1        	l32r	a10, 42000508 <_stext+0x4e8> (3fc91f48 <s_esp_rtc_time_lock>)
420030f6:	f4c681        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420030f9:	0008e0        	callx8	a8
420030fc:	000346        	j	4200310d <esp_rtc_get_time_us+0x29>
420030ff:	b20000        	mulsh	a0, a0, a0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
42003102:	af          	.byte	0xaf
42003103:	ff          	.byte	0xff
42003104:	f501a1        	l32r	a10, 42000508 <_stext+0x4e8> (3fc91f48 <s_esp_rtc_time_lock>)
42003107:	f4c281        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200310a:	0008e0        	callx8	a8
    const uint32_t cal = esp_clk_slowclk_cal_get();
4200310d:	fffc65        	call8	420030d4 <esp_clk_slowclk_cal_get>
42003110:	207aa0        	or	a7, a10, a10
    if (cal == 0 || (first_call && !IS_RETAIN_MEM_VALID())) {
42003113:	1a9c      	beqz.n	a10, 42003128 <esp_rtc_get_time_us+0x44>
42003115:	f4fd81        	l32r	a8, 4200050c <_stext+0x4ec> (3fc91f44 <first_call$0>)
42003118:	000882        	l8ui	a8, a8, 0
4200311b:	689c      	beqz.n	a8, 42003135 <esp_rtc_get_time_us+0x51>
4200311d:	f4f881        	l32r	a8, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
42003120:	5838      	l32i.n	a3, a8, 20
42003122:	fff8e5        	call8	420030b0 <calc_checksum>
42003125:	0c13a7        	beq	a3, a10, 42003135 <esp_rtc_get_time_us+0x51>
        memset(&s_rtc_timer_retain_mem, 0, sizeof(retain_mem_t));
42003128:	8c1c      	movi.n	a12, 24
4200312a:	0b0c      	movi.n	a11, 0
4200312c:	f4f5a1        	l32r	a10, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
4200312f:	f47481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42003132:	0008e0        	callx8	a8
    first_call = false;
42003135:	f4f581        	l32r	a8, 4200050c <_stext+0x4ec> (3fc91f44 <first_call$0>)
42003138:	00a092        	movi	a9, 0
4200313b:	004892        	s8i	a9, a8, 0
    const uint64_t rtc_this_ticks = rtc_time_get();
4200313e:	f4f481        	l32r	a8, 42000510 <_stext+0x4f0> (403793f0 <rtc_time_get>)
42003141:	0008e0        	callx8	a8
    const uint64_t ticks = rtc_this_ticks - s_rtc_timer_retain_mem.rtc_last_ticks;
42003144:	f4ef91        	l32r	a9, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
42003147:	2988      	l32i.n	a8, a9, 8
42003149:	39d8      	l32i.n	a13, a9, 12
4200314b:	c0dbd0        	sub	a13, a11, a13
4200314e:	02ba87        	bgeu	a10, a8, 42003154 <esp_rtc_get_time_us+0x70>
42003151:	ffcdd2        	addi	a13, a13, -1
42003154:	c08a80        	sub	a8, a10, a8
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
42003157:	829780        	mull	a9, a7, a8
4200315a:	a28780        	muluh	a8, a7, a8
4200315d:	11c830        	slli	a12, a8, 13
42003160:	c59390        	extui	a9, a9, 19, 13
42003163:	209c90        	or	a9, a12, a9
42003166:	c58380        	extui	a8, a8, 19, 13
                                   ((ticks_high * cal) << (32 - RTC_CLK_CAL_FRACT));
42003169:	82c7d0        	mull	a12, a7, a13
4200316c:	a277d0        	muluh	a7, a7, a13
4200316f:	c5d3c0        	extui	a13, a12, 19, 13
42003172:	117730        	slli	a7, a7, 13
42003175:	207d70        	or	a7, a13, a7
42003178:	11cc30        	slli	a12, a12, 13
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
4200317b:	887a      	add.n	a8, a8, a7
4200317d:	99ca      	add.n	a9, a9, a12
4200317f:	01b9c7        	bgeu	a9, a12, 42003184 <esp_rtc_get_time_us+0xa0>
42003182:	881b      	addi.n	a8, a8, 1
    s_rtc_timer_retain_mem.rtc_time_us += delta_time_us;
42003184:	f4dfc1        	l32r	a12, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
42003187:	0c28      	l32i.n	a2, a12, 0
42003189:	1c38      	l32i.n	a3, a12, 4
4200318b:	338a      	add.n	a3, a3, a8
4200318d:	229a      	add.n	a2, a2, a9
4200318f:	01b297        	bgeu	a2, a9, 42003194 <esp_rtc_get_time_us+0xb0>
42003192:	331b      	addi.n	a3, a3, 1
42003194:	f4db71        	l32r	a7, 42000500 <_stext+0x4e0> (600fffe8 <s_rtc_timer_retain_mem>)
42003197:	006722        	s32i	a2, a7, 0
4200319a:	016732        	s32i	a3, a7, 4
    s_rtc_timer_retain_mem.rtc_last_ticks = rtc_this_ticks;
4200319d:	0267a2        	s32i	a10, a7, 8
420031a0:	37b9      	s32i.n	a11, a7, 12
    s_rtc_timer_retain_mem.checksum = calc_checksum();
420031a2:	fff0e5        	call8	420030b0 <calc_checksum>
420031a5:	57a9      	s32i.n	a10, a7, 20
    if (xPortInIsrContext()) {
420031a7:	f49381        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
420031aa:	0008e0        	callx8	a8
420031ad:	ba8c      	beqz.n	a10, 420031bc <esp_rtc_get_time_us+0xd8>
        portEXIT_CRITICAL_ISR(mux);
420031af:	f4d6a1        	l32r	a10, 42000508 <_stext+0x4e8> (3fc91f48 <s_esp_rtc_time_lock>)
420031b2:	f49881        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420031b5:	0008e0        	callx8	a8
420031b8:	000246        	j	420031c5 <esp_rtc_get_time_us+0xe1>
420031bb:	d3a100        	movt	a10, a1, b0
        portEXIT_CRITICAL(mux);
420031be:	9581f4        	lsi	f15, a1, 0x254
420031c1:	08e0f4        	lsi	f15, a0, 32
420031c4:	f01d00        	subx8	a1, a13, a0
	...

420031c8 <esp_clk_slowclk_cal_set>:
{
420031c8:	004136        	entry	a1, 32
    esp_rtc_get_time_us();
420031cb:	fff1a5        	call8	420030e4 <esp_rtc_get_time_us>
    REG_WRITE(RTC_SLOW_CLK_CAL_REG, cal_value);
420031ce:	f4cd81        	l32r	a8, 42000504 <_stext+0x4e4> (60008054 <RTCCNTL+0x54>)
420031d1:	0020c0        	memw
420031d4:	0829      	s32i.n	a2, a8, 0
}
420031d6:	f01d      	retw.n

420031d8 <insert_vector_desc>:
{
420031d8:	004136        	entry	a1, 32
    vector_desc_t *vd = vector_desc_head;
420031db:	f4ce81        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94acc <vector_desc_head>)
420031de:	08c8      	l32i.n	a12, a8, 0
420031e0:	0c8d      	mov.n	a8, a12
    vector_desc_t *prev = NULL;
420031e2:	0b0c      	movi.n	a11, 0
    while(vd != NULL) {
420031e4:	000a46        	j	42003211 <insert_vector_desc+0x39>
420031e7:	089800        	lsx	f9, a8, a0
        if (vd->cpu > to_insert->cpu) break;
420031ea:	059090        	extui	a9, a9, 16, 1
420031ed:	02a8      	l32i.n	a10, a2, 0
420031ef:	05a0a0        	extui	a10, a10, 16, 1
420031f2:	1e3a97        	bltu	a10, a9, 42003214 <insert_vector_desc+0x3c>
        if (vd->cpu == to_insert->cpu && vd->intno >= to_insert->intno) break;
420031f5:	0898      	l32i.n	a9, a8, 0
420031f7:	02a8      	l32i.n	a10, a2, 0
420031f9:	3099a0        	xor	a9, a9, a10
420031fc:	0df907        	bbsi	a9, 16, 4200320d <insert_vector_desc+0x35>
420031ff:	08a8      	l32i.n	a10, a8, 0
42003201:	45a1a0        	extui	a10, a10, 17, 5
42003204:	002292        	l32i	a9, a2, 0
42003207:	459190        	extui	a9, a9, 17, 5
4200320a:	06ba97        	bgeu	a10, a9, 42003214 <insert_vector_desc+0x3c>
        prev = vd;
4200320d:	08bd      	mov.n	a11, a8
        vd = vd->next;
4200320f:	2888      	l32i.n	a8, a8, 8
    while(vd != NULL) {
42003211:	fd3856        	bnez	a8, 420031e8 <insert_vector_desc+0x10>
    if ((vector_desc_head == NULL) || (prev == NULL)) {
42003214:	0c8c      	beqz.n	a12, 42003218 <insert_vector_desc+0x40>
42003216:	8bcc      	bnez.n	a11, 42003222 <insert_vector_desc+0x4a>
        to_insert->next = vd;
42003218:	2289      	s32i.n	a8, a2, 8
        vector_desc_head = to_insert;
4200321a:	f4be81        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94acc <vector_desc_head>)
4200321d:	0829      	s32i.n	a2, a8, 0
4200321f:	0000c6        	j	42003226 <insert_vector_desc+0x4e>
        prev->next = to_insert;
42003222:	2b29      	s32i.n	a2, a11, 8
        to_insert->next = vd;
42003224:	2289      	s32i.n	a8, a2, 8
}
42003226:	f01d      	retw.n

42003228 <find_desc_for_int>:
{
42003228:	004136        	entry	a1, 32
4200322b:	029d      	mov.n	a9, a2
    vector_desc_t *vd = vector_desc_head;
4200322d:	f4b981        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94acc <vector_desc_head>)
42003230:	0828      	l32i.n	a2, a8, 0
    while(vd != NULL) {
42003232:	000446        	j	42003247 <find_desc_for_int+0x1f>
        if (vd->cpu == cpu && vd->intno == intno) {
42003235:	0288      	l32i.n	a8, a2, 0
42003237:	058080        	extui	a8, a8, 16, 1
4200323a:	079837        	bne	a8, a3, 42003245 <find_desc_for_int+0x1d>
4200323d:	0288      	l32i.n	a8, a2, 0
4200323f:	458180        	extui	a8, a8, 17, 5
42003242:	041897        	beq	a8, a9, 4200324a <find_desc_for_int+0x22>
        vd = vd->next;
42003245:	2228      	l32i.n	a2, a2, 8
    while(vd != NULL) {
42003247:	fea256        	bnez	a2, 42003235 <find_desc_for_int+0xd>
}
4200324a:	f01d      	retw.n

4200324c <get_desc_for_int>:
{
4200324c:	004136        	entry	a1, 32
4200324f:	027d      	mov.n	a7, a2
    vector_desc_t *vd = find_desc_for_int(intno, cpu);
42003251:	03bd      	mov.n	a11, a3
42003253:	02ad      	mov.n	a10, a2
42003255:	fffd25        	call8	42003228 <find_desc_for_int>
42003258:	202aa0        	or	a2, a10, a10
    if (vd == NULL) {
4200325b:	041a56        	bnez	a10, 420032a0 <get_desc_for_int+0x54>
        vector_desc_t *newvd = heap_caps_malloc(sizeof(vector_desc_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
4200325e:	f496b1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42003261:	ca0c      	movi.n	a10, 12
42003263:	f4af81        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42003266:	0008e0        	callx8	a8
42003269:	0a2d      	mov.n	a2, a10
        if (newvd == NULL) {
4200326b:	1abc      	beqz.n	a10, 420032a0 <get_desc_for_int+0x54>
        memset(newvd, 0, sizeof(vector_desc_t));
4200326d:	cc0c      	movi.n	a12, 12
4200326f:	0b0c      	movi.n	a11, 0
42003271:	f42381        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42003274:	0008e0        	callx8	a8
        newvd->intno = intno;
42003277:	447070        	extui	a7, a7, 0, 5
4200327a:	0177f0        	slli	a7, a7, 17
4200327d:	0288      	l32i.n	a8, a2, 0
4200327f:	f4a691        	l32r	a9, 42000518 <_stext+0x4f8> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
42003282:	108890        	and	a8, a8, a9
42003285:	208870        	or	a8, a8, a7
42003288:	0289      	s32i.n	a8, a2, 0
        newvd->cpu = cpu;
4200328a:	043030        	extui	a3, a3, 0, 1
4200328d:	113300        	slli	a3, a3, 16
42003290:	f4a391        	l32r	a9, 4200051c <_stext+0x4fc> (fffeffff <_rtc_reserved_end+0x9feeffff>)
42003293:	108890        	and	a8, a8, a9
42003296:	208830        	or	a8, a8, a3
42003299:	0289      	s32i.n	a8, a2, 0
        insert_vector_desc(newvd);
4200329b:	02ad      	mov.n	a10, a2
4200329d:	fff3a5        	call8	420031d8 <insert_vector_desc>
}
420032a0:	f01d      	retw.n
	...

420032a4 <find_desc_for_source>:
{
420032a4:	004136        	entry	a1, 32
420032a7:	02ad      	mov.n	a10, a2
    vector_desc_t *vd = vector_desc_head;
420032a9:	f49a81        	l32r	a8, 42000514 <_stext+0x4f4> (3fc94acc <vector_desc_head>)
420032ac:	0828      	l32i.n	a2, a8, 0
    while(vd != NULL) {
420032ae:	0017c6        	j	42003311 <find_desc_for_source+0x6d>
        if (!(vd->flags & VECDESC_FL_SHARED)) {
420032b1:	009282        	l16si	a8, a2, 0
420032b4:	490c      	movi.n	a9, 4
420032b6:	108890        	and	a8, a8, a9
420032b9:	238880        	sext	a8, a8, 15
420032bc:	48dc      	bnez.n	a8, 420032d4 <find_desc_for_source+0x30>
            if (vd->source == source && cpu == vd->cpu) {
420032be:	0288      	l32i.n	a8, a2, 0
420032c0:	1188e0        	slli	a8, a8, 2
420032c3:	318880        	srai	a8, a8, 24
420032c6:	4498a7        	bne	a8, a10, 4200330e <find_desc_for_source+0x6a>
420032c9:	0288      	l32i.n	a8, a2, 0
420032cb:	058080        	extui	a8, a8, 16, 1
420032ce:	3c9837        	bne	a8, a3, 4200330e <find_desc_for_source+0x6a>
420032d1:	000fc6        	j	42003314 <find_desc_for_source+0x70>
        } else if (vd->cpu == cpu) {
420032d4:	0288      	l32i.n	a8, a2, 0
420032d6:	058080        	extui	a8, a8, 16, 1
420032d9:	319837        	bne	a8, a3, 4200330e <find_desc_for_source+0x6a>
            shared_vector_desc_t *svd = vd->shared_vec_info;
420032dc:	1298      	l32i.n	a9, a2, 4
            assert(svd != NULL);
420032de:	09ec      	bnez.n	a9, 42003302 <find_desc_for_source+0x5e>
420032e0:	f491d1        	l32r	a13, 42000524 <_stext+0x504> (3c0234a4 <_flash_rodata_start+0x3384>)
420032e3:	f491c1        	l32r	a12, 42000528 <_stext+0x508> (3c027b7c <__func__$6>)
420032e6:	b7a0b2        	movi	a11, 183
420032e9:	f490a1        	l32r	a10, 4200052c <_stext+0x50c> (3c0234d0 <_flash_rodata_start+0x33b0>)
420032ec:	f37581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420032ef:	0008e0        	callx8	a8
                if (svd->source == source) {
420032f2:	0988      	l32i.n	a8, a9, 0
420032f4:	118890        	slli	a8, a8, 7
420032f7:	238880        	sext	a8, a8, 15
420032fa:	218880        	srai	a8, a8, 8
420032fd:	0918a7        	beq	a8, a10, 4200330a <find_desc_for_source+0x66>
                svd = svd->next;
42003300:	5998      	l32i.n	a9, a9, 20
            while(svd) {
42003302:	fec956        	bnez	a9, 420032f2 <find_desc_for_source+0x4e>
            bool found = false;
42003305:	080c      	movi.n	a8, 0
42003307:	000046        	j	4200330c <find_desc_for_source+0x68>
                    found = true;
4200330a:	180c      	movi.n	a8, 1
            if (found) {
4200330c:	48cc      	bnez.n	a8, 42003314 <find_desc_for_source+0x70>
        vd = vd->next;
4200330e:	022222        	l32i	a2, a2, 8
    while(vd != NULL) {
42003311:	f9c256        	bnez	a2, 420032b1 <find_desc_for_source+0xd>
}
42003314:	f01d      	retw.n
	...

42003318 <is_vect_desc_usable>:
{
42003318:	006136        	entry	a1, 48
4200331b:	04ad      	mov.n	a10, a4
    int x = vd->intno;
4200331d:	0278      	l32i.n	a7, a2, 0
4200331f:	457170        	extui	a7, a7, 17, 5
    esp_cpu_intr_get_desc(cpu, x, &intr_desc);
42003322:	01cd      	mov.n	a12, a1
42003324:	07bd      	mov.n	a11, a7
42003326:	0261a5        	call8	42005940 <esp_cpu_intr_get_desc>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_RESVD) {
42003329:	2188      	l32i.n	a8, a1, 8
4200332b:	7ae817        	bbsi	a8, 1, 420033a9 <is_vect_desc_usable+0x91>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_SPECIAL && force == -1) {
4200332e:	026807        	bbci	a8, 0, 42003334 <is_vect_desc_usable+0x1c>
42003331:	790526        	beqi	a5, -1, 420033ae <is_vect_desc_usable+0x96>
    if (!(flags & (1 << intr_desc.priority))) {
42003334:	0188      	l32i.n	a8, a1, 0
42003336:	7a5387        	bbc	a3, a8, 420033b4 <is_vect_desc_usable+0x9c>
    if (((flags & ESP_INTR_FLAG_EDGE) && (intr_desc.type == ESP_CPU_INTR_TYPE_LEVEL)) ||
42003339:	076397        	bbci	a3, 9, 42003344 <is_vect_desc_usable+0x2c>
4200333c:	1188      	l32i.n	a8, a1, 4
4200333e:	78cc      	bnez.n	a8, 42003349 <is_vect_desc_usable+0x31>
42003340:	001d46        	j	420033b9 <is_vect_desc_usable+0xa1>
42003343:	118800        	slli	a8, a8, 16
            (((!(flags & ESP_INTR_FLAG_EDGE)) && (intr_desc.type == ESP_CPU_INTR_TYPE_EDGE)))) {
42003346:	741826        	beqi	a8, 1, 420033be <is_vect_desc_usable+0xa6>
    if (vd->flags & VECDESC_FL_RESERVED)  {
42003349:	009282        	l16si	a8, a2, 0
4200334c:	74e807        	bbsi	a8, 0, 420033c4 <is_vect_desc_usable+0xac>
    assert(!((vd->flags & VECDESC_FL_SHARED) && (vd->flags & VECDESC_FL_NONSHARED)));
4200334f:	c90c      	movi.n	a9, 12
42003351:	109890        	and	a9, a8, a9
42003354:	239980        	sext	a9, a9, 15
42003357:	11a966        	bnei	a9, 12, 4200336c <is_vect_desc_usable+0x54>
4200335a:	f475d1        	l32r	a13, 42000530 <_stext+0x510> (3c0234e0 <_flash_rodata_start+0x33c0>)
4200335d:	f475c1        	l32r	a12, 42000534 <_stext+0x514> (3c027b68 <__func__$5>)
42003360:	1aa1b2        	movi	a11, 0x11a
42003363:	f472a1        	l32r	a10, 4200052c <_stext+0x50c> (3c0234d0 <_flash_rodata_start+0x33b0>)
42003366:	f35681        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42003369:	0008e0        	callx8	a8
    if (vd->flags & VECDESC_FL_NONSHARED) {
4200336c:	890c      	movi.n	a9, 8
4200336e:	109890        	and	a9, a8, a9
42003371:	239980        	sext	a9, a9, 15
42003374:	051956        	bnez	a9, 420033c9 <is_vect_desc_usable+0xb1>
    if (vd->flags & VECDESC_FL_SHARED) {
42003377:	490c      	movi.n	a9, 4
42003379:	109890        	and	a9, a8, a9
4200337c:	239980        	sext	a9, a9, 15
4200337f:	199c      	beqz.n	a9, 42003394 <is_vect_desc_usable+0x7c>
        if (flags & ESP_INTR_FLAG_SHARED) {
42003381:	496387        	bbci	a3, 8, 420033ce <is_vect_desc_usable+0xb6>
            bool in_iram_flag = ((flags & ESP_INTR_FLAG_IRAM) != 0);
42003384:	043a30        	extui	a3, a3, 10, 1
            bool desc_in_iram_flag = ((vd->flags & VECDESC_FL_INIRAM) != 0);
42003387:	048180        	extui	a8, a8, 1, 1
            if ((vd->flags & VECDESC_FL_SHARED) && (desc_in_iram_flag != in_iram_flag))  {
4200338a:	469387        	bne	a3, a8, 420033d4 <is_vect_desc_usable+0xbc>
    return true;
4200338d:	120c      	movi.n	a2, 1
4200338f:	001206        	j	420033db <is_vect_desc_usable+0xc3>
42003392:	b00000        	addx8	a0, a0, a0
42003395:	03eb      	addi.n	a0, a3, 14
42003397:	04bdb0        	extui	a11, a11, 13, 1
    has_handler = xt_int_has_handler(intr_num, esp_cpu_get_core_id());
4200339a:	20a770        	or	a10, a7, a7
4200339d:	12e3e5        	call8	420161dc <xt_int_has_handler>
    } else if (esp_cpu_intr_has_handler(x)) {
420033a0:	035a56        	bnez	a10, 420033d9 <is_vect_desc_usable+0xc1>
    return true;
420033a3:	01a022        	movi	a2, 1
420033a6:	000c46        	j	420033db <is_vect_desc_usable+0xc3>
        return false;
420033a9:	020c      	movi.n	a2, 0
420033ab:	000b06        	j	420033db <is_vect_desc_usable+0xc3>
        return false;
420033ae:	020c      	movi.n	a2, 0
420033b0:	0009c6        	j	420033db <is_vect_desc_usable+0xc3>
420033b3:	020c00        	andb	b0, b12, b0
        return false;
420033b6:	000846        	j	420033db <is_vect_desc_usable+0xc3>
        return false;
420033b9:	020c      	movi.n	a2, 0
420033bb:	000706        	j	420033db <is_vect_desc_usable+0xc3>
420033be:	020c      	movi.n	a2, 0
420033c0:	0005c6        	j	420033db <is_vect_desc_usable+0xc3>
420033c3:	020c00        	andb	b0, b12, b0
        return false;
420033c6:	000446        	j	420033db <is_vect_desc_usable+0xc3>
        return false;
420033c9:	020c      	movi.n	a2, 0
420033cb:	000306        	j	420033db <is_vect_desc_usable+0xc3>
            return false;
420033ce:	020c      	movi.n	a2, 0
420033d0:	0001c6        	j	420033db <is_vect_desc_usable+0xc3>
420033d3:	020c00        	andb	b0, b12, b0
                return false;
420033d6:	000046        	j	420033db <is_vect_desc_usable+0xc3>
        return false;
420033d9:	020c      	movi.n	a2, 0
}
420033db:	f01d      	retw.n
420033dd:	000000        	ill

420033e0 <get_available_int>:
{
420033e0:	00a136        	entry	a1, 80
    memset(&empty_vect_desc, 0, sizeof(vector_desc_t));
420033e3:	cc0c      	movi.n	a12, 12
420033e5:	00a0b2        	movi	a11, 0
420033e8:	01ad      	mov.n	a10, a1
420033ea:	f3c581        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420033ed:	0008e0        	callx8	a8
    if (!(flags & ESP_INTR_FLAG_LEVELMASK)) {
420033f0:	648120        	extui	a8, a2, 1, 7
420033f3:	38cc      	bnez.n	a8, 420033fa <get_available_int+0x1a>
        flags |= ESP_INTR_FLAG_LOWMED;
420033f5:	e80c      	movi.n	a8, 14
420033f7:	202280        	or	a2, a2, a8
    vector_desc_t *vd = find_desc_for_source(source, cpu);
420033fa:	03bd      	mov.n	a11, a3
420033fc:	05ad      	mov.n	a10, a5
420033fe:	ffea65        	call8	420032a4 <find_desc_for_source>
42003401:	0a7d      	mov.n	a7, a10
    if (vd) {
42003403:	1abc      	beqz.n	a10, 42003438 <get_available_int+0x58>
        if ( force != -1 && force != vd->intno ) {
42003405:	070426        	beqi	a4, -1, 42003410 <get_available_int+0x30>
42003408:	0a88      	l32i.n	a8, a10, 0
4200340a:	458180        	extui	a8, a8, 17, 5
4200340d:	199847        	bne	a8, a4, 4200342a <get_available_int+0x4a>
        } else if (!is_vect_desc_usable(vd, flags, cpu, force)) {
42003410:	20d440        	or	a13, a4, a4
42003413:	20c330        	or	a12, a3, a3
42003416:	20b220        	or	a11, a2, a2
42003419:	07ad      	mov.n	a10, a7
4200341b:	ffefe5        	call8	42003318 <is_vect_desc_usable>
4200341e:	fa8c      	beqz.n	a10, 42003431 <get_available_int+0x51>
            best = vd->intno;
42003420:	0788      	l32i.n	a8, a7, 0
42003422:	458180        	extui	a8, a8, 17, 5
42003425:	8189      	s32i.n	a8, a1, 32
42003427:	003d86        	j	42003521 <get_available_int+0x141>
    int best=-1;
4200342a:	f87c      	movi.n	a8, -1
4200342c:	8189      	s32i.n	a8, a1, 32
4200342e:	003bc6        	j	42003521 <get_available_int+0x141>
42003431:	f87c      	movi.n	a8, -1
42003433:	8189      	s32i.n	a8, a1, 32
        return best;
42003435:	003a06        	j	42003521 <get_available_int+0x141>
    if (force != -1) {
42003438:	020466        	bnei	a4, -1, 4200343e <get_available_int+0x5e>
4200343b:	0033c6        	j	4200350e <get_available_int+0x12e>
        vd = find_desc_for_int(force, cpu);
4200343e:	03bd      	mov.n	a11, a3
42003440:	04ad      	mov.n	a10, a4
42003442:	ffde65        	call8	42003228 <find_desc_for_int>
42003445:	0a7d      	mov.n	a7, a10
        if (vd == NULL) {
42003447:	3adc      	bnez.n	a10, 4200345e <get_available_int+0x7e>
            empty_vect_desc.intno = force;
42003449:	449040        	extui	a9, a4, 0, 5
4200344c:	0199f0        	slli	a9, a9, 17
4200344f:	0188      	l32i.n	a8, a1, 0
42003451:	f431a1        	l32r	a10, 42000518 <_stext+0x4f8> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
42003454:	1088a0        	and	a8, a8, a10
42003457:	208890        	or	a8, a8, a9
4200345a:	0189      	s32i.n	a8, a1, 0
            vd = &empty_vect_desc;
4200345c:	017d      	mov.n	a7, a1
        if (is_vect_desc_usable(vd, flags, cpu, force)) {
4200345e:	20d440        	or	a13, a4, a4
42003461:	20c330        	or	a12, a3, a3
42003464:	20b220        	or	a11, a2, a2
42003467:	07ad      	mov.n	a10, a7
42003469:	ffeae5        	call8	42003318 <is_vect_desc_usable>
4200346c:	8a8c      	beqz.n	a10, 42003478 <get_available_int+0x98>
            best = vd->intno;
4200346e:	0788      	l32i.n	a8, a7, 0
42003470:	458180        	extui	a8, a8, 17, 5
42003473:	8189      	s32i.n	a8, a1, 32
42003475:	002a06        	j	42003521 <get_available_int+0x141>
    int best=-1;
42003478:	f87c      	movi.n	a8, -1
4200347a:	8189      	s32i.n	a8, a1, 32
        return best;
4200347c:	002846        	j	42003521 <get_available_int+0x141>
4200347f:	03bd00        	lsi	f0, a13, 12
        vd = find_desc_for_int(x, cpu);
42003482:	06ad      	mov.n	a10, a6
42003484:	ffda25        	call8	42003228 <find_desc_for_int>
42003487:	0a7d      	mov.n	a7, a10
        if (vd == NULL) {
42003489:	3adc      	bnez.n	a10, 420034a0 <get_available_int+0xc0>
            empty_vect_desc.intno = x;
4200348b:	449060        	extui	a9, a6, 0, 5
4200348e:	0199f0        	slli	a9, a9, 17
42003491:	0188      	l32i.n	a8, a1, 0
42003493:	f421a1        	l32r	a10, 42000518 <_stext+0x4f8> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
42003496:	1088a0        	and	a8, a8, a10
42003499:	208890        	or	a8, a8, a9
4200349c:	0189      	s32i.n	a8, a1, 0
            vd = &empty_vect_desc;
4200349e:	017d      	mov.n	a7, a1
        esp_cpu_intr_get_desc(cpu, x, &intr_desc);
420034a0:	c1cb      	addi.n	a12, a1, 12
420034a2:	06bd      	mov.n	a11, a6
420034a4:	03ad      	mov.n	a10, a3
420034a6:	0249a5        	call8	42005940 <esp_cpu_intr_get_desc>
        if (!is_vect_desc_usable(vd, flags, cpu, force)) {
420034a9:	04dd      	mov.n	a13, a4
420034ab:	03cd      	mov.n	a12, a3
420034ad:	02bd      	mov.n	a11, a2
420034af:	07ad      	mov.n	a10, a7
420034b1:	ffe665        	call8	42003318 <is_vect_desc_usable>
420034b4:	051a16        	beqz	a10, 42003509 <get_available_int+0x129>
        if (flags & ESP_INTR_FLAG_SHARED) {
420034b7:	3b6287        	bbci	a2, 8, 420034f6 <get_available_int+0x116>
            if (vd->flags & VECDESC_FL_SHARED) {
420034ba:	009782        	l16si	a8, a7, 0
420034bd:	490c      	movi.n	a9, 4
420034bf:	108890        	and	a8, a8, a9
420034c2:	238880        	sext	a8, a8, 15
420034c5:	08ac      	beqz.n	a8, 420034e9 <get_available_int+0x109>
                shared_vector_desc_t *svdesc = vd->shared_vec_info;
420034c7:	1788      	l32i.n	a8, a7, 4
                int no = 0;
420034c9:	090c      	movi.n	a9, 0
                while (svdesc != NULL) {
420034cb:	0000c6        	j	420034d2 <get_available_int+0xf2>
                    no++;
420034ce:	991b      	addi.n	a9, a9, 1
                    svdesc = svdesc->next;
420034d0:	5888      	l32i.n	a8, a8, 20
                while (svdesc != NULL) {
420034d2:	ff8856        	bnez	a8, 420034ce <get_available_int+0xee>
                if (no<bestSharedCt || bestPriority > intr_desc.priority) {
420034d5:	9188      	l32i.n	a8, a1, 36
420034d7:	052987        	blt	a9, a8, 420034e0 <get_available_int+0x100>
420034da:	032182        	l32i	a8, a1, 12
420034dd:	28a857        	bge	a8, a5, 42003509 <get_available_int+0x129>
                    bestPriority = intr_desc.priority;
420034e0:	3158      	l32i.n	a5, a1, 12
                    bestSharedCt = no;
420034e2:	9199      	s32i.n	a9, a1, 36
                    best = x;
420034e4:	8169      	s32i.n	a6, a1, 32
420034e6:	0007c6        	j	42003509 <get_available_int+0x129>
                if (best == -1) {
420034e9:	8188      	l32i.n	a8, a1, 32
420034eb:	1a0866        	bnei	a8, -1, 42003509 <get_available_int+0x129>
                    if (bestPriority > intr_desc.priority) {
420034ee:	3188      	l32i.n	a8, a1, 12
420034f0:	0a2857        	blt	a8, a5, 420034fe <get_available_int+0x11e>
420034f3:	000486        	j	42003509 <get_available_int+0x129>
            if (bestPriority > intr_desc.priority) {
420034f6:	3188      	l32i.n	a8, a1, 12
420034f8:	092857        	blt	a8, a5, 42003505 <get_available_int+0x125>
420034fb:	000286        	j	42003509 <get_available_int+0x129>
                        bestPriority = intr_desc.priority;
420034fe:	085d      	mov.n	a5, a8
                        best = x;
42003500:	8169      	s32i.n	a6, a1, 32
42003502:	0000c6        	j	42003509 <get_available_int+0x129>
                bestPriority = intr_desc.priority;
42003505:	085d      	mov.n	a5, a8
                best = x;
42003507:	8169      	s32i.n	a6, a1, 32
    for (x = 0; x < CPU_INT_LINES_COUNT; x++) {
42003509:	661b      	addi.n	a6, a6, 1
4200350b:	000286        	j	42003519 <get_available_int+0x139>
    int best=-1;
4200350e:	8149      	s32i.n	a4, a1, 32
    int bestSharedCt=INT_MAX;
42003510:	f40a81        	l32r	a8, 42000538 <_stext+0x518> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42003513:	9189      	s32i.n	a8, a1, 36
    int bestPriority=9;
42003515:	950c      	movi.n	a5, 9
    for (x = 0; x < CPU_INT_LINES_COUNT; x++) {
42003517:	060c      	movi.n	a6, 0
42003519:	f81c      	movi.n	a8, 31
4200351b:	022867        	blt	a8, a6, 42003521 <get_available_int+0x141>
4200351e:	ffd786        	j	42003480 <get_available_int+0xa0>
}
42003521:	8128      	l32i.n	a2, a1, 32
42003523:	f01d      	retw.n
42003525:	000000        	ill

42003528 <esp_intr_ptr_in_isr_region>:
{
42003528:	004136        	entry	a1, 32
    return ((intptr_t)p >= SOC_IRAM_LOW && (intptr_t)p < SOC_IRAM_HIGH);
4200352b:	f36d81        	l32r	a8, 420002e0 <_stext+0x2c0> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
4200352e:	828a      	add.n	a8, a2, a8
    return esp_ptr_in_iram(ptr) || esp_ptr_in_rtc_iram_fast(ptr) || esp_ptr_in_rom(ptr);
42003530:	f36d91        	l32r	a9, 420002e4 <_stext+0x2c4> (6ffff <UserFrameTotalSize+0x6feff>)
42003533:	0fb987        	bgeu	a9, a8, 42003546 <esp_intr_ptr_in_isr_region+0x1e>
        (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH);
42003536:	f36c81        	l32r	a8, 420002e8 <_stext+0x2c8> (c0000000 <_rtc_reserved_end+0x5ff00000>)
42003539:	228a      	add.n	a2, a2, a8
4200353b:	f36c81        	l32r	a8, 420002ec <_stext+0x2cc> (5ffff <UserFrameTotalSize+0x5feff>)
4200353e:	0ab827        	bgeu	a8, a2, 4200354c <esp_intr_ptr_in_isr_region+0x24>
42003541:	020c      	movi.n	a2, 0
42003543:	0001c6        	j	4200354e <esp_intr_ptr_in_isr_region+0x26>
42003546:	120c      	movi.n	a2, 1
42003548:	000086        	j	4200354e <esp_intr_ptr_in_isr_region+0x26>
4200354b:	120c00        	andbc	b0, b12, b0
}
4200354e:	f01d      	retw.n

42003550 <esp_intr_alloc_intrstatus>:
{
42003550:	00a136        	entry	a1, 80
42003553:	5179      	s32i.n	a7, a1, 20
42003555:	4159      	s32i.n	a5, a1, 16
    if ((flags & ESP_INTR_FLAG_SHARED) && (flags & ESP_INTR_FLAG_EDGE)) {
42003557:	00a382        	movi	a8, 0x300
4200355a:	02c387        	bnall	a3, a8, 42003560 <esp_intr_alloc_intrstatus+0x10>
4200355d:	00b006        	j	42003821 <esp_intr_alloc_intrstatus+0x2d1>
    if ((flags & ESP_INTR_FLAG_HIGH) && (handler)) {
42003560:	348430        	extui	a8, a3, 4, 4
42003563:	002816        	beqz	a8, 42003569 <esp_intr_alloc_intrstatus+0x19>
42003566:	2be656        	bnez	a6, 42003828 <esp_intr_alloc_intrstatus+0x2d8>
    if ((flags & ESP_INTR_FLAG_SHARED) && (!handler || source<0)) {
42003569:	00a182        	movi	a8, 0x100
4200356c:	107380        	and	a7, a3, a8
4200356f:	0e0387        	bnone	a3, a8, 42003581 <esp_intr_alloc_intrstatus+0x31>
42003572:	40f680        	nsau	a8, a6
42003575:	418580        	srli	a8, a8, 5
42003578:	059f20        	extui	a9, a2, 31, 1
4200357b:	208890        	or	a8, a8, a9
4200357e:	2ae856        	bnez	a8, 42003830 <esp_intr_alloc_intrstatus+0x2e0>
    if (intrstatusreg && !intrstatusmask) {
42003581:	01a092        	movi	a9, 1
42003584:	839440        	moveqz	a9, a4, a4
42003587:	042182        	l32i	a8, a1, 16
4200358a:	40f880        	nsau	a8, a8
4200358d:	418580        	srli	a8, a8, 5
42003590:	020987        	bnone	a9, a8, 42003596 <esp_intr_alloc_intrstatus+0x46>
42003593:	00a846        	j	42003838 <esp_intr_alloc_intrstatus+0x2e8>
    if ((flags & ESP_INTR_FLAG_IRAM) && handler && !esp_intr_ptr_in_isr_region(handler)) {
42003596:	0a63a7        	bbci	a3, 10, 420035a4 <esp_intr_alloc_intrstatus+0x54>
42003599:	007616        	beqz	a6, 420035a4 <esp_intr_alloc_intrstatus+0x54>
4200359c:	06ad      	mov.n	a10, a6
4200359e:	fff8a5        	call8	42003528 <esp_intr_ptr_in_isr_region>
420035a1:	299a16        	beqz	a10, 4200383e <esp_intr_alloc_intrstatus+0x2ee>
    if ((flags & ESP_INTR_FLAG_LEVELMASK) == 0) {
420035a4:	648130        	extui	a8, a3, 1, 7
420035a7:	e8cc      	bnez.n	a8, 420035b9 <esp_intr_alloc_intrstatus+0x69>
        if (flags & ESP_INTR_FLAG_SHARED) {
420035a9:	778c      	beqz.n	a7, 420035b4 <esp_intr_alloc_intrstatus+0x64>
            flags |= ESP_INTR_FLAG_LEVEL1;
420035ab:	280c      	movi.n	a8, 2
420035ad:	203380        	or	a3, a3, a8
420035b0:	000146        	j	420035b9 <esp_intr_alloc_intrstatus+0x69>
420035b3:	e80c00        	lsi	f0, a12, 0x3a0
            flags |= ESP_INTR_FLAG_LOWMED;
420035b6:	203380        	or	a3, a3, a8
    if (source == ETS_INTERNAL_TIMER0_INTR_SOURCE) {
420035b9:	090226        	beqi	a2, -1, 420035c6 <esp_intr_alloc_intrstatus+0x76>
    if (source == ETS_INTERNAL_TIMER1_INTR_SOURCE) {
420035bc:	e87c      	movi.n	a8, -2
420035be:	0e1287        	beq	a2, a8, 420035d0 <esp_intr_alloc_intrstatus+0x80>
420035c1:	f77c      	movi.n	a7, -1
420035c3:	000046        	j	420035c8 <esp_intr_alloc_intrstatus+0x78>
        force = ETS_INTERNAL_TIMER0_INTR_NO;
420035c6:	670c      	movi.n	a7, 6
    if (source == ETS_INTERNAL_TIMER2_INTR_SOURCE) {
420035c8:	d87c      	movi.n	a8, -3
420035ca:	049287        	bne	a2, a8, 420035d2 <esp_intr_alloc_intrstatus+0x82>
420035cd:	000246        	j	420035da <esp_intr_alloc_intrstatus+0x8a>
        force = ETS_INTERNAL_TIMER1_INTR_NO;
420035d0:	f70c      	movi.n	a7, 15
    if (source == ETS_INTERNAL_SW0_INTR_SOURCE) {
420035d2:	c87c      	movi.n	a8, -4
420035d4:	049287        	bne	a2, a8, 420035dc <esp_intr_alloc_intrstatus+0x8c>
420035d7:	000246        	j	420035e4 <esp_intr_alloc_intrstatus+0x94>
        force = ETS_INTERNAL_TIMER2_INTR_NO;
420035da:	071c      	movi.n	a7, 16
    if (source == ETS_INTERNAL_SW1_INTR_SOURCE) {
420035dc:	b87c      	movi.n	a8, -5
420035de:	049287        	bne	a2, a8, 420035e6 <esp_intr_alloc_intrstatus+0x96>
420035e1:	000246        	j	420035ee <esp_intr_alloc_intrstatus+0x9e>
        force = ETS_INTERNAL_SW0_INTR_NO;
420035e4:	770c      	movi.n	a7, 7
    if (source == ETS_INTERNAL_PROFILING_INTR_SOURCE) {
420035e6:	a87c      	movi.n	a8, -6
420035e8:	099287        	bne	a2, a8, 420035f5 <esp_intr_alloc_intrstatus+0xa5>
420035eb:	000106        	j	420035f3 <esp_intr_alloc_intrstatus+0xa3>
        force = ETS_INTERNAL_SW1_INTR_NO;
420035ee:	d71c      	movi.n	a7, 29
420035f0:	000046        	j	420035f5 <esp_intr_alloc_intrstatus+0xa5>
        force = ETS_INTERNAL_PROFILING_INTR_NO;
420035f3:	b70c      	movi.n	a7, 11
    ret = heap_caps_malloc(sizeof(intr_handle_data_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
420035f5:	f3b0b1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
420035f8:	8a0c      	movi.n	a10, 8
420035fa:	f3c981        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
420035fd:	0008e0        	callx8	a8
42003600:	61a9      	s32i.n	a10, a1, 24
    if (ret == NULL) {
42003602:	23ea16        	beqz	a10, 42003844 <esp_intr_alloc_intrstatus+0x2f4>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
42003605:	fb7c      	movi.n	a11, -1
42003607:	f3cda1        	l32r	a10, 4200053c <_stext+0x51c> (3fc91f50 <spinlock>)
4200360a:	f38181        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200360d:	0008e0        	callx8	a8
42003610:	03eb80        	rsr.prid	a8
42003613:	048d80        	extui	a8, a8, 13, 1
42003616:	7189      	s32i.n	a8, a1, 28
    int intr = get_available_int(flags, cpu, force, source);
42003618:	02dd      	mov.n	a13, a2
4200361a:	07cd      	mov.n	a12, a7
4200361c:	08bd      	mov.n	a11, a8
4200361e:	03ad      	mov.n	a10, a3
42003620:	ffdbe5        	call8	420033e0 <get_available_int>
42003623:	0a5d      	mov.n	a5, a10
    if (intr == -1) {
42003625:	390a66        	bnei	a10, -1, 42003662 <esp_intr_alloc_intrstatus+0x112>
        portEXIT_CRITICAL(&spinlock);
42003628:	f3c5a1        	l32r	a10, 4200053c <_stext+0x51c> (3fc91f50 <spinlock>)
4200362b:	f37a81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4200362e:	0008e0        	callx8	a8
        free(ret);
42003631:	61a8      	l32i.n	a10, a1, 24
42003633:	f3cd81        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42003636:	0008e0        	callx8	a8
        ESP_LOGE(TAG, "No free interrupt inputs for %s interrupt (flags 0x%X)", esp_isr_names[source], flags);
42003639:	f28981        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200363c:	0008e0        	callx8	a8
4200363f:	f3c081        	l32r	a8, 42000540 <_stext+0x520> (3c0288b8 <esp_isr_names>)
42003642:	a08280        	addx4	a8, a2, a8
42003645:	f3bfb1        	l32r	a11, 42000544 <_stext+0x524> (3c02352c <_flash_rodata_start+0x340c>)
42003648:	0139      	s32i.n	a3, a1, 0
4200364a:	08f8      	l32i.n	a15, a8, 0
4200364c:	0bed      	mov.n	a14, a11
4200364e:	0add      	mov.n	a13, a10
42003650:	f3bec1        	l32r	a12, 42000548 <_stext+0x528> (3c023538 <_flash_rodata_start+0x3418>)
42003653:	01a0a2        	movi	a10, 1
42003656:	f28f81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42003659:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
4200365c:	05a122        	movi	a2, 0x105
4200365f:	007906        	j	42003847 <esp_intr_alloc_intrstatus+0x2f7>
    vector_desc_t *vd = get_desc_for_int(intr, cpu);
42003662:	0721b2        	l32i	a11, a1, 28
42003665:	ffbe65        	call8	4200324c <get_desc_for_int>
42003668:	207aa0        	or	a7, a10, a10
    if (vd == NULL) {
4200366b:	019a56        	bnez	a10, 42003688 <esp_intr_alloc_intrstatus+0x138>
        portEXIT_CRITICAL(&spinlock);
4200366e:	f3b3a1        	l32r	a10, 4200053c <_stext+0x51c> (3fc91f50 <spinlock>)
42003671:	f36881        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42003674:	0008e0        	callx8	a8
        free(ret);
42003677:	0621a2        	l32i	a10, a1, 24
4200367a:	f3bb81        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
4200367d:	0008e0        	callx8	a8
        return ESP_ERR_NO_MEM;
42003680:	01a122        	movi	a2, 0x101
42003683:	007006        	j	42003847 <esp_intr_alloc_intrstatus+0x2f7>
42003686:	870000        	lsi	f0, a0, 0x21c
    if (flags & ESP_INTR_FLAG_SHARED) {
42003689:	4602e3        	lsi	f14, a2, 0x118
4200368c:	b10024        	lsi	f2, a0, 0x2c4
        shared_vector_desc_t *sh_vec = heap_caps_malloc(sizeof(shared_vector_desc_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
4200368f:	f38a      	add.n	a15, a3, a8
42003691:	8a1c      	movi.n	a10, 24
42003693:	f3a381        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42003696:	0008e0        	callx8	a8
42003699:	81a9      	s32i.n	a10, a1, 32
        if (sh_vec == NULL) {
4200369b:	5adc      	bnez.n	a10, 420036b4 <esp_intr_alloc_intrstatus+0x164>
            portEXIT_CRITICAL(&spinlock);
4200369d:	f3a7a1        	l32r	a10, 4200053c <_stext+0x51c> (3fc91f50 <spinlock>)
420036a0:	f35d81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420036a3:	0008e0        	callx8	a8
            free(ret);
420036a6:	61a8      	l32i.n	a10, a1, 24
420036a8:	f3b081        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
420036ab:	0008e0        	callx8	a8
            return ESP_ERR_NO_MEM;
420036ae:	01a122        	movi	a2, 0x101
420036b1:	006486        	j	42003847 <esp_intr_alloc_intrstatus+0x2f7>
        memset(sh_vec, 0, sizeof(shared_vector_desc_t));
420036b4:	8c1c      	movi.n	a12, 24
420036b6:	0b0c      	movi.n	a11, 0
420036b8:	81a8      	l32i.n	a10, a1, 32
420036ba:	f31181        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420036bd:	0008e0        	callx8	a8
        sh_vec->statusreg = (uint32_t*)intrstatusreg;
420036c0:	81b8      	l32i.n	a11, a1, 32
420036c2:	1b49      	s32i.n	a4, a11, 4
        sh_vec->statusmask = intrstatusmask;
420036c4:	4188      	l32i.n	a8, a1, 16
420036c6:	2b89      	s32i.n	a8, a11, 8
        sh_vec->isr = handler;
420036c8:	3b69      	s32i.n	a6, a11, 12
        sh_vec->arg = arg;
420036ca:	5188      	l32i.n	a8, a1, 20
420036cc:	4b89      	s32i.n	a8, a11, 16
        sh_vec->next = vd->shared_vec_info;
420036ce:	1788      	l32i.n	a8, a7, 4
420036d0:	5b89      	s32i.n	a8, a11, 20
        sh_vec->source = source;
420036d2:	748020        	extui	a8, a2, 0, 8
420036d5:	988a      	add.n	a9, a8, a8
420036d7:	001b82        	l16ui	a8, a11, 0
420036da:	01aea2        	movi	a10, 0xfffffe01
420036dd:	1088a0        	and	a8, a8, a10
420036e0:	208890        	or	a8, a8, a9
420036e3:	005b82        	s16i	a8, a11, 0
        sh_vec->disabled = 0;
420036e6:	e97c      	movi.n	a9, -2
420036e8:	108890        	and	a8, a8, a9
420036eb:	005b82        	s16i	a8, a11, 0
        vd->shared_vec_info = sh_vec;
420036ee:	17b9      	s32i.n	a11, a7, 4
        vd->flags |= VECDESC_FL_SHARED;
420036f0:	009782        	l16si	a8, a7, 0
420036f3:	490c      	movi.n	a9, 4
420036f5:	208890        	or	a8, a8, a9
420036f8:	005782        	s16i	a8, a7, 0
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
420036fb:	f81c      	movi.n	a8, 31
420036fd:	11b857        	bgeu	a8, a5, 42003712 <esp_intr_alloc_intrstatus+0x1c2>
42003700:	f393d1        	l32r	a13, 4200054c <_stext+0x52c> (3c02357c <_flash_rodata_start+0x345c>)
42003703:	f393c1        	l32r	a12, 42000550 <_stext+0x530> (3c027b4c <__func__$3>)
42003706:	74a1b2        	movi	a11, 0x174
42003709:	f392a1        	l32r	a10, 42000554 <_stext+0x534> (3c0235d4 <_flash_rodata_start+0x34b4>)
4200370c:	f26d81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200370f:	0008e0        	callx8	a8
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
42003712:	07cd      	mov.n	a12, a7
42003714:	f391b1        	l32r	a11, 42000558 <_stext+0x538> (40376454 <shared_intr_isr>)
42003717:	05ad      	mov.n	a10, a5
42003719:	12ade5        	call8	420161f8 <xt_set_interrupt_handler>
}
4200371c:	0018c6        	j	42003783 <esp_intr_alloc_intrstatus+0x233>
4200371f:	880c00        	lsi	f0, a12, 0x220
        vd->flags = VECDESC_FL_NONSHARED;
42003722:	005a82        	s16i	a8, a10, 0
        if (handler) {
42003725:	f69c      	beqz.n	a6, 42003748 <esp_intr_alloc_intrstatus+0x1f8>
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
42003727:	f81c      	movi.n	a8, 31
42003729:	11b857        	bgeu	a8, a5, 4200373e <esp_intr_alloc_intrstatus+0x1ee>
4200372c:	f388d1        	l32r	a13, 4200054c <_stext+0x52c> (3c02357c <_flash_rodata_start+0x345c>)
4200372f:	f388c1        	l32r	a12, 42000550 <_stext+0x530> (3c027b4c <__func__$3>)
42003732:	74a1b2        	movi	a11, 0x174
42003735:	f387a1        	l32r	a10, 42000554 <_stext+0x534> (3c0235d4 <_flash_rodata_start+0x34b4>)
42003738:	f26281        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200373b:	0008e0        	callx8	a8
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
4200373e:	51c8      	l32i.n	a12, a1, 20
42003740:	06bd      	mov.n	a11, a6
42003742:	20a550        	or	a10, a5, a5
42003745:	12ab25        	call8	420161f8 <xt_set_interrupt_handler>
        if (flags & ESP_INTR_FLAG_EDGE) {
42003748:	246397        	bbci	a3, 9, 42003770 <esp_intr_alloc_intrstatus+0x220>
 *
 * @param intr_num Interrupt number (from 0 to 31)
 */
FORCE_INLINE_ATTR void esp_cpu_intr_edge_ack(int intr_num)
{
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
4200374b:	f81c      	movi.n	a8, 31
4200374d:	11b857        	bgeu	a8, a5, 42003762 <esp_intr_alloc_intrstatus+0x212>
42003750:	f37fd1        	l32r	a13, 4200054c <_stext+0x52c> (3c02357c <_flash_rodata_start+0x345c>)
42003753:	f382c1        	l32r	a12, 4200055c <_stext+0x53c> (3c027b34 <__func__$2>)
42003756:	c3a1b2        	movi	a11, 0x1c3
42003759:	f37ea1        	l32r	a10, 42000554 <_stext+0x534> (3c0235d4 <_flash_rodata_start+0x34b4>)
4200375c:	f25981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200375f:	0008e0        	callx8	a8
#ifdef __XTENSA__
    xthal_set_intclear((unsigned) (1 << intr_num));
42003762:	1a0c      	movi.n	a10, 1
42003764:	401500        	ssl	a5
42003767:	a1aa00        	sll	a10, a10
4200376a:	f38081        	l32r	a8, 4200056c <_stext+0x54c> (40001be4 <xthal_set_intclear>)
4200376d:	0008e0        	callx8	a8
        vd->source = source;
42003770:	749020        	extui	a9, a2, 0, 8
42003773:	0199a0        	slli	a9, a9, 22
42003776:	0788      	l32i.n	a8, a7, 0
42003778:	f37aa1        	l32r	a10, 42000560 <_stext+0x540> (c03fffff <_rtc_reserved_end+0x602fffff>)
4200377b:	1088a0        	and	a8, a8, a10
4200377e:	208890        	or	a8, a8, a9
42003781:	0789      	s32i.n	a8, a7, 0
    if (flags & ESP_INTR_FLAG_IRAM) {
42003783:	2963a7        	bbci	a3, 10, 420037b0 <esp_intr_alloc_intrstatus+0x260>
        vd->flags |= VECDESC_FL_INIRAM;
42003786:	009782        	l16si	a8, a7, 0
42003789:	290c      	movi.n	a9, 2
4200378b:	208890        	or	a8, a8, a9
4200378e:	005782        	s16i	a8, a7, 0
        non_iram_int_mask[cpu] &= ~(1<<intr);
42003791:	f37491        	l32r	a9, 42000564 <_stext+0x544> (3fc94ac4 <non_iram_int_mask>)
42003794:	7188      	l32i.n	a8, a1, 28
42003796:	a09890        	addx4	a9, a8, a9
42003799:	09a8      	l32i.n	a10, a9, 0
4200379b:	180c      	movi.n	a8, 1
4200379d:	401500        	ssl	a5
420037a0:	a18800        	sll	a8, a8
420037a3:	1088a0        	and	a8, a8, a10
420037a6:	3088a0        	xor	a8, a8, a10
420037a9:	0989      	s32i.n	a8, a9, 0
420037ab:	0008c6        	j	420037d2 <esp_intr_alloc_intrstatus+0x282>
420037ae:	820000        	mull	a0, a0, a0
        vd->flags &= ~VECDESC_FL_INIRAM;
420037b1:	7c0097        	bnone	a0, a9, 42003831 <esp_intr_alloc_intrstatus+0x2e1>
420037b4:	90d9      	s32i.n	a13, a0, 36
420037b6:	1088      	l32i.n	a8, a0, 4
420037b8:	005782        	s16i	a8, a7, 0
        non_iram_int_mask[cpu] |= (1<<intr);
420037bb:	f36a81        	l32r	a8, 42000564 <_stext+0x544> (3fc94ac4 <non_iram_int_mask>)
420037be:	7198      	l32i.n	a9, a1, 28
420037c0:	a08980        	addx4	a8, a9, a8
420037c3:	0898      	l32i.n	a9, a8, 0
420037c5:	1a0c      	movi.n	a10, 1
420037c7:	401500        	ssl	a5
420037ca:	a1aa00        	sll	a10, a10
420037cd:	2099a0        	or	a9, a9, a10
420037d0:	0899      	s32i.n	a9, a8, 0
    if (source>=0) {
420037d2:	00b296        	bltz	a2, 420037e1 <esp_intr_alloc_intrstatus+0x291>
        esp_rom_route_intr_matrix(cpu, source, intr);
420037d5:	05cd      	mov.n	a12, a5
420037d7:	02bd      	mov.n	a11, a2
420037d9:	71a8      	l32i.n	a10, a1, 28
420037db:	f23f81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420037de:	0008e0        	callx8	a8
    ret->vector_desc = vd;
420037e1:	6198      	l32i.n	a9, a1, 24
420037e3:	0979      	s32i.n	a7, a9, 0
    ret->shared_vector_desc = vd->shared_vec_info;
420037e5:	1788      	l32i.n	a8, a7, 4
420037e7:	1989      	s32i.n	a8, a9, 4
    ESP_INTR_ENABLE(intr);
420037e9:	05ad      	mov.n	a10, a5
420037eb:	f28781        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
420037ee:	0008e0        	callx8	a8
    if (flags & ESP_INTR_FLAG_INTRDISABLED) {
420037f1:	0763b7        	bbci	a3, 11, 420037fc <esp_intr_alloc_intrstatus+0x2ac>
        esp_intr_disable(ret);
420037f4:	61a8      	l32i.n	a10, a1, 24
420037f6:	f35e81        	l32r	a8, 42000570 <_stext+0x550> (40376588 <esp_intr_disable>)
420037f9:	0008e0        	callx8	a8
    portEXIT_CRITICAL(&spinlock);
420037fc:	f350a1        	l32r	a10, 4200053c <_stext+0x51c> (3fc91f50 <spinlock>)
420037ff:	f30581        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42003802:	0008e0        	callx8	a8
    if (ret_handle != NULL) {
42003805:	142182        	l32i	a8, a1, 80
42003808:	888c      	beqz.n	a8, 42003814 <esp_intr_alloc_intrstatus+0x2c4>
        *ret_handle = ret;
4200380a:	6198      	l32i.n	a9, a1, 24
4200380c:	0899      	s32i.n	a9, a8, 0
    return ESP_OK;
4200380e:	020c      	movi.n	a2, 0
42003810:	000cc6        	j	42003847 <esp_intr_alloc_intrstatus+0x2f7>
42003813:	61a800        	lsi	f0, a8, 0x184
        free(ret);
42003816:	f35481        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42003819:	0008e0        	callx8	a8
    return ESP_OK;
4200381c:	020c      	movi.n	a2, 0
4200381e:	000946        	j	42003847 <esp_intr_alloc_intrstatus+0x2f7>
        return ESP_ERR_INVALID_ARG;
42003821:	02a122        	movi	a2, 0x102
42003824:	0007c6        	j	42003847 <esp_intr_alloc_intrstatus+0x2f7>
42003827:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4200382a:	060602        	l8ui	a0, a6, 6
4200382d:	000000        	ill
        return ESP_ERR_INVALID_ARG;
42003830:	02a122        	movi	a2, 0x102
42003833:	000406        	j	42003847 <esp_intr_alloc_intrstatus+0x2f7>
42003836:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
42003839:	0602a1        	l32r	a10, 41fc5044 <_coredump_iram_end+0x1c43144>
4200383c:	220002        	l8ui	a0, a0, 34
        return ESP_ERR_INVALID_ARG;
4200383f:	8602a1        	l32r	a10, 41fe5048 <_coredump_iram_end+0x1c63148>
42003842:	220000        	orb	b0, b0, b0
        return ESP_ERR_NO_MEM;
42003845:	1d01a1        	l32r	a10, 41fcac4c <_coredump_iram_end+0x1c48d4c>
}
42003848:	0000f0        	callx12	a0
	...

4200384c <esp_intr_alloc>:
{
4200384c:	006136        	entry	a1, 48
4200384f:	02ad      	mov.n	a10, a2
42003851:	03bd      	mov.n	a11, a3
42003853:	04ed      	mov.n	a14, a4
42003855:	05fd      	mov.n	a15, a5
    return esp_intr_alloc_intrstatus(source, flags, 0, 0, handler, arg, ret_handle);
42003857:	0169      	s32i.n	a6, a1, 0
42003859:	0d0c      	movi.n	a13, 0
4200385b:	0dcd      	mov.n	a12, a13
4200385d:	ffcf25        	call8	42003550 <esp_intr_alloc_intrstatus>
}
42003860:	0a2d      	mov.n	a2, a10
42003862:	f01d      	retw.n

42003864 <s_rtc_isr_noniram_hook>:
{
42003864:	004136        	entry	a1, 32
    rtc_intr_cache |= rtc_intr_mask;
42003867:	f34391        	l32r	a9, 42000574 <_stext+0x554> (3fc92930 <rtc_intr_cache>)
4200386a:	0988      	l32i.n	a8, a9, 0
4200386c:	208820        	or	a8, a8, a2
4200386f:	0989      	s32i.n	a8, a9, 0
}
42003871:	f01d      	retw.n
	...

42003874 <s_rtc_isr_noniram_hook_relieve>:
{
42003874:	004136        	entry	a1, 32
    rtc_intr_cache &= ~rtc_intr_mask;
42003877:	f33f81        	l32r	a8, 42000574 <_stext+0x554> (3fc92930 <rtc_intr_cache>)
4200387a:	0898      	l32i.n	a9, a8, 0
4200387c:	102290        	and	a2, a2, a9
4200387f:	302290        	xor	a2, a2, a9
42003882:	0829      	s32i.n	a2, a8, 0
}
42003884:	f01d      	retw.n
	...

42003888 <rtc_isr_ensure_installed>:
{
42003888:	004136        	entry	a1, 32
4200388b:	ffafb2        	movi	a11, -1
4200388e:	f33aa1        	l32r	a10, 42000578 <_stext+0x558> (3fc9291c <s_rtc_isr_handler_list_lock>)
42003891:	f2df81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42003894:	0008e0        	callx8	a8
    if (s_rtc_isr_handle) {
42003897:	f33981        	l32r	a8, 4200057c <_stext+0x55c> (3fc94afc <s_rtc_isr_handle>)
4200389a:	002882        	l32i	a8, a8, 0
4200389d:	58fc      	bnez.n	a8, 420038d6 <rtc_isr_ensure_installed+0x4e>
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
4200389f:	0d0c      	movi.n	a13, 0
420038a1:	f33781        	l32r	a8, 42000580 <_stext+0x560> (60008040 <RTCCNTL+0x40>)
420038a4:	0020c0        	memw
420038a7:	08d9      	s32i.n	a13, a8, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
420038a9:	f33681        	l32r	a8, 42000584 <_stext+0x564> (6000804c <RTCCNTL+0x4c>)
420038ac:	f97c      	movi.n	a9, -1
420038ae:	0020c0        	memw
420038b1:	0899      	s32i.n	a9, a8, 0
    err = esp_intr_alloc(ETS_RTC_CORE_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_isr, NULL, &s_rtc_isr_handle);
420038b3:	f332e1        	l32r	a14, 4200057c <_stext+0x55c> (3fc94afc <s_rtc_isr_handle>)
420038b6:	f334c1        	l32r	a12, 42000588 <_stext+0x568> (403766e4 <rtc_isr>)
420038b9:	00a4b2        	movi	a11, 0x400
420038bc:	7a2c      	movi.n	a10, 39
420038be:	fff8e5        	call8	4200384c <esp_intr_alloc>
420038c1:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
420038c3:	1adc      	bnez.n	a10, 420038d8 <rtc_isr_ensure_installed+0x50>
    rtc_isr_cpu = esp_intr_get_cpu(s_rtc_isr_handle);
420038c5:	f32d81        	l32r	a8, 4200057c <_stext+0x55c> (3fc94afc <s_rtc_isr_handle>)
420038c8:	08a8      	l32i.n	a10, a8, 0
420038ca:	110425        	call8	4201490c <esp_intr_get_cpu>
420038cd:	f32f81        	l32r	a8, 4200058c <_stext+0x56c> (3fc92928 <rtc_isr_cpu>)
420038d0:	08a9      	s32i.n	a10, a8, 0
420038d2:	000086        	j	420038d8 <rtc_isr_ensure_installed+0x50>
420038d5:	020c00        	andb	b0, b12, b0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
420038d8:	f328a1        	l32r	a10, 42000578 <_stext+0x558> (3fc9291c <s_rtc_isr_handler_list_lock>)
420038db:	f2ce81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420038de:	0008e0        	callx8	a8
}
420038e1:	f01d      	retw.n
	...

420038e4 <rtc_isr_register>:
{
420038e4:	004136        	entry	a1, 32
420038e7:	027d      	mov.n	a7, a2
    esp_err_t err = rtc_isr_ensure_installed();
420038e9:	fff9e5        	call8	42003888 <rtc_isr_ensure_installed>
420038ec:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
420038ee:	04ea56        	bnez	a10, 42003940 <rtc_isr_register+0x5c>
    rtc_isr_handler_t* item = heap_caps_malloc(sizeof(*item), MALLOC_CAP_INTERNAL);
420038f1:	f327b1        	l32r	a11, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
420038f4:	4a1c      	movi.n	a10, 20
420038f6:	f30a81        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
420038f9:	0008e0        	callx8	a8
420038fc:	0a6d      	mov.n	a6, a10
    if (item == NULL) {
420038fe:	03ba16        	beqz	a10, 4200393d <rtc_isr_register+0x59>
    item->handler = handler;
42003901:	1a79      	s32i.n	a7, a10, 4
    item->handler_arg = handler_arg;
42003903:	2a39      	s32i.n	a3, a10, 8
    item->mask = rtc_intr_mask;
42003905:	0a49      	s32i.n	a4, a10, 0
    item->flags = flags;
42003907:	3a59      	s32i.n	a5, a10, 12
42003909:	fb7c      	movi.n	a11, -1
4200390b:	f31ba1        	l32r	a10, 42000578 <_stext+0x558> (3fc9291c <s_rtc_isr_handler_list_lock>)
4200390e:	f2c081        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42003911:	0008e0        	callx8	a8
    if (flags & RTC_INTR_FLAG_IRAM) {
42003914:	086507        	bbci	a5, 0, 42003920 <rtc_isr_register+0x3c>
        s_rtc_isr_noniram_hook(rtc_intr_mask);
42003917:	04ad      	mov.n	a10, a4
42003919:	fff4a5        	call8	42003864 <s_rtc_isr_noniram_hook>
4200391c:	000146        	j	42003925 <rtc_isr_register+0x41>
4200391f:	04ad00        	extui	a10, a0, 13, 1
        s_rtc_isr_noniram_hook_relieve(rtc_intr_mask);
42003922:	fff525        	call8	42003874 <s_rtc_isr_noniram_hook_relieve>
    SLIST_INSERT_HEAD(&s_rtc_isr_handler_list, item, next);
42003925:	f31b81        	l32r	a8, 42000594 <_stext+0x574> (3fc92924 <s_rtc_isr_handler_list>)
42003928:	0898      	l32i.n	a9, a8, 0
4200392a:	4699      	s32i.n	a9, a6, 16
4200392c:	006862        	s32i	a6, a8, 0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
4200392f:	f312a1        	l32r	a10, 42000578 <_stext+0x558> (3fc9291c <s_rtc_isr_handler_list_lock>)
42003932:	f2b881        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42003935:	0008e0        	callx8	a8
    return ESP_OK;
42003938:	000106        	j	42003940 <rtc_isr_register+0x5c>
4200393b:	220000        	orb	b0, b0, b0
        return ESP_ERR_NO_MEM;
4200393e:	1d01a1        	l32r	a10, 41fcad44 <_coredump_iram_end+0x1c48e44>
}
42003941:	0000f0        	callx12	a0

42003944 <esp_sleep_config_gpio_isolate>:
    }
}
#endif

void esp_sleep_config_gpio_isolate(void)
{
42003944:	004136        	entry	a1, 32
42003947:	f1b981        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
4200394a:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "Configure to isolate all GPIO pins in sleep state");
4200394c:	6138b6        	bltui	a8, 3, 420039b1 <esp_sleep_config_gpio_isolate+0x6d>
4200394f:	f1c481        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42003952:	0008e0        	callx8	a8
42003955:	f310c1        	l32r	a12, 42000598 <_stext+0x578> (3c02362c <_flash_rodata_start+0x350c>)
42003958:	20baa0        	or	a11, a10, a10
4200395b:	f310a1        	l32r	a10, 4200059c <_stext+0x57c> (3c023638 <_flash_rodata_start+0x3518>)
4200395e:	f1c181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42003961:	0008e0        	callx8	a8
42003964:	001246        	j	420039b1 <esp_sleep_config_gpio_isolate+0x6d>
42003967:	960000        	lsi	f0, a0, 0x258
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
        if (GPIO_IS_VALID_GPIO(gpio_num)) {
4200396a:	a203d7        	bnone	a3, a13, 42003910 <rtc_isr_register+0x2c>
4200396d:	a020a0        	addx4	a2, a0, a10
42003970:	8210a7        	beq	a0, a10, 420038f6 <rtc_isr_register+0x12>
42003973:	af          	.byte	0xaf
42003974:	ff          	.byte	0xff
42003975:	308780        	xor	a8, a7, a8
42003978:	f30a91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
4200397b:	401800        	ssl	a8
4200397e:	a19900        	sll	a9, a9
42003981:	f30881        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42003984:	400700        	ssr	a7
42003987:	918080        	srl	a8, a8
4200398a:	208980        	or	a8, a9, a8
4200398d:	f30691        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42003990:	400700        	ssr	a7
42003993:	919090        	srl	a9, a9
42003996:	9389a0        	movnez	a8, a9, a10
42003999:	0d6807        	bbci	a8, 0, 420039aa <esp_sleep_config_gpio_isolate+0x66>
            gpio_sleep_set_direction(gpio_num, GPIO_MODE_DISABLE);
4200399c:	0b0c      	movi.n	a11, 0
4200399e:	07ad      	mov.n	a10, a7
420039a0:	0550e5        	call8	42008eb0 <gpio_sleep_set_direction>
            gpio_sleep_set_pull_mode(gpio_num, GPIO_FLOATING);
420039a3:	3b0c      	movi.n	a11, 3
420039a5:	07ad      	mov.n	a10, a7
420039a7:	0559a5        	call8	42008f40 <gpio_sleep_set_pull_mode>
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
420039aa:	771b      	addi.n	a7, a7, 1
420039ac:	000106        	j	420039b4 <esp_sleep_config_gpio_isolate+0x70>
420039af:	720000        	lsi	f0, a0, 0x1c8
{
420039b2:	3c00a0        	lsi	f10, a0, 240
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
420039b5:	7708      	l32i.n	a0, a7, 28
420039b7:	afa8      	l32i.n	a10, a15, 40
        gpio_sleep_set_pull_mode(mspi_io_cs1_io_num, GPIO_PULLUP_ONLY);
    }
#endif // CONFIG_ESP_SLEEP_PSRAM_LEAKAGE_WORKAROUND && CONFIG_SPIRAM

#if CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND
    int32_t mspi_io_cs0_io_num = esp_mspi_get_io(ESP_MSPI_IO_CS0);
420039b9:	3a0c      	movi.n	a10, 3
420039bb:	061325        	call8	42009aec <esp_mspi_get_io>
    if (GPIO_IS_VALID_GPIO(mspi_io_cs0_io_num)) {
420039be:	0b2c      	movi.n	a11, 32
420039c0:	10bab0        	and	a11, a10, a11
420039c3:	f87c      	movi.n	a8, -1
420039c5:	308a80        	xor	a8, a10, a8
420039c8:	f2f691        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
420039cb:	401800        	ssl	a8
420039ce:	a19900        	sll	a9, a9
420039d1:	f2f481        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
420039d4:	400a00        	ssr	a10
420039d7:	918080        	srl	a8, a8
420039da:	208980        	or	a8, a9, a8
420039dd:	f2f291        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
420039e0:	400a00        	ssr	a10
420039e3:	919090        	srl	a9, a9
420039e6:	9389b0        	movnez	a8, a9, a11
420039e9:	096807        	bbci	a8, 0, 420039f6 <esp_sleep_config_gpio_isolate+0xb2>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_CS0), GPIO_PULLUP_ONLY);
420039ec:	3a0c      	movi.n	a10, 3
420039ee:	060fe5        	call8	42009aec <esp_mspi_get_io>
420039f1:	0b0c      	movi.n	a11, 0
420039f3:	0554e5        	call8	42008f40 <gpio_sleep_set_pull_mode>
    }
#endif // CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND

#if CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_CLK), GPIO_PULLUP_ONLY);
420039f6:	0a0c      	movi.n	a10, 0
420039f8:	060f25        	call8	42009aec <esp_mspi_get_io>
420039fb:	0b0c      	movi.n	a11, 0
420039fd:	055425        	call8	42008f40 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_Q),   GPIO_PULLUP_ONLY);
42003a00:	1a0c      	movi.n	a10, 1
42003a02:	060ea5        	call8	42009aec <esp_mspi_get_io>
42003a05:	0b0c      	movi.n	a11, 0
42003a07:	0553a5        	call8	42008f40 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D),   GPIO_PULLUP_ONLY);
42003a0a:	2a0c      	movi.n	a10, 2
42003a0c:	060de5        	call8	42009aec <esp_mspi_get_io>
42003a0f:	0b0c      	movi.n	a11, 0
42003a11:	0552e5        	call8	42008f40 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_HD),  GPIO_PULLUP_ONLY);
42003a14:	4a0c      	movi.n	a10, 4
42003a16:	060d65        	call8	42009aec <esp_mspi_get_io>
42003a19:	0b0c      	movi.n	a11, 0
42003a1b:	055265        	call8	42008f40 <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_WP),  GPIO_PULLUP_ONLY);
42003a1e:	5a0c      	movi.n	a10, 5
42003a20:	060ca5        	call8	42009aec <esp_mspi_get_io>
42003a23:	0b0c      	movi.n	a11, 0
42003a25:	0551a5        	call8	42008f40 <gpio_sleep_set_pull_mode>
#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    bool octal_mspi_required = bootloader_flash_is_octal_mode_enabled();
42003a28:	f2e181        	l32r	a8, 420005ac <_stext+0x58c> (40377670 <bootloader_flash_is_octal_mode_enabled>)
42003a2b:	0008e0        	callx8	a8
#if CONFIG_SPIRAM_MODE_OCT
    octal_mspi_required |= true;
#endif // CONFIG_SPIRAM_MODE_OCT
    if (octal_mspi_required) {
42003a2e:	032a16        	beqz	a10, 42003a64 <esp_sleep_config_gpio_isolate+0x120>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_DQS), GPIO_PULLUP_ONLY);
42003a31:	06a0a2        	movi	a10, 6
42003a34:	060b65        	call8	42009aec <esp_mspi_get_io>
42003a37:	0b0c      	movi.n	a11, 0
42003a39:	055065        	call8	42008f40 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D4),  GPIO_PULLUP_ONLY);
42003a3c:	7a0c      	movi.n	a10, 7
42003a3e:	060ae5        	call8	42009aec <esp_mspi_get_io>
42003a41:	0b0c      	movi.n	a11, 0
42003a43:	054fe5        	call8	42008f40 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D5),  GPIO_PULLUP_ONLY);
42003a46:	8a0c      	movi.n	a10, 8
42003a48:	060a25        	call8	42009aec <esp_mspi_get_io>
42003a4b:	0b0c      	movi.n	a11, 0
42003a4d:	054f25        	call8	42008f40 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D6),  GPIO_PULLUP_ONLY);
42003a50:	9a0c      	movi.n	a10, 9
42003a52:	0609a5        	call8	42009aec <esp_mspi_get_io>
42003a55:	0b0c      	movi.n	a11, 0
42003a57:	054ea5        	call8	42008f40 <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D7),  GPIO_PULLUP_ONLY);
42003a5a:	aa0c      	movi.n	a10, 10
42003a5c:	0608e5        	call8	42009aec <esp_mspi_get_io>
42003a5f:	0b0c      	movi.n	a11, 0
42003a61:	054de5        	call8	42008f40 <gpio_sleep_set_pull_mode>
    }
#endif // SOC_SPI_MEM_SUPPORT_OPI_MODE
#endif // CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU
}
42003a64:	f01d      	retw.n
	...

42003a68 <esp_sleep_enable_gpio_switch>:

void esp_sleep_enable_gpio_switch(bool enable)
{
42003a68:	004136        	entry	a1, 32
42003a6b:	742020        	extui	a2, a2, 0, 8
42003a6e:	f16f81        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42003a71:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "%s automatic switching of GPIO sleep configuration", enable ? "Enable" : "Disable");
42003a73:	7238b6        	bltui	a8, 3, 42003ae9 <esp_sleep_enable_gpio_switch+0x81>
42003a76:	f17a81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42003a79:	0008e0        	callx8	a8
42003a7c:	0abd      	mov.n	a11, a10
42003a7e:	728c      	beqz.n	a2, 42003a89 <esp_sleep_enable_gpio_switch+0x21>
42003a80:	f2ccd1        	l32r	a13, 420005b0 <_stext+0x590> (3c023678 <_flash_rodata_start+0x3558>)
42003a83:	000146        	j	42003a8c <esp_sleep_enable_gpio_switch+0x24>
42003a86:	000000        	ill
42003a89:	f2cad1        	l32r	a13, 420005b4 <_stext+0x594> (3c023680 <_flash_rodata_start+0x3560>)
42003a8c:	f2c3c1        	l32r	a12, 42000598 <_stext+0x578> (3c02362c <_flash_rodata_start+0x350c>)
42003a8f:	f2caa1        	l32r	a10, 420005b8 <_stext+0x598> (3c023688 <_flash_rodata_start+0x3568>)
42003a92:	f17481        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42003a95:	0008e0        	callx8	a8
42003a98:	001346        	j	42003ae9 <esp_sleep_enable_gpio_switch+0x81>
42003a9b:	960000        	lsi	f0, a0, 0x258
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
        if (GPIO_IS_VALID_GPIO(gpio_num)) {
42003a9e:	a20407        	bnone	a4, a0, 42003a44 <esp_sleep_config_gpio_isolate+0x100>
42003aa1:	a020a0        	addx4	a2, a0, a10
42003aa4:	8210a7        	beq	a0, a10, 42003a2a <esp_sleep_config_gpio_isolate+0xe6>
42003aa7:	af          	.byte	0xaf
42003aa8:	ff          	.byte	0xff
42003aa9:	308780        	xor	a8, a7, a8
42003aac:	f2bd91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42003aaf:	401800        	ssl	a8
42003ab2:	a19900        	sll	a9, a9
42003ab5:	f2bb81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42003ab8:	400700        	ssr	a7
42003abb:	918080        	srl	a8, a8
42003abe:	208980        	or	a8, a9, a8
42003ac1:	f2b991        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42003ac4:	400700        	ssr	a7
42003ac7:	919090        	srl	a9, a9
42003aca:	9389a0        	movnez	a8, a9, a10
42003acd:	106807        	bbci	a8, 0, 42003ae1 <esp_sleep_enable_gpio_switch+0x79>
            if (enable) {
42003ad0:	008216        	beqz	a2, 42003adc <esp_sleep_enable_gpio_switch+0x74>
                gpio_sleep_sel_en(gpio_num);
42003ad3:	07ad      	mov.n	a10, a7
42003ad5:	0557a5        	call8	42009050 <gpio_sleep_sel_en>
42003ad8:	000146        	j	42003ae1 <esp_sleep_enable_gpio_switch+0x79>
42003adb:	07ad00        	lsi	f0, a13, 28
            } else {
                gpio_sleep_sel_dis(gpio_num);
42003ade:	056025        	call8	420090e0 <gpio_sleep_sel_dis>
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003ae1:	771b      	addi.n	a7, a7, 1
42003ae3:	000106        	j	42003aeb <esp_sleep_enable_gpio_switch+0x83>
42003ae6:	000000        	ill
    ESP_EARLY_LOGI(TAG, "%s automatic switching of GPIO sleep configuration", enable ? "Enable" : "Disable");
42003ae9:	070c      	movi.n	a7, 0
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003aeb:	083c      	movi.n	a8, 48
42003aed:	aca877        	bge	a8, a7, 42003a9d <esp_sleep_enable_gpio_switch+0x35>
            }
        }
    }
}
42003af0:	f01d      	retw.n
	...

42003af4 <__esp_system_init_fn_esp_sleep_startup_init>:
}
#endif

#if CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND || CONFIG_PM_SLP_DISABLE_GPIO
ESP_SYSTEM_INIT_FN(esp_sleep_startup_init, SECONDARY, BIT(0), 105)
{
42003af4:	004136        	entry	a1, 32
/* If the TOP domain is powered off, the GPIO will also be powered off during sleep,
   and all configurations in the sleep state of GPIO will not take effect.*/
#if !CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP
    // Configure to isolate (disable the Input/Output/Pullup/Pulldown
    // function of the pin) all GPIO pins in sleep state
    esp_sleep_config_gpio_isolate();
42003af7:	ffe4e5        	call8	42003944 <esp_sleep_config_gpio_isolate>
#endif
    // Enable automatic switching of GPIO configuration
    esp_sleep_enable_gpio_switch(true);
42003afa:	01a0a2        	movi	a10, 1
42003afd:	fff6a5        	call8	42003a68 <esp_sleep_enable_gpio_switch>
    return ESP_OK;
}
42003b00:	00a022        	movi	a2, 0
42003b03:	f01d      	retw.n
42003b05:	000000        	ill

42003b08 <esp_deep_sleep_wakeup_io_reset>:
{
42003b08:	004136        	entry	a1, 32
    return REG_GET_FIELD(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL);
42003b0b:	f2aca1        	l32r	a10, 420005bc <_stext+0x59c> (600080e0 <RTCCNTL+0xe0>)
42003b0e:	0020c0        	memw
42003b11:	0a98      	l32i.n	a9, a10, 0
42003b13:	119960        	slli	a9, a9, 10
42003b16:	419a90        	srli	a9, a9, 10
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL_M);
42003b19:	0020c0        	memw
42003b1c:	0a88      	l32i.n	a8, a10, 0
42003b1e:	958680        	extui	a8, a8, 22, 10
42003b21:	0188a0        	slli	a8, a8, 22
42003b24:	0020c0        	memw
42003b27:	0a89      	s32i.n	a8, a10, 0
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
42003b29:	0a0c      	movi.n	a10, 0
42003b2b:	000f06        	j	42003b6b <esp_deep_sleep_wakeup_io_reset+0x63>
42003b2e:	810000        	src	a0, a0, a0
        int rtcio_num = rtc_io_num_map[gpio_num];
42003b31:	80f2a4        	lsi	f10, a2, 0x200
42003b34:	a08a      	add.n	a10, a0, a8
42003b36:	08b8      	l32i.n	a11, a8, 0
        if ((rtc_io_mask & BIT(rtcio_num)) == 0) {
42003b38:	2d59b7        	bbc	a9, a11, 42003b69 <esp_deep_sleep_wakeup_io_reset+0x61>
 * @note If disable the pad hold, the status of pad maybe changed in sleep mode.
 * @param rtcio_num The index of rtcio. 0 ~ MAX(rtcio).
 */
static inline void rtcio_ll_force_hold_disable(int rtcio_num)
{
    CLEAR_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, rtc_io_desc[rtcio_num].hold_force);
42003b3b:	f2a2c1        	l32r	a12, 420005c4 <_stext+0x5a4> (600080d8 <RTCCNTL+0xd8>)
42003b3e:	0020c0        	memw
42003b41:	0cd8      	l32i.n	a13, a12, 0
42003b43:	f08bb0        	subx8	a8, a11, a11
42003b46:	11e8d0        	slli	a14, a8, 3
42003b49:	f29f81        	l32r	a8, 420005c8 <_stext+0x5a8> (3c028b08 <rtc_io_desc>)
42003b4c:	88ea      	add.n	a8, a8, a14
42003b4e:	a888      	l32i.n	a8, a8, 40
42003b50:	1088d0        	and	a8, a8, a13
42003b53:	3088d0        	xor	a8, a8, a13
42003b56:	0020c0        	memw
42003b59:	0c89      	s32i.n	a8, a12, 0
        rtc_io_mask &= ~BIT(rtcio_num);
42003b5b:	180c      	movi.n	a8, 1
42003b5d:	401b00        	ssl	a11
42003b60:	a18800        	sll	a8, a8
42003b63:	108890        	and	a8, a8, a9
42003b66:	309890        	xor	a9, a8, a9
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
42003b69:	aa1b      	addi.n	a10, a10, 1
42003b6b:	083c      	movi.n	a8, 48
42003b6d:	7288a0        	lsi	f10, a8, 0x1c8
42003b70:	880b      	addi.n	a8, a8, -1
42003b72:	608080        	neg	a8, a8
42003b75:	748080        	extui	a8, a8, 0, 8
42003b78:	1b0c      	movi.n	a11, 1
42003b7a:	83b990        	moveqz	a11, a9, a9
42003b7d:	188c      	beqz.n	a8, 42003b82 <esp_deep_sleep_wakeup_io_reset+0x7a>
42003b7f:	fadb56        	bnez	a11, 42003b30 <esp_deep_sleep_wakeup_io_reset+0x28>
}
42003b82:	f01d      	retw.n

42003b84 <esp_chip_info>:
#include <string.h>
#include "esp_chip_info.h"
#include "hal/efuse_hal.h"

void esp_chip_info(esp_chip_info_t *out_info)
{
42003b84:	004136        	entry	a1, 32
    memset(out_info, 0, sizeof(*out_info));
42003b87:	0ca0c2        	movi	a12, 12
42003b8a:	00a0b2        	movi	a11, 0
42003b8d:	20a220        	or	a10, a2, a2
42003b90:	f1dc81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42003b93:	0008e0        	callx8	a8
    out_info->model = CHIP_ESP32S3;
42003b96:	980c      	movi.n	a8, 9
42003b98:	0289      	s32i.n	a8, a2, 0
    out_info->revision = efuse_hal_chip_revision();
42003b9a:	f13b81        	l32r	a8, 42000088 <_stext+0x68> (40375df8 <efuse_hal_chip_revision>)
42003b9d:	0008e0        	callx8	a8
42003ba0:	0452a2        	s16i	a10, a2, 8
    out_info->cores = 2;
42003ba3:	280c      	movi.n	a8, 2
42003ba5:	0a4282        	s8i	a8, a2, 10
    out_info->features = CHIP_FEATURE_WIFI_BGN | CHIP_FEATURE_BLE;
42003ba8:	281c      	movi.n	a8, 18
42003baa:	1289      	s32i.n	a8, a2, 4
}
42003bac:	f01d      	retw.n
	...

42003bb0 <memprot_ll_icache_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_icache_set_pms_area_0(const bool r, const bool w, const bool x)
{
42003bb0:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
42003bb3:	f28681        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003bb6:	0020c0        	memw
42003bb9:	0898      	l32i.n	a9, a8, 0
42003bbb:	f28581        	l32r	a8, 420005d0 <_stext+0x5b0> (ffff8fff <_rtc_reserved_end+0x9fef8fff>)
42003bbe:	109980        	and	a9, a9, a8
    if (r) {
42003bc1:	32cc      	bnez.n	a2, 42003bc8 <memprot_ll_icache_set_pms_area_0+0x18>
    uint32_t permissions = 0;
42003bc3:	080c      	movi.n	a8, 0
42003bc5:	000046        	j	42003bca <memprot_ll_icache_set_pms_area_0+0x1a>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003bc8:	180c      	movi.n	a8, 1
    if (w) {
42003bca:	338c      	beqz.n	a3, 42003bd1 <memprot_ll_icache_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003bcc:	2a0c      	movi.n	a10, 2
42003bce:	2088a0        	or	a8, a8, a10
    if (x) {
42003bd1:	348c      	beqz.n	a4, 42003bd8 <memprot_ll_icache_set_pms_area_0+0x28>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003bd3:	4a0c      	movi.n	a10, 4
42003bd5:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
42003bd8:	118840        	slli	a8, a8, 12
42003bdb:	248c80        	extui	a8, a8, 12, 3
42003bde:	118840        	slli	a8, a8, 12
42003be1:	209980        	or	a9, a9, a8
42003be4:	f27a81        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003be7:	0020c0        	memw
42003bea:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0);
    HAL_ASSERT((expected == memprot_ll_icache_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003bec:	f01d      	retw.n
	...

42003bf0 <memprot_ll_icache_set_pms_area_1>:

static inline void memprot_ll_icache_set_pms_area_1(const bool r, const bool w, const bool x)
{
42003bf0:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003bf3:	f27681        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003bf6:	0020c0        	memw
42003bf9:	0898      	l32i.n	a9, a8, 0
42003bfb:	f27681        	l32r	a8, 420005d4 <_stext+0x5b4> (fffc7fff <_rtc_reserved_end+0x9fec7fff>)
42003bfe:	109980        	and	a9, a9, a8
    if (r) {
42003c01:	32cc      	bnez.n	a2, 42003c08 <memprot_ll_icache_set_pms_area_1+0x18>
    uint32_t permissions = 0;
42003c03:	080c      	movi.n	a8, 0
42003c05:	000046        	j	42003c0a <memprot_ll_icache_set_pms_area_1+0x1a>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003c08:	180c      	movi.n	a8, 1
    if (w) {
42003c0a:	338c      	beqz.n	a3, 42003c11 <memprot_ll_icache_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003c0c:	2a0c      	movi.n	a10, 2
42003c0e:	2088a0        	or	a8, a8, a10
    if (x) {
42003c11:	348c      	beqz.n	a4, 42003c18 <memprot_ll_icache_set_pms_area_1+0x28>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003c13:	4a0c      	movi.n	a10, 4
42003c15:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003c18:	118810        	slli	a8, a8, 15
42003c1b:	248f80        	extui	a8, a8, 15, 3
42003c1e:	118810        	slli	a8, a8, 15
42003c21:	209980        	or	a9, a9, a8
42003c24:	f26a81        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003c27:	0020c0        	memw
42003c2a:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1);
    HAL_ASSERT((expected == memprot_ll_icache_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003c2c:	f01d      	retw.n
	...

42003c30 <memprot_ll_prepare_iram0_split_line_regval>:
{
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
}

static inline void memprot_ll_prepare_iram0_split_line_regval(const uint32_t addr, uint32_t* regval)
{
42003c30:	00c136        	entry	a1, 96
    //set category bits for given split line
    uint32_t cat[7] = { MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
42003c33:	cc1c      	movi.n	a12, 28
42003c35:	f268b1        	l32r	a11, 420005d8 <_stext+0x5b8> (3c027c40 <__func__$1+0xc>)
42003c38:	a1ca      	add.n	a10, a1, a12
42003c3a:	f0fb81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003c3d:	0008e0        	callx8	a8
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA };
    for (size_t x=0; x<7; x++) {
42003c40:	070c      	movi.n	a7, 0
42003c42:	0009c6        	j	42003c6d <memprot_ll_prepare_iram0_split_line_regval+0x3d>
        if (addr <= SRAM_RG3_LEVEL_HLIMITS(x)) {
42003c45:	cc1c      	movi.n	a12, 28
42003c47:	f265b1        	l32r	a11, 420005dc <_stext+0x5bc> (3c027c5c <__func__$1+0x28>)
42003c4a:	01ad      	mov.n	a10, a1
42003c4c:	f0f781        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003c4f:	0008e0        	callx8	a8
42003c52:	a08710        	addx4	a8, a7, a1
42003c55:	0888      	l32i.n	a8, a8, 0
42003c57:	093827        	bltu	a8, a2, 42003c64 <memprot_ll_prepare_iram0_split_line_regval+0x34>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
42003c5a:	a07710        	addx4	a7, a7, a1
42003c5d:	280c      	movi.n	a8, 2
42003c5f:	7789      	s32i.n	a8, a7, 28
            break;
42003c61:	0002c6        	j	42003c70 <memprot_ll_prepare_iram0_split_line_regval+0x40>
        } else {
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
42003c64:	a08710        	addx4	a8, a7, a1
42003c67:	090c      	movi.n	a9, 0
42003c69:	7899      	s32i.n	a9, a8, 28
    for (size_t x=0; x<7; x++) {
42003c6b:	771b      	addi.n	a7, a7, 1
42003c6d:	d477b6        	bltui	a7, 7, 42003c45 <memprot_ll_prepare_iram0_split_line_regval+0x15>

    //resolve split address' significant bits
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR_V);

    //write values to required configuration-register
    constrain_reg_fields_t cfg_reg_val = {
42003c70:	81a8      	l32i.n	a10, a1, 32
42003c72:	14a0a0        	extui	a10, a10, 0, 2
42003c75:	11aae0        	slli	a10, a10, 2
42003c78:	7188      	l32i.n	a8, a1, 28
42003c7a:	148080        	extui	a8, a8, 0, 2
42003c7d:	9198      	l32i.n	a9, a1, 36
42003c7f:	149090        	extui	a9, a9, 0, 2
42003c82:	1199c0        	slli	a9, a9, 4
42003c85:	2088a0        	or	a8, a8, a10
42003c88:	a1a8      	l32i.n	a10, a1, 40
42003c8a:	14a0a0        	extui	a10, a10, 0, 2
42003c8d:	11aaa0        	slli	a10, a10, 6
42003c90:	208890        	or	a8, a8, a9
42003c93:	b198      	l32i.n	a9, a1, 44
42003c95:	149090        	extui	a9, a9, 0, 2
42003c98:	119980        	slli	a9, a9, 8
42003c9b:	2088a0        	or	a8, a8, a10
42003c9e:	c1a8      	l32i.n	a10, a1, 48
42003ca0:	14a0a0        	extui	a10, a10, 0, 2
42003ca3:	11aa60        	slli	a10, a10, 10
42003ca6:	208890        	or	a8, a8, a9
42003ca9:	d198      	l32i.n	a9, a1, 52
42003cab:	149090        	extui	a9, a9, 0, 2
42003cae:	119940        	slli	a9, a9, 12
42003cb1:	2088a0        	or	a8, a8, a10
42003cb4:	742820        	extui	a2, a2, 8, 8
42003cb7:	112220        	slli	a2, a2, 14
42003cba:	208890        	or	a8, a8, a9
42003cbd:	208820        	or	a8, a8, a2
            .cat6 = cat[6],
            .splitaddr = conf_add,
            .reserved = 0
    };

    *regval = cfg_reg_val.val;
42003cc0:	0389      	s32i.n	a8, a3, 0
}
42003cc2:	f01d      	retw.n

42003cc4 <memprot_ll_set_iram0_split_line>:

// all the split lines registers have the same layout
static inline memprot_hal_err_t memprot_ll_set_iram0_split_line(const void *line_addr, const uint32_t sensitive_reg)
{
42003cc4:	006136        	entry	a1, 48
42003cc7:	20a220        	or	a10, a2, a2
    uint32_t addr = (uint32_t)line_addr;

    //sanity check
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
42003cca:	f24581        	l32r	a8, 420005e0 <_stext+0x5c0> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
42003ccd:	808280        	add	a8, a2, a8
42003cd0:	f24591        	l32r	a9, 420005e4 <_stext+0x5c4> (67fff <UserFrameTotalSize+0x67eff>)
42003cd3:	163987        	bltu	a9, a8, 42003ced <memprot_ll_set_iram0_split_line+0x29>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42003cd6:	748020        	extui	a8, a2, 0, 8
42003cd9:	015856        	bnez	a8, 42003cf2 <memprot_ll_set_iram0_split_line+0x2e>

    uint32_t regval;
    memprot_ll_prepare_iram0_split_line_regval(addr, &regval);
42003cdc:	01bd      	mov.n	a11, a1
42003cde:	fff525        	call8	42003c30 <memprot_ll_prepare_iram0_split_line_regval>

    REG_WRITE(sensitive_reg, regval);
42003ce1:	0188      	l32i.n	a8, a1, 0
42003ce3:	0020c0        	memw
42003ce6:	0389      	s32i.n	a8, a3, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((REG_READ(sensitive_reg) == regval) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
42003ce8:	020c      	movi.n	a2, 0
42003cea:	000186        	j	42003cf4 <memprot_ll_set_iram0_split_line+0x30>
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
42003ced:	220c      	movi.n	a2, 2
42003cef:	000046        	j	42003cf4 <memprot_ll_set_iram0_split_line+0x30>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42003cf2:	320c      	movi.n	a2, 3
}
42003cf4:	f01d      	retw.n
	...

42003cf8 <memprot_ll_iram0_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_iram0_set_pms_area_0(const bool r, const bool w, const bool x)
{
42003cf8:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
42003cfb:	f23481        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003cfe:	0020c0        	memw
42003d01:	0888      	l32i.n	a8, a8, 0
42003d03:	897c      	movi.n	a9, -8
42003d05:	108890        	and	a8, a8, a9
    if (r) {
42003d08:	42cc      	bnez.n	a2, 42003d10 <memprot_ll_iram0_set_pms_area_0+0x18>
    uint32_t permissions = 0;
42003d0a:	090c      	movi.n	a9, 0
42003d0c:	000086        	j	42003d12 <memprot_ll_iram0_set_pms_area_0+0x1a>
42003d0f:	190c00        	lsi	f0, a12, 100
    if (w) {
42003d12:	338c      	beqz.n	a3, 42003d19 <memprot_ll_iram0_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003d14:	2a0c      	movi.n	a10, 2
42003d16:	2099a0        	or	a9, a9, a10
    if (x) {
42003d19:	348c      	beqz.n	a4, 42003d20 <memprot_ll_iram0_set_pms_area_0+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003d1b:	4a0c      	movi.n	a10, 4
42003d1d:	2099a0        	or	a9, a9, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
42003d20:	249090        	extui	a9, a9, 0, 3
42003d23:	208890        	or	a8, a8, a9
42003d26:	f22991        	l32r	a9, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003d29:	0020c0        	memw
42003d2c:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003d2e:	f01d      	retw.n

42003d30 <memprot_ll_iram0_set_pms_area_1>:

static inline void memprot_ll_iram0_set_pms_area_1(const bool r, const bool w, const bool x)
{
42003d30:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
42003d33:	f22681        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003d36:	0020c0        	memw
42003d39:	0898      	l32i.n	a9, a8, 0
42003d3b:	c7af82        	movi	a8, -57
42003d3e:	109980        	and	a9, a9, a8
    if (r) {
42003d41:	32cc      	bnez.n	a2, 42003d48 <memprot_ll_iram0_set_pms_area_1+0x18>
    uint32_t permissions = 0;
42003d43:	080c      	movi.n	a8, 0
42003d45:	000046        	j	42003d4a <memprot_ll_iram0_set_pms_area_1+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003d48:	180c      	movi.n	a8, 1
    if (w) {
42003d4a:	338c      	beqz.n	a3, 42003d51 <memprot_ll_iram0_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003d4c:	2a0c      	movi.n	a10, 2
42003d4e:	2088a0        	or	a8, a8, a10
    if (x) {
42003d51:	348c      	beqz.n	a4, 42003d58 <memprot_ll_iram0_set_pms_area_1+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003d53:	4a0c      	movi.n	a10, 4
42003d55:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
42003d58:	1188d0        	slli	a8, a8, 3
42003d5b:	8a3c      	movi.n	a10, 56
42003d5d:	1088a0        	and	a8, a8, a10
42003d60:	209980        	or	a9, a9, a8
42003d63:	f21a81        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003d66:	0020c0        	memw
42003d69:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003d6b:	f01d      	retw.n
42003d6d:	000000        	ill

42003d70 <memprot_ll_iram0_set_pms_area_2>:

static inline void memprot_ll_iram0_set_pms_area_2(const bool r, const bool w, const bool x)
{
42003d70:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
42003d73:	f21681        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003d76:	0020c0        	memw
42003d79:	0898      	l32i.n	a9, a8, 0
42003d7b:	3fae82        	movi	a8, 0xfffffe3f
42003d7e:	109980        	and	a9, a9, a8
    if (r) {
42003d81:	32cc      	bnez.n	a2, 42003d88 <memprot_ll_iram0_set_pms_area_2+0x18>
    uint32_t permissions = 0;
42003d83:	080c      	movi.n	a8, 0
42003d85:	000046        	j	42003d8a <memprot_ll_iram0_set_pms_area_2+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003d88:	180c      	movi.n	a8, 1
    if (w) {
42003d8a:	338c      	beqz.n	a3, 42003d91 <memprot_ll_iram0_set_pms_area_2+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003d8c:	2a0c      	movi.n	a10, 2
42003d8e:	2088a0        	or	a8, a8, a10
    if (x) {
42003d91:	348c      	beqz.n	a4, 42003d98 <memprot_ll_iram0_set_pms_area_2+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003d93:	4a0c      	movi.n	a10, 4
42003d95:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
42003d98:	1188a0        	slli	a8, a8, 6
42003d9b:	c0a1a2        	movi	a10, 0x1c0
42003d9e:	1088a0        	and	a8, a8, a10
42003da1:	209980        	or	a9, a9, a8
42003da4:	f20a81        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003da7:	0020c0        	memw
42003daa:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003dac:	f01d      	retw.n
	...

42003db0 <memprot_ll_iram0_set_pms_area_3>:

static inline void memprot_ll_iram0_set_pms_area_3(const bool r, const bool w, const bool x)
{
42003db0:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
42003db3:	f20681        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003db6:	0020c0        	memw
42003db9:	0898      	l32i.n	a9, a8, 0
42003dbb:	f20b81        	l32r	a8, 420005e8 <_stext+0x5c8> (fffff1ff <_rtc_reserved_end+0x9feff1ff>)
42003dbe:	109980        	and	a9, a9, a8
    if (r) {
42003dc1:	32cc      	bnez.n	a2, 42003dc8 <memprot_ll_iram0_set_pms_area_3+0x18>
    uint32_t permissions = 0;
42003dc3:	080c      	movi.n	a8, 0
42003dc5:	000046        	j	42003dca <memprot_ll_iram0_set_pms_area_3+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003dc8:	180c      	movi.n	a8, 1
    if (w) {
42003dca:	338c      	beqz.n	a3, 42003dd1 <memprot_ll_iram0_set_pms_area_3+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003dcc:	2a0c      	movi.n	a10, 2
42003dce:	2088a0        	or	a8, a8, a10
    if (x) {
42003dd1:	348c      	beqz.n	a4, 42003dd8 <memprot_ll_iram0_set_pms_area_3+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003dd3:	4a0c      	movi.n	a10, 4
42003dd5:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
42003dd8:	118870        	slli	a8, a8, 9
42003ddb:	248980        	extui	a8, a8, 9, 3
42003dde:	118870        	slli	a8, a8, 9
42003de1:	209980        	or	a9, a9, a8
42003de4:	f1fa81        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42003de7:	0020c0        	memw
42003dea:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003dec:	f01d      	retw.n
	...

42003df0 <memprot_ll_iram0_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_iram0_get_monitor_lock(const int core, bool* locked)
{
42003df0:	004136        	entry	a1, 32
    switch (core) {
42003df3:	628c      	beqz.n	a2, 42003dfd <memprot_ll_iram0_get_monitor_lock+0xd>
42003df5:	1b1226        	beqi	a2, 1, 42003e14 <memprot_ll_iram0_get_monitor_lock+0x24>
42003df8:	720c      	movi.n	a2, 7
42003dfa:	000ac6        	j	42003e29 <memprot_ll_iram0_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG) == 1;
42003dfd:	f1fb81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e4 <SYSTEM+0x10e4>)
42003e00:	0020c0        	memw
42003e03:	0888      	l32i.n	a8, a8, 0
42003e05:	880b      	addi.n	a8, a8, -1
42003e07:	40f880        	nsau	a8, a8
42003e0a:	418580        	srli	a8, a8, 5
42003e0d:	004382        	s8i	a8, a3, 0
            break;
42003e10:	000546        	j	42003e29 <memprot_ll_iram0_get_monitor_lock+0x39>
42003e13:	f78100        	lsi	f0, a1, 0x3dc
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG) == 1;
42003e16:	20c0f1        	l32r	a15, 41fcc118 <_coredump_iram_end+0x1c4a218>
42003e19:	088800        	lsx	f8, a8, a0
42003e1c:	880b      	addi.n	a8, a8, -1
42003e1e:	40f880        	nsau	a8, a8
42003e21:	418580        	srli	a8, a8, 5
42003e24:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003e27:	020c      	movi.n	a2, 0
}
42003e29:	f01d      	retw.n
	...

42003e2c <memprot_ll_iram0_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_iram0_set_monitor_en(const int core, const bool enable)
{
42003e2c:	004136        	entry	a1, 32
    switch (core) {
42003e2f:	628c      	beqz.n	a2, 42003e39 <memprot_ll_iram0_set_monitor_en+0xd>
42003e31:	301226        	beqi	a2, 1, 42003e65 <memprot_ll_iram0_set_monitor_en+0x39>
42003e34:	720c      	movi.n	a2, 7
42003e36:	001606        	j	42003e92 <memprot_ll_iram0_set_monitor_en+0x66>
        case PRO_CPU_NUM:
            if (enable) {
42003e39:	339c      	beqz.n	a3, 42003e50 <memprot_ll_iram0_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003e3b:	f1ee91        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003e3e:	0020c0        	memw
42003e41:	0988      	l32i.n	a8, a9, 0
42003e43:	2a0c      	movi.n	a10, 2
42003e45:	2088a0        	or	a8, a8, a10
42003e48:	0020c0        	memw
42003e4b:	0989      	s32i.n	a8, a9, 0
42003e4d:	001046        	j	42003e92 <memprot_ll_iram0_set_monitor_en+0x66>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003e50:	f1e991        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003e53:	0020c0        	memw
42003e56:	0988      	l32i.n	a8, a9, 0
42003e58:	da7c      	movi.n	a10, -3
42003e5a:	1088a0        	and	a8, a8, a10
42003e5d:	0020c0        	memw
42003e60:	0989      	s32i.n	a8, a9, 0
42003e62:	000b06        	j	42003e92 <memprot_ll_iram0_set_monitor_en+0x66>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
42003e65:	539c      	beqz.n	a3, 42003e7e <memprot_ll_iram0_set_monitor_en+0x52>
                REG_SET_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003e67:	f1e491        	l32r	a9, 420005f8 <_stext+0x5d8> (600c10f4 <SYSTEM+0x10f4>)
42003e6a:	0020c0        	memw
42003e6d:	0988      	l32i.n	a8, a9, 0
42003e6f:	2a0c      	movi.n	a10, 2
42003e71:	2088a0        	or	a8, a8, a10
42003e74:	0020c0        	memw
42003e77:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003e79:	020c      	movi.n	a2, 0
42003e7b:	0004c6        	j	42003e92 <memprot_ll_iram0_set_monitor_en+0x66>
                REG_CLR_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN);
42003e7e:	f1de91        	l32r	a9, 420005f8 <_stext+0x5d8> (600c10f4 <SYSTEM+0x10f4>)
42003e81:	0020c0        	memw
42003e84:	0988      	l32i.n	a8, a9, 0
42003e86:	da7c      	movi.n	a10, -3
42003e88:	1088a0        	and	a8, a8, a10
42003e8b:	0020c0        	memw
42003e8e:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
42003e90:	020c      	movi.n	a2, 0
}
42003e92:	f01d      	retw.n

42003e94 <memprot_ll_iram0_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_iram0_get_monitor_en(const int core, bool* enabled)
{
42003e94:	004136        	entry	a1, 32
    switch (core) {
42003e97:	628c      	beqz.n	a2, 42003ea1 <memprot_ll_iram0_get_monitor_en+0xd>
42003e99:	171226        	beqi	a2, 1, 42003eb4 <memprot_ll_iram0_get_monitor_en+0x20>
42003e9c:	720c      	movi.n	a2, 7
42003e9e:	000886        	j	42003ec4 <memprot_ll_iram0_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
42003ea1:	f1d481        	l32r	a8, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003ea4:	0020c0        	memw
42003ea7:	0888      	l32i.n	a8, a8, 0
42003ea9:	048180        	extui	a8, a8, 1, 1
42003eac:	004382        	s8i	a8, a3, 0
            break;
42003eaf:	000446        	j	42003ec4 <memprot_ll_iram0_get_monitor_en+0x30>
42003eb2:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
42003eb5:	c0f1d1        	l32r	a13, 41ff427c <_coredump_iram_end+0x1c7237c>
42003eb8:	880020        	lsi	f2, a0, 0x220
42003ebb:	8008      	l32i.n	a0, a0, 32
42003ebd:	820481        	l32r	a8, 41fe46d0 <_coredump_iram_end+0x1c627d0>
42003ec0:	0c0043        	lsi	f4, a0, 48
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003ec3:	f01d02        	l16ui	a0, a13, 0x1e0
	...

42003ec8 <memprot_ll_iram0_set_monitor_intrclr>:
}

static inline memprot_hal_err_t memprot_ll_iram0_set_monitor_intrclr(const int core)
{
42003ec8:	004136        	entry	a1, 32
    switch (core) {
42003ecb:	628c      	beqz.n	a2, 42003ed5 <memprot_ll_iram0_set_monitor_intrclr+0xd>
42003ecd:	1b1226        	beqi	a2, 1, 42003eec <memprot_ll_iram0_set_monitor_intrclr+0x24>
42003ed0:	720c      	movi.n	a2, 7
42003ed2:	000a86        	j	42003f00 <memprot_ll_iram0_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42003ed5:	f1c791        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003ed8:	0020c0        	memw
42003edb:	0988      	l32i.n	a8, a9, 0
42003edd:	1a0c      	movi.n	a10, 1
42003edf:	2088a0        	or	a8, a8, a10
42003ee2:	0020c0        	memw
42003ee5:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
42003ee7:	000546        	j	42003f00 <memprot_ll_iram0_set_monitor_intrclr+0x38>
42003eea:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42003eed:	c0f1c3        	lsi	f12, a1, 0x300
42003ef0:	880020        	lsi	f2, a0, 0x220
42003ef3:	0c09      	s32i.n	a0, a12, 0
42003ef5:	a01a      	add.n	a10, a0, a1
42003ef7:	2088      	l32i.n	a8, a0, 8
42003ef9:	0020c0        	memw
42003efc:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003efe:	020c      	movi.n	a2, 0
}
42003f00:	f01d      	retw.n
	...

42003f04 <memprot_ll_iram0_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_iram0_reset_monitor_intrclr(const int core)
{
42003f04:	004136        	entry	a1, 32
    switch (core) {
42003f07:	628c      	beqz.n	a2, 42003f11 <memprot_ll_iram0_reset_monitor_intrclr+0xd>
42003f09:	1b1226        	beqi	a2, 1, 42003f28 <memprot_ll_iram0_reset_monitor_intrclr+0x24>
42003f0c:	720c      	movi.n	a2, 7
42003f0e:	000a86        	j	42003f3c <memprot_ll_iram0_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42003f11:	f1b891        	l32r	a9, 420005f4 <_stext+0x5d4> (600c10e8 <SYSTEM+0x10e8>)
42003f14:	0020c0        	memw
42003f17:	0988      	l32i.n	a8, a9, 0
42003f19:	ea7c      	movi.n	a10, -2
42003f1b:	1088a0        	and	a8, a8, a10
42003f1e:	0020c0        	memw
42003f21:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
42003f23:	000546        	j	42003f3c <memprot_ll_iram0_reset_monitor_intrclr+0x38>
42003f26:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42003f29:	c0f1b4        	lsi	f11, a1, 0x300
42003f2c:	880020        	lsi	f2, a0, 0x220
42003f2f:	7c09      	s32i.n	a0, a12, 28
42003f31:	a0ea      	add.n	a10, a0, a14
42003f33:	1088      	l32i.n	a8, a0, 4
42003f35:	0020c0        	memw
42003f38:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003f3a:	020c      	movi.n	a2, 0
}
42003f3c:	f01d      	retw.n
	...

42003f40 <memprot_ll_get_pif_constraint_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_get_pif_constraint_lock(const int core, bool* locked)
{
42003f40:	004136        	entry	a1, 32
    switch (core) {
42003f43:	628c      	beqz.n	a2, 42003f4d <memprot_ll_get_pif_constraint_lock+0xd>
42003f45:	1b1226        	beqi	a2, 1, 42003f64 <memprot_ll_get_pif_constraint_lock+0x24>
42003f48:	720c      	movi.n	a2, 7
42003f4a:	000ac6        	j	42003f79 <memprot_ll_get_pif_constraint_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG) == 1;
42003f4d:	f1ab81        	l32r	a8, 420005fc <_stext+0x5dc> (600c1124 <SYSTEM+0x1124>)
42003f50:	0020c0        	memw
42003f53:	0888      	l32i.n	a8, a8, 0
42003f55:	880b      	addi.n	a8, a8, -1
42003f57:	40f880        	nsau	a8, a8
42003f5a:	418580        	srli	a8, a8, 5
42003f5d:	004382        	s8i	a8, a3, 0
            break;
42003f60:	000546        	j	42003f79 <memprot_ll_get_pif_constraint_lock+0x39>
42003f63:	a78100        	lsi	f0, a1, 0x29c
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG) == 1;
42003f66:	20c0f1        	l32r	a15, 41fcc268 <_coredump_iram_end+0x1c4a368>
42003f69:	088800        	lsx	f8, a8, a0
42003f6c:	880b      	addi.n	a8, a8, -1
42003f6e:	40f880        	nsau	a8, a8
42003f71:	418580        	srli	a8, a8, 5
42003f74:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42003f77:	020c      	movi.n	a2, 0
}
42003f79:	f01d      	retw.n
	...

42003f7c <memprot_ll_set_rtcfast_split_line>:
/* ********************************
 * IRAM0 RTCFAST - SPLIT LINES
 */

static inline memprot_hal_err_t memprot_ll_set_rtcfast_split_line(const int core, const void *line_addr, const memprot_hal_world_t world)
{
42003f7c:	004136        	entry	a1, 32
    uint32_t addr = (uint32_t)line_addr;

    if (addr < SOC_RTC_IRAM_LOW || addr >= SOC_RTC_IRAM_HIGH) {
42003f7f:	f0dc81        	l32r	a8, 420002f0 <_stext+0x2d0> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
42003f82:	838a      	add.n	a8, a3, a8
42003f84:	f0dc91        	l32r	a9, 420002f4 <_stext+0x2d4> (1fff <UserFrameTotalSize+0x1eff>)
42003f87:	523987        	bltu	a9, a8, 42003fdd <memprot_ll_set_rtcfast_split_line+0x61>
        return MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE;
    }

    if (addr % 0x4 != 0) {
42003f8a:	148030        	extui	a8, a3, 0, 2
42003f8d:	051856        	bnez	a8, 42003fe2 <memprot_ll_set_rtcfast_split_line+0x66>
        return MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED;
    }

    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42003f90:	5422f6        	bgeui	a2, 2, 42003fe8 <memprot_ll_set_rtcfast_split_line+0x6c>
    }

    uint32_t mask;
    uint32_t val;

    switch (world) {
42003f93:	091426        	beqi	a4, 1, 42003fa0 <memprot_ll_set_rtcfast_split_line+0x24>
42003f96:	53b466        	bnei	a4, 16, 42003fed <memprot_ll_set_rtcfast_split_line+0x71>
    case MEMP_HAL_WORLD_0:
        mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_M;
        val = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_V : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_V;
        break;
    case MEMP_HAL_WORLD_1:
        mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1_M;
42003f99:	f19aa1        	l32r	a10, 42000604 <_stext+0x5e4> (3ff800 <UserFrameTotalSize+0x3ff700>)
42003f9c:	0000c6        	j	42003fa3 <memprot_ll_set_rtcfast_split_line+0x27>
42003f9f:	a7a200        	lsi	f0, a2, 0x29c
    switch (world) {
42003fa2:	ff          	.byte	0xff
        break;
    default:
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_9_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_9_REG;
42003fa3:	52cc      	bnez.n	a2, 42003fac <memprot_ll_set_rtcfast_split_line+0x30>
42003fa5:	f19891        	l32r	a9, 42000608 <_stext+0x5e8> (600c1148 <SYSTEM+0x1148>)
42003fa8:	0000c6        	j	42003faf <memprot_ll_set_rtcfast_split_line+0x33>
42003fab:	989100        	lsi	f0, a1, 0x260
42003fae:	20c0f1        	l32r	a15, 41fcc2b0 <_coredump_iram_end+0x1c4a3b0>

    CLEAR_PERI_REG_MASK(reg, mask);
42003fb1:	09b800        	l32e	a0, a8, -20
42003fb4:	108ab0        	and	a8, a10, a11
42003fb7:	3088b0        	xor	a8, a8, a11
42003fba:	0020c0        	memw
42003fbd:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((GET_PERI_REG_MASK(reg, mask) == 0) && "Value not stored to required register");
#endif
    REG_SET_BITS(reg, mask, (addr >> 2) & val);
42003fbf:	0020c0        	memw
42003fc2:	09b8      	l32i.n	a11, a9, 0
42003fc4:	a43230        	extui	a3, a3, 2, 11
42003fc7:	1083b0        	and	a8, a3, a11
42003fca:	3088b0        	xor	a8, a8, a11
42003fcd:	1033a0        	and	a3, a3, a10
42003fd0:	208830        	or	a8, a8, a3
42003fd3:	0020c0        	memw
42003fd6:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_READ(reg) & mask;
    HAL_ASSERT((expected == ((addr >> 2) & val)) && "Value not stored to required register");
#endif
    return MEMP_HAL_OK;
42003fd8:	020c      	movi.n	a2, 0
42003fda:	000446        	j	42003fef <memprot_ll_set_rtcfast_split_line+0x73>
        return MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE;
42003fdd:	220c      	movi.n	a2, 2
42003fdf:	000306        	j	42003fef <memprot_ll_set_rtcfast_split_line+0x73>
        return MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED;
42003fe2:	320c      	movi.n	a2, 3
42003fe4:	0001c6        	j	42003fef <memprot_ll_set_rtcfast_split_line+0x73>
42003fe7:	720c00        	lsi	f0, a12, 0x1c8
        return MEMP_HAL_ERR_CORE_INVALID;
42003fea:	000046        	j	42003fef <memprot_ll_set_rtcfast_split_line+0x73>
    switch (world) {
42003fed:	620c      	movi.n	a2, 6
}
42003fef:	f01d      	retw.n
42003ff1:	000000        	ill

42003ff4 <memprot_ll_rtcfast_set_pms_area>:

    return permissions;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_set_pms_area(const int core, const bool r, const bool w, const bool x, const memprot_hal_world_t world, const memprot_hal_area_t area)
{
42003ff4:	004136        	entry	a1, 32
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42003ff7:	0222b6        	bltui	a2, 2, 42003ffd <memprot_ll_rtcfast_set_pms_area+0x9>
42003ffa:	003386        	j	420040cc <memprot_ll_rtcfast_set_pms_area+0xd8>
    }

    uint32_t bits;
    uint32_t mask;

    switch (world) {
42003ffd:	071626        	beqi	a6, 1, 42004008 <memprot_ll_rtcfast_set_pms_area+0x14>
42004000:	48b626        	beqi	a6, 16, 4200404c <memprot_ll_rtcfast_set_pms_area+0x58>
42004003:	620c      	movi.n	a2, 6
42004005:	003146        	j	420040ce <memprot_ll_rtcfast_set_pms_area+0xda>
    case MEMP_HAL_WORLD_0: {
        switch (area) {
42004008:	081726        	beqi	a7, 1, 42004014 <memprot_ll_rtcfast_set_pms_area+0x20>
4200400b:	232726        	beqi	a7, 2, 42004032 <memprot_ll_rtcfast_set_pms_area+0x3e>
4200400e:	520c      	movi.n	a2, 5
42004010:	002e86        	j	420040ce <memprot_ll_rtcfast_set_pms_area+0xda>
42004013:	43cc00        	min	a12, a12, a0
    uint32_t permissions = 0;
42004016:	070c      	movi.n	a7, 0
42004018:	000086        	j	4200401e <memprot_ll_rtcfast_set_pms_area+0x2a>
4200401b:	270c00        	lsi	f0, a12, 156
    if (w) {
4200401e:	348c      	beqz.n	a4, 42004025 <memprot_ll_rtcfast_set_pms_area+0x31>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004020:	180c      	movi.n	a8, 1
42004022:	207780        	or	a7, a7, a8
    if (x) {
42004025:	06c516        	beqz	a5, 42004095 <memprot_ll_rtcfast_set_pms_area+0xa1>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42004028:	480c      	movi.n	a8, 4
4200402a:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_LOW:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_S);
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M;
4200402d:	7b0c      	movi.n	a11, 7
4200402f:	001906        	j	42004097 <memprot_ll_rtcfast_set_pms_area+0xa3>
    if (r) {
42004032:	03cc      	bnez.n	a3, 42004036 <memprot_ll_rtcfast_set_pms_area+0x42>
    uint32_t permissions = 0;
42004034:	070c      	movi.n	a7, 0
    if (w) {
42004036:	348c      	beqz.n	a4, 4200403d <memprot_ll_rtcfast_set_pms_area+0x49>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004038:	180c      	movi.n	a8, 1
4200403a:	207780        	or	a7, a7, a8
    if (x) {
4200403d:	358c      	beqz.n	a5, 42004044 <memprot_ll_rtcfast_set_pms_area+0x50>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
4200403f:	480c      	movi.n	a8, 4
42004041:	207780        	or	a7, a7, a8
            break;
        case MEMP_HAL_AREA_HIGH:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S);
42004044:	1177d0        	slli	a7, a7, 3
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_M;
42004047:	8b3c      	movi.n	a11, 56
            break;
42004049:	001286        	j	42004097 <memprot_ll_rtcfast_set_pms_area+0xa3>
        default:
            return MEMP_HAL_ERR_AREA_INVALID;
        }
    } break;
    case MEMP_HAL_WORLD_1: {
        switch (area) {
4200404c:	081726        	beqi	a7, 1, 42004058 <memprot_ll_rtcfast_set_pms_area+0x64>
4200404f:	262726        	beqi	a7, 2, 42004079 <memprot_ll_rtcfast_set_pms_area+0x85>
42004052:	520c      	movi.n	a2, 5
42004054:	001d86        	j	420040ce <memprot_ll_rtcfast_set_pms_area+0xda>
42004057:	43cc00        	min	a12, a12, a0
    uint32_t permissions = 0;
4200405a:	070c      	movi.n	a7, 0
4200405c:	000086        	j	42004062 <memprot_ll_rtcfast_set_pms_area+0x6e>
4200405f:	270c00        	lsi	f0, a12, 156
    if (w) {
42004062:	348c      	beqz.n	a4, 42004069 <memprot_ll_rtcfast_set_pms_area+0x75>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004064:	180c      	movi.n	a8, 1
42004066:	207780        	or	a7, a7, a8
    if (x) {
42004069:	358c      	beqz.n	a5, 42004070 <memprot_ll_rtcfast_set_pms_area+0x7c>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
4200406b:	480c      	movi.n	a8, 4
4200406d:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_LOW:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_S);
42004070:	1177a0        	slli	a7, a7, 6
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_M;
42004073:	c0a1b2        	movi	a11, 0x1c0
            break;
42004076:	000746        	j	42004097 <memprot_ll_rtcfast_set_pms_area+0xa3>
    if (r) {
42004079:	13cc      	bnez.n	a3, 4200407e <memprot_ll_rtcfast_set_pms_area+0x8a>
    uint32_t permissions = 0;
4200407b:	00a072        	movi	a7, 0
    if (w) {
4200407e:	348c      	beqz.n	a4, 42004085 <memprot_ll_rtcfast_set_pms_area+0x91>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004080:	180c      	movi.n	a8, 1
42004082:	207780        	or	a7, a7, a8
    if (x) {
42004085:	358c      	beqz.n	a5, 4200408c <memprot_ll_rtcfast_set_pms_area+0x98>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42004087:	480c      	movi.n	a8, 4
42004089:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_HIGH:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_S);
4200408c:	117770        	slli	a7, a7, 9
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_M;
4200408f:	f160b1        	l32r	a11, 42000610 <_stext+0x5f0> (e00 <UserFrameTotalSize+0xd00>)
            break;
42004092:	000046        	j	42004097 <memprot_ll_rtcfast_set_pms_area+0xa3>
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M;
42004095:	7b0c      	movi.n	a11, 7
    } break;
    default:
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG;
42004097:	52cc      	bnez.n	a2, 420040a0 <memprot_ll_rtcfast_set_pms_area+0xac>
42004099:	f15e81        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
4200409c:	0000c6        	j	420040a3 <memprot_ll_rtcfast_set_pms_area+0xaf>
4200409f:	5e8100        	f64rnd	a8, a1, a0, 1
420040a2:	20c0f1        	l32r	a15, 41fcc3a4 <_coredump_iram_end+0x1c4a4a4>

    CLEAR_PERI_REG_MASK(reg, mask);
420040a5:	08a800        	lsx	f10, a8, a0
420040a8:	109ba0        	and	a9, a11, a10
420040ab:	3099a0        	xor	a9, a9, a10
420040ae:	0020c0        	memw
420040b1:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((GET_PERI_REG_MASK(reg, mask) == 0) && "Value not stored to required register");
#endif
    REG_SET_BITS(reg, bits, mask);
420040b3:	0020c0        	memw
420040b6:	0898      	l32i.n	a9, a8, 0
420040b8:	307970        	xor	a7, a9, a7
420040bb:	1077b0        	and	a7, a7, a11
420040be:	307790        	xor	a7, a7, a9
420040c1:	0020c0        	memw
420040c4:	0879      	s32i.n	a7, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_READ(reg) & mask;
    HAL_ASSERT((expected == bits) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
420040c6:	020c      	movi.n	a2, 0
420040c8:	000086        	j	420040ce <memprot_ll_rtcfast_set_pms_area+0xda>
420040cb:	720c00        	lsi	f0, a12, 0x1c8
}
420040ce:	f01d      	retw.n

420040d0 <memprot_ll_rtcfast_get_pms_area>:
    *w = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
    *x = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_get_pms_area(const int core, bool *r, bool *w, bool *x, const memprot_hal_world_t world, const memprot_hal_area_t area)
{
420040d0:	004136        	entry	a1, 32
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
420040d3:	0222b6        	bltui	a2, 2, 420040d9 <memprot_ll_rtcfast_get_pms_area+0x9>
420040d6:	002d06        	j	4200418e <memprot_ll_rtcfast_get_pms_area+0xbe>
        return MEMP_HAL_ERR_CORE_INVALID;
    }

    uint32_t permissions = 0;

    switch (world) {
420040d9:	071626        	beqi	a6, 1, 420040e4 <memprot_ll_rtcfast_get_pms_area+0x14>
420040dc:	50b626        	beqi	a6, 16, 42004130 <memprot_ll_rtcfast_get_pms_area+0x60>
420040df:	620c      	movi.n	a2, 6
420040e1:	002ac6        	j	42004190 <memprot_ll_rtcfast_get_pms_area+0xc0>
    case MEMP_HAL_WORLD_0: {
        switch (area) {
420040e4:	081726        	beqi	a7, 1, 420040f0 <memprot_ll_rtcfast_get_pms_area+0x20>
420040e7:	232726        	beqi	a7, 2, 4200410e <memprot_ll_rtcfast_get_pms_area+0x3e>
420040ea:	520c      	movi.n	a2, 5
420040ec:	002806        	j	42004190 <memprot_ll_rtcfast_get_pms_area+0xc0>
420040ef:	c2cc00        	quou	a12, a12, a0
        case MEMP_HAL_AREA_LOW:
            if (core == PRO_CPU_NUM) {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L);
420040f2:	f14881        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
420040f5:	0020c0        	memw
420040f8:	0888      	l32i.n	a8, a8, 0
420040fa:	248080        	extui	a8, a8, 0, 3
420040fd:	001d86        	j	42004177 <memprot_ll_rtcfast_get_pms_area+0xa7>
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
42004100:	f14681        	l32r	a8, 42000618 <_stext+0x5f8> (600c11f8 <SYSTEM+0x11f8>)
42004103:	0020c0        	memw
42004106:	0888      	l32i.n	a8, a8, 0
42004108:	248680        	extui	a8, a8, 6, 3
4200410b:	001a06        	j	42004177 <memprot_ll_rtcfast_get_pms_area+0xa7>
            }
            break;
        case MEMP_HAL_AREA_HIGH:
            if (core == PRO_CPU_NUM) {
4200410e:	e2cc      	bnez.n	a2, 42004120 <memprot_ll_rtcfast_get_pms_area+0x50>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
42004110:	f14181        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
42004113:	0020c0        	memw
42004116:	0888      	l32i.n	a8, a8, 0
42004118:	248380        	extui	a8, a8, 3, 3
4200411b:	001606        	j	42004177 <memprot_ll_rtcfast_get_pms_area+0xa7>
4200411e:	810000        	src	a0, a0, a0
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
42004121:	3e          	.byte	0x3e
42004122:	20c0f1        	l32r	a15, 41fcc424 <_coredump_iram_end+0x1c4a524>
42004125:	088800        	lsx	f8, a8, a0
42004128:	248380        	extui	a8, a8, 3, 3
4200412b:	001206        	j	42004177 <memprot_ll_rtcfast_get_pms_area+0xa7>
4200412e:	260000        	lsi	f0, a0, 152
        default:
            return MEMP_HAL_ERR_AREA_INVALID;
        }
    } break;
    case MEMP_HAL_WORLD_1: {
        switch (area) {
42004131:	260717        	bnone	a7, a1, 4200415b <memprot_ll_rtcfast_get_pms_area+0x8b>
42004134:	0c2327        	blt	a3, a2, 42004144 <memprot_ll_rtcfast_get_pms_area+0x74>
42004137:	150652        	l8ui	a5, a6, 21
4200413a:	d2cc00        	quos	a12, a12, a0
        case MEMP_HAL_AREA_LOW:
            if (core == PRO_CPU_NUM) {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
4200413d:	f13581        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
42004140:	0020c0        	memw
42004143:	0888      	l32i.n	a8, a8, 0
42004145:	248680        	extui	a8, a8, 6, 3
42004148:	000ac6        	j	42004177 <memprot_ll_rtcfast_get_pms_area+0xa7>
4200414b:	338100        	clamps	a8, a1, 7
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
4200414e:	20c0f1        	l32r	a15, 41fcc450 <_coredump_iram_end+0x1c4a550>
42004151:	088800        	lsx	f8, a8, a0
42004154:	248680        	extui	a8, a8, 6, 3
42004157:	000706        	j	42004177 <memprot_ll_rtcfast_get_pms_area+0xa7>
            }
            break;
        case MEMP_HAL_AREA_HIGH:
            if (core == PRO_CPU_NUM) {
4200415a:	e2cc      	bnez.n	a2, 4200416c <memprot_ll_rtcfast_get_pms_area+0x9c>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H);
4200415c:	f12e81        	l32r	a8, 42000614 <_stext+0x5f4> (600c114c <SYSTEM+0x114c>)
4200415f:	0020c0        	memw
42004162:	0888      	l32i.n	a8, a8, 0
42004164:	248980        	extui	a8, a8, 9, 3
42004167:	000306        	j	42004177 <memprot_ll_rtcfast_get_pms_area+0xa7>
4200416a:	810000        	src	a0, a0, a0
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H);
4200416d:	f12b      	addi.n	a15, a1, 2
4200416f:	0020c0        	memw
42004172:	0888      	l32i.n	a8, a8, 0
42004174:	248980        	extui	a8, a8, 9, 3
    *r = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_R;
42004177:	049180        	extui	a9, a8, 1, 1
4200417a:	004392        	s8i	a9, a3, 0
    *w = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
4200417d:	049080        	extui	a9, a8, 0, 1
42004180:	004492        	s8i	a9, a4, 0
    *x = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42004183:	418280        	srli	a8, a8, 2
42004186:	004582        	s8i	a8, a5, 0
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    memprot_ll_rtcfast_get_permissions(permissions, r, w, x);

    return MEMP_HAL_OK;
42004189:	020c      	movi.n	a2, 0
4200418b:	000046        	j	42004190 <memprot_ll_rtcfast_get_pms_area+0xc0>
        return MEMP_HAL_ERR_CORE_INVALID;
4200418e:	720c      	movi.n	a2, 7
}
42004190:	f01d      	retw.n
	...

42004194 <memprot_ll_rtcfast_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_get_monitor_lock(const int core, bool* locked)
{
42004194:	004136        	entry	a1, 32
    switch (core) {
42004197:	628c      	beqz.n	a2, 420041a1 <memprot_ll_rtcfast_get_monitor_lock+0xd>
42004199:	1b1226        	beqi	a2, 1, 420041b8 <memprot_ll_rtcfast_get_monitor_lock+0x24>
4200419c:	720c      	movi.n	a2, 7
4200419e:	000ac6        	j	420041cd <memprot_ll_rtcfast_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG) == 1;
420041a1:	f11e81        	l32r	a8, 4200061c <_stext+0x5fc> (600c119c <SYSTEM+0x119c>)
420041a4:	0020c0        	memw
420041a7:	0888      	l32i.n	a8, a8, 0
420041a9:	880b      	addi.n	a8, a8, -1
420041ab:	40f880        	nsau	a8, a8
420041ae:	418580        	srli	a8, a8, 5
420041b1:	004382        	s8i	a8, a3, 0
            break;
420041b4:	000546        	j	420041cd <memprot_ll_rtcfast_get_monitor_lock+0x39>
420041b7:	1a8100        	sub.s	f8, f1, f0
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG) == 1;
420041ba:	20c0f1        	l32r	a15, 41fcc4bc <_coredump_iram_end+0x1c4a5bc>
420041bd:	088800        	lsx	f8, a8, a0
420041c0:	880b      	addi.n	a8, a8, -1
420041c2:	40f880        	nsau	a8, a8
420041c5:	418580        	srli	a8, a8, 5
420041c8:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420041cb:	020c      	movi.n	a2, 0
}
420041cd:	f01d      	retw.n
	...

420041d0 <memprot_ll_rtcfast_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_rtcfast_set_monitor_en(const int core, const bool enable)
{
420041d0:	004136        	entry	a1, 32
    switch (core) {
420041d3:	628c      	beqz.n	a2, 420041dd <memprot_ll_rtcfast_set_monitor_en+0xd>
420041d5:	301226        	beqi	a2, 1, 42004209 <memprot_ll_rtcfast_set_monitor_en+0x39>
420041d8:	720c      	movi.n	a2, 7
420041da:	001686        	j	42004238 <memprot_ll_rtcfast_set_monitor_en+0x68>
        case PRO_CPU_NUM:
            if (enable) {
420041dd:	339c      	beqz.n	a3, 420041f4 <memprot_ll_rtcfast_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN);
420041df:	f11191        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
420041e2:	0020c0        	memw
420041e5:	0988      	l32i.n	a8, a9, 0
420041e7:	2a0c      	movi.n	a10, 2
420041e9:	2088a0        	or	a8, a8, a10
420041ec:	0020c0        	memw
420041ef:	0989      	s32i.n	a8, a9, 0
420041f1:	0010c6        	j	42004238 <memprot_ll_rtcfast_set_monitor_en+0x68>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN);
420041f4:	f10c91        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
420041f7:	0020c0        	memw
420041fa:	0988      	l32i.n	a8, a9, 0
420041fc:	da7c      	movi.n	a10, -3
420041fe:	1088a0        	and	a8, a8, a10
42004201:	0020c0        	memw
42004204:	0989      	s32i.n	a8, a9, 0
42004206:	000b86        	j	42004238 <memprot_ll_rtcfast_set_monitor_en+0x68>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
42004209:	739c      	beqz.n	a3, 42004224 <memprot_ll_rtcfast_set_monitor_en+0x54>
                REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
4200420b:	f10791        	l32r	a9, 42000628 <_stext+0x608> (600c124c <SYSTEM+0x124c>)
4200420e:	0020c0        	memw
42004211:	0988      	l32i.n	a8, a9, 0
42004213:	2a0c      	movi.n	a10, 2
42004215:	2088a0        	or	a8, a8, a10
42004218:	0020c0        	memw
4200421b:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200421d:	020c      	movi.n	a2, 0
4200421f:	000546        	j	42004238 <memprot_ll_rtcfast_set_monitor_en+0x68>
42004222:	910000        	srl	a0, a0
                REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
42004225:	c0f101        	l32r	a0, 41ff45ec <_coredump_iram_end+0x1c726ec>
42004228:	880020        	lsi	f2, a0, 0x220
4200422b:	7c09      	s32i.n	a0, a12, 28
4200422d:	a0da      	add.n	a10, a0, a13
4200422f:	1088      	l32i.n	a8, a0, 4
42004231:	0020c0        	memw
42004234:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
42004236:	020c      	movi.n	a2, 0
}
42004238:	f01d      	retw.n
	...

4200423c <memprot_ll_rtcfast_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_rtcfast_get_monitor_en(const int core, bool* enabled)
{
4200423c:	004136        	entry	a1, 32
    switch (core) {
4200423f:	628c      	beqz.n	a2, 42004249 <memprot_ll_rtcfast_get_monitor_en+0xd>
42004241:	171226        	beqi	a2, 1, 4200425c <memprot_ll_rtcfast_get_monitor_en+0x20>
42004244:	720c      	movi.n	a2, 7
42004246:	000886        	j	4200426c <memprot_ll_rtcfast_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
42004249:	f0f681        	l32r	a8, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
4200424c:	0020c0        	memw
4200424f:	0888      	l32i.n	a8, a8, 0
42004251:	048180        	extui	a8, a8, 1, 1
42004254:	004382        	s8i	a8, a3, 0
            break;
42004257:	000446        	j	4200426c <memprot_ll_rtcfast_get_monitor_en+0x30>
4200425a:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
4200425d:	c0f0f3        	lsi	f15, a0, 0x300
42004260:	880020        	lsi	f2, a0, 0x220
42004263:	8008      	l32i.n	a0, a0, 32
42004265:	820481        	l32r	a8, 41fe4a78 <_coredump_iram_end+0x1c62b78>
42004268:	0c0043        	lsi	f4, a0, 48
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200426b:	f01d02        	l16ui	a0, a13, 0x1e0
	...

42004270 <memprot_ll_rtcfast_set_monitor_intrclr>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_set_monitor_intrclr(const int core)
{
42004270:	004136        	entry	a1, 32
    switch (core) {
42004273:	628c      	beqz.n	a2, 4200427d <memprot_ll_rtcfast_set_monitor_intrclr+0xd>
42004275:	1b1226        	beqi	a2, 1, 42004294 <memprot_ll_rtcfast_set_monitor_intrclr+0x24>
42004278:	720c      	movi.n	a2, 7
4200427a:	000a86        	j	420042a8 <memprot_ll_rtcfast_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
4200427d:	f0e991        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
42004280:	0020c0        	memw
42004283:	0988      	l32i.n	a8, a9, 0
42004285:	1a0c      	movi.n	a10, 1
42004287:	2088a0        	or	a8, a8, a10
4200428a:	0020c0        	memw
4200428d:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
4200428f:	000546        	j	420042a8 <memprot_ll_rtcfast_set_monitor_intrclr+0x38>
42004292:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
42004295:	c0f0e5        	call8	41fc51a4 <_coredump_iram_end+0x1c432a4>
42004298:	880020        	lsi	f2, a0, 0x220
4200429b:	0c09      	s32i.n	a0, a12, 0
4200429d:	a01a      	add.n	a10, a0, a1
4200429f:	2088      	l32i.n	a8, a0, 8
420042a1:	0020c0        	memw
420042a4:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420042a6:	020c      	movi.n	a2, 0
}
420042a8:	f01d      	retw.n
	...

420042ac <memprot_ll_rtcfast_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_rtcfast_reset_monitor_intrclr(const int core)
{
420042ac:	004136        	entry	a1, 32
    switch (core) {
420042af:	628c      	beqz.n	a2, 420042b9 <memprot_ll_rtcfast_reset_monitor_intrclr+0xd>
420042b1:	1b1226        	beqi	a2, 1, 420042d0 <memprot_ll_rtcfast_reset_monitor_intrclr+0x24>
420042b4:	720c      	movi.n	a2, 7
420042b6:	000a86        	j	420042e4 <memprot_ll_rtcfast_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
420042b9:	f0da91        	l32r	a9, 42000624 <_stext+0x604> (600c11a0 <SYSTEM+0x11a0>)
420042bc:	0020c0        	memw
420042bf:	0988      	l32i.n	a8, a9, 0
420042c1:	ea7c      	movi.n	a10, -2
420042c3:	1088a0        	and	a8, a8, a10
420042c6:	0020c0        	memw
420042c9:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
420042cb:	000546        	j	420042e4 <memprot_ll_rtcfast_reset_monitor_intrclr+0x38>
420042ce:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
420042d1:	c0f0d6        	bgez	a0, 42003ee4 <memprot_ll_iram0_set_monitor_intrclr+0x1c>
420042d4:	880020        	lsi	f2, a0, 0x220
420042d7:	7c09      	s32i.n	a0, a12, 28
420042d9:	a0ea      	add.n	a10, a0, a14
420042db:	1088      	l32i.n	a8, a0, 4
420042dd:	0020c0        	memw
420042e0:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420042e2:	020c      	movi.n	a2, 0
}
420042e4:	f01d      	retw.n
	...

420042e8 <memprot_ll_prepare_dram0_split_line_regval>:
{
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
}

static inline void memprot_ll_prepare_dram0_split_line_regval(const uint32_t addr, uint32_t* regval)
{
420042e8:	00c136        	entry	a1, 96
    //set category bits for given split line
    uint32_t cat[7] = { MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
420042eb:	cc1c      	movi.n	a12, 28
420042ed:	f0bab1        	l32r	a11, 420005d8 <_stext+0x5b8> (3c027c40 <__func__$1+0xc>)
420042f0:	a1ca      	add.n	a10, a1, a12
420042f2:	ef4d81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420042f5:	0008e0        	callx8	a8
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA };

    for (size_t x=0; x<7; x++) {
420042f8:	070c      	movi.n	a7, 0
420042fa:	000b06        	j	4200432a <memprot_ll_prepare_dram0_split_line_regval+0x42>
        if (addr <= MAP_IRAM_TO_DRAM(SRAM_RG3_LEVEL_HLIMITS(x))) {
420042fd:	cc1c      	movi.n	a12, 28
420042ff:	f0b7b1        	l32r	a11, 420005dc <_stext+0x5bc> (3c027c5c <__func__$1+0x28>)
42004302:	01ad      	mov.n	a10, a1
42004304:	ef4981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42004307:	0008e0        	callx8	a8
4200430a:	a08710        	addx4	a8, a7, a1
4200430d:	0888      	l32i.n	a8, a8, 0
4200430f:	f0c791        	l32r	a9, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
42004312:	889a      	add.n	a8, a8, a9
42004314:	093827        	bltu	a8, a2, 42004321 <memprot_ll_prepare_dram0_split_line_regval+0x39>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
42004317:	a07710        	addx4	a7, a7, a1
4200431a:	280c      	movi.n	a8, 2
4200431c:	7789      	s32i.n	a8, a7, 28
            break;
4200431e:	0002c6        	j	4200432d <memprot_ll_prepare_dram0_split_line_regval+0x45>
        } else {
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
42004321:	a08710        	addx4	a8, a7, a1
42004324:	090c      	movi.n	a9, 0
42004326:	7899      	s32i.n	a9, a8, 28
    for (size_t x=0; x<7; x++) {
42004328:	771b      	addi.n	a7, a7, 1
4200432a:	cf77b6        	bltui	a7, 7, 420042fd <memprot_ll_prepare_dram0_split_line_regval+0x15>

    //resolve split address' significant bits
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR_V);

    //write values to required configuration-register
    constrain_reg_fields_t cfg_reg_val = {
4200432d:	81a8      	l32i.n	a10, a1, 32
4200432f:	14a0a0        	extui	a10, a10, 0, 2
42004332:	11aae0        	slli	a10, a10, 2
42004335:	7188      	l32i.n	a8, a1, 28
42004337:	148080        	extui	a8, a8, 0, 2
4200433a:	9198      	l32i.n	a9, a1, 36
4200433c:	149090        	extui	a9, a9, 0, 2
4200433f:	1199c0        	slli	a9, a9, 4
42004342:	2088a0        	or	a8, a8, a10
42004345:	a1a8      	l32i.n	a10, a1, 40
42004347:	14a0a0        	extui	a10, a10, 0, 2
4200434a:	11aaa0        	slli	a10, a10, 6
4200434d:	208890        	or	a8, a8, a9
42004350:	b198      	l32i.n	a9, a1, 44
42004352:	149090        	extui	a9, a9, 0, 2
42004355:	119980        	slli	a9, a9, 8
42004358:	2088a0        	or	a8, a8, a10
4200435b:	c1a8      	l32i.n	a10, a1, 48
4200435d:	14a0a0        	extui	a10, a10, 0, 2
42004360:	11aa60        	slli	a10, a10, 10
42004363:	208890        	or	a8, a8, a9
42004366:	d198      	l32i.n	a9, a1, 52
42004368:	149090        	extui	a9, a9, 0, 2
4200436b:	119940        	slli	a9, a9, 12
4200436e:	2088a0        	or	a8, a8, a10
42004371:	742820        	extui	a2, a2, 8, 8
42004374:	112220        	slli	a2, a2, 14
42004377:	208890        	or	a8, a8, a9
4200437a:	208820        	or	a8, a8, a2
            .splitaddr = conf_add,
            .reserved = 0
    };


    *regval = cfg_reg_val.val;
4200437d:	0389      	s32i.n	a8, a3, 0
}
4200437f:	f01d      	retw.n
42004381:	000000        	ill

42004384 <memprot_ll_set_dram0_split_line>:

static inline memprot_hal_err_t memprot_ll_set_dram0_split_line(const void *line_addr, const uint32_t sensitive_reg)
{
42004384:	006136        	entry	a1, 48
42004387:	20a220        	or	a10, a2, a2
    uint32_t addr = (uint32_t)line_addr;

    //sanity check
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
4200438a:	f0a981        	l32r	a8, 42000630 <_stext+0x610> (c0378000 <_rtc_reserved_end+0x60278000>)
4200438d:	808280        	add	a8, a2, a8
42004390:	f09591        	l32r	a9, 420005e4 <_stext+0x5c4> (67fff <UserFrameTotalSize+0x67eff>)
42004393:	163987        	bltu	a9, a8, 420043ad <memprot_ll_set_dram0_split_line+0x29>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42004396:	748020        	extui	a8, a2, 0, 8
42004399:	015856        	bnez	a8, 420043b2 <memprot_ll_set_dram0_split_line+0x2e>

    uint32_t regval;
    memprot_ll_prepare_dram0_split_line_regval(addr, &regval);
4200439c:	01bd      	mov.n	a11, a1
4200439e:	fff4a5        	call8	420042e8 <memprot_ll_prepare_dram0_split_line_regval>

    REG_WRITE(sensitive_reg, regval);
420043a1:	0188      	l32i.n	a8, a1, 0
420043a3:	0020c0        	memw
420043a6:	0389      	s32i.n	a8, a3, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((REG_READ(sensitive_reg) == regval) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
420043a8:	020c      	movi.n	a2, 0
420043aa:	000186        	j	420043b4 <memprot_ll_set_dram0_split_line+0x30>
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
420043ad:	220c      	movi.n	a2, 2
420043af:	000046        	j	420043b4 <memprot_ll_set_dram0_split_line+0x30>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
420043b2:	320c      	movi.n	a2, 3
}
420043b4:	f01d      	retw.n
	...

420043b8 <memprot_ll_dram0_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_dram0_set_pms_area_0(const bool r, const bool w)
{
420043b8:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
420043bb:	f09e81        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
420043be:	0020c0        	memw
420043c1:	0888      	l32i.n	a8, a8, 0
420043c3:	c97c      	movi.n	a9, -4
420043c5:	108890        	and	a8, a8, a9
    if (r) {
420043c8:	42cc      	bnez.n	a2, 420043d0 <memprot_ll_dram0_set_pms_area_0+0x18>
    uint32_t permissions = 0;
420043ca:	090c      	movi.n	a9, 0
420043cc:	000086        	j	420043d2 <memprot_ll_dram0_set_pms_area_0+0x1a>
420043cf:	190c00        	lsi	f0, a12, 100
    if (w) {
420043d2:	338c      	beqz.n	a3, 420043d9 <memprot_ll_dram0_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420043d4:	2a0c      	movi.n	a10, 2
420043d6:	2099a0        	or	a9, a9, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
420043d9:	149090        	extui	a9, a9, 0, 2
420043dc:	208890        	or	a8, a8, a9
420043df:	f09591        	l32r	a9, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
420043e2:	0020c0        	memw
420043e5:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
420043e7:	f01d      	retw.n
420043e9:	000000        	ill

420043ec <memprot_ll_dram0_set_pms_area_1>:

static inline void memprot_ll_dram0_set_pms_area_1(const bool r, const bool w)
{
420043ec:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
420043ef:	f09181        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
420043f2:	0020c0        	memw
420043f5:	0898      	l32i.n	a9, a8, 0
420043f7:	387c      	movi.n	a8, -13
420043f9:	109980        	and	a9, a9, a8
    if (r) {
420043fc:	42cc      	bnez.n	a2, 42004404 <memprot_ll_dram0_set_pms_area_1+0x18>
    uint32_t permissions = 0;
420043fe:	080c      	movi.n	a8, 0
42004400:	000086        	j	42004406 <memprot_ll_dram0_set_pms_area_1+0x1a>
42004403:	180c00        	lsxp	f0, a12, a0
    if (w) {
42004406:	338c      	beqz.n	a3, 4200440d <memprot_ll_dram0_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004408:	2a0c      	movi.n	a10, 2
4200440a:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
4200440d:	1188e0        	slli	a8, a8, 2
42004410:	ca0c      	movi.n	a10, 12
42004412:	1088a0        	and	a8, a8, a10
42004415:	209980        	or	a9, a9, a8
42004418:	f08781        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
4200441b:	0020c0        	memw
4200441e:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
42004420:	f01d      	retw.n
	...

42004424 <memprot_ll_dram0_set_pms_area_2>:

static inline void memprot_ll_dram0_set_pms_area_2(const bool r, const bool w)
{
42004424:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
42004427:	f08381        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
4200442a:	0020c0        	memw
4200442d:	0898      	l32i.n	a9, a8, 0
4200442f:	cfaf82        	movi	a8, -49
42004432:	109980        	and	a9, a9, a8
    if (r) {
42004435:	32cc      	bnez.n	a2, 4200443c <memprot_ll_dram0_set_pms_area_2+0x18>
    uint32_t permissions = 0;
42004437:	080c      	movi.n	a8, 0
42004439:	000046        	j	4200443e <memprot_ll_dram0_set_pms_area_2+0x1a>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
4200443c:	180c      	movi.n	a8, 1
    if (w) {
4200443e:	338c      	beqz.n	a3, 42004445 <memprot_ll_dram0_set_pms_area_2+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004440:	2a0c      	movi.n	a10, 2
42004442:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
42004445:	1188c0        	slli	a8, a8, 4
42004448:	0a3c      	movi.n	a10, 48
4200444a:	1088a0        	and	a8, a8, a10
4200444d:	209980        	or	a9, a9, a8
42004450:	f07981        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004453:	0020c0        	memw
42004456:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
42004458:	f01d      	retw.n
	...

4200445c <memprot_ll_dram0_set_pms_area_3>:

static inline void memprot_ll_dram0_set_pms_area_3(const bool r, const bool w)
{
4200445c:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
4200445f:	f07581        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004462:	0020c0        	memw
42004465:	0898      	l32i.n	a9, a8, 0
42004467:	3faf82        	movi	a8, -193
4200446a:	109980        	and	a9, a9, a8
    if (r) {
4200446d:	32cc      	bnez.n	a2, 42004474 <memprot_ll_dram0_set_pms_area_3+0x18>
    uint32_t permissions = 0;
4200446f:	080c      	movi.n	a8, 0
42004471:	000046        	j	42004476 <memprot_ll_dram0_set_pms_area_3+0x1a>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004474:	180c      	movi.n	a8, 1
    if (w) {
42004476:	338c      	beqz.n	a3, 4200447d <memprot_ll_dram0_set_pms_area_3+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004478:	2a0c      	movi.n	a10, 2
4200447a:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
4200447d:	1188a0        	slli	a8, a8, 6
42004480:	748080        	extui	a8, a8, 0, 8
42004483:	209980        	or	a9, a9, a8
42004486:	f06b81        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004489:	0020c0        	memw
4200448c:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
4200448e:	f01d      	retw.n

42004490 <memprot_ll_dram0_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_dram0_get_monitor_lock(const int core, bool* locked)
{
42004490:	004136        	entry	a1, 32
    switch (core) {
42004493:	628c      	beqz.n	a2, 4200449d <memprot_ll_dram0_get_monitor_lock+0xd>
42004495:	1b1226        	beqi	a2, 1, 420044b4 <memprot_ll_dram0_get_monitor_lock+0x24>
42004498:	720c      	movi.n	a2, 7
4200449a:	000ac6        	j	420044c9 <memprot_ll_dram0_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG) == 1;
4200449d:	f06681        	l32r	a8, 42000638 <_stext+0x618> (600c1104 <SYSTEM+0x1104>)
420044a0:	0020c0        	memw
420044a3:	0888      	l32i.n	a8, a8, 0
420044a5:	880b      	addi.n	a8, a8, -1
420044a7:	40f880        	nsau	a8, a8
420044aa:	418580        	srli	a8, a8, 5
420044ad:	004382        	s8i	a8, a3, 0
            break;
420044b0:	000546        	j	420044c9 <memprot_ll_dram0_get_monitor_lock+0x39>
420044b3:	628100        	lsi	f0, a1, 0x188
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG) == 1;
420044b6:	20c0f0        	or	a12, a0, a15
420044b9:	088800        	lsx	f8, a8, a0
420044bc:	880b      	addi.n	a8, a8, -1
420044be:	40f880        	nsau	a8, a8
420044c1:	418580        	srli	a8, a8, 5
420044c4:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420044c7:	020c      	movi.n	a2, 0
}
420044c9:	f01d      	retw.n
	...

420044cc <memprot_ll_dram0_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_dram0_set_monitor_en(const int core, const bool enable)
{
420044cc:	004136        	entry	a1, 32
    switch (core) {
420044cf:	628c      	beqz.n	a2, 420044d9 <memprot_ll_dram0_set_monitor_en+0xd>
420044d1:	301226        	beqi	a2, 1, 42004505 <memprot_ll_dram0_set_monitor_en+0x39>
420044d4:	720c      	movi.n	a2, 7
420044d6:	001606        	j	42004532 <memprot_ll_dram0_set_monitor_en+0x66>
        case PRO_CPU_NUM:
            if (enable) {
420044d9:	339c      	beqz.n	a3, 420044f0 <memprot_ll_dram0_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN);
420044db:	f05991        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
420044de:	0020c0        	memw
420044e1:	0988      	l32i.n	a8, a9, 0
420044e3:	2a0c      	movi.n	a10, 2
420044e5:	2088a0        	or	a8, a8, a10
420044e8:	0020c0        	memw
420044eb:	0989      	s32i.n	a8, a9, 0
420044ed:	001046        	j	42004532 <memprot_ll_dram0_set_monitor_en+0x66>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN);
420044f0:	f05491        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
420044f3:	0020c0        	memw
420044f6:	0988      	l32i.n	a8, a9, 0
420044f8:	da7c      	movi.n	a10, -3
420044fa:	1088a0        	and	a8, a8, a10
420044fd:	0020c0        	memw
42004500:	0989      	s32i.n	a8, a9, 0
42004502:	000b06        	j	42004532 <memprot_ll_dram0_set_monitor_en+0x66>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
42004505:	539c      	beqz.n	a3, 4200451e <memprot_ll_dram0_set_monitor_en+0x52>
                REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
42004507:	f04f91        	l32r	a9, 42000644 <_stext+0x624> (600c1118 <SYSTEM+0x1118>)
4200450a:	0020c0        	memw
4200450d:	0988      	l32i.n	a8, a9, 0
4200450f:	2a0c      	movi.n	a10, 2
42004511:	2088a0        	or	a8, a8, a10
42004514:	0020c0        	memw
42004517:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004519:	020c      	movi.n	a2, 0
4200451b:	0004c6        	j	42004532 <memprot_ll_dram0_set_monitor_en+0x66>
                REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
4200451e:	f04991        	l32r	a9, 42000644 <_stext+0x624> (600c1118 <SYSTEM+0x1118>)
42004521:	0020c0        	memw
42004524:	0988      	l32i.n	a8, a9, 0
42004526:	da7c      	movi.n	a10, -3
42004528:	1088a0        	and	a8, a8, a10
4200452b:	0020c0        	memw
4200452e:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
42004530:	020c      	movi.n	a2, 0
}
42004532:	f01d      	retw.n

42004534 <memprot_ll_dram0_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_dram0_get_monitor_en(const int core, bool* enabled)
{
42004534:	004136        	entry	a1, 32
    switch (core) {
42004537:	628c      	beqz.n	a2, 42004541 <memprot_ll_dram0_get_monitor_en+0xd>
42004539:	171226        	beqi	a2, 1, 42004554 <memprot_ll_dram0_get_monitor_en+0x20>
4200453c:	720c      	movi.n	a2, 7
4200453e:	000886        	j	42004564 <memprot_ll_dram0_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
42004541:	f03f81        	l32r	a8, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
42004544:	0020c0        	memw
42004547:	0888      	l32i.n	a8, a8, 0
42004549:	048180        	extui	a8, a8, 1, 1
4200454c:	004382        	s8i	a8, a3, 0
            break;
4200454f:	000446        	j	42004564 <memprot_ll_dram0_get_monitor_en+0x30>
42004552:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
42004555:	f03c      	movi.n	a0, 63
42004557:	0020c0        	memw
4200455a:	0888      	l32i.n	a8, a8, 0
4200455c:	048180        	extui	a8, a8, 1, 1
4200455f:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004562:	020c      	movi.n	a2, 0
}
42004564:	f01d      	retw.n
	...

42004568 <memprot_ll_dram0_set_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_dram0_set_monitor_intrclr(const int core)
{
42004568:	004136        	entry	a1, 32
    switch (core) {
4200456b:	628c      	beqz.n	a2, 42004575 <memprot_ll_dram0_set_monitor_intrclr+0xd>
4200456d:	1b1226        	beqi	a2, 1, 4200458c <memprot_ll_dram0_set_monitor_intrclr+0x24>
42004570:	720c      	movi.n	a2, 7
42004572:	000a86        	j	420045a0 <memprot_ll_dram0_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
42004575:	f03291        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
42004578:	0020c0        	memw
4200457b:	0988      	l32i.n	a8, a9, 0
4200457d:	1a0c      	movi.n	a10, 1
4200457f:	2088a0        	or	a8, a8, a10
42004582:	0020c0        	memw
42004585:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
42004587:	000546        	j	420045a0 <memprot_ll_dram0_set_monitor_intrclr+0x38>
4200458a:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
4200458d:	2e          	.byte	0x2e
4200458e:	20c0f0        	or	a12, a0, a15
42004591:	098800        	l32e	a0, a8, -32
42004594:	1a0c      	movi.n	a10, 1
42004596:	2088a0        	or	a8, a8, a10
42004599:	0020c0        	memw
4200459c:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200459e:	020c      	movi.n	a2, 0
}
420045a0:	f01d      	retw.n
	...

420045a4 <memprot_ll_dram0_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_dram0_reset_monitor_intrclr(const int core)
{
420045a4:	004136        	entry	a1, 32
    switch (core) {
420045a7:	628c      	beqz.n	a2, 420045b1 <memprot_ll_dram0_reset_monitor_intrclr+0xd>
420045a9:	1b1226        	beqi	a2, 1, 420045c8 <memprot_ll_dram0_reset_monitor_intrclr+0x24>
420045ac:	720c      	movi.n	a2, 7
420045ae:	000a86        	j	420045dc <memprot_ll_dram0_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
420045b1:	f02391        	l32r	a9, 42000640 <_stext+0x620> (600c1108 <SYSTEM+0x1108>)
420045b4:	0020c0        	memw
420045b7:	0988      	l32i.n	a8, a9, 0
420045b9:	ea7c      	movi.n	a10, -2
420045bb:	1088a0        	and	a8, a8, a10
420045be:	0020c0        	memw
420045c1:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
420045c3:	000546        	j	420045dc <memprot_ll_dram0_reset_monitor_intrclr+0x38>
420045c6:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
420045c9:	1f          	.byte	0x1f
420045ca:	20c0f0        	or	a12, a0, a15
420045cd:	098800        	l32e	a0, a8, -32
420045d0:	ea7c      	movi.n	a10, -2
420045d2:	1088a0        	and	a8, a8, a10
420045d5:	0020c0        	memw
420045d8:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420045da:	020c      	movi.n	a2, 0
}
420045dc:	f01d      	retw.n
	...

420045e0 <esp_mprot_cpuid_valid>:

//////////////////////////////////////////////////////////////////////////////
// internal helpers

static esp_err_t esp_mprot_cpuid_valid(const int core)
{
420045e0:	004136        	entry	a1, 32
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
420045e3:	090c      	movi.n	a9, 0
420045e5:	000386        	j	420045f7 <esp_mprot_cpuid_valid+0x17>
        if (core == s_memp_cfg.target_cpu[x]) {
420045e8:	894b      	addi.n	a8, a9, 4
420045ea:	f018a1        	l32r	a10, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
420045ed:	a088a0        	addx4	a8, a8, a10
420045f0:	0888      	l32i.n	a8, a8, 0
420045f2:	0f1827        	beq	a8, a2, 42004605 <esp_mprot_cpuid_valid+0x25>
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
420045f5:	991b      	addi.n	a9, a9, 1
420045f7:	f01581        	l32r	a8, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
420045fa:	3888      	l32i.n	a8, a8, 12
420045fc:	e83987        	bltu	a9, a8, 420045e8 <esp_mprot_cpuid_valid+0x8>
            return ESP_OK;
        }
    }

    return ESP_ERR_MEMPROT_CPUID_INVALID;
420045ff:	f01221        	l32r	a2, 42000648 <_stext+0x628> (d008 <UserFrameTotalSize+0xcf08>)
42004602:	000046        	j	42004607 <esp_mprot_cpuid_valid+0x27>
            return ESP_OK;
42004605:	020c      	movi.n	a2, 0
}
42004607:	f01d      	retw.n
42004609:	000000        	ill

4200460c <esp_memprot_iram0_get_def_split_addr>:

static void *esp_memprot_iram0_get_def_split_addr(void)
{
4200460c:	004136        	entry	a1, 32
    return (void *)(uint32_t)&_iram_text_end;
}
4200460f:	f01021        	l32r	a2, 42000650 <_stext+0x630> (40381f00 <_coredump_iram_end>)
42004612:	f01d      	retw.n

42004614 <esp_memprot_dram0_get_def_split_addr>:

static void *esp_memprot_dram0_get_def_split_addr(void)
{
42004614:	004136        	entry	a1, 32
    return (void *)MAP_IRAM_TO_DRAM((uint32_t)&_iram_text_end);
}
42004617:	f00e21        	l32r	a2, 42000650 <_stext+0x630> (40381f00 <_coredump_iram_end>)
4200461a:	f00481        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
4200461d:	228a      	add.n	a2, a2, a8
4200461f:	f01d      	retw.n
42004621:	000000        	ill

42004624 <esp_memprot_rtcfast_get_min_split_addr>:

static void *esp_memprot_rtcfast_get_min_split_addr(void)
{
42004624:	004136        	entry	a1, 32
    return (void *)(uint32_t)&_rtc_text_end;
}
42004627:	f00b21        	l32r	a2, 42000654 <_stext+0x634> (600fe000 <s_sleep_sub_mode_ref_cnt>)
4200462a:	f01d      	retw.n

4200462c <esp_mprot_set_intr_matrix>:

//register MEMPROT-relevant interrupts in the global matrix (to deploy panic handling)
//mapped to ETS_MEMACCESS_ERR_INUM (shared with cache-access interrupts)
static esp_err_t esp_mprot_set_intr_matrix(const esp_mprot_mem_t mem_type, const int core)
{
4200462c:	004136        	entry	a1, 32
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
4200462f:	19a0a2        	movi	a10, 25
42004632:	eef481        	l32r	a8, 42000204 <_stext+0x1e4> (40376578 <esp_intr_disable_source>)
42004635:	0008e0        	callx8	a8

    esp_err_t err;
    uint32_t intr_src_num = ETS_MAX_INTR_SOURCE;

    switch (mem_type) {
42004638:	3c2226        	beqi	a2, 2, 42004678 <esp_mprot_set_intr_matrix+0x4c>
4200463b:	6d4226        	beqi	a2, 4, 420046ac <esp_mprot_set_intr_matrix+0x80>
4200463e:	021226        	beqi	a2, 1, 42004644 <esp_mprot_set_intr_matrix+0x18>
42004641:	002906        	j	420046e9 <esp_mprot_set_intr_matrix+0xbd>
    switch (core) {
42004644:	838c      	beqz.n	a3, 42004650 <esp_mprot_set_intr_matrix+0x24>
42004646:	0f1366        	bnei	a3, 1, 42004659 <esp_mprot_set_intr_matrix+0x2d>
            *src_num = ETS_CORE1_IRAM0_PMS_INTR_SOURCE;
42004649:	975c      	movi.n	a7, 89
    return MEMP_HAL_OK;
4200464b:	0a0c      	movi.n	a10, 0
4200464d:	000386        	j	4200465f <esp_mprot_set_intr_matrix+0x33>
42004650:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_IRAM0_PMS_INTR_SOURCE;
42004652:	575c      	movi.n	a7, 85
42004654:	0001c6        	j	4200465f <esp_mprot_set_intr_matrix+0x33>
42004657:	720000        	lsi	f0, a0, 0x1c8
    switch (core) {
4200465a:	a263a0        	muluh	a6, a3, a10
4200465d:	af          	.byte	0xaf
4200465e:	ff          	.byte	0xff
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_intr_source_num(core, &intr_src_num)))
4200465f:	0129a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004662:	202aa0        	or	a2, a10, a10
42004665:	083a56        	bnez	a10, 420046ec <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
42004668:	19a0c2        	movi	a12, 25
4200466b:	07bd      	mov.n	a11, a7
4200466d:	03ad      	mov.n	a10, a3
4200466f:	ee9a81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
42004672:	0008e0        	callx8	a8
        break;
42004675:	0018c6        	j	420046dc <esp_mprot_set_intr_matrix+0xb0>
    switch (core) {
42004678:	838c      	beqz.n	a3, 42004684 <esp_mprot_set_intr_matrix+0x58>
4200467a:	0f1366        	bnei	a3, 1, 4200468d <esp_mprot_set_intr_matrix+0x61>
            *src_num = ETS_CORE1_DRAM0_PMS_INTR_SOURCE;
4200467d:	a75c      	movi.n	a7, 90
    return MEMP_HAL_OK;
4200467f:	0a0c      	movi.n	a10, 0
42004681:	000386        	j	42004693 <esp_mprot_set_intr_matrix+0x67>
42004684:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_DRAM0_PMS_INTR_SOURCE;
42004686:	675c      	movi.n	a7, 86
42004688:	0001c6        	j	42004693 <esp_mprot_set_intr_matrix+0x67>
4200468b:	720000        	lsi	f0, a0, 0x1c8
    switch (core) {
4200468e:	a263a0        	muluh	a6, a3, a10
42004691:	6507a0        	extui	a0, a10, 23, 7
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_intr_source_num(core, &intr_src_num)))
42004694:	a00126        	beqi	a1, -1, 42004638 <esp_mprot_set_intr_matrix+0xc>
42004697:	202a      	add.n	a2, a0, a2
42004699:	04fa56        	bnez	a10, 420046ec <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
4200469c:	19a0c2        	movi	a12, 25
4200469f:	07bd      	mov.n	a11, a7
420046a1:	03ad      	mov.n	a10, a3
420046a3:	ee8d81        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420046a6:	0008e0        	callx8	a8
        break;
420046a9:	000bc6        	j	420046dc <esp_mprot_set_intr_matrix+0xb0>
    switch (core) {
420046ac:	838c      	beqz.n	a3, 420046b8 <esp_mprot_set_intr_matrix+0x8c>
420046ae:	0f1366        	bnei	a3, 1, 420046c1 <esp_mprot_set_intr_matrix+0x95>
            *src_num = ETS_CORE1_PIF_PMS_INTR_SOURCE;
420046b1:	b75c      	movi.n	a7, 91
    return MEMP_HAL_OK;
420046b3:	0a0c      	movi.n	a10, 0
420046b5:	000386        	j	420046c7 <esp_mprot_set_intr_matrix+0x9b>
420046b8:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_PIF_PMS_INTR_SOURCE;
420046ba:	775c      	movi.n	a7, 87
420046bc:	0001c6        	j	420046c7 <esp_mprot_set_intr_matrix+0x9b>
420046bf:	720000        	lsi	f0, a0, 0x1c8
    switch (core) {
420046c2:	a263a0        	muluh	a6, a3, a10
420046c5:	2507a0        	extui	a0, a10, 23, 3
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_intr_source_num(core, &intr_src_num)))
420046c8:	a00123        	lsi	f2, a1, 0x280
420046cb:	202a      	add.n	a2, a0, a2
420046cd:	01ba56        	bnez	a10, 420046ec <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
420046d0:	9c1c      	movi.n	a12, 25
420046d2:	07bd      	mov.n	a11, a7
420046d4:	03ad      	mov.n	a10, a3
420046d6:	ee8081        	l32r	a8, 420000d8 <_stext+0xb8> (40001b54 <esp_rom_route_intr_matrix>)
420046d9:	0008e0        	callx8	a8
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    ESP_INTR_ENABLE(ETS_MEMACCESS_ERR_INUM);
420046dc:	9a1c      	movi.n	a10, 25
420046de:	eeca81        	l32r	a8, 42000208 <_stext+0x1e8> (40376568 <esp_intr_enable_source>)
420046e1:	0008e0        	callx8	a8

    return ESP_OK;
420046e4:	020c      	movi.n	a2, 0
420046e6:	000086        	j	420046ec <esp_mprot_set_intr_matrix+0xc0>
    switch (mem_type) {
420046e9:	efdb21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
}
420046ec:	f01d      	retw.n
	...

420046f0 <esp_mprot_set_split_addr>:
//////////////////////////////////////////////////////////////////////////////
// PMS configuration APIs (set/get/lock)
// IRAM/DRAM settings are shared by both CPUs, RTCFAST settings are separate for each core

esp_err_t esp_mprot_set_split_addr(const esp_mprot_mem_t mem_type, const esp_mprot_split_addr_t line_type, const void *line_addr, const int core __attribute__((unused)))
{
420046f0:	004136        	entry	a1, 32
    switch (mem_type) {
420046f3:	4e2226        	beqi	a2, 2, 42004745 <esp_mprot_set_split_addr+0x55>
420046f6:	024266        	bnei	a2, 4, 420046fc <esp_mprot_set_split_addr+0xc>
420046f9:	001f06        	j	42004779 <esp_mprot_set_split_addr+0x89>
420046fc:	021226        	beqi	a2, 1, 42004702 <esp_mprot_set_split_addr+0x12>
420046ff:	002546        	j	42004798 <esp_mprot_set_split_addr+0xa8>
    case MEMPROT_TYPE_IRAM0_SRAM:
        switch (line_type) {
42004702:	1b2326        	beqi	a3, 2, 42004721 <esp_mprot_set_split_addr+0x31>
42004705:	2a4326        	beqi	a3, 4, 42004733 <esp_mprot_set_split_addr+0x43>
42004708:	021326        	beqi	a3, 1, 4200470e <esp_mprot_set_split_addr+0x1e>
4200470b:	002446        	j	420047a0 <esp_mprot_set_split_addr+0xb0>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
4200470e:	efd4b1        	l32r	a11, 42000660 <_stext+0x640> (600c10c4 <SYSTEM+0x10c4>)
42004711:	20a440        	or	a10, a4, a4
42004714:	ff5ae5        	call8	42003cc4 <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_DRAM0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_main_I_D(line_addr));
42004717:	011e25        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
4200471a:	202aa0        	or	a2, a10, a10
4200471d:	0022c6        	j	420047ac <esp_mprot_set_split_addr+0xbc>
42004720:	d0b100        	subx2	a11, a1, a0
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
42004723:	ef          	.byte	0xef
42004724:	20a440        	or	a10, a4, a4
42004727:	ff59e5        	call8	42003cc4 <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_LINE_0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_0(line_addr));
4200472a:	011ce5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
4200472d:	202aa0        	or	a2, a10, a10
42004730:	001e06        	j	420047ac <esp_mprot_set_split_addr+0xbc>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
42004733:	efcdb1        	l32r	a11, 42000668 <_stext+0x648> (600c10cc <SYSTEM+0x10cc>)
42004736:	20a440        	or	a10, a4, a4
42004739:	ff58a5        	call8	42003cc4 <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_LINE_1:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_1(line_addr));
4200473c:	011ba5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
4200473f:	202aa0        	or	a2, a10, a10
42004742:	001986        	j	420047ac <esp_mprot_set_split_addr+0xbc>
        default:
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
        } break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        switch (line_type) {
42004745:	088326        	beqi	a3, 8, 42004751 <esp_mprot_set_split_addr+0x61>
42004748:	19b326        	beqi	a3, 16, 42004765 <esp_mprot_set_split_addr+0x75>
4200474b:	efc421        	l32r	a2, 4200065c <_stext+0x63c> (d002 <UserFrameTotalSize+0xcf02>)
4200474e:	001686        	j	420047ac <esp_mprot_set_split_addr+0xbc>
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
42004751:	efc6b1        	l32r	a11, 4200066c <_stext+0x64c> (600c10d0 <SYSTEM+0x10d0>)
42004754:	20a440        	or	a10, a4, a4
42004757:	ffc2e5        	call8	42004384 <memprot_ll_set_dram0_split_line>
        case MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_0(line_addr));
4200475a:	0119e5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
4200475d:	202aa0        	or	a2, a10, a10
42004760:	001206        	j	420047ac <esp_mprot_set_split_addr+0xbc>
42004763:	b10000        	sra	a0, a0
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
42004766:	40efc2        	s32c1i	a12, a15, 0x100
42004769:	a520a4        	lsi	f10, a0, 0x294
4200476c:	a5ffc1        	l32r	a12, 41fedf68 <_coredump_iram_end+0x1c6c068>
        case MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_1:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_1(line_addr));
4200476f:	0118      	l32i.n	a1, a1, 0
42004771:	202aa0        	or	a2, a10, a10
42004774:	000d06        	j	420047ac <esp_mprot_set_split_addr+0xbc>
42004777:	660000        	lsi	f0, a0, 0x198
        default:
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
        } break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        if (line_type == MEMPROT_SPLIT_ADDR_MAIN) { /* so far only WORLD_0 is supported */
4200477a:	502c13        	lsi	f1, a12, 0x140
            esp_err_t err;
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
4200477d:	2520a5        	call8	42029988 <_etext+0x13732>
42004780:	2dffe6        	bgei	a15, 0x100, 420047b1 <esp_mprot_get_default_main_split_addr+0x1>
42004783:	ec0a      	add.n	a14, a12, a0
42004785:	0c4a      	add.n	a0, a12, a4
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_rtcfast_split_line(core, line_addr, MEMP_HAL_WORLD_0)))
42004787:	bd1c      	movi.n	a13, 27
42004789:	05ad04        	lsi	f0, a13, 20
4200478c:	ff7ee5        	call8	42003f7c <memprot_ll_set_rtcfast_split_line>
4200478f:	0116a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004792:	0a2d      	mov.n	a2, a10
42004794:	000506        	j	420047ac <esp_mprot_set_split_addr+0xbc>
42004797:	b02100        	addx8	a2, a1, a0
    switch (mem_type) {
4200479a:	ef          	.byte	0xef
4200479b:	000346        	j	420047ac <esp_mprot_set_split_addr+0xbc>
4200479e:	210000        	srai	a0, a0, 0
        switch (line_type) {
420047a1:	af          	.byte	0xaf
420047a2:	ef          	.byte	0xef
420047a3:	000146        	j	420047ac <esp_mprot_set_split_addr+0xbc>
420047a6:	000000        	ill
            return ESP_OK;
        } else {
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
420047a9:	efac21        	l32r	a2, 4200065c <_stext+0x63c> (d002 <UserFrameTotalSize+0xcf02>)
        }
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }
}
420047ac:	f01d      	retw.n
	...

420047b0 <esp_mprot_get_default_main_split_addr>:

    return ESP_OK;
}

esp_err_t esp_mprot_get_default_main_split_addr(const esp_mprot_mem_t mem_type, void **def_split_addr)
{
420047b0:	004136        	entry	a1, 32
    if (def_split_addr == NULL) {
420047b3:	02e316        	beqz	a3, 420047e5 <esp_mprot_get_default_main_split_addr+0x35>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
420047b6:	112226        	beqi	a2, 2, 420047cb <esp_mprot_get_default_main_split_addr+0x1b>
420047b9:	1b4226        	beqi	a2, 4, 420047d8 <esp_mprot_get_default_main_split_addr+0x28>
420047bc:	2c1266        	bnei	a2, 1, 420047ec <esp_mprot_get_default_main_split_addr+0x3c>
    case MEMPROT_TYPE_IRAM0_SRAM:
        *def_split_addr = esp_memprot_iram0_get_def_split_addr();
420047bf:	ffe4e5        	call8	4200460c <esp_memprot_iram0_get_def_split_addr>
420047c2:	0063a2        	s32i	a10, a3, 0
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
420047c5:	00a022        	movi	a2, 0
        break;
420047c8:	0008c6        	j	420047ef <esp_mprot_get_default_main_split_addr+0x3f>
        *def_split_addr = esp_memprot_dram0_get_def_split_addr();
420047cb:	ffe4a5        	call8	42004614 <esp_memprot_dram0_get_def_split_addr>
420047ce:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
420047d0:	020c      	movi.n	a2, 0
        break;
420047d2:	000646        	j	420047ef <esp_mprot_get_default_main_split_addr+0x3f>
420047d5:	000000        	ill
        *def_split_addr = esp_memprot_rtcfast_get_min_split_addr();
420047d8:	ffe4a5        	call8	42004624 <esp_memprot_rtcfast_get_min_split_addr>
420047db:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
420047dd:	020c      	movi.n	a2, 0
        break;
420047df:	000306        	j	420047ef <esp_mprot_get_default_main_split_addr+0x3f>
420047e2:	000000        	ill
        return ESP_ERR_INVALID_ARG;
420047e5:	02a122        	movi	a2, 0x102
420047e8:	0000c6        	j	420047ef <esp_mprot_get_default_main_split_addr+0x3f>
420047eb:	9b2100        	movnez.s	f2, f1, a0
    switch (mem_type) {
420047ee:	ef          	.byte	0xef
}
420047ef:	f01d      	retw.n
420047f1:	000000        	ill

420047f4 <esp_mprot_set_split_addr_lock>:

esp_err_t esp_mprot_set_split_addr_lock(const esp_mprot_mem_t mem_type, const int core __attribute__((unused)))
{
420047f4:	004136        	entry	a1, 32
    switch (mem_type) {
420047f7:	0932f6        	bgeui	a2, 3, 42004804 <esp_mprot_set_split_addr_lock+0x10>
420047fa:	f2cc      	bnez.n	a2, 4200480d <esp_mprot_set_split_addr_lock+0x19>
420047fc:	ef9721        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
420047ff:	001446        	j	42004854 <esp_mprot_set_split_addr_lock+0x60>
42004802:	260000        	lsi	f0, a0, 152
42004805:	211442        	l16ui	a4, a4, 66
42004808:	86ef94        	lsi	f9, a15, 0x218
4200480b:	810011        	l32r	a1, 41fe4c0c <_coredump_iram_end+0x1c62d0c>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG, 1);
4200480e:	ef99      	s32i.n	a9, a15, 56
42004810:	190c      	movi.n	a9, 1
42004812:	0020c0        	memw
42004815:	0899      	s32i.n	a9, a8, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004817:	020c      	movi.n	a2, 0
}
42004819:	000dc6        	j	42004854 <esp_mprot_set_split_addr_lock+0x60>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
4200481c:	20a330        	or	a10, a3, a3
4200481f:	ffdc25        	call8	420045e0 <esp_mprot_cpuid_valid>
42004822:	202aa0        	or	a2, a10, a10
42004825:	02ba56        	bnez	a10, 42004854 <esp_mprot_set_split_addr_lock+0x60>
    switch (core) {
42004828:	838c      	beqz.n	a3, 42004834 <esp_mprot_set_split_addr_lock+0x40>
4200482a:	131326        	beqi	a3, 1, 42004841 <esp_mprot_set_split_addr_lock+0x4d>
4200482d:	730c      	movi.n	a3, 7
4200482f:	000686        	j	4200484d <esp_mprot_set_split_addr_lock+0x59>
42004832:	810000        	src	a0, a0, a0
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG, 1);
42004835:	0cef72        	s32c1i	a7, a15, 48
42004838:	c019      	s32i.n	a1, a0, 48
4200483a:	990020        	lsi	f2, a0, 0x264
4200483d:	c608      	l32i.n	a0, a6, 48
            break;
4200483f:	810002        	l8ui	a0, a0, 129
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
42004842:	6f          	.byte	0x6f
42004843:	ef          	.byte	0xef
42004844:	190c      	movi.n	a9, 1
42004846:	0020c0        	memw
42004849:	0899      	s32i.n	a9, a8, 0
    return MEMP_HAL_OK;
4200484b:	0a3d      	mov.n	a3, a10
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_pif_constraint_lock(core)))
4200484d:	03ad      	mov.n	a10, a3
4200484f:	010aa5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004852:	0a2d      	mov.n	a2, a10
}
42004854:	f01d      	retw.n
	...

42004858 <esp_mprot_get_split_addr_lock>:

esp_err_t esp_mprot_get_split_addr_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core __attribute__((unused)))
{
42004858:	004136        	entry	a1, 32
    if (locked == NULL) {
4200485b:	04a316        	beqz	a3, 420048a9 <esp_mprot_get_split_addr_lock+0x51>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
4200485e:	0732f6        	bgeui	a2, 3, 42004869 <esp_mprot_get_split_addr_lock+0x11>
42004861:	f2cc      	bnez.n	a2, 42004874 <esp_mprot_get_split_addr_lock+0x1c>
42004863:	ef7d21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004866:	001086        	j	420048ac <esp_mprot_get_split_addr_lock+0x54>
42004869:	214226        	beqi	a2, 4, 4200488e <esp_mprot_get_split_addr_lock+0x36>
4200486c:	ef7b21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
4200486f:	000e46        	j	420048ac <esp_mprot_get_split_addr_lock+0x54>
42004872:	810000        	src	a0, a0, a0
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
42004875:	c0ef80        	sub	a14, a15, a8
42004878:	880020        	lsi	f2, a0, 0x220
4200487b:	0b08      	l32i.n	a0, a11, 0
4200487d:	8088      	l32i.n	a8, a0, 32
4200487f:	40f8      	l32i.n	a15, a0, 16
42004881:	418580        	srli	a8, a8, 5
    case MEMPROT_TYPE_IRAM0_SRAM:
    case MEMPROT_TYPE_DRAM0_SRAM:
        *locked = memprot_ll_get_iram0_dram0_split_line_lock();
42004884:	004382        	s8i	a8, a3, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004887:	020c      	movi.n	a2, 0
        break;
42004889:	0007c6        	j	420048ac <esp_mprot_get_split_addr_lock+0x54>
4200488c:	400000        	ssr	a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
4200488f:	e520a4        	lsi	f10, a0, 0x394
42004892:	2dffd4        	lsi	f13, a15, 180
42004895:	dc0a      	add.n	a13, a12, a0
42004897:	bd2a      	add.n	a11, a13, a2
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_get_pif_constraint_lock(core, locked)))
42004899:	04ad03        	lsi	f0, a13, 16
4200489c:	ff6a25        	call8	42003f40 <memprot_ll_get_pif_constraint_lock>
4200489f:	0105a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
420048a2:	0a2d      	mov.n	a2, a10
420048a4:	000106        	j	420048ac <esp_mprot_get_split_addr_lock+0x54>
420048a7:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
420048aa:	1d02a1        	l32r	a10, 41fcbcb4 <_coredump_iram_end+0x1c49db4>
}
420048ad:	0000f0        	callx12	a0

420048b0 <esp_mprot_set_pms_lock>:

esp_err_t esp_mprot_set_pms_lock(const esp_mprot_mem_t mem_type, const int core __attribute__((unused)))
{
420048b0:	004136        	entry	a1, 32
    switch (mem_type) {
420048b3:	152226        	beqi	a2, 2, 420048cc <esp_mprot_set_pms_lock+0x1c>
420048b6:	224226        	beqi	a2, 4, 420048dc <esp_mprot_set_pms_lock+0x2c>
420048b9:	601266        	bnei	a2, 1, 4200491d <esp_mprot_set_pms_lock+0x6d>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG, 1);
420048bc:	ef6f81        	l32r	a8, 42000678 <_stext+0x658> (600c10d8 <SYSTEM+0x10d8>)
420048bf:	190c      	movi.n	a9, 1
420048c1:	0020c0        	memw
420048c4:	0899      	s32i.n	a9, a8, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
420048c6:	020c      	movi.n	a2, 0
}
420048c8:	001506        	j	42004920 <esp_mprot_set_pms_lock+0x70>
420048cb:	6c8100        	lsi	f0, a1, 0x1b0
    REG_WRITE(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG, 1);
420048ce:	ef          	.byte	0xef
420048cf:	190c      	movi.n	a9, 1
420048d1:	0020c0        	memw
420048d4:	0899      	s32i.n	a9, a8, 0
420048d6:	020c      	movi.n	a2, 0
}
420048d8:	001106        	j	42004920 <esp_mprot_set_pms_lock+0x70>
420048db:	a33000        	movltz	a3, a0, a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
420048de:	d02520        	subx2	a2, a5, a2
420048e1:	ff          	.byte	0xff
420048e2:	202aa0        	or	a2, a10, a10
420048e5:	037a56        	bnez	a10, 42004920 <esp_mprot_set_pms_lock+0x70>
    switch (core) {
420048e8:	838c      	beqz.n	a3, 420048f4 <esp_mprot_set_pms_lock+0x44>
420048ea:	131326        	beqi	a3, 1, 42004901 <esp_mprot_set_pms_lock+0x51>
420048ed:	730c      	movi.n	a3, 7
420048ef:	000746        	j	42004910 <esp_mprot_set_pms_lock+0x60>
420048f2:	810000        	src	a0, a0, a0
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG, 1);
420048f5:	0cef42        	s32c1i	a4, a15, 48
420048f8:	c019      	s32i.n	a1, a0, 48
420048fa:	990020        	lsi	f2, a0, 0x264
420048fd:	8608      	l32i.n	a0, a6, 32
            break;
420048ff:	810003        	lsi	f0, a0, 0x204
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
42004902:	3f          	.byte	0x3f
42004903:	ef          	.byte	0xef
42004904:	01a092        	movi	a9, 1
42004907:	0020c0        	memw
4200490a:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
4200490d:	203aa0        	or	a3, a10, a10
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_pif_constraint_lock(core)))
42004910:	03ad      	mov.n	a10, a3
42004912:	00fe65        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004915:	0a2d      	mov.n	a2, a10
42004917:	000146        	j	42004920 <esp_mprot_set_pms_lock+0x70>
4200491a:	000000        	ill
    switch (mem_type) {
4200491d:	ef4e21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
}
42004920:	f01d      	retw.n
	...

42004924 <esp_mprot_get_pms_lock>:

esp_err_t esp_mprot_get_pms_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core __attribute__((unused)))
{
42004924:	004136        	entry	a1, 32
    if (locked == NULL) {
42004927:	055316        	beqz	a3, 42004980 <esp_mprot_get_pms_lock+0x5c>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
4200492a:	1d2226        	beqi	a2, 2, 4200494b <esp_mprot_get_pms_lock+0x27>
4200492d:	354226        	beqi	a2, 4, 42004966 <esp_mprot_get_pms_lock+0x42>
42004930:	551266        	bnei	a2, 1, 42004989 <esp_mprot_get_pms_lock+0x65>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG) == 1;
42004933:	ef5181        	l32r	a8, 42000678 <_stext+0x658> (600c10d8 <SYSTEM+0x10d8>)
42004936:	0020c0        	memw
42004939:	0888      	l32i.n	a8, a8, 0
4200493b:	880b      	addi.n	a8, a8, -1
4200493d:	40f880        	nsau	a8, a8
42004940:	418580        	srli	a8, a8, 5
    case MEMPROT_TYPE_IRAM0_SRAM:
        *locked = memprot_ll_iram0_get_pms_lock();
42004943:	004382        	s8i	a8, a3, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004946:	020c      	movi.n	a2, 0
        break;
42004948:	001006        	j	4200498c <esp_mprot_get_pms_lock+0x68>
    return REG_READ(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG) == 1;
4200494b:	ef4c81        	l32r	a8, 4200067c <_stext+0x65c> (600c10fc <SYSTEM+0x10fc>)
4200494e:	0020c0        	memw
42004951:	0888      	l32i.n	a8, a8, 0
42004953:	880b      	addi.n	a8, a8, -1
42004955:	40f880        	nsau	a8, a8
42004958:	418580        	srli	a8, a8, 5
        *locked = memprot_ll_dram0_get_pms_lock();
4200495b:	004382        	s8i	a8, a3, 0
    return ESP_OK;
4200495e:	020c      	movi.n	a2, 0
        break;
42004960:	000a06        	j	4200498c <esp_mprot_get_pms_lock+0x68>
42004963:	000000        	ill
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004966:	20a440        	or	a10, a4, a4
42004969:	ffc765        	call8	420045e0 <esp_mprot_cpuid_valid>
4200496c:	0a2d      	mov.n	a2, a10
4200496e:	aadc      	bnez.n	a10, 4200498c <esp_mprot_get_pms_lock+0x68>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_get_pif_constraint_lock(core, locked)))
42004970:	03bd      	mov.n	a11, a3
42004972:	04ad      	mov.n	a10, a4
42004974:	ff5ca5        	call8	42003f40 <memprot_ll_get_pif_constraint_lock>
42004977:	00f825        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
4200497a:	0a2d      	mov.n	a2, a10
4200497c:	000306        	j	4200498c <esp_mprot_get_pms_lock+0x68>
4200497f:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004982:	014602        	s8i	a0, a6, 1
42004985:	000000        	ill
42004988:	332100        	clamps	a2, a1, 7
    switch (mem_type) {
4200498b:	ef          	.byte	0xef
}
4200498c:	f01d      	retw.n
	...

42004990 <esp_mprot_set_pms_area>:

esp_err_t esp_mprot_set_pms_area(const esp_mprot_pms_area_t area_type, const uint32_t flags, const int core __attribute__((unused)))
{
42004990:	004136        	entry	a1, 32
    esp_err_t err;
    bool r = flags & MEMPROT_OP_READ;
    bool w = flags & MEMPROT_OP_WRITE;
42004993:	047130        	extui	a7, a3, 1, 1
    bool x = flags & MEMPROT_OP_EXEC;
42004996:	046230        	extui	a6, a3, 2, 1

    switch (area_type) {
42004999:	02d266        	bnei	a2, 64, 4200499f <esp_mprot_set_pms_area+0xf>
4200499c:	003446        	j	42004a71 <esp_mprot_set_pms_area+0xe1>
4200499f:	084c      	movi.n	a8, 64
420049a1:	2f3827        	bltu	a8, a2, 420049d4 <esp_mprot_set_pms_area+0x44>
420049a4:	028266        	bnei	a2, 8, 420049aa <esp_mprot_set_pms_area+0x1a>
420049a7:	002506        	j	42004a3f <esp_mprot_set_pms_area+0xaf>
420049aa:	880c      	movi.n	a8, 8
420049ac:	103827        	bltu	a8, a2, 420049c0 <esp_mprot_set_pms_area+0x30>
420049af:	6b2226        	beqi	a2, 2, 42004a1e <esp_mprot_set_pms_area+0x8e>
420049b2:	774226        	beqi	a2, 4, 42004a2d <esp_mprot_set_pms_area+0x9d>
420049b5:	531226        	beqi	a2, 1, 42004a0c <esp_mprot_set_pms_area+0x7c>
420049b8:	06a122        	movi	a2, 0x106
420049bb:	004ec6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
420049be:	660000        	lsi	f0, a0, 0x198
420049c1:	8602b2        	l8ui	a11, a2, 134
420049c4:	660022        	l8ui	a2, a0, 102
420049c7:	0602c2        	l8ui	a12, a2, 6
420049ca:	220025        	call8	420269cc <_etext+0x10776>
420049cd:	c606a1        	l32r	a10, 41ff61e8 <_coredump_iram_end+0x1c742e8>
420049d0:	0049      	s32i.n	a4, a0, 0
420049d2:	820000        	mull	a0, a0, a0
420049d5:	8700a2        	l8ui	a10, a0, 135
420049d8:	060292        	l8ui	a9, a2, 6
420049db:	270036        	entry	a0, 0x1380
420049de:	1338      	l32i.n	a3, a3, 4
420049e0:	02e266        	bnei	a2, 128, 420049e6 <esp_mprot_set_pms_area+0x56>
420049e3:	002686        	j	42004a81 <esp_mprot_set_pms_area+0xf1>
420049e6:	02f266        	bnei	a2, 0x100, 420049ec <esp_mprot_set_pms_area+0x5c>
420049e9:	002906        	j	42004a91 <esp_mprot_set_pms_area+0x101>
420049ec:	06a122        	movi	a2, 0x106
420049ef:	0041c6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
420049f2:	820000        	mull	a0, a0, a0
420049f5:	8700a4        	lsi	f10, a0, 0x21c
420049f8:	860292        	l8ui	a9, a2, 134
420049fb:	810037        	bnone	a0, a3, 42004980 <esp_mprot_get_pms_lock+0x5c>
420049fe:	87eee4        	lsi	f14, a14, 0x21c
42004a01:	c60292        	l8ui	a9, a2, 198
42004a04:	0039      	s32i.n	a3, a0, 0
42004a06:	06a122        	movi	a2, 0x106
42004a09:	003b46        	j	42004afa <esp_mprot_set_pms_area+0x16a>
    case MEMPROT_PMS_AREA_IRAM0_0:
        memprot_ll_iram0_set_pms_area_0(r, w, x);
42004a0c:	20c660        	or	a12, a6, a6
42004a0f:	20b770        	or	a11, a7, a7
42004a12:	04a030        	extui	a10, a3, 0, 1
42004a15:	ff2e25        	call8	42003cf8 <memprot_ll_iram0_set_pms_area_0>
        break;
    default:
        return ESP_ERR_NOT_SUPPORTED;
    }

    return ESP_OK;
42004a18:	00a022        	movi	a2, 0
        break;
42004a1b:	0036c6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_1(r, w, x);
42004a1e:	06cd      	mov.n	a12, a6
42004a20:	07bd      	mov.n	a11, a7
42004a22:	04a030        	extui	a10, a3, 0, 1
42004a25:	ff30a5        	call8	42003d30 <memprot_ll_iram0_set_pms_area_1>
    return ESP_OK;
42004a28:	020c      	movi.n	a2, 0
        break;
42004a2a:	003306        	j	42004afa <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_2(r, w, x);
42004a2d:	20c660        	or	a12, a6, a6
42004a30:	20b770        	or	a11, a7, a7
42004a33:	04a030        	extui	a10, a3, 0, 1
42004a36:	ff33a5        	call8	42003d70 <memprot_ll_iram0_set_pms_area_2>
    return ESP_OK;
42004a39:	00a022        	movi	a2, 0
        break;
42004a3c:	002e86        	j	42004afa <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_3(r, w, x);
42004a3f:	20c660        	or	a12, a6, a6
42004a42:	20b770        	or	a11, a7, a7
42004a45:	04a030        	extui	a10, a3, 0, 1
42004a48:	ff3665        	call8	42003db0 <memprot_ll_iram0_set_pms_area_3>
    return ESP_OK;
42004a4b:	00a022        	movi	a2, 0
        break;
42004a4e:	002a06        	j	42004afa <esp_mprot_set_pms_area+0x16a>
        memprot_ll_dram0_set_pms_area_0(r, w);
42004a51:	07bd      	mov.n	a11, a7
42004a53:	04a030        	extui	a10, a3, 0, 1
42004a56:	ff9625        	call8	420043b8 <memprot_ll_dram0_set_pms_area_0>
    return ESP_OK;
42004a59:	020c      	movi.n	a2, 0
        break;
42004a5b:	0026c6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
42004a5e:	000000        	ill
        memprot_ll_dram0_set_pms_area_1(r, w);
42004a61:	07bd      	mov.n	a11, a7
42004a63:	04a030        	extui	a10, a3, 0, 1
42004a66:	ff9865        	call8	420043ec <memprot_ll_dram0_set_pms_area_1>
    return ESP_OK;
42004a69:	020c      	movi.n	a2, 0
        break;
42004a6b:	0022c6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
42004a6e:	000000        	ill
        memprot_ll_dram0_set_pms_area_2(r, w);
42004a71:	07bd      	mov.n	a11, a7
42004a73:	04a030        	extui	a10, a3, 0, 1
42004a76:	ff9ae5        	call8	42004424 <memprot_ll_dram0_set_pms_area_2>
    return ESP_OK;
42004a79:	020c      	movi.n	a2, 0
        break;
42004a7b:	001ec6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
42004a7e:	000000        	ill
        memprot_ll_dram0_set_pms_area_3(r, w);
42004a81:	07bd      	mov.n	a11, a7
42004a83:	04a030        	extui	a10, a3, 0, 1
42004a86:	ff9d65        	call8	4200445c <memprot_ll_dram0_set_pms_area_3>
    return ESP_OK;
42004a89:	020c      	movi.n	a2, 0
        break;
42004a8b:	001ac6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
42004a8e:	000000        	ill
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004a91:	20a440        	or	a10, a4, a4
42004a94:	ffb4a5        	call8	420045e0 <esp_mprot_cpuid_valid>
42004a97:	0a2d      	mov.n	a2, a10
42004a99:	05da56        	bnez	a10, 42004afa <esp_mprot_set_pms_area+0x16a>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_pms_area(core, r, w, x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_LOW)))
42004a9c:	1f0c      	movi.n	a15, 1
42004a9e:	0fed      	mov.n	a14, a15
42004aa0:	06dd      	mov.n	a13, a6
42004aa2:	07cd      	mov.n	a12, a7
42004aa4:	10b3f0        	and	a11, a3, a15
42004aa7:	04ad      	mov.n	a10, a4
42004aa9:	ff54a5        	call8	42003ff4 <memprot_ll_rtcfast_set_pms_area>
42004aac:	00e4a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004aaf:	0a2d      	mov.n	a2, a10
42004ab1:	001146        	j	42004afa <esp_mprot_set_pms_area+0x16a>
42004ab4:	400000        	ssr	a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004ab7:	6520a4        	lsi	f10, a0, 0x194
42004aba:	2dffb2        	s32ri	a11, a15, 180
42004abd:	560a      	add.n	a5, a6, a0
42004abf:	038a      	add.n	a0, a3, a8
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_pms_area(core, r, w, x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
42004ac1:	2f0c      	movi.n	a15, 2
42004ac3:	1e0c      	movi.n	a14, 1
42004ac5:	20d660        	or	a13, a6, a6
42004ac8:	20c770        	or	a12, a7, a7
42004acb:	10b3e0        	and	a11, a3, a14
42004ace:	04ad      	mov.n	a10, a4
42004ad0:	ff5225        	call8	42003ff4 <memprot_ll_rtcfast_set_pms_area>
42004ad3:	00e265        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004ad6:	0a2d      	mov.n	a2, a10
42004ad8:	000786        	j	42004afa <esp_mprot_set_pms_area+0x16a>
42004adb:	c66000        	lsi	f0, a0, 0x318
        memprot_ll_icache_set_pms_area_0(r, w, x);
42004ade:	b77020        	lsi	f2, a0, 0x2dc
42004ae1:	a03020        	addx4	a3, a0, a2
42004ae4:	0ca504        	lsi	f0, a5, 48
42004ae7:	ff          	.byte	0xff
    return ESP_OK;
42004ae8:	00a022        	movi	a2, 0
        break;
42004aeb:	0002c6        	j	42004afa <esp_mprot_set_pms_area+0x16a>
        memprot_ll_icache_set_pms_area_1(r, w, x);
42004aee:	06cd      	mov.n	a12, a6
42004af0:	07bd      	mov.n	a11, a7
42004af2:	04a030        	extui	a10, a3, 0, 1
42004af5:	ff0fa5        	call8	42003bf0 <memprot_ll_icache_set_pms_area_1>
    return ESP_OK;
42004af8:	020c      	movi.n	a2, 0
}
42004afa:	f01d      	retw.n

42004afc <esp_mprot_get_pms_area>:

esp_err_t esp_mprot_get_pms_area(const esp_mprot_pms_area_t area_type, uint32_t *flags, const int core __attribute__((unused)))
{
42004afc:	006136        	entry	a1, 48
    if (flags == NULL) {
42004aff:	209316        	beqz	a3, 42004d0c <esp_mprot_get_pms_area+0x210>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    bool r = false;
42004b02:	080c      	movi.n	a8, 0
42004b04:	004182        	s8i	a8, a1, 0
    bool w = false;
42004b07:	014182        	s8i	a8, a1, 1
    bool x = false;
42004b0a:	024182        	s8i	a8, a1, 2

    switch (area_type) {
42004b0d:	02d266        	bnei	a2, 64, 42004b13 <esp_mprot_get_pms_area+0x17>
42004b10:	004406        	j	42004c24 <esp_mprot_get_pms_area+0x128>
42004b13:	084c      	movi.n	a8, 64
42004b15:	2e3827        	bltu	a8, a2, 42004b47 <esp_mprot_get_pms_area+0x4b>
42004b18:	028266        	bnei	a2, 8, 42004b1e <esp_mprot_get_pms_area+0x22>
42004b1b:	002e46        	j	42004bd8 <esp_mprot_get_pms_area+0xdc>
42004b1e:	880c      	movi.n	a8, 8
42004b20:	113827        	bltu	a8, a2, 42004b35 <esp_mprot_get_pms_area+0x39>
42004b23:	752226        	beqi	a2, 2, 42004b9c <esp_mprot_get_pms_area+0xa0>
42004b26:	024266        	bnei	a2, 4, 42004b2c <esp_mprot_get_pms_area+0x30>
42004b29:	002306        	j	42004bb9 <esp_mprot_get_pms_area+0xbd>
42004b2c:	4d1226        	beqi	a2, 1, 42004b7d <esp_mprot_get_pms_area+0x81>
42004b2f:	eeca21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004b32:	007786        	j	42004d14 <esp_mprot_get_pms_area+0x218>
42004b35:	02b266        	bnei	a2, 16, 42004b3b <esp_mprot_get_pms_area+0x3f>
42004b38:	002e46        	j	42004bf5 <esp_mprot_get_pms_area+0xf9>
42004b3b:	02c266        	bnei	a2, 32, 42004b41 <esp_mprot_get_pms_area+0x45>
42004b3e:	003286        	j	42004c0c <esp_mprot_get_pms_area+0x110>
42004b41:	eec521        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004b44:	007306        	j	42004d14 <esp_mprot_get_pms_area+0x218>
42004b47:	00a282        	movi	a8, 0x200
42004b4a:	029287        	bne	a2, a8, 42004b50 <esp_mprot_get_pms_area+0x54>
42004b4d:	004a86        	j	42004c7b <esp_mprot_get_pms_area+0x17f>
42004b50:	113827        	bltu	a8, a2, 42004b65 <esp_mprot_get_pms_area+0x69>
42004b53:	02e266        	bnei	a2, 128, 42004b59 <esp_mprot_get_pms_area+0x5d>
42004b56:	003886        	j	42004c3c <esp_mprot_get_pms_area+0x140>
42004b59:	02f266        	bnei	a2, 0x100, 42004b5f <esp_mprot_get_pms_area+0x63>
42004b5c:	003d86        	j	42004c56 <esp_mprot_get_pms_area+0x15a>
42004b5f:	eebe21        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004b62:	006b86        	j	42004d14 <esp_mprot_get_pms_area+0x218>
42004b65:	00a482        	movi	a8, 0x400
42004b68:	029287        	bne	a2, a8, 42004b6e <esp_mprot_get_pms_area+0x72>
42004b6b:	004c86        	j	42004ca1 <esp_mprot_get_pms_area+0x1a5>
42004b6e:	ee8881        	l32r	a8, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
42004b71:	029287        	bne	a2, a8, 42004b77 <esp_mprot_get_pms_area+0x7b>
42004b74:	005206        	j	42004cc0 <esp_mprot_get_pms_area+0x1c4>
42004b77:	eeb821        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
42004b7a:	006586        	j	42004d14 <esp_mprot_get_pms_area+0x218>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
42004b7d:	ee9381        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42004b80:	0020c0        	memw
42004b83:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004b85:	049080        	extui	a9, a8, 0, 1
42004b88:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004b8b:	049180        	extui	a9, a8, 1, 1
42004b8e:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004b91:	048280        	extui	a8, a8, 2, 1
42004b94:	024182        	s8i	a8, a1, 2
}
42004b97:	004fc6        	j	42004cda <esp_mprot_get_pms_area+0x1de>
42004b9a:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
42004b9d:	ee8c      	beqz.n	a14, 42004baf <esp_mprot_get_pms_area+0xb3>
42004b9f:	0020c0        	memw
42004ba2:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004ba4:	049380        	extui	a9, a8, 3, 1
42004ba7:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004baa:	049480        	extui	a9, a8, 4, 1
42004bad:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004bb0:	048580        	extui	a8, a8, 5, 1
42004bb3:	024182        	s8i	a8, a1, 2
}
42004bb6:	004806        	j	42004cda <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
42004bb9:	ee8481        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42004bbc:	0020c0        	memw
42004bbf:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004bc1:	049680        	extui	a9, a8, 6, 1
42004bc4:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004bc7:	049780        	extui	a9, a8, 7, 1
42004bca:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004bcd:	048880        	extui	a8, a8, 8, 1
42004bd0:	024182        	s8i	a8, a1, 2
}
42004bd3:	0040c6        	j	42004cda <esp_mprot_get_pms_area+0x1de>
42004bd6:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
42004bd9:	ee7d      	lsi	f7, a14, 56
42004bdb:	0020c0        	memw
42004bde:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004be0:	049980        	extui	a9, a8, 9, 1
42004be3:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004be6:	049a80        	extui	a9, a8, 10, 1
42004be9:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004bec:	048b80        	extui	a8, a8, 11, 1
42004bef:	024182        	s8i	a8, a1, 2
}
42004bf2:	003906        	j	42004cda <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
42004bf5:	ee8f81        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004bf8:	0020c0        	memw
42004bfb:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004bfd:	049080        	extui	a9, a8, 0, 1
42004c00:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004c03:	048180        	extui	a8, a8, 1, 1
42004c06:	014182        	s8i	a8, a1, 1
}
42004c09:	003346        	j	42004cda <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
42004c0c:	ee8a81        	l32r	a8, 42000634 <_stext+0x614> (600c1100 <SYSTEM+0x1100>)
42004c0f:	0020c0        	memw
42004c12:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004c14:	049280        	extui	a9, a8, 2, 1
42004c17:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004c1a:	048380        	extui	a8, a8, 3, 1
42004c1d:	014182        	s8i	a8, a1, 1
}
42004c20:	002d86        	j	42004cda <esp_mprot_get_pms_area+0x1de>
42004c23:	848100        	extui	a8, a0, 1, 9
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
42004c26:	ee          	.byte	0xee
42004c27:	0020c0        	memw
42004c2a:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004c2c:	049480        	extui	a9, a8, 4, 1
42004c2f:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004c32:	048580        	extui	a8, a8, 5, 1
42004c35:	014182        	s8i	a8, a1, 1
}
42004c38:	002786        	j	42004cda <esp_mprot_get_pms_area+0x1de>
42004c3b:	7e8100        	f64rnd	a8, a1, a0, 3
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
42004c3e:	ee          	.byte	0xee
42004c3f:	0020c0        	memw
42004c42:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004c44:	049680        	extui	a9, a8, 6, 1
42004c47:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004c4a:	048780        	extui	a8, a8, 7, 1
42004c4d:	014182        	s8i	a8, a1, 1
}
42004c50:	002186        	j	42004cda <esp_mprot_get_pms_area+0x1de>
42004c53:	000000        	ill
        break;
    case MEMPROT_PMS_AREA_DRAM0_3:
        memprot_ll_dram0_get_pms_area_3(&r, &w);
        break;
    case MEMPROT_PMS_AREA_IRAM0_RTCFAST_LO:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004c56:	20a440        	or	a10, a4, a4
42004c59:	ff9865        	call8	420045e0 <esp_mprot_cpuid_valid>
42004c5c:	0a2d      	mov.n	a2, a10
42004c5e:	0b2a56        	bnez	a10, 42004d14 <esp_mprot_get_pms_area+0x218>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_pms_area(core, &r, &w, &x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_LOW)))
42004c61:	1f0c      	movi.n	a15, 1
42004c63:	0fed      	mov.n	a14, a15
42004c65:	d12b      	addi.n	a13, a1, 2
42004c67:	c1fa      	add.n	a12, a1, a15
42004c69:	01bd      	mov.n	a11, a1
42004c6b:	04ad      	mov.n	a10, a4
42004c6d:	ff4625        	call8	420040d0 <memprot_ll_rtcfast_get_pms_area>
42004c70:	00c865        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004c73:	0a2d      	mov.n	a2, a10
42004c75:	061a16        	beqz	a10, 42004cda <esp_mprot_get_pms_area+0x1de>
42004c78:	002606        	j	42004d14 <esp_mprot_get_pms_area+0x218>
        break;
    case MEMPROT_PMS_AREA_IRAM0_RTCFAST_HI:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004c7b:	20a440        	or	a10, a4, a4
42004c7e:	ff9625        	call8	420045e0 <esp_mprot_cpuid_valid>
42004c81:	0a2d      	mov.n	a2, a10
42004c83:	08da56        	bnez	a10, 42004d14 <esp_mprot_get_pms_area+0x218>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_pms_area(core, &r, &w, &x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
42004c86:	2f0c      	movi.n	a15, 2
42004c88:	1e0c      	movi.n	a14, 1
42004c8a:	d1fa      	add.n	a13, a1, a15
42004c8c:	c1ea      	add.n	a12, a1, a14
42004c8e:	20b110        	or	a11, a1, a1
42004c91:	20a440        	or	a10, a4, a4
42004c94:	ff43a5        	call8	420040d0 <memprot_ll_rtcfast_get_pms_area>
42004c97:	00c625        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004c9a:	0a2d      	mov.n	a2, a10
42004c9c:	aabc      	beqz.n	a10, 42004cda <esp_mprot_get_pms_area+0x1de>
42004c9e:	001c86        	j	42004d14 <esp_mprot_get_pms_area+0x218>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0);
42004ca1:	ee4a81        	l32r	a8, 420005cc <_stext+0x5ac> (600c10e0 <SYSTEM+0x10e0>)
42004ca4:	0020c0        	memw
42004ca7:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004ca9:	049c80        	extui	a9, a8, 12, 1
42004cac:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004caf:	049d80        	extui	a9, a8, 13, 1
42004cb2:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004cb5:	048e80        	extui	a8, a8, 14, 1
42004cb8:	024182        	s8i	a8, a1, 2
}
42004cbb:	0006c6        	j	42004cda <esp_mprot_get_pms_area+0x1de>
42004cbe:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1);
42004cc1:	c0ee43        	lsi	f4, a14, 0x300
42004cc4:	880020        	lsi	f2, a0, 0x220
42004cc7:	8008      	l32i.n	a0, a0, 32
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004cc9:	9f          	.byte	0x9f
42004cca:	419204        	lsi	f0, a2, 0x104
42004ccd:	908000        	addx2	a8, a0, a0
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004cd0:	419205        	call0	420465f4 <_etext+0x3039e>
42004cd3:	818001        	l32r	a0, 41fe52d4 <_coredump_iram_end+0x1c633d4>
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004cd6:	418205        	call0	420464f8 <_etext+0x302a2>
42004cd9:	080c02        	l8ui	a0, a12, 8
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    *flags = 0;
42004cdc:	0389      	s32i.n	a8, a3, 0
    if (r) {
42004cde:	000182        	l8ui	a8, a1, 0
42004ce1:	388c      	beqz.n	a8, 42004ce8 <esp_mprot_get_pms_area+0x1ec>
        *flags |= MEMPROT_OP_READ;
42004ce3:	01a082        	movi	a8, 1
42004ce6:	0389      	s32i.n	a8, a3, 0
    }
    if (w) {
42004ce8:	010182        	l8ui	a8, a1, 1
42004ceb:	988c      	beqz.n	a8, 42004cf8 <esp_mprot_get_pms_area+0x1fc>
        *flags |= MEMPROT_OP_WRITE;
42004ced:	0388      	l32i.n	a8, a3, 0
42004cef:	02a092        	movi	a9, 2
42004cf2:	208890        	or	a8, a8, a9
42004cf5:	006382        	s32i	a8, a3, 0
    }
    if (x) {
42004cf8:	020182        	l8ui	a8, a1, 2
42004cfb:	389c      	beqz.n	a8, 42004d12 <esp_mprot_get_pms_area+0x216>
        *flags |= MEMPROT_OP_EXEC;
42004cfd:	0388      	l32i.n	a8, a3, 0
42004cff:	490c      	movi.n	a9, 4
42004d01:	208890        	or	a8, a8, a9
42004d04:	0389      	s32i.n	a8, a3, 0
    }

    return ESP_OK;
42004d06:	020c      	movi.n	a2, 0
42004d08:	000206        	j	42004d14 <esp_mprot_get_pms_area+0x218>
42004d0b:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004d0e:	004602        	s8i	a0, a6, 0
42004d11:	020c00        	andb	b0, b12, b0
}
42004d14:	f01d      	retw.n
	...

42004d18 <esp_mprot_set_monitor_lock>:

esp_err_t esp_mprot_set_monitor_lock(const esp_mprot_mem_t mem_type, const int core)
{
42004d18:	004136        	entry	a1, 32
42004d1b:	207220        	or	a7, a2, a2
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004d1e:	20a330        	or	a10, a3, a3
42004d21:	ff8be5        	call8	420045e0 <esp_mprot_cpuid_valid>
42004d24:	202aa0        	or	a2, a10, a10
42004d27:	0a1a56        	bnez	a10, 42004dcc <esp_mprot_set_monitor_lock+0xb4>

    switch (mem_type) {
42004d2a:	382726        	beqi	a7, 2, 42004d66 <esp_mprot_set_monitor_lock+0x4e>
42004d2d:	654726        	beqi	a7, 4, 42004d96 <esp_mprot_set_monitor_lock+0x7e>
42004d30:	021726        	beqi	a7, 1, 42004d36 <esp_mprot_set_monitor_lock+0x1e>
42004d33:	002486        	j	42004dc9 <esp_mprot_set_monitor_lock+0xb1>
    switch (core) {
42004d36:	638c      	beqz.n	a3, 42004d40 <esp_mprot_set_monitor_lock+0x28>
42004d38:	111326        	beqi	a3, 1, 42004d4d <esp_mprot_set_monitor_lock+0x35>
42004d3b:	730c      	movi.n	a3, 7
42004d3d:	0006c6        	j	42004d5c <esp_mprot_set_monitor_lock+0x44>
            REG_WRITE(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG, 1);
42004d40:	ee2b81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e4 <SYSTEM+0x10e4>)
42004d43:	190c      	movi.n	a9, 1
42004d45:	0020c0        	memw
42004d48:	0899      	s32i.n	a9, a8, 0
            break;
42004d4a:	000386        	j	42004d5c <esp_mprot_set_monitor_lock+0x44>
            REG_WRITE(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG, 1);
42004d4d:	ee2881        	l32r	a8, 420005f0 <_stext+0x5d0> (600c10f0 <SYSTEM+0x10f0>)
42004d50:	01a092        	movi	a9, 1
42004d53:	0020c0        	memw
42004d56:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004d59:	203aa0        	or	a3, a10, a10
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_lock(core)))
42004d5c:	03ad      	mov.n	a10, a3
42004d5e:	00b9a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004d61:	0a2d      	mov.n	a2, a10
42004d63:	001946        	j	42004dcc <esp_mprot_set_monitor_lock+0xb4>
    switch (core) {
42004d66:	638c      	beqz.n	a3, 42004d70 <esp_mprot_set_monitor_lock+0x58>
42004d68:	111326        	beqi	a3, 1, 42004d7d <esp_mprot_set_monitor_lock+0x65>
42004d6b:	730c      	movi.n	a3, 7
42004d6d:	0006c6        	j	42004d8c <esp_mprot_set_monitor_lock+0x74>
            REG_WRITE(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG, 1);
42004d70:	ee3281        	l32r	a8, 42000638 <_stext+0x618> (600c1104 <SYSTEM+0x1104>)
42004d73:	190c      	movi.n	a9, 1
42004d75:	0020c0        	memw
42004d78:	0899      	s32i.n	a9, a8, 0
            break;
42004d7a:	000386        	j	42004d8c <esp_mprot_set_monitor_lock+0x74>
            REG_WRITE(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG, 1);
42004d7d:	ee2f81        	l32r	a8, 4200063c <_stext+0x61c> (600c1114 <SYSTEM+0x1114>)
42004d80:	01a092        	movi	a9, 1
42004d83:	0020c0        	memw
42004d86:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004d89:	203aa0        	or	a3, a10, a10
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_lock(core)))
42004d8c:	03ad      	mov.n	a10, a3
42004d8e:	00b6a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004d91:	0a2d      	mov.n	a2, a10
42004d93:	000d46        	j	42004dcc <esp_mprot_set_monitor_lock+0xb4>
    switch (core) {
42004d96:	638c      	beqz.n	a3, 42004da0 <esp_mprot_set_monitor_lock+0x88>
42004d98:	111326        	beqi	a3, 1, 42004dad <esp_mprot_set_monitor_lock+0x95>
42004d9b:	730c      	movi.n	a3, 7
42004d9d:	0006c6        	j	42004dbc <esp_mprot_set_monitor_lock+0xa4>
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG, 1);
42004da0:	ee1f81        	l32r	a8, 4200061c <_stext+0x5fc> (600c119c <SYSTEM+0x119c>)
42004da3:	190c      	movi.n	a9, 1
42004da5:	0020c0        	memw
42004da8:	0899      	s32i.n	a9, a8, 0
            break;
42004daa:	000386        	j	42004dbc <esp_mprot_set_monitor_lock+0xa4>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG, 1);
42004dad:	ee1c81        	l32r	a8, 42000620 <_stext+0x600> (600c1248 <SYSTEM+0x1248>)
42004db0:	01a092        	movi	a9, 1
42004db3:	0020c0        	memw
42004db6:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004db9:	203aa0        	or	a3, a10, a10
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_lock(core)))
42004dbc:	03ad      	mov.n	a10, a3
42004dbe:	00b3a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004dc1:	0a2d      	mov.n	a2, a10
42004dc3:	000146        	j	42004dcc <esp_mprot_set_monitor_lock+0xb4>
42004dc6:	000000        	ill
    switch (mem_type) {
42004dc9:	ee2321        	l32r	a2, 42000658 <_stext+0x638> (d001 <UserFrameTotalSize+0xcf01>)
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004dcc:	f01d      	retw.n
	...

42004dd0 <esp_mprot_get_monitor_lock>:

esp_err_t esp_mprot_get_monitor_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core)
{
42004dd0:	004136        	entry	a1, 32
42004dd3:	207220        	or	a7, a2, a2
    if (locked == NULL) {
42004dd6:	04a316        	beqz	a3, 42004e24 <esp_mprot_get_monitor_lock+0x54>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004dd9:	20a440        	or	a10, a4, a4
42004ddc:	ff8025        	call8	420045e0 <esp_mprot_cpuid_valid>
42004ddf:	0a2d      	mov.n	a2, a10
42004de1:	04ba56        	bnez	a10, 42004e30 <esp_mprot_get_monitor_lock+0x60>

    switch (mem_type) {
42004de4:	162726        	beqi	a7, 2, 42004dfe <esp_mprot_get_monitor_lock+0x2e>
42004de7:	274726        	beqi	a7, 4, 42004e12 <esp_mprot_get_monitor_lock+0x42>
42004dea:	3f1766        	bnei	a7, 1, 42004e2d <esp_mprot_get_monitor_lock+0x5d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_monitor_lock(core, locked)))
42004ded:	03bd      	mov.n	a11, a3
42004def:	04ad      	mov.n	a10, a4
42004df1:	feffe5        	call8	42003df0 <memprot_ll_iram0_get_monitor_lock>
42004df4:	00b025        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004df7:	0a2d      	mov.n	a2, a10
42004df9:	000cc6        	j	42004e30 <esp_mprot_get_monitor_lock+0x60>
42004dfc:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_monitor_lock(core, locked)))
42004dff:	4020b3        	lsi	f11, a0, 0x100
42004e02:	a520a4        	lsi	f10, a0, 0x294
42004e05:	ff68      	l32i.n	a6, a15, 60
42004e07:	00af25        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004e0a:	0a2d      	mov.n	a2, a10
42004e0c:	000806        	j	42004e30 <esp_mprot_get_monitor_lock+0x60>
42004e0f:	000000        	ill
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_lock(core, locked)))
42004e12:	20b330        	or	a11, a3, a3
42004e15:	20a440        	or	a10, a4, a4
42004e18:	ff37a5        	call8	42004194 <memprot_ll_rtcfast_get_monitor_lock>
42004e1b:	00ade5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004e1e:	0a2d      	mov.n	a2, a10
42004e20:	000306        	j	42004e30 <esp_mprot_get_monitor_lock+0x60>
42004e23:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004e26:	014602        	s8i	a0, a6, 1
42004e29:	000000        	ill
42004e2c:	0a2100        	add.s	f2, f1, f0
    switch (mem_type) {
42004e2f:	ee          	.byte	0xee
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004e30:	f01d      	retw.n
	...

42004e34 <esp_mprot_set_monitor_en>:

esp_err_t esp_mprot_set_monitor_en(const esp_mprot_mem_t mem_type, const bool enable, const int core)
{
42004e34:	004136        	entry	a1, 32
42004e37:	207220        	or	a7, a2, a2
42004e3a:	743030        	extui	a3, a3, 0, 8
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004e3d:	20a440        	or	a10, a4, a4
42004e40:	ff79e5        	call8	420045e0 <esp_mprot_cpuid_valid>
42004e43:	0a2d      	mov.n	a2, a10
42004e45:	03fa56        	bnez	a10, 42004e88 <esp_mprot_set_monitor_en+0x54>

    switch (mem_type) {
42004e48:	162726        	beqi	a7, 2, 42004e62 <esp_mprot_set_monitor_en+0x2e>
42004e4b:	244726        	beqi	a7, 4, 42004e73 <esp_mprot_set_monitor_en+0x3f>
42004e4e:	331766        	bnei	a7, 1, 42004e85 <esp_mprot_set_monitor_en+0x51>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_en(core, enable)))
42004e51:	03bd      	mov.n	a11, a3
42004e53:	04ad      	mov.n	a10, a4
42004e55:	fefd65        	call8	42003e2c <memprot_ll_iram0_set_monitor_en>
42004e58:	00a9e5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004e5b:	0a2d      	mov.n	a2, a10
42004e5d:	0009c6        	j	42004e88 <esp_mprot_set_monitor_en+0x54>
42004e60:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_en(core, enable)))
42004e63:	4020b3        	lsi	f11, a0, 0x100
42004e66:	2520a4        	lsi	f10, a0, 148
42004e69:	e5ff66        	bnei	a15, 0x100, 42004e52 <esp_mprot_set_monitor_en+0x1e>
42004e6c:	00a8      	l32i.n	a10, a0, 0
42004e6e:	0a2d      	mov.n	a2, a10
42004e70:	000506        	j	42004e88 <esp_mprot_set_monitor_en+0x54>
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_en(core, enable)))
42004e73:	20b330        	or	a11, a3, a3
42004e76:	20a440        	or	a10, a4, a4
42004e79:	ff3565        	call8	420041d0 <memprot_ll_rtcfast_set_monitor_en>
42004e7c:	00a7a5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004e7f:	0a2d      	mov.n	a2, a10
42004e81:	0000c6        	j	42004e88 <esp_mprot_set_monitor_en+0x54>
42004e84:	f42100        	extui	a2, a0, 1, 16
    switch (mem_type) {
42004e87:	1ded      	lsi	f14, a13, 52
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004e89:	0000f0        	callx12	a0

42004e8c <esp_mprot_get_monitor_en>:

esp_err_t esp_mprot_get_monitor_en(esp_mprot_mem_t mem_type, bool *enabled, const int core)
{
42004e8c:	004136        	entry	a1, 32
42004e8f:	207220        	or	a7, a2, a2
    if (enabled == NULL) {
42004e92:	04a316        	beqz	a3, 42004ee0 <esp_mprot_get_monitor_en+0x54>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004e95:	20a440        	or	a10, a4, a4
42004e98:	ff7465        	call8	420045e0 <esp_mprot_cpuid_valid>
42004e9b:	0a2d      	mov.n	a2, a10
42004e9d:	04ba56        	bnez	a10, 42004eec <esp_mprot_get_monitor_en+0x60>

    switch (mem_type) {
42004ea0:	162726        	beqi	a7, 2, 42004eba <esp_mprot_get_monitor_en+0x2e>
42004ea3:	274726        	beqi	a7, 4, 42004ece <esp_mprot_get_monitor_en+0x42>
42004ea6:	3f1766        	bnei	a7, 1, 42004ee9 <esp_mprot_get_monitor_en+0x5d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_monitor_en(core, enabled)))
42004ea9:	03bd      	mov.n	a11, a3
42004eab:	04ad      	mov.n	a10, a4
42004ead:	fefe65        	call8	42003e94 <memprot_ll_iram0_get_monitor_en>
42004eb0:	00a465        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004eb3:	0a2d      	mov.n	a2, a10
42004eb5:	000cc6        	j	42004eec <esp_mprot_get_monitor_en+0x60>
42004eb8:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_monitor_en(core, enabled)))
42004ebb:	4020b3        	lsi	f11, a0, 0x100
42004ebe:	2520a4        	lsi	f10, a0, 148
42004ec1:	65ff67        	bbsi	a15, 22, 42004f2a <esp_mprot_monitor_clear_intr+0x3a>
42004ec4:	2d00a3        	lsi	f10, a0, 180
42004ec7:	060a      	add.n	a0, a6, a0
42004ec9:	0008      	l32i.n	a0, a0, 0
42004ecb:	000000        	ill
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_en(core, enabled)))
42004ece:	20b330        	or	a11, a3, a3
42004ed1:	20a440        	or	a10, a4, a4
42004ed4:	ff3665        	call8	4200423c <memprot_ll_rtcfast_get_monitor_en>
42004ed7:	00a225        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004eda:	0a2d      	mov.n	a2, a10
42004edc:	000306        	j	42004eec <esp_mprot_get_monitor_en+0x60>
42004edf:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004ee2:	014602        	s8i	a0, a6, 1
42004ee5:	000000        	ill
42004ee8:	db2100        	movt.s	f2, f1, b0
    switch (mem_type) {
42004eeb:	1ded      	lsi	f14, a13, 52
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004eed:	0000f0        	callx12	a0

42004ef0 <esp_mprot_monitor_clear_intr>:

    return ESP_OK;
}

esp_err_t esp_mprot_monitor_clear_intr(esp_mprot_mem_t mem_type, const int core)
{
42004ef0:	004136        	entry	a1, 32
42004ef3:	027d      	mov.n	a7, a2
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004ef5:	03ad      	mov.n	a10, a3
42004ef7:	ff6ea5        	call8	420045e0 <esp_mprot_cpuid_valid>
42004efa:	0a2d      	mov.n	a2, a10
42004efc:	060a56        	bnez	a10, 42004f60 <esp_mprot_monitor_clear_intr+0x70>

    switch (mem_type) {
42004eff:	212726        	beqi	a7, 2, 42004f24 <esp_mprot_monitor_clear_intr+0x34>
42004f02:	3a4726        	beqi	a7, 4, 42004f40 <esp_mprot_monitor_clear_intr+0x50>
42004f05:	541766        	bnei	a7, 1, 42004f5d <esp_mprot_monitor_clear_intr+0x6d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_intrclr(core)))
42004f08:	20a330        	or	a10, a3, a3
42004f0b:	fefbe5        	call8	42003ec8 <memprot_ll_iram0_set_monitor_intrclr>
42004f0e:	009ea5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004f11:	0a2d      	mov.n	a2, a10
42004f13:	049a56        	bnez	a10, 42004f60 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_reset_monitor_intrclr(core)))
42004f16:	03ad      	mov.n	a10, a3
42004f18:	fefea5        	call8	42003f04 <memprot_ll_iram0_reset_monitor_intrclr>
42004f1b:	009de5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004f1e:	0a2d      	mov.n	a2, a10
42004f20:	000f06        	j	42004f60 <esp_mprot_monitor_clear_intr+0x70>
42004f23:	03ad00        	lsi	f0, a13, 12
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_intrclr(core)))
42004f26:	ff6425        	call8	42004568 <memprot_ll_dram0_set_monitor_intrclr>
42004f29:	009ce5        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004f2c:	202aa0        	or	a2, a10, a10
42004f2f:	daec      	bnez.n	a10, 42004f60 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_reset_monitor_intrclr(core)))
42004f31:	20a330        	or	a10, a3, a3
42004f34:	ff66e5        	call8	420045a4 <memprot_ll_dram0_reset_monitor_intrclr>
42004f37:	009c25        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004f3a:	0a2d      	mov.n	a2, a10
42004f3c:	000806        	j	42004f60 <esp_mprot_monitor_clear_intr+0x70>
42004f3f:	03ad00        	lsi	f0, a13, 12
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_intrclr(core)))
42004f42:	ff32e5        	call8	42004270 <memprot_ll_rtcfast_set_monitor_intrclr>
42004f45:	009b25        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004f48:	0a2d      	mov.n	a2, a10
42004f4a:	012a56        	bnez	a10, 42004f60 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_reset_monitor_intrclr(core)))
42004f4d:	20a330        	or	a10, a3, a3
42004f50:	ff35a5        	call8	420042ac <memprot_ll_rtcfast_reset_monitor_intrclr>
42004f53:	009a65        	call8	420058f8 <esp_mprot_ll_err_to_esp_err>
42004f56:	0a2d      	mov.n	a2, a10
42004f58:	000106        	j	42004f60 <esp_mprot_monitor_clear_intr+0x70>
42004f5b:	210000        	srai	a0, a0, 0
    switch (mem_type) {
42004f5e:	be          	.byte	0xbe
42004f5f:	1ded      	lsi	f14, a13, 52
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42004f61:	0000f0        	callx12	a0

42004f64 <esp_mprot_is_conf_locked_any>:

esp_err_t esp_mprot_is_conf_locked_any(bool *locked)
{
42004f64:	006136        	entry	a1, 48
42004f67:	027d      	mov.n	a7, a2
    if (locked == NULL) {
42004f69:	173216        	beqz	a2, 420050e0 <esp_mprot_is_conf_locked_any+0x17c>
        return ESP_ERR_INVALID_ARG;
    }

    bool lock_on = false;
42004f6c:	080c      	movi.n	a8, 0
42004f6e:	004182        	s8i	a8, a1, 0
    esp_err_t err;

    //IRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM) {
42004f71:	edb681        	l32r	a8, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
42004f74:	2888      	l32i.n	a8, a8, 8
42004f76:	6f6807        	bbci	a8, 0, 42004fe9 <esp_mprot_is_conf_locked_any+0x85>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
42004f79:	fc7c      	movi.n	a12, -1
42004f7b:	01bd      	mov.n	a11, a1
42004f7d:	1a0c      	movi.n	a10, 1
42004f7f:	ff8da5        	call8	42004858 <esp_mprot_get_split_addr_lock>
42004f82:	0a2d      	mov.n	a2, a10
42004f84:	160a56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42004f87:	000782        	l8ui	a8, a7, 0
42004f8a:	000192        	l8ui	a9, a1, 0
42004f8d:	208890        	or	a8, a8, a9
42004f90:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
42004f93:	fc7c      	movi.n	a12, -1
42004f95:	01bd      	mov.n	a11, a1
42004f97:	1a0c      	movi.n	a10, 1
42004f99:	ff98a5        	call8	42004924 <esp_mprot_get_pms_lock>
42004f9c:	0a2d      	mov.n	a2, a10
42004f9e:	146a56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42004fa1:	000782        	l8ui	a8, a7, 0
42004fa4:	000192        	l8ui	a9, a1, 0
42004fa7:	208890        	or	a8, a8, a9
42004faa:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, PRO_CPU_NUM))
42004fad:	0c0c      	movi.n	a12, 0
42004faf:	01bd      	mov.n	a11, a1
42004fb1:	1a0c      	movi.n	a10, 1
42004fb3:	ffe1e5        	call8	42004dd0 <esp_mprot_get_monitor_lock>
42004fb6:	0a2d      	mov.n	a2, a10
42004fb8:	12ca56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42004fbb:	000782        	l8ui	a8, a7, 0
42004fbe:	000192        	l8ui	a9, a1, 0
42004fc1:	208890        	or	a8, a8, a9
42004fc4:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
42004fc7:	eda181        	l32r	a8, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
42004fca:	3888      	l32i.n	a8, a8, 12
42004fcc:	1928b6        	bltui	a8, 2, 42004fe9 <esp_mprot_is_conf_locked_any+0x85>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, APP_CPU_NUM))
42004fcf:	1c0c      	movi.n	a12, 1
42004fd1:	01bd      	mov.n	a11, a1
42004fd3:	0cad      	mov.n	a10, a12
42004fd5:	ffdfa5        	call8	42004dd0 <esp_mprot_get_monitor_lock>
42004fd8:	0a2d      	mov.n	a2, a10
42004fda:	10aa56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
42004fdd:	000782        	l8ui	a8, a7, 0
42004fe0:	000192        	l8ui	a9, a1, 0
42004fe3:	208890        	or	a8, a8, a9
42004fe6:	004782        	s8i	a8, a7, 0
        }
    }

    //DRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM) {
42004fe9:	ed9881        	l32r	a8, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
42004fec:	2888      	l32i.n	a8, a8, 8
42004fee:	706817        	bbci	a8, 1, 42005062 <esp_mprot_is_conf_locked_any+0xfe>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
42004ff1:	fc7c      	movi.n	a12, -1
42004ff3:	01bd      	mov.n	a11, a1
42004ff5:	2a0c      	movi.n	a10, 2
42004ff7:	ff8625        	call8	42004858 <esp_mprot_get_split_addr_lock>
42004ffa:	0a2d      	mov.n	a2, a10
42004ffc:	0e8a56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42004fff:	000782        	l8ui	a8, a7, 0
42005002:	000192        	l8ui	a9, a1, 0
42005005:	208890        	or	a8, a8, a9
42005008:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
4200500b:	fc7c      	movi.n	a12, -1
4200500d:	01bd      	mov.n	a11, a1
4200500f:	2a0c      	movi.n	a10, 2
42005011:	ff9125        	call8	42004924 <esp_mprot_get_pms_lock>
42005014:	0a2d      	mov.n	a2, a10
42005016:	0cea56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005019:	000782        	l8ui	a8, a7, 0
4200501c:	000192        	l8ui	a9, a1, 0
4200501f:	208890        	or	a8, a8, a9
42005022:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, PRO_CPU_NUM));
42005025:	0c0c      	movi.n	a12, 0
42005027:	01bd      	mov.n	a11, a1
42005029:	2a0c      	movi.n	a10, 2
4200502b:	ffda65        	call8	42004dd0 <esp_mprot_get_monitor_lock>
4200502e:	0a2d      	mov.n	a2, a10
42005030:	0b4a56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005033:	000782        	l8ui	a8, a7, 0
42005036:	000192        	l8ui	a9, a1, 0
42005039:	208890        	or	a8, a8, a9
4200503c:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
4200503f:	ed8381        	l32r	a8, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
42005042:	3888      	l32i.n	a8, a8, 12
42005044:	1a28b6        	bltui	a8, 2, 42005062 <esp_mprot_is_conf_locked_any+0xfe>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, APP_CPU_NUM));
42005047:	1c0c      	movi.n	a12, 1
42005049:	20b110        	or	a11, a1, a1
4200504c:	2a0c      	movi.n	a10, 2
4200504e:	ffd825        	call8	42004dd0 <esp_mprot_get_monitor_lock>
42005051:	0a2d      	mov.n	a2, a10
42005053:	091a56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
42005056:	000782        	l8ui	a8, a7, 0
42005059:	000192        	l8ui	a9, a1, 0
4200505c:	208890        	or	a8, a8, a9
4200505f:	004782        	s8i	a8, a7, 0
        }
    }

    //RTCFAST
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST) {
42005062:	ed7a81        	l32r	a8, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
42005065:	2888      	l32i.n	a8, a8, 8
42005067:	02e827        	bbsi	a8, 2, 4200506d <esp_mprot_is_conf_locked_any+0x109>
4200506a:	001e06        	j	420050e6 <esp_mprot_is_conf_locked_any+0x182>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM))
4200506d:	0c0c      	movi.n	a12, 0
4200506f:	01bd      	mov.n	a11, a1
42005071:	4a0c      	movi.n	a10, 4
42005073:	ff8b25        	call8	42004924 <esp_mprot_get_pms_lock>
42005076:	0a2d      	mov.n	a2, a10
42005078:	06ca56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
4200507b:	000782        	l8ui	a8, a7, 0
4200507e:	000192        	l8ui	a9, a1, 0
42005081:	208890        	or	a8, a8, a9
42005084:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM));
42005087:	0c0c      	movi.n	a12, 0
42005089:	01bd      	mov.n	a11, a1
4200508b:	4a0c      	movi.n	a10, 4
4200508d:	ffd425        	call8	42004dd0 <esp_mprot_get_monitor_lock>
42005090:	0a2d      	mov.n	a2, a10
42005092:	052a56        	bnez	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005095:	000782        	l8ui	a8, a7, 0
42005098:	000192        	l8ui	a9, a1, 0
4200509b:	208890        	or	a8, a8, a9
4200509e:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
420050a1:	ed6a81        	l32r	a8, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
420050a4:	3888      	l32i.n	a8, a8, 12
420050a6:	3e28b6        	bltui	a8, 2, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM))
420050a9:	1c0c      	movi.n	a12, 1
420050ab:	01bd      	mov.n	a11, a1
420050ad:	04a0a2        	movi	a10, 4
420050b0:	ff8725        	call8	42004924 <esp_mprot_get_pms_lock>
420050b3:	0a2d      	mov.n	a2, a10
420050b5:	faec      	bnez.n	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
420050b7:	000782        	l8ui	a8, a7, 0
420050ba:	000192        	l8ui	a9, a1, 0
420050bd:	208890        	or	a8, a8, a9
420050c0:	004782        	s8i	a8, a7, 0

            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM));
420050c3:	1c0c      	movi.n	a12, 1
420050c5:	01bd      	mov.n	a11, a1
420050c7:	4a0c      	movi.n	a10, 4
420050c9:	ffd065        	call8	42004dd0 <esp_mprot_get_monitor_lock>
420050cc:	0a2d      	mov.n	a2, a10
420050ce:	6adc      	bnez.n	a10, 420050e8 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
420050d0:	000782        	l8ui	a8, a7, 0
420050d3:	000192        	l8ui	a9, a1, 0
420050d6:	208890        	or	a8, a8, a9
420050d9:	004782        	s8i	a8, a7, 0
420050dc:	000206        	j	420050e8 <esp_mprot_is_conf_locked_any+0x184>
420050df:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
420050e2:	004602        	s8i	a0, a6, 0
420050e5:	020c00        	andb	b0, b12, b0
        }
    }

    return ESP_OK;
}
420050e8:	f01d      	retw.n
	...

420050ec <esp_mprot_set_prot>:
}

//////////////////////////////////////////////////////////////////////////////
// convenient "public" APIs
esp_err_t esp_mprot_set_prot(const esp_memp_config_t *memp_config)
{
420050ec:	008136        	entry	a1, 64
420050ef:	027d      	mov.n	a7, a2
    RER(reg, dcr);
420050f1:	ec6381        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
420050f4:	406880        	rer	a8, a8
    return (bool)(dcr & 0x1);
420050f7:	044080        	extui	a4, a8, 0, 1
    //debugger connected:
    // 1.check the signal repeatedly to avoid possible glitching attempt
    // 2.leave the Memprot unset to allow debug operations

    if (esp_cpu_dbgr_is_attached()) {
420050fa:	5b6807        	bbci	a8, 0, 42005159 <esp_mprot_set_prot+0x6d>
    RER(reg, dcr);
420050fd:	ec6081        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
42005100:	406880        	rer	a8, a8
        ESP_FAULT_ASSERT(esp_cpu_dbgr_is_attached());
42005103:	13e807        	bbsi	a8, 0, 4200511a <esp_mprot_set_prot+0x2e>
42005106:	ed7381        	l32r	a8, 420006d4 <_stext+0x6b4> (400006d8 <esp_rom_software_reset_system>)
42005109:	0008e0        	callx8	a8
4200510c:	f06d      	ill.n
4200510e:	f06d      	ill.n
42005110:	f06d      	ill.n
42005112:	f06d      	ill.n
42005114:	f06d      	ill.n
42005116:	f06d      	ill.n
42005118:	f06d      	ill.n
4200511a:	ec5981        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
4200511d:	406880        	rer	a8, a8
42005120:	13e807        	bbsi	a8, 0, 42005137 <esp_mprot_set_prot+0x4b>
42005123:	ed6c81        	l32r	a8, 420006d4 <_stext+0x6b4> (400006d8 <esp_rom_software_reset_system>)
42005126:	0008e0        	callx8	a8
42005129:	f06d      	ill.n
4200512b:	f06d      	ill.n
4200512d:	f06d      	ill.n
4200512f:	f06d      	ill.n
42005131:	f06d      	ill.n
42005133:	f06d      	ill.n
42005135:	f06d      	ill.n
42005137:	ec5281        	l32r	a8, 42000280 <_stext+0x260> (10200c <UserFrameTotalSize+0x101f0c>)
4200513a:	406880        	rer	a8, a8
4200513d:	13e807        	bbsi	a8, 0, 42005154 <esp_mprot_set_prot+0x68>
42005140:	ed6581        	l32r	a8, 420006d4 <_stext+0x6b4> (400006d8 <esp_rom_software_reset_system>)
42005143:	0008e0        	callx8	a8
42005146:	f06d      	ill.n
42005148:	f06d      	ill.n
4200514a:	f06d      	ill.n
4200514c:	f06d      	ill.n
4200514e:	f06d      	ill.n
42005150:	f06d      	ill.n
42005152:	f06d      	ill.n
        return ESP_OK;
42005154:	020c      	movi.n	a2, 0
42005156:	01e686        	j	420058f4 <esp_mprot_set_prot+0x808>
    }

    //sanity checks
    if (memp_config == NULL) {
42005159:	12cc      	bnez.n	a2, 4200515e <esp_mprot_set_prot+0x72>
4200515b:	01e046        	j	420058e0 <esp_mprot_set_prot+0x7f4>
        return ESP_ERR_INVALID_ARG;
    }
    if (memp_config->mem_type_mask == MEMPROT_TYPE_NONE) {
4200515e:	2258      	l32i.n	a5, a2, 8
42005160:	15cc      	bnez.n	a5, 42005165 <esp_mprot_set_prot+0x79>
42005162:	01e086        	j	420058e8 <esp_mprot_set_prot+0x7fc>
        return ESP_ERR_NO_MEM;
    }
    if (memp_config->target_cpu_count < 1 || memp_config->target_cpu_count > CONFIG_FREERTOS_NUMBER_OF_CORES) {
42005165:	3268      	l32i.n	a6, a2, 12
42005167:	860b      	addi.n	a8, a6, -1
42005169:	0228b6        	bltui	a8, 2, 4200516f <esp_mprot_set_prot+0x83>
4200516c:	01e046        	j	420058f1 <esp_mprot_set_prot+0x805>
        return ESP_ERR_MEMPROT_CPUID_INVALID;
    }

    esp_err_t ret = ESP_OK;
    size_t core_count = memp_config->target_cpu_count;
    for (size_t x = 0; x < core_count; x++) {
4200516f:	043d      	mov.n	a3, a4
    esp_err_t ret = ESP_OK;
42005171:	020c      	movi.n	a2, 0
42005173:	000486        	j	42005189 <esp_mprot_set_prot+0x9d>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_cpuid_valid(memp_config->target_cpu[x]))
42005176:	834b      	addi.n	a8, a3, 4
42005178:	a08870        	addx4	a8, a8, a7
4200517b:	08a8      	l32i.n	a10, a8, 0
4200517d:	ff4625        	call8	420045e0 <esp_mprot_cpuid_valid>
42005180:	0a2d      	mov.n	a2, a10
42005182:	1a8c      	beqz.n	a10, 42005187 <esp_mprot_set_prot+0x9b>
42005184:	01db06        	j	420058f4 <esp_mprot_set_prot+0x808>
    for (size_t x = 0; x < core_count; x++) {
42005187:	331b      	addi.n	a3, a3, 1
42005189:	e93367        	bltu	a3, a6, 42005176 <esp_mprot_set_prot+0x8a>
    }

    bool use_iram0 = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM;
4200518c:	048050        	extui	a8, a5, 0, 1
4200518f:	5189      	s32i.n	a8, a1, 20
    bool use_dram0 = memp_config->mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM;
42005191:	230c      	movi.n	a3, 2
42005193:	103530        	and	a3, a5, a3
42005196:	180c      	movi.n	a8, 1
42005198:	838330        	moveqz	a8, a3, a3
4200519b:	6189      	s32i.n	a8, a1, 24
    bool use_rtcfast = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST;
4200519d:	480c      	movi.n	a8, 4
4200519f:	108580        	and	a8, a5, a8
420051a2:	4189      	s32i.n	a8, a1, 16

    //disable protection (must be unlocked)
    if (use_iram0) {
420051a4:	1ae507        	bbsi	a5, 0, 420051c2 <esp_mprot_set_prot+0xd6>
420051a7:	000706        	j	420051c7 <esp_mprot_set_prot+0xdb>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, false, memp_config->target_cpu[x]))
420051aa:	854b      	addi.n	a8, a5, 4
420051ac:	a08870        	addx4	a8, a8, a7
420051af:	08c8      	l32i.n	a12, a8, 0
420051b1:	0b0c      	movi.n	a11, 0
420051b3:	1a0c      	movi.n	a10, 1
420051b5:	ffc7e5        	call8	42004e34 <esp_mprot_set_monitor_en>
420051b8:	0a2d      	mov.n	a2, a10
420051ba:	736a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420051bd:	551b      	addi.n	a5, a5, 1
420051bf:	000046        	j	420051c4 <esp_mprot_set_prot+0xd8>
420051c2:	045d      	mov.n	a5, a4
420051c4:	e23567        	bltu	a5, a6, 420051aa <esp_mprot_set_prot+0xbe>
        }
    }
    if (use_dram0) {
420051c7:	d3dc      	bnez.n	a3, 420051e8 <esp_mprot_set_prot+0xfc>
420051c9:	000806        	j	420051ed <esp_mprot_set_prot+0x101>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, false, memp_config->target_cpu[x]))
420051cc:	04c582        	addi	a8, a5, 4
420051cf:	a08870        	addx4	a8, a8, a7
420051d2:	0028c2        	l32i	a12, a8, 0
420051d5:	00a0b2        	movi	a11, 0
420051d8:	2a0c      	movi.n	a10, 2
420051da:	ffc5a5        	call8	42004e34 <esp_mprot_set_monitor_en>
420051dd:	0a2d      	mov.n	a2, a10
420051df:	711a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420051e2:	551b      	addi.n	a5, a5, 1
420051e4:	000086        	j	420051ea <esp_mprot_set_prot+0xfe>
420051e7:	045d00        	extui	a5, a0, 13, 1
420051ea:	de3567        	bltu	a5, a6, 420051cc <esp_mprot_set_prot+0xe0>
        }
    }
    if (use_rtcfast) {
420051ed:	4188      	l32i.n	a8, a1, 16
420051ef:	d8dc      	bnez.n	a8, 42005210 <esp_mprot_set_prot+0x124>
420051f1:	000806        	j	42005215 <esp_mprot_set_prot+0x129>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, false, memp_config->target_cpu[x]))
420051f4:	04c582        	addi	a8, a5, 4
420051f7:	a08870        	addx4	a8, a8, a7
420051fa:	0028c2        	l32i	a12, a8, 0
420051fd:	00a0b2        	movi	a11, 0
42005200:	4a0c      	movi.n	a10, 4
42005202:	ffc325        	call8	42004e34 <esp_mprot_set_monitor_en>
42005205:	0a2d      	mov.n	a2, a10
42005207:	6e9a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200520a:	551b      	addi.n	a5, a5, 1
4200520c:	000086        	j	42005212 <esp_mprot_set_prot+0x126>
4200520f:	045d00        	extui	a5, a0, 13, 1
42005212:	de3567        	bltu	a5, a6, 420051f4 <esp_mprot_set_prot+0x108>
        }
    }

    //panic handling
    if (memp_config->invoke_panic_handler) {
42005215:	000782        	l8ui	a8, a7, 0
42005218:	06f816        	beqz	a8, 4200528b <esp_mprot_set_prot+0x19f>
        if (use_iram0) {
4200521b:	5188      	l32i.n	a8, a1, 20
4200521d:	b8dc      	bnez.n	a8, 4200523c <esp_mprot_set_prot+0x150>
4200521f:	000786        	j	42005241 <esp_mprot_set_prot+0x155>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
42005222:	04c582        	addi	a8, a5, 4
42005225:	a08870        	addx4	a8, a8, a7
42005228:	0028b2        	l32i	a11, a8, 0
4200522b:	01a0a2        	movi	a10, 1
4200522e:	ff3fe5        	call8	4200462c <esp_mprot_set_intr_matrix>
42005231:	0a2d      	mov.n	a2, a10
42005233:	6bda56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005236:	551b      	addi.n	a5, a5, 1
42005238:	000086        	j	4200523e <esp_mprot_set_prot+0x152>
4200523b:	045d00        	extui	a5, a0, 13, 1
4200523e:	e03567        	bltu	a5, a6, 42005222 <esp_mprot_set_prot+0x136>
            }
        }
        if (use_dram0) {
42005241:	b3dc      	bnez.n	a3, 42005260 <esp_mprot_set_prot+0x174>
42005243:	000786        	j	42005265 <esp_mprot_set_prot+0x179>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42005246:	04c582        	addi	a8, a5, 4
42005249:	a08870        	addx4	a8, a8, a7
4200524c:	0028b2        	l32i	a11, a8, 0
4200524f:	02a0a2        	movi	a10, 2
42005252:	ff3da5        	call8	4200462c <esp_mprot_set_intr_matrix>
42005255:	0a2d      	mov.n	a2, a10
42005257:	699a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
4200525a:	551b      	addi.n	a5, a5, 1
4200525c:	000086        	j	42005262 <esp_mprot_set_prot+0x176>
4200525f:	045d00        	extui	a5, a0, 13, 1
42005262:	e03567        	bltu	a5, a6, 42005246 <esp_mprot_set_prot+0x15a>
            }
        }
        if (use_rtcfast) {
42005265:	4188      	l32i.n	a8, a1, 16
42005267:	b8dc      	bnez.n	a8, 42005286 <esp_mprot_set_prot+0x19a>
42005269:	000786        	j	4200528b <esp_mprot_set_prot+0x19f>
4200526c:	c58200        	extui	a8, a0, 18, 13
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
4200526f:	887004        	lsi	f0, a0, 0x220
42005272:	28b2a0        	lsi	f10, a2, 160
42005275:	a0a200        	addx4	a10, a2, a0
42005278:	3b2504        	lsi	f0, a5, 236
4200527b:	ff          	.byte	0xff
4200527c:	0a2d      	mov.n	a2, a10
4200527e:	672a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005281:	551b      	addi.n	a5, a5, 1
42005283:	000046        	j	42005288 <esp_mprot_set_prot+0x19c>
42005286:	045d      	mov.n	a5, a4
42005288:	e13567        	bltu	a5, a6, 4200526d <esp_mprot_set_prot+0x181>
            }
        }
    }

    //set split lines (must-have for all mem_types). This version sets only the main I/D which is then shared for all PMS regions
    void *line_addr __attribute__((unused)) = NULL;
4200528b:	080c      	movi.n	a8, 0
4200528d:	0189      	s32i.n	a8, a1, 0
    if (use_iram0 || use_dram0) {
4200528f:	5188      	l32i.n	a8, a1, 20
42005291:	6198      	l32i.n	a9, a1, 24
42005293:	208890        	or	a8, a8, a9
42005296:	6189      	s32i.n	a8, a1, 24
42005298:	0c7816        	beqz	a8, 42005363 <esp_mprot_set_prot+0x277>
        line_addr = memp_config->split_addr;
4200529b:	1788      	l32i.n	a8, a7, 4
4200529d:	0189      	s32i.n	a8, a1, 0
        if (line_addr == NULL) {
4200529f:	b8cc      	bnez.n	a8, 420052ae <esp_mprot_set_prot+0x1c2>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_default_main_split_addr(MEMPROT_TYPE_IRAM0_SRAM, &line_addr))
420052a1:	01bd      	mov.n	a11, a1
420052a3:	1a0c      	movi.n	a10, 1
420052a5:	ff50a5        	call8	420047b0 <esp_mprot_get_default_main_split_addr>
420052a8:	202aa0        	or	a2, a10, a10
420052ab:	645a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_1, line_addr, DEFAULT_CPU_NUM))
420052ae:	fd7c      	movi.n	a13, -1
420052b0:	01c8      	l32i.n	a12, a1, 0
420052b2:	4b0c      	movi.n	a11, 4
420052b4:	1a0c      	movi.n	a10, 1
420052b6:	ff43a5        	call8	420046f0 <esp_mprot_set_split_addr>
420052b9:	0a2d      	mov.n	a2, a10
420052bb:	635a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_0, line_addr, DEFAULT_CPU_NUM))
420052be:	fd7c      	movi.n	a13, -1
420052c0:	01c8      	l32i.n	a12, a1, 0
420052c2:	2b0c      	movi.n	a11, 2
420052c4:	1a0c      	movi.n	a10, 1
420052c6:	ff42a5        	call8	420046f0 <esp_mprot_set_split_addr>
420052c9:	0a2d      	mov.n	a2, a10
420052cb:	625a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_DRAM0, line_addr, DEFAULT_CPU_NUM))
420052ce:	fd7c      	movi.n	a13, -1
420052d0:	01c8      	l32i.n	a12, a1, 0
420052d2:	1b0c      	movi.n	a11, 1
420052d4:	0bad      	mov.n	a10, a11
420052d6:	ff41a5        	call8	420046f0 <esp_mprot_set_split_addr>
420052d9:	0a2d      	mov.n	a2, a10
420052db:	615a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
420052de:	fd7c      	movi.n	a13, -1
420052e0:	01c8      	l32i.n	a12, a1, 0
420052e2:	ecd281        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
420052e5:	cc8a      	add.n	a12, a12, a8
420052e7:	8b0c      	movi.n	a11, 8
420052e9:	2a0c      	movi.n	a10, 2
420052eb:	ff4065        	call8	420046f0 <esp_mprot_set_split_addr>
420052ee:	0a2d      	mov.n	a2, a10
420052f0:	600a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_1, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
420052f3:	fd7c      	movi.n	a13, -1
420052f5:	01c8      	l32i.n	a12, a1, 0
420052f7:	eccd81        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
420052fa:	cc8a      	add.n	a12, a12, a8
420052fc:	0b1c      	movi.n	a11, 16
420052fe:	2a0c      	movi.n	a10, 2
42005300:	ff3ee5        	call8	420046f0 <esp_mprot_set_split_addr>
42005303:	0a2d      	mov.n	a2, a10
42005305:	5eba56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
    }

    //set permissions
    if (use_iram0) {
42005308:	5188      	l32i.n	a8, a1, 20
4200530a:	055816        	beqz	a8, 42005363 <esp_mprot_set_prot+0x277>
        ret = ESP_OK;
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_0, MEMPROT_OP_NONE, DEFAULT_CPU_NUM));
4200530d:	fc7c      	movi.n	a12, -1
4200530f:	0b0c      	movi.n	a11, 0
42005311:	00a4a2        	movi	a10, 0x400
42005314:	ff67a5        	call8	42004990 <esp_mprot_set_pms_area>
42005317:	0a2d      	mov.n	a2, a10
42005319:	5d7a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
#if CONFIG_ESP32S3_INSTRUCTION_CACHE_16KB
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_1, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM));
4200531c:	fc7c      	movi.n	a12, -1
4200531e:	5b0c      	movi.n	a11, 5
42005320:	ec9ca1        	l32r	a10, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
42005323:	ff66e5        	call8	42004990 <esp_mprot_set_pms_area>
42005326:	0a2d      	mov.n	a2, a10
42005328:	5c8a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
#else
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_1, MEMPROT_OP_NONE, DEFAULT_CPU_NUM));
#endif
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_0, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
4200532b:	fc7c      	movi.n	a12, -1
4200532d:	5b0c      	movi.n	a11, 5
4200532f:	1a0c      	movi.n	a10, 1
42005331:	ff65e5        	call8	42004990 <esp_mprot_set_pms_area>
42005334:	0a2d      	mov.n	a2, a10
42005336:	5baa56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_1, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
42005339:	fc7c      	movi.n	a12, -1
4200533b:	5b0c      	movi.n	a11, 5
4200533d:	2a0c      	movi.n	a10, 2
4200533f:	ff6525        	call8	42004990 <esp_mprot_set_pms_area>
42005342:	0a2d      	mov.n	a2, a10
42005344:	5aca56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_2, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
42005347:	fc7c      	movi.n	a12, -1
42005349:	5b0c      	movi.n	a11, 5
4200534b:	4a0c      	movi.n	a10, 4
4200534d:	ff6425        	call8	42004990 <esp_mprot_set_pms_area>
42005350:	0a2d      	mov.n	a2, a10
42005352:	59ea56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_3, MEMPROT_OP_NONE, DEFAULT_CPU_NUM))
42005355:	fc7c      	movi.n	a12, -1
42005357:	0b0c      	movi.n	a11, 0
42005359:	8a0c      	movi.n	a10, 8
4200535b:	ff6365        	call8	42004990 <esp_mprot_set_pms_area>
4200535e:	0a2d      	mov.n	a2, a10
42005360:	590a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
    }
    if (use_dram0) {
42005363:	03a316        	beqz	a3, 420053a1 <esp_mprot_set_prot+0x2b5>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_0, MEMPROT_OP_READ, DEFAULT_CPU_NUM))
42005366:	fc7c      	movi.n	a12, -1
42005368:	1b0c      	movi.n	a11, 1
4200536a:	0a1c      	movi.n	a10, 16
4200536c:	ff6225        	call8	42004990 <esp_mprot_set_pms_area>
4200536f:	0a2d      	mov.n	a2, a10
42005371:	57fa56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_1, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
42005374:	fc7c      	movi.n	a12, -1
42005376:	3b0c      	movi.n	a11, 3
42005378:	0a2c      	movi.n	a10, 32
4200537a:	ff6165        	call8	42004990 <esp_mprot_set_pms_area>
4200537d:	0a2d      	mov.n	a2, a10
4200537f:	571a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_2, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
42005382:	fc7c      	movi.n	a12, -1
42005384:	3b0c      	movi.n	a11, 3
42005386:	0a4c      	movi.n	a10, 64
42005388:	ff6065        	call8	42004990 <esp_mprot_set_pms_area>
4200538b:	0a2d      	mov.n	a2, a10
4200538d:	563a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_3, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
42005390:	ffafc2        	movi	a12, -1
42005393:	03a0b2        	movi	a11, 3
42005396:	80a0a2        	movi	a10, 128
42005399:	ff5f65        	call8	42004990 <esp_mprot_set_pms_area>
4200539c:	0a2d      	mov.n	a2, a10
4200539e:	552a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
    }

    void *rtc_fast_line __attribute__((unused)) = NULL;
420053a1:	00a082        	movi	a8, 0
420053a4:	016182        	s32i	a8, a1, 4
    if (use_rtcfast) {
420053a7:	042182        	l32i	a8, a1, 16
420053aa:	052816        	beqz	a8, 42005400 <esp_mprot_set_prot+0x314>
        //RTCFAST split-line cannot be set manually - always use default
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_default_main_split_addr(MEMPROT_TYPE_IRAM0_RTCFAST, &rtc_fast_line));
420053ad:	b14b      	addi.n	a11, a1, 4
420053af:	4a0c      	movi.n	a10, 4
420053b1:	ff3fe5        	call8	420047b0 <esp_mprot_get_default_main_split_addr>
420053b4:	0a2d      	mov.n	a2, a10
420053b6:	53aa56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420053b9:	045d      	mov.n	a5, a4
420053bb:	000f86        	j	420053fd <esp_mprot_set_prot+0x311>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_RTCFAST, MEMPROT_SPLIT_ADDR_MAIN, rtc_fast_line, memp_config->target_cpu[x]))
420053be:	854b      	addi.n	a8, a5, 4
420053c0:	a08870        	addx4	a8, a8, a7
420053c3:	08d8      	l32i.n	a13, a8, 0
420053c5:	11c8      	l32i.n	a12, a1, 4
420053c7:	1b0c      	movi.n	a11, 1
420053c9:	4a0c      	movi.n	a10, 4
420053cb:	ff3265        	call8	420046f0 <esp_mprot_set_split_addr>
420053ce:	0a2d      	mov.n	a2, a10
420053d0:	520a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_LO, MEMPROT_OP_READ | MEMPROT_OP_EXEC, memp_config->target_cpu[x]))
420053d3:	854b      	addi.n	a8, a5, 4
420053d5:	a08870        	addx4	a8, a8, a7
420053d8:	08c8      	l32i.n	a12, a8, 0
420053da:	5b0c      	movi.n	a11, 5
420053dc:	00a1a2        	movi	a10, 0x100
420053df:	ff5b25        	call8	42004990 <esp_mprot_set_pms_area>
420053e2:	0a2d      	mov.n	a2, a10
420053e4:	50ca56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_HI, MEMPROT_OP_READ | MEMPROT_OP_WRITE, memp_config->target_cpu[x]))
420053e7:	854b      	addi.n	a8, a5, 4
420053e9:	a08870        	addx4	a8, a8, a7
420053ec:	08c8      	l32i.n	a12, a8, 0
420053ee:	3b0c      	movi.n	a11, 3
420053f0:	00a2a2        	movi	a10, 0x200
420053f3:	ff59e5        	call8	42004990 <esp_mprot_set_pms_area>
420053f6:	0a2d      	mov.n	a2, a10
420053f8:	4f8a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420053fb:	551b      	addi.n	a5, a5, 1
420053fd:	bd3567        	bltu	a5, a6, 420053be <esp_mprot_set_prot+0x2d2>
        }
    }

    //reenable the protection
    if (use_iram0) {
42005400:	5188      	l32i.n	a8, a1, 20
42005402:	e8ec      	bnez.n	a8, 42005434 <esp_mprot_set_prot+0x348>
42005404:	000c46        	j	42005439 <esp_mprot_set_prot+0x34d>
42005407:	820000        	mull	a0, a0, a0
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
4200540a:	7004c5        	call0	42075458 <_etext+0x5f202>
4200540d:	a088      	l32i.n	a8, a0, 40
4200540f:	0028b2        	l32i	a11, a8, 0
42005412:	1a0c      	movi.n	a10, 1
42005414:	ffada5        	call8	42004ef0 <esp_mprot_monitor_clear_intr>
42005417:	0a2d      	mov.n	a2, a10
42005419:	4d7a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, true, memp_config->target_cpu[x]))
4200541c:	854b      	addi.n	a8, a5, 4
4200541e:	a08870        	addx4	a8, a8, a7
42005421:	08c8      	l32i.n	a12, a8, 0
42005423:	1b0c      	movi.n	a11, 1
42005425:	0bad      	mov.n	a10, a11
42005427:	ffa0e5        	call8	42004e34 <esp_mprot_set_monitor_en>
4200542a:	0a2d      	mov.n	a2, a10
4200542c:	4c4a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200542f:	551b      	addi.n	a5, a5, 1
42005431:	000046        	j	42005436 <esp_mprot_set_prot+0x34a>
42005434:	045d      	mov.n	a5, a4
42005436:	cf3567        	bltu	a5, a6, 42005409 <esp_mprot_set_prot+0x31d>
        }
    }

    if (use_dram0) {
42005439:	d3ec      	bnez.n	a3, 4200546a <esp_mprot_set_prot+0x37e>
4200543b:	000c06        	j	4200546f <esp_mprot_set_prot+0x383>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
4200543e:	04c582        	addi	a8, a5, 4
42005441:	a08870        	addx4	a8, a8, a7
42005444:	0028b2        	l32i	a11, a8, 0
42005447:	02a0a2        	movi	a10, 2
4200544a:	ffaa65        	call8	42004ef0 <esp_mprot_monitor_clear_intr>
4200544d:	0a2d      	mov.n	a2, a10
4200544f:	4a1a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, true, memp_config->target_cpu[x]))
42005452:	854b      	addi.n	a8, a5, 4
42005454:	a08870        	addx4	a8, a8, a7
42005457:	08c8      	l32i.n	a12, a8, 0
42005459:	1b0c      	movi.n	a11, 1
4200545b:	2a0c      	movi.n	a10, 2
4200545d:	ff9d65        	call8	42004e34 <esp_mprot_set_monitor_en>
42005460:	0a2d      	mov.n	a2, a10
42005462:	48ea56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
42005465:	551b      	addi.n	a5, a5, 1
42005467:	000046        	j	4200546c <esp_mprot_set_prot+0x380>
4200546a:	045d      	mov.n	a5, a4
4200546c:	ce3567        	bltu	a5, a6, 4200543e <esp_mprot_set_prot+0x352>
        }
    }
    if (use_rtcfast) {
4200546f:	4188      	l32i.n	a8, a1, 16
42005471:	d8ec      	bnez.n	a8, 420054a2 <esp_mprot_set_prot+0x3b6>
42005473:	000c06        	j	420054a7 <esp_mprot_set_prot+0x3bb>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42005476:	04c582        	addi	a8, a5, 4
42005479:	a08870        	addx4	a8, a8, a7
4200547c:	0028b2        	l32i	a11, a8, 0
4200547f:	04a0a2        	movi	a10, 4
42005482:	ffa6e5        	call8	42004ef0 <esp_mprot_monitor_clear_intr>
42005485:	0a2d      	mov.n	a2, a10
42005487:	469a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, true, memp_config->target_cpu[x]))
4200548a:	854b      	addi.n	a8, a5, 4
4200548c:	a08870        	addx4	a8, a8, a7
4200548f:	08c8      	l32i.n	a12, a8, 0
42005491:	1b0c      	movi.n	a11, 1
42005493:	4a0c      	movi.n	a10, 4
42005495:	ff99e5        	call8	42004e34 <esp_mprot_set_monitor_en>
42005498:	0a2d      	mov.n	a2, a10
4200549a:	456a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200549d:	551b      	addi.n	a5, a5, 1
4200549f:	000046        	j	420054a4 <esp_mprot_set_prot+0x3b8>
420054a2:	045d      	mov.n	a5, a4
420054a4:	ce3567        	bltu	a5, a6, 42005476 <esp_mprot_set_prot+0x38a>
        }
    }

    //lock if required
    if (memp_config->lock_feature) {
420054a7:	010782        	l8ui	a8, a7, 1
420054aa:	0a2816        	beqz	a8, 42005550 <esp_mprot_set_prot+0x464>
        if (use_iram0) {
420054ad:	5188      	l32i.n	a8, a1, 20
420054af:	48bc      	beqz.n	a8, 420054e7 <esp_mprot_set_prot+0x3fb>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, DEFAULT_CPU_NUM))
420054b1:	fb7c      	movi.n	a11, -1
420054b3:	1a0c      	movi.n	a10, 1
420054b5:	ff33e5        	call8	420047f4 <esp_mprot_set_split_addr_lock>
420054b8:	0a2d      	mov.n	a2, a10
420054ba:	436a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, DEFAULT_CPU_NUM))
420054bd:	fb7c      	movi.n	a11, -1
420054bf:	1a0c      	movi.n	a10, 1
420054c1:	ff3ee5        	call8	420048b0 <esp_mprot_set_pms_lock>
420054c4:	0a2d      	mov.n	a2, a10
420054c6:	42aa56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
420054c9:	045d      	mov.n	a5, a4
420054cb:	000546        	j	420054e4 <esp_mprot_set_prot+0x3f8>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
420054ce:	04c582        	addi	a8, a5, 4
420054d1:	a08870        	addx4	a8, a8, a7
420054d4:	08b8      	l32i.n	a11, a8, 0
420054d6:	01a0a2        	movi	a10, 1
420054d9:	ff83e5        	call8	42004d18 <esp_mprot_set_monitor_lock>
420054dc:	0a2d      	mov.n	a2, a10
420054de:	412a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
420054e1:	01c552        	addi	a5, a5, 1
420054e4:	e63567        	bltu	a5, a6, 420054ce <esp_mprot_set_prot+0x3e2>
            }
        }
        if (use_dram0) {
420054e7:	13bc      	beqz.n	a3, 4200551c <esp_mprot_set_prot+0x430>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, DEFAULT_CPU_NUM))
420054e9:	fb7c      	movi.n	a11, -1
420054eb:	2a0c      	movi.n	a10, 2
420054ed:	ff3065        	call8	420047f4 <esp_mprot_set_split_addr_lock>
420054f0:	0a2d      	mov.n	a2, a10
420054f2:	3fea56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, DEFAULT_CPU_NUM))
420054f5:	fb7c      	movi.n	a11, -1
420054f7:	2a0c      	movi.n	a10, 2
420054f9:	ff3b65        	call8	420048b0 <esp_mprot_set_pms_lock>
420054fc:	0a2d      	mov.n	a2, a10
420054fe:	3f2a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005501:	045d      	mov.n	a5, a4
42005503:	000486        	j	42005519 <esp_mprot_set_prot+0x42d>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42005506:	854b      	addi.n	a8, a5, 4
42005508:	a08870        	addx4	a8, a8, a7
4200550b:	08b8      	l32i.n	a11, a8, 0
4200550d:	2a0c      	movi.n	a10, 2
4200550f:	ff80a5        	call8	42004d18 <esp_mprot_set_monitor_lock>
42005512:	0a2d      	mov.n	a2, a10
42005514:	3dca56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005517:	551b      	addi.n	a5, a5, 1
42005519:	e93567        	bltu	a5, a6, 42005506 <esp_mprot_set_prot+0x41a>
            }
        }
        if (use_rtcfast) {
4200551c:	4188      	l32i.n	a8, a1, 16
4200551e:	b8ec      	bnez.n	a8, 4200554d <esp_mprot_set_prot+0x461>
42005520:	000b06        	j	42005550 <esp_mprot_set_prot+0x464>
42005523:	000000        	ill
            //split address and area permissions are locked by the same PMS register
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42005526:	04c482        	addi	a8, a4, 4
42005529:	a08870        	addx4	a8, a8, a7
4200552c:	0028b2        	l32i	a11, a8, 0
4200552f:	04a0a2        	movi	a10, 4
42005532:	ff37e5        	call8	420048b0 <esp_mprot_set_pms_lock>
42005535:	0a2d      	mov.n	a2, a10
42005537:	3b9a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
4200553a:	844b      	addi.n	a8, a4, 4
4200553c:	a08870        	addx4	a8, a8, a7
4200553f:	08b8      	l32i.n	a11, a8, 0
42005541:	4a0c      	movi.n	a10, 4
42005543:	ff7d65        	call8	42004d18 <esp_mprot_set_monitor_lock>
42005546:	0a2d      	mov.n	a2, a10
42005548:	3a8a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
4200554b:	441b      	addi.n	a4, a4, 1
4200554d:	d53467        	bltu	a4, a6, 42005526 <esp_mprot_set_prot+0x43a>
            }
        }
    }

    //sanity check (RTC FAST tbd within IDF-5208)
    if (use_iram0 || use_dram0) {
42005550:	6188      	l32i.n	a8, a1, 24
42005552:	375816        	beqz	a8, 420058cb <esp_mprot_set_prot+0x7df>

        uint32_t check_val;

        //IRAM0 split lines
        memprot_ll_prepare_iram0_split_line_regval((const uint32_t) line_addr, &check_val);
42005555:	b18b      	addi.n	a11, a1, 8
42005557:	01a8      	l32i.n	a10, a1, 0
42005559:	fe6d65        	call8	42003c30 <memprot_ll_prepare_iram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
4200555c:	ec4181        	l32r	a8, 42000660 <_stext+0x640> (600c10c4 <SYSTEM+0x10c4>)
4200555f:	0020c0        	memw
42005562:	0888      	l32i.n	a8, a8, 0

        if (memprot_ll_get_iram0_split_line_main_I_D_regval() != check_val) {
42005564:	21b8      	l32i.n	a11, a1, 8
42005566:	161b87        	beq	a11, a8, 42005580 <esp_mprot_set_prot+0x494>
42005569:	ec3d81        	l32r	a8, 42000660 <_stext+0x640> (600c10c4 <SYSTEM+0x10c4>)
4200556c:	0020c0        	memw
4200556f:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
42005571:	ec43a1        	l32r	a10, 42000680 <_stext+0x660> (3c0237a8 <_flash_rodata_start+0x3688>)
42005574:	eabc81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005577:	0008e0        	callx8	a8
                "Fatal error: Main I/D split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_D_regval());
            abort();
4200557a:	eade81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200557d:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
42005580:	ec3981        	l32r	a8, 42000664 <_stext+0x644> (600c10c8 <SYSTEM+0x10c8>)
42005583:	0020c0        	memw
42005586:	0888      	l32i.n	a8, a8, 0
        }
        if (memprot_ll_get_iram0_split_line_main_I_0_regval() != check_val) {
42005588:	161b87        	beq	a11, a8, 420055a2 <esp_mprot_set_prot+0x4b6>
4200558b:	ec3681        	l32r	a8, 42000664 <_stext+0x644> (600c10c8 <SYSTEM+0x10c8>)
4200558e:	0020c0        	memw
42005591:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
42005593:	ec3ca1        	l32r	a10, 42000684 <_stext+0x664> (3c023808 <_flash_rodata_start+0x36e8>)
42005596:	eab381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005599:	0008e0        	callx8	a8
                "Fatal error: IRAM0 I_0 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_0_regval());
            abort();
4200559c:	ead681        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200559f:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
420055a2:	ec3181        	l32r	a8, 42000668 <_stext+0x648> (600c10cc <SYSTEM+0x10cc>)
420055a5:	0020c0        	memw
420055a8:	002882        	l32i	a8, a8, 0
        }
        if (memprot_ll_get_iram0_split_line_main_I_1_regval() != check_val) {
420055ab:	171b87        	beq	a11, a8, 420055c6 <esp_mprot_set_prot+0x4da>
420055ae:	ec2e81        	l32r	a8, 42000668 <_stext+0x648> (600c10cc <SYSTEM+0x10cc>)
420055b1:	0020c0        	memw
420055b4:	0028c2        	l32i	a12, a8, 0
            esp_rom_printf(
420055b7:	ec34a1        	l32r	a10, 42000688 <_stext+0x668> (3c023868 <_flash_rodata_start+0x3748>)
420055ba:	eaaa81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420055bd:	0008e0        	callx8	a8
                "Fatal error: IRAM0 I_1 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_1_regval());
            abort();
420055c0:	eacd81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420055c3:	0008e0        	callx8	a8
        }

        //DRAM0 split lines
        memprot_ll_prepare_dram0_split_line_regval(MAP_IRAM_TO_DRAM((const uint32_t) line_addr), &check_val);
420055c6:	b18b      	addi.n	a11, a1, 8
420055c8:	01a8      	l32i.n	a10, a1, 0
420055ca:	ec1881        	l32r	a8, 4200062c <_stext+0x60c> (ff910000 <_rtc_reserved_end+0x9f810000>)
420055cd:	aa8a      	add.n	a10, a10, a8
420055cf:	fed1a5        	call8	420042e8 <memprot_ll_prepare_dram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
420055d2:	ec2681        	l32r	a8, 4200066c <_stext+0x64c> (600c10d0 <SYSTEM+0x10d0>)
420055d5:	0020c0        	memw
420055d8:	0888      	l32i.n	a8, a8, 0

        if (memprot_ll_get_dram0_split_line_main_D_0_regval() != check_val) {
420055da:	21b8      	l32i.n	a11, a1, 8
420055dc:	161b87        	beq	a11, a8, 420055f6 <esp_mprot_set_prot+0x50a>
420055df:	ec2381        	l32r	a8, 4200066c <_stext+0x64c> (600c10d0 <SYSTEM+0x10d0>)
420055e2:	0020c0        	memw
420055e5:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
420055e7:	ec29a1        	l32r	a10, 4200068c <_stext+0x66c> (3c0238c8 <_flash_rodata_start+0x37a8>)
420055ea:	ea9e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420055ed:	0008e0        	callx8	a8
                "Fatal error: DRAM0 D_0 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_dram0_split_line_main_D_0_regval());
            abort();
420055f0:	eac181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420055f3:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
420055f6:	ec1e81        	l32r	a8, 42000670 <_stext+0x650> (600c10d4 <SYSTEM+0x10d4>)
420055f9:	0020c0        	memw
420055fc:	002882        	l32i	a8, a8, 0
        }
        if (memprot_ll_get_dram0_split_line_main_D_1_regval() != check_val) {
420055ff:	171b87        	beq	a11, a8, 4200561a <esp_mprot_set_prot+0x52e>
42005602:	ec1b81        	l32r	a8, 42000670 <_stext+0x650> (600c10d4 <SYSTEM+0x10d4>)
42005605:	0020c0        	memw
42005608:	0028c2        	l32i	a12, a8, 0
            esp_rom_printf(
4200560b:	ec21a1        	l32r	a10, 42000690 <_stext+0x670> (3c023928 <_flash_rodata_start+0x3808>)
4200560e:	ea9581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005611:	0008e0        	callx8	a8
                "Fatal error: DRAM0 D_1 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_dram0_split_line_main_D_1_regval());
            abort();
42005614:	eab881        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005617:	0008e0        	callx8	a8
        }

        //IRAM0 perms
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_0, &check_val, DEFAULT_CPU_NUM))
4200561a:	fc7c      	movi.n	a12, -1
4200561c:	b18b      	addi.n	a11, a1, 8
4200561e:	1a0c      	movi.n	a10, 1
42005620:	ff4da5        	call8	42004afc <esp_mprot_get_pms_area>
42005623:	0a2d      	mov.n	a2, a10
42005625:	2cba56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42005628:	21c8      	l32i.n	a12, a1, 8
4200562a:	105c26        	beqi	a12, 5, 4200563e <esp_mprot_set_prot+0x552>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_0 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
4200562d:	5b0c      	movi.n	a11, 5
4200562f:	ec19a1        	l32r	a10, 42000694 <_stext+0x674> (3c023988 <_flash_rodata_start+0x3868>)
42005632:	ea8c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005635:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
42005638:	eaaf81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200563b:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_1, &check_val, DEFAULT_CPU_NUM))
4200563e:	fc7c      	movi.n	a12, -1
42005640:	b18b      	addi.n	a11, a1, 8
42005642:	2a0c      	movi.n	a10, 2
42005644:	ff4b65        	call8	42004afc <esp_mprot_get_pms_area>
42005647:	0a2d      	mov.n	a2, a10
42005649:	2a7a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
4200564c:	21c8      	l32i.n	a12, a1, 8
4200564e:	105c26        	beqi	a12, 5, 42005662 <esp_mprot_set_prot+0x576>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_1 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005651:	5b0c      	movi.n	a11, 5
42005653:	ec11a1        	l32r	a10, 42000698 <_stext+0x678> (3c0239e4 <_flash_rodata_start+0x38c4>)
42005656:	ea8381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005659:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
4200565c:	eaa681        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200565f:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_2, &check_val, DEFAULT_CPU_NUM))
42005662:	fc7c      	movi.n	a12, -1
42005664:	b18b      	addi.n	a11, a1, 8
42005666:	4a0c      	movi.n	a10, 4
42005668:	ff4925        	call8	42004afc <esp_mprot_get_pms_area>
4200566b:	0a2d      	mov.n	a2, a10
4200566d:	283a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42005670:	21c8      	l32i.n	a12, a1, 8
42005672:	105c26        	beqi	a12, 5, 42005686 <esp_mprot_set_prot+0x59a>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_2 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005675:	5b0c      	movi.n	a11, 5
42005677:	ec09a1        	l32r	a10, 4200069c <_stext+0x67c> (3c023a40 <_flash_rodata_start+0x3920>)
4200567a:	ea7a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200567d:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
42005680:	ea9d81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005683:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_3, &check_val, DEFAULT_CPU_NUM))
42005686:	ffafc2        	movi	a12, -1
42005689:	08c1b2        	addi	a11, a1, 8
4200568c:	08a0a2        	movi	a10, 8
4200568f:	ff46e5        	call8	42004afc <esp_mprot_get_pms_area>
42005692:	0a2d      	mov.n	a2, a10
42005694:	25ca56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != MEMPROT_OP_NONE) {
42005697:	2158      	l32i.n	a5, a1, 8
42005699:	159c      	beqz.n	a5, 420056ae <esp_mprot_set_prot+0x5c2>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_3 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
4200569b:	05cd      	mov.n	a12, a5
4200569d:	0b0c      	movi.n	a11, 0
4200569f:	ec00a1        	l32r	a10, 420006a0 <_stext+0x680> (3c023a9c <_flash_rodata_start+0x397c>)
420056a2:	ea7081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420056a5:	0008e0        	callx8	a8
                          (uint32_t) MEMPROT_OP_NONE, check_val);
            abort();
420056a8:	ea9381        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420056ab:	0008e0        	callx8	a8
        }

        //DRAM0 perms
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_0, &check_val, DEFAULT_CPU_NUM))
420056ae:	fc7c      	movi.n	a12, -1
420056b0:	b18b      	addi.n	a11, a1, 8
420056b2:	0a1c      	movi.n	a10, 16
420056b4:	ff4465        	call8	42004afc <esp_mprot_get_pms_area>
420056b7:	0a2d      	mov.n	a2, a10
420056b9:	237a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != MEMPROT_OP_READ) {
420056bc:	21c8      	l32i.n	a12, a1, 8
420056be:	101c26        	beqi	a12, 1, 420056d2 <esp_mprot_set_prot+0x5e6>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_0 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420056c1:	1b0c      	movi.n	a11, 1
420056c3:	ebf8a1        	l32r	a10, 420006a4 <_stext+0x684> (3c023af8 <_flash_rodata_start+0x39d8>)
420056c6:	ea6781        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420056c9:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ, check_val);
            abort();
420056cc:	ea8a81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420056cf:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_1, &check_val, DEFAULT_CPU_NUM))
420056d2:	fc7c      	movi.n	a12, -1
420056d4:	b18b      	addi.n	a11, a1, 8
420056d6:	0a2c      	movi.n	a10, 32
420056d8:	ff4225        	call8	42004afc <esp_mprot_get_pms_area>
420056db:	0a2d      	mov.n	a2, a10
420056dd:	213a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
420056e0:	21c8      	l32i.n	a12, a1, 8
420056e2:	103c26        	beqi	a12, 3, 420056f6 <esp_mprot_set_prot+0x60a>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_1 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420056e5:	3b0c      	movi.n	a11, 3
420056e7:	ebf0a1        	l32r	a10, 420006a8 <_stext+0x688> (3c023b54 <_flash_rodata_start+0x3a34>)
420056ea:	ea5e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420056ed:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
420056f0:	ea8181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420056f3:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_2, &check_val, DEFAULT_CPU_NUM))
420056f6:	fc7c      	movi.n	a12, -1
420056f8:	b18b      	addi.n	a11, a1, 8
420056fa:	0a4c      	movi.n	a10, 64
420056fc:	ff3fe5        	call8	42004afc <esp_mprot_get_pms_area>
420056ff:	0a2d      	mov.n	a2, a10
42005701:	1efa56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42005704:	21c8      	l32i.n	a12, a1, 8
42005706:	103c26        	beqi	a12, 3, 4200571a <esp_mprot_set_prot+0x62e>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_2 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005709:	3b0c      	movi.n	a11, 3
4200570b:	ebe8a1        	l32r	a10, 420006ac <_stext+0x68c> (3c023bb0 <_flash_rodata_start+0x3a90>)
4200570e:	ea5581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005711:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
42005714:	ea7881        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005717:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_3, &check_val, DEFAULT_CPU_NUM))
4200571a:	fc7c      	movi.n	a12, -1
4200571c:	b18b      	addi.n	a11, a1, 8
4200571e:	80a0a2        	movi	a10, 128
42005721:	ff3da5        	call8	42004afc <esp_mprot_get_pms_area>
42005724:	0a2d      	mov.n	a2, a10
42005726:	1caa56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42005729:	21c8      	l32i.n	a12, a1, 8
4200572b:	103c26        	beqi	a12, 3, 4200573f <esp_mprot_set_prot+0x653>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_3 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
4200572e:	3b0c      	movi.n	a11, 3
42005730:	ebe0a1        	l32r	a10, 420006b0 <_stext+0x690> (3c023c0c <_flash_rodata_start+0x3aec>)
42005733:	ea4c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005736:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
42005739:	ea6e81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200573c:	0008e0        	callx8	a8
        }

        //memory protection enabled
        bool enabled;
        if (use_iram0) {
4200573f:	5188      	l32i.n	a8, a1, 20
42005741:	68fc      	bnez.n	a8, 4200577b <esp_mprot_set_prot+0x68f>
42005743:	000e46        	j	42005780 <esp_mprot_set_prot+0x694>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, &enabled,
42005746:	844b      	addi.n	a8, a4, 4
42005748:	a08870        	addx4	a8, a8, a7
4200574b:	08c8      	l32i.n	a12, a8, 0
4200574d:	b1db      	addi.n	a11, a1, 13
4200574f:	1a0c      	movi.n	a10, 1
42005751:	ff73a5        	call8	42004e8c <esp_mprot_get_monitor_en>
42005754:	0a2d      	mov.n	a2, a10
42005756:	19aa56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                                      memp_config->target_cpu[x]))
                if (!enabled) {
42005759:	0d0182        	l8ui	a8, a1, 13
4200575c:	68dc      	bnez.n	a8, 42005776 <esp_mprot_set_prot+0x68a>
                    esp_rom_printf(
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not enabled on core %d)\n",
                        memp_config->target_cpu[x]);
4200575e:	04c482        	addi	a8, a4, 4
42005761:	a08870        	addx4	a8, a8, a7
                    esp_rom_printf(
42005764:	0028b2        	l32i	a11, a8, 0
42005767:	ebd3a1        	l32r	a10, 420006b4 <_stext+0x694> (3c023c68 <_flash_rodata_start+0x3b48>)
4200576a:	ea3e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200576d:	0008e0        	callx8	a8
                    abort();
42005770:	ea6181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005773:	0008e0        	callx8	a8
            for (size_t x = 0; x < core_count; x++) {
42005776:	441b      	addi.n	a4, a4, 1
42005778:	000046        	j	4200577d <esp_mprot_set_prot+0x691>
4200577b:	054d      	mov.n	a4, a5
4200577d:	c53467        	bltu	a4, a6, 42005746 <esp_mprot_set_prot+0x65a>
                }
            }
        }
        if (use_dram0) {
42005780:	83fc      	bnez.n	a3, 420057bc <esp_mprot_set_prot+0x6d0>
42005782:	000ec6        	j	420057c1 <esp_mprot_set_prot+0x6d5>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, &enabled,
42005785:	04c482        	addi	a8, a4, 4
42005788:	a08870        	addx4	a8, a8, a7
4200578b:	0028c2        	l32i	a12, a8, 0
4200578e:	0dc1b2        	addi	a11, a1, 13
42005791:	2a0c      	movi.n	a10, 2
42005793:	ff6fa5        	call8	42004e8c <esp_mprot_get_monitor_en>
42005796:	0a2d      	mov.n	a2, a10
42005798:	158a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                                      memp_config->target_cpu[x]))
                if (!enabled) {
4200579b:	0d0182        	l8ui	a8, a1, 13
4200579e:	48dc      	bnez.n	a8, 420057b6 <esp_mprot_set_prot+0x6ca>
                    esp_rom_printf(
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not enabled on core %d)\n",
                        memp_config->target_cpu[x]);
420057a0:	844b      	addi.n	a8, a4, 4
420057a2:	a08870        	addx4	a8, a8, a7
                    esp_rom_printf(
420057a5:	08b8      	l32i.n	a11, a8, 0
420057a7:	ebc4a1        	l32r	a10, 420006b8 <_stext+0x698> (3c023cc4 <_flash_rodata_start+0x3ba4>)
420057aa:	ea2e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420057ad:	0008e0        	callx8	a8
                    abort();
420057b0:	ea5181        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420057b3:	0008e0        	callx8	a8
            for (size_t x = 0; x < core_count; x++) {
420057b6:	441b      	addi.n	a4, a4, 1
420057b8:	000086        	j	420057be <esp_mprot_set_prot+0x6d2>
420057bb:	054d00        	extui	a4, a0, 29, 1
420057be:	c33467        	bltu	a4, a6, 42005785 <esp_mprot_set_prot+0x699>
                }
            }
        }

        //locks
        if (memp_config->lock_feature) {
420057c1:	010782        	l8ui	a8, a7, 1
420057c4:	103816        	beqz	a8, 420058cb <esp_mprot_set_prot+0x7df>

            bool locked;

            if (use_iram0) {
420057c7:	5188      	l32i.n	a8, a1, 20
420057c9:	080816        	beqz	a8, 4200584d <esp_mprot_set_prot+0x761>
                ESP_MEMPROT_ERR_CHECK(ret,
420057cc:	fc7c      	movi.n	a12, -1
420057ce:	b1cb      	addi.n	a11, a1, 12
420057d0:	1a0c      	movi.n	a10, 1
420057d2:	ff0865        	call8	42004858 <esp_mprot_get_split_addr_lock>
420057d5:	0a2d      	mov.n	a2, a10
420057d7:	119a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                                      esp_mprot_get_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
                if (!locked) {
420057da:	0c0182        	l8ui	a8, a1, 12
420057dd:	d8cc      	bnez.n	a8, 420057ee <esp_mprot_set_prot+0x702>
                    esp_rom_printf(
420057df:	ebb7a1        	l32r	a10, 420006bc <_stext+0x69c> (3c023d20 <_flash_rodata_start+0x3c00>)
420057e2:	ea2081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420057e5:	0008e0        	callx8	a8
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - split address lock)\n");
                    abort();
420057e8:	ea4381        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420057eb:	0008e0        	callx8	a8
                }
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
420057ee:	ffafc2        	movi	a12, -1
420057f1:	0cc1b2        	addi	a11, a1, 12
420057f4:	01a0a2        	movi	a10, 1
420057f7:	ff12e5        	call8	42004924 <esp_mprot_get_pms_lock>
420057fa:	0a2d      	mov.n	a2, a10
420057fc:	0f4a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                if (!locked) {
420057ff:	0c0182        	l8ui	a8, a1, 12
42005802:	042856        	bnez	a8, 42005848 <esp_mprot_set_prot+0x75c>
                    esp_rom_printf(
42005805:	ebaea1        	l32r	a10, 420006c0 <_stext+0x6a0> (3c023d84 <_flash_rodata_start+0x3c64>)
42005808:	ea1781        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200580b:	0008e0        	callx8	a8
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - global PMS lock)\n");
                    abort();
4200580e:	ea3981        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005811:	0008e0        	callx8	a8
                }
                for (size_t x = 0; x < core_count; x++) {
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked,
42005814:	844b      	addi.n	a8, a4, 4
42005816:	a08870        	addx4	a8, a8, a7
42005819:	08c8      	l32i.n	a12, a8, 0
4200581b:	b1cb      	addi.n	a11, a1, 12
4200581d:	1a0c      	movi.n	a10, 1
4200581f:	ff5b25        	call8	42004dd0 <esp_mprot_get_monitor_lock>
42005822:	0a2d      	mov.n	a2, a10
42005824:	0cca56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                                          memp_config->target_cpu[x]))
                    if (!locked) {
42005827:	0c0182        	l8ui	a8, a1, 12
4200582a:	48dc      	bnez.n	a8, 42005842 <esp_mprot_set_prot+0x756>
                        esp_rom_printf(
                            "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - monitor lock on core %d)\n",
                            memp_config->target_cpu[x]);
4200582c:	844b      	addi.n	a8, a4, 4
4200582e:	a08870        	addx4	a8, a8, a7
                        esp_rom_printf(
42005831:	08b8      	l32i.n	a11, a8, 0
42005833:	eba4a1        	l32r	a10, 420006c4 <_stext+0x6a4> (3c023de8 <_flash_rodata_start+0x3cc8>)
42005836:	ea0b81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005839:	0008e0        	callx8	a8
                        abort();
4200583c:	ea2e81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200583f:	0008e0        	callx8	a8
                for (size_t x = 0; x < core_count; x++) {
42005842:	441b      	addi.n	a4, a4, 1
42005844:	000086        	j	4200584a <esp_mprot_set_prot+0x75e>
42005847:	054d00        	extui	a4, a0, 29, 1
4200584a:	c63467        	bltu	a4, a6, 42005814 <esp_mprot_set_prot+0x728>
                    }
                }
            }

            if (use_dram0) {
4200584d:	07a316        	beqz	a3, 420058cb <esp_mprot_set_prot+0x7df>
                ESP_MEMPROT_ERR_CHECK(ret,
42005850:	fc7c      	movi.n	a12, -1
42005852:	b1cb      	addi.n	a11, a1, 12
42005854:	2a0c      	movi.n	a10, 2
42005856:	ff0025        	call8	42004858 <esp_mprot_get_split_addr_lock>
42005859:	0a2d      	mov.n	a2, a10
4200585b:	095a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                                      esp_mprot_get_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
                if (!locked) {
4200585e:	0c0182        	l8ui	a8, a1, 12
42005861:	d8cc      	bnez.n	a8, 42005872 <esp_mprot_set_prot+0x786>
                    esp_rom_printf(
42005863:	eb99a1        	l32r	a10, 420006c8 <_stext+0x6a8> (3c023e54 <_flash_rodata_start+0x3d34>)
42005866:	e9ff81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005869:	0008e0        	callx8	a8
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - split address lock)\n");
                    abort();
4200586c:	ea2281        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200586f:	0008e0        	callx8	a8
                }
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
42005872:	ffafc2        	movi	a12, -1
42005875:	0cc1b2        	addi	a11, a1, 12
42005878:	02a0a2        	movi	a10, 2
4200587b:	ff0aa5        	call8	42004924 <esp_mprot_get_pms_lock>
4200587e:	0a2d      	mov.n	a2, a10
42005880:	070a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                if (!locked) {
42005883:	0c0182        	l8ui	a8, a1, 12
42005886:	03e856        	bnez	a8, 420058c8 <esp_mprot_set_prot+0x7dc>
                    esp_rom_printf(
42005889:	eb90a1        	l32r	a10, 420006cc <_stext+0x6ac> (3c023eb8 <_flash_rodata_start+0x3d98>)
4200588c:	e9f681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200588f:	0008e0        	callx8	a8
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - global PMS lock)\n");
                    abort();
42005892:	ea1881        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005895:	0008e0        	callx8	a8
                }
                for (size_t x = 0; x < core_count; x++) {
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked,
42005898:	854b      	addi.n	a8, a5, 4
4200589a:	a08870        	addx4	a8, a8, a7
4200589d:	08c8      	l32i.n	a12, a8, 0
4200589f:	b1cb      	addi.n	a11, a1, 12
420058a1:	2a0c      	movi.n	a10, 2
420058a3:	ff52e5        	call8	42004dd0 <esp_mprot_get_monitor_lock>
420058a6:	0a2d      	mov.n	a2, a10
420058a8:	048a56        	bnez	a10, 420058f4 <esp_mprot_set_prot+0x808>
                                          memp_config->target_cpu[x]))
                    if (!locked) {
420058ab:	0c0182        	l8ui	a8, a1, 12
420058ae:	48dc      	bnez.n	a8, 420058c6 <esp_mprot_set_prot+0x7da>
                        esp_rom_printf(
                            "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - monitor lock on core %d)\n",
                            memp_config->target_cpu[x]);
420058b0:	854b      	addi.n	a8, a5, 4
420058b2:	a08870        	addx4	a8, a8, a7
                        esp_rom_printf(
420058b5:	08b8      	l32i.n	a11, a8, 0
420058b7:	eb86a1        	l32r	a10, 420006d0 <_stext+0x6b0> (3c023f1c <_flash_rodata_start+0x3dfc>)
420058ba:	e9ea81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420058bd:	0008e0        	callx8	a8
                        abort();
420058c0:	ea0d81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
420058c3:	0008e0        	callx8	a8
                for (size_t x = 0; x < core_count; x++) {
420058c6:	551b      	addi.n	a5, a5, 1
420058c8:	cc3567        	bltu	a5, a6, 42005898 <esp_mprot_set_prot+0x7ac>
            }
        }
    }

    //keep current configuration copy if all went well
    if (ret == ESP_OK) {
420058cb:	52ec      	bnez.n	a2, 420058f4 <esp_mprot_set_prot+0x808>
        s_memp_cfg = *memp_config;
420058cd:	18a0c2        	movi	a12, 24
420058d0:	20b770        	or	a11, a7, a7
420058d3:	eb5ea1        	l32r	a10, 4200064c <_stext+0x62c> (3fc91f78 <s_memp_cfg>)
420058d6:	e9d481        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420058d9:	0008e0        	callx8	a8
420058dc:	000506        	j	420058f4 <esp_mprot_set_prot+0x808>
420058df:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
420058e2:	034602        	s8i	a0, a6, 3
420058e5:	000000        	ill
        return ESP_ERR_NO_MEM;
420058e8:	01a122        	movi	a2, 0x101
420058eb:	000146        	j	420058f4 <esp_mprot_set_prot+0x808>
420058ee:	000000        	ill
        return ESP_ERR_MEMPROT_CPUID_INVALID;
420058f1:	eb5521        	l32r	a2, 42000648 <_stext+0x628> (d008 <UserFrameTotalSize+0xcf08>)
    }

    return ret;
}
420058f4:	f01d      	retw.n
	...

420058f8 <esp_mprot_ll_err_to_esp_err>:
#include "esp_memprot_err.h"
#include "hal/memprot_types.h"
#include "esp_memprot_types.h"

esp_err_t esp_mprot_ll_err_to_esp_err(const memprot_hal_err_t err)
{
420058f8:	004136        	entry	a1, 32
    switch (err) {
420058fb:	194226        	beqi	a2, 4, 42005918 <esp_mprot_ll_err_to_esp_err+0x20>
420058fe:	0a52e6        	bgei	a2, 5, 4200590c <esp_mprot_ll_err_to_esp_err+0x14>
42005901:	1b2226        	beqi	a2, 2, 42005920 <esp_mprot_ll_err_to_esp_err+0x28>
42005904:	203226        	beqi	a2, 3, 42005928 <esp_mprot_ll_err_to_esp_err+0x30>
42005907:	32ec      	bnez.n	a2, 4200592e <esp_mprot_ll_err_to_esp_err+0x36>
42005909:	000bc6        	j	4200593c <esp_mprot_ll_err_to_esp_err+0x44>
4200590c:	245226        	beqi	a2, 5, 42005934 <esp_mprot_ll_err_to_esp_err+0x3c>
4200590f:	276266        	bnei	a2, 6, 4200593a <esp_mprot_ll_err_to_esp_err+0x42>
    case MEMP_HAL_OK: return ESP_OK;
    case MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE: return ESP_ERR_MEMPROT_SPLIT_ADDR_OUT_OF_RANGE;
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
    case MEMP_HAL_ERR_UNI_BLOCK_INVALID: return ESP_ERR_MEMPROT_UNIMGMT_BLOCK_INVALID;
    case MEMP_HAL_ERR_WORLD_INVALID: return ESP_ERR_MEMPROT_WORLD_INVALID;
42005912:	eb7421        	l32r	a2, 420006e4 <_stext+0x6c4> (d006 <UserFrameTotalSize+0xcf06>)
42005915:	0008c6        	j	4200593c <esp_mprot_ll_err_to_esp_err+0x44>
    case MEMP_HAL_ERR_UNI_BLOCK_INVALID: return ESP_ERR_MEMPROT_UNIMGMT_BLOCK_INVALID;
42005918:	eb7221        	l32r	a2, 420006e0 <_stext+0x6c0> (d005 <UserFrameTotalSize+0xcf05>)
4200591b:	000746        	j	4200593c <esp_mprot_ll_err_to_esp_err+0x44>
4200591e:	210000        	srai	a0, a0, 0
    case MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE: return ESP_ERR_MEMPROT_SPLIT_ADDR_OUT_OF_RANGE;
42005921:	6e          	.byte	0x6e
42005922:	46eb      	addi.n	a4, a6, 14
42005924:	000005        	call0	42005928 <esp_mprot_ll_err_to_esp_err+0x30>
42005927:	6d2100        	lsi	f0, a1, 0x1b4
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
4200592a:	46eb      	addi.n	a4, a6, 14
4200592c:	7c0003        	lsi	f0, a0, 0x1f0
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
    default:
        return ESP_FAIL;
4200592f:	0206f2        	l8ui	a15, a6, 2
42005932:	210000        	srai	a0, a0, 0
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
42005935:	eb6d      	lsi	f6, a11, 44
42005937:	000046        	j	4200593c <esp_mprot_ll_err_to_esp_err+0x44>
        return ESP_FAIL;
4200593a:	f27c      	movi.n	a2, -1
    }
}
4200593c:	f01d      	retw.n
	...

42005940 <esp_cpu_intr_get_desc>:
    [31] = { 5, ESP_CPU_INTR_TYPE_LEVEL, { 0,                              0                               } },
};


void esp_cpu_intr_get_desc(int core_id, int intr_num, esp_cpu_intr_desc_t *intr_desc_ret)
{
42005940:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM && intr_desc_ret != NULL);
42005943:	180c      	movi.n	a8, 1
42005945:	628820        	lsi	f2, a8, 0x188
42005948:	880b      	addi.n	a8, a8, -1
4200594a:	608080        	neg	a8, a8
4200594d:	01a092        	movi	a9, 1
42005950:	839440        	moveqz	a9, a4, a4
42005953:	118897        	bany	a8, a9, 42005968 <esp_cpu_intr_get_desc+0x28>
42005956:	eb65d1        	l32r	a13, 420006ec <_stext+0x6cc> (3c023f88 <_flash_rodata_start+0x3e68>)
42005959:	eb65c1        	l32r	a12, 420006f0 <_stext+0x6d0> (3c027c78 <__func__$0>)
4200595c:	47a0b2        	movi	a11, 71
4200595f:	eb65a1        	l32r	a10, 420006f4 <_stext+0x6d4> (3c023ffd <_flash_rodata_start+0x3edd>)
42005962:	e9d781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42005965:	0008e0        	callx8	a8
    intr_desc_ret->priority = intr_desc_table[intr_num].priority;
42005968:	eb6491        	l32r	a9, 420006f8 <_stext+0x6d8> (3c027c90 <intr_desc_table>)
4200596b:	1183c0        	slli	a8, a3, 4
4200596e:	898a      	add.n	a8, a9, a8
42005970:	08a8      	l32i.n	a10, a8, 0
42005972:	04a9      	s32i.n	a10, a4, 0
    intr_desc_ret->type = intr_desc_table[intr_num].type;
42005974:	1888      	l32i.n	a8, a8, 4
42005976:	1489      	s32i.n	a8, a4, 4
    intr_desc_ret->flags = intr_desc_table[intr_num].flags[core_id];
42005978:	a03320        	addx4	a3, a3, a2
4200597b:	a03390        	addx4	a3, a3, a9
4200597e:	2388      	l32i.n	a8, a3, 8
42005980:	2489      	s32i.n	a8, a4, 8
}
42005982:	f01d      	retw.n

42005984 <esp_sleep_sub_mode_config>:
    assert(refs >= 0);
    return ESP_OK;
}

esp_err_t esp_sleep_sub_mode_config(esp_sleep_sub_mode_t mode, bool activate)
{
42005984:	004136        	entry	a1, 32
42005987:	743030        	extui	a3, a3, 0, 8
    if (mode >= ESP_SLEEP_MODE_MAX) {
4200598a:	7f72f6        	bgeui	a2, 7, 42005a0d <esp_sleep_sub_mode_config+0x89>
    if (xPortInIsrContext()) {
4200598d:	ea9981        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
42005990:	0008e0        	callx8	a8
42005993:	ca8c      	beqz.n	a10, 420059a3 <esp_sleep_sub_mode_config+0x1f>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42005995:	fb7c      	movi.n	a11, -1
42005997:	eb59a1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc91fc0 <s_config+0x30>)
4200599a:	ea9d81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200599d:	0008e0        	callx8	a8
420059a0:	000286        	j	420059ae <esp_sleep_sub_mode_config+0x2a>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
420059a3:	fb7c      	movi.n	a11, -1
420059a5:	eb55a1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc91fc0 <s_config+0x30>)
420059a8:	ea9a81        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420059ab:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }

    portENTER_CRITICAL_SAFE(&s_config.lock);
    if (activate) {
420059ae:	e38c      	beqz.n	a3, 420059c0 <esp_sleep_sub_mode_config+0x3c>
        s_sleep_sub_mode_ref_cnt[mode]++;
420059b0:	eb5481        	l32r	a8, 42000700 <_stext+0x6e0> (600fe000 <s_sleep_sub_mode_ref_cnt>)
420059b3:	a08280        	addx4	a8, a2, a8
420059b6:	0898      	l32i.n	a9, a8, 0
420059b8:	991b      	addi.n	a9, a9, 1
420059ba:	0899      	s32i.n	a9, a8, 0
420059bc:	000306        	j	420059cc <esp_sleep_sub_mode_config+0x48>
420059bf:	508100        	lsi	f0, a1, 0x140
    } else {
        s_sleep_sub_mode_ref_cnt[mode]--;
420059c2:	80eb      	addi.n	a8, a0, 14
420059c4:	98a082        	movi	a8, 152
420059c7:	0b08      	l32i.n	a0, a11, 0
420059c9:	9999      	s32i.n	a9, a9, 36
420059cb:	8108      	l32i.n	a0, a1, 32
    }
    assert(s_sleep_sub_mode_ref_cnt[mode] >= 0);
420059cd:	eb4d      	lsi	f4, a11, 44
420059cf:	a02280        	addx4	a2, a2, a8
420059d2:	0288      	l32i.n	a8, a2, 0
420059d4:	0118d6        	bgez	a8, 420059e9 <esp_sleep_sub_mode_config+0x65>
420059d7:	eb4bd1        	l32r	a13, 42000704 <_stext+0x6e4> (3c0240b8 <_flash_rodata_start+0x3f98>)
420059da:	eb4bc1        	l32r	a12, 42000708 <_stext+0x6e8> (3c027e90 <__func__$4>)
420059dd:	eb4bb1        	l32r	a11, 4200070c <_stext+0x6ec> (8ca <UserFrameTotalSize+0x7ca>)
420059e0:	eb4ca1        	l32r	a10, 42000710 <_stext+0x6f0> (3c02407c <_flash_rodata_start+0x3f5c>)
420059e3:	e9b781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420059e6:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
420059e9:	ea8281        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
420059ec:	0008e0        	callx8	a8
420059ef:	0a2d      	mov.n	a2, a10
420059f1:	ca8c      	beqz.n	a10, 42005a01 <esp_sleep_sub_mode_config+0x7d>
        portEXIT_CRITICAL_ISR(mux);
420059f3:	eb42a1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc91fc0 <s_config+0x30>)
420059f6:	ea8781        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420059f9:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&s_config.lock);
    return ESP_OK;
420059fc:	020c      	movi.n	a2, 0
420059fe:	000386        	j	42005a10 <esp_sleep_sub_mode_config+0x8c>
        portEXIT_CRITICAL(mux);
42005a01:	eb3ea1        	l32r	a10, 420006fc <_stext+0x6dc> (3fc91fc0 <s_config+0x30>)
42005a04:	ea8481        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42005a07:	0008e0        	callx8	a8
42005a0a:	000086        	j	42005a10 <esp_sleep_sub_mode_config+0x8c>
        return ESP_ERR_INVALID_ARG;
42005a0d:	02a122        	movi	a2, 0x102
}
42005a10:	f01d      	retw.n
	...

42005a14 <__esp_system_init_fn_init_libc>:
#include "esp_newlib.h"
#include "esp_private/startup_internal.h"
#include "esp_bit_defs.h"

ESP_SYSTEM_INIT_FN(init_libc, CORE, BIT(0), 102)
{
42005a14:	004136        	entry	a1, 32
    esp_libc_init();
42005a17:	0037a5        	call8	42005d90 <esp_libc_init>
    return ESP_OK;
}
42005a1a:	020c      	movi.n	a2, 0
42005a1c:	f01d      	retw.n
	...

42005a20 <__esp_system_init_fn_init_libc_stdio>:

ESP_SYSTEM_INIT_FN(init_libc_stdio, CORE, BIT(0), 115)
{
42005a20:	004136        	entry	a1, 32
#if CONFIG_VFS_SUPPORT_IO
    esp_libc_init_global_stdio("/dev/console");
42005a23:	eb3ca1        	l32r	a10, 42000714 <_stext+0x6f4> (3c024d94 <_flash_rodata_start+0x4c74>)
42005a26:	003b65        	call8	42005ddc <esp_libc_init_global_stdio>
#else
    esp_libc_init_global_stdio();
#endif
    return ESP_OK;
}
42005a29:	020c      	movi.n	a2, 0
42005a2b:	f01d      	retw.n
42005a2d:	000000        	ill

42005a30 <esp_libc_newlib_locks_init>:
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___dd_hash_mutex;
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___arc4random_mutex;

#if CONFIG_LIBC_NEWLIB
static void esp_libc_newlib_locks_init(void)
{
42005a30:	006136        	entry	a1, 48
     * No access to lock variables for the purpose of ECO forward compatibility,
     * however we have an API to initialize lock variables used in the ROM.
     */
    extern void esp_rom_newlib_init_common_mutexes(_LOCK_T, _LOCK_T);
    /* See notes about ROM_NEEDS_MUTEX_OVERRIDE above */
    int magic_val = ROM_MUTEX_MAGIC;
42005a33:	eb3981        	l32r	a8, 42000718 <_stext+0x6f8> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
42005a36:	0189      	s32i.n	a8, a1, 0
    _LOCK_T magic_mutex = (_LOCK_T) &magic_val;
    esp_rom_newlib_init_common_mutexes(magic_mutex, magic_mutex);
42005a38:	01bd      	mov.n	a11, a1
42005a3a:	01ad      	mov.n	a10, a1
42005a3c:	eb3881        	l32r	a8, 4200071c <_stext+0x6fc> (400011dc <esp_rom_newlib_init_common_mutexes>)
42005a3f:	0008e0        	callx8	a8
#else // other target
#error Unsupported target
#endif
}
42005a42:	f01d      	retw.n

42005a44 <esp_libc_locks_init>:
#endif // CONFIG_LIBC_NEWLIB

/* TODO IDF-11226 */
void esp_newlib_locks_init(void) __attribute__((alias("esp_libc_locks_init")));
void esp_libc_locks_init(void)
{
42005a44:	004136        	entry	a1, 32
    /* Initialize the two mutexes used for the locks above.
     * Asserts below check our assumption that SemaphoreHandle_t will always
     * point to the corresponding StaticSemaphore_t structure.
     */
    SemaphoreHandle_t handle;
    handle = xSemaphoreCreateMutexStatic(&s_common_mutex);
42005a47:	eb3671        	l32r	a7, 42000720 <_stext+0x700> (3fc94e58 <__lock___arc4random_mutex>)
42005a4a:	07bd      	mov.n	a11, a7
42005a4c:	1a0c      	movi.n	a10, 1
42005a4e:	ea6181        	l32r	a8, 420003d4 <_stext+0x3b4> (40379c68 <xQueueCreateMutexStatic>)
42005a51:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_mutex);
42005a54:	1117a7        	beq	a7, a10, 42005a69 <esp_libc_locks_init+0x25>
42005a57:	eb33d1        	l32r	a13, 42000724 <_stext+0x704> (3c024e38 <_flash_rodata_start+0x4d18>)
42005a5a:	eb33c1        	l32r	a12, 42000728 <_stext+0x708> (3c02827c <__func__$4>)
42005a5d:	a0a1b2        	movi	a11, 0x1a0
42005a60:	eb33a1        	l32r	a10, 4200072c <_stext+0x70c> (3c024dec <_flash_rodata_start+0x4ccc>)
42005a63:	e99781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42005a66:	0008e0        	callx8	a8
    handle = xSemaphoreCreateRecursiveMutexStatic(&s_common_recursive_mutex);
42005a69:	eb3171        	l32r	a7, 42000730 <_stext+0x710> (3fc94e04 <__lock___atexit_recursive_mutex>)
42005a6c:	20b770        	or	a11, a7, a7
42005a6f:	04a0a2        	movi	a10, 4
42005a72:	ea5881        	l32r	a8, 420003d4 <_stext+0x3b4> (40379c68 <xQueueCreateMutexStatic>)
42005a75:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_recursive_mutex);
42005a78:	1117a7        	beq	a7, a10, 42005a8d <esp_libc_locks_init+0x49>
42005a7b:	eb2ed1        	l32r	a13, 42000734 <_stext+0x714> (3c024e68 <_flash_rodata_start+0x4d48>)
42005a7e:	eb2ac1        	l32r	a12, 42000728 <_stext+0x708> (3c02827c <__func__$4>)
42005a81:	a2a1b2        	movi	a11, 0x1a2
42005a84:	eb2aa1        	l32r	a10, 4200072c <_stext+0x70c> (3c024dec <_flash_rodata_start+0x4ccc>)
42005a87:	e98e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42005a8a:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &__lock___libc_recursive_mutex);
#endif
    (void) handle;

#if CONFIG_LIBC_NEWLIB
    esp_libc_newlib_locks_init();
42005a8d:	fffa25        	call8	42005a30 <esp_libc_newlib_locks_init>
#endif
}
42005a90:	f01d      	retw.n
	...

42005a94 <adjust_boot_time>:
{
42005a94:	004136        	entry	a1, 32
    uint64_t boot_time = esp_time_impl_get_boot_time();
42005a97:	002125        	call8	42005ca8 <esp_time_impl_get_boot_time>
42005a9a:	202aa0        	or	a2, a10, a10
42005a9d:	203bb0        	or	a3, a11, a11
    if ((boot_time == 0) || (esp_time_impl_get_time_since_boot() < s_adjtime_start_us)) {
42005aa0:	208ab0        	or	a8, a10, a11
42005aa3:	189c      	beqz.n	a8, 42005ab8 <adjust_boot_time+0x24>
42005aa5:	001be5        	call8	42005c64 <esp_time_impl_get_time_since_boot>
42005aa8:	eb2481        	l32r	a8, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005aab:	0898      	l32i.n	a9, a8, 0
42005aad:	1888      	l32i.n	a8, a8, 4
42005aaf:	053b87        	bltu	a11, a8, 42005ab8 <adjust_boot_time+0x24>
42005ab2:	0b98b7        	bne	a8, a11, 42005ac1 <adjust_boot_time+0x2d>
42005ab5:	08ba97        	bgeu	a10, a9, 42005ac1 <adjust_boot_time+0x2d>
        s_adjtime_start_us = 0;
42005ab8:	eb2081        	l32r	a8, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005abb:	090c      	movi.n	a9, 0
42005abd:	0899      	s32i.n	a9, a8, 0
42005abf:	1899      	s32i.n	a9, a8, 4
    if (s_adjtime_start_us > 0) {
42005ac1:	eb1d91        	l32r	a9, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005ac4:	0988      	l32i.n	a8, a9, 0
42005ac6:	1998      	l32i.n	a9, a9, 4
42005ac8:	208890        	or	a8, a8, a9
42005acb:	0d9816        	beqz	a8, 42005ba8 <adjust_boot_time+0x114>
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
42005ace:	001965        	call8	42005c64 <esp_time_impl_get_time_since_boot>
        int64_t correction = (since_boot >> ADJTIME_CORRECTION_FACTOR) - (s_adjtime_start_us >> ADJTIME_CORRECTION_FACTOR);
42005ad1:	018b60        	slli	a8, a11, 26
42005ad4:	41d6a0        	srli	a13, a10, 6
42005ad7:	20d8d0        	or	a13, a8, a13
42005ada:	4176b0        	srli	a7, a11, 6
42005add:	eb1681        	l32r	a8, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005ae0:	1898      	l32i.n	a9, a8, 4
42005ae2:	01c960        	slli	a12, a9, 26
42005ae5:	0888      	l32i.n	a8, a8, 0
42005ae7:	418680        	srli	a8, a8, 6
42005aea:	208c80        	or	a8, a12, a8
42005aed:	41c690        	srli	a12, a9, 6
42005af0:	c0e7c0        	sub	a14, a7, a12
42005af3:	01bd87        	bgeu	a13, a8, 42005af8 <adjust_boot_time+0x64>
42005af6:	ee0b      	addi.n	a14, a14, -1
42005af8:	c0fd80        	sub	a15, a13, a8
42005afb:	0f6d      	mov.n	a6, a15
42005afd:	0e9d      	mov.n	a9, a14
        if (correction > 0) {
42005aff:	051ee6        	bgei	a14, 1, 42005b08 <adjust_boot_time+0x74>
42005b02:	0a2e56        	bnez	a14, 42005ba8 <adjust_boot_time+0x114>
42005b05:	09ff16        	beqz	a15, 42005ba8 <adjust_boot_time+0x114>
            s_adjtime_start_us = since_boot;
42005b08:	eb0c51        	l32r	a5, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005b0b:	05a9      	s32i.n	a10, a5, 0
42005b0d:	15b9      	s32i.n	a11, a5, 4
            if (s_adjtime_total_correction_us < 0) {
42005b0f:	eb0bb1        	l32r	a11, 4200073c <_stext+0x71c> (3fc94eb0 <s_adjtime_total_correction_us>)
42005b12:	0ba8      	l32i.n	a10, a11, 0
42005b14:	1bb8      	l32i.n	a11, a11, 4
42005b16:	047bd6        	bgez	a11, 42005b61 <adjust_boot_time+0xcd>
                if ((s_adjtime_total_correction_us + correction) >= 0) {
42005b19:	eb9a      	add.n	a14, a11, a9
42005b1b:	809af0        	add	a9, a10, a15
42005b1e:	02b967        	bgeu	a9, a6, 42005b24 <adjust_boot_time+0x90>
42005b21:	01cee2        	addi	a14, a14, 1
42005b24:	019e96        	bltz	a14, 42005b41 <adjust_boot_time+0xad>
                    boot_time = boot_time + s_adjtime_total_correction_us;
42005b27:	a2aa      	add.n	a10, a2, a10
42005b29:	628a20        	lsi	f2, a10, 0x188
42005b2c:	b3ba      	add.n	a11, a3, a11
42005b2e:	0a2d      	mov.n	a2, a10
42005b30:	38ba      	add.n	a3, a8, a11
                    s_adjtime_start_us = 0;
42005b32:	eb0181        	l32r	a8, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005b35:	090c      	movi.n	a9, 0
42005b37:	0899      	s32i.n	a9, a8, 0
42005b39:	1899      	s32i.n	a9, a8, 4
42005b3b:	001886        	j	42005ba1 <adjust_boot_time+0x10d>
42005b3e:	000000        	ill
                    s_adjtime_total_correction_us += correction;
42005b41:	eafea1        	l32r	a10, 4200073c <_stext+0x71c> (3fc94eb0 <s_adjtime_total_correction_us>)
42005b44:	0a99      	s32i.n	a9, a10, 0
42005b46:	1ae9      	s32i.n	a14, a10, 4
                    boot_time -= correction;
42005b48:	c09c70        	sub	a9, a12, a7
42005b4b:	01b8d7        	bgeu	a8, a13, 42005b50 <adjust_boot_time+0xbc>
42005b4e:	990b      	addi.n	a9, a9, -1
42005b50:	c088d0        	sub	a8, a8, a13
42005b53:	828a      	add.n	a8, a2, a8
42005b55:	62a820        	lsi	f2, a8, 0x188
42005b58:	939a      	add.n	a9, a3, a9
42005b5a:	082d      	mov.n	a2, a8
42005b5c:	3a9a      	add.n	a3, a10, a9
42005b5e:	000fc6        	j	42005ba1 <adjust_boot_time+0x10d>
                if ((s_adjtime_total_correction_us - correction) <= 0) {
42005b61:	c09b90        	sub	a9, a11, a9
42005b64:	01ba67        	bgeu	a10, a6, 42005b69 <adjust_boot_time+0xd5>
42005b67:	990b      	addi.n	a9, a9, -1
42005b69:	c08af0        	sub	a8, a10, a15
42005b6c:	1c19e6        	bgei	a9, 1, 42005b8c <adjust_boot_time+0xf8>
42005b6f:	19cc      	bnez.n	a9, 42005b74 <adjust_boot_time+0xe0>
42005b71:	017856        	bnez	a8, 42005b8c <adjust_boot_time+0xf8>
                    boot_time = boot_time + s_adjtime_total_correction_us;
42005b74:	a2aa      	add.n	a10, a2, a10
42005b76:	628a20        	lsi	f2, a10, 0x188
42005b79:	b3ba      	add.n	a11, a3, a11
42005b7b:	0a2d      	mov.n	a2, a10
42005b7d:	38ba      	add.n	a3, a8, a11
                    s_adjtime_start_us = 0;
42005b7f:	eaee81        	l32r	a8, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005b82:	090c      	movi.n	a9, 0
42005b84:	0899      	s32i.n	a9, a8, 0
42005b86:	1899      	s32i.n	a9, a8, 4
42005b88:	000546        	j	42005ba1 <adjust_boot_time+0x10d>
42005b8b:	eca100        	lsi	f0, a1, 0x3b0
                    s_adjtime_total_correction_us -= correction;
42005b8e:	82ea      	add.n	a8, a2, a14
42005b90:	006a      	add.n	a0, a0, a6
42005b92:	016a92        	s32i	a9, a10, 4
                    boot_time += correction;
42005b95:	8092f0        	add	a9, a2, a15
42005b98:	62a920        	lsi	f2, a9, 0x188
42005b9b:	83ea      	add.n	a8, a3, a14
42005b9d:	092d      	mov.n	a2, a9
42005b9f:	3a8a      	add.n	a3, a10, a8
            esp_time_impl_set_boot_time(boot_time);
42005ba1:	02ad      	mov.n	a10, a2
42005ba3:	03bd      	mov.n	a11, a3
42005ba5:	000da5        	call8	42005c80 <esp_time_impl_set_boot_time>
}
42005ba8:	f01d      	retw.n
	...

42005bac <get_adjusted_boot_time>:
{
42005bac:	004136        	entry	a1, 32
    _lock_acquire(&s_time_lock);
42005baf:	eae4a1        	l32r	a10, 42000740 <_stext+0x720> (3fc94eac <s_time_lock>)
42005bb2:	eae481        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005bb5:	0008e0        	callx8	a8
    uint64_t adjust_time = adjust_boot_time();
42005bb8:	ffeda5        	call8	42005a94 <adjust_boot_time>
42005bbb:	0a2d      	mov.n	a2, a10
42005bbd:	0b3d      	mov.n	a3, a11
    _lock_release(&s_time_lock);
42005bbf:	eae0a1        	l32r	a10, 42000740 <_stext+0x720> (3fc94eac <s_time_lock>)
42005bc2:	eae181        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005bc5:	0008e0        	callx8	a8
}
42005bc8:	f01d      	retw.n
	...

42005bcc <adjtime_corr_stop>:
{
42005bcc:	004136        	entry	a1, 32
    _lock_acquire(&s_time_lock);
42005bcf:	eadca1        	l32r	a10, 42000740 <_stext+0x720> (3fc94eac <s_time_lock>)
42005bd2:	eadc81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005bd5:	0008e0        	callx8	a8
    if (s_adjtime_start_us != 0) {
42005bd8:	ead881        	l32r	a8, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005bdb:	0898      	l32i.n	a9, a8, 0
42005bdd:	0128a2        	l32i	a10, a8, 4
42005be0:	2089a0        	or	a8, a9, a10
42005be3:	a88c      	beqz.n	a8, 42005bf1 <adjtime_corr_stop+0x25>
        adjust_boot_time();
42005be5:	ffeae5        	call8	42005a94 <adjust_boot_time>
        s_adjtime_start_us = 0;
42005be8:	ead481        	l32r	a8, 42000738 <_stext+0x718> (3fc94eb8 <s_adjtime_start_us>)
42005beb:	090c      	movi.n	a9, 0
42005bed:	0899      	s32i.n	a9, a8, 0
42005bef:	1899      	s32i.n	a9, a8, 4
    _lock_release(&s_time_lock);
42005bf1:	ead3a1        	l32r	a10, 42000740 <_stext+0x720> (3fc94eac <s_time_lock>)
42005bf4:	ead581        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005bf7:	0008e0        	callx8	a8
}
42005bfa:	f01d      	retw.n

42005bfc <settimeofday>:

WEAK_UNLESS_TIMEFUNC_IMPL int settimeofday(const struct timeval *tv, const struct timezone *tz)
{
42005bfc:	004136        	entry	a1, 32
    (void) tz;
#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
42005bff:	32bc      	beqz.n	a2, 42005c36 <settimeofday+0x3a>
        adjtime_corr_stop();
42005c01:	fffca5        	call8	42005bcc <adjtime_corr_stop>
        uint64_t now = ((uint64_t) tv->tv_sec) * 1000000LL + tv->tv_usec;
42005c04:	0288      	l32i.n	a8, a2, 0
42005c06:	1278      	l32i.n	a7, a2, 4
42005c08:	ead191        	l32r	a9, 4200074c <_stext+0x72c> (f4240 <UserFrameTotalSize+0xf4140>)
42005c0b:	827970        	mull	a7, a9, a7
42005c0e:	82a980        	mull	a10, a9, a8
42005c11:	a28890        	muluh	a8, a8, a9
42005c14:	778a      	add.n	a7, a7, a8
42005c16:	2288      	l32i.n	a8, a2, 8
42005c18:	319f80        	srai	a9, a8, 31
42005c1b:	779a      	add.n	a7, a7, a9
42005c1d:	2a8a      	add.n	a2, a10, a8
42005c1f:	01b287        	bgeu	a2, a8, 42005c24 <settimeofday+0x28>
42005c22:	771b      	addi.n	a7, a7, 1
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
42005c24:	0003e5        	call8	42005c64 <esp_time_impl_get_time_since_boot>
        esp_time_impl_set_boot_time(now - since_boot);
42005c27:	c0b7b0        	sub	a11, a7, a11
42005c2a:	02b2a7        	bgeu	a2, a10, 42005c30 <settimeofday+0x34>
42005c2d:	ffcbb2        	addi	a11, a11, -1
42005c30:	c0a2a0        	sub	a10, a2, a10
42005c33:	0004e5        	call8	42005c80 <esp_time_impl_set_boot_time>
    return 0;
#else
    errno = ENOSYS;
    return -1;
#endif
}
42005c36:	020c      	movi.n	a2, 0
42005c38:	f01d      	retw.n
	...

42005c3c <esp_libc_time_init>:
}

/* TODO IDF-11226 */
void esp_newlib_time_init(void) __attribute__((alias("esp_libc_time_init")));
void esp_libc_time_init(void)
{
42005c3c:	004136        	entry	a1, 32
    esp_set_time_from_rtc();
42005c3f:	000925        	call8	42005cd0 <esp_set_time_from_rtc>
}
42005c42:	f01d      	retw.n

42005c44 <fstat>:
{
    abort();
}

int fstat(int fd, struct stat *st)
{
42005c44:	004136        	entry	a1, 32
    return _fstat_r(__getreent(), fd, st);
42005c47:	eac281        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
42005c4a:	0008e0        	callx8	a8
42005c4d:	03cd      	mov.n	a12, a3
42005c4f:	02bd      	mov.n	a11, a2
42005c51:	012a65        	call8	42006ef8 <_fstat_r>
}
42005c54:	0a2d      	mov.n	a2, a10
42005c56:	f01d      	retw.n

42005c58 <_raise_r>:
    __errno_r(r) = ENOSYS;
    return -1;
}

static int syscall_not_implemented_aborts(void)
{
42005c58:	004136        	entry	a1, 32
    abort();
42005c5b:	e92681        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005c5e:	0008e0        	callx8	a8
42005c61:	000000        	ill

42005c64 <esp_time_impl_get_time_since_boot>:

static _lock_t s_boot_time_lock;

#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) || defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
uint64_t esp_time_impl_get_time_since_boot(void)
{
42005c64:	004136        	entry	a1, 32
    uint64_t microseconds = 0;

#ifdef CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    microseconds = s_microseconds_offset + esp_system_get_time();
42005c67:	eabc81        	l32r	a8, 42000758 <_stext+0x738> (40376c1c <esp_system_get_time>)
42005c6a:	0008e0        	callx8	a8
42005c6d:	eab991        	l32r	a9, 42000754 <_stext+0x734> (3fc94ec8 <s_microseconds_offset>)
42005c70:	0988      	l32i.n	a8, a9, 0
42005c72:	1998      	l32i.n	a9, a9, 4
42005c74:	3b9a      	add.n	a3, a11, a9
42005c76:	2a8a      	add.n	a2, a10, a8
42005c78:	01b287        	bgeu	a2, a8, 42005c7d <esp_time_impl_get_time_since_boot+0x19>
42005c7b:	331b      	addi.n	a3, a3, 1
#endif // CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
#elif defined(CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER)
    microseconds = esp_rtc_get_time_us();
#endif // CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
    return microseconds;
}
42005c7d:	f01d      	retw.n
	...

42005c80 <esp_time_impl_set_boot_time>:
}

#endif // defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) || defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )

void esp_time_impl_set_boot_time(uint64_t time_us)
{
42005c80:	004136        	entry	a1, 32
    _lock_acquire(&s_boot_time_lock);
42005c83:	eab6a1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94ec0 <s_boot_time_lock>)
42005c86:	eaaf81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005c89:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    REG_WRITE(RTC_BOOT_TIME_LOW_REG, (uint32_t)(time_us & 0xffffffff));
42005c8c:	eab581        	l32r	a8, 42000760 <_stext+0x740> (60008058 <RTCCNTL+0x58>)
42005c8f:	0020c0        	memw
42005c92:	0829      	s32i.n	a2, a8, 0
    REG_WRITE(RTC_BOOT_TIME_HIGH_REG, (uint32_t)(time_us >> 32));
42005c94:	eab481        	l32r	a8, 42000764 <_stext+0x744> (6000805c <RTCCNTL+0x5c>)
42005c97:	0020c0        	memw
42005c9a:	0839      	s32i.n	a3, a8, 0
#else
    s_boot_time = time_us;
#endif
    _lock_release(&s_boot_time_lock);
42005c9c:	eab0a1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94ec0 <s_boot_time_lock>)
42005c9f:	eaaa81        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005ca2:	0008e0        	callx8	a8
}
42005ca5:	f01d      	retw.n
	...

42005ca8 <esp_time_impl_get_boot_time>:

uint64_t esp_time_impl_get_boot_time(void)
{
42005ca8:	004136        	entry	a1, 32
    uint64_t result;
    _lock_acquire(&s_boot_time_lock);
42005cab:	eaaca1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94ec0 <s_boot_time_lock>)
42005cae:	eaa581        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42005cb1:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    result = ((uint64_t) REG_READ(RTC_BOOT_TIME_LOW_REG)) + (((uint64_t) REG_READ(RTC_BOOT_TIME_HIGH_REG)) << 32);
42005cb4:	eaab81        	l32r	a8, 42000760 <_stext+0x740> (60008058 <RTCCNTL+0x58>)
42005cb7:	0020c0        	memw
42005cba:	0828      	l32i.n	a2, a8, 0
42005cbc:	eaaa81        	l32r	a8, 42000764 <_stext+0x744> (6000805c <RTCCNTL+0x5c>)
42005cbf:	0020c0        	memw
42005cc2:	0838      	l32i.n	a3, a8, 0
#else
    result = s_boot_time;
#endif
    _lock_release(&s_boot_time_lock);
42005cc4:	eaa6a1        	l32r	a10, 4200075c <_stext+0x73c> (3fc94ec0 <s_boot_time_lock>)
42005cc7:	eaa081        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42005cca:	0008e0        	callx8	a8
    return result;
}
42005ccd:	f01d      	retw.n
	...

42005cd0 <esp_set_time_from_rtc>:

void esp_set_time_from_rtc(void)
{
42005cd0:	004136        	entry	a1, 32
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    // initialize time from RTC clock
    s_microseconds_offset = esp_rtc_get_time_us() - esp_system_get_time();
42005cd3:	fd4125        	call8	420030e4 <esp_rtc_get_time_us>
42005cd6:	0a6d      	mov.n	a6, a10
42005cd8:	0b7d      	mov.n	a7, a11
42005cda:	ea9f81        	l32r	a8, 42000758 <_stext+0x738> (40376c1c <esp_system_get_time>)
42005cdd:	0008e0        	callx8	a8
42005ce0:	c0b7b0        	sub	a11, a7, a11
42005ce3:	01b6a7        	bgeu	a6, a10, 42005ce8 <esp_set_time_from_rtc+0x18>
42005ce6:	bb0b      	addi.n	a11, a11, -1
42005ce8:	c066a0        	sub	a6, a6, a10
42005ceb:	ea9a81        	l32r	a8, 42000754 <_stext+0x734> (3fc94ec8 <s_microseconds_offset>)
42005cee:	0869      	s32i.n	a6, a8, 0
42005cf0:	18b9      	s32i.n	a11, a8, 4
#endif // CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER && CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
}
42005cf2:	f01d      	retw.n

42005cf4 <esp_sync_timekeeping_timers>:

void esp_sync_timekeeping_timers(void)
{
42005cf4:	006136        	entry	a1, 48
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    struct timeval tv;
    gettimeofday(&tv, NULL);
42005cf7:	00a0b2        	movi	a11, 0
42005cfa:	20a110        	or	a10, a1, a1
42005cfd:	057d25        	call8	4200b4d0 <gettimeofday>
    settimeofday(&tv, NULL);
42005d00:	0b0c      	movi.n	a11, 0
42005d02:	01ad      	mov.n	a10, a1
42005d04:	ffef65        	call8	42005bfc <settimeofday>
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
42005d07:	fd3de5        	call8	420030e4 <esp_rtc_get_time_us>
42005d0a:	0a7d      	mov.n	a7, a10
42005d0c:	0b6d      	mov.n	a6, a11
42005d0e:	ea9281        	l32r	a8, 42000758 <_stext+0x738> (40376c1c <esp_system_get_time>)
42005d11:	0008e0        	callx8	a8
42005d14:	c066b0        	sub	a6, a6, a11
42005d17:	01b7a7        	bgeu	a7, a10, 42005d1c <esp_sync_timekeeping_timers+0x28>
42005d1a:	660b      	addi.n	a6, a6, -1
42005d1c:	c077a0        	sub	a7, a7, a10
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
42005d1f:	fff8a5        	call8	42005ca8 <esp_time_impl_get_boot_time>
42005d22:	ea8c91        	l32r	a9, 42000754 <_stext+0x734> (3fc94ec8 <s_microseconds_offset>)
42005d25:	002982        	l32i	a8, a9, 0
42005d28:	012992        	l32i	a9, a9, 4
42005d2b:	c09960        	sub	a9, a9, a6
42005d2e:	02b877        	bgeu	a8, a7, 42005d34 <esp_sync_timekeeping_timers+0x40>
42005d31:	ffc992        	addi	a9, a9, -1
42005d34:	c08870        	sub	a8, a8, a7
42005d37:	bb9a      	add.n	a11, a11, a9
42005d39:	aa8a      	add.n	a10, a10, a8
42005d3b:	01ba87        	bgeu	a10, a8, 42005d40 <esp_sync_timekeeping_timers+0x4c>
42005d3e:	bb1b      	addi.n	a11, a11, 1
42005d40:	fff3e5        	call8	42005c80 <esp_time_impl_set_boot_time>
#endif
}
42005d43:	f01d      	retw.n
42005d45:	000000        	ill

42005d48 <esp_cleanup_r>:
{
    _raise_r(rptr, 0);
}

static void esp_cleanup_r(struct _reent *rptr)
{
42005d48:	004136        	entry	a1, 32
    if (_REENT_STDIN(rptr) != _REENT_STDIN(_GLOBAL_REENT)) {
42005d4b:	12b8      	l32i.n	a11, a2, 4
42005d4d:	ea8681        	l32r	a8, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
42005d50:	1888      	l32i.n	a8, a8, 4
42005d52:	041b87        	beq	a11, a8, 42005d5a <esp_cleanup_r+0x12>
        _fclose_r(rptr, _REENT_STDIN(rptr));
42005d55:	02ad      	mov.n	a10, a2
42005d57:	048865        	call8	4200a5dc <_fclose_r>
    }

    if (_REENT_STDOUT(rptr) != _REENT_STDOUT(_GLOBAL_REENT)) {
42005d5a:	0222b2        	l32i	a11, a2, 8
42005d5d:	ea8281        	l32r	a8, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
42005d60:	022882        	l32i	a8, a8, 8
42005d63:	051b87        	beq	a11, a8, 42005d6c <esp_cleanup_r+0x24>
        _fclose_r(rptr, _REENT_STDOUT(rptr));
42005d66:	20a220        	or	a10, a2, a2
42005d69:	048725        	call8	4200a5dc <_fclose_r>
    }

    if (_REENT_STDERR(rptr) != _REENT_STDERR(_GLOBAL_REENT)) {
42005d6c:	0322b2        	l32i	a11, a2, 12
42005d6f:	ea7e81        	l32r	a8, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
42005d72:	032882        	l32i	a8, a8, 12
42005d75:	051b87        	beq	a11, a8, 42005d7e <esp_cleanup_r+0x36>
        _fclose_r(rptr, _REENT_STDERR(rptr));
42005d78:	20a220        	or	a10, a2, a2
42005d7b:	048625        	call8	4200a5dc <_fclose_r>
    }
}
42005d7e:	f01d      	retw.n

42005d80 <raise_r_stub>:
{
42005d80:	004136        	entry	a1, 32
42005d83:	20a220        	or	a10, a2, a2
    _raise_r(rptr, 0);
42005d86:	00a0b2        	movi	a11, 0
42005d89:	ffece5        	call8	42005c58 <_raise_r>
}
42005d8c:	000090        	retw
	...

42005d90 <esp_libc_init>:
};

/* TODO IDF-11226 */
void esp_newlib_init(void) __attribute__((alias("esp_libc_init")));
void esp_libc_init(void)
{
42005d90:	004136        	entry	a1, 32
#if CONFIG_IDF_TARGET_ESP32
    syscall_table_ptr_pro = syscall_table_ptr_app = &s_stub_table;
#elif CONFIG_IDF_TARGET_ESP32S2
    syscall_table_ptr_pro = &s_stub_table;
#else
    syscall_table_ptr = &s_stub_table;
42005d93:	ea7681        	l32r	a8, 4200076c <_stext+0x74c> (3fceffd4 <syscall_table_ptr>)
42005d96:	ea7691        	l32r	a9, 42000770 <_stext+0x750> (3fc92008 <s_stub_table>)
42005d99:	0899      	s32i.n	a9, a8, 0
#endif

    memset(&__sglue, 0, sizeof(__sglue));
42005d9b:	cc0c      	movi.n	a12, 12
42005d9d:	0b0c      	movi.n	a11, 0
42005d9f:	ea75a1        	l32r	a10, 42000774 <_stext+0x754> (3fc92694 <__sglue>)
42005da2:	e95781        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42005da5:	0008e0        	callx8	a8
    _global_impure_ptr = _GLOBAL_REENT;
42005da8:	ea7081        	l32r	a8, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
42005dab:	ea7391        	l32r	a9, 42000778 <_stext+0x758> (3fceffd0 <_global_impure_ptr>)
42005dae:	0989      	s32i.n	a8, a9, 0

    /* Ensure that the initialization of sfp is prevented until esp_newlib_init_global_stdio() is explicitly invoked. */
    _GLOBAL_REENT->__cleanup = esp_cleanup_r;
42005db0:	ea7391        	l32r	a9, 4200077c <_stext+0x75c> (42005d48 <esp_cleanup_r>)
42005db3:	a899      	s32i.n	a9, a8, 40
    _REENT_SDIDINIT(_GLOBAL_REENT) = 1;
42005db5:	190c      	movi.n	a9, 1
42005db7:	6899      	s32i.n	a9, a8, 24

    environ = malloc(sizeof(char*));
42005db9:	4a0c      	movi.n	a10, 4
42005dbb:	ea7281        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
42005dbe:	0008e0        	callx8	a8
42005dc1:	ea6f81        	l32r	a8, 42000780 <_stext+0x760> (3fc92690 <environ>)
42005dc4:	08a9      	s32i.n	a10, a8, 0
    if (environ == 0) {
42005dc6:	4acc      	bnez.n	a10, 42005dce <esp_libc_init+0x3e>
        // if allocation fails this early in startup process, there's nothing else other than to panic.
        abort();
42005dc8:	e8cb81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42005dcb:	0008e0        	callx8	a8
    }
    environ[0] = NULL;
42005dce:	00a082        	movi	a8, 0
42005dd1:	006a82        	s32i	a8, a10, 0

    esp_libc_locks_init();
42005dd4:	ffc6e5        	call8	42005a44 <esp_libc_locks_init>
}
42005dd7:	000090        	retw
	...

42005ddc <esp_libc_init_global_stdio>:
 * Called from startup code and FreeRTOS, not intended to be called from
 * application code.
 */
#if CONFIG_VFS_SUPPORT_IO
void esp_libc_init_global_stdio(const char *stdio_dev)
{
42005ddc:	004136        	entry	a1, 32
    _REENT_STDIN(_GLOBAL_REENT) = fopen(stdio_dev, "r");
42005ddf:	ea6ab1        	l32r	a11, 42000788 <_stext+0x768> (3c020d4c <_flash_rodata_start+0xc2c>)
42005de2:	02ad      	mov.n	a10, a2
42005de4:	04d765        	call8	4200ab5c <fopen>
42005de7:	ea6071        	l32r	a7, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
42005dea:	17a9      	s32i.n	a10, a7, 4
    _REENT_STDOUT(_GLOBAL_REENT) = fopen(stdio_dev, "w");
42005dec:	ea68b1        	l32r	a11, 4200078c <_stext+0x76c> (3c024ea0 <_flash_rodata_start+0x4d80>)
42005def:	02ad      	mov.n	a10, a2
42005df1:	04d6a5        	call8	4200ab5c <fopen>
42005df4:	27a9      	s32i.n	a10, a7, 8
    _REENT_STDERR(_GLOBAL_REENT) = fopen(stdio_dev, "w");
42005df6:	ea65b1        	l32r	a11, 4200078c <_stext+0x76c> (3c024ea0 <_flash_rodata_start+0x4d80>)
42005df9:	20a220        	or	a10, a2, a2
42005dfc:	04d5e5        	call8	4200ab5c <fopen>
42005dff:	37a9      	s32i.n	a10, a7, 12
    - Thus, we call the toolchain version of __swsetup_r() now (before any printf calls are made) to setup all of the
      file pointers. Thus, the ROM newlib code will never call the ROM version of __swsetup_r().
    - See IDFGH-7728 for more details
    */
    extern int __swsetup_r(struct _reent *, FILE *);
    __swsetup_r(_GLOBAL_REENT, _REENT_STDIN(_GLOBAL_REENT));
42005e01:	17b8      	l32i.n	a11, a7, 4
42005e03:	07ad      	mov.n	a10, a7
42005e05:	0523a5        	call8	4200b040 <__swsetup_r>
    __swsetup_r(_GLOBAL_REENT, _REENT_STDOUT(_GLOBAL_REENT));
42005e08:	27b8      	l32i.n	a11, a7, 8
42005e0a:	07ad      	mov.n	a10, a7
42005e0c:	052325        	call8	4200b040 <__swsetup_r>
    __swsetup_r(_GLOBAL_REENT, _REENT_STDERR(_GLOBAL_REENT));
42005e0f:	37b8      	l32i.n	a11, a7, 12
42005e11:	07ad      	mov.n	a10, a7
42005e13:	0522e5        	call8	4200b040 <__swsetup_r>
#endif /* ESP_ROM_NEEDS_SWSETUP_WORKAROUND */
}
42005e16:	f01d      	retw.n

42005e18 <pthread_key_create>:
// Type for the head of the list, as saved as a FreeRTOS thread local storage pointer
SLIST_HEAD(values_list_t_, value_entry_t_);
typedef struct values_list_t_ values_list_t;

int pthread_key_create(pthread_key_t *key, pthread_destructor_t destructor)
{
42005e18:	004136        	entry	a1, 32
    key_entry_t *new_key = malloc(sizeof(key_entry_t));
42005e1b:	0ca0a2        	movi	a10, 12
42005e1e:	ea5981        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
42005e21:	0008e0        	callx8	a8
42005e24:	0a7d      	mov.n	a7, a10
    if (new_key == NULL) {
42005e26:	7abc      	beqz.n	a10, 42005e61 <pthread_key_create+0x49>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
42005e28:	ffafb2        	movi	a11, -1
42005e2b:	ea59a1        	l32r	a10, 42000790 <_stext+0x770> (3fc920a4 <s_keys_lock>)
42005e2e:	e97881        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42005e31:	0008e0        	callx8	a8
        return ENOMEM;
    }

    portENTER_CRITICAL(&s_keys_lock);

    const key_entry_t *head = SLIST_FIRST(&s_keys);
42005e34:	ea5881        	l32r	a8, 42000794 <_stext+0x774> (3fc94ed0 <s_keys>)
42005e37:	0888      	l32i.n	a8, a8, 0
    new_key->key = (head == NULL) ? 1 : (head->key + 1);
42005e39:	588c      	beqz.n	a8, 42005e42 <pthread_key_create+0x2a>
42005e3b:	0888      	l32i.n	a8, a8, 0
42005e3d:	881b      	addi.n	a8, a8, 1
42005e3f:	000046        	j	42005e44 <pthread_key_create+0x2c>
42005e42:	180c      	movi.n	a8, 1
42005e44:	0789      	s32i.n	a8, a7, 0
    new_key->destructor = destructor;
42005e46:	1739      	s32i.n	a3, a7, 4
    *key = new_key->key;
42005e48:	0289      	s32i.n	a8, a2, 0

    SLIST_INSERT_HEAD(&s_keys, new_key, next);
42005e4a:	ea5281        	l32r	a8, 42000794 <_stext+0x774> (3fc94ed0 <s_keys>)
42005e4d:	0898      	l32i.n	a9, a8, 0
42005e4f:	2799      	s32i.n	a9, a7, 8
42005e51:	0879      	s32i.n	a7, a8, 0

    portEXIT_CRITICAL(&s_keys_lock);
42005e53:	ea4fa1        	l32r	a10, 42000790 <_stext+0x770> (3fc920a4 <s_keys_lock>)
42005e56:	e96f81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42005e59:	0008e0        	callx8	a8
    return 0;
42005e5c:	020c      	movi.n	a2, 0
42005e5e:	000046        	j	42005e63 <pthread_key_create+0x4b>
        return ENOMEM;
42005e61:	c20c      	movi.n	a2, 12
}
42005e63:	f01d      	retw.n
42005e65:	000000        	ill

42005e68 <esp_timer_early_init>:
#include "esp_private/startup_internal.h"
#include "esp_timer_impl.h"
#include "sdkconfig.h"

esp_err_t esp_timer_early_init(void)
{
42005e68:	004136        	entry	a1, 32
    esp_timer_impl_early_init();
42005e6b:	000765        	call8	42005ee0 <esp_timer_impl_early_init>
#if CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
    esp_timer_impl_init_system_time();
42005e6e:	000165        	call8	42005e84 <esp_timer_impl_init_system_time>
#endif
    return ESP_OK;
}
42005e71:	00a022        	movi	a2, 0
42005e74:	000090        	retw
	...

42005e78 <__esp_system_init_fn_esp_timer_init_nonos>:
 *
 * Another initialization function, esp_timer_init_nonos (which initializes ISR and task),
 * is called only if other code calls the esp_timer API.
 */
ESP_SYSTEM_INIT_FN(esp_timer_init_nonos, CORE, BIT(0), 101)
{
42005e78:	004136        	entry	a1, 32
    return esp_timer_early_init();
42005e7b:	fffee5        	call8	42005e68 <esp_timer_early_init>
}
42005e7e:	0a2d      	mov.n	a2, a10
42005e80:	f01d      	retw.n
	...

42005e84 <esp_timer_impl_init_system_time>:
{
42005e84:	004136        	entry	a1, 32
    s_correction_us = esp_rtc_get_time_us() - g_startup_time - esp_timer_impl_get_time();
42005e87:	fd25e5        	call8	420030e4 <esp_rtc_get_time_us>
42005e8a:	ea4391        	l32r	a9, 42000798 <_stext+0x778> (3fc948b8 <g_startup_time>)
42005e8d:	002982        	l32i	a8, a9, 0
42005e90:	012992        	l32i	a9, a9, 4
42005e93:	c06b90        	sub	a6, a11, a9
42005e96:	02ba87        	bgeu	a10, a8, 42005e9c <esp_timer_impl_init_system_time+0x18>
42005e99:	ffc662        	addi	a6, a6, -1
42005e9c:	c07a80        	sub	a7, a10, a8
42005e9f:	ea4381        	l32r	a8, 420007ac <_stext+0x78c> (40376c38 <esp_timer_get_time>)
42005ea2:	0008e0        	callx8	a8
42005ea5:	c066b0        	sub	a6, a6, a11
42005ea8:	01b7a7        	bgeu	a7, a10, 42005ead <esp_timer_impl_init_system_time+0x29>
42005eab:	660b      	addi.n	a6, a6, -1
42005ead:	c077a0        	sub	a7, a7, a10
42005eb0:	ea3b81        	l32r	a8, 4200079c <_stext+0x77c> (3fc94ed8 <s_correction_us>)
42005eb3:	0879      	s32i.n	a7, a8, 0
42005eb5:	016862        	s32i	a6, a8, 4
    esp_err_t err = esp_register_shutdown_handler(esp_sync_timekeeping_timers);
42005eb8:	ea3aa1        	l32r	a10, 420007a0 <_stext+0x780> (42005cf4 <esp_sync_timekeeping_timers>)
42005ebb:	fb3de5        	call8	42001298 <esp_register_shutdown_handler>
42005ebe:	0a7d      	mov.n	a7, a10
    if (err != ESP_OK) {
42005ec0:	8a9c      	beqz.n	a10, 42005edc <esp_timer_impl_init_system_time+0x58>
        ESP_LOGW(TAG, "Register shutdown handler failed, err = 0x%x", err);
42005ec2:	e86781        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42005ec5:	0008e0        	callx8	a8
42005ec8:	ea37b1        	l32r	a11, 420007a4 <_stext+0x784> (3c024ea4 <_flash_rodata_start+0x4d84>)
42005ecb:	07fd      	mov.n	a15, a7
42005ecd:	0bed      	mov.n	a14, a11
42005ecf:	0add      	mov.n	a13, a10
42005ed1:	ea35c1        	l32r	a12, 420007a8 <_stext+0x788> (3c024eb0 <_flash_rodata_start+0x4d90>)
42005ed4:	2a0c      	movi.n	a10, 2
42005ed6:	e86f81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42005ed9:	0008e0        	callx8	a8
}
42005edc:	f01d      	retw.n
	...

42005ee0 <esp_timer_impl_early_init>:
    systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER, time_diff_us);
    portEXIT_CRITICAL_SAFE(&s_time_update_lock);
}

esp_err_t esp_timer_impl_early_init(void)
{
42005ee0:	006136        	entry	a1, 48
    PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_SYSTIMER_MODULE, ref_count) {
42005ee3:	170c      	movi.n	a7, 1
42005ee5:	000f46        	j	42005f26 <esp_timer_impl_early_init+0x46>
    SYSTEM.perip_clk_en0.systimer_clk_en = enable;
42005ee8:	e8cc81        	l32r	a8, 42000218 <_stext+0x1f8> (600c0000 <SYSTEM>)
42005eeb:	0020c0        	memw
42005eee:	6898      	l32i.n	a9, a8, 24
42005ef0:	e950a1        	l32r	a10, 42000430 <_stext+0x410> (20000000 <UserFrameTotalSize+0x1fffff00>)
42005ef3:	2099a0        	or	a9, a9, a10
42005ef6:	0020c0        	memw
42005ef9:	6899      	s32i.n	a9, a8, 24
    SYSTEM.perip_rst_en0.systimer_rst = 1;
42005efb:	0020c0        	memw
42005efe:	8898      	l32i.n	a9, a8, 32
42005f00:	2099a0        	or	a9, a9, a10
42005f03:	0020c0        	memw
42005f06:	8899      	s32i.n	a9, a8, 32
    SYSTEM.perip_rst_en0.systimer_rst = 0;
42005f08:	0020c0        	memw
42005f0b:	8898      	l32i.n	a9, a8, 32
42005f0d:	e949a1        	l32r	a10, 42000434 <_stext+0x414> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42005f10:	1099a0        	and	a9, a9, a10
42005f13:	0020c0        	memw
42005f16:	8899      	s32i.n	a9, a8, 32
42005f18:	24a0a2        	movi	a10, 36
42005f1b:	e8c781        	l32r	a8, 42000238 <_stext+0x218> (403766cc <periph_rcc_acquire_exit>)
42005f1e:	0008e0        	callx8	a8
42005f21:	770b      	addi.n	a7, a7, -1
42005f23:	747070        	extui	a7, a7, 0, 8
42005f26:	e78c      	beqz.n	a7, 42005f38 <esp_timer_impl_early_init+0x58>
42005f28:	4a2c      	movi.n	a10, 36
42005f2a:	e8c481        	l32r	a8, 4200023c <_stext+0x21c> (403766bc <periph_rcc_acquire_enter>)
42005f2d:	0008e0        	callx8	a8
42005f30:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
42005f32:	fb2a16        	beqz	a10, 42005ee8 <esp_timer_impl_early_init+0x8>
42005f35:	fff7c6        	j	42005f18 <esp_timer_impl_early_init+0x38>
            systimer_ll_enable_bus_clock(true);
            systimer_ll_reset_register();
        }
    }
    systimer_hal_tick_rate_ops_t ops = {
42005f38:	ea1e81        	l32r	a8, 420007b0 <_stext+0x790> (3c0282e0 <__func__$0+0xc>)
42005f3b:	0898      	l32i.n	a9, a8, 0
42005f3d:	1888      	l32i.n	a8, a8, 4
42005f3f:	0199      	s32i.n	a9, a1, 0
42005f41:	1189      	s32i.n	a8, a1, 4
        .ticks_to_us = systimer_ticks_to_us,
        .us_to_ticks = systimer_us_to_ticks,
    };
    systimer_hal_init(&systimer_hal);
42005f43:	ea1c71        	l32r	a7, 420007b4 <_stext+0x794> (3fc94ee0 <systimer_hal>)
42005f46:	07ad      	mov.n	a10, a7
42005f48:	ea1c81        	l32r	a8, 420007b8 <_stext+0x798> (4037e378 <systimer_hal_init>)
42005f4b:	0008e0        	callx8	a8
    systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
42005f4e:	01bd      	mov.n	a11, a1
42005f50:	07ad      	mov.n	a10, a7
42005f52:	ea1a81        	l32r	a8, 420007bc <_stext+0x79c> (4037e4fc <systimer_hal_set_tick_rate_ops>)
42005f55:	0008e0        	callx8	a8
           "update the step for xtal to support other XTAL:APB frequency ratios");
    systimer_hal_set_steps_per_tick(&systimer_hal, 0, 2); // for xtal
    systimer_hal_set_steps_per_tick(&systimer_hal, 1, 1); // for pll
#endif

    systimer_hal_enable_counter(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER);
42005f58:	0b0c      	movi.n	a11, 0
42005f5a:	07ad      	mov.n	a10, a7
42005f5c:	ea1981        	l32r	a8, 420007c0 <_stext+0x7a0> (4037e52c <systimer_hal_enable_counter>)
42005f5f:	0008e0        	callx8	a8
    systimer_hal_select_alarm_mode(&systimer_hal, SYSTIMER_ALARM_ESPTIMER, SYSTIMER_ALARM_MODE_ONESHOT);
42005f62:	0c0c      	movi.n	a12, 0
42005f64:	2b0c      	movi.n	a11, 2
42005f66:	07ad      	mov.n	a10, a7
42005f68:	ea1781        	l32r	a8, 420007c4 <_stext+0x7a4> (4037e4bc <systimer_hal_select_alarm_mode>)
42005f6b:	0008e0        	callx8	a8
    systimer_hal_connect_alarm_counter(&systimer_hal, SYSTIMER_ALARM_ESPTIMER, SYSTIMER_COUNTER_ESPTIMER);
42005f6e:	0c0c      	movi.n	a12, 0
42005f70:	2b0c      	movi.n	a11, 2
42005f72:	07ad      	mov.n	a10, a7
42005f74:	ea1581        	l32r	a8, 420007c8 <_stext+0x7a8> (4037e550 <systimer_hal_connect_alarm_counter>)
42005f77:	0008e0        	callx8	a8

    for (unsigned cpuid = 0; cpuid < SOC_CPU_CORES_NUM; ++cpuid) {
42005f7a:	070c      	movi.n	a7, 0
42005f7c:	000486        	j	42005f92 <esp_timer_impl_early_init+0xb2>
42005f7f:	0c0000        	lsi	f0, a0, 48
        bool can_stall = (cpuid < portNUM_PROCESSORS);
        systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER, cpuid, can_stall);
42005f82:	cd1d      	lsi	f1, a13, 52
42005f84:	0b0c07        	bnone	a12, a0, 42005f93 <esp_timer_impl_early_init+0xb3>
42005f87:	ea0ba1        	l32r	a10, 420007b4 <_stext+0x794> (3fc94ee0 <systimer_hal>)
42005f8a:	ea1081        	l32r	a8, 420007cc <_stext+0x7ac> (4037e574 <systimer_hal_counter_can_stall_by_cpu>)
42005f8d:	0008e0        	callx8	a8
    for (unsigned cpuid = 0; cpuid < SOC_CPU_CORES_NUM; ++cpuid) {
42005f90:	771b      	addi.n	a7, a7, 1
42005f92:	eb27b6        	bltui	a7, 2, 42005f81 <esp_timer_impl_early_init+0xa1>
    }

    return ESP_OK;
}
42005f95:	020c      	movi.n	a2, 0
42005f97:	f01d      	retw.n
42005f99:	000000        	ill

42005f9c <__esp_system_init_fn_usb_serial_jtag_conn_status_init>:

ESP_SYSTEM_INIT_FN(usb_serial_jtag_conn_status_init, SECONDARY, BIT(0), 230)
{
42005f9c:	004136        	entry	a1, 32
    // We always assume it is connected at first, so acquires the lock to avoid auto light sleep
    esp_pm_lock_acquire(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
// TODO: esp32p4 USJ rely on SPLL, if it will also be disabled during sleep, we need to call spll_add_consumer? IDF-9947
    rtc_clk_bbpll_add_consumer();
42005f9f:	ea0f81        	l32r	a8, 420007dc <_stext+0x7bc> (403786ec <rtc_clk_bbpll_add_consumer>)
42005fa2:	0008e0        	callx8	a8
#endif
    s_usb_serial_jtag_conn_status = true;
42005fa5:	ea0a81        	l32r	a8, 420007d0 <_stext+0x7b0> (3fc94ef0 <s_usb_serial_jtag_conn_status>)
42005fa8:	01a092        	movi	a9, 1
42005fab:	0020c0        	memw
42005fae:	004892        	s8i	a9, a8, 0
    remaining_allowed_no_sof_ticks = ALLOWED_NO_SOF_TICKS;
42005fb1:	ea0881        	l32r	a8, 420007d4 <_stext+0x7b4> (3fc94eec <remaining_allowed_no_sof_ticks>)
42005fb4:	00a092        	movi	a9, 0
42005fb7:	006892        	s32i	a9, a8, 0

    return esp_register_freertos_tick_hook(usb_serial_jtag_sof_tick_hook);
42005fba:	ea07a1        	l32r	a10, 420007d8 <_stext+0x7b8> (40376c50 <usb_serial_jtag_sof_tick_hook>)
42005fbd:	fc7a65        	call8	42002764 <esp_register_freertos_tick_hook>
}
42005fc0:	0a2d      	mov.n	a2, a10
42005fc2:	f01d      	retw.n

42005fc4 <usb_serial_jtag_open>:
static esp_err_t usb_serial_jtag_end_select(void *end_select_args);

#endif // CONFIG_VFS_SUPPORT_SELECT

static int usb_serial_jtag_open(const char * path, int flags, int mode)
{
42005fc4:	004136        	entry	a1, 32
    s_ctx.non_blocking = ((flags & O_NONBLOCK) == O_NONBLOCK);
42005fc7:	043e30        	extui	a3, a3, 14, 1
42005fca:	ea0581        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42005fcd:	0c4832        	s8i	a3, a8, 12
    return USJ_LOCAL_FD;
}
42005fd0:	020c      	movi.n	a2, 0
42005fd2:	f01d      	retw.n

42005fd4 <usb_serial_jtag_rx_char_no_driver>:
    } while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US);

}

static int usb_serial_jtag_rx_char_no_driver(int fd)
{
42005fd4:	006136        	entry	a1, 48
    for (i = 0; i < rd_len; i++) {
42005fd7:	080c      	movi.n	a8, 0
42005fd9:	000646        	j	42005ff6 <usb_serial_jtag_rx_char_no_driver+0x22>
        if (!USB_SERIAL_JTAG.ep1_conf.serial_out_ep_data_avail) break;
42005fdc:	e89d91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42005fdf:	0020c0        	memw
42005fe2:	1998      	l32i.n	a9, a9, 4
42005fe4:	116927        	bbci	a9, 2, 42005ff9 <usb_serial_jtag_rx_char_no_driver+0x25>
        buf[i] = USB_SERIAL_JTAG.ep1.rdwr_byte;
42005fe7:	e89a91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42005fea:	0020c0        	memw
42005fed:	09a8      	l32i.n	a10, a9, 0
42005fef:	918a      	add.n	a9, a1, a8
42005ff1:	0049a2        	s8i	a10, a9, 0
    for (i = 0; i < rd_len; i++) {
42005ff4:	881b      	addi.n	a8, a8, 1
42005ff6:	fe2816        	beqz	a8, 42005fdc <usb_serial_jtag_rx_char_no_driver+0x8>
    uint8_t c;
    int l = usb_serial_jtag_ll_read_rxfifo(&c, 1);
    if (l == 0) {
42005ff9:	488c      	beqz.n	a8, 42006001 <usb_serial_jtag_rx_char_no_driver+0x2d>
        return NONE;
    }
    return c;
42005ffb:	000122        	l8ui	a2, a1, 0
42005ffe:	000046        	j	42006003 <usb_serial_jtag_rx_char_no_driver+0x2f>
        return NONE;
42006001:	f27c      	movi.n	a2, -1
}
42006003:	f01d      	retw.n
42006005:	000000        	ill

42006008 <usb_serial_jtag_read_char>:
/* Helper function which returns a previous character or reads a new one from
 * the port. Previous character can be returned ("pushed back") using
 * usb_serial_jtag_return_char function.
 */
static int usb_serial_jtag_read_char(int fd)
{
42006008:	004136        	entry	a1, 32
4200600b:	02ad      	mov.n	a10, a2
    /* return character from peek buffer, if it is there */
    if (s_ctx.peek_char != NONE) {
4200600d:	e9f481        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006010:	0828      	l32i.n	a2, a8, 0
42006012:	060226        	beqi	a2, -1, 4200601c <usb_serial_jtag_read_char+0x14>
        int c = s_ctx.peek_char;
        s_ctx.peek_char = NONE;
42006015:	f97c      	movi.n	a9, -1
42006017:	0899      	s32i.n	a9, a8, 0
        return c;
42006019:	000246        	j	42006026 <usb_serial_jtag_read_char+0x1e>
    }
    return s_ctx.rx_func(fd);
4200601c:	e9f181        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
4200601f:	7888      	l32i.n	a8, a8, 28
42006021:	0008e0        	callx8	a8
42006024:	0a2d      	mov.n	a2, a10
}
42006026:	f01d      	retw.n

42006028 <usb_serial_jtag_wait_tx_done_no_driver>:
    }
    return result;
}

static int usb_serial_jtag_wait_tx_done_no_driver(int fd)
{
42006028:	004136        	entry	a1, 32
 *
 * @return na
 */
static inline void usb_serial_jtag_ll_txfifo_flush(void)
{
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
4200602b:	e88991        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
4200602e:	0020c0        	memw
42006031:	1988      	l32i.n	a8, a9, 4
42006033:	1a0c      	movi.n	a10, 1
42006035:	2088a0        	or	a8, a8, a10
42006038:	0020c0        	memw
4200603b:	1989      	s32i.n	a8, a9, 4
}
4200603d:	000bc6        	j	42006070 <usb_serial_jtag_wait_tx_done_no_driver+0x48>
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
42006040:	e88481        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
42006043:	0020c0        	memw
42006046:	1888      	l32i.n	a8, a8, 4
    usb_serial_jtag_ll_txfifo_flush();
    //Wait for the host to have picked up the buffer, but honour the timeout in
    //case the host is not listening.
    while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US) {
        if (usb_serial_jtag_ll_txfifo_writable()) {
42006048:	246817        	bbci	a8, 1, 42006070 <usb_serial_jtag_wait_tx_done_no_driver+0x48>
            s_ctx.last_tx_ts = esp_timer_get_time();
4200604b:	e9d881        	l32r	a8, 420007ac <_stext+0x78c> (40376c38 <esp_timer_get_time>)
4200604e:	0008e0        	callx8	a8
42006051:	e9e381        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006054:	a8a9      	s32i.n	a10, a8, 40
42006056:	b8b9      	s32i.n	a11, a8, 44
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
42006058:	e87e91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
4200605b:	0020c0        	memw
4200605e:	1988      	l32i.n	a8, a9, 4
42006060:	1a0c      	movi.n	a10, 1
42006062:	2088a0        	or	a8, a8, a10
42006065:	0020c0        	memw
42006068:	1989      	s32i.n	a8, a9, 4
            //The last transfer may have been a 64-byte one. Flush again in order to
            //send a 0-byte packet to indicate the end of the USB transfer, otherwise
            //those 64 bytes will get stuck in the hosts buffer.
            usb_serial_jtag_ll_txfifo_flush();
            return 0;
4200606a:	020c      	movi.n	a2, 0
4200606c:	000986        	j	42006096 <usb_serial_jtag_wait_tx_done_no_driver+0x6e>
4200606f:	cf8100        	f64cmph	a8, a1, a0, 12
    while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US) {
42006072:	e0e9      	s32i.n	a14, a0, 56
42006074:	0008      	l32i.n	a0, a0, 0
42006076:	e9da91        	l32r	a9, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006079:	a988      	l32i.n	a8, a9, 40
4200607b:	b998      	l32i.n	a9, a9, 44
4200607d:	c0bb90        	sub	a11, a11, a9
42006080:	01ba87        	bgeu	a10, a8, 42006085 <usb_serial_jtag_wait_tx_done_no_driver+0x5d>
42006083:	bb0b      	addi.n	a11, a11, -1
42006085:	c0aa80        	sub	a10, a10, a8
42006088:	081be6        	bgei	a11, 1, 42006094 <usb_serial_jtag_wait_tx_done_no_driver+0x6c>
4200608b:	fb1b56        	bnez	a11, 42006040 <usb_serial_jtag_wait_tx_done_no_driver+0x18>
4200608e:	e9d581        	l32r	a8, 420007e4 <_stext+0x7c4> (c34f <UserFrameTotalSize+0xc24f>)
42006091:	abb8a7        	bgeu	a8, a10, 42006040 <usb_serial_jtag_wait_tx_done_no_driver+0x18>
        }
    }
    //Timeout. Host probably isn't listening.
    return EIO;
42006094:	520c      	movi.n	a2, 5
}
42006096:	f01d      	retw.n

42006098 <usb_serial_jtag_tx_char_no_driver>:
{
42006098:	006136        	entry	a1, 48
    uint8_t cc = (uint8_t)c;
4200609b:	004132        	s8i	a3, a1, 0
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
4200609e:	e86c81        	l32r	a8, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420060a1:	0020c0        	memw
420060a4:	1888      	l32i.n	a8, a8, 4
        if (usb_serial_jtag_ll_txfifo_writable()) {
420060a6:	4b6817        	bbci	a8, 1, 420060f5 <usb_serial_jtag_tx_char_no_driver+0x5d>
420060a9:	000786        	j	420060cb <usb_serial_jtag_tx_char_no_driver+0x33>
        if (!USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free) break;
420060ac:	e86991        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420060af:	0020c0        	memw
420060b2:	1998      	l32i.n	a9, a9, 4
420060b4:	186917        	bbci	a9, 1, 420060d0 <usb_serial_jtag_tx_char_no_driver+0x38>
        USB_SERIAL_JTAG.ep1.rdwr_byte = buf[i];
420060b7:	918a      	add.n	a9, a1, a8
420060b9:	0009a2        	l8ui	a10, a9, 0
420060bc:	e86591        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420060bf:	0020c0        	memw
420060c2:	09a9      	s32i.n	a10, a9, 0
    for (i = 0; i < wr_len; i++) {
420060c4:	881b      	addi.n	a8, a8, 1
420060c6:	0000c6        	j	420060cd <usb_serial_jtag_tx_char_no_driver+0x35>
420060c9:	0c0000        	lsi	f0, a0, 48
420060cc:	1608      	l32i.n	a0, a6, 4
420060ce:	fdb8      	l32i.n	a11, a13, 60
            if (c == '\n') {
420060d0:	119366        	bnei	a3, 10, 420060e5 <usb_serial_jtag_tx_char_no_driver+0x4d>
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
420060d3:	e85f91        	l32r	a9, 42000250 <_stext+0x230> (60038000 <USB_SERIAL_JTAG>)
420060d6:	0020c0        	memw
420060d9:	1988      	l32i.n	a8, a9, 4
420060db:	1a0c      	movi.n	a10, 1
420060dd:	2088a0        	or	a8, a8, a10
420060e0:	0020c0        	memw
420060e3:	1989      	s32i.n	a8, a9, 4
            s_ctx.last_tx_ts = esp_timer_get_time();
420060e5:	e9b181        	l32r	a8, 420007ac <_stext+0x78c> (40376c38 <esp_timer_get_time>)
420060e8:	0008e0        	callx8	a8
420060eb:	e9bd81        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
420060ee:	a8a9      	s32i.n	a10, a8, 40
420060f0:	b8b9      	s32i.n	a11, a8, 44
            break;
420060f2:	000986        	j	4200611c <usb_serial_jtag_tx_char_no_driver+0x84>
    } while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US);
420060f5:	e9ad81        	l32r	a8, 420007ac <_stext+0x78c> (40376c38 <esp_timer_get_time>)
420060f8:	0008e0        	callx8	a8
420060fb:	e9b991        	l32r	a9, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
420060fe:	0a2982        	l32i	a8, a9, 40
42006101:	0b2992        	l32i	a9, a9, 44
42006104:	c0bb90        	sub	a11, a11, a9
42006107:	02ba87        	bgeu	a10, a8, 4200610d <usb_serial_jtag_tx_char_no_driver+0x75>
4200610a:	ffcbb2        	addi	a11, a11, -1
4200610d:	c0aa80        	sub	a10, a10, a8
42006110:	081be6        	bgei	a11, 1, 4200611c <usb_serial_jtag_tx_char_no_driver+0x84>
42006113:	f87b56        	bnez	a11, 4200609e <usb_serial_jtag_tx_char_no_driver+0x6>
42006116:	e9b381        	l32r	a8, 420007e4 <_stext+0x7c4> (c34f <UserFrameTotalSize+0xc24f>)
42006119:	81b8a7        	bgeu	a8, a10, 4200609e <usb_serial_jtag_tx_char_no_driver+0x6>
}
4200611c:	f01d      	retw.n
	...

42006120 <unregister_select>:

    return ret;
}

static esp_err_t unregister_select(usb_serial_jtag_select_args_t *args)
{
42006120:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    if (args) {
42006123:	069216        	beqz	a2, 42006190 <unregister_select+0x70>
42006126:	fb7c      	movi.n	a11, -1
42006128:	e9b0a1        	l32r	a10, 420007e8 <_stext+0x7c8> (3fc920ac <s_registered_select_lock>)
4200612b:	e8b981        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200612e:	0008e0        	callx8	a8
        ret = ESP_ERR_INVALID_STATE;
        portENTER_CRITICAL(&s_registered_select_lock);
        for (int i = 0; i < s_registered_select_num; ++i) {
42006131:	080c      	movi.n	a8, 0
42006133:	000ec6        	j	42006172 <unregister_select+0x52>
42006136:	a10000        	sll	a0, a0
            if (s_registered_selects[i] == args) {
42006139:	e9ad      	lsi	f10, a9, 36
4200613b:	0aa8      	l32i.n	a10, a10, 0
4200613d:	a0b8a0        	addx4	a11, a8, a10
42006140:	0bc8      	l32i.n	a12, a11, 0
42006142:	2a9c27        	bne	a12, a2, 42006170 <unregister_select+0x50>
                const int new_size = s_registered_select_num - 1;
42006145:	290b      	addi.n	a2, a9, -1
                // The item is removed by overwriting it with the last item. The subsequent rellocation will drop the
                // last item.
                s_registered_selects[i] = s_registered_selects[new_size];
42006147:	a082a0        	addx4	a8, a2, a10
4200614a:	0888      	l32i.n	a8, a8, 0
4200614c:	006b82        	s32i	a8, a11, 0
                s_registered_selects = heap_caps_realloc(s_registered_selects, new_size * sizeof(usb_serial_jtag_select_args_t *), USJ_VFS_MALLOC_FLAGS);
4200614f:	e9a8c1        	l32r	a12, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
42006152:	11b2e0        	slli	a11, a2, 2
42006155:	e9a881        	l32r	a8, 420007f8 <_stext+0x7d8> (40375fcc <heap_caps_realloc>)
42006158:	0008e0        	callx8	a8
4200615b:	e9a481        	l32r	a8, 420007ec <_stext+0x7cc> (3fc94ef8 <s_registered_selects>)
4200615e:	08a9      	s32i.n	a10, a8, 0
                // Shrinking a buffer with realloc is guaranteed to succeed.
                s_registered_select_num = new_size;
42006160:	e9a581        	l32r	a8, 420007f4 <_stext+0x7d4> (3fc94ef4 <s_registered_select_num>)
42006163:	0829      	s32i.n	a2, a8, 0

                /* when the last select is unregistered, also unregister the callback  */
                if (s_registered_select_num == 0) {
42006165:	82dc      	bnez.n	a2, 42006181 <unregister_select+0x61>
                    usb_serial_jtag_set_select_notif_callback(NULL);
42006167:	0a0c      	movi.n	a10, 0
42006169:	004de5        	call8	42006648 <usb_serial_jtag_set_select_notif_callback>
4200616c:	0004c6        	j	42006183 <unregister_select+0x63>
4200616f:	881b00        	lsi	f0, a11, 0x220
        for (int i = 0; i < s_registered_select_num; ++i) {
42006172:	e9a091        	l32r	a9, 420007f4 <_stext+0x7d4> (3fc94ef4 <s_registered_select_num>)
42006175:	0998      	l32i.n	a9, a9, 0
42006177:	bd2897        	blt	a8, a9, 42006138 <unregister_select+0x18>
        ret = ESP_ERR_INVALID_STATE;
4200617a:	03a122        	movi	a2, 0x103
4200617d:	000086        	j	42006183 <unregister_select+0x63>
42006180:	020c00        	andb	b0, b12, b0

                ret = ESP_OK;
                break;
            }
        }
        portEXIT_CRITICAL(&s_registered_select_lock);
42006183:	e999a1        	l32r	a10, 420007e8 <_stext+0x7c8> (3fc920ac <s_registered_select_lock>)
42006186:	e8a381        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42006189:	0008e0        	callx8	a8
4200618c:	000086        	j	42006192 <unregister_select+0x72>
4200618f:	020c00        	andb	b0, b12, b0
    }
    return ret;
}
42006192:	f01d      	retw.n

42006194 <usb_serial_jtag_end_select>:
    *end_select_args = args;
    return ESP_OK;
}

static esp_err_t usb_serial_jtag_end_select(void *end_select_args)
{
42006194:	004136        	entry	a1, 32
42006197:	207220        	or	a7, a2, a2
    usb_serial_jtag_select_args_t *args = end_select_args;
    esp_err_t ret = unregister_select(args);
4200619a:	20a220        	or	a10, a2, a2
4200619d:	fff825        	call8	42006120 <unregister_select>
420061a0:	202aa0        	or	a2, a10, a10
    if (args) {
420061a3:	678c      	beqz.n	a7, 420061ad <usb_serial_jtag_end_select+0x19>
        free(args);
420061a5:	07ad      	mov.n	a10, a7
420061a7:	e8f081        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
420061aa:	0008e0        	callx8	a8
    }

    return ret;
}
420061ad:	f01d      	retw.n
	...

420061b0 <register_select>:
{
420061b0:	004136        	entry	a1, 32
    if (args) {
420061b3:	05c216        	beqz	a2, 42006213 <register_select+0x63>
420061b6:	ffafb2        	movi	a11, -1
420061b9:	e98ba1        	l32r	a10, 420007e8 <_stext+0x7c8> (3fc920ac <s_registered_select_lock>)
420061bc:	e89581        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420061bf:	0008e0        	callx8	a8
        const int new_size = s_registered_select_num + 1;
420061c2:	e98c81        	l32r	a8, 420007f4 <_stext+0x7d4> (3fc94ef4 <s_registered_select_num>)
420061c5:	002862        	l32i	a6, a8, 0
420061c8:	01c662        	addi	a6, a6, 1
        if ((new_selects = heap_caps_realloc(s_registered_selects, new_size * sizeof(usb_serial_jtag_select_args_t *), USJ_VFS_MALLOC_FLAGS)) == NULL) {
420061cb:	e989c1        	l32r	a12, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
420061ce:	11b6e0        	slli	a11, a6, 2
420061d1:	e98681        	l32r	a8, 420007ec <_stext+0x7cc> (3fc94ef8 <s_registered_selects>)
420061d4:	08a8      	l32i.n	a10, a8, 0
420061d6:	e98881        	l32r	a8, 420007f8 <_stext+0x7d8> (40375fcc <heap_caps_realloc>)
420061d9:	0008e0        	callx8	a8
420061dc:	0a7d      	mov.n	a7, a10
420061de:	2aac      	beqz.n	a10, 42006204 <register_select+0x54>
            if (s_registered_select_num == 0) {
420061e0:	e98581        	l32r	a8, 420007f4 <_stext+0x7d4> (3fc94ef4 <s_registered_select_num>)
420061e3:	0888      	l32i.n	a8, a8, 0
420061e5:	48cc      	bnez.n	a8, 420061ed <register_select+0x3d>
                usb_serial_jtag_set_select_notif_callback(select_notif_callback_isr);
420061e7:	e985a1        	l32r	a10, 420007fc <_stext+0x7dc> (42006304 <select_notif_callback_isr>)
420061ea:	0045e5        	call8	42006648 <usb_serial_jtag_set_select_notif_callback>
            s_registered_selects = new_selects;
420061ed:	e97f81        	l32r	a8, 420007ec <_stext+0x7cc> (3fc94ef8 <s_registered_selects>)
420061f0:	0879      	s32i.n	a7, a8, 0
            s_registered_selects[s_registered_select_num] = args;
420061f2:	e98091        	l32r	a9, 420007f4 <_stext+0x7d4> (3fc94ef4 <s_registered_select_num>)
420061f5:	0988      	l32i.n	a8, a9, 0
420061f7:	a08870        	addx4	a8, a8, a7
420061fa:	0829      	s32i.n	a2, a8, 0
            s_registered_select_num = new_size;
420061fc:	0969      	s32i.n	a6, a9, 0
            ret = ESP_OK;
420061fe:	020c      	movi.n	a2, 0
42006200:	0000c6        	j	42006207 <register_select+0x57>
42006203:	a12200        	sll	a2, a2
            ret = ESP_ERR_NO_MEM;
42006206:	78a101        	l32r	a0, 41fe448c <_coredump_iram_end+0x1c6258c>
        portEXIT_CRITICAL(&s_registered_select_lock);
42006209:	81e9      	s32i.n	a14, a1, 32
4200620b:	e0e882        	s32c1i	a8, a8, 0x380
4200620e:	0008      	l32i.n	a0, a0, 0
42006210:	000086        	j	42006216 <register_select+0x66>
    esp_err_t ret = ESP_ERR_INVALID_ARG;
42006213:	02a122        	movi	a2, 0x102
}
42006216:	f01d      	retw.n

42006218 <usb_serial_jtag_start_select>:
{
42006218:	006136        	entry	a1, 48
4200621b:	0169      	s32i.n	a6, a1, 0
4200621d:	1179      	s32i.n	a7, a1, 4
4200621f:	c168      	l32i.n	a6, a1, 48
    *end_select_args = NULL;
42006221:	080c      	movi.n	a8, 0
42006223:	0689      	s32i.n	a8, a6, 0
    if (!usb_serial_jtag_is_driver_installed()) {
42006225:	004125        	call8	42006638 <usb_serial_jtag_is_driver_installed>
42006228:	0c9a16        	beqz	a10, 420062f5 <usb_serial_jtag_start_select+0xdd>
    usb_serial_jtag_select_args_t *args = heap_caps_malloc(sizeof(usb_serial_jtag_select_args_t), USJ_VFS_MALLOC_FLAGS);
4200622b:	e971b1        	l32r	a11, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
4200622e:	ca2c      	movi.n	a10, 44
42006230:	e8bc81        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006233:	0008e0        	callx8	a8
42006236:	0a7d      	mov.n	a7, a10
    if (args == NULL) {
42006238:	0c0a16        	beqz	a10, 420062fc <usb_serial_jtag_start_select+0xe4>
    args->select_sem = select_sem;
4200623b:	0188      	l32i.n	a8, a1, 0
4200623d:	0a89      	s32i.n	a8, a10, 0
4200623f:	1188      	l32i.n	a8, a1, 4
42006241:	1a89      	s32i.n	a8, a10, 4
    args->readfds = readfds;
42006243:	2a39      	s32i.n	a3, a10, 8
    args->writefds = writefds;
42006245:	3a49      	s32i.n	a4, a10, 12
    args->errorfds = exceptfds;
42006247:	4a59      	s32i.n	a5, a10, 16
    args->readfds_orig = *readfds; // store the original values because they will be set to zero
42006249:	0398      	l32i.n	a9, a3, 0
4200624b:	1388      	l32i.n	a8, a3, 4
4200624d:	5a99      	s32i.n	a9, a10, 20
4200624f:	6a89      	s32i.n	a8, a10, 24
    args->writefds_orig = *writefds;
42006251:	0498      	l32i.n	a9, a4, 0
42006253:	1488      	l32i.n	a8, a4, 4
42006255:	7a99      	s32i.n	a9, a10, 28
42006257:	8a89      	s32i.n	a8, a10, 32
    args->errorfds_orig = *exceptfds;
42006259:	0598      	l32i.n	a9, a5, 0
4200625b:	1588      	l32i.n	a8, a5, 4
4200625d:	9a99      	s32i.n	a9, a10, 36
4200625f:	aa89      	s32i.n	a8, a10, 40
    FD_ZERO(readfds);
42006261:	280c      	movi.n	a8, 2
42006263:	000206        	j	4200626f <usb_serial_jtag_start_select+0x57>
42006266:	880b      	addi.n	a8, a8, -1
42006268:	a09830        	addx4	a9, a8, a3
4200626b:	0a0c      	movi.n	a10, 0
4200626d:	09a9      	s32i.n	a10, a9, 0
4200626f:	ff3856        	bnez	a8, 42006266 <usb_serial_jtag_start_select+0x4e>
    FD_ZERO(writefds);
42006272:	280c      	movi.n	a8, 2
42006274:	000246        	j	42006281 <usb_serial_jtag_start_select+0x69>
42006277:	880b00        	lsi	f0, a11, 0x220
4200627a:	a09840        	addx4	a9, a8, a4
4200627d:	0a0c      	movi.n	a10, 0
4200627f:	09a9      	s32i.n	a10, a9, 0
42006281:	ff3856        	bnez	a8, 42006278 <usb_serial_jtag_start_select+0x60>
    FD_ZERO(exceptfds);
42006284:	280c      	movi.n	a8, 2
42006286:	0002c6        	j	42006295 <usb_serial_jtag_start_select+0x7d>
42006289:	ffc882        	addi	a8, a8, -1
4200628c:	a09850        	addx4	a9, a8, a5
4200628f:	00a0a2        	movi	a10, 0
42006292:	0069a2        	s32i	a10, a9, 0
42006295:	ff0856        	bnez	a8, 42006289 <usb_serial_jtag_start_select+0x71>
    esp_err_t ret = register_select(args);
42006298:	07ad      	mov.n	a10, a7
4200629a:	fff165        	call8	420061b0 <register_select>
4200629d:	0a2d      	mov.n	a2, a10
    if (ret != ESP_OK) {
4200629f:	aa8c      	beqz.n	a10, 420062ad <usb_serial_jtag_start_select+0x95>
        free(args);
420062a1:	07ad      	mov.n	a10, a7
420062a3:	e8b181        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
420062a6:	0008e0        	callx8	a8
        return ret;
420062a9:	001486        	j	420062ff <usb_serial_jtag_start_select+0xe7>
420062ac:	278200        	lsi	f0, a2, 156
    if (FD_ISSET(USJ_LOCAL_FD, &args->readfds_orig) && usb_serial_jtag_read_ready()) {
420062af:	680705        	call0	4206e320 <_etext+0x580ca>
420062b2:	3aa514        	lsi	f1, a5, 232
420062b5:	5aa000        	msub.s	f10, f0, f0
420062b8:	da1620        	ufloat.s	f1, a6, 2
420062bb:	038800        	lsi	f0, a8, 12
        FD_SET(USJ_LOCAL_FD, readfds);
420062be:	190c      	movi.n	a9, 1
420062c0:	208890        	or	a8, a8, a9
420062c3:	0389      	s32i.n	a8, a3, 0
        trigger_select = true;
420062c5:	000046        	j	420062ca <usb_serial_jtag_start_select+0xb2>
    bool trigger_select = false;
420062c8:	050c      	movi.n	a5, 0
    if (FD_ISSET(USJ_LOCAL_FD, &args->writefds_orig) && usb_serial_jtag_write_ready()) {
420062ca:	072782        	l32i	a8, a7, 28
420062cd:	136807        	bbci	a8, 0, 420062e4 <usb_serial_jtag_start_select+0xcc>
420062d0:	003b25        	call8	42006684 <usb_serial_jtag_write_ready>
420062d3:	00da16        	beqz	a10, 420062e4 <usb_serial_jtag_start_select+0xcc>
        FD_SET(USJ_LOCAL_FD, writefds);
420062d6:	002482        	l32i	a8, a4, 0
420062d9:	190c      	movi.n	a9, 1
420062db:	208890        	or	a8, a8, a9
420062de:	0489      	s32i.n	a8, a4, 0
    if (trigger_select) {
420062e0:	0000c6        	j	420062e7 <usb_serial_jtag_start_select+0xcf>
420062e3:	851600        	extui	a1, a0, 22, 9
420062e6:	27a200        	lsi	f0, a2, 156
        esp_vfs_select_triggered(args->select_sem);
420062e9:	27b200        	lsi	f0, a2, 156
420062ec:	f5e501        	l32r	a0, 42003a80 <esp_sleep_enable_gpio_switch+0x18> (46f2ccd1 <_etext+0x4f16a7b>)
420062ef:	067900        	lsi	f0, a9, 24
    return ESP_OK;
420062f2:	000246        	j	420062ff <usb_serial_jtag_start_select+0xe7>
        return ESP_ERR_INVALID_STATE;
420062f5:	03a122        	movi	a2, 0x103
420062f8:	0000c6        	j	420062ff <usb_serial_jtag_start_select+0xe7>
420062fb:	a12200        	sll	a2, a2
        return ESP_ERR_NO_MEM;
420062fe:	f01d01        	l32r	a0, 42002374 <print_cache_err_details+0x20> (f7f5a100 <_rtc_reserved_end+0x97e5a100>)
42006301:	000000        	ill

42006304 <select_notif_callback_isr>:
{
42006304:	004136        	entry	a1, 32
42006307:	fb7c      	movi.n	a11, -1
42006309:	e937a1        	l32r	a10, 420007e8 <_stext+0x7c8> (3fc920ac <s_registered_select_lock>)
4200630c:	e84181        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
4200630f:	0008e0        	callx8	a8
    for (int i = 0; i < s_registered_select_num; ++i) {
42006312:	070c      	movi.n	a7, 0
42006314:	001bc6        	j	42006387 <select_notif_callback_isr+0x83>
        usb_serial_jtag_select_args_t *args = s_registered_selects[i];
42006317:	e93581        	l32r	a8, 420007ec <_stext+0x7cc> (3fc94ef8 <s_registered_selects>)
4200631a:	002882        	l32i	a8, a8, 0
4200631d:	a08780        	addx4	a8, a7, a8
42006320:	002882        	l32i	a8, a8, 0
        if (args) {
42006323:	05e816        	beqz	a8, 42006385 <select_notif_callback_isr+0x81>
            switch (usj_select_notif) {
42006326:	221226        	beqi	a2, 1, 4200634c <select_notif_callback_isr+0x48>
42006329:	3f2226        	beqi	a2, 2, 4200636c <select_notif_callback_isr+0x68>
4200632c:	055256        	bnez	a2, 42006385 <select_notif_callback_isr+0x81>
                if (FD_ISSET(USJ_LOCAL_FD, &args->readfds_orig)) {
4200632f:	052892        	l32i	a9, a8, 20
42006332:	4f6907        	bbci	a9, 0, 42006385 <select_notif_callback_isr+0x81>
                    FD_SET(USJ_LOCAL_FD, args->readfds);
42006335:	28a8      	l32i.n	a10, a8, 8
42006337:	0a98      	l32i.n	a9, a10, 0
42006339:	1b0c      	movi.n	a11, 1
4200633b:	2099b0        	or	a9, a9, a11
4200633e:	0a99      	s32i.n	a9, a10, 0
                    esp_vfs_select_triggered_isr(args->select_sem, task_woken);
42006340:	03cd      	mov.n	a12, a3
42006342:	08a8      	l32i.n	a10, a8, 0
42006344:	18b8      	l32i.n	a11, a8, 4
42006346:	00f565        	call8	4200729c <esp_vfs_select_triggered_isr>
42006349:	000e06        	j	42006385 <select_notif_callback_isr+0x81>
                if (FD_ISSET(USJ_LOCAL_FD, &args->writefds_orig)) {
4200634c:	072892        	l32i	a9, a8, 28
4200634f:	326907        	bbci	a9, 0, 42006385 <select_notif_callback_isr+0x81>
                    FD_SET(USJ_LOCAL_FD, args->writefds);
42006352:	0328a2        	l32i	a10, a8, 12
42006355:	002a92        	l32i	a9, a10, 0
42006358:	1b0c      	movi.n	a11, 1
4200635a:	2099b0        	or	a9, a9, a11
4200635d:	0a99      	s32i.n	a9, a10, 0
                    esp_vfs_select_triggered_isr(args->select_sem, task_woken);
4200635f:	03cd      	mov.n	a12, a3
42006361:	08a8      	l32i.n	a10, a8, 0
42006363:	18b8      	l32i.n	a11, a8, 4
42006365:	00f365        	call8	4200729c <esp_vfs_select_triggered_isr>
42006368:	000646        	j	42006385 <select_notif_callback_isr+0x81>
4200636b:	989800        	lsi	f0, a8, 0x260
                if (FD_ISSET(USJ_LOCAL_FD, &args->errorfds_orig)) {
4200636e:	136907        	bbci	a9, 0, 42006385 <select_notif_callback_isr+0x81>
                    FD_SET(USJ_LOCAL_FD, args->errorfds);
42006371:	48a8      	l32i.n	a10, a8, 16
42006373:	0a98      	l32i.n	a9, a10, 0
42006375:	1b0c      	movi.n	a11, 1
42006377:	2099b0        	or	a9, a9, a11
4200637a:	0a99      	s32i.n	a9, a10, 0
                    esp_vfs_select_triggered_isr(args->select_sem, task_woken);
4200637c:	03cd      	mov.n	a12, a3
4200637e:	08a8      	l32i.n	a10, a8, 0
42006380:	18b8      	l32i.n	a11, a8, 4
42006382:	00f1a5        	call8	4200729c <esp_vfs_select_triggered_isr>
    for (int i = 0; i < s_registered_select_num; ++i) {
42006385:	771b      	addi.n	a7, a7, 1
42006387:	e91b81        	l32r	a8, 420007f4 <_stext+0x7d4> (3fc94ef4 <s_registered_select_num>)
4200638a:	0888      	l32i.n	a8, a8, 0
4200638c:	872787        	blt	a7, a8, 42006317 <select_notif_callback_isr+0x13>
    portEXIT_CRITICAL_ISR(&s_registered_select_lock);
4200638f:	e916a1        	l32r	a10, 420007e8 <_stext+0x7c8> (3fc920ac <s_registered_select_lock>)
42006392:	e82081        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42006395:	0008e0        	callx8	a8
}
42006398:	f01d      	retw.n
	...

4200639c <usb_serial_jtag_tcflush>:
    usb_serial_jtag_fsync(fd);
    return 0;
}

static int usb_serial_jtag_tcflush(int fd, int select)
{
4200639c:	004136        	entry	a1, 32
    //Flushing is not supported.
    errno = EINVAL;
4200639f:	050ee5        	call8	4200b48c <__errno>
420063a2:	16a082        	movi	a8, 22
420063a5:	006a82        	s32i	a8, a10, 0
    return -1;
}
420063a8:	ffaf22        	movi	a2, -1
420063ab:	f01d      	retw.n
420063ad:	000000        	ill

420063b0 <usb_serial_jtag_fcntl>:
{
420063b0:	004136        	entry	a1, 32
    if (cmd == F_GETFL) {
420063b3:	0d3366        	bnei	a3, 3, 420063c4 <usb_serial_jtag_fcntl+0x14>
        if (s_ctx.non_blocking) {
420063b6:	e90a81        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
420063b9:	0c0882        	l8ui	a8, a8, 12
420063bc:	48ec      	bnez.n	a8, 420063e4 <usb_serial_jtag_fcntl+0x34>
        result |= O_RDWR;
420063be:	220c      	movi.n	a2, 2
420063c0:	0008c6        	j	420063e7 <usb_serial_jtag_fcntl+0x37>
420063c3:	436600        	min	a6, a6, a0
    } else if (cmd == F_SETFL) {
420063c6:	400d      	lsi	f0, a0, 0
        s_ctx.non_blocking = (arg & O_NONBLOCK) != 0;
420063c8:	4e          	.byte	0x4e
420063c9:	058104        	lsi	f0, a1, 20
420063cc:	42e9      	s32i.n	a14, a2, 16
420063ce:	0c48      	l32i.n	a4, a12, 0
    int result = 0;
420063d0:	020c      	movi.n	a2, 0
420063d2:	000446        	j	420063e7 <usb_serial_jtag_fcntl+0x37>
        errno = ENOSYS;
420063d5:	050b65        	call8	4200b48c <__errno>
420063d8:	58a082        	movi	a8, 88
420063db:	006a82        	s32i	a8, a10, 0
        result = -1;
420063de:	ffaf22        	movi	a2, -1
420063e1:	000086        	j	420063e7 <usb_serial_jtag_fcntl+0x37>
            result |= O_NONBLOCK;
420063e4:	e90721        	l32r	a2, 42000800 <_stext+0x7e0> (4002 <UserFrameTotalSize+0x3f02>)
}
420063e7:	f01d      	retw.n
420063e9:	000000        	ill

420063ec <usb_serial_jtag_tcgetattr>:
{
420063ec:	004136        	entry	a1, 32
    if (p == NULL) {
420063ef:	00e356        	bnez	a3, 42006401 <usb_serial_jtag_tcgetattr+0x15>
        errno = EINVAL;
420063f2:	0509a5        	call8	4200b48c <__errno>
420063f5:	16a082        	movi	a8, 22
420063f8:	006a82        	s32i	a8, a10, 0
        return -1;
420063fb:	ffaf22        	movi	a2, -1
420063fe:	001346        	j	4200644f <usb_serial_jtag_tcgetattr+0x63>
    memset(p, 0, sizeof(struct termios));
42006401:	cc1c      	movi.n	a12, 28
42006403:	0b0c      	movi.n	a11, 0
42006405:	03ad      	mov.n	a10, a3
42006407:	e7be81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200640a:	0008e0        	callx8	a8
    if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CRLF) {
4200640d:	e8f481        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006410:	5888      	l32i.n	a8, a8, 20
42006412:	e8cc      	bnez.n	a8, 42006424 <usb_serial_jtag_tcgetattr+0x38>
        p->c_iflag |= IGNCR;
42006414:	001382        	l16ui	a8, a3, 0
42006417:	890c      	movi.n	a9, 8
42006419:	208890        	or	a8, a8, a9
4200641c:	005382        	s16i	a8, a3, 0
4200641f:	0003c6        	j	42006432 <usb_serial_jtag_tcgetattr+0x46>
42006422:	660000        	lsi	f0, a0, 0x198
    } else if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CR) {
42006425:	0a18      	l32i.n	a1, a10, 0
        p->c_iflag |= ICRNL;
42006427:	001382        	l16ui	a8, a3, 0
4200642a:	290c      	movi.n	a9, 2
4200642c:	208890        	or	a8, a8, a9
4200642f:	005382        	s16i	a8, a3, 0
    p->c_cflag &= (~CSIZE);
42006432:	021382        	l16ui	a8, a3, 4
42006435:	d49280        	extui	a9, a8, 2, 14
42006438:	1199e0        	slli	a9, a9, 2
4200643b:	025392        	s16i	a9, a3, 4
    p->c_cflag |= CS8;
4200643e:	390c      	movi.n	a9, 3
42006440:	208890        	or	a8, a8, a9
42006443:	025382        	s16i	a8, a3, 4
    p->c_ispeed = p->c_ospeed = 1000000;
42006446:	e8c181        	l32r	a8, 4200074c <_stext+0x72c> (f4240 <UserFrameTotalSize+0xf4140>)
42006449:	6389      	s32i.n	a8, a3, 24
4200644b:	5389      	s32i.n	a8, a3, 20
    return 0;
4200644d:	020c      	movi.n	a2, 0
}
4200644f:	f01d      	retw.n
42006451:	000000        	ill

42006454 <usb_serial_jtag_fstat>:
{
42006454:	004136        	entry	a1, 32
    memset(st, 0, sizeof(*st));
42006457:	8c5c      	movi.n	a12, 88
42006459:	0b0c      	movi.n	a11, 0
4200645b:	20a330        	or	a10, a3, a3
4200645e:	e7a881        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42006461:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR;
42006464:	e8e881        	l32r	a8, 42000804 <_stext+0x7e4> (2000 <UserFrameTotalSize+0x1f00>)
42006467:	1389      	s32i.n	a8, a3, 4
}
42006469:	020c      	movi.n	a2, 0
4200646b:	f01d      	retw.n
4200646d:	000000        	ill

42006470 <usb_serial_jtag_fsync>:
{
42006470:	004136        	entry	a1, 32
    _lock_acquire_recursive(&s_ctx.write_lock);
42006473:	e8e5a1        	l32r	a10, 42000808 <_stext+0x7e8> (3fc920c0 <s_ctx+0x8>)
42006476:	e8e581        	l32r	a8, 4200080c <_stext+0x7ec> (40376a2c <_lock_acquire_recursive>)
42006479:	0008e0        	callx8	a8
    int r = s_ctx.fsync_func(fd);
4200647c:	e8d981        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
4200647f:	082882        	l32i	a8, a8, 32
42006482:	20a220        	or	a10, a2, a2
42006485:	0008e0        	callx8	a8
42006488:	202aa0        	or	a2, a10, a10
    _lock_release_recursive(&s_ctx.write_lock);
4200648b:	e8dfa1        	l32r	a10, 42000808 <_stext+0x7e8> (3fc920c0 <s_ctx+0x8>)
4200648e:	e8e081        	l32r	a8, 42000810 <_stext+0x7f0> (40376a6c <_lock_release_recursive>)
42006491:	0008e0        	callx8	a8
    if (r == 0) {
42006494:	528c      	beqz.n	a2, 4200649d <usb_serial_jtag_fsync+0x2d>
        errno = r;
42006496:	04ff65        	call8	4200b48c <__errno>
42006499:	0a29      	s32i.n	a2, a10, 0
        return -1;
4200649b:	f27c      	movi.n	a2, -1
}
4200649d:	f01d      	retw.n
	...

420064a0 <usb_serial_jtag_tcdrain>:
{
420064a0:	004136        	entry	a1, 32
420064a3:	02ad      	mov.n	a10, a2
    usb_serial_jtag_fsync(fd);
420064a5:	fffca5        	call8	42006470 <usb_serial_jtag_fsync>
}
420064a8:	020c      	movi.n	a2, 0
420064aa:	f01d      	retw.n

420064ac <usb_serial_jtag_tcsetattr>:
{
420064ac:	004136        	entry	a1, 32
    if (p == NULL) {
420064af:	00e456        	bnez	a4, 420064c1 <usb_serial_jtag_tcsetattr+0x15>
        errno = EINVAL;
420064b2:	04fda5        	call8	4200b48c <__errno>
420064b5:	16a082        	movi	a8, 22
420064b8:	006a82        	s32i	a8, a10, 0
        return -1;
420064bb:	ffaf22        	movi	a2, -1
420064be:	0012c6        	j	4200650d <usb_serial_jtag_tcsetattr+0x61>
    switch (optional_actions) {
420064c1:	071326        	beqi	a3, 1, 420064cc <usb_serial_jtag_tcsetattr+0x20>
420064c4:	1c2326        	beqi	a3, 2, 420064e4 <usb_serial_jtag_tcsetattr+0x38>
420064c7:	93cc      	bnez.n	a3, 420064d4 <usb_serial_jtag_tcsetattr+0x28>
420064c9:	0005c6        	j	420064e4 <usb_serial_jtag_tcsetattr+0x38>
        usb_serial_jtag_fsync(fd);
420064cc:	02ad      	mov.n	a10, a2
420064ce:	fffa25        	call8	42006470 <usb_serial_jtag_fsync>
        break;
420064d1:	0003c6        	j	420064e4 <usb_serial_jtag_tcsetattr+0x38>
        errno = EINVAL;
420064d4:	04fb65        	call8	4200b48c <__errno>
420064d7:	16a082        	movi	a8, 22
420064da:	006a82        	s32i	a8, a10, 0
        return -1;
420064dd:	ffaf22        	movi	a2, -1
420064e0:	000a46        	j	4200650d <usb_serial_jtag_tcsetattr+0x61>
420064e3:	148200        	extui	a8, a0, 2, 2
    if (p->c_iflag & IGNCR) {
420064e6:	683700        	lsi	f0, a7, 0x1a0
420064e9:	0c09      	s32i.n	a0, a12, 0
        s_ctx.rx_mode = ESP_LINE_ENDINGS_CRLF;
420064eb:	bd8102        	lsi	f0, a1, 0x2f4
420064ee:	29e8      	l32i.n	a14, a9, 8
420064f0:	0658      	l32i.n	a5, a6, 0
420064f2:	170006        	j	4200c0f6 <_vfprintf_r+0x616>
    } else if (p->c_iflag & ICRNL) {
420064f5:	0c68      	l32i.n	a6, a12, 0
        s_ctx.rx_mode = ESP_LINE_ENDINGS_CR;
420064f7:	e8ba81        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
420064fa:	190c      	movi.n	a9, 1
420064fc:	5899      	s32i.n	a9, a8, 20
    return 0;
420064fe:	020c      	movi.n	a2, 0
42006500:	000246        	j	4200650d <usb_serial_jtag_tcsetattr+0x61>
42006503:	b78100        	lsi	f0, a1, 0x2dc
        s_ctx.rx_mode = ESP_LINE_ENDINGS_LF;
42006506:	0ce8      	l32i.n	a14, a12, 0
42006508:	9929      	s32i.n	a2, a9, 36
4200650a:	0c58      	l32i.n	a5, a12, 0
    return 0;
4200650c:	f01d02        	l16ui	a0, a13, 0x1e0
	...

42006510 <usb_serial_jtag_write>:
{
42006510:	004136        	entry	a1, 32
42006513:	025d      	mov.n	a5, a2
42006515:	042d      	mov.n	a2, a4
    _lock_acquire_recursive(&s_ctx.write_lock);
42006517:	e8bca1        	l32r	a10, 42000808 <_stext+0x7e8> (3fc920c0 <s_ctx+0x8>)
4200651a:	e8bc81        	l32r	a8, 4200080c <_stext+0x7ec> (40376a2c <_lock_acquire_recursive>)
4200651d:	0008e0        	callx8	a8
    for (size_t i = 0; i < size; i++) {
42006520:	070c      	movi.n	a7, 0
42006522:	000b86        	j	42006554 <usb_serial_jtag_write+0x44>
        int c = data_c[i];
42006525:	837a      	add.n	a8, a3, a7
42006527:	000862        	l8ui	a6, a8, 0
        if (c == '\n' && s_ctx.tx_mode != ESP_LINE_ENDINGS_LF) {
4200652a:	189666        	bnei	a6, 10, 42006546 <usb_serial_jtag_write+0x36>
4200652d:	e8ac81        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006530:	4888      	l32i.n	a8, a8, 16
42006532:	102826        	beqi	a8, 2, 42006546 <usb_serial_jtag_write+0x36>
            s_ctx.tx_func(fd, '\r');
42006535:	e8aa41        	l32r	a4, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006538:	6488      	l32i.n	a8, a4, 24
4200653a:	db0c      	movi.n	a11, 13
4200653c:	05ad      	mov.n	a10, a5
4200653e:	0008e0        	callx8	a8
            if (s_ctx.tx_mode == ESP_LINE_ENDINGS_CR) {
42006541:	4488      	l32i.n	a8, a4, 16
42006543:	0b1826        	beqi	a8, 1, 42006552 <usb_serial_jtag_write+0x42>
        s_ctx.tx_func(fd, c);
42006546:	e8a681        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006549:	6888      	l32i.n	a8, a8, 24
4200654b:	06bd      	mov.n	a11, a6
4200654d:	05ad      	mov.n	a10, a5
4200654f:	0008e0        	callx8	a8
    for (size_t i = 0; i < size; i++) {
42006552:	771b      	addi.n	a7, a7, 1
42006554:	cd3727        	bltu	a7, a2, 42006525 <usb_serial_jtag_write+0x15>
    _lock_release_recursive(&s_ctx.write_lock);
42006557:	e8aca1        	l32r	a10, 42000808 <_stext+0x7e8> (3fc920c0 <s_ctx+0x8>)
4200655a:	e8ad81        	l32r	a8, 42000810 <_stext+0x7f0> (40376a6c <_lock_release_recursive>)
4200655d:	0008e0        	callx8	a8
}
42006560:	f01d      	retw.n
	...

42006564 <usb_serial_jtag_return_char>:
{
42006564:	004136        	entry	a1, 32
    assert(s_ctx.peek_char == NONE);
42006567:	e89e81        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
4200656a:	0888      	l32i.n	a8, a8, 0
4200656c:	110826        	beqi	a8, -1, 42006581 <usb_serial_jtag_return_char+0x1d>
4200656f:	e8a9d1        	l32r	a13, 42000814 <_stext+0x7f4> (3c024eec <_flash_rodata_start+0x4dcc>)
42006572:	e8a9c1        	l32r	a12, 42000818 <_stext+0x7f8> (3c0282e8 <__func__$0>)
42006575:	dfa0b2        	movi	a11, 223
42006578:	e8a9a1        	l32r	a10, 4200081c <_stext+0x7fc> (3c024f34 <_flash_rodata_start+0x4e14>)
4200657b:	e6d181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200657e:	0008e0        	callx8	a8
    s_ctx.peek_char = c;
42006581:	e89781        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
42006584:	0839      	s32i.n	a3, a8, 0
}
42006586:	f01d      	retw.n

42006588 <usb_serial_jtag_read>:
{
42006588:	004136        	entry	a1, 32
4200658b:	026d      	mov.n	a6, a2
    _lock_acquire_recursive(&s_ctx.read_lock);
4200658d:	e8a4a1        	l32r	a10, 42000820 <_stext+0x800> (3fc920bc <s_ctx+0x4>)
42006590:	e89f81        	l32r	a8, 4200080c <_stext+0x7ec> (40376a2c <_lock_acquire_recursive>)
42006593:	0008e0        	callx8	a8
    size_t received = 0;
42006596:	020c      	movi.n	a2, 0
    while (received < size) {
42006598:	001586        	j	420065f2 <usb_serial_jtag_read+0x6a>
4200659b:	a66000        	lsi	f0, a0, 0x298
        int c = usb_serial_jtag_read_char(fd);
4200659e:	a6a520        	lsi	f2, a5, 0x298
420065a1:	ff          	.byte	0xff
420065a2:	0a7d      	mov.n	a7, a10
        if (c == '\r') {
420065a4:	d80c      	movi.n	a8, 13
420065a6:	2e9a87        	bne	a10, a8, 420065d8 <usb_serial_jtag_read+0x50>
            if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CR) {
420065a9:	e88d81        	l32r	a8, 420007e0 <_stext+0x7c0> (3fc920b8 <s_ctx>)
420065ac:	5888      	l32i.n	a8, a8, 20
420065ae:	2c1826        	beqi	a8, 1, 420065de <usb_serial_jtag_read+0x56>
            } else if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CRLF) {
420065b1:	38fc      	bnez.n	a8, 420065e8 <usb_serial_jtag_read+0x60>
                int c2 = usb_serial_jtag_read_char(fd);
420065b3:	06ad      	mov.n	a10, a6
420065b5:	ffa525        	call8	42006008 <usb_serial_jtag_read_char>
                if (c2 == NONE) {
420065b8:	0c0a66        	bnei	a10, -1, 420065c8 <usb_serial_jtag_read+0x40>
                    usb_serial_jtag_return_char(fd, c);
420065bb:	20b770        	or	a11, a7, a7
420065be:	20a660        	or	a10, a6, a6
420065c1:	fffa25        	call8	42006564 <usb_serial_jtag_return_char>
                    break;
420065c4:	000b46        	j	420065f5 <usb_serial_jtag_read+0x6d>
420065c7:	9a2600        	trunc.s	a2, f6, 0
                if (c2 == '\n') {
420065ca:	bd1a      	add.n	a11, a13, a1
                    usb_serial_jtag_return_char(fd, c2);
420065cc:	ad0a      	add.n	a10, a13, a0
420065ce:	f96506        	j	42004b66 <esp_mprot_get_pms_area+0x6a>
420065d1:	ff          	.byte	0xff
420065d2:	000486        	j	420065e8 <usb_serial_jtag_read+0x60>
420065d5:	000000        	ill
        } else if (c == NONE) {
420065d8:	0c0a66        	bnei	a10, -1, 420065e8 <usb_serial_jtag_read+0x60>
420065db:	000586        	j	420065f5 <usb_serial_jtag_read+0x6d>
                c = '\n';
420065de:	a70c      	movi.n	a7, 10
420065e0:	000106        	j	420065e8 <usb_serial_jtag_read+0x60>
420065e3:	000000        	ill
                    c = '\n';
420065e6:	0a7d      	mov.n	a7, a10
        data_c[received] = (char) c;
420065e8:	832a      	add.n	a8, a3, a2
420065ea:	004872        	s8i	a7, a8, 0
        ++received;
420065ed:	221b      	addi.n	a2, a2, 1
        if (c == '\n') {
420065ef:	029726        	beqi	a7, 10, 420065f5 <usb_serial_jtag_read+0x6d>
    while (received < size) {
420065f2:	a63247        	bltu	a2, a4, 4200659c <usb_serial_jtag_read+0x14>
    _lock_release_recursive(&s_ctx.read_lock);
420065f5:	e88aa1        	l32r	a10, 42000820 <_stext+0x800> (3fc920bc <s_ctx+0x4>)
420065f8:	e88681        	l32r	a8, 42000810 <_stext+0x7f0> (40376a6c <_lock_release_recursive>)
420065fb:	0008e0        	callx8	a8
    if (received > 0) {
420065fe:	00a256        	bnez	a2, 4200660c <usb_serial_jtag_read+0x84>
    errno = EWOULDBLOCK;
42006601:	04e8a5        	call8	4200b48c <__errno>
42006604:	0ba082        	movi	a8, 11
42006607:	006a82        	s32i	a8, a10, 0
    return -1;
4200660a:	f27c      	movi.n	a2, -1
}
4200660c:	f01d      	retw.n
	...

42006610 <esp_vfs_usb_serial_jtag_get_vfs>:
    .termios = &s_vfs_jtag_termios,
#endif // CONFIG_VFS_SUPPORT_TERMIOS
};

const esp_vfs_fs_ops_t* esp_vfs_usb_serial_jtag_get_vfs(void)
{
42006610:	004136        	entry	a1, 32
    return &s_vfs_jtag;
}
42006613:	e88421        	l32r	a2, 42000824 <_stext+0x804> (3c028304 <s_vfs_jtag>)
42006616:	f01d      	retw.n

42006618 <esp_vfs_dev_usb_serial_jtag_register>:

esp_err_t usb_serial_jtag_vfs_register(void)
{
42006618:	004136        	entry	a1, 32
    // "/dev/usb_serial_jtag" unfortunately is too long for vfs
    return esp_vfs_register_fs("/dev/usbserjtag", &s_vfs_jtag, ESP_VFS_FLAG_STATIC, NULL);
4200661b:	0d0c      	movi.n	a13, 0
4200661d:	8c0c      	movi.n	a12, 8
4200661f:	e881b1        	l32r	a11, 42000824 <_stext+0x804> (3c028304 <s_vfs_jtag>)
42006622:	e881a1        	l32r	a10, 42000828 <_stext+0x808> (3c024f4c <_flash_rodata_start+0x4e2c>)
42006625:	004a25        	call8	42006ac8 <esp_vfs_register_fs>
}
42006628:	0a2d      	mov.n	a2, a10
4200662a:	f01d      	retw.n

4200662c <__esp_system_init_fn_init_vfs_usj>:

#if CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
ESP_SYSTEM_INIT_FN(init_vfs_usj, CORE, BIT(0), 111)
{
4200662c:	004136        	entry	a1, 32
    usb_serial_jtag_vfs_register();
4200662f:	fffea5        	call8	42006618 <esp_vfs_dev_usb_serial_jtag_register>
    return ESP_OK;
}
42006632:	020c      	movi.n	a2, 0
42006634:	f01d      	retw.n
	...

42006638 <usb_serial_jtag_is_driver_installed>:
    p_usb_serial_jtag_obj = NULL;
    return ESP_OK;
}

bool usb_serial_jtag_is_driver_installed(void)
{
42006638:	004136        	entry	a1, 32
    return (p_usb_serial_jtag_obj != NULL);
4200663b:	e87c81        	l32r	a8, 4200082c <_stext+0x80c> (3fc94efc <p_usb_serial_jtag_obj>)
4200663e:	0828      	l32i.n	a2, a8, 0
}
42006640:	180c      	movi.n	a8, 1
42006642:	932820        	movnez	a2, a8, a2
42006645:	f01d      	retw.n
	...

42006648 <usb_serial_jtag_set_select_notif_callback>:

void usb_serial_jtag_set_select_notif_callback(usj_select_notif_callback_t usj_select_notif_callback)
{
42006648:	004136        	entry	a1, 32
    if (usb_serial_jtag_is_driver_installed()) {
4200664b:	fffee5        	call8	42006638 <usb_serial_jtag_is_driver_installed>
4200664e:	6a8c      	beqz.n	a10, 42006658 <usb_serial_jtag_set_select_notif_callback+0x10>
        p_usb_serial_jtag_obj->usj_select_notif_callback = usj_select_notif_callback;
42006650:	e87781        	l32r	a8, 4200082c <_stext+0x80c> (3fc94efc <p_usb_serial_jtag_obj>)
42006653:	0888      	l32i.n	a8, a8, 0
42006655:	166822        	s32i	a2, a8, 88
    }
}
42006658:	f01d      	retw.n
	...

4200665c <usb_serial_jtag_read_ready>:

bool usb_serial_jtag_read_ready(void)
{
4200665c:	006136        	entry	a1, 48
    // sign the the driver is read ready is that data is waiting in the RX ringbuffer
    UBaseType_t items_waiting = 0;
4200665f:	0b0c      	movi.n	a11, 0
42006661:	01b9      	s32i.n	a11, a1, 0
    vRingbufferGetInfo(p_usb_serial_jtag_obj->rx_ring_buf, NULL, NULL, NULL, NULL, &items_waiting);
42006663:	e87281        	l32r	a8, 4200082c <_stext+0x80c> (3fc94efc <p_usb_serial_jtag_obj>)
42006666:	0888      	l32i.n	a8, a8, 0
42006668:	01fd      	mov.n	a15, a1
4200666a:	0bed      	mov.n	a14, a11
4200666c:	0bdd      	mov.n	a13, a11
4200666e:	0bcd      	mov.n	a12, a11
42006670:	18a8      	l32i.n	a10, a8, 4
42006672:	e86f81        	l32r	a8, 42000830 <_stext+0x810> (40379520 <vRingbufferGetInfo>)
42006675:	0008e0        	callx8	a8
    return items_waiting != 0;
}
42006678:	0128      	l32i.n	a2, a1, 0
4200667a:	180c      	movi.n	a8, 1
4200667c:	932820        	movnez	a2, a8, a2
4200667f:	f01d      	retw.n
42006681:	000000        	ill

42006684 <usb_serial_jtag_write_ready>:

bool usb_serial_jtag_write_ready(void)
{
42006684:	004136        	entry	a1, 32
    // sign that the driver is write ready is that the TX ring buffer is not full
    return (xRingbufferGetCurFreeSize(p_usb_serial_jtag_obj->tx_ring_buf) > 0);
42006687:	e86981        	l32r	a8, 4200082c <_stext+0x80c> (3fc94efc <p_usb_serial_jtag_obj>)
4200668a:	0888      	l32i.n	a8, a8, 0
4200668c:	28a8      	l32i.n	a10, a8, 8
4200668e:	e86981        	l32r	a8, 42000834 <_stext+0x814> (403794f0 <xRingbufferGetCurFreeSize>)
42006691:	0008e0        	callx8	a8
}
42006694:	120c      	movi.n	a2, 1
42006696:	832aa0        	moveqz	a2, a10, a10
42006699:	f01d      	retw.n
	...

4200669c <console_start_select>:
#endif // CONFIG_VFS_SUPPORT_DIR

#ifdef CONFIG_VFS_SUPPORT_SELECT
static esp_err_t console_start_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
                                      esp_vfs_select_sem_t select_sem, void **end_select_args)
{
4200669c:	008136        	entry	a1, 64
4200669f:	02ad      	mov.n	a10, a2
420066a1:	03bd      	mov.n	a11, a3
420066a3:	04cd      	mov.n	a12, a4
420066a5:	05dd      	mov.n	a13, a5
420066a7:	4169      	s32i.n	a6, a1, 16
420066a9:	5179      	s32i.n	a7, a1, 20
    // start_select is not guaranteed be implemented even though CONFIG_VFS_SUPPORT_SELECT is enabled in sdkconfig
    if (primary_vfs->select->start_select) {
420066ab:	e86381        	l32r	a8, 42000838 <_stext+0x818> (3fc94f0c <primary_vfs>)
420066ae:	0888      	l32i.n	a8, a8, 0
420066b0:	d888      	l32i.n	a8, a8, 52
420066b2:	0888      	l32i.n	a8, a8, 0
420066b4:	089c      	beqz.n	a8, 420066c8 <console_start_select+0x2c>
        return primary_vfs->select->start_select(nfds, readfds, writefds, exceptfds, select_sem, end_select_args);
420066b6:	102192        	l32i	a9, a1, 64
420066b9:	0199      	s32i.n	a9, a1, 0
420066bb:	06ed      	mov.n	a14, a6
420066bd:	07fd      	mov.n	a15, a7
420066bf:	0008e0        	callx8	a8
420066c2:	0a2d      	mov.n	a2, a10
420066c4:	0000c6        	j	420066cb <console_start_select+0x2f>
420066c7:	a12200        	sll	a2, a2
    }

    return ESP_ERR_NOT_SUPPORTED;
420066ca:	f01d06        	j	42002742 <esp_register_freertos_tick_hook_for_cpu+0x36>
420066cd:	000000        	ill

420066d0 <console_end_select>:
}

esp_err_t console_end_select(void *end_select_args)
{
420066d0:	004136        	entry	a1, 32
420066d3:	02ad      	mov.n	a10, a2
    // end_select is not guaranteed be implemented even though CONFIG_VFS_SUPPORT_SELECT is enabled in sdkconfig
    if (primary_vfs->select->end_select) {
420066d5:	e85881        	l32r	a8, 42000838 <_stext+0x818> (3fc94f0c <primary_vfs>)
420066d8:	0888      	l32i.n	a8, a8, 0
420066da:	d888      	l32i.n	a8, a8, 52
420066dc:	5888      	l32i.n	a8, a8, 20
420066de:	007816        	beqz	a8, 420066e9 <console_end_select+0x19>
        return primary_vfs->select->end_select(end_select_args);
420066e1:	0008e0        	callx8	a8
420066e4:	0a2d      	mov.n	a2, a10
420066e6:	000086        	j	420066ec <console_end_select+0x1c>
    }

    return ESP_ERR_NOT_SUPPORTED;
420066e9:	06a122        	movi	a2, 0x106
}
420066ec:	f01d      	retw.n
	...

420066f0 <console_open>:
{
420066f0:	004136        	entry	a1, 32
    if (s_open_count > 0) {
420066f3:	e85281        	l32r	a8, 4200083c <_stext+0x81c> (3fc94f00 <s_open_count>)
420066f6:	0888      	l32i.n	a8, a8, 0
420066f8:	888c      	beqz.n	a8, 42006704 <console_open+0x14>
        s_open_count++;
420066fa:	881b      	addi.n	a8, a8, 1
420066fc:	e85091        	l32r	a9, 4200083c <_stext+0x81c> (3fc94f00 <s_open_count>)
420066ff:	0989      	s32i.n	a8, a9, 0
        return 0;
42006701:	000686        	j	4200671f <console_open+0x2f>
    vfs_console.fd_primary = open("/dev/usbserjtag", flags, mode);
42006704:	20c440        	or	a12, a4, a4
42006707:	20b330        	or	a11, a3, a3
4200670a:	e84da1        	l32r	a10, 42000840 <_stext+0x820> (3c024f4c <_flash_rodata_start+0x4e2c>)
4200670d:	04dda5        	call8	4200b4e8 <open>
42006710:	e84d81        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006713:	0068a2        	s32i	a10, a8, 0
    s_open_count++;
42006716:	e84991        	l32r	a9, 4200083c <_stext+0x81c> (3fc94f00 <s_open_count>)
42006719:	0988      	l32i.n	a8, a9, 0
4200671b:	881b      	addi.n	a8, a8, 1
4200671d:	0989      	s32i.n	a8, a9, 0
}
4200671f:	020c      	movi.n	a2, 0
42006721:	f01d      	retw.n
	...

42006724 <console_write>:
{
42006724:	004136        	entry	a1, 32
42006727:	20b330        	or	a11, a3, a3
4200672a:	202440        	or	a2, a4, a4
    write(vfs_console.fd_primary, data, size);
4200672d:	20c440        	or	a12, a4, a4
42006730:	e84581        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006733:	08a8      	l32i.n	a10, a8, 0
42006735:	04e1a5        	call8	4200b550 <write>
}
42006738:	f01d      	retw.n
	...

4200673c <console_fstat>:
{
4200673c:	004136        	entry	a1, 32
4200673f:	20b330        	or	a11, a3, a3
    return fstat(vfs_console.fd_primary, st);
42006742:	e84081        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006745:	0028a2        	l32i	a10, a8, 0
42006748:	ff4fa5        	call8	42005c44 <fstat>
}
4200674b:	202aa0        	or	a2, a10, a10
4200674e:	f01d      	retw.n

42006750 <console_close>:
{
42006750:	004136        	entry	a1, 32
    if (s_open_count == 0) {
42006753:	e83a81        	l32r	a8, 4200083c <_stext+0x81c> (3fc94f00 <s_open_count>)
42006756:	002882        	l32i	a8, a8, 0
42006759:	00c856        	bnez	a8, 42006769 <console_close+0x19>
        errno = EBADF;
4200675c:	04d2e5        	call8	4200b48c <__errno>
4200675f:	09a082        	movi	a8, 9
42006762:	0a89      	s32i.n	a8, a10, 0
        return -1;
42006764:	f27c      	movi.n	a2, -1
42006766:	000686        	j	42006784 <console_close+0x34>
    s_open_count--;
42006769:	ffc882        	addi	a8, a8, -1
4200676c:	e83491        	l32r	a9, 4200083c <_stext+0x81c> (3fc94f00 <s_open_count>)
4200676f:	006982        	s32i	a8, a9, 0
    if (s_open_count > 0) {
42006772:	00c856        	bnez	a8, 42006782 <console_close+0x32>
    close(vfs_console.fd_primary);
42006775:	e83381        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006778:	08a8      	l32i.n	a10, a8, 0
4200677a:	04d225        	call8	4200b49c <close>
    return 0;
4200677d:	020c      	movi.n	a2, 0
4200677f:	000046        	j	42006784 <console_close+0x34>
        return 0;
42006782:	020c      	movi.n	a2, 0
}
42006784:	f01d      	retw.n
	...

42006788 <console_read>:
{
42006788:	004136        	entry	a1, 32
4200678b:	20b330        	or	a11, a3, a3
4200678e:	20c440        	or	a12, a4, a4
    return read(vfs_console.fd_primary, dst, size);
42006791:	e82c81        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006794:	0028a2        	l32i	a10, a8, 0
42006797:	04d9e5        	call8	4200b534 <read>
}
4200679a:	0a2d      	mov.n	a2, a10
4200679c:	f01d      	retw.n
	...

420067a0 <console_fcntl>:
{
420067a0:	004136        	entry	a1, 32
420067a3:	20b330        	or	a11, a3, a3
420067a6:	20c440        	or	a12, a4, a4
    return fcntl(vfs_console.fd_primary, cmd, arg);
420067a9:	e82681        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
420067ac:	0028a2        	l32i	a10, a8, 0
420067af:	04d065        	call8	4200b4b4 <fcntl>
}
420067b2:	0a2d      	mov.n	a2, a10
420067b4:	f01d      	retw.n
	...

420067b8 <console_fsync>:
{
420067b8:	004136        	entry	a1, 32
    const int ret_val = fsync(vfs_console.fd_primary);
420067bb:	e82281        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
420067be:	0028a2        	l32i	a10, a8, 0
420067c1:	008125        	call8	42006fd4 <esp_vfs_fsync>
}
420067c4:	202aa0        	or	a2, a10, a10
420067c7:	000090        	retw
	...

420067cc <console_access>:
{
420067cc:	004136        	entry	a1, 32
420067cf:	20b330        	or	a11, a3, a3
    return access("/dev/uart/"STRINGIFY(CONFIG_ESP_CONSOLE_UART_NUM), amode);
420067d2:	e81da1        	l32r	a10, 42000848 <_stext+0x828> (3c024f5c <_flash_rodata_start+0x4e3c>)
420067d5:	00a1a5        	call8	420071f0 <access>
}
420067d8:	202aa0        	or	a2, a10, a10
420067db:	000090        	retw
	...

420067e0 <console_tcsetattr>:
#endif // CONFIG_VFS_SUPPORT_SELECT

#ifdef CONFIG_VFS_SUPPORT_TERMIOS

int console_tcsetattr(int fd, int optional_actions, const struct termios *p)
{
420067e0:	004136        	entry	a1, 32
420067e3:	20b330        	or	a11, a3, a3
420067e6:	20c440        	or	a12, a4, a4
    return tcsetattr(vfs_console.fd_primary, optional_actions, p);
420067e9:	e81681        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
420067ec:	0028a2        	l32i	a10, a8, 0
420067ef:	00b725        	call8	42007360 <tcsetattr>
}
420067f2:	0a2d      	mov.n	a2, a10
420067f4:	f01d      	retw.n
	...

420067f8 <console_tcgetattr>:

int console_tcgetattr(int fd, struct termios *p)
{
420067f8:	004136        	entry	a1, 32
420067fb:	20b330        	or	a11, a3, a3
    return tcgetattr(vfs_console.fd_primary, p);
420067fe:	e81181        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006801:	0028a2        	l32i	a10, a8, 0
42006804:	00ae25        	call8	420072e8 <tcgetattr>
}
42006807:	202aa0        	or	a2, a10, a10
4200680a:	f01d      	retw.n

4200680c <console_tcdrain>:

int console_tcdrain(int fd)
{
4200680c:	004136        	entry	a1, 32
    return tcdrain(vfs_console.fd_primary);
4200680f:	e80d81        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006812:	0028a2        	l32i	a10, a8, 0
42006815:	00bc65        	call8	420073dc <tcdrain>
}
42006818:	202aa0        	or	a2, a10, a10
4200681b:	000090        	retw
	...

42006820 <console_tcflush>:

int console_tcflush(int fd, int select)
{
42006820:	004136        	entry	a1, 32
42006823:	20b330        	or	a11, a3, a3
    return tcflush(vfs_console.fd_primary, select);
42006826:	e80781        	l32r	a8, 42000844 <_stext+0x824> (3fc94f04 <vfs_console>)
42006829:	0028a2        	l32i	a10, a8, 0
4200682c:	00c225        	call8	42007450 <tcflush>
}
4200682f:	202aa0        	or	a2, a10, a10
42006832:	f01d      	retw.n

42006834 <esp_vfs_dev_console_register>:
    .termios = &s_vfs_console_termios,
#endif // CONFIG_VFS_SUPPORT_TERMIOS
};

static esp_err_t esp_vfs_dev_console_register(void)
{
42006834:	004136        	entry	a1, 32
    return esp_vfs_register_fs(ESP_VFS_DEV_CONSOLE, &s_vfs_console, ESP_VFS_FLAG_STATIC, NULL);
42006837:	0d0c      	movi.n	a13, 0
42006839:	8c0c      	movi.n	a12, 8
4200683b:	e804b1        	l32r	a11, 4200084c <_stext+0x82c> (3c028370 <s_vfs_console>)
4200683e:	e804a1        	l32r	a10, 42000850 <_stext+0x830> (3c024d94 <_flash_rodata_start+0x4c74>)
42006841:	002865        	call8	42006ac8 <esp_vfs_register_fs>
}
42006844:	0a2d      	mov.n	a2, a10
42006846:	f01d      	retw.n

42006848 <esp_vfs_console_register>:

esp_err_t esp_vfs_console_register(void)
{
42006848:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
// Primary vfs part.
#if CONFIG_ESP_CONSOLE_UART
    primary_vfs = esp_vfs_uart_get_vfs();
#elif CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
    primary_vfs = esp_vfs_usb_serial_jtag_get_vfs();
4200684b:	ffdc65        	call8	42006610 <esp_vfs_usb_serial_jtag_get_vfs>
4200684e:	e7fa81        	l32r	a8, 42000838 <_stext+0x818> (3fc94f0c <primary_vfs>)
42006851:	0068a2        	s32i	a10, a8, 0

// Secondary vfs part.
#if CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG
    secondary_vfs = esp_vfs_usb_serial_jtag_get_vfs();
#endif
    err = esp_vfs_dev_console_register();
42006854:	fffde5        	call8	42006834 <esp_vfs_dev_console_register>
    return err;
}
42006857:	202aa0        	or	a2, a10, a10
4200685a:	f01d      	retw.n

4200685c <__esp_system_init_fn_init_vfs_console>:

ESP_SYSTEM_INIT_FN(init_vfs_console, CORE, BIT(0), 114)
{
4200685c:	004136        	entry	a1, 32
    return esp_vfs_console_register();
4200685f:	fffea5        	call8	42006848 <esp_vfs_console_register>
}
42006862:	0a2d      	mov.n	a2, a10
42006864:	f01d      	retw.n
	...

42006868 <esp_get_free_index>:
static size_t s_vfs_count = 0;

static fd_table_t s_fd_table[MAX_FDS] = { [0 ... MAX_FDS-1] = FD_TABLE_ENTRY_UNUSED };
static _lock_t s_fd_table_lock;

static ssize_t esp_get_free_index(void) {
42006868:	004136        	entry	a1, 32
    for (ssize_t i = 0; i < VFS_MAX_COUNT; i++) {
4200686b:	020c      	movi.n	a2, 0
4200686d:	0002c6        	j	4200687c <esp_get_free_index+0x14>
        if (s_vfs[i] == NULL) {
42006870:	e7f981        	l32r	a8, 42000854 <_stext+0x834> (3fc94f18 <s_vfs>)
42006873:	a08280        	addx4	a8, a2, a8
42006876:	0888      	l32i.n	a8, a8, 0
42006878:	588c      	beqz.n	a8, 42006881 <esp_get_free_index+0x19>
    for (ssize_t i = 0; i < VFS_MAX_COUNT; i++) {
4200687a:	221b      	addi.n	a2, a2, 1
4200687c:	f082a6        	blti	a2, 8, 42006870 <esp_get_free_index+0x8>
            return i;
        }
    }
    return -1;
4200687f:	f27c      	movi.n	a2, -1
}
42006881:	f01d      	retw.n
	...

42006884 <free_proxy_members>:
#ifdef CONFIG_VFS_SUPPORT_SELECT
    esp_vfs_select_ops_t *select;
#endif
} vfs_component_proxy_t;

static void free_proxy_members(vfs_component_proxy_t *proxy) {
42006884:	004136        	entry	a1, 32
#ifdef CONFIG_VFS_SUPPORT_DIR
    free(proxy->dir);
42006887:	0022a2        	l32i	a10, a2, 0
4200688a:	e73781        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
4200688d:	0008e0        	callx8	a8
#endif
#ifdef CONFIG_VFS_SUPPORT_TERMIOS
    free(proxy->termios);
42006890:	12a8      	l32i.n	a10, a2, 4
42006892:	e73581        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42006895:	0008e0        	callx8	a8
#endif
#ifdef CONFIG_VFS_SUPPORT_SELECT
    free(proxy->select);
42006898:	22a8      	l32i.n	a10, a2, 8
4200689a:	e73381        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
4200689d:	0008e0        	callx8	a8
#endif
}
420068a0:	f01d      	retw.n
	...

420068a4 <esp_vfs_duplicate_fs_ops>:

    return out;
}


static esp_vfs_fs_ops_t* esp_vfs_duplicate_fs_ops(const esp_vfs_fs_ops_t *orig) {
420068a4:	00e136        	entry	a1, 112
    vfs_component_proxy_t proxy = {};
420068a7:	0ca0c2        	movi	a12, 12
420068aa:	00a0b2        	movi	a11, 0
420068ad:	20a110        	or	a10, a1, a1
420068b0:	e69481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420068b3:	0008e0        	callx8	a8

#ifdef CONFIG_VFS_SUPPORT_DIR
    if (orig->dir != NULL) {
420068b6:	b288      	l32i.n	a8, a2, 44
420068b8:	a89c      	beqz.n	a8, 420068d6 <esp_vfs_duplicate_fs_ops+0x32>
        proxy.dir = (esp_vfs_dir_ops_t*) heap_caps_malloc(sizeof(esp_vfs_dir_ops_t), VFS_MALLOC_FLAGS);
420068ba:	e7cdb1        	l32r	a11, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
420068bd:	40a0a2        	movi	a10, 64
420068c0:	e71881        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
420068c3:	0008e0        	callx8	a8
420068c6:	01a9      	s32i.n	a10, a1, 0
        if (proxy.dir == NULL) {
420068c8:	09fa16        	beqz	a10, 4200696b <esp_vfs_duplicate_fs_ops+0xc7>
            goto fail;
        }
        memcpy(proxy.dir, orig->dir, sizeof(esp_vfs_dir_ops_t));
420068cb:	0c4c      	movi.n	a12, 64
420068cd:	0b22b2        	l32i	a11, a2, 44
420068d0:	e5d681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420068d3:	0008e0        	callx8	a8
    }
#endif

#ifdef CONFIG_VFS_SUPPORT_TERMIOS
    if (orig->termios != NULL) {
420068d6:	c288      	l32i.n	a8, a2, 48
420068d8:	a89c      	beqz.n	a8, 420068f6 <esp_vfs_duplicate_fs_ops+0x52>
        proxy.termios = (esp_vfs_termios_ops_t*) heap_caps_malloc(sizeof(esp_vfs_termios_ops_t), VFS_MALLOC_FLAGS);
420068da:	e7c5b1        	l32r	a11, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
420068dd:	1ca0a2        	movi	a10, 28
420068e0:	e71081        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
420068e3:	0008e0        	callx8	a8
420068e6:	11a9      	s32i.n	a10, a1, 4
        if (proxy.termios == NULL) {
420068e8:	07fa16        	beqz	a10, 4200696b <esp_vfs_duplicate_fs_ops+0xc7>
            goto fail;
        }
        memcpy(proxy.termios, orig->termios, sizeof(esp_vfs_termios_ops_t));
420068eb:	cc1c      	movi.n	a12, 28
420068ed:	0c22b2        	l32i	a11, a2, 48
420068f0:	e5ce81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420068f3:	0008e0        	callx8	a8
    }
#endif

#ifdef CONFIG_VFS_SUPPORT_SELECT
    if (orig->select != NULL) {
420068f6:	d288      	l32i.n	a8, a2, 52
420068f8:	889c      	beqz.n	a8, 42006914 <esp_vfs_duplicate_fs_ops+0x70>
        proxy.select = (esp_vfs_select_ops_t*) heap_caps_malloc(sizeof(esp_vfs_select_ops_t), VFS_MALLOC_FLAGS);
420068fa:	e7bdb1        	l32r	a11, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
420068fd:	8a1c      	movi.n	a10, 24
420068ff:	e70881        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006902:	0008e0        	callx8	a8
42006905:	21a9      	s32i.n	a10, a1, 8
        if (proxy.select == NULL) {
42006907:	060a16        	beqz	a10, 4200696b <esp_vfs_duplicate_fs_ops+0xc7>
            goto fail;
        }
        memcpy(proxy.select, orig->select, sizeof(esp_vfs_select_ops_t));
4200690a:	8c1c      	movi.n	a12, 24
4200690c:	d2b8      	l32i.n	a11, a2, 52
4200690e:	e5c681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42006911:	0008e0        	callx8	a8
    }
#endif

    // This tediousness is required because of const members
    esp_vfs_fs_ops_t tmp = {
        .write = orig->write,
42006914:	0288      	l32i.n	a8, a2, 0
    esp_vfs_fs_ops_t tmp = {
42006916:	3189      	s32i.n	a8, a1, 12
        .lseek = orig->lseek,
42006918:	1288      	l32i.n	a8, a2, 4
    esp_vfs_fs_ops_t tmp = {
4200691a:	4189      	s32i.n	a8, a1, 16
        .read = orig->read,
4200691c:	2288      	l32i.n	a8, a2, 8
    esp_vfs_fs_ops_t tmp = {
4200691e:	5189      	s32i.n	a8, a1, 20
        .pread = orig->pread,
42006920:	3288      	l32i.n	a8, a2, 12
    esp_vfs_fs_ops_t tmp = {
42006922:	6189      	s32i.n	a8, a1, 24
        .pwrite = orig->pwrite,
42006924:	4288      	l32i.n	a8, a2, 16
    esp_vfs_fs_ops_t tmp = {
42006926:	7189      	s32i.n	a8, a1, 28
        .open = orig->open,
42006928:	5288      	l32i.n	a8, a2, 20
    esp_vfs_fs_ops_t tmp = {
4200692a:	8189      	s32i.n	a8, a1, 32
        .close = orig->close,
4200692c:	6288      	l32i.n	a8, a2, 24
    esp_vfs_fs_ops_t tmp = {
4200692e:	9189      	s32i.n	a8, a1, 36
        .fstat = orig->fstat,
42006930:	7288      	l32i.n	a8, a2, 28
    esp_vfs_fs_ops_t tmp = {
42006932:	a189      	s32i.n	a8, a1, 40
        .fcntl = orig->fcntl,
42006934:	8288      	l32i.n	a8, a2, 32
    esp_vfs_fs_ops_t tmp = {
42006936:	b189      	s32i.n	a8, a1, 44
        .ioctl = orig->ioctl,
42006938:	9288      	l32i.n	a8, a2, 36
    esp_vfs_fs_ops_t tmp = {
4200693a:	c189      	s32i.n	a8, a1, 48
        .fsync = orig->fsync,
4200693c:	a288      	l32i.n	a8, a2, 40
    esp_vfs_fs_ops_t tmp = {
4200693e:	d189      	s32i.n	a8, a1, 52
#ifdef CONFIG_VFS_SUPPORT_DIR
        .dir = proxy.dir,
42006940:	0188      	l32i.n	a8, a1, 0
    esp_vfs_fs_ops_t tmp = {
42006942:	e189      	s32i.n	a8, a1, 56
#endif
#ifdef CONFIG_VFS_SUPPORT_TERMIOS
        .termios = proxy.termios,
42006944:	1188      	l32i.n	a8, a1, 4
    esp_vfs_fs_ops_t tmp = {
42006946:	f189      	s32i.n	a8, a1, 60
#endif
#ifdef CONFIG_VFS_SUPPORT_SELECT
        .select = proxy.select,
42006948:	022182        	l32i	a8, a1, 8
    esp_vfs_fs_ops_t tmp = {
4200694b:	106182        	s32i	a8, a1, 64
#endif
    };

    esp_vfs_fs_ops_t *out = heap_caps_malloc(sizeof(esp_vfs_fs_ops_t), VFS_MALLOC_FLAGS);
4200694e:	e7a8b1        	l32r	a11, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
42006951:	38a0a2        	movi	a10, 56
42006954:	e6f381        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006957:	0008e0        	callx8	a8
4200695a:	0a2d      	mov.n	a2, a10
    if (out == NULL) {
4200695c:	ba8c      	beqz.n	a10, 4200696b <esp_vfs_duplicate_fs_ops+0xc7>
        goto fail;
    }

    memcpy(out, &tmp, sizeof(esp_vfs_fs_ops_t));
4200695e:	8c3c      	movi.n	a12, 56
42006960:	b1cb      	addi.n	a11, a1, 12
42006962:	e5b181        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42006965:	0008e0        	callx8	a8

    return out;
42006968:	000206        	j	42006974 <esp_vfs_duplicate_fs_ops+0xd0>

fail:
    free_proxy_members(&proxy);
4200696b:	20a110        	or	a10, a1, a1
4200696e:	fff165        	call8	42006884 <free_proxy_members>
    return NULL;
42006971:	00a022        	movi	a2, 0
}
42006974:	000090        	retw
	...

42006978 <esp_vfs_free_fs_ops>:
static void esp_vfs_free_fs_ops(esp_vfs_fs_ops_t *vfs) {
42006978:	004136        	entry	a1, 32
    free((void*)vfs->termios);
4200697b:	0c22a2        	l32i	a10, a2, 48
4200697e:	e6fa81        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42006981:	0008e0        	callx8	a8
    free((void*)vfs->dir);
42006984:	b2a8      	l32i.n	a10, a2, 44
42006986:	e6f881        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42006989:	0008e0        	callx8	a8
    free((void*)vfs->select);
4200698c:	d2a8      	l32i.n	a10, a2, 52
4200698e:	e6f681        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42006991:	0008e0        	callx8	a8
    free(vfs);
42006994:	02ad      	mov.n	a10, a2
42006996:	e6f481        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42006999:	0008e0        	callx8	a8
}
4200699c:	f01d      	retw.n
	...

420069a0 <esp_vfs_register_fs_common>:
    free_proxy_members(&proxy);
    return ESP_ERR_NO_MEM;
}

static esp_err_t esp_vfs_register_fs_common(const char* base_path, size_t len, const esp_vfs_fs_ops_t* vfs, int flags, void* ctx, int *vfs_index)
{
420069a0:	006136        	entry	a1, 48
420069a3:	0159      	s32i.n	a5, a1, 0
420069a5:	1169      	s32i.n	a6, a1, 4
420069a7:	2179      	s32i.n	a7, a1, 8
    if (vfs == NULL) {
420069a9:	0a7416        	beqz	a4, 42006a54 <esp_vfs_register_fs_common+0xb4>
        ESP_LOGE(TAG, "VFS is NULL");
        return ESP_ERR_INVALID_ARG;
    }

    if (len != LEN_PATH_PREFIX_IGNORED) {
420069ac:	300326        	beqi	a3, -1, 420069e0 <esp_vfs_register_fs_common+0x40>
        /* empty prefix is allowed, "/" is not allowed */
        if ((len == 1) || (len > ESP_VFS_PATH_MAX)) {
420069af:	830b      	addi.n	a8, a3, -1
420069b1:	40f880        	nsau	a8, a8
420069b4:	418580        	srli	a8, a8, 5
420069b7:	f90c      	movi.n	a9, 15
420069b9:	629930        	lsi	f3, a9, 0x188
420069bc:	208890        	or	a8, a8, a9
420069bf:	099856        	bnez	a8, 42006a5c <esp_vfs_register_fs_common+0xbc>
            return ESP_ERR_INVALID_ARG;
        }
        /* prefix has to start with "/" and not end with "/" */
        if (len >= 2 && ((base_path[0] != '/') || (base_path[len - 1] == '/'))) {
420069c2:	1a23b6        	bltui	a3, 2, 420069e0 <esp_vfs_register_fs_common+0x40>
420069c5:	000292        	l8ui	a9, a2, 0
420069c8:	f82c      	movi.n	a8, 47
420069ca:	021987        	beq	a9, a8, 420069d0 <esp_vfs_register_fs_common+0x30>
420069cd:	0024c6        	j	42006a64 <esp_vfs_register_fs_common+0xc4>
420069d0:	823a      	add.n	a8, a2, a3
420069d2:	ffc882        	addi	a8, a8, -1
420069d5:	000892        	l8ui	a9, a8, 0
420069d8:	f82c      	movi.n	a8, 47
420069da:	029987        	bne	a9, a8, 420069e0 <esp_vfs_register_fs_common+0x40>
420069dd:	0022c6        	j	42006a6c <esp_vfs_register_fs_common+0xcc>
            return ESP_ERR_INVALID_ARG;
        }
    }

    ssize_t index = esp_get_free_index();
420069e0:	ffe865        	call8	42006868 <esp_get_free_index>
420069e3:	206aa0        	or	a6, a10, a10
    if (index < 0) {
420069e6:	08aa96        	bltz	a10, 42006a74 <esp_vfs_register_fs_common+0xd4>
        return ESP_ERR_NO_MEM;
    }

    if (s_vfs[index] != NULL) {
420069e9:	e79a81        	l32r	a8, 42000854 <_stext+0x834> (3fc94f18 <s_vfs>)
420069ec:	a08a80        	addx4	a8, a10, a8
420069ef:	002882        	l32i	a8, a8, 0
420069f2:	086856        	bnez	a8, 42006a7c <esp_vfs_register_fs_common+0xdc>
        return ESP_ERR_INVALID_STATE;
    }

    if (index == s_vfs_count) {
420069f5:	e79881        	l32r	a8, 42000858 <_stext+0x838> (3fc94f14 <s_vfs_count>)
420069f8:	002882        	l32i	a8, a8, 0
420069fb:	069a87        	bne	a10, a8, 42006a05 <esp_vfs_register_fs_common+0x65>
        s_vfs_count++;
420069fe:	881b      	addi.n	a8, a8, 1
42006a00:	e79691        	l32r	a9, 42000858 <_stext+0x838> (3fc94f14 <s_vfs_count>)
42006a03:	0989      	s32i.n	a8, a9, 0
    }

    vfs_entry_t *entry = (vfs_entry_t*) heap_caps_malloc(sizeof(vfs_entry_t), VFS_MALLOC_FLAGS);
42006a05:	e77ab1        	l32r	a11, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
42006a08:	4a2c      	movi.n	a10, 36
42006a0a:	e6c581        	l32r	a8, 42000520 <_stext+0x500> (40375f38 <heap_caps_malloc>)
42006a0d:	0008e0        	callx8	a8
42006a10:	0a5d      	mov.n	a5, a10
    if (entry == NULL) {
42006a12:	06ca16        	beqz	a10, 42006a82 <esp_vfs_register_fs_common+0xe2>
        return ESP_ERR_NO_MEM;
    }

    s_vfs[index] = entry;
42006a15:	e78f81        	l32r	a8, 42000854 <_stext+0x834> (3fc94f18 <s_vfs>)
42006a18:	a08680        	addx4	a8, a6, a8
42006a1b:	08a9      	s32i.n	a10, a8, 0
    if (len != LEN_PATH_PREFIX_IGNORED) {
42006a1d:	0f0326        	beqi	a3, -1, 42006a30 <esp_vfs_register_fs_common+0x90>
        strcpy(entry->path_prefix, base_path); // we have already verified argument length
42006a20:	20b220        	or	a11, a2, a2
42006a23:	08caa2        	addi	a10, a10, 8
42006a26:	e78d81        	l32r	a8, 4200085c <_stext+0x83c> (40001218 <strcpy>)
42006a29:	0008e0        	callx8	a8
42006a2c:	000286        	j	42006a3a <esp_vfs_register_fs_common+0x9a>
42006a2f:	fb0c00        	f64addc	a0, a12, 0, 0
    } else {
        bzero(entry->path_prefix, sizeof(entry->path_prefix));
42006a32:	aa8b      	addi.n	a10, a10, 8
42006a34:	e78b81        	l32r	a8, 42000860 <_stext+0x840> (40001260 <bzero>)
42006a37:	0008e0        	callx8	a8
    }
    entry->path_prefix_len = len;
42006a3a:	6539      	s32i.n	a3, a5, 24
    entry->vfs = vfs;
42006a3c:	1549      	s32i.n	a4, a5, 4
    entry->ctx = ctx;
42006a3e:	1188      	l32i.n	a8, a1, 4
42006a40:	7589      	s32i.n	a8, a5, 28
    entry->offset = index;
42006a42:	8569      	s32i.n	a6, a5, 32
    entry->flags = flags;
42006a44:	0188      	l32i.n	a8, a1, 0
42006a46:	0589      	s32i.n	a8, a5, 0

    if (vfs_index) {
42006a48:	2188      	l32i.n	a8, a1, 8
42006a4a:	a8bc      	beqz.n	a8, 42006a88 <esp_vfs_register_fs_common+0xe8>
        *vfs_index = index;
42006a4c:	0769      	s32i.n	a6, a7, 0
    }

    return ESP_OK;
42006a4e:	020c      	movi.n	a2, 0
42006a50:	000d86        	j	42006a8a <esp_vfs_register_fs_common+0xea>
42006a53:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42006a56:	0bc602        	addi	a0, a6, 11
42006a59:	000000        	ill
            return ESP_ERR_INVALID_ARG;
42006a5c:	02a122        	movi	a2, 0x102
42006a5f:	0009c6        	j	42006a8a <esp_vfs_register_fs_common+0xea>
42006a62:	220000        	orb	b0, b0, b0
            return ESP_ERR_INVALID_ARG;
42006a65:	c602a1        	l32r	a10, 41ff8270 <_coredump_iram_end+0x1c76370>
42006a68:	000007        	bnone	a0, a0, 42006a6c <esp_vfs_register_fs_common+0xcc>
42006a6b:	a12200        	sll	a2, a2
42006a6e:	05c602        	addi	a0, a6, 5
42006a71:	000000        	ill
        return ESP_ERR_NO_MEM;
42006a74:	01a122        	movi	a2, 0x101
42006a77:	0003c6        	j	42006a8a <esp_vfs_register_fs_common+0xea>
42006a7a:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_STATE;
42006a7d:	c603a1        	l32r	a10, 41ff828c <_coredump_iram_end+0x1c7638c>
42006a80:	220001        	l32r	a0, 41fcf280 <_coredump_iram_end+0x1c4d380>
        return ESP_ERR_NO_MEM;
42006a83:	4601a1        	l32r	a10, 41fd8288 <_coredump_iram_end+0x1c56388>
42006a86:	0c0000        	lsi	f0, a0, 48
    return ESP_OK;
42006a89:	f01d02        	l16ui	a0, a13, 0x1e0

42006a8c <translate_path>:

    return local_fd;
}

static const char* translate_path(const vfs_entry_t* vfs, const char* src_path)
{
42006a8c:	004136        	entry	a1, 32
    assert(strncmp(src_path, vfs->path_prefix, vfs->path_prefix_len) == 0);
42006a8f:	6278      	l32i.n	a7, a2, 24
42006a91:	07cd      	mov.n	a12, a7
42006a93:	b28b      	addi.n	a11, a2, 8
42006a95:	03ad      	mov.n	a10, a3
42006a97:	e77781        	l32r	a8, 42000874 <_stext+0x854> (4000123c <strncmp>)
42006a9a:	0008e0        	callx8	a8
42006a9d:	0a9c      	beqz.n	a10, 42006ab1 <translate_path+0x25>
42006a9f:	e772d1        	l32r	a13, 42000868 <_stext+0x848> (3c024f98 <_flash_rodata_start+0x4e78>)
42006aa2:	e772c1        	l32r	a12, 4200086c <_stext+0x84c> (3c02841c <__func__$1>)
42006aa5:	fca2b2        	movi	a11, 0x2fc
42006aa8:	e772a1        	l32r	a10, 42000870 <_stext+0x850> (3c024f8d <_flash_rodata_start+0x4e6d>)
42006aab:	e58581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42006aae:	0008e0        	callx8	a8
    if (strlen(src_path) == vfs->path_prefix_len) {
42006ab1:	03ad      	mov.n	a10, a3
42006ab3:	e5fa81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006ab6:	0008e0        	callx8	a8
42006ab9:	0417a7        	beq	a7, a10, 42006ac1 <translate_path+0x35>
        // special case when src_path matches the path prefix exactly
        return "/";
    }
    return src_path + vfs->path_prefix_len;
42006abc:	237a      	add.n	a2, a3, a7
42006abe:	000086        	j	42006ac4 <translate_path+0x38>
        return "/";
42006ac1:	e76821        	l32r	a2, 42000864 <_stext+0x844> (3c024f94 <_flash_rodata_start+0x4e74>)
}
42006ac4:	f01d      	retw.n
	...

42006ac8 <esp_vfs_register_fs>:
{
42006ac8:	004136        	entry	a1, 32
    if (vfs == NULL) {
42006acb:	04c316        	beqz	a3, 42006b1b <esp_vfs_register_fs+0x53>
    if ((flags & ESP_VFS_FLAG_STATIC)) {
42006ace:	1c6437        	bbci	a4, 3, 42006aee <esp_vfs_register_fs+0x26>
        return esp_vfs_register_fs_common(base_path, strlen(base_path), vfs, flags, ctx, NULL);
42006ad1:	02ad      	mov.n	a10, a2
42006ad3:	e5f281        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006ad6:	0008e0        	callx8	a8
42006ad9:	0f0c      	movi.n	a15, 0
42006adb:	05ed      	mov.n	a14, a5
42006add:	04dd      	mov.n	a13, a4
42006adf:	03cd      	mov.n	a12, a3
42006ae1:	0abd      	mov.n	a11, a10
42006ae3:	02ad      	mov.n	a10, a2
42006ae5:	ffeba5        	call8	420069a0 <esp_vfs_register_fs_common>
42006ae8:	0a2d      	mov.n	a2, a10
42006aea:	000d86        	j	42006b24 <esp_vfs_register_fs+0x5c>
42006aed:	a33000        	movltz	a3, a0, a0
    esp_vfs_fs_ops_t *_vfs = esp_vfs_duplicate_fs_ops(vfs);
42006af0:	db2520        	movt.s	f2, f5, b2
42006af3:	ff          	.byte	0xff
42006af4:	0a3d      	mov.n	a3, a10
    if (_vfs == NULL) {
42006af6:	7aac      	beqz.n	a10, 42006b21 <esp_vfs_register_fs+0x59>
    esp_err_t ret = esp_vfs_register_fs_common(base_path, strlen(base_path), _vfs, flags, ctx, NULL);
42006af8:	02ad      	mov.n	a10, a2
42006afa:	e5e881        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006afd:	0008e0        	callx8	a8
42006b00:	0f0c      	movi.n	a15, 0
42006b02:	05ed      	mov.n	a14, a5
42006b04:	04dd      	mov.n	a13, a4
42006b06:	03cd      	mov.n	a12, a3
42006b08:	0abd      	mov.n	a11, a10
42006b0a:	02ad      	mov.n	a10, a2
42006b0c:	ffe925        	call8	420069a0 <esp_vfs_register_fs_common>
42006b0f:	0a2d      	mov.n	a2, a10
    if (ret != ESP_OK) {
42006b11:	fa8c      	beqz.n	a10, 42006b24 <esp_vfs_register_fs+0x5c>
        esp_vfs_free_fs_ops(_vfs);
42006b13:	03ad      	mov.n	a10, a3
42006b15:	ffe625        	call8	42006978 <esp_vfs_free_fs_ops>
        return ret;
42006b18:	000206        	j	42006b24 <esp_vfs_register_fs+0x5c>
        return ESP_ERR_INVALID_ARG;
42006b1b:	02a122        	movi	a2, 0x102
42006b1e:	000086        	j	42006b24 <esp_vfs_register_fs+0x5c>
        return ESP_ERR_NO_MEM;
42006b21:	01a122        	movi	a2, 0x101
}
42006b24:	f01d      	retw.n
	...

42006b28 <get_vfs_for_index>:
{
42006b28:	004136        	entry	a1, 32
    if (index < 0 || index >= s_vfs_count) {
42006b2b:	012296        	bltz	a2, 42006b41 <get_vfs_for_index+0x19>
42006b2e:	e74a81        	l32r	a8, 42000858 <_stext+0x838> (3fc94f14 <s_vfs_count>)
42006b31:	0888      	l32i.n	a8, a8, 0
42006b33:	0fb287        	bgeu	a2, a8, 42006b46 <get_vfs_for_index+0x1e>
        return s_vfs[index];
42006b36:	e74781        	l32r	a8, 42000854 <_stext+0x834> (3fc94f18 <s_vfs>)
42006b39:	a02280        	addx4	a2, a2, a8
42006b3c:	0228      	l32i.n	a2, a2, 0
42006b3e:	000186        	j	42006b48 <get_vfs_for_index+0x20>
        return NULL;
42006b41:	020c      	movi.n	a2, 0
42006b43:	000046        	j	42006b48 <get_vfs_for_index+0x20>
42006b46:	020c      	movi.n	a2, 0
}
42006b48:	f01d      	retw.n
	...

42006b4c <get_vfs_for_fd>:
{
42006b4c:	004136        	entry	a1, 32
    if (fd_valid(fd)) {
42006b4f:	3fa082        	movi	a8, 63
42006b52:	173827        	bltu	a8, a2, 42006b6d <get_vfs_for_fd+0x21>
        const int index = s_fd_table[fd].vfs_index; // single read -> no locking is required
42006b55:	902220        	addx2	a2, a2, a2
42006b58:	e74881        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006b5b:	808820        	add	a8, a8, a2
42006b5e:	0108a2        	l8ui	a10, a8, 1
        vfs = get_vfs_for_index(index);
42006b61:	23aa00        	sext	a10, a10, 7
42006b64:	fffc25        	call8	42006b28 <get_vfs_for_index>
42006b67:	202aa0        	or	a2, a10, a10
42006b6a:	000046        	j	42006b6f <get_vfs_for_fd+0x23>
    const vfs_entry_t *vfs = NULL;
42006b6d:	020c      	movi.n	a2, 0
}
42006b6f:	f01d      	retw.n
42006b71:	000000        	ill

42006b74 <get_vfs_for_path>:

const vfs_entry_t* get_vfs_for_path(const char* path)
{
42006b74:	006136        	entry	a1, 48
42006b77:	023d      	mov.n	a3, a2
    const vfs_entry_t* best_match = NULL;
    ssize_t best_match_prefix_len = -1;
    size_t len = strlen(path);
42006b79:	02ad      	mov.n	a10, a2
42006b7b:	e5c881        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42006b7e:	0008e0        	callx8	a8
42006b81:	0a4d      	mov.n	a4, a10
    for (size_t i = 0; i < s_vfs_count; ++i) {
42006b83:	070c      	movi.n	a7, 0
    ssize_t best_match_prefix_len = -1;
42006b85:	f87c      	movi.n	a8, -1
42006b87:	0189      	s32i.n	a8, a1, 0
    const vfs_entry_t* best_match = NULL;
42006b89:	072d      	mov.n	a2, a7
    for (size_t i = 0; i < s_vfs_count; ++i) {
42006b8b:	001146        	j	42006bd4 <get_vfs_for_path+0x60>
42006b8e:	810000        	src	a0, a0, a0
        const vfs_entry_t* vfs = s_vfs[i];
42006b91:	80e731        	l32r	a3, 41fe6f30 <_coredump_iram_end+0x1c65030>
42006b94:	58a087        	bge	a0, a8, 42006bf0 <_open_r+0x10>
42006b97:	bc08      	l32i.n	a0, a12, 44
        if (vfs == NULL || vfs->path_prefix_len == LEN_PATH_PREFIX_IGNORED) {
42006b99:	656865        	call8	4206c220 <_etext+0x55fca>
42006b9c:	320626        	beqi	a6, -1, 42006bd2 <get_vfs_for_path+0x5e>
            continue;
        }
        // match path prefix
        if (len < vfs->path_prefix_len ||
42006b9f:	2f3467        	bltu	a4, a6, 42006bd2 <get_vfs_for_path+0x5e>
            memcmp(path, vfs->path_prefix, vfs->path_prefix_len) != 0) {
42006ba2:	06cd      	mov.n	a12, a6
42006ba4:	b58b      	addi.n	a11, a5, 8
42006ba6:	03ad      	mov.n	a10, a3
42006ba8:	e73581        	l32r	a8, 4200087c <_stext+0x85c> (4000120c <memcmp>)
42006bab:	0008e0        	callx8	a8
        if (len < vfs->path_prefix_len ||
42006bae:	0aec      	bnez.n	a10, 42006bd2 <get_vfs_for_path+0x5e>
            continue;
        }
        // this is the default VFS and we don't have a better match yet.
        if (vfs->path_prefix_len == 0 && !best_match) {
42006bb0:	06cc      	bnez.n	a6, 42006bb4 <get_vfs_for_path+0x40>
42006bb2:	329c      	beqz.n	a2, 42006bc9 <get_vfs_for_path+0x55>
            best_match = vfs;
            continue;
        }
        // if path is not equal to the prefix, expect to see a path separator
        // i.e. don't match "/data" prefix for "/data1/foo.txt" path
        if (len > vfs->path_prefix_len &&
42006bb4:	09b647        	bgeu	a6, a4, 42006bc1 <get_vfs_for_path+0x4d>
                path[vfs->path_prefix_len] != '/') {
42006bb7:	836a      	add.n	a8, a3, a6
42006bb9:	000892        	l8ui	a9, a8, 0
        if (len > vfs->path_prefix_len &&
42006bbc:	f82c      	movi.n	a8, 47
42006bbe:	109987        	bne	a9, a8, 42006bd2 <get_vfs_for_path+0x5e>
        // i.e. if "/dev" and "/dev/uart" both match, for "/dev/uart/1" path,
        // choose "/dev/uart",
        // This causes all s_vfs_count VFS entries to be scanned when opening
        // a file by name. This can be optimized by introducing a table for
        // FS search order, sorted so that longer prefixes are checked first.
        if (best_match_prefix_len < (ssize_t) vfs->path_prefix_len) {
42006bc1:	0188      	l32i.n	a8, a1, 0
42006bc3:	072867        	blt	a8, a6, 42006bce <get_vfs_for_path+0x5a>
42006bc6:	000206        	j	42006bd2 <get_vfs_for_path+0x5e>
            best_match = vfs;
42006bc9:	052d      	mov.n	a2, a5
42006bcb:	0000c6        	j	42006bd2 <get_vfs_for_path+0x5e>
            best_match_prefix_len = (ssize_t) vfs->path_prefix_len;
42006bce:	0169      	s32i.n	a6, a1, 0
            best_match = vfs;
42006bd0:	052d      	mov.n	a2, a5
    for (size_t i = 0; i < s_vfs_count; ++i) {
42006bd2:	771b      	addi.n	a7, a7, 1
42006bd4:	e72181        	l32r	a8, 42000858 <_stext+0x838> (3fc94f14 <s_vfs_count>)
42006bd7:	0888      	l32i.n	a8, a8, 0
42006bd9:	b33787        	bltu	a7, a8, 42006b90 <get_vfs_for_path+0x1c>
        }
    }
    return best_match;
}
42006bdc:	f01d      	retw.n
	...

42006be0 <_open_r>:
        __errno_r(r) = EROFS; \
        return -1; \
    }

int esp_vfs_open(struct _reent *r, const char * path, int flags, int mode)
{
42006be0:	004136        	entry	a1, 32
42006be3:	207220        	or	a7, a2, a2
    const vfs_entry_t *vfs = get_vfs_for_path(path);
42006be6:	20a330        	or	a10, a3, a3
42006be9:	fff8a5        	call8	42006b74 <get_vfs_for_path>
42006bec:	206aa0        	or	a6, a10, a10
    if (vfs == NULL) {
42006bef:	9acc      	bnez.n	a10, 42006bfc <_open_r+0x1c>
        __errno_r(r) = ENOENT;
42006bf1:	280c      	movi.n	a8, 2
42006bf3:	0289      	s32i.n	a8, a2, 0
        return -1;
42006bf5:	f27c      	movi.n	a2, -1
42006bf7:	003946        	j	42006ce0 <_open_r+0x100>
42006bfa:	400000        	ssr	a0
    }

    int acc_mode = flags & O_ACCMODE;
42006bfd:	281480        	lsi	f8, a4, 160
    int ro_filesystem = vfs->flags & ESP_VFS_FLAG_READONLY_FS;
42006c00:	0c0a      	add.n	a0, a12, a0
    if (acc_mode != O_RDONLY && ro_filesystem) {
42006c02:	8019      	s32i.n	a1, a0, 32
42006c04:	8398      	l32i.n	a9, a3, 32
42006c06:	048220        	extui	a8, a2, 2, 1
42006c09:	080987        	bnone	a9, a8, 42006c15 <_open_r+0x35>
        __errno_r(r) = EROFS;
42006c0c:	e81c      	movi.n	a8, 30
42006c0e:	0789      	s32i.n	a8, a7, 0
        return -1;
42006c10:	f27c      	movi.n	a2, -1
42006c12:	003286        	j	42006ce0 <_open_r+0x100>
    }

    const char *path_within_vfs = translate_path(vfs, path);
42006c15:	20b330        	or	a11, a3, a3
42006c18:	ffe725        	call8	42006a8c <translate_path>
    int fd_within_vfs;
    CHECK_AND_CALL(fd_within_vfs, r, vfs, open, path_within_vfs, flags, mode);
42006c1b:	012682        	l32i	a8, a6, 4
42006c1e:	052882        	l32i	a8, a8, 20
42006c21:	78cc      	bnez.n	a8, 42006c2c <_open_r+0x4c>
42006c23:	885c      	movi.n	a8, 88
42006c25:	0789      	s32i.n	a8, a7, 0
42006c27:	f27c      	movi.n	a2, -1
42006c29:	002cc6        	j	42006ce0 <_open_r+0x100>
42006c2c:	116217        	bbci	a2, 1, 42006c41 <_open_r+0x61>
42006c2f:	05dd      	mov.n	a13, a5
42006c31:	04cd      	mov.n	a12, a4
42006c33:	0abd      	mov.n	a11, a10
42006c35:	76a8      	l32i.n	a10, a6, 28
42006c37:	0008e0        	callx8	a8
42006c3a:	0a5d      	mov.n	a5, a10
42006c3c:	000286        	j	42006c4a <_open_r+0x6a>
42006c3f:	cd0000        	lsi	f0, a0, 0x334
42006c42:	04bd05        	call0	4200b814 <get_arg$isra$0+0x204>
42006c45:	0008e0        	callx8	a8
42006c48:	0a5d      	mov.n	a5, a10
    if (fd_within_vfs >= 0) {
42006c4a:	086596        	bltz	a5, 42006cd4 <_open_r+0xf4>
        _lock_acquire(&s_fd_table_lock);
42006c4d:	e70ca1        	l32r	a10, 42000880 <_stext+0x860> (3fc94f10 <s_fd_table_lock>)
42006c50:	e6bd81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42006c53:	0008e0        	callx8	a8
        for (int i = 0; i < MAX_FDS; ++i) {
42006c56:	020c      	movi.n	a2, 0
42006c58:	000e86        	j	42006c96 <_open_r+0xb6>
42006c5b:	922000        	lsi	f0, a0, 0x248
            if (s_fd_table[i].vfs_index == -1) {
42006c5e:	068190        	lsi	f9, a1, 24
42006c61:	889ae7        	bne	a10, a14, 42006bed <_open_r+0xd>
42006c64:	010882        	l8ui	a8, a8, 1
42006c67:	238800        	sext	a8, a8, 7
42006c6a:	260866        	bnei	a8, -1, 42006c94 <_open_r+0xb4>
                s_fd_table[i].permanent = false;
42006c6d:	e70281        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006c70:	889a      	add.n	a8, a8, a9
42006c72:	000892        	l8ui	a9, a8, 0
42006c75:	feafa2        	movi	a10, -2
42006c78:	1099a0        	and	a9, a9, a10
42006c7b:	004892        	s8i	a9, a8, 0
                s_fd_table[i].vfs_index = vfs->offset;
42006c7e:	082692        	l32i	a9, a6, 32
42006c81:	014892        	s8i	a9, a8, 1
                s_fd_table[i].local_fd = fd_within_vfs;
42006c84:	024852        	s8i	a5, a8, 2
                _lock_release(&s_fd_table_lock);
42006c87:	e6fea1        	l32r	a10, 42000880 <_stext+0x860> (3fc94f10 <s_fd_table_lock>)
42006c8a:	e6af81        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42006c8d:	0008e0        	callx8	a8
                return i;
42006c90:	001306        	j	42006ce0 <_open_r+0x100>
42006c93:	221b00        	orb	b1, b11, b0
        for (int i = 0; i < MAX_FDS; ++i) {
42006c96:	f83c      	movi.n	a8, 63
42006c98:	c0a827        	bge	a8, a2, 42006c5c <_open_r+0x7c>
            }
        }
        _lock_release(&s_fd_table_lock);
42006c9b:	e6f9a1        	l32r	a10, 42000880 <_stext+0x860> (3fc94f10 <s_fd_table_lock>)
42006c9e:	e6aa81        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42006ca1:	0008e0        	callx8	a8
        int ret;
        CHECK_AND_CALL(ret, r, vfs, close, fd_within_vfs);
42006ca4:	1688      	l32i.n	a8, a6, 4
42006ca6:	6888      	l32i.n	a8, a8, 24
42006ca8:	78cc      	bnez.n	a8, 42006cb3 <_open_r+0xd3>
42006caa:	885c      	movi.n	a8, 88
42006cac:	0789      	s32i.n	a8, a7, 0
42006cae:	f27c      	movi.n	a2, -1
42006cb0:	000b06        	j	42006ce0 <_open_r+0x100>
42006cb3:	0698      	l32i.n	a9, a6, 0
42006cb5:	0b6917        	bbci	a9, 1, 42006cc4 <_open_r+0xe4>
42006cb8:	05bd      	mov.n	a11, a5
42006cba:	0726a2        	l32i	a10, a6, 28
42006cbd:	0008e0        	callx8	a8
42006cc0:	000146        	j	42006cc9 <_open_r+0xe9>
42006cc3:	05ad00        	extui	a10, a0, 29, 1
42006cc6:	0008e0        	callx8	a8
        (void) ret; // remove "set but not used" warning
        __errno_r(r) = ENOMEM;
42006cc9:	c80c      	movi.n	a8, 12
42006ccb:	0789      	s32i.n	a8, a7, 0
        return -1;
42006ccd:	f27c      	movi.n	a2, -1
42006ccf:	000346        	j	42006ce0 <_open_r+0x100>
42006cd2:	650000        	extui	a0, a0, 16, 7
    }
    __errno_r(r) = errno;
42006cd5:	047b      	addi.n	a0, a4, 7
42006cd7:	002a82        	l32i	a8, a10, 0
42006cda:	006782        	s32i	a8, a7, 0
    return -1;
42006cdd:	ffaf22        	movi	a2, -1
}
42006ce0:	f01d      	retw.n
	...

42006ce4 <_write_r>:

ssize_t esp_vfs_write(struct _reent *r, int fd, const void * data, size_t size)
{
42006ce4:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42006ce7:	03ad      	mov.n	a10, a3
42006ce9:	ffe625        	call8	42006b4c <get_vfs_for_fd>
42006cec:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42006cee:	2a9c      	beqz.n	a10, 42006d04 <_write_r+0x20>
42006cf0:	f93c      	movi.n	a9, 63
42006cf2:	133937        	bltu	a9, a3, 42006d09 <_write_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42006cf5:	903330        	addx2	a3, a3, a3
42006cf8:	e6e091        	l32r	a9, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006cfb:	993a      	add.n	a9, a9, a3
42006cfd:	0209a2        	l8ui	a10, a9, 2
42006d00:	0001c6        	j	42006d0b <_write_r+0x27>
42006d03:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
42006d06:	000046        	j	42006d0b <_write_r+0x27>
42006d09:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42006d0b:	40f890        	nsau	a9, a8
42006d0e:	419590        	srli	a9, a9, 5
42006d11:	05bfa0        	extui	a11, a10, 31, 1
42006d14:	2099b0        	or	a9, a9, a11
42006d17:	798c      	beqz.n	a9, 42006d22 <_write_r+0x3e>
        __errno_r(r) = EBADF;
42006d19:	980c      	movi.n	a8, 9
42006d1b:	0289      	s32i.n	a8, a2, 0
        return -1;
42006d1d:	f27c      	movi.n	a2, -1
42006d1f:	000b06        	j	42006d4f <_write_r+0x6b>
    }
    ssize_t ret;
    CHECK_AND_CALL(ret, r, vfs, write, local_fd, data, size);
42006d22:	1898      	l32i.n	a9, a8, 4
42006d24:	0998      	l32i.n	a9, a9, 0
42006d26:	79cc      	bnez.n	a9, 42006d31 <_write_r+0x4d>
42006d28:	885c      	movi.n	a8, 88
42006d2a:	0289      	s32i.n	a8, a2, 0
42006d2c:	f27c      	movi.n	a2, -1
42006d2e:	000746        	j	42006d4f <_write_r+0x6b>
42006d31:	08b8      	l32i.n	a11, a8, 0
42006d33:	0f6b17        	bbci	a11, 1, 42006d46 <_write_r+0x62>
42006d36:	05dd      	mov.n	a13, a5
42006d38:	04cd      	mov.n	a12, a4
42006d3a:	0abd      	mov.n	a11, a10
42006d3c:	78a8      	l32i.n	a10, a8, 28
42006d3e:	0009e0        	callx8	a9
42006d41:	0a2d      	mov.n	a2, a10
42006d43:	000206        	j	42006d4f <_write_r+0x6b>
42006d46:	05cd      	mov.n	a12, a5
42006d48:	04bd      	mov.n	a11, a4
42006d4a:	0009e0        	callx8	a9
42006d4d:	0a2d      	mov.n	a2, a10
    return ret;
}
42006d4f:	f01d      	retw.n
42006d51:	000000        	ill

42006d54 <_lseek_r>:

off_t esp_vfs_lseek(struct _reent *r, int fd, off_t size, int mode)
{
42006d54:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42006d57:	03ad      	mov.n	a10, a3
42006d59:	ffdf25        	call8	42006b4c <get_vfs_for_fd>
42006d5c:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42006d5e:	2a9c      	beqz.n	a10, 42006d74 <_lseek_r+0x20>
42006d60:	f93c      	movi.n	a9, 63
42006d62:	133937        	bltu	a9, a3, 42006d79 <_lseek_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42006d65:	903330        	addx2	a3, a3, a3
42006d68:	e6c491        	l32r	a9, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006d6b:	993a      	add.n	a9, a9, a3
42006d6d:	0209a2        	l8ui	a10, a9, 2
42006d70:	0001c6        	j	42006d7b <_lseek_r+0x27>
42006d73:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
42006d76:	000046        	j	42006d7b <_lseek_r+0x27>
42006d79:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42006d7b:	40f890        	nsau	a9, a8
42006d7e:	419590        	srli	a9, a9, 5
42006d81:	05bfa0        	extui	a11, a10, 31, 1
42006d84:	2099b0        	or	a9, a9, a11
42006d87:	798c      	beqz.n	a9, 42006d92 <_lseek_r+0x3e>
        __errno_r(r) = EBADF;
42006d89:	980c      	movi.n	a8, 9
42006d8b:	0289      	s32i.n	a8, a2, 0
        return -1;
42006d8d:	f27c      	movi.n	a2, -1
42006d8f:	000b06        	j	42006dbf <_lseek_r+0x6b>
    }
    off_t ret;
    CHECK_AND_CALL(ret, r, vfs, lseek, local_fd, size, mode);
42006d92:	1898      	l32i.n	a9, a8, 4
42006d94:	1998      	l32i.n	a9, a9, 4
42006d96:	79cc      	bnez.n	a9, 42006da1 <_lseek_r+0x4d>
42006d98:	885c      	movi.n	a8, 88
42006d9a:	0289      	s32i.n	a8, a2, 0
42006d9c:	f27c      	movi.n	a2, -1
42006d9e:	000746        	j	42006dbf <_lseek_r+0x6b>
42006da1:	08b8      	l32i.n	a11, a8, 0
42006da3:	0f6b17        	bbci	a11, 1, 42006db6 <_lseek_r+0x62>
42006da6:	05dd      	mov.n	a13, a5
42006da8:	04cd      	mov.n	a12, a4
42006daa:	0abd      	mov.n	a11, a10
42006dac:	78a8      	l32i.n	a10, a8, 28
42006dae:	0009e0        	callx8	a9
42006db1:	0a2d      	mov.n	a2, a10
42006db3:	000206        	j	42006dbf <_lseek_r+0x6b>
42006db6:	05cd      	mov.n	a12, a5
42006db8:	04bd      	mov.n	a11, a4
42006dba:	0009e0        	callx8	a9
42006dbd:	0a2d      	mov.n	a2, a10
    return ret;
}
42006dbf:	f01d      	retw.n
42006dc1:	000000        	ill

42006dc4 <_read_r>:

ssize_t esp_vfs_read(struct _reent *r, int fd, void * dst, size_t size)
{
42006dc4:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42006dc7:	03ad      	mov.n	a10, a3
42006dc9:	ffd825        	call8	42006b4c <get_vfs_for_fd>
42006dcc:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42006dce:	2a9c      	beqz.n	a10, 42006de4 <_read_r+0x20>
42006dd0:	f93c      	movi.n	a9, 63
42006dd2:	133937        	bltu	a9, a3, 42006de9 <_read_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42006dd5:	903330        	addx2	a3, a3, a3
42006dd8:	e6a891        	l32r	a9, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006ddb:	993a      	add.n	a9, a9, a3
42006ddd:	0209a2        	l8ui	a10, a9, 2
42006de0:	0001c6        	j	42006deb <_read_r+0x27>
42006de3:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
42006de6:	000046        	j	42006deb <_read_r+0x27>
42006de9:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42006deb:	40f890        	nsau	a9, a8
42006dee:	419590        	srli	a9, a9, 5
42006df1:	05bfa0        	extui	a11, a10, 31, 1
42006df4:	2099b0        	or	a9, a9, a11
42006df7:	798c      	beqz.n	a9, 42006e02 <_read_r+0x3e>
        __errno_r(r) = EBADF;
42006df9:	980c      	movi.n	a8, 9
42006dfb:	0289      	s32i.n	a8, a2, 0
        return -1;
42006dfd:	f27c      	movi.n	a2, -1
42006dff:	000b06        	j	42006e2f <_read_r+0x6b>
    }
    ssize_t ret;
    CHECK_AND_CALL(ret, r, vfs, read, local_fd, dst, size);
42006e02:	1898      	l32i.n	a9, a8, 4
42006e04:	2998      	l32i.n	a9, a9, 8
42006e06:	79cc      	bnez.n	a9, 42006e11 <_read_r+0x4d>
42006e08:	885c      	movi.n	a8, 88
42006e0a:	0289      	s32i.n	a8, a2, 0
42006e0c:	f27c      	movi.n	a2, -1
42006e0e:	000746        	j	42006e2f <_read_r+0x6b>
42006e11:	08b8      	l32i.n	a11, a8, 0
42006e13:	0f6b17        	bbci	a11, 1, 42006e26 <_read_r+0x62>
42006e16:	05dd      	mov.n	a13, a5
42006e18:	04cd      	mov.n	a12, a4
42006e1a:	0abd      	mov.n	a11, a10
42006e1c:	78a8      	l32i.n	a10, a8, 28
42006e1e:	0009e0        	callx8	a9
42006e21:	0a2d      	mov.n	a2, a10
42006e23:	000206        	j	42006e2f <_read_r+0x6b>
42006e26:	05cd      	mov.n	a12, a5
42006e28:	04bd      	mov.n	a11, a4
42006e2a:	0009e0        	callx8	a9
42006e2d:	0a2d      	mov.n	a2, a10
    return ret;
}
42006e2f:	f01d      	retw.n
42006e31:	000000        	ill

42006e34 <_close_r>:
    CHECK_AND_CALL(ret, r, vfs, pwrite, local_fd, src, size, offset);
    return ret;
}

int esp_vfs_close(struct _reent *r, int fd)
{
42006e34:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42006e37:	03ad      	mov.n	a10, a3
42006e39:	ffd125        	call8	42006b4c <get_vfs_for_fd>
42006e3c:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42006e3e:	2a9c      	beqz.n	a10, 42006e54 <_close_r+0x20>
42006e40:	f93c      	movi.n	a9, 63
42006e42:	133937        	bltu	a9, a3, 42006e59 <_close_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42006e45:	90a330        	addx2	a10, a3, a3
42006e48:	e68c91        	l32r	a9, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006e4b:	99aa      	add.n	a9, a9, a10
42006e4d:	0209a2        	l8ui	a10, a9, 2
42006e50:	0001c6        	j	42006e5b <_close_r+0x27>
42006e53:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
42006e56:	000046        	j	42006e5b <_close_r+0x27>
42006e59:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42006e5b:	40f890        	nsau	a9, a8
42006e5e:	419590        	srli	a9, a9, 5
42006e61:	05bfa0        	extui	a11, a10, 31, 1
42006e64:	2099b0        	or	a9, a9, a11
42006e67:	798c      	beqz.n	a9, 42006e72 <_close_r+0x3e>
        __errno_r(r) = EBADF;
42006e69:	980c      	movi.n	a8, 9
42006e6b:	0289      	s32i.n	a8, a2, 0
        return -1;
42006e6d:	f27c      	movi.n	a2, -1
42006e6f:	002086        	j	42006ef5 <_close_r+0xc1>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, close, local_fd);
42006e72:	1898      	l32i.n	a9, a8, 4
42006e74:	6998      	l32i.n	a9, a9, 24
42006e76:	79cc      	bnez.n	a9, 42006e81 <_close_r+0x4d>
42006e78:	885c      	movi.n	a8, 88
42006e7a:	0289      	s32i.n	a8, a2, 0
42006e7c:	f27c      	movi.n	a2, -1
42006e7e:	001cc6        	j	42006ef5 <_close_r+0xc1>
42006e81:	08b8      	l32i.n	a11, a8, 0
42006e83:	0e6b17        	bbci	a11, 1, 42006e95 <_close_r+0x61>
42006e86:	0abd      	mov.n	a11, a10
42006e88:	78a8      	l32i.n	a10, a8, 28
42006e8a:	0009e0        	callx8	a9
42006e8d:	0a2d      	mov.n	a2, a10
42006e8f:	000206        	j	42006e9b <_close_r+0x67>
42006e92:	000000        	ill
42006e95:	0009e0        	callx8	a9
42006e98:	202aa0        	or	a2, a10, a10

    _lock_acquire(&s_fd_table_lock);
42006e9b:	e679a1        	l32r	a10, 42000880 <_stext+0x860> (3fc94f10 <s_fd_table_lock>)
42006e9e:	e62981        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
42006ea1:	0008e0        	callx8	a8
    if (!s_fd_table[fd].permanent) {
42006ea4:	909330        	addx2	a9, a3, a3
42006ea7:	e67481        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006eaa:	889a      	add.n	a8, a8, a9
42006eac:	000882        	l8ui	a8, a8, 0
42006eaf:	39e807        	bbsi	a8, 0, 42006eec <_close_r+0xb8>
        if (s_fd_table[fd].has_pending_select) {
42006eb2:	e67181        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006eb5:	889a      	add.n	a8, a8, a9
42006eb7:	000882        	l8ui	a8, a8, 0
42006eba:	126827        	bbci	a8, 2, 42006ed0 <_close_r+0x9c>
            s_fd_table[fd].has_pending_close = true;
42006ebd:	e66e81        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006ec0:	389a      	add.n	a3, a8, a9
42006ec2:	000382        	l8ui	a8, a3, 0
42006ec5:	290c      	movi.n	a9, 2
42006ec7:	208890        	or	a8, a8, a9
42006eca:	004382        	s8i	a8, a3, 0
42006ecd:	0006c6        	j	42006eec <_close_r+0xb8>
        } else {
            s_fd_table[fd] = FD_TABLE_ENTRY_UNUSED;
42006ed0:	903330        	addx2	a3, a3, a3
42006ed3:	e66981        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006ed6:	383a      	add.n	a3, a8, a3
42006ed8:	3c0c      	movi.n	a12, 3
42006eda:	0b0c      	movi.n	a11, 0
42006edc:	03ad      	mov.n	a10, a3
42006ede:	e50881        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42006ee1:	0008e0        	callx8	a8
42006ee4:	f87c      	movi.n	a8, -1
42006ee6:	014382        	s8i	a8, a3, 1
42006ee9:	024382        	s8i	a8, a3, 2
        }
    }
    _lock_release(&s_fd_table_lock);
42006eec:	e665a1        	l32r	a10, 42000880 <_stext+0x860> (3fc94f10 <s_fd_table_lock>)
42006eef:	e61681        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
42006ef2:	0008e0        	callx8	a8
    return ret;
}
42006ef5:	f01d      	retw.n
	...

42006ef8 <_fstat_r>:

int esp_vfs_fstat(struct _reent *r, int fd, struct stat * st)
{
42006ef8:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42006efb:	03ad      	mov.n	a10, a3
42006efd:	ffc4e5        	call8	42006b4c <get_vfs_for_fd>
42006f00:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42006f02:	2a9c      	beqz.n	a10, 42006f18 <_fstat_r+0x20>
42006f04:	f93c      	movi.n	a9, 63
42006f06:	133937        	bltu	a9, a3, 42006f1d <_fstat_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42006f09:	903330        	addx2	a3, a3, a3
42006f0c:	e65b91        	l32r	a9, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006f0f:	993a      	add.n	a9, a9, a3
42006f11:	0209a2        	l8ui	a10, a9, 2
42006f14:	0001c6        	j	42006f1f <_fstat_r+0x27>
42006f17:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
42006f1a:	000046        	j	42006f1f <_fstat_r+0x27>
42006f1d:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42006f1f:	40f890        	nsau	a9, a8
42006f22:	419590        	srli	a9, a9, 5
42006f25:	05bfa0        	extui	a11, a10, 31, 1
42006f28:	2099b0        	or	a9, a9, a11
42006f2b:	798c      	beqz.n	a9, 42006f36 <_fstat_r+0x3e>
        __errno_r(r) = EBADF;
42006f2d:	980c      	movi.n	a8, 9
42006f2f:	0289      	s32i.n	a8, a2, 0
        return -1;
42006f31:	f27c      	movi.n	a2, -1
42006f33:	000a46        	j	42006f60 <_fstat_r+0x68>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, fstat, local_fd, st);
42006f36:	1898      	l32i.n	a9, a8, 4
42006f38:	7998      	l32i.n	a9, a9, 28
42006f3a:	79cc      	bnez.n	a9, 42006f45 <_fstat_r+0x4d>
42006f3c:	885c      	movi.n	a8, 88
42006f3e:	0289      	s32i.n	a8, a2, 0
42006f40:	f27c      	movi.n	a2, -1
42006f42:	000686        	j	42006f60 <_fstat_r+0x68>
42006f45:	08b8      	l32i.n	a11, a8, 0
42006f47:	0e6b17        	bbci	a11, 1, 42006f59 <_fstat_r+0x61>
42006f4a:	04cd      	mov.n	a12, a4
42006f4c:	0abd      	mov.n	a11, a10
42006f4e:	0728a2        	l32i	a10, a8, 28
42006f51:	0009e0        	callx8	a9
42006f54:	0a2d      	mov.n	a2, a10
42006f56:	000186        	j	42006f60 <_fstat_r+0x68>
42006f59:	04bd      	mov.n	a11, a4
42006f5b:	0009e0        	callx8	a9
42006f5e:	0a2d      	mov.n	a2, a10
    return ret;
}
42006f60:	f01d      	retw.n
	...

42006f64 <_fcntl_r>:

int esp_vfs_fcntl_r(struct _reent *r, int fd, int cmd, int arg)
{
42006f64:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42006f67:	03ad      	mov.n	a10, a3
42006f69:	ffbe25        	call8	42006b4c <get_vfs_for_fd>
42006f6c:	0a8d      	mov.n	a8, a10
    if (vfs && fd_valid(fd)) {
42006f6e:	2a9c      	beqz.n	a10, 42006f84 <_fcntl_r+0x20>
42006f70:	f93c      	movi.n	a9, 63
42006f72:	133937        	bltu	a9, a3, 42006f89 <_fcntl_r+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42006f75:	903330        	addx2	a3, a3, a3
42006f78:	e64091        	l32r	a9, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006f7b:	993a      	add.n	a9, a9, a3
42006f7d:	0209a2        	l8ui	a10, a9, 2
42006f80:	0001c6        	j	42006f8b <_fcntl_r+0x27>
42006f83:	fa7c00        	mov.s	f7, f12
    int local_fd = -1;
42006f86:	000046        	j	42006f8b <_fcntl_r+0x27>
42006f89:	fa7c      	movi.n	a10, -1
    const int local_fd = get_local_fd(vfs, fd);
    if (vfs == NULL || local_fd < 0) {
42006f8b:	40f890        	nsau	a9, a8
42006f8e:	419590        	srli	a9, a9, 5
42006f91:	05bfa0        	extui	a11, a10, 31, 1
42006f94:	2099b0        	or	a9, a9, a11
42006f97:	798c      	beqz.n	a9, 42006fa2 <_fcntl_r+0x3e>
        __errno_r(r) = EBADF;
42006f99:	980c      	movi.n	a8, 9
42006f9b:	0289      	s32i.n	a8, a2, 0
        return -1;
42006f9d:	f27c      	movi.n	a2, -1
42006f9f:	000b06        	j	42006fcf <_fcntl_r+0x6b>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, fcntl, local_fd, cmd, arg);
42006fa2:	1898      	l32i.n	a9, a8, 4
42006fa4:	8998      	l32i.n	a9, a9, 32
42006fa6:	79cc      	bnez.n	a9, 42006fb1 <_fcntl_r+0x4d>
42006fa8:	885c      	movi.n	a8, 88
42006faa:	0289      	s32i.n	a8, a2, 0
42006fac:	f27c      	movi.n	a2, -1
42006fae:	000746        	j	42006fcf <_fcntl_r+0x6b>
42006fb1:	08b8      	l32i.n	a11, a8, 0
42006fb3:	0f6b17        	bbci	a11, 1, 42006fc6 <_fcntl_r+0x62>
42006fb6:	05dd      	mov.n	a13, a5
42006fb8:	04cd      	mov.n	a12, a4
42006fba:	0abd      	mov.n	a11, a10
42006fbc:	78a8      	l32i.n	a10, a8, 28
42006fbe:	0009e0        	callx8	a9
42006fc1:	0a2d      	mov.n	a2, a10
42006fc3:	000206        	j	42006fcf <_fcntl_r+0x6b>
42006fc6:	05cd      	mov.n	a12, a5
42006fc8:	04bd      	mov.n	a11, a4
42006fca:	0009e0        	callx8	a9
42006fcd:	0a2d      	mov.n	a2, a10
    return ret;
}
42006fcf:	f01d      	retw.n
42006fd1:	000000        	ill

42006fd4 <esp_vfs_fsync>:
    va_end(args);
    return ret;
}

int esp_vfs_fsync(int fd)
{
42006fd4:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42006fd7:	02ad      	mov.n	a10, a2
42006fd9:	ffb725        	call8	42006b4c <get_vfs_for_fd>
42006fdc:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
42006fde:	2a9c      	beqz.n	a10, 42006ff4 <esp_vfs_fsync+0x20>
42006fe0:	f83c      	movi.n	a8, 63
42006fe2:	133827        	bltu	a8, a2, 42006ff9 <esp_vfs_fsync+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42006fe5:	902220        	addx2	a2, a2, a2
42006fe8:	e62481        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42006feb:	882a      	add.n	a8, a8, a2
42006fed:	020822        	l8ui	a2, a8, 2
42006ff0:	0001c6        	j	42006ffb <esp_vfs_fsync+0x27>
42006ff3:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
42006ff6:	000046        	j	42006ffb <esp_vfs_fsync+0x27>
42006ff9:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
42006ffb:	e5d581        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
42006ffe:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
42007001:	40f780        	nsau	a8, a7
42007004:	418580        	srli	a8, a8, 5
42007007:	059f20        	extui	a9, a2, 31, 1
4200700a:	208890        	or	a8, a8, a9
4200700d:	788c      	beqz.n	a8, 42007018 <esp_vfs_fsync+0x44>
        __errno_r(r) = EBADF;
4200700f:	980c      	movi.n	a8, 9
42007011:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007013:	f27c      	movi.n	a2, -1
42007015:	0009c6        	j	42007040 <esp_vfs_fsync+0x6c>
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, fsync, local_fd);
42007018:	1788      	l32i.n	a8, a7, 4
4200701a:	a888      	l32i.n	a8, a8, 40
4200701c:	88cc      	bnez.n	a8, 42007028 <esp_vfs_fsync+0x54>
4200701e:	885c      	movi.n	a8, 88
42007020:	0a89      	s32i.n	a8, a10, 0
42007022:	f27c      	movi.n	a2, -1
42007024:	000606        	j	42007040 <esp_vfs_fsync+0x6c>
42007027:	079800        	lsi	f0, a8, 28
4200702a:	0b6917        	bbci	a9, 1, 42007039 <esp_vfs_fsync+0x65>
4200702d:	02bd      	mov.n	a11, a2
4200702f:	77a8      	l32i.n	a10, a7, 28
42007031:	0008e0        	callx8	a8
42007034:	0a2d      	mov.n	a2, a10
42007036:	000186        	j	42007040 <esp_vfs_fsync+0x6c>
42007039:	02ad      	mov.n	a10, a2
4200703b:	0008e0        	callx8	a8
4200703e:	0a2d      	mov.n	a2, a10
    return ret;
}
42007040:	f01d      	retw.n
	...

42007044 <_stat_r>:

#ifdef CONFIG_VFS_SUPPORT_DIR

int esp_vfs_stat(struct _reent *r, const char * path, struct stat * st)
{
42007044:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(path);
42007047:	03ad      	mov.n	a10, a3
42007049:	ffb2a5        	call8	42006b74 <get_vfs_for_path>
4200704c:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
4200704e:	8acc      	bnez.n	a10, 4200705a <_stat_r+0x16>
        __errno_r(r) = ENOENT;
42007050:	280c      	movi.n	a8, 2
42007052:	0289      	s32i.n	a8, a2, 0
        return -1;
42007054:	f27c      	movi.n	a2, -1
42007056:	000d86        	j	42007090 <_stat_r+0x4c>
42007059:	b33000        	movgez	a3, a0, a0
    }
    const char* path_within_vfs = translate_path(vfs, path);
4200705c:	a2e520        	muluh	a14, a5, a2
4200705f:	ff          	.byte	0xff
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, stat, path_within_vfs, st);
42007060:	012782        	l32i	a8, a7, 4
42007063:	0b2882        	l32i	a8, a8, 44
42007066:	288c      	beqz.n	a8, 4200706c <_stat_r+0x28>
42007068:	0888      	l32i.n	a8, a8, 0
4200706a:	78cc      	bnez.n	a8, 42007075 <_stat_r+0x31>
4200706c:	885c      	movi.n	a8, 88
4200706e:	0289      	s32i.n	a8, a2, 0
42007070:	f27c      	movi.n	a2, -1
42007072:	000686        	j	42007090 <_stat_r+0x4c>
42007075:	0798      	l32i.n	a9, a7, 0
42007077:	0e6917        	bbci	a9, 1, 42007089 <_stat_r+0x45>
4200707a:	04cd      	mov.n	a12, a4
4200707c:	0abd      	mov.n	a11, a10
4200707e:	0727a2        	l32i	a10, a7, 28
42007081:	0008e0        	callx8	a8
42007084:	0a2d      	mov.n	a2, a10
42007086:	000186        	j	42007090 <_stat_r+0x4c>
42007089:	04bd      	mov.n	a11, a4
4200708b:	0008e0        	callx8	a8
4200708e:	0a2d      	mov.n	a2, a10
    return ret;
}
42007090:	f01d      	retw.n
	...

42007094 <_link_r>:
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, utime, path_within_vfs, times);
    return ret;
}

int esp_vfs_link(struct _reent *r, const char* n1, const char* n2)
{
42007094:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(n1);
42007097:	03ad      	mov.n	a10, a3
42007099:	ffada5        	call8	42006b74 <get_vfs_for_path>
4200709c:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
4200709e:	7acc      	bnez.n	a10, 420070a9 <_link_r+0x15>
        __errno_r(r) = ENOENT;
420070a0:	280c      	movi.n	a8, 2
420070a2:	0289      	s32i.n	a8, a2, 0
        return -1;
420070a4:	f27c      	movi.n	a2, -1
420070a6:	001906        	j	4200710e <_link_r+0x7a>
    }
    const vfs_entry_t* vfs2 = get_vfs_for_path(n2);
420070a9:	20a440        	or	a10, a4, a4
420070ac:	ffac65        	call8	42006b74 <get_vfs_for_path>
    if (vfs != vfs2) {
420070af:	0a17a7        	beq	a7, a10, 420070bd <_link_r+0x29>
        __errno_r(r) = EXDEV;
420070b2:	12a082        	movi	a8, 18
420070b5:	006282        	s32i	a8, a2, 0
        return -1;
420070b8:	f27c      	movi.n	a2, -1
420070ba:	001406        	j	4200710e <_link_r+0x7a>
    }

    CHECK_VFS_READONLY_FLAG(vfs2->flags);
420070bd:	0a88      	l32i.n	a8, a10, 0
420070bf:	096827        	bbci	a8, 2, 420070cc <_link_r+0x38>
420070c2:	e81c      	movi.n	a8, 30
420070c4:	0289      	s32i.n	a8, a2, 0
420070c6:	f27c      	movi.n	a2, -1
420070c8:	001086        	j	4200710e <_link_r+0x7a>
420070cb:	b33000        	movgez	a3, a0, a0

    const char* path1_within_vfs = translate_path(vfs, n1);
420070ce:	a77020        	lsi	f2, a0, 0x29c
420070d1:	9ba520        	movnez.s	f10, f5, a2
420070d4:	ff          	.byte	0xff
420070d5:	0a3d      	mov.n	a3, a10
    const char* path2_within_vfs = translate_path(vfs, n2);
420070d7:	04bd      	mov.n	a11, a4
420070d9:	07ad      	mov.n	a10, a7
420070db:	ff9b25        	call8	42006a8c <translate_path>
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, link, path1_within_vfs, path2_within_vfs);
420070de:	1788      	l32i.n	a8, a7, 4
420070e0:	b888      	l32i.n	a8, a8, 44
420070e2:	288c      	beqz.n	a8, 420070e8 <_link_r+0x54>
420070e4:	1888      	l32i.n	a8, a8, 4
420070e6:	88cc      	bnez.n	a8, 420070f2 <_link_r+0x5e>
420070e8:	885c      	movi.n	a8, 88
420070ea:	0289      	s32i.n	a8, a2, 0
420070ec:	f27c      	movi.n	a2, -1
420070ee:	000706        	j	4200710e <_link_r+0x7a>
420070f1:	079800        	lsi	f0, a8, 28
420070f4:	0d6917        	bbci	a9, 1, 42007105 <_link_r+0x71>
420070f7:	0acd      	mov.n	a12, a10
420070f9:	03bd      	mov.n	a11, a3
420070fb:	77a8      	l32i.n	a10, a7, 28
420070fd:	0008e0        	callx8	a8
42007100:	0a2d      	mov.n	a2, a10
42007102:	000206        	j	4200710e <_link_r+0x7a>
42007105:	0abd      	mov.n	a11, a10
42007107:	03ad      	mov.n	a10, a3
42007109:	0008e0        	callx8	a8
4200710c:	0a2d      	mov.n	a2, a10
    return ret;
}
4200710e:	f01d      	retw.n

42007110 <_unlink_r>:

int esp_vfs_unlink(struct _reent *r, const char *path)
{
42007110:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(path);
42007113:	03ad      	mov.n	a10, a3
42007115:	ffa5e5        	call8	42006b74 <get_vfs_for_path>
42007118:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
4200711a:	7acc      	bnez.n	a10, 42007125 <_unlink_r+0x15>
        __errno_r(r) = ENOENT;
4200711c:	280c      	movi.n	a8, 2
4200711e:	0289      	s32i.n	a8, a2, 0
        return -1;
42007120:	f27c      	movi.n	a2, -1
42007122:	001006        	j	42007166 <_unlink_r+0x56>
    }

    CHECK_VFS_READONLY_FLAG(vfs->flags);
42007125:	0a68      	l32i.n	a6, a10, 0
42007127:	096627        	bbci	a6, 2, 42007134 <_unlink_r+0x24>
4200712a:	e81c      	movi.n	a8, 30
4200712c:	0289      	s32i.n	a8, a2, 0
4200712e:	f27c      	movi.n	a2, -1
42007130:	000c86        	j	42007166 <_unlink_r+0x56>
42007133:	b33000        	movgez	a3, a0, a0

    const char* path_within_vfs = translate_path(vfs, path);
42007136:	956520        	extui	a6, a2, 21, 10
42007139:	ff          	.byte	0xff
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, unlink, path_within_vfs);
4200713a:	012782        	l32i	a8, a7, 4
4200713d:	0b2882        	l32i	a8, a8, 44
42007140:	288c      	beqz.n	a8, 42007146 <_unlink_r+0x36>
42007142:	2888      	l32i.n	a8, a8, 8
42007144:	88cc      	bnez.n	a8, 42007150 <_unlink_r+0x40>
42007146:	885c      	movi.n	a8, 88
42007148:	0289      	s32i.n	a8, a2, 0
4200714a:	f27c      	movi.n	a2, -1
4200714c:	000586        	j	42007166 <_unlink_r+0x56>
4200714f:	661700        	lsi	f0, a7, 0x198
42007152:	bd0d      	lsi	f0, a13, 52
42007154:	a80a      	add.n	a10, a8, a0
42007156:	08e077        	bbsi	a0, 7, 42007162 <_unlink_r+0x52>
42007159:	0a2d00        	add.s	f2, f13, f0
4200715c:	000186        	j	42007166 <_unlink_r+0x56>
4200715f:	e00000        	subx4	a0, a0, a0
42007162:	0008      	l32i.n	a0, a0, 0
42007164:	0a2d      	mov.n	a2, a10
    return ret;
}
42007166:	f01d      	retw.n

42007168 <_rename_r>:

int esp_vfs_rename(struct _reent *r, const char *src, const char *dst)
{
42007168:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(src);
4200716b:	03ad      	mov.n	a10, a3
4200716d:	ffa065        	call8	42006b74 <get_vfs_for_path>
42007170:	0a7d      	mov.n	a7, a10
    if (vfs == NULL) {
42007172:	7acc      	bnez.n	a10, 4200717d <_rename_r+0x15>
        __errno_r(r) = ENOENT;
42007174:	280c      	movi.n	a8, 2
42007176:	0289      	s32i.n	a8, a2, 0
        return -1;
42007178:	f27c      	movi.n	a2, -1
4200717a:	001c06        	j	420071ee <_rename_r+0x86>
    }

    CHECK_VFS_READONLY_FLAG(vfs->flags);
4200717d:	0a68      	l32i.n	a6, a10, 0
4200717f:	096627        	bbci	a6, 2, 4200718c <_rename_r+0x24>
42007182:	e81c      	movi.n	a8, 30
42007184:	0289      	s32i.n	a8, a2, 0
42007186:	f27c      	movi.n	a2, -1
42007188:	001886        	j	420071ee <_rename_r+0x86>
4200718b:	a44000        	extui	a4, a0, 0, 11

    const vfs_entry_t* vfs_dst = get_vfs_for_path(dst);
4200718e:	9e6520        	f64iter	a6, a5, a2, 1, 0
42007191:	ff          	.byte	0xff
    if (vfs != vfs_dst) {
42007192:	0a17a7        	beq	a7, a10, 420071a0 <_rename_r+0x38>
        __errno_r(r) = EXDEV;
42007195:	12a082        	movi	a8, 18
42007198:	006282        	s32i	a8, a2, 0
        return -1;
4200719b:	f27c      	movi.n	a2, -1
4200719d:	001346        	j	420071ee <_rename_r+0x86>
    }

    CHECK_VFS_READONLY_FLAG(vfs_dst->flags);
420071a0:	0a88      	l32i.n	a8, a10, 0
420071a2:	086827        	bbci	a8, 2, 420071ae <_rename_r+0x46>
420071a5:	e81c      	movi.n	a8, 30
420071a7:	0289      	s32i.n	a8, a2, 0
420071a9:	f27c      	movi.n	a2, -1
420071ab:	000fc6        	j	420071ee <_rename_r+0x86>

    const char* src_within_vfs = translate_path(vfs, src);
420071ae:	20b330        	or	a11, a3, a3
420071b1:	20a770        	or	a10, a7, a7
420071b4:	ff8d65        	call8	42006a8c <translate_path>
420071b7:	0a3d      	mov.n	a3, a10
    const char* dst_within_vfs = translate_path(vfs, dst);
420071b9:	04bd      	mov.n	a11, a4
420071bb:	07ad      	mov.n	a10, a7
420071bd:	ff8ce5        	call8	42006a8c <translate_path>
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, rename, src_within_vfs, dst_within_vfs);
420071c0:	1788      	l32i.n	a8, a7, 4
420071c2:	b888      	l32i.n	a8, a8, 44
420071c4:	288c      	beqz.n	a8, 420071ca <_rename_r+0x62>
420071c6:	3888      	l32i.n	a8, a8, 12
420071c8:	78cc      	bnez.n	a8, 420071d3 <_rename_r+0x6b>
420071ca:	885c      	movi.n	a8, 88
420071cc:	0289      	s32i.n	a8, a2, 0
420071ce:	f27c      	movi.n	a2, -1
420071d0:	000686        	j	420071ee <_rename_r+0x86>
420071d3:	0e6617        	bbci	a6, 1, 420071e5 <_rename_r+0x7d>
420071d6:	0acd      	mov.n	a12, a10
420071d8:	03bd      	mov.n	a11, a3
420071da:	0727a2        	l32i	a10, a7, 28
420071dd:	0008e0        	callx8	a8
420071e0:	0a2d      	mov.n	a2, a10
420071e2:	000206        	j	420071ee <_rename_r+0x86>
420071e5:	0abd      	mov.n	a11, a10
420071e7:	03ad      	mov.n	a10, a3
420071e9:	0008e0        	callx8	a8
420071ec:	0a2d      	mov.n	a2, a10
    return ret;
}
420071ee:	f01d      	retw.n

420071f0 <access>:
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, rmdir, path_within_vfs);
    return ret;
}

int esp_vfs_access(const char *path, int amode)
{
420071f0:	004136        	entry	a1, 32
    int ret;
    const vfs_entry_t* vfs = get_vfs_for_path(path);
420071f3:	02ad      	mov.n	a10, a2
420071f5:	ff97e5        	call8	42006b74 <get_vfs_for_path>
420071f8:	0a7d      	mov.n	a7, a10
    [[maybe_unused]] struct _reent* r = __getreent();
420071fa:	e55581        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
420071fd:	0008e0        	callx8	a8
42007200:	0a6d      	mov.n	a6, a10
    if (vfs == NULL) {
42007202:	87cc      	bnez.n	a7, 4200720e <access+0x1e>
        __errno_r(r) = ENOENT;
42007204:	280c      	movi.n	a8, 2
42007206:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007208:	f27c      	movi.n	a2, -1
4200720a:	000e46        	j	42007247 <access+0x57>
4200720d:	b22000        	mulsh	a2, a0, a0
    }
    const char* path_within_vfs = translate_path(vfs, path);
42007210:	a77020        	lsi	f2, a0, 0x29c
42007213:	876520        	lsi	f2, a5, 0x21c
42007216:	ff          	.byte	0xff
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, dir, access, path_within_vfs, amode);
42007217:	012782        	l32i	a8, a7, 4
4200721a:	b888      	l32i.n	a8, a8, 44
4200721c:	288c      	beqz.n	a8, 42007222 <access+0x32>
4200721e:	c888      	l32i.n	a8, a8, 48
42007220:	88cc      	bnez.n	a8, 4200722c <access+0x3c>
42007222:	885c      	movi.n	a8, 88
42007224:	0689      	s32i.n	a8, a6, 0
42007226:	f27c      	movi.n	a2, -1
42007228:	0006c6        	j	42007247 <access+0x57>
4200722b:	079800        	lsi	f0, a8, 28
4200722e:	0e6917        	bbci	a9, 1, 42007240 <access+0x50>
42007231:	03cd      	mov.n	a12, a3
42007233:	0abd      	mov.n	a11, a10
42007235:	77a8      	l32i.n	a10, a7, 28
42007237:	0008e0        	callx8	a8
4200723a:	0a2d      	mov.n	a2, a10
4200723c:	0001c6        	j	42007247 <access+0x57>
4200723f:	03bd00        	lsi	f0, a13, 12
42007242:	0008e0        	callx8	a8
42007245:	0a2d      	mov.n	a2, a10
    return ret;
}
42007247:	f01d      	retw.n
42007249:	000000        	ill

4200724c <esp_vfs_select_triggered>:
    esp_vfs_log_fd_set("errorfds", errorfds);
    return ret;
}

void esp_vfs_select_triggered(esp_vfs_select_sem_t sem)
{
4200724c:	006136        	entry	a1, 48
4200724f:	0129      	s32i.n	a2, a1, 0
42007251:	1139      	s32i.n	a3, a1, 4
    if (sem.is_sem_local) {
42007253:	000182        	l8ui	a8, a1, 0
42007256:	38bc      	beqz.n	a8, 4200728d <esp_vfs_select_triggered+0x41>
        xSemaphoreGive(sem.sem);
42007258:	0d0c      	movi.n	a13, 0
4200725a:	0dcd      	mov.n	a12, a13
4200725c:	20bdd0        	or	a11, a13, a13
4200725f:	20a330        	or	a10, a3, a3
42007262:	e58881        	l32r	a8, 42000884 <_stext+0x864> (40379ad8 <xQueueGenericSend>)
42007265:	0008e0        	callx8	a8
42007268:	000ac6        	j	42007297 <esp_vfs_select_triggered+0x4b>
4200726b:	7a9100        	divn.s	f9, f1, f0
        // which has a permanent FD. But in order to avoid to lock
        // s_fd_table_lock we go through the VFS table.
        for (int i = 0; i < s_vfs_count; ++i) {
            // Note: s_vfs_count could have changed since the start of vfs_select() call. However, that change doesn't
            // matter here stop_socket_select() will be called for only valid VFS drivers.
            const vfs_entry_t *vfs = s_vfs[i];
4200726e:	9890e5        	call8	41f9fb7c <_coredump_iram_end+0x1c1dc7c>
42007271:	0998a0        	l32e	a10, a8, -28
            if (vfs != NULL
42007274:	099c      	beqz.n	a9, 42007288 <esp_vfs_select_triggered+0x3c>
                && vfs->vfs->select != NULL
42007276:	1998      	l32i.n	a9, a9, 4
42007278:	d998      	l32i.n	a9, a9, 52
4200727a:	a98c      	beqz.n	a9, 42007288 <esp_vfs_select_triggered+0x3c>
                && vfs->vfs->select->stop_socket_select != NULL
4200727c:	2998      	l32i.n	a9, a9, 8
4200727e:	698c      	beqz.n	a9, 42007288 <esp_vfs_select_triggered+0x3c>
            ) {
                vfs->vfs->select->stop_socket_select(sem.sem);
42007280:	11a8      	l32i.n	a10, a1, 4
42007282:	0009e0        	callx8	a9
                break;
42007285:	000386        	j	42007297 <esp_vfs_select_triggered+0x4b>
        for (int i = 0; i < s_vfs_count; ++i) {
42007288:	881b      	addi.n	a8, a8, 1
4200728a:	000046        	j	4200728f <esp_vfs_select_triggered+0x43>
4200728d:	080c      	movi.n	a8, 0
4200728f:	e57291        	l32r	a9, 42000858 <_stext+0x838> (3fc94f14 <s_vfs_count>)
42007292:	0998      	l32i.n	a9, a9, 0
42007294:	d43897        	bltu	a8, a9, 4200726c <esp_vfs_select_triggered+0x20>
            }
        }
    }
}
42007297:	f01d      	retw.n
42007299:	000000        	ill

4200729c <esp_vfs_select_triggered_isr>:

void esp_vfs_select_triggered_isr(esp_vfs_select_sem_t sem, BaseType_t *woken)
{
4200729c:	006136        	entry	a1, 48
4200729f:	0129      	s32i.n	a2, a1, 0
420072a1:	1139      	s32i.n	a3, a1, 4
420072a3:	20b440        	or	a11, a4, a4
    if (sem.is_sem_local) {
420072a6:	000182        	l8ui	a8, a1, 0
420072a9:	c8ac      	beqz.n	a8, 420072d9 <esp_vfs_select_triggered_isr+0x3d>
        xSemaphoreGiveFromISR(sem.sem, woken);
420072ab:	20a330        	or	a10, a3, a3
420072ae:	e57681        	l32r	a8, 42000888 <_stext+0x868> (40379cc4 <xQueueGiveFromISR>)
420072b1:	0008e0        	callx8	a8
420072b4:	000ac6        	j	420072e3 <esp_vfs_select_triggered_isr+0x47>
        // which has a permanent FD. But in order to avoid to lock
        // s_fd_table_lock we go through the VFS table.
        for (int i = 0; i < s_vfs_count; ++i) {
            // Note: s_vfs_count could have changed since the start of vfs_select() call. However, that change doesn't
            // matter here stop_socket_select() will be called for only valid VFS drivers.
            const vfs_entry_t *vfs = s_vfs[i];
420072b7:	e56791        	l32r	a9, 42000854 <_stext+0x834> (3fc94f18 <s_vfs>)
420072ba:	a09890        	addx4	a9, a8, a9
420072bd:	0998      	l32i.n	a9, a9, 0
            if (vfs != NULL
420072bf:	199c      	beqz.n	a9, 420072d4 <esp_vfs_select_triggered_isr+0x38>
                && vfs->vfs->select != NULL
420072c1:	1998      	l32i.n	a9, a9, 4
420072c3:	d998      	l32i.n	a9, a9, 52
420072c5:	b98c      	beqz.n	a9, 420072d4 <esp_vfs_select_triggered_isr+0x38>
                && vfs->vfs->select->stop_socket_select_isr != NULL
420072c7:	3998      	l32i.n	a9, a9, 12
420072c9:	798c      	beqz.n	a9, 420072d4 <esp_vfs_select_triggered_isr+0x38>
            ) {
                // Note: If the UART ISR resides in IRAM, the function referenced by stop_socket_select_isr should also be placed in IRAM.
                vfs->vfs->select->stop_socket_select_isr(sem.sem, woken);
420072cb:	11a8      	l32i.n	a10, a1, 4
420072cd:	0009e0        	callx8	a9
                break;
420072d0:	0003c6        	j	420072e3 <esp_vfs_select_triggered_isr+0x47>
420072d3:	881b00        	lsi	f0, a11, 0x220
        for (int i = 0; i < s_vfs_count; ++i) {
420072d6:	000046        	j	420072db <esp_vfs_select_triggered_isr+0x3f>
420072d9:	080c      	movi.n	a8, 0
420072db:	e55f91        	l32r	a9, 42000858 <_stext+0x838> (3fc94f14 <s_vfs_count>)
420072de:	0998      	l32i.n	a9, a9, 0
420072e0:	d33897        	bltu	a8, a9, 420072b7 <esp_vfs_select_triggered_isr+0x1b>
            }
        }
    }
}
420072e3:	f01d      	retw.n
420072e5:	000000        	ill

420072e8 <tcgetattr>:
#endif // CONFIG_VFS_SUPPORT_SELECT

#ifdef CONFIG_VFS_SUPPORT_TERMIOS

int tcgetattr(int fd, struct termios *p)
{
420072e8:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420072eb:	02ad      	mov.n	a10, a2
420072ed:	ff85e5        	call8	42006b4c <get_vfs_for_fd>
420072f0:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
420072f2:	2a9c      	beqz.n	a10, 42007308 <tcgetattr+0x20>
420072f4:	f83c      	movi.n	a8, 63
420072f6:	133827        	bltu	a8, a2, 4200730d <tcgetattr+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420072f9:	902220        	addx2	a2, a2, a2
420072fc:	e55f81        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
420072ff:	882a      	add.n	a8, a8, a2
42007301:	020822        	l8ui	a2, a8, 2
42007304:	0001c6        	j	4200730f <tcgetattr+0x27>
42007307:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
4200730a:	000046        	j	4200730f <tcgetattr+0x27>
4200730d:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
4200730f:	e51081        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
42007312:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
42007315:	40f780        	nsau	a8, a7
42007318:	418580        	srli	a8, a8, 5
4200731b:	059f20        	extui	a9, a2, 31, 1
4200731e:	208890        	or	a8, a8, a9
42007321:	788c      	beqz.n	a8, 4200732c <tcgetattr+0x44>
        __errno_r(r) = EBADF;
42007323:	980c      	movi.n	a8, 9
42007325:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007327:	f27c      	movi.n	a2, -1
42007329:	000c46        	j	4200735e <tcgetattr+0x76>
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcgetattr, local_fd, p);
4200732c:	1788      	l32i.n	a8, a7, 4
4200732e:	c888      	l32i.n	a8, a8, 48
42007330:	288c      	beqz.n	a8, 42007336 <tcgetattr+0x4e>
42007332:	1888      	l32i.n	a8, a8, 4
42007334:	88cc      	bnez.n	a8, 42007340 <tcgetattr+0x58>
42007336:	885c      	movi.n	a8, 88
42007338:	0a89      	s32i.n	a8, a10, 0
4200733a:	f27c      	movi.n	a2, -1
4200733c:	000786        	j	4200735e <tcgetattr+0x76>
4200733f:	079800        	lsi	f0, a8, 28
42007342:	0f6917        	bbci	a9, 1, 42007355 <tcgetattr+0x6d>
42007345:	03cd      	mov.n	a12, a3
42007347:	02bd      	mov.n	a11, a2
42007349:	77a8      	l32i.n	a10, a7, 28
4200734b:	0008e0        	callx8	a8
4200734e:	0a2d      	mov.n	a2, a10
42007350:	000286        	j	4200735e <tcgetattr+0x76>
42007353:	bd0000        	lsi	f0, a0, 0x2f4
42007356:	02ad03        	lsi	f0, a13, 8
42007359:	0008e0        	callx8	a8
4200735c:	0a2d      	mov.n	a2, a10
    return ret;
}
4200735e:	f01d      	retw.n

42007360 <tcsetattr>:

int tcsetattr(int fd, int optional_actions, const struct termios *p)
{
42007360:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42007363:	02ad      	mov.n	a10, a2
42007365:	ff7e65        	call8	42006b4c <get_vfs_for_fd>
42007368:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
4200736a:	2a9c      	beqz.n	a10, 42007380 <tcsetattr+0x20>
4200736c:	f83c      	movi.n	a8, 63
4200736e:	133827        	bltu	a8, a2, 42007385 <tcsetattr+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42007371:	902220        	addx2	a2, a2, a2
42007374:	e54181        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42007377:	882a      	add.n	a8, a8, a2
42007379:	020822        	l8ui	a2, a8, 2
4200737c:	0001c6        	j	42007387 <tcsetattr+0x27>
4200737f:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
42007382:	000046        	j	42007387 <tcsetattr+0x27>
42007385:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
42007387:	e4f281        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200738a:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
4200738d:	40f780        	nsau	a8, a7
42007390:	418580        	srli	a8, a8, 5
42007393:	059f20        	extui	a9, a2, 31, 1
42007396:	208890        	or	a8, a8, a9
42007399:	788c      	beqz.n	a8, 420073a4 <tcsetattr+0x44>
        __errno_r(r) = EBADF;
4200739b:	980c      	movi.n	a8, 9
4200739d:	0a89      	s32i.n	a8, a10, 0
        return -1;
4200739f:	f27c      	movi.n	a2, -1
420073a1:	000cc6        	j	420073d8 <tcsetattr+0x78>
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcsetattr, local_fd, optional_actions, p);
420073a4:	1788      	l32i.n	a8, a7, 4
420073a6:	c888      	l32i.n	a8, a8, 48
420073a8:	288c      	beqz.n	a8, 420073ae <tcsetattr+0x4e>
420073aa:	0888      	l32i.n	a8, a8, 0
420073ac:	88cc      	bnez.n	a8, 420073b8 <tcsetattr+0x58>
420073ae:	885c      	movi.n	a8, 88
420073b0:	0a89      	s32i.n	a8, a10, 0
420073b2:	f27c      	movi.n	a2, -1
420073b4:	000806        	j	420073d8 <tcsetattr+0x78>
420073b7:	079800        	lsi	f0, a8, 28
420073ba:	0f6917        	bbci	a9, 1, 420073cd <tcsetattr+0x6d>
420073bd:	04dd      	mov.n	a13, a4
420073bf:	03cd      	mov.n	a12, a3
420073c1:	02bd      	mov.n	a11, a2
420073c3:	77a8      	l32i.n	a10, a7, 28
420073c5:	0008e0        	callx8	a8
420073c8:	0a2d      	mov.n	a2, a10
420073ca:	000286        	j	420073d8 <tcsetattr+0x78>
420073cd:	04cd      	mov.n	a12, a4
420073cf:	03bd      	mov.n	a11, a3
420073d1:	02ad      	mov.n	a10, a2
420073d3:	0008e0        	callx8	a8
420073d6:	0a2d      	mov.n	a2, a10
    return ret;
}
420073d8:	f01d      	retw.n
	...

420073dc <tcdrain>:

int tcdrain(int fd)
{
420073dc:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
420073df:	02ad      	mov.n	a10, a2
420073e1:	ff76a5        	call8	42006b4c <get_vfs_for_fd>
420073e4:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
420073e6:	2a9c      	beqz.n	a10, 420073fc <tcdrain+0x20>
420073e8:	f83c      	movi.n	a8, 63
420073ea:	133827        	bltu	a8, a2, 42007401 <tcdrain+0x25>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420073ed:	902220        	addx2	a2, a2, a2
420073f0:	e52281        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
420073f3:	882a      	add.n	a8, a8, a2
420073f5:	020822        	l8ui	a2, a8, 2
420073f8:	0001c6        	j	42007403 <tcdrain+0x27>
420073fb:	f27c00        	rems	a7, a12, a0
    int local_fd = -1;
420073fe:	000046        	j	42007403 <tcdrain+0x27>
42007401:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
42007403:	e4d381        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
42007406:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
42007409:	40f780        	nsau	a8, a7
4200740c:	418580        	srli	a8, a8, 5
4200740f:	059f20        	extui	a9, a2, 31, 1
42007412:	208890        	or	a8, a8, a9
42007415:	788c      	beqz.n	a8, 42007420 <tcdrain+0x44>
        __errno_r(r) = EBADF;
42007417:	980c      	movi.n	a8, 9
42007419:	0a89      	s32i.n	a8, a10, 0
        return -1;
4200741b:	f27c      	movi.n	a2, -1
4200741d:	000ac6        	j	4200744c <tcdrain+0x70>
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcdrain, local_fd);
42007420:	1788      	l32i.n	a8, a7, 4
42007422:	c888      	l32i.n	a8, a8, 48
42007424:	288c      	beqz.n	a8, 4200742a <tcdrain+0x4e>
42007426:	2888      	l32i.n	a8, a8, 8
42007428:	88cc      	bnez.n	a8, 42007434 <tcdrain+0x58>
4200742a:	885c      	movi.n	a8, 88
4200742c:	0a89      	s32i.n	a8, a10, 0
4200742e:	f27c      	movi.n	a2, -1
42007430:	000606        	j	4200744c <tcdrain+0x70>
42007433:	079800        	lsi	f0, a8, 28
42007436:	0b6917        	bbci	a9, 1, 42007445 <tcdrain+0x69>
42007439:	02bd      	mov.n	a11, a2
4200743b:	77a8      	l32i.n	a10, a7, 28
4200743d:	0008e0        	callx8	a8
42007440:	0a2d      	mov.n	a2, a10
42007442:	000186        	j	4200744c <tcdrain+0x70>
42007445:	02ad      	mov.n	a10, a2
42007447:	0008e0        	callx8	a8
4200744a:	0a2d      	mov.n	a2, a10
    return ret;
}
4200744c:	f01d      	retw.n
	...

42007450 <tcflush>:

int tcflush(int fd, int select)
{
42007450:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42007453:	02ad      	mov.n	a10, a2
42007455:	ff6f65        	call8	42006b4c <get_vfs_for_fd>
42007458:	0a7d      	mov.n	a7, a10
    if (vfs && fd_valid(fd)) {
4200745a:	1a9c      	beqz.n	a10, 4200746f <tcflush+0x1f>
4200745c:	f83c      	movi.n	a8, 63
4200745e:	123827        	bltu	a8, a2, 42007474 <tcflush+0x24>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
42007461:	902220        	addx2	a2, a2, a2
42007464:	e50581        	l32r	a8, 42000878 <_stext+0x858> (3fc920e8 <s_fd_table>)
42007467:	882a      	add.n	a8, a8, a2
42007469:	020822        	l8ui	a2, a8, 2
4200746c:	000186        	j	42007476 <tcflush+0x26>
    int local_fd = -1;
4200746f:	f27c      	movi.n	a2, -1
42007471:	000046        	j	42007476 <tcflush+0x26>
42007474:	f27c      	movi.n	a2, -1
    const int local_fd = get_local_fd(vfs, fd);
    [[maybe_unused]] struct _reent* r = __getreent();
42007476:	e4b681        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
42007479:	0008e0        	callx8	a8
    if (vfs == NULL || local_fd < 0) {
4200747c:	40f780        	nsau	a8, a7
4200747f:	418580        	srli	a8, a8, 5
42007482:	059f20        	extui	a9, a2, 31, 1
42007485:	208890        	or	a8, a8, a9
42007488:	888c      	beqz.n	a8, 42007494 <tcflush+0x44>
        __errno_r(r) = EBADF;
4200748a:	980c      	movi.n	a8, 9
4200748c:	0a89      	s32i.n	a8, a10, 0
        return -1;
4200748e:	f27c      	movi.n	a2, -1
42007490:	000c86        	j	420074c6 <tcflush+0x76>
42007493:	178800        	lsi	f0, a8, 92
    }
    int ret;
    CHECK_AND_CALL_SUBCOMPONENT(ret, r, vfs, termios, tcflush, local_fd, select);
42007496:	c888      	l32i.n	a8, a8, 48
42007498:	288c      	beqz.n	a8, 4200749e <tcflush+0x4e>
4200749a:	3888      	l32i.n	a8, a8, 12
4200749c:	88cc      	bnez.n	a8, 420074a8 <tcflush+0x58>
4200749e:	885c      	movi.n	a8, 88
420074a0:	0a89      	s32i.n	a8, a10, 0
420074a2:	f27c      	movi.n	a2, -1
420074a4:	000786        	j	420074c6 <tcflush+0x76>
420074a7:	079800        	lsi	f0, a8, 28
420074aa:	0f6917        	bbci	a9, 1, 420074bd <tcflush+0x6d>
420074ad:	03cd      	mov.n	a12, a3
420074af:	02bd      	mov.n	a11, a2
420074b1:	77a8      	l32i.n	a10, a7, 28
420074b3:	0008e0        	callx8	a8
420074b6:	0a2d      	mov.n	a2, a10
420074b8:	000286        	j	420074c6 <tcflush+0x76>
420074bb:	bd0000        	lsi	f0, a0, 0x2f4
420074be:	02ad03        	lsi	f0, a13, 8
420074c1:	0008e0        	callx8	a8
420074c4:	0a2d      	mov.n	a2, a10
    return ret;
}
420074c6:	f01d      	retw.n

420074c8 <vfs_null_get_empty_fd>:

    return size;
}

static int vfs_null_get_empty_fd(void)
{
420074c8:	004136        	entry	a1, 32
    for (int i = 0; i < VFS_NULL_MAX_FDS; i++) {
420074cb:	020c      	movi.n	a2, 0
420074cd:	000506        	j	420074e5 <vfs_null_get_empty_fd+0x1d>
420074d0:	922a00        	lsi	f0, a10, 0x248
        if (GET_FLAGS(g_fds, i) == VFS_NULL_CLOSED) {
420074d3:	e4ee81        	l32r	a8, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
420074d6:	0888      	l32i.n	a8, a8, 0
420074d8:	400900        	ssr	a9
420074db:	918080        	srl	a8, a8
420074de:	148080        	extui	a8, a8, 0, 2
420074e1:	788c      	beqz.n	a8, 420074ec <vfs_null_get_empty_fd+0x24>
    for (int i = 0; i < VFS_NULL_MAX_FDS; i++) {
420074e3:	221b      	addi.n	a2, a2, 1
420074e5:	f80c      	movi.n	a8, 15
420074e7:	e6b827        	bgeu	a8, a2, 420074d1 <vfs_null_get_empty_fd+0x9>
            return i;
        }
    }

    return -1;
420074ea:	f27c      	movi.n	a2, -1
}
420074ec:	f01d      	retw.n
	...

420074f0 <vfs_null_fsync>:
        return -1;
    }
}

static int vfs_null_fsync(int fd)
{
420074f0:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
420074f3:	0fa082        	movi	a8, 15
420074f6:	0eb827        	bgeu	a8, a2, 42007508 <vfs_null_fsync+0x18>
        errno = EBADF;
420074f9:	03f925        	call8	4200b48c <__errno>
420074fc:	09a082        	movi	a8, 9
420074ff:	006a82        	s32i	a8, a10, 0
        return -1;
42007502:	f27c      	movi.n	a2, -1
42007504:	000086        	j	4200750a <vfs_null_fsync+0x1a>
42007507:	020c00        	andb	b0, b12, b0
    }

    return 0;
}
4200750a:	f01d      	retw.n

4200750c <vfs_null_ioctl>:
{
4200750c:	006136        	entry	a1, 48
4200750f:	006142        	s32i	a4, a1, 0
42007512:	016152        	s32i	a5, a1, 4
42007515:	026162        	s32i	a6, a1, 8
    if (!FD_IN_RANGE(fd)) {
42007518:	f80c      	movi.n	a8, 15
4200751a:	0ab827        	bgeu	a8, a2, 42007528 <vfs_null_ioctl+0x1c>
        errno = EBADF;
4200751d:	03f6e5        	call8	4200b48c <__errno>
42007520:	980c      	movi.n	a8, 9
42007522:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007524:	000246        	j	42007531 <vfs_null_ioctl+0x25>
42007527:	f62500        	lsi	f0, a5, 0x3d8
        errno = ENOSYS;
4200752a:	a08203        	lsip	f0, a2, 0x280
4200752d:	8258      	l32i.n	a5, a2, 32
4200752f:	006a      	add.n	a0, a0, a6
}
42007531:	ffaf22        	movi	a2, -1
42007534:	f01d      	retw.n
	...

42007538 <vfs_null_fcntl>:
{
42007538:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
4200753b:	0fa082        	movi	a8, 15
4200753e:	0bb827        	bgeu	a8, a2, 4200754d <vfs_null_fcntl+0x15>
        errno = EBADF;
42007541:	03f4a5        	call8	4200b48c <__errno>
42007544:	09a082        	movi	a8, 9
42007547:	006a82        	s32i	a8, a10, 0
        return -1;
4200754a:	000206        	j	42007556 <vfs_null_fcntl+0x1e>
        errno = ENOSYS;
4200754d:	03f3e5        	call8	4200b48c <__errno>
42007550:	58a082        	movi	a8, 88
42007553:	006a82        	s32i	a8, a10, 0
}
42007556:	ffaf22        	movi	a2, -1
42007559:	f01d      	retw.n
	...

4200755c <vfs_null_close>:
{
4200755c:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
4200755f:	0fa082        	movi	a8, 15
42007562:	0eb827        	bgeu	a8, a2, 42007574 <vfs_null_close+0x18>
        errno = EBADF;
42007565:	03f265        	call8	4200b48c <__errno>
42007568:	09a082        	movi	a8, 9
4200756b:	006a82        	s32i	a8, a10, 0
        return -1;
4200756e:	f27c      	movi.n	a2, -1
42007570:	000086        	j	42007576 <vfs_null_close+0x1a>
42007573:	020c00        	andb	b0, b12, b0
}
42007576:	f01d      	retw.n

42007578 <vfs_null_open>:
{
42007578:	004136        	entry	a1, 32
4200757b:	20a220        	or	a10, a2, a2
    if (strcmp(path, "/") != 0) {
4200757e:	e4c4b1        	l32r	a11, 42000890 <_stext+0x870> (3c024f94 <_flash_rodata_start+0x4e74>)
42007581:	e3b281        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
42007584:	0008e0        	callx8	a8
42007587:	00ca16        	beqz	a10, 42007597 <vfs_null_open+0x1f>
        errno = ENOENT;
4200758a:	03f025        	call8	4200b48c <__errno>
4200758d:	02a082        	movi	a8, 2
42007590:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007592:	f27c      	movi.n	a2, -1
42007594:	002006        	j	42007618 <vfs_null_open+0xa0>
    int fd = vfs_null_get_empty_fd();
42007597:	fff325        	call8	420074c8 <vfs_null_get_empty_fd>
4200759a:	202aa0        	or	a2, a10, a10
    if (fd == -1) {
4200759d:	0b0a66        	bnei	a10, -1, 420075ac <vfs_null_open+0x34>
        errno = EMFILE;
420075a0:	03eea5        	call8	4200b48c <__errno>
420075a3:	18a082        	movi	a8, 24
420075a6:	0a89      	s32i.n	a8, a10, 0
        return -1;
420075a8:	001b06        	j	42007618 <vfs_null_open+0xa0>
420075ab:	303000        	xor	a3, a0, a0
    int acc_mode = flags & O_ACCMODE;
420075ae:	236614        	lsi	f1, a6, 140
    if (acc_mode == O_RDWR) {
420075b1:	baaa25        	call8	41fc2054 <_coredump_iram_end+0x1c40154>
        SET_READABLE(g_fds, fd);
420075b4:	180c      	movi.n	a8, 1
420075b6:	401b00        	ssl	a11
420075b9:	a18800        	sll	a8, a8
420075bc:	e4b491        	l32r	a9, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
420075bf:	09a8      	l32i.n	a10, a9, 0
420075c1:	2088a0        	or	a8, a8, a10
420075c4:	0989      	s32i.n	a8, a9, 0
        SET_WRITABLE(g_fds, fd);
420075c6:	2a0c      	movi.n	a10, 2
420075c8:	401b00        	ssl	a11
420075cb:	a1aa00        	sll	a10, a10
420075ce:	2088a0        	or	a8, a8, a10
420075d1:	0989      	s32i.n	a8, a9, 0
420075d3:	001046        	j	42007618 <vfs_null_open+0xa0>
420075d6:	660000        	lsi	f0, a0, 0x198
    } else if (acc_mode == O_WRONLY) {
420075d9:	aa1613        	lsi	f1, a6, 0x2a8
        SET_WRITABLE(g_fds, fd);
420075dc:	0c8a      	add.n	a0, a12, a8
420075de:	0029      	s32i.n	a2, a0, 0
420075e0:	4018      	l32i.n	a1, a0, 16
420075e2:	a19900        	sll	a9, a9
420075e5:	e4a9a1        	l32r	a10, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
420075e8:	0a88      	l32i.n	a8, a10, 0
420075ea:	208890        	or	a8, a8, a9
420075ed:	0a89      	s32i.n	a8, a10, 0
420075ef:	000946        	j	42007618 <vfs_null_open+0xa0>
    } else if (acc_mode == O_RDONLY) {
420075f2:	63dc      	bnez.n	a3, 4200760c <vfs_null_open+0x94>
        SET_READABLE(g_fds, fd);
420075f4:	8aaa      	add.n	a8, a10, a10
420075f6:	190c      	movi.n	a9, 1
420075f8:	401800        	ssl	a8
420075fb:	a19900        	sll	a9, a9
420075fe:	e4a3a1        	l32r	a10, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
42007601:	0a88      	l32i.n	a8, a10, 0
42007603:	208890        	or	a8, a8, a9
42007606:	0a89      	s32i.n	a8, a10, 0
42007608:	000306        	j	42007618 <vfs_null_open+0xa0>
4200760b:	e7e500        	lsi	f0, a5, 0x39c
        errno = EINVAL;
4200760e:	a08203        	lsip	f0, a2, 0x280
42007611:	6a8216        	beqz	a2, 42007cbd <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x81>
42007614:	af2200        	f64cmph	a2, a2, a0, 10
        return -1;
42007617:	ff          	.byte	0xff
}
42007618:	f01d      	retw.n
	...

4200761c <vfs_null_pwrite>:
{
4200761c:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd) || !WRITABLE(g_fds, fd)) {
4200761f:	f90c      	movi.n	a9, 15
42007621:	0f3927        	bltu	a9, a2, 42007634 <vfs_null_pwrite+0x18>
42007624:	822a      	add.n	a8, a2, a2
42007626:	e49991        	l32r	a9, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
42007629:	0998      	l32i.n	a9, a9, 0
4200762b:	400800        	ssr	a8
4200762e:	918090        	srl	a8, a9
42007631:	0fe817        	bbsi	a8, 1, 42007644 <vfs_null_pwrite+0x28>
        errno = EBADF;
42007634:	03e565        	call8	4200b48c <__errno>
42007637:	09a082        	movi	a8, 9
4200763a:	006a82        	s32i	a8, a10, 0
        return -1;
4200763d:	ffaf22        	movi	a2, -1
42007640:	000086        	j	42007646 <vfs_null_pwrite+0x2a>
42007643:	042d00        	extui	a2, a0, 13, 1
}
42007646:	f01d      	retw.n

42007648 <vfs_null_pread>:
{
42007648:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd) || !READABLE(g_fds, fd)) {
4200764b:	f80c      	movi.n	a8, 15
4200764d:	0b3827        	bltu	a8, a2, 4200765c <vfs_null_pread+0x14>
42007650:	802220        	add	a2, a2, a2
42007653:	e48e81        	l32r	a8, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
42007656:	002882        	l32i	a8, a8, 0
42007659:	0fd827        	bbs	a8, a2, 4200766c <vfs_null_pread+0x24>
        errno = EBADF;
4200765c:	03e2e5        	call8	4200b48c <__errno>
4200765f:	09a082        	movi	a8, 9
42007662:	006a82        	s32i	a8, a10, 0
        return -1;
42007665:	ffaf22        	movi	a2, -1
42007668:	000086        	j	4200766e <vfs_null_pread+0x26>
4200766b:	020c00        	andb	b0, b12, b0
}
4200766e:	f01d      	retw.n

42007670 <vfs_null_read>:
{
42007670:	004136        	entry	a1, 32
    if (FD_IN_RANGE(fd) && READABLE(g_fds, fd)) {
42007673:	f80c      	movi.n	a8, 15
42007675:	0b3827        	bltu	a8, a2, 42007684 <vfs_null_read+0x14>
42007678:	802220        	add	a2, a2, a2
4200767b:	e48481        	l32r	a8, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
4200767e:	002882        	l32i	a8, a8, 0
42007681:	0fd827        	bbs	a8, a2, 42007694 <vfs_null_read+0x24>
    errno = EBADF;
42007684:	03e065        	call8	4200b48c <__errno>
42007687:	09a082        	movi	a8, 9
4200768a:	006a82        	s32i	a8, a10, 0
    return -1;
4200768d:	ffaf22        	movi	a2, -1
42007690:	000086        	j	42007696 <vfs_null_read+0x26>
42007693:	020c00        	andb	b0, b12, b0
}
42007696:	f01d      	retw.n

42007698 <vfs_null_lseek>:
{
42007698:	004136        	entry	a1, 32
    if (!IS_FD_VALID(fd)) {
4200769b:	f80c      	movi.n	a8, 15
4200769d:	133827        	bltu	a8, a2, 420076b4 <vfs_null_lseek+0x1c>
420076a0:	222a      	add.n	a2, a2, a2
420076a2:	e47a81        	l32r	a8, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
420076a5:	002882        	l32i	a8, a8, 0
420076a8:	400200        	ssr	a2
420076ab:	918080        	srl	a8, a8
420076ae:	148080        	extui	a8, a8, 0, 2
420076b1:	00f856        	bnez	a8, 420076c4 <vfs_null_lseek+0x2c>
        errno = EBADF;
420076b4:	03dd65        	call8	4200b48c <__errno>
420076b7:	09a082        	movi	a8, 9
420076ba:	006a82        	s32i	a8, a10, 0
        return -1;
420076bd:	ffaf22        	movi	a2, -1
420076c0:	000506        	j	420076d8 <vfs_null_lseek+0x40>
420076c3:	34b600        	extui	a11, a0, 6, 4
    switch (whence) {
420076c6:	0e          	.byte	0xe
        errno = EINVAL;
420076c7:	03dc65        	call8	4200b48c <__errno>
420076ca:	16a082        	movi	a8, 22
420076cd:	006a82        	s32i	a8, a10, 0
        return -1;
420076d0:	ffaf22        	movi	a2, -1
420076d3:	000046        	j	420076d8 <vfs_null_lseek+0x40>
        return 0;
420076d6:	020c      	movi.n	a2, 0
}
420076d8:	f01d      	retw.n
	...

420076dc <vfs_null_write>:
{
420076dc:	004136        	entry	a1, 32
    if (FD_IN_RANGE(fd) && WRITABLE(g_fds, fd)) {
420076df:	f90c      	movi.n	a9, 15
420076e1:	143927        	bltu	a9, a2, 420076f9 <vfs_null_write+0x1d>
420076e4:	822a      	add.n	a8, a2, a2
420076e6:	e46991        	l32r	a9, 4200088c <_stext+0x86c> (3fc94f38 <g_fds>)
420076e9:	0998      	l32i.n	a9, a9, 0
420076eb:	400800        	ssr	a8
420076ee:	918090        	srl	a8, a9
420076f1:	046817        	bbci	a8, 1, 420076f9 <vfs_null_write+0x1d>
        return size;
420076f4:	042d      	mov.n	a2, a4
420076f6:	0002c6        	j	42007705 <vfs_null_write+0x29>
    errno = EBADF;
420076f9:	03d925        	call8	4200b48c <__errno>
420076fc:	09a082        	movi	a8, 9
420076ff:	006a82        	s32i	a8, a10, 0
    return -1;
42007702:	ffaf22        	movi	a2, -1
}
42007705:	f01d      	retw.n
	...

42007708 <vfs_null_stat>:
{
42007708:	004136        	entry	a1, 32
4200770b:	20a220        	or	a10, a2, a2
    if (strcmp(path, "/") != 0) {
4200770e:	e460b1        	l32r	a11, 42000890 <_stext+0x870> (3c024f94 <_flash_rodata_start+0x4e74>)
42007711:	e34e81        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
42007714:	0008e0        	callx8	a8
42007717:	202aa0        	or	a2, a10, a10
4200771a:	00ba16        	beqz	a10, 42007729 <vfs_null_stat+0x21>
        errno = ENOENT;
4200771d:	03d6e5        	call8	4200b48c <__errno>
42007720:	280c      	movi.n	a8, 2
42007722:	0a89      	s32i.n	a8, a10, 0
        return -1;
42007724:	f27c      	movi.n	a2, -1
42007726:	000846        	j	4200774b <vfs_null_stat+0x43>
    memset(st, 0, sizeof(struct stat));
42007729:	8c5c      	movi.n	a12, 88
4200772b:	0b0c      	movi.n	a11, 0
4200772d:	03ad      	mov.n	a10, a3
4200772f:	e2f481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007732:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR | 0666; // Special character device with read/write permissions for everyone
42007735:	e45781        	l32r	a8, 42000894 <_stext+0x874> (21b6 <UserFrameTotalSize+0x20b6>)
42007738:	1389      	s32i.n	a8, a3, 4
    st->st_nlink = 1;
4200773a:	180c      	movi.n	a8, 1
4200773c:	045382        	s16i	a8, a3, 8
    st->st_uid = 0;
4200773f:	080c      	movi.n	a8, 0
42007741:	055382        	s16i	a8, a3, 10
    st->st_gid = 0;
42007744:	065382        	s16i	a8, a3, 12
    st->st_size = 0;
42007747:	080c      	movi.n	a8, 0
42007749:	4389      	s32i.n	a8, a3, 16
}
4200774b:	f01d      	retw.n
4200774d:	000000        	ill

42007750 <vfs_null_fstat>:
{
42007750:	004136        	entry	a1, 32
    if (!FD_IN_RANGE(fd)) {
42007753:	0fa082        	movi	a8, 15
42007756:	0eb827        	bgeu	a8, a2, 42007768 <vfs_null_fstat+0x18>
        errno = EBADF;
42007759:	03d325        	call8	4200b48c <__errno>
4200775c:	09a082        	movi	a8, 9
4200775f:	006a82        	s32i	a8, a10, 0
        return -1;
42007762:	f27c      	movi.n	a2, -1
42007764:	000886        	j	4200778a <vfs_null_fstat+0x3a>
42007767:	8c5c00        	lsi	f0, a12, 0x230
    memset(st, 0, sizeof(struct stat));
4200776a:	0b0c      	movi.n	a11, 0
4200776c:	03ad      	mov.n	a10, a3
4200776e:	e2e481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007771:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR | 0666; // Special character device with read/write permissions for everyone
42007774:	e44881        	l32r	a8, 42000894 <_stext+0x874> (21b6 <UserFrameTotalSize+0x20b6>)
42007777:	1389      	s32i.n	a8, a3, 4
    st->st_nlink = 1;
42007779:	180c      	movi.n	a8, 1
4200777b:	045382        	s16i	a8, a3, 8
    st->st_uid = 0;
4200777e:	080c      	movi.n	a8, 0
42007780:	055382        	s16i	a8, a3, 10
    st->st_gid = 0;
42007783:	065382        	s16i	a8, a3, 12
    st->st_size = 0;
42007786:	020c      	movi.n	a2, 0
42007788:	4329      	s32i.n	a2, a3, 16
}
4200778a:	f01d      	retw.n

4200778c <esp_vfs_null_register>:
{
4200778c:	004136        	entry	a1, 32
    return esp_vfs_register_fs("/dev/null", &s_vfs_null, ESP_VFS_FLAG_STATIC, NULL);
4200778f:	0d0c      	movi.n	a13, 0
42007791:	8c0c      	movi.n	a12, 8
42007793:	e441b1        	l32r	a11, 42000898 <_stext+0x878> (3c02842c <s_vfs_null>)
42007796:	e441a1        	l32r	a10, 4200089c <_stext+0x87c> (3c024fd8 <_flash_rodata_start+0x4eb8>)
42007799:	ff32e5        	call8	42006ac8 <esp_vfs_register_fs>
}
4200779c:	0a2d      	mov.n	a2, a10
4200779e:	f01d      	retw.n

420077a0 <__esp_system_init_fn_init_vfs_nullfs>:

#if defined(CONFIG_VFS_INITIALIZE_DEV_NULL) || defined(CONFIG_ESP_CONSOLE_NONE)
ESP_SYSTEM_INIT_FN(init_vfs_nullfs, CORE, BIT(0), 113)
{
420077a0:	004136        	entry	a1, 32
    return esp_vfs_null_register();
420077a3:	fffea5        	call8	4200778c <esp_vfs_null_register>
}
420077a6:	0a2d      	mov.n	a2, a10
420077a8:	f01d      	retw.n
	...

420077ac <app_main>:
#endif

int32_t cycles{0};

extern "C" void app_main(void)
{
420077ac:	004136        	entry	a1, 32
    #if USE_ETL
        printf("Using ETL...\n");
420077af:	e43ca1        	l32r	a10, 420008a0 <_stext+0x880> (3c024fe4 <_flash_rodata_start+0x4ec4>)
420077b2:	037725        	call8	4200af24 <puts>
    #else
        printf("Using libstdc++...\n"); 
    #endif

    #if USE_STRING
        printf("Benchmarking string operations...\n"); 
420077b5:	e43ba1        	l32r	a10, 420008a4 <_stext+0x884> (3c024ff4 <_flash_rodata_start+0x4ed4>)
420077b8:	0376a5        	call8	4200af24 <puts>
        string_benchmark(cycles);
420077bb:	e43b81        	l32r	a8, 420008a8 <_stext+0x888> (3fc94f3c <cycles>)
420077be:	0028a2        	l32i	a10, a8, 0
420077c1:	006f65        	call8	42007eb8 <_Z16string_benchmarkm>
        set_benchmark(cycles); 
    #elif USE_DEQUE     
        printf("Benchmarking deque operations...\n"); 
        deque_benchmark(cycles); 
    #endif
}
420077c4:	f01d      	retw.n
	...

420077c8 <_ZN3etl18memory_clear_rangeIcEEvPVT_S3_>:
  ///\param begin The first object in the range.
  ///\param end   One past the last object in the range.
  ///\ingroup memory
  //*****************************************************************************
  template <typename T>
  void memory_clear_range(volatile T* begin, volatile T* end)
420077c8:	004136        	entry	a1, 32
420077cb:	02ad      	mov.n	a10, a2
  {
    const size_t n = static_cast<size_t>(etl::distance(begin, end));

    memory_clear_range(begin, n);
420077cd:	c0b320        	sub	a11, a3, a2
420077d0:	0d2625        	call8	42014a34 <_ZN3etl18memory_clear_rangeIcEEvPVT_j>
  }
420077d3:	f01d      	retw.n
420077d5:	000000        	ill

420077d8 <_ZN3etl13ibasic_stringIcE7cleanupEv>:
    }

    //*************************************************************************
    /// Clear the unused trailing portion of the string.
    //*************************************************************************
    void cleanup()
420077d8:	004136        	entry	a1, 32
    /// Tests bits.
    //*************************************************************************
    template <value_type pattern>
    ETL_CONSTEXPR bool test() const ETL_NOEXCEPT
    {
      return (data & pattern) != value_type(0);
420077db:	080282        	l8ui	a8, a2, 8
    {
#if ETL_HAS_STRING_CLEAR_AFTER_USE
      if (is_secure())
420077de:	0f6817        	bbci	a8, 1, 420077f1 <_ZN3etl13ibasic_stringIcE7cleanupEv+0x19>
      {
        etl::memory_clear_range(&p_buffer[current_size], &p_buffer[CAPACITY]);
420077e1:	032282        	l32i	a8, a2, 12
420077e4:	0022a2        	l32i	a10, a2, 0
420077e7:	0122b2        	l32i	a11, a2, 4
420077ea:	b8ba      	add.n	a11, a8, a11
420077ec:	a8aa      	add.n	a10, a8, a10
420077ee:	fffda5        	call8	420077c8 <_ZN3etl18memory_clear_rangeIcEEvPVT_S3_>
      }
#endif
    }
420077f1:	f01d      	retw.n
	...

420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>:
    void initialise()
420077f4:	004136        	entry	a1, 32
      current_size = 0U;
420077f7:	070c      	movi.n	a7, 0
420077f9:	0279      	s32i.n	a7, a2, 0
      cleanup();
420077fb:	02ad      	mov.n	a10, a2
420077fd:	fffda5        	call8	420077d8 <_ZN3etl13ibasic_stringIcE7cleanupEv>
      p_buffer[0] = 0;
42007800:	3288      	l32i.n	a8, a2, 12
42007802:	004872        	s8i	a7, a8, 0

    //*******************************************
    template <value_type pattern>
    ETL_CONSTEXPR14 flags<T, MASK>& set(bool value) ETL_NOEXCEPT
    {
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);
42007805:	080282        	l8ui	a8, a2, 8
42007808:	e97c      	movi.n	a9, -2
4200780a:	108890        	and	a8, a8, a9
4200780d:	084282        	s8i	a8, a2, 8
    }
42007810:	f01d      	retw.n
	...

42007814 <_ZN3etl13ibasic_stringIcED1Ev>:
  public:
    virtual
#else
  protected:
#endif
    ~ibasic_string()
42007814:	004136        	entry	a1, 32
      return (data & pattern) != value_type(0);
42007817:	080282        	l8ui	a8, a2, 8
    {
#if ETL_HAS_STRING_CLEAR_AFTER_USE
      if (is_secure())
4200781a:	046817        	bbci	a8, 1, 42007822 <_ZN3etl13ibasic_stringIcED1Ev+0xe>
      {
        initialise();
4200781d:	02ad      	mov.n	a10, a2
4200781f:	fffd65        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
      }
#endif
    }
42007822:	f01d      	retw.n

42007824 <_ZN3etl6stringILj256EED1Ev>:
  /// A string implementation that uses a fixed size buffer.
  ///\tparam MAX_SIZE_ The maximum number of elements that can be stored.
  ///\ingroup string
  //***************************************************************************
  template <size_t MAX_SIZE_>
  class string : public istring
42007824:	004136        	entry	a1, 32
42007827:	02ad      	mov.n	a10, a2
42007829:	fffea5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
4200782c:	f01d      	retw.n
	...

42007830 <_ZN3etl6stringILj1536EED1Ev>:
42007830:	004136        	entry	a1, 32
42007833:	02ad      	mov.n	a10, a2
42007835:	fffde5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
42007838:	f01d      	retw.n
	...

4200783c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb>:

    //*********************************************************************
    /// Common implementation for 'assign'.
    //*********************************************************************
    template <typename TIterator>
    void assign_impl(TIterator first, TIterator last, bool truncated, bool secure)
4200783c:	004136        	entry	a1, 32
4200783f:	745050        	extui	a5, a5, 0, 8
42007842:	746060        	extui	a6, a6, 0, 8
#if ETL_IS_DEBUG_BUILD
      difference_type d = etl::distance(first, last);
      ETL_ASSERT(d >= 0, ETL_ERROR(string_iterator));
#endif

      initialise();
42007845:	02ad      	mov.n	a10, a2
42007847:	fffae5        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>

      while ((first != last) && (current_size != CAPACITY))
4200784a:	000486        	j	42007860 <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb+0x24>
4200784d:	00          	.byte	00
4200784e:	00          	.byte	00
4200784f:	00          	.byte	00
      {
        p_buffer[current_size++] = *first++;
42007850:	0003a2        	l8ui	a10, a3, 0
42007853:	3298      	l32i.n	a9, a2, 12
42007855:	b81b      	addi.n	a11, a8, 1
42007857:	02b9      	s32i.n	a11, a2, 0
42007859:	898a      	add.n	a8, a9, a8
4200785b:	0048a2        	s8i	a10, a8, 0
4200785e:	331b      	addi.n	a3, a3, 1
      while ((first != last) && (current_size != CAPACITY))
42007860:	061347        	beq	a3, a4, 4200786a <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb+0x2e>
42007863:	0288      	l32i.n	a8, a2, 0
42007865:	1298      	l32i.n	a9, a2, 4
42007867:	e59897        	bne	a8, a9, 42007850 <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb+0x14>
      }

      p_buffer[current_size] = 0;
4200786a:	3288      	l32i.n	a8, a2, 12
4200786c:	0298      	l32i.n	a9, a2, 0
4200786e:	889a      	add.n	a8, a8, a9
42007870:	090c      	movi.n	a9, 0
42007872:	004892        	s8i	a9, a8, 0

#if ETL_HAS_STRING_TRUNCATION_CHECKS
      set_truncated((first != last) || truncated);
42007875:	c03340        	sub	a3, a3, a4
42007878:	180c      	movi.n	a8, 1
4200787a:	838330        	moveqz	a8, a3, a3
4200787d:	208850        	or	a8, a8, a5
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);
42007880:	c88c      	beqz.n	a8, 42007890 <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb+0x54>
42007882:	080282        	l8ui	a8, a2, 8
42007885:	190c      	movi.n	a9, 1
42007887:	208890        	or	a8, a8, a9
4200788a:	084282        	s8i	a8, a2, 8
4200788d:	0002c6        	j	4200789c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb+0x60>
42007890:	080282        	l8ui	a8, a2, 8
42007893:	feaf92        	movi	a9, -2
42007896:	108890        	and	a8, a8, a9
42007899:	084282        	s8i	a8, a2, 8
      ETL_ASSERT(flags.test<IS_TRUNCATED>() == false, ETL_ERROR(string_truncation));
#endif
#endif

#if ETL_HAS_STRING_CLEAR_AFTER_USE
      if (secure)
4200789c:	00b616        	beqz	a6, 420078ab <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb+0x6f>

    //*******************************************
    template <value_type pattern>
    ETL_CONSTEXPR14 flags<T, MASK>& set() ETL_NOEXCEPT
    {
      data |= (pattern & MASK);
4200789f:	080282        	l8ui	a8, a2, 8
420078a2:	02a092        	movi	a9, 2
420078a5:	208890        	or	a8, a8, a9
420078a8:	084282        	s8i	a8, a2, 8
      {
        set_secure();
      }
#endif

      cleanup();
420078ab:	02ad      	mov.n	a10, a2
420078ad:	fff2a5        	call8	420077d8 <_ZN3etl13ibasic_stringIcE7cleanupEv>
    }
420078b0:	f01d      	retw.n
	...

420078b4 <_ZN3etl6stringILj256EEC1EPKcj>:
    //*************************************************************************
    /// Constructor, from null terminated text and count.
    ///\param text  The initial text of the string.
    ///\param count The number of characters to copy.
    //*************************************************************************
    string(const value_type* text, size_t count)
420078b4:	004136        	entry	a1, 32
420078b7:	20a220        	or	a10, a2, a2
420078ba:	20b330        	or	a11, a3, a3
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
420078bd:	10c282        	addi	a8, a2, 16
      : current_size(0)
420078c0:	00a0d2        	movi	a13, 0
420078c3:	02d9      	s32i.n	a13, a2, 0
      , CAPACITY(max_size_)
420078c5:	00a192        	movi	a9, 0x100
420078c8:	1299      	s32i.n	a9, a2, 4
      : data(value_type(0))
420078ca:	0842d2        	s8i	a13, a2, 8
        p_buffer(p_buffer_)
420078cd:	3289      	s32i.n	a8, a2, 12
      assign_impl(first, last, false, false);
420078cf:	0ded      	mov.n	a14, a13
420078d1:	c34a      	add.n	a12, a3, a4
420078d3:	fff6a5        	call8	4200783c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb>
    {
      this->assign(text, text + count);
    }
420078d6:	f01d      	retw.n

420078d8 <_ZN3etl6stringILj256EEC1ERKNS_17basic_string_viewIcNS_11char_traitsIcEEEE>:

    //*************************************************************************
    /// From string_view.
    ///\param view The string_view.
    //*************************************************************************
    explicit string(const etl::string_view& view)
420078d8:	004136        	entry	a1, 32
420078db:	20a220        	or	a10, a2, a2
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
420078de:	10c282        	addi	a8, a2, 16
      : current_size(0)
420078e1:	00a0d2        	movi	a13, 0
420078e4:	0062d2        	s32i	a13, a2, 0
      , CAPACITY(max_size_)
420078e7:	00a192        	movi	a9, 0x100
420078ea:	1299      	s32i.n	a9, a2, 4
420078ec:	0842d2        	s8i	a13, a2, 8
        p_buffer(p_buffer_)
420078ef:	3289      	s32i.n	a8, a2, 12
      assign_impl(first, last, false, false);
420078f1:	0ded      	mov.n	a14, a13
420078f3:	13c8      	l32i.n	a12, a3, 4
420078f5:	03b8      	l32i.n	a11, a3, 0
420078f7:	fff465        	call8	4200783c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb>
    {
      this->assign(view.begin(), view.end());
    }
420078fa:	f01d      	retw.n

420078fc <_ZN3etl6stringILj256EEC1EPKc>:
    ETL_EXPLICIT_STRING_FROM_CHAR string(const value_type* text)
420078fc:	004136        	entry	a1, 32
420078ff:	02ad      	mov.n	a10, a2
42007901:	03bd      	mov.n	a11, a3
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
42007903:	10c292        	addi	a9, a2, 16
      : current_size(0)
42007906:	080c      	movi.n	a8, 0
42007908:	0289      	s32i.n	a8, a2, 0
      , CAPACITY(max_size_)
4200790a:	00a1c2        	movi	a12, 0x100
4200790d:	12c9      	s32i.n	a12, a2, 4
4200790f:	084282        	s8i	a8, a2, 8
        p_buffer(p_buffer_)
42007912:	3299      	s32i.n	a9, a2, 12
    //*************************************************************************
    static ETL_CONSTEXPR14 size_t length(const char_type* str)
    {
      size_t count = 0UL;

      if (str != 0)
42007914:	c3cc      	bnez.n	a3, 42007924 <_ZN3etl6stringILj256EEC1EPKc+0x28>
      size_t count = 0UL;
42007916:	08cd      	mov.n	a12, a8
42007918:	0005c6        	j	42007933 <_ZN3etl6stringILj256EEC1EPKc+0x37>
4200791b:	00          	.byte	00
      {
        while (*str++ != 0)
        {
          ++count;
4200791c:	cc1b      	addi.n	a12, a12, 1
        while (*str++ != 0)
4200791e:	098d      	mov.n	a8, a9
42007920:	000186        	j	4200792a <_ZN3etl6stringILj256EEC1EPKc+0x2e>
42007923:	00          	.byte	00
42007924:	208330        	or	a8, a3, a3
      size_t count = 0UL;
42007927:	00a0c2        	movi	a12, 0
        while (*str++ != 0)
4200792a:	01c892        	addi	a9, a8, 1
4200792d:	000882        	l8ui	a8, a8, 0
42007930:	fe8856        	bnez	a8, 4200791c <_ZN3etl6stringILj256EEC1EPKc+0x20>
      assign_impl(first, last, false, false);
42007933:	0e0c      	movi.n	a14, 0
42007935:	0edd      	mov.n	a13, a14
42007937:	cbca      	add.n	a12, a11, a12
42007939:	fff025        	call8	4200783c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb>
    }
4200793c:	f01d      	retw.n
	...

42007940 <_ZNK3etl6stringILj1536EE6substrEjj>:
    //*************************************************************************
    /// Returns a sub-string.
    ///\param position The position of the first character.  Default = 0.
    ///\param length   The number of characters. Default = npos.
    //*************************************************************************
    etl::string<MAX_SIZE_> substr(size_type position = 0, size_type length_ = npos) const
42007940:	004136        	entry	a1, 32
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
42007943:	10c292        	addi	a9, a2, 16
      : current_size(0)
42007946:	00a082        	movi	a8, 0
42007949:	006282        	s32i	a8, a2, 0
      , CAPACITY(max_size_)
4200794c:	00a6a2        	movi	a10, 0x600
4200794f:	12a9      	s32i.n	a10, a2, 4
42007951:	084282        	s8i	a8, a2, 8
        p_buffer(p_buffer_)
42007954:	3299      	s32i.n	a9, a2, 12
      this->initialise();
42007956:	02ad      	mov.n	a10, a2
42007958:	ffe9a5        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
      return current_size;
4200795b:	0388      	l32i.n	a8, a3, 0
    {
      etl::string<MAX_SIZE_> new_string;

      if (position != this->size())
4200795d:	191487        	beq	a4, a8, 4200797a <_ZNK3etl6stringILj1536EE6substrEjj+0x3a>
      {
        ETL_ASSERT(position < this->size(), ETL_ERROR(string_out_of_bounds));

        length_ = etl::min(length_, this->size() - position);
42007960:	c08840        	sub	a8, a8, a4
  template <typename T, typename TCompare>
  ETL_NODISCARD
  ETL_CONSTEXPR 
  const T& min(const T& a, const T& b, TCompare compare)
  {
    return (compare(a, b)) ? a : b;
42007963:	013587        	bltu	a5, a8, 42007968 <_ZNK3etl6stringILj1536EE6substrEjj+0x28>
42007966:	085d      	mov.n	a5, a8

        new_string.assign(buffer + position, buffer + position + length_);
42007968:	10c3b2        	addi	a11, a3, 16
4200796b:	c54a      	add.n	a12, a5, a4
      assign_impl(first, last, false, false);
4200796d:	0e0c      	movi.n	a14, 0
4200796f:	0edd      	mov.n	a13, a14
42007971:	cbca      	add.n	a12, a11, a12
42007973:	bb4a      	add.n	a11, a11, a4
42007975:	02ad      	mov.n	a10, a2
42007977:	ffec65        	call8	4200783c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb>
      }

      return new_string;
    }
4200797a:	f01d      	retw.n

4200797c <_ZN3etl6stringILj1536EEC1EPKc>:
    ETL_EXPLICIT_STRING_FROM_CHAR string(const value_type* text)
4200797c:	004136        	entry	a1, 32
4200797f:	02ad      	mov.n	a10, a2
42007981:	03bd      	mov.n	a11, a3
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
42007983:	10c292        	addi	a9, a2, 16
      : current_size(0)
42007986:	080c      	movi.n	a8, 0
42007988:	0289      	s32i.n	a8, a2, 0
      , CAPACITY(max_size_)
4200798a:	00a6c2        	movi	a12, 0x600
4200798d:	12c9      	s32i.n	a12, a2, 4
4200798f:	084282        	s8i	a8, a2, 8
        p_buffer(p_buffer_)
42007992:	3299      	s32i.n	a9, a2, 12
      if (str != 0)
42007994:	a3cc      	bnez.n	a3, 420079a2 <_ZN3etl6stringILj1536EEC1EPKc+0x26>
      size_t count = 0UL;
42007996:	08cd      	mov.n	a12, a8
42007998:	000546        	j	420079b1 <_ZN3etl6stringILj1536EEC1EPKc+0x35>
          ++count;
4200799b:	cc1b      	addi.n	a12, a12, 1
        while (*str++ != 0)
4200799d:	098d      	mov.n	a8, a9
4200799f:	000146        	j	420079a8 <_ZN3etl6stringILj1536EEC1EPKc+0x2c>
420079a2:	208330        	or	a8, a3, a3
      size_t count = 0UL;
420079a5:	00a0c2        	movi	a12, 0
        while (*str++ != 0)
420079a8:	01c892        	addi	a9, a8, 1
420079ab:	000882        	l8ui	a8, a8, 0
420079ae:	fe9856        	bnez	a8, 4200799b <_ZN3etl6stringILj1536EEC1EPKc+0x1f>
      assign_impl(first, last, false, false);
420079b1:	0e0c      	movi.n	a14, 0
420079b3:	0edd      	mov.n	a13, a14
420079b5:	cbca      	add.n	a12, a11, a12
420079b7:	ffe865        	call8	4200783c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb>
    }
420079ba:	f01d      	retw.n

420079bc <_Z41__static_initialization_and_destruction_0v>:
        "string: _str_jumbo.replace(middle_pos, \"hello again\")"
    );
    
    ESP_LOGI(tag, "DONE\n");    

}
420079bc:	004136        	entry	a1, 32
_string _str_tiny{c_str_tiny};
420079bf:	e3bc51        	l32r	a5, 420008b0 <_stext+0x890> (3fc95d98 <_str_tiny>)
420079c2:	e3ba81        	l32r	a8, 420008ac <_stext+0x88c> (3fc921b4 <c_str_tiny>)
420079c5:	08b8      	l32i.n	a11, a8, 0
420079c7:	05ad      	mov.n	a10, a5
420079c9:	fff325        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>

      static __waiter_pool_base&
      _S_for(const void* __addr) noexcept
      {
	constexpr uintptr_t __ct = 16;
	static __waiter_pool_base __w[__ct];
420079cc:	e3ba61        	l32r	a6, 420008b4 <_stext+0x894> (3fc94ed4 <__dso_handle>)
420079cf:	e3ba71        	l32r	a7, 420008b8 <_stext+0x898> (42007824 <_ZN3etl6stringILj256EED1Ev>)
420079d2:	06cd      	mov.n	a12, a6
420079d4:	05bd      	mov.n	a11, a5
420079d6:	20a770        	or	a10, a7, a7
420079d9:	02bea5        	call8	4200a5c4 <__cxa_atexit>
_string _str_medium{c_str_medium};
420079dc:	e3b951        	l32r	a5, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
420079df:	e3b781        	l32r	a8, 420008bc <_stext+0x89c> (3fc921b0 <c_str_medium>)
420079e2:	08b8      	l32i.n	a11, a8, 0
420079e4:	05ad      	mov.n	a10, a5
420079e6:	fff165        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
420079e9:	06cd      	mov.n	a12, a6
420079eb:	05bd      	mov.n	a11, a5
420079ed:	07ad      	mov.n	a10, a7
420079ef:	02bd65        	call8	4200a5c4 <__cxa_atexit>
_string _str_large{c_str_large};
420079f2:	e3b451        	l32r	a5, 420008c4 <_stext+0x8a4> (3fc921ac <c_str_large>)
420079f5:	05b8      	l32i.n	a11, a5, 0
420079f7:	e3b4a1        	l32r	a10, 420008c8 <_stext+0x8a8> (3fc95b70 <_str_large>)
420079fa:	fff025        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
420079fd:	06cd      	mov.n	a12, a6
420079ff:	e3b2b1        	l32r	a11, 420008c8 <_stext+0x8a8> (3fc95b70 <_str_large>)
42007a02:	20a770        	or	a10, a7, a7
42007a05:	02bbe5        	call8	4200a5c4 <__cxa_atexit>
const _string_view _str_vu{c_str_large};
42007a08:	05b8      	l32i.n	a11, a5, 0

    //*************************************************************************
    /// Construct from T*.
    //*************************************************************************
    ETL_CONSTEXPR14  ETL_EXPLICIT_STRING_FROM_CHAR basic_string_view(const T* begin_)
      : mbegin(begin_)
42007a0a:	e3b081        	l32r	a8, 420008cc <_stext+0x8ac> (3fc95b68 <_str_vu>)
42007a0d:	08b9      	s32i.n	a11, a8, 0
      if (str != 0)
42007a0f:	abcc      	bnez.n	a11, 42007a1d <_Z41__static_initialization_and_destruction_0v+0x61>
      size_t count = 0UL;
42007a11:	090c      	movi.n	a9, 0
42007a13:	000486        	j	42007a29 <_Z41__static_initialization_and_destruction_0v+0x6d>
          ++count;
42007a16:	991b      	addi.n	a9, a9, 1
        while (*str++ != 0)
42007a18:	0a8d      	mov.n	a8, a10
42007a1a:	0000c6        	j	42007a21 <_Z41__static_initialization_and_destruction_0v+0x65>
42007a1d:	0b8d      	mov.n	a8, a11
      size_t count = 0UL;
42007a1f:	090c      	movi.n	a9, 0
        while (*str++ != 0)
42007a21:	a81b      	addi.n	a10, a8, 1
42007a23:	000882        	l8ui	a8, a8, 0
42007a26:	fec856        	bnez	a8, 42007a16 <_Z41__static_initialization_and_destruction_0v+0x5a>
      , mend(begin_ + TTraits::length(begin_))
42007a29:	bb9a      	add.n	a11, a11, a9
42007a2b:	e3a881        	l32r	a8, 420008cc <_stext+0x8ac> (3fc95b68 <_str_vu>)
42007a2e:	18b9      	s32i.n	a11, a8, 4
    etl::string<6*MAX_STRLN> _str_jumbo{c_str_jumbo};
42007a30:	e3a971        	l32r	a7, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
42007a33:	e3a781        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc921a8 <c_str_jumbo>)
42007a36:	08b8      	l32i.n	a11, a8, 0
42007a38:	07ad      	mov.n	a10, a7
42007a3a:	fff425        	call8	4200797c <_ZN3etl6stringILj1536EEC1EPKc>
42007a3d:	e3a661        	l32r	a6, 420008d8 <_stext+0x8b8> (42007830 <_ZN3etl6stringILj1536EED1Ev>)
42007a40:	e39dc1        	l32r	a12, 420008b4 <_stext+0x894> (3fc94ed4 <__dso_handle>)
42007a43:	07bd      	mov.n	a11, a7
42007a45:	06ad      	mov.n	a10, a6
42007a47:	02b7e5        	call8	4200a5c4 <__cxa_atexit>
      : current_size(0)
42007a4a:	e3a471        	l32r	a7, 420008dc <_stext+0x8bc> (3fc94f40 <_str_jumbo2>)
42007a4d:	080c      	movi.n	a8, 0
42007a4f:	0789      	s32i.n	a8, a7, 0
      , CAPACITY(max_size_)
42007a51:	00a692        	movi	a9, 0x600
42007a54:	1799      	s32i.n	a9, a7, 4
42007a56:	084782        	s8i	a8, a7, 8
        p_buffer(p_buffer_)
42007a59:	e3a181        	l32r	a8, 420008e0 <_stext+0x8c0> (3fc94f50 <_str_jumbo2+0x10>)
42007a5c:	3789      	s32i.n	a8, a7, 12
      this->initialise();
42007a5e:	07ad      	mov.n	a10, a7
42007a60:	ffd925        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
42007a63:	e394c1        	l32r	a12, 420008b4 <_stext+0x894> (3fc94ed4 <__dso_handle>)
42007a66:	07bd      	mov.n	a11, a7
42007a68:	06ad      	mov.n	a10, a6
42007a6a:	02b5a5        	call8	4200a5c4 <__cxa_atexit>
}
42007a6d:	f01d      	retw.n
	...

42007a70 <_ZN3etl13ibasic_stringIcE6assignEPKc>:
    void assign(const_pointer text)
42007a70:	004136        	entry	a1, 32
42007a73:	02ad      	mov.n	a10, a2
42007a75:	03bd      	mov.n	a11, a3
      if (str != 0)
42007a77:	a3cc      	bnez.n	a3, 42007a85 <_ZN3etl13ibasic_stringIcE6assignEPKc+0x15>
      size_t count = 0UL;
42007a79:	0c0c      	movi.n	a12, 0
42007a7b:	000546        	j	42007a94 <_ZN3etl13ibasic_stringIcE6assignEPKc+0x24>
          ++count;
42007a7e:	cc1b      	addi.n	a12, a12, 1
        while (*str++ != 0)
42007a80:	098d      	mov.n	a8, a9
42007a82:	000146        	j	42007a8b <_ZN3etl13ibasic_stringIcE6assignEPKc+0x1b>
42007a85:	208330        	or	a8, a3, a3
      size_t count = 0UL;
42007a88:	00a0c2        	movi	a12, 0
        while (*str++ != 0)
42007a8b:	01c892        	addi	a9, a8, 1
42007a8e:	000882        	l8ui	a8, a8, 0
42007a91:	fe9856        	bnez	a8, 42007a7e <_ZN3etl13ibasic_stringIcE6assignEPKc+0xe>
      assign_impl(text, text + etl::strlen(text), false, false);
42007a94:	0e0c      	movi.n	a14, 0
42007a96:	0edd      	mov.n	a13, a14
42007a98:	cbca      	add.n	a12, a11, a12
42007a9a:	ffda25        	call8	4200783c <_ZN3etl13ibasic_stringIcE11assign_implIPKcEEvT_S5_bb>
    }
42007a9d:	f01d      	retw.n
	...

42007aa0 <_ZN3etl13ibasic_stringIcE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE_EEvjT_>:
    void resize_and_overwrite(size_type new_size, TOperation operation)
42007aa0:	004136        	entry	a1, 32
    CYCLE_GET_COUNT(
42007aa3:	5c0c      	movi.n	a12, 5
42007aa5:	e38fb1        	l32r	a11, 420008e4 <_stext+0x8c4> (3c025018 <_flash_rodata_start+0x4ef8>)
42007aa8:	32a8      	l32i.n	a10, a2, 12
42007aaa:	e15f81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42007aad:	0008e0        	callx8	a8
      current_size = operation(p_buffer, new_size);
42007ab0:	580c      	movi.n	a8, 5
42007ab2:	0289      	s32i.n	a8, a2, 0
      p_buffer[current_size] = '\0';
42007ab4:	3288      	l32i.n	a8, a2, 12
42007ab6:	090c      	movi.n	a9, 0
42007ab8:	054892        	s8i	a9, a8, 5
      cleanup();
42007abb:	02ad      	mov.n	a10, a2
42007abd:	ffd1a5        	call8	420077d8 <_ZN3etl13ibasic_stringIcE7cleanupEv>
    }
42007ac0:	f01d      	retw.n
	...

42007ac4 <_ZN3etl13ibasic_stringIcE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE0_EEvjT_>:
    void resize_and_overwrite(size_type new_size, TOperation operation)
42007ac4:	004136        	entry	a1, 32
42007ac7:	5c0c      	movi.n	a12, 5
42007ac9:	e386b1        	l32r	a11, 420008e4 <_stext+0x8c4> (3c025018 <_flash_rodata_start+0x4ef8>)
42007acc:	32a8      	l32i.n	a10, a2, 12
42007ace:	e15681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42007ad1:	0008e0        	callx8	a8
      current_size = operation(p_buffer, new_size);
42007ad4:	580c      	movi.n	a8, 5
42007ad6:	0289      	s32i.n	a8, a2, 0
      p_buffer[current_size] = '\0';
42007ad8:	3288      	l32i.n	a8, a2, 12
42007ada:	090c      	movi.n	a9, 0
42007adc:	054892        	s8i	a9, a8, 5
      cleanup();
42007adf:	02ad      	mov.n	a10, a2
42007ae1:	ffcf65        	call8	420077d8 <_ZN3etl13ibasic_stringIcE7cleanupEv>
    }
42007ae4:	f01d      	retw.n
	...

42007ae8 <_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsrSt9__is_byteIT_E7__valueEvE6__typeEPS3_S7_RKS3_>:
  // Specialization: for char types we can use memset.
  template<typename _Tp>
    _GLIBCXX20_CONSTEXPR
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
42007ae8:	004136        	entry	a1, 32
    {
      const _Tp __tmp = __c;
42007aeb:	0004b2        	l8ui	a11, a4, 0
	  for (; __first != __last; ++__first)
	    *__first = __tmp;
	  return;
	}
#endif
      if (const size_t __len = __last - __first)
42007aee:	c0c320        	sub	a12, a3, a2
42007af1:	071237        	beq	a2, a3, 42007afc <_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsrSt9__is_byteIT_E7__valueEvE6__typeEPS3_S7_RKS3_+0x14>
	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
42007af4:	02ad      	mov.n	a10, a2
42007af6:	e20281        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42007af9:	0008e0        	callx8	a8
    }
42007afc:	f01d      	retw.n
	...

42007b00 <_ZN3etl13ibasic_stringIcE6resizeEjc>:
    void resize(size_type new_size, T value)
42007b00:	006136        	entry	a1, 48
42007b03:	004142        	s8i	a4, a1, 0
      if (new_size > CAPACITY)
42007b06:	012282        	l32i	a8, a2, 4
42007b09:	0bb837        	bgeu	a8, a3, 42007b18 <_ZN3etl13ibasic_stringIcE6resizeEjc+0x18>
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);
42007b0c:	080292        	l8ui	a9, a2, 8
42007b0f:	01a0a2        	movi	a10, 1
42007b12:	2099a0        	or	a9, a9, a10
42007b15:	084292        	s8i	a9, a2, 8
42007b18:	023387        	bltu	a3, a8, 42007b1e <_ZN3etl13ibasic_stringIcE6resizeEjc+0x1e>
      new_size = etl::min(new_size, CAPACITY);
42007b1b:	203880        	or	a3, a8, a8
      if (new_size > current_size)
42007b1e:	002282        	l32i	a8, a2, 0
42007b21:	0bb837        	bgeu	a8, a3, 42007b30 <_ZN3etl13ibasic_stringIcE6resizeEjc+0x30>
        etl::fill(p_buffer + current_size, p_buffer + new_size, value);
42007b24:	0322a2        	l32i	a10, a2, 12

  template<typename _FIte, typename _Tp>
    _GLIBCXX20_CONSTEXPR
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }
42007b27:	01cd      	mov.n	a12, a1
42007b29:	ba3a      	add.n	a11, a10, a3
42007b2b:	aa8a      	add.n	a10, a10, a8
42007b2d:	fffba5        	call8	42007ae8 <_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsrSt9__is_byteIT_E7__valueEvE6__typeEPS3_S7_RKS3_>
      current_size = new_size;
42007b30:	0239      	s32i.n	a3, a2, 0
      p_buffer[new_size] = 0;
42007b32:	3288      	l32i.n	a8, a2, 12
42007b34:	883a      	add.n	a8, a8, a3
42007b36:	090c      	movi.n	a9, 0
42007b38:	004892        	s8i	a9, a8, 0
      cleanup();
42007b3b:	02ad      	mov.n	a10, a2
42007b3d:	ffc9a5        	call8	420077d8 <_ZN3etl13ibasic_stringIcE7cleanupEv>
    }
42007b40:	f01d      	retw.n
	...

42007b44 <_ZN3etl6stringILj256EEC1Ejc>:
    string(size_type count, value_type c)
42007b44:	004136        	entry	a1, 32
42007b47:	744040        	extui	a4, a4, 0, 8
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
42007b4a:	10c292        	addi	a9, a2, 16
      : current_size(0)
42007b4d:	00a082        	movi	a8, 0
42007b50:	006282        	s32i	a8, a2, 0
      , CAPACITY(max_size_)
42007b53:	00a1a2        	movi	a10, 0x100
42007b56:	12a9      	s32i.n	a10, a2, 4
      : data(value_type(0))
42007b58:	084282        	s8i	a8, a2, 8
        p_buffer(p_buffer_)
42007b5b:	3299      	s32i.n	a9, a2, 12
      this->initialise();
42007b5d:	20a220        	or	a10, a2, a2
42007b60:	ffc925        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
      this->resize(count, c);
42007b63:	04cd      	mov.n	a12, a4
42007b65:	03bd      	mov.n	a11, a3
42007b67:	02ad      	mov.n	a10, a2
42007b69:	fff965        	call8	42007b00 <_ZN3etl13ibasic_stringIcE6resizeEjc>
    }
42007b6c:	f01d      	retw.n
	...

42007b70 <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_>:
	__copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
42007b70:	004136        	entry	a1, 32
42007b73:	02bd      	mov.n	a11, a2
	  const ptrdiff_t _Num = __last - __first;
42007b75:	c03320        	sub	a3, a3, a2
	  if (__builtin_expect(_Num > 1, true))
42007b78:	180c      	movi.n	a8, 1
42007b7a:	0fa837        	bge	a8, a3, 42007b8d <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_+0x1d>
	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
42007b7d:	03cd      	mov.n	a12, a3
42007b7f:	c0a430        	sub	a10, a4, a3
42007b82:	e35981        	l32r	a8, 420008e8 <_stext+0x8c8> (40001200 <memmove>)
42007b85:	0008e0        	callx8	a8
42007b88:	000306        	j	42007b98 <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_+0x28>
42007b8b:	00          	.byte	00
42007b8c:	00          	.byte	00
	  else if (_Num == 1)
42007b8d:	071366        	bnei	a3, 1, 42007b98 <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_+0x28>
	{ *__to = *__from; }
42007b90:	000292        	l8ui	a9, a2, 0
42007b93:	840b      	addi.n	a8, a4, -1
42007b95:	004892        	s8i	a9, a8, 0
	}
42007b98:	c02430        	sub	a2, a4, a3
42007b9b:	f01d      	retw.n
42007b9d:	000000        	ill

42007ba0 <_ZN3etl13ibasic_stringIcE6insertEPKcjc>:
    iterator insert(const_iterator position, size_type n, T value)
42007ba0:	006136        	entry	a1, 48
42007ba3:	027d      	mov.n	a7, a2
42007ba5:	032d      	mov.n	a2, a3
42007ba7:	004152        	s8i	a5, a1, 0
      if (n == 0)
42007baa:	08a416        	beqz	a4, 42007c38 <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x98>
      return &p_buffer[0];
42007bad:	37b8      	l32i.n	a11, a7, 12
  }

  template<typename TIterator>
  ETL_CONSTEXPR14 typename etl::iterator_traits<TIterator>::difference_type distance_helper(TIterator first, TIterator last, ETL_OR_STD::random_access_iterator_tag)
  {
    return last - first;
42007baf:	c083b0        	sub	a8, a3, a11
      if (start >= CAPACITY)
42007bb2:	1798      	l32i.n	a9, a7, 4
42007bb4:	0d3897        	bltu	a8, a9, 42007bc5 <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x25>
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);
42007bb7:	080782        	l8ui	a8, a7, 8
42007bba:	190c      	movi.n	a9, 1
42007bbc:	208890        	or	a8, a8, a9
42007bbf:	084782        	s8i	a8, a7, 8
        return to_iterator(position);;
42007bc2:	001c86        	j	42007c38 <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x98>
      if ((start + n) >= CAPACITY)
42007bc5:	c48a      	add.n	a12, a4, a8
42007bc7:	213c97        	bltu	a12, a9, 42007bec <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x4c>
        if ((current_size + n) > CAPACITY)
42007bca:	0788      	l32i.n	a8, a7, 0
42007bcc:	884a      	add.n	a8, a8, a4
42007bce:	0bb987        	bgeu	a9, a8, 42007bdd <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x3d>
42007bd1:	080782        	l8ui	a8, a7, 8
42007bd4:	01a0a2        	movi	a10, 1
42007bd7:	2088a0        	or	a8, a8, a10
42007bda:	084782        	s8i	a8, a7, 8
        current_size = CAPACITY;
42007bdd:	0799      	s32i.n	a9, a7, 0
    { std::__fill_a1(__first, __last, __value); }
42007bdf:	01cd      	mov.n	a12, a1
42007be1:	bb9a      	add.n	a11, a11, a9
42007be3:	02ad      	mov.n	a10, a2
42007be5:	fff025        	call8	42007ae8 <_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsrSt9__is_byteIT_E7__valueEvE6__typeEPS3_S7_RKS3_>
  }
42007be8:	001046        	j	42007c2d <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x8d>
42007beb:	00          	.byte	00
        const size_type remaining_characters = current_size - start;
42007bec:	07a8      	l32i.n	a10, a7, 0
42007bee:	c0da80        	sub	a13, a10, a8
        const size_type max_shift_characters = CAPACITY - start - shift_amount;
42007bf1:	c08980        	sub	a8, a9, a8
42007bf4:	c08840        	sub	a8, a8, a4
    return (compare(a, b)) ? a : b;
42007bf7:	0138d7        	bltu	a8, a13, 42007bfc <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x5c>
42007bfa:	0d8d      	mov.n	a8, a13
        if ((start + shift_amount + remaining_characters) > CAPACITY)
42007bfc:	aa4a      	add.n	a10, a10, a4
42007bfe:	0fb9a7        	bgeu	a9, a10, 42007c11 <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x71>
          current_size = CAPACITY;
42007c01:	0799      	s32i.n	a9, a7, 0
42007c03:	080792        	l8ui	a9, a7, 8
42007c06:	1a0c      	movi.n	a10, 1
42007c08:	2099a0        	or	a9, a9, a10
42007c0b:	084792        	s8i	a9, a7, 8
42007c0e:	0001c6        	j	42007c19 <_ZN3etl13ibasic_stringIcE6insertEPKcjc+0x79>
          current_size += shift_amount;
42007c11:	002792        	l32i	a9, a7, 0
42007c14:	809940        	add	a9, a9, a4
42007c17:	0799      	s32i.n	a9, a7, 0
        etl::copy_backward(insert_position, insert_position + characters_to_shift, begin() + to_position + characters_to_shift);
42007c19:	cc8a      	add.n	a12, a12, a8
				       _Category>::__copy_move_b(__first,
42007c1b:	cbca      	add.n	a12, a11, a12
42007c1d:	b28a      	add.n	a11, a2, a8
42007c1f:	02ad      	mov.n	a10, a2
42007c21:	fff4e5        	call8	42007b70 <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_>
    { std::__fill_a1(__first, __last, __value); }
42007c24:	01cd      	mov.n	a12, a1
42007c26:	b24a      	add.n	a11, a2, a4
42007c28:	02ad      	mov.n	a10, a2
42007c2a:	ffebe5        	call8	42007ae8 <_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsrSt9__is_byteIT_E7__valueEvE6__typeEPS3_S7_RKS3_>
      p_buffer[current_size] = 0;
42007c2d:	3788      	l32i.n	a8, a7, 12
42007c2f:	0798      	l32i.n	a9, a7, 0
42007c31:	889a      	add.n	a8, a8, a9
42007c33:	090c      	movi.n	a9, 0
42007c35:	004892        	s8i	a9, a8, 0
    }
42007c38:	f01d      	retw.n
	...

42007c3c <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_>:
    iterator insert(const_iterator position, TIterator first, TIterator last)
42007c3c:	004136        	entry	a1, 32
42007c3f:	027d      	mov.n	a7, a2
42007c41:	032d      	mov.n	a2, a3
      if (first == last)
42007c43:	029457        	bne	a4, a5, 42007c49 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0xd>
42007c46:	002886        	j	42007cec <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0xb0>
      return &p_buffer[0];
42007c49:	37d8      	l32i.n	a13, a7, 12
42007c4b:	c083d0        	sub	a8, a3, a13
42007c4e:	c0a540        	sub	a10, a5, a4
      if (start >= CAPACITY)
42007c51:	1798      	l32i.n	a9, a7, 4
42007c53:	0e3897        	bltu	a8, a9, 42007c65 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x29>
42007c56:	080782        	l8ui	a8, a7, 8
42007c59:	190c      	movi.n	a9, 1
42007c5b:	208890        	or	a8, a8, a9
42007c5e:	084782        	s8i	a8, a7, 8
        return position_;
42007c61:	0021c6        	j	42007cec <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0xb0>
42007c64:	00          	.byte	00
      if ((start + n) >= CAPACITY)
42007c65:	c8aa      	add.n	a12, a8, a10
42007c67:	2c3c97        	bltu	a12, a9, 42007c97 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x5b>
        if (((current_size + n) > CAPACITY))
42007c6a:	0788      	l32i.n	a8, a7, 0
42007c6c:	88aa      	add.n	a8, a8, a10
42007c6e:	0ab987        	bgeu	a9, a8, 42007c7c <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x40>
42007c71:	080782        	l8ui	a8, a7, 8
42007c74:	1a0c      	movi.n	a10, 1
42007c76:	2088a0        	or	a8, a8, a10
42007c79:	084782        	s8i	a8, a7, 8
        current_size = CAPACITY;
42007c7c:	0799      	s32i.n	a9, a7, 0
        while (position_ != end())
42007c7e:	000246        	j	42007c8b <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x4f>
          *position_++ = *first++;
42007c81:	000482        	l8ui	a8, a4, 0
42007c84:	004282        	s8i	a8, a2, 0
42007c87:	221b      	addi.n	a2, a2, 1
42007c89:	441b      	addi.n	a4, a4, 1
      return &p_buffer[current_size];
42007c8b:	3788      	l32i.n	a8, a7, 12
42007c8d:	0798      	l32i.n	a9, a7, 0
42007c8f:	889a      	add.n	a8, a8, a9
        while (position_ != end())
42007c91:	ec9287        	bne	a2, a8, 42007c81 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x45>
42007c94:	001246        	j	42007ce1 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0xa5>
        const size_type remaining_characters = current_size - start;
42007c97:	07e8      	l32i.n	a14, a7, 0
42007c99:	c0fe80        	sub	a15, a14, a8
        const size_type max_shift_characters = CAPACITY - start - shift_amount;
42007c9c:	c08980        	sub	a8, a9, a8
42007c9f:	c0b8a0        	sub	a11, a8, a10
42007ca2:	023bf7        	bltu	a11, a15, 42007ca8 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x6c>
42007ca5:	20bff0        	or	a11, a15, a15
        if ((start + shift_amount + remaining_characters) > CAPACITY)
42007ca8:	eeaa      	add.n	a14, a14, a10
42007caa:	0fb9e7        	bgeu	a9, a14, 42007cbd <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x81>
          current_size = CAPACITY;
42007cad:	0799      	s32i.n	a9, a7, 0
42007caf:	080782        	l8ui	a8, a7, 8
42007cb2:	190c      	movi.n	a9, 1
42007cb4:	208890        	or	a8, a8, a9
42007cb7:	084782        	s8i	a8, a7, 8
42007cba:	000206        	j	42007cc6 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x8a>
          current_size += shift_amount;
42007cbd:	002782        	l32i	a8, a7, 0
42007cc0:	8088a0        	add	a8, a8, a10
42007cc3:	006782        	s32i	a8, a7, 0
        etl::copy_backward(position_, position_ + characters_to_shift, begin() + to_position + characters_to_shift);
42007cc6:	ccba      	add.n	a12, a12, a11
				       _Category>::__copy_move_b(__first,
42007cc8:	cdca      	add.n	a12, a13, a12
42007cca:	b2ba      	add.n	a11, a2, a11
42007ccc:	02ad      	mov.n	a10, a2
42007cce:	ffea25        	call8	42007b70 <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_>
    return std::copy_backward(sb, se, de);
42007cd1:	000246        	j	42007cde <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0xa2>
          *position_++ = *first++;
42007cd4:	000482        	l8ui	a8, a4, 0
42007cd7:	004282        	s8i	a8, a2, 0
42007cda:	221b      	addi.n	a2, a2, 1
42007cdc:	441b      	addi.n	a4, a4, 1
        while (first != last)
42007cde:	f29457        	bne	a4, a5, 42007cd4 <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_+0x98>
      p_buffer[current_size] = 0;
42007ce1:	3788      	l32i.n	a8, a7, 12
42007ce3:	0798      	l32i.n	a9, a7, 0
42007ce5:	889a      	add.n	a8, a8, a9
42007ce7:	090c      	movi.n	a9, 0
42007ce9:	004892        	s8i	a9, a8, 0
    }
42007cec:	f01d      	retw.n
	...

42007cf0 <_ZN3etl13ibasic_stringIcE6insertEjPKc>:
    etl::ibasic_string<T>& insert(size_type position, const_pointer s)
42007cf0:	004136        	entry	a1, 32
42007cf3:	04cd      	mov.n	a12, a4
      return &p_buffer[0];
42007cf5:	32b8      	l32i.n	a11, a2, 12
      insert(begin() + position, s, s + etl::strlen(s));
42007cf7:	bb3a      	add.n	a11, a11, a3
      if (str != 0)
42007cf9:	b4cc      	bnez.n	a4, 42007d08 <_ZN3etl13ibasic_stringIcE6insertEjPKc+0x18>
      size_t count = 0UL;
42007cfb:	0d0c      	movi.n	a13, 0
42007cfd:	000586        	j	42007d17 <_ZN3etl13ibasic_stringIcE6insertEjPKc+0x27>
          ++count;
42007d00:	dd1b      	addi.n	a13, a13, 1
        while (*str++ != 0)
42007d02:	098d      	mov.n	a8, a9
42007d04:	000186        	j	42007d0e <_ZN3etl13ibasic_stringIcE6insertEjPKc+0x1e>
42007d07:	00          	.byte	00
42007d08:	208440        	or	a8, a4, a4
      size_t count = 0UL;
42007d0b:	00a0d2        	movi	a13, 0
        while (*str++ != 0)
42007d0e:	01c892        	addi	a9, a8, 1
42007d11:	000882        	l8ui	a8, a8, 0
42007d14:	fe8856        	bnez	a8, 42007d00 <_ZN3etl13ibasic_stringIcE6insertEjPKc+0x10>
42007d17:	dcda      	add.n	a13, a12, a13
42007d19:	02ad      	mov.n	a10, a2
42007d1b:	fff225        	call8	42007c3c <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_>
    }
42007d1e:	f01d      	retw.n

42007d20 <_ZN3etl13ibasic_stringIcE6insertEjRKS1_>:
    etl::ibasic_string<T>& insert(size_type position, const etl::ibasic_string<T>& str)
42007d20:	004136        	entry	a1, 32
      return &p_buffer[0];
42007d23:	0322b2        	l32i	a11, a2, 12
      return &p_buffer[0];
42007d26:	0324c2        	l32i	a12, a4, 12
      return &p_buffer[current_size];
42007d29:	0024d2        	l32i	a13, a4, 0
      insert(begin() + position, str.cbegin(), str.cend());
42007d2c:	dcda      	add.n	a13, a12, a13
42007d2e:	bb3a      	add.n	a11, a11, a3
42007d30:	02ad      	mov.n	a10, a2
42007d32:	fff0a5        	call8	42007c3c <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_>
      return (data & pattern) != value_type(0);
42007d35:	080482        	l8ui	a8, a4, 8
      if (str.is_truncated())
42007d38:	0a6807        	bbci	a8, 0, 42007d46 <_ZN3etl13ibasic_stringIcE6insertEjRKS1_+0x26>
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);
42007d3b:	080282        	l8ui	a8, a2, 8
42007d3e:	190c      	movi.n	a9, 1
42007d40:	208890        	or	a8, a8, a9
42007d43:	084282        	s8i	a8, a2, 8
    }
42007d46:	f01d      	retw.n

42007d48 <_ZN3etl13ibasic_stringIcE6insertEPKcc>:
    iterator insert(const_iterator position, T value)
42007d48:	004136        	entry	a1, 32
42007d4b:	027d      	mov.n	a7, a2
42007d4d:	032d      	mov.n	a2, a3
42007d4f:	744040        	extui	a4, a4, 0, 8
      if (current_size < CAPACITY)
42007d52:	0788      	l32i.n	a8, a7, 0
42007d54:	1798      	l32i.n	a9, a7, 4
42007d56:	27b897        	bgeu	a8, a9, 42007d81 <_ZN3etl13ibasic_stringIcE6insertEPKcc+0x39>
      return &p_buffer[current_size];
42007d59:	37c8      	l32i.n	a12, a7, 12
42007d5b:	bc8a      	add.n	a11, a12, a8
        if (position != end())
42007d5d:	1313b7        	beq	a3, a11, 42007d74 <_ZN3etl13ibasic_stringIcE6insertEPKcc+0x2c>
          ++current_size;
42007d60:	881b      	addi.n	a8, a8, 1
42007d62:	0789      	s32i.n	a8, a7, 0
42007d64:	cc8a      	add.n	a12, a12, a8
42007d66:	20a330        	or	a10, a3, a3
42007d69:	ffe065        	call8	42007b70 <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_>
          *insert_position = value;
42007d6c:	004342        	s8i	a4, a3, 0
42007d6f:	000b06        	j	42007d9f <_ZN3etl13ibasic_stringIcE6insertEPKcc+0x57>
42007d72:	00          	.byte	00
42007d73:	00          	.byte	00
          *insert_position = value;
42007d74:	004342        	s8i	a4, a3, 0
          ++current_size;
42007d77:	0788      	l32i.n	a8, a7, 0
42007d79:	881b      	addi.n	a8, a8, 1
42007d7b:	0789      	s32i.n	a8, a7, 0
42007d7d:	000786        	j	42007d9f <_ZN3etl13ibasic_stringIcE6insertEPKcc+0x57>
42007d80:	00          	.byte	00
      return &p_buffer[current_size];
42007d81:	37b8      	l32i.n	a11, a7, 12
42007d83:	cb8a      	add.n	a12, a11, a8
        if (position != end())
42007d85:	0b13c7        	beq	a3, a12, 42007d94 <_ZN3etl13ibasic_stringIcE6insertEPKcc+0x4c>
          etl::copy_backward(insert_position, end() - 1, end());
42007d88:	880b      	addi.n	a8, a8, -1
42007d8a:	bb8a      	add.n	a11, a11, a8
42007d8c:	03ad      	mov.n	a10, a3
42007d8e:	ffde25        	call8	42007b70 <_ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIccEEPT0_PT_S6_S4_>
          *insert_position = value;
42007d91:	004342        	s8i	a4, a3, 0
42007d94:	080782        	l8ui	a8, a7, 8
42007d97:	190c      	movi.n	a9, 1
42007d99:	208890        	or	a8, a8, a9
42007d9c:	084782        	s8i	a8, a7, 8
      p_buffer[current_size] = 0;
42007d9f:	3788      	l32i.n	a8, a7, 12
42007da1:	0798      	l32i.n	a9, a7, 0
42007da3:	889a      	add.n	a8, a8, a9
42007da5:	090c      	movi.n	a9, 0
42007da7:	004892        	s8i	a9, a8, 0
    }
42007daa:	f01d      	retw.n

42007dac <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIccEEPT0_PT_S6_S4_>:
	__copy_m(_Tp* __first, _Tp* __last, _Up* __result)
42007dac:	004136        	entry	a1, 32
42007daf:	02bd      	mov.n	a11, a2
	  const ptrdiff_t _Num = __last - __first;
42007db1:	c03320        	sub	a3, a3, a2
	  if (__builtin_expect(_Num > 1, true))
42007db4:	180c      	movi.n	a8, 1
42007db6:	0da837        	bge	a8, a3, 42007dc7 <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIccEEPT0_PT_S6_S4_+0x1b>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
42007db9:	03cd      	mov.n	a12, a3
42007dbb:	20a440        	or	a10, a4, a4
42007dbe:	e2ca81        	l32r	a8, 420008e8 <_stext+0x8c8> (40001200 <memmove>)
42007dc1:	0008e0        	callx8	a8
42007dc4:	000206        	j	42007dd0 <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIccEEPT0_PT_S6_S4_+0x24>
	  else if (_Num == 1)
42007dc7:	051366        	bnei	a3, 1, 42007dd0 <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIccEEPT0_PT_S6_S4_+0x24>
	{ *__to = *__from; }
42007dca:	000282        	l8ui	a8, a2, 0
42007dcd:	004482        	s8i	a8, a4, 0
	}
42007dd0:	243a      	add.n	a2, a4, a3
42007dd2:	f01d      	retw.n

42007dd4 <_ZN3etl13ibasic_stringIcE5eraseEPKcS3_>:
    iterator erase(const_iterator first, const_iterator last)
42007dd4:	004136        	entry	a1, 32
42007dd7:	027d      	mov.n	a7, a2
42007dd9:	032d      	mov.n	a2, a3
      if (first_ == last_)
42007ddb:	251347        	beq	a3, a4, 42007e04 <_ZN3etl13ibasic_stringIcE5eraseEPKcS3_+0x30>
      return &p_buffer[current_size];
42007dde:	37b8      	l32i.n	a11, a7, 12
42007de0:	0788      	l32i.n	a8, a7, 0
			      _Category>::__copy_m(__first, __last, __result);
42007de2:	03cd      	mov.n	a12, a3
42007de4:	bb8a      	add.n	a11, a11, a8
42007de6:	04ad      	mov.n	a10, a4
42007de8:	fffc25        	call8	42007dac <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIccEEPT0_PT_S6_S4_>
42007deb:	c04430        	sub	a4, a4, a3
      current_size -= n_delete;
42007dee:	0788      	l32i.n	a8, a7, 0
42007df0:	c08840        	sub	a8, a8, a4
42007df3:	0789      	s32i.n	a8, a7, 0
      p_buffer[current_size] = 0;
42007df5:	3798      	l32i.n	a9, a7, 12
42007df7:	898a      	add.n	a8, a9, a8
42007df9:	090c      	movi.n	a9, 0
42007dfb:	004892        	s8i	a9, a8, 0
      cleanup();
42007dfe:	20a770        	or	a10, a7, a7
42007e01:	ff9d65        	call8	420077d8 <_ZN3etl13ibasic_stringIcE7cleanupEv>
    }
42007e04:	f01d      	retw.n
	...

42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>:
    etl::ibasic_string<T>& erase(size_type position, size_type length_ = npos)
42007e08:	004136        	entry	a1, 32
      return current_size;
42007e0b:	002282        	l32i	a8, a2, 0
      length_ = etl::min(length_, size() - position);
42007e0e:	c08830        	sub	a8, a8, a3
    return (compare(a, b)) ? a : b;
42007e11:	023487        	bltu	a4, a8, 42007e17 <_ZN3etl13ibasic_stringIcE5eraseEjj+0xf>
42007e14:	204880        	or	a4, a8, a8
      return &p_buffer[0];
42007e17:	0322b2        	l32i	a11, a2, 12
      erase(begin() + position, begin() + position + length_);
42007e1a:	443a      	add.n	a4, a4, a3
42007e1c:	cb4a      	add.n	a12, a11, a4
42007e1e:	bb3a      	add.n	a11, a11, a3
42007e20:	02ad      	mov.n	a10, a2
42007e22:	fffb25        	call8	42007dd4 <_ZN3etl13ibasic_stringIcE5eraseEPKcS3_>
    }
42007e25:	f01d      	retw.n
	...

42007e28 <_ZN3etl13ibasic_stringIcE7replaceEjjPKc>:
    ibasic_string& replace(size_type position, size_type length_, const_pointer s)
42007e28:	004136        	entry	a1, 32
42007e2b:	04cd      	mov.n	a12, a4
      return current_size;
42007e2d:	0288      	l32i.n	a8, a2, 0
      length_ = etl::min(length_, size() - position);
42007e2f:	c08830        	sub	a8, a8, a3
42007e32:	013487        	bltu	a4, a8, 42007e37 <_ZN3etl13ibasic_stringIcE7replaceEjjPKc+0xf>
42007e35:	08cd      	mov.n	a12, a8
      erase(position, length_);
42007e37:	03bd      	mov.n	a11, a3
42007e39:	02ad      	mov.n	a10, a2
42007e3b:	fffce5        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
      if (str != 0)
42007e3e:	a5cc      	bnez.n	a5, 42007e4c <_ZN3etl13ibasic_stringIcE7replaceEjjPKc+0x24>
      size_t count = 0UL;
42007e40:	0d0c      	movi.n	a13, 0
42007e42:	000546        	j	42007e5b <_ZN3etl13ibasic_stringIcE7replaceEjjPKc+0x33>
          ++count;
42007e45:	dd1b      	addi.n	a13, a13, 1
        while (*str++ != 0)
42007e47:	098d      	mov.n	a8, a9
42007e49:	000146        	j	42007e52 <_ZN3etl13ibasic_stringIcE7replaceEjjPKc+0x2a>
42007e4c:	208550        	or	a8, a5, a5
      size_t count = 0UL;
42007e4f:	00a0d2        	movi	a13, 0
        while (*str++ != 0)
42007e52:	01c892        	addi	a9, a8, 1
42007e55:	000882        	l8ui	a8, a8, 0
42007e58:	fe9856        	bnez	a8, 42007e45 <_ZN3etl13ibasic_stringIcE7replaceEjjPKc+0x1d>
      return &p_buffer[0];
42007e5b:	32b8      	l32i.n	a11, a2, 12
      insert(begin() + position, s, s + n);
42007e5d:	d5da      	add.n	a13, a5, a13
42007e5f:	05cd      	mov.n	a12, a5
42007e61:	bb3a      	add.n	a11, a11, a3
42007e63:	02ad      	mov.n	a10, a2
42007e65:	ffdd65        	call8	42007c3c <_ZN3etl13ibasic_stringIcE6insertIPKcEEPcS4_T_S6_>
    }
42007e68:	f01d      	retw.n
	...

42007e6c <_ZN3etl13ibasic_stringIcE7replaceEjjRKS1_>:
    ibasic_string& replace(size_type position, size_type length_, const ibasic_string& str)
42007e6c:	004136        	entry	a1, 32
42007e6f:	20c440        	or	a12, a4, a4
      return current_size;
42007e72:	002282        	l32i	a8, a2, 0
      length_ = etl::min(length_, size() - position);
42007e75:	c08830        	sub	a8, a8, a3
42007e78:	023487        	bltu	a4, a8, 42007e7e <_ZN3etl13ibasic_stringIcE7replaceEjjRKS1_+0x12>
42007e7b:	20c880        	or	a12, a8, a8
      erase(position, length_);
42007e7e:	03bd      	mov.n	a11, a3
42007e80:	02ad      	mov.n	a10, a2
42007e82:	fff865        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
      insert(position, str);
42007e85:	05cd      	mov.n	a12, a5
42007e87:	03bd      	mov.n	a11, a3
42007e89:	02ad      	mov.n	a10, a2
42007e8b:	ffe965        	call8	42007d20 <_ZN3etl13ibasic_stringIcE6insertEjRKS1_>
    }
42007e8e:	f01d      	retw.n

42007e90 <_ZN3etl13ibasic_stringIcE5eraseEPc>:
    iterator erase(iterator i_element)
42007e90:	004136        	entry	a1, 32
42007e93:	027d      	mov.n	a7, a2
42007e95:	032d      	mov.n	a2, a3
      return &p_buffer[current_size];
42007e97:	37b8      	l32i.n	a11, a7, 12
42007e99:	0788      	l32i.n	a8, a7, 0
42007e9b:	03cd      	mov.n	a12, a3
42007e9d:	bb8a      	add.n	a11, a11, a8
42007e9f:	a31b      	addi.n	a10, a3, 1
42007ea1:	fff0a5        	call8	42007dac <_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIccEEPT0_PT_S6_S4_>
      p_buffer[--current_size] = 0;
42007ea4:	3798      	l32i.n	a9, a7, 12
42007ea6:	0788      	l32i.n	a8, a7, 0
42007ea8:	880b      	addi.n	a8, a8, -1
42007eaa:	0789      	s32i.n	a8, a7, 0
42007eac:	898a      	add.n	a8, a9, a8
42007eae:	090c      	movi.n	a9, 0
42007eb0:	004892        	s8i	a9, a8, 0
    }
42007eb3:	f01d      	retw.n
42007eb5:	000000        	ill

42007eb8 <_Z16string_benchmarkm>:
{
42007eb8:	10e136        	entry	a1, 0x870
      : current_size(0)
42007ebb:	06d182        	addmi	a8, a1, 0x600
42007ebe:	00a062        	movi	a6, 0
42007ec1:	096862        	s32i	a6, a8, 36
      , CAPACITY(max_size_)
42007ec4:	00a192        	movi	a9, 0x100
42007ec7:	a899      	s32i.n	a9, a8, 40
      : data(value_type(0))
42007ec9:	2c4862        	s8i	a6, a8, 44
        p_buffer(p_buffer_)
42007ecc:	24a672        	movi	a7, 0x624
42007ecf:	717a      	add.n	a7, a1, a7
42007ed1:	10c792        	addi	a9, a7, 16
42007ed4:	c899      	s32i.n	a9, a8, 48
      this->initialise();
42007ed6:	07ad      	mov.n	a10, a7
42007ed8:	ff91a5        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
  class string : public istring
42007edb:	07ad      	mov.n	a10, a7
42007edd:	ff9365        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    RSR(CCOUNT, ccount);
42007ee0:	03ea50        	rsr.ccount	a5
    CYCLE_GET_COUNT(
42007ee3:	000986        	j	42007f0d <_Z16string_benchmarkm+0x55>
42007ee6:	820000        	mull	a0, a0, a0
      : current_size(0)
42007ee9:	0c06d1        	l32r	a13, 41fcaf04 <_coredump_iram_end+0x1c49004>
42007eec:	9909      	s32i.n	a0, a9, 36
42007eee:	a298      	l32i.n	a9, a2, 40
      , CAPACITY(max_size_)
42007ef0:	a900a1        	l32r	a10, 41ff22f0 <_coredump_iram_end+0x1c703f0>
42007ef3:	92a8      	l32i.n	a10, a2, 36
42007ef5:	2c48      	l32i.n	a4, a12, 8
        p_buffer(p_buffer_)
42007ef7:	24a672        	movi	a7, 0x624
42007efa:	717a      	add.n	a7, a1, a7
42007efc:	10c792        	addi	a9, a7, 16
42007eff:	c899      	s32i.n	a9, a8, 48
      this->initialise();
42007f01:	07ad      	mov.n	a10, a7
42007f03:	ff8f25        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
  class string : public istring
42007f06:	07ad      	mov.n	a10, a7
42007f08:	ff90a5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
42007f0b:	661b      	addi.n	a6, a6, 1
42007f0d:	e27781        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42007f10:	d4a867        	bge	a8, a6, 42007ee8 <_Z16string_benchmarkm+0x30>
42007f13:	03ea70        	rsr.ccount	a7
42007f16:	c07750        	sub	a7, a7, a5
42007f19:	e275c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42007f1c:	a2c7c0        	muluh	a12, a7, a12
42007f1f:	41ccc0        	srli	a12, a12, 12
42007f22:	e274b1        	l32r	a11, 420008f4 <_stext+0x8d4> (3c025020 <_flash_rodata_start+0x4f00>)
42007f25:	e274a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42007f28:	02f525        	call8	4200ae7c <printf>
    CYCLE_GET_COUNT(
42007f2b:	e26681        	l32r	a8, 420008c4 <_stext+0x8a4> (3fc921ac <c_str_large>)
42007f2e:	08b8      	l32i.n	a11, a8, 0
42007f30:	38a7a2        	movi	a10, 0x738
42007f33:	a1aa      	add.n	a10, a1, a10
42007f35:	ff9c65        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
42007f38:	03ea50        	rsr.ccount	a5
42007f3b:	060c      	movi.n	a6, 0
42007f3d:	000546        	j	42007f56 <_Z16string_benchmarkm+0x9e>
42007f40:	24a672        	movi	a7, 0x624
42007f43:	717a      	add.n	a7, a1, a7
42007f45:	e25f81        	l32r	a8, 420008c4 <_stext+0x8a4> (3fc921ac <c_str_large>)
42007f48:	08b8      	l32i.n	a11, a8, 0
42007f4a:	07ad      	mov.n	a10, a7
42007f4c:	ff9ae5        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
42007f4f:	07ad      	mov.n	a10, a7
42007f51:	ff8c25        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
42007f54:	661b      	addi.n	a6, a6, 1
42007f56:	e26581        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42007f59:	e3a867        	bge	a8, a6, 42007f40 <_Z16string_benchmarkm+0x88>
42007f5c:	03ea70        	rsr.ccount	a7
42007f5f:	c07750        	sub	a7, a7, a5
42007f62:	e263c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42007f65:	a2c7c0        	muluh	a12, a7, a12
42007f68:	41ccc0        	srli	a12, a12, 12
42007f6b:	e264b1        	l32r	a11, 420008fc <_stext+0x8dc> (3c025054 <_flash_rodata_start+0x4f34>)
42007f6e:	e262a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42007f71:	02f0a5        	call8	4200ae7c <printf>
42007f74:	38a772        	movi	a7, 0x738
42007f77:	717a      	add.n	a7, a1, a7
42007f79:	20a770        	or	a10, a7, a7
42007f7c:	ff8965        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    size_t c_str_large_len = strnlen(c_str_large, MAX_STRLN); 
42007f7f:	e25181        	l32r	a8, 420008c4 <_stext+0x8a4> (3fc921ac <c_str_large>)
42007f82:	002862        	l32i	a6, a8, 0
42007f85:	00a1b2        	movi	a11, 0x100
42007f88:	20a660        	or	a10, a6, a6
42007f8b:	e28c81        	l32r	a8, 420009bc <_stext+0x99c> (400013f8 <strnlen>)
42007f8e:	0008e0        	callx8	a8
42007f91:	0a5d      	mov.n	a5, a10
    CYCLE_GET_COUNT(
42007f93:	0acd      	mov.n	a12, a10
42007f95:	06bd      	mov.n	a11, a6
42007f97:	07ad      	mov.n	a10, a7
42007f99:	ff91a5        	call8	420078b4 <_ZN3etl6stringILj256EEC1EPKcj>
42007f9c:	03ea40        	rsr.ccount	a4
42007f9f:	060c      	movi.n	a6, 0
42007fa1:	0005c6        	j	42007fbc <_Z16string_benchmarkm+0x104>
42007fa4:	24a672        	movi	a7, 0x624
42007fa7:	717a      	add.n	a7, a1, a7
42007fa9:	05cd      	mov.n	a12, a5
42007fab:	e24681        	l32r	a8, 420008c4 <_stext+0x8a4> (3fc921ac <c_str_large>)
42007fae:	08b8      	l32i.n	a11, a8, 0
42007fb0:	07ad      	mov.n	a10, a7
42007fb2:	ff9025        	call8	420078b4 <_ZN3etl6stringILj256EEC1EPKcj>
42007fb5:	07ad      	mov.n	a10, a7
42007fb7:	ff85e5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
42007fba:	661b      	addi.n	a6, a6, 1
42007fbc:	e24c81        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42007fbf:	e1a867        	bge	a8, a6, 42007fa4 <_Z16string_benchmarkm+0xec>
42007fc2:	03ea70        	rsr.ccount	a7
42007fc5:	c07740        	sub	a7, a7, a4
42007fc8:	e24ac1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42007fcb:	a2c7c0        	muluh	a12, a7, a12
42007fce:	41ccc0        	srli	a12, a12, 12
42007fd1:	e24bb1        	l32r	a11, 42000900 <_stext+0x8e0> (3c025074 <_flash_rodata_start+0x4f54>)
42007fd4:	e249a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42007fd7:	02ea65        	call8	4200ae7c <printf>
42007fda:	38a772        	movi	a7, 0x738
42007fdd:	717a      	add.n	a7, a1, a7
42007fdf:	07ad      	mov.n	a10, a7
42007fe1:	ff8325        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    CYCLE_GET_COUNT(
42007fe4:	61a0c2        	movi	a12, 97
42007fe7:	00a1b2        	movi	a11, 0x100
42007fea:	20a770        	or	a10, a7, a7
42007fed:	ffb565        	call8	42007b44 <_ZN3etl6stringILj256EEC1Ejc>
42007ff0:	03ea50        	rsr.ccount	a5
42007ff3:	060c      	movi.n	a6, 0
42007ff5:	0005c6        	j	42008010 <_Z16string_benchmarkm+0x158>
42007ff8:	a67200        	lsi	f0, a2, 0x298
42007ffb:	717a24        	lsi	f2, a10, 0x1c4
42007ffe:	61a0c2        	movi	a12, 97
42008001:	00a1b2        	movi	a11, 0x100
42008004:	07ad      	mov.n	a10, a7
42008006:	ffb3e5        	call8	42007b44 <_ZN3etl6stringILj256EEC1Ejc>
42008009:	07ad      	mov.n	a10, a7
4200800b:	ff80a5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
4200800e:	661b      	addi.n	a6, a6, 1
42008010:	e23781        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008013:	e2a867        	bge	a8, a6, 42007ff9 <_Z16string_benchmarkm+0x141>
42008016:	03ea70        	rsr.ccount	a7
42008019:	c07750        	sub	a7, a7, a5
4200801c:	e235c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200801f:	a2c7c0        	muluh	a12, a7, a12
42008022:	41ccc0        	srli	a12, a12, 12
42008025:	e237b1        	l32r	a11, 42000904 <_stext+0x8e4> (3c025098 <_flash_rodata_start+0x4f78>)
42008028:	e234a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200802b:	02e525        	call8	4200ae7c <printf>
4200802e:	38a772        	movi	a7, 0x738
42008031:	717a      	add.n	a7, a1, a7
42008033:	07ad      	mov.n	a10, a7
42008035:	ff7de5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    CYCLE_GET_COUNT(
42008038:	e225b1        	l32r	a11, 420008cc <_stext+0x8ac> (3fc95b68 <_str_vu>)
4200803b:	07ad      	mov.n	a10, a7
4200803d:	ff89a5        	call8	420078d8 <_ZN3etl6stringILj256EEC1ERKNS_17basic_string_viewIcNS_11char_traitsIcEEEE>
42008040:	03ea50        	rsr.ccount	a5
42008043:	060c      	movi.n	a6, 0
42008045:	000506        	j	4200805d <_Z16string_benchmarkm+0x1a5>
42008048:	a67200        	lsi	f0, a2, 0x298
4200804b:	717a24        	lsi	f2, a10, 0x1c4
4200804e:	e21fb1        	l32r	a11, 420008cc <_stext+0x8ac> (3fc95b68 <_str_vu>)
42008051:	07ad      	mov.n	a10, a7
42008053:	ff8865        	call8	420078d8 <_ZN3etl6stringILj256EEC1ERKNS_17basic_string_viewIcNS_11char_traitsIcEEEE>
42008056:	07ad      	mov.n	a10, a7
42008058:	ff7ba5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
4200805b:	661b      	addi.n	a6, a6, 1
4200805d:	e22381        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008060:	e5a867        	bge	a8, a6, 42008049 <_Z16string_benchmarkm+0x191>
42008063:	03ea70        	rsr.ccount	a7
42008066:	c07750        	sub	a7, a7, a5
42008069:	e221c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200806c:	a2c7c0        	muluh	a12, a7, a12
4200806f:	41ccc0        	srli	a12, a12, 12
42008072:	e225b1        	l32r	a11, 42000908 <_stext+0x8e8> (3c0250bc <_flash_rodata_start+0x4f9c>)
42008075:	e220a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008078:	02e025        	call8	4200ae7c <printf>
4200807b:	38a772        	movi	a7, 0x738
4200807e:	717a      	add.n	a7, a1, a7
42008080:	07ad      	mov.n	a10, a7
42008082:	ff7925        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    CYCLE_GET_COUNT(
42008085:	e20981        	l32r	a8, 420008ac <_stext+0x88c> (3fc921b4 <c_str_tiny>)
42008088:	08b8      	l32i.n	a11, a8, 0
4200808a:	20a770        	or	a10, a7, a7
4200808d:	ff86e5        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
42008090:	03ea50        	rsr.ccount	a5
42008093:	060c      	movi.n	a6, 0
42008095:	000546        	j	420080ae <_Z16string_benchmarkm+0x1f6>
42008098:	24a672        	movi	a7, 0x624
4200809b:	717a      	add.n	a7, a1, a7
4200809d:	e20381        	l32r	a8, 420008ac <_stext+0x88c> (3fc921b4 <c_str_tiny>)
420080a0:	08b8      	l32i.n	a11, a8, 0
420080a2:	07ad      	mov.n	a10, a7
420080a4:	ff8565        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
420080a7:	07ad      	mov.n	a10, a7
420080a9:	ff76a5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
420080ac:	661b      	addi.n	a6, a6, 1
420080ae:	e20f81        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420080b1:	e3a867        	bge	a8, a6, 42008098 <_Z16string_benchmarkm+0x1e0>
420080b4:	03ea70        	rsr.ccount	a7
420080b7:	c07750        	sub	a7, a7, a5
420080ba:	e20dc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420080bd:	a2c7c0        	muluh	a12, a7, a12
420080c0:	41ccc0        	srli	a12, a12, 12
420080c3:	e212b1        	l32r	a11, 4200090c <_stext+0x8ec> (3c0250dc <_flash_rodata_start+0x4fbc>)
420080c6:	e20ca1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420080c9:	02db25        	call8	4200ae7c <printf>
420080cc:	38a772        	movi	a7, 0x738
420080cf:	717a      	add.n	a7, a1, a7
420080d1:	20a770        	or	a10, a7, a7
420080d4:	ff73e5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    CYCLE_GET_COUNT(
420080d7:	e1f981        	l32r	a8, 420008bc <_stext+0x89c> (3fc921b0 <c_str_medium>)
420080da:	08b8      	l32i.n	a11, a8, 0
420080dc:	07ad      	mov.n	a10, a7
420080de:	ff81e5        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
420080e1:	03ea50        	rsr.ccount	a5
420080e4:	060c      	movi.n	a6, 0
420080e6:	000586        	j	42008100 <_Z16string_benchmarkm+0x248>
420080e9:	24a672        	movi	a7, 0x624
420080ec:	717a      	add.n	a7, a1, a7
420080ee:	e1f381        	l32r	a8, 420008bc <_stext+0x89c> (3fc921b0 <c_str_medium>)
420080f1:	08b8      	l32i.n	a11, a8, 0
420080f3:	20a770        	or	a10, a7, a7
420080f6:	ff8065        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
420080f9:	07ad      	mov.n	a10, a7
420080fb:	ff71a5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
420080fe:	661b      	addi.n	a6, a6, 1
42008100:	e1fb81        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008103:	e2a867        	bge	a8, a6, 420080e9 <_Z16string_benchmarkm+0x231>
42008106:	03ea70        	rsr.ccount	a7
42008109:	c07750        	sub	a7, a7, a5
4200810c:	e1f9c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200810f:	a2c7c0        	muluh	a12, a7, a12
42008112:	41ccc0        	srli	a12, a12, 12
42008115:	e1feb1        	l32r	a11, 42000910 <_stext+0x8f0> (3c0250f0 <_flash_rodata_start+0x4fd0>)
42008118:	e1f8a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200811b:	02d625        	call8	4200ae7c <printf>
4200811e:	38a772        	movi	a7, 0x738
42008121:	717a      	add.n	a7, a1, a7
42008123:	07ad      	mov.n	a10, a7
42008125:	ff6ee5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    CYCLE_GET_COUNT(
42008128:	e1e781        	l32r	a8, 420008c4 <_stext+0x8a4> (3fc921ac <c_str_large>)
4200812b:	0028b2        	l32i	a11, a8, 0
4200812e:	20a770        	or	a10, a7, a7
42008131:	ff7ca5        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
42008134:	03ea50        	rsr.ccount	a5
42008137:	060c      	movi.n	a6, 0
42008139:	000546        	j	42008152 <_Z16string_benchmarkm+0x29a>
4200813c:	24a672        	movi	a7, 0x624
4200813f:	717a      	add.n	a7, a1, a7
42008141:	e1e081        	l32r	a8, 420008c4 <_stext+0x8a4> (3fc921ac <c_str_large>)
42008144:	08b8      	l32i.n	a11, a8, 0
42008146:	07ad      	mov.n	a10, a7
42008148:	ff7b25        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
4200814b:	07ad      	mov.n	a10, a7
4200814d:	ff6c65        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
42008150:	661b      	addi.n	a6, a6, 1
42008152:	e1e681        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008155:	e3a867        	bge	a8, a6, 4200813c <_Z16string_benchmarkm+0x284>
42008158:	03ea70        	rsr.ccount	a7
4200815b:	c07750        	sub	a7, a7, a5
4200815e:	e1e4c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008161:	a2c7c0        	muluh	a12, a7, a12
42008164:	41ccc0        	srli	a12, a12, 12
42008167:	e1ebb1        	l32r	a11, 42000914 <_stext+0x8f4> (3c025108 <_flash_rodata_start+0x4fe8>)
4200816a:	e1e3a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200816d:	02d0e5        	call8	4200ae7c <printf>
42008170:	38a772        	movi	a7, 0x738
42008173:	717a      	add.n	a7, a1, a7
42008175:	20a770        	or	a10, a7, a7
42008178:	ff69a5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
    CYCLE_GET_COUNT(
4200817b:	e1d581        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc921a8 <c_str_jumbo>)
4200817e:	08b8      	l32i.n	a11, a8, 0
42008180:	07ad      	mov.n	a10, a7
42008182:	ff77a5        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
42008185:	03ea50        	rsr.ccount	a5
42008188:	060c      	movi.n	a6, 0
4200818a:	000606        	j	420081a6 <_Z16string_benchmarkm+0x2ee>
4200818d:	24a672        	movi	a7, 0x624
42008190:	807170        	add	a7, a1, a7
42008193:	e1cf81        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc921a8 <c_str_jumbo>)
42008196:	0028b2        	l32i	a11, a8, 0
42008199:	20a770        	or	a10, a7, a7
4200819c:	ff75e5        	call8	420078fc <_ZN3etl6stringILj256EEC1EPKc>
4200819f:	07ad      	mov.n	a10, a7
420081a1:	ff6725        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
420081a4:	661b      	addi.n	a6, a6, 1
420081a6:	e1d181        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420081a9:	e0a867        	bge	a8, a6, 4200818d <_Z16string_benchmarkm+0x2d5>
420081ac:	03ea70        	rsr.ccount	a7
420081af:	c07750        	sub	a7, a7, a5
420081b2:	e1cfc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420081b5:	a2c7c0        	muluh	a12, a7, a12
420081b8:	41ccc0        	srli	a12, a12, 12
420081bb:	e1d7b1        	l32r	a11, 42000918 <_stext+0x8f8> (3c02511c <_flash_rodata_start+0x4ffc>)
420081be:	e1cea1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420081c1:	02cba5        	call8	4200ae7c <printf>
420081c4:	38a7a2        	movi	a10, 0x738
420081c7:	a1aa      	add.n	a10, a1, a10
420081c9:	ff64a5        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
420081cc:	03eaa0        	rsr.ccount	a10
     CYCLE_GET_COUNT_RETURN(
420081cf:	080c      	movi.n	a8, 0
420081d1:	000086        	j	420081d7 <_Z16string_benchmarkm+0x31f>
420081d4:	881b00        	lsi	f0, a11, 0x220
420081d7:	e1c591        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420081da:	f7a987        	bge	a9, a8, 420081d5 <_Z16string_benchmarkm+0x31d>
420081dd:	03ea70        	rsr.ccount	a7
420081e0:	c077a0        	sub	a7, a7, a10
420081e3:	e1c3c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420081e6:	a2c7c0        	muluh	a12, a7, a12
420081e9:	41ccc0        	srli	a12, a12, 12
420081ec:	e1ccb1        	l32r	a11, 4200091c <_stext+0x8fc> (3c025130 <_flash_rodata_start+0x5010>)
420081ef:	e1c2a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420081f2:	02c8a5        	call8	4200ae7c <printf>
420081f5:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420081f8:	080c      	movi.n	a8, 0
420081fa:	000046        	j	420081ff <_Z16string_benchmarkm+0x347>
420081fd:	881b      	addi.n	a8, a8, 1
420081ff:	e1bb91        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008202:	f7a987        	bge	a9, a8, 420081fd <_Z16string_benchmarkm+0x345>
42008205:	03ea70        	rsr.ccount	a7
42008208:	c077a0        	sub	a7, a7, a10
4200820b:	e1b9c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200820e:	a2c7c0        	muluh	a12, a7, a12
42008211:	41ccc0        	srli	a12, a12, 12
42008214:	e1c3b1        	l32r	a11, 42000920 <_stext+0x900> (3c025148 <_flash_rodata_start+0x5028>)
42008217:	e1b8a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200821a:	02c625        	call8	4200ae7c <printf>
4200821d:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008220:	080c      	movi.n	a8, 0
42008222:	000046        	j	42008227 <_Z16string_benchmarkm+0x36f>
42008225:	881b      	addi.n	a8, a8, 1
42008227:	e1b191        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200822a:	f7a987        	bge	a9, a8, 42008225 <_Z16string_benchmarkm+0x36d>
4200822d:	03ea70        	rsr.ccount	a7
42008230:	c077a0        	sub	a7, a7, a10
42008233:	e1afc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008236:	a2c7c0        	muluh	a12, a7, a12
42008239:	41ccc0        	srli	a12, a12, 12
4200823c:	e1bab1        	l32r	a11, 42000924 <_stext+0x904> (3c025160 <_flash_rodata_start+0x5040>)
4200823f:	e1aea1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008242:	02c3a5        	call8	4200ae7c <printf>
42008245:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008248:	080c      	movi.n	a8, 0
4200824a:	000046        	j	4200824f <_Z16string_benchmarkm+0x397>
4200824d:	881b      	addi.n	a8, a8, 1
4200824f:	e1a791        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008252:	f7a987        	bge	a9, a8, 4200824d <_Z16string_benchmarkm+0x395>
42008255:	03ea70        	rsr.ccount	a7
42008258:	c077a0        	sub	a7, a7, a10
4200825b:	e1a5c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200825e:	a2c7c0        	muluh	a12, a7, a12
42008261:	41ccc0        	srli	a12, a12, 12
42008264:	e1b1b1        	l32r	a11, 42000928 <_stext+0x908> (3c025178 <_flash_rodata_start+0x5058>)
42008267:	e1a4a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200826a:	02c125        	call8	4200ae7c <printf>
4200826d:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008270:	080c      	movi.n	a8, 0
42008272:	000106        	j	4200827a <_Z16string_benchmarkm+0x3c2>
42008275:	000000        	ill
42008278:	881b      	addi.n	a8, a8, 1
4200827a:	e19c91        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200827d:	f7a987        	bge	a9, a8, 42008278 <_Z16string_benchmarkm+0x3c0>
42008280:	03ea70        	rsr.ccount	a7
42008283:	c077a0        	sub	a7, a7, a10
42008286:	e19ac1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008289:	a2c7c0        	muluh	a12, a7, a12
4200828c:	41ccc0        	srli	a12, a12, 12
4200828f:	e1a7b1        	l32r	a11, 4200092c <_stext+0x90c> (3c025190 <_flash_rodata_start+0x5070>)
42008292:	e199a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008295:	02be65        	call8	4200ae7c <printf>
42008298:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
4200829b:	080c      	movi.n	a8, 0
4200829d:	000086        	j	420082a3 <_Z16string_benchmarkm+0x3eb>
420082a0:	881b00        	lsi	f0, a11, 0x220
420082a3:	e19291        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420082a6:	f7a987        	bge	a9, a8, 420082a1 <_Z16string_benchmarkm+0x3e9>
420082a9:	03ea70        	rsr.ccount	a7
420082ac:	c077a0        	sub	a7, a7, a10
420082af:	e190c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420082b2:	a2c7c0        	muluh	a12, a7, a12
420082b5:	41ccc0        	srli	a12, a12, 12
420082b8:	e19eb1        	l32r	a11, 42000930 <_stext+0x910> (3c0251ac <_flash_rodata_start+0x508c>)
420082bb:	e18fa1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420082be:	02bbe5        	call8	4200ae7c <printf>
420082c1:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420082c4:	080c      	movi.n	a8, 0
420082c6:	000046        	j	420082cb <_Z16string_benchmarkm+0x413>
420082c9:	881b      	addi.n	a8, a8, 1
420082cb:	e18891        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420082ce:	f7a987        	bge	a9, a8, 420082c9 <_Z16string_benchmarkm+0x411>
420082d1:	03ea70        	rsr.ccount	a7
420082d4:	c077a0        	sub	a7, a7, a10
420082d7:	e186c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420082da:	a2c7c0        	muluh	a12, a7, a12
420082dd:	41ccc0        	srli	a12, a12, 12
420082e0:	e195b1        	l32r	a11, 42000934 <_stext+0x914> (3c0251c8 <_flash_rodata_start+0x50a8>)
420082e3:	e185a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420082e6:	02b965        	call8	4200ae7c <printf>
420082e9:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420082ec:	080c      	movi.n	a8, 0
420082ee:	000046        	j	420082f3 <_Z16string_benchmarkm+0x43b>
420082f1:	881b      	addi.n	a8, a8, 1
420082f3:	e17e91        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420082f6:	f7a987        	bge	a9, a8, 420082f1 <_Z16string_benchmarkm+0x439>
420082f9:	03ea70        	rsr.ccount	a7
420082fc:	c077a0        	sub	a7, a7, a10
420082ff:	e17cc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008302:	a2c7c0        	muluh	a12, a7, a12
42008305:	41ccc0        	srli	a12, a12, 12
42008308:	e18cb1        	l32r	a11, 42000938 <_stext+0x918> (3c0251e4 <_flash_rodata_start+0x50c4>)
4200830b:	e17ba1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200830e:	02b6e5        	call8	4200ae7c <printf>
42008311:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008314:	080c      	movi.n	a8, 0
42008316:	000086        	j	4200831c <_Z16string_benchmarkm+0x464>
42008319:	01c882        	addi	a8, a8, 1
4200831c:	e17491        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200831f:	f6a987        	bge	a9, a8, 42008319 <_Z16string_benchmarkm+0x461>
42008322:	03ea70        	rsr.ccount	a7
42008325:	c077a0        	sub	a7, a7, a10
42008328:	e172c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200832b:	a2c7c0        	muluh	a12, a7, a12
4200832e:	41ccc0        	srli	a12, a12, 12
42008331:	e182b1        	l32r	a11, 4200093c <_stext+0x91c> (3c025200 <_flash_rodata_start+0x50e0>)
42008334:	e171a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008337:	02b465        	call8	4200ae7c <printf>
      return &p_buffer[current_size];
4200833a:	e16381        	l32r	a8, 420008c8 <_stext+0x8a8> (3fc95b70 <_str_large>)
4200833d:	0328a2        	l32i	a10, a8, 12
42008340:	002882        	l32i	a8, a8, 0
42008343:	aa8a      	add.n	a10, a10, a8
       *  This %iterator will move in the opposite direction that @p x does.
      */
      explicit _GLIBCXX17_CONSTEXPR
      reverse_iterator(iterator_type __x)
      _GLIBCXX_NOEXCEPT_IF(noexcept(_Iterator(__x)))
      : current(__x)
42008345:	31a9      	s32i.n	a10, a1, 12
42008347:	03eab0        	rsr.ccount	a11
    CYCLE_GET_COUNT_RETURN(
4200834a:	080c      	movi.n	a8, 0
4200834c:	000186        	j	42008356 <_Z16string_benchmarkm+0x49e>
4200834f:	61a200        	lsi	f0, a2, 0x184
42008352:	c88202        	lsi	f0, a2, 0x320
42008355:	659101        	l32r	a0, 41fe199c <_coredump_iram_end+0x1c5fa9c>
42008358:	a987e1        	l32r	a14, 41ff2974 <_coredump_iram_end+0x1c70a74>
4200835b:	ea70f3        	lsi	f15, a0, 0x3a8
4200835e:	77b003        	lsi	f0, a0, 0x1dc
42008361:	63c1c0        	minu	a12, a1, a12
42008364:	c7c0e1        	l32r	a14, 41ffa264 <_coredump_iram_end+0x1c78364>
42008367:	ccc0a2        	addi	a10, a0, -52
4200836a:	75b141        	l32r	a4, 41fe5a30 <_coredump_iram_end+0x1c63b30>
4200836d:	62a1e1        	l32r	a14, 41fe0df4 <_coredump_iram_end+0x1c5eef4>
42008370:	b0a5e1        	l32r	a14, 41ff4604 <_coredump_iram_end+0x1c72704>
42008373:	558102        	lsi	f0, a1, 0x154
      return &p_buffer[0];
42008376:	28a2e1        	l32r	a14, 41fd2600 <_coredump_iram_end+0x1c50700>
42008379:	11a903        	lsi	f0, a9, 68
4200837c:	03eab0        	rsr.ccount	a11
    CYCLE_GET_COUNT_RETURN(
4200837f:	080c      	movi.n	a8, 0
42008381:	000146        	j	4200838a <_Z16string_benchmarkm+0x4d2>
42008384:	0061a2        	s32i	a10, a1, 0
42008387:	01c882        	addi	a8, a8, 1
4200838a:	e15891        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200838d:	f3a987        	bge	a9, a8, 42008384 <_Z16string_benchmarkm+0x4cc>
42008390:	03ea70        	rsr.ccount	a7
42008393:	c077b0        	sub	a7, a7, a11
42008396:	e156c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008399:	a2c7c0        	muluh	a12, a7, a12
4200839c:	41ccc0        	srli	a12, a12, 12
4200839f:	e169b1        	l32r	a11, 42000944 <_stext+0x924> (3c025238 <_flash_rodata_start+0x5118>)
420083a2:	e155a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420083a5:	02ad65        	call8	4200ae7c <printf>
420083a8:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420083ab:	00a082        	movi	a8, 0
420083ae:	000046        	j	420083b3 <_Z16string_benchmarkm+0x4fb>
420083b1:	881b      	addi.n	a8, a8, 1
420083b3:	e14e91        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420083b6:	f7a987        	bge	a9, a8, 420083b1 <_Z16string_benchmarkm+0x4f9>
420083b9:	03ea70        	rsr.ccount	a7
420083bc:	c077a0        	sub	a7, a7, a10
420083bf:	e14cc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420083c2:	a2c7c0        	muluh	a12, a7, a12
420083c5:	41ccc0        	srli	a12, a12, 12
420083c8:	e160b1        	l32r	a11, 42000948 <_stext+0x928> (3c025254 <_flash_rodata_start+0x5134>)
420083cb:	e14ba1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420083ce:	02aae5        	call8	4200ae7c <printf>
420083d1:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420083d4:	080c      	movi.n	a8, 0
420083d6:	000046        	j	420083db <_Z16string_benchmarkm+0x523>
420083d9:	881b      	addi.n	a8, a8, 1
420083db:	e14491        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420083de:	f7a987        	bge	a9, a8, 420083d9 <_Z16string_benchmarkm+0x521>
420083e1:	03ea70        	rsr.ccount	a7
420083e4:	c077a0        	sub	a7, a7, a10
420083e7:	e142c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420083ea:	a2c7c0        	muluh	a12, a7, a12
420083ed:	41ccc0        	srli	a12, a12, 12
420083f0:	e157b1        	l32r	a11, 4200094c <_stext+0x92c> (3c025270 <_flash_rodata_start+0x5150>)
420083f3:	e141a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420083f6:	02a865        	call8	4200ae7c <printf>
420083f9:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
420083fc:	080c      	movi.n	a8, 0
420083fe:	000046        	j	42008403 <_Z16string_benchmarkm+0x54b>
42008401:	881b      	addi.n	a8, a8, 1
42008403:	e13a91        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008406:	f7a987        	bge	a9, a8, 42008401 <_Z16string_benchmarkm+0x549>
42008409:	03ea70        	rsr.ccount	a7
4200840c:	c077a0        	sub	a7, a7, a10
4200840f:	e138c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008412:	a2c7c0        	muluh	a12, a7, a12
42008415:	41ccc0        	srli	a12, a12, 12
42008418:	e14eb1        	l32r	a11, 42000950 <_stext+0x930> (3c02528c <_flash_rodata_start+0x516c>)
4200841b:	e137a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200841e:	02a5e5        	call8	4200ae7c <printf>
42008421:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008424:	080c      	movi.n	a8, 0
42008426:	000046        	j	4200842b <_Z16string_benchmarkm+0x573>
42008429:	881b      	addi.n	a8, a8, 1
4200842b:	e13091        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200842e:	f7a987        	bge	a9, a8, 42008429 <_Z16string_benchmarkm+0x571>
42008431:	03ea70        	rsr.ccount	a7
42008434:	c077a0        	sub	a7, a7, a10
42008437:	e12ec1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200843a:	a2c7c0        	muluh	a12, a7, a12
4200843d:	41ccc0        	srli	a12, a12, 12
42008440:	e145b1        	l32r	a11, 42000954 <_stext+0x934> (3c0252ac <_flash_rodata_start+0x518c>)
42008443:	e12da1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008446:	02a365        	call8	4200ae7c <printf>
42008449:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
4200844c:	080c      	movi.n	a8, 0
4200844e:	000146        	j	42008457 <_Z16string_benchmarkm+0x59f>
42008451:	000000        	ill
42008454:	01c882        	addi	a8, a8, 1
42008457:	e12591        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200845a:	f6a987        	bge	a9, a8, 42008454 <_Z16string_benchmarkm+0x59c>
4200845d:	03ea70        	rsr.ccount	a7
42008460:	c077a0        	sub	a7, a7, a10
42008463:	e123c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008466:	a2c7c0        	muluh	a12, a7, a12
42008469:	41ccc0        	srli	a12, a12, 12
4200846c:	e13bb1        	l32r	a11, 42000958 <_stext+0x938> (3c0252cc <_flash_rodata_start+0x51ac>)
4200846f:	e122a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008472:	02a0a5        	call8	4200ae7c <printf>
      resize(new_size, 0);
42008475:	00a0c2        	movi	a12, 0
42008478:	00a1b2        	movi	a11, 0x100
4200847b:	e10da1        	l32r	a10, 420008b0 <_stext+0x890> (3fc95d98 <_str_tiny>)
4200847e:	ff6825        	call8	42007b00 <_ZN3etl13ibasic_stringIcE6resizeEjc>
42008481:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
42008484:	070c      	movi.n	a7, 0
42008486:	000386        	j	42008498 <_Z16string_benchmarkm+0x5e0>
42008489:	0c0c00        	lsi	f0, a12, 48
4200848c:	00a1b2        	movi	a11, 0x100
4200848f:	e108a1        	l32r	a10, 420008b0 <_stext+0x890> (3fc95d98 <_str_tiny>)
42008492:	ff66e5        	call8	42007b00 <_ZN3etl13ibasic_stringIcE6resizeEjc>
42008495:	01c772        	addi	a7, a7, 1
42008498:	e11581        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200849b:	eba877        	bge	a8, a7, 4200848a <_Z16string_benchmarkm+0x5d2>
4200849e:	03ea70        	rsr.ccount	a7
420084a1:	c07760        	sub	a7, a7, a6
420084a4:	e113c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420084a7:	a2c7c0        	muluh	a12, a7, a12
420084aa:	41ccc0        	srli	a12, a12, 12
420084ad:	e12bb1        	l32r	a11, 4200095c <_stext+0x93c> (3c0252e8 <_flash_rodata_start+0x51c8>)
420084b0:	e112a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420084b3:	029ca5        	call8	4200ae7c <printf>
420084b6:	e0fe71        	l32r	a7, 420008b0 <_stext+0x890> (3fc95d98 <_str_tiny>)
420084b9:	0c0c      	movi.n	a12, 0
420084bb:	2b0c      	movi.n	a11, 2
420084bd:	20a770        	or	a10, a7, a7
420084c0:	ff63e5        	call8	42007b00 <_ZN3etl13ibasic_stringIcE6resizeEjc>
    CYCLE_GET_COUNT(
420084c3:	0c0c      	movi.n	a12, 0
420084c5:	ab0c      	movi.n	a11, 10
420084c7:	07ad      	mov.n	a10, a7
420084c9:	ff5d65        	call8	42007aa0 <_ZN3etl13ibasic_stringIcE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE_EEvjT_>
420084cc:	03ea60        	rsr.ccount	a6
420084cf:	070c      	movi.n	a7, 0
420084d1:	0002c6        	j	420084e0 <_Z16string_benchmarkm+0x628>
420084d4:	0c0c      	movi.n	a12, 0
420084d6:	ab0c      	movi.n	a11, 10
420084d8:	e0f6a1        	l32r	a10, 420008b0 <_stext+0x890> (3fc95d98 <_str_tiny>)
420084db:	ff5ea5        	call8	42007ac4 <_ZN3etl13ibasic_stringIcE20resize_and_overwriteIZ16string_benchmarkmEUlPcjE0_EEvjT_>
420084de:	771b      	addi.n	a7, a7, 1
420084e0:	e10381        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420084e3:	eda877        	bge	a8, a7, 420084d4 <_Z16string_benchmarkm+0x61c>
420084e6:	03ea70        	rsr.ccount	a7
420084e9:	c07760        	sub	a7, a7, a6
420084ec:	e101c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420084ef:	a2c7c0        	muluh	a12, a7, a12
420084f2:	41ccc0        	srli	a12, a12, 12
420084f5:	e11ab1        	l32r	a11, 42000960 <_stext+0x940> (3c02530c <_flash_rodata_start+0x51ec>)
420084f8:	e100a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420084fb:	029825        	call8	4200ae7c <printf>
    //*************************************************************************
    /// Assignment operator.
    //*************************************************************************
    string& operator = (const value_type* text)
    {
      this->assign(text);
420084fe:	e0ec71        	l32r	a7, 420008b0 <_stext+0x890> (3fc95d98 <_str_tiny>)
42008501:	e118b1        	l32r	a11, 42000964 <_stext+0x944> (3c025344 <_flash_rodata_start+0x5224>)
42008504:	07ad      	mov.n	a10, a7
42008506:	ff56a5        	call8	42007a70 <_ZN3etl13ibasic_stringIcE6assignEPKc>
      return &p_buffer[0];
42008509:	37a8      	l32i.n	a10, a7, 12
      return &p_buffer[current_size];
4200850b:	0027b2        	l32i	a11, a7, 0

template <typename Iter>
inline void _reverse(Iter first, Iter last) 
{
    #if USE_ETL
        etl::reverse(first, last);
4200850e:	80bab0        	add	a11, a10, a11
42008511:	0c5025        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
42008514:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
42008517:	070c      	movi.n	a7, 0
42008519:	000446        	j	4200852e <_Z16string_benchmarkm+0x676>
4200851c:	e48100        	extui	a8, a0, 1, 15
      return &p_buffer[0];
4200851f:	28a2e0        	lsi	f14, a2, 160
42008522:	28b203        	lsi	f0, a2, 160
      return &p_buffer[current_size];
42008525:	bab000        	ceil.s	a11, f0, 0
42008528:	4ea580        	f64rnd	a10, a5, a8, 0
4200852b:	1b0c      	movi.n	a11, 1
4200852d:	ef8177        	bany	a1, a7, 42008520 <_Z16string_benchmarkm+0x668>
42008530:	a877e0        	lsi	f14, a7, 0x2a0
42008533:	70e8      	l32i.n	a14, a0, 28
42008535:	03ea      	add.n	a0, a3, a14
42008537:	c07760        	sub	a7, a7, a6
4200853a:	e0edc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200853d:	a2c7c0        	muluh	a12, a7, a12
42008540:	41ccc0        	srli	a12, a12, 12
42008543:	e109b1        	l32r	a11, 42000968 <_stext+0x948> (3c025348 <_flash_rodata_start+0x5228>)
42008546:	e0eca1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008549:	029325        	call8	4200ae7c <printf>
      return &p_buffer[0];
4200854c:	e0dd81        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
4200854f:	38a8      	l32i.n	a10, a8, 12
      return &p_buffer[current_size];
42008551:	08b8      	l32i.n	a11, a8, 0
42008553:	baba      	add.n	a11, a10, a11
42008555:	0c4be5        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
42008558:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
4200855b:	070c      	movi.n	a7, 0
4200855d:	000446        	j	42008572 <_Z16string_benchmarkm+0x6ba>
42008560:	d78100        	lsi	f0, a1, 0x35c
      return &p_buffer[0];
42008563:	28a2e0        	lsi	f14, a2, 160
42008566:	28b203        	lsi	f0, a2, 160
      return &p_buffer[current_size];
42008569:	bab000        	ceil.s	a11, f0, 0
4200856c:	4a6580        	madd.s	f6, f5, f8
4200856f:	1b0c      	movi.n	a11, 1
42008571:	de8177        	bany	a1, a7, 42008553 <_Z16string_benchmarkm+0x69b>
42008574:	a877e0        	lsi	f14, a7, 0x2a0
42008577:	70e8      	l32i.n	a14, a0, 28
42008579:	03ea      	add.n	a0, a3, a14
4200857b:	c07760        	sub	a7, a7, a6
4200857e:	e0dcc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008581:	a2c7c0        	muluh	a12, a7, a12
42008584:	41ccc0        	srli	a12, a12, 12
42008587:	e0f9b1        	l32r	a11, 4200096c <_stext+0x94c> (3c025364 <_flash_rodata_start+0x5244>)
4200858a:	e0dba1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200858d:	028ee5        	call8	4200ae7c <printf>
      return &p_buffer[0];
42008590:	e0ce81        	l32r	a8, 420008c8 <_stext+0x8a8> (3fc95b70 <_str_large>)
42008593:	38a8      	l32i.n	a10, a8, 12
      return &p_buffer[current_size];
42008595:	08b8      	l32i.n	a11, a8, 0
42008597:	baba      	add.n	a11, a10, a11
42008599:	0c47a5        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
4200859c:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
4200859f:	070c      	movi.n	a7, 0
420085a1:	000446        	j	420085b6 <_Z16string_benchmarkm+0x6fe>
420085a4:	c88100        	lsi	f0, a1, 0x320
      return &p_buffer[0];
420085a7:	28a2e0        	lsi	f14, a2, 160
420085aa:	28b203        	lsi	f0, a2, 160
      return &p_buffer[current_size];
420085ad:	bab000        	ceil.s	a11, f0, 0
420085b0:	462580        	lsi	f8, a5, 0x118
420085b3:	1b0c      	movi.n	a11, 1
420085b5:	cd8177        	bany	a1, a7, 42008586 <_Z16string_benchmarkm+0x6ce>
420085b8:	a877e0        	lsi	f14, a7, 0x2a0
420085bb:	70e8      	l32i.n	a14, a0, 28
420085bd:	03ea      	add.n	a0, a3, a14
420085bf:	c07760        	sub	a7, a7, a6
420085c2:	e0cbc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420085c5:	a2c7c0        	muluh	a12, a7, a12
420085c8:	41ccc0        	srli	a12, a12, 12
420085cb:	e0e9b1        	l32r	a11, 42000970 <_stext+0x950> (3c025380 <_flash_rodata_start+0x5260>)
420085ce:	e0caa1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420085d1:	028aa5        	call8	4200ae7c <printf>
      return &p_buffer[0];
420085d4:	e0c081        	l32r	a8, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
420085d7:	38a8      	l32i.n	a10, a8, 12
      return &p_buffer[current_size];
420085d9:	08b8      	l32i.n	a11, a8, 0
420085db:	baba      	add.n	a11, a10, a11
420085dd:	0c4365        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
420085e0:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
420085e3:	070c      	movi.n	a7, 0
420085e5:	000386        	j	420085f7 <_Z16string_benchmarkm+0x73f>
420085e8:	ba8100        	ceil.s	a8, f1, 0
      return &p_buffer[0];
420085eb:	38a8e0        	lsi	f14, a8, 224
      return &p_buffer[current_size];
420085ee:	08b8      	l32i.n	a11, a8, 0
420085f0:	baba      	add.n	a11, a10, a11
420085f2:	0c4225        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
420085f5:	771b      	addi.n	a7, a7, 1
420085f7:	e0bd81        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420085fa:	eba877        	bge	a8, a7, 420085e9 <_Z16string_benchmarkm+0x731>
420085fd:	03ea70        	rsr.ccount	a7
42008600:	c07760        	sub	a7, a7, a6
42008603:	e0bbc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008606:	a2c7c0        	muluh	a12, a7, a12
42008609:	41ccc0        	srli	a12, a12, 12
4200860c:	e0dab1        	l32r	a11, 42000974 <_stext+0x954> (3c02539c <_flash_rodata_start+0x527c>)
4200860f:	e0baa1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008612:	0286a5        	call8	4200ae7c <printf>
      return &p_buffer[0];
42008615:	e0a681        	l32r	a8, 420008b0 <_stext+0x890> (3fc95d98 <_str_tiny>)
42008618:	38a8      	l32i.n	a10, a8, 12
      return &p_buffer[current_size];
4200861a:	08b8      	l32i.n	a11, a8, 0
4200861c:	baba      	add.n	a11, a10, a11
4200861e:	0c3f65        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
      return &p_buffer[0];
42008621:	e0a781        	l32r	a8, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
42008624:	38a8      	l32i.n	a10, a8, 12
      return &p_buffer[current_size];
42008626:	08b8      	l32i.n	a11, a8, 0
42008628:	80bab0        	add	a11, a10, a11
4200862b:	0c3ea5        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
      return &p_buffer[0];
4200862e:	e0a681        	l32r	a8, 420008c8 <_stext+0x8a8> (3fc95b70 <_str_large>)
42008631:	38a8      	l32i.n	a10, a8, 12
      return &p_buffer[current_size];
42008633:	08b8      	l32i.n	a11, a8, 0
42008635:	80bab0        	add	a11, a10, a11
42008638:	0c3da5        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
      return &p_buffer[0];
4200863b:	e0a671        	l32r	a7, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
4200863e:	37a8      	l32i.n	a10, a7, 12
      return &p_buffer[current_size];
42008640:	07b8      	l32i.n	a11, a7, 0
42008642:	baba      	add.n	a11, a10, a11
42008644:	0c3ce5        	call8	42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>
      initialise();
42008647:	07ad      	mov.n	a10, a7
42008649:	ff1aa5        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
4200864c:	03ea60        	rsr.ccount	a6
    CYCLE_GET_COUNT(
4200864f:	070c      	movi.n	a7, 0
42008651:	000206        	j	4200865d <_Z16string_benchmarkm+0x7a5>
42008654:	e0a0a1        	l32r	a10, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
42008657:	ff19e5        	call8	420077f4 <_ZN3etl13ibasic_stringIcE10initialiseEv>
4200865a:	01c772        	addi	a7, a7, 1
4200865d:	e0a381        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008660:	f0a877        	bge	a8, a7, 42008654 <_Z16string_benchmarkm+0x79c>
42008663:	03ea70        	rsr.ccount	a7
42008666:	c07760        	sub	a7, a7, a6
42008669:	e0a1c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
4200866c:	a2c7c0        	muluh	a12, a7, a12
4200866f:	41ccc0        	srli	a12, a12, 12
42008672:	e0c1b1        	l32r	a11, 42000978 <_stext+0x958> (3c0253b8 <_flash_rodata_start+0x5298>)
42008675:	e0a0a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008678:	028025        	call8	4200ae7c <printf>
      return current_size;
4200867b:	e09671        	l32r	a7, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
      insert(size(), str);
4200867e:	e0bfc1        	l32r	a12, 4200097c <_stext+0x95c> (3c0253cc <_flash_rodata_start+0x52ac>)
42008681:	07b8      	l32i.n	a11, a7, 0
42008683:	07ad      	mov.n	a10, a7
42008685:	ff66a5        	call8	42007cf0 <_ZN3etl13ibasic_stringIcE6insertEjPKc>
      if (current_size != 0)
42008688:	0788      	l32i.n	a8, a7, 0
4200868a:	047816        	beqz	a8, 420086d5 <_Z16string_benchmarkm+0x81d>
        p_buffer[--current_size] = 0;
4200868d:	e091a1        	l32r	a10, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
42008690:	3a98      	l32i.n	a9, a10, 12
42008692:	880b      	addi.n	a8, a8, -1
42008694:	0a89      	s32i.n	a8, a10, 0
42008696:	898a      	add.n	a8, a9, a8
42008698:	090c      	movi.n	a9, 0
4200869a:	004892        	s8i	a9, a8, 0
4200869d:	000d06        	j	420086d5 <_Z16string_benchmarkm+0x81d>
420086a0:	ea4000        	utrunc.s	a4, f0, 0
420086a3:	8c6103        	lsi	f0, a1, 0x230
      return current_size;
420086a6:	b5c1e0        	extui	a12, a14, 17, 12
      insert(size(), str);
420086a9:	26b2e0        	lsi	f14, a2, 152
420086ac:	a66000        	lsi	f0, a0, 0x298
420086af:	63e520        	minu	a14, a5, a2
420086b2:	ff          	.byte	0xff
420086b3:	03ea80        	rsr.ccount	a8
    CYCLE_GET_COUNT_MUTATE(
420086b6:	c08840        	sub	a8, a8, a4
420086b9:	807780        	add	a7, a7, a8
      if (current_size != 0)
420086bc:	0688      	l32i.n	a8, a6, 0
420086be:	e88c      	beqz.n	a8, 420086d0 <_Z16string_benchmarkm+0x818>
        p_buffer[--current_size] = 0;
420086c0:	e085a1        	l32r	a10, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
420086c3:	3a98      	l32i.n	a9, a10, 12
420086c5:	880b      	addi.n	a8, a8, -1
420086c7:	0a89      	s32i.n	a8, a10, 0
420086c9:	898a      	add.n	a8, a9, a8
420086cb:	090c      	movi.n	a9, 0
420086cd:	004892        	s8i	a9, a8, 0
420086d0:	551b      	addi.n	a5, a5, 1
420086d2:	000106        	j	420086da <_Z16string_benchmarkm+0x822>
    CYCLE_GET_COUNT(
420086d5:	00a052        	movi	a5, 0
420086d8:	057d      	mov.n	a7, a5
    CYCLE_GET_COUNT_MUTATE(
420086da:	e08481        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420086dd:	c0a857        	bge	a8, a5, 420086a1 <_Z16string_benchmarkm+0x7e9>
420086e0:	e084c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420086e3:	a2c7c0        	muluh	a12, a7, a12
420086e6:	41ccc0        	srli	a12, a12, 12
420086e9:	e0a5b1        	l32r	a11, 42000980 <_stext+0x960> (3c0253d0 <_flash_rodata_start+0x52b0>)
420086ec:	e083a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420086ef:	0278e5        	call8	4200ae7c <printf>
    CYCLE_GET_COUNT_MUTATE(
420086f2:	e07761        	l32r	a6, 420008d0 <_stext+0x8b0> (3fc921a8 <c_str_jumbo>)
      return current_size;
420086f5:	e07771        	l32r	a7, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
      insert(size(), str);
420086f8:	06c8      	l32i.n	a12, a6, 0
420086fa:	07b8      	l32i.n	a11, a7, 0
420086fc:	07ad      	mov.n	a10, a7
420086fe:	ff5f25        	call8	42007cf0 <_ZN3etl13ibasic_stringIcE6insertEjPKc>
      return current_size;
42008701:	0758      	l32i.n	a5, a7, 0
42008703:	06a8      	l32i.n	a10, a6, 0
42008705:	dee581        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42008708:	0008e0        	callx8	a8
4200870b:	fc7c      	movi.n	a12, -1
4200870d:	c0b5a0        	sub	a11, a5, a10
42008710:	07ad      	mov.n	a10, a7
42008712:	ff6f65        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
42008715:	070c      	movi.n	a7, 0
42008717:	075d      	mov.n	a5, a7
42008719:	000c46        	j	4200874e <_Z16string_benchmarkm+0x896>
4200871c:	03ea30        	rsr.ccount	a3
4200871f:	e06c41        	l32r	a4, 420008d0 <_stext+0x8b0> (3fc921a8 <c_str_jumbo>)
42008722:	e06c61        	l32r	a6, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
      insert(size(), str);
42008725:	0024c2        	l32i	a12, a4, 0
42008728:	06b8      	l32i.n	a11, a6, 0
4200872a:	06ad      	mov.n	a10, a6
4200872c:	ff5c25        	call8	42007cf0 <_ZN3etl13ibasic_stringIcE6insertEjPKc>
4200872f:	03ea80        	rsr.ccount	a8
42008732:	c08830        	sub	a8, a8, a3
42008735:	778a      	add.n	a7, a7, a8
      return current_size;
42008737:	0638      	l32i.n	a3, a6, 0
42008739:	0024a2        	l32i	a10, a4, 0
4200873c:	ded881        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200873f:	0008e0        	callx8	a8
42008742:	fc7c      	movi.n	a12, -1
42008744:	c0b3a0        	sub	a11, a3, a10
42008747:	06ad      	mov.n	a10, a6
42008749:	ff6be5        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
4200874c:	551b      	addi.n	a5, a5, 1
4200874e:	e06781        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008751:	c7a857        	bge	a8, a5, 4200871c <_Z16string_benchmarkm+0x864>
42008754:	e067c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008757:	a2c7c0        	muluh	a12, a7, a12
4200875a:	41ccc0        	srli	a12, a12, 12
4200875d:	e089b1        	l32r	a11, 42000984 <_stext+0x964> (3c0253e4 <_flash_rodata_start+0x52c4>)
42008760:	e066a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008763:	0271a5        	call8	4200ae7c <printf>
42008766:	03eaa0        	rsr.ccount	a10
    CYCLE_GET_COUNT_RETURN(
42008769:	080c      	movi.n	a8, 0
4200876b:	000086        	j	42008771 <_Z16string_benchmarkm+0x8b9>
4200876e:	01c882        	addi	a8, a8, 1
42008771:	e05e91        	l32r	a9, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008774:	f6a987        	bge	a9, a8, 4200876e <_Z16string_benchmarkm+0x8b6>
42008777:	03ea70        	rsr.ccount	a7
4200877a:	c077a0        	sub	a7, a7, a10
4200877d:	e05cc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008780:	a2c7c0        	muluh	a12, a7, a12
42008783:	41ccc0        	srli	a12, a12, 12
42008786:	e080b1        	l32r	a11, 42000988 <_stext+0x968> (3c025400 <_flash_rodata_start+0x52e0>)
42008789:	e05ba1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200878c:	026ee5        	call8	4200ae7c <printf>
    CYCLE_GET_COUNT_MUTATE(
4200878f:	e04c71        	l32r	a7, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
42008792:	61a0b2        	movi	a11, 97
42008795:	20a770        	or	a10, a7, a7
42008798:	0c2425        	call8	420149dc <_ZN3etl13ibasic_stringIcE9push_backEc>
      if (current_size != 0)
4200879b:	002782        	l32i	a8, a7, 0
4200879e:	044816        	beqz	a8, 420087e6 <_Z16string_benchmarkm+0x92e>
        p_buffer[--current_size] = 0;
420087a1:	e047a1        	l32r	a10, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
420087a4:	3a98      	l32i.n	a9, a10, 12
420087a6:	880b      	addi.n	a8, a8, -1
420087a8:	0a89      	s32i.n	a8, a10, 0
420087aa:	898a      	add.n	a8, a9, a8
420087ac:	090c      	movi.n	a9, 0
420087ae:	004892        	s8i	a9, a8, 0
420087b1:	000c46        	j	420087e6 <_Z16string_benchmarkm+0x92e>
420087b4:	03ea40        	rsr.ccount	a4
420087b7:	e04251        	l32r	a5, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
420087ba:	61a0b2        	movi	a11, 97
420087bd:	20a550        	or	a10, a5, a5
420087c0:	0c21a5        	call8	420149dc <_ZN3etl13ibasic_stringIcE9push_backEc>
420087c3:	03ea80        	rsr.ccount	a8
420087c6:	c08840        	sub	a8, a8, a4
420087c9:	807780        	add	a7, a7, a8
      if (current_size != 0)
420087cc:	002582        	l32i	a8, a5, 0
420087cf:	e88c      	beqz.n	a8, 420087e1 <_Z16string_benchmarkm+0x929>
        p_buffer[--current_size] = 0;
420087d1:	e03ba1        	l32r	a10, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
420087d4:	3a98      	l32i.n	a9, a10, 12
420087d6:	880b      	addi.n	a8, a8, -1
420087d8:	0a89      	s32i.n	a8, a10, 0
420087da:	898a      	add.n	a8, a9, a8
420087dc:	090c      	movi.n	a9, 0
420087de:	004892        	s8i	a9, a8, 0
420087e1:	661b      	addi.n	a6, a6, 1
420087e3:	000106        	j	420087eb <_Z16string_benchmarkm+0x933>
    CYCLE_GET_COUNT_RETURN(
420087e6:	00a062        	movi	a6, 0
420087e9:	067d      	mov.n	a7, a6
    CYCLE_GET_COUNT_MUTATE(
420087eb:	e04081        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420087ee:	c2a867        	bge	a8, a6, 420087b4 <_Z16string_benchmarkm+0x8fc>
420087f1:	e03fc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420087f4:	a2c7c0        	muluh	a12, a7, a12
420087f7:	41ccc0        	srli	a12, a12, 12
420087fa:	e064b1        	l32r	a11, 4200098c <_stext+0x96c> (3c025424 <_flash_rodata_start+0x5304>)
420087fd:	e03ea1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008800:	0267a5        	call8	4200ae7c <printf>
    CYCLE_GET_COUNT_MUTATE(
42008803:	e02f71        	l32r	a7, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
42008806:	e062c1        	l32r	a12, 42000990 <_stext+0x970> (3c025448 <_flash_rodata_start+0x5328>)
42008809:	3b0c      	movi.n	a11, 3
4200880b:	07ad      	mov.n	a10, a7
4200880d:	ff4e25        	call8	42007cf0 <_ZN3etl13ibasic_stringIcE6insertEjPKc>
42008810:	5c0c      	movi.n	a12, 5
42008812:	3b0c      	movi.n	a11, 3
42008814:	07ad      	mov.n	a10, a7
42008816:	ff5f25        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
42008819:	070c      	movi.n	a7, 0
4200881b:	076d      	mov.n	a6, a7
4200881d:	000986        	j	42008847 <_Z16string_benchmarkm+0x98f>
42008820:	ea4000        	utrunc.s	a4, f0, 0
42008823:	275103        	lsi	f0, a1, 156
42008826:	5ac1e0        	msub.s	f12, f1, f14
42008829:	a0b2e0        	addx4	a11, a2, a14
4200882c:	a55003        	lsi	f0, a0, 0x294
4200882f:	4be520        	olt.s	b14, f5, f2
42008832:	ff          	.byte	0xff
42008833:	03ea80        	rsr.ccount	a8
42008836:	c08840        	sub	a8, a8, a4
42008839:	807780        	add	a7, a7, a8
4200883c:	5c0c      	movi.n	a12, 5
4200883e:	3b0c      	movi.n	a11, 3
42008840:	05ad      	mov.n	a10, a5
42008842:	ff5c65        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
42008845:	661b      	addi.n	a6, a6, 1
42008847:	e02981        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200884a:	d3a867        	bge	a8, a6, 42008821 <_Z16string_benchmarkm+0x969>
4200884d:	e028c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008850:	a2c7c0        	muluh	a12, a7, a12
42008853:	41ccc0        	srli	a12, a12, 12
42008856:	e04fb1        	l32r	a11, 42000994 <_stext+0x974> (3c025450 <_flash_rodata_start+0x5330>)
42008859:	e027a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200885c:	0261e5        	call8	4200ae7c <printf>
      return &p_buffer[0];
4200885f:	e01871        	l32r	a7, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
42008862:	37b8      	l32i.n	a11, a7, 12
      insert(begin() + position, n, c);
42008864:	61a0d2        	movi	a13, 97
42008867:	5c0c      	movi.n	a12, 5
42008869:	bb3b      	addi.n	a11, a11, 3
4200886b:	07ad      	mov.n	a10, a7
4200886d:	ff3325        	call8	42007ba0 <_ZN3etl13ibasic_stringIcE6insertEPKcjc>
    CYCLE_GET_COUNT_MUTATE (
42008870:	5c0c      	movi.n	a12, 5
42008872:	3b0c      	movi.n	a11, 3
42008874:	07ad      	mov.n	a10, a7
42008876:	ff5925        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
42008879:	070c      	movi.n	a7, 0
4200887b:	075d      	mov.n	a5, a7
4200887d:	0009c6        	j	420088a8 <_Z16string_benchmarkm+0x9f0>
42008880:	ea4000        	utrunc.s	a4, f0, 0
42008883:	0f6103        	lsi	f0, a1, 60
      return &p_buffer[0];
42008886:	36b8e0        	lsi	f14, a8, 216
      insert(begin() + position, n, c);
42008889:	61a0d2        	movi	a13, 97
4200888c:	5c0c      	movi.n	a12, 5
4200888e:	bb3b      	addi.n	a11, a11, 3
42008890:	06ad      	mov.n	a10, a6
42008892:	ff30e5        	call8	42007ba0 <_ZN3etl13ibasic_stringIcE6insertEPKcjc>
42008895:	03ea80        	rsr.ccount	a8
42008898:	c08840        	sub	a8, a8, a4
4200889b:	778a      	add.n	a7, a7, a8
4200889d:	5c0c      	movi.n	a12, 5
4200889f:	3b0c      	movi.n	a11, 3
420088a1:	06ad      	mov.n	a10, a6
420088a3:	ff5665        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
420088a6:	551b      	addi.n	a5, a5, 1
420088a8:	e01181        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420088ab:	d2a857        	bge	a8, a5, 42008881 <_Z16string_benchmarkm+0x9c9>
420088ae:	e010c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420088b1:	a2c7c0        	muluh	a12, a7, a12
420088b4:	41ccc0        	srli	a12, a12, 12
420088b7:	e038b1        	l32r	a11, 42000998 <_stext+0x978> (3c025478 <_flash_rodata_start+0x5358>)
420088ba:	e00fa1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420088bd:	025be5        	call8	4200ae7c <printf>
      return &p_buffer[0];
420088c0:	e00071        	l32r	a7, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
420088c3:	37b8      	l32i.n	a11, a7, 12
    CYCLE_GET_COUNT_MUTATE (
420088c5:	61a0c2        	movi	a12, 97
420088c8:	bb3b      	addi.n	a11, a11, 3
420088ca:	07ad      	mov.n	a10, a7
420088cc:	ff47a5        	call8	42007d48 <_ZN3etl13ibasic_stringIcE6insertEPKcc>
420088cf:	37b8      	l32i.n	a11, a7, 12
420088d1:	bb3b      	addi.n	a11, a11, 3
420088d3:	07ad      	mov.n	a10, a7
420088d5:	ff5ba5        	call8	42007e90 <_ZN3etl13ibasic_stringIcE5eraseEPc>
420088d8:	070c      	movi.n	a7, 0
420088da:	075d      	mov.n	a5, a7
420088dc:	000a06        	j	42008908 <_Z16string_benchmarkm+0xa50>
420088df:	ea4000        	utrunc.s	a4, f0, 0
420088e2:	f76103        	lsi	f0, a1, 0x3dc
420088e5:	df          	.byte	0xdf
420088e6:	0326b2        	l32i	a11, a6, 12
420088e9:	61a0c2        	movi	a12, 97
420088ec:	03cbb2        	addi	a11, a11, 3
420088ef:	20a660        	or	a10, a6, a6
420088f2:	ff4565        	call8	42007d48 <_ZN3etl13ibasic_stringIcE6insertEPKcc>
420088f5:	03ea80        	rsr.ccount	a8
420088f8:	c08840        	sub	a8, a8, a4
420088fb:	778a      	add.n	a7, a7, a8
420088fd:	36b8      	l32i.n	a11, a6, 12
420088ff:	bb3b      	addi.n	a11, a11, 3
42008901:	06ad      	mov.n	a10, a6
42008903:	ff58e5        	call8	42007e90 <_ZN3etl13ibasic_stringIcE5eraseEPc>
42008906:	551b      	addi.n	a5, a5, 1
42008908:	dff981        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
4200890b:	d1a857        	bge	a8, a5, 420088e0 <_Z16string_benchmarkm+0xa28>
4200890e:	dff8c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008911:	a2c7c0        	muluh	a12, a7, a12
42008914:	41ccc0        	srli	a12, a12, 12
42008917:	e021b1        	l32r	a11, 4200099c <_stext+0x97c> (3c0254a0 <_flash_rodata_start+0x5380>)
4200891a:	dff7a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
4200891d:	0255e5        	call8	4200ae7c <printf>
    CYCLE_GET_COUNT_MUTATE(
42008920:	dfe871        	l32r	a7, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
42008923:	5c0c      	movi.n	a12, 5
42008925:	3b0c      	movi.n	a11, 3
42008927:	07ad      	mov.n	a10, a7
42008929:	ff4de5        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
4200892c:	e01dc1        	l32r	a12, 420009a0 <_stext+0x980> (3c0254dc <_flash_rodata_start+0x53bc>)
4200892f:	3b0c      	movi.n	a11, 3
42008931:	07ad      	mov.n	a10, a7
42008933:	ff3be5        	call8	42007cf0 <_ZN3etl13ibasic_stringIcE6insertEjPKc>
42008936:	070c      	movi.n	a7, 0
42008938:	076d      	mov.n	a6, a7
4200893a:	000886        	j	42008960 <_Z16string_benchmarkm+0xaa8>
4200893d:	03ea40        	rsr.ccount	a4
42008940:	dfe051        	l32r	a5, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
42008943:	5c0c      	movi.n	a12, 5
42008945:	3b0c      	movi.n	a11, 3
42008947:	05ad      	mov.n	a10, a5
42008949:	ff4be5        	call8	42007e08 <_ZN3etl13ibasic_stringIcE5eraseEjj>
4200894c:	03ea80        	rsr.ccount	a8
4200894f:	c08840        	sub	a8, a8, a4
42008952:	778a      	add.n	a7, a7, a8
42008954:	e013c1        	l32r	a12, 420009a0 <_stext+0x980> (3c0254dc <_flash_rodata_start+0x53bc>)
42008957:	3b0c      	movi.n	a11, 3
42008959:	05ad      	mov.n	a10, a5
4200895b:	ff3965        	call8	42007cf0 <_ZN3etl13ibasic_stringIcE6insertEjPKc>
4200895e:	661b      	addi.n	a6, a6, 1
42008960:	dfe381        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008963:	d6a867        	bge	a8, a6, 4200893d <_Z16string_benchmarkm+0xa85>
42008966:	dfe2c1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008969:	a2c7c0        	muluh	a12, a7, a12
4200896c:	41ccc0        	srli	a12, a12, 12
4200896f:	e00db1        	l32r	a11, 420009a4 <_stext+0x984> (3c0254e4 <_flash_rodata_start+0x53c4>)
42008972:	dfe1a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008975:	025065        	call8	4200ae7c <printf>
42008978:	dfd271        	l32r	a7, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
4200897b:	37b8      	l32i.n	a11, a7, 12
    CYCLE_GET_COUNT_MUTATE (
4200897d:	bb3b      	addi.n	a11, a11, 3
4200897f:	07ad      	mov.n	a10, a7
42008981:	ff50e5        	call8	42007e90 <_ZN3etl13ibasic_stringIcE5eraseEPc>
42008984:	37b8      	l32i.n	a11, a7, 12
42008986:	6ca0c2        	movi	a12, 108
42008989:	bb3b      	addi.n	a11, a11, 3
4200898b:	07ad      	mov.n	a10, a7
4200898d:	ff3ba5        	call8	42007d48 <_ZN3etl13ibasic_stringIcE6insertEPKcc>
42008990:	070c      	movi.n	a7, 0
42008992:	075d      	mov.n	a5, a7
42008994:	000986        	j	420089be <_Z16string_benchmarkm+0xb06>
42008997:	400000        	ssr	a0
4200899a:	03ea      	add.n	a0, a3, a14
4200899c:	dfc961        	l32r	a6, 420008c0 <_stext+0x8a0> (3fc95c84 <_str_medium>)
4200899f:	36b8      	l32i.n	a11, a6, 12
420089a1:	bb3b      	addi.n	a11, a11, 3
420089a3:	06ad      	mov.n	a10, a6
420089a5:	ff4ea5        	call8	42007e90 <_ZN3etl13ibasic_stringIcE5eraseEPc>
420089a8:	03ea80        	rsr.ccount	a8
420089ab:	c08840        	sub	a8, a8, a4
420089ae:	778a      	add.n	a7, a7, a8
420089b0:	36b8      	l32i.n	a11, a6, 12
420089b2:	6ca0c2        	movi	a12, 108
420089b5:	bb3b      	addi.n	a11, a11, 3
420089b7:	06ad      	mov.n	a10, a6
420089b9:	ff38e5        	call8	42007d48 <_ZN3etl13ibasic_stringIcE6insertEPKcc>
420089bc:	551b      	addi.n	a5, a5, 1
420089be:	dfcb81        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
420089c1:	d4a857        	bge	a8, a5, 42008999 <_Z16string_benchmarkm+0xae1>
420089c4:	dfcbc1        	l32r	a12, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
420089c7:	a2c7c0        	muluh	a12, a7, a12
420089ca:	41ccc0        	srli	a12, a12, 12
420089cd:	dff6b1        	l32r	a11, 420009a8 <_stext+0x988> (3c025504 <_flash_rodata_start+0x53e4>)
420089d0:	dfcaa1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
420089d3:	024aa5        	call8	4200ae7c <printf>
      return current_size;
420089d6:	dfbf71        	l32r	a7, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
420089d9:	0748      	l32i.n	a4, a7, 0
    size_t half_jumbo = _str_jumbo.size() / 2;
420089db:	414140        	srli	a4, a4, 1
    auto substr = _str_jumbo.substr(half_jumbo, temp_len);
420089de:	10c162        	addi	a6, a1, 16
420089e1:	bd0c      	movi.n	a13, 11
420089e3:	04cd      	mov.n	a12, a4
420089e5:	07bd      	mov.n	a11, a7
420089e7:	06ad      	mov.n	a10, a6
420089e9:	fef565        	call8	42007940 <_ZNK3etl6stringILj1536EE6substrEjj>
420089ec:	dfb981        	l32r	a8, 420008d0 <_stext+0x8b0> (3fc921a8 <c_str_jumbo>)
420089ef:	08b8      	l32i.n	a11, a8, 0
420089f1:	07ad      	mov.n	a10, a7
420089f3:	ff07e5        	call8	42007a70 <_ZN3etl13ibasic_stringIcE6assignEPKc>
    CYCLE_GET_COUNT_MUTATE (
420089f6:	dfedd1        	l32r	a13, 420009ac <_stext+0x98c> (3c025538 <_flash_rodata_start+0x5418>)
420089f9:	bc0c      	movi.n	a12, 11
420089fb:	20b440        	or	a11, a4, a4
420089fe:	07ad      	mov.n	a10, a7
42008a00:	ff4265        	call8	42007e28 <_ZN3etl13ibasic_stringIcE7replaceEjjPKc>
42008a03:	06dd      	mov.n	a13, a6
42008a05:	bc0c      	movi.n	a12, 11
42008a07:	04bd      	mov.n	a11, a4
42008a09:	07ad      	mov.n	a10, a7
42008a0b:	ff4625        	call8	42007e6c <_ZN3etl13ibasic_stringIcE7replaceEjjRKS1_>
42008a0e:	070c      	movi.n	a7, 0
42008a10:	076d      	mov.n	a6, a7
42008a12:	000a46        	j	42008a3f <_Z16string_benchmarkm+0xb87>
42008a15:	03ea30        	rsr.ccount	a3
42008a18:	dfaf51        	l32r	a5, 420008d4 <_stext+0x8b4> (3fc95554 <_str_jumbo>)
42008a1b:	dfe4d1        	l32r	a13, 420009ac <_stext+0x98c> (3c025538 <_flash_rodata_start+0x5418>)
42008a1e:	bc0c      	movi.n	a12, 11
42008a20:	04bd      	mov.n	a11, a4
42008a22:	05ad      	mov.n	a10, a5
42008a24:	ff4025        	call8	42007e28 <_ZN3etl13ibasic_stringIcE7replaceEjjPKc>
42008a27:	03ea80        	rsr.ccount	a8
42008a2a:	c08830        	sub	a8, a8, a3
42008a2d:	778a      	add.n	a7, a7, a8
42008a2f:	10c1d2        	addi	a13, a1, 16
42008a32:	bc0c      	movi.n	a12, 11
42008a34:	04bd      	mov.n	a11, a4
42008a36:	20a550        	or	a10, a5, a5
42008a39:	ff4325        	call8	42007e6c <_ZN3etl13ibasic_stringIcE7replaceEjjRKS1_>
42008a3c:	01c662        	addi	a6, a6, 1
42008a3f:	dfab81        	l32r	a8, 420008ec <_stext+0x8cc> (1387 <UserFrameTotalSize+0x1287>)
42008a42:	cfa867        	bge	a8, a6, 42008a15 <_Z16string_benchmarkm+0xb5d>
42008a45:	dfaa81        	l32r	a8, 420008f0 <_stext+0x8d0> (d1b71759 <_rtc_reserved_end+0x71a71759>)
42008a48:	a2c780        	muluh	a12, a7, a8
42008a4b:	41ccc0        	srli	a12, a12, 12
42008a4e:	dfd8b1        	l32r	a11, 420009b0 <_stext+0x990> (3c025544 <_flash_rodata_start+0x5424>)
42008a51:	dfa9a1        	l32r	a10, 420008f8 <_stext+0x8d8> (3c025034 <_flash_rodata_start+0x4f14>)
42008a54:	024265        	call8	4200ae7c <printf>
    ESP_LOGI(tag, "DONE\n");    
42008a57:	dd8281        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008a5a:	0008e0        	callx8	a8
42008a5d:	dfd5b1        	l32r	a11, 420009b4 <_stext+0x994> (3c02557c <_flash_rodata_start+0x545c>)
42008a60:	0bed      	mov.n	a14, a11
42008a62:	0add      	mov.n	a13, a10
42008a64:	dfd5c1        	l32r	a12, 420009b8 <_stext+0x998> (3c025584 <_flash_rodata_start+0x5464>)
42008a67:	3a0c      	movi.n	a10, 3
42008a69:	dd8a81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008a6c:	0008e0        	callx8	a8
  class string : public istring
42008a6f:	10c1a2        	addi	a10, a1, 16
42008a72:	feda25        	call8	42007814 <_ZN3etl13ibasic_stringIcED1Ev>
}
42008a75:	f01d      	retw.n
	...

42008a78 <_GLOBAL__sub_I_c_str_tiny>:
42008a78:	004136        	entry	a1, 32
42008a7b:	fef425        	call8	420079bc <_Z41__static_initialization_and_destruction_0v>
42008a7e:	f01d      	retw.n

42008a80 <gpio_sleep_input_enable>:
    gpio_hal_sleep_input_disable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
}

static esp_err_t gpio_sleep_input_enable(gpio_num_t gpio_num)
{
42008a80:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008a83:	02d296        	bltz	a2, 42008ab4 <gpio_sleep_input_enable+0x34>
42008a86:	0a2c      	movi.n	a10, 32
42008a88:	10a2a0        	and	a10, a2, a10
42008a8b:	f87c      	movi.n	a8, -1
42008a8d:	308280        	xor	a8, a2, a8
42008a90:	dec491        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008a93:	401800        	ssl	a8
42008a96:	a19900        	sll	a9, a9
42008a99:	dec281        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008a9c:	400200        	ssr	a2
42008a9f:	918080        	srl	a8, a8
42008aa2:	208980        	or	a8, a9, a8
42008aa5:	dec091        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008aa8:	400200        	ssr	a2
42008aab:	919090        	srl	a9, a9
42008aae:	9389a0        	movnez	a8, a9, a10
42008ab1:	2be807        	bbsi	a8, 0, 42008ae0 <gpio_sleep_input_enable+0x60>
42008ab4:	dd6b81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008ab7:	0008e0        	callx8	a8
42008aba:	dfc2b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008abd:	dfc381        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008ac0:	1189      	s32i.n	a8, a1, 4
42008ac2:	5da382        	movi	a8, 0x35d
42008ac5:	0189      	s32i.n	a8, a1, 0
42008ac7:	dfbef1        	l32r	a15, 420009c0 <_stext+0x9a0> (3c0285d8 <__FUNCTION__$13>)
42008aca:	0bed      	mov.n	a14, a11
42008acc:	0add      	mov.n	a13, a10
42008ace:	dfbec1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008ad1:	1a0c      	movi.n	a10, 1
42008ad3:	dd7081        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008ad6:	0008e0        	callx8	a8
42008ad9:	02a122        	movi	a2, 0x102
42008adc:	000646        	j	42008af9 <gpio_sleep_input_enable+0x79>
42008adf:	bc8100        	lsi	f0, a1, 0x2f0
  * @param gpio_num GPIO number
  */
__attribute__((always_inline))
static inline void gpio_ll_sleep_input_enable(gpio_dev_t *hw, uint32_t gpio_num)
{
    PIN_SLP_INPUT_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008ae2:	df          	.byte	0xdf
42008ae3:	a02280        	addx4	a2, a2, a8
42008ae6:	0298      	l32i.n	a9, a2, 0
42008ae8:	0020c0        	memw
42008aeb:	0988      	l32i.n	a8, a9, 0
42008aed:	0a1c      	movi.n	a10, 16
42008aef:	2088a0        	or	a8, a8, a10
42008af2:	0020c0        	memw
42008af5:	0989      	s32i.n	a8, a9, 0
    gpio_hal_sleep_input_enable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
42008af7:	020c      	movi.n	a2, 0
}
42008af9:	f01d      	retw.n
	...

42008afc <gpio_sleep_input_disable>:
{
42008afc:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008aff:	02d296        	bltz	a2, 42008b30 <gpio_sleep_input_disable+0x34>
42008b02:	0a2c      	movi.n	a10, 32
42008b04:	10a2a0        	and	a10, a2, a10
42008b07:	f87c      	movi.n	a8, -1
42008b09:	308280        	xor	a8, a2, a8
42008b0c:	dea591        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008b0f:	401800        	ssl	a8
42008b12:	a19900        	sll	a9, a9
42008b15:	dea381        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008b18:	400200        	ssr	a2
42008b1b:	918080        	srl	a8, a8
42008b1e:	208980        	or	a8, a9, a8
42008b21:	dea191        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008b24:	400200        	ssr	a2
42008b27:	919090        	srl	a9, a9
42008b2a:	9389a0        	movnez	a8, a9, a10
42008b2d:	2be807        	bbsi	a8, 0, 42008b5c <gpio_sleep_input_disable+0x60>
42008b30:	dd4c81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008b33:	0008e0        	callx8	a8
42008b36:	dfa3b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008b39:	dfa481        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008b3c:	1189      	s32i.n	a8, a1, 4
42008b3e:	56a382        	movi	a8, 0x356
42008b41:	0189      	s32i.n	a8, a1, 0
42008b43:	dfa4f1        	l32r	a15, 420009d4 <_stext+0x9b4> (3c0285bc <__FUNCTION__$12>)
42008b46:	0bed      	mov.n	a14, a11
42008b48:	0add      	mov.n	a13, a10
42008b4a:	df9fc1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008b4d:	1a0c      	movi.n	a10, 1
42008b4f:	dd5181        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008b52:	0008e0        	callx8	a8
42008b55:	02a122        	movi	a2, 0x102
42008b58:	000646        	j	42008b75 <gpio_sleep_input_disable+0x79>
42008b5b:	9d8100        	lsi	f0, a1, 0x274
    PIN_SLP_INPUT_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008b5e:	df          	.byte	0xdf
42008b5f:	a02280        	addx4	a2, a2, a8
42008b62:	0298      	l32i.n	a9, a2, 0
42008b64:	0020c0        	memw
42008b67:	0988      	l32i.n	a8, a9, 0
42008b69:	fa6c      	movi.n	a10, -17
42008b6b:	1088a0        	and	a8, a8, a10
42008b6e:	0020c0        	memw
42008b71:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
42008b73:	020c      	movi.n	a2, 0
}
42008b75:	f01d      	retw.n
	...

42008b78 <gpio_sleep_output_enable>:
    gpio_hal_sleep_output_disable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
}

static esp_err_t gpio_sleep_output_enable(gpio_num_t gpio_num)
{
42008b78:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_OUTPUT_GPIO(gpio_num), "GPIO output gpio_num error", ESP_ERR_INVALID_ARG);
42008b7b:	02d296        	bltz	a2, 42008bac <gpio_sleep_output_enable+0x34>
42008b7e:	0a2c      	movi.n	a10, 32
42008b80:	10a2a0        	and	a10, a2, a10
42008b83:	f87c      	movi.n	a8, -1
42008b85:	308280        	xor	a8, a2, a8
42008b88:	de8691        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008b8b:	401800        	ssl	a8
42008b8e:	a19900        	sll	a9, a9
42008b91:	de8481        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008b94:	400200        	ssr	a2
42008b97:	918080        	srl	a8, a8
42008b9a:	208980        	or	a8, a9, a8
42008b9d:	de8291        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008ba0:	400200        	ssr	a2
42008ba3:	919090        	srl	a9, a9
42008ba6:	9389a0        	movnez	a8, a9, a10
42008ba9:	2be807        	bbsi	a8, 0, 42008bd8 <gpio_sleep_output_enable+0x60>
42008bac:	dd2d81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008baf:	0008e0        	callx8	a8
42008bb2:	df84b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008bb5:	df8981        	l32r	a8, 420009dc <_stext+0x9bc> (3c025b74 <_flash_rodata_start+0x5a54>)
42008bb8:	1189      	s32i.n	a8, a1, 4
42008bba:	6ba382        	movi	a8, 0x36b
42008bbd:	0189      	s32i.n	a8, a1, 0
42008bbf:	df86f1        	l32r	a15, 420009d8 <_stext+0x9b8> (3c0285a0 <__FUNCTION__$11>)
42008bc2:	0bed      	mov.n	a14, a11
42008bc4:	0add      	mov.n	a13, a10
42008bc6:	df80c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008bc9:	1a0c      	movi.n	a10, 1
42008bcb:	dd3281        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008bce:	0008e0        	callx8	a8
42008bd1:	02a122        	movi	a2, 0x102
42008bd4:	000646        	j	42008bf1 <gpio_sleep_output_enable+0x79>
42008bd7:	7e8100        	f64rnd	a8, a1, a0, 3
  * @param gpio_num GPIO number
  */
__attribute__((always_inline))
static inline void gpio_ll_sleep_output_enable(gpio_dev_t *hw, uint32_t gpio_num)
{
    PIN_SLP_OUTPUT_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008bda:	df          	.byte	0xdf
42008bdb:	a02280        	addx4	a2, a2, a8
42008bde:	0298      	l32i.n	a9, a2, 0
42008be0:	0020c0        	memw
42008be3:	0988      	l32i.n	a8, a9, 0
42008be5:	1a0c      	movi.n	a10, 1
42008be7:	2088a0        	or	a8, a8, a10
42008bea:	0020c0        	memw
42008bed:	0989      	s32i.n	a8, a9, 0
    gpio_hal_sleep_output_enable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
42008bef:	020c      	movi.n	a2, 0
}
42008bf1:	f01d      	retw.n
	...

42008bf4 <gpio_sleep_output_disable>:
{
42008bf4:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008bf7:	02d296        	bltz	a2, 42008c28 <gpio_sleep_output_disable+0x34>
42008bfa:	0a2c      	movi.n	a10, 32
42008bfc:	10a2a0        	and	a10, a2, a10
42008bff:	f87c      	movi.n	a8, -1
42008c01:	308280        	xor	a8, a2, a8
42008c04:	de6791        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008c07:	401800        	ssl	a8
42008c0a:	a19900        	sll	a9, a9
42008c0d:	de6581        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008c10:	400200        	ssr	a2
42008c13:	918080        	srl	a8, a8
42008c16:	208980        	or	a8, a9, a8
42008c19:	de6391        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008c1c:	400200        	ssr	a2
42008c1f:	919090        	srl	a9, a9
42008c22:	9389a0        	movnez	a8, a9, a10
42008c25:	2be807        	bbsi	a8, 0, 42008c54 <gpio_sleep_output_disable+0x60>
42008c28:	dd0e81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008c2b:	0008e0        	callx8	a8
42008c2e:	df65b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008c31:	df6681        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008c34:	1189      	s32i.n	a8, a1, 4
42008c36:	64a382        	movi	a8, 0x364
42008c39:	0189      	s32i.n	a8, a1, 0
42008c3b:	df69f1        	l32r	a15, 420009e0 <_stext+0x9c0> (3c028584 <__FUNCTION__$10>)
42008c3e:	0bed      	mov.n	a14, a11
42008c40:	0add      	mov.n	a13, a10
42008c42:	df61c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008c45:	1a0c      	movi.n	a10, 1
42008c47:	dd1381        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008c4a:	0008e0        	callx8	a8
42008c4d:	02a122        	movi	a2, 0x102
42008c50:	000646        	j	42008c6d <gpio_sleep_output_disable+0x79>
42008c53:	5f8100        	f64cmph	a8, a1, a0, 5
    PIN_SLP_OUTPUT_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008c56:	df          	.byte	0xdf
42008c57:	a02280        	addx4	a2, a2, a8
42008c5a:	0298      	l32i.n	a9, a2, 0
42008c5c:	0020c0        	memw
42008c5f:	0988      	l32i.n	a8, a9, 0
42008c61:	ea7c      	movi.n	a10, -2
42008c63:	1088a0        	and	a8, a8, a10
42008c66:	0020c0        	memw
42008c69:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
42008c6b:	020c      	movi.n	a2, 0
}
42008c6d:	f01d      	retw.n
	...

42008c70 <gpio_sleep_pulldown_en>:
{
42008c70:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008c73:	02d296        	bltz	a2, 42008ca4 <gpio_sleep_pulldown_en+0x34>
42008c76:	0a2c      	movi.n	a10, 32
42008c78:	10a2a0        	and	a10, a2, a10
42008c7b:	f87c      	movi.n	a8, -1
42008c7d:	308280        	xor	a8, a2, a8
42008c80:	de4891        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008c83:	401800        	ssl	a8
42008c86:	a19900        	sll	a9, a9
42008c89:	de4681        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008c8c:	400200        	ssr	a2
42008c8f:	918080        	srl	a8, a8
42008c92:	208980        	or	a8, a9, a8
42008c95:	de4491        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008c98:	400200        	ssr	a2
42008c9b:	919090        	srl	a9, a9
42008c9e:	9389a0        	movnez	a8, a9, a10
42008ca1:	2ce807        	bbsi	a8, 0, 42008cd1 <gpio_sleep_pulldown_en+0x61>
42008ca4:	dcef81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008ca7:	0008e0        	callx8	a8
42008caa:	df46b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008cad:	df4781        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008cb0:	1189      	s32i.n	a8, a1, 4
42008cb2:	40a382        	movi	a8, 0x340
42008cb5:	0189      	s32i.n	a8, a1, 0
42008cb7:	df4bf1        	l32r	a15, 420009e4 <_stext+0x9c4> (3c028550 <__FUNCTION__$8>)
42008cba:	0bed      	mov.n	a14, a11
42008cbc:	0add      	mov.n	a13, a10
42008cbe:	df42c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008cc1:	1a0c      	movi.n	a10, 1
42008cc3:	dcf481        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008cc6:	0008e0        	callx8	a8
42008cc9:	02a122        	movi	a2, 0x102
42008ccc:	000b86        	j	42008cfe <gpio_sleep_pulldown_en+0x8e>
42008ccf:	7c0000        	lsi	f0, a0, 0x1f0
42008cd2:	a1fb      	addi.n	a10, a1, 15
42008cd4:	81df45        	call0	41f8aacc <_coredump_iram_end+0x1c08bcc>
42008cd7:	ce          	.byte	0xce
42008cd8:	e0dd      	lsi	f13, a0, 0
42008cda:	0008      	l32i.n	a0, a0, 0
    PIN_SLP_PULLDOWN_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008cdc:	df3d81        	l32r	a8, 420009d0 <_stext+0x9b0> (3c028a44 <GPIO_PIN_MUX_REG>)
42008cdf:	a02280        	addx4	a2, a2, a8
42008ce2:	0298      	l32i.n	a9, a2, 0
42008ce4:	0020c0        	memw
42008ce7:	0988      	l32i.n	a8, a9, 0
42008ce9:	4a0c      	movi.n	a10, 4
42008ceb:	2088a0        	or	a8, a8, a10
42008cee:	0020c0        	memw
42008cf1:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42008cf3:	df3da1        	l32r	a10, 420009e8 <_stext+0x9c8> (3fc925ec <gpio_context+0x4>)
42008cf6:	ddc781        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42008cf9:	0008e0        	callx8	a8
    return ESP_OK;
42008cfc:	020c      	movi.n	a2, 0
}
42008cfe:	f01d      	retw.n

42008d00 <gpio_sleep_pullup_en>:
{
42008d00:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008d03:	02d296        	bltz	a2, 42008d34 <gpio_sleep_pullup_en+0x34>
42008d06:	0a2c      	movi.n	a10, 32
42008d08:	10a2a0        	and	a10, a2, a10
42008d0b:	f87c      	movi.n	a8, -1
42008d0d:	308280        	xor	a8, a2, a8
42008d10:	de2491        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008d13:	401800        	ssl	a8
42008d16:	a19900        	sll	a9, a9
42008d19:	de2281        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008d1c:	400200        	ssr	a2
42008d1f:	918080        	srl	a8, a8
42008d22:	208980        	or	a8, a9, a8
42008d25:	de2091        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008d28:	400200        	ssr	a2
42008d2b:	919090        	srl	a9, a9
42008d2e:	9389a0        	movnez	a8, a9, a10
42008d31:	2ce807        	bbsi	a8, 0, 42008d61 <gpio_sleep_pullup_en+0x61>
42008d34:	dccb81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008d37:	0008e0        	callx8	a8
42008d3a:	df22b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008d3d:	df2381        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008d40:	1189      	s32i.n	a8, a1, 4
42008d42:	2aa382        	movi	a8, 0x32a
42008d45:	0189      	s32i.n	a8, a1, 0
42008d47:	df29f1        	l32r	a15, 420009ec <_stext+0x9cc> (3c028538 <__FUNCTION__$7>)
42008d4a:	0bed      	mov.n	a14, a11
42008d4c:	0add      	mov.n	a13, a10
42008d4e:	df1ec1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008d51:	1a0c      	movi.n	a10, 1
42008d53:	dcd081        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008d56:	0008e0        	callx8	a8
42008d59:	02a122        	movi	a2, 0x102
42008d5c:	000b86        	j	42008d8e <gpio_sleep_pullup_en+0x8e>
42008d5f:	7c0000        	lsi	f0, a0, 0x1f0
42008d62:	a1fb      	addi.n	a10, a1, 15
42008d64:	81df21        	l32r	a2, 41fe94e0 <_coredump_iram_end+0x1c675e0>
42008d67:	ddaa      	add.n	a13, a13, a10
42008d69:	0008e0        	callx8	a8
    PIN_SLP_PULLUP_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008d6c:	df1981        	l32r	a8, 420009d0 <_stext+0x9b0> (3c028a44 <GPIO_PIN_MUX_REG>)
42008d6f:	a02280        	addx4	a2, a2, a8
42008d72:	0298      	l32i.n	a9, a2, 0
42008d74:	0020c0        	memw
42008d77:	0988      	l32i.n	a8, a9, 0
42008d79:	8a0c      	movi.n	a10, 8
42008d7b:	2088a0        	or	a8, a8, a10
42008d7e:	0020c0        	memw
42008d81:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42008d83:	df19a1        	l32r	a10, 420009e8 <_stext+0x9c8> (3fc925ec <gpio_context+0x4>)
42008d86:	dda381        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42008d89:	0008e0        	callx8	a8
    return ESP_OK;
42008d8c:	020c      	movi.n	a2, 0
}
42008d8e:	f01d      	retw.n

42008d90 <gpio_sleep_pulldown_dis>:
{
42008d90:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008d93:	02d296        	bltz	a2, 42008dc4 <gpio_sleep_pulldown_dis+0x34>
42008d96:	0a2c      	movi.n	a10, 32
42008d98:	10a2a0        	and	a10, a2, a10
42008d9b:	f87c      	movi.n	a8, -1
42008d9d:	308280        	xor	a8, a2, a8
42008da0:	de0091        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008da3:	401800        	ssl	a8
42008da6:	a19900        	sll	a9, a9
42008da9:	ddfe81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008dac:	400200        	ssr	a2
42008daf:	918080        	srl	a8, a8
42008db2:	208980        	or	a8, a9, a8
42008db5:	ddfc91        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008db8:	400200        	ssr	a2
42008dbb:	919090        	srl	a9, a9
42008dbe:	9389a0        	movnez	a8, a9, a10
42008dc1:	2ae807        	bbsi	a8, 0, 42008def <gpio_sleep_pulldown_dis+0x5f>
42008dc4:	dca781        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008dc7:	0008e0        	callx8	a8
42008dca:	defeb1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008dcd:	deff81        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008dd0:	1189      	s32i.n	a8, a1, 4
42008dd2:	4ba382        	movi	a8, 0x34b
42008dd5:	0189      	s32i.n	a8, a1, 0
42008dd7:	df06f1        	l32r	a15, 420009f0 <_stext+0x9d0> (3c028520 <__FUNCTION__$6>)
42008dda:	0bed      	mov.n	a14, a11
42008ddc:	0add      	mov.n	a13, a10
42008dde:	defac1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008de1:	1a0c      	movi.n	a10, 1
42008de3:	dcac81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008de6:	0008e0        	callx8	a8
42008de9:	02a122        	movi	a2, 0x102
42008dec:	000b06        	j	42008e1c <gpio_sleep_pulldown_dis+0x8c>
42008def:	fb7c      	movi.n	a11, -1
42008df1:	defda1        	l32r	a10, 420009e8 <_stext+0x9c8> (3fc925ec <gpio_context+0x4>)
42008df4:	dd8781        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42008df7:	0008e0        	callx8	a8
    PIN_SLP_PULLDOWN_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008dfa:	def581        	l32r	a8, 420009d0 <_stext+0x9b0> (3c028a44 <GPIO_PIN_MUX_REG>)
42008dfd:	a02280        	addx4	a2, a2, a8
42008e00:	0298      	l32i.n	a9, a2, 0
42008e02:	0020c0        	memw
42008e05:	0988      	l32i.n	a8, a9, 0
42008e07:	ba7c      	movi.n	a10, -5
42008e09:	1088a0        	and	a8, a8, a10
42008e0c:	0020c0        	memw
42008e0f:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42008e11:	def5a1        	l32r	a10, 420009e8 <_stext+0x9c8> (3fc925ec <gpio_context+0x4>)
42008e14:	dd8081        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42008e17:	0008e0        	callx8	a8
    return ESP_OK;
42008e1a:	020c      	movi.n	a2, 0
}
42008e1c:	f01d      	retw.n
	...

42008e20 <gpio_sleep_pullup_dis>:
{
42008e20:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008e23:	02d296        	bltz	a2, 42008e54 <gpio_sleep_pullup_dis+0x34>
42008e26:	0a2c      	movi.n	a10, 32
42008e28:	10a2a0        	and	a10, a2, a10
42008e2b:	f87c      	movi.n	a8, -1
42008e2d:	308280        	xor	a8, a2, a8
42008e30:	dddc91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008e33:	401800        	ssl	a8
42008e36:	a19900        	sll	a9, a9
42008e39:	ddda81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008e3c:	400200        	ssr	a2
42008e3f:	918080        	srl	a8, a8
42008e42:	208980        	or	a8, a9, a8
42008e45:	ddd891        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008e48:	400200        	ssr	a2
42008e4b:	919090        	srl	a9, a9
42008e4e:	9389a0        	movnez	a8, a9, a10
42008e51:	2ce807        	bbsi	a8, 0, 42008e81 <gpio_sleep_pullup_dis+0x61>
42008e54:	dc8381        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008e57:	0008e0        	callx8	a8
42008e5a:	dedab1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008e5d:	dedb81        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008e60:	1189      	s32i.n	a8, a1, 4
42008e62:	35a382        	movi	a8, 0x335
42008e65:	0189      	s32i.n	a8, a1, 0
42008e67:	dee3f1        	l32r	a15, 420009f4 <_stext+0x9d4> (3c028508 <__FUNCTION__$5>)
42008e6a:	0bed      	mov.n	a14, a11
42008e6c:	0add      	mov.n	a13, a10
42008e6e:	ded6c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008e71:	1a0c      	movi.n	a10, 1
42008e73:	dc8881        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008e76:	0008e0        	callx8	a8
42008e79:	02a122        	movi	a2, 0x102
42008e7c:	000b86        	j	42008eae <gpio_sleep_pullup_dis+0x8e>
42008e7f:	7c0000        	lsi	f0, a0, 0x1f0
42008e82:	a1fb      	addi.n	a10, a1, 15
42008e84:	ded9      	s32i.n	a13, a14, 52
42008e86:	dd6281        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42008e89:	0008e0        	callx8	a8
    PIN_SLP_PULLUP_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
42008e8c:	ded181        	l32r	a8, 420009d0 <_stext+0x9b0> (3c028a44 <GPIO_PIN_MUX_REG>)
42008e8f:	a02280        	addx4	a2, a2, a8
42008e92:	0298      	l32i.n	a9, a2, 0
42008e94:	0020c0        	memw
42008e97:	0988      	l32i.n	a8, a9, 0
42008e99:	7a7c      	movi.n	a10, -9
42008e9b:	1088a0        	and	a8, a8, a10
42008e9e:	0020c0        	memw
42008ea1:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42008ea3:	ded1a1        	l32r	a10, 420009e8 <_stext+0x9c8> (3fc925ec <gpio_context+0x4>)
42008ea6:	dd5b81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42008ea9:	0008e0        	callx8	a8
    return ESP_OK;
42008eac:	020c      	movi.n	a2, 0
}
42008eae:	f01d      	retw.n

42008eb0 <gpio_sleep_set_direction>:

esp_err_t gpio_sleep_set_direction(gpio_num_t gpio_num, gpio_mode_t mode)
{
42008eb0:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008eb3:	02d296        	bltz	a2, 42008ee4 <gpio_sleep_set_direction+0x34>
42008eb6:	0a2c      	movi.n	a10, 32
42008eb8:	10a2a0        	and	a10, a2, a10
42008ebb:	f87c      	movi.n	a8, -1
42008ebd:	308280        	xor	a8, a2, a8
42008ec0:	ddb891        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008ec3:	401800        	ssl	a8
42008ec6:	a19900        	sll	a9, a9
42008ec9:	ddb681        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008ecc:	400200        	ssr	a2
42008ecf:	918080        	srl	a8, a8
42008ed2:	208980        	or	a8, a9, a8
42008ed5:	ddb491        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008ed8:	400200        	ssr	a2
42008edb:	919090        	srl	a9, a9
42008ede:	9389a0        	movnez	a8, a9, a10
42008ee1:	2ce807        	bbsi	a8, 0, 42008f11 <gpio_sleep_set_direction+0x61>
42008ee4:	dc5f81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008ee7:	0008e0        	callx8	a8
42008eea:	deb6b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008eed:	deb781        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008ef0:	1189      	s32i.n	a8, a1, 4
42008ef2:	72a382        	movi	a8, 0x372
42008ef5:	0189      	s32i.n	a8, a1, 0
42008ef7:	dec0f1        	l32r	a15, 420009f8 <_stext+0x9d8> (3c0285f0 <__FUNCTION__$14>)
42008efa:	0bed      	mov.n	a14, a11
42008efc:	0add      	mov.n	a13, a10
42008efe:	deb2c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008f01:	1a0c      	movi.n	a10, 1
42008f03:	dc6481        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008f06:	0008e0        	callx8	a8
42008f09:	02a122        	movi	a2, 0x102
42008f0c:	000a86        	j	42008f3a <gpio_sleep_set_direction+0x8a>
42008f0f:	070000        	lsi	f0, a0, 28
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t ret = ESP_OK;

    if (mode & GPIO_MODE_DEF_INPUT) {
42008f12:	ad0863        	lsi	f6, a8, 0x2b4
        gpio_sleep_input_enable(gpio_num);
42008f15:	b6a502        	movi	a0, 0x5b6
42008f18:	ff          	.byte	0xff
42008f19:	000186        	j	42008f23 <gpio_sleep_set_direction+0x73>
42008f1c:	a22000        	muluh	a2, a0, a0
    } else {
        gpio_sleep_input_disable(gpio_num);
42008f1f:	bda520        	lsi	f2, a5, 0x2f4
42008f22:	ff          	.byte	0xff
    }

    if (mode & GPIO_MODE_DEF_OUTPUT) {
42008f23:	0a6317        	bbci	a3, 1, 42008f31 <gpio_sleep_set_direction+0x81>
        gpio_sleep_output_enable(gpio_num);
42008f26:	20a220        	or	a10, a2, a2
42008f29:	ffc4e5        	call8	42008b78 <gpio_sleep_output_enable>
    } else {
        gpio_sleep_output_disable(gpio_num);
    }

    return ret;
42008f2c:	020c      	movi.n	a2, 0
42008f2e:	000206        	j	42008f3a <gpio_sleep_set_direction+0x8a>
        gpio_sleep_output_disable(gpio_num);
42008f31:	20a220        	or	a10, a2, a2
42008f34:	ffcbe5        	call8	42008bf4 <gpio_sleep_output_disable>
    return ret;
42008f37:	00a022        	movi	a2, 0
}
42008f3a:	000090        	retw
42008f3d:	000000        	ill

42008f40 <gpio_sleep_set_pull_mode>:

esp_err_t gpio_sleep_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
42008f40:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42008f43:	02d296        	bltz	a2, 42008f74 <gpio_sleep_set_pull_mode+0x34>
42008f46:	0a2c      	movi.n	a10, 32
42008f48:	10a2a0        	and	a10, a2, a10
42008f4b:	f87c      	movi.n	a8, -1
42008f4d:	308280        	xor	a8, a2, a8
42008f50:	dd9491        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42008f53:	401800        	ssl	a8
42008f56:	a19900        	sll	a9, a9
42008f59:	dd9281        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42008f5c:	400200        	ssr	a2
42008f5f:	918080        	srl	a8, a8
42008f62:	208980        	or	a8, a9, a8
42008f65:	dd9091        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42008f68:	400200        	ssr	a2
42008f6b:	919090        	srl	a9, a9
42008f6e:	9389a0        	movnez	a8, a9, a10
42008f71:	2be807        	bbsi	a8, 0, 42008fa0 <gpio_sleep_set_pull_mode+0x60>
42008f74:	dc3b81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42008f77:	0008e0        	callx8	a8
42008f7a:	de92b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008f7d:	de9381        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42008f80:	1189      	s32i.n	a8, a1, 4
42008f82:	8ca382        	movi	a8, 0x38c
42008f85:	0189      	s32i.n	a8, a1, 0
42008f87:	de9df1        	l32r	a15, 420009fc <_stext+0x9dc> (3c028568 <__FUNCTION__$9>)
42008f8a:	0bed      	mov.n	a14, a11
42008f8c:	0add      	mov.n	a13, a10
42008f8e:	de8ec1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008f91:	1a0c      	movi.n	a10, 1
42008f93:	dc4081        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008f96:	0008e0        	callx8	a8
42008f99:	02a122        	movi	a2, 0x102
42008f9c:	002ac6        	j	4200904b <gpio_sleep_set_pull_mode+0x10b>
42008f9f:	43b600        	min	a11, a6, a0
    GPIO_CHECK(pull <= GPIO_FLOATING, "GPIO pull mode error", ESP_ERR_INVALID_ARG);
42008fa2:	812c      	movi.n	a1, 40
42008fa4:	2f          	.byte	0x2f
42008fa5:	e0dc      	bnez.n	a0, 42008fc7 <gpio_sleep_set_pull_mode+0x87>
42008fa7:	0008      	l32i.n	a0, a0, 0
42008fa9:	de86b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42008fac:	de9581        	l32r	a8, 42000a00 <_stext+0x9e0> (3c025b90 <_flash_rodata_start+0x5a70>)
42008faf:	1189      	s32i.n	a8, a1, 4
42008fb1:	8da382        	movi	a8, 0x38d
42008fb4:	0189      	s32i.n	a8, a1, 0
42008fb6:	de91f1        	l32r	a15, 420009fc <_stext+0x9dc> (3c028568 <__FUNCTION__$9>)
42008fb9:	0bed      	mov.n	a14, a11
42008fbb:	0add      	mov.n	a13, a10
42008fbd:	de82c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42008fc0:	1a0c      	movi.n	a10, 1
42008fc2:	dc3481        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42008fc5:	0008e0        	callx8	a8
42008fc8:	02a122        	movi	a2, 0x102
42008fcb:	001f06        	j	4200904b <gpio_sleep_set_pull_mode+0x10b>
42008fce:	260000        	lsi	f0, a0, 152
    esp_err_t ret = ESP_OK;

    switch (pull) {
42008fd1:	f63523        	lsi	f2, a5, 0x3d8
42008fd4:	8c0933        	lsi	f3, a9, 0x230
42008fd7:	1326c3        	lsi	f12, a6, 76
42008fda:	061c      	movi.n	a6, 16
42008fdc:	000013        	lsi	f1, a0, 0
42008fdf:	332600        	clamps	a2, a6, 7
42008fe2:	110636        	entry	a6, 0x880
42008fe5:	a22000        	muluh	a2, a0, a0
    case GPIO_PULLUP_ONLY:
        gpio_sleep_pulldown_dis(gpio_num);
42008fe8:	da6520        	ufloat.s	f6, a5, 2
42008feb:	ff          	.byte	0xff
        gpio_sleep_pullup_en(gpio_num);
42008fec:	20a220        	or	a10, a2, a2
42008fef:	ffd125        	call8	42008d00 <gpio_sleep_pullup_en>
    esp_err_t ret = ESP_OK;
42008ff2:	020c      	movi.n	a2, 0
        break;
42008ff4:	0014c6        	j	4200904b <gpio_sleep_set_pull_mode+0x10b>
42008ff7:	a22000        	muluh	a2, a0, a0

    case GPIO_PULLDOWN_ONLY:
        gpio_sleep_pulldown_en(gpio_num);
42008ffa:	c76520        	lsi	f2, a5, 0x31c
42008ffd:	ff          	.byte	0xff
        gpio_sleep_pullup_dis(gpio_num);
42008ffe:	20a220        	or	a10, a2, a2
42009001:	ffe1e5        	call8	42008e20 <gpio_sleep_pullup_dis>
    esp_err_t ret = ESP_OK;
42009004:	020c      	movi.n	a2, 0
        break;
42009006:	001046        	j	4200904b <gpio_sleep_set_pull_mode+0x10b>

    case GPIO_PULLUP_PULLDOWN:
        gpio_sleep_pulldown_en(gpio_num);
42009009:	20a220        	or	a10, a2, a2
4200900c:	ffc625        	call8	42008c70 <gpio_sleep_pulldown_en>
        gpio_sleep_pullup_en(gpio_num);
4200900f:	20a220        	or	a10, a2, a2
42009012:	ffcee5        	call8	42008d00 <gpio_sleep_pullup_en>
    esp_err_t ret = ESP_OK;
42009015:	020c      	movi.n	a2, 0
        break;
42009017:	000c06        	j	4200904b <gpio_sleep_set_pull_mode+0x10b>

    case GPIO_FLOATING:
        gpio_sleep_pulldown_dis(gpio_num);
4200901a:	20a220        	or	a10, a2, a2
4200901d:	ffd725        	call8	42008d90 <gpio_sleep_pulldown_dis>
        gpio_sleep_pullup_dis(gpio_num);
42009020:	20a220        	or	a10, a2, a2
42009023:	ffdfe5        	call8	42008e20 <gpio_sleep_pullup_dis>
    esp_err_t ret = ESP_OK;
42009026:	020c      	movi.n	a2, 0
        break;
42009028:	0007c6        	j	4200904b <gpio_sleep_set_pull_mode+0x10b>

    default:
        ESP_LOGE(GPIO_TAG, "Unknown pull up/down mode,gpio_num=%u,pull=%u", gpio_num, pull);
4200902b:	dc0d81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200902e:	0008e0        	callx8	a8
42009031:	de64b1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
42009034:	0139      	s32i.n	a3, a1, 0
42009036:	02fd      	mov.n	a15, a2
42009038:	0bed      	mov.n	a14, a11
4200903a:	0add      	mov.n	a13, a10
4200903c:	de72c1        	l32r	a12, 42000a04 <_stext+0x9e4> (3c025ba8 <_flash_rodata_start+0x5a88>)
4200903f:	01a0a2        	movi	a10, 1
42009042:	dc1481        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009045:	0008e0        	callx8	a8
        ret = ESP_ERR_INVALID_ARG;
42009048:	02a122        	movi	a2, 0x102
        break;
    }

    return ret;
}
4200904b:	f01d      	retw.n
4200904d:	000000        	ill

42009050 <gpio_sleep_sel_en>:

esp_err_t gpio_sleep_sel_en(gpio_num_t gpio_num)
{
42009050:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42009053:	02d296        	bltz	a2, 42009084 <gpio_sleep_sel_en+0x34>
42009056:	0a2c      	movi.n	a10, 32
42009058:	10a2a0        	and	a10, a2, a10
4200905b:	f87c      	movi.n	a8, -1
4200905d:	308280        	xor	a8, a2, a8
42009060:	dd5091        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
42009063:	401800        	ssl	a8
42009066:	a19900        	sll	a9, a9
42009069:	dd4e81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200906c:	400200        	ssr	a2
4200906f:	918080        	srl	a8, a8
42009072:	208980        	or	a8, a9, a8
42009075:	dd4c91        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42009078:	400200        	ssr	a2
4200907b:	919090        	srl	a9, a9
4200907e:	9389a0        	movnez	a8, a9, a10
42009081:	2ce807        	bbsi	a8, 0, 420090b1 <gpio_sleep_sel_en+0x61>
42009084:	dbf781        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009087:	0008e0        	callx8	a8
4200908a:	de4eb1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
4200908d:	de4f81        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42009090:	1189      	s32i.n	a8, a1, 4
42009092:	b0a382        	movi	a8, 0x3b0
42009095:	0189      	s32i.n	a8, a1, 0
42009097:	de5cf1        	l32r	a15, 42000a08 <_stext+0x9e8> (3c0284f4 <__FUNCTION__$4>)
4200909a:	0bed      	mov.n	a14, a11
4200909c:	0add      	mov.n	a13, a10
4200909e:	de4ac1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
420090a1:	1a0c      	movi.n	a10, 1
420090a3:	dbfc81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
420090a6:	0008e0        	callx8	a8
420090a9:	02a122        	movi	a2, 0x102
420090ac:	000b86        	j	420090de <gpio_sleep_sel_en+0x8e>
420090af:	7c0000        	lsi	f0, a0, 0x1f0
420090b2:	a1fb      	addi.n	a10, a1, 15
420090b4:	de4d      	lsi	f4, a14, 56
420090b6:	dcd681        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420090b9:	0008e0        	callx8	a8
    PIN_SLP_SEL_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
420090bc:	de4581        	l32r	a8, 420009d0 <_stext+0x9b0> (3c028a44 <GPIO_PIN_MUX_REG>)
420090bf:	a02280        	addx4	a2, a2, a8
420090c2:	0298      	l32i.n	a9, a2, 0
420090c4:	0020c0        	memw
420090c7:	0988      	l32i.n	a8, a9, 0
420090c9:	2a0c      	movi.n	a10, 2
420090cb:	2088a0        	or	a8, a8, a10
420090ce:	0020c0        	memw
420090d1:	0989      	s32i.n	a8, a9, 0

    portENTER_CRITICAL(&gpio_context.gpio_spinlock);
    gpio_hal_sleep_sel_en(gpio_context.gpio_hal, gpio_num);
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
420090d3:	de45a1        	l32r	a10, 420009e8 <_stext+0x9c8> (3fc925ec <gpio_context+0x4>)
420090d6:	dccf81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
420090d9:	0008e0        	callx8	a8

    return ESP_OK;
420090dc:	020c      	movi.n	a2, 0
}
420090de:	f01d      	retw.n

420090e0 <gpio_sleep_sel_dis>:

esp_err_t gpio_sleep_sel_dis(gpio_num_t gpio_num)
{
420090e0:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420090e3:	02d296        	bltz	a2, 42009114 <gpio_sleep_sel_dis+0x34>
420090e6:	0a2c      	movi.n	a10, 32
420090e8:	10a2a0        	and	a10, a2, a10
420090eb:	f87c      	movi.n	a8, -1
420090ed:	308280        	xor	a8, a2, a8
420090f0:	dd2c91        	l32r	a9, 420005a0 <_stext+0x580> (3fffe <UserFrameTotalSize+0x3fefe>)
420090f3:	401800        	ssl	a8
420090f6:	a19900        	sll	a9, a9
420090f9:	dd2a81        	l32r	a8, 420005a4 <_stext+0x584> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
420090fc:	400200        	ssr	a2
420090ff:	918080        	srl	a8, a8
42009102:	208980        	or	a8, a9, a8
42009105:	dd2891        	l32r	a9, 420005a8 <_stext+0x588> (1ffff <UserFrameTotalSize+0x1feff>)
42009108:	400200        	ssr	a2
4200910b:	919090        	srl	a9, a9
4200910e:	9389a0        	movnez	a8, a9, a10
42009111:	2ce807        	bbsi	a8, 0, 42009141 <gpio_sleep_sel_dis+0x61>
42009114:	dbd381        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009117:	0008e0        	callx8	a8
4200911a:	de2ab1        	l32r	a11, 420009c4 <_stext+0x9a4> (3c025b40 <_flash_rodata_start+0x5a20>)
4200911d:	de2b81        	l32r	a8, 420009cc <_stext+0x9ac> (3c025b60 <_flash_rodata_start+0x5a40>)
42009120:	1189      	s32i.n	a8, a1, 4
42009122:	bba382        	movi	a8, 0x3bb
42009125:	0189      	s32i.n	a8, a1, 0
42009127:	de39f1        	l32r	a15, 42000a0c <_stext+0x9ec> (3c0284e0 <__FUNCTION__$3>)
4200912a:	0bed      	mov.n	a14, a11
4200912c:	0add      	mov.n	a13, a10
4200912e:	de26c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c025b48 <_flash_rodata_start+0x5a28>)
42009131:	1a0c      	movi.n	a10, 1
42009133:	dbd881        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009136:	0008e0        	callx8	a8
42009139:	02a122        	movi	a2, 0x102
4200913c:	000b86        	j	4200916e <gpio_sleep_sel_dis+0x8e>
4200913f:	7c0000        	lsi	f0, a0, 0x1f0
42009142:	a1fb      	addi.n	a10, a1, 15
42009144:	de29      	s32i.n	a2, a14, 52
42009146:	dcb281        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42009149:	0008e0        	callx8	a8
    PIN_SLP_SEL_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200914c:	de2181        	l32r	a8, 420009d0 <_stext+0x9b0> (3c028a44 <GPIO_PIN_MUX_REG>)
4200914f:	a02280        	addx4	a2, a2, a8
42009152:	0298      	l32i.n	a9, a2, 0
42009154:	0020c0        	memw
42009157:	0988      	l32i.n	a8, a9, 0
42009159:	da7c      	movi.n	a10, -3
4200915b:	1088a0        	and	a8, a8, a10
4200915e:	0020c0        	memw
42009161:	0989      	s32i.n	a8, a9, 0

    portENTER_CRITICAL(&gpio_context.gpio_spinlock);
    gpio_hal_sleep_sel_dis(gpio_context.gpio_hal, gpio_num);
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42009163:	de21a1        	l32r	a10, 420009e8 <_stext+0x9c8> (3fc925ec <gpio_context+0x4>)
42009166:	dcab81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42009169:	0008e0        	callx8	a8

    return ESP_OK;
4200916c:	020c      	movi.n	a2, 0
}
4200916e:	f01d      	retw.n

42009170 <bootloader_init_mem>:
#if SOC_APM_SUPPORTED
#include "hal/apm_hal.h"
#endif

void bootloader_init_mem(void)
{
42009170:	004136        	entry	a1, 32
#endif
#endif

#ifdef CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE
    // protect memory region
    esp_cpu_configure_region_protection();
42009173:	00f565        	call8	4200a0c8 <esp_cpu_configure_region_protection>
#endif
}
42009176:	f01d      	retw.n

42009178 <bootloader_flash_update_id>:
#define FLASH_CS_SETUP_TIME 3
#define FLASH_CS_HOLD_TIME  3
#define FLASH_CS_HOLD_DELAY 2

void bootloader_flash_update_id()
{
42009178:	004136        	entry	a1, 32
    esp_rom_spiflash_chip_t *chip = &rom_spiflash_legacy_data->chip;
4200917b:	de2581        	l32r	a8, 42000a10 <_stext+0x9f0> (3fceffe4 <rom_spiflash_legacy_data>)
4200917e:	0878      	l32i.n	a7, a8, 0
    chip->device_id = bootloader_read_flash_id();
42009180:	de2581        	l32r	a8, 42000a14 <_stext+0x9f4> (403775b0 <bootloader_read_flash_id>)
42009183:	0008e0        	callx8	a8
42009186:	07a9      	s32i.n	a10, a7, 0
}
42009188:	f01d      	retw.n
	...

4200918c <s_get_bus_mask>:
{
4200918c:	004136        	entry	a1, 32
    uint32_t vaddr_end = vaddr_start + len - 1;
4200918f:	323a      	add.n	a3, a2, a3
42009191:	330b      	addi.n	a3, a3, -1
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
42009193:	de2191        	l32r	a9, 42000a18 <_stext+0x9f8> (41ffffff <_coredump_iram_end+0x1c7e0ff>)
42009196:	629920        	lsi	f2, a9, 0x188
42009199:	de2081        	l32r	a8, 42000a1c <_stext+0x9fc> (43ffffff <_etext+0x1fe9da9>)
4200919c:	628830        	lsi	f3, a8, 0x188
4200919f:	880b      	addi.n	a8, a8, -1
420091a1:	608080        	neg	a8, a8
420091a4:	258897        	bany	a8, a9, 420091cd <s_get_bus_mask+0x41>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
420091a7:	de1e91        	l32r	a9, 42000a20 <_stext+0xa00> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
420091aa:	629920        	lsi	f2, a9, 0x188
420091ad:	de1d81        	l32r	a8, 42000a24 <_stext+0xa04> (3dffffff <_esp_system_init_fn_array_end+0x1fd608b>)
420091b0:	628830        	lsi	f3, a8, 0x188
420091b3:	880b      	addi.n	a8, a8, -1
420091b5:	608080        	neg	a8, a8
420091b8:	168897        	bany	a8, a9, 420091d2 <s_get_bus_mask+0x46>
        HAL_ASSERT(0);      //Out of region
420091bb:	de1bd1        	l32r	a13, 42000a28 <_stext+0xa08> (3c024598 <_flash_rodata_start+0x4478>)
420091be:	de1bc1        	l32r	a12, 42000a2c <_stext+0xa0c> (3c02868c <__func__$9>)
420091c1:	3aa2b2        	movi	a11, 0x23a
420091c4:	de1ba1        	l32r	a10, 42000a30 <_stext+0xa10> (3c020480 <_flash_rodata_start+0x360>)
420091c7:	dbbe81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420091ca:	0008e0        	callx8	a8
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_IBUS0);    //Both cores have their own IBUS0
420091cd:	120c      	movi.n	a2, 1
420091cf:	000046        	j	420091d4 <s_get_bus_mask+0x48>
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_DBUS0);    //Both cores have their own DBUS0
420091d2:	820c      	movi.n	a2, 8
}
420091d4:	f01d      	retw.n
	...

420091d8 <s_reserve_irom_region>:
{
420091d8:	004136        	entry	a1, 32
    size_t irom_len_to_reserve = (uint32_t)&_instruction_reserved_end - (uint32_t)&_instruction_reserved_start;
420091db:	de1681        	l32r	a8, 42000a34 <_stext+0xa14> (42016256 <_etext>)
420091de:	de16a1        	l32r	a10, 42000a38 <_stext+0xa18> (42000020 <_stext>)
420091e1:	c0b8a0        	sub	a11, a8, a10
    return vaddr & SOC_MMU_LINEAR_ADDR_MASK;
420091e4:	dc3e91        	l32r	a9, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
420091e7:	108890        	and	a8, a8, a9
420091ea:	109a90        	and	a9, a10, a9
    assert((mmu_ll_vaddr_to_laddr((uint32_t)&_instruction_reserved_end) - mmu_ll_vaddr_to_laddr((uint32_t)&_instruction_reserved_start)) == irom_len_to_reserve);
420091ed:	c08890        	sub	a8, a8, a9
420091f0:	1118b7        	beq	a8, a11, 42009205 <s_reserve_irom_region+0x2d>
420091f3:	de12d1        	l32r	a13, 42000a3c <_stext+0xa1c> (3c025c64 <_flash_rodata_start+0x5b44>)
420091f6:	de12c1        	l32r	a12, 42000a40 <_stext+0xa20> (3c0286a0 <__func__$10>)
420091f9:	8ca0b2        	movi	a11, 140
420091fc:	de12a1        	l32r	a10, 42000a44 <_stext+0xa24> (3c025d14 <_flash_rodata_start+0x5bf4>)
420091ff:	dbb081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42009202:	0008e0        	callx8	a8
    irom_len_to_reserve += (uint32_t)&_instruction_reserved_start - ALIGN_DOWN_BY((uint32_t)&_instruction_reserved_start, CONFIG_MMU_PAGE_SIZE);
42009205:	f470a0        	extui	a7, a10, 0, 16
42009208:	8077b0        	add	a7, a7, a11
    irom_len_to_reserve = ALIGN_UP_BY(irom_len_to_reserve, CONFIG_MMU_PAGE_SIZE);
4200920b:	de0f81        	l32r	a8, 42000a48 <_stext+0xa28> (ffff <UserFrameTotalSize+0xfeff>)
4200920e:	807780        	add	a7, a7, a8
42009211:	f57070        	extui	a7, a7, 16, 16
42009214:	117700        	slli	a7, a7, 16
    cache_bus_mask_t bus_mask = s_get_bus_mask((uint32_t)&_instruction_reserved_start, irom_len_to_reserve);
42009217:	20b770        	or	a11, a7, a7
4200921a:	fff725        	call8	4200918c <s_get_bus_mask>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200921d:	080c      	movi.n	a8, 0
4200921f:	000bc6        	j	42009252 <s_reserve_irom_region+0x7a>
42009222:	800000        	add	a0, a0, a0
        if (bus_mask & hw_mem_regions[i].bus_id) {
42009225:	a098      	l32i.n	a9, a0, 40
42009227:	b09920        	addx8	a9, a9, a2
4200922a:	09b8      	l32i.n	a11, a9, 0
4200922c:	200ba7        	bnone	a11, a10, 42009250 <s_reserve_irom_region+0x78>
            if (hw_mem_regions[i].region_size <= irom_len_to_reserve) {
4200922f:	39b8      	l32i.n	a11, a9, 12
42009231:	0d37b7        	bltu	a7, a11, 42009242 <s_reserve_irom_region+0x6a>
                hw_mem_regions[i].free_head = hw_mem_regions[i].end;
42009234:	29c8      	l32i.n	a12, a9, 8
42009236:	49c9      	s32i.n	a12, a9, 16
                hw_mem_regions[i].max_slot_size = 0;
42009238:	0c0c      	movi.n	a12, 0
4200923a:	59c9      	s32i.n	a12, a9, 20
                irom_len_to_reserve -= hw_mem_regions[i].region_size;
4200923c:	c077b0        	sub	a7, a7, a11
4200923f:	000346        	j	42009250 <s_reserve_irom_region+0x78>
                hw_mem_regions[i].free_head = hw_mem_regions[i].free_head + irom_len_to_reserve;
42009242:	49b8      	l32i.n	a11, a9, 16
42009244:	bb7a      	add.n	a11, a11, a7
42009246:	49b9      	s32i.n	a11, a9, 16
                hw_mem_regions[i].max_slot_size -= irom_len_to_reserve;
42009248:	59b8      	l32i.n	a11, a9, 20
4200924a:	c0bb70        	sub	a11, a11, a7
4200924d:	0569b2        	s32i	a11, a9, 20
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009250:	881b      	addi.n	a8, a8, 1
42009252:	fce816        	beqz	a8, 42009224 <s_reserve_irom_region+0x4c>
}
42009255:	f01d      	retw.n
	...

42009258 <s_reserve_drom_region>:
{
42009258:	004136        	entry	a1, 32
    size_t drom_len_to_reserve = (uint32_t)&_rodata_reserved_end - (uint32_t)&_rodata_reserved_start;
4200925b:	ddfc81        	l32r	a8, 42000a4c <_stext+0xa2c> (3c029f74 <_esp_system_init_fn_array_end>)
4200925e:	ddfca1        	l32r	a10, 42000a50 <_stext+0xa30> (3c020020 <esp_app_desc>)
42009261:	c0b8a0        	sub	a11, a8, a10
42009264:	dc1e91        	l32r	a9, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
42009267:	108890        	and	a8, a8, a9
4200926a:	109a90        	and	a9, a10, a9
    assert((mmu_ll_vaddr_to_laddr((uint32_t)&_rodata_reserved_end) - mmu_ll_vaddr_to_laddr((uint32_t)&_rodata_reserved_start)) == drom_len_to_reserve);
4200926d:	c08890        	sub	a8, a8, a9
42009270:	1118b7        	beq	a8, a11, 42009285 <s_reserve_drom_region+0x2d>
42009273:	ddf8d1        	l32r	a13, 42000a54 <_stext+0xa34> (3c025d24 <_flash_rodata_start+0x5c04>)
42009276:	ddf8c1        	l32r	a12, 42000a58 <_stext+0xa38> (3c028674 <__func__$8>)
42009279:	a8a0b2        	movi	a11, 168
4200927c:	ddf2a1        	l32r	a10, 42000a44 <_stext+0xa24> (3c025d14 <_flash_rodata_start+0x5bf4>)
4200927f:	db9081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42009282:	0008e0        	callx8	a8
    drom_len_to_reserve += (uint32_t)&_rodata_reserved_start - ALIGN_DOWN_BY((uint32_t)&_rodata_reserved_start, CONFIG_MMU_PAGE_SIZE);
42009285:	f470a0        	extui	a7, a10, 0, 16
42009288:	8077b0        	add	a7, a7, a11
    drom_len_to_reserve = ALIGN_UP_BY(drom_len_to_reserve, CONFIG_MMU_PAGE_SIZE);
4200928b:	ddef81        	l32r	a8, 42000a48 <_stext+0xa28> (ffff <UserFrameTotalSize+0xfeff>)
4200928e:	807780        	add	a7, a7, a8
42009291:	f57070        	extui	a7, a7, 16, 16
42009294:	117700        	slli	a7, a7, 16
    cache_bus_mask_t bus_mask = s_get_bus_mask((uint32_t)&_rodata_reserved_start, drom_len_to_reserve);
42009297:	20b770        	or	a11, a7, a7
4200929a:	ffef25        	call8	4200918c <s_get_bus_mask>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200929d:	080c      	movi.n	a8, 0
4200929f:	000bc6        	j	420092d2 <s_reserve_drom_region+0x7a>
420092a2:	800000        	add	a0, a0, a0
        if (bus_mask & hw_mem_regions[i].bus_id) {
420092a5:	a098      	l32i.n	a9, a0, 40
420092a7:	b09920        	addx8	a9, a9, a2
420092aa:	09b8      	l32i.n	a11, a9, 0
420092ac:	200ba7        	bnone	a11, a10, 420092d0 <s_reserve_drom_region+0x78>
            if (hw_mem_regions[i].region_size <= drom_len_to_reserve) {
420092af:	39b8      	l32i.n	a11, a9, 12
420092b1:	0d37b7        	bltu	a7, a11, 420092c2 <s_reserve_drom_region+0x6a>
                hw_mem_regions[i].free_head = hw_mem_regions[i].end;
420092b4:	29c8      	l32i.n	a12, a9, 8
420092b6:	49c9      	s32i.n	a12, a9, 16
                hw_mem_regions[i].max_slot_size = 0;
420092b8:	0c0c      	movi.n	a12, 0
420092ba:	59c9      	s32i.n	a12, a9, 20
                drom_len_to_reserve -= hw_mem_regions[i].region_size;
420092bc:	c077b0        	sub	a7, a7, a11
420092bf:	000346        	j	420092d0 <s_reserve_drom_region+0x78>
                hw_mem_regions[i].free_head = hw_mem_regions[i].free_head + drom_len_to_reserve;
420092c2:	49b8      	l32i.n	a11, a9, 16
420092c4:	bb7a      	add.n	a11, a11, a7
420092c6:	49b9      	s32i.n	a11, a9, 16
                hw_mem_regions[i].max_slot_size -= drom_len_to_reserve;
420092c8:	59b8      	l32i.n	a11, a9, 20
420092ca:	c0bb70        	sub	a11, a11, a7
420092cd:	0569b2        	s32i	a11, a9, 20
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420092d0:	881b      	addi.n	a8, a8, 1
420092d2:	fce816        	beqz	a8, 420092a4 <s_reserve_drom_region+0x4c>
}
420092d5:	f01d      	retw.n
	...

420092d8 <esp_mmu_map_init>:
{
420092d8:	00a136        	entry	a1, 80
    mem_region_t hw_mem_regions[SOC_MMU_LINEAR_ADDRESS_REGION_NUM] = {};
420092db:	8c2c      	movi.n	a12, 40
420092dd:	0b0c      	movi.n	a11, 0
420092df:	20a110        	or	a10, a1, a1
420092e2:	dc0781        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
420092e5:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
420092e8:	0a0c      	movi.n	a10, 0
420092ea:	001286        	j	42009338 <esp_mmu_map_init+0x60>
        hw_mem_regions[i].start = g_mmu_mem_regions[i].start;
420092ed:	909aa0        	addx2	a9, a10, a10
420092f0:	1189d0        	slli	a8, a9, 3
420092f3:	ddda91        	l32r	a9, 42000a5c <_stext+0xa3c> (3c0286cc <g_mmu_mem_regions>)
420092f6:	998a      	add.n	a9, a9, a8
420092f8:	09c8      	l32i.n	a12, a9, 0
420092fa:	a0baa0        	addx4	a11, a10, a10
420092fd:	118bd0        	slli	a8, a11, 3
42009300:	818a      	add.n	a8, a1, a8
42009302:	18c9      	s32i.n	a12, a8, 4
        hw_mem_regions[i].end = g_mmu_mem_regions[i].end;
42009304:	19b8      	l32i.n	a11, a9, 4
42009306:	28b9      	s32i.n	a11, a8, 8
        hw_mem_regions[i].region_size = g_mmu_mem_regions[i].size;
42009308:	29b8      	l32i.n	a11, a9, 8
4200930a:	38b9      	s32i.n	a11, a8, 12
        hw_mem_regions[i].max_slot_size = g_mmu_mem_regions[i].size;
4200930c:	58b9      	s32i.n	a11, a8, 20
        hw_mem_regions[i].free_head = g_mmu_mem_regions[i].start;
4200930e:	48c9      	s32i.n	a12, a8, 16
        hw_mem_regions[i].bus_id = g_mmu_mem_regions[i].bus_id;
42009310:	39c8      	l32i.n	a12, a9, 12
42009312:	08c9      	s32i.n	a12, a8, 0
        hw_mem_regions[i].caps = g_mmu_mem_regions[i].caps;
42009314:	59c8      	l32i.n	a12, a9, 20
42009316:	68c9      	s32i.n	a12, a8, 24
        hw_mem_regions[i].targets = g_mmu_mem_regions[i].targets;
42009318:	4998      	l32i.n	a9, a9, 16
4200931a:	076892        	s32i	a9, a8, 28
        assert(hw_mem_regions[i].region_size % CONFIG_MMU_PAGE_SIZE == 0);
4200931d:	f4b0b0        	extui	a11, a11, 0, 16
42009320:	011b16        	beqz	a11, 42009335 <esp_mmu_map_init+0x5d>
42009323:	ddcfd1        	l32r	a13, 42000a60 <_stext+0xa40> (3c025db8 <_flash_rodata_start+0x5c98>)
42009326:	ddcfc1        	l32r	a12, 42000a64 <_stext+0xa44> (3c0286b8 <__func__$11>)
42009329:	d4a0b2        	movi	a11, 212
4200932c:	ddc6a1        	l32r	a10, 42000a44 <_stext+0xa24> (3c025d14 <_flash_rodata_start+0x5bf4>)
4200932f:	db6481        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42009332:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009335:	01caa2        	addi	a10, a10, 1
42009338:	fb1a16        	beqz	a10, 420092ed <esp_mmu_map_init+0x15>
    s_reserve_irom_region(hw_mem_regions, SOC_MMU_LINEAR_ADDRESS_REGION_NUM);
4200933b:	01a0b2        	movi	a11, 1
4200933e:	01ad      	mov.n	a10, a1
42009340:	ffe965        	call8	420091d8 <s_reserve_irom_region>
    s_reserve_drom_region(hw_mem_regions, SOC_MMU_LINEAR_ADDRESS_REGION_NUM);
42009343:	1b0c      	movi.n	a11, 1
42009345:	01ad      	mov.n	a10, a1
42009347:	fff125        	call8	42009258 <s_reserve_drom_region>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200934a:	080c      	movi.n	a8, 0
    uint32_t region_num = 0;
4200934c:	085d      	mov.n	a5, a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200934e:	000406        	j	42009362 <esp_mmu_map_init+0x8a>
        if (hw_mem_regions[i].caps != MEM_REGION_MERGED) {
42009351:	a0a880        	addx4	a10, a8, a8
42009354:	119ad0        	slli	a9, a10, 3
42009357:	919a      	add.n	a9, a1, a9
42009359:	6998      	l32i.n	a9, a9, 24
4200935b:	010926        	beqi	a9, -1, 42009360 <esp_mmu_map_init+0x88>
            region_num++;
4200935e:	551b      	addi.n	a5, a5, 1
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009360:	881b      	addi.n	a8, a8, 1
42009362:	feb816        	beqz	a8, 42009351 <esp_mmu_map_init+0x79>
    s_mmu_ctx.num_regions = region_num;
42009365:	ddc081        	l32r	a8, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
42009368:	0859      	s32i.n	a5, a8, 0
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200936a:	070c      	movi.n	a7, 0
    uint32_t available_region_idx = 0;
4200936c:	076d      	mov.n	a6, a7
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200936e:	000a86        	j	4200939c <esp_mmu_map_init+0xc4>
        if (hw_mem_regions[i].caps == MEM_REGION_MERGED) {
42009371:	a09770        	addx4	a9, a7, a7
42009374:	1189d0        	slli	a8, a9, 3
42009377:	818a      	add.n	a8, a1, a8
42009379:	6888      	l32i.n	a8, a8, 24
4200937b:	1b0826        	beqi	a8, -1, 4200939a <esp_mmu_map_init+0xc2>
        memcpy(&s_mmu_ctx.mem_regions[available_region_idx], &hw_mem_regions[i], sizeof(mem_region_t));
4200937e:	a08660        	addx4	a8, a6, a6
42009381:	11a8d0        	slli	a10, a8, 3
42009384:	ddb981        	l32r	a8, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
42009387:	aa8a      	add.n	a10, a10, a8
42009389:	11b9d0        	slli	a11, a9, 3
4200938c:	8c2c      	movi.n	a12, 40
4200938e:	b1ba      	add.n	a11, a1, a11
42009390:	aa4b      	addi.n	a10, a10, 4
42009392:	db2581        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42009395:	0008e0        	callx8	a8
        available_region_idx++;
42009398:	661b      	addi.n	a6, a6, 1
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200939a:	771b      	addi.n	a7, a7, 1
4200939c:	fd1716        	beqz	a7, 42009371 <esp_mmu_map_init+0x99>
    for (int i = 0; i < available_region_idx; i++) {
4200939f:	080c      	movi.n	a8, 0
420093a1:	0007c6        	j	420093c4 <esp_mmu_map_init+0xec>
        TAILQ_INIT(&s_mmu_ctx.mem_regions[i].mem_block_head);
420093a4:	ddb1b1        	l32r	a11, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
420093a7:	a09880        	addx4	a9, a8, a8
420093aa:	11a9d0        	slli	a10, a9, 3
420093ad:	abaa      	add.n	a10, a11, a10
420093af:	090c      	movi.n	a9, 0
420093b1:	9a99      	s32i.n	a9, a10, 36
420093b3:	a0c880        	addx4	a12, a8, a8
420093b6:	119cd0        	slli	a9, a12, 3
420093b9:	20c992        	addi	a9, a9, 32
420093bc:	99ba      	add.n	a9, a9, a11
420093be:	994b      	addi.n	a9, a9, 4
420093c0:	aa99      	s32i.n	a9, a10, 40
    for (int i = 0; i < available_region_idx; i++) {
420093c2:	881b      	addi.n	a8, a8, 1
420093c4:	dc3867        	bltu	a8, a6, 420093a4 <esp_mmu_map_init+0xcc>
    assert(available_region_idx == region_num);
420093c7:	111567        	beq	a5, a6, 420093dc <esp_mmu_map_init+0x104>
420093ca:	dda8d1        	l32r	a13, 42000a6c <_stext+0xa4c> (3c025df4 <_flash_rodata_start+0x5cd4>)
420093cd:	dda5c1        	l32r	a12, 42000a64 <_stext+0xa44> (3c0286b8 <__func__$11>)
420093d0:	06a1b2        	movi	a11, 0x106
420093d3:	dd9ca1        	l32r	a10, 42000a44 <_stext+0xa24> (3c025d14 <_flash_rodata_start+0x5bf4>)
420093d6:	db3a81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420093d9:	0008e0        	callx8	a8
}
420093dc:	f01d      	retw.n
	...

420093e0 <esp_mmu_map>:
{
420093e0:	00c136        	entry	a1, 96
420093e3:	7179      	s32i.n	a7, a1, 28
420093e5:	4129      	s32i.n	a2, a1, 16
420093e7:	056152        	s32i	a5, a1, 20
    ESP_RETURN_ON_FALSE(out_ptr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
420093ea:	c7ec      	bnez.n	a7, 4200941a <esp_mmu_map+0x3a>
420093ec:	dda171        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
420093ef:	002762        	l32i	a6, a7, 0
420093f2:	db1b81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420093f5:	0008e0        	callx8	a8
420093f8:	bea182        	movi	a8, 0x1be
420093fb:	0189      	s32i.n	a8, a1, 0
420093fd:	dd9df1        	l32r	a15, 42000a74 <_stext+0xa54> (3c028668 <__FUNCTION__$5>)
42009400:	07e8      	l32i.n	a14, a7, 0
42009402:	0add      	mov.n	a13, a10
42009404:	dd9dc1        	l32r	a12, 42000a78 <_stext+0xa58> (3c025e18 <_flash_rodata_start+0x5cf8>)
42009407:	06bd      	mov.n	a11, a6
42009409:	1a0c      	movi.n	a10, 1
4200940b:	db2281        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200940e:	0008e0        	callx8	a8
42009411:	02a182        	movi	a8, 0x102
42009414:	6189      	s32i.n	a8, a1, 24
42009416:	00e4c6        	j	420097ad <esp_mmu_map+0x3cd>
42009419:	418800        	srli	a8, a0, 8
    ESP_RETURN_ON_FALSE((paddr_start % CONFIG_MMU_PAGE_SIZE == 0), ESP_ERR_INVALID_ARG, TAG, "paddr must be rounded up to the nearest multiple of CONFIG_MMU_PAGE_SIZE");
4200941c:	f45080        	extui	a5, a8, 0, 16
4200941f:	a5ac      	beqz.n	a5, 4200944d <esp_mmu_map+0x6d>
42009421:	dd9371        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
42009424:	0768      	l32i.n	a6, a7, 0
42009426:	db0e81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009429:	0008e0        	callx8	a8
4200942c:	c2a182        	movi	a8, 0x1c2
4200942f:	0189      	s32i.n	a8, a1, 0
42009431:	dd90f1        	l32r	a15, 42000a74 <_stext+0xa54> (3c028668 <__FUNCTION__$5>)
42009434:	07e8      	l32i.n	a14, a7, 0
42009436:	0add      	mov.n	a13, a10
42009438:	dd91c1        	l32r	a12, 42000a7c <_stext+0xa5c> (3c025e84 <_flash_rodata_start+0x5d64>)
4200943b:	06bd      	mov.n	a11, a6
4200943d:	1a0c      	movi.n	a10, 1
4200943f:	db1581        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009442:	0008e0        	callx8	a8
42009445:	02a182        	movi	a8, 0x102
42009448:	6189      	s32i.n	a8, a1, 24
4200944a:	00d7c6        	j	420097ad <esp_mmu_map+0x3cd>
    ESP_RETURN_ON_ERROR(s_mem_caps_check(caps), TAG, "invalid caps");
4200944d:	0521a2        	l32i	a10, a1, 20
42009450:	0b5fe5        	call8	42014a50 <s_mem_caps_check>
42009453:	0661a2        	s32i	a10, a1, 24
42009456:	026a16        	beqz	a10, 42009480 <esp_mmu_map+0xa0>
42009459:	dd8571        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
4200945c:	0768      	l32i.n	a6, a7, 0
4200945e:	db0081        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009461:	0008e0        	callx8	a8
42009464:	c3a182        	movi	a8, 0x1c3
42009467:	0189      	s32i.n	a8, a1, 0
42009469:	dd82f1        	l32r	a15, 42000a74 <_stext+0xa54> (3c028668 <__FUNCTION__$5>)
4200946c:	07e8      	l32i.n	a14, a7, 0
4200946e:	0add      	mov.n	a13, a10
42009470:	dd84c1        	l32r	a12, 42000a80 <_stext+0xa60> (3c025e3c <_flash_rodata_start+0x5d1c>)
42009473:	06bd      	mov.n	a11, a6
42009475:	1a0c      	movi.n	a10, 1
42009477:	db0781        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200947a:	0008e0        	callx8	a8
4200947d:	00cb06        	j	420097ad <esp_mmu_map+0x3cd>
    size_t aligned_size = ALIGN_UP_BY(size, CONFIG_MMU_PAGE_SIZE);
42009480:	dd7281        	l32r	a8, 42000a48 <_stext+0xa28> (ffff <UserFrameTotalSize+0xfeff>)
42009483:	338a      	add.n	a3, a3, a8
42009485:	f53030        	extui	a3, a3, 16, 16
42009488:	113300        	slli	a3, a3, 16
    int32_t found_region_id = s_find_available_region(s_mmu_ctx.mem_regions, s_mmu_ctx.num_regions, aligned_size, caps, target);
4200948b:	04ed      	mov.n	a14, a4
4200948d:	51d8      	l32i.n	a13, a1, 20
4200948f:	20c330        	or	a12, a3, a3
42009492:	dd7581        	l32r	a8, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
42009495:	0028b2        	l32i	a11, a8, 0
42009498:	dd7ba1        	l32r	a10, 42000a84 <_stext+0xa64> (3fc95eb0 <s_mmu_ctx+0x4>)
4200949b:	0b5d25        	call8	42014a6c <s_find_available_region>
4200949e:	0a2d      	mov.n	a2, a10
    if (found_region_id == -1) {
420094a0:	250a66        	bnei	a10, -1, 420094c9 <esp_mmu_map+0xe9>
420094a3:	dae281        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
420094a6:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "no such vaddr range");
420094a8:	489c      	beqz.n	a8, 420094c0 <esp_mmu_map+0xe0>
420094aa:	daed81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420094ad:	0008e0        	callx8	a8
420094b0:	dd7081        	l32r	a8, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
420094b3:	08c8      	l32i.n	a12, a8, 0
420094b5:	0abd      	mov.n	a11, a10
420094b7:	dd74a1        	l32r	a10, 42000a88 <_stext+0xa68> (3c025e60 <_flash_rodata_start+0x5d40>)
420094ba:	daea81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420094bd:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
420094c0:	05a182        	movi	a8, 0x105
420094c3:	6189      	s32i.n	a8, a1, 24
420094c5:	00b906        	j	420097ad <esp_mmu_map+0x3cd>
420094c8:	8aa000        	round.s	a10, f0, 0
    if (TAILQ_EMPTY(&found_region->mem_block_head)) {
420094cb:	6791a0        	lsi	f10, a1, 0x19c
420094ce:	90dd      	lsi	f13, a0, 0
420094d0:	b088      	l32i.n	a8, a0, 44
420094d2:	9888      	l32i.n	a8, a8, 36
420094d4:	0f1856        	bnez	a8, 420095c9 <esp_mmu_map+0x1e9>
        dummy_head = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
420094d7:	dbf8c1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
420094da:	cb2c      	movi.n	a11, 44
420094dc:	01a0a2        	movi	a10, 1
420094df:	dd7281        	l32r	a8, 42000aa8 <_stext+0xa88> (4037606c <heap_caps_calloc>)
420094e2:	0008e0        	callx8	a8
420094e5:	b1a9      	s32i.n	a10, a1, 44
        ESP_GOTO_ON_FALSE(dummy_head, ESP_ERR_NO_MEM, err, TAG, "no mem");
420094e7:	5aec      	bnez.n	a10, 42009510 <esp_mmu_map+0x130>
420094e9:	dd6171        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
420094ec:	0768      	l32i.n	a6, a7, 0
420094ee:	dadc81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420094f1:	0008e0        	callx8	a8
420094f4:	d4a182        	movi	a8, 0x1d4
420094f7:	0189      	s32i.n	a8, a1, 0
420094f9:	dd5ef1        	l32r	a15, 42000a74 <_stext+0xa54> (3c028668 <__FUNCTION__$5>)
420094fc:	07e8      	l32i.n	a14, a7, 0
420094fe:	0add      	mov.n	a13, a10
42009500:	dd63c1        	l32r	a12, 42000a8c <_stext+0xa6c> (3c025ee4 <_flash_rodata_start+0x5dc4>)
42009503:	06bd      	mov.n	a11, a6
42009505:	1a0c      	movi.n	a10, 1
42009507:	dae381        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200950a:	0008e0        	callx8	a8
    if (dummy_tail) {
4200950d:	00a146        	j	42009796 <esp_mmu_map+0x3b6>
        dummy_head->laddr_start = found_region->free_head;
42009510:	a08220        	addx4	a8, a2, a2
42009513:	dd5591        	l32r	a9, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
42009516:	b08890        	addx8	a8, a8, a9
42009519:	5898      	l32i.n	a9, a8, 20
4200951b:	b1a8      	l32i.n	a10, a1, 44
4200951d:	0a99      	s32i.n	a9, a10, 0
        dummy_head->laddr_end = found_region->free_head;
4200951f:	1a99      	s32i.n	a9, a10, 4
        dummy_head->size = 0;
42009521:	090c      	movi.n	a9, 0
42009523:	4a99      	s32i.n	a9, a10, 16
        dummy_head->caps = caps;
42009525:	0a9d      	mov.n	a9, a10
42009527:	51a8      	l32i.n	a10, a1, 20
42009529:	59a9      	s32i.n	a10, a9, 20
        TAILQ_INSERT_HEAD(&found_region->mem_block_head, dummy_head, entries);
4200952b:	9888      	l32i.n	a8, a8, 36
4200952d:	9989      	s32i.n	a8, a9, 36
4200952f:	688c      	beqz.n	a8, 42009539 <esp_mmu_map+0x159>
42009531:	24c992        	addi	a9, a9, 36
42009534:	a899      	s32i.n	a9, a8, 40
42009536:	0003c6        	j	42009549 <esp_mmu_map+0x169>
42009539:	b188      	l32i.n	a8, a1, 44
4200953b:	24c892        	addi	a9, a8, 36
4200953e:	a08220        	addx4	a8, a2, a2
42009541:	dd49a1        	l32r	a10, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
42009544:	b088a0        	addx8	a8, a8, a10
42009547:	a899      	s32i.n	a9, a8, 40
42009549:	dd4791        	l32r	a9, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
4200954c:	a08220        	addx4	a8, a2, a2
4200954f:	b08890        	addx8	a8, a8, a9
42009552:	b1a8      	l32i.n	a10, a1, 44
42009554:	98a9      	s32i.n	a10, a8, 36
42009556:	a08220        	addx4	a8, a2, a2
42009559:	1188d0        	slli	a8, a8, 3
4200955c:	20c882        	addi	a8, a8, 32
4200955f:	889a      	add.n	a8, a8, a9
42009561:	884b      	addi.n	a8, a8, 4
42009563:	aa89      	s32i.n	a8, a10, 40
        dummy_tail = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42009565:	dbd4c1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42009568:	cb2c      	movi.n	a11, 44
4200956a:	1a0c      	movi.n	a10, 1
4200956c:	dd4f81        	l32r	a8, 42000aa8 <_stext+0xa88> (4037606c <heap_caps_calloc>)
4200956f:	0008e0        	callx8	a8
42009572:	c1a9      	s32i.n	a10, a1, 48
        ESP_GOTO_ON_FALSE(dummy_tail, ESP_ERR_NO_MEM, err, TAG, "no mem");
42009574:	8aec      	bnez.n	a10, 420095a0 <esp_mmu_map+0x1c0>
42009576:	dd3e71        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
42009579:	0768      	l32i.n	a6, a7, 0
4200957b:	dab981        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200957e:	0008e0        	callx8	a8
42009581:	dea182        	movi	a8, 0x1de
42009584:	0189      	s32i.n	a8, a1, 0
42009586:	dd3bf1        	l32r	a15, 42000a74 <_stext+0xa54> (3c028668 <__FUNCTION__$5>)
42009589:	07e8      	l32i.n	a14, a7, 0
4200958b:	0add      	mov.n	a13, a10
4200958d:	dd3fc1        	l32r	a12, 42000a8c <_stext+0xa6c> (3c025ee4 <_flash_rodata_start+0x5dc4>)
42009590:	20b660        	or	a11, a6, a6
42009593:	01a0a2        	movi	a10, 1
42009596:	dabf81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009599:	0008e0        	callx8	a8
4200959c:	007a86        	j	4200978a <esp_mmu_map+0x3aa>
4200959f:	822000        	mull	a2, a0, a0
        dummy_tail->laddr_start = found_region->end;
420095a2:	3191a0        	srai	a9, a10, 17
420095a5:	90dd      	lsi	f13, a0, 0
420095a7:	b088      	l32i.n	a8, a0, 44
420095a9:	3898      	l32i.n	a9, a8, 12
420095ab:	c1a8      	l32i.n	a10, a1, 48
420095ad:	0a99      	s32i.n	a9, a10, 0
        dummy_tail->laddr_end = found_region->end;
420095af:	1a99      	s32i.n	a9, a10, 4
        dummy_tail->size = 0;
420095b1:	090c      	movi.n	a9, 0
420095b3:	4a99      	s32i.n	a9, a10, 16
        dummy_tail->caps = caps;
420095b5:	51b8      	l32i.n	a11, a1, 20
420095b7:	5ab9      	s32i.n	a11, a10, 20
        TAILQ_INSERT_TAIL(&found_region->mem_block_head, dummy_tail, entries);
420095b9:	9a99      	s32i.n	a9, a10, 36
420095bb:	a898      	l32i.n	a9, a8, 40
420095bd:	aa99      	s32i.n	a9, a10, 40
420095bf:	09a9      	s32i.n	a10, a9, 0
420095c1:	24ca92        	addi	a9, a10, 36
420095c4:	a899      	s32i.n	a9, a8, 40
420095c6:	000146        	j	420095cf <esp_mmu_map+0x1ef>
    mem_block_t *dummy_tail = NULL;
420095c9:	080c      	movi.n	a8, 0
420095cb:	c189      	s32i.n	a8, a1, 48
    mem_block_t *dummy_head = NULL;
420095cd:	b189      	s32i.n	a8, a1, 44
    bool allow_overlap = flags & ESP_MMU_MMAP_FLAG_PADDR_SHARED;
420095cf:	04a060        	extui	a10, a6, 0, 1
420095d2:	a1a9      	s32i.n	a10, a1, 40
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
420095d4:	a08220        	addx4	a8, a2, a2
420095d7:	dd2491        	l32r	a9, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
420095da:	b08890        	addx8	a8, a8, a9
420095dd:	9878      	l32i.n	a7, a8, 36
420095df:	8129      	s32i.n	a2, a1, 32
420095e1:	9159      	s32i.n	a5, a1, 36
420095e3:	0a5d      	mov.n	a5, a10
420095e5:	000ac6        	j	42009614 <esp_mmu_map+0x234>
420095e8:	820000        	mull	a0, a0, a0
        if (target == mem_block->target) {
420095eb:	470827        	bnone	a8, a2, 42009636 <esp_mmu_map+0x256>
420095ee:	2198      	l32i.n	a9, a1, 8
            if ((s_is_enclosed(mem_block->paddr_start, mem_block->paddr_end, paddr_start, aligned_size))) {
420095f0:	062762        	l32i	a6, a7, 24
420095f3:	7728      	l32i.n	a2, a7, 28
420095f5:	03dd      	mov.n	a13, a3
420095f7:	41c8      	l32i.n	a12, a1, 16
420095f9:	02bd      	mov.n	a11, a2
420095fb:	20a660        	or	a10, a6, a6
420095fe:	0b49a5        	call8	42014a98 <s_is_enclosed>
42009601:	dadc      	bnez.n	a10, 42009622 <esp_mmu_map+0x242>
            if (!allow_overlap && (s_is_overlapped(mem_block->paddr_start, mem_block->paddr_end, paddr_start, aligned_size))) {
42009603:	b5cc      	bnez.n	a5, 42009612 <esp_mmu_map+0x232>
42009605:	03dd      	mov.n	a13, a3
42009607:	41c8      	l32i.n	a12, a1, 16
42009609:	02bd      	mov.n	a11, a2
4200960b:	06ad      	mov.n	a10, a6
4200960d:	0b4aa5        	call8	42014ab8 <s_is_overlapped>
42009610:	8adc      	bnez.n	a10, 4200962c <esp_mmu_map+0x24c>
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
42009612:	9778      	l32i.n	a7, a7, 36
42009614:	fd2756        	bnez	a7, 420095ea <esp_mmu_map+0x20a>
    bool is_overlapped = false;
42009617:	8128      	l32i.n	a2, a1, 32
42009619:	9158      	l32i.n	a5, a1, 36
4200961b:	080c      	movi.n	a8, 0
    bool is_enclosed = false;
4200961d:	08ad      	mov.n	a10, a8
4200961f:	000446        	j	42009634 <esp_mmu_map+0x254>
    bool is_overlapped = false;
42009622:	8128      	l32i.n	a2, a1, 32
42009624:	9158      	l32i.n	a5, a1, 36
42009626:	080c      	movi.n	a8, 0
42009628:	000206        	j	42009634 <esp_mmu_map+0x254>
4200962b:	0a8d00        	add.s	f8, f13, f0
    bool is_enclosed = false;
4200962e:	8128      	l32i.n	a2, a1, 32
42009630:	9158      	l32i.n	a5, a1, 36
42009632:	a1a8      	l32i.n	a10, a1, 40
    if (is_enclosed) {
42009634:	9abc      	beqz.n	a10, 42009671 <esp_mmu_map+0x291>
        ESP_LOGW(TAG, "paddr block is mapped already, vaddr_start: %p, size: 0x%x", (void *)mem_block->vaddr_start, mem_block->size);
42009636:	dd0e61        	l32r	a6, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
42009639:	0658      	l32i.n	a5, a6, 0
4200963b:	da8981        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200963e:	0008e0        	callx8	a8
42009641:	27f8      	l32i.n	a15, a7, 8
42009643:	4788      	l32i.n	a8, a7, 16
42009645:	0189      	s32i.n	a8, a1, 0
42009647:	06e8      	l32i.n	a14, a6, 0
42009649:	0add      	mov.n	a13, a10
4200964b:	dd11c1        	l32r	a12, 42000a90 <_stext+0xa70> (3c025f00 <_flash_rodata_start+0x5de0>)
4200964e:	05bd      	mov.n	a11, a5
42009650:	2a0c      	movi.n	a10, 2
42009652:	da9081        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009655:	0008e0        	callx8	a8
        const uint32_t new_paddr_offset = paddr_start - mem_block->paddr_start;
42009658:	6798      	l32i.n	a9, a7, 24
4200965a:	4188      	l32i.n	a8, a1, 16
4200965c:	c09890        	sub	a9, a8, a9
        *out_ptr = (void *)mem_block->vaddr_start + new_paddr_offset;
4200965f:	2788      	l32i.n	a8, a7, 8
42009661:	889a      	add.n	a8, a8, a9
42009663:	7198      	l32i.n	a9, a1, 28
42009665:	0989      	s32i.n	a8, a9, 0
        return ESP_ERR_INVALID_STATE;
42009667:	03a182        	movi	a8, 0x103
4200966a:	6189      	s32i.n	a8, a1, 24
4200966c:	004f46        	j	420097ad <esp_mmu_map+0x3cd>
4200966f:	0c0000        	lsi	f0, a0, 48
    if (!allow_overlap && is_overlapped) {
42009672:	a819      	s32i.n	a1, a8, 40
42009674:	9a90a1        	l32r	a10, 41ff00b4 <_coredump_iram_end+0x1c6e1b4>
42009677:	909030        	addx2	a9, a0, a3
4200967a:	698074        	lsi	f7, a0, 0x1a4
4200967d:	098710        	l32e	a1, a7, -32
42009680:	fb7123        	lsi	f2, a1, 0x3ec
        ESP_LOGE(TAG, "paddr block is overlapped with an already mapped paddr block");
42009683:	68dc      	bnez.n	a8, 4200969d <esp_mmu_map+0x2bd>
42009685:	768107        	bany	a1, a0, 420096ff <esp_mmu_map+0x31f>
42009688:	e0da      	add.n	a14, a0, a13
4200968a:	0008      	l32i.n	a0, a0, 0
4200968c:	07e8      	l32i.n	a14, a7, 0
4200968e:	0add      	mov.n	a13, a10
42009690:	dd01c1        	l32r	a12, 42000a94 <_stext+0xa74> (3c025f48 <_flash_rodata_start+0x5e28>)
42009693:	06bd      	mov.n	a11, a6
42009695:	1a0c      	movi.n	a10, 1
42009697:	da7f81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200969a:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
4200969d:	02a182        	movi	a8, 0x102
420096a0:	6189      	s32i.n	a8, a1, 24
420096a2:	0041c6        	j	420097ad <esp_mmu_map+0x3cd>
    new_block = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
420096a5:	db84c1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
420096a8:	cb2c      	movi.n	a11, 44
420096aa:	1a0c      	movi.n	a10, 1
420096ac:	dcff81        	l32r	a8, 42000aa8 <_stext+0xa88> (4037606c <heap_caps_calloc>)
420096af:	0008e0        	callx8	a8
420096b2:	0a7d      	mov.n	a7, a10
    ESP_GOTO_ON_FALSE(new_block, ESP_ERR_NO_MEM, err, TAG, "no mem");
420096b4:	7aec      	bnez.n	a10, 420096df <esp_mmu_map+0x2ff>
420096b6:	dcee71        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
420096b9:	0768      	l32i.n	a6, a7, 0
420096bb:	da6981        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420096be:	0008e0        	callx8	a8
420096c1:	14a282        	movi	a8, 0x214
420096c4:	0189      	s32i.n	a8, a1, 0
420096c6:	dcebf1        	l32r	a15, 42000a74 <_stext+0xa54> (3c028668 <__FUNCTION__$5>)
420096c9:	07e8      	l32i.n	a14, a7, 0
420096cb:	0add      	mov.n	a13, a10
420096cd:	dcefc1        	l32r	a12, 42000a8c <_stext+0xa6c> (3c025ee4 <_flash_rodata_start+0x5dc4>)
420096d0:	20b660        	or	a11, a6, a6
420096d3:	01a0a2        	movi	a10, 1
420096d6:	da6f81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
420096d9:	0008e0        	callx8	a8
420096dc:	002a86        	j	4200978a <esp_mmu_map+0x3aa>
    uint32_t last_end = TAILQ_FIRST(&found_region->mem_block_head)->laddr_end;
420096df:	a08220        	addx4	a8, a2, a2
420096e2:	dce191        	l32r	a9, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
420096e5:	b08890        	addx8	a8, a8, a9
420096e8:	9888      	l32i.n	a8, a8, 36
420096ea:	18a8      	l32i.n	a10, a8, 4
    mem_block_t *found_block = NULL;  //This stands for the block we found, whose slot between its prior block is where we will insert the new block to
420096ec:	0b0c      	movi.n	a11, 0
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
420096ee:	000646        	j	4200970b <esp_mmu_map+0x32b>
        slot_len = mem_block->laddr_start - last_end;
420096f1:	0898      	l32i.n	a9, a8, 0
420096f3:	c099a0        	sub	a9, a9, a10
        if (!found) {
420096f6:	a6cc      	bnez.n	a6, 42009704 <esp_mmu_map+0x324>
            if (slot_len >= aligned_size) {
420096f8:	083937        	bltu	a9, a3, 42009704 <esp_mmu_map+0x324>
                slot_len -= aligned_size;
420096fb:	c09930        	sub	a9, a9, a3
                new_block->laddr_start = last_end;
420096fe:	07a9      	s32i.n	a10, a7, 0
                found_block = mem_block;
42009700:	08bd      	mov.n	a11, a8
                found = true;
42009702:	160c      	movi.n	a6, 1
        max_slot_len = (slot_len > max_slot_len) ? slot_len : max_slot_len;
42009704:	735590        	maxu	a5, a5, a9
        last_end = mem_block->laddr_end;
42009707:	18a8      	l32i.n	a10, a8, 4
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
42009709:	9888      	l32i.n	a8, a8, 36
4200970b:	fe2856        	bnez	a8, 420096f1 <esp_mmu_map+0x311>
    assert(found);
4200970e:	06dc      	bnez.n	a6, 42009722 <esp_mmu_map+0x342>
42009710:	dce2d1        	l32r	a13, 42000a98 <_stext+0xa78> (3c025f94 <_flash_rodata_start+0x5e74>)
42009713:	dce2c1        	l32r	a12, 42000a9c <_stext+0xa7c> (3c02865c <__func__$4>)
42009716:	2fa2b2        	movi	a11, 0x22f
42009719:	dccaa1        	l32r	a10, 42000a44 <_stext+0xa24> (3c025d14 <_flash_rodata_start+0x5bf4>)
4200971c:	da6981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200971f:	0008e0        	callx8	a8
    TAILQ_INSERT_BEFORE(found_block, new_block, entries);
42009722:	ab88      	l32i.n	a8, a11, 40
42009724:	a789      	s32i.n	a8, a7, 40
42009726:	97b9      	s32i.n	a11, a7, 36
42009728:	ab88      	l32i.n	a8, a11, 40
4200972a:	0879      	s32i.n	a7, a8, 0
4200972c:	24c782        	addi	a8, a7, 36
4200972f:	ab89      	s32i.n	a8, a11, 40
    found_region->max_slot_size = max_slot_len;
42009731:	a02220        	addx4	a2, a2, a2
42009734:	dccd81        	l32r	a8, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
42009737:	b02280        	addx8	a2, a2, a8
4200973a:	6259      	s32i.n	a5, a2, 24
    new_block->laddr_end = new_block->laddr_start + aligned_size;
4200973c:	0798      	l32i.n	a9, a7, 0
4200973e:	839a      	add.n	a8, a3, a9
42009740:	1789      	s32i.n	a8, a7, 4
    new_block->size = aligned_size;
42009742:	4739      	s32i.n	a3, a7, 16
    new_block->caps = caps;
42009744:	51b8      	l32i.n	a11, a1, 20
42009746:	57b9      	s32i.n	a11, a7, 20
    new_block->paddr_start = paddr_start;
42009748:	41a8      	l32i.n	a10, a1, 16
4200974a:	67a9      	s32i.n	a10, a7, 24
    new_block->paddr_end = paddr_start + aligned_size;
4200974c:	a3aa      	add.n	a10, a3, a10
4200974e:	77a9      	s32i.n	a10, a7, 28
    new_block->target = target;
42009750:	8749      	s32i.n	a4, a7, 32
    if (caps & MMU_MEM_CAP_EXEC) {
42009752:	0f6b07        	bbci	a11, 0, 42009765 <esp_mmu_map+0x385>
    return vaddr_base | laddr;
42009755:	dcd2a1        	l32r	a10, 42000aa0 <_stext+0xa80> (42000000 <_coredump_iram_end+0x1c7e100>)
42009758:	2099a0        	or	a9, a9, a10
        new_block->vaddr_start = mmu_ll_laddr_to_vaddr(new_block->laddr_start, MMU_VADDR_INSTRUCTION, target);
4200975b:	2799      	s32i.n	a9, a7, 8
4200975d:	2088a0        	or	a8, a8, a10
        new_block->vaddr_end = mmu_ll_laddr_to_vaddr(new_block->laddr_end, MMU_VADDR_INSTRUCTION, target);
42009760:	3789      	s32i.n	a8, a7, 12
42009762:	000306        	j	42009772 <esp_mmu_map+0x392>
42009765:	dccfa1        	l32r	a10, 42000aa4 <_stext+0xa84> (3c000000 <UserFrameTotalSize+0x3bffff00>)
42009768:	2099a0        	or	a9, a9, a10
        new_block->vaddr_start = mmu_ll_laddr_to_vaddr(new_block->laddr_start, MMU_VADDR_DATA, target);
4200976b:	2799      	s32i.n	a9, a7, 8
4200976d:	2088a0        	or	a8, a8, a10
        new_block->vaddr_end = mmu_ll_laddr_to_vaddr(new_block->laddr_end, MMU_VADDR_DATA, target);
42009770:	3789      	s32i.n	a8, a7, 12
    s_do_mapping(target, new_block->vaddr_start, paddr_start, aligned_size);
42009772:	03dd      	mov.n	a13, a3
42009774:	41c8      	l32i.n	a12, a1, 16
42009776:	27b8      	l32i.n	a11, a7, 8
42009778:	04ad      	mov.n	a10, a4
4200977a:	dccc81        	l32r	a8, 42000aac <_stext+0xa8c> (4037769c <s_do_mapping>)
4200977d:	0008e0        	callx8	a8
    *out_ptr = (void *)new_block->vaddr_start;
42009780:	2788      	l32i.n	a8, a7, 8
42009782:	7198      	l32i.n	a9, a1, 28
42009784:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
42009786:	0008c6        	j	420097ad <esp_mmu_map+0x3cd>
42009789:	c18800        	mul16u	a8, a8, a0
    if (dummy_tail) {
4200978c:	688c      	beqz.n	a8, 42009796 <esp_mmu_map+0x3b6>
        free(dummy_tail);
4200978e:	08ad      	mov.n	a10, a8
42009790:	db7681        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42009793:	0008e0        	callx8	a8
    if (dummy_head) {
42009796:	b1a8      	l32i.n	a10, a1, 44
42009798:	ca8c      	beqz.n	a10, 420097a8 <esp_mmu_map+0x3c8>
        free(dummy_head);
4200979a:	db7381        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
4200979d:	0008e0        	callx8	a8
    return ret;
420097a0:	01a182        	movi	a8, 0x101
420097a3:	6189      	s32i.n	a8, a1, 24
420097a5:	000106        	j	420097ad <esp_mmu_map+0x3cd>
420097a8:	01a182        	movi	a8, 0x101
420097ab:	6189      	s32i.n	a8, a1, 24
}
420097ad:	6128      	l32i.n	a2, a1, 24
420097af:	f01d      	retw.n
420097b1:	000000        	ill

420097b4 <esp_mmu_unmap>:
{
420097b4:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(ptr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
420097b7:	92ec      	bnez.n	a2, 420097e4 <esp_mmu_unmap+0x30>
420097b9:	dcad71        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
420097bc:	0768      	l32i.n	a6, a7, 0
420097be:	da2881        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420097c1:	0008e0        	callx8	a8
420097c4:	7aa282        	movi	a8, 0x27a
420097c7:	0189      	s32i.n	a8, a1, 0
420097c9:	dcb9f1        	l32r	a15, 42000ab0 <_stext+0xa90> (3c02864c <__FUNCTION__$2>)
420097cc:	07e8      	l32i.n	a14, a7, 0
420097ce:	0add      	mov.n	a13, a10
420097d0:	dcaac1        	l32r	a12, 42000a78 <_stext+0xa58> (3c025e18 <_flash_rodata_start+0x5cf8>)
420097d3:	06bd      	mov.n	a11, a6
420097d5:	1a0c      	movi.n	a10, 1
420097d7:	da2f81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
420097da:	0008e0        	callx8	a8
420097dd:	02a122        	movi	a2, 0x102
420097e0:	003c86        	j	420098d6 <esp_mmu_unmap+0x122>
420097e3:	829000        	mull	a9, a0, a0
    return vaddr & SOC_MMU_LINEAR_ADDR_MASK;
420097e6:	878011        	l32r	a1, 41feb5e8 <_coredump_iram_end+0x1c696e8>
420097e9:	090c41        	l32r	a4, 41fcbc1c <_coredump_iram_end+0x1c49d1c>
    mem_region_t *region = NULL;
420097ec:	096d      	mov.n	a6, a9
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
420097ee:	000886        	j	42009814 <esp_mmu_unmap+0x60>
        if (ptr_laddr >= s_mmu_ctx.mem_regions[i].free_head && ptr_laddr < s_mmu_ctx.mem_regions[i].end) {
420097f1:	a0a990        	addx4	a10, a9, a9
420097f4:	dc9db1        	l32r	a11, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
420097f7:	b0aab0        	addx8	a10, a10, a11
420097fa:	5aa8      	l32i.n	a10, a10, 20
420097fc:	1238a7        	bltu	a8, a10, 42009812 <esp_mmu_unmap+0x5e>
420097ff:	a0a990        	addx4	a10, a9, a9
42009802:	b0aab0        	addx8	a10, a10, a11
42009805:	3aa8      	l32i.n	a10, a10, 12
42009807:	07b8a7        	bgeu	a8, a10, 42009812 <esp_mmu_unmap+0x5e>
            region = &s_mmu_ctx.mem_regions[i];
4200980a:	a06990        	addx4	a6, a9, a9
4200980d:	b066b0        	addx8	a6, a6, a11
42009810:	664b      	addi.n	a6, a6, 4
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
42009812:	991b      	addi.n	a9, a9, 1
42009814:	dc95a1        	l32r	a10, 42000a68 <_stext+0xa48> (3fc95eac <s_mmu_ctx>)
42009817:	0aa8      	l32i.n	a10, a10, 0
42009819:	d439a7        	bltu	a9, a10, 420097f1 <esp_mmu_unmap+0x3d>
    ESP_RETURN_ON_FALSE(region, ESP_ERR_NOT_FOUND, TAG, "munmap target pointer is outside external memory regions");
4200981c:	a6ec      	bnez.n	a6, 4200984a <esp_mmu_unmap+0x96>
4200981e:	dc9471        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
42009821:	0768      	l32i.n	a6, a7, 0
42009823:	da0f81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009826:	0008e0        	callx8	a8
42009829:	88a282        	movi	a8, 0x288
4200982c:	0189      	s32i.n	a8, a1, 0
4200982e:	dca0f1        	l32r	a15, 42000ab0 <_stext+0xa90> (3c02864c <__FUNCTION__$2>)
42009831:	07e8      	l32i.n	a14, a7, 0
42009833:	0add      	mov.n	a13, a10
42009835:	dc9fc1        	l32r	a12, 42000ab4 <_stext+0xa94> (3c025f9c <_flash_rodata_start+0x5e7c>)
42009838:	20b660        	or	a11, a6, a6
4200983b:	01a0a2        	movi	a10, 1
4200983e:	da1581        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009841:	0008e0        	callx8	a8
42009844:	05a122        	movi	a2, 0x105
42009847:	0022c6        	j	420098d6 <esp_mmu_unmap+0x122>
    TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
4200984a:	86a8      	l32i.n	a10, a6, 32
4200984c:	0a7d      	mov.n	a7, a10
4200984e:	000e46        	j	4200988b <esp_mmu_unmap+0xd7>
        if (mem_block == TAILQ_FIRST(&region->mem_block_head) || mem_block == TAILQ_LAST(&region->mem_block_head, mem_block_head_)) {
42009851:	341a77        	beq	a10, a7, 42009889 <esp_mmu_unmap+0xd5>
42009854:	9698      	l32i.n	a9, a6, 36
42009856:	1998      	l32i.n	a9, a9, 4
42009858:	0998      	l32i.n	a9, a9, 0
4200985a:	2b1977        	beq	a9, a7, 42009889 <esp_mmu_unmap+0xd5>
        if (mem_block->laddr_start == ptr_laddr) {
4200985d:	0798      	l32i.n	a9, a7, 0
4200985f:	269897        	bne	a8, a9, 42009889 <esp_mmu_unmap+0xd5>
            slot_len = TAILQ_NEXT(mem_block, entries)->laddr_start - TAILQ_PREV(mem_block, mem_block_head_, entries)->laddr_end;
42009862:	9788      	l32i.n	a8, a7, 36
42009864:	0888      	l32i.n	a8, a8, 0
42009866:	a798      	l32i.n	a9, a7, 40
42009868:	1998      	l32i.n	a9, a9, 4
4200986a:	0998      	l32i.n	a9, a9, 0
4200986c:	1998      	l32i.n	a9, a9, 4
4200986e:	c08890        	sub	a8, a8, a9
            region->max_slot_size = (slot_len > region->max_slot_size) ? slot_len : region->max_slot_size;
42009871:	5698      	l32i.n	a9, a6, 20
42009873:	738890        	maxu	a8, a8, a9
42009876:	5689      	s32i.n	a8, a6, 20
    s_do_unmapping(mem_block->vaddr_start, mem_block->size);
42009878:	47b8      	l32i.n	a11, a7, 16
4200987a:	27a8      	l32i.n	a10, a7, 8
4200987c:	dc9081        	l32r	a8, 42000abc <_stext+0xa9c> (40377788 <s_do_unmapping>)
4200987f:	0008e0        	callx8	a8
    TAILQ_REMOVE(&region->mem_block_head, found_block, entries);
42009882:	9788      	l32i.n	a8, a7, 36
42009884:	28fc      	bnez.n	a8, 420098ba <esp_mmu_unmap+0x106>
42009886:	000dc6        	j	420098c1 <esp_mmu_unmap+0x10d>
    TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
42009889:	9778      	l32i.n	a7, a7, 36
4200988b:	fc2756        	bnez	a7, 42009851 <esp_mmu_unmap+0x9d>
    ESP_RETURN_ON_FALSE(found, ESP_ERR_NOT_FOUND, TAG, "munmap target pointer isn't mapped yet");
4200988e:	dc7871        	l32r	a7, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
42009891:	0768      	l32i.n	a6, a7, 0
42009893:	d9f381        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009896:	0008e0        	callx8	a8
42009899:	9da282        	movi	a8, 0x29d
4200989c:	0189      	s32i.n	a8, a1, 0
4200989e:	dc84f1        	l32r	a15, 42000ab0 <_stext+0xa90> (3c02864c <__FUNCTION__$2>)
420098a1:	07e8      	l32i.n	a14, a7, 0
420098a3:	0add      	mov.n	a13, a10
420098a5:	dc84c1        	l32r	a12, 42000ab8 <_stext+0xa98> (3c025fec <_flash_rodata_start+0x5ecc>)
420098a8:	20b660        	or	a11, a6, a6
420098ab:	01a0a2        	movi	a10, 1
420098ae:	d9f981        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
420098b1:	0008e0        	callx8	a8
420098b4:	05a122        	movi	a2, 0x105
420098b7:	0006c6        	j	420098d6 <esp_mmu_unmap+0x122>
    TAILQ_REMOVE(&region->mem_block_head, found_block, entries);
420098ba:	a798      	l32i.n	a9, a7, 40
420098bc:	a899      	s32i.n	a9, a8, 40
420098be:	0000c6        	j	420098c5 <esp_mmu_unmap+0x111>
420098c1:	a788      	l32i.n	a8, a7, 40
420098c3:	9689      	s32i.n	a8, a6, 36
420098c5:	a788      	l32i.n	a8, a7, 40
420098c7:	9798      	l32i.n	a9, a7, 36
420098c9:	0899      	s32i.n	a9, a8, 0
    free(found_block);
420098cb:	20a770        	or	a10, a7, a7
420098ce:	db2681        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
420098d1:	0008e0        	callx8	a8
    return ESP_OK;
420098d4:	020c      	movi.n	a2, 0
}
420098d6:	f01d      	retw.n

420098d8 <esp_mmu_vaddr_to_paddr>:

esp_err_t esp_mmu_vaddr_to_paddr(void *vaddr, esp_paddr_t *out_paddr, mmu_target_t *out_target)
{
420098d8:	008136        	entry	a1, 64
    ESP_RETURN_ON_FALSE(vaddr && out_paddr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
420098db:	40f280        	nsau	a8, a2
420098de:	418580        	srli	a8, a8, 5
420098e1:	40f390        	nsau	a9, a3
420098e4:	419590        	srli	a9, a9, 5
420098e7:	208890        	or	a8, a8, a9
420098ea:	a8ac      	beqz.n	a8, 42009918 <esp_mmu_vaddr_to_paddr+0x40>
420098ec:	dc6141        	l32r	a4, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
420098ef:	002432        	l32i	a3, a4, 0
420098f2:	d9db81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
420098f5:	0008e0        	callx8	a8
420098f8:	03a382        	movi	a8, 0x303
420098fb:	0189      	s32i.n	a8, a1, 0
420098fd:	dc70f1        	l32r	a15, 42000ac0 <_stext+0xaa0> (3c028634 <__FUNCTION__$1>)
42009900:	04e8      	l32i.n	a14, a4, 0
42009902:	0add      	mov.n	a13, a10
42009904:	dc5dc1        	l32r	a12, 42000a78 <_stext+0xa58> (3c025e18 <_flash_rodata_start+0x5cf8>)
42009907:	03bd      	mov.n	a11, a3
42009909:	1a0c      	movi.n	a10, 1
4200990b:	d9e281        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200990e:	0008e0        	callx8	a8
42009911:	02a122        	movi	a2, 0x102
42009914:	002206        	j	420099a0 <esp_mmu_vaddr_to_paddr+0xc8>
42009917:	3d0c00        	lsi	f0, a12, 244
    ESP_RETURN_ON_FALSE(mmu_hal_check_valid_ext_vaddr_region(0, (uint32_t)vaddr, 1, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION), ESP_ERR_INVALID_ARG, TAG, "not a valid external virtual address");
4200991a:	1c0c      	movi.n	a12, 1
4200991c:	02bd      	mov.n	a11, a2
4200991e:	0a0c      	movi.n	a10, 0
42009920:	dc6b81        	l32r	a8, 42000acc <_stext+0xaac> (4037cd50 <mmu_hal_check_valid_ext_vaddr_region>)
42009923:	0008e0        	callx8	a8
42009926:	aaec      	bnez.n	a10, 42009954 <esp_mmu_vaddr_to_paddr+0x7c>
42009928:	dc5241        	l32r	a4, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
4200992b:	002432        	l32i	a3, a4, 0
4200992e:	d9cc81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009931:	0008e0        	callx8	a8
42009934:	04a382        	movi	a8, 0x304
42009937:	0189      	s32i.n	a8, a1, 0
42009939:	dc61f1        	l32r	a15, 42000ac0 <_stext+0xaa0> (3c028634 <__FUNCTION__$1>)
4200993c:	04e8      	l32i.n	a14, a4, 0
4200993e:	0add      	mov.n	a13, a10
42009940:	dc61c1        	l32r	a12, 42000ac4 <_stext+0xaa4> (3c026028 <_flash_rodata_start+0x5f08>)
42009943:	03bd      	mov.n	a11, a3
42009945:	1a0c      	movi.n	a10, 1
42009947:	d9d381        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200994a:	0008e0        	callx8	a8
4200994d:	02a122        	movi	a2, 0x102
42009950:	001306        	j	420099a0 <esp_mmu_vaddr_to_paddr+0xc8>
42009953:	080c00        	lsx	f0, a12, a0

    esp_paddr_t paddr = 0;
42009956:	4189      	s32i.n	a8, a1, 16
    mmu_target_t target = 0;
42009958:	5189      	s32i.n	a8, a1, 20

    bool is_mapped = s_vaddr_to_paddr((uint32_t)vaddr, &paddr, &target);
4200995a:	14c1c2        	addi	a12, a1, 20
4200995d:	10c1b2        	addi	a11, a1, 16
42009960:	02ad      	mov.n	a10, a2
42009962:	dc5b81        	l32r	a8, 42000ad0 <_stext+0xab0> (403777a0 <s_vaddr_to_paddr>)
42009965:	0008e0        	callx8	a8
    ESP_RETURN_ON_FALSE(is_mapped, ESP_ERR_NOT_FOUND, TAG, "vaddr isn't mapped");
42009968:	aaec      	bnez.n	a10, 42009996 <esp_mmu_vaddr_to_paddr+0xbe>
4200996a:	dc4141        	l32r	a4, 42000a70 <_stext+0xa50> (3fc9354c <TAG>)
4200996d:	0438      	l32i.n	a3, a4, 0
4200996f:	d9bc81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009972:	0008e0        	callx8	a8
42009975:	0aa382        	movi	a8, 0x30a
42009978:	0189      	s32i.n	a8, a1, 0
4200997a:	dc51f1        	l32r	a15, 42000ac0 <_stext+0xaa0> (3c028634 <__FUNCTION__$1>)
4200997d:	04e8      	l32i.n	a14, a4, 0
4200997f:	0add      	mov.n	a13, a10
42009981:	dc51c1        	l32r	a12, 42000ac8 <_stext+0xaa8> (3c026064 <_flash_rodata_start+0x5f44>)
42009984:	20b330        	or	a11, a3, a3
42009987:	01a0a2        	movi	a10, 1
4200998a:	d9c281        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200998d:	0008e0        	callx8	a8
42009990:	05a122        	movi	a2, 0x105
42009993:	000246        	j	420099a0 <esp_mmu_vaddr_to_paddr+0xc8>

    *out_paddr = paddr;
42009996:	4188      	l32i.n	a8, a1, 16
42009998:	0389      	s32i.n	a8, a3, 0
    *out_target = target;
4200999a:	5188      	l32i.n	a8, a1, 20
4200999c:	0489      	s32i.n	a8, a4, 0

    return ESP_OK;
4200999e:	020c      	movi.n	a2, 0
}
420099a0:	f01d      	retw.n
	...

420099a4 <spi_flash_init_lock>:
{
420099a4:	004136        	entry	a1, 32
    s_flash_op_mutex = xSemaphoreCreateRecursiveMutex();
420099a7:	04a0a2        	movi	a10, 4
420099aa:	dc4e81        	l32r	a8, 42000ae4 <_stext+0xac4> (40379c50 <xQueueCreateMutex>)
420099ad:	0008e0        	callx8	a8
420099b0:	dc4981        	l32r	a8, 42000ad4 <_stext+0xab4> (3fc95edc <s_flash_op_mutex>)
420099b3:	08a9      	s32i.n	a10, a8, 0
    assert(s_flash_op_mutex != NULL);
420099b5:	facc      	bnez.n	a10, 420099c8 <spi_flash_init_lock+0x24>
420099b7:	dc48d1        	l32r	a13, 42000ad8 <_stext+0xab8> (3c02608c <_flash_rodata_start+0x5f6c>)
420099ba:	dc48c1        	l32r	a12, 42000adc <_stext+0xabc> (3c02874c <__func__$2>)
420099bd:	db4c      	movi.n	a11, 77
420099bf:	dc48a1        	l32r	a10, 42000ae0 <_stext+0xac0> (3c0260c3 <_flash_rodata_start+0x5fa3>)
420099c2:	d9bf81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420099c5:	0008e0        	callx8	a8
}
420099c8:	f01d      	retw.n
	...

420099cc <spi_flash_op_lock>:
{
420099cc:	004136        	entry	a1, 32
    xSemaphoreTakeRecursive(s_flash_op_mutex, portMAX_DELAY);
420099cf:	fb7c      	movi.n	a11, -1
420099d1:	dc4081        	l32r	a8, 42000ad4 <_stext+0xab4> (3fc95edc <s_flash_op_mutex>)
420099d4:	08a8      	l32i.n	a10, a8, 0
420099d6:	dc4481        	l32r	a8, 42000ae8 <_stext+0xac8> (40379e88 <xQueueTakeMutexRecursive>)
420099d9:	0008e0        	callx8	a8
}
420099dc:	f01d      	retw.n
	...

420099e0 <spi_flash_op_unlock>:
{
420099e0:	004136        	entry	a1, 32
    xSemaphoreGiveRecursive(s_flash_op_mutex);
420099e3:	dc3c81        	l32r	a8, 42000ad4 <_stext+0xab4> (3fc95edc <s_flash_op_mutex>)
420099e6:	08a8      	l32i.n	a10, a8, 0
420099e8:	dc4181        	l32r	a8, 42000aec <_stext+0xacc> (40379c84 <xQueueGiveMutexRecursive>)
420099eb:	0008e0        	callx8	a8
}
420099ee:	f01d      	retw.n

420099f0 <spi_flash_mmap>:
{
420099f0:	008136        	entry	a1, 64
420099f3:	4169      	s32i.n	a6, a1, 16
    void *ptr = NULL;
420099f5:	080c      	movi.n	a8, 0
420099f7:	0189      	s32i.n	a8, a1, 0
    block = heap_caps_calloc(1, sizeof(mmap_block_t), MALLOC_CAP_INTERNAL);
420099f9:	dae5c1        	l32r	a12, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
420099fc:	8b0c      	movi.n	a11, 8
420099fe:	1a0c      	movi.n	a10, 1
42009a00:	dc2a81        	l32r	a8, 42000aa8 <_stext+0xa88> (4037606c <heap_caps_calloc>)
42009a03:	0008e0        	callx8	a8
42009a06:	0a7d      	mov.n	a7, a10
    if (!block) {
42009a08:	061a16        	beqz	a10, 42009a6d <spi_flash_mmap+0x7d>
    vaddr_list = heap_caps_calloc(1, 1 * sizeof(uint32_t), MALLOC_CAP_INTERNAL);
42009a0b:	dae1c1        	l32r	a12, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
42009a0e:	4b0c      	movi.n	a11, 4
42009a10:	1a0c      	movi.n	a10, 1
42009a12:	dc2581        	l32r	a8, 42000aa8 <_stext+0xa88> (4037606c <heap_caps_calloc>)
42009a15:	0008e0        	callx8	a8
42009a18:	0a6d      	mov.n	a6, a10
    if (!vaddr_list) {
42009a1a:	056a16        	beqz	a10, 42009a74 <spi_flash_mmap+0x84>
    block->vaddr_list = vaddr_list;
42009a1d:	07a9      	s32i.n	a10, a7, 0
    if (memory == SPI_FLASH_MMAP_INST) {
42009a1f:	041466        	bnei	a4, 1, 42009a27 <spi_flash_mmap+0x37>
        caps = MMU_MEM_CAP_EXEC | MMU_MEM_CAP_32BIT;
42009a22:	9d0c      	movi.n	a13, 9
42009a24:	000086        	j	42009a2a <spi_flash_mmap+0x3a>
        caps = MMU_MEM_CAP_READ | MMU_MEM_CAP_8BIT;
42009a27:	12a0d2        	movi	a13, 18
    ret = esp_mmu_map(src_addr, size, MMU_TARGET_FLASH0, caps, ESP_MMU_MMAP_FLAG_PADDR_SHARED, &ptr);
42009a2a:	20f110        	or	a15, a1, a1
42009a2d:	01a0e2        	movi	a14, 1
42009a30:	0ecd      	mov.n	a12, a14
42009a32:	03bd      	mov.n	a11, a3
42009a34:	02ad      	mov.n	a10, a2
42009a36:	ff9aa5        	call8	420093e0 <esp_mmu_map>
42009a39:	0a2d      	mov.n	a2, a10
    if (ret == ESP_OK) {
42009a3b:	9acc      	bnez.n	a10, 42009a48 <spi_flash_mmap+0x58>
        vaddr_list[0] = (uint32_t)ptr;
42009a3d:	0188      	l32i.n	a8, a1, 0
42009a3f:	0689      	s32i.n	a8, a6, 0
        block->list_num = 1;
42009a41:	180c      	movi.n	a8, 1
42009a43:	1789      	s32i.n	a8, a7, 4
42009a45:	0005c6        	j	42009a60 <spi_flash_mmap+0x70>
    } else if (ret == ESP_ERR_INVALID_STATE) {
42009a48:	03a182        	movi	a8, 0x103
42009a4b:	069a87        	bne	a10, a8, 42009a55 <spi_flash_mmap+0x65>
        block->list_num = 0;
42009a4e:	080c      	movi.n	a8, 0
42009a50:	1789      	s32i.n	a8, a7, 4
42009a52:	000286        	j	42009a60 <spi_flash_mmap+0x70>
        free(vaddr_list);
42009a55:	06ad      	mov.n	a10, a6
42009a57:	dac481        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42009a5a:	0008e0        	callx8	a8
42009a5d:	000586        	j	42009a77 <spi_flash_mmap+0x87>
    *out_ptr = ptr;
42009a60:	0188      	l32i.n	a8, a1, 0
42009a62:	0589      	s32i.n	a8, a5, 0
    *out_handle = (uint32_t)block;
42009a64:	4188      	l32i.n	a8, a1, 16
42009a66:	0879      	s32i.n	a7, a8, 0
    return ESP_OK;
42009a68:	020c      	movi.n	a2, 0
42009a6a:	0004c6        	j	42009a81 <spi_flash_mmap+0x91>
        ret = ESP_ERR_NO_MEM;
42009a6d:	01a122        	movi	a2, 0x101
42009a70:	0000c6        	j	42009a77 <spi_flash_mmap+0x87>
42009a73:	a12200        	sll	a2, a2
        ret = ESP_ERR_NO_MEM;
42009a76:	678c01        	l32r	a0, 41fe38a8 <_coredump_iram_end+0x1c619a8>
        free(block);
42009a79:	07ad      	mov.n	a10, a7
42009a7b:	dabb81        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42009a7e:	0008e0        	callx8	a8
}
42009a81:	f01d      	retw.n
	...

42009a84 <spi_flash_munmap>:
{
42009a84:	004136        	entry	a1, 32
    for (int i = 0; i < block->list_num; i++) {
42009a87:	070c      	movi.n	a7, 0
42009a89:	0008c6        	j	42009ab0 <spi_flash_munmap+0x2c>
        ret = esp_mmu_unmap((void *)block->vaddr_list[i]);
42009a8c:	0288      	l32i.n	a8, a2, 0
42009a8e:	a08780        	addx4	a8, a7, a8
42009a91:	08a8      	l32i.n	a10, a8, 0
42009a93:	ffd225        	call8	420097b4 <esp_mmu_unmap>
        if (ret == ESP_ERR_NOT_FOUND) {
42009a96:	05a182        	movi	a8, 0x105
42009a99:	119a87        	bne	a10, a8, 42009aae <spi_flash_munmap+0x2a>
            assert(0 && "invalid handle, or handle already unmapped");
42009a9c:	dc15d1        	l32r	a13, 42000af0 <_stext+0xad0> (3c026220 <_flash_rodata_start+0x6100>)
42009a9f:	dc15c1        	l32r	a12, 42000af4 <_stext+0xad4> (3c028760 <__func__$1>)
42009aa2:	f4a0b2        	movi	a11, 244
42009aa5:	dc14a1        	l32r	a10, 42000af8 <_stext+0xad8> (3c026213 <_flash_rodata_start+0x60f3>)
42009aa8:	d98681        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42009aab:	0008e0        	callx8	a8
    for (int i = 0; i < block->list_num; i++) {
42009aae:	771b      	addi.n	a7, a7, 1
42009ab0:	1288      	l32i.n	a8, a2, 4
42009ab2:	d62787        	blt	a7, a8, 42009a8c <spi_flash_munmap+0x8>
    free(block->vaddr_list);
42009ab5:	02a8      	l32i.n	a10, a2, 0
42009ab7:	daac81        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42009aba:	0008e0        	callx8	a8
    free(block);
42009abd:	02ad      	mov.n	a10, a2
42009abf:	daaa81        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
42009ac2:	0008e0        	callx8	a8
}
42009ac5:	f01d      	retw.n
	...

42009ac8 <spi_flash_cache2phys>:

#if !CONFIG_SPI_FLASH_ROM_IMPL || CONFIG_SPIRAM_FETCH_INSTRUCTIONS || CONFIG_SPIRAM_RODATA
//The ROM implementation returns physical address of the PSRAM when the .text or .rodata is in the PSRAM.
//Always patch it when SPIRAM_FETCH_INSTRUCTIONS or SPIRAM_RODATA is set.
size_t spi_flash_cache2phys(const void *cached)
{
42009ac8:	006136        	entry	a1, 48
42009acb:	02ad      	mov.n	a10, a2
    if (cached == NULL) {
42009acd:	229c      	beqz.n	a2, 42009ae3 <spi_flash_cache2phys+0x1b>
        return SPI_FLASH_CACHE2PHYS_FAIL;
    }

    esp_err_t ret = ESP_FAIL;
    uint32_t paddr = 0;
42009acf:	080c      	movi.n	a8, 0
42009ad1:	0189      	s32i.n	a8, a1, 0
    mmu_target_t target = 0;
42009ad3:	1189      	s32i.n	a8, a1, 4
    if (paddr != SPI_FLASH_CACHE2PHYS_FAIL) {
        return paddr;
    }
#endif

    ret = esp_mmu_vaddr_to_paddr((void *)cached, &paddr, &target);
42009ad5:	c14b      	addi.n	a12, a1, 4
42009ad7:	01bd      	mov.n	a11, a1
42009ad9:	ffdfe5        	call8	420098d8 <esp_mmu_vaddr_to_paddr>
    if (ret != ESP_OK) {
42009adc:	8acc      	bnez.n	a10, 42009ae8 <spi_flash_cache2phys+0x20>
        offset = instruction_flash2spiram_offset();
    }
#endif
#endif  //#if !CONFIG_SPIRAM_FLASH_LOAD_TO_PSRAM

    return paddr + offset * CONFIG_MMU_PAGE_SIZE;
42009ade:	0128      	l32i.n	a2, a1, 0
42009ae0:	000186        	j	42009aea <spi_flash_cache2phys+0x22>
        return SPI_FLASH_CACHE2PHYS_FAIL;
42009ae3:	f27c      	movi.n	a2, -1
42009ae5:	000046        	j	42009aea <spi_flash_cache2phys+0x22>
        return SPI_FLASH_CACHE2PHYS_FAIL;
42009ae8:	f27c      	movi.n	a2, -1
}
42009aea:	f01d      	retw.n

42009aec <esp_mspi_get_io>:
{
42009aec:	004136        	entry	a1, 32
    assert(io <= ESP_MSPI_IO_D7);
42009aef:	a80c      	movi.n	a8, 10
42009af1:	11b827        	bgeu	a8, a2, 42009b06 <esp_mspi_get_io+0x1a>
42009af4:	dc02d1        	l32r	a13, 42000afc <_stext+0xadc> (3c026254 <_flash_rodata_start+0x6134>)
42009af7:	dc02c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c028774 <__func__$0>)
42009afa:	f5a0b2        	movi	a11, 245
42009afd:	dc01a1        	l32r	a10, 42000b04 <_stext+0xae4> (3c026287 <_flash_rodata_start+0x6167>)
42009b00:	d97081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42009b03:	0008e0        	callx8	a8
    if (io == ESP_MSPI_IO_WP) {
42009b06:	1e5266        	bnei	a2, 5, 42009b28 <esp_mspi_get_io+0x3c>
        spiconfig = esp_rom_efuse_get_flash_wp_gpio();
42009b09:	dc0081        	l32r	a8, 42000b0c <_stext+0xaec> (40001fa4 <esp_rom_efuse_get_flash_wp_gpio>)
42009b0c:	0008e0        	callx8	a8
        return (spiconfig == 0x3f) ? s_mspi_io_num_default[io] : spiconfig & 0x3f;
42009b0f:	f83c      	movi.n	a8, 63
42009b11:	0b9a87        	bne	a10, a8, 42009b20 <esp_mspi_get_io+0x34>
42009b14:	dbfd81        	l32r	a8, 42000b08 <_stext+0xae8> (3c028784 <s_mspi_io_num_default>)
42009b17:	882a      	add.n	a8, a8, a2
42009b19:	000822        	l8ui	a2, a8, 0
42009b1c:	001246        	j	42009b69 <esp_mspi_get_io+0x7d>
42009b1f:	20a000        	or	a10, a0, a0
42009b22:	108654        	lsi	f5, a6, 64
42009b25:	000000        	ill
    spiconfig = (io < ESP_MSPI_IO_WP) ? esp_rom_efuse_get_flash_gpio_info() : esp_rom_efuse_get_opiconfig();
42009b28:	0852f6        	bgeui	a2, 5, 42009b34 <esp_mspi_get_io+0x48>
42009b2b:	dbf981        	l32r	a8, 42000b10 <_stext+0xaf0> (40001f74 <esp_rom_efuse_get_flash_gpio_info>)
42009b2e:	0008e0        	callx8	a8
42009b31:	000086        	j	42009b37 <esp_mspi_get_io+0x4b>
42009b34:	002fe5        	call8	42009e34 <esp_rom_efuse_get_opiconfig>
    if (spiconfig == ESP_ROM_EFUSE_FLASH_DEFAULT_SPI) {
42009b37:	9acc      	bnez.n	a10, 42009b44 <esp_mspi_get_io+0x58>
        mspi_io = s_mspi_io_num_default[io];
42009b39:	dbf381        	l32r	a8, 42000b08 <_stext+0xae8> (3c028784 <s_mspi_io_num_default>)
42009b3c:	882a      	add.n	a8, a8, a2
42009b3e:	000822        	l8ui	a2, a8, 0
42009b41:	000906        	j	42009b69 <esp_mspi_get_io+0x7d>
    } else if (io < ESP_MSPI_IO_WP) {
42009b44:	1052f6        	bgeui	a2, 5, 42009b58 <esp_mspi_get_io+0x6c>
        mspi_io = (spiconfig >> io * 6) & 0x3f;
42009b47:	902220        	addx2	a2, a2, a2
42009b4a:	222a      	add.n	a2, a2, a2
42009b4c:	400200        	ssr	a2
42009b4f:	91a0a0        	srl	a10, a10
42009b52:	5420a0        	extui	a2, a10, 0, 6
42009b55:	000406        	j	42009b69 <esp_mspi_get_io+0x7d>
        mspi_io = (spiconfig >> (io - ESP_MSPI_IO_DQS) * 6) & 0x3f;
42009b58:	902220        	addx2	a2, a2, a2
42009b5b:	222a      	add.n	a2, a2, a2
42009b5d:	dcc222        	addi	a2, a2, -36
42009b60:	400200        	ssr	a2
42009b63:	91a0a0        	srl	a10, a10
42009b66:	5420a0        	extui	a2, a10, 0, 6
}
42009b69:	f01d      	retw.n
	...

42009b6c <esp_mspi_pin_reserve>:
{
42009b6c:	004136        	entry	a1, 32
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
42009b6f:	070c      	movi.n	a7, 0
    uint64_t reserve_pin_mask = 0;
42009b71:	075d      	mov.n	a5, a7
42009b73:	076d      	mov.n	a6, a7
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
42009b75:	000e86        	j	42009bb3 <esp_mspi_pin_reserve+0x47>
        if (!bootloader_flash_is_octal_mode_enabled()
42009b78:	da8d81        	l32r	a8, 420005ac <_stext+0x58c> (40377670 <bootloader_flash_is_octal_mode_enabled>)
42009b7b:	0008e0        	callx8	a8
42009b7e:	4acc      	bnez.n	a10, 42009b86 <esp_mspi_pin_reserve+0x1a>
            && i >=  ESP_MSPI_IO_DQS && i <= ESP_MSPI_IO_D7) {
42009b80:	fac782        	addi	a8, a7, -6
42009b83:	2958b6        	bltui	a8, 5, 42009bb0 <esp_mspi_pin_reserve+0x44>
        mspi_io = esp_mspi_get_io(i);
42009b86:	20a770        	or	a10, a7, a7
42009b89:	fff625        	call8	42009aec <esp_mspi_get_io>
        if (mspi_io < 64) {     // 'reserve_pin_mask' have 64 bits length
42009b8c:	3fa082        	movi	a8, 63
42009b8f:	1d38a7        	bltu	a8, a10, 42009bb0 <esp_mspi_pin_reserve+0x44>
            reserve_pin_mask |= BIT64(mspi_io);
42009b92:	20a092        	movi	a9, 32
42009b95:	109a90        	and	a9, a10, a9
42009b98:	0b0c      	movi.n	a11, 0
42009b9a:	180c      	movi.n	a8, 1
42009b9c:	401a00        	ssl	a10
42009b9f:	a18800        	sll	a8, a8
42009ba2:	08ad      	mov.n	a10, a8
42009ba4:	83ab90        	moveqz	a10, a11, a9
42009ba7:	938b90        	movnez	a8, a11, a9
42009baa:	205580        	or	a5, a5, a8
42009bad:	2066a0        	or	a6, a6, a10
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
42009bb0:	01c772        	addi	a7, a7, 1
42009bb3:	0aa082        	movi	a8, 10
42009bb6:	beb877        	bgeu	a8, a7, 42009b78 <esp_mspi_pin_reserve+0xc>
    esp_gpio_reserve(reserve_pin_mask);
42009bb9:	20a550        	or	a10, a5, a5
42009bbc:	06bd      	mov.n	a11, a6
42009bbe:	0053a5        	call8	4200a0f8 <esp_gpio_reserve>
}
42009bc1:	f01d      	retw.n
	...

42009bc4 <esp_flash_read_chip_id>:
{
42009bc4:	004136        	entry	a1, 32
42009bc7:	02ad      	mov.n	a10, a2
42009bc9:	03bd      	mov.n	a11, a3
    return read_id_core(chip, out_id, true);
42009bcb:	01a0c2        	movi	a12, 1
42009bce:	dbd181        	l32r	a8, 42000b14 <_stext+0xaf4> (40377c54 <read_id_core>)
42009bd1:	0008e0        	callx8	a8
}
42009bd4:	0a2d      	mov.n	a2, a10
42009bd6:	f01d      	retw.n

42009bd8 <spimem_flash_ll_get_source_freq_mhz>:
{
42009bd8:	004136        	entry	a1, 32
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
42009bdb:	dbcf81        	l32r	a8, 42000b18 <_stext+0xaf8> (60003000 <SPIMEM0>)
42009bde:	0020c0        	memw
42009be1:	3b2882        	l32i	a8, a8, 236
42009be4:	148080        	extui	a8, a8, 0, 2
42009be7:	132826        	beqi	a8, 2, 42009bfe <spimem_flash_ll_get_source_freq_mhz+0x26>
42009bea:	0738f6        	bgeui	a8, 3, 42009bf5 <spimem_flash_ll_get_source_freq_mhz+0x1d>
42009bed:	389c      	beqz.n	a8, 42009c04 <spimem_flash_ll_get_source_freq_mhz+0x2c>
42009bef:	161826        	beqi	a8, 1, 42009c09 <spimem_flash_ll_get_source_freq_mhz+0x31>
42009bf2:	000086        	j	42009bf8 <spimem_flash_ll_get_source_freq_mhz+0x20>
42009bf5:	173826        	beqi	a8, 3, 42009c10 <spimem_flash_ll_get_source_freq_mhz+0x38>
        abort();
42009bf8:	d93f81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42009bfb:	0008e0        	callx8	a8
        clock_val = 160;
42009bfe:	a0a022        	movi	a2, 160
42009c01:	000386        	j	42009c13 <spimem_flash_ll_get_source_freq_mhz+0x3b>
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
42009c04:	025c      	movi.n	a2, 80
42009c06:	000246        	j	42009c13 <spimem_flash_ll_get_source_freq_mhz+0x3b>
        clock_val = 120;
42009c09:	78a022        	movi	a2, 120
42009c0c:	0000c6        	j	42009c13 <spimem_flash_ll_get_source_freq_mhz+0x3b>
42009c0f:	a02200        	addx4	a2, a2, a0
        clock_val = 240;
42009c12:	f01df0        	subx8	a1, a13, a15
42009c15:	000000        	ill

42009c18 <s_esp_flash_choose_correct_mode>:
};

#if CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT
/* This function is used to correct flash mode if config option is not consistent with efuse information */
static void s_esp_flash_choose_correct_mode(memspi_host_config_t *cfg)
{
42009c18:	004136        	entry	a1, 32
    static const char *mode = FLASH_MODE_STRING;
    if (bootloader_flash_is_octal_mode_enabled()) {
42009c1b:	da6481        	l32r	a8, 420005ac <_stext+0x58c> (40377670 <bootloader_flash_is_octal_mode_enabled>)
42009c1e:	0008e0        	callx8	a8
42009c21:	baac      	beqz.n	a10, 42009c50 <s_esp_flash_choose_correct_mode+0x38>
42009c23:	d90281        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42009c26:	0888      	l32i.n	a8, a8, 0
    #if !CONFIG_ESPTOOLPY_FLASHMODE_OPI
        ESP_EARLY_LOGW(TAG, "Octal flash chip is using but %s mode is selected, will automatically switch to Octal mode", mode);
42009c28:	1628b6        	bltui	a8, 2, 42009c42 <s_esp_flash_choose_correct_mode+0x2a>
42009c2b:	d90d81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009c2e:	0008e0        	callx8	a8
42009c31:	dbbad1        	l32r	a13, 42000b1c <_stext+0xafc> (3c026478 <_flash_rodata_start+0x6358>)
42009c34:	dbbbc1        	l32r	a12, 42000b20 <_stext+0xb00> (3c028860 <TAG>)
42009c37:	0abd      	mov.n	a11, a10
42009c39:	dbbaa1        	l32r	a10, 42000b24 <_stext+0xb04> (3c02647c <_flash_rodata_start+0x635c>)
42009c3c:	d90a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42009c3f:	0008e0        	callx8	a8
        cfg->octal_mode_en = 1;
42009c42:	180c      	movi.n	a8, 1
42009c44:	294282        	s8i	a8, a2, 41
        cfg->default_io_mode = SPI_FLASH_OPI_STR;
42009c47:	081c      	movi.n	a8, 16
42009c49:	b289      	s32i.n	a8, a2, 44
        default_chip.read_mode = SPI_FLASH_OPI_STR;
42009c4b:	dbb791        	l32r	a9, 42000b28 <_stext+0xb08> (3fc93578 <default_chip>)
42009c4e:	4989      	s32i.n	a8, a9, 16
        cfg->octal_mode_en = 0;
        cfg->default_io_mode = SPI_FLASH_DIO;
        default_chip.read_mode = SPI_FLASH_DIO;
    #endif
    }
}
42009c50:	f01d      	retw.n
	...

42009c54 <esp_flash_init_default_chip>:
#endif // CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT

extern esp_err_t esp_flash_suspend_cmd_init(esp_flash_t* chip);
esp_err_t esp_flash_init_default_chip(void)
{
42009c54:	00c136        	entry	a1, 96
    const esp_rom_spiflash_chip_t *legacy_chip = &g_rom_flashchip;
42009c57:	db6e81        	l32r	a8, 42000a10 <_stext+0x9f0> (3fceffe4 <rom_spiflash_legacy_data>)
42009c5a:	0878      	l32i.n	a7, a8, 0
    memspi_host_config_t cfg = ESP_FLASH_HOST_CONFIG_DEFAULT();
42009c5c:	cc3c      	movi.n	a12, 60
42009c5e:	0b0c      	movi.n	a11, 0
42009c60:	20a110        	or	a10, a1, a1
42009c63:	d9a781        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42009c66:	0008e0        	callx8	a8
42009c69:	180c      	movi.n	a8, 1
42009c6b:	0c4182        	s8i	a8, a1, 12
42009c6e:	144182        	s8i	a8, a1, 20
42009c71:	085c      	movi.n	a8, 80
42009c73:	c189      	s32i.n	a8, a1, 48

    #if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C3
    // Only these chips have efuses for spi pin configuration.
    cfg.iomux = esp_rom_efuse_get_flash_gpio_info() == 0 ?  true : false;
42009c75:	dba681        	l32r	a8, 42000b10 <_stext+0xaf0> (40001f74 <esp_rom_efuse_get_flash_gpio_info>)
42009c78:	0008e0        	callx8	a8
42009c7b:	40faa0        	nsau	a10, a10
42009c7e:	41a5a0        	srli	a10, a10, 5
42009c81:	1441a2        	s8i	a10, a1, 20
    cfg.default_io_mode = DEFAULT_FLASH_MODE;
    #endif

    #if CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT
    // Automatically detect flash mode in run time
    s_esp_flash_choose_correct_mode(&cfg);
42009c84:	01ad      	mov.n	a10, a1
42009c86:	fff925        	call8	42009c18 <s_esp_flash_choose_correct_mode>
    #endif


    // For chips need time tuning, get value directly from system here.
    #if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    if (spi_flash_timing_is_tuned()) {
42009c89:	dbae81        	l32r	a8, 42000b44 <_stext+0xb24> (40378540 <spi_flash_timing_is_tuned>)
42009c8c:	0008e0        	callx8	a8
42009c8f:	ba8c      	beqz.n	a10, 42009c9e <esp_flash_init_default_chip+0x4a>
        cfg.using_timing_tuning = 1;
42009c91:	180c      	movi.n	a8, 1
42009c93:	2a4182        	s8i	a8, a1, 42
        spi_timing_get_flash_timing_param(&cfg.timing_reg);
42009c96:	01ad      	mov.n	a10, a1
42009c98:	dbac81        	l32r	a8, 42000b48 <_stext+0xb28> (403784cc <spi_timing_get_flash_timing_param>)
42009c9b:	0008e0        	callx8	a8
    }
    #endif // SOC_SPI_MEM_SUPPORT_TIMING_TUNING

    cfg.clock_src_freq = spi_flash_ll_get_source_clock_freq_mhz(cfg.host_id);
42009c9e:	8188      	l32i.n	a8, a1, 32
42009ca0:	58cc      	bnez.n	a8, 42009ca9 <esp_flash_init_default_chip+0x55>
42009ca2:	fff365        	call8	42009bd8 <spimem_flash_ll_get_source_freq_mhz>
42009ca5:	000086        	j	42009cab <esp_flash_init_default_chip+0x57>
42009ca8:	0a5c00        	add.s	f5, f12, f0
42009cab:	d1a9      	s32i.n	a10, a1, 52
    #if CONFIG_SPI_FLASH_AUTO_CHECK_SUSPEND_STATUS
    cfg.auto_waiti_pes = true;
    #endif

    //the host is already initialized, only do init for the data and load it to the host
    esp_err_t err = memspi_host_init_pointers(&esp_flash_default_host, &cfg);
42009cad:	01bd      	mov.n	a11, a1
42009caf:	db9fa1        	l32r	a10, 42000b2c <_stext+0xb0c> (3fc93598 <esp_flash_default_host>)
42009cb2:	dba681        	l32r	a8, 42000b4c <_stext+0xb2c> (40380158 <memspi_host_init_pointers>)
42009cb5:	0008e0        	callx8	a8
42009cb8:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
42009cba:	0bba56        	bnez	a10, 42009d79 <esp_flash_init_default_chip+0x125>
        return err;
    }

    // ROM TODO: account for non-standard default pins in efuse
    // ROM TODO: to account for chips which are slow to power on, maybe keep probing in a loop here
    err = esp_flash_init_main(&default_chip);
42009cbd:	db9aa1        	l32r	a10, 42000b28 <_stext+0xb08> (3fc93578 <default_chip>)
42009cc0:	dba481        	l32r	a8, 42000b50 <_stext+0xb30> (40377d30 <esp_flash_init_main>)
42009cc3:	0008e0        	callx8	a8
42009cc6:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
42009cc8:	0ada56        	bnez	a10, 42009d79 <esp_flash_init_default_chip+0x125>
        return err;
    }
    if (default_chip.size < legacy_chip->chip_size) {
42009ccb:	db9781        	l32r	a8, 42000b28 <_stext+0xb08> (3fc93578 <default_chip>)
42009cce:	5888      	l32i.n	a8, a8, 20
42009cd0:	012792        	l32i	a9, a7, 4
42009cd3:	31b897        	bgeu	a8, a9, 42009d08 <esp_flash_init_default_chip+0xb4>
42009cd6:	d8d581        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42009cd9:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Detected size(%dk) smaller than the size in the binary image header(%dk). Probe failed.", default_chip.size/1024, legacy_chip->chip_size/1024);
42009cdc:	020816        	beqz	a8, 42009d00 <esp_flash_init_default_chip+0xac>
42009cdf:	d8e081        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009ce2:	0008e0        	callx8	a8
42009ce5:	db9081        	l32r	a8, 42000b28 <_stext+0xb08> (3fc93578 <default_chip>)
42009ce8:	58d8      	l32i.n	a13, a8, 20
42009cea:	17e8      	l32i.n	a14, a7, 4
42009cec:	41eae0        	srli	a14, a14, 10
42009cef:	41dad0        	srli	a13, a13, 10
42009cf2:	db8bc1        	l32r	a12, 42000b20 <_stext+0xb00> (3c028860 <TAG>)
42009cf5:	0abd      	mov.n	a11, a10
42009cf7:	db8ea1        	l32r	a10, 42000b30 <_stext+0xb10> (3c0264e4 <_flash_rodata_start+0x63c4>)
42009cfa:	d8da81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42009cfd:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_SIZE_NOT_MATCH;
42009d00:	04a122        	movi	a2, 0x104
42009d03:	001c86        	j	42009d79 <esp_flash_init_default_chip+0x125>
42009d06:	870000        	lsi	f0, a0, 0x21c
    }

    if (default_chip.size > legacy_chip->chip_size) {
42009d09:	28b9      	s32i.n	a11, a8, 8
42009d0b:	d8c881        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42009d0e:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGW(TAG, "Detected size(%dk) larger than the size in the binary image header(%dk). Using the size in the binary image header.", default_chip.size/1024, legacy_chip->chip_size/1024);
42009d10:	2028b6        	bltui	a8, 2, 42009d34 <esp_flash_init_default_chip+0xe0>
42009d13:	d8d381        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009d16:	0008e0        	callx8	a8
42009d19:	db8381        	l32r	a8, 42000b28 <_stext+0xb08> (3fc93578 <default_chip>)
42009d1c:	58d8      	l32i.n	a13, a8, 20
42009d1e:	17e8      	l32i.n	a14, a7, 4
42009d20:	41eae0        	srli	a14, a14, 10
42009d23:	41dad0        	srli	a13, a13, 10
42009d26:	db7ec1        	l32r	a12, 42000b20 <_stext+0xb00> (3c028860 <TAG>)
42009d29:	0abd      	mov.n	a11, a10
42009d2b:	db82a1        	l32r	a10, 42000b34 <_stext+0xb14> (3c02654c <_flash_rodata_start+0x642c>)
42009d2e:	d8cd81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42009d31:	0008e0        	callx8	a8
    }
#if !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM // IDF-10019
    if (legacy_chip->chip_size > 16 * 1024 * 1024) {
42009d34:	1788      	l32i.n	a8, a7, 4
42009d36:	d91d91        	l32r	a9, 420001ac <_stext+0x18c> (1000000 <UserFrameTotalSize+0xffff00>)
42009d39:	30b987        	bgeu	a9, a8, 42009d6d <esp_flash_init_default_chip+0x119>
        ESP_RETURN_ON_ERROR_ISR(esp_mspi_32bit_address_flash_feature_check(), TAG, "32bit address feature check failed");
42009d3c:	db8681        	l32r	a8, 42000b54 <_stext+0xb34> (40378150 <esp_mspi_32bit_address_flash_feature_check>)
42009d3f:	0008e0        	callx8	a8
42009d42:	0a6d      	mov.n	a6, a10
42009d44:	5aac      	beqz.n	a10, 42009d6d <esp_flash_init_default_chip+0x119>
42009d46:	d8b981        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42009d49:	0888      	l32i.n	a8, a8, 0
42009d4b:	019816        	beqz	a8, 42009d68 <esp_flash_init_default_chip+0x114>
42009d4e:	d8c481        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009d51:	0008e0        	callx8	a8
42009d54:	9fa1e2        	movi	a14, 0x19f
42009d57:	db78d1        	l32r	a13, 42000b38 <_stext+0xb18> (3c028844 <__FUNCTION__$1>)
42009d5a:	db71c1        	l32r	a12, 42000b20 <_stext+0xb00> (3c028860 <TAG>)
42009d5d:	0abd      	mov.n	a11, a10
42009d5f:	db77a1        	l32r	a10, 42000b3c <_stext+0xb1c> (3c0265d0 <_flash_rodata_start+0x64b0>)
42009d62:	d8c081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42009d65:	0008e0        	callx8	a8
42009d68:	062d      	mov.n	a2, a6
42009d6a:	0002c6        	j	42009d79 <esp_flash_init_default_chip+0x125>
    }
#endif // !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM
    // Set chip->size equal to ROM flash size(also equal to the size in binary image header), which means the available size that can be used
    default_chip.size = legacy_chip->chip_size;
42009d6d:	1798      	l32i.n	a9, a7, 4
42009d6f:	db6e81        	l32r	a8, 42000b28 <_stext+0xb08> (3fc93578 <default_chip>)
42009d72:	5899      	s32i.n	a9, a8, 20

    esp_flash_default_chip = &default_chip;
42009d74:	db7391        	l32r	a9, 42000b40 <_stext+0xb20> (3fc95eec <esp_flash_default_chip>)
42009d77:	0989      	s32i.n	a8, a9, 0
        default_chip.hpm_dummy_ena = 1;
    }
#endif

    return ESP_OK;
}
42009d79:	f01d      	retw.n
	...

42009d7c <esp_flash_app_init>:

esp_err_t esp_flash_app_init(void)
{
42009d7c:	004136        	entry	a1, 32
    };
    err = esp_ldo_acquire_channel(&ldo_config, &s_ldo_chan);
    if (err != ESP_OK) return err;
#endif // CONFIG_ESP_LDO_RESERVE_SPI_NOR_FLASH

    spi_flash_init_lock();
42009d7f:	ffc265        	call8	420099a4 <spi_flash_init_lock>
    spi_flash_guard_set(&g_flash_guard_default_ops);
42009d82:	db75a1        	l32r	a10, 42000b58 <_stext+0xb38> (3fc93550 <g_flash_guard_default_ops>)
42009d85:	db7581        	l32r	a8, 42000b5c <_stext+0xb3c> (40377b14 <spi_flash_guard_set>)
42009d88:	0008e0        	callx8	a8
#endif
#if CONFIG_SPI_FLASH_SHARE_SPI1_BUS
    err = esp_flash_init_main_bus_lock();
    if (err != ESP_OK) return err;
#endif
    err = esp_flash_app_enable_os_functions(&default_chip);
42009d8b:	db67a1        	l32r	a10, 42000b28 <_stext+0xb08> (3fc93578 <default_chip>)
42009d8e:	0000a5        	call8	42009d98 <esp_flash_app_enable_os_functions>
    return err;
}
42009d91:	202aa0        	or	a2, a10, a10
42009d94:	000090        	retw
	...

42009d98 <esp_flash_app_enable_os_functions>:
{
42009d98:	004136        	entry	a1, 32
    main_flash_arg = (app_func_arg_t) {
42009d9b:	db7181        	l32r	a8, 42000b60 <_stext+0xb40> (3c0290b0 <g_spi_lock_main_flash_dev>)
42009d9e:	0868      	l32i.n	a6, a8, 0
42009da0:	db7171        	l32r	a7, 42000b64 <_stext+0xb44> (3fc935f0 <main_flash_arg>)
42009da3:	0c1c      	movi.n	a12, 16
42009da5:	0b0c      	movi.n	a11, 0
42009da7:	20a770        	or	a10, a7, a7
42009daa:	d95581        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42009dad:	0008e0        	callx8	a8
42009db0:	0769      	s32i.n	a6, a7, 0
    chip->os_func = &esp_flash_spi1_default_os_functions;
42009db2:	db6d81        	l32r	a8, 42000b68 <_stext+0xb48> (3fc935c8 <esp_flash_spi1_default_os_functions>)
42009db5:	2289      	s32i.n	a8, a2, 8
    chip->os_func_data = &main_flash_arg;
42009db7:	3279      	s32i.n	a7, a2, 12
}
42009db9:	020c      	movi.n	a2, 0
42009dbb:	f01d      	retw.n
42009dbd:	000000        	ill

42009dc0 <esp_crosscore_int_init>:
{
42009dc0:	004136        	entry	a1, 32
42009dc3:	fb7c      	movi.n	a11, -1
42009dc5:	db69a1        	l32r	a10, 42000b6c <_stext+0xb4c> (3fc92674 <reason_spinlock>)
42009dc8:	d99281        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
42009dcb:	0008e0        	callx8	a8
    asm volatile (
42009dce:	03eb80        	rsr.prid	a8
42009dd1:	048d80        	extui	a8, a8, 13, 1
    reason[esp_cpu_get_core_id()] = 0;
42009dd4:	db6791        	l32r	a9, 42000b70 <_stext+0xb50> (3fc95ef8 <reason>)
42009dd7:	a08890        	addx4	a8, a8, a9
42009dda:	090c      	movi.n	a9, 0
42009ddc:	0020c0        	memw
42009ddf:	006892        	s32i	a9, a8, 0
    portEXIT_CRITICAL(&reason_spinlock);
42009de2:	db62a1        	l32r	a10, 42000b6c <_stext+0xb4c> (3fc92674 <reason_spinlock>)
42009de5:	d98b81        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
42009de8:	0008e0        	callx8	a8
42009deb:	03eb80        	rsr.prid	a8
42009dee:	048d80        	extui	a8, a8, 13, 1
    if (esp_cpu_get_core_id() == 0) {
42009df1:	48dc      	bnez.n	a8, 42009e09 <esp_crosscore_int_init+0x49>
        err = esp_intr_alloc(ETS_FROM_CPU_INTR0_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[0], NULL);
42009df3:	0e0c      	movi.n	a14, 0
42009df5:	db5ed1        	l32r	a13, 42000b70 <_stext+0xb50> (3fc95ef8 <reason>)
42009df8:	db5fc1        	l32r	a12, 42000b74 <_stext+0xb54> (40378028 <esp_crosscore_isr>)
42009dfb:	00a4b2        	movi	a11, 0x400
42009dfe:	4fa0a2        	movi	a10, 79
42009e01:	f9a4a5        	call8	4200384c <esp_intr_alloc>
42009e04:	0004c6        	j	42009e1b <esp_crosscore_int_init+0x5b>
42009e07:	e20000        	remu	a0, a0, a0
        err = esp_intr_alloc(ETS_FROM_CPU_INTR1_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[1], NULL);
42009e0a:	d100a0        	mul16s	a0, a0, a10
42009e0d:	db5b      	addi.n	a13, a11, 5
42009e0f:	db59c1        	l32r	a12, 42000b74 <_stext+0xb54> (40378028 <esp_crosscore_isr>)
42009e12:	00a4b2        	movi	a11, 0x400
42009e15:	50a0a2        	movi	a10, 80
42009e18:	f9a325        	call8	4200384c <esp_intr_alloc>
    ESP_ERROR_CHECK(err);
42009e1b:	011a16        	beqz	a10, 42009e30 <esp_crosscore_int_init+0x70>
42009e1e:	db57e1        	l32r	a14, 42000b7c <_stext+0xb5c> (3c0266a8 <_flash_rodata_start+0x6588>)
42009e21:	db57d1        	l32r	a13, 42000b80 <_stext+0xb60> (3c0288a0 <__func__$1>)
42009e24:	6ca0c2        	movi	a12, 108
42009e27:	db57b1        	l32r	a11, 42000b84 <_stext+0xb64> (3c0266ac <_flash_rodata_start+0x658c>)
42009e2a:	db5781        	l32r	a8, 42000b88 <_stext+0xb68> (40379760 <_esp_error_check_failed>)
42009e2d:	0008e0        	callx8	a8
}
42009e30:	f01d      	retw.n
	...

42009e34 <esp_rom_efuse_get_opiconfig>:
/**
 * Since rom of esp32s3 does not export function ets_efuse_get_opiconfig,
 * patch this function here.
 */
uint32_t esp_rom_efuse_get_opiconfig(void)
{
42009e34:	004136        	entry	a1, 32
    uint64_t spiconfig1 = REG_GET_FIELD(EFUSE_RD_MAC_SPI_SYS_2_REG, EFUSE_SPI_PAD_CONF_1);
42009e37:	db5581        	l32r	a8, 42000b8c <_stext+0xb6c> (6000704c <EFUSE+0x4c>)
42009e3a:	0020c0        	memw
42009e3d:	0898      	l32i.n	a9, a8, 0
    uint64_t spiconfig2 = REG_GET_FIELD(EFUSE_RD_MAC_SPI_SYS_3_REG, EFUSE_SPI_PAD_CONF_2);
42009e3f:	db5481        	l32r	a8, 42000b90 <_stext+0xb70> (60007050 <EFUSE+0x50>)
42009e42:	0020c0        	memw
42009e45:	0888      	l32i.n	a8, a8, 0
42009e47:	118820        	slli	a8, a8, 14
42009e4a:	418e80        	srli	a8, a8, 14
    uint64_t opiconfig = (spiconfig2 << 12) | (spiconfig1 >> 20);
42009e4d:	118840        	slli	a8, a8, 12
42009e50:	b59490        	extui	a9, a9, 20, 12
42009e53:	202890        	or	a2, a8, a9
    if (opiconfig == 0 || opiconfig == 0x3fffffffllu) {
42009e56:	40f280        	nsau	a8, a2
42009e59:	418580        	srli	a8, a8, 5
42009e5c:	d91e91        	l32r	a9, 420002d4 <_stext+0x2b4> (3fffffff <ets_rom_layout_p+0xe0003>)
42009e5f:	309290        	xor	a9, a2, a9
42009e62:	40f990        	nsau	a9, a9
42009e65:	419590        	srli	a9, a9, 5
42009e68:	208890        	or	a8, a8, a9
42009e6b:	188c      	beqz.n	a8, 42009e70 <esp_rom_efuse_get_opiconfig+0x3c>
        return 0;
42009e6d:	00a022        	movi	a2, 0
    // [42:47] -- D4
    // [48:53] -- D5
    // [54:59] -- D6
    // [60:65] -- D7
    return opiconfig & 0x3fffffff;
}
42009e70:	f01d      	retw.n
	...

42009e74 <gpspi_flash_ll_calculate_clock_reg>:
 * @param clkdiv frequency division factor
 *
 * @return Register setting for the given clock division factor.
 */
static inline uint32_t gpspi_flash_ll_calculate_clock_reg(uint8_t clkdiv)
{
42009e74:	004136        	entry	a1, 32
    uint32_t div_parameter;
    // See comments of `clock` in `spi_struct.h`
    if (clkdiv == 1) {
42009e77:	211226        	beqi	a2, 1, 42009e9c <gpspi_flash_ll_calculate_clock_reg+0x28>
        div_parameter = (1 << 31);
    } else {
        div_parameter = ((clkdiv - 1) | (((clkdiv / 2 - 1) & 0xff) << 6) | (((clkdiv - 1) & 0xff) << 12));
42009e7a:	820b      	addi.n	a8, a2, -1
42009e7c:	412120        	srli	a2, a2, 1
42009e7f:	220b      	addi.n	a2, a2, -1
42009e81:	1122a0        	slli	a2, a2, 6
42009e84:	742620        	extui	a2, a2, 6, 8
42009e87:	1122a0        	slli	a2, a2, 6
42009e8a:	202820        	or	a2, a8, a2
42009e8d:	118840        	slli	a8, a8, 12
42009e90:	748c80        	extui	a8, a8, 12, 8
42009e93:	118840        	slli	a8, a8, 12
42009e96:	202280        	or	a2, a2, a8
42009e99:	000086        	j	42009e9f <gpspi_flash_ll_calculate_clock_reg+0x2b>
        div_parameter = (1 << 31);
42009e9c:	db3e21        	l32r	a2, 42000b94 <_stext+0xb74> (80000000 <_rtc_reserved_end+0x1ff00000>)
    }
    return div_parameter;
}
42009e9f:	f01d      	retw.n
42009ea1:	000000        	ill

42009ea4 <spimem_flash_ll_calculate_clock_reg>:
{
42009ea4:	004136        	entry	a1, 32
    if (clkdiv == 1) {
42009ea7:	211226        	beqi	a2, 1, 42009ecc <spimem_flash_ll_calculate_clock_reg+0x28>
        div_parameter = ((clkdiv - 1) | (((clkdiv - 1) / 2 & 0xff) << 8) | (((clkdiv - 1) & 0xff) << 16));
42009eaa:	220b      	addi.n	a2, a2, -1
42009eac:	058f20        	extui	a8, a2, 31, 1
42009eaf:	882a      	add.n	a8, a8, a2
42009eb1:	218180        	srai	a8, a8, 1
42009eb4:	118880        	slli	a8, a8, 8
42009eb7:	f48080        	extui	a8, a8, 0, 16
42009eba:	208280        	or	a8, a2, a8
42009ebd:	112200        	slli	a2, a2, 16
42009ec0:	752020        	extui	a2, a2, 16, 8
42009ec3:	112200        	slli	a2, a2, 16
42009ec6:	202820        	or	a2, a8, a2
42009ec9:	000086        	j	42009ecf <spimem_flash_ll_calculate_clock_reg+0x2b>
        div_parameter = (1 << 31);
42009ecc:	db3221        	l32r	a2, 42000b94 <_stext+0xb74> (80000000 <_rtc_reserved_end+0x1ff00000>)
}
42009ecf:	f01d      	retw.n
42009ed1:	000000        	ill

42009ed4 <extra_dummy_under_timing_tuning>:
    return apb_period_n / apbclk_n;
}

#if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
static inline int extra_dummy_under_timing_tuning(const spi_flash_hal_config_t *cfg)
{
42009ed4:	004136        	entry	a1, 32
    bool main_flash = (cfg->host_id == SPI1_HOST && cfg->cs_num == 0);
42009ed7:	8288      	l32i.n	a8, a2, 32
42009ed9:	38cc      	bnez.n	a8, 42009ee0 <extra_dummy_under_timing_tuning+0xc>
42009edb:	092282        	l32i	a8, a2, 36
42009ede:	488c      	beqz.n	a8, 42009ee6 <extra_dummy_under_timing_tuning+0x12>
         * Instead, for both Quad and Octal Flash, we use `usr_dummy` and set the whole dummy length (usr_dummy + extra_dummy) to this register.
         */
        extra_dummy = cfg->extra_dummy;
    } else {
        // TODO: for other flash chips, dummy get logic implement here. Currently, still calculate extra dummy by itself.
        abort();
42009ee0:	d88581        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42009ee3:	0008e0        	callx8	a8
        extra_dummy = cfg->extra_dummy;
42009ee6:	0228      	l32i.n	a2, a2, 0
    }

    return extra_dummy;
}
42009ee8:	f01d      	retw.n
	...

42009eec <get_flash_clock_divider>:
{
42009eec:	006136        	entry	a1, 48
    const int clk_source   = cfg->clock_src_freq;
42009eef:	d2a8      	l32i.n	a10, a2, 52
    const int clk_freq_mhz = cfg->freq_mhz;
42009ef1:	c278      	l32i.n	a7, a2, 48
    if (clk_source < clk_freq_mhz) {
42009ef3:	1faa77        	bge	a10, a7, 42009f16 <get_flash_clock_divider+0x2a>
        HAL_LOGE(TAG, "Target frequency %dMHz higher than supported.", clk_freq_mhz);
42009ef6:	d85a81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009ef9:	0008e0        	callx8	a8
42009efc:	db27b1        	l32r	a11, 42000b98 <_stext+0xb78> (3c0266d8 <_flash_rodata_start+0x65b8>)
42009eff:	07fd      	mov.n	a15, a7
42009f01:	0bed      	mov.n	a14, a11
42009f03:	0add      	mov.n	a13, a10
42009f05:	db25c1        	l32r	a12, 42000b9c <_stext+0xb7c> (3c0266e4 <_flash_rodata_start+0x65c4>)
42009f08:	1a0c      	movi.n	a10, 1
42009f0a:	d86281        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009f0d:	0008e0        	callx8	a8
        abort();
42009f10:	d87981        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42009f13:	0008e0        	callx8	a8
        best_div = (clk_source + clk_freq_mhz - 1) / clk_freq_mhz;
42009f16:	27aa      	add.n	a2, a7, a10
42009f18:	220b      	addi.n	a2, a2, -1
42009f1a:	d22270        	quos	a2, a2, a7
        const div_t res = div(clk_source, clk_freq_mhz);
42009f1d:	20b770        	or	a11, a7, a7
42009f20:	db2181        	l32r	a8, 42000ba4 <_stext+0xb84> (40001464 <div>)
42009f23:	0008e0        	callx8	a8
42009f26:	01a9      	s32i.n	a10, a1, 0
42009f28:	11b9      	s32i.n	a11, a1, 4
        if (res.rem != 0) {
42009f2a:	1188      	l32i.n	a8, a1, 4
42009f2c:	889c      	beqz.n	a8, 42009f48 <get_flash_clock_divider+0x5c>
            HAL_LOGW(TAG, "Flash clock frequency round down to %d", res.quot);
42009f2e:	d84c81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42009f31:	0008e0        	callx8	a8
42009f34:	db19b1        	l32r	a11, 42000b98 <_stext+0xb78> (3c0266d8 <_flash_rodata_start+0x65b8>)
42009f37:	01f8      	l32i.n	a15, a1, 0
42009f39:	0bed      	mov.n	a14, a11
42009f3b:	0add      	mov.n	a13, a10
42009f3d:	db18c1        	l32r	a12, 42000ba0 <_stext+0xb80> (3c026720 <_flash_rodata_start+0x6600>)
42009f40:	2a0c      	movi.n	a10, 2
42009f42:	d85481        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42009f45:	0008e0        	callx8	a8
}
42009f48:	f01d      	retw.n
	...

42009f4c <spi_flash_cal_clock>:
{
42009f4c:	004136        	entry	a1, 32
42009f4f:	20a220        	or	a10, a2, a2
    uint32_t div_parameter = spi_flash_ll_calculate_clock_reg(cfg->host_id, get_flash_clock_divider(cfg));
42009f52:	082282        	l32i	a8, a2, 32
42009f55:	010856        	bnez	a8, 42009f69 <spi_flash_cal_clock+0x1d>
42009f58:	fff925        	call8	42009eec <get_flash_clock_divider>
42009f5b:	74a0a0        	extui	a10, a10, 0, 8
42009f5e:	fff465        	call8	42009ea4 <spimem_flash_ll_calculate_clock_reg>
42009f61:	0a2d      	mov.n	a2, a10
42009f63:	000386        	j	42009f75 <spi_flash_cal_clock+0x29>
42009f66:	000000        	ill
42009f69:	fff825        	call8	42009eec <get_flash_clock_divider>
42009f6c:	74a0a0        	extui	a10, a10, 0, 8
42009f6f:	fff065        	call8	42009e74 <gpspi_flash_ll_calculate_clock_reg>
42009f72:	202aa0        	or	a2, a10, a10
}
42009f75:	000090        	retw

42009f78 <spi_flash_hal_init>:
#endif //SOC_SPI_MEM_SUPPORT_TIMING_TUNING

esp_err_t spi_flash_hal_init(spi_flash_hal_context_t *data_out, const spi_flash_hal_config_t *cfg)
{
42009f78:	006136        	entry	a1, 48
    if (cfg->cs_num >= SOC_SPI_PERIPH_CS_NUM(cfg->host_id)) {
42009f7b:	9378      	l32i.n	a7, a3, 36
42009f7d:	8388      	l32i.n	a8, a3, 32
42009f7f:	688c      	beqz.n	a8, 42009f89 <spi_flash_hal_init+0x11>
42009f81:	091866        	bnei	a8, 1, 42009f8e <spi_flash_hal_init+0x16>
42009f84:	690c      	movi.n	a9, 6
42009f86:	000186        	j	42009f90 <spi_flash_hal_init+0x18>
42009f89:	290c      	movi.n	a9, 2
42009f8b:	000046        	j	42009f90 <spi_flash_hal_init+0x18>
42009f8e:	390c      	movi.n	a9, 3
42009f90:	022797        	blt	a7, a9, 42009f96 <spi_flash_hal_init+0x1e>
42009f93:	003f46        	j	4200a094 <spi_flash_hal_init+0x11c>
        return ESP_ERR_INVALID_ARG;
    }

    *data_out = (spi_flash_hal_context_t) {
        .inst = data_out->inst, // Keeps the function pointer table
42009f96:	0248      	l32i.n	a4, a2, 0
42009f98:	0a1826        	beqi	a8, 1, 42009fa6 <spi_flash_hal_init+0x2e>
42009f9b:	0f2826        	beqi	a8, 2, 42009fae <spi_flash_hal_init+0x36>
42009f9e:	689c      	beqz.n	a8, 42009fb8 <spi_flash_hal_init+0x40>
        .spi = spi_flash_ll_get_hw(cfg->host_id),
42009fa0:	d85581        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42009fa3:	0008e0        	callx8	a8
        .inst = data_out->inst, // Keeps the function pointer table
42009fa6:	db0181        	l32r	a8, 42000bac <_stext+0xb8c> (60024000 <GPSPI2>)
42009fa9:	2189      	s32i.n	a8, a1, 8
42009fab:	0003c6        	j	42009fbe <spi_flash_hal_init+0x46>
42009fae:	db0081        	l32r	a8, 42000bb0 <_stext+0xb90> (60025000 <GPSPI3>)
42009fb1:	2189      	s32i.n	a8, a1, 8
42009fb3:	0001c6        	j	42009fbe <spi_flash_hal_init+0x46>
42009fb6:	810000        	src	a0, a0, a0
42009fb9:	dafc      	bnez.n	a10, 42009ffa <spi_flash_hal_init+0x82>
42009fbb:	026182        	s32i	a8, a1, 8
        .cs_num = cfg->cs_num,
        .cs_hold = cfg->cs_hold,
        .cs_setup = cfg->cs_setup,
42009fbe:	0c0352        	l8ui	a5, a3, 12
        .cs_hold = cfg->cs_hold,
42009fc1:	022362        	l32i	a6, a3, 8
        .base_io_mode = cfg->default_io_mode,
42009fc4:	0b2382        	l32i	a8, a3, 44
42009fc7:	0189      	s32i.n	a8, a1, 0
        .freq_mhz = cfg->freq_mhz,
42009fc9:	c398      	l32i.n	a9, a3, 48
42009fcb:	1199      	s32i.n	a9, a1, 4
    *data_out = (spi_flash_hal_context_t) {
42009fcd:	0c3c      	movi.n	a12, 48
42009fcf:	0b0c      	movi.n	a11, 0
42009fd1:	02ad      	mov.n	a10, a2
42009fd3:	d8cb81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42009fd6:	0008e0        	callx8	a8
42009fd9:	0249      	s32i.n	a4, a2, 0
42009fdb:	21a8      	l32i.n	a10, a1, 8
42009fdd:	12a9      	s32i.n	a10, a2, 4
42009fdf:	2279      	s32i.n	a7, a2, 8
42009fe1:	0e4252        	s8i	a5, a2, 14
42009fe4:	0f4262        	s8i	a6, a2, 15
42009fe7:	0188      	l32i.n	a8, a1, 0
42009fe9:	5289      	s32i.n	a8, a2, 20
42009feb:	1198      	l32i.n	a9, a1, 4
42009fed:	a299      	s32i.n	a9, a2, 40
    };
#if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    if (cfg->using_timing_tuning) {
42009fef:	2a0382        	l8ui	a8, a3, 42
42009ff2:	489c      	beqz.n	a8, 4200a00a <spi_flash_hal_init+0x92>
        data_out->extra_dummy = extra_dummy_under_timing_tuning(cfg);
42009ff4:	03ad      	mov.n	a10, a3
42009ff6:	ffede5        	call8	42009ed4 <extra_dummy_under_timing_tuning>
42009ff9:	0c42a2        	s8i	a10, a2, 12
        data_out->fdummy_rin = cfg->fdummy_rin;
42009ffc:	1388      	l32i.n	a8, a3, 4
42009ffe:	0d4282        	s8i	a8, a2, 13
        data_out->clock_conf = cfg->clock_config;
4200a001:	4388      	l32i.n	a8, a3, 16
4200a003:	4289      	s32i.n	a8, a2, 16
4200a005:	001146        	j	4200a04e <spi_flash_hal_init+0xd6>
4200a008:	720000        	lsi	f0, a0, 0x1c8
    } else
#endif // SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    {
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
4200a00b:	300623        	lsi	f2, a6, 192
4200a00e:	a520a3        	lsi	f10, a0, 0x294
4200a011:	ffed      	lsi	f14, a15, 60
4200a013:	dae881        	l32r	a8, 42000bb4 <_stext+0xb94> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
4200a016:	c2a8a0        	quou	a10, a8, a10
    const int apbclk_n = APB_CLK_FREQ / eff_clk;
4200a019:	d2a8a0        	quos	a10, a8, a10
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
4200a01c:	01c782        	addi	a8, a7, 1
4200a01f:	a08880        	addx4	a8, a8, a8
4200a022:	1188c0        	slli	a8, a8, 4
4200a025:	d88f91        	l32r	a9, 42000264 <_stext+0x244> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
4200a028:	b29890        	mulsh	a9, a8, a9
4200a02b:	219690        	srai	a9, a9, 6
4200a02e:	31bf80        	srai	a11, a8, 31
4200a031:	c099b0        	sub	a9, a9, a11
    if (apb_period_n < 0) {
4200a034:	19acb2        	movi	a11, 0xfffffc19
4200a037:	01a8b7        	bge	a8, a11, 4200a03c <spi_flash_hal_init+0xc4>
        apb_period_n = 0;
4200a03a:	090c      	movi.n	a9, 0
    return apb_period_n / apbclk_n;
4200a03c:	d299a0        	quos	a9, a9, a10
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
4200a03f:	0c4292        	s8i	a9, a2, 12
        data_out->clock_conf = (spi_flash_ll_clock_reg_t)spi_flash_cal_clock(cfg);
4200a042:	20a330        	or	a10, a3, a3
4200a045:	fff065        	call8	42009f4c <spi_flash_cal_clock>
4200a048:	0020c0        	memw
4200a04b:	0462a2        	s32i	a10, a2, 16
    }


    if (cfg->auto_sus_en) {
4200a04e:	280382        	l8ui	a8, a3, 40
4200a051:	01b816        	beqz	a8, 4200a070 <spi_flash_hal_init+0xf8>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND;
4200a054:	6288      	l32i.n	a8, a2, 24
4200a056:	190c      	movi.n	a9, 1
4200a058:	209890        	or	a9, a8, a9
4200a05b:	6299      	s32i.n	a9, a2, 24
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME;
4200a05d:	390c      	movi.n	a9, 3
4200a05f:	208890        	or	a8, a8, a9
4200a062:	6289      	s32i.n	a8, a2, 24
        data_out->tsus_val = cfg->tsus_val;
4200a064:	380382        	l8ui	a8, a3, 56
4200a067:	2c4282        	s8i	a8, a2, 44
        data_out->auto_waiti_pes = cfg->auto_waiti_pes;
4200a06a:	390382        	l8ui	a8, a3, 57
4200a06d:	2d4282        	s8i	a8, a2, 45
#if CONFIG_SPI_FLASH_SOFTWARE_RESUME
    data_out->flags &= ~SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME;
#endif

#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    if (cfg->octal_mode_en) {
4200a070:	290382        	l8ui	a8, a3, 41
4200a073:	788c      	beqz.n	a8, 4200a07e <spi_flash_hal_init+0x106>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_OCTAL_MODE;
4200a075:	6288      	l32i.n	a8, a2, 24
4200a077:	490c      	movi.n	a9, 4
4200a079:	208890        	or	a8, a8, a9
4200a07c:	6289      	s32i.n	a8, a2, 24
    }

    if (cfg->default_io_mode == SPI_FLASH_OPI_DTR) {
4200a07e:	b398      	l32i.n	a9, a3, 44
4200a080:	181c      	movi.n	a8, 17
4200a082:	149987        	bne	a9, a8, 4200a09a <spi_flash_hal_init+0x122>
        data_out->slicer_flags |= SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR;
4200a085:	9288      	l32i.n	a8, a2, 36
4200a087:	190c      	movi.n	a9, 1
4200a089:	208890        	or	a8, a8, a9
4200a08c:	9289      	s32i.n	a8, a2, 36
    }
#endif

    return ESP_OK;
4200a08e:	020c      	movi.n	a2, 0
4200a090:	000206        	j	4200a09c <spi_flash_hal_init+0x124>
4200a093:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4200a096:	004602        	s8i	a0, a6, 0
4200a099:	020c00        	andb	b0, b12, b0
}
4200a09c:	f01d      	retw.n
	...

4200a0a0 <spi_flash_hal_supports_direct_write>:

bool spi_flash_hal_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
4200a0a0:	004136        	entry	a1, 32
    (void)p;
    bool direct_write = (((spi_flash_hal_context_t *)host)->spi != spi_flash_ll_get_hw(SPI1_HOST));
4200a0a3:	1228      	l32i.n	a2, a2, 4
4200a0a5:	dac081        	l32r	a8, 42000ba8 <_stext+0xb88> (60002000 <SPIMEM1>)
4200a0a8:	c02280        	sub	a2, a2, a8
    return direct_write;
}
4200a0ab:	180c      	movi.n	a8, 1
4200a0ad:	932820        	movnez	a2, a8, a2
4200a0b0:	f01d      	retw.n
	...

4200a0b4 <spi_flash_hal_supports_direct_read>:


bool spi_flash_hal_supports_direct_read(spi_flash_host_inst_t *host, const void *p)
{
4200a0b4:	004136        	entry	a1, 32
    (void)p;
    //currently the host doesn't support to read through dma, no word-aligned requirements
    bool direct_read = ( ((spi_flash_hal_context_t *)host)->spi != spi_flash_ll_get_hw(SPI1_HOST));
4200a0b7:	1228      	l32i.n	a2, a2, 4
4200a0b9:	dabb81        	l32r	a8, 42000ba8 <_stext+0xb88> (60002000 <SPIMEM1>)
4200a0bc:	c02280        	sub	a2, a2, a8
    return direct_read;
}
4200a0bf:	180c      	movi.n	a8, 1
4200a0c1:	932820        	movnez	a2, a8, a2
4200a0c4:	f01d      	retw.n
	...

4200a0c8 <esp_cpu_configure_region_protection>:

#include <stdint.h>
#include "hal/mpu_hal.h"

void esp_cpu_configure_region_protection(void)
{
4200a0c8:	008136        	entry	a1, 64
    /* Note: currently this is configured the same on all Xtensa targets
     *
     * Both chips have the address space divided into 8 regions, 512MB each.
     */
    const int illegal_regions[] = {0, 4, 5, 6, 7}; // 0x00000000, 0x80000000, 0xa0000000, 0xc0000000, 0xe0000000
4200a0cb:	4c1c      	movi.n	a12, 20
4200a0cd:	dabab1        	l32r	a11, 42000bb8 <_stext+0xb98> (3c02909c <rtc_io_num_map+0xc4>)
4200a0d0:	01ad      	mov.n	a10, a1
4200a0d2:	d7d581        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200a0d5:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
4200a0d8:	070c      	movi.n	a7, 0
4200a0da:	000346        	j	4200a0eb <esp_cpu_configure_region_protection+0x23>
        mpu_hal_set_region_access(illegal_regions[i], MPU_REGION_ILLEGAL);
4200a0dd:	a08710        	addx4	a8, a7, a1
4200a0e0:	00a0b2        	movi	a11, 0
4200a0e3:	0028a2        	l32i	a10, a8, 0
4200a0e6:	0a9ee5        	call8	42014ad4 <mpu_hal_set_region_access>
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
4200a0e9:	771b      	addi.n	a7, a7, 1
4200a0eb:	ee57b6        	bltui	a7, 5, 4200a0dd <esp_cpu_configure_region_protection+0x15>
    }

    mpu_hal_set_region_access(1, MPU_REGION_RW); // 0x20000000
4200a0ee:	1b0c      	movi.n	a11, 1
4200a0f0:	0bad      	mov.n	a10, a11
4200a0f2:	0a9e25        	call8	42014ad4 <mpu_hal_set_region_access>
}
4200a0f5:	f01d      	retw.n
	...

4200a0f8 <esp_gpio_reserve>:
#include "esp_private/esp_gpio_reserve.h"

static _Atomic uint64_t s_reserved_pin_mask = ATOMIC_VAR_INIT(~(SOC_GPIO_VALID_GPIO_MASK));

uint64_t esp_gpio_reserve(uint64_t gpio_mask)
{
4200a0f8:	004136        	entry	a1, 32
4200a0fb:	02cd      	mov.n	a12, a2
4200a0fd:	03dd      	mov.n	a13, a3
    return atomic_fetch_or(&s_reserved_pin_mask, gpio_mask);
4200a0ff:	5e0c      	movi.n	a14, 5
4200a101:	daaea1        	l32r	a10, 42000bbc <_stext+0xb9c> (3fc92680 <s_reserved_pin_mask>)
4200a104:	daaf81        	l32r	a8, 42000bc0 <_stext+0xba0> (4037fecc <__atomic_fetch_or_8>)
4200a107:	0008e0        	callx8	a8
}
4200a10a:	0a2d      	mov.n	a2, a10
4200a10c:	0b3d      	mov.n	a3, a11
4200a10e:	f01d      	retw.n

4200a110 <_Z41__static_initialization_and_destruction_0v>:
        break;
    }
    return ESP_OK;
}

} // namespace nvs
4200a110:	004136        	entry	a1, 32
const uint32_t nvs::Page::SEC_SIZE = esp_partition_get_main_flash_sector_size();
4200a113:	003c65        	call8	4200a4d8 <esp_partition_get_main_flash_sector_size>
4200a116:	daab81        	l32r	a8, 42000bc4 <_stext+0xba4> (3fc95f00 <_ZN3nvs4Page8SEC_SIZEE>)
4200a119:	08a9      	s32i.n	a10, a8, 0
} // namespace nvs
4200a11b:	f01d      	retw.n
4200a11d:	000000        	ill

4200a120 <_GLOBAL__sub_I__ZN3nvs4PageC2Ev>:
4200a120:	004136        	entry	a1, 32
4200a123:	fffee5        	call8	4200a110 <_Z41__static_initialization_and_destruction_0v>
4200a126:	f01d      	retw.n

4200a128 <is_partition_encrypted>:
static _lock_t s_partition_list_lock;

static const char *TAG = "partition";

static bool is_partition_encrypted(bool encryption_config, esp_partition_type_t type, esp_partition_subtype_t subtype)
{
4200a128:	004136        	entry	a1, 32
4200a12b:	207220        	or	a7, a2, a2
    (void) subtype;
    (void) encryption_config;
    return false;
#else
    bool ret_encrypted = encryption_config;
    if (!esp_flash_encryption_enabled()) {
4200a12e:	daa681        	l32r	a8, 42000bc8 <_stext+0xba8> (40377680 <esp_flash_encryption_enabled>)
4200a131:	0008e0        	callx8	a8
4200a134:	0a2d      	mov.n	a2, a10
4200a136:	4abc      	beqz.n	a10, 4200a16e <is_partition_encrypted+0x46>
        /* If flash encryption is not turned on, no partitions should be treated as encrypted */
        ret_encrypted = false;
    } else if (type == ESP_PARTITION_TYPE_APP
4200a138:	40f380        	nsau	a8, a3
4200a13b:	418580        	srli	a8, a8, 5
                || (type == ESP_PARTITION_TYPE_BOOTLOADER)
4200a13e:	fec392        	addi	a9, a3, -2
4200a141:	40f990        	nsau	a9, a9
4200a144:	419590        	srli	a9, a9, 5
4200a147:	208890        	or	a8, a8, a9
    } else if (type == ESP_PARTITION_TYPE_APP
4200a14a:	08ec      	bnez.n	a8, 4200a16e <is_partition_encrypted+0x46>
                || (type == ESP_PARTITION_TYPE_PARTITION_TABLE)
4200a14c:	1e3326        	beqi	a3, 3, 4200a16e <is_partition_encrypted+0x46>
                || (type == ESP_PARTITION_TYPE_DATA && subtype == ESP_PARTITION_SUBTYPE_DATA_OTA)
4200a14f:	330b      	addi.n	a3, a3, -1
4200a151:	40f330        	nsau	a3, a3
4200a154:	413530        	srli	a3, a3, 5
4200a157:	40f480        	nsau	a8, a4
4200a15a:	418580        	srli	a8, a8, 5
4200a15d:	0d8387        	bany	a3, a8, 4200a16e <is_partition_encrypted+0x46>
                || (type == ESP_PARTITION_TYPE_DATA && subtype == ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS)) {
4200a160:	fcc442        	addi	a4, a4, -4
4200a163:	40f440        	nsau	a4, a4
4200a166:	414540        	srli	a4, a4, 5
4200a169:	018347        	bany	a3, a4, 4200a16e <is_partition_encrypted+0x46>
    bool ret_encrypted = encryption_config;
4200a16c:	072d      	mov.n	a2, a7
    // FE can be enabled in virt eFuses but not in real eFuses.
    ret_encrypted &= efuse_hal_flash_encryption_enabled();
#endif
    return ret_encrypted;
#endif
}
4200a16e:	f01d      	retw.n

4200a170 <load_partitions>:

// Create linked list of partition_list_item_t structures.
// This function is called only once, with s_partition_list_lock taken.
static esp_err_t load_partitions(void)
{
4200a170:	016136        	entry	a1, 176
#if !CONFIG_IDF_TARGET_LINUX
    spi_flash_mmap_handle_t handle;
#endif

    // Temporary list of loaded partitions, if valid then we copy this to s_partition_list
    typeof(s_partition_list) new_partitions_list = SLIST_HEAD_INITIALIZER(s_partition_list);
4200a173:	040c      	movi.n	a4, 0
    const uint8_t *md5_part = NULL;
    const uint8_t *stored_md5;
    uint8_t calc_md5[ESP_ROM_MD5_DIGEST_LEN];
    md5_context_t context;

    esp_rom_md5_init(&context);
4200a175:	18c1a2        	addi	a10, a1, 24
4200a178:	da9c81        	l32r	a8, 42000be8 <_stext+0xbc8> (40001c5c <MD5Init>)
4200a17b:	0008e0        	callx8	a8

#if CONFIG_IDF_TARGET_LINUX
    esp_err_t err = esp_partition_file_mmap(&p_start);
    size_t mapped_size = ESP_PARTITION_EMULATED_SECTOR_SIZE;
#else
    esp_err_t err = spi_flash_mmap(partition_align_pg_size,
4200a17e:	e14b      	addi.n	a14, a1, 4
4200a180:	01dd      	mov.n	a13, a1
4200a182:	04cd      	mov.n	a12, a4
4200a184:	d99bb1        	l32r	a11, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
4200a187:	04ad      	mov.n	a10, a4
4200a189:	ff8665        	call8	420099f0 <spi_flash_mmap>
4200a18c:	0a2d      	mov.n	a2, a10
                                   SPI_FLASH_SEC_SIZE, SPI_FLASH_MMAP_DATA, (const void **)&p_start, &handle);
    size_t mapped_size = SPI_FLASH_SEC_SIZE;
#endif

    if (err != ESP_OK) {
4200a18e:	14ca56        	bnez	a10, 4200a2de <load_partitions+0x16e>
        return err;
    }

    // calculate partition address within mmap-ed region
    p_start += partition_pad;
4200a191:	0138      	l32i.n	a3, a1, 0
4200a193:	d82261        	l32r	a6, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
4200a196:	636a      	add.n	a6, a3, a6
4200a198:	0169      	s32i.n	a6, a1, 0
    p_end = p_start + mapped_size;
4200a19a:	da8c81        	l32r	a8, 42000bcc <_stext+0xbac> (9000 <UserFrameTotalSize+0x8f00>)
4200a19d:	338a      	add.n	a3, a3, a8
    partition_list_item_t *last = NULL;
4200a19f:	045d      	mov.n	a5, a4

    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200a1a1:	002b06        	j	4200a251 <load_partitions+0xe1>
        esp_partition_info_t entry;
        // copying to RAM instead of using pointer to flash to avoid any chance of TOCTOU due to cache miss
        // when flash encryption is used
        memcpy(&entry, p_entry, sizeof(entry));
4200a1a4:	0c2c      	movi.n	a12, 32
4200a1a6:	06bd      	mov.n	a11, a6
4200a1a8:	70c1a2        	addi	a10, a1, 112
4200a1ab:	d79f81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200a1ae:	0008e0        	callx8	a8

#if CONFIG_PARTITION_TABLE_MD5
        if (entry.magic == ESP_PARTITION_MAGIC_MD5) {
4200a1b1:	381182        	l16ui	a8, a1, 112
4200a1b4:	da8c91        	l32r	a9, 42000be4 <_stext+0xbc4> (ebeb <UserFrameTotalSize+0xeaeb>)
4200a1b7:	029897        	bne	a8, a9, 4200a1bd <load_partitions+0x4d>
4200a1ba:	0026c6        	j	4200a259 <load_partitions+0xe9>
            md5_part = p_entry;
            break;
        }
#endif
        if (entry.magic != ESP_PARTITION_MAGIC) {
4200a1bd:	da8891        	l32r	a9, 42000be0 <_stext+0xbc0> (50aa <UserFrameTotalSize+0x4faa>)
4200a1c0:	021897        	beq	a8, a9, 4200a1c6 <load_partitions+0x56>
4200a1c3:	001f46        	j	4200a244 <load_partitions+0xd4>
            break;
        }

#if CONFIG_PARTITION_TABLE_MD5
        esp_rom_md5_update(&context, &entry, sizeof(entry));
4200a1c6:	0c2c      	movi.n	a12, 32
4200a1c8:	70c1b2        	addi	a11, a1, 112
4200a1cb:	18c1a2        	addi	a10, a1, 24
4200a1ce:	da8781        	l32r	a8, 42000bec <_stext+0xbcc> (40001c68 <MD5Update>)
4200a1d1:	0008e0        	callx8	a8
#endif

        // allocate new linked list item and populate it with data from partition table
        partition_list_item_t *item = (partition_list_item_t *) calloc(1, sizeof(partition_list_item_t));
4200a1d4:	4b3c      	movi.n	a11, 52
4200a1d6:	1a0c      	movi.n	a10, 1
4200a1d8:	da8681        	l32r	a8, 42000bf0 <_stext+0xbd0> (4037fe58 <calloc>)
4200a1db:	0008e0        	callx8	a8
4200a1de:	0a7d      	mov.n	a7, a10
        if (item == NULL) {
4200a1e0:	065a16        	beqz	a10, 4200a249 <load_partitions+0xd9>
            break;
        }
#if CONFIG_IDF_TARGET_LINUX
        item->info.flash_chip = NULL;
#else
        item->info.flash_chip = esp_flash_default_chip;
4200a1e3:	da5781        	l32r	a8, 42000b40 <_stext+0xb20> (3fc95eec <esp_flash_default_chip>)
4200a1e6:	0888      	l32i.n	a8, a8, 0
4200a1e8:	0a89      	s32i.n	a8, a10, 0
#endif
        item->info.address = entry.pos.offset;
4200a1ea:	1d2182        	l32i	a8, a1, 116
4200a1ed:	3a89      	s32i.n	a8, a10, 12
        item->info.size = entry.pos.size;
4200a1ef:	1e2182        	l32i	a8, a1, 120
4200a1f2:	4a89      	s32i.n	a8, a10, 16
#if CONFIG_IDF_TARGET_LINUX
        item->info.erase_size = ESP_PARTITION_EMULATED_SECTOR_SIZE;
#else
        item->info.erase_size = SPI_FLASH_SEC_SIZE;
4200a1f4:	d97f81        	l32r	a8, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
4200a1f7:	5a89      	s32i.n	a8, a10, 20
#endif
        item->info.type = entry.type;
4200a1f9:	7201b2        	l8ui	a11, a1, 114
4200a1fc:	1ab9      	s32i.n	a11, a10, 4
        item->info.subtype = entry.subtype;
4200a1fe:	7301c2        	l8ui	a12, a1, 115
4200a201:	026ac2        	s32i	a12, a10, 8
        item->info.encrypted = is_partition_encrypted(entry.flags & PART_FLAG_ENCRYPTED, entry.type, entry.subtype);
4200a204:	2321a2        	l32i	a10, a1, 140
4200a207:	04a0a0        	extui	a10, a10, 0, 1
4200a20a:	fff1e5        	call8	4200a128 <is_partition_encrypted>
4200a20d:	2947a2        	s8i	a10, a7, 41
        item->info.readonly = entry.flags & PART_FLAG_READONLY;
4200a210:	232182        	l32i	a8, a1, 140
4200a213:	048180        	extui	a8, a8, 1, 1
4200a216:	2a4782        	s8i	a8, a7, 42
        item->user_registered = false;
4200a219:	080c      	movi.n	a8, 0
4200a21b:	2c4782        	s8i	a8, a7, 44
            ESP_LOGI(TAG, "Ignoring encrypted flag for \"%s\" partition", entry.label);
            item->info.encrypted = false;
        }
#endif
        // item->info.label is initialized by calloc, so resulting string will be null terminated
        strncpy(item->info.label, (const char *) entry.label, sizeof(item->info.label) - 1);
4200a21e:	0c1c      	movi.n	a12, 16
4200a220:	7cc1b2        	addi	a11, a1, 124
4200a223:	18c7a2        	addi	a10, a7, 24
4200a226:	da7381        	l32r	a8, 42000bf4 <_stext+0xbd4> (40001224 <strncpy>)
4200a229:	0008e0        	callx8	a8

        // add it to the list
        if (last == NULL) {
4200a22c:	55cc      	bnez.n	a5, 4200a235 <load_partitions+0xc5>
            SLIST_INSERT_HEAD(&new_partitions_list, item, next);
4200a22e:	c749      	s32i.n	a4, a7, 48
4200a230:	074d      	mov.n	a4, a7
4200a232:	000146        	j	4200a23b <load_partitions+0xcb>
        } else {
            SLIST_INSERT_AFTER(last, item, next);
4200a235:	c588      	l32i.n	a8, a5, 48
4200a237:	c789      	s32i.n	a8, a7, 48
4200a239:	c579      	s32i.n	a7, a5, 48
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200a23b:	20c662        	addi	a6, a6, 32
        }
        last = item;
4200a23e:	075d      	mov.n	a5, a7
4200a240:	000346        	j	4200a251 <load_partitions+0xe1>
4200a243:	060c00        	lsi	f0, a12, 24
    const uint8_t *md5_part = NULL;
4200a246:	0003c6        	j	4200a259 <load_partitions+0xe9>
4200a249:	0a6d      	mov.n	a6, a10
            err = ESP_ERR_NO_MEM;
4200a24b:	01a122        	movi	a2, 0x101
4200a24e:	0001c6        	j	4200a259 <load_partitions+0xe9>
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200a251:	02b637        	bgeu	a6, a3, 4200a257 <load_partitions+0xe7>
4200a254:	ffd306        	j	4200a1a4 <load_partitions+0x34>
    const uint8_t *md5_part = NULL;
4200a257:	060c      	movi.n	a6, 0
    }

#if CONFIG_PARTITION_TABLE_MD5
    if (md5_part == NULL) {
4200a259:	f6dc      	bnez.n	a6, 4200a27c <load_partitions+0x10c>
        ESP_LOGE(TAG, "No MD5 found in partition table");
4200a25b:	d78181        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200a25e:	0008e0        	callx8	a8
4200a261:	da5bb1        	l32r	a11, 42000bd0 <_stext+0xbb0> (3c026cc0 <_flash_rodata_start+0x6ba0>)
4200a264:	0bed      	mov.n	a14, a11
4200a266:	0add      	mov.n	a13, a10
4200a268:	da5bc1        	l32r	a12, 42000bd4 <_stext+0xbb4> (3c026ccc <_flash_rodata_start+0x6bac>)
4200a26b:	01a0a2        	movi	a10, 1
4200a26e:	d78981        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200a271:	0008e0        	callx8	a8
        err = ESP_ERR_NOT_FOUND;
4200a274:	05a122        	movi	a2, 0x105
4200a277:	001246        	j	4200a2c4 <load_partitions+0x154>
4200a27a:	620000        	lsi	f0, a0, 0x188
    } else {
        stored_md5 = md5_part + ESP_PARTITION_MD5_OFFSET;
4200a27d:	8b10c6        	j	41fecec4 <_coredump_iram_end+0x1c6afc4>
        esp_rom_md5_final(calc_md5, &context);
4200a280:	c1b271        	l32r	a7, 41ffa948 <_coredump_iram_end+0x1c78a48>
4200a283:	ad18      	l32i.n	a1, a13, 40
4200a285:	5c8107        	bany	a1, a0, 4200a2e5 <ensure_partitions_loaded+0x5>
4200a288:	e0da      	add.n	a14, a0, a13
4200a28a:	0008      	l32i.n	a0, a0, 0
#if !CONFIG_IDF_TARGET_LINUX
        ESP_LOG_BUFFER_HEXDUMP("calculated md5", calc_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
        ESP_LOG_BUFFER_HEXDUMP("stored md5", stored_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
#endif

        if (memcmp(calc_md5, stored_md5, ESP_ROM_MD5_DIGEST_LEN) != 0) {
4200a28c:	0c1c      	movi.n	a12, 16
4200a28e:	06bd      	mov.n	a11, a6
4200a290:	07ad      	mov.n	a10, a7
4200a292:	d97a81        	l32r	a8, 4200087c <_stext+0x85c> (4000120c <memcmp>)
4200a295:	0008e0        	callx8	a8
4200a298:	ea9c      	beqz.n	a10, 4200a2ba <load_partitions+0x14a>
            ESP_LOGE(TAG, "Partition table MD5 mismatch");
4200a29a:	d77181        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200a29d:	0008e0        	callx8	a8
4200a2a0:	da4cb1        	l32r	a11, 42000bd0 <_stext+0xbb0> (3c026cc0 <_flash_rodata_start+0x6ba0>)
4200a2a3:	0bed      	mov.n	a14, a11
4200a2a5:	20daa0        	or	a13, a10, a10
4200a2a8:	da4cc1        	l32r	a12, 42000bd8 <_stext+0xbb8> (3c026cfc <_flash_rodata_start+0x6bdc>)
4200a2ab:	01a0a2        	movi	a10, 1
4200a2ae:	d77981        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200a2b1:	0008e0        	callx8	a8
            err = ESP_ERR_INVALID_STATE;
4200a2b4:	03a122        	movi	a2, 0x103
4200a2b7:	000246        	j	4200a2c4 <load_partitions+0x154>
            ESP_LOGV(TAG, "Partition table MD5 verified");
        }
    }
#endif

    if (err == ESP_OK) {
4200a2ba:	62cc      	bnez.n	a2, 4200a2c4 <load_partitions+0x154>
        /* Don't copy the list to the static variable unless it's verified */
        s_partition_list = new_partitions_list;
4200a2bc:	da4881        	l32r	a8, 42000bdc <_stext+0xbbc> (3fc95f08 <s_partition_list>)
4200a2bf:	0849      	s32i.n	a4, a8, 0
4200a2c1:	0004c6        	j	4200a2d8 <load_partitions+0x168>
    } else {
        /* Otherwise, free all the memory we just allocated */
        partition_list_item_t *it = new_partitions_list.slh_first;
4200a2c4:	04ad      	mov.n	a10, a4
        while (it) {
4200a2c6:	0002c6        	j	4200a2d5 <load_partitions+0x165>
            partition_list_item_t *next = it->next.sle_next;
4200a2c9:	0c2a72        	l32i	a7, a10, 48
            free(it);
4200a2cc:	d8a781        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
4200a2cf:	0008e0        	callx8	a8
            it = next;
4200a2d2:	20a770        	or	a10, a7, a7
        while (it) {
4200a2d5:	ff0a56        	bnez	a10, 4200a2c9 <load_partitions+0x159>
        }
    }

#if !CONFIG_IDF_TARGET_LINUX
    spi_flash_munmap(handle);
4200a2d8:	0121a2        	l32i	a10, a1, 4
4200a2db:	ff7aa5        	call8	42009a84 <spi_flash_munmap>
#endif

    return err;
}
4200a2de:	f01d      	retw.n

4200a2e0 <ensure_partitions_loaded>:

    assert(SLIST_EMPTY(&s_partition_list));
}

static esp_err_t ensure_partitions_loaded(void)
{
4200a2e0:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
    if (SLIST_EMPTY(&s_partition_list)) {
4200a2e3:	da3e81        	l32r	a8, 42000bdc <_stext+0xbbc> (3fc95f08 <s_partition_list>)
4200a2e6:	0888      	l32i.n	a8, a8, 0
4200a2e8:	044856        	bnez	a8, 4200a330 <ensure_partitions_loaded+0x50>
        // only lock if list is empty (and check again after acquiring lock)
        _lock_acquire(&s_partition_list_lock);
4200a2eb:	da44a1        	l32r	a10, 42000bfc <_stext+0xbdc> (3fc95f04 <s_partition_list_lock>)
4200a2ee:	d91581        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
4200a2f1:	0008e0        	callx8	a8
        if (SLIST_EMPTY(&s_partition_list)) {
4200a2f4:	da3a81        	l32r	a8, 42000bdc <_stext+0xbbc> (3fc95f08 <s_partition_list>)
4200a2f7:	0888      	l32i.n	a8, a8, 0
4200a2f9:	58ec      	bnez.n	a8, 4200a322 <ensure_partitions_loaded+0x42>
            ESP_LOGV(TAG, "Loading the partition table");
            err = load_partitions();
4200a2fb:	ffe765        	call8	4200a170 <load_partitions>
4200a2fe:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
4200a300:	0aac      	beqz.n	a10, 4200a324 <ensure_partitions_loaded+0x44>
                ESP_LOGE(TAG, "load_partitions returned 0x%x", err);
4200a302:	d75781        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4200a305:	0008e0        	callx8	a8
4200a308:	da32b1        	l32r	a11, 42000bd0 <_stext+0xbb0> (3c026cc0 <_flash_rodata_start+0x6ba0>)
4200a30b:	02fd      	mov.n	a15, a2
4200a30d:	0bed      	mov.n	a14, a11
4200a30f:	0add      	mov.n	a13, a10
4200a311:	da3bc1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c026d28 <_flash_rodata_start+0x6c08>)
4200a314:	1a0c      	movi.n	a10, 1
4200a316:	d75f81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
4200a319:	0008e0        	callx8	a8
4200a31c:	000106        	j	4200a324 <ensure_partitions_loaded+0x44>
4200a31f:	000000        	ill
    esp_err_t err = ESP_OK;
4200a322:	020c      	movi.n	a2, 0
            }
        }
        _lock_release(&s_partition_list_lock);
4200a324:	da36a1        	l32r	a10, 42000bfc <_stext+0xbdc> (3fc95f04 <s_partition_list_lock>)
4200a327:	d90881        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
4200a32a:	0008e0        	callx8	a8
4200a32d:	000046        	j	4200a332 <ensure_partitions_loaded+0x52>
    esp_err_t err = ESP_OK;
4200a330:	020c      	movi.n	a2, 0
    }
    return err;
}
4200a332:	f01d      	retw.n

4200a334 <iterator_create>:

static esp_partition_iterator_opaque_t *iterator_create(esp_partition_type_t type,
        esp_partition_subtype_t subtype, const char *label)
{
4200a334:	004136        	entry	a1, 32
4200a337:	027d      	mov.n	a7, a2
    esp_partition_iterator_opaque_t *it =
        (esp_partition_iterator_opaque_t *) malloc(sizeof(esp_partition_iterator_opaque_t));
4200a339:	4a1c      	movi.n	a10, 20
4200a33b:	d91281        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
4200a33e:	0008e0        	callx8	a8
4200a341:	0a2d      	mov.n	a2, a10
    if (it == NULL) {
4200a343:	fa8c      	beqz.n	a10, 4200a356 <iterator_create+0x22>
        return NULL;
    }
    it->type = type;
4200a345:	0a79      	s32i.n	a7, a10, 0
    it->subtype = subtype;
4200a347:	1a39      	s32i.n	a3, a10, 4
    it->label = label;
4200a349:	2a49      	s32i.n	a4, a10, 8
    it->next_item = SLIST_FIRST(&s_partition_list);
4200a34b:	da2481        	l32r	a8, 42000bdc <_stext+0xbbc> (3fc95f08 <s_partition_list>)
4200a34e:	0888      	l32i.n	a8, a8, 0
4200a350:	3a89      	s32i.n	a8, a10, 12
    it->info = NULL;
4200a352:	080c      	movi.n	a8, 0
4200a354:	4a89      	s32i.n	a8, a10, 16
    return it;
}
4200a356:	f01d      	retw.n

4200a358 <esp_partition_iterator_release>:
    esp_partition_iterator_release(it);
    return res;
}

void esp_partition_iterator_release(esp_partition_iterator_t iterator)
{
4200a358:	004136        	entry	a1, 32
4200a35b:	20a220        	or	a10, a2, a2
    // iterator == NULL is okay
    free(iterator);
4200a35e:	d88281        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
4200a361:	0008e0        	callx8	a8
}
4200a364:	f01d      	retw.n
	...

4200a368 <esp_partition_next>:
{
4200a368:	004136        	entry	a1, 32
4200a36b:	027d      	mov.n	a7, a2
    assert(it);
4200a36d:	02dc      	bnez.n	a2, 4200a381 <esp_partition_next+0x19>
4200a36f:	da25d1        	l32r	a13, 42000c04 <_stext+0xbe4> (3c020230 <_flash_rodata_start+0x110>)
4200a372:	da25c1        	l32r	a12, 42000c08 <_stext+0xbe8> (3c0290f8 <__func__$3>)
4200a375:	47a1b2        	movi	a11, 0x147
4200a378:	da25a1        	l32r	a10, 42000c0c <_stext+0xbec> (3c026d93 <_flash_rodata_start+0x6c73>)
4200a37b:	d75181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200a37e:	0008e0        	callx8	a8
    if (it->next_item == NULL) {
4200a381:	032222        	l32i	a2, a2, 12
4200a384:	008256        	bnez	a2, 4200a390 <esp_partition_next+0x28>
        esp_partition_iterator_release(it);
4200a387:	20a770        	or	a10, a7, a7
4200a38a:	fffce5        	call8	4200a358 <esp_partition_iterator_release>
        return NULL;
4200a38d:	0017c6        	j	4200a3f0 <esp_partition_next+0x88>
    _lock_acquire(&s_partition_list_lock);
4200a390:	da1ba1        	l32r	a10, 42000bfc <_stext+0xbdc> (3fc95f04 <s_partition_list_lock>)
4200a393:	d8ec81        	l32r	a8, 42000744 <_stext+0x724> (40376a1c <_lock_acquire>)
4200a396:	0008e0        	callx8	a8
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
4200a399:	000b46        	j	4200a3ca <esp_partition_next+0x62>
        if (it->type != ESP_PARTITION_TYPE_ANY && it->type != p->type) {
4200a39c:	0788      	l32i.n	a8, a7, 0
4200a39e:	ffa092        	movi	a9, 255
4200a3a1:	041897        	beq	a8, a9, 4200a3a9 <esp_partition_next+0x41>
4200a3a4:	1698      	l32i.n	a9, a6, 4
4200a3a6:	1c9897        	bne	a8, a9, 4200a3c6 <esp_partition_next+0x5e>
        if (it->subtype != ESP_PARTITION_SUBTYPE_ANY && it->subtype != p->subtype) {
4200a3a9:	1788      	l32i.n	a8, a7, 4
4200a3ab:	ffa092        	movi	a9, 255
4200a3ae:	041897        	beq	a8, a9, 4200a3b6 <esp_partition_next+0x4e>
4200a3b1:	2698      	l32i.n	a9, a6, 8
4200a3b3:	0f9897        	bne	a8, a9, 4200a3c6 <esp_partition_next+0x5e>
        if (it->label != NULL && strcmp(it->label, p->label) != 0) {
4200a3b6:	27a8      	l32i.n	a10, a7, 8
4200a3b8:	014a16        	beqz	a10, 4200a3d0 <esp_partition_next+0x68>
4200a3bb:	18c6b2        	addi	a11, a6, 24
4200a3be:	d82381        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
4200a3c1:	0008e0        	callx8	a8
4200a3c4:	8a8c      	beqz.n	a10, 4200a3d0 <esp_partition_next+0x68>
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
4200a3c6:	c688      	l32i.n	a8, a6, 48
4200a3c8:	3789      	s32i.n	a8, a7, 12
4200a3ca:	032762        	l32i	a6, a7, 12
4200a3cd:	fcb656        	bnez	a6, 4200a39c <esp_partition_next+0x34>
    _lock_release(&s_partition_list_lock);
4200a3d0:	da0ba1        	l32r	a10, 42000bfc <_stext+0xbdc> (3fc95f04 <s_partition_list_lock>)
4200a3d3:	d8dd81        	l32r	a8, 42000748 <_stext+0x728> (40376a5c <_lock_release>)
4200a3d6:	0008e0        	callx8	a8
    if (it->next_item == NULL) {
4200a3d9:	032722        	l32i	a2, a7, 12
4200a3dc:	008256        	bnez	a2, 4200a3e8 <esp_partition_next+0x80>
        esp_partition_iterator_release(it);
4200a3df:	20a770        	or	a10, a7, a7
4200a3e2:	fff765        	call8	4200a358 <esp_partition_iterator_release>
        return NULL;
4200a3e5:	0001c6        	j	4200a3f0 <esp_partition_next+0x88>
    it->info = &it->next_item->info;
4200a3e8:	4729      	s32i.n	a2, a7, 16
    it->next_item = SLIST_NEXT(it->next_item, next);
4200a3ea:	c288      	l32i.n	a8, a2, 48
4200a3ec:	3789      	s32i.n	a8, a7, 12
    return it;
4200a3ee:	072d      	mov.n	a2, a7
}
4200a3f0:	f01d      	retw.n
	...

4200a3f4 <esp_partition_find>:
{
4200a3f4:	004136        	entry	a1, 32
    if (ensure_partitions_loaded() != ESP_OK) {
4200a3f7:	ffeea5        	call8	4200a2e0 <ensure_partitions_loaded>
4200a3fa:	026a56        	bnez	a10, 4200a424 <esp_partition_find+0x30>
    if (type == ESP_PARTITION_TYPE_ANY && subtype != ESP_PARTITION_SUBTYPE_ANY) {
4200a3fd:	01af92        	movi	a9, -255
4200a400:	829a      	add.n	a8, a2, a9
4200a402:	40f880        	nsau	a8, a8
4200a405:	418580        	srli	a8, a8, 5
4200a408:	939a      	add.n	a9, a3, a9
4200a40a:	1a0c      	movi.n	a10, 1
4200a40c:	83a990        	moveqz	a10, a9, a9
4200a40f:	1788a7        	bany	a8, a10, 4200a42a <esp_partition_find+0x36>
    esp_partition_iterator_t it = iterator_create(type, subtype, label);
4200a412:	04cd      	mov.n	a12, a4
4200a414:	03bd      	mov.n	a11, a3
4200a416:	02ad      	mov.n	a10, a2
4200a418:	fff1a5        	call8	4200a334 <iterator_create>
    if (it == NULL) {
4200a41b:	da8c      	beqz.n	a10, 4200a42c <esp_partition_find+0x38>
    it = esp_partition_next(it);
4200a41d:	fff4a5        	call8	4200a368 <esp_partition_next>
    return it;
4200a420:	000206        	j	4200a42c <esp_partition_find+0x38>
4200a423:	0a0c00        	add.s	f0, f12, f0
        return NULL;
4200a426:	000086        	j	4200a42c <esp_partition_find+0x38>
4200a429:	0a0c00        	add.s	f0, f12, f0
}
4200a42c:	0a2d      	mov.n	a2, a10
4200a42e:	f01d      	retw.n

4200a430 <esp_partition_get>:

const esp_partition_t *esp_partition_get(esp_partition_iterator_t iterator)
{
4200a430:	004136        	entry	a1, 32
    assert(iterator != NULL);
4200a433:	011256        	bnez	a2, 4200a448 <esp_partition_get+0x18>
4200a436:	d9f6d1        	l32r	a13, 42000c10 <_stext+0xbf0> (3c026da0 <_flash_rodata_start+0x6c80>)
4200a439:	d9f6c1        	l32r	a12, 42000c14 <_stext+0xbf4> (3c0290e4 <__func__$2>)
4200a43c:	7aa1b2        	movi	a11, 0x17a
4200a43f:	d9f3a1        	l32r	a10, 42000c0c <_stext+0xbec> (3c026d93 <_flash_rodata_start+0x6c73>)
4200a442:	d71f81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200a445:	0008e0        	callx8	a8
    return iterator->info;
}
4200a448:	4228      	l32i.n	a2, a2, 16
4200a44a:	f01d      	retw.n

4200a44c <esp_partition_is_flash_region_writable>:
    }
    return false;
}

bool esp_partition_is_flash_region_writable(size_t addr, size_t size)
{
4200a44c:	004136        	entry	a1, 32
    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_ANY, ESP_PARTITION_SUBTYPE_ANY, NULL);
4200a44f:	00a0c2        	movi	a12, 0
4200a452:	ffa0b2        	movi	a11, 255
4200a455:	20abb0        	or	a10, a11, a11
4200a458:	fff9a5        	call8	4200a3f4 <esp_partition_find>
4200a45b:	207aa0        	or	a7, a10, a10
    for (; it != NULL; it = esp_partition_next(it)) {
4200a45e:	000a06        	j	4200a48a <esp_partition_is_flash_region_writable+0x3e>
        const esp_partition_t *p = esp_partition_get(it);
4200a461:	07ad      	mov.n	a10, a7
4200a463:	fffce5        	call8	4200a430 <esp_partition_get>
        if (p->readonly) {
4200a466:	2a0a82        	l8ui	a8, a10, 42
4200a469:	489c      	beqz.n	a8, 4200a481 <esp_partition_is_flash_region_writable+0x35>
            if (addr >= p->address && addr < p->address + p->size) {
4200a46b:	3a88      	l32i.n	a8, a10, 12
4200a46d:	073287        	bltu	a2, a8, 4200a478 <esp_partition_is_flash_region_writable+0x2c>
4200a470:	4a98      	l32i.n	a9, a10, 16
4200a472:	809890        	add	a9, a8, a9
4200a475:	193297        	bltu	a2, a9, 4200a492 <esp_partition_is_flash_region_writable+0x46>
                return false;
            }
            if (addr < p->address && addr + size > p->address) {
4200a478:	05b287        	bgeu	a2, a8, 4200a481 <esp_partition_is_flash_region_writable+0x35>
4200a47b:	809230        	add	a9, a2, a3
4200a47e:	163897        	bltu	a8, a9, 4200a498 <esp_partition_is_flash_region_writable+0x4c>
    for (; it != NULL; it = esp_partition_next(it)) {
4200a481:	20a770        	or	a10, a7, a7
4200a484:	ffee25        	call8	4200a368 <esp_partition_next>
4200a487:	207aa0        	or	a7, a10, a10
4200a48a:	fd3756        	bnez	a7, 4200a461 <esp_partition_is_flash_region_writable+0x15>
                return false;
            }
        }
    }
    return true;
4200a48d:	120c      	movi.n	a2, 1
4200a48f:	0001c6        	j	4200a49a <esp_partition_is_flash_region_writable+0x4e>
                return false;
4200a492:	020c      	movi.n	a2, 0
4200a494:	000086        	j	4200a49a <esp_partition_is_flash_region_writable+0x4e>
4200a497:	020c00        	andb	b0, b12, b0
}
4200a49a:	f01d      	retw.n

4200a49c <esp_partition_main_flash_region_safe>:

bool esp_partition_main_flash_region_safe(size_t addr, size_t size)
{
4200a49c:	004136        	entry	a1, 32
    if (addr <= ESP_PARTITION_TABLE_OFFSET + ESP_PARTITION_TABLE_MAX_LEN) {
4200a49f:	d9de81        	l32r	a8, 42000c18 <_stext+0xbf8> (8c00 <UserFrameTotalSize+0x8b00>)
4200a4a2:	1bb827        	bgeu	a8, a2, 4200a4c1 <esp_partition_main_flash_region_safe+0x25>
        return false;
    }
    const esp_partition_t *p = esp_ota_get_running_partition();
4200a4a5:	0003a5        	call8	4200a4e0 <esp_ota_get_running_partition>
    if (addr >= p->address && addr < p->address + p->size) {
4200a4a8:	3a88      	l32i.n	a8, a10, 12
4200a4aa:	063287        	bltu	a2, a8, 4200a4b4 <esp_partition_main_flash_region_safe+0x18>
4200a4ad:	4a98      	l32i.n	a9, a10, 16
4200a4af:	989a      	add.n	a9, a8, a9
4200a4b1:	113297        	bltu	a2, a9, 4200a4c6 <esp_partition_main_flash_region_safe+0x2a>
        return false;
    }
    if (addr < p->address && addr + size > p->address) {
4200a4b4:	14b287        	bgeu	a2, a8, 4200a4cc <esp_partition_main_flash_region_safe+0x30>
4200a4b7:	323a      	add.n	a3, a2, a3
4200a4b9:	143837        	bltu	a8, a3, 4200a4d1 <esp_partition_main_flash_region_safe+0x35>
        return false;
    }
    return true;
4200a4bc:	120c      	movi.n	a2, 1
4200a4be:	000446        	j	4200a4d3 <esp_partition_main_flash_region_safe+0x37>
        return false;
4200a4c1:	020c      	movi.n	a2, 0
4200a4c3:	000306        	j	4200a4d3 <esp_partition_main_flash_region_safe+0x37>
        return false;
4200a4c6:	020c      	movi.n	a2, 0
4200a4c8:	0001c6        	j	4200a4d3 <esp_partition_main_flash_region_safe+0x37>
4200a4cb:	120c00        	andbc	b0, b12, b0
    return true;
4200a4ce:	000046        	j	4200a4d3 <esp_partition_main_flash_region_safe+0x37>
        return false;
4200a4d1:	020c      	movi.n	a2, 0
}
4200a4d3:	f01d      	retw.n
4200a4d5:	000000        	ill

4200a4d8 <esp_partition_get_main_flash_sector_size>:

uint32_t esp_partition_get_main_flash_sector_size(void)
{
4200a4d8:	004136        	entry	a1, 32
    return SPI_FLASH_SEC_SIZE;
}
4200a4db:	d8c521        	l32r	a2, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
4200a4de:	f01d      	retw.n

4200a4e0 <esp_ota_get_running_partition>:
    }
}


const esp_partition_t* esp_ota_get_running_partition(void)
{
4200a4e0:	004136        	entry	a1, 32

    /*
     * Currently running partition is unlikely to change across reset cycle,
     * so it can be cached here, and avoid lookup on every flash write operation.
     */
    if (curr_partition != NULL) {
4200a4e3:	d9ce81        	l32r	a8, 42000c1c <_stext+0xbfc> (3fc95f0c <curr_partition$2>)
4200a4e6:	0828      	l32i.n	a2, a8, 0
4200a4e8:	072256        	bnez	a2, 4200a55e <esp_ota_get_running_partition+0x7e>
        return curr_partition;
    }

    /* Find the flash address of this exact function. By definition that is part
       of the currently running firmware. Then find the enclosing partition. */
    size_t phys_offs = spi_flash_cache2phys(esp_ota_get_running_partition);
4200a4eb:	d9cda1        	l32r	a10, 42000c20 <_stext+0xc00> (4200a4e0 <esp_ota_get_running_partition>)
4200a4ee:	ff5da5        	call8	42009ac8 <spi_flash_cache2phys>
4200a4f1:	206aa0        	or	a6, a10, a10

    assert (phys_offs != SPI_FLASH_CACHE2PHYS_FAIL); /* indicates cache2phys lookup is buggy */
4200a4f4:	110a66        	bnei	a10, -1, 4200a509 <esp_ota_get_running_partition+0x29>
4200a4f7:	d9cbd1        	l32r	a13, 42000c24 <_stext+0xc04> (3c026db4 <_flash_rodata_start+0x6c94>)
4200a4fa:	d9cbc1        	l32r	a12, 42000c28 <_stext+0xc08> (3c02910c <__func__$1>)
4200a4fd:	8ba2b2        	movi	a11, 0x28b
4200a500:	d9cba1        	l32r	a10, 42000c2c <_stext+0xc0c> (3c026df8 <_flash_rodata_start+0x6cd8>)
4200a503:	d6ef81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200a506:	0008e0        	callx8	a8

    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP,
4200a509:	0c0c      	movi.n	a12, 0
4200a50b:	ffa0b2        	movi	a11, 255
4200a50e:	0cad      	mov.n	a10, a12
4200a510:	ffee25        	call8	4200a3f4 <esp_partition_find>
4200a513:	0a7d      	mov.n	a7, a10
                                                     ESP_PARTITION_SUBTYPE_ANY,
                                                     NULL);
    assert(it != NULL); /* has to be at least one app partition */
4200a515:	03ca56        	bnez	a10, 4200a555 <esp_ota_get_running_partition+0x75>
4200a518:	d9c6d1        	l32r	a13, 42000c30 <_stext+0xc10> (3c026e08 <_flash_rodata_start+0x6ce8>)
4200a51b:	d9c3c1        	l32r	a12, 42000c28 <_stext+0xc08> (3c02910c <__func__$1>)
4200a51e:	90a2b2        	movi	a11, 0x290
4200a521:	d9c2a1        	l32r	a10, 42000c2c <_stext+0xc0c> (3c026df8 <_flash_rodata_start+0x6cd8>)
4200a524:	d6e781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4200a527:	0008e0        	callx8	a8

    while (it != NULL) {
        const esp_partition_t *p = esp_partition_get(it);
4200a52a:	20a770        	or	a10, a7, a7
4200a52d:	fff025        	call8	4200a430 <esp_partition_get>
4200a530:	202aa0        	or	a2, a10, a10
        if (p->address <= phys_offs && p->address + p->size > phys_offs) {
4200a533:	3a88      	l32i.n	a8, a10, 12
4200a535:	153687        	bltu	a6, a8, 4200a54e <esp_ota_get_running_partition+0x6e>
4200a538:	4a98      	l32i.n	a9, a10, 16
4200a53a:	889a      	add.n	a8, a8, a9
4200a53c:	0eb687        	bgeu	a6, a8, 4200a54e <esp_ota_get_running_partition+0x6e>
            esp_partition_iterator_release(it);
4200a53f:	07ad      	mov.n	a10, a7
4200a541:	ffe165        	call8	4200a358 <esp_partition_iterator_release>
            curr_partition = p;
4200a544:	d9b681        	l32r	a8, 42000c1c <_stext+0xbfc> (3fc95f0c <curr_partition$2>)
4200a547:	0829      	s32i.n	a2, a8, 0
            return p;
4200a549:	000446        	j	4200a55e <esp_ota_get_running_partition+0x7e>
4200a54c:	ad0000        	lsi	f0, a0, 0x2b4
        }
        it = esp_partition_next(it);
4200a54f:	e16507        	bbci	a5, 0, 4200a534 <esp_ota_get_running_partition+0x54>
4200a552:	ff          	.byte	0xff
4200a553:	0a7d      	mov.n	a7, a10
    while (it != NULL) {
4200a555:	fd1756        	bnez	a7, 4200a52a <esp_ota_get_running_partition+0x4a>
    }

    abort(); /* Partition table is invalid or corrupt */
4200a558:	d6e781        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200a55b:	0008e0        	callx8	a8
}
4200a55e:	f01d      	retw.n

4200a560 <_ZL15eh_globals_dtorPv>:
4200a560:	004136        	entry	a1, 32
4200a563:	b29c      	beqz.n	a2, 4200a582 <_ZL15eh_globals_dtorPv+0x22>
4200a565:	02a8      	l32i.n	a10, a2, 0
4200a567:	000306        	j	4200a577 <_ZL15eh_globals_dtorPv+0x17>
4200a56a:	4a78      	l32i.n	a7, a10, 16
4200a56c:	30caa2        	addi	a10, a10, 48
4200a56f:	201110        	or	a1, a1, a1
4200a572:	0003e5        	call8	4200a5b0 <__wrap__Unwind_DeleteException>
4200a575:	07ad      	mov.n	a10, a7
4200a577:	fefa56        	bnez	a10, 4200a56a <_ZL15eh_globals_dtorPv+0xa>
4200a57a:	02ad      	mov.n	a10, a2
4200a57c:	d7fb81        	l32r	a8, 42000568 <_stext+0x548> (4037fe4c <cfree>)
4200a57f:	0008e0        	callx8	a8
4200a582:	f01d      	retw.n

4200a584 <_GLOBAL__sub_I__ZN17__eh_globals_init7_S_initE>:
4200a584:	004136        	entry	a1, 32
4200a587:	d9abb1        	l32r	a11, 42000c34 <_stext+0xc14> (4200a560 <_ZL15eh_globals_dtorPv>)
4200a58a:	d9aba1        	l32r	a10, 42000c38 <_stext+0xc18> (3fc95f10 <_ZL4init>)
4200a58d:	201110        	or	a1, a1, a1
4200a590:	fb8865        	call8	42005e18 <pthread_key_create>
4200a593:	d9aa81        	l32r	a8, 42000c3c <_stext+0xc1c> (3fc95f14 <_ZN17__eh_globals_init7_S_initE>)
4200a596:	40faa0        	nsau	a10, a10
4200a599:	41a5a0        	srli	a10, a10, 5
4200a59c:	0048a2        	s8i	a10, a8, 0
4200a59f:	f01d      	retw.n
4200a5a1:	000000        	ill

4200a5a4 <_Z12abort_returnIiET_v>:
{
    return abort_expect_void_and_return((void*) context);
}

template<typename T>
static T abort_return()
4200a5a4:	004136        	entry	a1, 32
{
    abort();
4200a5a7:	d6d381        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200a5aa:	0008e0        	callx8	a8
4200a5ad:	000000        	ill

4200a5b0 <__wrap__Unwind_DeleteException>:
{
    abort();
}

extern "C" void __wrap__Unwind_DeleteException(struct _Unwind_Exception *exc)
{
4200a5b0:	004136        	entry	a1, 32
    abort();
4200a5b3:	d6d081        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
4200a5b6:	0008e0        	callx8	a8
4200a5b9:	000000        	ill

4200a5bc <__wrap___gxx_personality_v0>:
extern "C" _Unwind_Reason_Code __wrap___gxx_personality_v0(int version,
                                                           _Unwind_Action actions,
                                                           _Unwind_Exception_Class exception_class,
                                                           struct _Unwind_Exception *ue_header,
                                                           struct _Unwind_Context *context)
{
4200a5bc:	004136        	entry	a1, 32
    return abort_return<_Unwind_Reason_Code>();
4200a5bf:	fffe65        	call8	4200a5a4 <_Z12abort_returnIiET_v>
	...

4200a5c4 <__cxa_atexit>:
4200a5c4:	004136        	entry	a1, 32
4200a5c7:	02bd      	mov.n	a11, a2
4200a5c9:	03cd      	mov.n	a12, a3
4200a5cb:	04dd      	mov.n	a13, a4
4200a5cd:	2a0c      	movi.n	a10, 2
4200a5cf:	201110        	or	a1, a1, a1
4200a5d2:	00f9a5        	call8	4200b56c <__register_exitproc>
4200a5d5:	0a2d      	mov.n	a2, a10
4200a5d7:	f01d      	retw.n
4200a5d9:	000000        	ill

4200a5dc <_fclose_r>:
4200a5dc:	004136        	entry	a1, 32
4200a5df:	027d      	mov.n	a7, a2
4200a5e1:	53bc      	beqz.n	a3, 4200a61a <_fclose_r+0x3e>
4200a5e3:	a28c      	beqz.n	a2, 4200a5f1 <_fclose_r+0x15>
4200a5e5:	a288      	l32i.n	a8, a2, 40
4200a5e7:	68cc      	bnez.n	a8, 4200a5f1 <_fclose_r+0x15>
4200a5e9:	02ad      	mov.n	a10, a2
4200a5eb:	201110        	or	a1, a1, a1
4200a5ee:	004665        	call8	4200aa54 <__sinit>
4200a5f1:	192382        	l32i	a8, a3, 100
4200a5f4:	0ee807        	bbsi	a8, 0, 4200a606 <_fclose_r+0x2a>
4200a5f7:	061382        	l16ui	a8, a3, 12
4200a5fa:	22e897        	bbsi	a8, 9, 4200a620 <_fclose_r+0x44>
4200a5fd:	1623a2        	l32i	a10, a3, 88
4200a600:	d99081        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200a603:	0008e0        	callx8	a8
4200a606:	069382        	l16si	a8, a3, 12
4200a609:	38dc      	bnez.n	a8, 4200a620 <_fclose_r+0x44>
4200a60b:	192382        	l32i	a8, a3, 100
4200a60e:	08e807        	bbsi	a8, 0, 4200a61a <_fclose_r+0x3e>
4200a611:	1623a2        	l32i	a10, a3, 88
4200a614:	d98c81        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200a617:	0008e0        	callx8	a8
4200a61a:	020c      	movi.n	a2, 0
4200a61c:	001fc6        	j	4200a69f <_fclose_r+0xc3>
4200a61f:	03bd00        	lsi	f0, a13, 12
4200a622:	07ad      	mov.n	a10, a7
4200a624:	201110        	or	a1, a1, a1
4200a627:	000925        	call8	4200a6b8 <__sflush_r>
4200a62a:	c388      	l32i.n	a8, a3, 48
4200a62c:	0a2d      	mov.n	a2, a10
4200a62e:	00c816        	beqz	a8, 4200a63e <_fclose_r+0x62>
4200a631:	0823b2        	l32i	a11, a3, 32
4200a634:	07ad      	mov.n	a10, a7
4200a636:	0008e0        	callx8	a8
4200a639:	f87c      	movi.n	a8, -1
4200a63b:	a328a0        	movltz	a2, a8, a10
4200a63e:	061382        	l16ui	a8, a3, 12
4200a641:	096877        	bbci	a8, 7, 4200a64e <_fclose_r+0x72>
4200a644:	43b8      	l32i.n	a11, a3, 16
4200a646:	07ad      	mov.n	a10, a7
4200a648:	d98081        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200a64b:	0008e0        	callx8	a8
4200a64e:	d3b8      	l32i.n	a11, a3, 52
4200a650:	0b9c      	beqz.n	a11, 4200a664 <_fclose_r+0x88>
4200a652:	44c382        	addi	a8, a3, 68
4200a655:	071b87        	beq	a11, a8, 4200a660 <_fclose_r+0x84>
4200a658:	07ad      	mov.n	a10, a7
4200a65a:	d97b81        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200a65d:	0008e0        	callx8	a8
4200a660:	080c      	movi.n	a8, 0
4200a662:	d389      	s32i.n	a8, a3, 52
4200a664:	1223b2        	l32i	a11, a3, 72
4200a667:	bb8c      	beqz.n	a11, 4200a676 <_fclose_r+0x9a>
4200a669:	07ad      	mov.n	a10, a7
4200a66b:	d97781        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200a66e:	0008e0        	callx8	a8
4200a671:	080c      	movi.n	a8, 0
4200a673:	126382        	s32i	a8, a3, 72
4200a676:	201110        	or	a1, a1, a1
4200a679:	003125        	call8	4200a98c <__sfp_lock_acquire>
4200a67c:	080c      	movi.n	a8, 0
4200a67e:	065382        	s16i	a8, a3, 12
4200a681:	192382        	l32i	a8, a3, 100
4200a684:	08e807        	bbsi	a8, 0, 4200a690 <_fclose_r+0xb4>
4200a687:	1623a2        	l32i	a10, a3, 88
4200a68a:	d96e81        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200a68d:	0008e0        	callx8	a8
4200a690:	1623a2        	l32i	a10, a3, 88
4200a693:	d96e81        	l32r	a8, 42000c4c <_stext+0xc2c> (40376ab4 <__retarget_lock_close_recursive>)
4200a696:	0008e0        	callx8	a8
4200a699:	201110        	or	a1, a1, a1
4200a69c:	002fe5        	call8	4200a99c <__sfp_lock_release>
4200a69f:	f01d      	retw.n
4200a6a1:	000000        	ill

4200a6a4 <fclose>:
4200a6a4:	004136        	entry	a1, 32
4200a6a7:	d82a81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200a6aa:	0008e0        	callx8	a8
4200a6ad:	02bd      	mov.n	a11, a2
4200a6af:	fff2e5        	call8	4200a5dc <_fclose_r>
4200a6b2:	0a2d      	mov.n	a2, a10
4200a6b4:	f01d      	retw.n
	...

4200a6b8 <__sflush_r>:
4200a6b8:	004136        	entry	a1, 32
4200a6bb:	069382        	l16si	a8, a3, 12
4200a6be:	026837        	bbci	a8, 3, 4200a6c4 <__sflush_r+0xc>
4200a6c1:	003ac6        	j	4200a7b0 <__sflush_r+0xf8>
4200a6c4:	190c      	movi.n	a9, 1
4200a6c6:	119950        	slli	a9, a9, 11
4200a6c9:	209890        	or	a9, a8, a9
4200a6cc:	065392        	s16i	a9, a3, 12
4200a6cf:	1398      	l32i.n	a9, a3, 4
4200a6d1:	0819e6        	bgei	a9, 1, 4200a6dd <__sflush_r+0x25>
4200a6d4:	102392        	l32i	a9, a3, 64
4200a6d7:	0219e6        	bgei	a9, 1, 4200a6dd <__sflush_r+0x25>
4200a6da:	004206        	j	4200a7e6 <__sflush_r+0x12e>
4200a6dd:	b398      	l32i.n	a9, a3, 44
4200a6df:	103916        	beqz	a9, 4200a7e6 <__sflush_r+0x12e>
4200a6e2:	0a0c      	movi.n	a10, 0
4200a6e4:	048c80        	extui	a8, a8, 12, 1
4200a6e7:	0278      	l32i.n	a7, a2, 0
4200a6e9:	118840        	slli	a8, a8, 12
4200a6ec:	02a9      	s32i.n	a10, a2, 0
4200a6ee:	488c      	beqz.n	a8, 4200a6f6 <__sflush_r+0x3e>
4200a6f0:	1523c2        	l32i	a12, a3, 84
4200a6f3:	001086        	j	4200a739 <__sflush_r+0x81>
4200a6f6:	83b8      	l32i.n	a11, a3, 32
4200a6f8:	0c0c      	movi.n	a12, 0
4200a6fa:	1d0c      	movi.n	a13, 1
4200a6fc:	20a220        	or	a10, a2, a2
4200a6ff:	0009e0        	callx8	a9
4200a702:	0acd      	mov.n	a12, a10
4200a704:	310a66        	bnei	a10, -1, 4200a739 <__sflush_r+0x81>
4200a707:	0288      	l32i.n	a8, a2, 0
4200a709:	c8ac      	beqz.n	a8, 4200a739 <__sflush_r+0x81>
4200a70b:	e3c892        	addi	a9, a8, -29
4200a70e:	40f9a0        	nsau	a10, a9
4200a711:	41a5a0        	srli	a10, a10, 5
4200a714:	898c      	beqz.n	a9, 4200a720 <__sflush_r+0x68>
4200a716:	eac882        	addi	a8, a8, -22
4200a719:	190c      	movi.n	a9, 1
4200a71b:	939a80        	movnez	a9, a10, a8
4200a71e:	398c      	beqz.n	a9, 4200a725 <__sflush_r+0x6d>
4200a720:	0279      	s32i.n	a7, a2, 0
4200a722:	003006        	j	4200a7e6 <__sflush_r+0x12e>
4200a725:	061382        	l16ui	a8, a3, 12
4200a728:	094c      	movi.n	a9, 64
4200a72a:	208890        	or	a8, a8, a9
4200a72d:	238880        	sext	a8, a8, 15
4200a730:	065382        	s16i	a8, a3, 12
4200a733:	f27c      	movi.n	a2, -1
4200a735:	002bc6        	j	4200a7e8 <__sflush_r+0x130>
4200a738:	138200        	lsi	f0, a2, 76
4200a73b:	682706        	j	420247db <_etext+0xe585>
4200a73e:	0e          	.byte	0xe
4200a73f:	1388      	l32i.n	a8, a3, 4
4200a741:	c0cc80        	sub	a12, a12, a8
4200a744:	d388      	l32i.n	a8, a3, 52
4200a746:	488c      	beqz.n	a8, 4200a74e <__sflush_r+0x96>
4200a748:	102382        	l32i	a8, a3, 64
4200a74b:	c0cc80        	sub	a12, a12, a8
4200a74e:	b388      	l32i.n	a8, a3, 44
4200a750:	83b8      	l32i.n	a11, a3, 32
4200a752:	0d0c      	movi.n	a13, 0
4200a754:	02ad      	mov.n	a10, a2
4200a756:	0008e0        	callx8	a8
4200a759:	069382        	l16si	a8, a3, 12
4200a75c:	0c0a66        	bnei	a10, -1, 4200a76c <__sflush_r+0xb4>
4200a75f:	0298      	l32i.n	a9, a2, 0
4200a761:	db1c      	movi.n	a11, 29
4200a763:	413b97        	bltu	a11, a9, 4200a7a8 <__sflush_r+0xf0>
4200a766:	d93ab1        	l32r	a11, 42000c50 <_stext+0xc30> (20400001 <UserFrameTotalSize+0x203fff01>)
4200a769:	3b5b97        	bbc	a11, a9, 4200a7a8 <__sflush_r+0xf0>
4200a76c:	f97c      	movi.n	a9, -1
4200a76e:	f8d992        	addmi	a9, a9, 0xfffff800
4200a771:	109890        	and	a9, a8, a9
4200a774:	065392        	s16i	a9, a3, 12
4200a777:	090c      	movi.n	a9, 0
4200a779:	1399      	s32i.n	a9, a3, 4
4200a77b:	4398      	l32i.n	a9, a3, 16
4200a77d:	0399      	s32i.n	a9, a3, 0
4200a77f:	0968c7        	bbci	a8, 12, 4200a78c <__sflush_r+0xd4>
4200a782:	030a66        	bnei	a10, -1, 4200a789 <__sflush_r+0xd1>
4200a785:	0288      	l32i.n	a8, a2, 0
4200a787:	18cc      	bnez.n	a8, 4200a78c <__sflush_r+0xd4>
4200a789:	1563a2        	s32i	a10, a3, 84
4200a78c:	d3b8      	l32i.n	a11, a3, 52
4200a78e:	0279      	s32i.n	a7, a2, 0
4200a790:	052b16        	beqz	a11, 4200a7e6 <__sflush_r+0x12e>
4200a793:	44c382        	addi	a8, a3, 68
4200a796:	071b87        	beq	a11, a8, 4200a7a1 <__sflush_r+0xe9>
4200a799:	02ad      	mov.n	a10, a2
4200a79b:	d92b81        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200a79e:	0008e0        	callx8	a8
4200a7a1:	080c      	movi.n	a8, 0
4200a7a3:	d389      	s32i.n	a8, a3, 52
4200a7a5:	000f46        	j	4200a7e6 <__sflush_r+0x12e>
4200a7a8:	094c      	movi.n	a9, 64
4200a7aa:	208890        	or	a8, a8, a9
4200a7ad:	ffdfc6        	j	4200a730 <__sflush_r+0x78>
4200a7b0:	4368      	l32i.n	a6, a3, 16
4200a7b2:	06bc      	beqz.n	a6, 4200a7e6 <__sflush_r+0x12e>
4200a7b4:	0378      	l32i.n	a7, a3, 0
4200a7b6:	148080        	extui	a8, a8, 0, 2
4200a7b9:	0369      	s32i.n	a6, a3, 0
4200a7bb:	c07760        	sub	a7, a7, a6
4200a7be:	090c      	movi.n	a9, 0
4200a7c0:	08cc      	bnez.n	a8, 4200a7c4 <__sflush_r+0x10c>
4200a7c2:	5398      	l32i.n	a9, a3, 20
4200a7c4:	2399      	s32i.n	a9, a3, 8
4200a7c6:	000646        	j	4200a7e3 <__sflush_r+0x12b>
4200a7c9:	a388      	l32i.n	a8, a3, 40
4200a7cb:	83b8      	l32i.n	a11, a3, 32
4200a7cd:	07dd      	mov.n	a13, a7
4200a7cf:	20c660        	or	a12, a6, a6
4200a7d2:	20a220        	or	a10, a2, a2
4200a7d5:	0008e0        	callx8	a8
4200a7d8:	021ae6        	bgei	a10, 1, 4200a7de <__sflush_r+0x126>
4200a7db:	ffd186        	j	4200a725 <__sflush_r+0x6d>
4200a7de:	66aa      	add.n	a6, a6, a10
4200a7e0:	c077a0        	sub	a7, a7, a10
4200a7e3:	e217e6        	bgei	a7, 1, 4200a7c9 <__sflush_r+0x111>
4200a7e6:	020c      	movi.n	a2, 0
4200a7e8:	f01d      	retw.n
	...

4200a7ec <_fflush_r>:
4200a7ec:	004136        	entry	a1, 32
4200a7ef:	4388      	l32i.n	a8, a3, 16
4200a7f1:	005856        	bnez	a8, 4200a7fa <_fflush_r+0xe>
4200a7f4:	020c      	movi.n	a2, 0
4200a7f6:	001186        	j	4200a840 <_fflush_r+0x54>
4200a7f9:	b28c00        	mulsh	a8, a12, a0
4200a7fc:	a288      	l32i.n	a8, a2, 40
4200a7fe:	78cc      	bnez.n	a8, 4200a809 <_fflush_r+0x1d>
4200a800:	20a220        	or	a10, a2, a2
4200a803:	201110        	or	a1, a1, a1
4200a806:	0024e5        	call8	4200aa54 <__sinit>
4200a809:	069382        	l16si	a8, a3, 12
4200a80c:	fe4816        	beqz	a8, 4200a7f4 <_fflush_r+0x8>
4200a80f:	192392        	l32i	a9, a3, 100
4200a812:	0be907        	bbsi	a9, 0, 4200a821 <_fflush_r+0x35>
4200a815:	08e897        	bbsi	a8, 9, 4200a821 <_fflush_r+0x35>
4200a818:	1623a2        	l32i	a10, a3, 88
4200a81b:	d90981        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200a81e:	0008e0        	callx8	a8
4200a821:	02ad      	mov.n	a10, a2
4200a823:	20b330        	or	a11, a3, a3
4200a826:	ffe925        	call8	4200a6b8 <__sflush_r>
4200a829:	192382        	l32i	a8, a3, 100
4200a82c:	0a2d      	mov.n	a2, a10
4200a82e:	0ee807        	bbsi	a8, 0, 4200a840 <_fflush_r+0x54>
4200a831:	061382        	l16ui	a8, a3, 12
4200a834:	08e897        	bbsi	a8, 9, 4200a840 <_fflush_r+0x54>
4200a837:	1623a2        	l32i	a10, a3, 88
4200a83a:	d90281        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200a83d:	0008e0        	callx8	a8
4200a840:	f01d      	retw.n
	...

4200a844 <fflush>:
4200a844:	004136        	entry	a1, 32
4200a847:	02dc      	bnez.n	a2, 4200a85b <fflush+0x17>
4200a849:	d7cac1        	l32r	a12, 42000774 <_stext+0x754> (3fc92694 <__sglue>)
4200a84c:	d902b1        	l32r	a11, 42000c54 <_stext+0xc34> (4200a7ec <_fflush_r>)
4200a84f:	d7c6a1        	l32r	a10, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
4200a852:	201110        	or	a1, a1, a1
4200a855:	0a2ca5        	call8	42014b20 <_fwalk_sglue>
4200a858:	000286        	j	4200a866 <fflush+0x22>
4200a85b:	d7bd81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200a85e:	0008e0        	callx8	a8
4200a861:	02bd      	mov.n	a11, a2
4200a863:	fff8a5        	call8	4200a7ec <_fflush_r>
4200a866:	0a2d      	mov.n	a2, a10
4200a868:	f01d      	retw.n
	...

4200a86c <std>:
4200a86c:	004136        	entry	a1, 32
4200a86f:	070c      	movi.n	a7, 0
4200a871:	0279      	s32i.n	a7, a2, 0
4200a873:	1279      	s32i.n	a7, a2, 4
4200a875:	2279      	s32i.n	a7, a2, 8
4200a877:	196272        	s32i	a7, a2, 100
4200a87a:	4279      	s32i.n	a7, a2, 16
4200a87c:	5279      	s32i.n	a7, a2, 20
4200a87e:	6279      	s32i.n	a7, a2, 24
4200a880:	065232        	s16i	a3, a2, 12
4200a883:	075242        	s16i	a4, a2, 14
4200a886:	8c0c      	movi.n	a12, 8
4200a888:	00a0b2        	movi	a11, 0
4200a88b:	5cc2a2        	addi	a10, a2, 92
4200a88e:	d69c81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200a891:	0008e0        	callx8	a8
4200a894:	d8f181        	l32r	a8, 42000c58 <_stext+0xc38> (4200af38 <__sread>)
4200a897:	d8f4a1        	l32r	a10, 42000c68 <_stext+0xc48> (3fc95f84 <__sf+0x68>)
4200a89a:	9289      	s32i.n	a8, a2, 36
4200a89c:	d8f081        	l32r	a8, 42000c5c <_stext+0xc3c> (4200af74 <__swrite>)
4200a89f:	c0a2a0        	sub	a10, a2, a10
4200a8a2:	a289      	s32i.n	a8, a2, 40
4200a8a4:	d8ef81        	l32r	a8, 42000c60 <_stext+0xc40> (4200afb0 <__sseek>)
4200a8a7:	079d      	mov.n	a9, a7
4200a8a9:	b289      	s32i.n	a8, a2, 44
4200a8ab:	d8ee81        	l32r	a8, 42000c64 <_stext+0xc44> (4200afec <__sclose>)
4200a8ae:	8229      	s32i.n	a2, a2, 32
4200a8b0:	c289      	s32i.n	a8, a2, 48
4200a8b2:	180c      	movi.n	a8, 1
4200a8b4:	8398a0        	moveqz	a9, a8, a10
4200a8b7:	d8eda1        	l32r	a10, 42000c6c <_stext+0xc4c> (3fc95f1c <__sf>)
4200a8ba:	c0a2a0        	sub	a10, a2, a10
4200a8bd:	8378a0        	moveqz	a7, a8, a10
4200a8c0:	209970        	or	a9, a9, a7
4200a8c3:	99cc      	bnez.n	a9, 4200a8d0 <std+0x64>
4200a8c5:	d8eaa1        	l32r	a10, 42000c70 <_stext+0xc50> (3fc95fec <__sf+0xd0>)
4200a8c8:	c0a2a0        	sub	a10, a2, a10
4200a8cb:	9389a0        	movnez	a8, a9, a10
4200a8ce:	788c      	beqz.n	a8, 4200a8d9 <std+0x6d>
4200a8d0:	58c2a2        	addi	a10, a2, 88
4200a8d3:	d8e881        	l32r	a8, 42000c74 <_stext+0xc54> (40376a90 <__retarget_lock_init_recursive>)
4200a8d6:	0008e0        	callx8	a8
4200a8d9:	f01d      	retw.n
	...

4200a8dc <stdio_exit_handler>:
4200a8dc:	004136        	entry	a1, 32
4200a8df:	d7a5c1        	l32r	a12, 42000774 <_stext+0x754> (3fc92694 <__sglue>)
4200a8e2:	d8e5b1        	l32r	a11, 42000c78 <_stext+0xc58> (4200a5dc <_fclose_r>)
4200a8e5:	d7a0a1        	l32r	a10, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
4200a8e8:	201110        	or	a1, a1, a1
4200a8eb:	0a2365        	call8	42014b20 <_fwalk_sglue>
4200a8ee:	f01d      	retw.n

4200a8f0 <cleanup_stdio>:
4200a8f0:	004136        	entry	a1, 32
4200a8f3:	12b8      	l32i.n	a11, a2, 4
4200a8f5:	d8dd81        	l32r	a8, 42000c6c <_stext+0xc4c> (3fc95f1c <__sf>)
4200a8f8:	081b87        	beq	a11, a8, 4200a904 <cleanup_stdio+0x14>
4200a8fb:	20a220        	or	a10, a2, a2
4200a8fe:	201110        	or	a1, a1, a1
4200a901:	ffcda5        	call8	4200a5dc <_fclose_r>
4200a904:	22b8      	l32i.n	a11, a2, 8
4200a906:	d8d881        	l32r	a8, 42000c68 <_stext+0xc48> (3fc95f84 <__sf+0x68>)
4200a909:	071b87        	beq	a11, a8, 4200a914 <cleanup_stdio+0x24>
4200a90c:	02ad      	mov.n	a10, a2
4200a90e:	201110        	or	a1, a1, a1
4200a911:	ffcca5        	call8	4200a5dc <_fclose_r>
4200a914:	32b8      	l32i.n	a11, a2, 12
4200a916:	d8d681        	l32r	a8, 42000c70 <_stext+0xc50> (3fc95fec <__sf+0xd0>)
4200a919:	071b87        	beq	a11, a8, 4200a924 <cleanup_stdio+0x34>
4200a91c:	02ad      	mov.n	a10, a2
4200a91e:	201110        	or	a1, a1, a1
4200a921:	ffcba5        	call8	4200a5dc <_fclose_r>
4200a924:	f01d      	retw.n
	...

4200a928 <__fp_lock>:
4200a928:	004136        	entry	a1, 32
4200a92b:	192382        	l32i	a8, a3, 100
4200a92e:	0ee807        	bbsi	a8, 0, 4200a940 <__fp_lock+0x18>
4200a931:	061382        	l16ui	a8, a3, 12
4200a934:	08e897        	bbsi	a8, 9, 4200a940 <__fp_lock+0x18>
4200a937:	1623a2        	l32i	a10, a3, 88
4200a93a:	d8c181        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200a93d:	0008e0        	callx8	a8
4200a940:	020c      	movi.n	a2, 0
4200a942:	f01d      	retw.n

4200a944 <__fp_unlock>:
4200a944:	004136        	entry	a1, 32
4200a947:	192382        	l32i	a8, a3, 100
4200a94a:	0ee807        	bbsi	a8, 0, 4200a95c <__fp_unlock+0x18>
4200a94d:	061382        	l16ui	a8, a3, 12
4200a950:	08e897        	bbsi	a8, 9, 4200a95c <__fp_unlock+0x18>
4200a953:	1623a2        	l32i	a10, a3, 88
4200a956:	d8bb81        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200a959:	0008e0        	callx8	a8
4200a95c:	020c      	movi.n	a2, 0
4200a95e:	f01d      	retw.n

4200a960 <global_stdio_init$part$0>:
4200a960:	004136        	entry	a1, 32
4200a963:	d8c681        	l32r	a8, 42000c7c <_stext+0xc5c> (3fc96054 <__stdio_exit_handler>)
4200a966:	d8c691        	l32r	a9, 42000c80 <_stext+0xc60> (4200a8dc <stdio_exit_handler>)
4200a969:	d8c0a1        	l32r	a10, 42000c6c <_stext+0xc4c> (3fc95f1c <__sf>)
4200a96c:	0899      	s32i.n	a9, a8, 0
4200a96e:	0c0c      	movi.n	a12, 0
4200a970:	4b0c      	movi.n	a11, 4
4200a972:	ffefa5        	call8	4200a86c <std>
4200a975:	d8bca1        	l32r	a10, 42000c68 <_stext+0xc48> (3fc95f84 <__sf+0x68>)
4200a978:	01a0c2        	movi	a12, 1
4200a97b:	8b0c      	movi.n	a11, 8
4200a97d:	ffeee5        	call8	4200a86c <std>
4200a980:	d8bca1        	l32r	a10, 42000c70 <_stext+0xc50> (3fc95fec <__sf+0xd0>)
4200a983:	2c0c      	movi.n	a12, 2
4200a985:	2b1c      	movi.n	a11, 18
4200a987:	ffee65        	call8	4200a86c <std>
4200a98a:	f01d      	retw.n

4200a98c <__sfp_lock_acquire>:
4200a98c:	004136        	entry	a1, 32
4200a98f:	d768a1        	l32r	a10, 42000730 <_stext+0x710> (3fc94e04 <__lock___atexit_recursive_mutex>)
4200a992:	d8ab81        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200a995:	0008e0        	callx8	a8
4200a998:	f01d      	retw.n
	...

4200a99c <__sfp_lock_release>:
4200a99c:	004136        	entry	a1, 32
4200a99f:	d764a1        	l32r	a10, 42000730 <_stext+0x710> (3fc94e04 <__lock___atexit_recursive_mutex>)
4200a9a2:	d8a881        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200a9a5:	0008e0        	callx8	a8
4200a9a8:	f01d      	retw.n
	...

4200a9ac <__sfp>:
4200a9ac:	004136        	entry	a1, 32
4200a9af:	fffde5        	call8	4200a98c <__sfp_lock_acquire>
4200a9b2:	d8b281        	l32r	a8, 42000c7c <_stext+0xc5c> (3fc96054 <__stdio_exit_handler>)
4200a9b5:	025d      	mov.n	a5, a2
4200a9b7:	002882        	l32i	a8, a8, 0
4200a9ba:	002856        	bnez	a8, 4200a9c0 <__sfp+0x14>
4200a9bd:	fffa25        	call8	4200a960 <global_stdio_init$part$0>
4200a9c0:	d76d61        	l32r	a6, 42000774 <_stext+0x754> (3fc92694 <__sglue>)
4200a9c3:	2628      	l32i.n	a2, a6, 8
4200a9c5:	1688      	l32i.n	a8, a6, 4
4200a9c7:	001146        	j	4200aa10 <__sfp+0x64>
4200a9ca:	720000        	lsi	f0, a0, 0x1c8
4200a9cd:	fc0692        	l8ui	a9, a6, 252
4200a9d0:	ac81a7        	bany	a1, a10, 4200a980 <global_stdio_init$part$0+0x20>
4200a9d3:	a2d8      	l32i.n	a13, a2, 40
4200a9d5:	8958c2        	s16i	a12, a8, 0x112
4200a9d8:	627232        	lsi	f3, a2, 0x188
4200a9db:	8119      	s32i.n	a1, a1, 32
4200a9dd:	e0d8a6        	blti	a8, 64, 4200a9c1 <__sfp+0x15>
4200a9e0:	0008      	l32i.n	a0, a0, 0
4200a9e2:	fffba5        	call8	4200a99c <__sfp_lock_release>
4200a9e5:	8c0c      	movi.n	a12, 8
4200a9e7:	0279      	s32i.n	a7, a2, 0
4200a9e9:	2279      	s32i.n	a7, a2, 8
4200a9eb:	1279      	s32i.n	a7, a2, 4
4200a9ed:	4279      	s32i.n	a7, a2, 16
4200a9ef:	5279      	s32i.n	a7, a2, 20
4200a9f1:	6279      	s32i.n	a7, a2, 24
4200a9f3:	0b0c      	movi.n	a11, 0
4200a9f5:	5cc2a2        	addi	a10, a2, 92
4200a9f8:	d64281        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200a9fb:	0008e0        	callx8	a8
4200a9fe:	d279      	s32i.n	a7, a2, 52
4200aa00:	e279      	s32i.n	a7, a2, 56
4200aa02:	126272        	s32i	a7, a2, 72
4200aa05:	136272        	s32i	a7, a2, 76
4200aa08:	001186        	j	4200aa52 <__sfp+0xa6>
4200aa0b:	220000        	orb	b0, b0, b0
4200aa0e:	0b68c2        	s32i	a12, a8, 44
4200aa11:	d688      	l32i.n	a8, a6, 52
4200aa13:	fb68      	l32i.n	a6, a11, 60
4200aa15:	0678      	l32i.n	a7, a6, 0
4200aa17:	27fc      	bnez.n	a7, 4200aa4d <__sfp+0xa1>
4200aa19:	aca1b2        	movi	a11, 0x1ac
4200aa1c:	05ad      	mov.n	a10, a5
4200aa1e:	d89a81        	l32r	a8, 42000c88 <_stext+0xc68> (4037fea4 <_malloc_r>)
4200aa21:	0008e0        	callx8	a8
4200aa24:	0a2d      	mov.n	a2, a10
4200aa26:	aacc      	bnez.n	a10, 4200aa34 <__sfp+0x88>
4200aa28:	06a9      	s32i.n	a10, a6, 0
4200aa2a:	fff725        	call8	4200a99c <__sfp_lock_release>
4200aa2d:	c80c      	movi.n	a8, 12
4200aa2f:	0589      	s32i.n	a8, a5, 0
4200aa31:	000746        	j	4200aa52 <__sfp+0xa6>
4200aa34:	480c      	movi.n	a8, 4
4200aa36:	0a79      	s32i.n	a7, a10, 0
4200aa38:	1a89      	s32i.n	a8, a10, 4
4200aa3a:	aacb      	addi.n	a10, a10, 12
4200aa3c:	22a9      	s32i.n	a10, a2, 8
4200aa3e:	a0a1c2        	movi	a12, 0x1a0
4200aa41:	0b0c      	movi.n	a11, 0
4200aa43:	d62f81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200aa46:	0008e0        	callx8	a8
4200aa49:	027d      	mov.n	a7, a2
4200aa4b:	0629      	s32i.n	a2, a6, 0
4200aa4d:	076d      	mov.n	a6, a7
4200aa4f:	ffdc06        	j	4200a9c3 <__sfp+0x17>
4200aa52:	f01d      	retw.n

4200aa54 <__sinit>:
4200aa54:	004136        	entry	a1, 32
4200aa57:	fff365        	call8	4200a98c <__sfp_lock_acquire>
4200aa5a:	0a2282        	l32i	a8, a2, 40
4200aa5d:	004816        	beqz	a8, 4200aa65 <__sinit+0x11>
4200aa60:	fff3a5        	call8	4200a99c <__sfp_lock_release>
4200aa63:	f01d      	retw.n
4200aa65:	d88981        	l32r	a8, 42000c8c <_stext+0xc6c> (4200a8f0 <cleanup_stdio>)
4200aa68:	a289      	s32i.n	a8, a2, 40
4200aa6a:	d88481        	l32r	a8, 42000c7c <_stext+0xc5c> (3fc96054 <__stdio_exit_handler>)
4200aa6d:	0888      	l32i.n	a8, a8, 0
4200aa6f:	fed856        	bnez	a8, 4200aa60 <__sinit+0xc>
4200aa72:	ffeee5        	call8	4200a960 <global_stdio_init$part$0>
4200aa75:	fff9c6        	j	4200aa60 <__sinit+0xc>

4200aa78 <__fp_lock_all>:
4200aa78:	004136        	entry	a1, 32
4200aa7b:	fff125        	call8	4200a98c <__sfp_lock_acquire>
4200aa7e:	d73dc1        	l32r	a12, 42000774 <_stext+0x754> (3fc92694 <__sglue>)
4200aa81:	d883b1        	l32r	a11, 42000c90 <_stext+0xc70> (4200a928 <__fp_lock>)
4200aa84:	0a0c      	movi.n	a10, 0
4200aa86:	201110        	or	a1, a1, a1
4200aa89:	0a0965        	call8	42014b20 <_fwalk_sglue>
4200aa8c:	f01d      	retw.n
	...

4200aa90 <__fp_unlock_all>:
4200aa90:	004136        	entry	a1, 32
4200aa93:	d738c1        	l32r	a12, 42000774 <_stext+0x754> (3fc92694 <__sglue>)
4200aa96:	d87fb1        	l32r	a11, 42000c94 <_stext+0xc74> (4200a944 <__fp_unlock>)
4200aa99:	0a0c      	movi.n	a10, 0
4200aa9b:	0a0865        	call8	42014b20 <_fwalk_sglue>
4200aa9e:	ffefe5        	call8	4200a99c <__sfp_lock_release>
4200aaa1:	f01d      	retw.n
	...

4200aaa4 <_fopen_r>:
4200aaa4:	006136        	entry	a1, 48
4200aaa7:	20b440        	or	a11, a4, a4
4200aaaa:	20c110        	or	a12, a1, a1
4200aaad:	20a220        	or	a10, a2, a2
4200aab0:	201110        	or	a1, a1, a1
4200aab3:	0a0a65        	call8	42014b58 <__sflags>
4200aab6:	026d      	mov.n	a6, a2
4200aab8:	207aa0        	or	a7, a10, a10
4200aabb:	9abc      	beqz.n	a10, 4200aaf8 <_fopen_r+0x54>
4200aabd:	20a220        	or	a10, a2, a2
4200aac0:	201110        	or	a1, a1, a1
4200aac3:	ffeea5        	call8	4200a9ac <__sfp>
4200aac6:	0a2d      	mov.n	a2, a10
4200aac8:	caac      	beqz.n	a10, 4200aaf8 <_fopen_r+0x54>
4200aaca:	01c8      	l32i.n	a12, a1, 0
4200aacc:	b6a1d2        	movi	a13, 0x1b6
4200aacf:	03bd      	mov.n	a11, a3
4200aad1:	06ad      	mov.n	a10, a6
4200aad3:	201110        	or	a1, a1, a1
4200aad6:	fc10a5        	call8	42006be0 <_open_r>
4200aad9:	0a5d      	mov.n	a5, a10
4200aadb:	01ead6        	bgez	a10, 4200aafd <_fopen_r+0x59>
4200aade:	201110        	or	a1, a1, a1
4200aae1:	ffeaa5        	call8	4200a98c <__sfp_lock_acquire>
4200aae4:	080c      	movi.n	a8, 0
4200aae6:	1622a2        	l32i	a10, a2, 88
4200aae9:	065282        	s16i	a8, a2, 12
4200aaec:	d85881        	l32r	a8, 42000c4c <_stext+0xc2c> (40376ab4 <__retarget_lock_close_recursive>)
4200aaef:	0008e0        	callx8	a8
4200aaf2:	201110        	or	a1, a1, a1
4200aaf5:	ffea65        	call8	4200a99c <__sfp_lock_release>
4200aaf8:	020c      	movi.n	a2, 0
4200aafa:	0016c6        	j	4200ab59 <_fopen_r+0xb5>
4200aafd:	192282        	l32i	a8, a2, 100
4200ab00:	0ee807        	bbsi	a8, 0, 4200ab12 <_fopen_r+0x6e>
4200ab03:	061282        	l16ui	a8, a2, 12
4200ab06:	08e897        	bbsi	a8, 9, 4200ab12 <_fopen_r+0x6e>
4200ab09:	1622a2        	l32i	a10, a2, 88
4200ab0c:	d84d81        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200ab0f:	0008e0        	callx8	a8
4200ab12:	d85181        	l32r	a8, 42000c58 <_stext+0xc38> (4200af38 <__sread>)
4200ab15:	237780        	sext	a7, a7, 15
4200ab18:	9289      	s32i.n	a8, a2, 36
4200ab1a:	d85081        	l32r	a8, 42000c5c <_stext+0xc3c> (4200af74 <__swrite>)
4200ab1d:	075252        	s16i	a5, a2, 14
4200ab20:	a289      	s32i.n	a8, a2, 40
4200ab22:	d84f81        	l32r	a8, 42000c60 <_stext+0xc40> (4200afb0 <__sseek>)
4200ab25:	065272        	s16i	a7, a2, 12
4200ab28:	b289      	s32i.n	a8, a2, 44
4200ab2a:	d84e81        	l32r	a8, 42000c64 <_stext+0xc44> (4200afec <__sclose>)
4200ab2d:	8229      	s32i.n	a2, a2, 32
4200ab2f:	c289      	s32i.n	a8, a2, 48
4200ab31:	0f6787        	bbci	a7, 8, 4200ab44 <_fopen_r+0xa0>
4200ab34:	2d0c      	movi.n	a13, 2
4200ab36:	00a0c2        	movi	a12, 0
4200ab39:	02bd      	mov.n	a11, a2
4200ab3b:	20a660        	or	a10, a6, a6
4200ab3e:	201110        	or	a1, a1, a1
4200ab41:	0002e5        	call8	4200ab70 <_fseek_r>
4200ab44:	192282        	l32i	a8, a2, 100
4200ab47:	0ee807        	bbsi	a8, 0, 4200ab59 <_fopen_r+0xb5>
4200ab4a:	061282        	l16ui	a8, a2, 12
4200ab4d:	08e897        	bbsi	a8, 9, 4200ab59 <_fopen_r+0xb5>
4200ab50:	1622a2        	l32i	a10, a2, 88
4200ab53:	d83c81        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200ab56:	0008e0        	callx8	a8
4200ab59:	f01d      	retw.n
	...

4200ab5c <fopen>:
4200ab5c:	004136        	entry	a1, 32
4200ab5f:	d6fc81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200ab62:	0008e0        	callx8	a8
4200ab65:	02bd      	mov.n	a11, a2
4200ab67:	03cd      	mov.n	a12, a3
4200ab69:	fff3a5        	call8	4200aaa4 <_fopen_r>
4200ab6c:	0a2d      	mov.n	a2, a10
4200ab6e:	f01d      	retw.n

4200ab70 <_fseek_r>:
4200ab70:	004136        	entry	a1, 32
4200ab73:	02ad      	mov.n	a10, a2
4200ab75:	03bd      	mov.n	a11, a3
4200ab77:	04cd      	mov.n	a12, a4
4200ab79:	05dd      	mov.n	a13, a5
4200ab7b:	201110        	or	a1, a1, a1
4200ab7e:	005665        	call8	4200b0e4 <_fseeko_r>
4200ab81:	0a2d      	mov.n	a2, a10
4200ab83:	f01d      	retw.n
4200ab85:	000000        	ill

4200ab88 <fseek>:
4200ab88:	004136        	entry	a1, 32
4200ab8b:	d6f181        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200ab8e:	0008e0        	callx8	a8
4200ab91:	02bd      	mov.n	a11, a2
4200ab93:	04dd      	mov.n	a13, a4
4200ab95:	03cd      	mov.n	a12, a3
4200ab97:	201110        	or	a1, a1, a1
4200ab9a:	0054a5        	call8	4200b0e4 <_fseeko_r>
4200ab9d:	0a2d      	mov.n	a2, a10
4200ab9f:	f01d      	retw.n
4200aba1:	000000        	ill

4200aba4 <__sfvwrite_r>:
4200aba4:	006136        	entry	a1, 48
4200aba7:	2498      	l32i.n	a9, a4, 8
4200aba9:	0129      	s32i.n	a2, a1, 0
4200abab:	032d      	mov.n	a2, a3
4200abad:	39cc      	bnez.n	a9, 4200abb4 <__sfvwrite_r+0x10>
4200abaf:	020c      	movi.n	a2, 0
4200abb1:	00a606        	j	4200ae4d <__sfvwrite_r+0x2a9>
4200abb4:	061392        	l16ui	a9, a3, 12
4200abb7:	136937        	bbci	a9, 3, 4200abce <__sfvwrite_r+0x2a>
4200abba:	042392        	l32i	a9, a3, 16
4200abbd:	00d916        	beqz	a9, 4200abce <__sfvwrite_r+0x2a>
4200abc0:	069292        	l16si	a9, a2, 12
4200abc3:	0478      	l32i.n	a7, a4, 0
4200abc5:	20e917        	bbsi	a9, 1, 4200abe9 <__sfvwrite_r+0x45>
4200abc8:	001346        	j	4200ac19 <__sfvwrite_r+0x75>
4200abcb:	000000        	ill
4200abce:	01a8      	l32i.n	a10, a1, 0
4200abd0:	02bd      	mov.n	a11, a2
4200abd2:	201110        	or	a1, a1, a1
4200abd5:	0046a5        	call8	4200b040 <__swsetup_r>
4200abd8:	fe4a16        	beqz	a10, 4200abc0 <__sfvwrite_r+0x1c>
4200abdb:	009b06        	j	4200ae4b <__sfvwrite_r+0x2a7>
4200abde:	0738      	l32i.n	a3, a7, 0
4200abe0:	1768      	l32i.n	a6, a7, 4
4200abe2:	778b      	addi.n	a7, a7, 8
4200abe4:	000206        	j	4200abf0 <__sfvwrite_r+0x4c>
4200abe7:	510000        	lsi	f0, a0, 0x144
4200abea:	d82b      	addi.n	a13, a8, 2
4200abec:	030c      	movi.n	a3, 0
4200abee:	060c      	movi.n	a6, 0
4200abf0:	fea616        	beqz	a6, 4200abde <__sfvwrite_r+0x3a>
4200abf3:	a298      	l32i.n	a9, a2, 40
4200abf5:	82b8      	l32i.n	a11, a2, 32
4200abf7:	01a8      	l32i.n	a10, a1, 0
4200abf9:	63d650        	minu	a13, a6, a5
4200abfc:	03cd      	mov.n	a12, a3
4200abfe:	0009e0        	callx8	a9
4200ac01:	021ae6        	bgei	a10, 1, 4200ac07 <__sfvwrite_r+0x63>
4200ac04:	008e06        	j	4200ae40 <__sfvwrite_r+0x29c>
4200ac07:	2498      	l32i.n	a9, a4, 8
4200ac09:	33aa      	add.n	a3, a3, a10
4200ac0b:	c099a0        	sub	a9, a9, a10
4200ac0e:	2499      	s32i.n	a9, a4, 8
4200ac10:	c066a0        	sub	a6, a6, a10
4200ac13:	fd9956        	bnez	a9, 4200abf0 <__sfvwrite_r+0x4c>
4200ac16:	ffe546        	j	4200abaf <__sfvwrite_r+0xb>
4200ac19:	146907        	bbci	a9, 0, 4200ac31 <__sfvwrite_r+0x8d>
4200ac1c:	030c      	movi.n	a3, 0
4200ac1e:	0a0c      	movi.n	a10, 0
4200ac20:	060c      	movi.n	a6, 0
4200ac22:	050c      	movi.n	a5, 0
4200ac24:	005a06        	j	4200ad90 <__sfvwrite_r+0x1ec>
4200ac27:	075800        	lsi	f0, a8, 28
4200ac2a:	1738      	l32i.n	a3, a7, 4
4200ac2c:	778b      	addi.n	a7, a7, 8
4200ac2e:	0000c6        	j	4200ac35 <__sfvwrite_r+0x91>
4200ac31:	050c      	movi.n	a5, 0
4200ac33:	030c      	movi.n	a3, 0
4200ac35:	fef316        	beqz	a3, 4200ac28 <__sfvwrite_r+0x84>
4200ac38:	0692f2        	l16si	a15, a2, 12
4200ac3b:	02a8      	l32i.n	a10, a2, 0
4200ac3d:	22e8      	l32i.n	a14, a2, 8
4200ac3f:	02ef97        	bbsi	a15, 9, 4200ac45 <__sfvwrite_r+0xa1>
4200ac42:	003606        	j	4200ad1e <__sfvwrite_r+0x17a>
4200ac45:	0ecd      	mov.n	a12, a14
4200ac47:	05b3e7        	bgeu	a3, a14, 4200ac50 <__sfvwrite_r+0xac>
4200ac4a:	03ed      	mov.n	a14, a3
4200ac4c:	002886        	j	4200acf2 <__sfvwrite_r+0x14e>
4200ac4f:	a4b200        	extui	a11, a0, 2, 11
4200ac52:	8fb780        	f64cmph	a11, a7, a8, 8
4200ac55:	27c602        	addi	a0, a6, 39
4200ac58:	42b800        	xorb	b11, b8, b0
4200ac5b:	c08ab0        	sub	a8, a10, a11
4200ac5e:	52a8      	l32i.n	a10, a2, 20
4200ac60:	1189      	s32i.n	a8, a1, 4
4200ac62:	90aaa0        	addx2	a10, a10, a10
4200ac65:	05dfa0        	extui	a13, a10, 31, 1
4200ac68:	ddaa      	add.n	a13, a13, a10
4200ac6a:	a81b      	addi.n	a10, a8, 1
4200ac6c:	2161d0        	srai	a6, a13, 1
4200ac6f:	aa3a      	add.n	a10, a10, a3
4200ac71:	20c660        	or	a12, a6, a6
4200ac74:	04b6a7        	bgeu	a6, a10, 4200ac7c <__sfvwrite_r+0xd8>
4200ac77:	0a6d      	mov.n	a6, a10
4200ac79:	20caa0        	or	a12, a10, a10
4200ac7c:	366fa7        	bbci	a15, 10, 4200acb6 <__sfvwrite_r+0x112>
4200ac7f:	01a8      	l32i.n	a10, a1, 0
4200ac81:	0cbd      	mov.n	a11, a12
4200ac83:	d80181        	l32r	a8, 42000c88 <_stext+0xc68> (4037fea4 <_malloc_r>)
4200ac86:	0008e0        	callx8	a8
4200ac89:	1acc      	bnez.n	a10, 4200ac8e <__sfvwrite_r+0xea>
4200ac8b:	001246        	j	4200acd8 <__sfvwrite_r+0x134>
4200ac8e:	42b8      	l32i.n	a11, a2, 16
4200ac90:	0121c2        	l32i	a12, a1, 4
4200ac93:	0261a2        	s32i	a10, a1, 8
4200ac96:	d4e481        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200ac99:	0008e0        	callx8	a8
4200ac9c:	0612a2        	l16ui	a10, a2, 12
4200ac9f:	7fabb2        	movi	a11, 0xfffffb7f
4200aca2:	10aab0        	and	a10, a10, a11
4200aca5:	80a0b2        	movi	a11, 128
4200aca8:	20aab0        	or	a10, a10, a11
4200acab:	21e8      	l32i.n	a14, a1, 8
4200acad:	0652a2        	s16i	a10, a2, 12
4200acb0:	000b46        	j	4200ace1 <__sfvwrite_r+0x13d>
4200acb3:	000000        	ill
4200acb6:	01a8      	l32i.n	a10, a1, 0
4200acb8:	d7f981        	l32r	a8, 42000c9c <_stext+0xc7c> (4037fe90 <_realloc_r>)
4200acbb:	0008e0        	callx8	a8
4200acbe:	0aed      	mov.n	a14, a10
4200acc0:	dadc      	bnez.n	a10, 4200ace1 <__sfvwrite_r+0x13d>
4200acc2:	01a8      	l32i.n	a10, a1, 0
4200acc4:	42b8      	l32i.n	a11, a2, 16
4200acc6:	d7e081        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200acc9:	0008e0        	callx8	a8
4200accc:	061292        	l16ui	a9, a2, 12
4200accf:	7fafa2        	movi	a10, -129
4200acd2:	1099a0        	and	a9, a9, a10
4200acd5:	065292        	s16i	a9, a2, 12
4200acd8:	0188      	l32i.n	a8, a1, 0
4200acda:	c90c      	movi.n	a9, 12
4200acdc:	0899      	s32i.n	a9, a8, 0
4200acde:	005786        	j	4200ae40 <__sfvwrite_r+0x29c>
4200ace1:	1188      	l32i.n	a8, a1, 4
4200ace3:	42e9      	s32i.n	a14, a2, 16
4200ace5:	c0d680        	sub	a13, a6, a8
4200ace8:	ee8a      	add.n	a14, a14, a8
4200acea:	02e9      	s32i.n	a14, a2, 0
4200acec:	5269      	s32i.n	a6, a2, 20
4200acee:	03ed      	mov.n	a14, a3
4200acf0:	22d9      	s32i.n	a13, a2, 8
4200acf2:	036d      	mov.n	a6, a3
4200acf4:	03cd      	mov.n	a12, a3
4200acf6:	000046        	j	4200acfb <__sfvwrite_r+0x157>
4200acf9:	036d      	mov.n	a6, a3
4200acfb:	02a8      	l32i.n	a10, a2, 0
4200acfd:	05bd      	mov.n	a11, a5
4200acff:	21e9      	s32i.n	a14, a1, 8
4200ad01:	11c9      	s32i.n	a12, a1, 4
4200ad03:	d6f981        	l32r	a8, 420008e8 <_stext+0x8c8> (40001200 <memmove>)
4200ad06:	0008e0        	callx8	a8
4200ad09:	22a8      	l32i.n	a10, a2, 8
4200ad0b:	21e8      	l32i.n	a14, a1, 8
4200ad0d:	11c8      	l32i.n	a12, a1, 4
4200ad0f:	c0aae0        	sub	a10, a10, a14
4200ad12:	22a9      	s32i.n	a10, a2, 8
4200ad14:	02a8      	l32i.n	a10, a2, 0
4200ad16:	aaca      	add.n	a10, a10, a12
4200ad18:	02a9      	s32i.n	a10, a2, 0
4200ad1a:	0015c6        	j	4200ad75 <__sfvwrite_r+0x1d1>
4200ad1d:	42b800        	xorb	b11, b8, b0
4200ad20:	043ba7        	bltu	a11, a10, 4200ad28 <__sfvwrite_r+0x184>
4200ad23:	52b8      	l32i.n	a11, a2, 20
4200ad25:	2bb3b7        	bgeu	a3, a11, 4200ad54 <__sfvwrite_r+0x1b0>
4200ad28:	636e30        	minu	a6, a14, a3
4200ad2b:	05bd      	mov.n	a11, a5
4200ad2d:	06cd      	mov.n	a12, a6
4200ad2f:	d6ee81        	l32r	a8, 420008e8 <_stext+0x8c8> (40001200 <memmove>)
4200ad32:	0008e0        	callx8	a8
4200ad35:	22a8      	l32i.n	a10, a2, 8
4200ad37:	02b8      	l32i.n	a11, a2, 0
4200ad39:	c0aa60        	sub	a10, a10, a6
4200ad3c:	bb6a      	add.n	a11, a11, a6
4200ad3e:	22a9      	s32i.n	a10, a2, 8
4200ad40:	02b9      	s32i.n	a11, a2, 0
4200ad42:	faec      	bnez.n	a10, 4200ad75 <__sfvwrite_r+0x1d1>
4200ad44:	01a8      	l32i.n	a10, a1, 0
4200ad46:	02bd      	mov.n	a11, a2
4200ad48:	201110        	or	a1, a1, a1
4200ad4b:	ffaa25        	call8	4200a7ec <_fflush_r>
4200ad4e:	3aac      	beqz.n	a10, 4200ad75 <__sfvwrite_r+0x1d1>
4200ad50:	003b06        	j	4200ae40 <__sfvwrite_r+0x29c>
4200ad53:	f87c00        	lsi	f0, a12, 0x3e0
4200ad56:	418180        	srli	a8, a8, 1
4200ad59:	63d380        	minu	a13, a3, a8
4200ad5c:	f2bdb0        	rems	a11, a13, a11
4200ad5f:	c0ddb0        	sub	a13, a13, a11
4200ad62:	a2e8      	l32i.n	a14, a2, 40
4200ad64:	82b8      	l32i.n	a11, a2, 32
4200ad66:	01a8      	l32i.n	a10, a1, 0
4200ad68:	05cd      	mov.n	a12, a5
4200ad6a:	000ee0        	callx8	a14
4200ad6d:	0a6d      	mov.n	a6, a10
4200ad6f:	021ae6        	bgei	a10, 1, 4200ad75 <__sfvwrite_r+0x1d1>
4200ad72:	003286        	j	4200ae40 <__sfvwrite_r+0x29c>
4200ad75:	24a8      	l32i.n	a10, a4, 8
4200ad77:	556a      	add.n	a5, a5, a6
4200ad79:	c0aa60        	sub	a10, a10, a6
4200ad7c:	24a9      	s32i.n	a10, a4, 8
4200ad7e:	c03360        	sub	a3, a3, a6
4200ad81:	eb0a56        	bnez	a10, 4200ac35 <__sfvwrite_r+0x91>
4200ad84:	ff89c6        	j	4200abaf <__sfvwrite_r+0xb>
4200ad87:	076800        	lsi	f0, a8, 28
4200ad8a:	1758      	l32i.n	a5, a7, 4
4200ad8c:	0a0c      	movi.n	a10, 0
4200ad8e:	778b      	addi.n	a7, a7, 8
4200ad90:	ff4516        	beqz	a5, 4200ad88 <__sfvwrite_r+0x1e4>
4200ad93:	3adc      	bnez.n	a10, 4200adaa <__sfvwrite_r+0x206>
4200ad95:	05cd      	mov.n	a12, a5
4200ad97:	ab0c      	movi.n	a11, 10
4200ad99:	06ad      	mov.n	a10, a6
4200ad9b:	d7c181        	l32r	a8, 42000ca0 <_stext+0xc80> (40001344 <memchr>)
4200ad9e:	0008e0        	callx8	a8
4200ada1:	351b      	addi.n	a3, a5, 1
4200ada3:	3a8c      	beqz.n	a10, 4200adaa <__sfvwrite_r+0x206>
4200ada5:	aa1b      	addi.n	a10, a10, 1
4200ada7:	c03a60        	sub	a3, a10, a6
4200adaa:	52d8      	l32i.n	a13, a2, 20
4200adac:	22c8      	l32i.n	a12, a2, 8
4200adae:	02a8      	l32i.n	a10, a2, 0
4200adb0:	42b8      	l32i.n	a11, a2, 16
4200adb2:	639350        	minu	a9, a3, a5
4200adb5:	cdca      	add.n	a12, a13, a12
4200adb7:	26bba7        	bgeu	a11, a10, 4200ade1 <__sfvwrite_r+0x23d>
4200adba:	23ac97        	bge	a12, a9, 4200ade1 <__sfvwrite_r+0x23d>
4200adbd:	20b660        	or	a11, a6, a6
4200adc0:	11c9      	s32i.n	a12, a1, 4
4200adc2:	d6c981        	l32r	a8, 420008e8 <_stext+0x8c8> (40001200 <memmove>)
4200adc5:	0008e0        	callx8	a8
4200adc8:	0298      	l32i.n	a9, a2, 0
4200adca:	11c8      	l32i.n	a12, a1, 4
4200adcc:	01a8      	l32i.n	a10, a1, 0
4200adce:	99ca      	add.n	a9, a9, a12
4200add0:	0299      	s32i.n	a9, a2, 0
4200add2:	02bd      	mov.n	a11, a2
4200add4:	201110        	or	a1, a1, a1
4200add7:	ffa165        	call8	4200a7ec <_fflush_r>
4200adda:	11c8      	l32i.n	a12, a1, 4
4200addc:	5abc      	beqz.n	a10, 4200ae15 <__sfvwrite_r+0x271>
4200adde:	001786        	j	4200ae40 <__sfvwrite_r+0x29c>
4200ade1:	1329d7        	blt	a9, a13, 4200adf8 <__sfvwrite_r+0x254>
4200ade4:	a298      	l32i.n	a9, a2, 40
4200ade6:	82b8      	l32i.n	a11, a2, 32
4200ade8:	01a8      	l32i.n	a10, a1, 0
4200adea:	20c660        	or	a12, a6, a6
4200aded:	0009e0        	callx8	a9
4200adf0:	0acd      	mov.n	a12, a10
4200adf2:	1f1ae6        	bgei	a10, 1, 4200ae15 <__sfvwrite_r+0x271>
4200adf5:	0011c6        	j	4200ae40 <__sfvwrite_r+0x29c>
4200adf8:	09cd      	mov.n	a12, a9
4200adfa:	06bd      	mov.n	a11, a6
4200adfc:	1199      	s32i.n	a9, a1, 4
4200adfe:	d6ba81        	l32r	a8, 420008e8 <_stext+0x8c8> (40001200 <memmove>)
4200ae01:	0008e0        	callx8	a8
4200ae04:	1198      	l32i.n	a9, a1, 4
4200ae06:	22a8      	l32i.n	a10, a2, 8
4200ae08:	09cd      	mov.n	a12, a9
4200ae0a:	c0aa90        	sub	a10, a10, a9
4200ae0d:	22a9      	s32i.n	a10, a2, 8
4200ae0f:	02a8      	l32i.n	a10, a2, 0
4200ae11:	aa9a      	add.n	a10, a10, a9
4200ae13:	02a9      	s32i.n	a10, a2, 0
4200ae15:	c033c0        	sub	a3, a3, a12
4200ae18:	1a0c      	movi.n	a10, 1
4200ae1a:	e3cc      	bnez.n	a3, 4200ae2c <__sfvwrite_r+0x288>
4200ae1c:	01a8      	l32i.n	a10, a1, 0
4200ae1e:	02bd      	mov.n	a11, a2
4200ae20:	11c9      	s32i.n	a12, a1, 4
4200ae22:	201110        	or	a1, a1, a1
4200ae25:	ff9c65        	call8	4200a7ec <_fflush_r>
4200ae28:	11c8      	l32i.n	a12, a1, 4
4200ae2a:	2adc      	bnez.n	a10, 4200ae40 <__sfvwrite_r+0x29c>
4200ae2c:	2498      	l32i.n	a9, a4, 8
4200ae2e:	66ca      	add.n	a6, a6, a12
4200ae30:	c099c0        	sub	a9, a9, a12
4200ae33:	2499      	s32i.n	a9, a4, 8
4200ae35:	c055c0        	sub	a5, a5, a12
4200ae38:	f54956        	bnez	a9, 4200ad90 <__sfvwrite_r+0x1ec>
4200ae3b:	ff5c06        	j	4200abaf <__sfvwrite_r+0xb>
4200ae3e:	920000        	lsi	f0, a0, 0x248
4200ae41:	4c0612        	l8ui	a1, a6, 76
4200ae44:	a00a      	add.n	a10, a0, a0
4200ae46:	2099      	s32i.n	a9, a0, 8
4200ae48:	065292        	s16i	a9, a2, 12
4200ae4b:	f27c      	movi.n	a2, -1
4200ae4d:	f01d      	retw.n
	...

4200ae50 <_printf_r>:
4200ae50:	00a136        	entry	a1, 80
4200ae53:	6149      	s32i.n	a4, a1, 24
4200ae55:	7159      	s32i.n	a5, a1, 28
4200ae57:	8169      	s32i.n	a6, a1, 32
4200ae59:	9179      	s32i.n	a7, a1, 36
4200ae5b:	22b8      	l32i.n	a11, a2, 8
4200ae5d:	10c1e2        	addi	a14, a1, 16
4200ae60:	30c1d2        	addi	a13, a1, 48
4200ae63:	880c      	movi.n	a8, 8
4200ae65:	02ad      	mov.n	a10, a2
4200ae67:	03cd      	mov.n	a12, a3
4200ae69:	8f0c      	movi.n	a15, 8
4200ae6b:	11e9      	s32i.n	a14, a1, 4
4200ae6d:	01d9      	s32i.n	a13, a1, 0
4200ae6f:	026182        	s32i	a8, a1, 8
4200ae72:	201110        	or	a1, a1, a1
4200ae75:	00c6a5        	call8	4200bae0 <_vfprintf_r>
4200ae78:	0a2d      	mov.n	a2, a10
4200ae7a:	f01d      	retw.n

4200ae7c <printf>:
4200ae7c:	00a136        	entry	a1, 80
4200ae7f:	5139      	s32i.n	a3, a1, 20
4200ae81:	6149      	s32i.n	a4, a1, 24
4200ae83:	7159      	s32i.n	a5, a1, 28
4200ae85:	086162        	s32i	a6, a1, 32
4200ae88:	9179      	s32i.n	a7, a1, 36
4200ae8a:	d63181        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200ae8d:	0008e0        	callx8	a8
4200ae90:	2ab8      	l32i.n	a11, a10, 8
4200ae92:	10c1e2        	addi	a14, a1, 16
4200ae95:	30c1d2        	addi	a13, a1, 48
4200ae98:	480c      	movi.n	a8, 4
4200ae9a:	02cd      	mov.n	a12, a2
4200ae9c:	4f0c      	movi.n	a15, 4
4200ae9e:	11e9      	s32i.n	a14, a1, 4
4200aea0:	01d9      	s32i.n	a13, a1, 0
4200aea2:	2189      	s32i.n	a8, a1, 8
4200aea4:	201110        	or	a1, a1, a1
4200aea7:	00c3a5        	call8	4200bae0 <_vfprintf_r>
4200aeaa:	0a2d      	mov.n	a2, a10
4200aeac:	f01d      	retw.n
	...

4200aeb0 <_puts_r>:
4200aeb0:	008136        	entry	a1, 64
4200aeb3:	20a330        	or	a10, a3, a3
4200aeb6:	d4f981        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200aeb9:	0008e0        	callx8	a8
4200aebc:	d77a81        	l32r	a8, 42000ca4 <_stext+0xc84> (3c02914c <Xthal_intlevel+0x20>)
4200aebf:	11a9      	s32i.n	a10, a1, 4
4200aec1:	2189      	s32i.n	a8, a1, 8
4200aec3:	180c      	movi.n	a8, 1
4200aec5:	3189      	s32i.n	a8, a1, 12
4200aec7:	280c      	movi.n	a8, 2
4200aec9:	aa1b      	addi.n	a10, a10, 1
4200aecb:	5189      	s32i.n	a8, a1, 20
4200aecd:	a288      	l32i.n	a8, a2, 40
4200aecf:	0139      	s32i.n	a3, a1, 0
4200aed1:	61a9      	s32i.n	a10, a1, 24
4200aed3:	4119      	s32i.n	a1, a1, 16
4200aed5:	2278      	l32i.n	a7, a2, 8
4200aed7:	68cc      	bnez.n	a8, 4200aee1 <_puts_r+0x31>
4200aed9:	02ad      	mov.n	a10, a2
4200aedb:	201110        	or	a1, a1, a1
4200aede:	ffb765        	call8	4200aa54 <__sinit>
4200aee1:	192782        	l32i	a8, a7, 100
4200aee4:	0ee807        	bbsi	a8, 0, 4200aef6 <_puts_r+0x46>
4200aee7:	061782        	l16ui	a8, a7, 12
4200aeea:	08e897        	bbsi	a8, 9, 4200aef6 <_puts_r+0x46>
4200aeed:	1627a2        	l32i	a10, a7, 88
4200aef0:	d75481        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200aef3:	0008e0        	callx8	a8
4200aef6:	02ad      	mov.n	a10, a2
4200aef8:	10c1c2        	addi	a12, a1, 16
4200aefb:	20b770        	or	a11, a7, a7
4200aefe:	201110        	or	a1, a1, a1
4200af01:	ffca25        	call8	4200aba4 <__sfvwrite_r>
4200af04:	f87c      	movi.n	a8, -1
4200af06:	a20c      	movi.n	a2, 10
4200af08:	9328a0        	movnez	a2, a8, a10
4200af0b:	192782        	l32i	a8, a7, 100
4200af0e:	0ee807        	bbsi	a8, 0, 4200af20 <_puts_r+0x70>
4200af11:	061782        	l16ui	a8, a7, 12
4200af14:	08e897        	bbsi	a8, 9, 4200af20 <_puts_r+0x70>
4200af17:	1627a2        	l32i	a10, a7, 88
4200af1a:	d74a81        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200af1d:	0008e0        	callx8	a8
4200af20:	f01d      	retw.n
	...

4200af24 <puts>:
4200af24:	004136        	entry	a1, 32
4200af27:	d60a81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200af2a:	0008e0        	callx8	a8
4200af2d:	02bd      	mov.n	a11, a2
4200af2f:	fff825        	call8	4200aeb0 <_puts_r>
4200af32:	0a2d      	mov.n	a2, a10
4200af34:	f01d      	retw.n
	...

4200af38 <__sread>:
4200af38:	004136        	entry	a1, 32
4200af3b:	0793b2        	l16si	a11, a3, 14
4200af3e:	02ad      	mov.n	a10, a2
4200af40:	04cd      	mov.n	a12, a4
4200af42:	05dd      	mov.n	a13, a5
4200af44:	201110        	or	a1, a1, a1
4200af47:	fbe7e5        	call8	42006dc4 <_read_r>
4200af4a:	0a2d      	mov.n	a2, a10
4200af4c:	00ca96        	bltz	a10, 4200af5c <__sread+0x24>
4200af4f:	152382        	l32i	a8, a3, 84
4200af52:	88aa      	add.n	a8, a8, a10
4200af54:	156382        	s32i	a8, a3, 84
4200af57:	0003c6        	j	4200af6a <__sread+0x32>
4200af5a:	820000        	mull	a0, a0, a0
4200af5d:	7c0613        	lsi	f1, a6, 0x1f0
4200af60:	92f9      	s32i.n	a15, a2, 36
4200af62:	f0d9      	s32i.n	a13, a0, 60
4200af64:	108890        	and	a8, a8, a9
4200af67:	065382        	s16i	a8, a3, 12
4200af6a:	f01d      	retw.n

4200af6c <__seofread>:
4200af6c:	004136        	entry	a1, 32
4200af6f:	020c      	movi.n	a2, 0
4200af71:	f01d      	retw.n
	...

4200af74 <__swrite>:
4200af74:	004136        	entry	a1, 32
4200af77:	061382        	l16ui	a8, a3, 12
4200af7a:	0e6887        	bbci	a8, 8, 4200af8c <__swrite+0x18>
4200af7d:	0793b2        	l16si	a11, a3, 14
4200af80:	2d0c      	movi.n	a13, 2
4200af82:	0c0c      	movi.n	a12, 0
4200af84:	02ad      	mov.n	a10, a2
4200af86:	201110        	or	a1, a1, a1
4200af89:	fbdca5        	call8	42006d54 <_lseek_r>
4200af8c:	061382        	l16ui	a8, a3, 12
4200af8f:	f97c      	movi.n	a9, -1
4200af91:	f0d992        	addmi	a9, a9, 0xfffff000
4200af94:	108890        	and	a8, a8, a9
4200af97:	0793b2        	l16si	a11, a3, 14
4200af9a:	065382        	s16i	a8, a3, 12
4200af9d:	05dd      	mov.n	a13, a5
4200af9f:	04cd      	mov.n	a12, a4
4200afa1:	02ad      	mov.n	a10, a2
4200afa3:	201110        	or	a1, a1, a1
4200afa6:	fbd3e5        	call8	42006ce4 <_write_r>
4200afa9:	0a2d      	mov.n	a2, a10
4200afab:	f01d      	retw.n
4200afad:	000000        	ill

4200afb0 <__sseek>:
4200afb0:	004136        	entry	a1, 32
4200afb3:	0793b2        	l16si	a11, a3, 14
4200afb6:	02ad      	mov.n	a10, a2
4200afb8:	20c440        	or	a12, a4, a4
4200afbb:	20d550        	or	a13, a5, a5
4200afbe:	201110        	or	a1, a1, a1
4200afc1:	fbd925        	call8	42006d54 <_lseek_r>
4200afc4:	069382        	l16si	a8, a3, 12
4200afc7:	0a2d      	mov.n	a2, a10
4200afc9:	0d0a66        	bnei	a10, -1, 4200afda <__sseek+0x2a>
4200afcc:	f97c      	movi.n	a9, -1
4200afce:	f0d992        	addmi	a9, a9, 0xfffff000
4200afd1:	108890        	and	a8, a8, a9
4200afd4:	065382        	s16i	a8, a3, 12
4200afd7:	000346        	j	4200afe8 <__sseek+0x38>
4200afda:	190c      	movi.n	a9, 1
4200afdc:	119940        	slli	a9, a9, 12
4200afdf:	208890        	or	a8, a8, a9
4200afe2:	065382        	s16i	a8, a3, 12
4200afe5:	1563a2        	s32i	a10, a3, 84
4200afe8:	f01d      	retw.n
	...

4200afec <__sclose>:
4200afec:	004136        	entry	a1, 32
4200afef:	0793b2        	l16si	a11, a3, 14
4200aff2:	02ad      	mov.n	a10, a2
4200aff4:	201110        	or	a1, a1, a1
4200aff7:	fbe3e5        	call8	42006e34 <_close_r>
4200affa:	0a2d      	mov.n	a2, a10
4200affc:	f01d      	retw.n
	...

4200b000 <vprintf>:
4200b000:	006136        	entry	a1, 48
4200b003:	0139      	s32i.n	a3, a1, 0
4200b005:	1149      	s32i.n	a4, a1, 4
4200b007:	026152        	s32i	a5, a1, 8
4200b00a:	d5d181        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b00d:	0008e0        	callx8	a8
4200b010:	01d8      	l32i.n	a13, a1, 0
4200b012:	11e8      	l32i.n	a14, a1, 4
4200b014:	21f8      	l32i.n	a15, a1, 8
4200b016:	2ab8      	l32i.n	a11, a10, 8
4200b018:	02cd      	mov.n	a12, a2
4200b01a:	201110        	or	a1, a1, a1
4200b01d:	00ac25        	call8	4200bae0 <_vfprintf_r>
4200b020:	0a2d      	mov.n	a2, a10
4200b022:	f01d      	retw.n

4200b024 <_vprintf_r>:
4200b024:	006136        	entry	a1, 48
4200b027:	22b8      	l32i.n	a11, a2, 8
4200b029:	02ad      	mov.n	a10, a2
4200b02b:	03cd      	mov.n	a12, a3
4200b02d:	04dd      	mov.n	a13, a4
4200b02f:	05ed      	mov.n	a14, a5
4200b031:	06fd      	mov.n	a15, a6
4200b033:	201110        	or	a1, a1, a1
4200b036:	00aaa5        	call8	4200bae0 <_vfprintf_r>
4200b039:	0a2d      	mov.n	a2, a10
4200b03b:	f01d      	retw.n
4200b03d:	000000        	ill

4200b040 <__swsetup_r>:
4200b040:	004136        	entry	a1, 32
4200b043:	d5c381        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b046:	0008e0        	callx8	a8
4200b049:	8a8c      	beqz.n	a10, 4200b055 <__swsetup_r+0x15>
4200b04b:	aa88      	l32i.n	a8, a10, 40
4200b04d:	48cc      	bnez.n	a8, 4200b055 <__swsetup_r+0x15>
4200b04f:	201110        	or	a1, a1, a1
4200b052:	ffa025        	call8	4200aa54 <__sinit>
4200b055:	069382        	l16si	a8, a3, 12
4200b058:	3ee837        	bbsi	a8, 3, 4200b09a <__swsetup_r+0x5a>
4200b05b:	06e847        	bbsi	a8, 4, 4200b065 <__swsetup_r+0x25>
4200b05e:	990c      	movi.n	a9, 9
4200b060:	0299      	s32i.n	a9, a2, 0
4200b062:	001c86        	j	4200b0d8 <__swsetup_r+0x98>
4200b065:	296827        	bbci	a8, 2, 4200b092 <__swsetup_r+0x52>
4200b068:	d3b8      	l32i.n	a11, a3, 52
4200b06a:	0b9c      	beqz.n	a11, 4200b07e <__swsetup_r+0x3e>
4200b06c:	44c382        	addi	a8, a3, 68
4200b06f:	071b87        	beq	a11, a8, 4200b07a <__swsetup_r+0x3a>
4200b072:	02ad      	mov.n	a10, a2
4200b074:	d6f581        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b077:	0008e0        	callx8	a8
4200b07a:	080c      	movi.n	a8, 0
4200b07c:	d389      	s32i.n	a8, a3, 52
4200b07e:	061382        	l16ui	a8, a3, 12
4200b081:	dbaf92        	movi	a9, -37
4200b084:	108890        	and	a8, a8, a9
4200b087:	090c      	movi.n	a9, 0
4200b089:	1399      	s32i.n	a9, a3, 4
4200b08b:	4398      	l32i.n	a9, a3, 16
4200b08d:	238880        	sext	a8, a8, 15
4200b090:	0399      	s32i.n	a9, a3, 0
4200b092:	890c      	movi.n	a9, 8
4200b094:	208890        	or	a8, a8, a9
4200b097:	065382        	s16i	a8, a3, 12
4200b09a:	4398      	l32i.n	a9, a3, 16
4200b09c:	49dc      	bnez.n	a9, 4200b0b4 <__swsetup_r+0x74>
4200b09e:	80a292        	movi	a9, 0x280
4200b0a1:	108890        	and	a8, a8, a9
4200b0a4:	00a292        	movi	a9, 0x200
4200b0a7:	091897        	beq	a8, a9, 4200b0b4 <__swsetup_r+0x74>
4200b0aa:	03bd      	mov.n	a11, a3
4200b0ac:	02ad      	mov.n	a10, a2
4200b0ae:	201110        	or	a1, a1, a1
4200b0b1:	059925        	call8	42010a44 <__smakebuf_r>
4200b0b4:	069382        	l16si	a8, a3, 12
4200b0b7:	090c      	movi.n	a9, 0
4200b0b9:	0b6807        	bbci	a8, 0, 4200b0c8 <__swsetup_r+0x88>
4200b0bc:	2399      	s32i.n	a9, a3, 8
4200b0be:	5398      	l32i.n	a9, a3, 20
4200b0c0:	609090        	neg	a9, a9
4200b0c3:	6399      	s32i.n	a9, a3, 24
4200b0c5:	000186        	j	4200b0cf <__swsetup_r+0x8f>
4200b0c8:	01e817        	bbsi	a8, 1, 4200b0cd <__swsetup_r+0x8d>
4200b0cb:	5398      	l32i.n	a9, a3, 20
4200b0cd:	2399      	s32i.n	a9, a3, 8
4200b0cf:	4398      	l32i.n	a9, a3, 16
4200b0d1:	020c      	movi.n	a2, 0
4200b0d3:	b9cc      	bnez.n	a9, 4200b0e2 <__swsetup_r+0xa2>
4200b0d5:	096877        	bbci	a8, 7, 4200b0e2 <__swsetup_r+0xa2>
4200b0d8:	094c      	movi.n	a9, 64
4200b0da:	208890        	or	a8, a8, a9
4200b0dd:	065382        	s16i	a8, a3, 12
4200b0e0:	f27c      	movi.n	a2, -1
4200b0e2:	f01d      	retw.n

4200b0e4 <_fseeko_r>:
4200b0e4:	012136        	entry	a1, 144
4200b0e7:	a28c      	beqz.n	a2, 4200b0f5 <_fseeko_r+0x11>
4200b0e9:	a288      	l32i.n	a8, a2, 40
4200b0eb:	68cc      	bnez.n	a8, 4200b0f5 <_fseeko_r+0x11>
4200b0ed:	02ad      	mov.n	a10, a2
4200b0ef:	201110        	or	a1, a1, a1
4200b0f2:	ff9625        	call8	4200aa54 <__sinit>
4200b0f5:	192382        	l32i	a8, a3, 100
4200b0f8:	0ee807        	bbsi	a8, 0, 4200b10a <_fseeko_r+0x26>
4200b0fb:	061382        	l16ui	a8, a3, 12
4200b0fe:	08e897        	bbsi	a8, 9, 4200b10a <_fseeko_r+0x26>
4200b101:	1623a2        	l32i	a10, a3, 88
4200b104:	d6cf81        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200b107:	0008e0        	callx8	a8
4200b10a:	061392        	l16ui	a9, a3, 12
4200b10d:	08a182        	movi	a8, 0x108
4200b110:	09c987        	bnall	a9, a8, 4200b11d <_fseeko_r+0x39>
4200b113:	03bd      	mov.n	a11, a3
4200b115:	02ad      	mov.n	a10, a2
4200b117:	201110        	or	a1, a1, a1
4200b11a:	ff6d25        	call8	4200a7ec <_fflush_r>
4200b11d:	b378      	l32i.n	a7, a3, 44
4200b11f:	d81c      	movi.n	a8, 29
4200b121:	085716        	beqz	a7, 4200b1aa <_fseeko_r+0xc6>
4200b124:	0e1526        	beqi	a5, 1, 4200b136 <_fseeko_r+0x52>
4200b127:	d87c      	movi.n	a8, -3
4200b129:	106580        	and	a6, a5, a8
4200b12c:	681c      	movi.n	a8, 22
4200b12e:	078656        	bnez	a6, 4200b1aa <_fseeko_r+0xc6>
4200b131:	001e86        	j	4200b1af <_fseeko_r+0xcb>
4200b134:	bd0000        	lsi	f0, a0, 0x2f4
4200b137:	02ad03        	lsi	f0, a13, 8
4200b13a:	201110        	or	a1, a1, a1
4200b13d:	ff6ae5        	call8	4200a7ec <_fflush_r>
4200b140:	061382        	l16ui	a8, a3, 12
4200b143:	0668c7        	bbci	a8, 12, 4200b14d <_fseeko_r+0x69>
4200b146:	152362        	l32i	a6, a3, 84
4200b149:	000ac6        	j	4200b178 <_fseeko_r+0x94>
4200b14c:	83b800        	moveqz	a11, a8, a0
4200b14f:	1d0c      	movi.n	a13, 1
4200b151:	0c0c      	movi.n	a12, 0
4200b153:	02ad      	mov.n	a10, a2
4200b155:	0007e0        	callx8	a7
4200b158:	0a6d      	mov.n	a6, a10
4200b15a:	1a0a66        	bnei	a10, -1, 4200b178 <_fseeko_r+0x94>
4200b15d:	192382        	l32i	a8, a3, 100
4200b160:	0ee807        	bbsi	a8, 0, 4200b172 <_fseeko_r+0x8e>
4200b163:	061382        	l16ui	a8, a3, 12
4200b166:	08e897        	bbsi	a8, 9, 4200b172 <_fseeko_r+0x8e>
4200b169:	1623a2        	l32i	a10, a3, 88
4200b16c:	d6b681        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200b16f:	0008e0        	callx8	a8
4200b172:	f27c      	movi.n	a2, -1
4200b174:	008d06        	j	4200b3ac <_fseeko_r+0x2c8>
4200b177:	939200        	movnez	a9, a2, a0
4200b17a:	692706        	j	4202561a <_etext+0xf3c4>
4200b17d:	139811        	l32r	a1, 41fcffe0 <_coredump_iram_end+0x1c4e0e0>
4200b180:	c06690        	sub	a6, a6, a9
4200b183:	d398      	l32i.n	a9, a3, 52
4200b185:	599c      	beqz.n	a9, 4200b19e <_fseeko_r+0xba>
4200b187:	102392        	l32i	a9, a3, 64
4200b18a:	c06690        	sub	a6, a6, a9
4200b18d:	000346        	j	4200b19e <_fseeko_r+0xba>
4200b190:	0a6937        	bbci	a9, 3, 4200b19e <_fseeko_r+0xba>
4200b193:	0398      	l32i.n	a9, a3, 0
4200b195:	598c      	beqz.n	a9, 4200b19e <_fseeko_r+0xba>
4200b197:	43a8      	l32i.n	a10, a3, 16
4200b199:	c099a0        	sub	a9, a9, a10
4200b19c:	669a      	add.n	a6, a6, a9
4200b19e:	180c      	movi.n	a8, 1
4200b1a0:	446a      	add.n	a4, a4, a6
4200b1a2:	186182        	s32i	a8, a1, 96
4200b1a5:	050c      	movi.n	a5, 0
4200b1a7:	000246        	j	4200b1b4 <_fseeko_r+0xd0>
4200b1aa:	0289      	s32i.n	a8, a2, 0
4200b1ac:	ffeb46        	j	4200b15d <_fseeko_r+0x79>
4200b1af:	080c      	movi.n	a8, 0
4200b1b1:	186182        	s32i	a8, a1, 96
4200b1b4:	4398      	l32i.n	a9, a3, 16
4200b1b6:	89cc      	bnez.n	a9, 4200b1c2 <_fseeko_r+0xde>
4200b1b8:	03bd      	mov.n	a11, a3
4200b1ba:	02ad      	mov.n	a10, a2
4200b1bc:	201110        	or	a1, a1, a1
4200b1bf:	058865        	call8	42010a44 <__smakebuf_r>
4200b1c2:	aa1c      	movi.n	a10, 26
4200b1c4:	069392        	l16si	a9, a3, 12
4200b1c7:	08daa2        	addmi	a10, a10, 0x800
4200b1ca:	0209a7        	bnone	a9, a10, 4200b1d0 <_fseeko_r+0xec>
4200b1cd:	005a06        	j	4200b339 <_fseeko_r+0x255>
4200b1d0:	4de9a7        	bbsi	a9, 10, 4200b221 <_fseeko_r+0x13d>
4200b1d3:	d6a391        	l32r	a9, 42000c60 <_stext+0xc40> (4200afb0 <__sseek>)
4200b1d6:	121797        	beq	a7, a9, 4200b1ec <_fseeko_r+0x108>
4200b1d9:	061382        	l16ui	a8, a3, 12
4200b1dc:	190c      	movi.n	a9, 1
4200b1de:	119950        	slli	a9, a9, 11
4200b1e1:	208890        	or	a8, a8, a9
4200b1e4:	065382        	s16i	a8, a3, 12
4200b1e7:	005386        	j	4200b339 <_fseeko_r+0x255>
4200b1ea:	b20000        	mulsh	a0, a0, a0
4200b1ed:	960793        	lsi	f9, a7, 0x258
4200b1f0:	fe6b      	addi.n	a15, a14, 6
4200b1f2:	01cd      	mov.n	a12, a1
4200b1f4:	02ad      	mov.n	a10, a2
4200b1f6:	201110        	or	a1, a1, a1
4200b1f9:	fbcfe5        	call8	42006ef8 <_fstat_r>
4200b1fc:	fd9a56        	bnez	a10, 4200b1d9 <_fseeko_r+0xf5>
4200b1ff:	1198      	l32i.n	a9, a1, 4
4200b201:	1a0c      	movi.n	a10, 1
4200b203:	349c90        	extui	a9, a9, 12, 4
4200b206:	119940        	slli	a9, a9, 12
4200b209:	11aa10        	slli	a10, a10, 15
4200b20c:	c999a7        	bne	a9, a10, 4200b1d9 <_fseeko_r+0xf5>
4200b20f:	1221a2        	l32i	a10, a1, 72
4200b212:	069392        	l16si	a9, a3, 12
4200b215:	1463a2        	s32i	a10, a3, 80
4200b218:	00a4a2        	movi	a10, 0x400
4200b21b:	2099a0        	or	a9, a9, a10
4200b21e:	065392        	s16i	a9, a3, 12
4200b221:	049d      	mov.n	a9, a4
4200b223:	015516        	beqz	a5, 4200b23c <_fseeko_r+0x158>
4200b226:	0793b2        	l16si	a11, a3, 14
4200b229:	20c110        	or	a12, a1, a1
4200b22c:	20a220        	or	a10, a2, a2
4200b22f:	201110        	or	a1, a1, a1
4200b232:	fbcc65        	call8	42006ef8 <_fstat_r>
4200b235:	100a56        	bnez	a10, 4200b339 <_fseeko_r+0x255>
4200b238:	4198      	l32i.n	a9, a1, 16
4200b23a:	949a      	add.n	a9, a4, a9
4200b23c:	182182        	l32i	a8, a1, 96
4200b23f:	18fc      	bnez.n	a8, 4200b274 <_fseeko_r+0x190>
4200b241:	061382        	l16ui	a8, a3, 12
4200b244:	0668c7        	bbci	a8, 12, 4200b24e <_fseeko_r+0x16a>
4200b247:	1523a2        	l32i	a10, a3, 84
4200b24a:	0005c6        	j	4200b265 <_fseeko_r+0x181>
4200b24d:	83b800        	moveqz	a11, a8, a0
4200b250:	1d0c      	movi.n	a13, 1
4200b252:	0c0c      	movi.n	a12, 0
4200b254:	02ad      	mov.n	a10, a2
4200b256:	186192        	s32i	a9, a1, 96
4200b259:	0007e0        	callx8	a7
4200b25c:	182192        	l32i	a9, a1, 96
4200b25f:	020a66        	bnei	a10, -1, 4200b265 <_fseeko_r+0x181>
4200b262:	0034c6        	j	4200b339 <_fseeko_r+0x255>
4200b265:	1388      	l32i.n	a8, a3, 4
4200b267:	c06a80        	sub	a6, a10, a8
4200b26a:	d3a8      	l32i.n	a10, a3, 52
4200b26c:	4a8c      	beqz.n	a10, 4200b274 <_fseeko_r+0x190>
4200b26e:	1023a2        	l32i	a10, a3, 64
4200b271:	c066a0        	sub	a6, a6, a10
4200b274:	d3b8      	l32i.n	a11, a3, 52
4200b276:	43c8      	l32i.n	a12, a3, 16
4200b278:	13a8      	l32i.n	a10, a3, 4
4200b27a:	eb8c      	beqz.n	a11, 4200b28c <_fseeko_r+0x1a8>
4200b27c:	f3d8      	l32i.n	a13, a3, 60
4200b27e:	86aa      	add.n	a8, a6, a10
4200b280:	c0ddc0        	sub	a13, a13, a12
4200b283:	1023a2        	l32i	a10, a3, 64
4200b286:	c088d0        	sub	a8, a8, a13
4200b289:	0001c6        	j	4200b294 <_fseeko_r+0x1b0>
4200b28c:	03d8      	l32i.n	a13, a3, 0
4200b28e:	c0ddc0        	sub	a13, a13, a12
4200b291:	c086d0        	sub	a8, a6, a13
4200b294:	aada      	add.n	a10, a10, a13
4200b296:	2f2987        	blt	a9, a8, 4200b2c9 <_fseeko_r+0x1e5>
4200b299:	d8aa      	add.n	a13, a8, a10
4200b29b:	2ab9d7        	bgeu	a9, a13, 4200b2c9 <_fseeko_r+0x1e5>
4200b29e:	c08980        	sub	a8, a9, a8
4200b2a1:	cc8a      	add.n	a12, a12, a8
4200b2a3:	c0aa80        	sub	a10, a10, a8
4200b2a6:	03c9      	s32i.n	a12, a3, 0
4200b2a8:	13a9      	s32i.n	a10, a3, 4
4200b2aa:	0b9c      	beqz.n	a11, 4200b2be <_fseeko_r+0x1da>
4200b2ac:	44c382        	addi	a8, a3, 68
4200b2af:	071b87        	beq	a11, a8, 4200b2ba <_fseeko_r+0x1d6>
4200b2b2:	02ad      	mov.n	a10, a2
4200b2b4:	d66581        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b2b7:	0008e0        	callx8	a8
4200b2ba:	080c      	movi.n	a8, 0
4200b2bc:	d389      	s32i.n	a8, a3, 52
4200b2be:	061382        	l16ui	a8, a3, 12
4200b2c1:	dfaf92        	movi	a9, -33
4200b2c4:	002e86        	j	4200b382 <_fseeko_r+0x29e>
4200b2c7:	620000        	lsi	f0, a0, 0x188
4200b2ca:	b81423        	lsi	f2, a4, 0x2e0
4200b2cd:	606083        	lsi	f8, a0, 0x180
4200b2d0:	669060        	lsi	f6, a0, 0x198
4200b2d3:	0d0c10        	lsi	f1, a12, 52
4200b2d6:	06cd      	mov.n	a12, a6
4200b2d8:	02ad      	mov.n	a10, a2
4200b2da:	186192        	s32i	a9, a1, 96
4200b2dd:	0007e0        	callx8	a7
4200b2e0:	550a26        	beqi	a10, -1, 4200b339 <_fseeko_r+0x255>
4200b2e3:	080c      	movi.n	a8, 0
4200b2e5:	1389      	s32i.n	a8, a3, 4
4200b2e7:	4388      	l32i.n	a8, a3, 16
4200b2e9:	d3b8      	l32i.n	a11, a3, 52
4200b2eb:	0389      	s32i.n	a8, a3, 0
4200b2ed:	182192        	l32i	a9, a1, 96
4200b2f0:	4b9c      	beqz.n	a11, 4200b308 <_fseeko_r+0x224>
4200b2f2:	44c382        	addi	a8, a3, 68
4200b2f5:	0b1b87        	beq	a11, a8, 4200b304 <_fseeko_r+0x220>
4200b2f8:	20a220        	or	a10, a2, a2
4200b2fb:	d65381        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b2fe:	0008e0        	callx8	a8
4200b301:	182192        	l32i	a9, a1, 96
4200b304:	080c      	movi.n	a8, 0
4200b306:	d389      	s32i.n	a8, a3, 52
4200b308:	061382        	l16ui	a8, a3, 12
4200b30b:	dfafa2        	movi	a10, -33
4200b30e:	1088a0        	and	a8, a8, a10
4200b311:	065382        	s16i	a8, a3, 12
4200b314:	c06960        	sub	a6, a9, a6
4200b317:	06d616        	beqz	a6, 4200b388 <_fseeko_r+0x2a4>
4200b31a:	03bd      	mov.n	a11, a3
4200b31c:	02ad      	mov.n	a10, a2
4200b31e:	201110        	or	a1, a1, a1
4200b321:	057ca5        	call8	42010aec <__srefill_r>
4200b324:	1adc      	bnez.n	a10, 4200b339 <_fseeko_r+0x255>
4200b326:	1388      	l32i.n	a8, a3, 4
4200b328:	0d3867        	bltu	a8, a6, 4200b339 <_fseeko_r+0x255>
4200b32b:	0398      	l32i.n	a9, a3, 0
4200b32d:	c08860        	sub	a8, a8, a6
4200b330:	996a      	add.n	a9, a9, a6
4200b332:	0399      	s32i.n	a9, a3, 0
4200b334:	1389      	s32i.n	a8, a3, 4
4200b336:	001386        	j	4200b388 <_fseeko_r+0x2a4>
4200b339:	03bd      	mov.n	a11, a3
4200b33b:	20a220        	or	a10, a2, a2
4200b33e:	201110        	or	a1, a1, a1
4200b341:	ff4aa5        	call8	4200a7ec <_fflush_r>
4200b344:	1a8c      	beqz.n	a10, 4200b349 <_fseeko_r+0x265>
4200b346:	ff84c6        	j	4200b15d <_fseeko_r+0x79>
4200b349:	83b8      	l32i.n	a11, a3, 32
4200b34b:	05dd      	mov.n	a13, a5
4200b34d:	04cd      	mov.n	a12, a4
4200b34f:	02ad      	mov.n	a10, a2
4200b351:	0007e0        	callx8	a7
4200b354:	020a66        	bnei	a10, -1, 4200b35a <_fseeko_r+0x276>
4200b357:	ff8086        	j	4200b15d <_fseeko_r+0x79>
4200b35a:	d3b8      	l32i.n	a11, a3, 52
4200b35c:	1b9c      	beqz.n	a11, 4200b371 <_fseeko_r+0x28d>
4200b35e:	44c382        	addi	a8, a3, 68
4200b361:	081b87        	beq	a11, a8, 4200b36d <_fseeko_r+0x289>
4200b364:	20a220        	or	a10, a2, a2
4200b367:	d63881        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b36a:	0008e0        	callx8	a8
4200b36d:	080c      	movi.n	a8, 0
4200b36f:	d389      	s32i.n	a8, a3, 52
4200b371:	4388      	l32i.n	a8, a3, 16
4200b373:	dfa092        	movi	a9, 223
4200b376:	0389      	s32i.n	a8, a3, 0
4200b378:	080c      	movi.n	a8, 0
4200b37a:	1389      	s32i.n	a8, a3, 4
4200b37c:	061382        	l16ui	a8, a3, 12
4200b37f:	f7d992        	addmi	a9, a9, 0xfffff700
4200b382:	108890        	and	a8, a8, a9
4200b385:	065382        	s16i	a8, a3, 12
4200b388:	8c0c      	movi.n	a12, 8
4200b38a:	0b0c      	movi.n	a11, 0
4200b38c:	5cc3a2        	addi	a10, a3, 92
4200b38f:	d3dc81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200b392:	0008e0        	callx8	a8
4200b395:	192382        	l32i	a8, a3, 100
4200b398:	0ee807        	bbsi	a8, 0, 4200b3aa <_fseeko_r+0x2c6>
4200b39b:	061382        	l16ui	a8, a3, 12
4200b39e:	08e897        	bbsi	a8, 9, 4200b3aa <_fseeko_r+0x2c6>
4200b3a1:	1623a2        	l32i	a10, a3, 88
4200b3a4:	d62881        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200b3a7:	0008e0        	callx8	a8
4200b3aa:	020c      	movi.n	a2, 0
4200b3ac:	f01d      	retw.n
	...

4200b3b0 <fseeko>:
4200b3b0:	004136        	entry	a1, 32
4200b3b3:	d4e781        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b3b6:	0008e0        	callx8	a8
4200b3b9:	02bd      	mov.n	a11, a2
4200b3bb:	04dd      	mov.n	a13, a4
4200b3bd:	03cd      	mov.n	a12, a3
4200b3bf:	ffd265        	call8	4200b0e4 <_fseeko_r>
4200b3c2:	0a2d      	mov.n	a2, a10
4200b3c4:	f01d      	retw.n
	...

4200b3c8 <_reclaim_reent>:
4200b3c8:	004136        	entry	a1, 32
4200b3cb:	d63781        	l32r	a8, 42000ca8 <_stext+0xc88> (3fc926a0 <_impure_ptr>)
4200b3ce:	0888      	l32i.n	a8, a8, 0
4200b3d0:	029827        	bne	a8, a2, 4200b3d6 <_reclaim_reent+0xe>
4200b3d3:	002cc6        	j	4200b48a <_reclaim_reent+0xc2>
4200b3d6:	9288      	l32i.n	a8, a2, 36
4200b3d8:	e8bc      	beqz.n	a8, 4200b41a <_reclaim_reent+0x52>
4200b3da:	3888      	l32i.n	a8, a8, 12
4200b3dc:	c8ac      	beqz.n	a8, 4200b40c <_reclaim_reent+0x44>
4200b3de:	070c      	movi.n	a7, 0
4200b3e0:	9288      	l32i.n	a8, a2, 36
4200b3e2:	3888      	l32i.n	a8, a8, 12
4200b3e4:	887a      	add.n	a8, a8, a7
4200b3e6:	08b8      	l32i.n	a11, a8, 0
4200b3e8:	000306        	j	4200b3f8 <_reclaim_reent+0x30>
4200b3eb:	0b6800        	lsi	f0, a8, 44
4200b3ee:	02ad      	mov.n	a10, a2
4200b3f0:	d61681        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b3f3:	0008e0        	callx8	a8
4200b3f6:	06bd      	mov.n	a11, a6
4200b3f8:	ff0b56        	bnez	a11, 4200b3ec <_reclaim_reent+0x24>
4200b3fb:	774b      	addi.n	a7, a7, 4
4200b3fd:	dfe766        	bnei	a7, 128, 4200b3e0 <_reclaim_reent+0x18>
4200b400:	9288      	l32i.n	a8, a2, 36
4200b402:	02ad      	mov.n	a10, a2
4200b404:	38b8      	l32i.n	a11, a8, 12
4200b406:	d61081        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b409:	0008e0        	callx8	a8
4200b40c:	9288      	l32i.n	a8, a2, 36
4200b40e:	08b8      	l32i.n	a11, a8, 0
4200b410:	6b8c      	beqz.n	a11, 4200b41a <_reclaim_reent+0x52>
4200b412:	02ad      	mov.n	a10, a2
4200b414:	d60d81        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b417:	0008e0        	callx8	a8
4200b41a:	52b8      	l32i.n	a11, a2, 20
4200b41c:	6b8c      	beqz.n	a11, 4200b426 <_reclaim_reent+0x5e>
4200b41e:	02ad      	mov.n	a10, a2
4200b420:	d60a81        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b423:	0008e0        	callx8	a8
4200b426:	92b8      	l32i.n	a11, a2, 36
4200b428:	6b8c      	beqz.n	a11, 4200b432 <_reclaim_reent+0x6a>
4200b42a:	02ad      	mov.n	a10, a2
4200b42c:	d60781        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b42f:	0008e0        	callx8	a8
4200b432:	e2b8      	l32i.n	a11, a2, 56
4200b434:	6b8c      	beqz.n	a11, 4200b43e <_reclaim_reent+0x76>
4200b436:	02ad      	mov.n	a10, a2
4200b438:	d60481        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b43b:	0008e0        	callx8	a8
4200b43e:	f2b8      	l32i.n	a11, a2, 60
4200b440:	008b16        	beqz	a11, 4200b44c <_reclaim_reent+0x84>
4200b443:	20a220        	or	a10, a2, a2
4200b446:	d60081        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b449:	0008e0        	callx8	a8
4200b44c:	1022b2        	l32i	a11, a2, 64
4200b44f:	6b8c      	beqz.n	a11, 4200b459 <_reclaim_reent+0x91>
4200b451:	02ad      	mov.n	a10, a2
4200b453:	d5fd81        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b456:	0008e0        	callx8	a8
4200b459:	3b22b2        	l32i	a11, a2, 236
4200b45c:	008b16        	beqz	a11, 4200b468 <_reclaim_reent+0xa0>
4200b45f:	20a220        	or	a10, a2, a2
4200b462:	d5f981        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b465:	0008e0        	callx8	a8
4200b468:	3a22b2        	l32i	a11, a2, 232
4200b46b:	6b8c      	beqz.n	a11, 4200b475 <_reclaim_reent+0xad>
4200b46d:	02ad      	mov.n	a10, a2
4200b46f:	d5f681        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b472:	0008e0        	callx8	a8
4200b475:	d2b8      	l32i.n	a11, a2, 52
4200b477:	6b8c      	beqz.n	a11, 4200b481 <_reclaim_reent+0xb9>
4200b479:	02ad      	mov.n	a10, a2
4200b47b:	d5f381        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
4200b47e:	0008e0        	callx8	a8
4200b481:	a288      	l32i.n	a8, a2, 40
4200b483:	388c      	beqz.n	a8, 4200b48a <_reclaim_reent+0xc2>
4200b485:	02ad      	mov.n	a10, a2
4200b487:	0008e0        	callx8	a8
4200b48a:	f01d      	retw.n

4200b48c <__errno>:
4200b48c:	004136        	entry	a1, 32
4200b48f:	d4b081        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b492:	0008e0        	callx8	a8
4200b495:	0a2d      	mov.n	a2, a10
4200b497:	f01d      	retw.n
4200b499:	000000        	ill

4200b49c <close>:
4200b49c:	004136        	entry	a1, 32
4200b49f:	d4ac81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b4a2:	0008e0        	callx8	a8
4200b4a5:	02bd      	mov.n	a11, a2
4200b4a7:	201110        	or	a1, a1, a1
4200b4aa:	fb98a5        	call8	42006e34 <_close_r>
4200b4ad:	0a2d      	mov.n	a2, a10
4200b4af:	f01d      	retw.n
4200b4b1:	000000        	ill

4200b4b4 <fcntl>:
4200b4b4:	004136        	entry	a1, 32
4200b4b7:	d4a681        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b4ba:	0008e0        	callx8	a8
4200b4bd:	02bd      	mov.n	a11, a2
4200b4bf:	04dd      	mov.n	a13, a4
4200b4c1:	03cd      	mov.n	a12, a3
4200b4c3:	201110        	or	a1, a1, a1
4200b4c6:	fba9e5        	call8	42006f64 <_fcntl_r>
4200b4c9:	0a2d      	mov.n	a2, a10
4200b4cb:	f01d      	retw.n
4200b4cd:	000000        	ill

4200b4d0 <gettimeofday>:
4200b4d0:	004136        	entry	a1, 32
4200b4d3:	d49f81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b4d6:	0008e0        	callx8	a8
4200b4d9:	02bd      	mov.n	a11, a2
4200b4db:	20c330        	or	a12, a3, a3
4200b4de:	d5f381        	l32r	a8, 42000cac <_stext+0xc8c> (40376b7c <_gettimeofday_r>)
4200b4e1:	0008e0        	callx8	a8
4200b4e4:	0a2d      	mov.n	a2, a10
4200b4e6:	f01d      	retw.n

4200b4e8 <open>:
4200b4e8:	00a136        	entry	a1, 80
4200b4eb:	10c182        	addi	a8, a1, 16
4200b4ee:	1189      	s32i.n	a8, a1, 4
4200b4f0:	30c182        	addi	a8, a1, 48
4200b4f3:	0189      	s32i.n	a8, a1, 0
4200b4f5:	6149      	s32i.n	a4, a1, 24
4200b4f7:	880c      	movi.n	a8, 8
4200b4f9:	7159      	s32i.n	a5, a1, 28
4200b4fb:	8169      	s32i.n	a6, a1, 32
4200b4fd:	9179      	s32i.n	a7, a1, 36
4200b4ff:	026182        	s32i	a8, a1, 8
4200b502:	d49381        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b505:	0008e0        	callx8	a8
4200b508:	2188      	l32i.n	a8, a1, 8
4200b50a:	8b1c      	movi.n	a11, 24
4200b50c:	984b      	addi.n	a9, a8, 4
4200b50e:	062b97        	blt	a11, a9, 4200b518 <open+0x30>
4200b511:	1188      	l32i.n	a8, a1, 4
4200b513:	000206        	j	4200b51f <open+0x37>
4200b516:	870000        	lsi	f0, a0, 0x21c
4200b519:	012b      	addi.n	a0, a1, 2
4200b51b:	492c      	movi.n	a9, 36
4200b51d:	0188      	l32i.n	a8, a1, 0
4200b51f:	889a      	add.n	a8, a8, a9
4200b521:	fcc882        	addi	a8, a8, -4
4200b524:	08d8      	l32i.n	a13, a8, 0
4200b526:	02bd      	mov.n	a11, a2
4200b528:	03cd      	mov.n	a12, a3
4200b52a:	201110        	or	a1, a1, a1
4200b52d:	fb6b25        	call8	42006be0 <_open_r>
4200b530:	0a2d      	mov.n	a2, a10
4200b532:	f01d      	retw.n

4200b534 <read>:
4200b534:	004136        	entry	a1, 32
4200b537:	d48681        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b53a:	0008e0        	callx8	a8
4200b53d:	02bd      	mov.n	a11, a2
4200b53f:	04dd      	mov.n	a13, a4
4200b541:	03cd      	mov.n	a12, a3
4200b543:	201110        	or	a1, a1, a1
4200b546:	fb87e5        	call8	42006dc4 <_read_r>
4200b549:	0a2d      	mov.n	a2, a10
4200b54b:	f01d      	retw.n
4200b54d:	000000        	ill

4200b550 <write>:
4200b550:	004136        	entry	a1, 32
4200b553:	d47f81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200b556:	0008e0        	callx8	a8
4200b559:	02bd      	mov.n	a11, a2
4200b55b:	04dd      	mov.n	a13, a4
4200b55d:	03cd      	mov.n	a12, a3
4200b55f:	201110        	or	a1, a1, a1
4200b562:	fb7825        	call8	42006ce4 <_write_r>
4200b565:	0a2d      	mov.n	a2, a10
4200b567:	f01d      	retw.n
4200b569:	000000        	ill

4200b56c <__register_exitproc>:
4200b56c:	004136        	entry	a1, 32
4200b56f:	d5d171        	l32r	a7, 42000cb4 <_stext+0xc94> (3fc92794 <__atexit_recursive_mutex>)
4200b572:	07a8      	l32i.n	a10, a7, 0
4200b574:	d5b381        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200b577:	0008e0        	callx8	a8
4200b57a:	d5cf81        	l32r	a8, 42000cb8 <_stext+0xc98> (3fc960e4 <__atexit>)
4200b57d:	0868      	l32i.n	a6, a8, 0
4200b57f:	d6cc      	bnez.n	a6, 4200b590 <__register_exitproc+0x24>
4200b581:	d5cb61        	l32r	a6, 42000cb0 <_stext+0xc90> (3fc96058 <__atexit0>)
4200b584:	0869      	s32i.n	a6, a8, 0
4200b586:	d5cd81        	l32r	a8, 42000cbc <_stext+0xc9c> (3c02926c <__on_exit_args>)
4200b589:	388c      	beqz.n	a8, 4200b590 <__register_exitproc+0x24>
4200b58b:	0888      	l32i.n	a8, a8, 0
4200b58d:	226682        	s32i	a8, a6, 136
4200b590:	1688      	l32i.n	a8, a6, 4
4200b592:	f91c      	movi.n	a9, 31
4200b594:	05a987        	bge	a9, a8, 4200b59d <__register_exitproc+0x31>
4200b597:	0003c6        	j	4200b5aa <__register_exitproc+0x3e>
4200b59a:	000000        	ill
4200b59d:	057216        	beqz	a2, 4200b5f8 <__register_exitproc+0x8c>
4200b5a0:	2226a2        	l32i	a10, a6, 136
4200b5a3:	9aec      	bnez.n	a10, 4200b5d0 <__register_exitproc+0x64>
4200b5a5:	d47781        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
4200b5a8:	c8cc      	bnez.n	a8, 4200b5b8 <__register_exitproc+0x4c>
4200b5aa:	07a8      	l32i.n	a10, a7, 0
4200b5ac:	f27c      	movi.n	a2, -1
4200b5ae:	d5a581        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200b5b1:	0008e0        	callx8	a8
4200b5b4:	0014c6        	j	4200b60b <__register_exitproc+0x9f>
4200b5b7:	a1a200        	sll	a10, a2
4200b5ba:	8108      	l32i.n	a0, a1, 32
4200b5bc:	e0d472        	addmi	a7, a4, 0xffffe000
4200b5bf:	0008      	l32i.n	a0, a0, 0
4200b5c1:	fe5a16        	beqz	a10, 4200b5aa <__register_exitproc+0x3e>
4200b5c4:	00a082        	movi	a8, 0
4200b5c7:	406a82        	s32i	a8, a10, 0x100
4200b5ca:	416a82        	s32i	a8, a10, 0x104
4200b5cd:	2266a2        	s32i	a10, a6, 136
4200b5d0:	1688      	l32i.n	a8, a6, 4
4200b5d2:	190c      	movi.n	a9, 1
4200b5d4:	a0c8a0        	addx4	a12, a8, a10
4200b5d7:	006c42        	s32i	a4, a12, 0
4200b5da:	402ab2        	l32i	a11, a10, 0x100
4200b5dd:	401800        	ssl	a8
4200b5e0:	a19900        	sll	a9, a9
4200b5e3:	20bb90        	or	a11, a11, a9
4200b5e6:	406ab2        	s32i	a11, a10, 0x100
4200b5e9:	206c52        	s32i	a5, a12, 128
4200b5ec:	082266        	bnei	a2, 2, 4200b5f8 <__register_exitproc+0x8c>
4200b5ef:	412ab2        	l32i	a11, a10, 0x104
4200b5f2:	209b90        	or	a9, a11, a9
4200b5f5:	416a92        	s32i	a9, a10, 0x104
4200b5f8:	981b      	addi.n	a9, a8, 1
4200b5fa:	1699      	s32i.n	a9, a6, 4
4200b5fc:	a08860        	addx4	a8, a8, a6
4200b5ff:	07a8      	l32i.n	a10, a7, 0
4200b601:	2839      	s32i.n	a3, a8, 8
4200b603:	d59081        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200b606:	0008e0        	callx8	a8
4200b609:	020c      	movi.n	a2, 0
4200b60b:	f01d      	retw.n
4200b60d:	000000        	ill

4200b610 <get_arg$isra$0>:
4200b610:	008136        	entry	a1, 64
4200b613:	102182        	l32i	a8, a1, 64
4200b616:	1179      	s32i.n	a7, a1, 4
4200b618:	0878      	l32i.n	a7, a8, 0
4200b61a:	2129      	s32i.n	a2, a1, 8
4200b61c:	21e8      	l32i.n	a14, a1, 8
4200b61e:	0528      	l32i.n	a2, a5, 0
4200b620:	4159      	s32i.n	a5, a1, 16
4200b622:	0169      	s32i.n	a6, a1, 0
4200b624:	837370        	moveqz	a7, a3, a7
4200b627:	00e306        	j	4200b9b7 <get_arg$isra$0+0x3a7>
4200b62a:	771b      	addi.n	a7, a7, 1
4200b62c:	000782        	l8ui	a8, a7, 0
4200b62f:	42f816        	beqz	a8, 4200ba62 <get_arg$isra$0+0x452>
4200b632:	dbc8a2        	addi	a10, a8, -37
4200b635:	ff1a56        	bnez	a10, 4200b62a <get_arg$isra$0+0x1a>
4200b638:	426816        	beqz	a8, 4200ba62 <get_arg$isra$0+0x452>
4200b63b:	080c      	movi.n	a8, 0
4200b63d:	a71b      	addi.n	a10, a7, 1
4200b63f:	050c      	movi.n	a5, 0
4200b641:	0d0c      	movi.n	a13, 0
4200b643:	f37c      	movi.n	a3, -1
4200b645:	060c      	movi.n	a6, 0
4200b647:	3189      	s32i.n	a8, a1, 12
4200b649:	000046        	j	4200b64e <get_arg$isra$0+0x3e>
4200b64c:	07ad      	mov.n	a10, a7
4200b64e:	d59c91        	l32r	a9, 42000cc0 <_stext+0xca0> (3c029b24 <__chclass>)
4200b651:	000a82        	l8ui	a8, a10, 0
4200b654:	7a1b      	addi.n	a7, a10, 1
4200b656:	b98a      	add.n	a11, a9, a8
4200b658:	3198      	l32i.n	a9, a1, 12
4200b65a:	000bc2        	l8ui	a12, a11, 0
4200b65d:	d599b1        	l32r	a11, 42000cc4 <_stext+0xca4> (3c029ab8 <__state_table>)
4200b660:	b0f990        	addx8	a15, a9, a9
4200b663:	bbfa      	add.n	a11, a11, a15
4200b665:	bbca      	add.n	a11, a11, a12
4200b667:	000b92        	l8ui	a9, a11, 0
4200b66a:	d597b1        	l32r	a11, 42000cc8 <_stext+0xca8> (3c029a4c <__action_table>)
4200b66d:	3199      	s32i.n	a9, a1, 12
4200b66f:	bbfa      	add.n	a11, a11, a15
4200b671:	bbca      	add.n	a11, a11, a12
4200b673:	000bb2        	l8ui	a11, a11, 0
4200b676:	bb0b      	addi.n	a11, a11, -1
4200b678:	74b0b0        	extui	a11, a11, 0, 8
4200b67b:	028bb6        	bltui	a11, 8, 4200b681 <get_arg$isra$0+0x71>
4200b67e:	00cac6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b681:	d592c1        	l32r	a12, 42000ccc <_stext+0xcac> (3c029270 <__on_exit_args+0x4>)
4200b684:	a0bbc0        	addx4	a11, a11, a12
4200b687:	0bb8      	l32i.n	a11, a11, 0
4200b689:	000ba0        	jx	a11
4200b68c:	0c0000        	lsi	f0, a0, 48
4200b68f:	069a      	add.n	a0, a6, a9
4200b691:	ad00c2        	l8ui	a12, a0, 173
4200b694:	ac4607        	ball	a6, a0, 4200b644 <get_arg$isra$0+0x34>
4200b697:	a0b200        	addx4	a11, a2, a0
4200b69a:	b76a      	add.n	a11, a7, a6
4200b69c:	3318      	l32i.n	a1, a3, 12
4200b69e:	0a3b87        	bltu	a11, a8, 4200b6ac <get_arg$isra$0+0x9c>
4200b6a1:	cb4c      	movi.n	a11, 76
4200b6a3:	2618b7        	beq	a8, a11, 4200b6cd <get_arg$isra$0+0xbd>
4200b6a6:	68a0b2        	movi	a11, 104
4200b6a9:	0005c6        	j	4200b6c4 <get_arg$isra$0+0xb4>
4200b6ac:	71a0b2        	movi	a11, 113
4200b6af:	1f18b7        	beq	a8, a11, 4200b6d2 <get_arg$isra$0+0xc2>
4200b6b2:	70a0b2        	movi	a11, 112
4200b6b5:	23bb87        	bgeu	a11, a8, 4200b6dc <get_arg$isra$0+0xcc>
4200b6b8:	74a0b2        	movi	a11, 116
4200b6bb:	0298b7        	bne	a8, a11, 4200b6c1 <get_arg$isra$0+0xb1>
4200b6be:	00bac6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b6c1:	7aa0b2        	movi	a11, 122
4200b6c4:	0298b7        	bne	a8, a11, 4200b6ca <get_arg$isra$0+0xba>
4200b6c7:	00b886        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b6ca:	000386        	j	4200b6dc <get_arg$isra$0+0xcc>
4200b6cd:	880c      	movi.n	a8, 8
4200b6cf:	000046        	j	4200b6d4 <get_arg$isra$0+0xc4>
4200b6d2:	082c      	movi.n	a8, 32
4200b6d4:	206680        	or	a6, a6, a8
4200b6d7:	00b486        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b6da:	b20000        	mulsh	a0, a0, a0
4200b6dd:	010a      	add.n	a0, a1, a0
4200b6df:	6ca082        	movi	a8, 108
4200b6e2:	0a9b87        	bne	a11, a8, 4200b6f0 <get_arg$isra$0+0xe0>
4200b6e5:	082c      	movi.n	a8, 32
4200b6e7:	206680        	or	a6, a6, a8
4200b6ea:	7a2b      	addi.n	a7, a10, 2
4200b6ec:	00af46        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b6ef:	081c00        	lsx	f1, a12, a0
4200b6f2:	fff786        	j	4200b6d4 <get_arg$isra$0+0xc4>
4200b6f5:	61a0b2        	movi	a11, 97
4200b6f8:	44a020        	extui	a10, a2, 0, 5
4200b6fb:	0298b7        	bne	a8, a11, 4200b701 <get_arg$isra$0+0xf1>
4200b6fe:	00e506        	j	4200ba96 <get_arg$isra$0+0x486>
4200b701:	3b3b87        	bltu	a11, a8, 4200b740 <get_arg$isra$0+0x130>
4200b704:	bfc882        	addi	a8, a8, -65
4200b707:	748080        	extui	a8, a8, 0, 8
4200b70a:	7b1c      	movi.n	a11, 23
4200b70c:	24bb87        	bgeu	a11, a8, 4200b734 <get_arg$isra$0+0x124>
4200b70f:	001686        	j	4200b76d <get_arg$isra$0+0x15d>
4200b712:	180c      	movi.n	a8, 1
4200b714:	401b00        	ssl	a11
4200b717:	a18800        	sll	a8, a8
4200b71a:	d56db1        	l32r	a11, 42000cd0 <_stext+0xcb0> (120821 <UserFrameTotalSize+0x120721>)
4200b71d:	3388b7        	bany	a8, a11, 4200b754 <get_arg$isra$0+0x144>
4200b720:	5b2c      	movi.n	a11, 37
4200b722:	11bb60        	slli	a11, a11, 10
4200b725:	0208b7        	bnone	a8, a11, 4200b72b <get_arg$isra$0+0x11b>
4200b728:	00dd46        	j	4200baa1 <get_arg$isra$0+0x491>
4200b72b:	248180        	extui	a8, a8, 1, 3
4200b72e:	364856        	bnez	a8, 4200ba96 <get_arg$isra$0+0x486>
4200b731:	000e06        	j	4200b76d <get_arg$isra$0+0x15d>
4200b734:	d568b1        	l32r	a11, 42000cd4 <_stext+0xcb4> (3c029290 <__on_exit_args+0x24>)
4200b737:	a088b0        	addx4	a8, a8, a11
4200b73a:	0888      	l32i.n	a8, a8, 0
4200b73c:	0008a0        	jx	a8
4200b73f:	a0b200        	addx4	a11, a2, a0
4200b742:	18b763        	lsi	f6, a7, 96
4200b745:	8219      	s32i.n	a1, a2, 32
4200b747:	9cc8      	l32i.n	a12, a12, 36
4200b749:	74b080        	extui	a11, a8, 0, 8
4200b74c:	481c      	movi.n	a8, 20
4200b74e:	c0b8b7        	bgeu	a8, a11, 4200b712 <get_arg$isra$0+0x102>
4200b751:	000606        	j	4200b76d <get_arg$isra$0+0x15d>
4200b754:	045560        	extui	a5, a6, 5, 1
4200b757:	555a      	add.n	a5, a5, a5
4200b759:	106647        	bbci	a6, 4, 4200b76d <get_arg$isra$0+0x15d>
4200b75c:	00d806        	j	4200bac0 <get_arg$isra$0+0x4b0>
4200b75f:	051c00        	extui	a1, a0, 28, 1
4200b762:	105650        	and	a5, a6, a5
4200b765:	34c556        	bnez	a5, 4200bab5 <get_arg$isra$0+0x4a5>
4200b768:	00d006        	j	4200baac <get_arg$isra$0+0x49c>
4200b76b:	260000        	lsi	f0, a0, 152
4200b76e:	880b03        	lsi	f0, a11, 0x220
4200b771:	0a2d11        	l32r	a1, 41fce028 <_coredump_iram_end+0x1c4c128>
4200b774:	a08380        	addx4	a8, a3, a8
4200b777:	0859      	s32i.n	a5, a8, 0
4200b779:	008c06        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b77c:	b50b      	addi.n	a11, a5, -1
4200b77e:	2488      	l32i.n	a8, a4, 8
4200b780:	2a1b      	addi.n	a2, a10, 1
4200b782:	026bb6        	bltui	a11, 6, 4200b788 <get_arg$isra$0+0x178>
4200b785:	002806        	j	4200b829 <get_arg$isra$0+0x219>
4200b788:	d554c1        	l32r	a12, 42000cd8 <_stext+0xcb8> (3c0292f0 <__on_exit_args+0x84>)
4200b78b:	a0bbc0        	addx4	a11, a11, a12
4200b78e:	0bc8      	l32i.n	a12, a11, 0
4200b790:	f4b0a0        	extui	a11, a10, 0, 16
4200b793:	000ca0        	jx	a12
4200b796:	0188      	l32i.n	a8, a1, 0
4200b798:	24b8      	l32i.n	a11, a4, 8
4200b79a:	2a1b      	addi.n	a2, a10, 1
4200b79c:	b0aa80        	addx8	a10, a10, a8
4200b79f:	8b4b      	addi.n	a8, a11, 4
4200b7a1:	2489      	s32i.n	a8, a4, 8
4200b7a3:	8c1c      	movi.n	a12, 24
4200b7a5:	042c87        	blt	a12, a8, 4200b7ad <get_arg$isra$0+0x19d>
4200b7a8:	14b8      	l32i.n	a11, a4, 4
4200b7aa:	000206        	j	4200b7b6 <get_arg$isra$0+0x1a6>
4200b7ad:	012cb7        	blt	a12, a11, 4200b7b2 <get_arg$isra$0+0x1a2>
4200b7b0:	482c      	movi.n	a8, 36
4200b7b2:	04b8      	l32i.n	a11, a4, 0
4200b7b4:	2489      	s32i.n	a8, a4, 8
4200b7b6:	bb8a      	add.n	a11, a11, a8
4200b7b8:	fccbb2        	addi	a11, a11, -4
4200b7bb:	0b88      	l32i.n	a8, a11, 0
4200b7bd:	f37c      	movi.n	a3, -1
4200b7bf:	0a89      	s32i.n	a8, a10, 0
4200b7c1:	150c      	movi.n	a5, 1
4200b7c3:	007986        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b7c6:	8a7c      	movi.n	a10, -8
4200b7c8:	887b      	addi.n	a8, a8, 7
4200b7ca:	1088a0        	and	a8, a8, a10
4200b7cd:	0198      	l32i.n	a9, a1, 0
4200b7cf:	a88b      	addi.n	a10, a8, 8
4200b7d1:	24a9      	s32i.n	a10, a4, 8
4200b7d3:	8c1c      	movi.n	a12, 24
4200b7d5:	b0bb90        	addx8	a11, a11, a9
4200b7d8:	042ca7        	blt	a12, a10, 4200b7e0 <get_arg$isra$0+0x1d0>
4200b7db:	1488      	l32i.n	a8, a4, 4
4200b7dd:	000206        	j	4200b7e9 <get_arg$isra$0+0x1d9>
4200b7e0:	012c87        	blt	a12, a8, 4200b7e5 <get_arg$isra$0+0x1d5>
4200b7e3:	8a2c      	movi.n	a10, 40
4200b7e5:	0488      	l32i.n	a8, a4, 0
4200b7e7:	24a9      	s32i.n	a10, a4, 8
4200b7e9:	88aa      	add.n	a8, a8, a10
4200b7eb:	f8c882        	addi	a8, a8, -8
4200b7ee:	1898      	l32i.n	a9, a8, 4
4200b7f0:	0888      	l32i.n	a8, a8, 0
4200b7f2:	1b99      	s32i.n	a9, a11, 4
4200b7f4:	0b89      	s32i.n	a8, a11, 0
4200b7f6:	006cc6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b7f9:	0188      	l32i.n	a8, a1, 0
4200b7fb:	24b8      	l32i.n	a11, a4, 8
4200b7fd:	2a1b      	addi.n	a2, a10, 1
4200b7ff:	b0aa80        	addx8	a10, a10, a8
4200b802:	8b4b      	addi.n	a8, a11, 4
4200b804:	2489      	s32i.n	a8, a4, 8
4200b806:	8c1c      	movi.n	a12, 24
4200b808:	042c87        	blt	a12, a8, 4200b810 <get_arg$isra$0+0x200>
4200b80b:	14b8      	l32i.n	a11, a4, 4
4200b80d:	000206        	j	4200b819 <get_arg$isra$0+0x209>
4200b810:	012cb7        	blt	a12, a11, 4200b815 <get_arg$isra$0+0x205>
4200b813:	482c      	movi.n	a8, 36
4200b815:	04b8      	l32i.n	a11, a4, 0
4200b817:	2489      	s32i.n	a8, a4, 8
4200b819:	bb8a      	add.n	a11, a11, a8
4200b81b:	fccbb2        	addi	a11, a11, -4
4200b81e:	0b88      	l32i.n	a8, a11, 0
4200b820:	f37c      	movi.n	a3, -1
4200b822:	0a89      	s32i.n	a8, a10, 0
4200b824:	650c      	movi.n	a5, 6
4200b826:	0060c6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b829:	0188      	l32i.n	a8, a1, 0
4200b82b:	24b8      	l32i.n	a11, a4, 8
4200b82d:	2a1b      	addi.n	a2, a10, 1
4200b82f:	b0aa80        	addx8	a10, a10, a8
4200b832:	8b4b      	addi.n	a8, a11, 4
4200b834:	2489      	s32i.n	a8, a4, 8
4200b836:	8c1c      	movi.n	a12, 24
4200b838:	042c87        	blt	a12, a8, 4200b840 <get_arg$isra$0+0x230>
4200b83b:	14b8      	l32i.n	a11, a4, 4
4200b83d:	000206        	j	4200b849 <get_arg$isra$0+0x239>
4200b840:	012cb7        	blt	a12, a11, 4200b845 <get_arg$isra$0+0x235>
4200b843:	482c      	movi.n	a8, 36
4200b845:	04b8      	l32i.n	a11, a4, 0
4200b847:	2489      	s32i.n	a8, a4, 8
4200b849:	bb8a      	add.n	a11, a11, a8
4200b84b:	fccbb2        	addi	a11, a11, -4
4200b84e:	0b88      	l32i.n	a8, a11, 0
4200b850:	f37c      	movi.n	a3, -1
4200b852:	0a89      	s32i.n	a8, a10, 0
4200b854:	050c      	movi.n	a5, 0
4200b856:	0054c6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b859:	0188      	l32i.n	a8, a1, 0
4200b85b:	24b8      	l32i.n	a11, a4, 8
4200b85d:	2a1b      	addi.n	a2, a10, 1
4200b85f:	b0aa80        	addx8	a10, a10, a8
4200b862:	8b4b      	addi.n	a8, a11, 4
4200b864:	2489      	s32i.n	a8, a4, 8
4200b866:	8c1c      	movi.n	a12, 24
4200b868:	042c87        	blt	a12, a8, 4200b870 <get_arg$isra$0+0x260>
4200b86b:	14b8      	l32i.n	a11, a4, 4
4200b86d:	000206        	j	4200b879 <get_arg$isra$0+0x269>
4200b870:	012cb7        	blt	a12, a11, 4200b875 <get_arg$isra$0+0x265>
4200b873:	482c      	movi.n	a8, 36
4200b875:	04b8      	l32i.n	a11, a4, 0
4200b877:	2489      	s32i.n	a8, a4, 8
4200b879:	bb8a      	add.n	a11, a11, a8
4200b87b:	fccbb2        	addi	a11, a11, -4
4200b87e:	0b88      	l32i.n	a8, a11, 0
4200b880:	f37c      	movi.n	a3, -1
4200b882:	0a89      	s32i.n	a8, a10, 0
4200b884:	350c      	movi.n	a5, 3
4200b886:	0048c6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b889:	0188      	l32i.n	a8, a1, 0
4200b88b:	2a1b      	addi.n	a2, a10, 1
4200b88d:	b0aa80        	addx8	a10, a10, a8
4200b890:	2488      	l32i.n	a8, a4, 8
4200b892:	8b7c      	movi.n	a11, -8
4200b894:	887b      	addi.n	a8, a8, 7
4200b896:	1088b0        	and	a8, a8, a11
4200b899:	b88b      	addi.n	a11, a8, 8
4200b89b:	24b9      	s32i.n	a11, a4, 8
4200b89d:	8c1c      	movi.n	a12, 24
4200b89f:	052cb7        	blt	a12, a11, 4200b8a8 <get_arg$isra$0+0x298>
4200b8a2:	1488      	l32i.n	a8, a4, 4
4200b8a4:	000246        	j	4200b8b1 <get_arg$isra$0+0x2a1>
4200b8a7:	2c8700        	lsi	f0, a7, 176
4200b8aa:	8b2c01        	l32r	a0, 41fee55c <_coredump_iram_end+0x1c6c65c>
4200b8ad:	0488      	l32i.n	a8, a4, 0
4200b8af:	24b9      	s32i.n	a11, a4, 8
4200b8b1:	88ba      	add.n	a8, a8, a11
4200b8b3:	f8c882        	addi	a8, a8, -8
4200b8b6:	1898      	l32i.n	a9, a8, 4
4200b8b8:	0888      	l32i.n	a8, a8, 0
4200b8ba:	f37c      	movi.n	a3, -1
4200b8bc:	0a89      	s32i.n	a8, a10, 0
4200b8be:	1a99      	s32i.n	a9, a10, 4
4200b8c0:	450c      	movi.n	a5, 4
4200b8c2:	0039c6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b8c5:	8a7c      	movi.n	a10, -8
4200b8c7:	887b      	addi.n	a8, a8, 7
4200b8c9:	1088a0        	and	a8, a8, a10
4200b8cc:	0198      	l32i.n	a9, a1, 0
4200b8ce:	a88b      	addi.n	a10, a8, 8
4200b8d0:	24a9      	s32i.n	a10, a4, 8
4200b8d2:	8c1c      	movi.n	a12, 24
4200b8d4:	b0bb90        	addx8	a11, a11, a9
4200b8d7:	052ca7        	blt	a12, a10, 4200b8e0 <get_arg$isra$0+0x2d0>
4200b8da:	1488      	l32i.n	a8, a4, 4
4200b8dc:	000246        	j	4200b8e9 <get_arg$isra$0+0x2d9>
4200b8df:	2c8700        	lsi	f0, a7, 176
4200b8e2:	8a2c01        	l32r	a0, 41fee194 <_coredump_iram_end+0x1c6c294>
4200b8e5:	0488      	l32i.n	a8, a4, 0
4200b8e7:	24a9      	s32i.n	a10, a4, 8
4200b8e9:	88aa      	add.n	a8, a8, a10
4200b8eb:	f8c882        	addi	a8, a8, -8
4200b8ee:	1898      	l32i.n	a9, a8, 4
4200b8f0:	0888      	l32i.n	a8, a8, 0
4200b8f2:	1b99      	s32i.n	a9, a11, 4
4200b8f4:	0b89      	s32i.n	a8, a11, 0
4200b8f6:	002cc6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b8f9:	1188      	l32i.n	a8, a1, 4
4200b8fb:	0888      	l32i.n	a8, a8, 0
4200b8fd:	140866        	bnei	a8, -1, 4200b915 <get_arg$isra$0+0x305>
4200b900:	11a8      	l32i.n	a10, a1, 4
4200b902:	80a0c2        	movi	a12, 128
4200b905:	0b0c      	movi.n	a11, 0
4200b907:	61d9      	s32i.n	a13, a1, 24
4200b909:	51e9      	s32i.n	a14, a1, 20
4200b90b:	d27d81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200b90e:	0008e0        	callx8	a8
4200b911:	61d8      	l32i.n	a13, a1, 24
4200b913:	51e8      	l32i.n	a14, a1, 20
4200b915:	3d0b      	addi.n	a3, a13, -1
4200b917:	53ee30        	max	a14, a14, a3
4200b91a:	0023c6        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b91d:	1188      	l32i.n	a8, a1, 4
4200b91f:	0888      	l32i.n	a8, a8, 0
4200b921:	140866        	bnei	a8, -1, 4200b939 <get_arg$isra$0+0x329>
4200b924:	11a8      	l32i.n	a10, a1, 4
4200b926:	80a0c2        	movi	a12, 128
4200b929:	0b0c      	movi.n	a11, 0
4200b92b:	61d9      	s32i.n	a13, a1, 24
4200b92d:	51e9      	s32i.n	a14, a1, 20
4200b92f:	d27481        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200b932:	0008e0        	callx8	a8
4200b935:	61d8      	l32i.n	a13, a1, 24
4200b937:	51e8      	l32i.n	a14, a1, 20
4200b939:	1188      	l32i.n	a8, a1, 4
4200b93b:	dd0b      	addi.n	a13, a13, -1
4200b93d:	a08d80        	addx4	a8, a13, a8
4200b940:	0a0c      	movi.n	a10, 0
4200b942:	08a9      	s32i.n	a10, a8, 0
4200b944:	53eed0        	max	a14, a14, a13
4200b947:	001886        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b94a:	0188      	l32i.n	a8, a1, 0
4200b94c:	24b8      	l32i.n	a11, a4, 8
4200b94e:	f21b      	addi.n	a15, a2, 1
4200b950:	b02280        	addx8	a2, a2, a8
4200b953:	8b4b      	addi.n	a8, a11, 4
4200b955:	2489      	s32i.n	a8, a4, 8
4200b957:	8c1c      	movi.n	a12, 24
4200b959:	042c87        	blt	a12, a8, 4200b961 <get_arg$isra$0+0x351>
4200b95c:	14b8      	l32i.n	a11, a4, 4
4200b95e:	000206        	j	4200b96a <get_arg$isra$0+0x35a>
4200b961:	012cb7        	blt	a12, a11, 4200b966 <get_arg$isra$0+0x356>
4200b964:	482c      	movi.n	a8, 36
4200b966:	04b8      	l32i.n	a11, a4, 0
4200b968:	2489      	s32i.n	a8, a4, 8
4200b96a:	bb8a      	add.n	a11, a11, a8
4200b96c:	fccbb2        	addi	a11, a11, -4
4200b96f:	0b88      	l32i.n	a8, a11, 0
4200b971:	0a7d      	mov.n	a7, a10
4200b973:	0289      	s32i.n	a8, a2, 0
4200b975:	0f2d      	mov.n	a2, a15
4200b977:	000c86        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b97a:	d20000        	quos	a0, a0, a0
4200b97d:	d0c8      	l32i.n	a12, a0, 52
4200b97f:	9a0c      	movi.n	a10, 9
4200b981:	0001c6        	j	4200b98c <get_arg$isra$0+0x37c>
4200b984:	a0ddd0        	addx4	a13, a13, a13
4200b987:	90dd80        	addx2	a13, a13, a8
4200b98a:	771b      	addi.n	a7, a7, 1
4200b98c:	000782        	l8ui	a8, a7, 0
4200b98f:	a89c      	beqz.n	a8, 4200b9ad <get_arg$isra$0+0x39d>
4200b991:	d0c882        	addi	a8, a8, -48
4200b994:	ecba87        	bgeu	a10, a8, 4200b984 <get_arg$isra$0+0x374>
4200b997:	000486        	j	4200b9ad <get_arg$isra$0+0x39d>
4200b99a:	820000        	mull	a0, a0, a0
4200b99d:	820007        	bnone	a0, a0, 4200b923 <get_arg$isra$0+0x313>
4200b9a0:	d0c8      	l32i.n	a12, a0, 52
4200b9a2:	748080        	extui	a8, a8, 0, 8
4200b9a5:	043a87        	bltu	a10, a8, 4200b9ad <get_arg$isra$0+0x39d>
4200b9a8:	771b      	addi.n	a7, a7, 1
4200b9aa:	fffb86        	j	4200b99c <get_arg$isra$0+0x38c>
4200b9ad:	3198      	l32i.n	a9, a1, 12
4200b9af:	b80c      	movi.n	a8, 11
4200b9b1:	021987        	beq	a9, a8, 4200b9b7 <get_arg$isra$0+0x3a7>
4200b9b4:	ff2506        	j	4200b64c <get_arg$isra$0+0x3c>
4200b9b7:	0007a2        	l8ui	a10, a7, 0
4200b9ba:	ea8c      	beqz.n	a10, 4200b9cc <get_arg$isra$0+0x3bc>
4200b9bc:	2188      	l32i.n	a8, a1, 8
4200b9be:	728820        	lsi	f2, a8, 0x1c8
4200b9c1:	880b      	addi.n	a8, a8, -1
4200b9c3:	608080        	neg	a8, a8
4200b9c6:	748080        	extui	a8, a8, 0, 8
4200b9c9:	c5f856        	bnez	a8, 4200b62c <get_arg$isra$0+0x1c>
4200b9cc:	2188      	l32i.n	a8, a1, 8
4200b9ce:	93e8a0        	movnez	a14, a8, a10
4200b9d1:	002346        	j	4200ba62 <get_arg$isra$0+0x452>
4200b9d4:	1188      	l32i.n	a8, a1, 4
4200b9d6:	a08d80        	addx4	a8, a13, a8
4200b9d9:	08c8      	l32i.n	a12, a8, 0
4200b9db:	dd1b      	addi.n	a13, a13, 1
4200b9dd:	cc0b      	addi.n	a12, a12, -1
4200b9df:	2488      	l32i.n	a8, a4, 8
4200b9e1:	5c6cf6        	bgeui	a12, 6, 4200ba41 <get_arg$isra$0+0x431>
4200b9e4:	a0cc60        	addx4	a12, a12, a6
4200b9e7:	0cc8      	l32i.n	a12, a12, 0
4200b9e9:	000ca0        	jx	a12
4200b9ec:	887b      	addi.n	a8, a8, 7
4200b9ee:	1088f0        	and	a8, a8, a15
4200b9f1:	c88b      	addi.n	a12, a8, 8
4200b9f3:	24c9      	s32i.n	a12, a4, 8
4200b9f5:	042ac7        	blt	a10, a12, 4200b9fd <get_arg$isra$0+0x3ed>
4200b9f8:	1488      	l32i.n	a8, a4, 4
4200b9fa:	000206        	j	4200ba06 <get_arg$isra$0+0x3f6>
4200b9fd:	012a87        	blt	a10, a8, 4200ba02 <get_arg$isra$0+0x3f2>
4200ba00:	8c2c      	movi.n	a12, 40
4200ba02:	0488      	l32i.n	a8, a4, 0
4200ba04:	24c9      	s32i.n	a12, a4, 8
4200ba06:	88ca      	add.n	a8, a8, a12
4200ba08:	f8c882        	addi	a8, a8, -8
4200ba0b:	1898      	l32i.n	a9, a8, 4
4200ba0d:	0888      	l32i.n	a8, a8, 0
4200ba0f:	1b99      	s32i.n	a9, a11, 4
4200ba11:	0b89      	s32i.n	a8, a11, 0
4200ba13:	001706        	j	4200ba73 <get_arg$isra$0+0x463>
4200ba16:	887b      	addi.n	a8, a8, 7
4200ba18:	1088f0        	and	a8, a8, a15
4200ba1b:	c88b      	addi.n	a12, a8, 8
4200ba1d:	24c9      	s32i.n	a12, a4, 8
4200ba1f:	052ac7        	blt	a10, a12, 4200ba28 <get_arg$isra$0+0x418>
4200ba22:	1488      	l32i.n	a8, a4, 4
4200ba24:	000246        	j	4200ba31 <get_arg$isra$0+0x421>
4200ba27:	2a8700        	mul.s	f8, f7, f0
4200ba2a:	8c2c01        	l32r	a0, 41feeadc <_coredump_iram_end+0x1c6cbdc>
4200ba2d:	0488      	l32i.n	a8, a4, 0
4200ba2f:	24c9      	s32i.n	a12, a4, 8
4200ba31:	88ca      	add.n	a8, a8, a12
4200ba33:	f8c882        	addi	a8, a8, -8
4200ba36:	1898      	l32i.n	a9, a8, 4
4200ba38:	0888      	l32i.n	a8, a8, 0
4200ba3a:	1b99      	s32i.n	a9, a11, 4
4200ba3c:	0b89      	s32i.n	a8, a11, 0
4200ba3e:	000c46        	j	4200ba73 <get_arg$isra$0+0x463>
4200ba41:	c84b      	addi.n	a12, a8, 4
4200ba43:	24c9      	s32i.n	a12, a4, 8
4200ba45:	042ac7        	blt	a10, a12, 4200ba4d <get_arg$isra$0+0x43d>
4200ba48:	1488      	l32i.n	a8, a4, 4
4200ba4a:	000206        	j	4200ba56 <get_arg$isra$0+0x446>
4200ba4d:	012a87        	blt	a10, a8, 4200ba52 <get_arg$isra$0+0x442>
4200ba50:	4c2c      	movi.n	a12, 36
4200ba52:	0488      	l32i.n	a8, a4, 0
4200ba54:	24c9      	s32i.n	a12, a4, 8
4200ba56:	88ca      	add.n	a8, a8, a12
4200ba58:	fcc882        	addi	a8, a8, -4
4200ba5b:	0888      	l32i.n	a8, a8, 0
4200ba5d:	0b89      	s32i.n	a8, a11, 0
4200ba5f:	000406        	j	4200ba73 <get_arg$isra$0+0x463>
4200ba62:	0188      	l32i.n	a8, a1, 0
4200ba64:	d49e61        	l32r	a6, 42000cdc <_stext+0xcbc> (3c029308 <__on_exit_args+0x9c>)
4200ba67:	b0b280        	addx8	a11, a2, a8
4200ba6a:	02dd      	mov.n	a13, a2
4200ba6c:	8a1c      	movi.n	a10, 24
4200ba6e:	8f7c      	movi.n	a15, -8
4200ba70:	000046        	j	4200ba75 <get_arg$isra$0+0x465>
4200ba73:	bb8b      	addi.n	a11, a11, 8
4200ba75:	022ed7        	blt	a14, a13, 4200ba7b <get_arg$isra$0+0x46b>
4200ba78:	ffd606        	j	4200b9d4 <get_arg$isra$0+0x3c4>
4200ba7b:	8e1b      	addi.n	a8, a14, 1
4200ba7d:	728820        	lsi	f2, a8, 0x1c8
4200ba80:	880b      	addi.n	a8, a8, -1
4200ba82:	608080        	neg	a8, a8
4200ba85:	748080        	extui	a8, a8, 0, 8
4200ba88:	0a0c      	movi.n	a10, 0
4200ba8a:	d8bc      	beqz.n	a8, 4200bacb <get_arg$isra$0+0x4bb>
4200ba8c:	820b      	addi.n	a8, a2, -1
4200ba8e:	608080        	neg	a8, a8
4200ba91:	a8ea      	add.n	a10, a8, a14
4200ba93:	000d06        	j	4200bacb <get_arg$isra$0+0x4bb>
4200ba96:	450c      	movi.n	a5, 4
4200ba98:	020326        	beqi	a3, -1, 4200ba9e <get_arg$isra$0+0x48e>
4200ba9b:	ff3446        	j	4200b770 <get_arg$isra$0+0x160>
4200ba9e:	ff79c6        	j	4200b889 <get_arg$isra$0+0x279>
4200baa1:	350c      	movi.n	a5, 3
4200baa3:	020326        	beqi	a3, -1, 4200baa9 <get_arg$isra$0+0x499>
4200baa6:	ff3186        	j	4200b770 <get_arg$isra$0+0x160>
4200baa9:	ff6b06        	j	4200b859 <get_arg$isra$0+0x249>
4200baac:	020326        	beqi	a3, -1, 4200bab2 <get_arg$isra$0+0x4a2>
4200baaf:	ff2f46        	j	4200b770 <get_arg$isra$0+0x160>
4200bab2:	ff5cc6        	j	4200b829 <get_arg$isra$0+0x219>
4200bab5:	650c      	movi.n	a5, 6
4200bab7:	020326        	beqi	a3, -1, 4200babd <get_arg$isra$0+0x4ad>
4200baba:	ff2c86        	j	4200b770 <get_arg$isra$0+0x160>
4200babd:	ff4e06        	j	4200b7f9 <get_arg$isra$0+0x1e9>
4200bac0:	150c      	movi.n	a5, 1
4200bac2:	020326        	beqi	a3, -1, 4200bac8 <get_arg$isra$0+0x4b8>
4200bac5:	ff29c6        	j	4200b770 <get_arg$isra$0+0x160>
4200bac8:	ff3286        	j	4200b796 <get_arg$isra$0+0x186>
4200bacb:	4198      	l32i.n	a9, a1, 16
4200bacd:	8a2a      	add.n	a8, a10, a2
4200bacf:	0989      	s32i.n	a8, a9, 0
4200bad1:	102182        	l32i	a8, a1, 64
4200bad4:	0198      	l32i.n	a9, a1, 0
4200bad6:	0879      	s32i.n	a7, a8, 0
4200bad8:	2188      	l32i.n	a8, a1, 8
4200bada:	b02890        	addx8	a2, a8, a9
4200badd:	f01d      	retw.n
	...

4200bae0 <_vfprintf_r>:
4200bae0:	064136        	entry	a1, 0x320
4200bae3:	9f6142        	s32i	a4, a1, 0x27c
4200bae6:	02ad      	mov.n	a10, a2
4200bae8:	9c6152        	s32i	a5, a1, 0x270
4200baeb:	9d6162        	s32i	a6, a1, 0x274
4200baee:	9e6172        	s32i	a7, a1, 0x278
4200baf1:	a16122        	s32i	a2, a1, 0x284
4200baf4:	a06132        	s32i	a3, a1, 0x280
4200baf7:	201110        	or	a1, a1, a1
4200bafa:	050f25        	call8	42010bec <_localeconv_r>
4200bafd:	0a88      	l32i.n	a8, a10, 0
4200baff:	10c142        	addi	a4, a1, 16
4200bb02:	08ad      	mov.n	a10, a8
4200bb04:	b16182        	s32i	a8, a1, 0x2c4
4200bb07:	d1e581        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200bb0a:	0008e0        	callx8	a8
4200bb0d:	a12182        	l32i	a8, a1, 0x284
4200bb10:	ad61a2        	s32i	a10, a1, 0x2b4
4200bb13:	00d816        	beqz	a8, 4200bb24 <_vfprintf_r+0x44>
4200bb16:	0a2882        	l32i	a8, a8, 40
4200bb19:	78cc      	bnez.n	a8, 4200bb24 <_vfprintf_r+0x44>
4200bb1b:	a121a2        	l32i	a10, a1, 0x284
4200bb1e:	201110        	or	a1, a1, a1
4200bb21:	fef325        	call8	4200aa54 <__sinit>
4200bb24:	a02182        	l32i	a8, a1, 0x280
4200bb27:	192882        	l32i	a8, a8, 100
4200bb2a:	14e807        	bbsi	a8, 0, 4200bb42 <_vfprintf_r+0x62>
4200bb2d:	a02182        	l32i	a8, a1, 0x280
4200bb30:	061882        	l16ui	a8, a8, 12
4200bb33:	0be897        	bbsi	a8, 9, 4200bb42 <_vfprintf_r+0x62>
4200bb36:	a02182        	l32i	a8, a1, 0x280
4200bb39:	1628a2        	l32i	a10, a8, 88
4200bb3c:	d44181        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200bb3f:	0008e0        	callx8	a8
4200bb42:	a02182        	l32i	a8, a1, 0x280
4200bb45:	061882        	l16ui	a8, a8, 12
4200bb48:	066837        	bbci	a8, 3, 4200bb52 <_vfprintf_r+0x72>
4200bb4b:	a02182        	l32i	a8, a1, 0x280
4200bb4e:	4888      	l32i.n	a8, a8, 16
4200bb50:	58fc      	bnez.n	a8, 4200bb89 <_vfprintf_r+0xa9>
4200bb52:	a021b2        	l32i	a11, a1, 0x280
4200bb55:	a121a2        	l32i	a10, a1, 0x284
4200bb58:	201110        	or	a1, a1, a1
4200bb5b:	ff4e65        	call8	4200b040 <__swsetup_r>
4200bb5e:	7aac      	beqz.n	a10, 4200bb89 <_vfprintf_r+0xa9>
4200bb60:	a02182        	l32i	a8, a1, 0x280
4200bb63:	192882        	l32i	a8, a8, 100
4200bb66:	076807        	bbci	a8, 0, 4200bb71 <_vfprintf_r+0x91>
4200bb69:	f87c      	movi.n	a8, -1
4200bb6b:	ae6182        	s32i	a8, a1, 0x2b8
4200bb6e:	0ae586        	j	4200e708 <_vfprintf_r+0x2c28>
4200bb71:	a02182        	l32i	a8, a1, 0x280
4200bb74:	061882        	l16ui	a8, a8, 12
4200bb77:	eee897        	bbsi	a8, 9, 4200bb69 <_vfprintf_r+0x89>
4200bb7a:	a02182        	l32i	a8, a1, 0x280
4200bb7d:	1628a2        	l32i	a10, a8, 88
4200bb80:	d43181        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200bb83:	0008e0        	callx8	a8
4200bb86:	fff7c6        	j	4200bb69 <_vfprintf_r+0x89>
4200bb89:	a02182        	l32i	a8, a1, 0x280
4200bb8c:	069892        	l16si	a9, a8, 12
4200bb8f:	1aa082        	movi	a8, 26
4200bb92:	108980        	and	a8, a9, a8
4200bb95:	439866        	bnei	a8, 10, 4200bbdc <_vfprintf_r+0xfc>
4200bb98:	a02182        	l32i	a8, a1, 0x280
4200bb9b:	079882        	l16si	a8, a8, 14
4200bb9e:	03a896        	bltz	a8, 4200bbdc <_vfprintf_r+0xfc>
4200bba1:	a02182        	l32i	a8, a1, 0x280
4200bba4:	192882        	l32i	a8, a8, 100
4200bba7:	0ee807        	bbsi	a8, 0, 4200bbb9 <_vfprintf_r+0xd9>
4200bbaa:	0be997        	bbsi	a9, 9, 4200bbb9 <_vfprintf_r+0xd9>
4200bbad:	a02182        	l32i	a8, a1, 0x280
4200bbb0:	1628a2        	l32i	a10, a8, 88
4200bbb3:	d42481        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200bbb6:	0008e0        	callx8	a8
4200bbb9:	9824d2        	l32i	a13, a4, 0x260
4200bbbc:	9924e2        	l32i	a14, a4, 0x264
4200bbbf:	9a24f2        	l32i	a15, a4, 0x268
4200bbc2:	9f21c2        	l32i	a12, a1, 0x27c
4200bbc5:	a021b2        	l32i	a11, a1, 0x280
4200bbc8:	a121a2        	l32i	a10, a1, 0x284
4200bbcb:	02d442        	addmi	a4, a4, 0x200
4200bbce:	201110        	or	a1, a1, a1
4200bbd1:	02b625        	call8	4200e734 <__sbprintf>
4200bbd4:	ae61a2        	s32i	a10, a1, 0x2b8
4200bbd7:	0acb46        	j	4200e708 <_vfprintf_r+0x2c28>
4200bbda:	820000        	mull	a0, a0, a0
4200bbdd:	8ae4a1        	l32r	a10, 41fee770 <_coredump_iram_end+0x1c6c870>
4200bbe0:	090c84        	lsi	f8, a12, 36
4200bbe3:	896482        	s32i	a8, a4, 0x224
4200bbe6:	082d      	mov.n	a2, a8
4200bbe8:	080c      	movi.n	a8, 0
4200bbea:	fa7c      	movi.n	a10, -1
4200bbec:	8b6492        	s32i	a9, a4, 0x22c
4200bbef:	8a6492        	s32i	a9, a4, 0x228
4200bbf2:	966192        	s32i	a9, a1, 0x258
4200bbf5:	976192        	s32i	a9, a1, 0x25c
4200bbf8:	a46192        	s32i	a9, a1, 0x290
4200bbfb:	b86182        	s32i	a8, a1, 0x2e0
4200bbfe:	b76182        	s32i	a8, a1, 0x2dc
4200bc01:	aa6182        	s32i	a8, a1, 0x2a8
4200bc04:	b06182        	s32i	a8, a1, 0x2c0
4200bc07:	b66182        	s32i	a8, a1, 0x2d8
4200bc0a:	ae6182        	s32i	a8, a1, 0x2b8
4200bc0d:	10c192        	addi	a9, a1, 16
4200bc10:	e4a182        	movi	a8, 0x1e4
4200bc13:	4064a2        	s32i	a10, a4, 0x100
4200bc16:	0b0c      	movi.n	a11, 0
4200bc18:	0a0c      	movi.n	a10, 0
4200bc1a:	898a      	add.n	a8, a9, a8
4200bc1c:	a661a2        	s32i	a10, a1, 0x298
4200bc1f:	a761b2        	s32i	a11, a1, 0x29c
4200bc22:	070c      	movi.n	a7, 0
4200bc24:	bb6182        	s32i	a8, a1, 0x2ec
4200bc27:	000346        	j	4200bc38 <_vfprintf_r+0x158>
4200bc2a:	e4a182        	movi	a8, 0x1e4
4200bc2d:	10c192        	addi	a9, a1, 16
4200bc30:	298a      	add.n	a2, a9, a8
4200bc32:	a82182        	l32i	a8, a1, 0x2a0
4200bc35:	9f6182        	s32i	a8, a1, 0x27c
4200bc38:	9f2152        	l32i	a5, a1, 0x27c
4200bc3b:	000046        	j	4200bc40 <_vfprintf_r+0x160>
4200bc3e:	551b      	addi.n	a5, a5, 1
4200bc40:	000582        	l8ui	a8, a5, 0
4200bc43:	005816        	beqz	a8, 4200bc4c <_vfprintf_r+0x16c>
4200bc46:	dbc882        	addi	a8, a8, -37
4200bc49:	ff1856        	bnez	a8, 4200bc3e <_vfprintf_r+0x15e>
4200bc4c:	9f2182        	l32i	a8, a1, 0x27c
4200bc4f:	c06580        	sub	a6, a5, a8
4200bc52:	044616        	beqz	a6, 4200bc9a <_vfprintf_r+0x1ba>
4200bc55:	0289      	s32i.n	a8, a2, 0
4200bc57:	10c182        	addi	a8, a1, 16
4200bc5a:	02d892        	addmi	a9, a8, 0x200
4200bc5d:	8f2182        	l32i	a8, a1, 0x23c
4200bc60:	1269      	s32i.n	a6, a2, 4
4200bc62:	886a      	add.n	a8, a8, a6
4200bc64:	b989      	s32i.n	a8, a9, 44
4200bc66:	a988      	l32i.n	a8, a9, 40
4200bc68:	228b      	addi.n	a2, a2, 8
4200bc6a:	881b      	addi.n	a8, a8, 1
4200bc6c:	a989      	s32i.n	a8, a9, 40
4200bc6e:	2088a6        	blti	a8, 8, 4200bc92 <_vfprintf_r+0x1b2>
4200bc71:	24a2c2        	movi	a12, 0x224
4200bc74:	10c182        	addi	a8, a1, 16
4200bc77:	a021b2        	l32i	a11, a1, 0x280
4200bc7a:	a121a2        	l32i	a10, a1, 0x284
4200bc7d:	c8ca      	add.n	a12, a8, a12
4200bc7f:	201110        	or	a1, a1, a1
4200bc82:	030165        	call8	4200ec98 <__sprint_r>
4200bc85:	1a8c      	beqz.n	a10, 4200bc8a <_vfprintf_r+0x1aa>
4200bc87:	0a9046        	j	4200e6cc <_vfprintf_r+0x2bec>
4200bc8a:	e4a182        	movi	a8, 0x1e4
4200bc8d:	10c192        	addi	a9, a1, 16
4200bc90:	298a      	add.n	a2, a9, a8
4200bc92:	ae2182        	l32i	a8, a1, 0x2b8
4200bc95:	886a      	add.n	a8, a8, a6
4200bc97:	ae6182        	s32i	a8, a1, 0x2b8
4200bc9a:	000582        	l8ui	a8, a5, 0
4200bc9d:	18cc      	bnez.n	a8, 4200bca2 <_vfprintf_r+0x1c2>
4200bc9f:	0a7b46        	j	4200e690 <_vfprintf_r+0x2bb0>
4200bca2:	10c192        	addi	a9, a1, 16
4200bca5:	02d992        	addmi	a9, a9, 0x200
4200bca8:	0a0c      	movi.n	a10, 0
4200bcaa:	5249a2        	s8i	a10, a9, 82
4200bcad:	f97c      	movi.n	a9, -1
4200bcaf:	a26192        	s32i	a9, a1, 0x288
4200bcb2:	090c      	movi.n	a9, 0
4200bcb4:	851b      	addi.n	a8, a5, 1
4200bcb6:	076d      	mov.n	a6, a7
4200bcb8:	ac6192        	s32i	a9, a1, 0x2b0
4200bcbb:	040c      	movi.n	a4, 0
4200bcbd:	030c      	movi.n	a3, 0
4200bcbf:	000286        	j	4200bccd <_vfprintf_r+0x1ed>
4200bcc2:	000000        	ill
4200bcc5:	a86192        	s32i	a9, a1, 0x2a0
4200bcc8:	040c      	movi.n	a4, 0
4200bcca:	a82182        	l32i	a8, a1, 0x2a0
4200bccd:	981b      	addi.n	a9, a8, 1
4200bccf:	000882        	l8ui	a8, a8, 0
4200bcd2:	a86192        	s32i	a9, a1, 0x2a0
4200bcd5:	a36182        	s32i	a8, a1, 0x28c
4200bcd8:	aa5c      	movi.n	a10, 90
4200bcda:	000086        	j	4200bce0 <_vfprintf_r+0x200>
4200bcdd:	ac6182        	s32i	a8, a1, 0x2b0
4200bce0:	a32182        	l32i	a8, a1, 0x28c
4200bce3:	e0c882        	addi	a8, a8, -32
4200bce6:	02ba87        	bgeu	a10, a8, 4200bcec <_vfprintf_r+0x20c>
4200bce9:	07a8c6        	j	4200db90 <_vfprintf_r+0x20b0>
4200bcec:	d40391        	l32r	a9, 42000cf8 <_stext+0xcd8> (3c029320 <__on_exit_args+0xb4>)
4200bcef:	a08890        	addx4	a8, a8, a9
4200bcf2:	0888      	l32i.n	a8, a8, 0
4200bcf4:	0008a0        	jx	a8
4200bcf7:	d3fe81        	l32r	a8, 42000cf0 <_stext+0xcd0> (3c02915e <Xthal_intlevel+0x32>)
4200bcfa:	066846        	j	4200d69f <_vfprintf_r+0x1bbf>
4200bcfd:	a121a2        	l32i	a10, a1, 0x284
4200bd00:	201110        	or	a1, a1, a1
4200bd03:	04eea5        	call8	42010bec <_localeconv_r>
4200bd06:	1a88      	l32i.n	a8, a10, 4
4200bd08:	20a880        	or	a10, a8, a8
4200bd0b:	b66182        	s32i	a8, a1, 0x2d8
4200bd0e:	d16381        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200bd11:	0008e0        	callx8	a8
4200bd14:	b061a2        	s32i	a10, a1, 0x2c0
4200bd17:	a121a2        	l32i	a10, a1, 0x284
4200bd1a:	201110        	or	a1, a1, a1
4200bd1d:	04ece5        	call8	42010bec <_localeconv_r>
4200bd20:	2a88      	l32i.n	a8, a10, 8
4200bd22:	aa6182        	s32i	a8, a1, 0x2a8
4200bd25:	b02182        	l32i	a8, a1, 0x2c0
4200bd28:	f9e816        	beqz	a8, 4200bcca <_vfprintf_r+0x1ea>
4200bd2b:	aa2182        	l32i	a8, a1, 0x2a8
4200bd2e:	f98816        	beqz	a8, 4200bcca <_vfprintf_r+0x1ea>
4200bd31:	000882        	l8ui	a8, a8, 0
4200bd34:	f92816        	beqz	a8, 4200bcca <_vfprintf_r+0x1ea>
4200bd37:	00a482        	movi	a8, 0x400
4200bd3a:	00c946        	j	4200c063 <_vfprintf_r+0x583>
4200bd3d:	10c182        	addi	a8, a1, 16
4200bd40:	02d882        	addmi	a8, a8, 0x200
4200bd43:	520892        	l8ui	a9, a8, 82
4200bd46:	f80956        	bnez	a9, 4200bcca <_vfprintf_r+0x1ea>
4200bd49:	092c      	movi.n	a9, 32
4200bd4b:	004ac6        	j	4200be7a <_vfprintf_r+0x39a>
4200bd4e:	180c      	movi.n	a8, 1
4200bd50:	00c3c6        	j	4200c063 <_vfprintf_r+0x583>
4200bd53:	a82182        	l32i	a8, a1, 0x2a0
4200bd56:	9a0c      	movi.n	a10, 9
4200bd58:	000882        	l8ui	a8, a8, 0
4200bd5b:	d0c892        	addi	a9, a8, -48
4200bd5e:	463a97        	bltu	a10, a9, 4200bda8 <_vfprintf_r+0x2c8>
4200bd61:	a82192        	l32i	a9, a1, 0x2a0
4200bd64:	0a0c      	movi.n	a10, 0
4200bd66:	991b      	addi.n	a9, a9, 1
4200bd68:	a36192        	s32i	a9, a1, 0x28c
4200bd6b:	9b0c      	movi.n	a11, 9
4200bd6d:	d0c882        	addi	a8, a8, -48
4200bd70:	a0aaa0        	addx4	a10, a10, a10
4200bd73:	90aa80        	addx2	a10, a10, a8
4200bd76:	a32182        	l32i	a8, a1, 0x28c
4200bd79:	a32192        	l32i	a9, a1, 0x28c
4200bd7c:	000882        	l8ui	a8, a8, 0
4200bd7f:	991b      	addi.n	a9, a9, 1
4200bd81:	a36192        	s32i	a9, a1, 0x28c
4200bd84:	d0c892        	addi	a9, a8, -48
4200bd87:	e2bb97        	bgeu	a11, a9, 4200bd6d <_vfprintf_r+0x28d>
4200bd8a:	492c      	movi.n	a9, 36
4200bd8c:	021897        	beq	a8, a9, 4200bd92 <_vfprintf_r+0x2b2>
4200bd8f:	ffcd46        	j	4200bcc8 <_vfprintf_r+0x1e8>
4200bd92:	082c      	movi.n	a8, 32
4200bd94:	02a8a7        	bge	a8, a10, 4200bd9a <_vfprintf_r+0x2ba>
4200bd97:	0a4c46        	j	4200e6cc <_vfprintf_r+0x2bec>
4200bd9a:	972182        	l32i	a8, a1, 0x25c
4200bd9d:	aa0b      	addi.n	a10, a10, -1
4200bd9f:	10c1e2        	addi	a14, a1, 16
4200bda2:	122a87        	blt	a10, a8, 4200bdb8 <_vfprintf_r+0x2d8>
4200bda5:	0005c6        	j	4200bdc0 <_vfprintf_r+0x2e0>
4200bda8:	9721b2        	l32i	a11, a1, 0x25c
4200bdab:	a71b      	addi.n	a10, a7, 1
4200bdad:	10c192        	addi	a9, a1, 16
4200bdb0:	3527b7        	blt	a7, a11, 4200bde9 <_vfprintf_r+0x309>
4200bdb3:	000e06        	j	4200bdef <_vfprintf_r+0x30f>
4200bdb6:	e00000        	subx4	a0, a0, a0
4200bdb9:	b0ea      	add.n	a11, a0, a14
4200bdbb:	0e88      	l32i.n	a8, a14, 0
4200bdbd:	000686        	j	4200bddb <_vfprintf_r+0x2fb>
4200bdc0:	48a282        	movi	a8, 0x248
4200bdc3:	8e8a      	add.n	a8, a14, a8
4200bdc5:	4ca2d2        	movi	a13, 0x24c
4200bdc8:	60a2c2        	movi	a12, 0x260
4200bdcb:	0189      	s32i.n	a8, a1, 0
4200bdcd:	01def2        	addmi	a15, a14, 0x100
4200bdd0:	deda      	add.n	a13, a14, a13
4200bdd2:	ceca      	add.n	a12, a14, a12
4200bdd4:	05bd      	mov.n	a11, a5
4200bdd6:	ff83a5        	call8	4200b610 <get_arg$isra$0>
4200bdd9:	0a88      	l32i.n	a8, a10, 0
4200bddb:	ac6182        	s32i	a8, a1, 0x2b0
4200bdde:	a32182        	l32i	a8, a1, 0x28c
4200bde1:	07ad      	mov.n	a10, a7
4200bde3:	a86182        	s32i	a8, a1, 0x2a0
4200bde6:	001d46        	j	4200be5f <_vfprintf_r+0x37f>
4200bde9:	b09690        	addx8	a9, a6, a9
4200bdec:	001a86        	j	4200be5a <_vfprintf_r+0x37a>
4200bdef:	9a29c2        	l32i	a12, a9, 0x268
4200bdf2:	fd1c      	movi.n	a13, 31
4200bdf4:	02d992        	addmi	a9, a9, 0x200
4200bdf7:	8c4b      	addi.n	a8, a12, 4
4200bdf9:	372db7        	blt	a13, a11, 4200be34 <_vfprintf_r+0x354>
4200bdfc:	db1b      	addi.n	a13, a11, 1
4200bdfe:	9761d2        	s32i	a13, a1, 0x25c
4200be01:	1a6982        	s32i	a8, a9, 104
4200be04:	8d1c      	movi.n	a13, 24
4200be06:	062d87        	blt	a13, a8, 4200be10 <_vfprintf_r+0x330>
4200be09:	192992        	l32i	a9, a9, 100
4200be0c:	000446        	j	4200be21 <_vfprintf_r+0x341>
4200be0f:	2dc700        	lsi	f0, a7, 180
4200be12:	482c01        	l32r	a0, 41fddec4 <_coredump_iram_end+0x1c5bfc4>
4200be15:	10c192        	addi	a9, a1, 16
4200be18:	02d992        	addmi	a9, a9, 0x200
4200be1b:	182992        	l32i	a9, a9, 96
4200be1e:	9e6182        	s32i	a8, a1, 0x278
4200be21:	998a      	add.n	a9, a9, a8
4200be23:	fcc992        	addi	a9, a9, -4
4200be26:	0988      	l32i.n	a8, a9, 0
4200be28:	b0bb10        	addx8	a11, a11, a1
4200be2b:	ac6182        	s32i	a8, a1, 0x2b0
4200be2e:	4b89      	s32i.n	a8, a11, 16
4200be30:	000ac6        	j	4200be5f <_vfprintf_r+0x37f>
4200be33:	698200        	lsi	f0, a2, 0x1a4
4200be36:	1c1a      	add.n	a1, a12, a1
4200be38:	878b      	addi.n	a8, a7, 8
4200be3a:	072b      	addi.n	a0, a7, 2
4200be3c:	192992        	l32i	a9, a9, 100
4200be3f:	000486        	j	4200be55 <_vfprintf_r+0x375>
4200be42:	c70000        	lsi	f0, a0, 0x31c
4200be45:	012b      	addi.n	a0, a1, 2
4200be47:	482c      	movi.n	a8, 36
4200be49:	10c192        	addi	a9, a1, 16
4200be4c:	02d992        	addmi	a9, a9, 0x200
4200be4f:	182992        	l32i	a9, a9, 96
4200be52:	9e6182        	s32i	a8, a1, 0x278
4200be55:	998a      	add.n	a9, a9, a8
4200be57:	fcc992        	addi	a9, a9, -4
4200be5a:	0988      	l32i.n	a8, a9, 0
4200be5c:	ac6182        	s32i	a8, a1, 0x2b0
4200be5f:	ac2182        	l32i	a8, a1, 0x2b0
4200be62:	0a7d      	mov.n	a7, a10
4200be64:	e628d6        	bgez	a8, 4200bcca <_vfprintf_r+0x1ea>
4200be67:	608080        	neg	a8, a8
4200be6a:	ac6182        	s32i	a8, a1, 0x2b0
4200be6d:	480c      	movi.n	a8, 4
4200be6f:	007c06        	j	4200c063 <_vfprintf_r+0x583>
4200be72:	10c182        	addi	a8, a1, 16
4200be75:	02d882        	addmi	a8, a8, 0x200
4200be78:	b92c      	movi.n	a9, 43
4200be7a:	524892        	s8i	a9, a8, 82
4200be7d:	ff9246        	j	4200bcca <_vfprintf_r+0x1ea>
4200be80:	a82182        	l32i	a8, a1, 0x2a0
4200be83:	981b      	addi.n	a9, a8, 1
4200be85:	000882        	l8ui	a8, a8, 0
4200be88:	a36182        	s32i	a8, a1, 0x28c
4200be8b:	a321b2        	l32i	a11, a1, 0x28c
4200be8e:	a82c      	movi.n	a8, 42
4200be90:	081b87        	beq	a11, a8, 4200be9c <_vfprintf_r+0x3bc>
4200be93:	080c      	movi.n	a8, 0
4200be95:	9c0c      	movi.n	a12, 9
4200be97:	0047c6        	j	4200bfba <_vfprintf_r+0x4da>
4200be9a:	820000        	mull	a0, a0, a0
4200be9d:	0ca821        	l32r	a2, 41fcf140 <_coredump_iram_end+0x1c4d240>
4200bea0:	829b      	addi.n	a8, a2, 9
4200bea2:	0108      	l32i.n	a0, a1, 0
4200bea4:	d0c8a2        	addi	a10, a8, -48
4200bea7:	453ba7        	bltu	a11, a10, 4200bef0 <_vfprintf_r+0x410>
4200beaa:	a821a2        	l32i	a10, a1, 0x2a0
4200bead:	aa2b      	addi.n	a10, a10, 2
4200beaf:	a361a2        	s32i	a10, a1, 0x28c
4200beb2:	0a0c      	movi.n	a10, 0
4200beb4:	d0c882        	addi	a8, a8, -48
4200beb7:	a0aaa0        	addx4	a10, a10, a10
4200beba:	90aa80        	addx2	a10, a10, a8
4200bebd:	a32182        	l32i	a8, a1, 0x28c
4200bec0:	a321c2        	l32i	a12, a1, 0x28c
4200bec3:	000882        	l8ui	a8, a8, 0
4200bec6:	cc1b      	addi.n	a12, a12, 1
4200bec8:	a361c2        	s32i	a12, a1, 0x28c
4200becb:	d0c8c2        	addi	a12, a8, -48
4200bece:	e2bbc7        	bgeu	a11, a12, 4200beb4 <_vfprintf_r+0x3d4>
4200bed1:	4b2c      	movi.n	a11, 36
4200bed3:	0218b7        	beq	a8, a11, 4200bed9 <_vfprintf_r+0x3f9>
4200bed6:	ff7ac6        	j	4200bcc5 <_vfprintf_r+0x1e5>
4200bed9:	082c      	movi.n	a8, 32
4200bedb:	02a8a7        	bge	a8, a10, 4200bee1 <_vfprintf_r+0x401>
4200bede:	09fa86        	j	4200e6cc <_vfprintf_r+0x2bec>
4200bee1:	972182        	l32i	a8, a1, 0x25c
4200bee4:	aa0b      	addi.n	a10, a10, -1
4200bee6:	10c1e2        	addi	a14, a1, 16
4200bee9:	132a87        	blt	a10, a8, 4200bf00 <_vfprintf_r+0x420>
4200beec:	000606        	j	4200bf08 <_vfprintf_r+0x428>
4200beef:	21a200        	srai	a10, a0, 2
4200bef2:	c71b97        	beq	a11, a9, 4200bebd <_vfprintf_r+0x3dd>
4200bef5:	10c182        	addi	a8, a1, 16
4200bef8:	3027a7        	blt	a7, a10, 4200bf2c <_vfprintf_r+0x44c>
4200befb:	000cc6        	j	4200bf32 <_vfprintf_r+0x452>
4200befe:	e00000        	subx4	a0, a0, a0
4200bf01:	b0ea      	add.n	a11, a0, a14
4200bf03:	0e88      	l32i.n	a8, a14, 0
4200bf05:	000686        	j	4200bf23 <_vfprintf_r+0x443>
4200bf08:	48a282        	movi	a8, 0x248
4200bf0b:	8e8a      	add.n	a8, a14, a8
4200bf0d:	4ca2d2        	movi	a13, 0x24c
4200bf10:	60a2c2        	movi	a12, 0x260
4200bf13:	0189      	s32i.n	a8, a1, 0
4200bf15:	01def2        	addmi	a15, a14, 0x100
4200bf18:	deda      	add.n	a13, a14, a13
4200bf1a:	ceca      	add.n	a12, a14, a12
4200bf1c:	05bd      	mov.n	a11, a5
4200bf1e:	ff6f25        	call8	4200b610 <get_arg$isra$0>
4200bf21:	0a88      	l32i.n	a8, a10, 0
4200bf23:	a32192        	l32i	a9, a1, 0x28c
4200bf26:	07cd      	mov.n	a12, a7
4200bf28:	001c06        	j	4200bf9c <_vfprintf_r+0x4bc>
4200bf2b:	868000        	lsi	f0, a0, 0x218
4200bf2e:	19c6b0        	lsi	f11, a6, 100
4200bf31:	fb1c00        	f64addc	a0, a12, 0, 1
4200bf34:	352ba7        	blt	a11, a10, 4200bf6d <_vfprintf_r+0x48d>
4200bf37:	9a28e2        	l32i	a14, a8, 0x268
4200bf3a:	ba1b      	addi.n	a11, a10, 1
4200bf3c:	9761b2        	s32i	a11, a1, 0x25c
4200bf3f:	be4b      	addi.n	a11, a14, 4
4200bf41:	9a68b2        	s32i	a11, a8, 0x268
4200bf44:	8f1c      	movi.n	a15, 24
4200bf46:	062fb7        	blt	a15, a11, 4200bf50 <_vfprintf_r+0x470>
4200bf49:	992882        	l32i	a8, a8, 0x264
4200bf4c:	000386        	j	4200bf5e <_vfprintf_r+0x47e>
4200bf4f:	2fe700        	f64cmph	a14, a7, a0, 2
4200bf52:	4b2c01        	l32r	a0, 41fdec04 <_coredump_iram_end+0x1c5cd04>
4200bf55:	9a68b2        	s32i	a11, a8, 0x268
4200bf58:	02d882        	addmi	a8, a8, 0x200
4200bf5b:	182882        	l32i	a8, a8, 96
4200bf5e:	88ba      	add.n	a8, a8, a11
4200bf60:	fcc882        	addi	a8, a8, -4
4200bf63:	0888      	l32i.n	a8, a8, 0
4200bf65:	b0aa10        	addx8	a10, a10, a1
4200bf68:	4a89      	s32i.n	a8, a10, 16
4200bf6a:	000b86        	j	4200bf9c <_vfprintf_r+0x4bc>
4200bf6d:	9a28b2        	l32i	a11, a8, 0x268
4200bf70:	8d1c      	movi.n	a13, 24
4200bf72:	ab4b      	addi.n	a10, a11, 4
4200bf74:	9a68a2        	s32i	a10, a8, 0x268
4200bf77:	02d882        	addmi	a8, a8, 0x200
4200bf7a:	062da7        	blt	a13, a10, 4200bf84 <_vfprintf_r+0x4a4>
4200bf7d:	192882        	l32i	a8, a8, 100
4200bf80:	000446        	j	4200bf95 <_vfprintf_r+0x4b5>
4200bf83:	2db700        	lsi	f0, a7, 180
4200bf86:	4a2c01        	l32r	a0, 41fde838 <_coredump_iram_end+0x1c5c938>
4200bf89:	10c182        	addi	a8, a1, 16
4200bf8c:	02d882        	addmi	a8, a8, 0x200
4200bf8f:	182882        	l32i	a8, a8, 96
4200bf92:	9e61a2        	s32i	a10, a1, 0x278
4200bf95:	88aa      	add.n	a8, a8, a10
4200bf97:	fcc882        	addi	a8, a8, -4
4200bf9a:	0888      	l32i.n	a8, a8, 0
4200bf9c:	fa7c      	movi.n	a10, -1
4200bf9e:	5388a0        	max	a8, a8, a10
4200bfa1:	a26182        	s32i	a8, a1, 0x288
4200bfa4:	0c7d      	mov.n	a7, a12
4200bfa6:	a86192        	s32i	a9, a1, 0x2a0
4200bfa9:	ff4746        	j	4200bcca <_vfprintf_r+0x1ea>
4200bfac:	a08880        	addx4	a8, a8, a8
4200bfaf:	9088b0        	addx2	a8, a8, a11
4200bfb2:	0009b2        	l8ui	a11, a9, 0
4200bfb5:	991b      	addi.n	a9, a9, 1
4200bfb7:	a361b2        	s32i	a11, a1, 0x28c
4200bfba:	a321b2        	l32i	a11, a1, 0x28c
4200bfbd:	a86192        	s32i	a9, a1, 0x2a0
4200bfc0:	d0cbb2        	addi	a11, a11, -48
4200bfc3:	e5bcb7        	bgeu	a12, a11, 4200bfac <_vfprintf_r+0x4cc>
4200bfc6:	f97c      	movi.n	a9, -1
4200bfc8:	538890        	max	a8, a8, a9
4200bfcb:	a26182        	s32i	a8, a1, 0x288
4200bfce:	ac2182        	l32i	a8, a1, 0x2b0
4200bfd1:	ff4206        	j	4200bcdd <_vfprintf_r+0x1fd>
4200bfd4:	820000        	mull	a0, a0, a0
4200bfd7:	8680a0        	lsi	f10, a0, 0x218
4200bfda:	0c0021        	l32r	a2, 41fcefdc <_coredump_iram_end+0x1c4d0dc>
4200bfdd:	0c08      	l32i.n	a0, a12, 0
4200bfdf:	929b      	addi.n	a9, a2, 9
4200bfe1:	80a321        	l32r	a2, 41fec270 <_coredump_iram_end+0x1c6a370>
4200bfe4:	a088      	l32i.n	a8, a0, 40
4200bfe6:	d0c992        	addi	a9, a9, -48
4200bfe9:	908890        	addx2	a8, a8, a9
4200bfec:	a82192        	l32i	a9, a1, 0x2a0
4200bfef:	000992        	l8ui	a9, a9, 0
4200bff2:	a36192        	s32i	a9, a1, 0x28c
4200bff5:	a82192        	l32i	a9, a1, 0x2a0
4200bff8:	991b      	addi.n	a9, a9, 1
4200bffa:	a86192        	s32i	a9, a1, 0x2a0
4200bffd:	a32192        	l32i	a9, a1, 0x28c
4200c000:	d0c992        	addi	a9, a9, -48
4200c003:	d9bb97        	bgeu	a11, a9, 4200bfe0 <_vfprintf_r+0x500>
4200c006:	a321b2        	l32i	a11, a1, 0x28c
4200c009:	492c      	movi.n	a9, 36
4200c00b:	021b97        	beq	a11, a9, 4200c011 <_vfprintf_r+0x531>
4200c00e:	ff32c6        	j	4200bcdd <_vfprintf_r+0x1fd>
4200c011:	092c      	movi.n	a9, 32
4200c013:	02a987        	bge	a9, a8, 4200c019 <_vfprintf_r+0x539>
4200c016:	09ac86        	j	4200e6cc <_vfprintf_r+0x2bec>
4200c019:	680b      	addi.n	a6, a8, -1
4200c01b:	140c      	movi.n	a4, 1
4200c01d:	ff2a46        	j	4200bcca <_vfprintf_r+0x1ea>
4200c020:	880c00        	lsi	f0, a12, 0x220
4200c023:	000f06        	j	4200c063 <_vfprintf_r+0x583>
4200c026:	a82182        	l32i	a8, a1, 0x2a0
4200c029:	000892        	l8ui	a9, a8, 0
4200c02c:	68a082        	movi	a8, 104
4200c02f:	0d9987        	bne	a9, a8, 4200c040 <_vfprintf_r+0x560>
4200c032:	a82182        	l32i	a8, a1, 0x2a0
4200c035:	881b      	addi.n	a8, a8, 1
4200c037:	a86182        	s32i	a8, a1, 0x2a0
4200c03a:	00a282        	movi	a8, 0x200
4200c03d:	000886        	j	4200c063 <_vfprintf_r+0x583>
4200c040:	084c      	movi.n	a8, 64
4200c042:	000746        	j	4200c063 <_vfprintf_r+0x583>
4200c045:	a82182        	l32i	a8, a1, 0x2a0
4200c048:	000892        	l8ui	a9, a8, 0
4200c04b:	6ca082        	movi	a8, 108
4200c04e:	0a9987        	bne	a9, a8, 4200c05c <_vfprintf_r+0x57c>
4200c051:	a82182        	l32i	a8, a1, 0x2a0
4200c054:	881b      	addi.n	a8, a8, 1
4200c056:	a86182        	s32i	a8, a1, 0x2a0
4200c059:	000106        	j	4200c061 <_vfprintf_r+0x581>
4200c05c:	081c      	movi.n	a8, 16
4200c05e:	000046        	j	4200c063 <_vfprintf_r+0x583>
4200c061:	082c      	movi.n	a8, 32
4200c063:	203380        	or	a3, a3, a8
4200c066:	ff1806        	j	4200bcca <_vfprintf_r+0x1ea>
4200c069:	972192        	l32i	a9, a1, 0x25c
4200c06c:	10c1e2        	addi	a14, a1, 16
4200c06f:	d4ac      	beqz.n	a4, 4200c0a0 <_vfprintf_r+0x5c0>
4200c071:	08a697        	bge	a6, a9, 4200c07d <_vfprintf_r+0x59d>
4200c074:	b0e6e0        	addx8	a14, a6, a14
4200c077:	000e82        	l8ui	a8, a14, 0
4200c07a:	000746        	j	4200c09b <_vfprintf_r+0x5bb>
4200c07d:	48a282        	movi	a8, 0x248
4200c080:	8e8a      	add.n	a8, a14, a8
4200c082:	4ca2d2        	movi	a13, 0x24c
4200c085:	60a2c2        	movi	a12, 0x260
4200c088:	0189      	s32i.n	a8, a1, 0
4200c08a:	01def2        	addmi	a15, a14, 0x100
4200c08d:	deda      	add.n	a13, a14, a13
4200c08f:	ceca      	add.n	a12, a14, a12
4200c091:	05bd      	mov.n	a11, a5
4200c093:	06ad      	mov.n	a10, a6
4200c095:	ff57a5        	call8	4200b610 <get_arg$isra$0>
4200c098:	000a82        	l8ui	a8, a10, 0
4200c09b:	07ad      	mov.n	a10, a7
4200c09d:	001f06        	j	4200c11d <_vfprintf_r+0x63d>
4200c0a0:	a71b      	addi.n	a10, a7, 1
4200c0a2:	0aa797        	bge	a7, a9, 4200c0b0 <_vfprintf_r+0x5d0>
4200c0a5:	b0e6e0        	addx8	a14, a6, a14
4200c0a8:	000e82        	l8ui	a8, a14, 0
4200c0ab:	001b86        	j	4200c11d <_vfprintf_r+0x63d>
4200c0ae:	b20000        	mulsh	a0, a0, a0
4200c0b1:	2e          	.byte	0x2e
4200c0b2:	1c9a      	add.n	a1, a12, a9
4200c0b4:	e2fc      	bnez.n	a2, 4200c0f6 <_vfprintf_r+0x616>
4200c0b6:	de          	.byte	0xde
4200c0b7:	8b4b02        	s8i	a0, a11, 139
4200c0ba:	362c97        	blt	a12, a9, 4200c0f4 <_vfprintf_r+0x614>
4200c0bd:	c91b      	addi.n	a12, a9, 1
4200c0bf:	9761c2        	s32i	a12, a1, 0x25c
4200c0c2:	1a6e82        	s32i	a8, a14, 104
4200c0c5:	8c1c      	movi.n	a12, 24
4200c0c7:	052c87        	blt	a12, a8, 4200c0d0 <_vfprintf_r+0x5f0>
4200c0ca:	192eb2        	l32i	a11, a14, 100
4200c0cd:	000406        	j	4200c0e1 <_vfprintf_r+0x601>
4200c0d0:	012cb7        	blt	a12, a11, 4200c0d5 <_vfprintf_r+0x5f5>
4200c0d3:	482c      	movi.n	a8, 36
4200c0d5:	10c1b2        	addi	a11, a1, 16
4200c0d8:	02dbb2        	addmi	a11, a11, 0x200
4200c0db:	182bb2        	l32i	a11, a11, 96
4200c0de:	9e6182        	s32i	a8, a1, 0x278
4200c0e1:	bb8a      	add.n	a11, a11, a8
4200c0e3:	fccbb2        	addi	a11, a11, -4
4200c0e6:	0b88      	l32i.n	a8, a11, 0
4200c0e8:	b09910        	addx8	a9, a9, a1
4200c0eb:	4989      	s32i.n	a8, a9, 16
4200c0ed:	748080        	extui	a8, a8, 0, 8
4200c0f0:	000a46        	j	4200c11d <_vfprintf_r+0x63d>
4200c0f3:	6e8200        	f64rnd	a8, a2, a0, 2
4200c0f6:	1c1a      	add.n	a1, a12, a1
4200c0f8:	8789      	s32i.n	a8, a7, 32
4200c0fa:	0729      	s32i.n	a2, a7, 0
4200c0fc:	192e92        	l32i	a9, a14, 100
4200c0ff:	000486        	j	4200c115 <_vfprintf_r+0x635>
4200c102:	b70000        	lsi	f0, a0, 0x2dc
4200c105:	0129      	s32i.n	a2, a1, 0
4200c107:	482c      	movi.n	a8, 36
4200c109:	10c192        	addi	a9, a1, 16
4200c10c:	02d992        	addmi	a9, a9, 0x200
4200c10f:	182992        	l32i	a9, a9, 96
4200c112:	9e6182        	s32i	a8, a1, 0x278
4200c115:	998a      	add.n	a9, a9, a8
4200c117:	fcc992        	addi	a9, a9, -4
4200c11a:	000982        	l8ui	a8, a9, 0
4200c11d:	10c192        	addi	a9, a1, 16
4200c120:	01d9b2        	addmi	a11, a9, 0x100
4200c123:	804b82        	s8i	a8, a11, 128
4200c126:	02d982        	addmi	a8, a9, 0x200
4200c129:	0b0c      	movi.n	a11, 0
4200c12b:	5248b2        	s8i	a11, a8, 82
4200c12e:	080c      	movi.n	a8, 0
4200c130:	a96182        	s32i	a8, a1, 0x2a4
4200c133:	180c      	movi.n	a8, 1
4200c135:	a26182        	s32i	a8, a1, 0x288
4200c138:	080c      	movi.n	a8, 0
4200c13a:	ab6182        	s32i	a8, a1, 0x2ac
4200c13d:	0a7d      	mov.n	a7, a10
4200c13f:	040c      	movi.n	a4, 0
4200c141:	050c      	movi.n	a5, 0
4200c143:	060c      	movi.n	a6, 0
4200c145:	80a182        	movi	a8, 0x180
4200c148:	069e06        	j	4200dbc4 <_vfprintf_r+0x20e4>
4200c14b:	1c0000        	lsi	f0, a0, 112
4200c14e:	8008      	l32i.n	a0, a0, 32
4200c150:	822033        	lsi	f3, a0, 0x208
4200c153:	e29721        	l32r	a2, 42004bb0 <esp_mprot_get_pms_area+0xb4> (82048580 <_rtc_reserved_end+0x21f48580>)
4200c156:	5710c1        	l32r	a12, 41fe1d98 <_coredump_iram_end+0x1c5fe98>
4200c159:	4602e3        	lsi	f14, a2, 0x118
4200c15c:	2f          	.byte	0x2f
4200c15d:	f4ac00        	extui	a10, a0, 12, 16
4200c160:	09a687        	bge	a6, a8, 4200c16d <_vfprintf_r+0x68d>
4200c163:	b0e6e0        	addx8	a14, a6, a14
4200c166:	0e58      	l32i.n	a5, a14, 0
4200c168:	1e48      	l32i.n	a4, a14, 4
4200c16a:	000786        	j	4200c18c <_vfprintf_r+0x6ac>
4200c16d:	48a282        	movi	a8, 0x248
4200c170:	8e8a      	add.n	a8, a14, a8
4200c172:	4ca2d2        	movi	a13, 0x24c
4200c175:	60a2c2        	movi	a12, 0x260
4200c178:	05bd      	mov.n	a11, a5
4200c17a:	0189      	s32i.n	a8, a1, 0
4200c17c:	01def2        	addmi	a15, a14, 0x100
4200c17f:	deda      	add.n	a13, a14, a13
4200c181:	ceca      	add.n	a12, a14, a12
4200c183:	06ad      	mov.n	a10, a6
4200c185:	ff48a5        	call8	4200b610 <get_arg$isra$0>
4200c188:	0a58      	l32i.n	a5, a10, 0
4200c18a:	1a48      	l32i.n	a4, a10, 4
4200c18c:	07ad      	mov.n	a10, a7
4200c18e:	00ab46        	j	4200c43f <_vfprintf_r+0x95f>
4200c191:	a71b      	addi.n	a10, a7, 1
4200c193:	09a787        	bge	a7, a8, 4200c1a0 <_vfprintf_r+0x6c0>
4200c196:	b0e6e0        	addx8	a14, a6, a14
4200c199:	0e58      	l32i.n	a5, a14, 0
4200c19b:	1e48      	l32i.n	a4, a14, 4
4200c19d:	00a786        	j	4200c43f <_vfprintf_r+0x95f>
4200c1a0:	9a2eb2        	l32i	a11, a14, 0x268
4200c1a3:	897c      	movi.n	a9, -8
4200c1a5:	bb7b      	addi.n	a11, a11, 7
4200c1a7:	10bb90        	and	a11, a11, a9
4200c1aa:	fc1c      	movi.n	a12, 31
4200c1ac:	02dee2        	addmi	a14, a14, 0x200
4200c1af:	9b8b      	addi.n	a9, a11, 8
4200c1b1:	3b2c87        	blt	a12, a8, 4200c1f0 <_vfprintf_r+0x710>
4200c1b4:	c81b      	addi.n	a12, a8, 1
4200c1b6:	9761c2        	s32i	a12, a1, 0x25c
4200c1b9:	1a6e92        	s32i	a9, a14, 104
4200c1bc:	8c1c      	movi.n	a12, 24
4200c1be:	062c97        	blt	a12, a9, 4200c1c8 <_vfprintf_r+0x6e8>
4200c1c1:	192eb2        	l32i	a11, a14, 100
4200c1c4:	000446        	j	4200c1d9 <_vfprintf_r+0x6f9>
4200c1c7:	2cb700        	lsi	f0, a7, 176
4200c1ca:	892c01        	l32r	a0, 41fee67c <_coredump_iram_end+0x1c6c77c>
4200c1cd:	10c1b2        	addi	a11, a1, 16
4200c1d0:	02dbb2        	addmi	a11, a11, 0x200
4200c1d3:	182bb2        	l32i	a11, a11, 96
4200c1d6:	9e6192        	s32i	a9, a1, 0x278
4200c1d9:	9b9a      	add.n	a9, a11, a9
4200c1db:	f8c992        	addi	a9, a9, -8
4200c1de:	0958      	l32i.n	a5, a9, 0
4200c1e0:	1948      	l32i.n	a4, a9, 4
4200c1e2:	10c192        	addi	a9, a1, 16
4200c1e5:	b08890        	addx8	a8, a8, a9
4200c1e8:	0859      	s32i.n	a5, a8, 0
4200c1ea:	1849      	s32i.n	a4, a8, 4
4200c1ec:	0093c6        	j	4200c43f <_vfprintf_r+0x95f>
4200c1ef:	6e9200        	f64rnd	a9, a2, a0, 2
4200c1f2:	1c1a      	add.n	a1, a12, a1
4200c1f4:	9788      	l32i.n	a8, a7, 36
4200c1f6:	0528      	l32i.n	a2, a5, 0
4200c1f8:	192e82        	l32i	a8, a14, 100
4200c1fb:	000446        	j	4200c210 <_vfprintf_r+0x730>
4200c1fe:	0228b7        	blt	a8, a11, 4200c204 <_vfprintf_r+0x724>
4200c201:	28a092        	movi	a9, 40
4200c204:	10c182        	addi	a8, a1, 16
4200c207:	02d882        	addmi	a8, a8, 0x200
4200c20a:	182882        	l32i	a8, a8, 96
4200c20d:	9e6192        	s32i	a9, a1, 0x278
4200c210:	889a      	add.n	a8, a8, a9
4200c212:	f8c882        	addi	a8, a8, -8
4200c215:	0858      	l32i.n	a5, a8, 0
4200c217:	1848      	l32i.n	a4, a8, 4
4200c219:	008886        	j	4200c43f <_vfprintf_r+0x95f>
4200c21c:	02e347        	bbsi	a3, 4, 4200c222 <_vfprintf_r+0x742>
4200c21f:	002a46        	j	4200c2cc <_vfprintf_r+0x7ec>
4200c222:	b4ac      	beqz.n	a4, 4200c251 <_vfprintf_r+0x771>
4200c224:	09a687        	bge	a6, a8, 4200c231 <_vfprintf_r+0x751>
4200c227:	b0e6e0        	addx8	a14, a6, a14
4200c22a:	0e58      	l32i.n	a5, a14, 0
4200c22c:	0033c6        	j	4200c2ff <_vfprintf_r+0x81f>
4200c22f:	820000        	mull	a0, a0, a0
4200c232:	8a48a2        	s8i	a10, a8, 138
4200c235:	8e          	.byte	0x8e
4200c236:	4ca2d2        	movi	a13, 0x24c
4200c239:	60a2c2        	movi	a12, 0x260
4200c23c:	05bd      	mov.n	a11, a5
4200c23e:	0189      	s32i.n	a8, a1, 0
4200c240:	01def2        	addmi	a15, a14, 0x100
4200c243:	deda      	add.n	a13, a14, a13
4200c245:	ceca      	add.n	a12, a14, a12
4200c247:	06ad      	mov.n	a10, a6
4200c249:	ff3c65        	call8	4200b610 <get_arg$isra$0>
4200c24c:	0a58      	l32i.n	a5, a10, 0
4200c24e:	002b46        	j	4200c2ff <_vfprintf_r+0x81f>
4200c251:	a71b      	addi.n	a10, a7, 1
4200c253:	09a787        	bge	a7, a8, 4200c260 <_vfprintf_r+0x780>
4200c256:	b0e6e0        	addx8	a14, a6, a14
4200c259:	0e58      	l32i.n	a5, a14, 0
4200c25b:	007746        	j	4200c43c <_vfprintf_r+0x95c>
4200c25e:	b20000        	mulsh	a0, a0, a0
4200c261:	2e          	.byte	0x2e
4200c262:	1c9a      	add.n	a1, a12, a9
4200c264:	e2fc      	bnez.n	a2, 4200c2a6 <_vfprintf_r+0x7c6>
4200c266:	de          	.byte	0xde
4200c267:	9b4b02        	s8i	a0, a11, 155
4200c26a:	322c87        	blt	a12, a8, 4200c2a0 <_vfprintf_r+0x7c0>
4200c26d:	c81b      	addi.n	a12, a8, 1
4200c26f:	9761c2        	s32i	a12, a1, 0x25c
4200c272:	1a6e92        	s32i	a9, a14, 104
4200c275:	8c1c      	movi.n	a12, 24
4200c277:	052c97        	blt	a12, a9, 4200c280 <_vfprintf_r+0x7a0>
4200c27a:	192eb2        	l32i	a11, a14, 100
4200c27d:	000406        	j	4200c291 <_vfprintf_r+0x7b1>
4200c280:	012cb7        	blt	a12, a11, 4200c285 <_vfprintf_r+0x7a5>
4200c283:	492c      	movi.n	a9, 36
4200c285:	10c1b2        	addi	a11, a1, 16
4200c288:	02dbb2        	addmi	a11, a11, 0x200
4200c28b:	182bb2        	l32i	a11, a11, 96
4200c28e:	9e6192        	s32i	a9, a1, 0x278
4200c291:	bb9a      	add.n	a11, a11, a9
4200c293:	fccbb2        	addi	a11, a11, -4
4200c296:	0b58      	l32i.n	a5, a11, 0
4200c298:	b08810        	addx8	a8, a8, a1
4200c29b:	4859      	s32i.n	a5, a8, 16
4200c29d:	0066c6        	j	4200c43c <_vfprintf_r+0x95c>
4200c2a0:	1a6e92        	s32i	a9, a14, 104
4200c2a3:	881c      	movi.n	a8, 24
4200c2a5:	072897        	blt	a8, a9, 4200c2b0 <_vfprintf_r+0x7d0>
4200c2a8:	192e82        	l32i	a8, a14, 100
4200c2ab:	000486        	j	4200c2c1 <_vfprintf_r+0x7e1>
4200c2ae:	b70000        	lsi	f0, a0, 0x2dc
4200c2b1:	0128      	l32i.n	a2, a1, 0
4200c2b3:	492c      	movi.n	a9, 36
4200c2b5:	10c182        	addi	a8, a1, 16
4200c2b8:	02d882        	addmi	a8, a8, 0x200
4200c2bb:	182882        	l32i	a8, a8, 96
4200c2be:	9e6192        	s32i	a9, a1, 0x278
4200c2c1:	889a      	add.n	a8, a8, a9
4200c2c3:	fcc882        	addi	a8, a8, -4
4200c2c6:	0858      	l32i.n	a5, a8, 0
4200c2c8:	005c06        	j	4200c43c <_vfprintf_r+0x95c>
4200c2cb:	e36700        	lsi	f0, a7, 0x38c
4200c2ce:	2c4602        	s8i	a0, a6, 44
4200c2d1:	e4ac00        	extui	a10, a0, 12, 15
4200c2d4:	09a687        	bge	a6, a8, 4200c2e1 <_vfprintf_r+0x801>
4200c2d7:	b0e6e0        	addx8	a14, a6, a14
4200c2da:	009e52        	l16si	a5, a14, 0
4200c2dd:	000786        	j	4200c2ff <_vfprintf_r+0x81f>
4200c2e0:	a28200        	muluh	a8, a2, a0
4200c2e3:	8a48      	l32i.n	a4, a10, 32
4200c2e5:	8e          	.byte	0x8e
4200c2e6:	4ca2d2        	movi	a13, 0x24c
4200c2e9:	60a2c2        	movi	a12, 0x260
4200c2ec:	05bd      	mov.n	a11, a5
4200c2ee:	0189      	s32i.n	a8, a1, 0
4200c2f0:	01def2        	addmi	a15, a14, 0x100
4200c2f3:	deda      	add.n	a13, a14, a13
4200c2f5:	ceca      	add.n	a12, a14, a12
4200c2f7:	06ad      	mov.n	a10, a6
4200c2f9:	ff3165        	call8	4200b610 <get_arg$isra$0>
4200c2fc:	009a52        	l16si	a5, a10, 0
4200c2ff:	07ad      	mov.n	a10, a7
4200c301:	004dc6        	j	4200c43c <_vfprintf_r+0x95c>
4200c304:	a71b      	addi.n	a10, a7, 1
4200c306:	08a787        	bge	a7, a8, 4200c312 <_vfprintf_r+0x832>
4200c309:	b0e6e0        	addx8	a14, a6, a14
4200c30c:	009e52        	l16si	a5, a14, 0
4200c30f:	004a46        	j	4200c43c <_vfprintf_r+0x95c>
4200c312:	9a2eb2        	l32i	a11, a14, 0x268
4200c315:	fc1c      	movi.n	a12, 31
4200c317:	02dee2        	addmi	a14, a14, 0x200
4200c31a:	9b4b      	addi.n	a9, a11, 4
4200c31c:	382c87        	blt	a12, a8, 4200c358 <_vfprintf_r+0x878>
4200c31f:	c81b      	addi.n	a12, a8, 1
4200c321:	9761c2        	s32i	a12, a1, 0x25c
4200c324:	1a6e92        	s32i	a9, a14, 104
4200c327:	8c1c      	movi.n	a12, 24
4200c329:	072c97        	blt	a12, a9, 4200c334 <_vfprintf_r+0x854>
4200c32c:	192eb2        	l32i	a11, a14, 100
4200c32f:	000486        	j	4200c345 <_vfprintf_r+0x865>
4200c332:	b70000        	lsi	f0, a0, 0x2dc
4200c335:	012c      	movi.n	a1, 32
4200c337:	492c      	movi.n	a9, 36
4200c339:	10c1b2        	addi	a11, a1, 16
4200c33c:	02dbb2        	addmi	a11, a11, 0x200
4200c33f:	182bb2        	l32i	a11, a11, 96
4200c342:	9e6192        	s32i	a9, a1, 0x278
4200c345:	bb9a      	add.n	a11, a11, a9
4200c347:	fccbb2        	addi	a11, a11, -4
4200c34a:	0b58      	l32i.n	a5, a11, 0
4200c34c:	b08810        	addx8	a8, a8, a1
4200c34f:	4859      	s32i.n	a5, a8, 16
4200c351:	235580        	sext	a5, a5, 15
4200c354:	003906        	j	4200c43c <_vfprintf_r+0x95c>
4200c357:	6e9200        	f64rnd	a9, a2, a0, 2
4200c35a:	1c1a      	add.n	a1, a12, a1
4200c35c:	9788      	l32i.n	a8, a7, 36
4200c35e:	0728      	l32i.n	a2, a7, 0
4200c360:	192e82        	l32i	a8, a14, 100
4200c363:	000486        	j	4200c379 <_vfprintf_r+0x899>
4200c366:	b70000        	lsi	f0, a0, 0x2dc
4200c369:	0128      	l32i.n	a2, a1, 0
4200c36b:	492c      	movi.n	a9, 36
4200c36d:	10c182        	addi	a8, a1, 16
4200c370:	02d882        	addmi	a8, a8, 0x200
4200c373:	182882        	l32i	a8, a8, 96
4200c376:	9e6192        	s32i	a9, a1, 0x278
4200c379:	889a      	add.n	a8, a8, a9
4200c37b:	fcc882        	addi	a8, a8, -4
4200c37e:	009852        	l16si	a5, a8, 0
4200c381:	002dc6        	j	4200c43c <_vfprintf_r+0x95c>
4200c384:	02e397        	bbsi	a3, 9, 4200c38a <_vfprintf_r+0x8aa>
4200c387:	002e46        	j	4200c444 <_vfprintf_r+0x964>
4200c38a:	e4ac      	beqz.n	a4, 4200c3bc <_vfprintf_r+0x8dc>
4200c38c:	09a687        	bge	a6, a8, 4200c399 <_vfprintf_r+0x8b9>
4200c38f:	b0e6e0        	addx8	a14, a6, a14
4200c392:	000e52        	l8ui	a5, a14, 0
4200c395:	000786        	j	4200c3b7 <_vfprintf_r+0x8d7>
4200c398:	a28200        	muluh	a8, a2, a0
4200c39b:	8a48      	l32i.n	a4, a10, 32
4200c39d:	8e          	.byte	0x8e
4200c39e:	4ca2d2        	movi	a13, 0x24c
4200c3a1:	60a2c2        	movi	a12, 0x260
4200c3a4:	05bd      	mov.n	a11, a5
4200c3a6:	0189      	s32i.n	a8, a1, 0
4200c3a8:	01def2        	addmi	a15, a14, 0x100
4200c3ab:	deda      	add.n	a13, a14, a13
4200c3ad:	ceca      	add.n	a12, a14, a12
4200c3af:	06ad      	mov.n	a10, a6
4200c3b1:	ff25e5        	call8	4200b610 <get_arg$isra$0>
4200c3b4:	000a52        	l8ui	a5, a10, 0
4200c3b7:	07ad      	mov.n	a10, a7
4200c3b9:	001f06        	j	4200c439 <_vfprintf_r+0x959>
4200c3bc:	a71b      	addi.n	a10, a7, 1
4200c3be:	0aa787        	bge	a7, a8, 4200c3cc <_vfprintf_r+0x8ec>
4200c3c1:	b0e6e0        	addx8	a14, a6, a14
4200c3c4:	000e52        	l8ui	a5, a14, 0
4200c3c7:	001b86        	j	4200c439 <_vfprintf_r+0x959>
4200c3ca:	b20000        	mulsh	a0, a0, a0
4200c3cd:	2e          	.byte	0x2e
4200c3ce:	1c9a      	add.n	a1, a12, a9
4200c3d0:	e2fc      	bnez.n	a2, 4200c412 <_vfprintf_r+0x932>
4200c3d2:	de          	.byte	0xde
4200c3d3:	9b4b02        	s8i	a0, a11, 155
4200c3d6:	362c87        	blt	a12, a8, 4200c410 <_vfprintf_r+0x930>
4200c3d9:	c81b      	addi.n	a12, a8, 1
4200c3db:	9761c2        	s32i	a12, a1, 0x25c
4200c3de:	1a6e92        	s32i	a9, a14, 104
4200c3e1:	8c1c      	movi.n	a12, 24
4200c3e3:	052c97        	blt	a12, a9, 4200c3ec <_vfprintf_r+0x90c>
4200c3e6:	192eb2        	l32i	a11, a14, 100
4200c3e9:	000406        	j	4200c3fd <_vfprintf_r+0x91d>
4200c3ec:	012cb7        	blt	a12, a11, 4200c3f1 <_vfprintf_r+0x911>
4200c3ef:	492c      	movi.n	a9, 36
4200c3f1:	10c1b2        	addi	a11, a1, 16
4200c3f4:	02dbb2        	addmi	a11, a11, 0x200
4200c3f7:	182bb2        	l32i	a11, a11, 96
4200c3fa:	9e6192        	s32i	a9, a1, 0x278
4200c3fd:	bb9a      	add.n	a11, a11, a9
4200c3ff:	fccbb2        	addi	a11, a11, -4
4200c402:	0b58      	l32i.n	a5, a11, 0
4200c404:	b08810        	addx8	a8, a8, a1
4200c407:	4859      	s32i.n	a5, a8, 16
4200c409:	745050        	extui	a5, a5, 0, 8
4200c40c:	000a46        	j	4200c439 <_vfprintf_r+0x959>
4200c40f:	6e9200        	f64rnd	a9, a2, a0, 2
4200c412:	1c1a      	add.n	a1, a12, a1
4200c414:	9788      	l32i.n	a8, a7, 36
4200c416:	0728      	l32i.n	a2, a7, 0
4200c418:	192e82        	l32i	a8, a14, 100
4200c41b:	000486        	j	4200c431 <_vfprintf_r+0x951>
4200c41e:	b70000        	lsi	f0, a0, 0x2dc
4200c421:	0128      	l32i.n	a2, a1, 0
4200c423:	492c      	movi.n	a9, 36
4200c425:	10c182        	addi	a8, a1, 16
4200c428:	02d882        	addmi	a8, a8, 0x200
4200c42b:	182882        	l32i	a8, a8, 96
4200c42e:	9e6192        	s32i	a9, a1, 0x278
4200c431:	889a      	add.n	a8, a8, a9
4200c433:	fcc882        	addi	a8, a8, -4
4200c436:	000852        	l8ui	a5, a8, 0
4200c439:	235500        	sext	a5, a5, 7
4200c43c:	314f50        	srai	a4, a5, 31
4200c43f:	0a7d      	mov.n	a7, a10
4200c441:	002a06        	j	4200c4ed <_vfprintf_r+0xa0d>
4200c444:	c4ac      	beqz.n	a4, 4200c474 <_vfprintf_r+0x994>
4200c446:	07a687        	bge	a6, a8, 4200c451 <_vfprintf_r+0x971>
4200c449:	b0e6e0        	addx8	a14, a6, a14
4200c44c:	0e58      	l32i.n	a5, a14, 0
4200c44e:	000706        	j	4200c46e <_vfprintf_r+0x98e>
4200c451:	48a282        	movi	a8, 0x248
4200c454:	8e8a      	add.n	a8, a14, a8
4200c456:	4ca2d2        	movi	a13, 0x24c
4200c459:	60a2c2        	movi	a12, 0x260
4200c45c:	05bd      	mov.n	a11, a5
4200c45e:	0189      	s32i.n	a8, a1, 0
4200c460:	01def2        	addmi	a15, a14, 0x100
4200c463:	deda      	add.n	a13, a14, a13
4200c465:	ceca      	add.n	a12, a14, a12
4200c467:	06ad      	mov.n	a10, a6
4200c469:	ff1a65        	call8	4200b610 <get_arg$isra$0>
4200c46c:	0a58      	l32i.n	a5, a10, 0
4200c46e:	079d      	mov.n	a9, a7
4200c470:	001d06        	j	4200c4e8 <_vfprintf_r+0xa08>
4200c473:	971b00        	lsi	f0, a11, 0x25c
4200c476:	07a787        	bge	a7, a8, 4200c481 <_vfprintf_r+0x9a1>
4200c479:	b0e6e0        	addx8	a14, a6, a14
4200c47c:	0e58      	l32i.n	a5, a14, 0
4200c47e:	001986        	j	4200c4e8 <_vfprintf_r+0xa08>
4200c481:	9a2eb2        	l32i	a11, a14, 0x268
4200c484:	fc1c      	movi.n	a12, 31
4200c486:	02dee2        	addmi	a14, a14, 0x200
4200c489:	ab4b      	addi.n	a10, a11, 4
4200c48b:	322c87        	blt	a12, a8, 4200c4c1 <_vfprintf_r+0x9e1>
4200c48e:	c81b      	addi.n	a12, a8, 1
4200c490:	9761c2        	s32i	a12, a1, 0x25c
4200c493:	1a6ea2        	s32i	a10, a14, 104
4200c496:	8c1c      	movi.n	a12, 24
4200c498:	052ca7        	blt	a12, a10, 4200c4a1 <_vfprintf_r+0x9c1>
4200c49b:	192eb2        	l32i	a11, a14, 100
4200c49e:	000406        	j	4200c4b2 <_vfprintf_r+0x9d2>
4200c4a1:	012cb7        	blt	a12, a11, 4200c4a6 <_vfprintf_r+0x9c6>
4200c4a4:	4a2c      	movi.n	a10, 36
4200c4a6:	10c1b2        	addi	a11, a1, 16
4200c4a9:	02dbb2        	addmi	a11, a11, 0x200
4200c4ac:	182bb2        	l32i	a11, a11, 96
4200c4af:	9e61a2        	s32i	a10, a1, 0x278
4200c4b2:	bbaa      	add.n	a11, a11, a10
4200c4b4:	fccbb2        	addi	a11, a11, -4
4200c4b7:	0b58      	l32i.n	a5, a11, 0
4200c4b9:	b08810        	addx8	a8, a8, a1
4200c4bc:	4859      	s32i.n	a5, a8, 16
4200c4be:	000986        	j	4200c4e8 <_vfprintf_r+0xa08>
4200c4c1:	1a6ea2        	s32i	a10, a14, 104
4200c4c4:	881c      	movi.n	a8, 24
4200c4c6:	0628a7        	blt	a8, a10, 4200c4d0 <_vfprintf_r+0x9f0>
4200c4c9:	192e82        	l32i	a8, a14, 100
4200c4cc:	000446        	j	4200c4e1 <_vfprintf_r+0xa01>
4200c4cf:	28b700        	lsi	f0, a7, 160
4200c4d2:	4a2c01        	l32r	a0, 41fded84 <_coredump_iram_end+0x1c5ce84>
4200c4d5:	10c182        	addi	a8, a1, 16
4200c4d8:	02d882        	addmi	a8, a8, 0x200
4200c4db:	182882        	l32i	a8, a8, 96
4200c4de:	9e61a2        	s32i	a10, a1, 0x278
4200c4e1:	88aa      	add.n	a8, a8, a10
4200c4e3:	fcc882        	addi	a8, a8, -4
4200c4e6:	0858      	l32i.n	a5, a8, 0
4200c4e8:	314f50        	srai	a4, a5, 31
4200c4eb:	097d      	mov.n	a7, a9
4200c4ed:	002496        	bltz	a4, 4200c4f3 <_vfprintf_r+0xa13>
4200c4f0:	088106        	j	4200e6f8 <_vfprintf_r+0x2c18>
4200c4f3:	604040        	neg	a4, a4
4200c4f6:	002516        	beqz	a5, 4200c4fc <_vfprintf_r+0xa1c>
4200c4f9:	ffc442        	addi	a4, a4, -1
4200c4fc:	605050        	neg	a5, a5
4200c4ff:	d82c      	movi.n	a8, 45
4200c501:	190c      	movi.n	a9, 1
4200c503:	052d46        	j	4200d9bc <_vfprintf_r+0x1edc>
4200c506:	972182        	l32i	a8, a1, 0x25c
4200c509:	10c1e2        	addi	a14, a1, 16
4200c50c:	44bc      	beqz.n	a4, 4200c544 <_vfprintf_r+0xa64>
4200c50e:	0fa687        	bge	a6, a8, 4200c521 <_vfprintf_r+0xa41>
4200c511:	b0e6e0        	addx8	a14, a6, a14
4200c514:	0e88      	l32i.n	a8, a14, 0
4200c516:	1e98      	l32i.n	a9, a14, 4
4200c518:	a66182        	s32i	a8, a1, 0x298
4200c51b:	a76192        	s32i	a9, a1, 0x29c
4200c51e:	002d06        	j	4200c5d6 <_vfprintf_r+0xaf6>
4200c521:	48a282        	movi	a8, 0x248
4200c524:	8e8a      	add.n	a8, a14, a8
4200c526:	4ca2d2        	movi	a13, 0x24c
4200c529:	60a2c2        	movi	a12, 0x260
4200c52c:	0189      	s32i.n	a8, a1, 0
4200c52e:	01def2        	addmi	a15, a14, 0x100
4200c531:	deda      	add.n	a13, a14, a13
4200c533:	ceca      	add.n	a12, a14, a12
4200c535:	05bd      	mov.n	a11, a5
4200c537:	06ad      	mov.n	a10, a6
4200c539:	ff0d65        	call8	4200b610 <get_arg$isra$0>
4200c53c:	0a88      	l32i.n	a8, a10, 0
4200c53e:	1a98      	l32i.n	a9, a10, 4
4200c540:	fff506        	j	4200c518 <_vfprintf_r+0xa38>
4200c543:	b71b00        	lsi	f0, a11, 0x2dc
4200c546:	0aa787        	bge	a7, a8, 4200c554 <_vfprintf_r+0xa74>
4200c549:	b0e6e0        	addx8	a14, a6, a14
4200c54c:	0e88      	l32i.n	a8, a14, 0
4200c54e:	1e98      	l32i.n	a9, a14, 4
4200c550:	001e86        	j	4200c5ce <_vfprintf_r+0xaee>
4200c553:	2ea200        	f64norm	a10, a2, a0, 0
4200c556:	7c9a      	add.n	a7, a12, a9
4200c558:	7b89      	s32i.n	a8, a11, 28
4200c55a:	90aa      	add.n	a9, a0, a10
4200c55c:	10aa      	add.n	a1, a0, a10
4200c55e:	fc1c      	movi.n	a12, 31
4200c560:	02dee2        	addmi	a14, a14, 0x200
4200c563:	9a8b      	addi.n	a9, a10, 8
4200c565:	3c2c87        	blt	a12, a8, 4200c5a5 <_vfprintf_r+0xac5>
4200c568:	c81b      	addi.n	a12, a8, 1
4200c56a:	9761c2        	s32i	a12, a1, 0x25c
4200c56d:	1a6e92        	s32i	a9, a14, 104
4200c570:	8c1c      	movi.n	a12, 24
4200c572:	052c97        	blt	a12, a9, 4200c57b <_vfprintf_r+0xa9b>
4200c575:	192ea2        	l32i	a10, a14, 100
4200c578:	000406        	j	4200c58c <_vfprintf_r+0xaac>
4200c57b:	012ca7        	blt	a12, a10, 4200c580 <_vfprintf_r+0xaa0>
4200c57e:	892c      	movi.n	a9, 40
4200c580:	10c1a2        	addi	a10, a1, 16
4200c583:	02daa2        	addmi	a10, a10, 0x200
4200c586:	182aa2        	l32i	a10, a10, 96
4200c589:	9e6192        	s32i	a9, a1, 0x278
4200c58c:	aa9a      	add.n	a10, a10, a9
4200c58e:	f8caa2        	addi	a10, a10, -8
4200c591:	0ac8      	l32i.n	a12, a10, 0
4200c593:	1ad8      	l32i.n	a13, a10, 4
4200c595:	b08810        	addx8	a8, a8, a1
4200c598:	a661c2        	s32i	a12, a1, 0x298
4200c59b:	a761d2        	s32i	a13, a1, 0x29c
4200c59e:	48c9      	s32i.n	a12, a8, 16
4200c5a0:	58d9      	s32i.n	a13, a8, 20
4200c5a2:	000b86        	j	4200c5d4 <_vfprintf_r+0xaf4>
4200c5a5:	1a6e92        	s32i	a9, a14, 104
4200c5a8:	881c      	movi.n	a8, 24
4200c5aa:	062897        	blt	a8, a9, 4200c5b4 <_vfprintf_r+0xad4>
4200c5ad:	192e82        	l32i	a8, a14, 100
4200c5b0:	000446        	j	4200c5c5 <_vfprintf_r+0xae5>
4200c5b3:	28a700        	lsi	f0, a7, 160
4200c5b6:	892c01        	l32r	a0, 41feea68 <_coredump_iram_end+0x1c6cb68>
4200c5b9:	10c182        	addi	a8, a1, 16
4200c5bc:	02d882        	addmi	a8, a8, 0x200
4200c5bf:	182882        	l32i	a8, a8, 96
4200c5c2:	9e6192        	s32i	a9, a1, 0x278
4200c5c5:	889a      	add.n	a8, a8, a9
4200c5c7:	f8c882        	addi	a8, a8, -8
4200c5ca:	1898      	l32i.n	a9, a8, 4
4200c5cc:	0888      	l32i.n	a8, a8, 0
4200c5ce:	a66182        	s32i	a8, a1, 0x298
4200c5d1:	a76192        	s32i	a9, a1, 0x29c
4200c5d4:	0b7d      	mov.n	a7, a11
4200c5d6:	a62182        	l32i	a8, a1, 0x298
4200c5d9:	d1ccd1        	l32r	a13, 42000d0c <_stext+0xcec> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
4200c5dc:	b46182        	s32i	a8, a1, 0x2d0
4200c5df:	a72182        	l32i	a8, a1, 0x29c
4200c5e2:	fc7c      	movi.n	a12, -1
4200c5e4:	888a      	add.n	a8, a8, a8
4200c5e6:	418180        	srli	a8, a8, 1
4200c5e9:	b56182        	s32i	a8, a1, 0x2d4
4200c5ec:	d0a282        	movi	a8, 0x2d0
4200c5ef:	881a      	add.n	a8, a8, a1
4200c5f1:	0028a2        	l32i	a10, a8, 0
4200c5f4:	18b8      	l32i.n	a11, a8, 4
4200c5f6:	d1c681        	l32r	a8, 42000d10 <_stext+0xcf0> (4000258c <__unorddf2>)
4200c5f9:	0008e0        	callx8	a8
4200c5fc:	8adc      	bnez.n	a10, 4200c618 <_vfprintf_r+0xb38>
4200c5fe:	d0a282        	movi	a8, 0x2d0
4200c601:	881a      	add.n	a8, a8, a1
4200c603:	d1c2d1        	l32r	a13, 42000d0c <_stext+0xcec> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
4200c606:	0028a2        	l32i	a10, a8, 0
4200c609:	0128b2        	l32i	a11, a8, 4
4200c60c:	ffafc2        	movi	a12, -1
4200c60f:	d1c181        	l32r	a8, 42000d14 <_stext+0xcf4> (400023b8 <__ledf2>)
4200c612:	0008e0        	callx8	a8
4200c615:	1c1ae6        	bgei	a10, 1, 4200c635 <_vfprintf_r+0xb55>
4200c618:	98a282        	movi	a8, 0x298
4200c61b:	881a      	add.n	a8, a8, a1
4200c61d:	08c8      	l32i.n	a12, a8, 0
4200c61f:	18d8      	l32i.n	a13, a8, 4
4200c621:	0cad      	mov.n	a10, a12
4200c623:	20bdd0        	or	a11, a13, a13
4200c626:	d1ba81        	l32r	a8, 42000d10 <_stext+0xcf0> (4000258c <__unorddf2>)
4200c629:	0008e0        	callx8	a8
4200c62c:	075a16        	beqz	a10, 4200c6a5 <_vfprintf_r+0xbc5>
4200c62f:	000e06        	j	4200c66b <_vfprintf_r+0xb8b>
4200c632:	000000        	ill
4200c635:	98a282        	movi	a8, 0x298
4200c638:	881a      	add.n	a8, a8, a1
4200c63a:	08a8      	l32i.n	a10, a8, 0
4200c63c:	18b8      	l32i.n	a11, a8, 4
4200c63e:	0c0c      	movi.n	a12, 0
4200c640:	0d0c      	movi.n	a13, 0
4200c642:	d1b581        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
4200c645:	0008e0        	callx8	a8
4200c648:	00aad6        	bgez	a10, 4200c656 <_vfprintf_r+0xb76>
4200c64b:	10c182        	addi	a8, a1, 16
4200c64e:	02d882        	addmi	a8, a8, 0x200
4200c651:	d92c      	movi.n	a9, 45
4200c653:	524892        	s8i	a9, a8, 82
4200c656:	d1a391        	l32r	a9, 42000ce4 <_stext+0xcc4> (3c029152 <Xthal_intlevel+0x26>)
4200c659:	784c      	movi.n	a8, 71
4200c65b:	9f6192        	s32i	a9, a1, 0x27c
4200c65e:	a32192        	l32i	a9, a1, 0x28c
4200c661:	2b2897        	blt	a8, a9, 4200c690 <_vfprintf_r+0xbb0>
4200c664:	d19f81        	l32r	a8, 42000ce0 <_stext+0xcc0> (3c02914e <Xthal_intlevel+0x22>)
4200c667:	000886        	j	4200c68d <_vfprintf_r+0xbad>
4200c66a:	218200        	srai	a8, a0, 2
4200c66d:	a8d6a7        	bbs	a6, a10, 4200c619 <_vfprintf_r+0xb39>
4200c670:	c18200        	mul16u	a8, a2, a0
4200c673:	d88210        	lsi	f1, a2, 0x360
4200c676:	d92c02        	l32i	a0, a12, 0x364
4200c679:	524892        	s8i	a9, a8, 82
4200c67c:	d19c91        	l32r	a9, 42000cec <_stext+0xccc> (3c02915a <Xthal_intlevel+0x2e>)
4200c67f:	784c      	movi.n	a8, 71
4200c681:	9f6192        	s32i	a9, a1, 0x27c
4200c684:	a32192        	l32i	a9, a1, 0x28c
4200c687:	052897        	blt	a8, a9, 4200c690 <_vfprintf_r+0xbb0>
4200c68a:	d19781        	l32r	a8, 42000ce8 <_stext+0xcc8> (3c029156 <Xthal_intlevel+0x2a>)
4200c68d:	9f6182        	s32i	a8, a1, 0x27c
4200c690:	7faf82        	movi	a8, -129
4200c693:	103380        	and	a3, a3, a8
4200c696:	080c      	movi.n	a8, 0
4200c698:	a96182        	s32i	a8, a1, 0x2a4
4200c69b:	380c      	movi.n	a8, 3
4200c69d:	a26182        	s32i	a8, a1, 0x288
4200c6a0:	054a86        	j	4200dbce <_vfprintf_r+0x20ee>
4200c6a3:	920000        	lsi	f0, a0, 0x248
4200c6a6:	82a321        	l32r	a2, 41fed134 <_coredump_iram_end+0x1c6b234>
4200c6a9:	af          	.byte	0xaf
4200c6aa:	df          	.byte	0xdf
4200c6ab:	104980        	and	a4, a9, a8
4200c6ae:	184c      	movi.n	a8, 65
4200c6b0:	5d9487        	bne	a4, a8, 4200c711 <_vfprintf_r+0xc31>
4200c6b3:	10c182        	addi	a8, a1, 16
4200c6b6:	02d892        	addmi	a9, a8, 0x200
4200c6b9:	0a3c      	movi.n	a10, 48
4200c6bb:	a321b2        	l32i	a11, a1, 0x28c
4200c6be:	5049a2        	s8i	a10, a9, 80
4200c6c1:	61a0a2        	movi	a10, 97
4200c6c4:	895c      	movi.n	a9, 88
4200c6c6:	029ba7        	bne	a11, a10, 4200c6cc <_vfprintf_r+0xbec>
4200c6c9:	78a092        	movi	a9, 120
4200c6cc:	02d8a2        	addmi	a10, a8, 0x200
4200c6cf:	514a92        	s8i	a9, a10, 81
4200c6d2:	0a0c      	movi.n	a10, 0
4200c6d4:	a961a2        	s32i	a10, a1, 0x2a4
4200c6d7:	80a1a2        	movi	a10, 0x180
4200c6da:	88aa      	add.n	a8, a8, a10
4200c6dc:	290c      	movi.n	a9, 2
4200c6de:	9f6182        	s32i	a8, a1, 0x27c
4200c6e1:	a22182        	l32i	a8, a1, 0x288
4200c6e4:	203390        	or	a3, a3, a9
4200c6e7:	63a092        	movi	a9, 99
4200c6ea:	53a987        	bge	a9, a8, 4200c741 <_vfprintf_r+0xc61>
4200c6ed:	a121a2        	l32i	a10, a1, 0x284
4200c6f0:	b81b      	addi.n	a11, a8, 1
4200c6f2:	d16581        	l32r	a8, 42000c88 <_stext+0xc68> (4037fea4 <_malloc_r>)
4200c6f5:	0008e0        	callx8	a8
4200c6f8:	9f61a2        	s32i	a10, a1, 0x27c
4200c6fb:	9aec      	bnez.n	a10, 4200c728 <_vfprintf_r+0xc48>
4200c6fd:	a02182        	l32i	a8, a1, 0x280
4200c700:	094c      	movi.n	a9, 64
4200c702:	061882        	l16ui	a8, a8, 12
4200c705:	208890        	or	a8, a8, a9
4200c708:	a02192        	l32i	a9, a1, 0x280
4200c70b:	065982        	s16i	a8, a9, 12
4200c70e:	07ee86        	j	4200e6cc <_vfprintf_r+0x2bec>
4200c711:	a22182        	l32i	a8, a1, 0x288
4200c714:	160826        	beqi	a8, -1, 4200c72e <_vfprintf_r+0xc4e>
4200c717:	18ec      	bnez.n	a8, 4200c73c <_vfprintf_r+0xc5c>
4200c719:	b9c482        	addi	a8, a4, -71
4200c71c:	c8dc      	bnez.n	a8, 4200c73c <_vfprintf_r+0xc5c>
4200c71e:	a96182        	s32i	a8, a1, 0x2a4
4200c721:	180c      	movi.n	a8, 1
4200c723:	000386        	j	4200c735 <_vfprintf_r+0xc55>
4200c726:	820000        	mull	a0, a0, a0
4200c729:	c69f21        	l32r	a2, 41ffe1a8 <_coredump_iram_end+0x1c7c2a8>
4200c72c:	0c0003        	lsi	f0, a0, 48
4200c72f:	8208      	l32i.n	a0, a2, 32
4200c731:	0ca961        	l32r	a6, 41fcf9d8 <_coredump_iram_end+0x1c4dad8>
4200c734:	8268      	l32i.n	a6, a2, 32
4200c736:	46a261        	l32r	a6, 41fde1c0 <_coredump_iram_end+0x1c5c2c0>
4200c739:	000001        	l32r	a0, 41fcc73c <_coredump_iram_end+0x1c4a83c>
4200c73c:	080c      	movi.n	a8, 0
4200c73e:	a96182        	s32i	a8, a1, 0x2a4
4200c741:	00a182        	movi	a8, 0x100
4200c744:	208380        	or	a8, a3, a8
4200c747:	af6182        	s32i	a8, a1, 0x2bc
4200c74a:	a72182        	l32i	a8, a1, 0x29c
4200c74d:	0188d6        	bgez	a8, 4200c769 <_vfprintf_r+0xc89>
4200c750:	a62182        	l32i	a8, a1, 0x298
4200c753:	a72192        	l32i	a9, a1, 0x29c
4200c756:	b26182        	s32i	a8, a1, 0x2c8
4200c759:	f87c      	movi.n	a8, -1
4200c75b:	018810        	slli	a8, a8, 31
4200c75e:	308980        	xor	a8, a9, a8
4200c761:	b36182        	s32i	a8, a1, 0x2cc
4200c764:	d82c      	movi.n	a8, 45
4200c766:	000406        	j	4200c77a <_vfprintf_r+0xc9a>
4200c769:	98a282        	movi	a8, 0x298
4200c76c:	881a      	add.n	a8, a8, a1
4200c76e:	1898      	l32i.n	a9, a8, 4
4200c770:	0888      	l32i.n	a8, a8, 0
4200c772:	b36192        	s32i	a9, a1, 0x2cc
4200c775:	b26182        	s32i	a8, a1, 0x2c8
4200c778:	080c      	movi.n	a8, 0
4200c77a:	b96182        	s32i	a8, a1, 0x2e4
4200c77d:	184c      	movi.n	a8, 65
4200c77f:	021487        	beq	a4, a8, 4200c785 <_vfprintf_r+0xca5>
4200c782:	005e06        	j	4200c8fe <_vfprintf_r+0xe1e>
4200c785:	c8a282        	movi	a8, 0x2c8
4200c788:	881a      	add.n	a8, a8, a1
4200c78a:	08a8      	l32i.n	a10, a8, 0
4200c78c:	18b8      	l32i.n	a11, a8, 4
4200c78e:	54a2c2        	movi	a12, 0x254
4200c791:	c1ca      	add.n	a12, a1, a12
4200c793:	201110        	or	a1, a1, a1
4200c796:	044765        	call8	42010c0c <frexp>
4200c799:	ffa0d2        	movi	a13, 255
4200c79c:	00a0c2        	movi	a12, 0
4200c79f:	01dda0        	slli	a13, a13, 22
4200c7a2:	d15e81        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
4200c7a5:	0008e0        	callx8	a8
4200c7a8:	a461a2        	s32i	a10, a1, 0x290
4200c7ab:	a561b2        	s32i	a11, a1, 0x294
4200c7ae:	0c0c      	movi.n	a12, 0
4200c7b0:	00a0d2        	movi	a13, 0
4200c7b3:	d15b81        	l32r	a8, 42000d20 <_stext+0xd00> (4000228c <__eqdf2>)
4200c7b6:	0008e0        	callx8	a8
4200c7b9:	3acc      	bnez.n	a10, 4200c7c0 <_vfprintf_r+0xce0>
4200c7bb:	180c      	movi.n	a8, 1
4200c7bd:	956182        	s32i	a8, a1, 0x254
4200c7c0:	d14d91        	l32r	a9, 42000cf4 <_stext+0xcd4> (3c02916f <Xthal_intlevel+0x43>)
4200c7c3:	61a082        	movi	a8, 97
4200c7c6:	ab6192        	s32i	a9, a1, 0x2ac
4200c7c9:	a32192        	l32i	a9, a1, 0x28c
4200c7cc:	059987        	bne	a9, a8, 4200c7d5 <_vfprintf_r+0xcf5>
4200c7cf:	d14881        	l32r	a8, 42000cf0 <_stext+0xcd0> (3c02915e <Xthal_intlevel+0x32>)
4200c7d2:	ab6182        	s32i	a8, a1, 0x2ac
4200c7d5:	a22182        	l32i	a8, a1, 0x288
4200c7d8:	9f2162        	l32i	a6, a1, 0x27c
4200c7db:	880b      	addi.n	a8, a8, -1
4200c7dd:	000046        	j	4200c7e2 <_vfprintf_r+0xd02>
4200c7e0:	058d      	mov.n	a8, a5
4200c7e2:	ba6182        	s32i	a8, a1, 0x2e8
4200c7e5:	90a282        	movi	a8, 0x290
4200c7e8:	881a      	add.n	a8, a8, a1
4200c7ea:	08a8      	l32i.n	a10, a8, 0
4200c7ec:	18b8      	l32i.n	a11, a8, 4
4200c7ee:	03a4d2        	movi	a13, 0x403
4200c7f1:	00a0c2        	movi	a12, 0
4200c7f4:	01ddc0        	slli	a13, a13, 20
4200c7f7:	d14981        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
4200c7fa:	0008e0        	callx8	a8
4200c7fd:	a561b2        	s32i	a11, a1, 0x294
4200c800:	a461a2        	s32i	a10, a1, 0x290
4200c803:	d14881        	l32r	a8, 42000d24 <_stext+0xd04> (400022d4 <__fixdfsi>)
4200c806:	0008e0        	callx8	a8
4200c809:	0a5d      	mov.n	a5, a10
4200c80b:	d14781        	l32r	a8, 42000d28 <_stext+0xd08> (40002334 <__floatsidf>)
4200c80e:	0008e0        	callx8	a8
4200c811:	90a282        	movi	a8, 0x290
4200c814:	881a      	add.n	a8, a8, a1
4200c816:	0acd      	mov.n	a12, a10
4200c818:	0bdd      	mov.n	a13, a11
4200c81a:	08a8      	l32i.n	a10, a8, 0
4200c81c:	18b8      	l32i.n	a11, a8, 4
4200c81e:	d14381        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
4200c821:	0008e0        	callx8	a8
4200c824:	ab2182        	l32i	a8, a1, 0x2ac
4200c827:	a461a2        	s32i	a10, a1, 0x290
4200c82a:	a85a      	add.n	a10, a8, a5
4200c82c:	000aa2        	l8ui	a10, a10, 0
4200c82f:	ba2182        	l32i	a8, a1, 0x2e8
4200c832:	0046a2        	s8i	a10, a6, 0
4200c835:	a561b2        	s32i	a11, a1, 0x294
4200c838:	661b      	addi.n	a6, a6, 1
4200c83a:	1f0826        	beqi	a8, -1, 4200c85d <_vfprintf_r+0xd7d>
4200c83d:	580b      	addi.n	a5, a8, -1
4200c83f:	90a282        	movi	a8, 0x290
4200c842:	881a      	add.n	a8, a8, a1
4200c844:	08a8      	l32i.n	a10, a8, 0
4200c846:	18b8      	l32i.n	a11, a8, 4
4200c848:	00a0c2        	movi	a12, 0
4200c84b:	00a0d2        	movi	a13, 0
4200c84e:	d13881        	l32r	a8, 42000d30 <_stext+0xd10> (4000246c <__nedf2>)
4200c851:	0008e0        	callx8	a8
4200c854:	ba2182        	l32i	a8, a1, 0x2e8
4200c857:	f85a56        	bnez	a10, 4200c7e0 <_vfprintf_r+0xd00>
4200c85a:	001c06        	j	4200c8ce <_vfprintf_r+0xdee>
4200c85d:	90a282        	movi	a8, 0x290
4200c860:	881a      	add.n	a8, a8, a1
4200c862:	d129d1        	l32r	a13, 42000d08 <_stext+0xce8> (3fe00000 <ets_ops_table_ptr+0x110004>)
4200c865:	08a8      	l32i.n	a10, a8, 0
4200c867:	18b8      	l32i.n	a11, a8, 4
4200c869:	0c0c      	movi.n	a12, 0
4200c86b:	d13281        	l32r	a8, 42000d34 <_stext+0xd14> (400023a0 <__gtdf2>)
4200c86e:	0008e0        	callx8	a8
4200c871:	191ae6        	bgei	a10, 1, 4200c88e <_vfprintf_r+0xdae>
4200c874:	90a282        	movi	a8, 0x290
4200c877:	881a      	add.n	a8, a8, a1
4200c879:	d123d1        	l32r	a13, 42000d08 <_stext+0xce8> (3fe00000 <ets_ops_table_ptr+0x110004>)
4200c87c:	08a8      	l32i.n	a10, a8, 0
4200c87e:	18b8      	l32i.n	a11, a8, 4
4200c880:	0c0c      	movi.n	a12, 0
4200c882:	d12781        	l32r	a8, 42000d20 <_stext+0xd00> (4000228c <__eqdf2>)
4200c885:	0008e0        	callx8	a8
4200c888:	040a56        	bnez	a10, 4200c8cc <_vfprintf_r+0xdec>
4200c88b:	3d6507        	bbci	a5, 0, 4200c8cc <_vfprintf_r+0xdec>
4200c88e:	ab2182        	l32i	a8, a1, 0x2ac
4200c891:	906162        	s32i	a6, a1, 0x240
4200c894:	0f0882        	l8ui	a8, a8, 15
4200c897:	0b3c      	movi.n	a11, 48
4200c899:	000086        	j	4200c89f <_vfprintf_r+0xdbf>
4200c89c:	0049b2        	s8i	a11, a9, 0
4200c89f:	902192        	l32i	a9, a1, 0x240
4200c8a2:	990b      	addi.n	a9, a9, -1
4200c8a4:	906192        	s32i	a9, a1, 0x240
4200c8a7:	0009a2        	l8ui	a10, a9, 0
4200c8aa:	ee1a87        	beq	a10, a8, 4200c89c <_vfprintf_r+0xdbc>
4200c8ad:	8a1b      	addi.n	a8, a10, 1
4200c8af:	9b3c      	movi.n	a11, 57
4200c8b1:	748080        	extui	a8, a8, 0, 8
4200c8b4:	059ab7        	bne	a10, a11, 4200c8bd <_vfprintf_r+0xddd>
4200c8b7:	ab2182        	l32i	a8, a1, 0x2ac
4200c8ba:	0a0882        	l8ui	a8, a8, 10
4200c8bd:	004982        	s8i	a8, a9, 0
4200c8c0:	000ac6        	j	4200c8ef <_vfprintf_r+0xe0f>
4200c8c3:	49c200        	s32e	a0, a2, -16
4200c8c6:	991b00        	lsi	f0, a11, 0x264
4200c8c9:	0001c6        	j	4200c8d4 <_vfprintf_r+0xdf4>
4200c8cc:	f87c      	movi.n	a8, -1
4200c8ce:	069d      	mov.n	a9, a6
4200c8d0:	b68a      	add.n	a11, a6, a8
4200c8d2:	0c3c      	movi.n	a12, 48
4200c8d4:	c0ab90        	sub	a10, a11, a9
4200c8d7:	fe9ad6        	bgez	a10, 4200c8c4 <_vfprintf_r+0xde4>
4200c8da:	f97c      	movi.n	a9, -1
4200c8dc:	729890        	lsi	f9, a8, 0x1c8
4200c8df:	990b      	addi.n	a9, a9, -1
4200c8e1:	609090        	neg	a9, a9
4200c8e4:	749090        	extui	a9, a9, 0, 8
4200c8e7:	0a0c      	movi.n	a10, 0
4200c8e9:	098c      	beqz.n	a9, 4200c8ed <_vfprintf_r+0xe0d>
4200c8eb:	a81b      	addi.n	a10, a8, 1
4200c8ed:	66aa      	add.n	a6, a6, a10
4200c8ef:	9f2182        	l32i	a8, a1, 0x27c
4200c8f2:	c08680        	sub	a8, a6, a8
4200c8f5:	a46182        	s32i	a8, a1, 0x290
4200c8f8:	952162        	l32i	a6, a1, 0x254
4200c8fb:	003e46        	j	4200c9f8 <_vfprintf_r+0xf18>
4200c8fe:	684c      	movi.n	a8, 70
4200c900:	a22162        	l32i	a6, a1, 0x288
4200c903:	3e0c      	movi.n	a14, 3
4200c905:	0f1487        	beq	a4, a8, 4200c918 <_vfprintf_r+0xe38>
4200c908:	bbc462        	addi	a6, a4, -69
4200c90b:	a22182        	l32i	a8, a1, 0x288
4200c90e:	40f660        	nsau	a6, a6
4200c911:	416560        	srli	a6, a6, 5
4200c914:	668a      	add.n	a6, a6, a8
4200c916:	2e0c      	movi.n	a14, 2
4200c918:	10c182        	addi	a8, a1, 16
4200c91b:	30a292        	movi	a9, 0x230
4200c91e:	989a      	add.n	a9, a8, a9
4200c920:	2199      	s32i.n	a9, a1, 8
4200c922:	40a292        	movi	a9, 0x240
4200c925:	989a      	add.n	a9, a8, a9
4200c927:	1199      	s32i.n	a9, a1, 4
4200c929:	44a292        	movi	a9, 0x244
4200c92c:	889a      	add.n	a8, a8, a9
4200c92e:	0189      	s32i.n	a8, a1, 0
4200c930:	c8a282        	movi	a8, 0x2c8
4200c933:	881a      	add.n	a8, a8, a1
4200c935:	08c8      	l32i.n	a12, a8, 0
4200c937:	18d8      	l32i.n	a13, a8, 4
4200c939:	a121a2        	l32i	a10, a1, 0x284
4200c93c:	06fd      	mov.n	a15, a6
4200c93e:	201110        	or	a1, a1, a1
4200c941:	044625        	call8	42010da4 <_dtoa_r>
4200c944:	9f61a2        	s32i	a10, a1, 0x27c
4200c947:	784c      	movi.n	a8, 71
4200c949:	239487        	bne	a4, a8, 4200c970 <_vfprintf_r+0xe90>
4200c94c:	18e307        	bbsi	a3, 0, 4200c968 <_vfprintf_r+0xe88>
4200c94f:	902182        	l32i	a8, a1, 0x240
4200c952:	9f2192        	l32i	a9, a1, 0x27c
4200c955:	952162        	l32i	a6, a1, 0x254
4200c958:	c08890        	sub	a8, a8, a9
4200c95b:	a46182        	s32i	a8, a1, 0x290
4200c95e:	784c      	movi.n	a8, 71
4200c960:	7a1487        	beq	a4, a8, 4200c9de <_vfprintf_r+0xefe>
4200c963:	002446        	j	4200c9f8 <_vfprintf_r+0xf18>
4200c966:	820000        	mull	a0, a0, a0
4200c969:	6a9f21        	l32r	a2, 41fe73e8 <_coredump_iram_end+0x1c654e8>
4200c96c:	0658      	l32i.n	a5, a6, 0
4200c96e:	0e          	.byte	0xe
4200c96f:	218200        	srai	a8, a0, 2
4200c972:	9f          	.byte	0x9f
4200c973:	586a      	add.n	a5, a8, a6
4200c975:	684c      	movi.n	a8, 70
4200c977:	2e9487        	bne	a4, a8, 4200c9a9 <_vfprintf_r+0xec9>
4200c97a:	9f2182        	l32i	a8, a1, 0x27c
4200c97d:	000882        	l8ui	a8, a8, 0
4200c980:	d0c882        	addi	a8, a8, -48
4200c983:	d8dc      	bnez.n	a8, 4200c9a4 <_vfprintf_r+0xec4>
4200c985:	c8a282        	movi	a8, 0x2c8
4200c988:	881a      	add.n	a8, a8, a1
4200c98a:	08a8      	l32i.n	a10, a8, 0
4200c98c:	18b8      	l32i.n	a11, a8, 4
4200c98e:	00a0c2        	movi	a12, 0
4200c991:	00a0d2        	movi	a13, 0
4200c994:	d0e781        	l32r	a8, 42000d30 <_stext+0xd10> (4000246c <__nedf2>)
4200c997:	0008e0        	callx8	a8
4200c99a:	6a8c      	beqz.n	a10, 4200c9a4 <_vfprintf_r+0xec4>
4200c99c:	660b      	addi.n	a6, a6, -1
4200c99e:	606060        	neg	a6, a6
4200c9a1:	956162        	s32i	a6, a1, 0x254
4200c9a4:	952182        	l32i	a8, a1, 0x254
4200c9a7:	558a      	add.n	a5, a5, a8
4200c9a9:	c8a282        	movi	a8, 0x2c8
4200c9ac:	881a      	add.n	a8, a8, a1
4200c9ae:	08a8      	l32i.n	a10, a8, 0
4200c9b0:	18b8      	l32i.n	a11, a8, 4
4200c9b2:	0c0c      	movi.n	a12, 0
4200c9b4:	0d0c      	movi.n	a13, 0
4200c9b6:	d0da81        	l32r	a8, 42000d20 <_stext+0xd00> (4000228c <__eqdf2>)
4200c9b9:	0008e0        	callx8	a8
4200c9bc:	0adc      	bnez.n	a10, 4200c9d0 <_vfprintf_r+0xef0>
4200c9be:	906152        	s32i	a5, a1, 0x240
4200c9c1:	0002c6        	j	4200c9d0 <_vfprintf_r+0xef0>
4200c9c4:	a81b      	addi.n	a10, a8, 1
4200c9c6:	9061a2        	s32i	a10, a1, 0x240
4200c9c9:	004892        	s8i	a9, a8, 0
4200c9cc:	000086        	j	4200c9d2 <_vfprintf_r+0xef2>
4200c9cf:	093c00        	l32e	a0, a12, -52
4200c9d2:	902182        	l32i	a8, a1, 0x240
4200c9d5:	eb3857        	bltu	a8, a5, 4200c9c4 <_vfprintf_r+0xee4>
4200c9d8:	ffdcc6        	j	4200c94f <_vfprintf_r+0xe6f>
4200c9db:	000000        	ill
4200c9de:	d87c      	movi.n	a8, -3
4200c9e0:	082687        	blt	a6, a8, 4200c9ec <_vfprintf_r+0xf0c>
4200c9e3:	a22182        	l32i	a8, a1, 0x288
4200c9e6:	022867        	blt	a8, a6, 4200c9ec <_vfprintf_r+0xf0c>
4200c9e9:	0048c6        	j	4200cb10 <_vfprintf_r+0x1030>
4200c9ec:	a32182        	l32i	a8, a1, 0x28c
4200c9ef:	fec882        	addi	a8, a8, -2
4200c9f2:	a36182        	s32i	a8, a1, 0x28c
4200c9f5:	0001c6        	j	4200ca00 <_vfprintf_r+0xf20>
4200c9f8:	684c      	movi.n	a8, 70
4200c9fa:	029487        	bne	a4, a8, 4200ca00 <_vfprintf_r+0xf20>
4200c9fd:	004606        	j	4200cb19 <_vfprintf_r+0x1039>
4200ca00:	a32192        	l32i	a9, a1, 0x28c
4200ca03:	dfafb2        	movi	a11, -33
4200ca06:	10b9b0        	and	a11, a9, a11
4200ca09:	8ca292        	movi	a9, 0x28c
4200ca0c:	991a      	add.n	a9, a9, a1
4200ca0e:	860b      	addi.n	a8, a6, -1
4200ca10:	0009a2        	l8ui	a10, a9, 0
4200ca13:	956182        	s32i	a8, a1, 0x254
4200ca16:	194c      	movi.n	a9, 65
4200ca18:	049b97        	bne	a11, a9, 4200ca20 <_vfprintf_r+0xf40>
4200ca1b:	aafb      	addi.n	a10, a10, 15
4200ca1d:	74a0a0        	extui	a10, a10, 0, 8
4200ca20:	10c192        	addi	a9, a1, 16
4200ca23:	02d9c2        	addmi	a12, a9, 0x200
4200ca26:	374ca2        	s8i	a10, a12, 55
4200ca29:	ba2c      	movi.n	a10, 43
4200ca2b:	0068d6        	bgez	a8, 4200ca35 <_vfprintf_r+0xf55>
4200ca2e:	860b      	addi.n	a8, a6, -1
4200ca30:	608080        	neg	a8, a8
4200ca33:	da2c      	movi.n	a10, 45
4200ca35:	02d9c2        	addmi	a12, a9, 0x200
4200ca38:	384ca2        	s8i	a10, a12, 56
4200ca3b:	9a0c      	movi.n	a10, 9
4200ca3d:	70aa87        	bge	a10, a8, 4200cab1 <_vfprintf_r+0xfd1>
4200ca40:	37a2a2        	movi	a10, 0x237
4200ca43:	ceaee1        	l32r	a14, 420004fc <_stext+0x4dc> (cccccccd <_rtc_reserved_end+0x6cbccccd>)
4200ca46:	8099a0        	add	a9, a9, a10
4200ca49:	63a0d2        	movi	a13, 99
4200ca4c:	a2b8e0        	muluh	a11, a8, a14
4200ca4f:	09cd      	mov.n	a12, a9
4200ca51:	41b3b0        	srli	a11, a11, 3
4200ca54:	a0abb0        	addx4	a10, a11, a11
4200ca57:	aaaa      	add.n	a10, a10, a10
4200ca59:	c0a8a0        	sub	a10, a8, a10
4200ca5c:	30caa2        	addi	a10, a10, 48
4200ca5f:	990b      	addi.n	a9, a9, -1
4200ca61:	0049a2        	s8i	a10, a9, 0
4200ca64:	08ad      	mov.n	a10, a8
4200ca66:	0b8d      	mov.n	a8, a11
4200ca68:	e02da7        	blt	a13, a10, 4200ca4c <_vfprintf_r+0xf6c>
4200ca6b:	30cb82        	addi	a8, a11, 48
4200ca6e:	fecc92        	addi	a9, a12, -2
4200ca71:	10c1a2        	addi	a10, a1, 16
4200ca74:	004982        	s8i	a8, a9, 0
4200ca77:	39a2b2        	movi	a11, 0x239
4200ca7a:	30a282        	movi	a8, 0x230
4200ca7d:	baba      	add.n	a11, a10, a11
4200ca7f:	aa8a      	add.n	a10, a10, a8
4200ca81:	0bdd      	mov.n	a13, a11
4200ca83:	8a7b      	addi.n	a8, a10, 7
4200ca85:	000246        	j	4200ca92 <_vfprintf_r+0xfb2>
4200ca88:	0009e2        	l8ui	a14, a9, 0
4200ca8b:	991b      	addi.n	a9, a9, 1
4200ca8d:	004de2        	s8i	a14, a13, 0
4200ca90:	dd1b      	addi.n	a13, a13, 1
4200ca92:	f23987        	bltu	a9, a8, 4200ca88 <_vfprintf_r+0xfa8>
4200ca95:	fecc92        	addi	a9, a12, -2
4200ca98:	628890        	lsi	f9, a8, 0x188
4200ca9b:	880b      	addi.n	a8, a8, -1
4200ca9d:	608080        	neg	a8, a8
4200caa0:	748080        	extui	a8, a8, 0, 8
4200caa3:	090c      	movi.n	a9, 0
4200caa5:	388c      	beqz.n	a8, 4200caac <_vfprintf_r+0xfcc>
4200caa7:	aa9b      	addi.n	a10, a10, 9
4200caa9:	c09ac0        	sub	a9, a10, a12
4200caac:	99ba      	add.n	a9, a9, a11
4200caae:	000706        	j	4200cace <_vfprintf_r+0xfee>
4200cab1:	39a2a2        	movi	a10, 0x239
4200cab4:	1d4c      	movi.n	a13, 65
4200cab6:	a9aa      	add.n	a10, a9, a10
4200cab8:	091bd7        	beq	a11, a13, 4200cac5 <_vfprintf_r+0xfe5>
4200cabb:	0a3c      	movi.n	a10, 48
4200cabd:	394ca2        	s8i	a10, a12, 57
4200cac0:	3aa2a2        	movi	a10, 0x23a
4200cac3:	a9aa      	add.n	a10, a9, a10
4200cac5:	30c882        	addi	a8, a8, 48
4200cac8:	01ca92        	addi	a9, a10, 1
4200cacb:	004a82        	s8i	a8, a10, 0
4200cace:	47a282        	movi	a8, 0x247
4200cad1:	808180        	add	a8, a1, a8
4200cad4:	c08980        	sub	a8, a9, a8
4200cad7:	a42192        	l32i	a9, a1, 0x290
4200cada:	b76182        	s32i	a8, a1, 0x2dc
4200cadd:	808890        	add	a8, a8, a9
4200cae0:	a26182        	s32i	a8, a1, 0x288
4200cae3:	0229e6        	bgei	a9, 2, 4200cae9 <_vfprintf_r+0x1009>
4200cae6:	0a6307        	bbci	a3, 0, 4200caf4 <_vfprintf_r+0x1014>
4200cae9:	a22182        	l32i	a8, a1, 0x288
4200caec:	ad2192        	l32i	a9, a1, 0x2b4
4200caef:	889a      	add.n	a8, a8, a9
4200caf1:	a26182        	s32i	a8, a1, 0x288
4200caf4:	ffab82        	movi	a8, 0xfffffbff
4200caf7:	108380        	and	a8, a3, a8
4200cafa:	00a192        	movi	a9, 0x100
4200cafd:	208890        	or	a8, a8, a9
4200cb00:	af6182        	s32i	a8, a1, 0x2bc
4200cb03:	080c      	movi.n	a8, 0
4200cb05:	ab6182        	s32i	a8, a1, 0x2ac
4200cb08:	050c      	movi.n	a5, 0
4200cb0a:	060c      	movi.n	a6, 0
4200cb0c:	003806        	j	4200cbf0 <_vfprintf_r+0x1110>
4200cb0f:	218200        	srai	a8, a0, 2
4200cb12:	a687a4        	lsi	f10, a7, 0x298
4200cb15:	862d      	lsi	f2, a6, 24
4200cb17:	0f          	.byte	0xf
4200cb18:	219200        	srai	a9, a0, 2
4200cb1b:	8030a2        	lsi	f10, a0, 0x200
4200cb1e:	889004        	lsi	f0, a0, 0x220
4200cb21:	16a620        	lsi	f2, a6, 88
4200cb24:	160a      	add.n	a1, a6, a0
4200cb26:	0508      	l32i.n	a0, a5, 0
4200cb28:	ad2182        	l32i	a8, a1, 0x2b4
4200cb2b:	868a      	add.n	a8, a6, a8
4200cb2d:	000286        	j	4200cb3b <_vfprintf_r+0x105b>
4200cb30:	051816        	beqz	a8, 4200cb85 <_vfprintf_r+0x10a5>
4200cb33:	ad2182        	l32i	a8, a1, 0x2b4
4200cb36:	a22192        	l32i	a9, a1, 0x288
4200cb39:	881b      	addi.n	a8, a8, 1
4200cb3b:	898a      	add.n	a8, a9, a8
4200cb3d:	a26182        	s32i	a8, a1, 0x288
4200cb40:	000e06        	j	4200cb7c <_vfprintf_r+0x109c>
4200cb43:	a08200        	addx4	a8, a2, a0
4200cb46:	618267        	bany	a2, a6, 4200cbab <_vfprintf_r+0x10cb>
4200cb49:	6162a3        	lsi	f10, a2, 0x184
4200cb4c:	2192a2        	l16si	a10, a2, 66
4200cb4f:	8dad      	lsi	f10, a13, 52
4200cb51:	e30706        	j	42005771 <esp_mprot_set_prot+0x685>
4200cb54:	1e          	.byte	0x1e
4200cb55:	000dc6        	j	4200cb90 <_vfprintf_r+0x10b0>
4200cb58:	a42182        	l32i	a8, a1, 0x290
4200cb5b:	ad2192        	l32i	a9, a1, 0x2b4
4200cb5e:	889a      	add.n	a8, a8, a9
4200cb60:	a26182        	s32i	a8, a1, 0x288
4200cb63:	67a082        	movi	a8, 103
4200cb66:	a36182        	s32i	a8, a1, 0x28c
4200cb69:	2316e6        	bgei	a6, 1, 4200cb90 <_vfprintf_r+0x10b0>
4200cb6c:	860b      	addi.n	a8, a6, -1
4200cb6e:	a22192        	l32i	a9, a1, 0x288
4200cb71:	608080        	neg	a8, a8
4200cb74:	898a      	add.n	a8, a9, a8
4200cb76:	0004c6        	j	4200cb8d <_vfprintf_r+0x10ad>
4200cb79:	a26162        	s32i	a6, a1, 0x288
4200cb7c:	66a082        	movi	a8, 102
4200cb7f:	a36182        	s32i	a8, a1, 0x28c
4200cb82:	000286        	j	4200cb90 <_vfprintf_r+0x10b0>
4200cb85:	66a082        	movi	a8, 102
4200cb88:	a36182        	s32i	a8, a1, 0x28c
4200cb8b:	180c      	movi.n	a8, 1
4200cb8d:	a26182        	s32i	a8, a1, 0x288
4200cb90:	00a452        	movi	a5, 0x400
4200cb93:	080c      	movi.n	a8, 0
4200cb95:	105350        	and	a5, a3, a5
4200cb98:	ab6182        	s32i	a8, a1, 0x2ac
4200cb9b:	051516        	beqz	a5, 4200cbf0 <_vfprintf_r+0x1110>
4200cb9e:	050c      	movi.n	a5, 0
4200cba0:	2d16e6        	bgei	a6, 1, 4200cbd1 <_vfprintf_r+0x10f1>
4200cba3:	001246        	j	4200cbf0 <_vfprintf_r+0x1110>
4200cba6:	670000        	lsi	f0, a0, 0x19c
4200cba9:	31a8      	l32i.n	a10, a1, 12
4200cbab:	c06680        	sub	a6, a6, a8
4200cbae:	aa2182        	l32i	a8, a1, 0x2a8
4200cbb1:	010882        	l8ui	a8, a8, 1
4200cbb4:	b88c      	beqz.n	a8, 4200cbc3 <_vfprintf_r+0x10e3>
4200cbb6:	aa2182        	l32i	a8, a1, 0x2a8
4200cbb9:	551b      	addi.n	a5, a5, 1
4200cbbb:	881b      	addi.n	a8, a8, 1
4200cbbd:	aa6182        	s32i	a8, a1, 0x2a8
4200cbc0:	000406        	j	4200cbd4 <_vfprintf_r+0x10f4>
4200cbc3:	ab2182        	l32i	a8, a1, 0x2ac
4200cbc6:	881b      	addi.n	a8, a8, 1
4200cbc8:	ab6182        	s32i	a8, a1, 0x2ac
4200cbcb:	000146        	j	4200cbd4 <_vfprintf_r+0x10f4>
4200cbce:	000000        	ill
4200cbd1:	ffa092        	movi	a9, 255
4200cbd4:	aa2182        	l32i	a8, a1, 0x2a8
4200cbd7:	000882        	l8ui	a8, a8, 0
4200cbda:	ca9897        	bne	a8, a9, 4200cba8 <_vfprintf_r+0x10c8>
4200cbdd:	ab2182        	l32i	a8, a1, 0x2ac
4200cbe0:	b02192        	l32i	a9, a1, 0x2c0
4200cbe3:	858a      	add.n	a8, a5, a8
4200cbe5:	828890        	mull	a8, a8, a9
4200cbe8:	a22192        	l32i	a9, a1, 0x288
4200cbeb:	889a      	add.n	a8, a8, a9
4200cbed:	a26182        	s32i	a8, a1, 0x288
4200cbf0:	b92182        	l32i	a8, a1, 0x2e4
4200cbf3:	68cc      	bnez.n	a8, 4200cbfd <_vfprintf_r+0x111d>
4200cbf5:	af2132        	l32i	a3, a1, 0x2bc
4200cbf8:	040c      	movi.n	a4, 0
4200cbfa:	03f6c6        	j	4200dbd9 <_vfprintf_r+0x20f9>
4200cbfd:	10c182        	addi	a8, a1, 16
4200cc00:	02d882        	addmi	a8, a8, 0x200
4200cc03:	d92c      	movi.n	a9, 45
4200cc05:	524892        	s8i	a9, a8, 82
4200cc08:	fffa46        	j	4200cbf5 <_vfprintf_r+0x1115>
4200cc0b:	218200        	srai	a8, a0, 2
4200cc0e:	c1e297        	bbsi	a2, 9, 4200cbd3 <_vfprintf_r+0x10f3>
4200cc11:	e35710        	lsi	f1, a7, 0x38c
4200cc14:	2c0602        	l8ui	a0, a6, 44
4200cc17:	c4ac00        	extui	a10, a0, 12, 13
4200cc1a:	07a687        	bge	a6, a8, 4200cc25 <_vfprintf_r+0x1145>
4200cc1d:	b0e6e0        	addx8	a14, a6, a14
4200cc20:	0e98      	l32i.n	a9, a14, 0
4200cc22:	000706        	j	4200cc42 <_vfprintf_r+0x1162>
4200cc25:	48a282        	movi	a8, 0x248
4200cc28:	8e8a      	add.n	a8, a14, a8
4200cc2a:	4ca2d2        	movi	a13, 0x24c
4200cc2d:	60a2c2        	movi	a12, 0x260
4200cc30:	0189      	s32i.n	a8, a1, 0
4200cc32:	01def2        	addmi	a15, a14, 0x100
4200cc35:	deda      	add.n	a13, a14, a13
4200cc37:	ceca      	add.n	a12, a14, a12
4200cc39:	05bd      	mov.n	a11, a5
4200cc3b:	06ad      	mov.n	a10, a6
4200cc3d:	fe9d25        	call8	4200b610 <get_arg$isra$0>
4200cc40:	0a98      	l32i.n	a9, a10, 0
4200cc42:	07ad      	mov.n	a10, a7
4200cc44:	001d06        	j	4200ccbc <_vfprintf_r+0x11dc>
4200cc47:	a71b00        	lsi	f0, a11, 0x29c
4200cc4a:	07a787        	bge	a7, a8, 4200cc55 <_vfprintf_r+0x1175>
4200cc4d:	b0e6e0        	addx8	a14, a6, a14
4200cc50:	0e98      	l32i.n	a9, a14, 0
4200cc52:	001986        	j	4200ccbc <_vfprintf_r+0x11dc>
4200cc55:	9a2eb2        	l32i	a11, a14, 0x268
4200cc58:	fc1c      	movi.n	a12, 31
4200cc5a:	02dee2        	addmi	a14, a14, 0x200
4200cc5d:	9b4b      	addi.n	a9, a11, 4
4200cc5f:	322c87        	blt	a12, a8, 4200cc95 <_vfprintf_r+0x11b5>
4200cc62:	c81b      	addi.n	a12, a8, 1
4200cc64:	9761c2        	s32i	a12, a1, 0x25c
4200cc67:	1a6e92        	s32i	a9, a14, 104
4200cc6a:	8c1c      	movi.n	a12, 24
4200cc6c:	052c97        	blt	a12, a9, 4200cc75 <_vfprintf_r+0x1195>
4200cc6f:	192eb2        	l32i	a11, a14, 100
4200cc72:	000406        	j	4200cc86 <_vfprintf_r+0x11a6>
4200cc75:	012cb7        	blt	a12, a11, 4200cc7a <_vfprintf_r+0x119a>
4200cc78:	492c      	movi.n	a9, 36
4200cc7a:	10c1b2        	addi	a11, a1, 16
4200cc7d:	02dbb2        	addmi	a11, a11, 0x200
4200cc80:	182bb2        	l32i	a11, a11, 96
4200cc83:	9e6192        	s32i	a9, a1, 0x278
4200cc86:	bb9a      	add.n	a11, a11, a9
4200cc88:	fccbb2        	addi	a11, a11, -4
4200cc8b:	0b98      	l32i.n	a9, a11, 0
4200cc8d:	b08810        	addx8	a8, a8, a1
4200cc90:	4899      	s32i.n	a9, a8, 16
4200cc92:	000986        	j	4200ccbc <_vfprintf_r+0x11dc>
4200cc95:	1a6e92        	s32i	a9, a14, 104
4200cc98:	881c      	movi.n	a8, 24
4200cc9a:	062897        	blt	a8, a9, 4200cca4 <_vfprintf_r+0x11c4>
4200cc9d:	192e82        	l32i	a8, a14, 100
4200cca0:	000446        	j	4200ccb5 <_vfprintf_r+0x11d5>
4200cca3:	28b700        	lsi	f0, a7, 160
4200cca6:	492c01        	l32r	a0, 41fdf158 <_coredump_iram_end+0x1c5d258>
4200cca9:	10c182        	addi	a8, a1, 16
4200ccac:	02d882        	addmi	a8, a8, 0x200
4200ccaf:	182882        	l32i	a8, a8, 96
4200ccb2:	9e6192        	s32i	a9, a1, 0x278
4200ccb5:	889a      	add.n	a8, a8, a9
4200ccb7:	fcc882        	addi	a8, a8, -4
4200ccba:	0898      	l32i.n	a9, a8, 0
4200ccbc:	ae2182        	l32i	a8, a1, 0x2b8
4200ccbf:	0989      	s32i.n	a8, a9, 0
4200ccc1:	318f80        	srai	a8, a8, 31
4200ccc4:	1989      	s32i.n	a8, a9, 4
4200ccc6:	002e06        	j	4200cd82 <_vfprintf_r+0x12a2>
4200ccc9:	026347        	bbci	a3, 4, 4200cccf <_vfprintf_r+0x11ef>
4200cccc:	005b46        	j	4200ce3d <_vfprintf_r+0x135d>
4200cccf:	02e367        	bbsi	a3, 6, 4200ccd5 <_vfprintf_r+0x11f5>
4200ccd2:	002c86        	j	4200cd88 <_vfprintf_r+0x12a8>
4200ccd5:	f4ac      	beqz.n	a4, 4200cd08 <_vfprintf_r+0x1228>
4200ccd7:	0aa687        	bge	a6, a8, 4200cce5 <_vfprintf_r+0x1205>
4200ccda:	b0e6e0        	addx8	a14, a6, a14
4200ccdd:	0e98      	l32i.n	a9, a14, 0
4200ccdf:	0007c6        	j	4200cd02 <_vfprintf_r+0x1222>
4200cce2:	000000        	ill
4200cce5:	48a282        	movi	a8, 0x248
4200cce8:	8e8a      	add.n	a8, a14, a8
4200ccea:	4ca2d2        	movi	a13, 0x24c
4200cced:	60a2c2        	movi	a12, 0x260
4200ccf0:	0189      	s32i.n	a8, a1, 0
4200ccf2:	01def2        	addmi	a15, a14, 0x100
4200ccf5:	deda      	add.n	a13, a14, a13
4200ccf7:	ceca      	add.n	a12, a14, a12
4200ccf9:	05bd      	mov.n	a11, a5
4200ccfb:	06ad      	mov.n	a10, a6
4200ccfd:	fe9125        	call8	4200b610 <get_arg$isra$0>
4200cd00:	0a98      	l32i.n	a9, a10, 0
4200cd02:	07ad      	mov.n	a10, a7
4200cd04:	001d06        	j	4200cd7c <_vfprintf_r+0x129c>
4200cd07:	a71b00        	lsi	f0, a11, 0x29c
4200cd0a:	07a787        	bge	a7, a8, 4200cd15 <_vfprintf_r+0x1235>
4200cd0d:	b0e6e0        	addx8	a14, a6, a14
4200cd10:	0e98      	l32i.n	a9, a14, 0
4200cd12:	001986        	j	4200cd7c <_vfprintf_r+0x129c>
4200cd15:	9a2eb2        	l32i	a11, a14, 0x268
4200cd18:	fc1c      	movi.n	a12, 31
4200cd1a:	02dee2        	addmi	a14, a14, 0x200
4200cd1d:	9b4b      	addi.n	a9, a11, 4
4200cd1f:	322c87        	blt	a12, a8, 4200cd55 <_vfprintf_r+0x1275>
4200cd22:	c81b      	addi.n	a12, a8, 1
4200cd24:	9761c2        	s32i	a12, a1, 0x25c
4200cd27:	1a6e92        	s32i	a9, a14, 104
4200cd2a:	8c1c      	movi.n	a12, 24
4200cd2c:	052c97        	blt	a12, a9, 4200cd35 <_vfprintf_r+0x1255>
4200cd2f:	192eb2        	l32i	a11, a14, 100
4200cd32:	000406        	j	4200cd46 <_vfprintf_r+0x1266>
4200cd35:	012cb7        	blt	a12, a11, 4200cd3a <_vfprintf_r+0x125a>
4200cd38:	492c      	movi.n	a9, 36
4200cd3a:	10c1b2        	addi	a11, a1, 16
4200cd3d:	02dbb2        	addmi	a11, a11, 0x200
4200cd40:	182bb2        	l32i	a11, a11, 96
4200cd43:	9e6192        	s32i	a9, a1, 0x278
4200cd46:	bb9a      	add.n	a11, a11, a9
4200cd48:	fccbb2        	addi	a11, a11, -4
4200cd4b:	0b98      	l32i.n	a9, a11, 0
4200cd4d:	b08810        	addx8	a8, a8, a1
4200cd50:	4899      	s32i.n	a9, a8, 16
4200cd52:	000986        	j	4200cd7c <_vfprintf_r+0x129c>
4200cd55:	1a6e92        	s32i	a9, a14, 104
4200cd58:	881c      	movi.n	a8, 24
4200cd5a:	062897        	blt	a8, a9, 4200cd64 <_vfprintf_r+0x1284>
4200cd5d:	192e82        	l32i	a8, a14, 100
4200cd60:	000446        	j	4200cd75 <_vfprintf_r+0x1295>
4200cd63:	28b700        	lsi	f0, a7, 160
4200cd66:	492c01        	l32r	a0, 41fdf218 <_coredump_iram_end+0x1c5d318>
4200cd69:	10c182        	addi	a8, a1, 16
4200cd6c:	02d882        	addmi	a8, a8, 0x200
4200cd6f:	182882        	l32i	a8, a8, 96
4200cd72:	9e6192        	s32i	a9, a1, 0x278
4200cd75:	889a      	add.n	a8, a8, a9
4200cd77:	fcc882        	addi	a8, a8, -4
4200cd7a:	0898      	l32i.n	a9, a8, 0
4200cd7c:	ae2182        	l32i	a8, a1, 0x2b8
4200cd7f:	005982        	s16i	a8, a9, 0
4200cd82:	0a7d      	mov.n	a7, a10
4200cd84:	fbaa86        	j	4200bc32 <_vfprintf_r+0x152>
4200cd87:	e39700        	lsi	f0, a7, 0x38c
4200cd8a:	2b8602        	lsi	f0, a6, 172
4200cd8d:	e4ac00        	extui	a10, a0, 12, 15
4200cd90:	09a687        	bge	a6, a8, 4200cd9d <_vfprintf_r+0x12bd>
4200cd93:	b0e6e0        	addx8	a14, a6, a14
4200cd96:	0e98      	l32i.n	a9, a14, 0
4200cd98:	000786        	j	4200cdba <_vfprintf_r+0x12da>
4200cd9b:	820000        	mull	a0, a0, a0
4200cd9e:	8a48a2        	s8i	a10, a8, 138
4200cda1:	8e          	.byte	0x8e
4200cda2:	4ca2d2        	movi	a13, 0x24c
4200cda5:	60a2c2        	movi	a12, 0x260
4200cda8:	0189      	s32i.n	a8, a1, 0
4200cdaa:	01def2        	addmi	a15, a14, 0x100
4200cdad:	deda      	add.n	a13, a14, a13
4200cdaf:	ceca      	add.n	a12, a14, a12
4200cdb1:	05bd      	mov.n	a11, a5
4200cdb3:	06ad      	mov.n	a10, a6
4200cdb5:	fe85a5        	call8	4200b610 <get_arg$isra$0>
4200cdb8:	0a98      	l32i.n	a9, a10, 0
4200cdba:	07ad      	mov.n	a10, a7
4200cdbc:	001d06        	j	4200ce34 <_vfprintf_r+0x1354>
4200cdbf:	a71b00        	lsi	f0, a11, 0x29c
4200cdc2:	07a787        	bge	a7, a8, 4200cdcd <_vfprintf_r+0x12ed>
4200cdc5:	b0e6e0        	addx8	a14, a6, a14
4200cdc8:	0e98      	l32i.n	a9, a14, 0
4200cdca:	001986        	j	4200ce34 <_vfprintf_r+0x1354>
4200cdcd:	9a2eb2        	l32i	a11, a14, 0x268
4200cdd0:	fc1c      	movi.n	a12, 31
4200cdd2:	02dee2        	addmi	a14, a14, 0x200
4200cdd5:	9b4b      	addi.n	a9, a11, 4
4200cdd7:	322c87        	blt	a12, a8, 4200ce0d <_vfprintf_r+0x132d>
4200cdda:	c81b      	addi.n	a12, a8, 1
4200cddc:	9761c2        	s32i	a12, a1, 0x25c
4200cddf:	1a6e92        	s32i	a9, a14, 104
4200cde2:	8c1c      	movi.n	a12, 24
4200cde4:	052c97        	blt	a12, a9, 4200cded <_vfprintf_r+0x130d>
4200cde7:	192eb2        	l32i	a11, a14, 100
4200cdea:	000406        	j	4200cdfe <_vfprintf_r+0x131e>
4200cded:	012cb7        	blt	a12, a11, 4200cdf2 <_vfprintf_r+0x1312>
4200cdf0:	492c      	movi.n	a9, 36
4200cdf2:	10c1b2        	addi	a11, a1, 16
4200cdf5:	02dbb2        	addmi	a11, a11, 0x200
4200cdf8:	182bb2        	l32i	a11, a11, 96
4200cdfb:	9e6192        	s32i	a9, a1, 0x278
4200cdfe:	bb9a      	add.n	a11, a11, a9
4200ce00:	fccbb2        	addi	a11, a11, -4
4200ce03:	0b98      	l32i.n	a9, a11, 0
4200ce05:	b08810        	addx8	a8, a8, a1
4200ce08:	4899      	s32i.n	a9, a8, 16
4200ce0a:	000986        	j	4200ce34 <_vfprintf_r+0x1354>
4200ce0d:	1a6e92        	s32i	a9, a14, 104
4200ce10:	881c      	movi.n	a8, 24
4200ce12:	062897        	blt	a8, a9, 4200ce1c <_vfprintf_r+0x133c>
4200ce15:	192e82        	l32i	a8, a14, 100
4200ce18:	000446        	j	4200ce2d <_vfprintf_r+0x134d>
4200ce1b:	28b700        	lsi	f0, a7, 160
4200ce1e:	492c01        	l32r	a0, 41fdf2d0 <_coredump_iram_end+0x1c5d3d0>
4200ce21:	10c182        	addi	a8, a1, 16
4200ce24:	02d882        	addmi	a8, a8, 0x200
4200ce27:	182882        	l32i	a8, a8, 96
4200ce2a:	9e6192        	s32i	a9, a1, 0x278
4200ce2d:	889a      	add.n	a8, a8, a9
4200ce2f:	fcc882        	addi	a8, a8, -4
4200ce32:	0898      	l32i.n	a9, a8, 0
4200ce34:	ae2182        	l32i	a8, a1, 0x2b8
4200ce37:	004982        	s8i	a8, a9, 0
4200ce3a:	ffd106        	j	4200cd82 <_vfprintf_r+0x12a2>
4200ce3d:	f4ac      	beqz.n	a4, 4200ce70 <_vfprintf_r+0x1390>
4200ce3f:	0aa687        	bge	a6, a8, 4200ce4d <_vfprintf_r+0x136d>
4200ce42:	b0e6e0        	addx8	a14, a6, a14
4200ce45:	0e98      	l32i.n	a9, a14, 0
4200ce47:	0007c6        	j	4200ce6a <_vfprintf_r+0x138a>
4200ce4a:	000000        	ill
4200ce4d:	48a282        	movi	a8, 0x248
4200ce50:	8e8a      	add.n	a8, a14, a8
4200ce52:	4ca2d2        	movi	a13, 0x24c
4200ce55:	60a2c2        	movi	a12, 0x260
4200ce58:	0189      	s32i.n	a8, a1, 0
4200ce5a:	01def2        	addmi	a15, a14, 0x100
4200ce5d:	deda      	add.n	a13, a14, a13
4200ce5f:	ceca      	add.n	a12, a14, a12
4200ce61:	05bd      	mov.n	a11, a5
4200ce63:	06ad      	mov.n	a10, a6
4200ce65:	fe7aa5        	call8	4200b610 <get_arg$isra$0>
4200ce68:	0a98      	l32i.n	a9, a10, 0
4200ce6a:	07ad      	mov.n	a10, a7
4200ce6c:	001d06        	j	4200cee4 <_vfprintf_r+0x1404>
4200ce6f:	a71b00        	lsi	f0, a11, 0x29c
4200ce72:	07a787        	bge	a7, a8, 4200ce7d <_vfprintf_r+0x139d>
4200ce75:	b0e6e0        	addx8	a14, a6, a14
4200ce78:	0e98      	l32i.n	a9, a14, 0
4200ce7a:	001986        	j	4200cee4 <_vfprintf_r+0x1404>
4200ce7d:	9a2eb2        	l32i	a11, a14, 0x268
4200ce80:	fc1c      	movi.n	a12, 31
4200ce82:	02dee2        	addmi	a14, a14, 0x200
4200ce85:	9b4b      	addi.n	a9, a11, 4
4200ce87:	322c87        	blt	a12, a8, 4200cebd <_vfprintf_r+0x13dd>
4200ce8a:	c81b      	addi.n	a12, a8, 1
4200ce8c:	9761c2        	s32i	a12, a1, 0x25c
4200ce8f:	1a6e92        	s32i	a9, a14, 104
4200ce92:	8c1c      	movi.n	a12, 24
4200ce94:	052c97        	blt	a12, a9, 4200ce9d <_vfprintf_r+0x13bd>
4200ce97:	192eb2        	l32i	a11, a14, 100
4200ce9a:	000406        	j	4200ceae <_vfprintf_r+0x13ce>
4200ce9d:	012cb7        	blt	a12, a11, 4200cea2 <_vfprintf_r+0x13c2>
4200cea0:	492c      	movi.n	a9, 36
4200cea2:	10c1b2        	addi	a11, a1, 16
4200cea5:	02dbb2        	addmi	a11, a11, 0x200
4200cea8:	182bb2        	l32i	a11, a11, 96
4200ceab:	9e6192        	s32i	a9, a1, 0x278
4200ceae:	bb9a      	add.n	a11, a11, a9
4200ceb0:	fccbb2        	addi	a11, a11, -4
4200ceb3:	0b98      	l32i.n	a9, a11, 0
4200ceb5:	b08810        	addx8	a8, a8, a1
4200ceb8:	4899      	s32i.n	a9, a8, 16
4200ceba:	000986        	j	4200cee4 <_vfprintf_r+0x1404>
4200cebd:	1a6e92        	s32i	a9, a14, 104
4200cec0:	881c      	movi.n	a8, 24
4200cec2:	062897        	blt	a8, a9, 4200cecc <_vfprintf_r+0x13ec>
4200cec5:	192e82        	l32i	a8, a14, 100
4200cec8:	000446        	j	4200cedd <_vfprintf_r+0x13fd>
4200cecb:	28b700        	lsi	f0, a7, 160
4200cece:	492c01        	l32r	a0, 41fdf380 <_coredump_iram_end+0x1c5d480>
4200ced1:	10c182        	addi	a8, a1, 16
4200ced4:	02d882        	addmi	a8, a8, 0x200
4200ced7:	182882        	l32i	a8, a8, 96
4200ceda:	9e6192        	s32i	a9, a1, 0x278
4200cedd:	889a      	add.n	a8, a8, a9
4200cedf:	fcc882        	addi	a8, a8, -4
4200cee2:	0898      	l32i.n	a9, a8, 0
4200cee4:	ae2182        	l32i	a8, a1, 0x2b8
4200cee7:	0989      	s32i.n	a8, a9, 0
4200cee9:	ffa546        	j	4200cd82 <_vfprintf_r+0x12a2>
4200ceec:	081c      	movi.n	a8, 16
4200ceee:	203380        	or	a3, a3, a8
4200cef1:	972192        	l32i	a9, a1, 0x25c
4200cef4:	10c1e2        	addi	a14, a1, 16
4200cef7:	02e357        	bbsi	a3, 5, 4200cefd <_vfprintf_r+0x141d>
4200cefa:	002fc6        	j	4200cfbd <_vfprintf_r+0x14dd>
4200cefd:	04bc      	beqz.n	a4, 4200cf31 <_vfprintf_r+0x1451>
4200ceff:	09a697        	bge	a6, a9, 4200cf0c <_vfprintf_r+0x142c>
4200cf02:	b0e6e0        	addx8	a14, a6, a14
4200cf05:	0e58      	l32i.n	a5, a14, 0
4200cf07:	1e48      	l32i.n	a4, a14, 4
4200cf09:	0007c6        	j	4200cf2c <_vfprintf_r+0x144c>
4200cf0c:	48a282        	movi	a8, 0x248
4200cf0f:	8e8a      	add.n	a8, a14, a8
4200cf11:	4ca2d2        	movi	a13, 0x24c
4200cf14:	60a2c2        	movi	a12, 0x260
4200cf17:	05bd      	mov.n	a11, a5
4200cf19:	0189      	s32i.n	a8, a1, 0
4200cf1b:	01def2        	addmi	a15, a14, 0x100
4200cf1e:	deda      	add.n	a13, a14, a13
4200cf20:	ceca      	add.n	a12, a14, a12
4200cf22:	20a660        	or	a10, a6, a6
4200cf25:	fe6ea5        	call8	4200b610 <get_arg$isra$0>
4200cf28:	0a58      	l32i.n	a5, a10, 0
4200cf2a:	1a48      	l32i.n	a4, a10, 4
4200cf2c:	078d      	mov.n	a8, a7
4200cf2e:	00a806        	j	4200d1d2 <_vfprintf_r+0x16f2>
4200cf31:	871b      	addi.n	a8, a7, 1
4200cf33:	09a797        	bge	a7, a9, 4200cf40 <_vfprintf_r+0x1460>
4200cf36:	b0e6e0        	addx8	a14, a6, a14
4200cf39:	0e58      	l32i.n	a5, a14, 0
4200cf3b:	1e48      	l32i.n	a4, a14, 4
4200cf3d:	00a446        	j	4200d1d2 <_vfprintf_r+0x16f2>
4200cf40:	9a2eb2        	l32i	a11, a14, 0x268
4200cf43:	8a7c      	movi.n	a10, -8
4200cf45:	bb7b      	addi.n	a11, a11, 7
4200cf47:	10bba0        	and	a11, a11, a10
4200cf4a:	fc1c      	movi.n	a12, 31
4200cf4c:	02dee2        	addmi	a14, a14, 0x200
4200cf4f:	ab8b      	addi.n	a10, a11, 8
4200cf51:	3b2c97        	blt	a12, a9, 4200cf90 <_vfprintf_r+0x14b0>
4200cf54:	c91b      	addi.n	a12, a9, 1
4200cf56:	9761c2        	s32i	a12, a1, 0x25c
4200cf59:	1a6ea2        	s32i	a10, a14, 104
4200cf5c:	8c1c      	movi.n	a12, 24
4200cf5e:	062ca7        	blt	a12, a10, 4200cf68 <_vfprintf_r+0x1488>
4200cf61:	192eb2        	l32i	a11, a14, 100
4200cf64:	000446        	j	4200cf79 <_vfprintf_r+0x1499>
4200cf67:	2cb700        	lsi	f0, a7, 176
4200cf6a:	8a2c01        	l32r	a0, 41fef81c <_coredump_iram_end+0x1c6d91c>
4200cf6d:	10c1b2        	addi	a11, a1, 16
4200cf70:	02dbb2        	addmi	a11, a11, 0x200
4200cf73:	182bb2        	l32i	a11, a11, 96
4200cf76:	9e61a2        	s32i	a10, a1, 0x278
4200cf79:	abaa      	add.n	a10, a11, a10
4200cf7b:	f8caa2        	addi	a10, a10, -8
4200cf7e:	0a58      	l32i.n	a5, a10, 0
4200cf80:	1a48      	l32i.n	a4, a10, 4
4200cf82:	10c1a2        	addi	a10, a1, 16
4200cf85:	b099a0        	addx8	a9, a9, a10
4200cf88:	0959      	s32i.n	a5, a9, 0
4200cf8a:	1949      	s32i.n	a4, a9, 4
4200cf8c:	009086        	j	4200d1d2 <_vfprintf_r+0x16f2>
4200cf8f:	6ea200        	f64rnd	a10, a2, a0, 2
4200cf92:	1c1a      	add.n	a1, a12, a1
4200cf94:	a789      	s32i.n	a8, a7, 40
4200cf96:	0729      	s32i.n	a2, a7, 0
4200cf98:	192e92        	l32i	a9, a14, 100
4200cf9b:	000486        	j	4200cfb1 <_vfprintf_r+0x14d1>
4200cf9e:	b70000        	lsi	f0, a0, 0x2dc
4200cfa1:	0129      	s32i.n	a2, a1, 0
4200cfa3:	8a2c      	movi.n	a10, 40
4200cfa5:	10c192        	addi	a9, a1, 16
4200cfa8:	02d992        	addmi	a9, a9, 0x200
4200cfab:	182992        	l32i	a9, a9, 96
4200cfae:	9e61a2        	s32i	a10, a1, 0x278
4200cfb1:	99aa      	add.n	a9, a9, a10
4200cfb3:	f8c992        	addi	a9, a9, -8
4200cfb6:	0958      	l32i.n	a5, a9, 0
4200cfb8:	1948      	l32i.n	a4, a9, 4
4200cfba:	008506        	j	4200d1d2 <_vfprintf_r+0x16f2>
4200cfbd:	036347        	bbci	a3, 4, 4200cfc4 <_vfprintf_r+0x14e4>
4200cfc0:	005a06        	j	4200d12c <_vfprintf_r+0x164c>
4200cfc3:	e36700        	lsi	f0, a7, 0x38c
4200cfc6:	2b4602        	s8i	a0, a6, 43
4200cfc9:	c4ac00        	extui	a10, a0, 12, 13
4200cfcc:	09a697        	bge	a6, a9, 4200cfd9 <_vfprintf_r+0x14f9>
4200cfcf:	b0e6e0        	addx8	a14, a6, a14
4200cfd2:	001e52        	l16ui	a5, a14, 0
4200cfd5:	005f46        	j	4200d156 <_vfprintf_r+0x1676>
4200cfd8:	a28200        	muluh	a8, a2, a0
4200cfdb:	8a48      	l32i.n	a4, a10, 32
4200cfdd:	8e          	.byte	0x8e
4200cfde:	4ca2d2        	movi	a13, 0x24c
4200cfe1:	60a2c2        	movi	a12, 0x260
4200cfe4:	05bd      	mov.n	a11, a5
4200cfe6:	0189      	s32i.n	a8, a1, 0
4200cfe8:	01def2        	addmi	a15, a14, 0x100
4200cfeb:	deda      	add.n	a13, a14, a13
4200cfed:	ceca      	add.n	a12, a14, a12
4200cfef:	06ad      	mov.n	a10, a6
4200cff1:	fe61e5        	call8	4200b610 <get_arg$isra$0>
4200cff4:	001a52        	l16ui	a5, a10, 0
4200cff7:	0056c6        	j	4200d156 <_vfprintf_r+0x1676>
4200cffa:	871b      	addi.n	a8, a7, 1
4200cffc:	08a797        	bge	a7, a9, 4200d008 <_vfprintf_r+0x1528>
4200cfff:	b0e6e0        	addx8	a14, a6, a14
4200d002:	001e52        	l16ui	a5, a14, 0
4200d005:	0071c6        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d008:	9a2eb2        	l32i	a11, a14, 0x268
4200d00b:	fc1c      	movi.n	a12, 31
4200d00d:	02dee2        	addmi	a14, a14, 0x200
4200d010:	ab4b      	addi.n	a10, a11, 4
4200d012:	362c97        	blt	a12, a9, 4200d04c <_vfprintf_r+0x156c>
4200d015:	c91b      	addi.n	a12, a9, 1
4200d017:	9761c2        	s32i	a12, a1, 0x25c
4200d01a:	1a6ea2        	s32i	a10, a14, 104
4200d01d:	8c1c      	movi.n	a12, 24
4200d01f:	052ca7        	blt	a12, a10, 4200d028 <_vfprintf_r+0x1548>
4200d022:	192eb2        	l32i	a11, a14, 100
4200d025:	000406        	j	4200d039 <_vfprintf_r+0x1559>
4200d028:	012cb7        	blt	a12, a11, 4200d02d <_vfprintf_r+0x154d>
4200d02b:	4a2c      	movi.n	a10, 36
4200d02d:	10c1b2        	addi	a11, a1, 16
4200d030:	02dbb2        	addmi	a11, a11, 0x200
4200d033:	182bb2        	l32i	a11, a11, 96
4200d036:	9e61a2        	s32i	a10, a1, 0x278
4200d039:	bbaa      	add.n	a11, a11, a10
4200d03b:	fccbb2        	addi	a11, a11, -4
4200d03e:	0b58      	l32i.n	a5, a11, 0
4200d040:	b09910        	addx8	a9, a9, a1
4200d043:	4959      	s32i.n	a5, a9, 16
4200d045:	f45050        	extui	a5, a5, 0, 16
4200d048:	006106        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d04b:	6ea200        	f64rnd	a10, a2, a0, 2
4200d04e:	1c1a      	add.n	a1, a12, a1
4200d050:	a789      	s32i.n	a8, a7, 40
4200d052:	0729      	s32i.n	a2, a7, 0
4200d054:	192e92        	l32i	a9, a14, 100
4200d057:	000486        	j	4200d06d <_vfprintf_r+0x158d>
4200d05a:	b70000        	lsi	f0, a0, 0x2dc
4200d05d:	0129      	s32i.n	a2, a1, 0
4200d05f:	4a2c      	movi.n	a10, 36
4200d061:	10c192        	addi	a9, a1, 16
4200d064:	02d992        	addmi	a9, a9, 0x200
4200d067:	182992        	l32i	a9, a9, 96
4200d06a:	9e61a2        	s32i	a10, a1, 0x278
4200d06d:	99aa      	add.n	a9, a9, a10
4200d06f:	fcc992        	addi	a9, a9, -4
4200d072:	001952        	l16ui	a5, a9, 0
4200d075:	0055c6        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d078:	02e397        	bbsi	a3, 9, 4200d07e <_vfprintf_r+0x159e>
4200d07b:	002b46        	j	4200d12c <_vfprintf_r+0x164c>
4200d07e:	c4ac      	beqz.n	a4, 4200d0ae <_vfprintf_r+0x15ce>
4200d080:	09a697        	bge	a6, a9, 4200d08d <_vfprintf_r+0x15ad>
4200d083:	b0e6e0        	addx8	a14, a6, a14
4200d086:	000e52        	l8ui	a5, a14, 0
4200d089:	003246        	j	4200d156 <_vfprintf_r+0x1676>
4200d08c:	a28200        	muluh	a8, a2, a0
4200d08f:	8a48      	l32i.n	a4, a10, 32
4200d091:	8e          	.byte	0x8e
4200d092:	4ca2d2        	movi	a13, 0x24c
4200d095:	60a2c2        	movi	a12, 0x260
4200d098:	05bd      	mov.n	a11, a5
4200d09a:	0189      	s32i.n	a8, a1, 0
4200d09c:	01def2        	addmi	a15, a14, 0x100
4200d09f:	deda      	add.n	a13, a14, a13
4200d0a1:	ceca      	add.n	a12, a14, a12
4200d0a3:	06ad      	mov.n	a10, a6
4200d0a5:	fe56a5        	call8	4200b610 <get_arg$isra$0>
4200d0a8:	000a52        	l8ui	a5, a10, 0
4200d0ab:	0029c6        	j	4200d156 <_vfprintf_r+0x1676>
4200d0ae:	871b      	addi.n	a8, a7, 1
4200d0b0:	08a797        	bge	a7, a9, 4200d0bc <_vfprintf_r+0x15dc>
4200d0b3:	b0e6e0        	addx8	a14, a6, a14
4200d0b6:	000e52        	l8ui	a5, a14, 0
4200d0b9:	0044c6        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d0bc:	9a2eb2        	l32i	a11, a14, 0x268
4200d0bf:	fc1c      	movi.n	a12, 31
4200d0c1:	02dee2        	addmi	a14, a14, 0x200
4200d0c4:	ab4b      	addi.n	a10, a11, 4
4200d0c6:	362c97        	blt	a12, a9, 4200d100 <_vfprintf_r+0x1620>
4200d0c9:	c91b      	addi.n	a12, a9, 1
4200d0cb:	9761c2        	s32i	a12, a1, 0x25c
4200d0ce:	1a6ea2        	s32i	a10, a14, 104
4200d0d1:	8c1c      	movi.n	a12, 24
4200d0d3:	052ca7        	blt	a12, a10, 4200d0dc <_vfprintf_r+0x15fc>
4200d0d6:	192eb2        	l32i	a11, a14, 100
4200d0d9:	000406        	j	4200d0ed <_vfprintf_r+0x160d>
4200d0dc:	012cb7        	blt	a12, a11, 4200d0e1 <_vfprintf_r+0x1601>
4200d0df:	4a2c      	movi.n	a10, 36
4200d0e1:	10c1b2        	addi	a11, a1, 16
4200d0e4:	02dbb2        	addmi	a11, a11, 0x200
4200d0e7:	182bb2        	l32i	a11, a11, 96
4200d0ea:	9e61a2        	s32i	a10, a1, 0x278
4200d0ed:	bbaa      	add.n	a11, a11, a10
4200d0ef:	fccbb2        	addi	a11, a11, -4
4200d0f2:	0b58      	l32i.n	a5, a11, 0
4200d0f4:	b09910        	addx8	a9, a9, a1
4200d0f7:	4959      	s32i.n	a5, a9, 16
4200d0f9:	745050        	extui	a5, a5, 0, 8
4200d0fc:	003406        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d0ff:	6ea200        	f64rnd	a10, a2, a0, 2
4200d102:	1c1a      	add.n	a1, a12, a1
4200d104:	a789      	s32i.n	a8, a7, 40
4200d106:	0729      	s32i.n	a2, a7, 0
4200d108:	192e92        	l32i	a9, a14, 100
4200d10b:	000486        	j	4200d121 <_vfprintf_r+0x1641>
4200d10e:	b70000        	lsi	f0, a0, 0x2dc
4200d111:	0129      	s32i.n	a2, a1, 0
4200d113:	4a2c      	movi.n	a10, 36
4200d115:	10c192        	addi	a9, a1, 16
4200d118:	02d992        	addmi	a9, a9, 0x200
4200d11b:	182992        	l32i	a9, a9, 96
4200d11e:	9e61a2        	s32i	a10, a1, 0x278
4200d121:	99aa      	add.n	a9, a9, a10
4200d123:	fcc992        	addi	a9, a9, -4
4200d126:	000952        	l8ui	a5, a9, 0
4200d129:	0028c6        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d12c:	c4ac      	beqz.n	a4, 4200d15c <_vfprintf_r+0x167c>
4200d12e:	07a697        	bge	a6, a9, 4200d139 <_vfprintf_r+0x1659>
4200d131:	b0e6e0        	addx8	a14, a6, a14
4200d134:	0e58      	l32i.n	a5, a14, 0
4200d136:	000706        	j	4200d156 <_vfprintf_r+0x1676>
4200d139:	48a282        	movi	a8, 0x248
4200d13c:	8e8a      	add.n	a8, a14, a8
4200d13e:	4ca2d2        	movi	a13, 0x24c
4200d141:	60a2c2        	movi	a12, 0x260
4200d144:	05bd      	mov.n	a11, a5
4200d146:	0189      	s32i.n	a8, a1, 0
4200d148:	01def2        	addmi	a15, a14, 0x100
4200d14b:	deda      	add.n	a13, a14, a13
4200d14d:	ceca      	add.n	a12, a14, a12
4200d14f:	06ad      	mov.n	a10, a6
4200d151:	fe4be5        	call8	4200b610 <get_arg$isra$0>
4200d154:	0a58      	l32i.n	a5, a10, 0
4200d156:	078d      	mov.n	a8, a7
4200d158:	001d06        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d15b:	871b00        	lsi	f0, a11, 0x21c
4200d15e:	07a797        	bge	a7, a9, 4200d169 <_vfprintf_r+0x1689>
4200d161:	b0e6e0        	addx8	a14, a6, a14
4200d164:	0e58      	l32i.n	a5, a14, 0
4200d166:	001986        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d169:	9a2eb2        	l32i	a11, a14, 0x268
4200d16c:	fc1c      	movi.n	a12, 31
4200d16e:	02dee2        	addmi	a14, a14, 0x200
4200d171:	ab4b      	addi.n	a10, a11, 4
4200d173:	322c97        	blt	a12, a9, 4200d1a9 <_vfprintf_r+0x16c9>
4200d176:	c91b      	addi.n	a12, a9, 1
4200d178:	9761c2        	s32i	a12, a1, 0x25c
4200d17b:	1a6ea2        	s32i	a10, a14, 104
4200d17e:	8c1c      	movi.n	a12, 24
4200d180:	052ca7        	blt	a12, a10, 4200d189 <_vfprintf_r+0x16a9>
4200d183:	192eb2        	l32i	a11, a14, 100
4200d186:	000406        	j	4200d19a <_vfprintf_r+0x16ba>
4200d189:	012cb7        	blt	a12, a11, 4200d18e <_vfprintf_r+0x16ae>
4200d18c:	4a2c      	movi.n	a10, 36
4200d18e:	10c1b2        	addi	a11, a1, 16
4200d191:	02dbb2        	addmi	a11, a11, 0x200
4200d194:	182bb2        	l32i	a11, a11, 96
4200d197:	9e61a2        	s32i	a10, a1, 0x278
4200d19a:	bbaa      	add.n	a11, a11, a10
4200d19c:	fccbb2        	addi	a11, a11, -4
4200d19f:	0b58      	l32i.n	a5, a11, 0
4200d1a1:	b09910        	addx8	a9, a9, a1
4200d1a4:	4959      	s32i.n	a5, a9, 16
4200d1a6:	000986        	j	4200d1d0 <_vfprintf_r+0x16f0>
4200d1a9:	1a6ea2        	s32i	a10, a14, 104
4200d1ac:	891c      	movi.n	a9, 24
4200d1ae:	0629a7        	blt	a9, a10, 4200d1b8 <_vfprintf_r+0x16d8>
4200d1b1:	192e92        	l32i	a9, a14, 100
4200d1b4:	000446        	j	4200d1c9 <_vfprintf_r+0x16e9>
4200d1b7:	29b700        	lsi	f0, a7, 164
4200d1ba:	4a2c01        	l32r	a0, 41fdfa6c <_coredump_iram_end+0x1c5db6c>
4200d1bd:	10c192        	addi	a9, a1, 16
4200d1c0:	02d992        	addmi	a9, a9, 0x200
4200d1c3:	182992        	l32i	a9, a9, 96
4200d1c6:	9e61a2        	s32i	a10, a1, 0x278
4200d1c9:	99aa      	add.n	a9, a9, a10
4200d1cb:	fcc992        	addi	a9, a9, -4
4200d1ce:	0958      	l32i.n	a5, a9, 0
4200d1d0:	040c      	movi.n	a4, 0
4200d1d2:	ffab92        	movi	a9, 0xfffffbff
4200d1d5:	103390        	and	a3, a3, a9
4200d1d8:	090c      	movi.n	a9, 0
4200d1da:	01f686        	j	4200d9b8 <_vfprintf_r+0x1ed8>
4200d1dd:	21a200        	srai	a10, a0, 2
4200d1e0:	c1e297        	bbsi	a2, 9, 4200d1a5 <_vfprintf_r+0x16c5>
4200d1e3:	c4ac10        	extui	a10, a1, 12, 13
4200d1e6:	07a6a7        	bge	a6, a10, 4200d1f1 <_vfprintf_r+0x1711>
4200d1e9:	b0e6e0        	addx8	a14, a6, a14
4200d1ec:	0e58      	l32i.n	a5, a14, 0
4200d1ee:	000706        	j	4200d20e <_vfprintf_r+0x172e>
4200d1f1:	48a282        	movi	a8, 0x248
4200d1f4:	8e8a      	add.n	a8, a14, a8
4200d1f6:	4ca2d2        	movi	a13, 0x24c
4200d1f9:	60a2c2        	movi	a12, 0x260
4200d1fc:	05bd      	mov.n	a11, a5
4200d1fe:	0189      	s32i.n	a8, a1, 0
4200d200:	01def2        	addmi	a15, a14, 0x100
4200d203:	deda      	add.n	a13, a14, a13
4200d205:	ceca      	add.n	a12, a14, a12
4200d207:	06ad      	mov.n	a10, a6
4200d209:	fe4065        	call8	4200b610 <get_arg$isra$0>
4200d20c:	0a58      	l32i.n	a5, a10, 0
4200d20e:	078d      	mov.n	a8, a7
4200d210:	001d06        	j	4200d288 <_vfprintf_r+0x17a8>
4200d213:	871b00        	lsi	f0, a11, 0x21c
4200d216:	07a7a7        	bge	a7, a10, 4200d221 <_vfprintf_r+0x1741>
4200d219:	b0e6e0        	addx8	a14, a6, a14
4200d21c:	0e58      	l32i.n	a5, a14, 0
4200d21e:	001986        	j	4200d288 <_vfprintf_r+0x17a8>
4200d221:	9a2eb2        	l32i	a11, a14, 0x268
4200d224:	fc1c      	movi.n	a12, 31
4200d226:	02dee2        	addmi	a14, a14, 0x200
4200d229:	9b4b      	addi.n	a9, a11, 4
4200d22b:	322ca7        	blt	a12, a10, 4200d261 <_vfprintf_r+0x1781>
4200d22e:	ca1b      	addi.n	a12, a10, 1
4200d230:	9761c2        	s32i	a12, a1, 0x25c
4200d233:	1a6e92        	s32i	a9, a14, 104
4200d236:	8c1c      	movi.n	a12, 24
4200d238:	052c97        	blt	a12, a9, 4200d241 <_vfprintf_r+0x1761>
4200d23b:	192eb2        	l32i	a11, a14, 100
4200d23e:	000406        	j	4200d252 <_vfprintf_r+0x1772>
4200d241:	012cb7        	blt	a12, a11, 4200d246 <_vfprintf_r+0x1766>
4200d244:	492c      	movi.n	a9, 36
4200d246:	10c1b2        	addi	a11, a1, 16
4200d249:	02dbb2        	addmi	a11, a11, 0x200
4200d24c:	182bb2        	l32i	a11, a11, 96
4200d24f:	9e6192        	s32i	a9, a1, 0x278
4200d252:	bb9a      	add.n	a11, a11, a9
4200d254:	fccbb2        	addi	a11, a11, -4
4200d257:	0b58      	l32i.n	a5, a11, 0
4200d259:	b09a10        	addx8	a9, a10, a1
4200d25c:	4959      	s32i.n	a5, a9, 16
4200d25e:	000986        	j	4200d288 <_vfprintf_r+0x17a8>
4200d261:	1a6e92        	s32i	a9, a14, 104
4200d264:	8a1c      	movi.n	a10, 24
4200d266:	062a97        	blt	a10, a9, 4200d270 <_vfprintf_r+0x1790>
4200d269:	192ea2        	l32i	a10, a14, 100
4200d26c:	000446        	j	4200d281 <_vfprintf_r+0x17a1>
4200d26f:	2ab700        	mul.s	f11, f7, f0
4200d272:	492c01        	l32r	a0, 41fdf724 <_coredump_iram_end+0x1c5d824>
4200d275:	10c1a2        	addi	a10, a1, 16
4200d278:	02daa2        	addmi	a10, a10, 0x200
4200d27b:	182aa2        	l32i	a10, a10, 96
4200d27e:	9e6192        	s32i	a9, a1, 0x278
4200d281:	aa9a      	add.n	a10, a10, a9
4200d283:	fccaa2        	addi	a10, a10, -4
4200d286:	0a58      	l32i.n	a5, a10, 0
4200d288:	290c      	movi.n	a9, 2
4200d28a:	203390        	or	a3, a3, a9
4200d28d:	10c192        	addi	a9, a1, 16
4200d290:	02d992        	addmi	a9, a9, 0x200
4200d293:	0a3c      	movi.n	a10, 48
4200d295:	5049a2        	s8i	a10, a9, 80
4200d298:	78a0a2        	movi	a10, 120
4200d29b:	5149a2        	s8i	a10, a9, 81
4200d29e:	ce9491        	l32r	a9, 42000cf0 <_stext+0xcd0> (3c02915e <Xthal_intlevel+0x32>)
4200d2a1:	78a0a2        	movi	a10, 120
4200d2a4:	b86192        	s32i	a9, a1, 0x2e0
4200d2a7:	040c      	movi.n	a4, 0
4200d2a9:	290c      	movi.n	a9, 2
4200d2ab:	a361a2        	s32i	a10, a1, 0x28c
4200d2ae:	01c186        	j	4200d9b8 <_vfprintf_r+0x1ed8>
4200d2b1:	219200        	srai	a9, a0, 2
4200d2b4:	c1e297        	bbsi	a2, 9, 4200d279 <_vfprintf_r+0x1799>
4200d2b7:	c4ac10        	extui	a10, a1, 12, 13
4200d2ba:	07a697        	bge	a6, a9, 4200d2c5 <_vfprintf_r+0x17e5>
4200d2bd:	b0e6e0        	addx8	a14, a6, a14
4200d2c0:	0e88      	l32i.n	a8, a14, 0
4200d2c2:	000706        	j	4200d2e2 <_vfprintf_r+0x1802>
4200d2c5:	48a282        	movi	a8, 0x248
4200d2c8:	8e8a      	add.n	a8, a14, a8
4200d2ca:	4ca2d2        	movi	a13, 0x24c
4200d2cd:	60a2c2        	movi	a12, 0x260
4200d2d0:	0189      	s32i.n	a8, a1, 0
4200d2d2:	01def2        	addmi	a15, a14, 0x100
4200d2d5:	deda      	add.n	a13, a14, a13
4200d2d7:	ceca      	add.n	a12, a14, a12
4200d2d9:	05bd      	mov.n	a11, a5
4200d2db:	06ad      	mov.n	a10, a6
4200d2dd:	fe3325        	call8	4200b610 <get_arg$isra$0>
4200d2e0:	0a88      	l32i.n	a8, a10, 0
4200d2e2:	9f6182        	s32i	a8, a1, 0x27c
4200d2e5:	002006        	j	4200d369 <_vfprintf_r+0x1889>
4200d2e8:	a71b      	addi.n	a10, a7, 1
4200d2ea:	07a797        	bge	a7, a9, 4200d2f5 <_vfprintf_r+0x1815>
4200d2ed:	b0e6e0        	addx8	a14, a6, a14
4200d2f0:	0e88      	l32i.n	a8, a14, 0
4200d2f2:	001b86        	j	4200d364 <_vfprintf_r+0x1884>
4200d2f5:	9a2eb2        	l32i	a11, a14, 0x268
4200d2f8:	fc1c      	movi.n	a12, 31
4200d2fa:	02dee2        	addmi	a14, a14, 0x200
4200d2fd:	8b4b      	addi.n	a8, a11, 4
4200d2ff:	392c97        	blt	a12, a9, 4200d33c <_vfprintf_r+0x185c>
4200d302:	c91b      	addi.n	a12, a9, 1
4200d304:	9761c2        	s32i	a12, a1, 0x25c
4200d307:	1a6e82        	s32i	a8, a14, 104
4200d30a:	8c1c      	movi.n	a12, 24
4200d30c:	052c87        	blt	a12, a8, 4200d315 <_vfprintf_r+0x1835>
4200d30f:	192eb2        	l32i	a11, a14, 100
4200d312:	000406        	j	4200d326 <_vfprintf_r+0x1846>
4200d315:	012cb7        	blt	a12, a11, 4200d31a <_vfprintf_r+0x183a>
4200d318:	482c      	movi.n	a8, 36
4200d31a:	10c1b2        	addi	a11, a1, 16
4200d31d:	02dbb2        	addmi	a11, a11, 0x200
4200d320:	182bb2        	l32i	a11, a11, 96
4200d323:	9e6182        	s32i	a8, a1, 0x278
4200d326:	bb8a      	add.n	a11, a11, a8
4200d328:	fccbb2        	addi	a11, a11, -4
4200d32b:	0b88      	l32i.n	a8, a11, 0
4200d32d:	9f6182        	s32i	a8, a1, 0x27c
4200d330:	b08910        	addx8	a8, a9, a1
4200d333:	9f2192        	l32i	a9, a1, 0x27c
4200d336:	4899      	s32i.n	a9, a8, 16
4200d338:	000ac6        	j	4200d367 <_vfprintf_r+0x1887>
4200d33b:	6e8200        	f64rnd	a8, a2, a0, 2
4200d33e:	1c1a      	add.n	a1, a12, a1
4200d340:	8789      	s32i.n	a8, a7, 32
4200d342:	0729      	s32i.n	a2, a7, 0
4200d344:	192e92        	l32i	a9, a14, 100
4200d347:	000486        	j	4200d35d <_vfprintf_r+0x187d>
4200d34a:	b70000        	lsi	f0, a0, 0x2dc
4200d34d:	0129      	s32i.n	a2, a1, 0
4200d34f:	482c      	movi.n	a8, 36
4200d351:	10c192        	addi	a9, a1, 16
4200d354:	02d992        	addmi	a9, a9, 0x200
4200d357:	182992        	l32i	a9, a9, 96
4200d35a:	9e6182        	s32i	a8, a1, 0x278
4200d35d:	998a      	add.n	a9, a9, a8
4200d35f:	fcc992        	addi	a9, a9, -4
4200d362:	0988      	l32i.n	a8, a9, 0
4200d364:	9f6182        	s32i	a8, a1, 0x27c
4200d367:	0a7d      	mov.n	a7, a10
4200d369:	10c182        	addi	a8, a1, 16
4200d36c:	02d882        	addmi	a8, a8, 0x200
4200d36f:	090c      	movi.n	a9, 0
4200d371:	524892        	s8i	a9, a8, 82
4200d374:	a22182        	l32i	a8, a1, 0x288
4200d377:	021896        	bltz	a8, 4200d39c <_vfprintf_r+0x18bc>
4200d37a:	9f21a2        	l32i	a10, a1, 0x27c
4200d37d:	08cd      	mov.n	a12, a8
4200d37f:	00a0b2        	movi	a11, 0
4200d382:	ce4781        	l32r	a8, 42000ca0 <_stext+0xc80> (40001344 <memchr>)
4200d385:	0008e0        	callx8	a8
4200d388:	a961a2        	s32i	a10, a1, 0x2a4
4200d38b:	1acc      	bnez.n	a10, 4200d390 <_vfprintf_r+0x18b0>
4200d38d:	020f46        	j	4200dbce <_vfprintf_r+0x20ee>
4200d390:	9f2192        	l32i	a9, a1, 0x27c
4200d393:	c08a90        	sub	a8, a10, a9
4200d396:	a26182        	s32i	a8, a1, 0x288
4200d399:	0002c6        	j	4200d3a8 <_vfprintf_r+0x18c8>
4200d39c:	9f21a2        	l32i	a10, a1, 0x27c
4200d39f:	cbbf81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200d3a2:	0008e0        	callx8	a8
4200d3a5:	a261a2        	s32i	a10, a1, 0x288
4200d3a8:	080c      	movi.n	a8, 0
4200d3aa:	a96182        	s32i	a8, a1, 0x2a4
4200d3ad:	040c      	movi.n	a4, 0
4200d3af:	0207c6        	j	4200dbd2 <_vfprintf_r+0x20f2>
4200d3b2:	081c      	movi.n	a8, 16
4200d3b4:	203380        	or	a3, a3, a8
4200d3b7:	972192        	l32i	a9, a1, 0x25c
4200d3ba:	10c1e2        	addi	a14, a1, 16
4200d3bd:	02e357        	bbsi	a3, 5, 4200d3c3 <_vfprintf_r+0x18e3>
4200d3c0:	002f46        	j	4200d481 <_vfprintf_r+0x19a1>
4200d3c3:	f4ac      	beqz.n	a4, 4200d3f6 <_vfprintf_r+0x1916>
4200d3c5:	09a697        	bge	a6, a9, 4200d3d2 <_vfprintf_r+0x18f2>
4200d3c8:	b0e6e0        	addx8	a14, a6, a14
4200d3cb:	0e58      	l32i.n	a5, a14, 0
4200d3cd:	1e48      	l32i.n	a4, a14, 4
4200d3cf:	000786        	j	4200d3f1 <_vfprintf_r+0x1911>
4200d3d2:	48a282        	movi	a8, 0x248
4200d3d5:	8e8a      	add.n	a8, a14, a8
4200d3d7:	4ca2d2        	movi	a13, 0x24c
4200d3da:	60a2c2        	movi	a12, 0x260
4200d3dd:	05bd      	mov.n	a11, a5
4200d3df:	0189      	s32i.n	a8, a1, 0
4200d3e1:	01def2        	addmi	a15, a14, 0x100
4200d3e4:	deda      	add.n	a13, a14, a13
4200d3e6:	ceca      	add.n	a12, a14, a12
4200d3e8:	06ad      	mov.n	a10, a6
4200d3ea:	fe2265        	call8	4200b610 <get_arg$isra$0>
4200d3ed:	0a58      	l32i.n	a5, a10, 0
4200d3ef:	1a48      	l32i.n	a4, a10, 4
4200d3f1:	078d      	mov.n	a8, a7
4200d3f3:	007e06        	j	4200d5ef <_vfprintf_r+0x1b0f>
4200d3f6:	871b      	addi.n	a8, a7, 1
4200d3f8:	09a797        	bge	a7, a9, 4200d405 <_vfprintf_r+0x1925>
4200d3fb:	b0e6e0        	addx8	a14, a6, a14
4200d3fe:	0e58      	l32i.n	a5, a14, 0
4200d400:	1e48      	l32i.n	a4, a14, 4
4200d402:	007a46        	j	4200d5ef <_vfprintf_r+0x1b0f>
4200d405:	9a2eb2        	l32i	a11, a14, 0x268
4200d408:	8a7c      	movi.n	a10, -8
4200d40a:	bb7b      	addi.n	a11, a11, 7
4200d40c:	10bba0        	and	a11, a11, a10
4200d40f:	fc1c      	movi.n	a12, 31
4200d411:	02dee2        	addmi	a14, a14, 0x200
4200d414:	ab8b      	addi.n	a10, a11, 8
4200d416:	3a2c97        	blt	a12, a9, 4200d454 <_vfprintf_r+0x1974>
4200d419:	c91b      	addi.n	a12, a9, 1
4200d41b:	9761c2        	s32i	a12, a1, 0x25c
4200d41e:	1a6ea2        	s32i	a10, a14, 104
4200d421:	8c1c      	movi.n	a12, 24
4200d423:	052ca7        	blt	a12, a10, 4200d42c <_vfprintf_r+0x194c>
4200d426:	192eb2        	l32i	a11, a14, 100
4200d429:	000406        	j	4200d43d <_vfprintf_r+0x195d>
4200d42c:	012cb7        	blt	a12, a11, 4200d431 <_vfprintf_r+0x1951>
4200d42f:	8a2c      	movi.n	a10, 40
4200d431:	10c1b2        	addi	a11, a1, 16
4200d434:	02dbb2        	addmi	a11, a11, 0x200
4200d437:	182bb2        	l32i	a11, a11, 96
4200d43a:	9e61a2        	s32i	a10, a1, 0x278
4200d43d:	abaa      	add.n	a10, a11, a10
4200d43f:	f8caa2        	addi	a10, a10, -8
4200d442:	0a58      	l32i.n	a5, a10, 0
4200d444:	1a48      	l32i.n	a4, a10, 4
4200d446:	10c1a2        	addi	a10, a1, 16
4200d449:	b099a0        	addx8	a9, a9, a10
4200d44c:	0959      	s32i.n	a5, a9, 0
4200d44e:	1949      	s32i.n	a4, a9, 4
4200d450:	0066c6        	j	4200d5ef <_vfprintf_r+0x1b0f>
4200d453:	6ea200        	f64rnd	a10, a2, a0, 2
4200d456:	1c1a      	add.n	a1, a12, a1
4200d458:	a789      	s32i.n	a8, a7, 40
4200d45a:	0729      	s32i.n	a2, a7, 0
4200d45c:	192e92        	l32i	a9, a14, 100
4200d45f:	000486        	j	4200d475 <_vfprintf_r+0x1995>
4200d462:	b70000        	lsi	f0, a0, 0x2dc
4200d465:	0129      	s32i.n	a2, a1, 0
4200d467:	8a2c      	movi.n	a10, 40
4200d469:	10c192        	addi	a9, a1, 16
4200d46c:	02d992        	addmi	a9, a9, 0x200
4200d46f:	182992        	l32i	a9, a9, 96
4200d472:	9e61a2        	s32i	a10, a1, 0x278
4200d475:	99aa      	add.n	a9, a9, a10
4200d477:	f8c992        	addi	a9, a9, -8
4200d47a:	0958      	l32i.n	a5, a9, 0
4200d47c:	1948      	l32i.n	a4, a9, 4
4200d47e:	005b46        	j	4200d5ef <_vfprintf_r+0x1b0f>
4200d481:	036347        	bbci	a3, 4, 4200d488 <_vfprintf_r+0x19a8>
4200d484:	005b06        	j	4200d5f4 <_vfprintf_r+0x1b14>
4200d487:	e36700        	lsi	f0, a7, 0x38c
4200d48a:	2b4602        	s8i	a0, a6, 43
4200d48d:	c4ac00        	extui	a10, a0, 12, 13
4200d490:	09a697        	bge	a6, a9, 4200d49d <_vfprintf_r+0x19bd>
4200d493:	b0e6e0        	addx8	a14, a6, a14
4200d496:	001e52        	l16ui	a5, a14, 0
4200d499:	006046        	j	4200d61e <_vfprintf_r+0x1b3e>
4200d49c:	a28200        	muluh	a8, a2, a0
4200d49f:	8a48      	l32i.n	a4, a10, 32
4200d4a1:	8e          	.byte	0x8e
4200d4a2:	4ca2d2        	movi	a13, 0x24c
4200d4a5:	60a2c2        	movi	a12, 0x260
4200d4a8:	05bd      	mov.n	a11, a5
4200d4aa:	0189      	s32i.n	a8, a1, 0
4200d4ac:	01def2        	addmi	a15, a14, 0x100
4200d4af:	deda      	add.n	a13, a14, a13
4200d4b1:	ceca      	add.n	a12, a14, a12
4200d4b3:	06ad      	mov.n	a10, a6
4200d4b5:	fe15a5        	call8	4200b610 <get_arg$isra$0>
4200d4b8:	001a52        	l16ui	a5, a10, 0
4200d4bb:	0057c6        	j	4200d61e <_vfprintf_r+0x1b3e>
4200d4be:	871b      	addi.n	a8, a7, 1
4200d4c0:	08a797        	bge	a7, a9, 4200d4cc <_vfprintf_r+0x19ec>
4200d4c3:	b0e6e0        	addx8	a14, a6, a14
4200d4c6:	001e52        	l16ui	a5, a14, 0
4200d4c9:	004806        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d4cc:	9a2eb2        	l32i	a11, a14, 0x268
4200d4cf:	fc1c      	movi.n	a12, 31
4200d4d1:	02dee2        	addmi	a14, a14, 0x200
4200d4d4:	ab4b      	addi.n	a10, a11, 4
4200d4d6:	362c97        	blt	a12, a9, 4200d510 <_vfprintf_r+0x1a30>
4200d4d9:	c91b      	addi.n	a12, a9, 1
4200d4db:	9761c2        	s32i	a12, a1, 0x25c
4200d4de:	1a6ea2        	s32i	a10, a14, 104
4200d4e1:	8c1c      	movi.n	a12, 24
4200d4e3:	052ca7        	blt	a12, a10, 4200d4ec <_vfprintf_r+0x1a0c>
4200d4e6:	192eb2        	l32i	a11, a14, 100
4200d4e9:	000406        	j	4200d4fd <_vfprintf_r+0x1a1d>
4200d4ec:	012cb7        	blt	a12, a11, 4200d4f1 <_vfprintf_r+0x1a11>
4200d4ef:	4a2c      	movi.n	a10, 36
4200d4f1:	10c1b2        	addi	a11, a1, 16
4200d4f4:	02dbb2        	addmi	a11, a11, 0x200
4200d4f7:	182bb2        	l32i	a11, a11, 96
4200d4fa:	9e61a2        	s32i	a10, a1, 0x278
4200d4fd:	bbaa      	add.n	a11, a11, a10
4200d4ff:	fccbb2        	addi	a11, a11, -4
4200d502:	0b58      	l32i.n	a5, a11, 0
4200d504:	b09910        	addx8	a9, a9, a1
4200d507:	4959      	s32i.n	a5, a9, 16
4200d509:	f45050        	extui	a5, a5, 0, 16
4200d50c:	003746        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d50f:	6ea200        	f64rnd	a10, a2, a0, 2
4200d512:	1c1a      	add.n	a1, a12, a1
4200d514:	a789      	s32i.n	a8, a7, 40
4200d516:	0729      	s32i.n	a2, a7, 0
4200d518:	192e92        	l32i	a9, a14, 100
4200d51b:	000486        	j	4200d531 <_vfprintf_r+0x1a51>
4200d51e:	b70000        	lsi	f0, a0, 0x2dc
4200d521:	0129      	s32i.n	a2, a1, 0
4200d523:	4a2c      	movi.n	a10, 36
4200d525:	10c192        	addi	a9, a1, 16
4200d528:	02d992        	addmi	a9, a9, 0x200
4200d52b:	182992        	l32i	a9, a9, 96
4200d52e:	9e61a2        	s32i	a10, a1, 0x278
4200d531:	99aa      	add.n	a9, a9, a10
4200d533:	fcc992        	addi	a9, a9, -4
4200d536:	001952        	l16ui	a5, a9, 0
4200d539:	002c06        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d53c:	02e397        	bbsi	a3, 9, 4200d542 <_vfprintf_r+0x1a62>
4200d53f:	002c46        	j	4200d5f4 <_vfprintf_r+0x1b14>
4200d542:	c4ac      	beqz.n	a4, 4200d572 <_vfprintf_r+0x1a92>
4200d544:	09a697        	bge	a6, a9, 4200d551 <_vfprintf_r+0x1a71>
4200d547:	b0e6e0        	addx8	a14, a6, a14
4200d54a:	000e52        	l8ui	a5, a14, 0
4200d54d:	003346        	j	4200d61e <_vfprintf_r+0x1b3e>
4200d550:	a28200        	muluh	a8, a2, a0
4200d553:	8a48      	l32i.n	a4, a10, 32
4200d555:	8e          	.byte	0x8e
4200d556:	4ca2d2        	movi	a13, 0x24c
4200d559:	60a2c2        	movi	a12, 0x260
4200d55c:	05bd      	mov.n	a11, a5
4200d55e:	0189      	s32i.n	a8, a1, 0
4200d560:	01def2        	addmi	a15, a14, 0x100
4200d563:	deda      	add.n	a13, a14, a13
4200d565:	ceca      	add.n	a12, a14, a12
4200d567:	06ad      	mov.n	a10, a6
4200d569:	fe0a65        	call8	4200b610 <get_arg$isra$0>
4200d56c:	000a52        	l8ui	a5, a10, 0
4200d56f:	002ac6        	j	4200d61e <_vfprintf_r+0x1b3e>
4200d572:	871b      	addi.n	a8, a7, 1
4200d574:	08a797        	bge	a7, a9, 4200d580 <_vfprintf_r+0x1aa0>
4200d577:	b0e6e0        	addx8	a14, a6, a14
4200d57a:	000e52        	l8ui	a5, a14, 0
4200d57d:	001b06        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d580:	9a2eb2        	l32i	a11, a14, 0x268
4200d583:	fc1c      	movi.n	a12, 31
4200d585:	02dee2        	addmi	a14, a14, 0x200
4200d588:	ab4b      	addi.n	a10, a11, 4
4200d58a:	362c97        	blt	a12, a9, 4200d5c4 <_vfprintf_r+0x1ae4>
4200d58d:	c91b      	addi.n	a12, a9, 1
4200d58f:	9761c2        	s32i	a12, a1, 0x25c
4200d592:	1a6ea2        	s32i	a10, a14, 104
4200d595:	8c1c      	movi.n	a12, 24
4200d597:	052ca7        	blt	a12, a10, 4200d5a0 <_vfprintf_r+0x1ac0>
4200d59a:	192eb2        	l32i	a11, a14, 100
4200d59d:	000406        	j	4200d5b1 <_vfprintf_r+0x1ad1>
4200d5a0:	012cb7        	blt	a12, a11, 4200d5a5 <_vfprintf_r+0x1ac5>
4200d5a3:	4a2c      	movi.n	a10, 36
4200d5a5:	10c1b2        	addi	a11, a1, 16
4200d5a8:	02dbb2        	addmi	a11, a11, 0x200
4200d5ab:	182bb2        	l32i	a11, a11, 96
4200d5ae:	9e61a2        	s32i	a10, a1, 0x278
4200d5b1:	bbaa      	add.n	a11, a11, a10
4200d5b3:	fccbb2        	addi	a11, a11, -4
4200d5b6:	0b58      	l32i.n	a5, a11, 0
4200d5b8:	b09910        	addx8	a9, a9, a1
4200d5bb:	4959      	s32i.n	a5, a9, 16
4200d5bd:	745050        	extui	a5, a5, 0, 8
4200d5c0:	000a46        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d5c3:	6ea200        	f64rnd	a10, a2, a0, 2
4200d5c6:	1c1a      	add.n	a1, a12, a1
4200d5c8:	a789      	s32i.n	a8, a7, 40
4200d5ca:	0729      	s32i.n	a2, a7, 0
4200d5cc:	192e92        	l32i	a9, a14, 100
4200d5cf:	000486        	j	4200d5e5 <_vfprintf_r+0x1b05>
4200d5d2:	b70000        	lsi	f0, a0, 0x2dc
4200d5d5:	0129      	s32i.n	a2, a1, 0
4200d5d7:	4a2c      	movi.n	a10, 36
4200d5d9:	10c192        	addi	a9, a1, 16
4200d5dc:	02d992        	addmi	a9, a9, 0x200
4200d5df:	182992        	l32i	a9, a9, 96
4200d5e2:	9e61a2        	s32i	a10, a1, 0x278
4200d5e5:	99aa      	add.n	a9, a9, a10
4200d5e7:	fcc992        	addi	a9, a9, -4
4200d5ea:	000952        	l8ui	a5, a9, 0
4200d5ed:	040c      	movi.n	a4, 0
4200d5ef:	190c      	movi.n	a9, 1
4200d5f1:	00f0c6        	j	4200d9b8 <_vfprintf_r+0x1ed8>
4200d5f4:	c4ac      	beqz.n	a4, 4200d624 <_vfprintf_r+0x1b44>
4200d5f6:	07a697        	bge	a6, a9, 4200d601 <_vfprintf_r+0x1b21>
4200d5f9:	b0e6e0        	addx8	a14, a6, a14
4200d5fc:	0e58      	l32i.n	a5, a14, 0
4200d5fe:	000706        	j	4200d61e <_vfprintf_r+0x1b3e>
4200d601:	48a282        	movi	a8, 0x248
4200d604:	8e8a      	add.n	a8, a14, a8
4200d606:	4ca2d2        	movi	a13, 0x24c
4200d609:	60a2c2        	movi	a12, 0x260
4200d60c:	05bd      	mov.n	a11, a5
4200d60e:	0189      	s32i.n	a8, a1, 0
4200d610:	01def2        	addmi	a15, a14, 0x100
4200d613:	deda      	add.n	a13, a14, a13
4200d615:	ceca      	add.n	a12, a14, a12
4200d617:	06ad      	mov.n	a10, a6
4200d619:	fdff65        	call8	4200b610 <get_arg$isra$0>
4200d61c:	0a58      	l32i.n	a5, a10, 0
4200d61e:	078d      	mov.n	a8, a7
4200d620:	fff246        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d623:	871b00        	lsi	f0, a11, 0x21c
4200d626:	07a797        	bge	a7, a9, 4200d631 <_vfprintf_r+0x1b51>
4200d629:	b0e6e0        	addx8	a14, a6, a14
4200d62c:	0e58      	l32i.n	a5, a14, 0
4200d62e:	ffeec6        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d631:	9a2eb2        	l32i	a11, a14, 0x268
4200d634:	fc1c      	movi.n	a12, 31
4200d636:	02dee2        	addmi	a14, a14, 0x200
4200d639:	ab4b      	addi.n	a10, a11, 4
4200d63b:	322c97        	blt	a12, a9, 4200d671 <_vfprintf_r+0x1b91>
4200d63e:	c91b      	addi.n	a12, a9, 1
4200d640:	9761c2        	s32i	a12, a1, 0x25c
4200d643:	1a6ea2        	s32i	a10, a14, 104
4200d646:	8c1c      	movi.n	a12, 24
4200d648:	052ca7        	blt	a12, a10, 4200d651 <_vfprintf_r+0x1b71>
4200d64b:	192eb2        	l32i	a11, a14, 100
4200d64e:	000406        	j	4200d662 <_vfprintf_r+0x1b82>
4200d651:	012cb7        	blt	a12, a11, 4200d656 <_vfprintf_r+0x1b76>
4200d654:	4a2c      	movi.n	a10, 36
4200d656:	10c1b2        	addi	a11, a1, 16
4200d659:	02dbb2        	addmi	a11, a11, 0x200
4200d65c:	182bb2        	l32i	a11, a11, 96
4200d65f:	9e61a2        	s32i	a10, a1, 0x278
4200d662:	bbaa      	add.n	a11, a11, a10
4200d664:	fccbb2        	addi	a11, a11, -4
4200d667:	0b58      	l32i.n	a5, a11, 0
4200d669:	b09910        	addx8	a9, a9, a1
4200d66c:	4959      	s32i.n	a5, a9, 16
4200d66e:	ffdec6        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d671:	1a6ea2        	s32i	a10, a14, 104
4200d674:	891c      	movi.n	a9, 24
4200d676:	0629a7        	blt	a9, a10, 4200d680 <_vfprintf_r+0x1ba0>
4200d679:	192e92        	l32i	a9, a14, 100
4200d67c:	000446        	j	4200d691 <_vfprintf_r+0x1bb1>
4200d67f:	29b700        	lsi	f0, a7, 164
4200d682:	4a2c01        	l32r	a0, 41fdff34 <_coredump_iram_end+0x1c5e034>
4200d685:	10c192        	addi	a9, a1, 16
4200d688:	02d992        	addmi	a9, a9, 0x200
4200d68b:	182992        	l32i	a9, a9, 96
4200d68e:	9e61a2        	s32i	a10, a1, 0x278
4200d691:	99aa      	add.n	a9, a9, a10
4200d693:	fcc992        	addi	a9, a9, -4
4200d696:	0958      	l32i.n	a5, a9, 0
4200d698:	ffd446        	j	4200d5ed <_vfprintf_r+0x1b0d>
4200d69b:	968100        	lsi	f0, a1, 0x258
4200d69e:	82cd      	lsi	f12, a2, 8
4200d6a0:	92b861        	l32r	a6, 41ff2180 <_coredump_iram_end+0x1c70280>
4200d6a3:	e29721        	l32r	a2, 42006100 <usb_serial_jtag_tx_char_no_driver+0x68> (b29920a <UserFrameTotalSize+0xb29910a>)
4200d6a6:	5710c1        	l32r	a12, 41fe32e8 <_coredump_iram_end+0x1c613e8>
4200d6a9:	4602e3        	lsi	f14, a2, 0x118
4200d6ac:	2f          	.byte	0x2f
4200d6ad:	f4ac00        	extui	a10, a0, 12, 16
4200d6b0:	09a697        	bge	a6, a9, 4200d6bd <_vfprintf_r+0x1bdd>
4200d6b3:	b0e6e0        	addx8	a14, a6, a14
4200d6b6:	0e58      	l32i.n	a5, a14, 0
4200d6b8:	1e48      	l32i.n	a4, a14, 4
4200d6ba:	000786        	j	4200d6dc <_vfprintf_r+0x1bfc>
4200d6bd:	48a282        	movi	a8, 0x248
4200d6c0:	8e8a      	add.n	a8, a14, a8
4200d6c2:	4ca2d2        	movi	a13, 0x24c
4200d6c5:	60a2c2        	movi	a12, 0x260
4200d6c8:	05bd      	mov.n	a11, a5
4200d6ca:	0189      	s32i.n	a8, a1, 0
4200d6cc:	01def2        	addmi	a15, a14, 0x100
4200d6cf:	deda      	add.n	a13, a14, a13
4200d6d1:	ceca      	add.n	a12, a14, a12
4200d6d3:	06ad      	mov.n	a10, a6
4200d6d5:	fdf3a5        	call8	4200b610 <get_arg$isra$0>
4200d6d8:	0a58      	l32i.n	a5, a10, 0
4200d6da:	1a48      	l32i.n	a4, a10, 4
4200d6dc:	078d      	mov.n	a8, a7
4200d6de:	00ac06        	j	4200d992 <_vfprintf_r+0x1eb2>
4200d6e1:	871b      	addi.n	a8, a7, 1
4200d6e3:	09a797        	bge	a7, a9, 4200d6f0 <_vfprintf_r+0x1c10>
4200d6e6:	b0e6e0        	addx8	a14, a6, a14
4200d6e9:	0e58      	l32i.n	a5, a14, 0
4200d6eb:	1e48      	l32i.n	a4, a14, 4
4200d6ed:	00a846        	j	4200d992 <_vfprintf_r+0x1eb2>
4200d6f0:	9a2eb2        	l32i	a11, a14, 0x268
4200d6f3:	8a7c      	movi.n	a10, -8
4200d6f5:	bb7b      	addi.n	a11, a11, 7
4200d6f7:	10bba0        	and	a11, a11, a10
4200d6fa:	fc1c      	movi.n	a12, 31
4200d6fc:	02dee2        	addmi	a14, a14, 0x200
4200d6ff:	ab8b      	addi.n	a10, a11, 8
4200d701:	3a2c97        	blt	a12, a9, 4200d73f <_vfprintf_r+0x1c5f>
4200d704:	c91b      	addi.n	a12, a9, 1
4200d706:	9761c2        	s32i	a12, a1, 0x25c
4200d709:	1a6ea2        	s32i	a10, a14, 104
4200d70c:	8c1c      	movi.n	a12, 24
4200d70e:	062ca7        	blt	a12, a10, 4200d718 <_vfprintf_r+0x1c38>
4200d711:	192eb2        	l32i	a11, a14, 100
4200d714:	000446        	j	4200d729 <_vfprintf_r+0x1c49>
4200d717:	2cb700        	lsi	f0, a7, 176
4200d71a:	8a2c01        	l32r	a0, 41feffcc <_coredump_iram_end+0x1c6e0cc>
4200d71d:	10c1b2        	addi	a11, a1, 16
4200d720:	02dbb2        	addmi	a11, a11, 0x200
4200d723:	182bb2        	l32i	a11, a11, 96
4200d726:	9e61a2        	s32i	a10, a1, 0x278
4200d729:	abaa      	add.n	a10, a11, a10
4200d72b:	f8caa2        	addi	a10, a10, -8
4200d72e:	0a58      	l32i.n	a5, a10, 0
4200d730:	1a48      	l32i.n	a4, a10, 4
4200d732:	10c1a2        	addi	a10, a1, 16
4200d735:	b099a0        	addx8	a9, a9, a10
4200d738:	0959      	s32i.n	a5, a9, 0
4200d73a:	1949      	s32i.n	a4, a9, 4
4200d73c:	009486        	j	4200d992 <_vfprintf_r+0x1eb2>
4200d73f:	1a6ea2        	s32i	a10, a14, 104
4200d742:	891c      	movi.n	a9, 24
4200d744:	0529a7        	blt	a9, a10, 4200d74d <_vfprintf_r+0x1c6d>
4200d747:	192e92        	l32i	a9, a14, 100
4200d74a:	000406        	j	4200d75e <_vfprintf_r+0x1c7e>
4200d74d:	0129b7        	blt	a9, a11, 4200d752 <_vfprintf_r+0x1c72>
4200d750:	8a2c      	movi.n	a10, 40
4200d752:	10c192        	addi	a9, a1, 16
4200d755:	02d992        	addmi	a9, a9, 0x200
4200d758:	182992        	l32i	a9, a9, 96
4200d75b:	9e61a2        	s32i	a10, a1, 0x278
4200d75e:	99aa      	add.n	a9, a9, a10
4200d760:	f8c992        	addi	a9, a9, -8
4200d763:	0958      	l32i.n	a5, a9, 0
4200d765:	1948      	l32i.n	a4, a9, 4
4200d767:	0089c6        	j	4200d992 <_vfprintf_r+0x1eb2>
4200d76a:	470000        	lsi	f0, a0, 0x11c
4200d76d:	8c1463        	lsi	f6, a4, 0x230
4200d770:	5e4614        	lsi	f1, a6, 0x178
4200d773:	871b00        	lsi	f0, a11, 0x21c
4200d776:	022797        	blt	a7, a9, 4200d77c <_vfprintf_r+0x1c9c>
4200d779:	006b06        	j	4200d929 <_vfprintf_r+0x1e49>
4200d77c:	b0e6e0        	addx8	a14, a6, a14
4200d77f:	0e58      	l32i.n	a5, a14, 0
4200d781:	0082c6        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d784:	02e367        	bbsi	a3, 6, 4200d78a <_vfprintf_r+0x1caa>
4200d787:	002b46        	j	4200d838 <_vfprintf_r+0x1d58>
4200d78a:	c4ac      	beqz.n	a4, 4200d7ba <_vfprintf_r+0x1cda>
4200d78c:	09a697        	bge	a6, a9, 4200d799 <_vfprintf_r+0x1cb9>
4200d78f:	b0e6e0        	addx8	a14, a6, a14
4200d792:	001e52        	l16ui	a5, a14, 0
4200d795:	005f46        	j	4200d916 <_vfprintf_r+0x1e36>
4200d798:	a28200        	muluh	a8, a2, a0
4200d79b:	8a48      	l32i.n	a4, a10, 32
4200d79d:	8e          	.byte	0x8e
4200d79e:	4ca2d2        	movi	a13, 0x24c
4200d7a1:	60a2c2        	movi	a12, 0x260
4200d7a4:	05bd      	mov.n	a11, a5
4200d7a6:	0189      	s32i.n	a8, a1, 0
4200d7a8:	01def2        	addmi	a15, a14, 0x100
4200d7ab:	deda      	add.n	a13, a14, a13
4200d7ad:	ceca      	add.n	a12, a14, a12
4200d7af:	06ad      	mov.n	a10, a6
4200d7b1:	fde5e5        	call8	4200b610 <get_arg$isra$0>
4200d7b4:	001a52        	l16ui	a5, a10, 0
4200d7b7:	0056c6        	j	4200d916 <_vfprintf_r+0x1e36>
4200d7ba:	871b      	addi.n	a8, a7, 1
4200d7bc:	08a797        	bge	a7, a9, 4200d7c8 <_vfprintf_r+0x1ce8>
4200d7bf:	b0e6e0        	addx8	a14, a6, a14
4200d7c2:	001e52        	l16ui	a5, a14, 0
4200d7c5:	0071c6        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d7c8:	9a2eb2        	l32i	a11, a14, 0x268
4200d7cb:	fc1c      	movi.n	a12, 31
4200d7cd:	02dee2        	addmi	a14, a14, 0x200
4200d7d0:	ab4b      	addi.n	a10, a11, 4
4200d7d2:	362c97        	blt	a12, a9, 4200d80c <_vfprintf_r+0x1d2c>
4200d7d5:	c91b      	addi.n	a12, a9, 1
4200d7d7:	9761c2        	s32i	a12, a1, 0x25c
4200d7da:	1a6ea2        	s32i	a10, a14, 104
4200d7dd:	8c1c      	movi.n	a12, 24
4200d7df:	052ca7        	blt	a12, a10, 4200d7e8 <_vfprintf_r+0x1d08>
4200d7e2:	192eb2        	l32i	a11, a14, 100
4200d7e5:	000406        	j	4200d7f9 <_vfprintf_r+0x1d19>
4200d7e8:	012cb7        	blt	a12, a11, 4200d7ed <_vfprintf_r+0x1d0d>
4200d7eb:	4a2c      	movi.n	a10, 36
4200d7ed:	10c1b2        	addi	a11, a1, 16
4200d7f0:	02dbb2        	addmi	a11, a11, 0x200
4200d7f3:	182bb2        	l32i	a11, a11, 96
4200d7f6:	9e61a2        	s32i	a10, a1, 0x278
4200d7f9:	bbaa      	add.n	a11, a11, a10
4200d7fb:	fccbb2        	addi	a11, a11, -4
4200d7fe:	0b58      	l32i.n	a5, a11, 0
4200d800:	b09910        	addx8	a9, a9, a1
4200d803:	4959      	s32i.n	a5, a9, 16
4200d805:	f45050        	extui	a5, a5, 0, 16
4200d808:	006106        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d80b:	6ea200        	f64rnd	a10, a2, a0, 2
4200d80e:	1c1a      	add.n	a1, a12, a1
4200d810:	a789      	s32i.n	a8, a7, 40
4200d812:	0729      	s32i.n	a2, a7, 0
4200d814:	192e92        	l32i	a9, a14, 100
4200d817:	000486        	j	4200d82d <_vfprintf_r+0x1d4d>
4200d81a:	b70000        	lsi	f0, a0, 0x2dc
4200d81d:	0129      	s32i.n	a2, a1, 0
4200d81f:	4a2c      	movi.n	a10, 36
4200d821:	10c192        	addi	a9, a1, 16
4200d824:	02d992        	addmi	a9, a9, 0x200
4200d827:	182992        	l32i	a9, a9, 96
4200d82a:	9e61a2        	s32i	a10, a1, 0x278
4200d82d:	99aa      	add.n	a9, a9, a10
4200d82f:	fcc992        	addi	a9, a9, -4
4200d832:	001952        	l16ui	a5, a9, 0
4200d835:	0055c6        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d838:	02e397        	bbsi	a3, 9, 4200d83e <_vfprintf_r+0x1d5e>
4200d83b:	002b46        	j	4200d8ec <_vfprintf_r+0x1e0c>
4200d83e:	c4ac      	beqz.n	a4, 4200d86e <_vfprintf_r+0x1d8e>
4200d840:	09a697        	bge	a6, a9, 4200d84d <_vfprintf_r+0x1d6d>
4200d843:	b0e6e0        	addx8	a14, a6, a14
4200d846:	000e52        	l8ui	a5, a14, 0
4200d849:	003246        	j	4200d916 <_vfprintf_r+0x1e36>
4200d84c:	a28200        	muluh	a8, a2, a0
4200d84f:	8a48      	l32i.n	a4, a10, 32
4200d851:	8e          	.byte	0x8e
4200d852:	4ca2d2        	movi	a13, 0x24c
4200d855:	60a2c2        	movi	a12, 0x260
4200d858:	05bd      	mov.n	a11, a5
4200d85a:	0189      	s32i.n	a8, a1, 0
4200d85c:	01def2        	addmi	a15, a14, 0x100
4200d85f:	deda      	add.n	a13, a14, a13
4200d861:	ceca      	add.n	a12, a14, a12
4200d863:	06ad      	mov.n	a10, a6
4200d865:	fddaa5        	call8	4200b610 <get_arg$isra$0>
4200d868:	000a52        	l8ui	a5, a10, 0
4200d86b:	0029c6        	j	4200d916 <_vfprintf_r+0x1e36>
4200d86e:	871b      	addi.n	a8, a7, 1
4200d870:	08a797        	bge	a7, a9, 4200d87c <_vfprintf_r+0x1d9c>
4200d873:	b0e6e0        	addx8	a14, a6, a14
4200d876:	000e52        	l8ui	a5, a14, 0
4200d879:	0044c6        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d87c:	9a2eb2        	l32i	a11, a14, 0x268
4200d87f:	fc1c      	movi.n	a12, 31
4200d881:	02dee2        	addmi	a14, a14, 0x200
4200d884:	ab4b      	addi.n	a10, a11, 4
4200d886:	362c97        	blt	a12, a9, 4200d8c0 <_vfprintf_r+0x1de0>
4200d889:	c91b      	addi.n	a12, a9, 1
4200d88b:	9761c2        	s32i	a12, a1, 0x25c
4200d88e:	1a6ea2        	s32i	a10, a14, 104
4200d891:	8c1c      	movi.n	a12, 24
4200d893:	052ca7        	blt	a12, a10, 4200d89c <_vfprintf_r+0x1dbc>
4200d896:	192eb2        	l32i	a11, a14, 100
4200d899:	000406        	j	4200d8ad <_vfprintf_r+0x1dcd>
4200d89c:	012cb7        	blt	a12, a11, 4200d8a1 <_vfprintf_r+0x1dc1>
4200d89f:	4a2c      	movi.n	a10, 36
4200d8a1:	10c1b2        	addi	a11, a1, 16
4200d8a4:	02dbb2        	addmi	a11, a11, 0x200
4200d8a7:	182bb2        	l32i	a11, a11, 96
4200d8aa:	9e61a2        	s32i	a10, a1, 0x278
4200d8ad:	bbaa      	add.n	a11, a11, a10
4200d8af:	fccbb2        	addi	a11, a11, -4
4200d8b2:	0b58      	l32i.n	a5, a11, 0
4200d8b4:	b09910        	addx8	a9, a9, a1
4200d8b7:	4959      	s32i.n	a5, a9, 16
4200d8b9:	745050        	extui	a5, a5, 0, 8
4200d8bc:	003406        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d8bf:	6ea200        	f64rnd	a10, a2, a0, 2
4200d8c2:	1c1a      	add.n	a1, a12, a1
4200d8c4:	a789      	s32i.n	a8, a7, 40
4200d8c6:	0729      	s32i.n	a2, a7, 0
4200d8c8:	192e92        	l32i	a9, a14, 100
4200d8cb:	000486        	j	4200d8e1 <_vfprintf_r+0x1e01>
4200d8ce:	b70000        	lsi	f0, a0, 0x2dc
4200d8d1:	0129      	s32i.n	a2, a1, 0
4200d8d3:	4a2c      	movi.n	a10, 36
4200d8d5:	10c192        	addi	a9, a1, 16
4200d8d8:	02d992        	addmi	a9, a9, 0x200
4200d8db:	182992        	l32i	a9, a9, 96
4200d8de:	9e61a2        	s32i	a10, a1, 0x278
4200d8e1:	99aa      	add.n	a9, a9, a10
4200d8e3:	fcc992        	addi	a9, a9, -4
4200d8e6:	000952        	l8ui	a5, a9, 0
4200d8e9:	0028c6        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d8ec:	c4ac      	beqz.n	a4, 4200d91c <_vfprintf_r+0x1e3c>
4200d8ee:	07a697        	bge	a6, a9, 4200d8f9 <_vfprintf_r+0x1e19>
4200d8f1:	b0e6e0        	addx8	a14, a6, a14
4200d8f4:	0e58      	l32i.n	a5, a14, 0
4200d8f6:	000706        	j	4200d916 <_vfprintf_r+0x1e36>
4200d8f9:	48a282        	movi	a8, 0x248
4200d8fc:	8e8a      	add.n	a8, a14, a8
4200d8fe:	4ca2d2        	movi	a13, 0x24c
4200d901:	60a2c2        	movi	a12, 0x260
4200d904:	05bd      	mov.n	a11, a5
4200d906:	0189      	s32i.n	a8, a1, 0
4200d908:	01def2        	addmi	a15, a14, 0x100
4200d90b:	deda      	add.n	a13, a14, a13
4200d90d:	ceca      	add.n	a12, a14, a12
4200d90f:	06ad      	mov.n	a10, a6
4200d911:	fdcfe5        	call8	4200b610 <get_arg$isra$0>
4200d914:	0a58      	l32i.n	a5, a10, 0
4200d916:	078d      	mov.n	a8, a7
4200d918:	001d06        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d91b:	871b00        	lsi	f0, a11, 0x21c
4200d91e:	07a797        	bge	a7, a9, 4200d929 <_vfprintf_r+0x1e49>
4200d921:	b066e0        	addx8	a6, a6, a14
4200d924:	0658      	l32i.n	a5, a6, 0
4200d926:	001986        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d929:	9a2eb2        	l32i	a11, a14, 0x268
4200d92c:	fc1c      	movi.n	a12, 31
4200d92e:	02dee2        	addmi	a14, a14, 0x200
4200d931:	ab4b      	addi.n	a10, a11, 4
4200d933:	322c97        	blt	a12, a9, 4200d969 <_vfprintf_r+0x1e89>
4200d936:	c91b      	addi.n	a12, a9, 1
4200d938:	9761c2        	s32i	a12, a1, 0x25c
4200d93b:	1a6ea2        	s32i	a10, a14, 104
4200d93e:	8c1c      	movi.n	a12, 24
4200d940:	052ca7        	blt	a12, a10, 4200d949 <_vfprintf_r+0x1e69>
4200d943:	192eb2        	l32i	a11, a14, 100
4200d946:	000406        	j	4200d95a <_vfprintf_r+0x1e7a>
4200d949:	012cb7        	blt	a12, a11, 4200d94e <_vfprintf_r+0x1e6e>
4200d94c:	4a2c      	movi.n	a10, 36
4200d94e:	10c1b2        	addi	a11, a1, 16
4200d951:	02dbb2        	addmi	a11, a11, 0x200
4200d954:	182bb2        	l32i	a11, a11, 96
4200d957:	9e61a2        	s32i	a10, a1, 0x278
4200d95a:	bbaa      	add.n	a11, a11, a10
4200d95c:	fccbb2        	addi	a11, a11, -4
4200d95f:	0b58      	l32i.n	a5, a11, 0
4200d961:	b09910        	addx8	a9, a9, a1
4200d964:	4959      	s32i.n	a5, a9, 16
4200d966:	000986        	j	4200d990 <_vfprintf_r+0x1eb0>
4200d969:	1a6ea2        	s32i	a10, a14, 104
4200d96c:	891c      	movi.n	a9, 24
4200d96e:	0629a7        	blt	a9, a10, 4200d978 <_vfprintf_r+0x1e98>
4200d971:	192e92        	l32i	a9, a14, 100
4200d974:	000446        	j	4200d989 <_vfprintf_r+0x1ea9>
4200d977:	29b700        	lsi	f0, a7, 164
4200d97a:	4a2c01        	l32r	a0, 41fe022c <_coredump_iram_end+0x1c5e32c>
4200d97d:	10c192        	addi	a9, a1, 16
4200d980:	02d992        	addmi	a9, a9, 0x200
4200d983:	182992        	l32i	a9, a9, 96
4200d986:	9e61a2        	s32i	a10, a1, 0x278
4200d989:	99aa      	add.n	a9, a9, a10
4200d98b:	fcc992        	addi	a9, a9, -4
4200d98e:	0958      	l32i.n	a5, a9, 0
4200d990:	040c      	movi.n	a4, 0
4200d992:	209540        	or	a9, a5, a4
4200d995:	799c      	beqz.n	a9, 4200d9b0 <_vfprintf_r+0x1ed0>
4200d997:	156307        	bbci	a3, 0, 4200d9b0 <_vfprintf_r+0x1ed0>
4200d99a:	10c192        	addi	a9, a1, 16
4200d99d:	02d992        	addmi	a9, a9, 0x200
4200d9a0:	0a3c      	movi.n	a10, 48
4200d9a2:	5049a2        	s8i	a10, a9, 80
4200d9a5:	a321a2        	l32i	a10, a1, 0x28c
4200d9a8:	5149a2        	s8i	a10, a9, 81
4200d9ab:	290c      	movi.n	a9, 2
4200d9ad:	203390        	or	a3, a3, a9
4200d9b0:	ffab92        	movi	a9, 0xfffffbff
4200d9b3:	103390        	and	a3, a3, a9
4200d9b6:	290c      	movi.n	a9, 2
4200d9b8:	087d      	mov.n	a7, a8
4200d9ba:	080c      	movi.n	a8, 0
4200d9bc:	10c1a2        	addi	a10, a1, 16
4200d9bf:	02daa2        	addmi	a10, a10, 0x200
4200d9c2:	524a82        	s8i	a8, a10, 82
4200d9c5:	a22182        	l32i	a8, a1, 0x288
4200d9c8:	01c896        	bltz	a8, 4200d9e8 <_vfprintf_r+0x1f08>
4200d9cb:	03ad      	mov.n	a10, a3
4200d9cd:	7faf82        	movi	a8, -129
4200d9d0:	103380        	and	a3, a3, a8
4200d9d3:	1b0c      	movi.n	a11, 1
4200d9d5:	208540        	or	a8, a5, a4
4200d9d8:	83b880        	moveqz	a11, a8, a8
4200d9db:	98cc      	bnez.n	a8, 4200d9e8 <_vfprintf_r+0x1f08>
4200d9dd:	a221c2        	l32i	a12, a1, 0x288
4200d9e0:	180c      	movi.n	a8, 1
4200d9e2:	838bc0        	moveqz	a8, a11, a12
4200d9e5:	15b816        	beqz	a8, 4200db44 <_vfprintf_r+0x2064>
4200d9e8:	501926        	beqi	a9, 1, 4200da3c <_vfprintf_r+0x1f5c>
4200d9eb:	10c182        	addi	a8, a1, 16
4200d9ee:	022966        	bnei	a9, 2, 4200d9f4 <_vfprintf_r+0x1f14>
4200d9f1:	0046c6        	j	4200db10 <_vfprintf_r+0x2030>
4200d9f4:	e4a192        	movi	a9, 0x1e4
4200d9f7:	889a      	add.n	a8, a8, a9
4200d9f9:	9f6182        	s32i	a8, a1, 0x27c
4200d9fc:	9f2192        	l32i	a9, a1, 0x27c
4200d9ff:	890b      	addi.n	a8, a9, -1
4200da01:	9f6182        	s32i	a8, a1, 0x27c
4200da04:	9f21a2        	l32i	a10, a1, 0x27c
4200da07:	248050        	extui	a8, a5, 0, 3
4200da0a:	30c882        	addi	a8, a8, 48
4200da0d:	404300        	ssai	3
4200da10:	815450        	src	a5, a4, a5
4200da13:	414340        	srli	a4, a4, 3
4200da16:	004a82        	s8i	a8, a10, 0
4200da19:	20a540        	or	a10, a5, a4
4200da1c:	fdca56        	bnez	a10, 4200d9fc <_vfprintf_r+0x1f1c>
4200da1f:	d0c882        	addi	a8, a8, -48
4200da22:	152816        	beqz	a8, 4200db78 <_vfprintf_r+0x2098>
4200da25:	02e307        	bbsi	a3, 0, 4200da2b <_vfprintf_r+0x1f4b>
4200da28:	005306        	j	4200db78 <_vfprintf_r+0x2098>
4200da2b:	9f2182        	l32i	a8, a1, 0x27c
4200da2e:	0a3c      	movi.n	a10, 48
4200da30:	880b      	addi.n	a8, a8, -1
4200da32:	0048a2        	s8i	a10, a8, 0
4200da35:	fec982        	addi	a8, a9, -2
4200da38:	004e46        	j	4200db75 <_vfprintf_r+0x2095>
4200da3b:	54dc00        	extui	a13, a0, 12, 6
4200da3e:	980c      	movi.n	a8, 9
4200da40:	113857        	bltu	a8, a5, 4200da55 <_vfprintf_r+0x1f75>
4200da43:	10c182        	addi	a8, a1, 16
4200da46:	01d892        	addmi	a9, a8, 0x100
4200da49:	30c552        	addi	a5, a5, 48
4200da4c:	e34952        	s8i	a5, a9, 227
4200da4f:	e3a192        	movi	a9, 0x1e3
4200da52:	004746        	j	4200db73 <_vfprintf_r+0x2093>
4200da55:	080c      	movi.n	a8, 0
4200da57:	a46182        	s32i	a8, a1, 0x290
4200da5a:	00a462        	movi	a6, 0x400
4200da5d:	f4a182        	movi	a8, 0x1f4
4200da60:	818a      	add.n	a8, a1, a8
4200da62:	106360        	and	a6, a3, a6
4200da65:	880b      	addi.n	a8, a8, -1
4200da67:	9f6182        	s32i	a8, a1, 0x27c
4200da6a:	ac0c      	movi.n	a12, 10
4200da6c:	0d0c      	movi.n	a13, 0
4200da6e:	05ad      	mov.n	a10, a5
4200da70:	04bd      	mov.n	a11, a4
4200da72:	ccb181        	l32r	a8, 42000d38 <_stext+0xd18> (40002574 <__umoddi3>)
4200da75:	0008e0        	callx8	a8
4200da78:	9f2182        	l32i	a8, a1, 0x27c
4200da7b:	30caa2        	addi	a10, a10, 48
4200da7e:	0048a2        	s8i	a10, a8, 0
4200da81:	a42182        	l32i	a8, a1, 0x290
4200da84:	881b      	addi.n	a8, a8, 1
4200da86:	a46182        	s32i	a8, a1, 0x290
4200da89:	061616        	beqz	a6, 4200daee <_vfprintf_r+0x200e>
4200da8c:	aa2182        	l32i	a8, a1, 0x2a8
4200da8f:	000892        	l8ui	a9, a8, 0
4200da92:	01af82        	movi	a8, -255
4200da95:	808980        	add	a8, a9, a8
4200da98:	052816        	beqz	a8, 4200daee <_vfprintf_r+0x200e>
4200da9b:	a42182        	l32i	a8, a1, 0x290
4200da9e:	4c9987        	bne	a9, a8, 4200daee <_vfprintf_r+0x200e>
4200daa1:	74cc      	bnez.n	a4, 4200daac <_vfprintf_r+0x1fcc>
4200daa3:	09a082        	movi	a8, 9
4200daa6:	023857        	bltu	a8, a5, 4200daac <_vfprintf_r+0x1fcc>
4200daa9:	0032c6        	j	4200db78 <_vfprintf_r+0x2098>
4200daac:	9f2182        	l32i	a8, a1, 0x27c
4200daaf:	b02192        	l32i	a9, a1, 0x2c0
4200dab2:	b621b2        	l32i	a11, a1, 0x2d8
4200dab5:	c08890        	sub	a8, a8, a9
4200dab8:	08ad      	mov.n	a10, a8
4200daba:	09cd      	mov.n	a12, a9
4200dabc:	9f6182        	s32i	a8, a1, 0x27c
4200dabf:	cc4d81        	l32r	a8, 42000bf4 <_stext+0xbd4> (40001224 <strncpy>)
4200dac2:	0008e0        	callx8	a8
4200dac5:	aa2182        	l32i	a8, a1, 0x2a8
4200dac8:	010882        	l8ui	a8, a8, 1
4200dacb:	18cc      	bnez.n	a8, 4200dad0 <_vfprintf_r+0x1ff0>
4200dacd:	0001c6        	j	4200dad8 <_vfprintf_r+0x1ff8>
4200dad0:	aa2182        	l32i	a8, a1, 0x2a8
4200dad3:	881b      	addi.n	a8, a8, 1
4200dad5:	aa6182        	s32i	a8, a1, 0x2a8
4200dad8:	ac0c      	movi.n	a12, 10
4200dada:	0d0c      	movi.n	a13, 0
4200dadc:	05ad      	mov.n	a10, a5
4200dade:	04bd      	mov.n	a11, a4
4200dae0:	c9a081        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4200dae3:	0008e0        	callx8	a8
4200dae6:	080c      	movi.n	a8, 0
4200dae8:	a46182        	s32i	a8, a1, 0x290
4200daeb:	000546        	j	4200db04 <_vfprintf_r+0x2024>
4200daee:	ac0c      	movi.n	a12, 10
4200daf0:	0d0c      	movi.n	a13, 0
4200daf2:	05ad      	mov.n	a10, a5
4200daf4:	20b440        	or	a11, a4, a4
4200daf7:	c99a81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4200dafa:	0008e0        	callx8	a8
4200dafd:	34cc      	bnez.n	a4, 4200db04 <_vfprintf_r+0x2024>
4200daff:	980c      	movi.n	a8, 9
4200db01:	73b857        	bgeu	a8, a5, 4200db78 <_vfprintf_r+0x2098>
4200db04:	9f2182        	l32i	a8, a1, 0x27c
4200db07:	0a5d      	mov.n	a5, a10
4200db09:	0b4d      	mov.n	a4, a11
4200db0b:	ffd586        	j	4200da65 <_vfprintf_r+0x1f85>
4200db0e:	920000        	lsi	f0, a0, 0x248
4200db11:	9ae4a1        	l32r	a10, 41ff46a4 <_coredump_iram_end+0x1c727a4>
4200db14:	8288      	l32i.n	a8, a2, 32
4200db16:	829f61        	l32r	a6, 41fee594 <_coredump_iram_end+0x1c6c694>
4200db19:	929f21        	l32r	a2, 41ff2598 <_coredump_iram_end+0x1c70698>
4200db1c:	0bb821        	l32r	a2, 41fd09fc <_coredump_iram_end+0x1c4eafc>
4200db1f:	8288      	l32i.n	a8, a2, 32
4200db21:	509f61        	l32r	a6, 41fe1da0 <_coredump_iram_end+0x1c5fea0>
4200db24:	8a3480        	round.s	a3, f4, 8
4200db27:	8289      	s32i.n	a8, a2, 32
4200db29:	0008      	l32i.n	a0, a0, 0
4200db2b:	9f2192        	l32i	a9, a1, 0x27c
4200db2e:	404400        	ssai	4
4200db31:	815450        	src	a5, a4, a5
4200db34:	414440        	srli	a4, a4, 4
4200db37:	004982        	s8i	a8, a9, 0
4200db3a:	208540        	or	a8, a5, a4
4200db3d:	fd7856        	bnez	a8, 4200db18 <_vfprintf_r+0x2038>
4200db40:	000d06        	j	4200db78 <_vfprintf_r+0x2098>
4200db43:	080c00        	lsx	f0, a12, a0
4200db46:	a26182        	s32i	a8, a1, 0x288
4200db49:	10c1b2        	addi	a11, a1, 16
4200db4c:	e4a182        	movi	a8, 0x1e4
4200db4f:	8b8a      	add.n	a8, a11, a8
4200db51:	9f6182        	s32i	a8, a1, 0x27c
4200db54:	09ec      	bnez.n	a9, 4200db78 <_vfprintf_r+0x2098>
4200db56:	0480a0        	extui	a8, a10, 0, 1
4200db59:	a26182        	s32i	a8, a1, 0x288
4200db5c:	a22182        	l32i	a8, a1, 0x288
4200db5f:	589c      	beqz.n	a8, 4200db78 <_vfprintf_r+0x2098>
4200db61:	01db82        	addmi	a8, a11, 0x100
4200db64:	093c      	movi.n	a9, 48
4200db66:	e34892        	s8i	a9, a8, 227
4200db69:	080c      	movi.n	a8, 0
4200db6b:	a26182        	s32i	a8, a1, 0x288
4200db6e:	0b9d      	mov.n	a9, a11
4200db70:	e3a182        	movi	a8, 0x1e3
4200db73:	898a      	add.n	a8, a9, a8
4200db75:	9f6182        	s32i	a8, a1, 0x27c
4200db78:	bb2182        	l32i	a8, a1, 0x2ec
4200db7b:	9f2192        	l32i	a9, a1, 0x27c
4200db7e:	a22142        	l32i	a4, a1, 0x288
4200db81:	c08890        	sub	a8, a8, a9
4200db84:	a26182        	s32i	a8, a1, 0x288
4200db87:	080c      	movi.n	a8, 0
4200db89:	a96182        	s32i	a8, a1, 0x2a4
4200db8c:	001086        	j	4200dbd2 <_vfprintf_r+0x20f2>
4200db8f:	218200        	srai	a8, a0, 2
4200db92:	18cca3        	ssip	f10, a12, 96
4200db95:	02bdc6        	j	4200e690 <_vfprintf_r+0x2bb0>
4200db98:	a321a2        	l32i	a10, a1, 0x28c
4200db9b:	10c182        	addi	a8, a1, 16
4200db9e:	01d892        	addmi	a9, a8, 0x100
4200dba1:	8049a2        	s8i	a10, a9, 128
4200dba4:	02d892        	addmi	a9, a8, 0x200
4200dba7:	0a0c      	movi.n	a10, 0
4200dba9:	5249a2        	s8i	a10, a9, 82
4200dbac:	090c      	movi.n	a9, 0
4200dbae:	a96192        	s32i	a9, a1, 0x2a4
4200dbb1:	190c      	movi.n	a9, 1
4200dbb3:	a26192        	s32i	a9, a1, 0x288
4200dbb6:	090c      	movi.n	a9, 0
4200dbb8:	ab6192        	s32i	a9, a1, 0x2ac
4200dbbb:	040c      	movi.n	a4, 0
4200dbbd:	050c      	movi.n	a5, 0
4200dbbf:	060c      	movi.n	a6, 0
4200dbc1:	80a192        	movi	a9, 0x180
4200dbc4:	889a      	add.n	a8, a8, a9
4200dbc6:	9f6182        	s32i	a8, a1, 0x27c
4200dbc9:	000306        	j	4200dbd9 <_vfprintf_r+0x20f9>
4200dbcc:	0c0000        	lsi	f0, a0, 48
4200dbcf:	080c04        	mula.dd.ll.ldinc	m0, a12, m0, m2
4200dbd2:	ab6182        	s32i	a8, a1, 0x2ac
4200dbd5:	050c      	movi.n	a5, 0
4200dbd7:	060c      	movi.n	a6, 0
4200dbd9:	a22182        	l32i	a8, a1, 0x288
4200dbdc:	538480        	max	a8, a4, a8
4200dbdf:	af6182        	s32i	a8, a1, 0x2bc
4200dbe2:	10c182        	addi	a8, a1, 16
4200dbe5:	02d882        	addmi	a8, a8, 0x200
4200dbe8:	520882        	l8ui	a8, a8, 82
4200dbeb:	788c      	beqz.n	a8, 4200dbf6 <_vfprintf_r+0x2116>
4200dbed:	af2182        	l32i	a8, a1, 0x2bc
4200dbf0:	01c882        	addi	a8, a8, 1
4200dbf3:	af6182        	s32i	a8, a1, 0x2bc
4200dbf6:	280c      	movi.n	a8, 2
4200dbf8:	108380        	and	a8, a3, a8
4200dbfb:	b96182        	s32i	a8, a1, 0x2e4
4200dbfe:	688c      	beqz.n	a8, 4200dc08 <_vfprintf_r+0x2128>
4200dc00:	af2182        	l32i	a8, a1, 0x2bc
4200dc03:	882b      	addi.n	a8, a8, 2
4200dc05:	af6182        	s32i	a8, a1, 0x2bc
4200dc08:	84a082        	movi	a8, 132
4200dc0b:	108380        	and	a8, a3, a8
4200dc0e:	ba6182        	s32i	a8, a1, 0x2e8
4200dc11:	089856        	bnez	a8, 4200dc9e <_vfprintf_r+0x21be>
4200dc14:	ac2182        	l32i	a8, a1, 0x2b0
4200dc17:	af2192        	l32i	a9, a1, 0x2bc
4200dc1a:	10c1d2        	addi	a13, a1, 16
4200dc1d:	c0f890        	sub	a15, a8, a9
4200dc20:	391fe6        	bgei	a15, 1, 4200dc5d <_vfprintf_r+0x217d>
4200dc23:	001dc6        	j	4200dc9e <_vfprintf_r+0x21be>
4200dc26:	10cbb2        	addi	a11, a11, 16
4200dc29:	12e9      	s32i.n	a14, a2, 4
4200dc2b:	0b69b2        	s32i	a11, a9, 44
4200dc2e:	a989      	s32i.n	a8, a9, 40
4200dc30:	2488a6        	blti	a8, 8, 4200dc58 <_vfprintf_r+0x2178>
4200dc33:	24a2c2        	movi	a12, 0x224
4200dc36:	a021b2        	l32i	a11, a1, 0x280
4200dc39:	a121a2        	l32i	a10, a1, 0x284
4200dc3c:	80cdc0        	add	a12, a13, a12
4200dc3f:	bc61f2        	s32i	a15, a1, 0x2f0
4200dc42:	201110        	or	a1, a1, a1
4200dc45:	010525        	call8	4200ec98 <__sprint_r>
4200dc48:	1a8c      	beqz.n	a10, 4200dc4d <_vfprintf_r+0x216d>
4200dc4a:	029b86        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200dc4d:	e4a1a2        	movi	a10, 0x1e4
4200dc50:	10c1d2        	addi	a13, a1, 16
4200dc53:	bc21f2        	l32i	a15, a1, 0x2f0
4200dc56:	adaa      	add.n	a10, a13, a10
4200dc58:	f0cff2        	addi	a15, a15, -16
4200dc5b:	0a2d      	mov.n	a2, a10
4200dc5d:	cc27c1        	l32r	a12, 42000cfc <_stext+0xcdc> (3c02949c <blanks$1>)
4200dc60:	8a2d82        	l32i	a8, a13, 0x228
4200dc63:	0e1c      	movi.n	a14, 16
4200dc65:	02c9      	s32i.n	a12, a2, 0
4200dc67:	02dd92        	addmi	a9, a13, 0x200
4200dc6a:	881b      	addi.n	a8, a8, 1
4200dc6c:	a28b      	addi.n	a10, a2, 8
4200dc6e:	b9b8      	l32i.n	a11, a9, 44
4200dc70:	b22ef7        	blt	a14, a15, 4200dc26 <_vfprintf_r+0x2146>
4200dc73:	12f9      	s32i.n	a15, a2, 4
4200dc75:	2fba      	add.n	a2, a15, a11
4200dc77:	b929      	s32i.n	a2, a9, 44
4200dc79:	a989      	s32i.n	a8, a9, 40
4200dc7b:	0a2d      	mov.n	a2, a10
4200dc7d:	1d88a6        	blti	a8, 8, 4200dc9e <_vfprintf_r+0x21be>
4200dc80:	24a2c2        	movi	a12, 0x224
4200dc83:	a021b2        	l32i	a11, a1, 0x280
4200dc86:	a121a2        	l32i	a10, a1, 0x284
4200dc89:	cdca      	add.n	a12, a13, a12
4200dc8b:	201110        	or	a1, a1, a1
4200dc8e:	0100a5        	call8	4200ec98 <__sprint_r>
4200dc91:	1a8c      	beqz.n	a10, 4200dc96 <_vfprintf_r+0x21b6>
4200dc93:	028946        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200dc96:	e4a182        	movi	a8, 0x1e4
4200dc99:	10c1d2        	addi	a13, a1, 16
4200dc9c:	2d8a      	add.n	a2, a13, a8
4200dc9e:	10c182        	addi	a8, a1, 16
4200dca1:	02d892        	addmi	a9, a8, 0x200
4200dca4:	520982        	l8ui	a8, a9, 82
4200dca7:	e8bc      	beqz.n	a8, 4200dce9 <_vfprintf_r+0x2209>
4200dca9:	b988      	l32i.n	a8, a9, 44
4200dcab:	52a2a2        	movi	a10, 0x252
4200dcae:	881b      	addi.n	a8, a8, 1
4200dcb0:	10c1b2        	addi	a11, a1, 16
4200dcb3:	b989      	s32i.n	a8, a9, 44
4200dcb5:	a988      	l32i.n	a8, a9, 40
4200dcb7:	abaa      	add.n	a10, a11, a10
4200dcb9:	02a9      	s32i.n	a10, a2, 0
4200dcbb:	881b      	addi.n	a8, a8, 1
4200dcbd:	1a0c      	movi.n	a10, 1
4200dcbf:	12a9      	s32i.n	a10, a2, 4
4200dcc1:	a989      	s32i.n	a8, a9, 40
4200dcc3:	228b      	addi.n	a2, a2, 8
4200dcc5:	2088a6        	blti	a8, 8, 4200dce9 <_vfprintf_r+0x2209>
4200dcc8:	24a2c2        	movi	a12, 0x224
4200dccb:	10c182        	addi	a8, a1, 16
4200dcce:	a021b2        	l32i	a11, a1, 0x280
4200dcd1:	a121a2        	l32i	a10, a1, 0x284
4200dcd4:	c8ca      	add.n	a12, a8, a12
4200dcd6:	201110        	or	a1, a1, a1
4200dcd9:	00fbe5        	call8	4200ec98 <__sprint_r>
4200dcdc:	1a8c      	beqz.n	a10, 4200dce1 <_vfprintf_r+0x2201>
4200dcde:	027686        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200dce1:	e4a182        	movi	a8, 0x1e4
4200dce4:	10c192        	addi	a9, a1, 16
4200dce7:	298a      	add.n	a2, a9, a8
4200dce9:	b92182        	l32i	a8, a1, 0x2e4
4200dcec:	046816        	beqz	a8, 4200dd36 <_vfprintf_r+0x2256>
4200dcef:	10c182        	addi	a8, a1, 16
4200dcf2:	02d892        	addmi	a9, a8, 0x200
4200dcf5:	8f2182        	l32i	a8, a1, 0x23c
4200dcf8:	50a2a2        	movi	a10, 0x250
4200dcfb:	882b      	addi.n	a8, a8, 2
4200dcfd:	10c1b2        	addi	a11, a1, 16
4200dd00:	b989      	s32i.n	a8, a9, 44
4200dd02:	a988      	l32i.n	a8, a9, 40
4200dd04:	abaa      	add.n	a10, a11, a10
4200dd06:	02a9      	s32i.n	a10, a2, 0
4200dd08:	881b      	addi.n	a8, a8, 1
4200dd0a:	2a0c      	movi.n	a10, 2
4200dd0c:	12a9      	s32i.n	a10, a2, 4
4200dd0e:	a989      	s32i.n	a8, a9, 40
4200dd10:	228b      	addi.n	a2, a2, 8
4200dd12:	2088a6        	blti	a8, 8, 4200dd36 <_vfprintf_r+0x2256>
4200dd15:	24a2c2        	movi	a12, 0x224
4200dd18:	10c182        	addi	a8, a1, 16
4200dd1b:	a021b2        	l32i	a11, a1, 0x280
4200dd1e:	a121a2        	l32i	a10, a1, 0x284
4200dd21:	c8ca      	add.n	a12, a8, a12
4200dd23:	201110        	or	a1, a1, a1
4200dd26:	00f725        	call8	4200ec98 <__sprint_r>
4200dd29:	1a8c      	beqz.n	a10, 4200dd2e <_vfprintf_r+0x224e>
4200dd2b:	026346        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200dd2e:	e4a182        	movi	a8, 0x1e4
4200dd31:	10c192        	addi	a9, a1, 16
4200dd34:	298a      	add.n	a2, a9, a8
4200dd36:	ba2182        	l32i	a8, a1, 0x2e8
4200dd39:	02e826        	beqi	a8, 128, 4200dd3f <_vfprintf_r+0x225f>
4200dd3c:	002246        	j	4200ddc9 <_vfprintf_r+0x22e9>
4200dd3f:	ac2182        	l32i	a8, a1, 0x2b0
4200dd42:	af2192        	l32i	a9, a1, 0x2bc
4200dd45:	10c1e2        	addi	a14, a1, 16
4200dd48:	c0f890        	sub	a15, a8, a9
4200dd4b:	371fe6        	bgei	a15, 1, 4200dd86 <_vfprintf_r+0x22a6>
4200dd4e:	001dc6        	j	4200ddc9 <_vfprintf_r+0x22e9>
4200dd51:	10cbb2        	addi	a11, a11, 16
4200dd54:	12d9      	s32i.n	a13, a2, 4
4200dd56:	b9b9      	s32i.n	a11, a9, 44
4200dd58:	a989      	s32i.n	a8, a9, 40
4200dd5a:	2388a6        	blti	a8, 8, 4200dd81 <_vfprintf_r+0x22a1>
4200dd5d:	24a2c2        	movi	a12, 0x224
4200dd60:	a021b2        	l32i	a11, a1, 0x280
4200dd63:	a121a2        	l32i	a10, a1, 0x284
4200dd66:	ceca      	add.n	a12, a14, a12
4200dd68:	b961f2        	s32i	a15, a1, 0x2e4
4200dd6b:	201110        	or	a1, a1, a1
4200dd6e:	00f2a5        	call8	4200ec98 <__sprint_r>
4200dd71:	1a8c      	beqz.n	a10, 4200dd76 <_vfprintf_r+0x2296>
4200dd73:	025146        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200dd76:	e4a1a2        	movi	a10, 0x1e4
4200dd79:	10c1e2        	addi	a14, a1, 16
4200dd7c:	b921f2        	l32i	a15, a1, 0x2e4
4200dd7f:	aeaa      	add.n	a10, a14, a10
4200dd81:	f0cff2        	addi	a15, a15, -16
4200dd84:	0a2d      	mov.n	a2, a10
4200dd86:	cbdec1        	l32r	a12, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200dd89:	8a2e82        	l32i	a8, a14, 0x228
4200dd8c:	0d1c      	movi.n	a13, 16
4200dd8e:	02c9      	s32i.n	a12, a2, 0
4200dd90:	02de92        	addmi	a9, a14, 0x200
4200dd93:	881b      	addi.n	a8, a8, 1
4200dd95:	a28b      	addi.n	a10, a2, 8
4200dd97:	b9b8      	l32i.n	a11, a9, 44
4200dd99:	b42df7        	blt	a13, a15, 4200dd51 <_vfprintf_r+0x2271>
4200dd9c:	bfba      	add.n	a11, a15, a11
4200dd9e:	12f9      	s32i.n	a15, a2, 4
4200dda0:	b9b9      	s32i.n	a11, a9, 44
4200dda2:	0a6982        	s32i	a8, a9, 40
4200dda5:	0a2d      	mov.n	a2, a10
4200dda7:	1e88a6        	blti	a8, 8, 4200ddc9 <_vfprintf_r+0x22e9>
4200ddaa:	24a2c2        	movi	a12, 0x224
4200ddad:	a021b2        	l32i	a11, a1, 0x280
4200ddb0:	a121a2        	l32i	a10, a1, 0x284
4200ddb3:	80cec0        	add	a12, a14, a12
4200ddb6:	201110        	or	a1, a1, a1
4200ddb9:	00ede5        	call8	4200ec98 <__sprint_r>
4200ddbc:	1a8c      	beqz.n	a10, 4200ddc1 <_vfprintf_r+0x22e1>
4200ddbe:	023e86        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200ddc1:	e4a182        	movi	a8, 0x1e4
4200ddc4:	10c1e2        	addi	a14, a1, 16
4200ddc7:	2e8a      	add.n	a2, a14, a8
4200ddc9:	a22182        	l32i	a8, a1, 0x288
4200ddcc:	c04480        	sub	a4, a4, a8
4200ddcf:	7b14a6        	blti	a4, 1, 4200de4e <_vfprintf_r+0x236e>
4200ddd2:	000c46        	j	4200de07 <_vfprintf_r+0x2327>
4200ddd5:	10cbb2        	addi	a11, a11, 16
4200ddd8:	12d9      	s32i.n	a13, a2, 4
4200ddda:	b9b9      	s32i.n	a11, a9, 44
4200dddc:	a989      	s32i.n	a8, a9, 40
4200ddde:	2088a6        	blti	a8, 8, 4200de02 <_vfprintf_r+0x2322>
4200dde1:	24a2c2        	movi	a12, 0x224
4200dde4:	10c182        	addi	a8, a1, 16
4200dde7:	a021b2        	l32i	a11, a1, 0x280
4200ddea:	a121a2        	l32i	a10, a1, 0x284
4200dded:	c8ca      	add.n	a12, a8, a12
4200ddef:	201110        	or	a1, a1, a1
4200ddf2:	00ea65        	call8	4200ec98 <__sprint_r>
4200ddf5:	1a8c      	beqz.n	a10, 4200ddfa <_vfprintf_r+0x231a>
4200ddf7:	023046        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200ddfa:	e4a1a2        	movi	a10, 0x1e4
4200ddfd:	10c182        	addi	a8, a1, 16
4200de00:	a8aa      	add.n	a10, a8, a10
4200de02:	f0c442        	addi	a4, a4, -16
4200de05:	0a2d      	mov.n	a2, a10
4200de07:	10c182        	addi	a8, a1, 16
4200de0a:	02d892        	addmi	a9, a8, 0x200
4200de0d:	cbbcc1        	l32r	a12, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200de10:	a988      	l32i.n	a8, a9, 40
4200de12:	0d1c      	movi.n	a13, 16
4200de14:	02c9      	s32i.n	a12, a2, 0
4200de16:	881b      	addi.n	a8, a8, 1
4200de18:	a28b      	addi.n	a10, a2, 8
4200de1a:	b9b8      	l32i.n	a11, a9, 44
4200de1c:	b52d47        	blt	a13, a4, 4200ddd5 <_vfprintf_r+0x22f5>
4200de1f:	1249      	s32i.n	a4, a2, 4
4200de21:	44ba      	add.n	a4, a4, a11
4200de23:	b949      	s32i.n	a4, a9, 44
4200de25:	a989      	s32i.n	a8, a9, 40
4200de27:	0a2d      	mov.n	a2, a10
4200de29:	2188a6        	blti	a8, 8, 4200de4e <_vfprintf_r+0x236e>
4200de2c:	24a2c2        	movi	a12, 0x224
4200de2f:	10c182        	addi	a8, a1, 16
4200de32:	a021b2        	l32i	a11, a1, 0x280
4200de35:	a121a2        	l32i	a10, a1, 0x284
4200de38:	80c8c0        	add	a12, a8, a12
4200de3b:	201110        	or	a1, a1, a1
4200de3e:	00e5a5        	call8	4200ec98 <__sprint_r>
4200de41:	1a8c      	beqz.n	a10, 4200de46 <_vfprintf_r+0x2366>
4200de43:	021d46        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200de46:	e4a182        	movi	a8, 0x1e4
4200de49:	10c192        	addi	a9, a1, 16
4200de4c:	298a      	add.n	a2, a9, a8
4200de4e:	10c182        	addi	a8, a1, 16
4200de51:	02d8e2        	addmi	a14, a8, 0x200
4200de54:	be98      	l32i.n	a9, a14, 44
4200de56:	3fe387        	bbsi	a3, 8, 4200de99 <_vfprintf_r+0x23b9>
4200de59:	9f2182        	l32i	a8, a1, 0x27c
4200de5c:	0289      	s32i.n	a8, a2, 0
4200de5e:	a22182        	l32i	a8, a1, 0x288
4200de61:	1289      	s32i.n	a8, a2, 4
4200de63:	889a      	add.n	a8, a8, a9
4200de65:	be89      	s32i.n	a8, a14, 44
4200de67:	ae88      	l32i.n	a8, a14, 40
4200de69:	228b      	addi.n	a2, a2, 8
4200de6b:	881b      	addi.n	a8, a8, 1
4200de6d:	ae89      	s32i.n	a8, a14, 40
4200de6f:	0288e6        	bgei	a8, 8, 4200de75 <_vfprintf_r+0x2395>
4200de72:	01d3c6        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200de75:	24a2c2        	movi	a12, 0x224
4200de78:	10c182        	addi	a8, a1, 16
4200de7b:	a021b2        	l32i	a11, a1, 0x280
4200de7e:	a121a2        	l32i	a10, a1, 0x284
4200de81:	c8ca      	add.n	a12, a8, a12
4200de83:	201110        	or	a1, a1, a1
4200de86:	00e125        	call8	4200ec98 <__sprint_r>
4200de89:	1a8c      	beqz.n	a10, 4200de8e <_vfprintf_r+0x23ae>
4200de8b:	020b46        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200de8e:	e4a182        	movi	a8, 0x1e4
4200de91:	10c192        	addi	a9, a1, 16
4200de94:	298a      	add.n	a2, a9, a8
4200de96:	01cac6        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200de99:	a321a2        	l32i	a10, a1, 0x28c
4200de9c:	65a082        	movi	a8, 101
4200de9f:	0228a7        	blt	a8, a10, 4200dea5 <_vfprintf_r+0x23c5>
4200dea2:	015d86        	j	4200e41c <_vfprintf_r+0x293c>
4200dea5:	98a282        	movi	a8, 0x298
4200dea8:	881a      	add.n	a8, a8, a1
4200deaa:	08a8      	l32i.n	a10, a8, 0
4200deac:	0128b2        	l32i	a11, a8, 4
4200deaf:	a361e2        	s32i	a14, a1, 0x28c
4200deb2:	a26192        	s32i	a9, a1, 0x288
4200deb5:	0c0c      	movi.n	a12, 0
4200deb7:	00a0d2        	movi	a13, 0
4200deba:	cb9981        	l32r	a8, 42000d20 <_stext+0xd00> (4000228c <__eqdf2>)
4200debd:	0008e0        	callx8	a8
4200dec0:	a22192        	l32i	a9, a1, 0x288
4200dec3:	a321e2        	l32i	a14, a1, 0x28c
4200dec6:	0dea56        	bnez	a10, 4200dfa8 <_vfprintf_r+0x24c8>
4200dec9:	cb8e81        	l32r	a8, 42000d04 <_stext+0xce4> (3c029180 <Xthal_intlevel+0x54>)
4200decc:	0289      	s32i.n	a8, a2, 0
4200dece:	180c      	movi.n	a8, 1
4200ded0:	1289      	s32i.n	a8, a2, 4
4200ded2:	891b      	addi.n	a8, a9, 1
4200ded4:	be89      	s32i.n	a8, a14, 44
4200ded6:	ae88      	l32i.n	a8, a14, 40
4200ded8:	228b      	addi.n	a2, a2, 8
4200deda:	881b      	addi.n	a8, a8, 1
4200dedc:	ae89      	s32i.n	a8, a14, 40
4200dede:	1f88a6        	blti	a8, 8, 4200df01 <_vfprintf_r+0x2421>
4200dee1:	24a2c2        	movi	a12, 0x224
4200dee4:	10c182        	addi	a8, a1, 16
4200dee7:	a021b2        	l32i	a11, a1, 0x280
4200deea:	a121a2        	l32i	a10, a1, 0x284
4200deed:	c8ca      	add.n	a12, a8, a12
4200deef:	201110        	or	a1, a1, a1
4200def2:	00da65        	call8	4200ec98 <__sprint_r>
4200def5:	7c3a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200def8:	e4a182        	movi	a8, 0x1e4
4200defb:	10c192        	addi	a9, a1, 16
4200defe:	802980        	add	a2, a9, a8
4200df01:	952182        	l32i	a8, a1, 0x254
4200df04:	a42192        	l32i	a9, a1, 0x290
4200df07:	052897        	blt	a8, a9, 4200df10 <_vfprintf_r+0x2430>
4200df0a:	02e307        	bbsi	a3, 0, 4200df10 <_vfprintf_r+0x2430>
4200df0d:	01ad06        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200df10:	b12182        	l32i	a8, a1, 0x2c4
4200df13:	10c162        	addi	a6, a1, 16
4200df16:	0289      	s32i.n	a8, a2, 0
4200df18:	ad2182        	l32i	a8, a1, 0x2b4
4200df1b:	ad21a2        	l32i	a10, a1, 0x2b4
4200df1e:	1289      	s32i.n	a8, a2, 4
4200df20:	8b2682        	l32i	a8, a6, 0x22c
4200df23:	228b      	addi.n	a2, a2, 8
4200df25:	88aa      	add.n	a8, a8, a10
4200df27:	8b6682        	s32i	a8, a6, 0x22c
4200df2a:	8a2682        	l32i	a8, a6, 0x228
4200df2d:	01c882        	addi	a8, a8, 1
4200df30:	8a6682        	s32i	a8, a6, 0x228
4200df33:	1988a6        	blti	a8, 8, 4200df50 <_vfprintf_r+0x2470>
4200df36:	24a2c2        	movi	a12, 0x224
4200df39:	a021b2        	l32i	a11, a1, 0x280
4200df3c:	a121a2        	l32i	a10, a1, 0x284
4200df3f:	80c6c0        	add	a12, a6, a12
4200df42:	201110        	or	a1, a1, a1
4200df45:	00d525        	call8	4200ec98 <__sprint_r>
4200df48:	770a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200df4b:	e4a182        	movi	a8, 0x1e4
4200df4e:	268a      	add.n	a2, a6, a8
4200df50:	a42182        	l32i	a8, a1, 0x290
4200df53:	680b      	addi.n	a6, a8, -1
4200df55:	0216e6        	bgei	a6, 1, 4200df5b <_vfprintf_r+0x247b>
4200df58:	019a46        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200df5b:	10c152        	addi	a5, a1, 16
4200df5e:	000ac6        	j	4200df8d <_vfprintf_r+0x24ad>
4200df61:	10cbb2        	addi	a11, a11, 16
4200df64:	12d9      	s32i.n	a13, a2, 4
4200df66:	b9b9      	s32i.n	a11, a9, 44
4200df68:	0a6982        	s32i	a8, a9, 40
4200df6b:	1988a6        	blti	a8, 8, 4200df88 <_vfprintf_r+0x24a8>
4200df6e:	24a2c2        	movi	a12, 0x224
4200df71:	a021b2        	l32i	a11, a1, 0x280
4200df74:	a121a2        	l32i	a10, a1, 0x284
4200df77:	80c5c0        	add	a12, a5, a12
4200df7a:	201110        	or	a1, a1, a1
4200df7d:	00d1a5        	call8	4200ec98 <__sprint_r>
4200df80:	738a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200df83:	e4a1a2        	movi	a10, 0x1e4
4200df86:	a5aa      	add.n	a10, a5, a10
4200df88:	f0c662        	addi	a6, a6, -16
4200df8b:	0a2d      	mov.n	a2, a10
4200df8d:	cb5cc1        	l32r	a12, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200df90:	8a2582        	l32i	a8, a5, 0x228
4200df93:	0d1c      	movi.n	a13, 16
4200df95:	02c9      	s32i.n	a12, a2, 0
4200df97:	02d592        	addmi	a9, a5, 0x200
4200df9a:	881b      	addi.n	a8, a8, 1
4200df9c:	a28b      	addi.n	a10, a2, 8
4200df9e:	b9b8      	l32i.n	a11, a9, 44
4200dfa0:	bd2d67        	blt	a13, a6, 4200df61 <_vfprintf_r+0x2481>
4200dfa3:	011206        	j	4200e3ef <_vfprintf_r+0x290f>
4200dfa6:	820000        	mull	a0, a0, a0
4200dfa9:	a69521        	l32r	a2, 41ff7a00 <_coredump_iram_end+0x1c75b00>
4200dfac:	0218      	l32i.n	a1, a2, 0
4200dfae:	004ac6        	j	4200e0dd <_vfprintf_r+0x25fd>
4200dfb1:	cb5481        	l32r	a8, 42000d04 <_stext+0xce4> (3c029180 <Xthal_intlevel+0x54>)
4200dfb4:	0289      	s32i.n	a8, a2, 0
4200dfb6:	180c      	movi.n	a8, 1
4200dfb8:	1289      	s32i.n	a8, a2, 4
4200dfba:	891b      	addi.n	a8, a9, 1
4200dfbc:	be89      	s32i.n	a8, a14, 44
4200dfbe:	ae88      	l32i.n	a8, a14, 40
4200dfc0:	228b      	addi.n	a2, a2, 8
4200dfc2:	881b      	addi.n	a8, a8, 1
4200dfc4:	ae89      	s32i.n	a8, a14, 40
4200dfc6:	1e88a6        	blti	a8, 8, 4200dfe8 <_vfprintf_r+0x2508>
4200dfc9:	24a2c2        	movi	a12, 0x224
4200dfcc:	10c182        	addi	a8, a1, 16
4200dfcf:	a021b2        	l32i	a11, a1, 0x280
4200dfd2:	a121a2        	l32i	a10, a1, 0x284
4200dfd5:	c8ca      	add.n	a12, a8, a12
4200dfd7:	201110        	or	a1, a1, a1
4200dfda:	00cbe5        	call8	4200ec98 <__sprint_r>
4200dfdd:	6dba56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200dfe0:	e4a182        	movi	a8, 0x1e4
4200dfe3:	10c192        	addi	a9, a1, 16
4200dfe6:	298a      	add.n	a2, a9, a8
4200dfe8:	a421b2        	l32i	a11, a1, 0x290
4200dfeb:	952192        	l32i	a9, a1, 0x254
4200dfee:	10c162        	addi	a6, a1, 16
4200dff1:	209b90        	or	a9, a11, a9
4200dff4:	04b030        	extui	a11, a3, 0, 1
4200dff7:	2099b0        	or	a9, a9, a11
4200dffa:	8b2682        	l32i	a8, a6, 0x22c
4200dffd:	5c4916        	beqz	a9, 4200e5c5 <_vfprintf_r+0x2ae5>
4200e000:	b12192        	l32i	a9, a1, 0x2c4
4200e003:	0299      	s32i.n	a9, a2, 0
4200e005:	ad2192        	l32i	a9, a1, 0x2b4
4200e008:	898a      	add.n	a8, a9, a8
4200e00a:	8b6682        	s32i	a8, a6, 0x22c
4200e00d:	8a2682        	l32i	a8, a6, 0x228
4200e010:	1299      	s32i.n	a9, a2, 4
4200e012:	881b      	addi.n	a8, a8, 1
4200e014:	8a6682        	s32i	a8, a6, 0x228
4200e017:	0588e6        	bgei	a8, 8, 4200e020 <_vfprintf_r+0x2540>
4200e01a:	828b      	addi.n	a8, a2, 8
4200e01c:	000646        	j	4200e039 <_vfprintf_r+0x2559>
4200e01f:	a2c200        	muluh	a12, a2, a0
4200e022:	21b224        	lsi	f2, a2, 132
4200e025:	21a2a0        	srai	a10, a10, 2
4200e028:	c6caa1        	l32r	a10, 41fffb50 <_coredump_iram_end+0x1c7dc50>
4200e02b:	201110        	or	a1, a1, a1
4200e02e:	00c6a5        	call8	4200ec98 <__sprint_r>
4200e031:	687a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e034:	e4a182        	movi	a8, 0x1e4
4200e037:	868a      	add.n	a8, a6, a8
4200e039:	952162        	l32i	a6, a1, 0x254
4200e03c:	0706d6        	bgez	a6, 4200e0b0 <_vfprintf_r+0x25d0>
4200e03f:	606060        	neg	a6, a6
4200e042:	08bd      	mov.n	a11, a8
4200e044:	10c152        	addi	a5, a1, 16
4200e047:	000ac6        	j	4200e076 <_vfprintf_r+0x2596>
4200e04a:	c20000        	quou	a0, a0, a0
4200e04d:	10cc      	bnez.n	a0, 4200e052 <_vfprintf_r+0x2572>
4200e04f:	1be9      	s32i.n	a14, a11, 4
4200e051:	bac9      	s32i.n	a12, a10, 44
4200e053:	aa99      	s32i.n	a9, a10, 40
4200e055:	1889a6        	blti	a9, 8, 4200e071 <_vfprintf_r+0x2591>
4200e058:	24a2c2        	movi	a12, 0x224
4200e05b:	a021b2        	l32i	a11, a1, 0x280
4200e05e:	a121a2        	l32i	a10, a1, 0x284
4200e061:	c5ca      	add.n	a12, a5, a12
4200e063:	201110        	or	a1, a1, a1
4200e066:	00c325        	call8	4200ec98 <__sprint_r>
4200e069:	64fa56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e06c:	e4a182        	movi	a8, 0x1e4
4200e06f:	858a      	add.n	a8, a5, a8
4200e071:	f0c662        	addi	a6, a6, -16
4200e074:	08bd      	mov.n	a11, a8
4200e076:	cb22d1        	l32r	a13, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200e079:	8a2592        	l32i	a9, a5, 0x228
4200e07c:	0e1c      	movi.n	a14, 16
4200e07e:	0bd9      	s32i.n	a13, a11, 0
4200e080:	02d5a2        	addmi	a10, a5, 0x200
4200e083:	991b      	addi.n	a9, a9, 1
4200e085:	888b      	addi.n	a8, a8, 8
4200e087:	bac8      	l32i.n	a12, a10, 44
4200e089:	bf2e67        	blt	a14, a6, 4200e04c <_vfprintf_r+0x256c>
4200e08c:	1b69      	s32i.n	a6, a11, 4
4200e08e:	66ca      	add.n	a6, a6, a12
4200e090:	ba69      	s32i.n	a6, a10, 44
4200e092:	aa99      	s32i.n	a9, a10, 40
4200e094:	1889a6        	blti	a9, 8, 4200e0b0 <_vfprintf_r+0x25d0>
4200e097:	24a2c2        	movi	a12, 0x224
4200e09a:	a021b2        	l32i	a11, a1, 0x280
4200e09d:	a121a2        	l32i	a10, a1, 0x284
4200e0a0:	c5ca      	add.n	a12, a5, a12
4200e0a2:	201110        	or	a1, a1, a1
4200e0a5:	00bf25        	call8	4200ec98 <__sprint_r>
4200e0a8:	610a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e0ab:	e4a182        	movi	a8, 0x1e4
4200e0ae:	858a      	add.n	a8, a5, a8
4200e0b0:	9f2192        	l32i	a9, a1, 0x27c
4200e0b3:	10c122        	addi	a2, a1, 16
4200e0b6:	0899      	s32i.n	a9, a8, 0
4200e0b8:	a42192        	l32i	a9, a1, 0x290
4200e0bb:	a421b2        	l32i	a11, a1, 0x290
4200e0be:	1899      	s32i.n	a9, a8, 4
4200e0c0:	8b2292        	l32i	a9, a2, 0x22c
4200e0c3:	99ba      	add.n	a9, a9, a11
4200e0c5:	8b6292        	s32i	a9, a2, 0x22c
4200e0c8:	8a2292        	l32i	a9, a2, 0x228
4200e0cb:	991b      	addi.n	a9, a9, 1
4200e0cd:	8a6292        	s32i	a9, a2, 0x228
4200e0d0:	0289a6        	blti	a9, 8, 4200e0d6 <_vfprintf_r+0x25f6>
4200e0d3:	013546        	j	4200e5ac <_vfprintf_r+0x2acc>
4200e0d6:	288b      	addi.n	a2, a8, 8
4200e0d8:	013a46        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200e0db:	820000        	mull	a0, a0, a0
4200e0de:	80a421        	l32r	a2, 41fee370 <_coredump_iram_end+0x1c6c470>
4200e0e1:	a64346        	j	41ff79f2 <_coredump_iram_end+0x1c75af2>
4200e0e4:	823514        	lsi	f1, a5, 0x208
4200e0e7:	499f21        	l32r	a2, 41fe0764 <_coredump_iram_end+0x1c5e864>
4200e0ea:	028912        	lsi	f1, a9, 8
4200e0ed:	849a      	add.n	a8, a4, a9
4200e0ef:	be89      	s32i.n	a8, a14, 44
4200e0f1:	ae88      	l32i.n	a8, a14, 40
4200e0f3:	228b      	addi.n	a2, a2, 8
4200e0f5:	881b      	addi.n	a8, a8, 1
4200e0f7:	ae89      	s32i.n	a8, a14, 40
4200e0f9:	1f88a6        	blti	a8, 8, 4200e11c <_vfprintf_r+0x263c>
4200e0fc:	24a2c2        	movi	a12, 0x224
4200e0ff:	10c182        	addi	a8, a1, 16
4200e102:	a021b2        	l32i	a11, a1, 0x280
4200e105:	a121a2        	l32i	a10, a1, 0x284
4200e108:	80c8c0        	add	a12, a8, a12
4200e10b:	201110        	or	a1, a1, a1
4200e10e:	00b8a5        	call8	4200ec98 <__sprint_r>
4200e111:	5a7a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e114:	e4a182        	movi	a8, 0x1e4
4200e117:	10c192        	addi	a9, a1, 16
4200e11a:	298a      	add.n	a2, a9, a8
4200e11c:	080c      	movi.n	a8, 0
4200e11e:	534480        	max	a4, a4, a8
4200e121:	c04640        	sub	a4, a6, a4
4200e124:	10c1e2        	addi	a14, a1, 16
4200e127:	3214e6        	bgei	a4, 1, 4200e15d <_vfprintf_r+0x267d>
4200e12a:	001b86        	j	4200e19c <_vfprintf_r+0x26bc>
4200e12d:	10cbb2        	addi	a11, a11, 16
4200e130:	12d9      	s32i.n	a13, a2, 4
4200e132:	0b69b2        	s32i	a11, a9, 44
4200e135:	0a6982        	s32i	a8, a9, 40
4200e138:	1c88a6        	blti	a8, 8, 4200e158 <_vfprintf_r+0x2678>
4200e13b:	24a2c2        	movi	a12, 0x224
4200e13e:	a021b2        	l32i	a11, a1, 0x280
4200e141:	a121a2        	l32i	a10, a1, 0x284
4200e144:	80cec0        	add	a12, a14, a12
4200e147:	201110        	or	a1, a1, a1
4200e14a:	00b4e5        	call8	4200ec98 <__sprint_r>
4200e14d:	56ba56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e150:	e4a1a2        	movi	a10, 0x1e4
4200e153:	10c1e2        	addi	a14, a1, 16
4200e156:	aeaa      	add.n	a10, a14, a10
4200e158:	f0c442        	addi	a4, a4, -16
4200e15b:	0a2d      	mov.n	a2, a10
4200e15d:	cae8c1        	l32r	a12, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200e160:	8a2e82        	l32i	a8, a14, 0x228
4200e163:	0d1c      	movi.n	a13, 16
4200e165:	02c9      	s32i.n	a12, a2, 0
4200e167:	02de92        	addmi	a9, a14, 0x200
4200e16a:	881b      	addi.n	a8, a8, 1
4200e16c:	a28b      	addi.n	a10, a2, 8
4200e16e:	b9b8      	l32i.n	a11, a9, 44
4200e170:	b92d47        	blt	a13, a4, 4200e12d <_vfprintf_r+0x264d>
4200e173:	1249      	s32i.n	a4, a2, 4
4200e175:	44ba      	add.n	a4, a4, a11
4200e177:	b949      	s32i.n	a4, a9, 44
4200e179:	a989      	s32i.n	a8, a9, 40
4200e17b:	0a2d      	mov.n	a2, a10
4200e17d:	1b88a6        	blti	a8, 8, 4200e19c <_vfprintf_r+0x26bc>
4200e180:	24a2c2        	movi	a12, 0x224
4200e183:	a021b2        	l32i	a11, a1, 0x280
4200e186:	a121a2        	l32i	a10, a1, 0x284
4200e189:	ceca      	add.n	a12, a14, a12
4200e18b:	201110        	or	a1, a1, a1
4200e18e:	00b0a5        	call8	4200ec98 <__sprint_r>
4200e191:	527a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e194:	e4a182        	movi	a8, 0x1e4
4200e197:	10c1e2        	addi	a14, a1, 16
4200e19a:	2e8a      	add.n	a2, a14, a8
4200e19c:	9f2182        	l32i	a8, a1, 0x27c
4200e19f:	686a      	add.n	a6, a8, a6
4200e1a1:	02e3a7        	bbsi	a3, 10, 4200e1a7 <_vfprintf_r+0x26c7>
4200e1a4:	005346        	j	4200e2f5 <_vfprintf_r+0x2815>
4200e1a7:	10c142        	addi	a4, a1, 16
4200e1aa:	004ac6        	j	4200e2d9 <_vfprintf_r+0x27f9>
4200e1ad:	ab2182        	l32i	a8, a1, 0x2ac
4200e1b0:	0718a6        	blti	a8, 1, 4200e1bb <_vfprintf_r+0x26db>
4200e1b3:	880b      	addi.n	a8, a8, -1
4200e1b5:	ab6182        	s32i	a8, a1, 0x2ac
4200e1b8:	000246        	j	4200e1c5 <_vfprintf_r+0x26e5>
4200e1bb:	aa2182        	l32i	a8, a1, 0x2a8
4200e1be:	550b      	addi.n	a5, a5, -1
4200e1c0:	880b      	addi.n	a8, a8, -1
4200e1c2:	aa6182        	s32i	a8, a1, 0x2a8
4200e1c5:	b62182        	l32i	a8, a1, 0x2d8
4200e1c8:	b021a2        	l32i	a10, a1, 0x2c0
4200e1cb:	0289      	s32i.n	a8, a2, 0
4200e1cd:	b02182        	l32i	a8, a1, 0x2c0
4200e1d0:	1289      	s32i.n	a8, a2, 4
4200e1d2:	8b2482        	l32i	a8, a4, 0x22c
4200e1d5:	228b      	addi.n	a2, a2, 8
4200e1d7:	88aa      	add.n	a8, a8, a10
4200e1d9:	8b6482        	s32i	a8, a4, 0x22c
4200e1dc:	8a2482        	l32i	a8, a4, 0x228
4200e1df:	881b      	addi.n	a8, a8, 1
4200e1e1:	8a6482        	s32i	a8, a4, 0x228
4200e1e4:	1888a6        	blti	a8, 8, 4200e200 <_vfprintf_r+0x2720>
4200e1e7:	24a2c2        	movi	a12, 0x224
4200e1ea:	a021b2        	l32i	a11, a1, 0x280
4200e1ed:	a121a2        	l32i	a10, a1, 0x284
4200e1f0:	c4ca      	add.n	a12, a4, a12
4200e1f2:	201110        	or	a1, a1, a1
4200e1f5:	00aa25        	call8	4200ec98 <__sprint_r>
4200e1f8:	4c0a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e1fb:	e4a182        	movi	a8, 0x1e4
4200e1fe:	248a      	add.n	a2, a4, a8
4200e200:	a42192        	l32i	a9, a1, 0x290
4200e203:	9f2182        	l32i	a8, a1, 0x27c
4200e206:	889a      	add.n	a8, a8, a9
4200e208:	c09860        	sub	a9, a8, a6
4200e20b:	aa2182        	l32i	a8, a1, 0x2a8
4200e20e:	000882        	l8ui	a8, a8, 0
4200e211:	43d980        	min	a13, a9, a8
4200e214:	381da6        	blti	a13, 1, 4200e250 <_vfprintf_r+0x2770>
4200e217:	8b2482        	l32i	a8, a4, 0x22c
4200e21a:	0269      	s32i.n	a6, a2, 0
4200e21c:	8d8a      	add.n	a8, a13, a8
4200e21e:	8b6482        	s32i	a8, a4, 0x22c
4200e221:	8a2482        	l32i	a8, a4, 0x228
4200e224:	12d9      	s32i.n	a13, a2, 4
4200e226:	881b      	addi.n	a8, a8, 1
4200e228:	8a6482        	s32i	a8, a4, 0x228
4200e22b:	228b      	addi.n	a2, a2, 8
4200e22d:	1f88a6        	blti	a8, 8, 4200e250 <_vfprintf_r+0x2770>
4200e230:	24a2c2        	movi	a12, 0x224
4200e233:	a021b2        	l32i	a11, a1, 0x280
4200e236:	a121a2        	l32i	a10, a1, 0x284
4200e239:	80c4c0        	add	a12, a4, a12
4200e23c:	a261d2        	s32i	a13, a1, 0x288
4200e23f:	201110        	or	a1, a1, a1
4200e242:	00a565        	call8	4200ec98 <__sprint_r>
4200e245:	473a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e248:	e4a182        	movi	a8, 0x1e4
4200e24b:	a221d2        	l32i	a13, a1, 0x288
4200e24e:	248a      	add.n	a2, a4, a8
4200e250:	aa2182        	l32i	a8, a1, 0x2a8
4200e253:	000892        	l8ui	a9, a8, 0
4200e256:	080c      	movi.n	a8, 0
4200e258:	538d80        	max	a8, a13, a8
4200e25b:	c0e980        	sub	a14, a9, a8
4200e25e:	6f1ea6        	blti	a14, 1, 4200e2d1 <_vfprintf_r+0x27f1>
4200e261:	000c06        	j	4200e295 <_vfprintf_r+0x27b5>
4200e264:	10cbb2        	addi	a11, a11, 16
4200e267:	12d9      	s32i.n	a13, a2, 4
4200e269:	b9b9      	s32i.n	a11, a9, 44
4200e26b:	a989      	s32i.n	a8, a9, 40
4200e26d:	1f88a6        	blti	a8, 8, 4200e290 <_vfprintf_r+0x27b0>
4200e270:	24a2c2        	movi	a12, 0x224
4200e273:	a021b2        	l32i	a11, a1, 0x280
4200e276:	a121a2        	l32i	a10, a1, 0x284
4200e279:	80c4c0        	add	a12, a4, a12
4200e27c:	a261e2        	s32i	a14, a1, 0x288
4200e27f:	201110        	or	a1, a1, a1
4200e282:	00a165        	call8	4200ec98 <__sprint_r>
4200e285:	433a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e288:	e4a1a2        	movi	a10, 0x1e4
4200e28b:	a221e2        	l32i	a14, a1, 0x288
4200e28e:	a4aa      	add.n	a10, a4, a10
4200e290:	f0cee2        	addi	a14, a14, -16
4200e293:	0a2d      	mov.n	a2, a10
4200e295:	ca9ac1        	l32r	a12, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200e298:	8a2482        	l32i	a8, a4, 0x228
4200e29b:	0d1c      	movi.n	a13, 16
4200e29d:	02c9      	s32i.n	a12, a2, 0
4200e29f:	02d492        	addmi	a9, a4, 0x200
4200e2a2:	881b      	addi.n	a8, a8, 1
4200e2a4:	a28b      	addi.n	a10, a2, 8
4200e2a6:	b9b8      	l32i.n	a11, a9, 44
4200e2a8:	b82de7        	blt	a13, a14, 4200e264 <_vfprintf_r+0x2784>
4200e2ab:	beba      	add.n	a11, a14, a11
4200e2ad:	12e9      	s32i.n	a14, a2, 4
4200e2af:	b9b9      	s32i.n	a11, a9, 44
4200e2b1:	a989      	s32i.n	a8, a9, 40
4200e2b3:	0a2d      	mov.n	a2, a10
4200e2b5:	1888a6        	blti	a8, 8, 4200e2d1 <_vfprintf_r+0x27f1>
4200e2b8:	24a2c2        	movi	a12, 0x224
4200e2bb:	a021b2        	l32i	a11, a1, 0x280
4200e2be:	a121a2        	l32i	a10, a1, 0x284
4200e2c1:	c4ca      	add.n	a12, a4, a12
4200e2c3:	201110        	or	a1, a1, a1
4200e2c6:	009d25        	call8	4200ec98 <__sprint_r>
4200e2c9:	3efa56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e2cc:	e4a182        	movi	a8, 0x1e4
4200e2cf:	248a      	add.n	a2, a4, a8
4200e2d1:	aa2182        	l32i	a8, a1, 0x2a8
4200e2d4:	000882        	l8ui	a8, a8, 0
4200e2d7:	668a      	add.n	a6, a6, a8
4200e2d9:	080c      	movi.n	a8, 0
4200e2db:	728850        	lsi	f5, a8, 0x1c8
4200e2de:	ecb856        	bnez	a8, 4200e1ad <_vfprintf_r+0x26cd>
4200e2e1:	ab2192        	l32i	a9, a1, 0x2ac
4200e2e4:	02a897        	bge	a8, a9, 4200e2ea <_vfprintf_r+0x280a>
4200e2e7:	ffb086        	j	4200e1ad <_vfprintf_r+0x26cd>
4200e2ea:	9f2182        	l32i	a8, a1, 0x27c
4200e2ed:	a42192        	l32i	a9, a1, 0x290
4200e2f0:	889a      	add.n	a8, a8, a9
4200e2f2:	636680        	minu	a6, a6, a8
4200e2f5:	952182        	l32i	a8, a1, 0x254
4200e2f8:	a42192        	l32i	a9, a1, 0x290
4200e2fb:	022897        	blt	a8, a9, 4200e301 <_vfprintf_r+0x2821>
4200e2fe:	3f6307        	bbci	a3, 0, 4200e341 <_vfprintf_r+0x2861>
4200e301:	b12182        	l32i	a8, a1, 0x2c4
4200e304:	10c152        	addi	a5, a1, 16
4200e307:	0289      	s32i.n	a8, a2, 0
4200e309:	ad2182        	l32i	a8, a1, 0x2b4
4200e30c:	ad21a2        	l32i	a10, a1, 0x2b4
4200e30f:	1289      	s32i.n	a8, a2, 4
4200e311:	8b2582        	l32i	a8, a5, 0x22c
4200e314:	228b      	addi.n	a2, a2, 8
4200e316:	88aa      	add.n	a8, a8, a10
4200e318:	8b6582        	s32i	a8, a5, 0x22c
4200e31b:	8a2582        	l32i	a8, a5, 0x228
4200e31e:	881b      	addi.n	a8, a8, 1
4200e320:	8a6582        	s32i	a8, a5, 0x228
4200e323:	1a88a6        	blti	a8, 8, 4200e341 <_vfprintf_r+0x2861>
4200e326:	24a2c2        	movi	a12, 0x224
4200e329:	a021b2        	l32i	a11, a1, 0x280
4200e32c:	a121a2        	l32i	a10, a1, 0x284
4200e32f:	80c5c0        	add	a12, a5, a12
4200e332:	201110        	or	a1, a1, a1
4200e335:	009625        	call8	4200ec98 <__sprint_r>
4200e338:	380a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e33b:	e4a182        	movi	a8, 0x1e4
4200e33e:	802580        	add	a2, a5, a8
4200e341:	a42182        	l32i	a8, a1, 0x290
4200e344:	952152        	l32i	a5, a1, 0x254
4200e347:	a42192        	l32i	a9, a1, 0x290
4200e34a:	c05850        	sub	a5, a8, a5
4200e34d:	9f2182        	l32i	a8, a1, 0x27c
4200e350:	889a      	add.n	a8, a8, a9
4200e352:	c08860        	sub	a8, a8, a6
4200e355:	435580        	min	a5, a5, a8
4200e358:	3415a6        	blti	a5, 1, 4200e390 <_vfprintf_r+0x28b0>
4200e35b:	8f2182        	l32i	a8, a1, 0x23c
4200e35e:	0269      	s32i.n	a6, a2, 0
4200e360:	858a      	add.n	a8, a5, a8
4200e362:	8f6182        	s32i	a8, a1, 0x23c
4200e365:	8e2182        	l32i	a8, a1, 0x238
4200e368:	1259      	s32i.n	a5, a2, 4
4200e36a:	881b      	addi.n	a8, a8, 1
4200e36c:	8e6182        	s32i	a8, a1, 0x238
4200e36f:	10c142        	addi	a4, a1, 16
4200e372:	228b      	addi.n	a2, a2, 8
4200e374:	1888a6        	blti	a8, 8, 4200e390 <_vfprintf_r+0x28b0>
4200e377:	24a2c2        	movi	a12, 0x224
4200e37a:	a021b2        	l32i	a11, a1, 0x280
4200e37d:	a121a2        	l32i	a10, a1, 0x284
4200e380:	c4ca      	add.n	a12, a4, a12
4200e382:	201110        	or	a1, a1, a1
4200e385:	009125        	call8	4200ec98 <__sprint_r>
4200e388:	330a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e38b:	e4a182        	movi	a8, 0x1e4
4200e38e:	248a      	add.n	a2, a4, a8
4200e390:	a42182        	l32i	a8, a1, 0x290
4200e393:	952162        	l32i	a6, a1, 0x254
4200e396:	c06860        	sub	a6, a8, a6
4200e399:	080c      	movi.n	a8, 0
4200e39b:	535580        	max	a5, a5, a8
4200e39e:	c06650        	sub	a6, a6, a5
4200e3a1:	0216e6        	bgei	a6, 1, 4200e3a7 <_vfprintf_r+0x28c7>
4200e3a4:	008746        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200e3a7:	10c152        	addi	a5, a1, 16
4200e3aa:	000ac6        	j	4200e3d9 <_vfprintf_r+0x28f9>
4200e3ad:	10cbb2        	addi	a11, a11, 16
4200e3b0:	12d9      	s32i.n	a13, a2, 4
4200e3b2:	b9b9      	s32i.n	a11, a9, 44
4200e3b4:	0a6982        	s32i	a8, a9, 40
4200e3b7:	1988a6        	blti	a8, 8, 4200e3d4 <_vfprintf_r+0x28f4>
4200e3ba:	24a2c2        	movi	a12, 0x224
4200e3bd:	a021b2        	l32i	a11, a1, 0x280
4200e3c0:	a121a2        	l32i	a10, a1, 0x284
4200e3c3:	80c5c0        	add	a12, a5, a12
4200e3c6:	201110        	or	a1, a1, a1
4200e3c9:	008ce5        	call8	4200ec98 <__sprint_r>
4200e3cc:	2eca56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e3cf:	e4a1a2        	movi	a10, 0x1e4
4200e3d2:	a5aa      	add.n	a10, a5, a10
4200e3d4:	f0c662        	addi	a6, a6, -16
4200e3d7:	0a2d      	mov.n	a2, a10
4200e3d9:	ca49c1        	l32r	a12, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200e3dc:	8a2582        	l32i	a8, a5, 0x228
4200e3df:	0d1c      	movi.n	a13, 16
4200e3e1:	02c9      	s32i.n	a12, a2, 0
4200e3e3:	02d592        	addmi	a9, a5, 0x200
4200e3e6:	881b      	addi.n	a8, a8, 1
4200e3e8:	a28b      	addi.n	a10, a2, 8
4200e3ea:	b9b8      	l32i.n	a11, a9, 44
4200e3ec:	bd2d67        	blt	a13, a6, 4200e3ad <_vfprintf_r+0x28cd>
4200e3ef:	1269      	s32i.n	a6, a2, 4
4200e3f1:	66ba      	add.n	a6, a6, a11
4200e3f3:	b969      	s32i.n	a6, a9, 44
4200e3f5:	a989      	s32i.n	a8, a9, 40
4200e3f7:	0a2d      	mov.n	a2, a10
4200e3f9:	0288e6        	bgei	a8, 8, 4200e3ff <_vfprintf_r+0x291f>
4200e3fc:	007146        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200e3ff:	24a2c2        	movi	a12, 0x224
4200e402:	a021b2        	l32i	a11, a1, 0x280
4200e405:	a121a2        	l32i	a10, a1, 0x284
4200e408:	c5ca      	add.n	a12, a5, a12
4200e40a:	201110        	or	a1, a1, a1
4200e40d:	0088a5        	call8	4200ec98 <__sprint_r>
4200e410:	2a8a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e413:	e4a182        	movi	a8, 0x1e4
4200e416:	258a      	add.n	a2, a5, a8
4200e418:	006a46        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200e41b:	ae8800        	f64iter	a8, a8, a0, 2, 0
4200e41e:	a91b      	addi.n	a10, a9, 1
4200e420:	a42192        	l32i	a9, a1, 0x290
4200e423:	881b      	addi.n	a8, a8, 1
4200e425:	628b      	addi.n	a6, a2, 8
4200e427:	0529e6        	bgei	a9, 2, 4200e430 <_vfprintf_r+0x2950>
4200e42a:	02e307        	bbsi	a3, 0, 4200e430 <_vfprintf_r+0x2950>
4200e42d:	004d06        	j	4200e565 <_vfprintf_r+0x2a85>
4200e430:	9f2192        	l32i	a9, a1, 0x27c
4200e433:	8f61a2        	s32i	a10, a1, 0x23c
4200e436:	0299      	s32i.n	a9, a2, 0
4200e438:	190c      	movi.n	a9, 1
4200e43a:	016292        	s32i	a9, a2, 4
4200e43d:	8e6182        	s32i	a8, a1, 0x238
4200e440:	10c152        	addi	a5, a1, 16
4200e443:	1988a6        	blti	a8, 8, 4200e460 <_vfprintf_r+0x2980>
4200e446:	24a2c2        	movi	a12, 0x224
4200e449:	a021b2        	l32i	a11, a1, 0x280
4200e44c:	a121a2        	l32i	a10, a1, 0x284
4200e44f:	80c5c0        	add	a12, a5, a12
4200e452:	201110        	or	a1, a1, a1
4200e455:	008425        	call8	4200ec98 <__sprint_r>
4200e458:	260a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e45b:	e4a162        	movi	a6, 0x1e4
4200e45e:	656a      	add.n	a6, a5, a6
4200e460:	b12182        	l32i	a8, a1, 0x2c4
4200e463:	10c152        	addi	a5, a1, 16
4200e466:	0689      	s32i.n	a8, a6, 0
4200e468:	ad2182        	l32i	a8, a1, 0x2b4
4200e46b:	ad21a2        	l32i	a10, a1, 0x2b4
4200e46e:	1689      	s32i.n	a8, a6, 4
4200e470:	8b2582        	l32i	a8, a5, 0x22c
4200e473:	88aa      	add.n	a8, a8, a10
4200e475:	8b6582        	s32i	a8, a5, 0x22c
4200e478:	8a2582        	l32i	a8, a5, 0x228
4200e47b:	881b      	addi.n	a8, a8, 1
4200e47d:	8a6582        	s32i	a8, a5, 0x228
4200e480:	0488e6        	bgei	a8, 8, 4200e488 <_vfprintf_r+0x29a8>
4200e483:	668b      	addi.n	a6, a6, 8
4200e485:	000606        	j	4200e4a1 <_vfprintf_r+0x29c1>
4200e488:	24a2c2        	movi	a12, 0x224
4200e48b:	a021b2        	l32i	a11, a1, 0x280
4200e48e:	a121a2        	l32i	a10, a1, 0x284
4200e491:	c5ca      	add.n	a12, a5, a12
4200e493:	201110        	or	a1, a1, a1
4200e496:	008025        	call8	4200ec98 <__sprint_r>
4200e499:	21fa56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e49c:	e4a162        	movi	a6, 0x1e4
4200e49f:	656a      	add.n	a6, a5, a6
4200e4a1:	a42182        	l32i	a8, a1, 0x290
4200e4a4:	0c0c      	movi.n	a12, 0
4200e4a6:	580b      	addi.n	a5, a8, -1
4200e4a8:	98a282        	movi	a8, 0x298
4200e4ab:	881a      	add.n	a8, a8, a1
4200e4ad:	08a8      	l32i.n	a10, a8, 0
4200e4af:	18b8      	l32i.n	a11, a8, 4
4200e4b1:	0d0c      	movi.n	a13, 0
4200e4b3:	ca1f81        	l32r	a8, 42000d30 <_stext+0xd10> (4000246c <__nedf2>)
4200e4b6:	0008e0        	callx8	a8
4200e4b9:	047a16        	beqz	a10, 4200e504 <_vfprintf_r+0x2a24>
4200e4bc:	9f21b2        	l32i	a11, a1, 0x27c
4200e4bf:	8f21c2        	l32i	a12, a1, 0x23c
4200e4c2:	bb1b      	addi.n	a11, a11, 1
4200e4c4:	8e2182        	l32i	a8, a1, 0x238
4200e4c7:	06b9      	s32i.n	a11, a6, 0
4200e4c9:	a421b2        	l32i	a11, a1, 0x290
4200e4cc:	cc0b      	addi.n	a12, a12, -1
4200e4ce:	881b      	addi.n	a8, a8, 1
4200e4d0:	ccba      	add.n	a12, a12, a11
4200e4d2:	1659      	s32i.n	a5, a6, 4
4200e4d4:	8f61c2        	s32i	a12, a1, 0x23c
4200e4d7:	8e6182        	s32i	a8, a1, 0x238
4200e4da:	10c1a2        	addi	a10, a1, 16
4200e4dd:	08c662        	addi	a6, a6, 8
4200e4e0:	0288e6        	bgei	a8, 8, 4200e4e6 <_vfprintf_r+0x2a06>
4200e4e3:	002646        	j	4200e580 <_vfprintf_r+0x2aa0>
4200e4e6:	24a2c2        	movi	a12, 0x224
4200e4e9:	80cac0        	add	a12, a10, a12
4200e4ec:	a021b2        	l32i	a11, a1, 0x280
4200e4ef:	a121a2        	l32i	a10, a1, 0x284
4200e4f2:	201110        	or	a1, a1, a1
4200e4f5:	007a25        	call8	4200ec98 <__sprint_r>
4200e4f8:	1c0a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e4fb:	f4a162        	movi	a6, 0x1f4
4200e4fe:	616a      	add.n	a6, a1, a6
4200e500:	001f06        	j	4200e580 <_vfprintf_r+0x2aa0>
4200e503:	218200        	srai	a8, a0, 2
4200e506:	28a6a4        	lsi	f10, a6, 160
4200e509:	c14275        	call12	41fcf930 <_coredump_iram_end+0x1c4da30>
4200e50c:	0a4610        	add.s	f4, f6, f1
4200e50f:	cbb200        	movf.s	f11, f2, b0
4200e512:	16d910        	lsi	f1, a9, 88
4200e515:	b9b9      	s32i.n	a11, a9, 44
4200e517:	a989      	s32i.n	a8, a9, 40
4200e519:	1888a6        	blti	a8, 8, 4200e535 <_vfprintf_r+0x2a55>
4200e51c:	24a2c2        	movi	a12, 0x224
4200e51f:	a021b2        	l32i	a11, a1, 0x280
4200e522:	a121a2        	l32i	a10, a1, 0x284
4200e525:	c4ca      	add.n	a12, a4, a12
4200e527:	201110        	or	a1, a1, a1
4200e52a:	0076e5        	call8	4200ec98 <__sprint_r>
4200e52d:	18ba56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e530:	e4a1a2        	movi	a10, 0x1e4
4200e533:	a4aa      	add.n	a10, a4, a10
4200e535:	f0c552        	addi	a5, a5, -16
4200e538:	0a6d      	mov.n	a6, a10
4200e53a:	c9f1c1        	l32r	a12, 42000d00 <_stext+0xce0> (3c02948c <zeroes$0>)
4200e53d:	8a2482        	l32i	a8, a4, 0x228
4200e540:	0d1c      	movi.n	a13, 16
4200e542:	06c9      	s32i.n	a12, a6, 0
4200e544:	02d492        	addmi	a9, a4, 0x200
4200e547:	881b      	addi.n	a8, a8, 1
4200e549:	a68b      	addi.n	a10, a6, 8
4200e54b:	b9b8      	l32i.n	a11, a9, 44
4200e54d:	bf2d57        	blt	a13, a5, 4200e510 <_vfprintf_r+0x2a30>
4200e550:	1659      	s32i.n	a5, a6, 4
4200e552:	55ba      	add.n	a5, a5, a11
4200e554:	24a2c2        	movi	a12, 0x224
4200e557:	b959      	s32i.n	a5, a9, 44
4200e559:	a989      	s32i.n	a8, a9, 40
4200e55b:	0a6d      	mov.n	a6, a10
4200e55d:	c4ca      	add.n	a12, a4, a12
4200e55f:	8988e6        	bgei	a8, 8, 4200e4ec <_vfprintf_r+0x2a0c>
4200e562:	000686        	j	4200e580 <_vfprintf_r+0x2aa0>
4200e565:	9f2192        	l32i	a9, a1, 0x27c
4200e568:	bea9      	s32i.n	a10, a14, 44
4200e56a:	0299      	s32i.n	a9, a2, 0
4200e56c:	190c      	movi.n	a9, 1
4200e56e:	1299      	s32i.n	a9, a2, 4
4200e570:	ae89      	s32i.n	a8, a14, 40
4200e572:	0a88a6        	blti	a8, 8, 4200e580 <_vfprintf_r+0x2aa0>
4200e575:	24a2c2        	movi	a12, 0x224
4200e578:	10c182        	addi	a8, a1, 16
4200e57b:	c8ca      	add.n	a12, a8, a12
4200e57d:	ffdac6        	j	4200e4ec <_vfprintf_r+0x2a0c>
4200e580:	10c122        	addi	a2, a1, 16
4200e583:	37a282        	movi	a8, 0x237
4200e586:	828a      	add.n	a8, a2, a8
4200e588:	0689      	s32i.n	a8, a6, 0
4200e58a:	b72182        	l32i	a8, a1, 0x2dc
4200e58d:	b721a2        	l32i	a10, a1, 0x2dc
4200e590:	1689      	s32i.n	a8, a6, 4
4200e592:	8b2282        	l32i	a8, a2, 0x22c
4200e595:	88aa      	add.n	a8, a8, a10
4200e597:	8b6282        	s32i	a8, a2, 0x22c
4200e59a:	8a2282        	l32i	a8, a2, 0x228
4200e59d:	881b      	addi.n	a8, a8, 1
4200e59f:	8a6282        	s32i	a8, a2, 0x228
4200e5a2:	0688e6        	bgei	a8, 8, 4200e5ac <_vfprintf_r+0x2acc>
4200e5a5:	268b      	addi.n	a2, a6, 8
4200e5a7:	000686        	j	4200e5c5 <_vfprintf_r+0x2ae5>
4200e5aa:	c20000        	quou	a0, a0, a0
4200e5ad:	b224a2        	l32i	a10, a4, 0x2c8
4200e5b0:	a2a021        	l32r	a2, 41ff7030 <_coredump_iram_end+0x1c75130>
4200e5b3:	caa121        	l32r	a2, 42001038 <_stext+0x1018> (40376cbc <xt_unhandled_interrupt>)
4200e5b6:	1110c2        	l16ui	a12, a0, 34
4200e5b9:	6de520        	lsi	f2, a5, 0x1b4
4200e5bc:	ba5600        	ceil.s	a5, f6, 0
4200e5bf:	0f          	.byte	0xf
4200e5c0:	e4a182        	movi	a8, 0x1e4
4200e5c3:	228a      	add.n	a2, a2, a8
4200e5c5:	1be327        	bbsi	a3, 2, 4200e5e4 <_vfprintf_r+0x2b04>
4200e5c8:	af2192        	l32i	a9, a1, 0x2bc
4200e5cb:	ac2182        	l32i	a8, a1, 0x2b0
4200e5ce:	538890        	max	a8, a8, a9
4200e5d1:	ae2192        	l32i	a9, a1, 0x2b8
4200e5d4:	898a      	add.n	a8, a9, a8
4200e5d6:	ae6182        	s32i	a8, a1, 0x2b8
4200e5d9:	8f2182        	l32i	a8, a1, 0x23c
4200e5dc:	076816        	beqz	a8, 4200e656 <_vfprintf_r+0x2b76>
4200e5df:	002046        	j	4200e664 <_vfprintf_r+0x2b84>
4200e5e2:	820000        	mull	a0, a0, a0
4200e5e5:	92ac21        	l32r	a2, 41ff3098 <_coredump_iram_end+0x1c71198>
4200e5e8:	90af21        	l32r	a2, 41ff28a4 <_coredump_iram_end+0x1c709a4>
4200e5eb:	c068      	l32i.n	a6, a0, 48
4200e5ed:	d716a6        	blti	a6, 1, 4200e5c8 <_vfprintf_r+0x2ae8>
4200e5f0:	10c152        	addi	a5, a1, 16
4200e5f3:	000a46        	j	4200e620 <_vfprintf_r+0x2b40>
4200e5f6:	10caa2        	addi	a10, a10, 16
4200e5f9:	12c9      	s32i.n	a12, a2, 4
4200e5fb:	b9a9      	s32i.n	a10, a9, 44
4200e5fd:	a989      	s32i.n	a8, a9, 40
4200e5ff:	228b      	addi.n	a2, a2, 8
4200e601:	1888a6        	blti	a8, 8, 4200e61d <_vfprintf_r+0x2b3d>
4200e604:	24a2c2        	movi	a12, 0x224
4200e607:	a021b2        	l32i	a11, a1, 0x280
4200e60a:	a121a2        	l32i	a10, a1, 0x284
4200e60d:	c5ca      	add.n	a12, a5, a12
4200e60f:	201110        	or	a1, a1, a1
4200e612:	006865        	call8	4200ec98 <__sprint_r>
4200e615:	0a3a56        	bnez	a10, 4200e6bc <_vfprintf_r+0x2bdc>
4200e618:	e4a182        	movi	a8, 0x1e4
4200e61b:	258a      	add.n	a2, a5, a8
4200e61d:	f0c662        	addi	a6, a6, -16
4200e620:	c9b7b1        	l32r	a11, 42000cfc <_stext+0xcdc> (3c02949c <blanks$1>)
4200e623:	8a2582        	l32i	a8, a5, 0x228
4200e626:	0c1c      	movi.n	a12, 16
4200e628:	02b9      	s32i.n	a11, a2, 0
4200e62a:	02d592        	addmi	a9, a5, 0x200
4200e62d:	881b      	addi.n	a8, a8, 1
4200e62f:	b9a8      	l32i.n	a10, a9, 44
4200e631:	c12c67        	blt	a12, a6, 4200e5f6 <_vfprintf_r+0x2b16>
4200e634:	1269      	s32i.n	a6, a2, 4
4200e636:	66aa      	add.n	a6, a6, a10
4200e638:	b969      	s32i.n	a6, a9, 44
4200e63a:	a989      	s32i.n	a8, a9, 40
4200e63c:	8888a6        	blti	a8, 8, 4200e5c8 <_vfprintf_r+0x2ae8>
4200e63f:	24a2c2        	movi	a12, 0x224
4200e642:	a021b2        	l32i	a11, a1, 0x280
4200e645:	a121a2        	l32i	a10, a1, 0x284
4200e648:	c5ca      	add.n	a12, a5, a12
4200e64a:	201110        	or	a1, a1, a1
4200e64d:	0064a5        	call8	4200ec98 <__sprint_r>
4200e650:	f74a16        	beqz	a10, 4200e5c8 <_vfprintf_r+0x2ae8>
4200e653:	001946        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200e656:	090c      	movi.n	a9, 0
4200e658:	a92182        	l32i	a8, a1, 0x2a4
4200e65b:	8e6192        	s32i	a9, a1, 0x238
4200e65e:	e8dc      	bnez.n	a8, 4200e680 <_vfprintf_r+0x2ba0>
4200e660:	f57186        	j	4200bc2a <_vfprintf_r+0x14a>
4200e663:	a2c200        	muluh	a12, a2, a0
4200e666:	c18224        	lsi	f2, a2, 0x304
4200e669:	21b210        	srai	a11, a1, 2
4200e66c:	21a2a0        	srai	a10, a10, 2
4200e66f:	c8caa1        	l32r	a10, 42000998 <_stext+0x978> (3c025478 <_flash_rodata_start+0x5358>)
4200e672:	201110        	or	a1, a1, a1
4200e675:	006225        	call8	4200ec98 <__sprint_r>
4200e678:	fdaa16        	beqz	a10, 4200e656 <_vfprintf_r+0x2b76>
4200e67b:	000f46        	j	4200e6bc <_vfprintf_r+0x2bdc>
4200e67e:	b20000        	mulsh	a0, a0, a0
4200e681:	a2a921        	l32r	a2, 41ff7128 <_coredump_iram_end+0x1c75228>
4200e684:	81a121        	l32r	a2, 41feed08 <_coredump_iram_end+0x1c6ce08>
4200e687:	e0c970        	subx4	a12, a9, a7
4200e68a:	0008      	l32i.n	a0, a0, 0
4200e68c:	f56686        	j	4200bc2a <_vfprintf_r+0x14a>
4200e68f:	218200        	srai	a8, a0, 2
4200e692:	8f          	.byte	0x8f
4200e693:	10c172        	addi	a7, a1, 16
4200e696:	a8cc      	bnez.n	a8, 4200e6a4 <_vfprintf_r+0x2bc4>
4200e698:	080c      	movi.n	a8, 0
4200e69a:	8a6782        	s32i	a8, a7, 0x228
4200e69d:	02d772        	addmi	a7, a7, 0x200
4200e6a0:	000a06        	j	4200e6cc <_vfprintf_r+0x2bec>
4200e6a3:	a2c200        	muluh	a12, a2, a0
4200e6a6:	21b224        	lsi	f2, a2, 132
4200e6a9:	21a2a0        	srai	a10, a10, 2
4200e6ac:	c7caa1        	l32r	a10, 420005d4 <_stext+0x5b4> (fffc7fff <_rtc_reserved_end+0x9fec7fff>)
4200e6af:	201110        	or	a1, a1, a1
4200e6b2:	005e65        	call8	4200ec98 <__sprint_r>
4200e6b5:	fdfa16        	beqz	a10, 4200e698 <_vfprintf_r+0x2bb8>
4200e6b8:	000406        	j	4200e6cc <_vfprintf_r+0x2bec>
4200e6bb:	218200        	srai	a8, a0, 2
4200e6be:	8ca9      	s32i.n	a10, a12, 32
4200e6c0:	a298      	l32i.n	a9, a2, 40
4200e6c2:	bda121        	l32r	a2, 41ffdd48 <_coredump_iram_end+0x1c7be48>
4200e6c5:	8108      	l32i.n	a0, a1, 32
4200e6c7:	e0c960        	subx4	a12, a9, a6
4200e6ca:	0008      	l32i.n	a0, a0, 0
4200e6cc:	a02182        	l32i	a8, a1, 0x280
4200e6cf:	192882        	l32i	a8, a8, 100
4200e6d2:	14e807        	bbsi	a8, 0, 4200e6ea <_vfprintf_r+0x2c0a>
4200e6d5:	a02182        	l32i	a8, a1, 0x280
4200e6d8:	061882        	l16ui	a8, a8, 12
4200e6db:	0be897        	bbsi	a8, 9, 4200e6ea <_vfprintf_r+0x2c0a>
4200e6de:	a02182        	l32i	a8, a1, 0x280
4200e6e1:	1628a2        	l32i	a10, a8, 88
4200e6e4:	c95881        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200e6e7:	0008e0        	callx8	a8
4200e6ea:	a02182        	l32i	a8, a1, 0x280
4200e6ed:	061882        	l16ui	a8, a8, 12
4200e6f0:	146867        	bbci	a8, 6, 4200e708 <_vfprintf_r+0x2c28>
4200e6f3:	f51c86        	j	4200bb69 <_vfprintf_r+0x89>
4200e6f6:	820000        	mull	a0, a0, a0
4200e6f9:	ada221        	l32r	a2, 41ff9d84 <_coredump_iram_end+0x1c77e84>
4200e6fc:	190c03        	lsi	f0, a12, 100
4200e6ff:	002896        	bltz	a8, 4200e705 <_vfprintf_r+0x2c25>
4200e702:	fcb1c6        	j	4200d9cd <_vfprintf_r+0x1eed>
4200e705:	fcccc6        	j	4200da3c <_vfprintf_r+0x1f5c>
4200e708:	ae2122        	l32i	a2, a1, 0x2b8
4200e70b:	f01d      	retw.n
4200e70d:	000000        	ill

4200e710 <vfprintf>:
4200e710:	006136        	entry	a1, 48
4200e713:	0149      	s32i.n	a4, a1, 0
4200e715:	1159      	s32i.n	a5, a1, 4
4200e717:	026162        	s32i	a6, a1, 8
4200e71a:	c80d81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4200e71d:	0008e0        	callx8	a8
4200e720:	01d8      	l32i.n	a13, a1, 0
4200e722:	11e8      	l32i.n	a14, a1, 4
4200e724:	21f8      	l32i.n	a15, a1, 8
4200e726:	02bd      	mov.n	a11, a2
4200e728:	03cd      	mov.n	a12, a3
4200e72a:	fd3b65        	call8	4200bae0 <_vfprintf_r>
4200e72d:	0a2d      	mov.n	a2, a10
4200e72f:	f01d      	retw.n
4200e731:	000000        	ill

4200e734 <__sbprintf>:
4200e734:	024136        	entry	a1, 0x120
4200e737:	078d      	mov.n	a8, a7
4200e739:	027d      	mov.n	a7, a2
4200e73b:	f0a022        	movi	a2, 240
4200e73e:	212a      	add.n	a2, a1, a2
4200e740:	2289      	s32i.n	a8, a2, 8
4200e742:	061382        	l16ui	a8, a3, 12
4200e745:	d97c      	movi.n	a9, -3
4200e747:	108890        	and	a8, a8, a9
4200e74a:	465182        	s16i	a8, a1, 140
4200e74d:	192382        	l32i	a8, a3, 100
4200e750:	1269      	s32i.n	a6, a2, 4
4200e752:	396182        	s32i	a8, a1, 228
4200e755:	071382        	l16ui	a8, a3, 14
4200e758:	80a062        	movi	a6, 128
4200e75b:	475182        	s16i	a8, a1, 142
4200e75e:	8388      	l32i.n	a8, a3, 32
4200e760:	226162        	s32i	a6, a1, 136
4200e763:	286182        	s32i	a8, a1, 160
4200e766:	a388      	l32i.n	a8, a3, 40
4200e768:	256162        	s32i	a6, a1, 148
4200e76b:	616a      	add.n	a6, a1, a6
4200e76d:	0259      	s32i.n	a5, a2, 0
4200e76f:	2a6182        	s32i	a8, a1, 168
4200e772:	58c6a2        	addi	a10, a6, 88
4200e775:	080c      	movi.n	a8, 0
4200e777:	266182        	s32i	a8, a1, 152
4200e77a:	206112        	s32i	a1, a1, 128
4200e77d:	246112        	s32i	a1, a1, 144
4200e780:	c93d81        	l32r	a8, 42000c74 <_stext+0xc54> (40376a90 <__retarget_lock_init_recursive>)
4200e783:	0008e0        	callx8	a8
4200e786:	02d8      	l32i.n	a13, a2, 0
4200e788:	12e8      	l32i.n	a14, a2, 4
4200e78a:	22f8      	l32i.n	a15, a2, 8
4200e78c:	04cd      	mov.n	a12, a4
4200e78e:	06bd      	mov.n	a11, a6
4200e790:	07ad      	mov.n	a10, a7
4200e792:	fd34e5        	call8	4200bae0 <_vfprintf_r>
4200e795:	0a2d      	mov.n	a2, a10
4200e797:	00ea96        	bltz	a10, 4200e7a9 <__sbprintf+0x75>
4200e79a:	06bd      	mov.n	a11, a6
4200e79c:	07ad      	mov.n	a10, a7
4200e79e:	201110        	or	a1, a1, a1
4200e7a1:	fc04a5        	call8	4200a7ec <_fflush_r>
4200e7a4:	f87c      	movi.n	a8, -1
4200e7a6:	9328a0        	movnez	a2, a8, a10
4200e7a9:	461182        	l16ui	a8, a1, 140
4200e7ac:	094c      	movi.n	a9, 64
4200e7ae:	080897        	bnone	a8, a9, 4200e7ba <__sbprintf+0x86>
4200e7b1:	061382        	l16ui	a8, a3, 12
4200e7b4:	208890        	or	a8, a8, a9
4200e7b7:	065382        	s16i	a8, a3, 12
4200e7ba:	3621a2        	l32i	a10, a1, 216
4200e7bd:	c92381        	l32r	a8, 42000c4c <_stext+0xc2c> (40376ab4 <__retarget_lock_close_recursive>)
4200e7c0:	0008e0        	callx8	a8
4200e7c3:	f01d      	retw.n
4200e7c5:	000000        	ill

4200e7c8 <get_arg$isra$0>:
4200e7c8:	008136        	entry	a1, 64
4200e7cb:	102182        	l32i	a8, a1, 64
4200e7ce:	1179      	s32i.n	a7, a1, 4
4200e7d0:	0878      	l32i.n	a7, a8, 0
4200e7d2:	2129      	s32i.n	a2, a1, 8
4200e7d4:	21e8      	l32i.n	a14, a1, 8
4200e7d6:	0528      	l32i.n	a2, a5, 0
4200e7d8:	4159      	s32i.n	a5, a1, 16
4200e7da:	0169      	s32i.n	a6, a1, 0
4200e7dc:	837370        	moveqz	a7, a3, a7
4200e7df:	00e306        	j	4200eb6f <get_arg$isra$0+0x3a7>
4200e7e2:	771b      	addi.n	a7, a7, 1
4200e7e4:	000782        	l8ui	a8, a7, 0
4200e7e7:	42f816        	beqz	a8, 4200ec1a <get_arg$isra$0+0x452>
4200e7ea:	dbc8a2        	addi	a10, a8, -37
4200e7ed:	ff1a56        	bnez	a10, 4200e7e2 <get_arg$isra$0+0x1a>
4200e7f0:	426816        	beqz	a8, 4200ec1a <get_arg$isra$0+0x452>
4200e7f3:	080c      	movi.n	a8, 0
4200e7f5:	a71b      	addi.n	a10, a7, 1
4200e7f7:	050c      	movi.n	a5, 0
4200e7f9:	0d0c      	movi.n	a13, 0
4200e7fb:	f37c      	movi.n	a3, -1
4200e7fd:	060c      	movi.n	a6, 0
4200e7ff:	3189      	s32i.n	a8, a1, 12
4200e801:	000046        	j	4200e806 <get_arg$isra$0+0x3e>
4200e804:	07ad      	mov.n	a10, a7
4200e806:	c92e91        	l32r	a9, 42000cc0 <_stext+0xca0> (3c029b24 <__chclass>)
4200e809:	000a82        	l8ui	a8, a10, 0
4200e80c:	7a1b      	addi.n	a7, a10, 1
4200e80e:	b98a      	add.n	a11, a9, a8
4200e810:	3198      	l32i.n	a9, a1, 12
4200e812:	000bc2        	l8ui	a12, a11, 0
4200e815:	c92bb1        	l32r	a11, 42000cc4 <_stext+0xca4> (3c029ab8 <__state_table>)
4200e818:	b0f990        	addx8	a15, a9, a9
4200e81b:	bbfa      	add.n	a11, a11, a15
4200e81d:	bbca      	add.n	a11, a11, a12
4200e81f:	000b92        	l8ui	a9, a11, 0
4200e822:	c929b1        	l32r	a11, 42000cc8 <_stext+0xca8> (3c029a4c <__action_table>)
4200e825:	3199      	s32i.n	a9, a1, 12
4200e827:	bbfa      	add.n	a11, a11, a15
4200e829:	bbca      	add.n	a11, a11, a12
4200e82b:	000bb2        	l8ui	a11, a11, 0
4200e82e:	bb0b      	addi.n	a11, a11, -1
4200e830:	74b0b0        	extui	a11, a11, 0, 8
4200e833:	028bb6        	bltui	a11, 8, 4200e839 <get_arg$isra$0+0x71>
4200e836:	00cac6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e839:	c940c1        	l32r	a12, 42000d3c <_stext+0xd1c> (3c0294ac <blanks$1+0x10>)
4200e83c:	a0bbc0        	addx4	a11, a11, a12
4200e83f:	0bb8      	l32i.n	a11, a11, 0
4200e841:	000ba0        	jx	a11
4200e844:	0c0000        	lsi	f0, a0, 48
4200e847:	069a      	add.n	a0, a6, a9
4200e849:	ad00c2        	l8ui	a12, a0, 173
4200e84c:	ac4607        	ball	a6, a0, 4200e7fc <get_arg$isra$0+0x34>
4200e84f:	a0b200        	addx4	a11, a2, a0
4200e852:	b76a      	add.n	a11, a7, a6
4200e854:	3318      	l32i.n	a1, a3, 12
4200e856:	0a3b87        	bltu	a11, a8, 4200e864 <get_arg$isra$0+0x9c>
4200e859:	cb4c      	movi.n	a11, 76
4200e85b:	2618b7        	beq	a8, a11, 4200e885 <get_arg$isra$0+0xbd>
4200e85e:	68a0b2        	movi	a11, 104
4200e861:	0005c6        	j	4200e87c <get_arg$isra$0+0xb4>
4200e864:	71a0b2        	movi	a11, 113
4200e867:	1f18b7        	beq	a8, a11, 4200e88a <get_arg$isra$0+0xc2>
4200e86a:	70a0b2        	movi	a11, 112
4200e86d:	23bb87        	bgeu	a11, a8, 4200e894 <get_arg$isra$0+0xcc>
4200e870:	74a0b2        	movi	a11, 116
4200e873:	0298b7        	bne	a8, a11, 4200e879 <get_arg$isra$0+0xb1>
4200e876:	00bac6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e879:	7aa0b2        	movi	a11, 122
4200e87c:	0298b7        	bne	a8, a11, 4200e882 <get_arg$isra$0+0xba>
4200e87f:	00b886        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e882:	000386        	j	4200e894 <get_arg$isra$0+0xcc>
4200e885:	880c      	movi.n	a8, 8
4200e887:	000046        	j	4200e88c <get_arg$isra$0+0xc4>
4200e88a:	082c      	movi.n	a8, 32
4200e88c:	206680        	or	a6, a6, a8
4200e88f:	00b486        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e892:	b20000        	mulsh	a0, a0, a0
4200e895:	010a      	add.n	a0, a1, a0
4200e897:	6ca082        	movi	a8, 108
4200e89a:	0a9b87        	bne	a11, a8, 4200e8a8 <get_arg$isra$0+0xe0>
4200e89d:	082c      	movi.n	a8, 32
4200e89f:	206680        	or	a6, a6, a8
4200e8a2:	7a2b      	addi.n	a7, a10, 2
4200e8a4:	00af46        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e8a7:	081c00        	lsx	f1, a12, a0
4200e8aa:	fff786        	j	4200e88c <get_arg$isra$0+0xc4>
4200e8ad:	61a0b2        	movi	a11, 97
4200e8b0:	44a020        	extui	a10, a2, 0, 5
4200e8b3:	0298b7        	bne	a8, a11, 4200e8b9 <get_arg$isra$0+0xf1>
4200e8b6:	00e506        	j	4200ec4e <get_arg$isra$0+0x486>
4200e8b9:	3b3b87        	bltu	a11, a8, 4200e8f8 <get_arg$isra$0+0x130>
4200e8bc:	bfc882        	addi	a8, a8, -65
4200e8bf:	748080        	extui	a8, a8, 0, 8
4200e8c2:	7b1c      	movi.n	a11, 23
4200e8c4:	24bb87        	bgeu	a11, a8, 4200e8ec <get_arg$isra$0+0x124>
4200e8c7:	001686        	j	4200e925 <get_arg$isra$0+0x15d>
4200e8ca:	180c      	movi.n	a8, 1
4200e8cc:	401b00        	ssl	a11
4200e8cf:	a18800        	sll	a8, a8
4200e8d2:	c8ffb1        	l32r	a11, 42000cd0 <_stext+0xcb0> (120821 <UserFrameTotalSize+0x120721>)
4200e8d5:	3388b7        	bany	a8, a11, 4200e90c <get_arg$isra$0+0x144>
4200e8d8:	5b2c      	movi.n	a11, 37
4200e8da:	11bb60        	slli	a11, a11, 10
4200e8dd:	0208b7        	bnone	a8, a11, 4200e8e3 <get_arg$isra$0+0x11b>
4200e8e0:	00dd46        	j	4200ec59 <get_arg$isra$0+0x491>
4200e8e3:	248180        	extui	a8, a8, 1, 3
4200e8e6:	364856        	bnez	a8, 4200ec4e <get_arg$isra$0+0x486>
4200e8e9:	000e06        	j	4200e925 <get_arg$isra$0+0x15d>
4200e8ec:	c915b1        	l32r	a11, 42000d40 <_stext+0xd20> (3c0294cc <blanks$1+0x30>)
4200e8ef:	a088b0        	addx4	a8, a8, a11
4200e8f2:	0888      	l32i.n	a8, a8, 0
4200e8f4:	0008a0        	jx	a8
4200e8f7:	a0b200        	addx4	a11, a2, a0
4200e8fa:	18b763        	lsi	f6, a7, 96
4200e8fd:	8219      	s32i.n	a1, a2, 32
4200e8ff:	9cc8      	l32i.n	a12, a12, 36
4200e901:	74b080        	extui	a11, a8, 0, 8
4200e904:	481c      	movi.n	a8, 20
4200e906:	c0b8b7        	bgeu	a8, a11, 4200e8ca <get_arg$isra$0+0x102>
4200e909:	000606        	j	4200e925 <get_arg$isra$0+0x15d>
4200e90c:	045560        	extui	a5, a6, 5, 1
4200e90f:	555a      	add.n	a5, a5, a5
4200e911:	106647        	bbci	a6, 4, 4200e925 <get_arg$isra$0+0x15d>
4200e914:	00d806        	j	4200ec78 <get_arg$isra$0+0x4b0>
4200e917:	051c00        	extui	a1, a0, 28, 1
4200e91a:	105650        	and	a5, a6, a5
4200e91d:	34c556        	bnez	a5, 4200ec6d <get_arg$isra$0+0x4a5>
4200e920:	00d006        	j	4200ec64 <get_arg$isra$0+0x49c>
4200e923:	260000        	lsi	f0, a0, 152
4200e926:	880b03        	lsi	f0, a11, 0x220
4200e929:	0a2d11        	l32r	a1, 41fd11e0 <_coredump_iram_end+0x1c4f2e0>
4200e92c:	a08380        	addx4	a8, a3, a8
4200e92f:	0859      	s32i.n	a5, a8, 0
4200e931:	008c06        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e934:	b50b      	addi.n	a11, a5, -1
4200e936:	2488      	l32i.n	a8, a4, 8
4200e938:	2a1b      	addi.n	a2, a10, 1
4200e93a:	026bb6        	bltui	a11, 6, 4200e940 <get_arg$isra$0+0x178>
4200e93d:	002806        	j	4200e9e1 <get_arg$isra$0+0x219>
4200e940:	c901c1        	l32r	a12, 42000d44 <_stext+0xd24> (3c02952c <blanks$1+0x90>)
4200e943:	a0bbc0        	addx4	a11, a11, a12
4200e946:	0bc8      	l32i.n	a12, a11, 0
4200e948:	f4b0a0        	extui	a11, a10, 0, 16
4200e94b:	000ca0        	jx	a12
4200e94e:	0188      	l32i.n	a8, a1, 0
4200e950:	24b8      	l32i.n	a11, a4, 8
4200e952:	2a1b      	addi.n	a2, a10, 1
4200e954:	b0aa80        	addx8	a10, a10, a8
4200e957:	8b4b      	addi.n	a8, a11, 4
4200e959:	2489      	s32i.n	a8, a4, 8
4200e95b:	8c1c      	movi.n	a12, 24
4200e95d:	042c87        	blt	a12, a8, 4200e965 <get_arg$isra$0+0x19d>
4200e960:	14b8      	l32i.n	a11, a4, 4
4200e962:	000206        	j	4200e96e <get_arg$isra$0+0x1a6>
4200e965:	012cb7        	blt	a12, a11, 4200e96a <get_arg$isra$0+0x1a2>
4200e968:	482c      	movi.n	a8, 36
4200e96a:	04b8      	l32i.n	a11, a4, 0
4200e96c:	2489      	s32i.n	a8, a4, 8
4200e96e:	bb8a      	add.n	a11, a11, a8
4200e970:	fccbb2        	addi	a11, a11, -4
4200e973:	0b88      	l32i.n	a8, a11, 0
4200e975:	f37c      	movi.n	a3, -1
4200e977:	0a89      	s32i.n	a8, a10, 0
4200e979:	150c      	movi.n	a5, 1
4200e97b:	007986        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e97e:	8a7c      	movi.n	a10, -8
4200e980:	887b      	addi.n	a8, a8, 7
4200e982:	1088a0        	and	a8, a8, a10
4200e985:	0198      	l32i.n	a9, a1, 0
4200e987:	a88b      	addi.n	a10, a8, 8
4200e989:	24a9      	s32i.n	a10, a4, 8
4200e98b:	8c1c      	movi.n	a12, 24
4200e98d:	b0bb90        	addx8	a11, a11, a9
4200e990:	042ca7        	blt	a12, a10, 4200e998 <get_arg$isra$0+0x1d0>
4200e993:	1488      	l32i.n	a8, a4, 4
4200e995:	000206        	j	4200e9a1 <get_arg$isra$0+0x1d9>
4200e998:	012c87        	blt	a12, a8, 4200e99d <get_arg$isra$0+0x1d5>
4200e99b:	8a2c      	movi.n	a10, 40
4200e99d:	0488      	l32i.n	a8, a4, 0
4200e99f:	24a9      	s32i.n	a10, a4, 8
4200e9a1:	88aa      	add.n	a8, a8, a10
4200e9a3:	f8c882        	addi	a8, a8, -8
4200e9a6:	1898      	l32i.n	a9, a8, 4
4200e9a8:	0888      	l32i.n	a8, a8, 0
4200e9aa:	1b99      	s32i.n	a9, a11, 4
4200e9ac:	0b89      	s32i.n	a8, a11, 0
4200e9ae:	006cc6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e9b1:	0188      	l32i.n	a8, a1, 0
4200e9b3:	24b8      	l32i.n	a11, a4, 8
4200e9b5:	2a1b      	addi.n	a2, a10, 1
4200e9b7:	b0aa80        	addx8	a10, a10, a8
4200e9ba:	8b4b      	addi.n	a8, a11, 4
4200e9bc:	2489      	s32i.n	a8, a4, 8
4200e9be:	8c1c      	movi.n	a12, 24
4200e9c0:	042c87        	blt	a12, a8, 4200e9c8 <get_arg$isra$0+0x200>
4200e9c3:	14b8      	l32i.n	a11, a4, 4
4200e9c5:	000206        	j	4200e9d1 <get_arg$isra$0+0x209>
4200e9c8:	012cb7        	blt	a12, a11, 4200e9cd <get_arg$isra$0+0x205>
4200e9cb:	482c      	movi.n	a8, 36
4200e9cd:	04b8      	l32i.n	a11, a4, 0
4200e9cf:	2489      	s32i.n	a8, a4, 8
4200e9d1:	bb8a      	add.n	a11, a11, a8
4200e9d3:	fccbb2        	addi	a11, a11, -4
4200e9d6:	0b88      	l32i.n	a8, a11, 0
4200e9d8:	f37c      	movi.n	a3, -1
4200e9da:	0a89      	s32i.n	a8, a10, 0
4200e9dc:	650c      	movi.n	a5, 6
4200e9de:	0060c6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200e9e1:	0188      	l32i.n	a8, a1, 0
4200e9e3:	24b8      	l32i.n	a11, a4, 8
4200e9e5:	2a1b      	addi.n	a2, a10, 1
4200e9e7:	b0aa80        	addx8	a10, a10, a8
4200e9ea:	8b4b      	addi.n	a8, a11, 4
4200e9ec:	2489      	s32i.n	a8, a4, 8
4200e9ee:	8c1c      	movi.n	a12, 24
4200e9f0:	042c87        	blt	a12, a8, 4200e9f8 <get_arg$isra$0+0x230>
4200e9f3:	14b8      	l32i.n	a11, a4, 4
4200e9f5:	000206        	j	4200ea01 <get_arg$isra$0+0x239>
4200e9f8:	012cb7        	blt	a12, a11, 4200e9fd <get_arg$isra$0+0x235>
4200e9fb:	482c      	movi.n	a8, 36
4200e9fd:	04b8      	l32i.n	a11, a4, 0
4200e9ff:	2489      	s32i.n	a8, a4, 8
4200ea01:	bb8a      	add.n	a11, a11, a8
4200ea03:	fccbb2        	addi	a11, a11, -4
4200ea06:	0b88      	l32i.n	a8, a11, 0
4200ea08:	f37c      	movi.n	a3, -1
4200ea0a:	0a89      	s32i.n	a8, a10, 0
4200ea0c:	050c      	movi.n	a5, 0
4200ea0e:	0054c6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200ea11:	0188      	l32i.n	a8, a1, 0
4200ea13:	24b8      	l32i.n	a11, a4, 8
4200ea15:	2a1b      	addi.n	a2, a10, 1
4200ea17:	b0aa80        	addx8	a10, a10, a8
4200ea1a:	8b4b      	addi.n	a8, a11, 4
4200ea1c:	2489      	s32i.n	a8, a4, 8
4200ea1e:	8c1c      	movi.n	a12, 24
4200ea20:	042c87        	blt	a12, a8, 4200ea28 <get_arg$isra$0+0x260>
4200ea23:	14b8      	l32i.n	a11, a4, 4
4200ea25:	000206        	j	4200ea31 <get_arg$isra$0+0x269>
4200ea28:	012cb7        	blt	a12, a11, 4200ea2d <get_arg$isra$0+0x265>
4200ea2b:	482c      	movi.n	a8, 36
4200ea2d:	04b8      	l32i.n	a11, a4, 0
4200ea2f:	2489      	s32i.n	a8, a4, 8
4200ea31:	bb8a      	add.n	a11, a11, a8
4200ea33:	fccbb2        	addi	a11, a11, -4
4200ea36:	0b88      	l32i.n	a8, a11, 0
4200ea38:	f37c      	movi.n	a3, -1
4200ea3a:	0a89      	s32i.n	a8, a10, 0
4200ea3c:	350c      	movi.n	a5, 3
4200ea3e:	0048c6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200ea41:	0188      	l32i.n	a8, a1, 0
4200ea43:	2a1b      	addi.n	a2, a10, 1
4200ea45:	b0aa80        	addx8	a10, a10, a8
4200ea48:	2488      	l32i.n	a8, a4, 8
4200ea4a:	8b7c      	movi.n	a11, -8
4200ea4c:	887b      	addi.n	a8, a8, 7
4200ea4e:	1088b0        	and	a8, a8, a11
4200ea51:	b88b      	addi.n	a11, a8, 8
4200ea53:	24b9      	s32i.n	a11, a4, 8
4200ea55:	8c1c      	movi.n	a12, 24
4200ea57:	052cb7        	blt	a12, a11, 4200ea60 <get_arg$isra$0+0x298>
4200ea5a:	1488      	l32i.n	a8, a4, 4
4200ea5c:	000246        	j	4200ea69 <get_arg$isra$0+0x2a1>
4200ea5f:	2c8700        	lsi	f0, a7, 176
4200ea62:	8b2c01        	l32r	a0, 41ff1714 <_coredump_iram_end+0x1c6f814>
4200ea65:	0488      	l32i.n	a8, a4, 0
4200ea67:	24b9      	s32i.n	a11, a4, 8
4200ea69:	88ba      	add.n	a8, a8, a11
4200ea6b:	f8c882        	addi	a8, a8, -8
4200ea6e:	1898      	l32i.n	a9, a8, 4
4200ea70:	0888      	l32i.n	a8, a8, 0
4200ea72:	f37c      	movi.n	a3, -1
4200ea74:	0a89      	s32i.n	a8, a10, 0
4200ea76:	1a99      	s32i.n	a9, a10, 4
4200ea78:	450c      	movi.n	a5, 4
4200ea7a:	0039c6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200ea7d:	8a7c      	movi.n	a10, -8
4200ea7f:	887b      	addi.n	a8, a8, 7
4200ea81:	1088a0        	and	a8, a8, a10
4200ea84:	0198      	l32i.n	a9, a1, 0
4200ea86:	a88b      	addi.n	a10, a8, 8
4200ea88:	24a9      	s32i.n	a10, a4, 8
4200ea8a:	8c1c      	movi.n	a12, 24
4200ea8c:	b0bb90        	addx8	a11, a11, a9
4200ea8f:	052ca7        	blt	a12, a10, 4200ea98 <get_arg$isra$0+0x2d0>
4200ea92:	1488      	l32i.n	a8, a4, 4
4200ea94:	000246        	j	4200eaa1 <get_arg$isra$0+0x2d9>
4200ea97:	2c8700        	lsi	f0, a7, 176
4200ea9a:	8a2c01        	l32r	a0, 41ff134c <_coredump_iram_end+0x1c6f44c>
4200ea9d:	0488      	l32i.n	a8, a4, 0
4200ea9f:	24a9      	s32i.n	a10, a4, 8
4200eaa1:	88aa      	add.n	a8, a8, a10
4200eaa3:	f8c882        	addi	a8, a8, -8
4200eaa6:	1898      	l32i.n	a9, a8, 4
4200eaa8:	0888      	l32i.n	a8, a8, 0
4200eaaa:	1b99      	s32i.n	a9, a11, 4
4200eaac:	0b89      	s32i.n	a8, a11, 0
4200eaae:	002cc6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200eab1:	1188      	l32i.n	a8, a1, 4
4200eab3:	0888      	l32i.n	a8, a8, 0
4200eab5:	140866        	bnei	a8, -1, 4200eacd <get_arg$isra$0+0x305>
4200eab8:	11a8      	l32i.n	a10, a1, 4
4200eaba:	80a0c2        	movi	a12, 128
4200eabd:	0b0c      	movi.n	a11, 0
4200eabf:	61d9      	s32i.n	a13, a1, 24
4200eac1:	51e9      	s32i.n	a14, a1, 20
4200eac3:	c60f81        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200eac6:	0008e0        	callx8	a8
4200eac9:	61d8      	l32i.n	a13, a1, 24
4200eacb:	51e8      	l32i.n	a14, a1, 20
4200eacd:	3d0b      	addi.n	a3, a13, -1
4200eacf:	53ee30        	max	a14, a14, a3
4200ead2:	0023c6        	j	4200eb65 <get_arg$isra$0+0x39d>
4200ead5:	1188      	l32i.n	a8, a1, 4
4200ead7:	0888      	l32i.n	a8, a8, 0
4200ead9:	140866        	bnei	a8, -1, 4200eaf1 <get_arg$isra$0+0x329>
4200eadc:	11a8      	l32i.n	a10, a1, 4
4200eade:	80a0c2        	movi	a12, 128
4200eae1:	0b0c      	movi.n	a11, 0
4200eae3:	61d9      	s32i.n	a13, a1, 24
4200eae5:	51e9      	s32i.n	a14, a1, 20
4200eae7:	c60681        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4200eaea:	0008e0        	callx8	a8
4200eaed:	61d8      	l32i.n	a13, a1, 24
4200eaef:	51e8      	l32i.n	a14, a1, 20
4200eaf1:	1188      	l32i.n	a8, a1, 4
4200eaf3:	dd0b      	addi.n	a13, a13, -1
4200eaf5:	a08d80        	addx4	a8, a13, a8
4200eaf8:	0a0c      	movi.n	a10, 0
4200eafa:	08a9      	s32i.n	a10, a8, 0
4200eafc:	53eed0        	max	a14, a14, a13
4200eaff:	001886        	j	4200eb65 <get_arg$isra$0+0x39d>
4200eb02:	0188      	l32i.n	a8, a1, 0
4200eb04:	24b8      	l32i.n	a11, a4, 8
4200eb06:	f21b      	addi.n	a15, a2, 1
4200eb08:	b02280        	addx8	a2, a2, a8
4200eb0b:	8b4b      	addi.n	a8, a11, 4
4200eb0d:	2489      	s32i.n	a8, a4, 8
4200eb0f:	8c1c      	movi.n	a12, 24
4200eb11:	042c87        	blt	a12, a8, 4200eb19 <get_arg$isra$0+0x351>
4200eb14:	14b8      	l32i.n	a11, a4, 4
4200eb16:	000206        	j	4200eb22 <get_arg$isra$0+0x35a>
4200eb19:	012cb7        	blt	a12, a11, 4200eb1e <get_arg$isra$0+0x356>
4200eb1c:	482c      	movi.n	a8, 36
4200eb1e:	04b8      	l32i.n	a11, a4, 0
4200eb20:	2489      	s32i.n	a8, a4, 8
4200eb22:	bb8a      	add.n	a11, a11, a8
4200eb24:	fccbb2        	addi	a11, a11, -4
4200eb27:	0b88      	l32i.n	a8, a11, 0
4200eb29:	0a7d      	mov.n	a7, a10
4200eb2b:	0289      	s32i.n	a8, a2, 0
4200eb2d:	0f2d      	mov.n	a2, a15
4200eb2f:	000c86        	j	4200eb65 <get_arg$isra$0+0x39d>
4200eb32:	d20000        	quos	a0, a0, a0
4200eb35:	d0c8      	l32i.n	a12, a0, 52
4200eb37:	9a0c      	movi.n	a10, 9
4200eb39:	0001c6        	j	4200eb44 <get_arg$isra$0+0x37c>
4200eb3c:	a0ddd0        	addx4	a13, a13, a13
4200eb3f:	90dd80        	addx2	a13, a13, a8
4200eb42:	771b      	addi.n	a7, a7, 1
4200eb44:	000782        	l8ui	a8, a7, 0
4200eb47:	a89c      	beqz.n	a8, 4200eb65 <get_arg$isra$0+0x39d>
4200eb49:	d0c882        	addi	a8, a8, -48
4200eb4c:	ecba87        	bgeu	a10, a8, 4200eb3c <get_arg$isra$0+0x374>
4200eb4f:	000486        	j	4200eb65 <get_arg$isra$0+0x39d>
4200eb52:	820000        	mull	a0, a0, a0
4200eb55:	820007        	bnone	a0, a0, 4200eadb <get_arg$isra$0+0x313>
4200eb58:	d0c8      	l32i.n	a12, a0, 52
4200eb5a:	748080        	extui	a8, a8, 0, 8
4200eb5d:	043a87        	bltu	a10, a8, 4200eb65 <get_arg$isra$0+0x39d>
4200eb60:	771b      	addi.n	a7, a7, 1
4200eb62:	fffb86        	j	4200eb54 <get_arg$isra$0+0x38c>
4200eb65:	3198      	l32i.n	a9, a1, 12
4200eb67:	b80c      	movi.n	a8, 11
4200eb69:	021987        	beq	a9, a8, 4200eb6f <get_arg$isra$0+0x3a7>
4200eb6c:	ff2506        	j	4200e804 <get_arg$isra$0+0x3c>
4200eb6f:	0007a2        	l8ui	a10, a7, 0
4200eb72:	ea8c      	beqz.n	a10, 4200eb84 <get_arg$isra$0+0x3bc>
4200eb74:	2188      	l32i.n	a8, a1, 8
4200eb76:	728820        	lsi	f2, a8, 0x1c8
4200eb79:	880b      	addi.n	a8, a8, -1
4200eb7b:	608080        	neg	a8, a8
4200eb7e:	748080        	extui	a8, a8, 0, 8
4200eb81:	c5f856        	bnez	a8, 4200e7e4 <get_arg$isra$0+0x1c>
4200eb84:	2188      	l32i.n	a8, a1, 8
4200eb86:	93e8a0        	movnez	a14, a8, a10
4200eb89:	002346        	j	4200ec1a <get_arg$isra$0+0x452>
4200eb8c:	1188      	l32i.n	a8, a1, 4
4200eb8e:	a08d80        	addx4	a8, a13, a8
4200eb91:	08c8      	l32i.n	a12, a8, 0
4200eb93:	dd1b      	addi.n	a13, a13, 1
4200eb95:	cc0b      	addi.n	a12, a12, -1
4200eb97:	2488      	l32i.n	a8, a4, 8
4200eb99:	5c6cf6        	bgeui	a12, 6, 4200ebf9 <get_arg$isra$0+0x431>
4200eb9c:	a0cc60        	addx4	a12, a12, a6
4200eb9f:	0cc8      	l32i.n	a12, a12, 0
4200eba1:	000ca0        	jx	a12
4200eba4:	887b      	addi.n	a8, a8, 7
4200eba6:	1088f0        	and	a8, a8, a15
4200eba9:	c88b      	addi.n	a12, a8, 8
4200ebab:	24c9      	s32i.n	a12, a4, 8
4200ebad:	042ac7        	blt	a10, a12, 4200ebb5 <get_arg$isra$0+0x3ed>
4200ebb0:	1488      	l32i.n	a8, a4, 4
4200ebb2:	000206        	j	4200ebbe <get_arg$isra$0+0x3f6>
4200ebb5:	012a87        	blt	a10, a8, 4200ebba <get_arg$isra$0+0x3f2>
4200ebb8:	8c2c      	movi.n	a12, 40
4200ebba:	0488      	l32i.n	a8, a4, 0
4200ebbc:	24c9      	s32i.n	a12, a4, 8
4200ebbe:	88ca      	add.n	a8, a8, a12
4200ebc0:	f8c882        	addi	a8, a8, -8
4200ebc3:	1898      	l32i.n	a9, a8, 4
4200ebc5:	0888      	l32i.n	a8, a8, 0
4200ebc7:	1b99      	s32i.n	a9, a11, 4
4200ebc9:	0b89      	s32i.n	a8, a11, 0
4200ebcb:	001706        	j	4200ec2b <get_arg$isra$0+0x463>
4200ebce:	887b      	addi.n	a8, a8, 7
4200ebd0:	1088f0        	and	a8, a8, a15
4200ebd3:	c88b      	addi.n	a12, a8, 8
4200ebd5:	24c9      	s32i.n	a12, a4, 8
4200ebd7:	052ac7        	blt	a10, a12, 4200ebe0 <get_arg$isra$0+0x418>
4200ebda:	1488      	l32i.n	a8, a4, 4
4200ebdc:	000246        	j	4200ebe9 <get_arg$isra$0+0x421>
4200ebdf:	2a8700        	mul.s	f8, f7, f0
4200ebe2:	8c2c01        	l32r	a0, 41ff1c94 <_coredump_iram_end+0x1c6fd94>
4200ebe5:	0488      	l32i.n	a8, a4, 0
4200ebe7:	24c9      	s32i.n	a12, a4, 8
4200ebe9:	88ca      	add.n	a8, a8, a12
4200ebeb:	f8c882        	addi	a8, a8, -8
4200ebee:	1898      	l32i.n	a9, a8, 4
4200ebf0:	0888      	l32i.n	a8, a8, 0
4200ebf2:	1b99      	s32i.n	a9, a11, 4
4200ebf4:	0b89      	s32i.n	a8, a11, 0
4200ebf6:	000c46        	j	4200ec2b <get_arg$isra$0+0x463>
4200ebf9:	c84b      	addi.n	a12, a8, 4
4200ebfb:	24c9      	s32i.n	a12, a4, 8
4200ebfd:	042ac7        	blt	a10, a12, 4200ec05 <get_arg$isra$0+0x43d>
4200ec00:	1488      	l32i.n	a8, a4, 4
4200ec02:	000206        	j	4200ec0e <get_arg$isra$0+0x446>
4200ec05:	012a87        	blt	a10, a8, 4200ec0a <get_arg$isra$0+0x442>
4200ec08:	4c2c      	movi.n	a12, 36
4200ec0a:	0488      	l32i.n	a8, a4, 0
4200ec0c:	24c9      	s32i.n	a12, a4, 8
4200ec0e:	88ca      	add.n	a8, a8, a12
4200ec10:	fcc882        	addi	a8, a8, -4
4200ec13:	0888      	l32i.n	a8, a8, 0
4200ec15:	0b89      	s32i.n	a8, a11, 0
4200ec17:	000406        	j	4200ec2b <get_arg$isra$0+0x463>
4200ec1a:	0188      	l32i.n	a8, a1, 0
4200ec1c:	c84b61        	l32r	a6, 42000d48 <_stext+0xd28> (3c029544 <blanks$1+0xa8>)
4200ec1f:	b0b280        	addx8	a11, a2, a8
4200ec22:	02dd      	mov.n	a13, a2
4200ec24:	8a1c      	movi.n	a10, 24
4200ec26:	8f7c      	movi.n	a15, -8
4200ec28:	000046        	j	4200ec2d <get_arg$isra$0+0x465>
4200ec2b:	bb8b      	addi.n	a11, a11, 8
4200ec2d:	022ed7        	blt	a14, a13, 4200ec33 <get_arg$isra$0+0x46b>
4200ec30:	ffd606        	j	4200eb8c <get_arg$isra$0+0x3c4>
4200ec33:	8e1b      	addi.n	a8, a14, 1
4200ec35:	728820        	lsi	f2, a8, 0x1c8
4200ec38:	880b      	addi.n	a8, a8, -1
4200ec3a:	608080        	neg	a8, a8
4200ec3d:	748080        	extui	a8, a8, 0, 8
4200ec40:	0a0c      	movi.n	a10, 0
4200ec42:	d8bc      	beqz.n	a8, 4200ec83 <get_arg$isra$0+0x4bb>
4200ec44:	820b      	addi.n	a8, a2, -1
4200ec46:	608080        	neg	a8, a8
4200ec49:	a8ea      	add.n	a10, a8, a14
4200ec4b:	000d06        	j	4200ec83 <get_arg$isra$0+0x4bb>
4200ec4e:	450c      	movi.n	a5, 4
4200ec50:	020326        	beqi	a3, -1, 4200ec56 <get_arg$isra$0+0x48e>
4200ec53:	ff3446        	j	4200e928 <get_arg$isra$0+0x160>
4200ec56:	ff79c6        	j	4200ea41 <get_arg$isra$0+0x279>
4200ec59:	350c      	movi.n	a5, 3
4200ec5b:	020326        	beqi	a3, -1, 4200ec61 <get_arg$isra$0+0x499>
4200ec5e:	ff3186        	j	4200e928 <get_arg$isra$0+0x160>
4200ec61:	ff6b06        	j	4200ea11 <get_arg$isra$0+0x249>
4200ec64:	020326        	beqi	a3, -1, 4200ec6a <get_arg$isra$0+0x4a2>
4200ec67:	ff2f46        	j	4200e928 <get_arg$isra$0+0x160>
4200ec6a:	ff5cc6        	j	4200e9e1 <get_arg$isra$0+0x219>
4200ec6d:	650c      	movi.n	a5, 6
4200ec6f:	020326        	beqi	a3, -1, 4200ec75 <get_arg$isra$0+0x4ad>
4200ec72:	ff2c86        	j	4200e928 <get_arg$isra$0+0x160>
4200ec75:	ff4e06        	j	4200e9b1 <get_arg$isra$0+0x1e9>
4200ec78:	150c      	movi.n	a5, 1
4200ec7a:	020326        	beqi	a3, -1, 4200ec80 <get_arg$isra$0+0x4b8>
4200ec7d:	ff29c6        	j	4200e928 <get_arg$isra$0+0x160>
4200ec80:	ff3286        	j	4200e94e <get_arg$isra$0+0x186>
4200ec83:	4198      	l32i.n	a9, a1, 16
4200ec85:	8a2a      	add.n	a8, a10, a2
4200ec87:	0989      	s32i.n	a8, a9, 0
4200ec89:	102182        	l32i	a8, a1, 64
4200ec8c:	0198      	l32i.n	a9, a1, 0
4200ec8e:	0879      	s32i.n	a7, a8, 0
4200ec90:	2188      	l32i.n	a8, a1, 8
4200ec92:	b02890        	addx8	a2, a8, a9
4200ec95:	f01d      	retw.n
	...

4200ec98 <__sprint_r>:
4200ec98:	004136        	entry	a1, 32
4200ec9b:	2488      	l32i.n	a8, a4, 8
4200ec9d:	02ad      	mov.n	a10, a2
4200ec9f:	03bd      	mov.n	a11, a3
4200eca1:	020c      	movi.n	a2, 0
4200eca3:	d88c      	beqz.n	a8, 4200ecb4 <__sprint_r+0x1c>
4200eca5:	20c440        	or	a12, a4, a4
4200eca8:	201110        	or	a1, a1, a1
4200ecab:	fbefa5        	call8	4200aba4 <__sfvwrite_r>
4200ecae:	080c      	movi.n	a8, 0
4200ecb0:	0a2d      	mov.n	a2, a10
4200ecb2:	2489      	s32i.n	a8, a4, 8
4200ecb4:	080c      	movi.n	a8, 0
4200ecb6:	1489      	s32i.n	a8, a4, 4
4200ecb8:	f01d      	retw.n
	...

4200ecbc <_vfiprintf_r>:
4200ecbc:	058136        	entry	a1, 0x2c0
4200ecbf:	996142        	s32i	a4, a1, 0x264
4200ecc2:	9b6122        	s32i	a2, a1, 0x26c
4200ecc5:	986132        	s32i	a3, a1, 0x260
4200ecc8:	946152        	s32i	a5, a1, 0x250
4200eccb:	956162        	s32i	a6, a1, 0x254
4200ecce:	966172        	s32i	a7, a1, 0x258
4200ecd1:	10c142        	addi	a4, a1, 16
4200ecd4:	c28c      	beqz.n	a2, 4200ece4 <_vfiprintf_r+0x28>
4200ecd6:	0a2282        	l32i	a8, a2, 40
4200ecd9:	007856        	bnez	a8, 4200ece4 <_vfiprintf_r+0x28>
4200ecdc:	02ad      	mov.n	a10, a2
4200ecde:	201110        	or	a1, a1, a1
4200ece1:	fbd725        	call8	4200aa54 <__sinit>
4200ece4:	982182        	l32i	a8, a1, 0x260
4200ece7:	192882        	l32i	a8, a8, 100
4200ecea:	14e807        	bbsi	a8, 0, 4200ed02 <_vfiprintf_r+0x46>
4200eced:	982182        	l32i	a8, a1, 0x260
4200ecf0:	061882        	l16ui	a8, a8, 12
4200ecf3:	0be897        	bbsi	a8, 9, 4200ed02 <_vfiprintf_r+0x46>
4200ecf6:	982182        	l32i	a8, a1, 0x260
4200ecf9:	1628a2        	l32i	a10, a8, 88
4200ecfc:	c7d181        	l32r	a8, 42000c40 <_stext+0xc20> (40376ae4 <__retarget_lock_acquire_recursive>)
4200ecff:	0008e0        	callx8	a8
4200ed02:	982182        	l32i	a8, a1, 0x260
4200ed05:	061882        	l16ui	a8, a8, 12
4200ed08:	066837        	bbci	a8, 3, 4200ed12 <_vfiprintf_r+0x56>
4200ed0b:	982182        	l32i	a8, a1, 0x260
4200ed0e:	4888      	l32i.n	a8, a8, 16
4200ed10:	58fc      	bnez.n	a8, 4200ed49 <_vfiprintf_r+0x8d>
4200ed12:	9821b2        	l32i	a11, a1, 0x260
4200ed15:	9b21a2        	l32i	a10, a1, 0x26c
4200ed18:	201110        	or	a1, a1, a1
4200ed1b:	fc3265        	call8	4200b040 <__swsetup_r>
4200ed1e:	7aac      	beqz.n	a10, 4200ed49 <_vfiprintf_r+0x8d>
4200ed20:	982182        	l32i	a8, a1, 0x260
4200ed23:	192882        	l32i	a8, a8, 100
4200ed26:	076807        	bbci	a8, 0, 4200ed31 <_vfiprintf_r+0x75>
4200ed29:	f87c      	movi.n	a8, -1
4200ed2b:	9d6182        	s32i	a8, a1, 0x274
4200ed2e:	06f986        	j	42010918 <_vfiprintf_r+0x1c5c>
4200ed31:	982182        	l32i	a8, a1, 0x260
4200ed34:	061882        	l16ui	a8, a8, 12
4200ed37:	eee897        	bbsi	a8, 9, 4200ed29 <_vfiprintf_r+0x6d>
4200ed3a:	982182        	l32i	a8, a1, 0x260
4200ed3d:	1628a2        	l32i	a10, a8, 88
4200ed40:	c7c181        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200ed43:	0008e0        	callx8	a8
4200ed46:	fff7c6        	j	4200ed29 <_vfiprintf_r+0x6d>
4200ed49:	982182        	l32i	a8, a1, 0x260
4200ed4c:	069892        	l16si	a9, a8, 12
4200ed4f:	1aa082        	movi	a8, 26
4200ed52:	108980        	and	a8, a9, a8
4200ed55:	439866        	bnei	a8, 10, 4200ed9c <_vfiprintf_r+0xe0>
4200ed58:	982182        	l32i	a8, a1, 0x260
4200ed5b:	079882        	l16si	a8, a8, 14
4200ed5e:	03a896        	bltz	a8, 4200ed9c <_vfiprintf_r+0xe0>
4200ed61:	982182        	l32i	a8, a1, 0x260
4200ed64:	192882        	l32i	a8, a8, 100
4200ed67:	0ee807        	bbsi	a8, 0, 4200ed79 <_vfiprintf_r+0xbd>
4200ed6a:	0be997        	bbsi	a9, 9, 4200ed79 <_vfiprintf_r+0xbd>
4200ed6d:	982182        	l32i	a8, a1, 0x260
4200ed70:	1628a2        	l32i	a10, a8, 88
4200ed73:	c7b481        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
4200ed76:	0008e0        	callx8	a8
4200ed79:	9024d2        	l32i	a13, a4, 0x240
4200ed7c:	9124e2        	l32i	a14, a4, 0x244
4200ed7f:	9224f2        	l32i	a15, a4, 0x248
4200ed82:	9921c2        	l32i	a12, a1, 0x264
4200ed85:	9821b2        	l32i	a11, a1, 0x260
4200ed88:	9b21a2        	l32i	a10, a1, 0x26c
4200ed8b:	02d442        	addmi	a4, a4, 0x200
4200ed8e:	201110        	or	a1, a1, a1
4200ed91:	01bb25        	call8	42010944 <__sbprintf>
4200ed94:	9d61a2        	s32i	a10, a1, 0x274
4200ed97:	06df46        	j	42010918 <_vfiprintf_r+0x1c5c>
4200ed9a:	820000        	mull	a0, a0, a0
4200ed9d:	8ae4a1        	l32r	a10, 41ff1930 <_coredump_iram_end+0x1c6fa30>
4200eda0:	090c84        	lsi	f8, a12, 36
4200eda3:	896482        	s32i	a8, a4, 0x224
4200eda6:	976182        	s32i	a8, a1, 0x25c
4200eda9:	080c      	movi.n	a8, 0
4200edab:	8b6492        	s32i	a9, a4, 0x22c
4200edae:	8a6492        	s32i	a9, a4, 0x228
4200edb1:	906192        	s32i	a9, a1, 0x240
4200edb4:	916192        	s32i	a9, a1, 0x244
4200edb7:	a16182        	s32i	a8, a1, 0x284
4200edba:	9f6182        	s32i	a8, a1, 0x27c
4200edbd:	a06182        	s32i	a8, a1, 0x280
4200edc0:	a26182        	s32i	a8, a1, 0x288
4200edc3:	9d6182        	s32i	a8, a1, 0x274
4200edc6:	10c192        	addi	a9, a1, 16
4200edc9:	e4a182        	movi	a8, 0x1e4
4200edcc:	fa7c      	movi.n	a10, -1
4200edce:	898a      	add.n	a8, a9, a8
4200edd0:	4064a2        	s32i	a10, a4, 0x100
4200edd3:	050c      	movi.n	a5, 0
4200edd5:	a46182        	s32i	a8, a1, 0x290
4200edd8:	992172        	l32i	a7, a1, 0x264
4200eddb:	000046        	j	4200ede0 <_vfiprintf_r+0x124>
4200edde:	771b      	addi.n	a7, a7, 1
4200ede0:	000782        	l8ui	a8, a7, 0
4200ede3:	005816        	beqz	a8, 4200edec <_vfiprintf_r+0x130>
4200ede6:	dbc882        	addi	a8, a8, -37
4200ede9:	ff1856        	bnez	a8, 4200edde <_vfiprintf_r+0x122>
4200edec:	992182        	l32i	a8, a1, 0x264
4200edef:	c06780        	sub	a6, a7, a8
4200edf2:	052616        	beqz	a6, 4200ee48 <_vfiprintf_r+0x18c>
4200edf5:	992192        	l32i	a9, a1, 0x264
4200edf8:	972182        	l32i	a8, a1, 0x25c
4200edfb:	0899      	s32i.n	a9, a8, 0
4200edfd:	1869      	s32i.n	a6, a8, 4
4200edff:	10c182        	addi	a8, a1, 16
4200ee02:	02d892        	addmi	a9, a8, 0x200
4200ee05:	8f2182        	l32i	a8, a1, 0x23c
4200ee08:	886a      	add.n	a8, a8, a6
4200ee0a:	b989      	s32i.n	a8, a9, 44
4200ee0c:	a988      	l32i.n	a8, a9, 40
4200ee0e:	881b      	addi.n	a8, a8, 1
4200ee10:	a989      	s32i.n	a8, a9, 40
4200ee12:	0788e6        	bgei	a8, 8, 4200ee1d <_vfiprintf_r+0x161>
4200ee15:	972182        	l32i	a8, a1, 0x25c
4200ee18:	888b      	addi.n	a8, a8, 8
4200ee1a:	000786        	j	4200ee3c <_vfiprintf_r+0x180>
4200ee1d:	24a2c2        	movi	a12, 0x224
4200ee20:	10c182        	addi	a8, a1, 16
4200ee23:	9821b2        	l32i	a11, a1, 0x260
4200ee26:	9b21a2        	l32i	a10, a1, 0x26c
4200ee29:	c8ca      	add.n	a12, a8, a12
4200ee2b:	ffe6e5        	call8	4200ec98 <__sprint_r>
4200ee2e:	1a8c      	beqz.n	a10, 4200ee33 <_vfiprintf_r+0x177>
4200ee30:	06ab46        	j	420108e1 <_vfiprintf_r+0x1c25>
4200ee33:	e4a182        	movi	a8, 0x1e4
4200ee36:	10c192        	addi	a9, a1, 16
4200ee39:	808980        	add	a8, a9, a8
4200ee3c:	976182        	s32i	a8, a1, 0x25c
4200ee3f:	9d2182        	l32i	a8, a1, 0x274
4200ee42:	808860        	add	a8, a8, a6
4200ee45:	9d6182        	s32i	a8, a1, 0x274
4200ee48:	000782        	l8ui	a8, a7, 0
4200ee4b:	18cc      	bnez.n	a8, 4200ee50 <_vfiprintf_r+0x194>
4200ee4d:	069ac6        	j	420108bc <_vfiprintf_r+0x1c00>
4200ee50:	10c192        	addi	a9, a1, 16
4200ee53:	02d992        	addmi	a9, a9, 0x200
4200ee56:	0a0c      	movi.n	a10, 0
4200ee58:	3a49a2        	s8i	a10, a9, 58
4200ee5b:	f97c      	movi.n	a9, -1
4200ee5d:	9a6192        	s32i	a9, a1, 0x268
4200ee60:	090c      	movi.n	a9, 0
4200ee62:	871b      	addi.n	a8, a7, 1
4200ee64:	056d      	mov.n	a6, a5
4200ee66:	9c6192        	s32i	a9, a1, 0x270
4200ee69:	040c      	movi.n	a4, 0
4200ee6b:	030c      	movi.n	a3, 0
4200ee6d:	000206        	j	4200ee79 <_vfiprintf_r+0x1bd>
4200ee70:	619200        	lsi	f0, a2, 0x184
4200ee73:	0c99      	s32i.n	a9, a12, 0
4200ee75:	218204        	lsi	f0, a2, 132
4200ee78:	1b99      	s32i.n	a9, a11, 4
4200ee7a:	8298      	l32i.n	a9, a2, 32
4200ee7c:	0008      	l32i.n	a0, a0, 0
4200ee7e:	996192        	s32i	a9, a1, 0x264
4200ee81:	9e6182        	s32i	a8, a1, 0x278
4200ee84:	aa5c      	movi.n	a10, 90
4200ee86:	000086        	j	4200ee8c <_vfiprintf_r+0x1d0>
4200ee89:	9c6182        	s32i	a8, a1, 0x270
4200ee8c:	9e2182        	l32i	a8, a1, 0x278
4200ee8f:	e0c882        	addi	a8, a8, -32
4200ee92:	02ba87        	bgeu	a10, a8, 4200ee98 <_vfiprintf_r+0x1dc>
4200ee95:	05a286        	j	42010523 <_vfiprintf_r+0x1867>
4200ee98:	c7af91        	l32r	a9, 42000d54 <_stext+0xd34> (3c02955c <blanks$1+0xc0>)
4200ee9b:	a08890        	addx4	a8, a8, a9
4200ee9e:	0888      	l32i.n	a8, a8, 0
4200eea0:	0008a0        	jx	a8
4200eea3:	c7ab81        	l32r	a8, 42000d50 <_stext+0xd30> (3c02915e <Xthal_intlevel+0x32>)
4200eea6:	046f46        	j	42010067 <_vfiprintf_r+0x13ab>
4200eea9:	9b21a2        	l32i	a10, a1, 0x26c
4200eeac:	201110        	or	a1, a1, a1
4200eeaf:	01d3e5        	call8	42010bec <_localeconv_r>
4200eeb2:	012a82        	l32i	a8, a10, 4
4200eeb5:	08ad      	mov.n	a10, a8
4200eeb7:	a26182        	s32i	a8, a1, 0x288
4200eeba:	c4f881        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200eebd:	0008e0        	callx8	a8
4200eec0:	a061a2        	s32i	a10, a1, 0x280
4200eec3:	9b21a2        	l32i	a10, a1, 0x26c
4200eec6:	201110        	or	a1, a1, a1
4200eec9:	01d225        	call8	42010bec <_localeconv_r>
4200eecc:	2a88      	l32i.n	a8, a10, 8
4200eece:	9f6182        	s32i	a8, a1, 0x27c
4200eed1:	a02182        	l32i	a8, a1, 0x280
4200eed4:	f9e816        	beqz	a8, 4200ee76 <_vfiprintf_r+0x1ba>
4200eed7:	9f2182        	l32i	a8, a1, 0x27c
4200eeda:	f98816        	beqz	a8, 4200ee76 <_vfiprintf_r+0x1ba>
4200eedd:	000882        	l8ui	a8, a8, 0
4200eee0:	f92816        	beqz	a8, 4200ee76 <_vfiprintf_r+0x1ba>
4200eee3:	00a482        	movi	a8, 0x400
4200eee6:	00c246        	j	4200f1f3 <_vfiprintf_r+0x537>
4200eee9:	10c182        	addi	a8, a1, 16
4200eeec:	02d882        	addmi	a8, a8, 0x200
4200eeef:	3a0892        	l8ui	a9, a8, 58
4200eef2:	f80956        	bnez	a9, 4200ee76 <_vfiprintf_r+0x1ba>
4200eef5:	092c      	movi.n	a9, 32
4200eef7:	004786        	j	4200f019 <_vfiprintf_r+0x35d>
4200eefa:	180c      	movi.n	a8, 1
4200eefc:	00bcc6        	j	4200f1f3 <_vfiprintf_r+0x537>
4200eeff:	992182        	l32i	a8, a1, 0x264
4200ef02:	9a0c      	movi.n	a10, 9
4200ef04:	000882        	l8ui	a8, a8, 0
4200ef07:	d0c892        	addi	a9, a8, -48
4200ef0a:	3e3a97        	bltu	a10, a9, 4200ef4c <_vfiprintf_r+0x290>
4200ef0d:	992192        	l32i	a9, a1, 0x264
4200ef10:	0a0c      	movi.n	a10, 0
4200ef12:	01c922        	addi	a2, a9, 1
4200ef15:	09a0b2        	movi	a11, 9
4200ef18:	d0c882        	addi	a8, a8, -48
4200ef1b:	a0aaa0        	addx4	a10, a10, a10
4200ef1e:	90aa80        	addx2	a10, a10, a8
4200ef21:	000282        	l8ui	a8, a2, 0
4200ef24:	221b      	addi.n	a2, a2, 1
4200ef26:	d0c892        	addi	a9, a8, -48
4200ef29:	ebbb97        	bgeu	a11, a9, 4200ef18 <_vfiprintf_r+0x25c>
4200ef2c:	492c      	movi.n	a9, 36
4200ef2e:	021897        	beq	a8, a9, 4200ef34 <_vfiprintf_r+0x278>
4200ef31:	ffcfc6        	j	4200ee74 <_vfiprintf_r+0x1b8>
4200ef34:	082c      	movi.n	a8, 32
4200ef36:	02a8a7        	bge	a8, a10, 4200ef3c <_vfiprintf_r+0x280>
4200ef39:	066906        	j	420108e1 <_vfiprintf_r+0x1c25>
4200ef3c:	912182        	l32i	a8, a1, 0x244
4200ef3f:	aa0b      	addi.n	a10, a10, -1
4200ef41:	10c1e2        	addi	a14, a1, 16
4200ef44:	142a87        	blt	a10, a8, 4200ef5c <_vfiprintf_r+0x2a0>
4200ef47:	000646        	j	4200ef64 <_vfiprintf_r+0x2a8>
4200ef4a:	b20000        	mulsh	a0, a0, a0
4200ef4d:	1b9121        	l32r	a2, 41fd5d94 <_coredump_iram_end+0x1c53e94>
4200ef50:	c18295        	call4	41fd077c <_coredump_iram_end+0x1c4e87c>
4200ef53:	25b710        	extui	a11, a1, 23, 3
4200ef56:	0dc634        	lsi	f3, a6, 52
4200ef59:	000000        	ill
4200ef5c:	b0eae0        	addx8	a14, a10, a14
4200ef5f:	0e88      	l32i.n	a8, a14, 0
4200ef61:	000686        	j	4200ef7f <_vfiprintf_r+0x2c3>
4200ef64:	30a282        	movi	a8, 0x230
4200ef67:	8e8a      	add.n	a8, a14, a8
4200ef69:	34a2d2        	movi	a13, 0x234
4200ef6c:	40a2c2        	movi	a12, 0x240
4200ef6f:	0189      	s32i.n	a8, a1, 0
4200ef71:	01def2        	addmi	a15, a14, 0x100
4200ef74:	deda      	add.n	a13, a14, a13
4200ef76:	ceca      	add.n	a12, a14, a12
4200ef78:	07bd      	mov.n	a11, a7
4200ef7a:	ff84e5        	call8	4200e7c8 <get_arg$isra$0>
4200ef7d:	0a88      	l32i.n	a8, a10, 0
4200ef7f:	9c6182        	s32i	a8, a1, 0x270
4200ef82:	996122        	s32i	a2, a1, 0x264
4200ef85:	059d      	mov.n	a9, a5
4200ef87:	001cc6        	j	4200effe <_vfiprintf_r+0x342>
4200ef8a:	800000        	add	a0, a0, a0
4200ef8d:	86b086        	j	41ff0a53 <_coredump_iram_end+0x1c6eb53>
4200ef90:	0019      	s32i.n	a1, a0, 0
4200ef92:	9228a2        	l32i	a10, a8, 0x248
4200ef95:	fd1c      	movi.n	a13, 31
4200ef97:	02d882        	addmi	a8, a8, 0x200
4200ef9a:	ca4b      	addi.n	a12, a10, 4
4200ef9c:	342db7        	blt	a13, a11, 4200efd4 <_vfiprintf_r+0x318>
4200ef9f:	db1b      	addi.n	a13, a11, 1
4200efa1:	9161d2        	s32i	a13, a1, 0x244
4200efa4:	1268c2        	s32i	a12, a8, 72
4200efa7:	8d1c      	movi.n	a13, 24
4200efa9:	072dc7        	blt	a13, a12, 4200efb4 <_vfiprintf_r+0x2f8>
4200efac:	1128a2        	l32i	a10, a8, 68
4200efaf:	000306        	j	4200efbf <_vfiprintf_r+0x303>
4200efb2:	a70000        	lsi	f0, a0, 0x29c
4200efb5:	012d      	mov.n	a2, a1
4200efb7:	4c2c      	movi.n	a12, 36
4200efb9:	9421a2        	l32i	a10, a1, 0x250
4200efbc:	9661c2        	s32i	a12, a1, 0x258
4200efbf:	aaca      	add.n	a10, a10, a12
4200efc1:	fccaa2        	addi	a10, a10, -4
4200efc4:	0a88      	l32i.n	a8, a10, 0
4200efc6:	9c6182        	s32i	a8, a1, 0x270
4200efc9:	9c21a2        	l32i	a10, a1, 0x270
4200efcc:	b08b10        	addx8	a8, a11, a1
4200efcf:	48a9      	s32i.n	a10, a8, 16
4200efd1:	000a46        	j	4200effe <_vfiprintf_r+0x342>
4200efd4:	1268c2        	s32i	a12, a8, 72
4200efd7:	8b1c      	movi.n	a11, 24
4200efd9:	052bc7        	blt	a11, a12, 4200efe2 <_vfiprintf_r+0x326>
4200efdc:	112882        	l32i	a8, a8, 68
4200efdf:	000446        	j	4200eff4 <_vfiprintf_r+0x338>
4200efe2:	022ba7        	blt	a11, a10, 4200efe8 <_vfiprintf_r+0x32c>
4200efe5:	24a0c2        	movi	a12, 36
4200efe8:	10c182        	addi	a8, a1, 16
4200efeb:	02d882        	addmi	a8, a8, 0x200
4200efee:	102882        	l32i	a8, a8, 64
4200eff1:	9661c2        	s32i	a12, a1, 0x258
4200eff4:	88ca      	add.n	a8, a8, a12
4200eff6:	fcc882        	addi	a8, a8, -4
4200eff9:	0888      	l32i.n	a8, a8, 0
4200effb:	9c6182        	s32i	a8, a1, 0x270
4200effe:	9c2182        	l32i	a8, a1, 0x270
4200f001:	095d      	mov.n	a5, a9
4200f003:	e6f8d6        	bgez	a8, 4200ee76 <_vfiprintf_r+0x1ba>
4200f006:	608080        	neg	a8, a8
4200f009:	9c6182        	s32i	a8, a1, 0x270
4200f00c:	480c      	movi.n	a8, 4
4200f00e:	007846        	j	4200f1f3 <_vfiprintf_r+0x537>
4200f011:	10c182        	addi	a8, a1, 16
4200f014:	02d882        	addmi	a8, a8, 0x200
4200f017:	b92c      	movi.n	a9, 43
4200f019:	3a4892        	s8i	a9, a8, 58
4200f01c:	ff9586        	j	4200ee76 <_vfiprintf_r+0x1ba>
4200f01f:	992182        	l32i	a8, a1, 0x264
4200f022:	981b      	addi.n	a9, a8, 1
4200f024:	000882        	l8ui	a8, a8, 0
4200f027:	9e6182        	s32i	a8, a1, 0x278
4200f02a:	9e21b2        	l32i	a11, a1, 0x278
4200f02d:	a82c      	movi.n	a8, 42
4200f02f:	061b87        	beq	a11, a8, 4200f039 <_vfiprintf_r+0x37d>
4200f032:	080c      	movi.n	a8, 0
4200f034:	9c0c      	movi.n	a12, 9
4200f036:	004506        	j	4200f14e <_vfiprintf_r+0x492>
4200f039:	992182        	l32i	a8, a1, 0x264
4200f03c:	9b0c      	movi.n	a11, 9
4200f03e:	010882        	l8ui	a8, a8, 1
4200f041:	d0c8a2        	addi	a10, a8, -48
4200f044:	3c3ba7        	bltu	a11, a10, 4200f084 <_vfiprintf_r+0x3c8>
4200f047:	9921a2        	l32i	a10, a1, 0x264
4200f04a:	02ca22        	addi	a2, a10, 2
4200f04d:	00a0a2        	movi	a10, 0
4200f050:	d0c882        	addi	a8, a8, -48
4200f053:	a0aaa0        	addx4	a10, a10, a10
4200f056:	90aa80        	addx2	a10, a10, a8
4200f059:	000282        	l8ui	a8, a2, 0
4200f05c:	221b      	addi.n	a2, a2, 1
4200f05e:	d0c8c2        	addi	a12, a8, -48
4200f061:	ebbbc7        	bgeu	a11, a12, 4200f050 <_vfiprintf_r+0x394>
4200f064:	4b2c      	movi.n	a11, 36
4200f066:	0218b7        	beq	a8, a11, 4200f06c <_vfiprintf_r+0x3b0>
4200f069:	ff8106        	j	4200ee71 <_vfiprintf_r+0x1b5>
4200f06c:	082c      	movi.n	a8, 32
4200f06e:	02a8a7        	bge	a8, a10, 4200f074 <_vfiprintf_r+0x3b8>
4200f071:	061b06        	j	420108e1 <_vfiprintf_r+0x1c25>
4200f074:	912182        	l32i	a8, a1, 0x244
4200f077:	aa0b      	addi.n	a10, a10, -1
4200f079:	10c1e2        	addi	a14, a1, 16
4200f07c:	142a87        	blt	a10, a8, 4200f094 <_vfiprintf_r+0x3d8>
4200f07f:	000646        	j	4200f09c <_vfiprintf_r+0x3e0>
4200f082:	a20000        	muluh	a0, a0, a0
4200f085:	1b9121        	l32r	a2, 41fd5ecc <_coredump_iram_end+0x1c53fcc>
4200f088:	c182c5        	call0	41fd08b8 <_coredump_iram_end+0x1c4e9b8>
4200f08b:	25a710        	extui	a10, a1, 23, 3
4200f08e:	0cc630        	lsi	f3, a6, 48
4200f091:	000000        	ill
4200f094:	b0eae0        	addx8	a14, a10, a14
4200f097:	0e88      	l32i.n	a8, a14, 0
4200f099:	000686        	j	4200f0b7 <_vfiprintf_r+0x3fb>
4200f09c:	30a282        	movi	a8, 0x230
4200f09f:	8e8a      	add.n	a8, a14, a8
4200f0a1:	34a2d2        	movi	a13, 0x234
4200f0a4:	40a2c2        	movi	a12, 0x240
4200f0a7:	0189      	s32i.n	a8, a1, 0
4200f0a9:	01def2        	addmi	a15, a14, 0x100
4200f0ac:	deda      	add.n	a13, a14, a13
4200f0ae:	ceca      	add.n	a12, a14, a12
4200f0b0:	07bd      	mov.n	a11, a7
4200f0b2:	ff7165        	call8	4200e7c8 <get_arg$isra$0>
4200f0b5:	0a88      	l32i.n	a8, a10, 0
4200f0b7:	029d      	mov.n	a9, a2
4200f0b9:	05cd      	mov.n	a12, a5
4200f0bb:	001c06        	j	4200f12f <_vfiprintf_r+0x473>
4200f0be:	800000        	add	a0, a0, a0
4200f0c1:	86b086        	j	41ff0b87 <_coredump_iram_end+0x1c6ec87>
4200f0c4:	0019      	s32i.n	a1, a0, 0
4200f0c6:	fb1c      	movi.n	a11, 31
4200f0c8:	352ba7        	blt	a11, a10, 4200f101 <_vfiprintf_r+0x445>
4200f0cb:	9228e2        	l32i	a14, a8, 0x248
4200f0ce:	ba1b      	addi.n	a11, a10, 1
4200f0d0:	9161b2        	s32i	a11, a1, 0x244
4200f0d3:	be4b      	addi.n	a11, a14, 4
4200f0d5:	9268b2        	s32i	a11, a8, 0x248
4200f0d8:	8f1c      	movi.n	a15, 24
4200f0da:	062fb7        	blt	a15, a11, 4200f0e4 <_vfiprintf_r+0x428>
4200f0dd:	912882        	l32i	a8, a8, 0x244
4200f0e0:	000386        	j	4200f0f2 <_vfiprintf_r+0x436>
4200f0e3:	2fe700        	f64cmph	a14, a7, a0, 2
4200f0e6:	4b2c01        	l32r	a0, 41fe1d98 <_coredump_iram_end+0x1c5fe98>
4200f0e9:	9268b2        	s32i	a11, a8, 0x248
4200f0ec:	02d882        	addmi	a8, a8, 0x200
4200f0ef:	102882        	l32i	a8, a8, 64
4200f0f2:	88ba      	add.n	a8, a8, a11
4200f0f4:	fcc882        	addi	a8, a8, -4
4200f0f7:	0888      	l32i.n	a8, a8, 0
4200f0f9:	b0aa10        	addx8	a10, a10, a1
4200f0fc:	4a89      	s32i.n	a8, a10, 16
4200f0fe:	000b46        	j	4200f12f <_vfiprintf_r+0x473>
4200f101:	9228b2        	l32i	a11, a8, 0x248
4200f104:	8d1c      	movi.n	a13, 24
4200f106:	ab4b      	addi.n	a10, a11, 4
4200f108:	9268a2        	s32i	a10, a8, 0x248
4200f10b:	02d882        	addmi	a8, a8, 0x200
4200f10e:	052da7        	blt	a13, a10, 4200f117 <_vfiprintf_r+0x45b>
4200f111:	112882        	l32i	a8, a8, 68
4200f114:	000406        	j	4200f128 <_vfiprintf_r+0x46c>
4200f117:	012db7        	blt	a13, a11, 4200f11c <_vfiprintf_r+0x460>
4200f11a:	4a2c      	movi.n	a10, 36
4200f11c:	10c182        	addi	a8, a1, 16
4200f11f:	02d882        	addmi	a8, a8, 0x200
4200f122:	102882        	l32i	a8, a8, 64
4200f125:	9661a2        	s32i	a10, a1, 0x258
4200f128:	88aa      	add.n	a8, a8, a10
4200f12a:	fcc882        	addi	a8, a8, -4
4200f12d:	0888      	l32i.n	a8, a8, 0
4200f12f:	fa7c      	movi.n	a10, -1
4200f131:	5388a0        	max	a8, a8, a10
4200f134:	9a6182        	s32i	a8, a1, 0x268
4200f137:	0c5d      	mov.n	a5, a12
4200f139:	996192        	s32i	a9, a1, 0x264
4200f13c:	ff4d86        	j	4200ee76 <_vfiprintf_r+0x1ba>
4200f13f:	888000        	lsi	f0, a0, 0x220
4200f142:	88b0a0        	lsi	f10, a0, 0x220
4200f145:	09b290        	l32e	a9, a2, -20
4200f148:	991b00        	lsi	f0, a11, 0x264
4200f14b:	9e61b2        	s32i	a11, a1, 0x278
4200f14e:	9e21b2        	l32i	a11, a1, 0x278
4200f151:	996192        	s32i	a9, a1, 0x264
4200f154:	d0cbb2        	addi	a11, a11, -48
4200f157:	e5bcb7        	bgeu	a12, a11, 4200f140 <_vfiprintf_r+0x484>
4200f15a:	f97c      	movi.n	a9, -1
4200f15c:	538890        	max	a8, a8, a9
4200f15f:	9a6182        	s32i	a8, a1, 0x268
4200f162:	9c2182        	l32i	a8, a1, 0x270
4200f165:	ff4806        	j	4200ee89 <_vfiprintf_r+0x1cd>
4200f168:	820000        	mull	a0, a0, a0
4200f16b:	8680a0        	lsi	f10, a0, 0x218
4200f16e:	0c0020        	lsi	f2, a0, 48
4200f171:	0c08      	l32i.n	a0, a12, 0
4200f173:	929b      	addi.n	a9, a2, 9
4200f175:	809e21        	l32r	a2, 41fef3f0 <_coredump_iram_end+0x1c6d4f0>
4200f178:	a088      	l32i.n	a8, a0, 40
4200f17a:	d0c992        	addi	a9, a9, -48
4200f17d:	908890        	addx2	a8, a8, a9
4200f180:	992192        	l32i	a9, a1, 0x264
4200f183:	000992        	l8ui	a9, a9, 0
4200f186:	9e6192        	s32i	a9, a1, 0x278
4200f189:	992192        	l32i	a9, a1, 0x264
4200f18c:	991b      	addi.n	a9, a9, 1
4200f18e:	996192        	s32i	a9, a1, 0x264
4200f191:	9e2192        	l32i	a9, a1, 0x278
4200f194:	d0c992        	addi	a9, a9, -48
4200f197:	d9bb97        	bgeu	a11, a9, 4200f174 <_vfiprintf_r+0x4b8>
4200f19a:	9e21b2        	l32i	a11, a1, 0x278
4200f19d:	492c      	movi.n	a9, 36
4200f19f:	021b97        	beq	a11, a9, 4200f1a5 <_vfiprintf_r+0x4e9>
4200f1a2:	ff38c6        	j	4200ee89 <_vfiprintf_r+0x1cd>
4200f1a5:	092c      	movi.n	a9, 32
4200f1a7:	02a987        	bge	a9, a8, 4200f1ad <_vfiprintf_r+0x4f1>
4200f1aa:	05ccc6        	j	420108e1 <_vfiprintf_r+0x1c25>
4200f1ad:	680b      	addi.n	a6, a8, -1
4200f1af:	140c      	movi.n	a4, 1
4200f1b1:	ff3046        	j	4200ee76 <_vfiprintf_r+0x1ba>
4200f1b4:	992182        	l32i	a8, a1, 0x264
4200f1b7:	000892        	l8ui	a9, a8, 0
4200f1ba:	68a082        	movi	a8, 104
4200f1bd:	0d9987        	bne	a9, a8, 4200f1ce <_vfiprintf_r+0x512>
4200f1c0:	992182        	l32i	a8, a1, 0x264
4200f1c3:	881b      	addi.n	a8, a8, 1
4200f1c5:	996182        	s32i	a8, a1, 0x264
4200f1c8:	00a282        	movi	a8, 0x200
4200f1cb:	000906        	j	4200f1f3 <_vfiprintf_r+0x537>
4200f1ce:	084c      	movi.n	a8, 64
4200f1d0:	0007c6        	j	4200f1f3 <_vfiprintf_r+0x537>
4200f1d3:	992182        	l32i	a8, a1, 0x264
4200f1d6:	000892        	l8ui	a9, a8, 0
4200f1d9:	6ca082        	movi	a8, 108
4200f1dc:	0a9987        	bne	a9, a8, 4200f1ea <_vfiprintf_r+0x52e>
4200f1df:	992182        	l32i	a8, a1, 0x264
4200f1e2:	881b      	addi.n	a8, a8, 1
4200f1e4:	996182        	s32i	a8, a1, 0x264
4200f1e7:	000186        	j	4200f1f1 <_vfiprintf_r+0x535>
4200f1ea:	081c      	movi.n	a8, 16
4200f1ec:	0000c6        	j	4200f1f3 <_vfiprintf_r+0x537>
4200f1ef:	2c0000        	lsi	f0, a0, 176
4200f1f2:	8008      	l32i.n	a0, a0, 32
4200f1f4:	062033        	lsi	f3, a0, 24
4200f1f7:	1f          	.byte	0x1f
4200f1f8:	ff          	.byte	0xff
4200f1f9:	912192        	l32i	a9, a1, 0x244
4200f1fc:	10c1e2        	addi	a14, a1, 16
4200f1ff:	d4ac      	beqz.n	a4, 4200f230 <_vfiprintf_r+0x574>
4200f201:	08a697        	bge	a6, a9, 4200f20d <_vfiprintf_r+0x551>
4200f204:	b0e6e0        	addx8	a14, a6, a14
4200f207:	000e82        	l8ui	a8, a14, 0
4200f20a:	000746        	j	4200f22b <_vfiprintf_r+0x56f>
4200f20d:	30a282        	movi	a8, 0x230
4200f210:	8e8a      	add.n	a8, a14, a8
4200f212:	34a2d2        	movi	a13, 0x234
4200f215:	40a2c2        	movi	a12, 0x240
4200f218:	0189      	s32i.n	a8, a1, 0
4200f21a:	01def2        	addmi	a15, a14, 0x100
4200f21d:	deda      	add.n	a13, a14, a13
4200f21f:	ceca      	add.n	a12, a14, a12
4200f221:	07bd      	mov.n	a11, a7
4200f223:	06ad      	mov.n	a10, a6
4200f225:	ff5a25        	call8	4200e7c8 <get_arg$isra$0>
4200f228:	000a82        	l8ui	a8, a10, 0
4200f22b:	057d      	mov.n	a7, a5
4200f22d:	001f06        	j	4200f2ad <_vfiprintf_r+0x5f1>
4200f230:	751b      	addi.n	a7, a5, 1
4200f232:	0aa597        	bge	a5, a9, 4200f240 <_vfiprintf_r+0x584>
4200f235:	b0e6e0        	addx8	a14, a6, a14
4200f238:	000e82        	l8ui	a8, a14, 0
4200f23b:	001b86        	j	4200f2ad <_vfiprintf_r+0x5f1>
4200f23e:	820000        	mull	a0, a0, a0
4200f241:	2e          	.byte	0x2e
4200f242:	fb1c92        	l16ui	a9, a12, 0x1f6
4200f245:	02dee2        	addmi	a14, a14, 0x200
4200f248:	a84b      	addi.n	a10, a8, 4
4200f24a:	362b97        	blt	a11, a9, 4200f284 <_vfiprintf_r+0x5c8>
4200f24d:	b91b      	addi.n	a11, a9, 1
4200f24f:	9161b2        	s32i	a11, a1, 0x244
4200f252:	126ea2        	s32i	a10, a14, 72
4200f255:	8b1c      	movi.n	a11, 24
4200f257:	052ba7        	blt	a11, a10, 4200f260 <_vfiprintf_r+0x5a4>
4200f25a:	112e82        	l32i	a8, a14, 68
4200f25d:	000406        	j	4200f271 <_vfiprintf_r+0x5b5>
4200f260:	012b87        	blt	a11, a8, 4200f265 <_vfiprintf_r+0x5a9>
4200f263:	4a2c      	movi.n	a10, 36
4200f265:	10c182        	addi	a8, a1, 16
4200f268:	02d882        	addmi	a8, a8, 0x200
4200f26b:	102882        	l32i	a8, a8, 64
4200f26e:	9661a2        	s32i	a10, a1, 0x258
4200f271:	88aa      	add.n	a8, a8, a10
4200f273:	fcc882        	addi	a8, a8, -4
4200f276:	0888      	l32i.n	a8, a8, 0
4200f278:	b09910        	addx8	a9, a9, a1
4200f27b:	4989      	s32i.n	a8, a9, 16
4200f27d:	748080        	extui	a8, a8, 0, 8
4200f280:	000a46        	j	4200f2ad <_vfiprintf_r+0x5f1>
4200f283:	6ea200        	f64rnd	a10, a2, a0, 2
4200f286:	891c12        	l16ui	a1, a12, 0x112
4200f289:	0729a7        	blt	a9, a10, 4200f294 <_vfiprintf_r+0x5d8>
4200f28c:	112e82        	l32i	a8, a14, 68
4200f28f:	000486        	j	4200f2a5 <_vfiprintf_r+0x5e9>
4200f292:	870000        	lsi	f0, a0, 0x21c
4200f295:	0129      	s32i.n	a2, a1, 0
4200f297:	4a2c      	movi.n	a10, 36
4200f299:	10c182        	addi	a8, a1, 16
4200f29c:	02d882        	addmi	a8, a8, 0x200
4200f29f:	102882        	l32i	a8, a8, 64
4200f2a2:	9661a2        	s32i	a10, a1, 0x258
4200f2a5:	88aa      	add.n	a8, a8, a10
4200f2a7:	fcc882        	addi	a8, a8, -4
4200f2aa:	000882        	l8ui	a8, a8, 0
4200f2ad:	10c162        	addi	a6, a1, 16
4200f2b0:	01d692        	addmi	a9, a6, 0x100
4200f2b3:	804982        	s8i	a8, a9, 128
4200f2b6:	02d682        	addmi	a8, a6, 0x200
4200f2b9:	090c      	movi.n	a9, 0
4200f2bb:	3a4892        	s8i	a9, a8, 58
4200f2be:	049f46        	j	4201053f <_vfiprintf_r+0x1883>
4200f2c1:	081c      	movi.n	a8, 16
4200f2c3:	203380        	or	a3, a3, a8
4200f2c6:	912182        	l32i	a8, a1, 0x244
4200f2c9:	10c1e2        	addi	a14, a1, 16
4200f2cc:	02e357        	bbsi	a3, 5, 4200f2d2 <_vfiprintf_r+0x616>
4200f2cf:	002f46        	j	4200f390 <_vfiprintf_r+0x6d4>
4200f2d2:	f4ac      	beqz.n	a4, 4200f305 <_vfiprintf_r+0x649>
4200f2d4:	09a687        	bge	a6, a8, 4200f2e1 <_vfiprintf_r+0x625>
4200f2d7:	b0e6e0        	addx8	a14, a6, a14
4200f2da:	0e48      	l32i.n	a4, a14, 0
4200f2dc:	1e28      	l32i.n	a2, a14, 4
4200f2de:	000786        	j	4200f300 <_vfiprintf_r+0x644>
4200f2e1:	30a282        	movi	a8, 0x230
4200f2e4:	8e8a      	add.n	a8, a14, a8
4200f2e6:	34a2d2        	movi	a13, 0x234
4200f2e9:	40a2c2        	movi	a12, 0x240
4200f2ec:	0189      	s32i.n	a8, a1, 0
4200f2ee:	01def2        	addmi	a15, a14, 0x100
4200f2f1:	deda      	add.n	a13, a14, a13
4200f2f3:	ceca      	add.n	a12, a14, a12
4200f2f5:	07bd      	mov.n	a11, a7
4200f2f7:	06ad      	mov.n	a10, a6
4200f2f9:	ff4ce5        	call8	4200e7c8 <get_arg$isra$0>
4200f2fc:	0a48      	l32i.n	a4, a10, 0
4200f2fe:	1a28      	l32i.n	a2, a10, 4
4200f300:	057d      	mov.n	a7, a5
4200f302:	00aa46        	j	4200f5af <_vfiprintf_r+0x8f3>
4200f305:	751b      	addi.n	a7, a5, 1
4200f307:	09a587        	bge	a5, a8, 4200f314 <_vfiprintf_r+0x658>
4200f30a:	b0e6e0        	addx8	a14, a6, a14
4200f30d:	0e48      	l32i.n	a4, a14, 0
4200f30f:	1e28      	l32i.n	a2, a14, 4
4200f311:	00a686        	j	4200f5af <_vfiprintf_r+0x8f3>
4200f314:	922e92        	l32i	a9, a14, 0x248
4200f317:	8a7c      	movi.n	a10, -8
4200f319:	997b      	addi.n	a9, a9, 7
4200f31b:	1099a0        	and	a9, a9, a10
4200f31e:	fb1c      	movi.n	a11, 31
4200f320:	02dee2        	addmi	a14, a14, 0x200
4200f323:	a98b      	addi.n	a10, a9, 8
4200f325:	3b2b87        	blt	a11, a8, 4200f364 <_vfiprintf_r+0x6a8>
4200f328:	b81b      	addi.n	a11, a8, 1
4200f32a:	9161b2        	s32i	a11, a1, 0x244
4200f32d:	126ea2        	s32i	a10, a14, 72
4200f330:	8b1c      	movi.n	a11, 24
4200f332:	062ba7        	blt	a11, a10, 4200f33c <_vfiprintf_r+0x680>
4200f335:	112e92        	l32i	a9, a14, 68
4200f338:	000446        	j	4200f34d <_vfiprintf_r+0x691>
4200f33b:	2b9700        	oeq.s	b9, f7, f0
4200f33e:	8a2c01        	l32r	a0, 41ff1bf0 <_coredump_iram_end+0x1c6fcf0>
4200f341:	10c192        	addi	a9, a1, 16
4200f344:	02d992        	addmi	a9, a9, 0x200
4200f347:	102992        	l32i	a9, a9, 64
4200f34a:	9661a2        	s32i	a10, a1, 0x258
4200f34d:	99aa      	add.n	a9, a9, a10
4200f34f:	f8c992        	addi	a9, a9, -8
4200f352:	0948      	l32i.n	a4, a9, 0
4200f354:	1928      	l32i.n	a2, a9, 4
4200f356:	10c192        	addi	a9, a1, 16
4200f359:	b08890        	addx8	a8, a8, a9
4200f35c:	0849      	s32i.n	a4, a8, 0
4200f35e:	1829      	s32i.n	a2, a8, 4
4200f360:	0092c6        	j	4200f5af <_vfiprintf_r+0x8f3>
4200f363:	6ea200        	f64rnd	a10, a2, a0, 2
4200f366:	881c12        	l16ui	a1, a12, 0x110
4200f369:	0528a7        	blt	a8, a10, 4200f372 <_vfiprintf_r+0x6b6>
4200f36c:	112e82        	l32i	a8, a14, 68
4200f36f:	000446        	j	4200f384 <_vfiprintf_r+0x6c8>
4200f372:	022897        	blt	a8, a9, 4200f378 <_vfiprintf_r+0x6bc>
4200f375:	28a0a2        	movi	a10, 40
4200f378:	10c182        	addi	a8, a1, 16
4200f37b:	02d882        	addmi	a8, a8, 0x200
4200f37e:	102882        	l32i	a8, a8, 64
4200f381:	9661a2        	s32i	a10, a1, 0x258
4200f384:	88aa      	add.n	a8, a8, a10
4200f386:	f8c882        	addi	a8, a8, -8
4200f389:	0848      	l32i.n	a4, a8, 0
4200f38b:	1828      	l32i.n	a2, a8, 4
4200f38d:	008786        	j	4200f5af <_vfiprintf_r+0x8f3>
4200f390:	046347        	bbci	a3, 4, 4200f398 <_vfiprintf_r+0x6dc>
4200f393:	005c46        	j	4200f508 <_vfiprintf_r+0x84c>
4200f396:	670000        	lsi	f0, a0, 0x19c
4200f399:	4602e3        	lsi	f14, a2, 0x118
4200f39c:	002b      	addi.n	a0, a0, 2
4200f39e:	c4ac      	beqz.n	a4, 4200f3ce <_vfiprintf_r+0x712>
4200f3a0:	09a687        	bge	a6, a8, 4200f3ad <_vfiprintf_r+0x6f1>
4200f3a3:	b0e6e0        	addx8	a14, a6, a14
4200f3a6:	009e42        	l16si	a4, a14, 0
4200f3a9:	006146        	j	4200f532 <_vfiprintf_r+0x876>
4200f3ac:	a28200        	muluh	a8, a2, a0
4200f3af:	8e8a30        	f64iter	a8, a10, a3, 0, 0
4200f3b2:	34a2d2        	movi	a13, 0x234
4200f3b5:	40a2c2        	movi	a12, 0x240
4200f3b8:	0189      	s32i.n	a8, a1, 0
4200f3ba:	01def2        	addmi	a15, a14, 0x100
4200f3bd:	deda      	add.n	a13, a14, a13
4200f3bf:	ceca      	add.n	a12, a14, a12
4200f3c1:	07bd      	mov.n	a11, a7
4200f3c3:	06ad      	mov.n	a10, a6
4200f3c5:	ff4025        	call8	4200e7c8 <get_arg$isra$0>
4200f3c8:	009a42        	l16si	a4, a10, 0
4200f3cb:	0058c6        	j	4200f532 <_vfiprintf_r+0x876>
4200f3ce:	751b      	addi.n	a7, a5, 1
4200f3d0:	08a587        	bge	a5, a8, 4200f3dc <_vfiprintf_r+0x720>
4200f3d3:	b0e6e0        	addx8	a14, a6, a14
4200f3d6:	009e42        	l16si	a4, a14, 0
4200f3d9:	0073c6        	j	4200f5ac <_vfiprintf_r+0x8f0>
4200f3dc:	922e92        	l32i	a9, a14, 0x248
4200f3df:	fb1c      	movi.n	a11, 31
4200f3e1:	02dee2        	addmi	a14, a14, 0x200
4200f3e4:	a94b      	addi.n	a10, a9, 4
4200f3e6:	362b87        	blt	a11, a8, 4200f420 <_vfiprintf_r+0x764>
4200f3e9:	b81b      	addi.n	a11, a8, 1
4200f3eb:	9161b2        	s32i	a11, a1, 0x244
4200f3ee:	126ea2        	s32i	a10, a14, 72
4200f3f1:	8b1c      	movi.n	a11, 24
4200f3f3:	052ba7        	blt	a11, a10, 4200f3fc <_vfiprintf_r+0x740>
4200f3f6:	112e92        	l32i	a9, a14, 68
4200f3f9:	000406        	j	4200f40d <_vfiprintf_r+0x751>
4200f3fc:	012b97        	blt	a11, a9, 4200f401 <_vfiprintf_r+0x745>
4200f3ff:	4a2c      	movi.n	a10, 36
4200f401:	10c192        	addi	a9, a1, 16
4200f404:	02d992        	addmi	a9, a9, 0x200
4200f407:	102992        	l32i	a9, a9, 64
4200f40a:	9661a2        	s32i	a10, a1, 0x258
4200f40d:	99aa      	add.n	a9, a9, a10
4200f40f:	fcc992        	addi	a9, a9, -4
4200f412:	0948      	l32i.n	a4, a9, 0
4200f414:	b08810        	addx8	a8, a8, a1
4200f417:	4849      	s32i.n	a4, a8, 16
4200f419:	234480        	sext	a4, a4, 15
4200f41c:	006306        	j	4200f5ac <_vfiprintf_r+0x8f0>
4200f41f:	6ea200        	f64rnd	a10, a2, a0, 2
4200f422:	881c12        	l16ui	a1, a12, 0x110
4200f425:	0728a7        	blt	a8, a10, 4200f430 <_vfiprintf_r+0x774>
4200f428:	112e82        	l32i	a8, a14, 68
4200f42b:	000486        	j	4200f441 <_vfiprintf_r+0x785>
4200f42e:	970000        	lsi	f0, a0, 0x25c
4200f431:	0128      	l32i.n	a2, a1, 0
4200f433:	4a2c      	movi.n	a10, 36
4200f435:	10c182        	addi	a8, a1, 16
4200f438:	02d882        	addmi	a8, a8, 0x200
4200f43b:	102882        	l32i	a8, a8, 64
4200f43e:	9661a2        	s32i	a10, a1, 0x258
4200f441:	88aa      	add.n	a8, a8, a10
4200f443:	fcc882        	addi	a8, a8, -4
4200f446:	009842        	l16si	a4, a8, 0
4200f449:	0057c6        	j	4200f5ac <_vfiprintf_r+0x8f0>
4200f44c:	02e397        	bbsi	a3, 9, 4200f452 <_vfiprintf_r+0x796>
4200f44f:	002d46        	j	4200f508 <_vfiprintf_r+0x84c>
4200f452:	e4ac      	beqz.n	a4, 4200f484 <_vfiprintf_r+0x7c8>
4200f454:	09a687        	bge	a6, a8, 4200f461 <_vfiprintf_r+0x7a5>
4200f457:	b0e6e0        	addx8	a14, a6, a14
4200f45a:	000e42        	l8ui	a4, a14, 0
4200f45d:	000786        	j	4200f47f <_vfiprintf_r+0x7c3>
4200f460:	a28200        	muluh	a8, a2, a0
4200f463:	8e8a30        	f64iter	a8, a10, a3, 0, 0
4200f466:	34a2d2        	movi	a13, 0x234
4200f469:	40a2c2        	movi	a12, 0x240
4200f46c:	0189      	s32i.n	a8, a1, 0
4200f46e:	01def2        	addmi	a15, a14, 0x100
4200f471:	deda      	add.n	a13, a14, a13
4200f473:	ceca      	add.n	a12, a14, a12
4200f475:	07bd      	mov.n	a11, a7
4200f477:	06ad      	mov.n	a10, a6
4200f479:	ff34e5        	call8	4200e7c8 <get_arg$isra$0>
4200f47c:	000a42        	l8ui	a4, a10, 0
4200f47f:	057d      	mov.n	a7, a5
4200f481:	001f06        	j	4200f501 <_vfiprintf_r+0x845>
4200f484:	751b      	addi.n	a7, a5, 1
4200f486:	0aa587        	bge	a5, a8, 4200f494 <_vfiprintf_r+0x7d8>
4200f489:	b0e6e0        	addx8	a14, a6, a14
4200f48c:	000e42        	l8ui	a4, a14, 0
4200f48f:	001b86        	j	4200f501 <_vfiprintf_r+0x845>
4200f492:	920000        	lsi	f0, a0, 0x248
4200f495:	2e          	.byte	0x2e
4200f496:	fb1c92        	l16ui	a9, a12, 0x1f6
4200f499:	02dee2        	addmi	a14, a14, 0x200
4200f49c:	a94b      	addi.n	a10, a9, 4
4200f49e:	362b87        	blt	a11, a8, 4200f4d8 <_vfiprintf_r+0x81c>
4200f4a1:	b81b      	addi.n	a11, a8, 1
4200f4a3:	9161b2        	s32i	a11, a1, 0x244
4200f4a6:	126ea2        	s32i	a10, a14, 72
4200f4a9:	8b1c      	movi.n	a11, 24
4200f4ab:	052ba7        	blt	a11, a10, 4200f4b4 <_vfiprintf_r+0x7f8>
4200f4ae:	112e92        	l32i	a9, a14, 68
4200f4b1:	000406        	j	4200f4c5 <_vfiprintf_r+0x809>
4200f4b4:	012b97        	blt	a11, a9, 4200f4b9 <_vfiprintf_r+0x7fd>
4200f4b7:	4a2c      	movi.n	a10, 36
4200f4b9:	10c192        	addi	a9, a1, 16
4200f4bc:	02d992        	addmi	a9, a9, 0x200
4200f4bf:	102992        	l32i	a9, a9, 64
4200f4c2:	9661a2        	s32i	a10, a1, 0x258
4200f4c5:	99aa      	add.n	a9, a9, a10
4200f4c7:	fcc992        	addi	a9, a9, -4
4200f4ca:	0948      	l32i.n	a4, a9, 0
4200f4cc:	b08810        	addx8	a8, a8, a1
4200f4cf:	4849      	s32i.n	a4, a8, 16
4200f4d1:	744040        	extui	a4, a4, 0, 8
4200f4d4:	000a46        	j	4200f501 <_vfiprintf_r+0x845>
4200f4d7:	6ea200        	f64rnd	a10, a2, a0, 2
4200f4da:	881c12        	l16ui	a1, a12, 0x110
4200f4dd:	0728a7        	blt	a8, a10, 4200f4e8 <_vfiprintf_r+0x82c>
4200f4e0:	112e82        	l32i	a8, a14, 68
4200f4e3:	000486        	j	4200f4f9 <_vfiprintf_r+0x83d>
4200f4e6:	970000        	lsi	f0, a0, 0x25c
4200f4e9:	0128      	l32i.n	a2, a1, 0
4200f4eb:	4a2c      	movi.n	a10, 36
4200f4ed:	10c182        	addi	a8, a1, 16
4200f4f0:	02d882        	addmi	a8, a8, 0x200
4200f4f3:	102882        	l32i	a8, a8, 64
4200f4f6:	9661a2        	s32i	a10, a1, 0x258
4200f4f9:	88aa      	add.n	a8, a8, a10
4200f4fb:	fcc882        	addi	a8, a8, -4
4200f4fe:	000842        	l8ui	a4, a8, 0
4200f501:	234400        	sext	a4, a4, 7
4200f504:	002906        	j	4200f5ac <_vfiprintf_r+0x8f0>
4200f507:	c4ac00        	extui	a10, a0, 12, 13
4200f50a:	07a687        	bge	a6, a8, 4200f515 <_vfiprintf_r+0x859>
4200f50d:	b0e6e0        	addx8	a14, a6, a14
4200f510:	0e48      	l32i.n	a4, a14, 0
4200f512:	000706        	j	4200f532 <_vfiprintf_r+0x876>
4200f515:	30a282        	movi	a8, 0x230
4200f518:	8e8a      	add.n	a8, a14, a8
4200f51a:	34a2d2        	movi	a13, 0x234
4200f51d:	40a2c2        	movi	a12, 0x240
4200f520:	0189      	s32i.n	a8, a1, 0
4200f522:	01def2        	addmi	a15, a14, 0x100
4200f525:	deda      	add.n	a13, a14, a13
4200f527:	ceca      	add.n	a12, a14, a12
4200f529:	07bd      	mov.n	a11, a7
4200f52b:	06ad      	mov.n	a10, a6
4200f52d:	ff29a5        	call8	4200e7c8 <get_arg$isra$0>
4200f530:	0a48      	l32i.n	a4, a10, 0
4200f532:	057d      	mov.n	a7, a5
4200f534:	001d06        	j	4200f5ac <_vfiprintf_r+0x8f0>
4200f537:	751b00        	extui	a1, a0, 27, 8
4200f53a:	07a587        	bge	a5, a8, 4200f545 <_vfiprintf_r+0x889>
4200f53d:	b0e6e0        	addx8	a14, a6, a14
4200f540:	0e48      	l32i.n	a4, a14, 0
4200f542:	001986        	j	4200f5ac <_vfiprintf_r+0x8f0>
4200f545:	922e92        	l32i	a9, a14, 0x248
4200f548:	fb1c      	movi.n	a11, 31
4200f54a:	02dee2        	addmi	a14, a14, 0x200
4200f54d:	a94b      	addi.n	a10, a9, 4
4200f54f:	322b87        	blt	a11, a8, 4200f585 <_vfiprintf_r+0x8c9>
4200f552:	b81b      	addi.n	a11, a8, 1
4200f554:	9161b2        	s32i	a11, a1, 0x244
4200f557:	126ea2        	s32i	a10, a14, 72
4200f55a:	8b1c      	movi.n	a11, 24
4200f55c:	052ba7        	blt	a11, a10, 4200f565 <_vfiprintf_r+0x8a9>
4200f55f:	112e92        	l32i	a9, a14, 68
4200f562:	000406        	j	4200f576 <_vfiprintf_r+0x8ba>
4200f565:	012b97        	blt	a11, a9, 4200f56a <_vfiprintf_r+0x8ae>
4200f568:	4a2c      	movi.n	a10, 36
4200f56a:	10c192        	addi	a9, a1, 16
4200f56d:	02d992        	addmi	a9, a9, 0x200
4200f570:	102992        	l32i	a9, a9, 64
4200f573:	9661a2        	s32i	a10, a1, 0x258
4200f576:	99aa      	add.n	a9, a9, a10
4200f578:	fcc992        	addi	a9, a9, -4
4200f57b:	0948      	l32i.n	a4, a9, 0
4200f57d:	b08810        	addx8	a8, a8, a1
4200f580:	4849      	s32i.n	a4, a8, 16
4200f582:	000986        	j	4200f5ac <_vfiprintf_r+0x8f0>
4200f585:	126ea2        	s32i	a10, a14, 72
4200f588:	881c      	movi.n	a8, 24
4200f58a:	0528a7        	blt	a8, a10, 4200f593 <_vfiprintf_r+0x8d7>
4200f58d:	112e82        	l32i	a8, a14, 68
4200f590:	000446        	j	4200f5a5 <_vfiprintf_r+0x8e9>
4200f593:	022897        	blt	a8, a9, 4200f599 <_vfiprintf_r+0x8dd>
4200f596:	24a0a2        	movi	a10, 36
4200f599:	10c182        	addi	a8, a1, 16
4200f59c:	02d882        	addmi	a8, a8, 0x200
4200f59f:	102882        	l32i	a8, a8, 64
4200f5a2:	9661a2        	s32i	a10, a1, 0x258
4200f5a5:	88aa      	add.n	a8, a8, a10
4200f5a7:	fcc882        	addi	a8, a8, -4
4200f5aa:	0848      	l32i.n	a4, a8, 0
4200f5ac:	312f40        	srai	a2, a4, 31
4200f5af:	002296        	bltz	a2, 4200f5b5 <_vfiprintf_r+0x8f9>
4200f5b2:	04d546        	j	4201090b <_vfiprintf_r+0x1c4f>
4200f5b5:	602020        	neg	a2, a2
4200f5b8:	048c      	beqz.n	a4, 4200f5bc <_vfiprintf_r+0x900>
4200f5ba:	220b      	addi.n	a2, a2, -1
4200f5bc:	604040        	neg	a4, a4
4200f5bf:	d92c      	movi.n	a9, 45
4200f5c1:	180c      	movi.n	a8, 1
4200f5c3:	036f06        	j	42010383 <_vfiprintf_r+0x16c7>
4200f5c6:	820000        	mull	a0, a0, a0
4200f5c9:	e29121        	l32r	a2, 42008010 <_Z16string_benchmarkm+0x158> (67e23781 <_rtc_reserved_end+0x7d23781>)
4200f5cc:	5710c1        	l32r	a12, 41fe520c <_coredump_iram_end+0x1c6330c>
4200f5cf:	c602e3        	lsi	f14, a2, 0x318
4200f5d2:	0029      	s32i.n	a2, a0, 0
4200f5d4:	c4ac      	beqz.n	a4, 4200f604 <_vfiprintf_r+0x948>
4200f5d6:	07a687        	bge	a6, a8, 4200f5e1 <_vfiprintf_r+0x925>
4200f5d9:	b0e6e0        	addx8	a14, a6, a14
4200f5dc:	0e98      	l32i.n	a9, a14, 0
4200f5de:	000706        	j	4200f5fe <_vfiprintf_r+0x942>
4200f5e1:	30a282        	movi	a8, 0x230
4200f5e4:	8e8a      	add.n	a8, a14, a8
4200f5e6:	34a2d2        	movi	a13, 0x234
4200f5e9:	40a2c2        	movi	a12, 0x240
4200f5ec:	0189      	s32i.n	a8, a1, 0
4200f5ee:	01def2        	addmi	a15, a14, 0x100
4200f5f1:	deda      	add.n	a13, a14, a13
4200f5f3:	ceca      	add.n	a12, a14, a12
4200f5f5:	07bd      	mov.n	a11, a7
4200f5f7:	06ad      	mov.n	a10, a6
4200f5f9:	ff1ce5        	call8	4200e7c8 <get_arg$isra$0>
4200f5fc:	0a98      	l32i.n	a9, a10, 0
4200f5fe:	05ad      	mov.n	a10, a5
4200f600:	001a86        	j	4200f66e <_vfiprintf_r+0x9b2>
4200f603:	a51b00        	extui	a1, a0, 27, 11
4200f606:	07a587        	bge	a5, a8, 4200f611 <_vfiprintf_r+0x955>
4200f609:	b0e6e0        	addx8	a14, a6, a14
4200f60c:	0e98      	l32i.n	a9, a14, 0
4200f60e:	001706        	j	4200f66e <_vfiprintf_r+0x9b2>
4200f611:	922ec2        	l32i	a12, a14, 0x248
4200f614:	fd1c      	movi.n	a13, 31
4200f616:	02deb2        	addmi	a11, a14, 0x200
4200f619:	9c4b      	addi.n	a9, a12, 4
4200f61b:	2d2d87        	blt	a13, a8, 4200f64c <_vfiprintf_r+0x990>
4200f61e:	d81b      	addi.n	a13, a8, 1
4200f620:	9161d2        	s32i	a13, a1, 0x244
4200f623:	126b92        	s32i	a9, a11, 72
4200f626:	8d1c      	movi.n	a13, 24
4200f628:	052d97        	blt	a13, a9, 4200f631 <_vfiprintf_r+0x975>
4200f62b:	112bb2        	l32i	a11, a11, 68
4200f62e:	000286        	j	4200f63c <_vfiprintf_r+0x980>
4200f631:	012dc7        	blt	a13, a12, 4200f636 <_vfiprintf_r+0x97a>
4200f634:	492c      	movi.n	a9, 36
4200f636:	902eb2        	l32i	a11, a14, 0x240
4200f639:	926e92        	s32i	a9, a14, 0x248
4200f63c:	bb9a      	add.n	a11, a11, a9
4200f63e:	fccbb2        	addi	a11, a11, -4
4200f641:	0b98      	l32i.n	a9, a11, 0
4200f643:	b088e0        	addx8	a8, a8, a14
4200f646:	0899      	s32i.n	a9, a8, 0
4200f648:	000886        	j	4200f66e <_vfiprintf_r+0x9b2>
4200f64b:	6b9200        	ole.s	b9, f2, f0
4200f64e:	881c12        	l16ui	a1, a12, 0x110
4200f651:	072897        	blt	a8, a9, 4200f65c <_vfiprintf_r+0x9a0>
4200f654:	112b82        	l32i	a8, a11, 68
4200f657:	000306        	j	4200f667 <_vfiprintf_r+0x9ab>
4200f65a:	c70000        	lsi	f0, a0, 0x31c
4200f65d:	0128      	l32i.n	a2, a1, 0
4200f65f:	492c      	movi.n	a9, 36
4200f661:	902e82        	l32i	a8, a14, 0x240
4200f664:	926e92        	s32i	a9, a14, 0x248
4200f667:	889a      	add.n	a8, a8, a9
4200f669:	fcc882        	addi	a8, a8, -4
4200f66c:	0898      	l32i.n	a9, a8, 0
4200f66e:	9d2182        	l32i	a8, a1, 0x274
4200f671:	0989      	s32i.n	a8, a9, 0
4200f673:	318f80        	srai	a8, a8, 31
4200f676:	1989      	s32i.n	a8, a9, 4
4200f678:	009606        	j	4200f8d4 <_vfiprintf_r+0xc18>
4200f67b:	634700        	minu	a4, a7, a0
4200f67e:	148c60        	extui	a8, a6, 12, 2
4200f681:	006d46        	j	4200f83a <_vfiprintf_r+0xb7e>
4200f684:	a51b      	addi.n	a10, a5, 1
4200f686:	02a587        	bge	a5, a8, 4200f68c <_vfiprintf_r+0x9d0>
4200f689:	007806        	j	4200f86d <_vfiprintf_r+0xbb1>
4200f68c:	922ec2        	l32i	a12, a14, 0x248
4200f68f:	fd1c      	movi.n	a13, 31
4200f691:	02deb2        	addmi	a11, a14, 0x200
4200f694:	9c4b      	addi.n	a9, a12, 4
4200f696:	272d87        	blt	a13, a8, 4200f6c1 <_vfiprintf_r+0xa05>
4200f699:	d81b      	addi.n	a13, a8, 1
4200f69b:	9161d2        	s32i	a13, a1, 0x244
4200f69e:	126b92        	s32i	a9, a11, 72
4200f6a1:	8d1c      	movi.n	a13, 24
4200f6a3:	052d97        	blt	a13, a9, 4200f6ac <_vfiprintf_r+0x9f0>
4200f6a6:	112bb2        	l32i	a11, a11, 68
4200f6a9:	000286        	j	4200f6b7 <_vfiprintf_r+0x9fb>
4200f6ac:	012dc7        	blt	a13, a12, 4200f6b1 <_vfiprintf_r+0x9f5>
4200f6af:	492c      	movi.n	a9, 36
4200f6b1:	902eb2        	l32i	a11, a14, 0x240
4200f6b4:	926e92        	s32i	a9, a14, 0x248
4200f6b7:	bb9a      	add.n	a11, a11, a9
4200f6b9:	fccbb2        	addi	a11, a11, -4
4200f6bc:	0b98      	l32i.n	a9, a11, 0
4200f6be:	007946        	j	4200f8a7 <_vfiprintf_r+0xbeb>
4200f6c1:	126b92        	s32i	a9, a11, 72
4200f6c4:	881c      	movi.n	a8, 24
4200f6c6:	062897        	blt	a8, a9, 4200f6d0 <_vfiprintf_r+0xa14>
4200f6c9:	112b82        	l32i	a8, a11, 68
4200f6cc:	0002c6        	j	4200f6db <_vfiprintf_r+0xa1f>
4200f6cf:	28c700        	lsi	f0, a7, 160
4200f6d2:	492c01        	l32r	a0, 41fe1b84 <_coredump_iram_end+0x1c5fc84>
4200f6d5:	902e82        	l32i	a8, a14, 0x240
4200f6d8:	926e92        	s32i	a9, a14, 0x248
4200f6db:	889a      	add.n	a8, a8, a9
4200f6dd:	007a46        	j	4200f8ca <_vfiprintf_r+0xc0e>
4200f6e0:	02e367        	bbsi	a3, 6, 4200f6e6 <_vfiprintf_r+0xa2a>
4200f6e3:	002946        	j	4200f78c <_vfiprintf_r+0xad0>
4200f6e6:	e4ac      	beqz.n	a4, 4200f718 <_vfiprintf_r+0xa5c>
4200f6e8:	09a687        	bge	a6, a8, 4200f6f5 <_vfiprintf_r+0xa39>
4200f6eb:	b0e6e0        	addx8	a14, a6, a14
4200f6ee:	0e98      	l32i.n	a9, a14, 0
4200f6f0:	000786        	j	4200f712 <_vfiprintf_r+0xa56>
4200f6f3:	820000        	mull	a0, a0, a0
4200f6f6:	8a30a2        	lsi	f10, a0, 0x228
4200f6f9:	8e          	.byte	0x8e
4200f6fa:	34a2d2        	movi	a13, 0x234
4200f6fd:	40a2c2        	movi	a12, 0x240
4200f700:	0189      	s32i.n	a8, a1, 0
4200f702:	01def2        	addmi	a15, a14, 0x100
4200f705:	deda      	add.n	a13, a14, a13
4200f707:	ceca      	add.n	a12, a14, a12
4200f709:	07bd      	mov.n	a11, a7
4200f70b:	06ad      	mov.n	a10, a6
4200f70d:	ff0ba5        	call8	4200e7c8 <get_arg$isra$0>
4200f710:	0a98      	l32i.n	a9, a10, 0
4200f712:	05ad      	mov.n	a10, a5
4200f714:	001a86        	j	4200f782 <_vfiprintf_r+0xac6>
4200f717:	a51b00        	extui	a1, a0, 27, 11
4200f71a:	07a587        	bge	a5, a8, 4200f725 <_vfiprintf_r+0xa69>
4200f71d:	b0e6e0        	addx8	a14, a6, a14
4200f720:	0e98      	l32i.n	a9, a14, 0
4200f722:	001706        	j	4200f782 <_vfiprintf_r+0xac6>
4200f725:	922ec2        	l32i	a12, a14, 0x248
4200f728:	fd1c      	movi.n	a13, 31
4200f72a:	02deb2        	addmi	a11, a14, 0x200
4200f72d:	9c4b      	addi.n	a9, a12, 4
4200f72f:	2d2d87        	blt	a13, a8, 4200f760 <_vfiprintf_r+0xaa4>
4200f732:	d81b      	addi.n	a13, a8, 1
4200f734:	9161d2        	s32i	a13, a1, 0x244
4200f737:	126b92        	s32i	a9, a11, 72
4200f73a:	8d1c      	movi.n	a13, 24
4200f73c:	052d97        	blt	a13, a9, 4200f745 <_vfiprintf_r+0xa89>
4200f73f:	112bb2        	l32i	a11, a11, 68
4200f742:	000286        	j	4200f750 <_vfiprintf_r+0xa94>
4200f745:	012dc7        	blt	a13, a12, 4200f74a <_vfiprintf_r+0xa8e>
4200f748:	492c      	movi.n	a9, 36
4200f74a:	902eb2        	l32i	a11, a14, 0x240
4200f74d:	926e92        	s32i	a9, a14, 0x248
4200f750:	bb9a      	add.n	a11, a11, a9
4200f752:	fccbb2        	addi	a11, a11, -4
4200f755:	0b98      	l32i.n	a9, a11, 0
4200f757:	b088e0        	addx8	a8, a8, a14
4200f75a:	0899      	s32i.n	a9, a8, 0
4200f75c:	000886        	j	4200f782 <_vfiprintf_r+0xac6>
4200f75f:	6b9200        	ole.s	b9, f2, f0
4200f762:	881c12        	l16ui	a1, a12, 0x110
4200f765:	072897        	blt	a8, a9, 4200f770 <_vfiprintf_r+0xab4>
4200f768:	112b82        	l32i	a8, a11, 68
4200f76b:	000306        	j	4200f77b <_vfiprintf_r+0xabf>
4200f76e:	c70000        	lsi	f0, a0, 0x31c
4200f771:	0128      	l32i.n	a2, a1, 0
4200f773:	492c      	movi.n	a9, 36
4200f775:	902e82        	l32i	a8, a14, 0x240
4200f778:	926e92        	s32i	a9, a14, 0x248
4200f77b:	889a      	add.n	a8, a8, a9
4200f77d:	fcc882        	addi	a8, a8, -4
4200f780:	0898      	l32i.n	a9, a8, 0
4200f782:	9d2182        	l32i	a8, a1, 0x274
4200f785:	005982        	s16i	a8, a9, 0
4200f788:	005206        	j	4200f8d4 <_vfiprintf_r+0xc18>
4200f78b:	e39700        	lsi	f0, a7, 0x38c
4200f78e:	294602        	s8i	a0, a6, 41
4200f791:	b4ac00        	extui	a10, a0, 12, 12
4200f794:	07a687        	bge	a6, a8, 4200f79f <_vfiprintf_r+0xae3>
4200f797:	b0e6e0        	addx8	a14, a6, a14
4200f79a:	0e98      	l32i.n	a9, a14, 0
4200f79c:	000706        	j	4200f7bc <_vfiprintf_r+0xb00>
4200f79f:	30a282        	movi	a8, 0x230
4200f7a2:	8e8a      	add.n	a8, a14, a8
4200f7a4:	34a2d2        	movi	a13, 0x234
4200f7a7:	40a2c2        	movi	a12, 0x240
4200f7aa:	0189      	s32i.n	a8, a1, 0
4200f7ac:	01def2        	addmi	a15, a14, 0x100
4200f7af:	deda      	add.n	a13, a14, a13
4200f7b1:	ceca      	add.n	a12, a14, a12
4200f7b3:	07bd      	mov.n	a11, a7
4200f7b5:	06ad      	mov.n	a10, a6
4200f7b7:	ff0125        	call8	4200e7c8 <get_arg$isra$0>
4200f7ba:	0a98      	l32i.n	a9, a10, 0
4200f7bc:	05ad      	mov.n	a10, a5
4200f7be:	001b06        	j	4200f82e <_vfiprintf_r+0xb72>
4200f7c1:	a51b      	addi.n	a10, a5, 1
4200f7c3:	09a587        	bge	a5, a8, 4200f7d0 <_vfiprintf_r+0xb14>
4200f7c6:	b0e6e0        	addx8	a14, a6, a14
4200f7c9:	0e98      	l32i.n	a9, a14, 0
4200f7cb:	0017c6        	j	4200f82e <_vfiprintf_r+0xb72>
4200f7ce:	c20000        	quou	a0, a0, a0
4200f7d1:	2e          	.byte	0x2e
4200f7d2:	fd1c92        	l16ui	a9, a12, 0x1fa
4200f7d5:	02deb2        	addmi	a11, a14, 0x200
4200f7d8:	9c4b      	addi.n	a9, a12, 4
4200f7da:	2e2d87        	blt	a13, a8, 4200f80c <_vfiprintf_r+0xb50>
4200f7dd:	d81b      	addi.n	a13, a8, 1
4200f7df:	9161d2        	s32i	a13, a1, 0x244
4200f7e2:	126b92        	s32i	a9, a11, 72
4200f7e5:	8d1c      	movi.n	a13, 24
4200f7e7:	052d97        	blt	a13, a9, 4200f7f0 <_vfiprintf_r+0xb34>
4200f7ea:	112bb2        	l32i	a11, a11, 68
4200f7ed:	000286        	j	4200f7fb <_vfiprintf_r+0xb3f>
4200f7f0:	012dc7        	blt	a13, a12, 4200f7f5 <_vfiprintf_r+0xb39>
4200f7f3:	492c      	movi.n	a9, 36
4200f7f5:	902eb2        	l32i	a11, a14, 0x240
4200f7f8:	926e92        	s32i	a9, a14, 0x248
4200f7fb:	bb9a      	add.n	a11, a11, a9
4200f7fd:	fccbb2        	addi	a11, a11, -4
4200f800:	0b98      	l32i.n	a9, a11, 0
4200f802:	b088e0        	addx8	a8, a8, a14
4200f805:	0899      	s32i.n	a9, a8, 0
4200f807:	0008c6        	j	4200f82e <_vfiprintf_r+0xb72>
4200f80a:	920000        	lsi	f0, a0, 0x248
4200f80d:	126b      	addi.n	a1, a2, 6
4200f80f:	881c      	movi.n	a8, 24
4200f811:	072897        	blt	a8, a9, 4200f81c <_vfiprintf_r+0xb60>
4200f814:	112b82        	l32i	a8, a11, 68
4200f817:	000306        	j	4200f827 <_vfiprintf_r+0xb6b>
4200f81a:	c70000        	lsi	f0, a0, 0x31c
4200f81d:	0128      	l32i.n	a2, a1, 0
4200f81f:	492c      	movi.n	a9, 36
4200f821:	902e82        	l32i	a8, a14, 0x240
4200f824:	926e92        	s32i	a9, a14, 0x248
4200f827:	889a      	add.n	a8, a8, a9
4200f829:	fcc882        	addi	a8, a8, -4
4200f82c:	0898      	l32i.n	a9, a8, 0
4200f82e:	9d2182        	l32i	a8, a1, 0x274
4200f831:	004982        	s8i	a8, a9, 0
4200f834:	002706        	j	4200f8d4 <_vfiprintf_r+0xc18>
4200f837:	c4ac00        	extui	a10, a0, 12, 13
4200f83a:	07a687        	bge	a6, a8, 4200f845 <_vfiprintf_r+0xb89>
4200f83d:	b0e6e0        	addx8	a14, a6, a14
4200f840:	0e98      	l32i.n	a9, a14, 0
4200f842:	000706        	j	4200f862 <_vfiprintf_r+0xba6>
4200f845:	30a282        	movi	a8, 0x230
4200f848:	8e8a      	add.n	a8, a14, a8
4200f84a:	34a2d2        	movi	a13, 0x234
4200f84d:	40a2c2        	movi	a12, 0x240
4200f850:	0189      	s32i.n	a8, a1, 0
4200f852:	01def2        	addmi	a15, a14, 0x100
4200f855:	deda      	add.n	a13, a14, a13
4200f857:	ceca      	add.n	a12, a14, a12
4200f859:	07bd      	mov.n	a11, a7
4200f85b:	06ad      	mov.n	a10, a6
4200f85d:	fef6a5        	call8	4200e7c8 <get_arg$isra$0>
4200f860:	0a98      	l32i.n	a9, a10, 0
4200f862:	05ad      	mov.n	a10, a5
4200f864:	0019c6        	j	4200f8cf <_vfiprintf_r+0xc13>
4200f867:	a51b00        	extui	a1, a0, 27, 11
4200f86a:	07a587        	bge	a5, a8, 4200f875 <_vfiprintf_r+0xbb9>
4200f86d:	b0e6e0        	addx8	a14, a6, a14
4200f870:	0e98      	l32i.n	a9, a14, 0
4200f872:	001646        	j	4200f8cf <_vfiprintf_r+0xc13>
4200f875:	922ec2        	l32i	a12, a14, 0x248
4200f878:	fd1c      	movi.n	a13, 31
4200f87a:	02de92        	addmi	a9, a14, 0x200
4200f87d:	bc4b      	addi.n	a11, a12, 4
4200f87f:	2c2d87        	blt	a13, a8, 4200f8af <_vfiprintf_r+0xbf3>
4200f882:	d81b      	addi.n	a13, a8, 1
4200f884:	9161d2        	s32i	a13, a1, 0x244
4200f887:	1269b2        	s32i	a11, a9, 72
4200f88a:	8d1c      	movi.n	a13, 24
4200f88c:	052db7        	blt	a13, a11, 4200f895 <_vfiprintf_r+0xbd9>
4200f88f:	112992        	l32i	a9, a9, 68
4200f892:	000286        	j	4200f8a0 <_vfiprintf_r+0xbe4>
4200f895:	012dc7        	blt	a13, a12, 4200f89a <_vfiprintf_r+0xbde>
4200f898:	4b2c      	movi.n	a11, 36
4200f89a:	902e92        	l32i	a9, a14, 0x240
4200f89d:	926eb2        	s32i	a11, a14, 0x248
4200f8a0:	99ba      	add.n	a9, a9, a11
4200f8a2:	fcc992        	addi	a9, a9, -4
4200f8a5:	0998      	l32i.n	a9, a9, 0
4200f8a7:	b088e0        	addx8	a8, a8, a14
4200f8aa:	0899      	s32i.n	a9, a8, 0
4200f8ac:	0007c6        	j	4200f8cf <_vfiprintf_r+0xc13>
4200f8af:	1269b2        	s32i	a11, a9, 72
4200f8b2:	881c      	movi.n	a8, 24
4200f8b4:	0528b7        	blt	a8, a11, 4200f8bd <_vfiprintf_r+0xc01>
4200f8b7:	112982        	l32i	a8, a9, 68
4200f8ba:	000286        	j	4200f8c8 <_vfiprintf_r+0xc0c>
4200f8bd:	0128c7        	blt	a8, a12, 4200f8c2 <_vfiprintf_r+0xc06>
4200f8c0:	4b2c      	movi.n	a11, 36
4200f8c2:	902e82        	l32i	a8, a14, 0x240
4200f8c5:	926eb2        	s32i	a11, a14, 0x248
4200f8c8:	88ba      	add.n	a8, a8, a11
4200f8ca:	fcc882        	addi	a8, a8, -4
4200f8cd:	0898      	l32i.n	a9, a8, 0
4200f8cf:	9d2182        	l32i	a8, a1, 0x274
4200f8d2:	0989      	s32i.n	a8, a9, 0
4200f8d4:	0a5d      	mov.n	a5, a10
4200f8d6:	fd3f86        	j	4200edd8 <_vfiprintf_r+0x11c>
4200f8d9:	081c      	movi.n	a8, 16
4200f8db:	203380        	or	a3, a3, a8
4200f8de:	912182        	l32i	a8, a1, 0x244
4200f8e1:	10c1e2        	addi	a14, a1, 16
4200f8e4:	02e357        	bbsi	a3, 5, 4200f8ea <_vfiprintf_r+0xc2e>
4200f8e7:	002f86        	j	4200f9a9 <_vfiprintf_r+0xced>
4200f8ea:	f4ac      	beqz.n	a4, 4200f91d <_vfiprintf_r+0xc61>
4200f8ec:	09a687        	bge	a6, a8, 4200f8f9 <_vfiprintf_r+0xc3d>
4200f8ef:	b0e6e0        	addx8	a14, a6, a14
4200f8f2:	0e48      	l32i.n	a4, a14, 0
4200f8f4:	1e28      	l32i.n	a2, a14, 4
4200f8f6:	000786        	j	4200f918 <_vfiprintf_r+0xc5c>
4200f8f9:	30a282        	movi	a8, 0x230
4200f8fc:	8e8a      	add.n	a8, a14, a8
4200f8fe:	34a2d2        	movi	a13, 0x234
4200f901:	40a2c2        	movi	a12, 0x240
4200f904:	0189      	s32i.n	a8, a1, 0
4200f906:	01def2        	addmi	a15, a14, 0x100
4200f909:	deda      	add.n	a13, a14, a13
4200f90b:	ceca      	add.n	a12, a14, a12
4200f90d:	07bd      	mov.n	a11, a7
4200f90f:	06ad      	mov.n	a10, a6
4200f911:	feeb65        	call8	4200e7c8 <get_arg$isra$0>
4200f914:	0a48      	l32i.n	a4, a10, 0
4200f916:	1a28      	l32i.n	a2, a10, 4
4200f918:	057d      	mov.n	a7, a5
4200f91a:	00a806        	j	4200fbbe <_vfiprintf_r+0xf02>
4200f91d:	751b      	addi.n	a7, a5, 1
4200f91f:	09a587        	bge	a5, a8, 4200f92c <_vfiprintf_r+0xc70>
4200f922:	b0e6e0        	addx8	a14, a6, a14
4200f925:	0e48      	l32i.n	a4, a14, 0
4200f927:	1e28      	l32i.n	a2, a14, 4
4200f929:	00a446        	j	4200fbbe <_vfiprintf_r+0xf02>
4200f92c:	922e92        	l32i	a9, a14, 0x248
4200f92f:	8a7c      	movi.n	a10, -8
4200f931:	997b      	addi.n	a9, a9, 7
4200f933:	1099a0        	and	a9, a9, a10
4200f936:	fb1c      	movi.n	a11, 31
4200f938:	02dee2        	addmi	a14, a14, 0x200
4200f93b:	a98b      	addi.n	a10, a9, 8
4200f93d:	3b2b87        	blt	a11, a8, 4200f97c <_vfiprintf_r+0xcc0>
4200f940:	b81b      	addi.n	a11, a8, 1
4200f942:	9161b2        	s32i	a11, a1, 0x244
4200f945:	126ea2        	s32i	a10, a14, 72
4200f948:	8b1c      	movi.n	a11, 24
4200f94a:	062ba7        	blt	a11, a10, 4200f954 <_vfiprintf_r+0xc98>
4200f94d:	112e92        	l32i	a9, a14, 68
4200f950:	000446        	j	4200f965 <_vfiprintf_r+0xca9>
4200f953:	2b9700        	oeq.s	b9, f7, f0
4200f956:	8a2c01        	l32r	a0, 41ff2208 <_coredump_iram_end+0x1c70308>
4200f959:	10c192        	addi	a9, a1, 16
4200f95c:	02d992        	addmi	a9, a9, 0x200
4200f95f:	102992        	l32i	a9, a9, 64
4200f962:	9661a2        	s32i	a10, a1, 0x258
4200f965:	99aa      	add.n	a9, a9, a10
4200f967:	f8c992        	addi	a9, a9, -8
4200f96a:	0948      	l32i.n	a4, a9, 0
4200f96c:	1928      	l32i.n	a2, a9, 4
4200f96e:	10c192        	addi	a9, a1, 16
4200f971:	b08890        	addx8	a8, a8, a9
4200f974:	0849      	s32i.n	a4, a8, 0
4200f976:	1829      	s32i.n	a2, a8, 4
4200f978:	009086        	j	4200fbbe <_vfiprintf_r+0xf02>
4200f97b:	6ea200        	f64rnd	a10, a2, a0, 2
4200f97e:	881c12        	l16ui	a1, a12, 0x110
4200f981:	0728a7        	blt	a8, a10, 4200f98c <_vfiprintf_r+0xcd0>
4200f984:	112e82        	l32i	a8, a14, 68
4200f987:	000486        	j	4200f99d <_vfiprintf_r+0xce1>
4200f98a:	970000        	lsi	f0, a0, 0x25c
4200f98d:	0128      	l32i.n	a2, a1, 0
4200f98f:	8a2c      	movi.n	a10, 40
4200f991:	10c182        	addi	a8, a1, 16
4200f994:	02d882        	addmi	a8, a8, 0x200
4200f997:	102882        	l32i	a8, a8, 64
4200f99a:	9661a2        	s32i	a10, a1, 0x258
4200f99d:	88aa      	add.n	a8, a8, a10
4200f99f:	f8c882        	addi	a8, a8, -8
4200f9a2:	0848      	l32i.n	a4, a8, 0
4200f9a4:	1828      	l32i.n	a2, a8, 4
4200f9a6:	008506        	j	4200fbbe <_vfiprintf_r+0xf02>
4200f9a9:	036347        	bbci	a3, 4, 4200f9b0 <_vfiprintf_r+0xcf4>
4200f9ac:	005946        	j	4200fb15 <_vfiprintf_r+0xe59>
4200f9af:	e36700        	lsi	f0, a7, 0x38c
4200f9b2:	2b4602        	s8i	a0, a6, 43
4200f9b5:	c4ac00        	extui	a10, a0, 12, 13
4200f9b8:	08a687        	bge	a6, a8, 4200f9c4 <_vfiprintf_r+0xd08>
4200f9bb:	b0e6e0        	addx8	a14, a6, a14
4200f9be:	001e42        	l16ui	a4, a14, 0
4200f9c1:	005f46        	j	4200fb42 <_vfiprintf_r+0xe86>
4200f9c4:	30a282        	movi	a8, 0x230
4200f9c7:	8e8a      	add.n	a8, a14, a8
4200f9c9:	34a2d2        	movi	a13, 0x234
4200f9cc:	40a2c2        	movi	a12, 0x240
4200f9cf:	0189      	s32i.n	a8, a1, 0
4200f9d1:	01def2        	addmi	a15, a14, 0x100
4200f9d4:	deda      	add.n	a13, a14, a13
4200f9d6:	ceca      	add.n	a12, a14, a12
4200f9d8:	07bd      	mov.n	a11, a7
4200f9da:	20a660        	or	a10, a6, a6
4200f9dd:	fedea5        	call8	4200e7c8 <get_arg$isra$0>
4200f9e0:	001a42        	l16ui	a4, a10, 0
4200f9e3:	0056c6        	j	4200fb42 <_vfiprintf_r+0xe86>
4200f9e6:	751b      	addi.n	a7, a5, 1
4200f9e8:	08a587        	bge	a5, a8, 4200f9f4 <_vfiprintf_r+0xd38>
4200f9eb:	b0e6e0        	addx8	a14, a6, a14
4200f9ee:	001e42        	l16ui	a4, a14, 0
4200f9f1:	0071c6        	j	4200fbbc <_vfiprintf_r+0xf00>
4200f9f4:	922e92        	l32i	a9, a14, 0x248
4200f9f7:	fb1c      	movi.n	a11, 31
4200f9f9:	02dee2        	addmi	a14, a14, 0x200
4200f9fc:	a94b      	addi.n	a10, a9, 4
4200f9fe:	362b87        	blt	a11, a8, 4200fa38 <_vfiprintf_r+0xd7c>
4200fa01:	b81b      	addi.n	a11, a8, 1
4200fa03:	9161b2        	s32i	a11, a1, 0x244
4200fa06:	126ea2        	s32i	a10, a14, 72
4200fa09:	8b1c      	movi.n	a11, 24
4200fa0b:	052ba7        	blt	a11, a10, 4200fa14 <_vfiprintf_r+0xd58>
4200fa0e:	112e92        	l32i	a9, a14, 68
4200fa11:	000406        	j	4200fa25 <_vfiprintf_r+0xd69>
4200fa14:	012b97        	blt	a11, a9, 4200fa19 <_vfiprintf_r+0xd5d>
4200fa17:	4a2c      	movi.n	a10, 36
4200fa19:	10c192        	addi	a9, a1, 16
4200fa1c:	02d992        	addmi	a9, a9, 0x200
4200fa1f:	102992        	l32i	a9, a9, 64
4200fa22:	9661a2        	s32i	a10, a1, 0x258
4200fa25:	99aa      	add.n	a9, a9, a10
4200fa27:	fcc992        	addi	a9, a9, -4
4200fa2a:	0948      	l32i.n	a4, a9, 0
4200fa2c:	b08810        	addx8	a8, a8, a1
4200fa2f:	4849      	s32i.n	a4, a8, 16
4200fa31:	f44040        	extui	a4, a4, 0, 16
4200fa34:	006106        	j	4200fbbc <_vfiprintf_r+0xf00>
4200fa37:	6ea200        	f64rnd	a10, a2, a0, 2
4200fa3a:	881c12        	l16ui	a1, a12, 0x110
4200fa3d:	0728a7        	blt	a8, a10, 4200fa48 <_vfiprintf_r+0xd8c>
4200fa40:	112e82        	l32i	a8, a14, 68
4200fa43:	000486        	j	4200fa59 <_vfiprintf_r+0xd9d>
4200fa46:	970000        	lsi	f0, a0, 0x25c
4200fa49:	0128      	l32i.n	a2, a1, 0
4200fa4b:	4a2c      	movi.n	a10, 36
4200fa4d:	10c182        	addi	a8, a1, 16
4200fa50:	02d882        	addmi	a8, a8, 0x200
4200fa53:	102882        	l32i	a8, a8, 64
4200fa56:	9661a2        	s32i	a10, a1, 0x258
4200fa59:	88aa      	add.n	a8, a8, a10
4200fa5b:	fcc882        	addi	a8, a8, -4
4200fa5e:	001842        	l16ui	a4, a8, 0
4200fa61:	0055c6        	j	4200fbbc <_vfiprintf_r+0xf00>
4200fa64:	02e397        	bbsi	a3, 9, 4200fa6a <_vfiprintf_r+0xdae>
4200fa67:	002a86        	j	4200fb15 <_vfiprintf_r+0xe59>
4200fa6a:	c4ac      	beqz.n	a4, 4200fa9a <_vfiprintf_r+0xdde>
4200fa6c:	09a687        	bge	a6, a8, 4200fa79 <_vfiprintf_r+0xdbd>
4200fa6f:	b0e6e0        	addx8	a14, a6, a14
4200fa72:	000e42        	l8ui	a4, a14, 0
4200fa75:	003246        	j	4200fb42 <_vfiprintf_r+0xe86>
4200fa78:	a28200        	muluh	a8, a2, a0
4200fa7b:	8e8a30        	f64iter	a8, a10, a3, 0, 0
4200fa7e:	34a2d2        	movi	a13, 0x234
4200fa81:	40a2c2        	movi	a12, 0x240
4200fa84:	0189      	s32i.n	a8, a1, 0
4200fa86:	01def2        	addmi	a15, a14, 0x100
4200fa89:	deda      	add.n	a13, a14, a13
4200fa8b:	ceca      	add.n	a12, a14, a12
4200fa8d:	07bd      	mov.n	a11, a7
4200fa8f:	06ad      	mov.n	a10, a6
4200fa91:	fed365        	call8	4200e7c8 <get_arg$isra$0>
4200fa94:	000a42        	l8ui	a4, a10, 0
4200fa97:	0029c6        	j	4200fb42 <_vfiprintf_r+0xe86>
4200fa9a:	751b      	addi.n	a7, a5, 1
4200fa9c:	08a587        	bge	a5, a8, 4200faa8 <_vfiprintf_r+0xdec>
4200fa9f:	b0e6e0        	addx8	a14, a6, a14
4200faa2:	000e42        	l8ui	a4, a14, 0
4200faa5:	0044c6        	j	4200fbbc <_vfiprintf_r+0xf00>
4200faa8:	922e92        	l32i	a9, a14, 0x248
4200faab:	fb1c      	movi.n	a11, 31
4200faad:	02dee2        	addmi	a14, a14, 0x200
4200fab0:	a94b      	addi.n	a10, a9, 4
4200fab2:	352b87        	blt	a11, a8, 4200faeb <_vfiprintf_r+0xe2f>
4200fab5:	b81b      	addi.n	a11, a8, 1
4200fab7:	9161b2        	s32i	a11, a1, 0x244
4200faba:	126ea2        	s32i	a10, a14, 72
4200fabd:	8b1c      	movi.n	a11, 24
4200fabf:	052ba7        	blt	a11, a10, 4200fac8 <_vfiprintf_r+0xe0c>
4200fac2:	112e92        	l32i	a9, a14, 68
4200fac5:	000406        	j	4200fad9 <_vfiprintf_r+0xe1d>
4200fac8:	012b97        	blt	a11, a9, 4200facd <_vfiprintf_r+0xe11>
4200facb:	4a2c      	movi.n	a10, 36
4200facd:	10c192        	addi	a9, a1, 16
4200fad0:	02d992        	addmi	a9, a9, 0x200
4200fad3:	102992        	l32i	a9, a9, 64
4200fad6:	9661a2        	s32i	a10, a1, 0x258
4200fad9:	99aa      	add.n	a9, a9, a10
4200fadb:	fcc992        	addi	a9, a9, -4
4200fade:	0948      	l32i.n	a4, a9, 0
4200fae0:	b08810        	addx8	a8, a8, a1
4200fae3:	4849      	s32i.n	a4, a8, 16
4200fae5:	744040        	extui	a4, a4, 0, 8
4200fae8:	003406        	j	4200fbbc <_vfiprintf_r+0xf00>
4200faeb:	126ea2        	s32i	a10, a14, 72
4200faee:	881c      	movi.n	a8, 24
4200faf0:	0528a7        	blt	a8, a10, 4200faf9 <_vfiprintf_r+0xe3d>
4200faf3:	112e82        	l32i	a8, a14, 68
4200faf6:	000406        	j	4200fb0a <_vfiprintf_r+0xe4e>
4200faf9:	012897        	blt	a8, a9, 4200fafe <_vfiprintf_r+0xe42>
4200fafc:	4a2c      	movi.n	a10, 36
4200fafe:	10c182        	addi	a8, a1, 16
4200fb01:	02d882        	addmi	a8, a8, 0x200
4200fb04:	102882        	l32i	a8, a8, 64
4200fb07:	9661a2        	s32i	a10, a1, 0x258
4200fb0a:	88aa      	add.n	a8, a8, a10
4200fb0c:	fcc882        	addi	a8, a8, -4
4200fb0f:	000842        	l8ui	a4, a8, 0
4200fb12:	002986        	j	4200fbbc <_vfiprintf_r+0xf00>
4200fb15:	f4ac      	beqz.n	a4, 4200fb48 <_vfiprintf_r+0xe8c>
4200fb17:	0aa687        	bge	a6, a8, 4200fb25 <_vfiprintf_r+0xe69>
4200fb1a:	b0e6e0        	addx8	a14, a6, a14
4200fb1d:	0e48      	l32i.n	a4, a14, 0
4200fb1f:	0007c6        	j	4200fb42 <_vfiprintf_r+0xe86>
4200fb22:	000000        	ill
4200fb25:	30a282        	movi	a8, 0x230
4200fb28:	8e8a      	add.n	a8, a14, a8
4200fb2a:	34a2d2        	movi	a13, 0x234
4200fb2d:	40a2c2        	movi	a12, 0x240
4200fb30:	0189      	s32i.n	a8, a1, 0
4200fb32:	01def2        	addmi	a15, a14, 0x100
4200fb35:	deda      	add.n	a13, a14, a13
4200fb37:	ceca      	add.n	a12, a14, a12
4200fb39:	07bd      	mov.n	a11, a7
4200fb3b:	06ad      	mov.n	a10, a6
4200fb3d:	fec8a5        	call8	4200e7c8 <get_arg$isra$0>
4200fb40:	0a48      	l32i.n	a4, a10, 0
4200fb42:	057d      	mov.n	a7, a5
4200fb44:	001d06        	j	4200fbbc <_vfiprintf_r+0xf00>
4200fb47:	751b00        	extui	a1, a0, 27, 8
4200fb4a:	07a587        	bge	a5, a8, 4200fb55 <_vfiprintf_r+0xe99>
4200fb4d:	b0e6e0        	addx8	a14, a6, a14
4200fb50:	0e48      	l32i.n	a4, a14, 0
4200fb52:	001986        	j	4200fbbc <_vfiprintf_r+0xf00>
4200fb55:	922e92        	l32i	a9, a14, 0x248
4200fb58:	fb1c      	movi.n	a11, 31
4200fb5a:	02dee2        	addmi	a14, a14, 0x200
4200fb5d:	a94b      	addi.n	a10, a9, 4
4200fb5f:	322b87        	blt	a11, a8, 4200fb95 <_vfiprintf_r+0xed9>
4200fb62:	b81b      	addi.n	a11, a8, 1
4200fb64:	9161b2        	s32i	a11, a1, 0x244
4200fb67:	126ea2        	s32i	a10, a14, 72
4200fb6a:	8b1c      	movi.n	a11, 24
4200fb6c:	052ba7        	blt	a11, a10, 4200fb75 <_vfiprintf_r+0xeb9>
4200fb6f:	112e92        	l32i	a9, a14, 68
4200fb72:	000406        	j	4200fb86 <_vfiprintf_r+0xeca>
4200fb75:	012b97        	blt	a11, a9, 4200fb7a <_vfiprintf_r+0xebe>
4200fb78:	4a2c      	movi.n	a10, 36
4200fb7a:	10c192        	addi	a9, a1, 16
4200fb7d:	02d992        	addmi	a9, a9, 0x200
4200fb80:	102992        	l32i	a9, a9, 64
4200fb83:	9661a2        	s32i	a10, a1, 0x258
4200fb86:	99aa      	add.n	a9, a9, a10
4200fb88:	fcc992        	addi	a9, a9, -4
4200fb8b:	0948      	l32i.n	a4, a9, 0
4200fb8d:	b08810        	addx8	a8, a8, a1
4200fb90:	4849      	s32i.n	a4, a8, 16
4200fb92:	000986        	j	4200fbbc <_vfiprintf_r+0xf00>
4200fb95:	126ea2        	s32i	a10, a14, 72
4200fb98:	881c      	movi.n	a8, 24
4200fb9a:	0628a7        	blt	a8, a10, 4200fba4 <_vfiprintf_r+0xee8>
4200fb9d:	112e82        	l32i	a8, a14, 68
4200fba0:	000446        	j	4200fbb5 <_vfiprintf_r+0xef9>
4200fba3:	289700        	lsi	f0, a7, 160
4200fba6:	4a2c01        	l32r	a0, 41fe2458 <_coredump_iram_end+0x1c60558>
4200fba9:	10c182        	addi	a8, a1, 16
4200fbac:	02d882        	addmi	a8, a8, 0x200
4200fbaf:	102882        	l32i	a8, a8, 64
4200fbb2:	9661a2        	s32i	a10, a1, 0x258
4200fbb5:	88aa      	add.n	a8, a8, a10
4200fbb7:	fcc882        	addi	a8, a8, -4
4200fbba:	0848      	l32i.n	a4, a8, 0
4200fbbc:	020c      	movi.n	a2, 0
4200fbbe:	ffab82        	movi	a8, 0xfffffbff
4200fbc1:	103380        	and	a3, a3, a8
4200fbc4:	080c      	movi.n	a8, 0
4200fbc6:	01edc6        	j	42010381 <_vfiprintf_r+0x16c5>
4200fbc9:	218200        	srai	a8, a0, 2
4200fbcc:	c1e291        	l32r	a9, 42000354 <_stext+0x334> (3c0209e0 <_flash_rodata_start+0x8c0>)
4200fbcf:	b4ac10        	extui	a10, a1, 12, 12
4200fbd2:	07a687        	bge	a6, a8, 4200fbdd <_vfiprintf_r+0xf21>
4200fbd5:	b0e6e0        	addx8	a14, a6, a14
4200fbd8:	0e48      	l32i.n	a4, a14, 0
4200fbda:	000706        	j	4200fbfa <_vfiprintf_r+0xf3e>
4200fbdd:	30a282        	movi	a8, 0x230
4200fbe0:	8e8a      	add.n	a8, a14, a8
4200fbe2:	34a2d2        	movi	a13, 0x234
4200fbe5:	40a2c2        	movi	a12, 0x240
4200fbe8:	0189      	s32i.n	a8, a1, 0
4200fbea:	01def2        	addmi	a15, a14, 0x100
4200fbed:	deda      	add.n	a13, a14, a13
4200fbef:	ceca      	add.n	a12, a14, a12
4200fbf1:	07bd      	mov.n	a11, a7
4200fbf3:	06ad      	mov.n	a10, a6
4200fbf5:	febd25        	call8	4200e7c8 <get_arg$isra$0>
4200fbf8:	0a48      	l32i.n	a4, a10, 0
4200fbfa:	057d      	mov.n	a7, a5
4200fbfc:	001d06        	j	4200fc74 <_vfiprintf_r+0xfb8>
4200fbff:	751b      	addi.n	a7, a5, 1
4200fc01:	07a587        	bge	a5, a8, 4200fc0c <_vfiprintf_r+0xf50>
4200fc04:	b0e6e0        	addx8	a14, a6, a14
4200fc07:	0e48      	l32i.n	a4, a14, 0
4200fc09:	0019c6        	j	4200fc74 <_vfiprintf_r+0xfb8>
4200fc0c:	922e92        	l32i	a9, a14, 0x248
4200fc0f:	fb1c      	movi.n	a11, 31
4200fc11:	02dee2        	addmi	a14, a14, 0x200
4200fc14:	a94b      	addi.n	a10, a9, 4
4200fc16:	322b87        	blt	a11, a8, 4200fc4c <_vfiprintf_r+0xf90>
4200fc19:	b81b      	addi.n	a11, a8, 1
4200fc1b:	9161b2        	s32i	a11, a1, 0x244
4200fc1e:	126ea2        	s32i	a10, a14, 72
4200fc21:	8b1c      	movi.n	a11, 24
4200fc23:	052ba7        	blt	a11, a10, 4200fc2c <_vfiprintf_r+0xf70>
4200fc26:	112e92        	l32i	a9, a14, 68
4200fc29:	000406        	j	4200fc3d <_vfiprintf_r+0xf81>
4200fc2c:	012b97        	blt	a11, a9, 4200fc31 <_vfiprintf_r+0xf75>
4200fc2f:	4a2c      	movi.n	a10, 36
4200fc31:	10c192        	addi	a9, a1, 16
4200fc34:	02d992        	addmi	a9, a9, 0x200
4200fc37:	102992        	l32i	a9, a9, 64
4200fc3a:	9661a2        	s32i	a10, a1, 0x258
4200fc3d:	99aa      	add.n	a9, a9, a10
4200fc3f:	fcc992        	addi	a9, a9, -4
4200fc42:	0948      	l32i.n	a4, a9, 0
4200fc44:	b08810        	addx8	a8, a8, a1
4200fc47:	4849      	s32i.n	a4, a8, 16
4200fc49:	0009c6        	j	4200fc74 <_vfiprintf_r+0xfb8>
4200fc4c:	126ea2        	s32i	a10, a14, 72
4200fc4f:	881c      	movi.n	a8, 24
4200fc51:	0728a7        	blt	a8, a10, 4200fc5c <_vfiprintf_r+0xfa0>
4200fc54:	112e82        	l32i	a8, a14, 68
4200fc57:	000486        	j	4200fc6d <_vfiprintf_r+0xfb1>
4200fc5a:	970000        	lsi	f0, a0, 0x25c
4200fc5d:	0128      	l32i.n	a2, a1, 0
4200fc5f:	4a2c      	movi.n	a10, 36
4200fc61:	10c182        	addi	a8, a1, 16
4200fc64:	02d882        	addmi	a8, a8, 0x200
4200fc67:	102882        	l32i	a8, a8, 64
4200fc6a:	9661a2        	s32i	a10, a1, 0x258
4200fc6d:	88aa      	add.n	a8, a8, a10
4200fc6f:	fcc882        	addi	a8, a8, -4
4200fc72:	0848      	l32i.n	a4, a8, 0
4200fc74:	280c      	movi.n	a8, 2
4200fc76:	203380        	or	a3, a3, a8
4200fc79:	10c182        	addi	a8, a1, 16
4200fc7c:	02d882        	addmi	a8, a8, 0x200
4200fc7f:	093c      	movi.n	a9, 48
4200fc81:	384892        	s8i	a9, a8, 56
4200fc84:	78a092        	movi	a9, 120
4200fc87:	394892        	s8i	a9, a8, 57
4200fc8a:	c43181        	l32r	a8, 42000d50 <_stext+0xd30> (3c02915e <Xthal_intlevel+0x32>)
4200fc8d:	020c      	movi.n	a2, 0
4200fc8f:	a16182        	s32i	a8, a1, 0x284
4200fc92:	01ba46        	j	4201037f <_vfiprintf_r+0x16c3>
4200fc95:	218200        	srai	a8, a0, 2
4200fc98:	c1e291        	l32r	a9, 42000420 <_stext+0x400> (3c027080 <esp_err_msg_table>)
4200fc9b:	c4ac10        	extui	a10, a1, 12, 13
4200fc9e:	07a687        	bge	a6, a8, 4200fca9 <_vfiprintf_r+0xfed>
4200fca1:	b0e6e0        	addx8	a14, a6, a14
4200fca4:	0e68      	l32i.n	a6, a14, 0
4200fca6:	000706        	j	4200fcc6 <_vfiprintf_r+0x100a>
4200fca9:	30a282        	movi	a8, 0x230
4200fcac:	8e8a      	add.n	a8, a14, a8
4200fcae:	34a2d2        	movi	a13, 0x234
4200fcb1:	40a2c2        	movi	a12, 0x240
4200fcb4:	06ad      	mov.n	a10, a6
4200fcb6:	0189      	s32i.n	a8, a1, 0
4200fcb8:	01def2        	addmi	a15, a14, 0x100
4200fcbb:	deda      	add.n	a13, a14, a13
4200fcbd:	ceca      	add.n	a12, a14, a12
4200fcbf:	07bd      	mov.n	a11, a7
4200fcc1:	feb065        	call8	4200e7c8 <get_arg$isra$0>
4200fcc4:	0a68      	l32i.n	a6, a10, 0
4200fcc6:	057d      	mov.n	a7, a5
4200fcc8:	001cc6        	j	4200fd3f <_vfiprintf_r+0x1083>
4200fccb:	751b00        	extui	a1, a0, 27, 8
4200fcce:	07a587        	bge	a5, a8, 4200fcd9 <_vfiprintf_r+0x101d>
4200fcd1:	b0e6e0        	addx8	a14, a6, a14
4200fcd4:	0e68      	l32i.n	a6, a14, 0
4200fcd6:	001946        	j	4200fd3f <_vfiprintf_r+0x1083>
4200fcd9:	922e92        	l32i	a9, a14, 0x248
4200fcdc:	fb1c      	movi.n	a11, 31
4200fcde:	02dee2        	addmi	a14, a14, 0x200
4200fce1:	a94b      	addi.n	a10, a9, 4
4200fce3:	322b87        	blt	a11, a8, 4200fd19 <_vfiprintf_r+0x105d>
4200fce6:	b81b      	addi.n	a11, a8, 1
4200fce8:	9161b2        	s32i	a11, a1, 0x244
4200fceb:	126ea2        	s32i	a10, a14, 72
4200fcee:	8b1c      	movi.n	a11, 24
4200fcf0:	052ba7        	blt	a11, a10, 4200fcf9 <_vfiprintf_r+0x103d>
4200fcf3:	112e92        	l32i	a9, a14, 68
4200fcf6:	000406        	j	4200fd0a <_vfiprintf_r+0x104e>
4200fcf9:	012b97        	blt	a11, a9, 4200fcfe <_vfiprintf_r+0x1042>
4200fcfc:	4a2c      	movi.n	a10, 36
4200fcfe:	10c192        	addi	a9, a1, 16
4200fd01:	02d992        	addmi	a9, a9, 0x200
4200fd04:	102992        	l32i	a9, a9, 64
4200fd07:	9661a2        	s32i	a10, a1, 0x258
4200fd0a:	99aa      	add.n	a9, a9, a10
4200fd0c:	fcc992        	addi	a9, a9, -4
4200fd0f:	0968      	l32i.n	a6, a9, 0
4200fd11:	b08810        	addx8	a8, a8, a1
4200fd14:	4869      	s32i.n	a6, a8, 16
4200fd16:	000946        	j	4200fd3f <_vfiprintf_r+0x1083>
4200fd19:	126ea2        	s32i	a10, a14, 72
4200fd1c:	881c      	movi.n	a8, 24
4200fd1e:	0528a7        	blt	a8, a10, 4200fd27 <_vfiprintf_r+0x106b>
4200fd21:	112e82        	l32i	a8, a14, 68
4200fd24:	000406        	j	4200fd38 <_vfiprintf_r+0x107c>
4200fd27:	012897        	blt	a8, a9, 4200fd2c <_vfiprintf_r+0x1070>
4200fd2a:	4a2c      	movi.n	a10, 36
4200fd2c:	10c182        	addi	a8, a1, 16
4200fd2f:	02d882        	addmi	a8, a8, 0x200
4200fd32:	102882        	l32i	a8, a8, 64
4200fd35:	9661a2        	s32i	a10, a1, 0x258
4200fd38:	88aa      	add.n	a8, a8, a10
4200fd3a:	fcc882        	addi	a8, a8, -4
4200fd3d:	0868      	l32i.n	a6, a8, 0
4200fd3f:	10c182        	addi	a8, a1, 16
4200fd42:	02d882        	addmi	a8, a8, 0x200
4200fd45:	090c      	movi.n	a9, 0
4200fd47:	3a4892        	s8i	a9, a8, 58
4200fd4a:	9a2182        	l32i	a8, a1, 0x268
4200fd4d:	017896        	bltz	a8, 4200fd68 <_vfiprintf_r+0x10ac>
4200fd50:	08cd      	mov.n	a12, a8
4200fd52:	0b0c      	movi.n	a11, 0
4200fd54:	06ad      	mov.n	a10, a6
4200fd56:	c3d281        	l32r	a8, 42000ca0 <_stext+0xc80> (40001344 <memchr>)
4200fd59:	0008e0        	callx8	a8
4200fd5c:	050c      	movi.n	a5, 0
4200fd5e:	c08a60        	sub	a8, a10, a6
4200fd61:	7b8a56        	bnez	a10, 4201051d <_vfiprintf_r+0x1861>
4200fd64:	01f8c6        	j	4201054b <_vfiprintf_r+0x188f>
4200fd67:	06ad00        	lsi	f0, a13, 24
4200fd6a:	c14c81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
4200fd6d:	0008e0        	callx8	a8
4200fd70:	9a61a2        	s32i	a10, a1, 0x268
4200fd73:	050c      	movi.n	a5, 0
4200fd75:	01f486        	j	4201054b <_vfiprintf_r+0x188f>
4200fd78:	081c00        	lsx	f1, a12, a0
4200fd7b:	203380        	or	a3, a3, a8
4200fd7e:	912182        	l32i	a8, a1, 0x244
4200fd81:	10c1e2        	addi	a14, a1, 16
4200fd84:	02e357        	bbsi	a3, 5, 4200fd8a <_vfiprintf_r+0x10ce>
4200fd87:	002f86        	j	4200fe49 <_vfiprintf_r+0x118d>
4200fd8a:	f4ac      	beqz.n	a4, 4200fdbd <_vfiprintf_r+0x1101>
4200fd8c:	09a687        	bge	a6, a8, 4200fd99 <_vfiprintf_r+0x10dd>
4200fd8f:	b0e6e0        	addx8	a14, a6, a14
4200fd92:	0e48      	l32i.n	a4, a14, 0
4200fd94:	1e28      	l32i.n	a2, a14, 4
4200fd96:	000786        	j	4200fdb8 <_vfiprintf_r+0x10fc>
4200fd99:	30a282        	movi	a8, 0x230
4200fd9c:	8e8a      	add.n	a8, a14, a8
4200fd9e:	34a2d2        	movi	a13, 0x234
4200fda1:	40a2c2        	movi	a12, 0x240
4200fda4:	0189      	s32i.n	a8, a1, 0
4200fda6:	01def2        	addmi	a15, a14, 0x100
4200fda9:	deda      	add.n	a13, a14, a13
4200fdab:	ceca      	add.n	a12, a14, a12
4200fdad:	07bd      	mov.n	a11, a7
4200fdaf:	06ad      	mov.n	a10, a6
4200fdb1:	fea165        	call8	4200e7c8 <get_arg$isra$0>
4200fdb4:	0a48      	l32i.n	a4, a10, 0
4200fdb6:	1a28      	l32i.n	a2, a10, 4
4200fdb8:	057d      	mov.n	a7, a5
4200fdba:	007d86        	j	4200ffb4 <_vfiprintf_r+0x12f8>
4200fdbd:	751b      	addi.n	a7, a5, 1
4200fdbf:	09a587        	bge	a5, a8, 4200fdcc <_vfiprintf_r+0x1110>
4200fdc2:	b0e6e0        	addx8	a14, a6, a14
4200fdc5:	0e48      	l32i.n	a4, a14, 0
4200fdc7:	1e28      	l32i.n	a2, a14, 4
4200fdc9:	0079c6        	j	4200ffb4 <_vfiprintf_r+0x12f8>
4200fdcc:	922e92        	l32i	a9, a14, 0x248
4200fdcf:	8a7c      	movi.n	a10, -8
4200fdd1:	997b      	addi.n	a9, a9, 7
4200fdd3:	1099a0        	and	a9, a9, a10
4200fdd6:	fb1c      	movi.n	a11, 31
4200fdd8:	02dee2        	addmi	a14, a14, 0x200
4200fddb:	a98b      	addi.n	a10, a9, 8
4200fddd:	3b2b87        	blt	a11, a8, 4200fe1c <_vfiprintf_r+0x1160>
4200fde0:	b81b      	addi.n	a11, a8, 1
4200fde2:	9161b2        	s32i	a11, a1, 0x244
4200fde5:	126ea2        	s32i	a10, a14, 72
4200fde8:	8b1c      	movi.n	a11, 24
4200fdea:	062ba7        	blt	a11, a10, 4200fdf4 <_vfiprintf_r+0x1138>
4200fded:	112e92        	l32i	a9, a14, 68
4200fdf0:	000446        	j	4200fe05 <_vfiprintf_r+0x1149>
4200fdf3:	2b9700        	oeq.s	b9, f7, f0
4200fdf6:	8a2c01        	l32r	a0, 41ff26a8 <_coredump_iram_end+0x1c707a8>
4200fdf9:	10c192        	addi	a9, a1, 16
4200fdfc:	02d992        	addmi	a9, a9, 0x200
4200fdff:	102992        	l32i	a9, a9, 64
4200fe02:	9661a2        	s32i	a10, a1, 0x258
4200fe05:	99aa      	add.n	a9, a9, a10
4200fe07:	f8c992        	addi	a9, a9, -8
4200fe0a:	0948      	l32i.n	a4, a9, 0
4200fe0c:	1928      	l32i.n	a2, a9, 4
4200fe0e:	10c192        	addi	a9, a1, 16
4200fe11:	b08890        	addx8	a8, a8, a9
4200fe14:	0849      	s32i.n	a4, a8, 0
4200fe16:	1829      	s32i.n	a2, a8, 4
4200fe18:	006606        	j	4200ffb4 <_vfiprintf_r+0x12f8>
4200fe1b:	6ea200        	f64rnd	a10, a2, a0, 2
4200fe1e:	881c12        	l16ui	a1, a12, 0x110
4200fe21:	0728a7        	blt	a8, a10, 4200fe2c <_vfiprintf_r+0x1170>
4200fe24:	112e82        	l32i	a8, a14, 68
4200fe27:	000486        	j	4200fe3d <_vfiprintf_r+0x1181>
4200fe2a:	970000        	lsi	f0, a0, 0x25c
4200fe2d:	0128      	l32i.n	a2, a1, 0
4200fe2f:	8a2c      	movi.n	a10, 40
4200fe31:	10c182        	addi	a8, a1, 16
4200fe34:	02d882        	addmi	a8, a8, 0x200
4200fe37:	102882        	l32i	a8, a8, 64
4200fe3a:	9661a2        	s32i	a10, a1, 0x258
4200fe3d:	88aa      	add.n	a8, a8, a10
4200fe3f:	f8c882        	addi	a8, a8, -8
4200fe42:	0848      	l32i.n	a4, a8, 0
4200fe44:	1828      	l32i.n	a2, a8, 4
4200fe46:	005a86        	j	4200ffb4 <_vfiprintf_r+0x12f8>
4200fe49:	036347        	bbci	a3, 4, 4200fe50 <_vfiprintf_r+0x1194>
4200fe4c:	005a46        	j	4200ffb9 <_vfiprintf_r+0x12fd>
4200fe4f:	e36700        	lsi	f0, a7, 0x38c
4200fe52:	2b4602        	s8i	a0, a6, 43
4200fe55:	c4ac00        	extui	a10, a0, 12, 13
4200fe58:	08a687        	bge	a6, a8, 4200fe64 <_vfiprintf_r+0x11a8>
4200fe5b:	b0e6e0        	addx8	a14, a6, a14
4200fe5e:	001e42        	l16ui	a4, a14, 0
4200fe61:	006046        	j	4200ffe6 <_vfiprintf_r+0x132a>
4200fe64:	30a282        	movi	a8, 0x230
4200fe67:	8e8a      	add.n	a8, a14, a8
4200fe69:	34a2d2        	movi	a13, 0x234
4200fe6c:	40a2c2        	movi	a12, 0x240
4200fe6f:	0189      	s32i.n	a8, a1, 0
4200fe71:	01def2        	addmi	a15, a14, 0x100
4200fe74:	deda      	add.n	a13, a14, a13
4200fe76:	ceca      	add.n	a12, a14, a12
4200fe78:	07bd      	mov.n	a11, a7
4200fe7a:	20a660        	or	a10, a6, a6
4200fe7d:	fe94a5        	call8	4200e7c8 <get_arg$isra$0>
4200fe80:	001a42        	l16ui	a4, a10, 0
4200fe83:	0057c6        	j	4200ffe6 <_vfiprintf_r+0x132a>
4200fe86:	751b      	addi.n	a7, a5, 1
4200fe88:	08a587        	bge	a5, a8, 4200fe94 <_vfiprintf_r+0x11d8>
4200fe8b:	b0e6e0        	addx8	a14, a6, a14
4200fe8e:	001e42        	l16ui	a4, a14, 0
4200fe91:	004746        	j	4200ffb2 <_vfiprintf_r+0x12f6>
4200fe94:	922e92        	l32i	a9, a14, 0x248
4200fe97:	fb1c      	movi.n	a11, 31
4200fe99:	02dee2        	addmi	a14, a14, 0x200
4200fe9c:	a94b      	addi.n	a10, a9, 4
4200fe9e:	362b87        	blt	a11, a8, 4200fed8 <_vfiprintf_r+0x121c>
4200fea1:	b81b      	addi.n	a11, a8, 1
4200fea3:	9161b2        	s32i	a11, a1, 0x244
4200fea6:	126ea2        	s32i	a10, a14, 72
4200fea9:	8b1c      	movi.n	a11, 24
4200feab:	052ba7        	blt	a11, a10, 4200feb4 <_vfiprintf_r+0x11f8>
4200feae:	112e92        	l32i	a9, a14, 68
4200feb1:	000406        	j	4200fec5 <_vfiprintf_r+0x1209>
4200feb4:	012b97        	blt	a11, a9, 4200feb9 <_vfiprintf_r+0x11fd>
4200feb7:	4a2c      	movi.n	a10, 36
4200feb9:	10c192        	addi	a9, a1, 16
4200febc:	02d992        	addmi	a9, a9, 0x200
4200febf:	102992        	l32i	a9, a9, 64
4200fec2:	9661a2        	s32i	a10, a1, 0x258
4200fec5:	99aa      	add.n	a9, a9, a10
4200fec7:	fcc992        	addi	a9, a9, -4
4200feca:	0948      	l32i.n	a4, a9, 0
4200fecc:	b08810        	addx8	a8, a8, a1
4200fecf:	4849      	s32i.n	a4, a8, 16
4200fed1:	f44040        	extui	a4, a4, 0, 16
4200fed4:	003686        	j	4200ffb2 <_vfiprintf_r+0x12f6>
4200fed7:	6ea200        	f64rnd	a10, a2, a0, 2
4200feda:	881c12        	l16ui	a1, a12, 0x110
4200fedd:	0728a7        	blt	a8, a10, 4200fee8 <_vfiprintf_r+0x122c>
4200fee0:	112e82        	l32i	a8, a14, 68
4200fee3:	000486        	j	4200fef9 <_vfiprintf_r+0x123d>
4200fee6:	970000        	lsi	f0, a0, 0x25c
4200fee9:	0128      	l32i.n	a2, a1, 0
4200feeb:	4a2c      	movi.n	a10, 36
4200feed:	10c182        	addi	a8, a1, 16
4200fef0:	02d882        	addmi	a8, a8, 0x200
4200fef3:	102882        	l32i	a8, a8, 64
4200fef6:	9661a2        	s32i	a10, a1, 0x258
4200fef9:	88aa      	add.n	a8, a8, a10
4200fefb:	fcc882        	addi	a8, a8, -4
4200fefe:	001842        	l16ui	a4, a8, 0
4200ff01:	002b46        	j	4200ffb2 <_vfiprintf_r+0x12f6>
4200ff04:	02e397        	bbsi	a3, 9, 4200ff0a <_vfiprintf_r+0x124e>
4200ff07:	002b86        	j	4200ffb9 <_vfiprintf_r+0x12fd>
4200ff0a:	c4ac      	beqz.n	a4, 4200ff3a <_vfiprintf_r+0x127e>
4200ff0c:	09a687        	bge	a6, a8, 4200ff19 <_vfiprintf_r+0x125d>
4200ff0f:	b0e6e0        	addx8	a14, a6, a14
4200ff12:	000e42        	l8ui	a4, a14, 0
4200ff15:	003346        	j	4200ffe6 <_vfiprintf_r+0x132a>
4200ff18:	a28200        	muluh	a8, a2, a0
4200ff1b:	8e8a30        	f64iter	a8, a10, a3, 0, 0
4200ff1e:	34a2d2        	movi	a13, 0x234
4200ff21:	40a2c2        	movi	a12, 0x240
4200ff24:	0189      	s32i.n	a8, a1, 0
4200ff26:	01def2        	addmi	a15, a14, 0x100
4200ff29:	deda      	add.n	a13, a14, a13
4200ff2b:	ceca      	add.n	a12, a14, a12
4200ff2d:	07bd      	mov.n	a11, a7
4200ff2f:	06ad      	mov.n	a10, a6
4200ff31:	fe8965        	call8	4200e7c8 <get_arg$isra$0>
4200ff34:	000a42        	l8ui	a4, a10, 0
4200ff37:	002ac6        	j	4200ffe6 <_vfiprintf_r+0x132a>
4200ff3a:	751b      	addi.n	a7, a5, 1
4200ff3c:	08a587        	bge	a5, a8, 4200ff48 <_vfiprintf_r+0x128c>
4200ff3f:	b0e6e0        	addx8	a14, a6, a14
4200ff42:	000e42        	l8ui	a4, a14, 0
4200ff45:	001a46        	j	4200ffb2 <_vfiprintf_r+0x12f6>
4200ff48:	922e92        	l32i	a9, a14, 0x248
4200ff4b:	fb1c      	movi.n	a11, 31
4200ff4d:	02dee2        	addmi	a14, a14, 0x200
4200ff50:	a94b      	addi.n	a10, a9, 4
4200ff52:	352b87        	blt	a11, a8, 4200ff8b <_vfiprintf_r+0x12cf>
4200ff55:	b81b      	addi.n	a11, a8, 1
4200ff57:	9161b2        	s32i	a11, a1, 0x244
4200ff5a:	126ea2        	s32i	a10, a14, 72
4200ff5d:	8b1c      	movi.n	a11, 24
4200ff5f:	052ba7        	blt	a11, a10, 4200ff68 <_vfiprintf_r+0x12ac>
4200ff62:	112e92        	l32i	a9, a14, 68
4200ff65:	000406        	j	4200ff79 <_vfiprintf_r+0x12bd>
4200ff68:	012b97        	blt	a11, a9, 4200ff6d <_vfiprintf_r+0x12b1>
4200ff6b:	4a2c      	movi.n	a10, 36
4200ff6d:	10c192        	addi	a9, a1, 16
4200ff70:	02d992        	addmi	a9, a9, 0x200
4200ff73:	102992        	l32i	a9, a9, 64
4200ff76:	9661a2        	s32i	a10, a1, 0x258
4200ff79:	99aa      	add.n	a9, a9, a10
4200ff7b:	fcc992        	addi	a9, a9, -4
4200ff7e:	0948      	l32i.n	a4, a9, 0
4200ff80:	b08810        	addx8	a8, a8, a1
4200ff83:	4849      	s32i.n	a4, a8, 16
4200ff85:	744040        	extui	a4, a4, 0, 8
4200ff88:	000986        	j	4200ffb2 <_vfiprintf_r+0x12f6>
4200ff8b:	126ea2        	s32i	a10, a14, 72
4200ff8e:	881c      	movi.n	a8, 24
4200ff90:	0528a7        	blt	a8, a10, 4200ff99 <_vfiprintf_r+0x12dd>
4200ff93:	112e82        	l32i	a8, a14, 68
4200ff96:	000406        	j	4200ffaa <_vfiprintf_r+0x12ee>
4200ff99:	012897        	blt	a8, a9, 4200ff9e <_vfiprintf_r+0x12e2>
4200ff9c:	4a2c      	movi.n	a10, 36
4200ff9e:	10c182        	addi	a8, a1, 16
4200ffa1:	02d882        	addmi	a8, a8, 0x200
4200ffa4:	102882        	l32i	a8, a8, 64
4200ffa7:	9661a2        	s32i	a10, a1, 0x258
4200ffaa:	88aa      	add.n	a8, a8, a10
4200ffac:	fcc882        	addi	a8, a8, -4
4200ffaf:	000842        	l8ui	a4, a8, 0
4200ffb2:	020c      	movi.n	a2, 0
4200ffb4:	180c      	movi.n	a8, 1
4200ffb6:	00f1c6        	j	42010381 <_vfiprintf_r+0x16c5>
4200ffb9:	f4ac      	beqz.n	a4, 4200ffec <_vfiprintf_r+0x1330>
4200ffbb:	0aa687        	bge	a6, a8, 4200ffc9 <_vfiprintf_r+0x130d>
4200ffbe:	b0e6e0        	addx8	a14, a6, a14
4200ffc1:	0e48      	l32i.n	a4, a14, 0
4200ffc3:	0007c6        	j	4200ffe6 <_vfiprintf_r+0x132a>
4200ffc6:	000000        	ill
4200ffc9:	30a282        	movi	a8, 0x230
4200ffcc:	8e8a      	add.n	a8, a14, a8
4200ffce:	34a2d2        	movi	a13, 0x234
4200ffd1:	40a2c2        	movi	a12, 0x240
4200ffd4:	0189      	s32i.n	a8, a1, 0
4200ffd6:	01def2        	addmi	a15, a14, 0x100
4200ffd9:	deda      	add.n	a13, a14, a13
4200ffdb:	ceca      	add.n	a12, a14, a12
4200ffdd:	07bd      	mov.n	a11, a7
4200ffdf:	06ad      	mov.n	a10, a6
4200ffe1:	fe7e65        	call8	4200e7c8 <get_arg$isra$0>
4200ffe4:	0a48      	l32i.n	a4, a10, 0
4200ffe6:	057d      	mov.n	a7, a5
4200ffe8:	fff186        	j	4200ffb2 <_vfiprintf_r+0x12f6>
4200ffeb:	751b00        	extui	a1, a0, 27, 8
4200ffee:	07a587        	bge	a5, a8, 4200fff9 <_vfiprintf_r+0x133d>
4200fff1:	b0e6e0        	addx8	a14, a6, a14
4200fff4:	0e48      	l32i.n	a4, a14, 0
4200fff6:	ffee06        	j	4200ffb2 <_vfiprintf_r+0x12f6>
4200fff9:	922e92        	l32i	a9, a14, 0x248
4200fffc:	fb1c      	movi.n	a11, 31
4200fffe:	02dee2        	addmi	a14, a14, 0x200
42010001:	a94b      	addi.n	a10, a9, 4
42010003:	322b87        	blt	a11, a8, 42010039 <_vfiprintf_r+0x137d>
42010006:	b81b      	addi.n	a11, a8, 1
42010008:	9161b2        	s32i	a11, a1, 0x244
4201000b:	126ea2        	s32i	a10, a14, 72
4201000e:	8b1c      	movi.n	a11, 24
42010010:	052ba7        	blt	a11, a10, 42010019 <_vfiprintf_r+0x135d>
42010013:	112e92        	l32i	a9, a14, 68
42010016:	000406        	j	4201002a <_vfiprintf_r+0x136e>
42010019:	012b97        	blt	a11, a9, 4201001e <_vfiprintf_r+0x1362>
4201001c:	4a2c      	movi.n	a10, 36
4201001e:	10c192        	addi	a9, a1, 16
42010021:	02d992        	addmi	a9, a9, 0x200
42010024:	102992        	l32i	a9, a9, 64
42010027:	9661a2        	s32i	a10, a1, 0x258
4201002a:	99aa      	add.n	a9, a9, a10
4201002c:	fcc992        	addi	a9, a9, -4
4201002f:	0948      	l32i.n	a4, a9, 0
42010031:	b08810        	addx8	a8, a8, a1
42010034:	4849      	s32i.n	a4, a8, 16
42010036:	ffde06        	j	4200ffb2 <_vfiprintf_r+0x12f6>
42010039:	126ea2        	s32i	a10, a14, 72
4201003c:	881c      	movi.n	a8, 24
4201003e:	0628a7        	blt	a8, a10, 42010048 <_vfiprintf_r+0x138c>
42010041:	112e82        	l32i	a8, a14, 68
42010044:	000446        	j	42010059 <_vfiprintf_r+0x139d>
42010047:	289700        	lsi	f0, a7, 160
4201004a:	4a2c01        	l32r	a0, 41fe28fc <_coredump_iram_end+0x1c609fc>
4201004d:	10c182        	addi	a8, a1, 16
42010050:	02d882        	addmi	a8, a8, 0x200
42010053:	102882        	l32i	a8, a8, 64
42010056:	9661a2        	s32i	a10, a1, 0x258
42010059:	88aa      	add.n	a8, a8, a10
4201005b:	fcc882        	addi	a8, a8, -4
4201005e:	0848      	l32i.n	a4, a8, 0
42010060:	ffd386        	j	4200ffb2 <_vfiprintf_r+0x12f6>
42010063:	3a8100        	lsi	f0, a1, 232
42010066:	6182c3        	lsip	f12, a2, 0x184
42010069:	c1e2a1        	l32r	a10, 420007f4 <_stext+0x7d4> (3fc94ef4 <s_registered_select_num>)
4201006c:	218210        	srai	a8, a1, 2
4201006f:	e35791        	l32r	a9, 42008dcc <gpio_sleep_pulldown_dis+0x3c> (deff81de <_rtc_reserved_end+0x7eef81de>)
42010072:	2f8602        	lsi	f0, a6, 188
42010075:	f4ac00        	extui	a10, a0, 12, 16
42010078:	09a687        	bge	a6, a8, 42010085 <_vfiprintf_r+0x13c9>
4201007b:	b0e6e0        	addx8	a14, a6, a14
4201007e:	0e48      	l32i.n	a4, a14, 0
42010080:	1e28      	l32i.n	a2, a14, 4
42010082:	000786        	j	420100a4 <_vfiprintf_r+0x13e8>
42010085:	30a282        	movi	a8, 0x230
42010088:	8e8a      	add.n	a8, a14, a8
4201008a:	34a2d2        	movi	a13, 0x234
4201008d:	40a2c2        	movi	a12, 0x240
42010090:	0189      	s32i.n	a8, a1, 0
42010092:	01def2        	addmi	a15, a14, 0x100
42010095:	deda      	add.n	a13, a14, a13
42010097:	ceca      	add.n	a12, a14, a12
42010099:	07bd      	mov.n	a11, a7
4201009b:	06ad      	mov.n	a10, a6
4201009d:	fe72a5        	call8	4200e7c8 <get_arg$isra$0>
420100a0:	0a48      	l32i.n	a4, a10, 0
420100a2:	1a28      	l32i.n	a2, a10, 4
420100a4:	057d      	mov.n	a7, a5
420100a6:	00ac06        	j	4201035a <_vfiprintf_r+0x169e>
420100a9:	751b      	addi.n	a7, a5, 1
420100ab:	09a587        	bge	a5, a8, 420100b8 <_vfiprintf_r+0x13fc>
420100ae:	b0e6e0        	addx8	a14, a6, a14
420100b1:	0e48      	l32i.n	a4, a14, 0
420100b3:	1e28      	l32i.n	a2, a14, 4
420100b5:	00a846        	j	4201035a <_vfiprintf_r+0x169e>
420100b8:	922e92        	l32i	a9, a14, 0x248
420100bb:	8a7c      	movi.n	a10, -8
420100bd:	997b      	addi.n	a9, a9, 7
420100bf:	1099a0        	and	a9, a9, a10
420100c2:	fb1c      	movi.n	a11, 31
420100c4:	02dee2        	addmi	a14, a14, 0x200
420100c7:	a98b      	addi.n	a10, a9, 8
420100c9:	3b2b87        	blt	a11, a8, 42010108 <_vfiprintf_r+0x144c>
420100cc:	b81b      	addi.n	a11, a8, 1
420100ce:	9161b2        	s32i	a11, a1, 0x244
420100d1:	126ea2        	s32i	a10, a14, 72
420100d4:	8b1c      	movi.n	a11, 24
420100d6:	062ba7        	blt	a11, a10, 420100e0 <_vfiprintf_r+0x1424>
420100d9:	112e92        	l32i	a9, a14, 68
420100dc:	000446        	j	420100f1 <_vfiprintf_r+0x1435>
420100df:	2b9700        	oeq.s	b9, f7, f0
420100e2:	8a2c01        	l32r	a0, 41ff2994 <_coredump_iram_end+0x1c70a94>
420100e5:	10c192        	addi	a9, a1, 16
420100e8:	02d992        	addmi	a9, a9, 0x200
420100eb:	102992        	l32i	a9, a9, 64
420100ee:	9661a2        	s32i	a10, a1, 0x258
420100f1:	99aa      	add.n	a9, a9, a10
420100f3:	f8c992        	addi	a9, a9, -8
420100f6:	0948      	l32i.n	a4, a9, 0
420100f8:	1928      	l32i.n	a2, a9, 4
420100fa:	10c192        	addi	a9, a1, 16
420100fd:	b08890        	addx8	a8, a8, a9
42010100:	0849      	s32i.n	a4, a8, 0
42010102:	1829      	s32i.n	a2, a8, 4
42010104:	009486        	j	4201035a <_vfiprintf_r+0x169e>
42010107:	6ea200        	f64rnd	a10, a2, a0, 2
4201010a:	881c12        	l16ui	a1, a12, 0x110
4201010d:	0728a7        	blt	a8, a10, 42010118 <_vfiprintf_r+0x145c>
42010110:	112e82        	l32i	a8, a14, 68
42010113:	000486        	j	42010129 <_vfiprintf_r+0x146d>
42010116:	970000        	lsi	f0, a0, 0x25c
42010119:	0128      	l32i.n	a2, a1, 0
4201011b:	8a2c      	movi.n	a10, 40
4201011d:	10c182        	addi	a8, a1, 16
42010120:	02d882        	addmi	a8, a8, 0x200
42010123:	102882        	l32i	a8, a8, 64
42010126:	9661a2        	s32i	a10, a1, 0x258
42010129:	88aa      	add.n	a8, a8, a10
4201012b:	f8c882        	addi	a8, a8, -8
4201012e:	0848      	l32i.n	a4, a8, 0
42010130:	1828      	l32i.n	a2, a8, 4
42010132:	008906        	j	4201035a <_vfiprintf_r+0x169e>
42010135:	146347        	bbci	a3, 4, 4201014d <_vfiprintf_r+0x1491>
42010138:	148c      	beqz.n	a4, 4201013d <_vfiprintf_r+0x1481>
4201013a:	005e06        	j	420102b6 <_vfiprintf_r+0x15fa>
4201013d:	751b      	addi.n	a7, a5, 1
4201013f:	022587        	blt	a5, a8, 42010145 <_vfiprintf_r+0x1489>
42010142:	006ac6        	j	420102f1 <_vfiprintf_r+0x1635>
42010145:	b0e6e0        	addx8	a14, a6, a14
42010148:	0e48      	l32i.n	a4, a14, 0
4201014a:	008286        	j	42010358 <_vfiprintf_r+0x169c>
4201014d:	02e367        	bbsi	a3, 6, 42010153 <_vfiprintf_r+0x1497>
42010150:	002b06        	j	42010200 <_vfiprintf_r+0x1544>
42010153:	b4ac      	beqz.n	a4, 42010182 <_vfiprintf_r+0x14c6>
42010155:	08a687        	bge	a6, a8, 42010161 <_vfiprintf_r+0x14a5>
42010158:	b0e6e0        	addx8	a14, a6, a14
4201015b:	001e42        	l16ui	a4, a14, 0
4201015e:	005f06        	j	420102de <_vfiprintf_r+0x1622>
42010161:	30a282        	movi	a8, 0x230
42010164:	8e8a      	add.n	a8, a14, a8
42010166:	34a2d2        	movi	a13, 0x234
42010169:	40a2c2        	movi	a12, 0x240
4201016c:	0189      	s32i.n	a8, a1, 0
4201016e:	01def2        	addmi	a15, a14, 0x100
42010171:	deda      	add.n	a13, a14, a13
42010173:	ceca      	add.n	a12, a14, a12
42010175:	07bd      	mov.n	a11, a7
42010177:	06ad      	mov.n	a10, a6
42010179:	fe64e5        	call8	4200e7c8 <get_arg$isra$0>
4201017c:	001a42        	l16ui	a4, a10, 0
4201017f:	0056c6        	j	420102de <_vfiprintf_r+0x1622>
42010182:	751b      	addi.n	a7, a5, 1
42010184:	08a587        	bge	a5, a8, 42010190 <_vfiprintf_r+0x14d4>
42010187:	b0e6e0        	addx8	a14, a6, a14
4201018a:	001e42        	l16ui	a4, a14, 0
4201018d:	0071c6        	j	42010358 <_vfiprintf_r+0x169c>
42010190:	922e92        	l32i	a9, a14, 0x248
42010193:	fb1c      	movi.n	a11, 31
42010195:	02dee2        	addmi	a14, a14, 0x200
42010198:	a94b      	addi.n	a10, a9, 4
4201019a:	362b87        	blt	a11, a8, 420101d4 <_vfiprintf_r+0x1518>
4201019d:	b81b      	addi.n	a11, a8, 1
4201019f:	9161b2        	s32i	a11, a1, 0x244
420101a2:	126ea2        	s32i	a10, a14, 72
420101a5:	8b1c      	movi.n	a11, 24
420101a7:	052ba7        	blt	a11, a10, 420101b0 <_vfiprintf_r+0x14f4>
420101aa:	112e92        	l32i	a9, a14, 68
420101ad:	000406        	j	420101c1 <_vfiprintf_r+0x1505>
420101b0:	012b97        	blt	a11, a9, 420101b5 <_vfiprintf_r+0x14f9>
420101b3:	4a2c      	movi.n	a10, 36
420101b5:	10c192        	addi	a9, a1, 16
420101b8:	02d992        	addmi	a9, a9, 0x200
420101bb:	102992        	l32i	a9, a9, 64
420101be:	9661a2        	s32i	a10, a1, 0x258
420101c1:	99aa      	add.n	a9, a9, a10
420101c3:	fcc992        	addi	a9, a9, -4
420101c6:	0948      	l32i.n	a4, a9, 0
420101c8:	b08810        	addx8	a8, a8, a1
420101cb:	4849      	s32i.n	a4, a8, 16
420101cd:	f44040        	extui	a4, a4, 0, 16
420101d0:	006106        	j	42010358 <_vfiprintf_r+0x169c>
420101d3:	6ea200        	f64rnd	a10, a2, a0, 2
420101d6:	881c12        	l16ui	a1, a12, 0x110
420101d9:	0728a7        	blt	a8, a10, 420101e4 <_vfiprintf_r+0x1528>
420101dc:	112e82        	l32i	a8, a14, 68
420101df:	000486        	j	420101f5 <_vfiprintf_r+0x1539>
420101e2:	970000        	lsi	f0, a0, 0x25c
420101e5:	0128      	l32i.n	a2, a1, 0
420101e7:	4a2c      	movi.n	a10, 36
420101e9:	10c182        	addi	a8, a1, 16
420101ec:	02d882        	addmi	a8, a8, 0x200
420101ef:	102882        	l32i	a8, a8, 64
420101f2:	9661a2        	s32i	a10, a1, 0x258
420101f5:	88aa      	add.n	a8, a8, a10
420101f7:	fcc882        	addi	a8, a8, -4
420101fa:	001842        	l16ui	a4, a8, 0
420101fd:	0055c6        	j	42010358 <_vfiprintf_r+0x169c>
42010200:	02e397        	bbsi	a3, 9, 42010206 <_vfiprintf_r+0x154a>
42010203:	002b46        	j	420102b4 <_vfiprintf_r+0x15f8>
42010206:	c4ac      	beqz.n	a4, 42010236 <_vfiprintf_r+0x157a>
42010208:	09a687        	bge	a6, a8, 42010215 <_vfiprintf_r+0x1559>
4201020b:	b0e6e0        	addx8	a14, a6, a14
4201020e:	000e42        	l8ui	a4, a14, 0
42010211:	003246        	j	420102de <_vfiprintf_r+0x1622>
42010214:	a28200        	muluh	a8, a2, a0
42010217:	8e8a30        	f64iter	a8, a10, a3, 0, 0
4201021a:	34a2d2        	movi	a13, 0x234
4201021d:	40a2c2        	movi	a12, 0x240
42010220:	0189      	s32i.n	a8, a1, 0
42010222:	01def2        	addmi	a15, a14, 0x100
42010225:	deda      	add.n	a13, a14, a13
42010227:	ceca      	add.n	a12, a14, a12
42010229:	07bd      	mov.n	a11, a7
4201022b:	06ad      	mov.n	a10, a6
4201022d:	fe59a5        	call8	4200e7c8 <get_arg$isra$0>
42010230:	000a42        	l8ui	a4, a10, 0
42010233:	0029c6        	j	420102de <_vfiprintf_r+0x1622>
42010236:	751b      	addi.n	a7, a5, 1
42010238:	08a587        	bge	a5, a8, 42010244 <_vfiprintf_r+0x1588>
4201023b:	b0e6e0        	addx8	a14, a6, a14
4201023e:	000e42        	l8ui	a4, a14, 0
42010241:	0044c6        	j	42010358 <_vfiprintf_r+0x169c>
42010244:	922e92        	l32i	a9, a14, 0x248
42010247:	fb1c      	movi.n	a11, 31
42010249:	02dee2        	addmi	a14, a14, 0x200
4201024c:	a94b      	addi.n	a10, a9, 4
4201024e:	362b87        	blt	a11, a8, 42010288 <_vfiprintf_r+0x15cc>
42010251:	b81b      	addi.n	a11, a8, 1
42010253:	9161b2        	s32i	a11, a1, 0x244
42010256:	126ea2        	s32i	a10, a14, 72
42010259:	8b1c      	movi.n	a11, 24
4201025b:	052ba7        	blt	a11, a10, 42010264 <_vfiprintf_r+0x15a8>
4201025e:	112e92        	l32i	a9, a14, 68
42010261:	000406        	j	42010275 <_vfiprintf_r+0x15b9>
42010264:	012b97        	blt	a11, a9, 42010269 <_vfiprintf_r+0x15ad>
42010267:	4a2c      	movi.n	a10, 36
42010269:	10c192        	addi	a9, a1, 16
4201026c:	02d992        	addmi	a9, a9, 0x200
4201026f:	102992        	l32i	a9, a9, 64
42010272:	9661a2        	s32i	a10, a1, 0x258
42010275:	99aa      	add.n	a9, a9, a10
42010277:	fcc992        	addi	a9, a9, -4
4201027a:	0948      	l32i.n	a4, a9, 0
4201027c:	b08810        	addx8	a8, a8, a1
4201027f:	4849      	s32i.n	a4, a8, 16
42010281:	744040        	extui	a4, a4, 0, 8
42010284:	003406        	j	42010358 <_vfiprintf_r+0x169c>
42010287:	6ea200        	f64rnd	a10, a2, a0, 2
4201028a:	881c12        	l16ui	a1, a12, 0x110
4201028d:	0728a7        	blt	a8, a10, 42010298 <_vfiprintf_r+0x15dc>
42010290:	112e82        	l32i	a8, a14, 68
42010293:	000486        	j	420102a9 <_vfiprintf_r+0x15ed>
42010296:	970000        	lsi	f0, a0, 0x25c
42010299:	0128      	l32i.n	a2, a1, 0
4201029b:	4a2c      	movi.n	a10, 36
4201029d:	10c182        	addi	a8, a1, 16
420102a0:	02d882        	addmi	a8, a8, 0x200
420102a3:	102882        	l32i	a8, a8, 64
420102a6:	9661a2        	s32i	a10, a1, 0x258
420102a9:	88aa      	add.n	a8, a8, a10
420102ab:	fcc882        	addi	a8, a8, -4
420102ae:	000842        	l8ui	a4, a8, 0
420102b1:	0028c6        	j	42010358 <_vfiprintf_r+0x169c>
420102b4:	c4ac      	beqz.n	a4, 420102e4 <_vfiprintf_r+0x1628>
420102b6:	07a687        	bge	a6, a8, 420102c1 <_vfiprintf_r+0x1605>
420102b9:	b0e6e0        	addx8	a14, a6, a14
420102bc:	0e48      	l32i.n	a4, a14, 0
420102be:	000706        	j	420102de <_vfiprintf_r+0x1622>
420102c1:	30a282        	movi	a8, 0x230
420102c4:	8e8a      	add.n	a8, a14, a8
420102c6:	34a2d2        	movi	a13, 0x234
420102c9:	40a2c2        	movi	a12, 0x240
420102cc:	0189      	s32i.n	a8, a1, 0
420102ce:	01def2        	addmi	a15, a14, 0x100
420102d1:	deda      	add.n	a13, a14, a13
420102d3:	ceca      	add.n	a12, a14, a12
420102d5:	07bd      	mov.n	a11, a7
420102d7:	06ad      	mov.n	a10, a6
420102d9:	fe4ee5        	call8	4200e7c8 <get_arg$isra$0>
420102dc:	0a48      	l32i.n	a4, a10, 0
420102de:	057d      	mov.n	a7, a5
420102e0:	001d06        	j	42010358 <_vfiprintf_r+0x169c>
420102e3:	751b00        	extui	a1, a0, 27, 8
420102e6:	07a587        	bge	a5, a8, 420102f1 <_vfiprintf_r+0x1635>
420102e9:	b066e0        	addx8	a6, a6, a14
420102ec:	0648      	l32i.n	a4, a6, 0
420102ee:	001986        	j	42010358 <_vfiprintf_r+0x169c>
420102f1:	922e92        	l32i	a9, a14, 0x248
420102f4:	fb1c      	movi.n	a11, 31
420102f6:	02dee2        	addmi	a14, a14, 0x200
420102f9:	a94b      	addi.n	a10, a9, 4
420102fb:	322b87        	blt	a11, a8, 42010331 <_vfiprintf_r+0x1675>
420102fe:	b81b      	addi.n	a11, a8, 1
42010300:	9161b2        	s32i	a11, a1, 0x244
42010303:	126ea2        	s32i	a10, a14, 72
42010306:	8b1c      	movi.n	a11, 24
42010308:	052ba7        	blt	a11, a10, 42010311 <_vfiprintf_r+0x1655>
4201030b:	112e92        	l32i	a9, a14, 68
4201030e:	000406        	j	42010322 <_vfiprintf_r+0x1666>
42010311:	012b97        	blt	a11, a9, 42010316 <_vfiprintf_r+0x165a>
42010314:	4a2c      	movi.n	a10, 36
42010316:	10c192        	addi	a9, a1, 16
42010319:	02d992        	addmi	a9, a9, 0x200
4201031c:	102992        	l32i	a9, a9, 64
4201031f:	9661a2        	s32i	a10, a1, 0x258
42010322:	99aa      	add.n	a9, a9, a10
42010324:	fcc992        	addi	a9, a9, -4
42010327:	0948      	l32i.n	a4, a9, 0
42010329:	b08810        	addx8	a8, a8, a1
4201032c:	4849      	s32i.n	a4, a8, 16
4201032e:	000986        	j	42010358 <_vfiprintf_r+0x169c>
42010331:	126ea2        	s32i	a10, a14, 72
42010334:	881c      	movi.n	a8, 24
42010336:	0628a7        	blt	a8, a10, 42010340 <_vfiprintf_r+0x1684>
42010339:	112e82        	l32i	a8, a14, 68
4201033c:	000446        	j	42010351 <_vfiprintf_r+0x1695>
4201033f:	289700        	lsi	f0, a7, 160
42010342:	4a2c01        	l32r	a0, 41fe2bf4 <_coredump_iram_end+0x1c60cf4>
42010345:	10c182        	addi	a8, a1, 16
42010348:	02d882        	addmi	a8, a8, 0x200
4201034b:	102882        	l32i	a8, a8, 64
4201034e:	9661a2        	s32i	a10, a1, 0x258
42010351:	88aa      	add.n	a8, a8, a10
42010353:	fcc882        	addi	a8, a8, -4
42010356:	0848      	l32i.n	a4, a8, 0
42010358:	020c      	movi.n	a2, 0
4201035a:	208420        	or	a8, a4, a2
4201035d:	889c      	beqz.n	a8, 42010379 <_vfiprintf_r+0x16bd>
4201035f:	166307        	bbci	a3, 0, 42010379 <_vfiprintf_r+0x16bd>
42010362:	10c182        	addi	a8, a1, 16
42010365:	02d882        	addmi	a8, a8, 0x200
42010368:	093c      	movi.n	a9, 48
4201036a:	384892        	s8i	a9, a8, 56
4201036d:	9e2192        	l32i	a9, a1, 0x278
42010370:	394892        	s8i	a9, a8, 57
42010373:	02a082        	movi	a8, 2
42010376:	203380        	or	a3, a3, a8
42010379:	ffab82        	movi	a8, 0xfffffbff
4201037c:	103380        	and	a3, a3, a8
4201037f:	280c      	movi.n	a8, 2
42010381:	090c      	movi.n	a9, 0
42010383:	10c1a2        	addi	a10, a1, 16
42010386:	02daa2        	addmi	a10, a10, 0x200
42010389:	3a4a92        	s8i	a9, a10, 58
4201038c:	9a2192        	l32i	a9, a1, 0x268
4201038f:	01d996        	bltz	a9, 420103b0 <_vfiprintf_r+0x16f4>
42010392:	20a330        	or	a10, a3, a3
42010395:	7faf92        	movi	a9, -129
42010398:	103390        	and	a3, a3, a9
4201039b:	1b0c      	movi.n	a11, 1
4201039d:	209420        	or	a9, a4, a2
420103a0:	83b990        	moveqz	a11, a9, a9
420103a3:	99cc      	bnez.n	a9, 420103b0 <_vfiprintf_r+0x16f4>
420103a5:	9a21c2        	l32i	a12, a1, 0x268
420103a8:	190c      	movi.n	a9, 1
420103aa:	839bc0        	moveqz	a9, a11, a12
420103ad:	12f916        	beqz	a9, 420104e0 <_vfiprintf_r+0x1824>
420103b0:	421826        	beqi	a8, 1, 420103f6 <_vfiprintf_r+0x173a>
420103b3:	e4a162        	movi	a6, 0x1e4
420103b6:	022866        	bnei	a8, 2, 420103bc <_vfiprintf_r+0x1700>
420103b9:	003ec6        	j	420104b8 <_vfiprintf_r+0x17fc>
420103bc:	10c182        	addi	a8, a1, 16
420103bf:	686a      	add.n	a6, a8, a6
420103c1:	248040        	extui	a8, a4, 0, 3
420103c4:	069d      	mov.n	a9, a6
420103c6:	404300        	ssai	3
420103c9:	814240        	src	a4, a2, a4
420103cc:	660b      	addi.n	a6, a6, -1
420103ce:	30c882        	addi	a8, a8, 48
420103d1:	412320        	srli	a2, a2, 3
420103d4:	004682        	s8i	a8, a6, 0
420103d7:	20a420        	or	a10, a4, a2
420103da:	fe3a56        	bnez	a10, 420103c1 <_vfiprintf_r+0x1705>
420103dd:	d0c882        	addi	a8, a8, -48
420103e0:	130816        	beqz	a8, 42010514 <_vfiprintf_r+0x1858>
420103e3:	02e307        	bbsi	a3, 0, 420103e9 <_vfiprintf_r+0x172d>
420103e6:	004a86        	j	42010514 <_vfiprintf_r+0x1858>
420103e9:	660b      	addi.n	a6, a6, -1
420103eb:	083c      	movi.n	a8, 48
420103ed:	004682        	s8i	a8, a6, 0
420103f0:	fec962        	addi	a6, a9, -2
420103f3:	004746        	j	42010514 <_vfiprintf_r+0x1858>
420103f6:	72dc      	bnez.n	a2, 42010411 <_vfiprintf_r+0x1755>
420103f8:	980c      	movi.n	a8, 9
420103fa:	133847        	bltu	a8, a4, 42010411 <_vfiprintf_r+0x1755>
420103fd:	10c162        	addi	a6, a1, 16
42010400:	01d682        	addmi	a8, a6, 0x100
42010403:	30c442        	addi	a4, a4, 48
42010406:	e34842        	s8i	a4, a8, 227
42010409:	e3a182        	movi	a8, 0x1e3
4201040c:	004086        	j	42010512 <_vfiprintf_r+0x1856>
4201040f:	620000        	lsi	f0, a0, 0x188
42010412:	52f4a1        	l32r	a10, 41fe4fe4 <_coredump_iram_end+0x1c630e4>
42010415:	0c00a4        	lsi	f10, a0, 48
42010418:	0e          	.byte	0xe
42010419:	616a      	add.n	a6, a1, a6
4201041b:	105350        	and	a5, a3, a5
4201041e:	9e61e2        	s32i	a14, a1, 0x278
42010421:	ac0c      	movi.n	a12, 10
42010423:	0d0c      	movi.n	a13, 0
42010425:	04ad      	mov.n	a10, a4
42010427:	20b220        	or	a11, a2, a2
4201042a:	c24381        	l32r	a8, 42000d38 <_stext+0xd18> (40002574 <__umoddi3>)
4201042d:	0008e0        	callx8	a8
42010430:	9e21e2        	l32i	a14, a1, 0x278
42010433:	660b      	addi.n	a6, a6, -1
42010435:	30caa2        	addi	a10, a10, 48
42010438:	0046a2        	s8i	a10, a6, 0
4201043b:	ee1b      	addi.n	a14, a14, 1
4201043d:	053516        	beqz	a5, 42010494 <_vfiprintf_r+0x17d8>
42010440:	9f2182        	l32i	a8, a1, 0x27c
42010443:	000892        	l8ui	a9, a8, 0
42010446:	01af82        	movi	a8, -255
42010449:	808980        	add	a8, a9, a8
4201044c:	044816        	beqz	a8, 42010494 <_vfiprintf_r+0x17d8>
4201044f:	4199e7        	bne	a9, a14, 42010494 <_vfiprintf_r+0x17d8>
42010452:	72cc      	bnez.n	a2, 4201045d <_vfiprintf_r+0x17a1>
42010454:	09a082        	movi	a8, 9
42010457:	023847        	bltu	a8, a4, 4201045d <_vfiprintf_r+0x17a1>
4201045a:	002d86        	j	42010514 <_vfiprintf_r+0x1858>
4201045d:	a02182        	l32i	a8, a1, 0x280
42010460:	a221b2        	l32i	a11, a1, 0x288
42010463:	c06680        	sub	a6, a6, a8
42010466:	08cd      	mov.n	a12, a8
42010468:	06ad      	mov.n	a10, a6
4201046a:	c1e281        	l32r	a8, 42000bf4 <_stext+0xbd4> (40001224 <strncpy>)
4201046d:	0008e0        	callx8	a8
42010470:	9f2182        	l32i	a8, a1, 0x27c
42010473:	010882        	l8ui	a8, a8, 1
42010476:	688c      	beqz.n	a8, 42010480 <_vfiprintf_r+0x17c4>
42010478:	9f2182        	l32i	a8, a1, 0x27c
4201047b:	881b      	addi.n	a8, a8, 1
4201047d:	9f6182        	s32i	a8, a1, 0x27c
42010480:	ac0c      	movi.n	a12, 10
42010482:	0d0c      	movi.n	a13, 0
42010484:	04ad      	mov.n	a10, a4
42010486:	02bd      	mov.n	a11, a2
42010488:	bf3681        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4201048b:	0008e0        	callx8	a8
4201048e:	0e0c      	movi.n	a14, 0
42010490:	000706        	j	420104b0 <_vfiprintf_r+0x17f4>
42010493:	61e200        	lsi	f0, a2, 0x184
42010496:	9e          	.byte	0x9e
42010497:	ac0c      	movi.n	a12, 10
42010499:	0d0c      	movi.n	a13, 0
4201049b:	04ad      	mov.n	a10, a4
4201049d:	02bd      	mov.n	a11, a2
4201049f:	bf3081        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
420104a2:	0008e0        	callx8	a8
420104a5:	9e21e2        	l32i	a14, a1, 0x278
420104a8:	42cc      	bnez.n	a2, 420104b0 <_vfiprintf_r+0x17f4>
420104aa:	09a082        	movi	a8, 9
420104ad:	63b847        	bgeu	a8, a4, 42010514 <_vfiprintf_r+0x1858>
420104b0:	0a4d      	mov.n	a4, a10
420104b2:	0b2d      	mov.n	a2, a11
420104b4:	ffd986        	j	4201041e <_vfiprintf_r+0x1762>
420104b7:	c18200        	mul16u	a8, a2, a0
420104ba:	686a10        	lsi	f1, a10, 0x1a0
420104bd:	a12192        	l32i	a9, a1, 0x284
420104c0:	348040        	extui	a8, a4, 0, 4
420104c3:	898a      	add.n	a8, a9, a8
420104c5:	000882        	l8ui	a8, a8, 0
420104c8:	404400        	ssai	4
420104cb:	814240        	src	a4, a2, a4
420104ce:	660b      	addi.n	a6, a6, -1
420104d0:	412420        	srli	a2, a2, 4
420104d3:	004682        	s8i	a8, a6, 0
420104d6:	208420        	or	a8, a4, a2
420104d9:	fe0856        	bnez	a8, 420104bd <_vfiprintf_r+0x1801>
420104dc:	000d06        	j	42010514 <_vfiprintf_r+0x1858>
420104df:	090c00        	l32e	a0, a12, -64
420104e2:	9a6192        	s32i	a9, a1, 0x268
420104e5:	e4a162        	movi	a6, 0x1e4
420104e8:	10c192        	addi	a9, a1, 16
420104eb:	696a      	add.n	a6, a9, a6
420104ed:	38ec      	bnez.n	a8, 42010514 <_vfiprintf_r+0x1858>
420104ef:	0480a0        	extui	a8, a10, 0, 1
420104f2:	9a6182        	s32i	a8, a1, 0x268
420104f5:	9a2182        	l32i	a8, a1, 0x268
420104f8:	e4a162        	movi	a6, 0x1e4
420104fb:	696a      	add.n	a6, a9, a6
420104fd:	389c      	beqz.n	a8, 42010514 <_vfiprintf_r+0x1858>
420104ff:	01d982        	addmi	a8, a9, 0x100
42010502:	093c      	movi.n	a9, 48
42010504:	e34892        	s8i	a9, a8, 227
42010507:	080c      	movi.n	a8, 0
42010509:	9a6182        	s32i	a8, a1, 0x268
4201050c:	e3a162        	movi	a6, 0x1e3
4201050f:	10c182        	addi	a8, a1, 16
42010512:	686a      	add.n	a6, a8, a6
42010514:	a42182        	l32i	a8, a1, 0x290
42010517:	9a2152        	l32i	a5, a1, 0x268
4201051a:	c08860        	sub	a8, a8, a6
4201051d:	9a6182        	s32i	a8, a1, 0x268
42010520:	0009c6        	j	4201054b <_vfiprintf_r+0x188f>
42010523:	9e2182        	l32i	a8, a1, 0x278
42010526:	392816        	beqz	a8, 420108bc <_vfiprintf_r+0x1c00>
42010529:	9e2192        	l32i	a9, a1, 0x278
4201052c:	10c162        	addi	a6, a1, 16
4201052f:	01d682        	addmi	a8, a6, 0x100
42010532:	804892        	s8i	a9, a8, 128
42010535:	02d682        	addmi	a8, a6, 0x200
42010538:	090c      	movi.n	a9, 0
4201053a:	3a4892        	s8i	a9, a8, 58
4201053d:	057d      	mov.n	a7, a5
4201053f:	180c      	movi.n	a8, 1
42010541:	9a6182        	s32i	a8, a1, 0x268
42010544:	80a182        	movi	a8, 0x180
42010547:	050c      	movi.n	a5, 0
42010549:	668a      	add.n	a6, a6, a8
4201054b:	9a2182        	l32i	a8, a1, 0x268
4201054e:	534580        	max	a4, a5, a8
42010551:	10c182        	addi	a8, a1, 16
42010554:	02d882        	addmi	a8, a8, 0x200
42010557:	3a0882        	l8ui	a8, a8, 58
4201055a:	088c      	beqz.n	a8, 4201055e <_vfiprintf_r+0x18a2>
4201055c:	441b      	addi.n	a4, a4, 1
4201055e:	220c      	movi.n	a2, 2
42010560:	108320        	and	a8, a3, a2
42010563:	9e6182        	s32i	a8, a1, 0x278
42010566:	002816        	beqz	a8, 4201056c <_vfiprintf_r+0x18b0>
42010569:	02c442        	addi	a4, a4, 2
4201056c:	84a082        	movi	a8, 132
4201056f:	108380        	and	a8, a3, a8
42010572:	a36182        	s32i	a8, a1, 0x28c
42010575:	084856        	bnez	a8, 420105fd <_vfiprintf_r+0x1941>
42010578:	9c2182        	l32i	a8, a1, 0x270
4201057b:	10c122        	addi	a2, a1, 16
4201057e:	c08840        	sub	a8, a8, a4
42010581:	3218e6        	bgei	a8, 1, 420105b7 <_vfiprintf_r+0x18fb>
42010584:	001d46        	j	420105fd <_vfiprintf_r+0x1941>
42010587:	ccc200        	lsi	f0, a2, 0x330
4201058a:	1df910        	lsi	f1, a9, 116
4201058d:	bac9      	s32i.n	a12, a10, 44
4201058f:	aa99      	s32i.n	a9, a10, 40
42010591:	1c89a6        	blti	a9, 8, 420105b1 <_vfiprintf_r+0x18f5>
42010594:	24a2c2        	movi	a12, 0x224
42010597:	9821b2        	l32i	a11, a1, 0x260
4201059a:	9b21a2        	l32i	a10, a1, 0x26c
4201059d:	c2ca      	add.n	a12, a2, a12
4201059f:	976182        	s32i	a8, a1, 0x25c
420105a2:	fe6f65        	call8	4200ec98 <__sprint_r>
420105a5:	338a56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
420105a8:	e4a1b2        	movi	a11, 0x1e4
420105ab:	972182        	l32i	a8, a1, 0x25c
420105ae:	80b2b0        	add	a11, a2, a11
420105b1:	f0c882        	addi	a8, a8, -16
420105b4:	9761b2        	s32i	a11, a1, 0x25c
420105b7:	c1e8e1        	l32r	a14, 42000d58 <_stext+0xd38> (3c0296d8 <blanks$1>)
420105ba:	9721d2        	l32i	a13, a1, 0x25c
420105bd:	9721b2        	l32i	a11, a1, 0x25c
420105c0:	8a2292        	l32i	a9, a2, 0x228
420105c3:	0f1c      	movi.n	a15, 16
420105c5:	0de9      	s32i.n	a14, a13, 0
420105c7:	02d2a2        	addmi	a10, a2, 0x200
420105ca:	991b      	addi.n	a9, a9, 1
420105cc:	bb8b      	addi.n	a11, a11, 8
420105ce:	bac8      	l32i.n	a12, a10, 44
420105d0:	b42f87        	blt	a15, a8, 42010588 <_vfiprintf_r+0x18cc>
420105d3:	1d89      	s32i.n	a8, a13, 4
420105d5:	88ca      	add.n	a8, a8, a12
420105d7:	ba89      	s32i.n	a8, a10, 44
420105d9:	0a6a92        	s32i	a9, a10, 40
420105dc:	9761b2        	s32i	a11, a1, 0x25c
420105df:	1a89a6        	blti	a9, 8, 420105fd <_vfiprintf_r+0x1941>
420105e2:	24a2c2        	movi	a12, 0x224
420105e5:	9821b2        	l32i	a11, a1, 0x260
420105e8:	9b21a2        	l32i	a10, a1, 0x26c
420105eb:	80c2c0        	add	a12, a2, a12
420105ee:	fe6aa5        	call8	4200ec98 <__sprint_r>
420105f1:	2eca56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
420105f4:	e4a182        	movi	a8, 0x1e4
420105f7:	808280        	add	a8, a2, a8
420105fa:	976182        	s32i	a8, a1, 0x25c
420105fd:	10c182        	addi	a8, a1, 16
42010600:	02d8a2        	addmi	a10, a8, 0x200
42010603:	3a0a82        	l8ui	a8, a10, 58
42010606:	042816        	beqz	a8, 4201064c <_vfiprintf_r+0x1990>
42010609:	10c1c2        	addi	a12, a1, 16
4201060c:	3aa292        	movi	a9, 0x23a
4201060f:	9c9a      	add.n	a9, a12, a9
42010611:	ba88      	l32i.n	a8, a10, 44
42010613:	9721c2        	l32i	a12, a1, 0x25c
42010616:	aab8      	l32i.n	a11, a10, 40
42010618:	881b      	addi.n	a8, a8, 1
4201061a:	bb1b      	addi.n	a11, a11, 1
4201061c:	0c99      	s32i.n	a9, a12, 0
4201061e:	190c      	movi.n	a9, 1
42010620:	ba89      	s32i.n	a8, a10, 44
42010622:	1c99      	s32i.n	a9, a12, 4
42010624:	aab9      	s32i.n	a11, a10, 40
42010626:	8c8b      	addi.n	a8, a12, 8
42010628:	1d8ba6        	blti	a11, 8, 42010649 <_vfiprintf_r+0x198d>
4201062b:	24a2c2        	movi	a12, 0x224
4201062e:	10c182        	addi	a8, a1, 16
42010631:	9821b2        	l32i	a11, a1, 0x260
42010634:	9b21a2        	l32i	a10, a1, 0x26c
42010637:	80c8c0        	add	a12, a8, a12
4201063a:	fe65e5        	call8	4200ec98 <__sprint_r>
4201063d:	2a0a56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
42010640:	e4a182        	movi	a8, 0x1e4
42010643:	10c192        	addi	a9, a1, 16
42010646:	808980        	add	a8, a9, a8
42010649:	976182        	s32i	a8, a1, 0x25c
4201064c:	9e2182        	l32i	a8, a1, 0x278
4201064f:	049816        	beqz	a8, 4201069c <_vfiprintf_r+0x19e0>
42010652:	10c182        	addi	a8, a1, 16
42010655:	10c1c2        	addi	a12, a1, 16
42010658:	38a292        	movi	a9, 0x238
4201065b:	02d8b2        	addmi	a11, a8, 0x200
4201065e:	9c9a      	add.n	a9, a12, a9
42010660:	8f2182        	l32i	a8, a1, 0x23c
42010663:	9721c2        	l32i	a12, a1, 0x25c
42010666:	aba8      	l32i.n	a10, a11, 40
42010668:	882b      	addi.n	a8, a8, 2
4201066a:	aa1b      	addi.n	a10, a10, 1
4201066c:	0c99      	s32i.n	a9, a12, 0
4201066e:	290c      	movi.n	a9, 2
42010670:	bb89      	s32i.n	a8, a11, 44
42010672:	1c99      	s32i.n	a9, a12, 4
42010674:	aba9      	s32i.n	a10, a11, 40
42010676:	8c8b      	addi.n	a8, a12, 8
42010678:	1d8aa6        	blti	a10, 8, 42010699 <_vfiprintf_r+0x19dd>
4201067b:	24a2c2        	movi	a12, 0x224
4201067e:	10c182        	addi	a8, a1, 16
42010681:	9821b2        	l32i	a11, a1, 0x260
42010684:	9b21a2        	l32i	a10, a1, 0x26c
42010687:	80c8c0        	add	a12, a8, a12
4201068a:	fe60e5        	call8	4200ec98 <__sprint_r>
4201068d:	250a56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
42010690:	e4a182        	movi	a8, 0x1e4
42010693:	10c192        	addi	a9, a1, 16
42010696:	808980        	add	a8, a9, a8
42010699:	976182        	s32i	a8, a1, 0x25c
4201069c:	a32182        	l32i	a8, a1, 0x28c
4201069f:	02e826        	beqi	a8, 128, 420106a5 <_vfiprintf_r+0x19e9>
420106a2:	002286        	j	42010730 <_vfiprintf_r+0x1a74>
420106a5:	9c2182        	l32i	a8, a1, 0x270
420106a8:	10c122        	addi	a2, a1, 16
420106ab:	c0e840        	sub	a14, a8, a4
420106ae:	381ee6        	bgei	a14, 1, 420106ea <_vfiprintf_r+0x1a2e>
420106b1:	001ec6        	j	42010730 <_vfiprintf_r+0x1a74>
420106b4:	9721f2        	l32i	a15, a1, 0x25c
420106b7:	10cbb2        	addi	a11, a11, 16
420106ba:	0fc9      	s32i.n	a12, a15, 0
420106bc:	1fd9      	s32i.n	a13, a15, 4
420106be:	0b69b2        	s32i	a11, a9, 44
420106c1:	0a6982        	s32i	a8, a9, 40
420106c4:	1c88a6        	blti	a8, 8, 420106e4 <_vfiprintf_r+0x1a28>
420106c7:	24a2c2        	movi	a12, 0x224
420106ca:	9821b2        	l32i	a11, a1, 0x260
420106cd:	9b21a2        	l32i	a10, a1, 0x26c
420106d0:	80c2c0        	add	a12, a2, a12
420106d3:	9761e2        	s32i	a14, a1, 0x25c
420106d6:	fe5c25        	call8	4200ec98 <__sprint_r>
420106d9:	204a56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
420106dc:	e4a1a2        	movi	a10, 0x1e4
420106df:	9721e2        	l32i	a14, a1, 0x25c
420106e2:	a2aa      	add.n	a10, a2, a10
420106e4:	f0cee2        	addi	a14, a14, -16
420106e7:	9761a2        	s32i	a10, a1, 0x25c
420106ea:	9721a2        	l32i	a10, a1, 0x25c
420106ed:	8a2282        	l32i	a8, a2, 0x228
420106f0:	0d1c      	movi.n	a13, 16
420106f2:	02d292        	addmi	a9, a2, 0x200
420106f5:	c199c1        	l32r	a12, 42000d5c <_stext+0xd3c> (3c0296c8 <zeroes$0>)
420106f8:	881b      	addi.n	a8, a8, 1
420106fa:	aa8b      	addi.n	a10, a10, 8
420106fc:	b9b8      	l32i.n	a11, a9, 44
420106fe:	b22de7        	blt	a13, a14, 420106b4 <_vfiprintf_r+0x19f8>
42010701:	9721d2        	l32i	a13, a1, 0x25c
42010704:	beba      	add.n	a11, a14, a11
42010706:	0dc9      	s32i.n	a12, a13, 0
42010708:	1de9      	s32i.n	a14, a13, 4
4201070a:	0b69b2        	s32i	a11, a9, 44
4201070d:	0a6982        	s32i	a8, a9, 40
42010710:	9761a2        	s32i	a10, a1, 0x25c
42010713:	1988a6        	blti	a8, 8, 42010730 <_vfiprintf_r+0x1a74>
42010716:	24a2c2        	movi	a12, 0x224
42010719:	9821b2        	l32i	a11, a1, 0x260
4201071c:	9b21a2        	l32i	a10, a1, 0x26c
4201071f:	80c2c0        	add	a12, a2, a12
42010722:	fe5765        	call8	4200ec98 <__sprint_r>
42010725:	1b8a56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
42010728:	e4a182        	movi	a8, 0x1e4
4201072b:	828a      	add.n	a8, a2, a8
4201072d:	976182        	s32i	a8, a1, 0x25c
42010730:	9a2182        	l32i	a8, a1, 0x268
42010733:	c05580        	sub	a5, a5, a8
42010736:	0215e6        	bgei	a5, 1, 4201073c <_vfiprintf_r+0x1a80>
42010739:	002146        	j	420107c2 <_vfiprintf_r+0x1b06>
4201073c:	000dc6        	j	42010777 <_vfiprintf_r+0x1abb>
4201073f:	e20000        	remu	a0, a0, a0
42010742:	b29721        	l32r	a2, 41ffd1a0 <_coredump_iram_end+0x1c7b2a0>
42010745:	10cb      	addi.n	a1, a0, 12
42010747:	0ec9      	s32i.n	a12, a14, 0
42010749:	1ed9      	s32i.n	a13, a14, 4
4201074b:	b9b9      	s32i.n	a11, a9, 44
4201074d:	0a6982        	s32i	a8, a9, 40
42010750:	1d88a6        	blti	a8, 8, 42010771 <_vfiprintf_r+0x1ab5>
42010753:	24a2c2        	movi	a12, 0x224
42010756:	10c182        	addi	a8, a1, 16
42010759:	9821b2        	l32i	a11, a1, 0x260
4201075c:	9b21a2        	l32i	a10, a1, 0x26c
4201075f:	80c8c0        	add	a12, a8, a12
42010762:	fe5365        	call8	4200ec98 <__sprint_r>
42010765:	178a56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
42010768:	e4a1a2        	movi	a10, 0x1e4
4201076b:	10c182        	addi	a8, a1, 16
4201076e:	80a8a0        	add	a10, a8, a10
42010771:	f0c552        	addi	a5, a5, -16
42010774:	9761a2        	s32i	a10, a1, 0x25c
42010777:	10c182        	addi	a8, a1, 16
4201077a:	02d892        	addmi	a9, a8, 0x200
4201077d:	a988      	l32i.n	a8, a9, 40
4201077f:	9721a2        	l32i	a10, a1, 0x25c
42010782:	0d1c      	movi.n	a13, 16
42010784:	c176c1        	l32r	a12, 42000d5c <_stext+0xd3c> (3c0296c8 <zeroes$0>)
42010787:	881b      	addi.n	a8, a8, 1
42010789:	aa8b      	addi.n	a10, a10, 8
4201078b:	b9b8      	l32i.n	a11, a9, 44
4201078d:	b02d57        	blt	a13, a5, 42010741 <_vfiprintf_r+0x1a85>
42010790:	9721d2        	l32i	a13, a1, 0x25c
42010793:	a989      	s32i.n	a8, a9, 40
42010795:	1d59      	s32i.n	a5, a13, 4
42010797:	55ba      	add.n	a5, a5, a11
42010799:	0dc9      	s32i.n	a12, a13, 0
4201079b:	b959      	s32i.n	a5, a9, 44
4201079d:	9761a2        	s32i	a10, a1, 0x25c
420107a0:	1e88a6        	blti	a8, 8, 420107c2 <_vfiprintf_r+0x1b06>
420107a3:	24a2c2        	movi	a12, 0x224
420107a6:	10c182        	addi	a8, a1, 16
420107a9:	9821b2        	l32i	a11, a1, 0x260
420107ac:	9b21a2        	l32i	a10, a1, 0x26c
420107af:	c8ca      	add.n	a12, a8, a12
420107b1:	fe4e65        	call8	4200ec98 <__sprint_r>
420107b4:	129a56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
420107b7:	e4a182        	movi	a8, 0x1e4
420107ba:	10c192        	addi	a9, a1, 16
420107bd:	898a      	add.n	a8, a9, a8
420107bf:	976182        	s32i	a8, a1, 0x25c
420107c2:	9a2192        	l32i	a9, a1, 0x268
420107c5:	972182        	l32i	a8, a1, 0x25c
420107c8:	9a21a2        	l32i	a10, a1, 0x268
420107cb:	1899      	s32i.n	a9, a8, 4
420107cd:	0869      	s32i.n	a6, a8, 0
420107cf:	10c182        	addi	a8, a1, 16
420107d2:	02d892        	addmi	a9, a8, 0x200
420107d5:	8f2182        	l32i	a8, a1, 0x23c
420107d8:	88aa      	add.n	a8, a8, a10
420107da:	b989      	s32i.n	a8, a9, 44
420107dc:	a988      	l32i.n	a8, a9, 40
420107de:	881b      	addi.n	a8, a8, 1
420107e0:	a989      	s32i.n	a8, a9, 40
420107e2:	0788e6        	bgei	a8, 8, 420107ed <_vfiprintf_r+0x1b31>
420107e5:	972182        	l32i	a8, a1, 0x25c
420107e8:	888b      	addi.n	a8, a8, 8
420107ea:	0006c6        	j	42010809 <_vfiprintf_r+0x1b4d>
420107ed:	24a2c2        	movi	a12, 0x224
420107f0:	10c182        	addi	a8, a1, 16
420107f3:	9821b2        	l32i	a11, a1, 0x260
420107f6:	9b21a2        	l32i	a10, a1, 0x26c
420107f9:	c8ca      	add.n	a12, a8, a12
420107fb:	fe49e5        	call8	4200ec98 <__sprint_r>
420107fe:	0dfa56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
42010801:	e4a182        	movi	a8, 0x1e4
42010804:	10c192        	addi	a9, a1, 16
42010807:	898a      	add.n	a8, a9, a8
42010809:	17e327        	bbsi	a3, 2, 42010824 <_vfiprintf_r+0x1b68>
4201080c:	9c2182        	l32i	a8, a1, 0x270
4201080f:	534840        	max	a4, a8, a4
42010812:	9d2182        	l32i	a8, a1, 0x274
42010815:	884a      	add.n	a8, a8, a4
42010817:	9d6182        	s32i	a8, a1, 0x274
4201081a:	8f2182        	l32i	a8, a1, 0x23c
4201081d:	06d816        	beqz	a8, 4201088e <_vfiprintf_r+0x1bd2>
42010820:	001fc6        	j	420108a3 <_vfiprintf_r+0x1be7>
42010823:	219200        	srai	a9, a0, 2
42010826:	409c      	beqz.n	a0, 4201083e <_vfiprintf_r+0x1b82>
42010828:	c069      	s32i.n	a6, a0, 48
4201082a:	de16a6        	blti	a6, 1, 4201080c <_vfiprintf_r+0x1b50>
4201082d:	10c152        	addi	a5, a1, 16
42010830:	0009c6        	j	4201085b <_vfiprintf_r+0x1b9f>
42010833:	cbb200        	movf.s	f11, f2, b0
42010836:	18d910        	lsxp	f13, a9, a1
42010839:	bab9      	s32i.n	a11, a10, 44
4201083b:	aa99      	s32i.n	a9, a10, 40
4201083d:	888b      	addi.n	a8, a8, 8
4201083f:	1589a6        	blti	a9, 8, 42010858 <_vfiprintf_r+0x1b9c>
42010842:	24a2c2        	movi	a12, 0x224
42010845:	9821b2        	l32i	a11, a1, 0x260
42010848:	9b21a2        	l32i	a10, a1, 0x26c
4201084b:	c5ca      	add.n	a12, a5, a12
4201084d:	fe44a5        	call8	4200ec98 <__sprint_r>
42010850:	08da56        	bnez	a10, 420108e1 <_vfiprintf_r+0x1c25>
42010853:	e4a182        	movi	a8, 0x1e4
42010856:	858a      	add.n	a8, a5, a8
42010858:	f0c662        	addi	a6, a6, -16
4201085b:	c13fc1        	l32r	a12, 42000d58 <_stext+0xd38> (3c0296d8 <blanks$1>)
4201085e:	8a2592        	l32i	a9, a5, 0x228
42010861:	0d1c      	movi.n	a13, 16
42010863:	08c9      	s32i.n	a12, a8, 0
42010865:	02d5a2        	addmi	a10, a5, 0x200
42010868:	991b      	addi.n	a9, a9, 1
4201086a:	bab8      	l32i.n	a11, a10, 44
4201086c:	c42d67        	blt	a13, a6, 42010834 <_vfiprintf_r+0x1b78>
4201086f:	1869      	s32i.n	a6, a8, 4
42010871:	66ba      	add.n	a6, a6, a11
42010873:	ba69      	s32i.n	a6, a10, 44
42010875:	aa99      	s32i.n	a9, a10, 40
42010877:	9189a6        	blti	a9, 8, 4201080c <_vfiprintf_r+0x1b50>
4201087a:	24a2c2        	movi	a12, 0x224
4201087d:	9821b2        	l32i	a11, a1, 0x260
42010880:	9b21a2        	l32i	a10, a1, 0x26c
42010883:	c5ca      	add.n	a12, a5, a12
42010885:	fe4125        	call8	4200ec98 <__sprint_r>
42010888:	f80a16        	beqz	a10, 4201080c <_vfiprintf_r+0x1b50>
4201088b:	001486        	j	420108e1 <_vfiprintf_r+0x1c25>
4201088e:	090c      	movi.n	a9, 0
42010890:	8e6192        	s32i	a9, a1, 0x238
42010893:	e4a182        	movi	a8, 0x1e4
42010896:	10c192        	addi	a9, a1, 16
42010899:	898a      	add.n	a8, a9, a8
4201089b:	075d      	mov.n	a5, a7
4201089d:	976182        	s32i	a8, a1, 0x25c
420108a0:	f94d06        	j	4200edd8 <_vfiprintf_r+0x11c>
420108a3:	24a2c2        	movi	a12, 0x224
420108a6:	10c182        	addi	a8, a1, 16
420108a9:	9821b2        	l32i	a11, a1, 0x260
420108ac:	9b21a2        	l32i	a10, a1, 0x26c
420108af:	c8ca      	add.n	a12, a8, a12
420108b1:	fe3e65        	call8	4200ec98 <__sprint_r>
420108b4:	fd6a16        	beqz	a10, 4201088e <_vfiprintf_r+0x1bd2>
420108b7:	000986        	j	420108e1 <_vfiprintf_r+0x1c25>
420108ba:	820000        	mull	a0, a0, a0
420108bd:	728f21        	l32r	a2, 41fed2fc <_coredump_iram_end+0x1c6b3fc>
420108c0:	cc10c1        	l32r	a12, 42003900 <rtc_isr_register+0x1c> (391a7903 <UserFrameTotalSize+0x391a7803>)
420108c3:	0ca8      	l32i.n	a10, a12, 0
420108c5:	8208      	l32i.n	a0, a2, 32
420108c7:	728a67        	bany	a10, a6, 4201093d <vfiprintf+0x1d>
420108ca:	4602d7        	bnone	a2, a13, 42010914 <_vfiprintf_r+0x1c58>
420108cd:	000004        	lsi	f0, a0, 0
420108d0:	24a2c2        	movi	a12, 0x224
420108d3:	9821b2        	l32i	a11, a1, 0x260
420108d6:	9b21a2        	l32i	a10, a1, 0x26c
420108d9:	c7ca      	add.n	a12, a7, a12
420108db:	fe3be5        	call8	4200ec98 <__sprint_r>
420108de:	fe2a16        	beqz	a10, 420108c4 <_vfiprintf_r+0x1c08>
420108e1:	982182        	l32i	a8, a1, 0x260
420108e4:	192882        	l32i	a8, a8, 100
420108e7:	14e807        	bbsi	a8, 0, 420108ff <_vfiprintf_r+0x1c43>
420108ea:	982182        	l32i	a8, a1, 0x260
420108ed:	061882        	l16ui	a8, a8, 12
420108f0:	0be897        	bbsi	a8, 9, 420108ff <_vfiprintf_r+0x1c43>
420108f3:	982182        	l32i	a8, a1, 0x260
420108f6:	1628a2        	l32i	a10, a8, 88
420108f9:	c0d281        	l32r	a8, 42000c44 <_stext+0xc24> (40376b68 <__retarget_lock_release_recursive>)
420108fc:	0008e0        	callx8	a8
420108ff:	982182        	l32i	a8, a1, 0x260
42010902:	061882        	l16ui	a8, a8, 12
42010905:	0f6867        	bbci	a8, 6, 42010918 <_vfiprintf_r+0x1c5c>
42010908:	f90746        	j	4200ed29 <_vfiprintf_r+0x6d>
4201090b:	9a2192        	l32i	a9, a1, 0x268
4201090e:	03ad      	mov.n	a10, a3
42010910:	180c      	movi.n	a8, 1
42010912:	a7f9d6        	bgez	a9, 42010395 <_vfiprintf_r+0x16d9>
42010915:	feb746        	j	420103f6 <_vfiprintf_r+0x173a>
42010918:	9d2122        	l32i	a2, a1, 0x274
4201091b:	f01d      	retw.n
4201091d:	000000        	ill

42010920 <vfiprintf>:
42010920:	006136        	entry	a1, 48
42010923:	0149      	s32i.n	a4, a1, 0
42010925:	1159      	s32i.n	a5, a1, 4
42010927:	026162        	s32i	a6, a1, 8
4201092a:	bf8981        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
4201092d:	0008e0        	callx8	a8
42010930:	01d8      	l32i.n	a13, a1, 0
42010932:	11e8      	l32i.n	a14, a1, 4
42010934:	21f8      	l32i.n	a15, a1, 8
42010936:	02bd      	mov.n	a11, a2
42010938:	03cd      	mov.n	a12, a3
4201093a:	fe3825        	call8	4200ecbc <_vfiprintf_r>
4201093d:	0a2d      	mov.n	a2, a10
4201093f:	f01d      	retw.n
42010941:	000000        	ill

42010944 <__sbprintf>:
42010944:	024136        	entry	a1, 0x120
42010947:	078d      	mov.n	a8, a7
42010949:	027d      	mov.n	a7, a2
4201094b:	f0a022        	movi	a2, 240
4201094e:	212a      	add.n	a2, a1, a2
42010950:	2289      	s32i.n	a8, a2, 8
42010952:	061382        	l16ui	a8, a3, 12
42010955:	d97c      	movi.n	a9, -3
42010957:	108890        	and	a8, a8, a9
4201095a:	465182        	s16i	a8, a1, 140
4201095d:	192382        	l32i	a8, a3, 100
42010960:	1269      	s32i.n	a6, a2, 4
42010962:	396182        	s32i	a8, a1, 228
42010965:	071382        	l16ui	a8, a3, 14
42010968:	80a062        	movi	a6, 128
4201096b:	475182        	s16i	a8, a1, 142
4201096e:	8388      	l32i.n	a8, a3, 32
42010970:	226162        	s32i	a6, a1, 136
42010973:	286182        	s32i	a8, a1, 160
42010976:	a388      	l32i.n	a8, a3, 40
42010978:	256162        	s32i	a6, a1, 148
4201097b:	616a      	add.n	a6, a1, a6
4201097d:	0259      	s32i.n	a5, a2, 0
4201097f:	2a6182        	s32i	a8, a1, 168
42010982:	58c6a2        	addi	a10, a6, 88
42010985:	080c      	movi.n	a8, 0
42010987:	266182        	s32i	a8, a1, 152
4201098a:	206112        	s32i	a1, a1, 128
4201098d:	246112        	s32i	a1, a1, 144
42010990:	c0b981        	l32r	a8, 42000c74 <_stext+0xc54> (40376a90 <__retarget_lock_init_recursive>)
42010993:	0008e0        	callx8	a8
42010996:	02d8      	l32i.n	a13, a2, 0
42010998:	12e8      	l32i.n	a14, a2, 4
4201099a:	22f8      	l32i.n	a15, a2, 8
4201099c:	04cd      	mov.n	a12, a4
4201099e:	06bd      	mov.n	a11, a6
420109a0:	07ad      	mov.n	a10, a7
420109a2:	fe31a5        	call8	4200ecbc <_vfiprintf_r>
420109a5:	0a2d      	mov.n	a2, a10
420109a7:	00ea96        	bltz	a10, 420109b9 <__sbprintf+0x75>
420109aa:	06bd      	mov.n	a11, a6
420109ac:	07ad      	mov.n	a10, a7
420109ae:	201110        	or	a1, a1, a1
420109b1:	f9e3a5        	call8	4200a7ec <_fflush_r>
420109b4:	f87c      	movi.n	a8, -1
420109b6:	9328a0        	movnez	a2, a8, a10
420109b9:	461182        	l16ui	a8, a1, 140
420109bc:	094c      	movi.n	a9, 64
420109be:	080897        	bnone	a8, a9, 420109ca <__sbprintf+0x86>
420109c1:	061382        	l16ui	a8, a3, 12
420109c4:	208890        	or	a8, a8, a9
420109c7:	065382        	s16i	a8, a3, 12
420109ca:	3621a2        	l32i	a10, a1, 216
420109cd:	c09f81        	l32r	a8, 42000c4c <_stext+0xc2c> (40376ab4 <__retarget_lock_close_recursive>)
420109d0:	0008e0        	callx8	a8
420109d3:	f01d      	retw.n
420109d5:	000000        	ill

420109d8 <__swhatbuf_r>:
420109d8:	010136        	entry	a1, 128
420109db:	0793b2        	l16si	a11, a3, 14
420109de:	20a220        	or	a10, a2, a2
420109e1:	018bd6        	bgez	a11, 420109fd <__swhatbuf_r+0x25>
420109e4:	061392        	l16ui	a9, a3, 12
420109e7:	080c      	movi.n	a8, 0
420109e9:	0589      	s32i.n	a8, a5, 0
420109eb:	049790        	extui	a9, a9, 7, 1
420109ee:	0a4c      	movi.n	a10, 64
420109f0:	80a082        	movi	a8, 128
420109f3:	938a90        	movnez	a8, a10, a9
420109f6:	0489      	s32i.n	a8, a4, 0
420109f8:	020c      	movi.n	a2, 0
420109fa:	0010c6        	j	42010a41 <__swhatbuf_r+0x69>
420109fd:	01cd      	mov.n	a12, a1
420109ff:	201110        	or	a1, a1, a1
42010a02:	f64f65        	call8	42006ef8 <_fstat_r>
42010a05:	fdba96        	bltz	a10, 420109e4 <__swhatbuf_r+0xc>
42010a08:	1188      	l32i.n	a8, a1, 4
42010a0a:	348c80        	extui	a8, a8, 12, 4
42010a0d:	118840        	slli	a8, a8, 12
42010a10:	e0d892        	addmi	a9, a8, 0xffffe000
42010a13:	40f990        	nsau	a9, a9
42010a16:	419590        	srli	a9, a9, 5
42010a19:	0599      	s32i.n	a9, a5, 0
42010a1b:	122192        	l32i	a9, a1, 72
42010a1e:	1719a6        	blti	a9, 1, 42010a39 <__swhatbuf_r+0x61>
42010a21:	0499      	s32i.n	a9, a4, 0
42010a23:	146392        	s32i	a9, a3, 80
42010a26:	190c      	movi.n	a9, 1
42010a28:	119910        	slli	a9, a9, 15
42010a2b:	00a422        	movi	a2, 0x400
42010a2e:	0f1897        	beq	a8, a9, 42010a41 <__swhatbuf_r+0x69>
42010a31:	120c      	movi.n	a2, 1
42010a33:	112250        	slli	a2, a2, 11
42010a36:	0001c6        	j	42010a41 <__swhatbuf_r+0x69>
42010a39:	80a082        	movi	a8, 128
42010a3c:	0489      	s32i.n	a8, a4, 0
42010a3e:	fffbc6        	j	42010a31 <__swhatbuf_r+0x59>
42010a41:	f01d      	retw.n
	...

42010a44 <__smakebuf_r>:
42010a44:	006136        	entry	a1, 48
42010a47:	061382        	l16ui	a8, a3, 12
42010a4a:	250c      	movi.n	a5, 2
42010a4c:	020857        	bnone	a8, a5, 42010a52 <__smakebuf_r+0xe>
42010a4f:	000b06        	j	42010a7f <__smakebuf_r+0x3b>
42010a52:	01dd      	mov.n	a13, a1
42010a54:	c14b      	addi.n	a12, a1, 4
42010a56:	03bd      	mov.n	a11, a3
42010a58:	20a220        	or	a10, a2, a2
42010a5b:	fff7e5        	call8	420109d8 <__swhatbuf_r>
42010a5e:	1168      	l32i.n	a6, a1, 4
42010a60:	0a7d      	mov.n	a7, a10
42010a62:	06bd      	mov.n	a11, a6
42010a64:	02ad      	mov.n	a10, a2
42010a66:	c08881        	l32r	a8, 42000c88 <_stext+0xc68> (4037fea4 <_malloc_r>)
42010a69:	0008e0        	callx8	a8
42010a6c:	069382        	l16si	a8, a3, 12
42010a6f:	aadc      	bnez.n	a10, 42010a8d <__smakebuf_r+0x49>
42010a71:	54e897        	bbsi	a8, 9, 42010ac9 <__smakebuf_r+0x85>
42010a74:	c97c      	movi.n	a9, -4
42010a76:	108890        	and	a8, a8, a9
42010a79:	208850        	or	a8, a8, a5
42010a7c:	065382        	s16i	a8, a3, 12
42010a7f:	47c382        	addi	a8, a3, 71
42010a82:	0389      	s32i.n	a8, a3, 0
42010a84:	4389      	s32i.n	a8, a3, 16
42010a86:	180c      	movi.n	a8, 1
42010a88:	5389      	s32i.n	a8, a3, 20
42010a8a:	000ec6        	j	42010ac9 <__smakebuf_r+0x85>
42010a8d:	80a092        	movi	a9, 128
42010a90:	208890        	or	a8, a8, a9
42010a93:	065382        	s16i	a8, a3, 12
42010a96:	0188      	l32i.n	a8, a1, 0
42010a98:	03a9      	s32i.n	a10, a3, 0
42010a9a:	43a9      	s32i.n	a10, a3, 16
42010a9c:	056362        	s32i	a6, a3, 20
42010a9f:	01d816        	beqz	a8, 42010ac0 <__smakebuf_r+0x7c>
42010aa2:	0793b2        	l16si	a11, a3, 14
42010aa5:	20a220        	or	a10, a2, a2
42010aa8:	201110        	or	a1, a1, a1
42010aab:	03e965        	call8	42014940 <_getpid_r>
42010aae:	ea8c      	beqz.n	a10, 42010ac0 <__smakebuf_r+0x7c>
42010ab0:	061382        	l16ui	a8, a3, 12
42010ab3:	c97c      	movi.n	a9, -4
42010ab5:	108890        	and	a8, a8, a9
42010ab8:	190c      	movi.n	a9, 1
42010aba:	208890        	or	a8, a8, a9
42010abd:	065382        	s16i	a8, a3, 12
42010ac0:	061382        	l16ui	a8, a3, 12
42010ac3:	207780        	or	a7, a7, a8
42010ac6:	065372        	s16i	a7, a3, 12
42010ac9:	f01d      	retw.n
	...

42010acc <lflush>:
42010acc:	004136        	entry	a1, 32
42010acf:	061392        	l16ui	a9, a3, 12
42010ad2:	09a082        	movi	a8, 9
42010ad5:	020c      	movi.n	a2, 0
42010ad7:	0fc987        	bnall	a9, a8, 42010aea <lflush+0x1e>
42010ada:	bf1d81        	l32r	a8, 42000750 <_stext+0x730> (4037c808 <__getreent>)
42010add:	0008e0        	callx8	a8
42010ae0:	03bd      	mov.n	a11, a3
42010ae2:	201110        	or	a1, a1, a1
42010ae5:	f9d065        	call8	4200a7ec <_fflush_r>
42010ae8:	0a2d      	mov.n	a2, a10
42010aea:	f01d      	retw.n

42010aec <__srefill_r>:
42010aec:	004136        	entry	a1, 32
42010aef:	b28c      	beqz.n	a2, 42010afe <__srefill_r+0x12>
42010af1:	a288      	l32i.n	a8, a2, 40
42010af3:	78cc      	bnez.n	a8, 42010afe <__srefill_r+0x12>
42010af5:	20a220        	or	a10, a2, a2
42010af8:	201110        	or	a1, a1, a1
42010afb:	f9f5a5        	call8	4200aa54 <__sinit>
42010afe:	080c      	movi.n	a8, 0
42010b00:	1389      	s32i.n	a8, a3, 4
42010b02:	069382        	l16si	a8, a3, 12
42010b05:	11e857        	bbsi	a8, 5, 42010b1a <__srefill_r+0x2e>
42010b08:	40e827        	bbsi	a8, 2, 42010b4c <__srefill_r+0x60>
42010b0b:	11e847        	bbsi	a8, 4, 42010b20 <__srefill_r+0x34>
42010b0e:	990c      	movi.n	a9, 9
42010b10:	0299      	s32i.n	a9, a2, 0
42010b12:	094c      	movi.n	a9, 64
42010b14:	208890        	or	a8, a8, a9
42010b17:	065382        	s16i	a8, a3, 12
42010b1a:	f27c      	movi.n	a2, -1
42010b1c:	002ec6        	j	42010bdb <__srefill_r+0xef>
42010b1f:	683700        	lsi	f0, a7, 0x1a0
42010b22:	bd1c      	movi.n	a13, 27
42010b24:	02ad03        	lsi	f0, a13, 8
42010b27:	201110        	or	a1, a1, a1
42010b2a:	f9cc25        	call8	4200a7ec <_fflush_r>
42010b2d:	fe9a56        	bnez	a10, 42010b1a <__srefill_r+0x2e>
42010b30:	061382        	l16ui	a8, a3, 12
42010b33:	797c      	movi.n	a9, -9
42010b35:	108890        	and	a8, a8, a9
42010b38:	238880        	sext	a8, a8, 15
42010b3b:	23a9      	s32i.n	a10, a3, 8
42010b3d:	0663a2        	s32i	a10, a3, 24
42010b40:	490c      	movi.n	a9, 4
42010b42:	208890        	or	a8, a8, a9
42010b45:	065382        	s16i	a8, a3, 12
42010b48:	000986        	j	42010b72 <__srefill_r+0x86>
42010b4b:	d3b800        	movt	a11, a8, b0
42010b4e:	0bac      	beqz.n	a11, 42010b72 <__srefill_r+0x86>
42010b50:	44c382        	addi	a8, a3, 68
42010b53:	071b87        	beq	a11, a8, 42010b5e <__srefill_r+0x72>
42010b56:	02ad      	mov.n	a10, a2
42010b58:	c03c81        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
42010b5b:	0008e0        	callx8	a8
42010b5e:	080c      	movi.n	a8, 0
42010b60:	d389      	s32i.n	a8, a3, 52
42010b62:	102382        	l32i	a8, a3, 64
42010b65:	1389      	s32i.n	a8, a3, 4
42010b67:	788c      	beqz.n	a8, 42010b72 <__srefill_r+0x86>
42010b69:	f388      	l32i.n	a8, a3, 60
42010b6b:	0389      	s32i.n	a8, a3, 0
42010b6d:	001546        	j	42010bc6 <__srefill_r+0xda>
42010b70:	880000        	lsi	f0, a0, 0x220
42010b73:	98cc43        	ssip	f4, a12, 0x260
42010b76:	03bd      	mov.n	a11, a3
42010b78:	20a220        	or	a10, a2, a2
42010b7b:	201110        	or	a1, a1, a1
42010b7e:	ffec65        	call8	42010a44 <__smakebuf_r>
42010b81:	061372        	l16ui	a7, a3, 12
42010b84:	148070        	extui	a8, a7, 0, 2
42010b87:	236780        	sext	a6, a7, 15
42010b8a:	48ac      	beqz.n	a8, 42010bb2 <__srefill_r+0xc6>
42010b8c:	180c      	movi.n	a8, 1
42010b8e:	bef9c1        	l32r	a12, 42000774 <_stext+0x754> (3fc92694 <__sglue>)
42010b91:	c073b1        	l32r	a11, 42000d60 <_stext+0xd40> (42010acc <lflush>)
42010b94:	bef5a1        	l32r	a10, 42000768 <_stext+0x748> (3fc926a4 <_impure_data>)
42010b97:	065382        	s16i	a8, a3, 12
42010b9a:	201110        	or	a1, a1, a1
42010b9d:	03f825        	call8	42014b20 <_fwalk_sglue>
42010ba0:	980c      	movi.n	a8, 9
42010ba2:	065372        	s16i	a7, a3, 12
42010ba5:	09c687        	bnall	a6, a8, 42010bb2 <__srefill_r+0xc6>
42010ba8:	03bd      	mov.n	a11, a3
42010baa:	02ad      	mov.n	a10, a2
42010bac:	201110        	or	a1, a1, a1
42010baf:	f9b0a5        	call8	4200a6b8 <__sflush_r>
42010bb2:	43c8      	l32i.n	a12, a3, 16
42010bb4:	9388      	l32i.n	a8, a3, 36
42010bb6:	53d8      	l32i.n	a13, a3, 20
42010bb8:	83b8      	l32i.n	a11, a3, 32
42010bba:	03c9      	s32i.n	a12, a3, 0
42010bbc:	02ad      	mov.n	a10, a2
42010bbe:	0008e0        	callx8	a8
42010bc1:	13a9      	s32i.n	a10, a3, 4
42010bc3:	051aa6        	blti	a10, 1, 42010bcc <__srefill_r+0xe0>
42010bc6:	020c      	movi.n	a2, 0
42010bc8:	0003c6        	j	42010bdb <__srefill_r+0xef>
42010bcb:	938200        	movnez	a8, a2, a0
42010bce:	092c06        	j	42013082 <_svfiprintf_r+0x62a>
42010bd1:	f3fa16        	beqz	a10, 42010b14 <__srefill_r+0x28>
42010bd4:	090c      	movi.n	a9, 0
42010bd6:	1399      	s32i.n	a9, a3, 4
42010bd8:	ffcd86        	j	42010b12 <__srefill_r+0x26>
42010bdb:	f01d      	retw.n
42010bdd:	000000        	ill

42010be0 <__localeconv_l>:
42010be0:	004136        	entry	a1, 32
42010be3:	f0a082        	movi	a8, 240
42010be6:	228a      	add.n	a2, a2, a8
42010be8:	f01d      	retw.n
	...

42010bec <_localeconv_r>:
42010bec:	004136        	entry	a1, 32
42010bef:	c05d81        	l32r	a8, 42000d64 <_stext+0xd44> (3fc92798 <__global_locale_ptr>)
42010bf2:	0828      	l32i.n	a2, a8, 0
42010bf4:	f0a082        	movi	a8, 240
42010bf7:	228a      	add.n	a2, a2, a8
42010bf9:	f01d      	retw.n
	...

42010bfc <localeconv>:
42010bfc:	004136        	entry	a1, 32
42010bff:	c05981        	l32r	a8, 42000d64 <_stext+0xd44> (3fc92798 <__global_locale_ptr>)
42010c02:	0828      	l32i.n	a2, a8, 0
42010c04:	f0a082        	movi	a8, 240
42010c07:	228a      	add.n	a2, a2, a8
42010c09:	f01d      	retw.n
	...

42010c0c <frexp>:
42010c0c:	004136        	entry	a1, 32
42010c0f:	0c0c      	movi.n	a12, 0
42010c11:	833a      	add.n	a8, a3, a3
42010c13:	04c9      	s32i.n	a12, a4, 0
42010c15:	c03dc1        	l32r	a12, 42000d0c <_stext+0xcec> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
42010c18:	418180        	srli	a8, a8, 1
42010c1b:	02ad      	mov.n	a10, a2
42010c1d:	03bd      	mov.n	a11, a3
42010c1f:	039d      	mov.n	a9, a3
42010c21:	403c87        	bltu	a12, a8, 42010c65 <frexp+0x59>
42010c24:	20c820        	or	a12, a8, a2
42010c27:	acbc      	beqz.n	a12, 42010c65 <frexp+0x59>
42010c29:	a5c430        	extui	a12, a3, 20, 11
42010c2c:	8cdc      	bnez.n	a12, 42010c48 <frexp+0x3c>
42010c2e:	35a4d2        	movi	a13, 0x435
42010c31:	0c0c      	movi.n	a12, 0
42010c33:	01ddc0        	slli	a13, a13, 20
42010c36:	c03981        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42010c39:	0008e0        	callx8	a8
42010c3c:	8bba      	add.n	a8, a11, a11
42010c3e:	caafc2        	movi	a12, -54
42010c41:	0b9d      	mov.n	a9, a11
42010c43:	418180        	srli	a8, a8, 1
42010c46:	04c9      	s32i.n	a12, a4, 0
42010c48:	02acc2        	movi	a12, 0xfffffc02
42010c4b:	318480        	srai	a8, a8, 20
42010c4e:	88ca      	add.n	a8, a8, a12
42010c50:	04c8      	l32i.n	a12, a4, 0
42010c52:	8c8a      	add.n	a8, a12, a8
42010c54:	0489      	s32i.n	a8, a4, 0
42010c56:	c04481        	l32r	a8, 42000d68 <_stext+0xd48> (800fffff <_rtc_reserved_end+0x1fffffff>)
42010c59:	109980        	and	a9, a9, a8
42010c5c:	ffa182        	movi	a8, 0x1ff
42010c5f:	0188b0        	slli	a8, a8, 21
42010c62:	20b980        	or	a11, a9, a8
42010c65:	0a2d      	mov.n	a2, a10
42010c67:	0b3d      	mov.n	a3, a11
42010c69:	f01d      	retw.n
	...

42010c6c <quorem>:
42010c6c:	006136        	entry	a1, 48
42010c6f:	4288      	l32i.n	a8, a2, 16
42010c71:	4378      	l32i.n	a7, a3, 16
42010c73:	025d      	mov.n	a5, a2
42010c75:	03bd      	mov.n	a11, a3
42010c77:	020c      	movi.n	a2, 0
42010c79:	02a877        	bge	a8, a7, 42010c7f <quorem+0x13>
42010c7c:	004886        	j	42010da2 <quorem+0x136>
42010c7f:	770b      	addi.n	a7, a7, -1
42010c81:	1187e0        	slli	a8, a7, 2
42010c84:	14c362        	addi	a6, a3, 20
42010c87:	368a      	add.n	a3, a6, a8
42010c89:	14c542        	addi	a4, a5, 20
42010c8c:	0398      	l32i.n	a9, a3, 0
42010c8e:	a48a      	add.n	a10, a4, a8
42010c90:	0ac8      	l32i.n	a12, a10, 0
42010c92:	991b      	addi.n	a9, a9, 1
42010c94:	c22c90        	quou	a2, a12, a9
42010c97:	02bc97        	bgeu	a12, a9, 42010c9d <quorem+0x31>
42010c9a:	002386        	j	42010d2c <quorem+0xc0>
42010c9d:	090c      	movi.n	a9, 0
42010c9f:	1199      	s32i.n	a9, a1, 4
42010ca1:	0199      	s32i.n	a9, a1, 0
42010ca3:	8b8a      	add.n	a8, a11, a8
42010ca5:	c09360        	sub	a9, a3, a6
42010ca8:	419290        	srli	a9, a9, 2
42010cab:	18cbc2        	addi	a12, a11, 24
42010cae:	18c882        	addi	a8, a8, 24
42010cb1:	04dd      	mov.n	a13, a4
42010cb3:	06ed      	mov.n	a14, a6
42010cb5:	991b      	addi.n	a9, a9, 1
42010cb7:	02b8c7        	bgeu	a8, a12, 42010cbd <quorem+0x51>
42010cba:	01a092        	movi	a9, 1
42010cbd:	4e8976        	loop	a9, 42010d0f <quorem+0xa3>
42010cc0:	0e88      	l32i.n	a8, a14, 0
42010cc2:	11f8      	l32i.n	a15, a1, 4
42010cc4:	f4c080        	extui	a12, a8, 0, 16
42010cc7:	82cc20        	mull	a12, a12, a2
42010cca:	f58080        	extui	a8, a8, 16, 16
42010ccd:	ccfa      	add.n	a12, a12, a15
42010ccf:	828820        	mull	a8, a8, a2
42010cd2:	f5f0c0        	extui	a15, a12, 16, 16
42010cd5:	88fa      	add.n	a8, a8, a15
42010cd7:	f5f080        	extui	a15, a8, 16, 16
42010cda:	11f9      	s32i.n	a15, a1, 4
42010cdc:	0df8      	l32i.n	a15, a13, 0
42010cde:	f4c0c0        	extui	a12, a12, 0, 16
42010ce1:	f4f0f0        	extui	a15, a15, 0, 16
42010ce4:	c0ffc0        	sub	a15, a15, a12
42010ce7:	01c8      	l32i.n	a12, a1, 0
42010ce9:	f48080        	extui	a8, a8, 0, 16
42010cec:	ffca      	add.n	a15, a15, a12
42010cee:	0dc8      	l32i.n	a12, a13, 0
42010cf0:	ee4b      	addi.n	a14, a14, 4
42010cf2:	f5c0c0        	extui	a12, a12, 16, 16
42010cf5:	c08c80        	sub	a8, a12, a8
42010cf8:	31c0f0        	srai	a12, a15, 16
42010cfb:	88ca      	add.n	a8, a8, a12
42010cfd:	31c080        	srai	a12, a8, 16
42010d00:	f4f0f0        	extui	a15, a15, 0, 16
42010d03:	118800        	slli	a8, a8, 16
42010d06:	2088f0        	or	a8, a8, a15
42010d09:	0d89      	s32i.n	a8, a13, 0
42010d0b:	01c9      	s32i.n	a12, a1, 0
42010d0d:	dd4b      	addi.n	a13, a13, 4
42010d0f:	0a88      	l32i.n	a8, a10, 0
42010d11:	388c      	beqz.n	a8, 42010d18 <quorem+0xac>
42010d13:	000546        	j	42010d2c <quorem+0xc0>
42010d16:	770b      	addi.n	a7, a7, -1
42010d18:	fccaa2        	addi	a10, a10, -4
42010d1b:	0534a7        	bltu	a4, a10, 42010d24 <quorem+0xb8>
42010d1e:	4579      	s32i.n	a7, a5, 16
42010d20:	000206        	j	42010d2c <quorem+0xc0>
42010d23:	0a8800        	add.s	f8, f8, f0
42010d26:	fec816        	beqz	a8, 42010d16 <quorem+0xaa>
42010d29:	fffc46        	j	42010d1e <quorem+0xb2>
42010d2c:	05ad      	mov.n	a10, a5
42010d2e:	201110        	or	a1, a1, a1
42010d31:	012fe5        	call8	42012030 <__mcmp>
42010d34:	06aa96        	bltz	a10, 42010da2 <quorem+0x136>
42010d37:	c09360        	sub	a9, a3, a6
42010d3a:	419290        	srli	a9, a9, 2
42010d3d:	864b      	addi.n	a8, a6, 4
42010d3f:	334b      	addi.n	a3, a3, 4
42010d41:	04ad      	mov.n	a10, a4
42010d43:	0c0c      	movi.n	a12, 0
42010d45:	991b      	addi.n	a9, a9, 1
42010d47:	02b387        	bgeu	a3, a8, 42010d4d <quorem+0xe1>
42010d4a:	01a092        	movi	a9, 1
42010d4d:	2e8976        	loop	a9, 42010d7f <quorem+0x113>
42010d50:	06d8      	l32i.n	a13, a6, 0
42010d52:	0a88      	l32i.n	a8, a10, 0
42010d54:	f4e0d0        	extui	a14, a13, 0, 16
42010d57:	f4b080        	extui	a11, a8, 0, 16
42010d5a:	c0bbe0        	sub	a11, a11, a14
42010d5d:	bbca      	add.n	a11, a11, a12
42010d5f:	f58080        	extui	a8, a8, 16, 16
42010d62:	f5d0d0        	extui	a13, a13, 16, 16
42010d65:	31c0b0        	srai	a12, a11, 16
42010d68:	c088d0        	sub	a8, a8, a13
42010d6b:	88ca      	add.n	a8, a8, a12
42010d6d:	31c080        	srai	a12, a8, 16
42010d70:	f4b0b0        	extui	a11, a11, 0, 16
42010d73:	118800        	slli	a8, a8, 16
42010d76:	2088b0        	or	a8, a8, a11
42010d79:	0a89      	s32i.n	a8, a10, 0
42010d7b:	664b      	addi.n	a6, a6, 4
42010d7d:	aa4b      	addi.n	a10, a10, 4
42010d7f:	a08740        	addx4	a8, a7, a4
42010d82:	0898      	l32i.n	a9, a8, 0
42010d84:	498c      	beqz.n	a9, 42010d8c <quorem+0x120>
42010d86:	000586        	j	42010da0 <quorem+0x134>
42010d89:	770b00        	lsi	f0, a11, 0x1dc
42010d8c:	fcc882        	addi	a8, a8, -4
42010d8f:	053487        	bltu	a4, a8, 42010d98 <quorem+0x12c>
42010d92:	4579      	s32i.n	a7, a5, 16
42010d94:	000206        	j	42010da0 <quorem+0x134>
42010d97:	089800        	lsx	f9, a8, a0
42010d9a:	fec916        	beqz	a9, 42010d8a <quorem+0x11e>
42010d9d:	fffc46        	j	42010d92 <quorem+0x126>
42010da0:	221b      	addi.n	a2, a2, 1
42010da2:	f01d      	retw.n

42010da4 <_dtoa_r>:
42010da4:	012136        	entry	a1, 144
42010da7:	92a8      	l32i.n	a10, a2, 36
42010da9:	c169      	s32i.n	a6, a1, 48
42010dab:	4129      	s32i.n	a2, a1, 16
42010dad:	146172        	s32i	a7, a1, 80
42010db0:	126142        	s32i	a4, a1, 72
42010db3:	136152        	s32i	a5, a1, 76
42010db6:	252162        	l32i	a6, a1, 148
42010db9:	3aec      	bnez.n	a10, 42010de0 <_dtoa_r+0x3c>
42010dbb:	10a0a2        	movi	a10, 16
42010dbe:	be7181        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
42010dc1:	0008e0        	callx8	a8
42010dc4:	4188      	l32i.n	a8, a1, 16
42010dc6:	98a9      	s32i.n	a10, a8, 36
42010dc8:	aacc      	bnez.n	a10, 42010dd6 <_dtoa_r+0x32>
42010dca:	bfedd1        	l32r	a13, 42000d80 <_stext+0xd60> (3c02918f <Xthal_intlevel+0x63>)
42010dcd:	0c0c      	movi.n	a12, 0
42010dcf:	efa0b2        	movi	a11, 239
42010dd2:	00ab86        	j	42011084 <_dtoa_r+0x2e0>
42010dd5:	080c00        	lsx	f0, a12, a0
42010dd8:	1a89      	s32i.n	a8, a10, 4
42010dda:	2a89      	s32i.n	a8, a10, 8
42010ddc:	0a89      	s32i.n	a8, a10, 0
42010dde:	3a89      	s32i.n	a8, a10, 12
42010de0:	0ab8      	l32i.n	a11, a10, 0
42010de2:	cb9c      	beqz.n	a11, 42010e02 <_dtoa_r+0x5e>
42010de4:	1a98      	l32i.n	a9, a10, 4
42010de6:	180c      	movi.n	a8, 1
42010de8:	401900        	ssl	a9
42010deb:	a18800        	sll	a8, a8
42010dee:	41a8      	l32i.n	a10, a1, 16
42010df0:	1b99      	s32i.n	a9, a11, 4
42010df2:	2b89      	s32i.n	a8, a11, 8
42010df4:	201110        	or	a1, a1, a1
42010df7:	00cca5        	call8	42011ac0 <_Bfree>
42010dfa:	4188      	l32i.n	a8, a1, 16
42010dfc:	090c      	movi.n	a9, 0
42010dfe:	9888      	l32i.n	a8, a8, 36
42010e00:	0899      	s32i.n	a9, a8, 0
42010e02:	053d      	mov.n	a3, a5
42010e04:	00e5d6        	bgez	a5, 42010e16 <_dtoa_r+0x72>
42010e07:	355a      	add.n	a3, a5, a5
42010e09:	180c      	movi.n	a8, 1
42010e0b:	413130        	srli	a3, a3, 1
42010e0e:	0689      	s32i.n	a8, a6, 0
42010e10:	136132        	s32i	a3, a1, 76
42010e13:	0000c6        	j	42010e1a <_dtoa_r+0x76>
42010e16:	080c      	movi.n	a8, 0
42010e18:	0689      	s32i.n	a8, a6, 0
42010e1a:	ffa782        	movi	a8, 0x7ff
42010e1d:	0188c0        	slli	a8, a8, 20
42010e20:	28c387        	bnall	a3, a8, 42010e4c <_dtoa_r+0xa8>
42010e23:	242192        	l32i	a9, a1, 144
42010e26:	f80c      	movi.n	a8, 15
42010e28:	113340        	slli	a3, a3, 12
42010e2b:	27d882        	addmi	a8, a8, 0x2700
42010e2e:	413c30        	srli	a3, a3, 12
42010e31:	0989      	s32i.n	a8, a9, 0
42010e33:	203340        	or	a3, a3, a4
42010e36:	13cc      	bnez.n	a3, 42010e3b <_dtoa_r+0x97>
42010e38:	02f206        	j	42011a04 <_dtoa_r+0xc60>
42010e3b:	02f5c6        	j	42011a16 <_dtoa_r+0xc72>
42010e3e:	000000        	ill
42010e41:	bfcd81        	l32r	a8, 42000d78 <_stext+0xd58> (3c02918e <Xthal_intlevel+0x62>)
42010e44:	262192        	l32i	a9, a1, 152
42010e47:	0989      	s32i.n	a8, a9, 0
42010e49:	02fa06        	j	42011a35 <_dtoa_r+0xc91>
42010e4c:	122182        	l32i	a8, a1, 72
42010e4f:	132192        	l32i	a9, a1, 76
42010e52:	e189      	s32i.n	a8, a1, 56
42010e54:	f199      	s32i.n	a9, a1, 60
42010e56:	e1a8      	l32i.n	a10, a1, 56
42010e58:	f1b8      	l32i.n	a11, a1, 60
42010e5a:	00a0c2        	movi	a12, 0
42010e5d:	00a0d2        	movi	a13, 0
42010e60:	bfb081        	l32r	a8, 42000d20 <_stext+0xd00> (4000228c <__eqdf2>)
42010e63:	0008e0        	callx8	a8
42010e66:	8adc      	bnez.n	a10, 42010e82 <_dtoa_r+0xde>
42010e68:	242192        	l32i	a9, a1, 144
42010e6b:	180c      	movi.n	a8, 1
42010e6d:	0989      	s32i.n	a8, a9, 0
42010e6f:	262182        	l32i	a8, a1, 152
42010e72:	688c      	beqz.n	a8, 42010e7c <_dtoa_r+0xd8>
42010e74:	bfc581        	l32r	a8, 42000d88 <_stext+0xd68> (3c029181 <Xthal_intlevel+0x55>)
42010e77:	262192        	l32i	a9, a1, 152
42010e7a:	0989      	s32i.n	a8, a9, 0
42010e7c:	bfc021        	l32r	a2, 42000d7c <_stext+0xd5c> (3c029180 <Xthal_intlevel+0x54>)
42010e7f:	02ec86        	j	42011a35 <_dtoa_r+0xc91>
42010e82:	e1c8      	l32i.n	a12, a1, 56
42010e84:	f1d8      	l32i.n	a13, a1, 60
42010e86:	41a8      	l32i.n	a10, a1, 16
42010e88:	f14b      	addi.n	a15, a1, 4
42010e8a:	01ed      	mov.n	a14, a1
42010e8c:	201110        	or	a1, a1, a1
42010e8f:	014025        	call8	42012290 <__d2b>
42010e92:	51a9      	s32i.n	a10, a1, 20
42010e94:	b59430        	extui	a9, a3, 20, 12
42010e97:	1168      	l32i.n	a6, a1, 4
42010e99:	899c      	beqz.n	a9, 42010eb5 <_dtoa_r+0x111>
42010e9b:	f188      	l32i.n	a8, a1, 60
42010e9d:	bfbba1        	l32r	a10, 42000d8c <_stext+0xd6c> (3ff00000 <ets_ops_table_ptr+0x210004>)
42010ea0:	118840        	slli	a8, a8, 12
42010ea3:	418c80        	srli	a8, a8, 12
42010ea6:	2088a0        	or	a8, a8, a10
42010ea9:	01aca2        	movi	a10, 0xfffffc01
42010eac:	59aa      	add.n	a5, a9, a10
42010eae:	e1a8      	l32i.n	a10, a1, 56
42010eb0:	090c      	movi.n	a9, 0
42010eb2:	0011c6        	j	42010efd <_dtoa_r+0x159>
42010eb5:	0128      	l32i.n	a2, a1, 0
42010eb7:	32a4a2        	movi	a10, 0x432
42010eba:	262a      	add.n	a2, a6, a2
42010ebc:	a2aa      	add.n	a10, a2, a10
42010ebe:	082c      	movi.n	a8, 32
42010ec0:	1ca8a7        	bge	a8, a10, 42010ee0 <_dtoa_r+0x13c>
42010ec3:	c0caa2        	addi	a10, a10, -64
42010ec6:	60a0a0        	neg	a10, a10
42010ec9:	12c282        	addi	a8, a2, 18
42010ecc:	401a00        	ssl	a10
42010ecf:	a13300        	sll	a3, a3
42010ed2:	400800        	ssr	a8
42010ed5:	918040        	srl	a8, a4
42010ed8:	20a380        	or	a10, a3, a8
42010edb:	000346        	j	42010eec <_dtoa_r+0x148>
42010ede:	a20000        	muluh	a0, a0, a0
42010ee1:	e0ca      	add.n	a14, a0, a12
42010ee3:	60a0a0        	neg	a10, a10
42010ee6:	401a00        	ssl	a10
42010ee9:	a1a400        	sll	a10, a4
42010eec:	bfb581        	l32r	a8, 42000dc0 <_stext+0xda0> (40002364 <__floatunsidf>)
42010eef:	0008e0        	callx8	a8
42010ef2:	186c      	movi.n	a8, -31
42010ef4:	0188c0        	slli	a8, a8, 20
42010ef7:	88ba      	add.n	a8, a8, a11
42010ef9:	520b      	addi.n	a5, a2, -1
42010efb:	190c      	movi.n	a9, 1
42010efd:	ffa7d2        	movi	a13, 0x7ff
42010f00:	186192        	s32i	a9, a1, 96
42010f03:	08bd      	mov.n	a11, a8
42010f05:	0c0c      	movi.n	a12, 0
42010f07:	01ddd0        	slli	a13, a13, 19
42010f0a:	bf8881        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
42010f0d:	0008e0        	callx8	a8
42010f10:	bfa6c1        	l32r	a12, 42000da8 <_stext+0xd88> (636f4361 <_rtc_reserved_end+0x35f4361>)
42010f13:	bfa6d1        	l32r	a13, 42000dac <_stext+0xd8c> (3fd287a7 <ets_ops_table_ptr+0x387ab>)
42010f16:	bf8181        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42010f19:	0008e0        	callx8	a8
42010f1c:	bfa5c1        	l32r	a12, 42000db0 <_stext+0xd90> (8b60c8b3 <_rtc_reserved_end+0x2b50c8b3>)
42010f1f:	bfa5d1        	l32r	a13, 42000db4 <_stext+0xd94> (3fc68a28 <_esp_system_init_fn_array_end+0x3c3eab4>)
42010f22:	bfa881        	l32r	a8, 42000dc4 <_stext+0xda4> (40002184 <__adddf3>)
42010f25:	0008e0        	callx8	a8
42010f28:	0a2d      	mov.n	a2, a10
42010f2a:	05ad      	mov.n	a10, a5
42010f2c:	0b3d      	mov.n	a3, a11
42010f2e:	bf7e81        	l32r	a8, 42000d28 <_stext+0xd08> (40002334 <__floatsidf>)
42010f31:	0008e0        	callx8	a8
42010f34:	bfa1c1        	l32r	a12, 42000db8 <_stext+0xd98> (509f79fb <_coredump_rtc_end+0x9f79fb>)
42010f37:	bfa1d1        	l32r	a13, 42000dbc <_stext+0xd9c> (3fd34413 <ets_ops_table_ptr+0x44417>)
42010f3a:	bf7881        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42010f3d:	0008e0        	callx8	a8
42010f40:	0acd      	mov.n	a12, a10
42010f42:	0bdd      	mov.n	a13, a11
42010f44:	02ad      	mov.n	a10, a2
42010f46:	03bd      	mov.n	a11, a3
42010f48:	bf9f81        	l32r	a8, 42000dc4 <_stext+0xda4> (40002184 <__adddf3>)
42010f4b:	0008e0        	callx8	a8
42010f4e:	71b9      	s32i.n	a11, a1, 28
42010f50:	61a9      	s32i.n	a10, a1, 24
42010f52:	bf7481        	l32r	a8, 42000d24 <_stext+0xd04> (400022d4 <__fixdfsi>)
42010f55:	0008e0        	callx8	a8
42010f58:	0a3d      	mov.n	a3, a10
42010f5a:	71b8      	l32i.n	a11, a1, 28
42010f5c:	61a8      	l32i.n	a10, a1, 24
42010f5e:	0c0c      	movi.n	a12, 0
42010f60:	00a0d2        	movi	a13, 0
42010f63:	bf6d81        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
42010f66:	0008e0        	callx8	a8
42010f69:	015ad6        	bgez	a10, 42010f82 <_dtoa_r+0x1de>
42010f6c:	03ad      	mov.n	a10, a3
42010f6e:	bf6e81        	l32r	a8, 42000d28 <_stext+0xd08> (40002334 <__floatsidf>)
42010f71:	0008e0        	callx8	a8
42010f74:	61c8      	l32i.n	a12, a1, 24
42010f76:	71d8      	l32i.n	a13, a1, 28
42010f78:	bf6e81        	l32r	a8, 42000d30 <_stext+0xd10> (4000246c <__nedf2>)
42010f7b:	0008e0        	callx8	a8
42010f7e:	0a8c      	beqz.n	a10, 42010f82 <_dtoa_r+0x1de>
42010f80:	330b      	addi.n	a3, a3, -1
42010f82:	190c      	movi.n	a9, 1
42010f84:	681c      	movi.n	a8, 22
42010f86:	156192        	s32i	a9, a1, 84
42010f89:	1d3837        	bltu	a8, a3, 42010faa <_dtoa_r+0x206>
42010f8c:	bf8181        	l32r	a8, 42000d90 <_stext+0xd70> (3c029748 <__mprec_tens>)
42010f8f:	e1a8      	l32i.n	a10, a1, 56
42010f91:	b08380        	addx8	a8, a3, a8
42010f94:	08c8      	l32i.n	a12, a8, 0
42010f96:	18d8      	l32i.n	a13, a8, 4
42010f98:	f1b8      	l32i.n	a11, a1, 60
42010f9a:	bf5f81        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
42010f9d:	0008e0        	callx8	a8
42010fa0:	001ad6        	bgez	a10, 42010fa5 <_dtoa_r+0x201>
42010fa3:	330b      	addi.n	a3, a3, -1
42010fa5:	080c      	movi.n	a8, 0
42010fa7:	156182        	s32i	a8, a1, 84
42010faa:	c06650        	sub	a6, a6, a5
42010fad:	860b      	addi.n	a8, a6, -1
42010faf:	a189      	s32i.n	a8, a1, 40
42010fb1:	040c      	movi.n	a4, 0
42010fb3:	0068d6        	bgez	a8, 42010fbd <_dtoa_r+0x219>
42010fb6:	604080        	neg	a4, a8
42010fb9:	080c      	movi.n	a8, 0
42010fbb:	a189      	s32i.n	a8, a1, 40
42010fbd:	00f396        	bltz	a3, 42010fd0 <_dtoa_r+0x22c>
42010fc0:	a188      	l32i.n	a8, a1, 40
42010fc2:	116132        	s32i	a3, a1, 68
42010fc5:	883a      	add.n	a8, a8, a3
42010fc7:	a189      	s32i.n	a8, a1, 40
42010fc9:	080c      	movi.n	a8, 0
42010fcb:	d189      	s32i.n	a8, a1, 52
42010fcd:	000306        	j	42010fdd <_dtoa_r+0x239>
42010fd0:	608030        	neg	a8, a3
42010fd3:	d189      	s32i.n	a8, a1, 52
42010fd5:	080c      	movi.n	a8, 0
42010fd7:	c04430        	sub	a4, a4, a3
42010fda:	116182        	s32i	a8, a1, 68
42010fdd:	c198      	l32i.n	a9, a1, 48
42010fdf:	980c      	movi.n	a8, 9
42010fe1:	150c      	movi.n	a5, 1
42010fe3:	4e3897        	bltu	a8, a9, 42011035 <_dtoa_r+0x291>
42010fe6:	0669a6        	blti	a9, 6, 42010ff0 <_dtoa_r+0x24c>
42010fe9:	fcc982        	addi	a8, a9, -4
42010fec:	c189      	s32i.n	a8, a1, 48
42010fee:	050c      	movi.n	a5, 0
42010ff0:	c188      	l32i.n	a8, a1, 48
42010ff2:	124826        	beqi	a8, 4, 42011008 <_dtoa_r+0x264>
42010ff5:	255826        	beqi	a8, 5, 4201101e <_dtoa_r+0x27a>
42010ff8:	112826        	beqi	a8, 2, 4201100d <_dtoa_r+0x269>
42010ffb:	080c      	movi.n	a8, 0
42010ffd:	106182        	s32i	a8, a1, 64
42011000:	c188      	l32i.n	a8, a1, 48
42011002:	1d3826        	beqi	a8, 3, 42011023 <_dtoa_r+0x27f>
42011005:	000c06        	j	42011039 <_dtoa_r+0x295>
42011008:	180c      	movi.n	a8, 1
4201100a:	000046        	j	4201100f <_dtoa_r+0x26b>
4201100d:	080c      	movi.n	a8, 0
4201100f:	106182        	s32i	a8, a1, 64
42011012:	3617a6        	blti	a7, 1, 4201104c <_dtoa_r+0x2a8>
42011015:	b179      	s32i.n	a7, a1, 44
42011017:	078d      	mov.n	a8, a7
42011019:	8179      	s32i.n	a7, a1, 32
4201101b:	000e06        	j	42011057 <_dtoa_r+0x2b3>
4201101e:	180c      	movi.n	a8, 1
42011020:	106182        	s32i	a8, a1, 64
42011023:	837a      	add.n	a8, a3, a7
42011025:	b189      	s32i.n	a8, a1, 44
42011027:	881b      	addi.n	a8, a8, 1
42011029:	8189      	s32i.n	a8, a1, 32
4201102b:	8198      	l32i.n	a9, a1, 32
4201102d:	180c      	movi.n	a8, 1
4201102f:	538980        	max	a8, a9, a8
42011032:	000846        	j	42011057 <_dtoa_r+0x2b3>
42011035:	080c      	movi.n	a8, 0
42011037:	c189      	s32i.n	a8, a1, 48
42011039:	180c      	movi.n	a8, 1
4201103b:	106182        	s32i	a8, a1, 64
4201103e:	f87c      	movi.n	a8, -1
42011040:	b189      	s32i.n	a8, a1, 44
42011042:	8189      	s32i.n	a8, a1, 32
42011044:	090c      	movi.n	a9, 0
42011046:	281c      	movi.n	a8, 18
42011048:	000206        	j	42011054 <_dtoa_r+0x2b0>
4201104b:	180c00        	lsxp	f0, a12, a0
4201104e:	b189      	s32i.n	a8, a1, 44
42011050:	8189      	s32i.n	a8, a1, 32
42011052:	190c      	movi.n	a9, 1
42011054:	146192        	s32i	a9, a1, 80
42011057:	4198      	l32i.n	a9, a1, 16
42011059:	0b0c      	movi.n	a11, 0
4201105b:	99a8      	l32i.n	a10, a9, 36
4201105d:	490c      	movi.n	a9, 4
4201105f:	0000c6        	j	42011066 <_dtoa_r+0x2c2>
42011062:	999a      	add.n	a9, a9, a9
42011064:	0dbd      	mov.n	a11, a13
42011066:	14c9c2        	addi	a12, a9, 20
42011069:	db1b      	addi.n	a13, a11, 1
4201106b:	f3b8c7        	bgeu	a8, a12, 42011062 <_dtoa_r+0x2be>
4201106e:	1ab9      	s32i.n	a11, a10, 4
42011070:	41a8      	l32i.n	a10, a1, 16
42011072:	201110        	or	a1, a1, a1
42011075:	009c25        	call8	42011a38 <_Balloc>
42011078:	0a2d      	mov.n	a2, a10
4201107a:	facc      	bnez.n	a10, 4201108d <_dtoa_r+0x2e9>
4201107c:	bf46d1        	l32r	a13, 42000d94 <_stext+0xd74> (3c0291fa <Xthal_intlevel+0xce>)
4201107f:	0c0c      	movi.n	a12, 0
42011081:	afa1b2        	movi	a11, 0x1af
42011084:	bf40a1        	l32r	a10, 42000d84 <_stext+0xd64> (3c0291a6 <Xthal_intlevel+0x7a>)
42011087:	bc0e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4201108a:	0008e0        	callx8	a8
4201108d:	4188      	l32i.n	a8, a1, 16
4201108f:	e60c      	movi.n	a6, 14
42011091:	9888      	l32i.n	a8, a8, 36
42011093:	08a9      	s32i.n	a10, a8, 0
42011095:	8188      	l32i.n	a8, a1, 32
42011097:	626680        	lsi	f8, a6, 0x188
4201109a:	660b      	addi.n	a6, a6, -1
4201109c:	606060        	neg	a6, a6
4201109f:	106650        	and	a6, a6, a5
420110a2:	348616        	beqz	a6, 420113ee <_dtoa_r+0x64a>
420110a5:	0213e6        	bgei	a3, 1, 420110ab <_dtoa_r+0x307>
420110a8:	002086        	j	4201112e <_dtoa_r+0x38a>
420110ab:	bf3991        	l32r	a9, 42000d90 <_stext+0xd70> (3c029748 <__mprec_tens>)
420110ae:	348030        	extui	a8, a3, 0, 4
420110b1:	b08890        	addx8	a8, a8, a9
420110b4:	1898      	l32i.n	a9, a8, 4
420110b6:	e1e8      	l32i.n	a14, a1, 56
420110b8:	0888      	l32i.n	a8, a8, 0
420110ba:	f1f8      	l32i.n	a15, a1, 60
420110bc:	216430        	srai	a6, a3, 4
420110bf:	270c      	movi.n	a7, 2
420110c1:	236387        	bbci	a3, 8, 420110e8 <_dtoa_r+0x344>
420110c4:	bf35a1        	l32r	a10, 42000d98 <_stext+0xd78> (3c029720 <__mprec_bigtens>)
420110c7:	6189      	s32i.n	a8, a1, 24
420110c9:	8ac8      	l32i.n	a12, a10, 32
420110cb:	9ad8      	l32i.n	a13, a10, 36
420110cd:	7199      	s32i.n	a9, a1, 28
420110cf:	0ead      	mov.n	a10, a14
420110d1:	0fbd      	mov.n	a11, a15
420110d3:	bf3d81        	l32r	a8, 42000dc8 <_stext+0xda8> (40002250 <__divdf3>)
420110d6:	0008e0        	callx8	a8
420110d9:	6188      	l32i.n	a8, a1, 24
420110db:	7198      	l32i.n	a9, a1, 28
420110dd:	346060        	extui	a6, a6, 0, 4
420110e0:	0aed      	mov.n	a14, a10
420110e2:	20fbb0        	or	a15, a11, a11
420110e5:	03a072        	movi	a7, 3
420110e8:	bf2c51        	l32r	a5, 42000d98 <_stext+0xd78> (3c029720 <__mprec_bigtens>)
420110eb:	000986        	j	42011115 <_dtoa_r+0x371>
420110ee:	1e6607        	bbci	a6, 0, 42011110 <_dtoa_r+0x36c>
420110f1:	05c8      	l32i.n	a12, a5, 0
420110f3:	15d8      	l32i.n	a13, a5, 4
420110f5:	61e9      	s32i.n	a14, a1, 24
420110f7:	71f9      	s32i.n	a15, a1, 28
420110f9:	20a880        	or	a10, a8, a8
420110fc:	09bd      	mov.n	a11, a9
420110fe:	bf0781        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42011101:	0008e0        	callx8	a8
42011104:	61e8      	l32i.n	a14, a1, 24
42011106:	71f8      	l32i.n	a15, a1, 28
42011108:	771b      	addi.n	a7, a7, 1
4201110a:	208aa0        	or	a8, a10, a10
4201110d:	209bb0        	or	a9, a11, a11
42011110:	216160        	srai	a6, a6, 1
42011113:	558b      	addi.n	a5, a5, 8
42011115:	fd5656        	bnez	a6, 420110ee <_dtoa_r+0x34a>
42011118:	08cd      	mov.n	a12, a8
4201111a:	09dd      	mov.n	a13, a9
4201111c:	20aee0        	or	a10, a14, a14
4201111f:	20bff0        	or	a11, a15, a15
42011122:	bf2981        	l32r	a8, 42000dc8 <_stext+0xda8> (40002250 <__divdf3>)
42011125:	0008e0        	callx8	a8
42011128:	001686        	j	42011186 <_dtoa_r+0x3e2>
4201112b:	000000        	ill
4201112e:	e188      	l32i.n	a8, a1, 56
42011130:	f198      	l32i.n	a9, a1, 60
42011132:	6189      	s32i.n	a8, a1, 24
42011134:	7199      	s32i.n	a9, a1, 28
42011136:	270c      	movi.n	a7, 2
42011138:	050316        	beqz	a3, 4201118c <_dtoa_r+0x3e8>
4201113b:	bf1591        	l32r	a9, 42000d90 <_stext+0xd70> (3c029748 <__mprec_tens>)
4201113e:	605030        	neg	a5, a3
42011141:	348050        	extui	a8, a5, 0, 4
42011144:	b08890        	addx8	a8, a8, a9
42011147:	08c8      	l32i.n	a12, a8, 0
42011149:	18d8      	l32i.n	a13, a8, 4
4201114b:	e1a8      	l32i.n	a10, a1, 56
4201114d:	f1b8      	l32i.n	a11, a1, 60
4201114f:	215450        	srai	a5, a5, 4
42011152:	bef281        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42011155:	0008e0        	callx8	a8
42011158:	bf1091        	l32r	a9, 42000d98 <_stext+0xd78> (3c029720 <__mprec_bigtens>)
4201115b:	61a9      	s32i.n	a10, a1, 24
4201115d:	71b9      	s32i.n	a11, a1, 28
4201115f:	080c      	movi.n	a8, 0
42011161:	000706        	j	42011181 <_dtoa_r+0x3dd>
42011164:	650700        	extui	a0, a0, 23, 7
42011167:	09c813        	ssip	f1, a8, 36
4201116a:	19d8      	l32i.n	a13, a9, 4
4201116c:	166192        	s32i	a9, a1, 88
4201116f:	beeb81        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42011172:	0008e0        	callx8	a8
42011175:	162192        	l32i	a9, a1, 88
42011178:	771b      	addi.n	a7, a7, 1
4201117a:	068d      	mov.n	a8, a6
4201117c:	215150        	srai	a5, a5, 1
4201117f:	998b      	addi.n	a9, a9, 8
42011181:	fe0556        	bnez	a5, 42011165 <_dtoa_r+0x3c1>
42011184:	488c      	beqz.n	a8, 4201118c <_dtoa_r+0x3e8>
42011186:	0661a2        	s32i	a10, a1, 24
42011189:	0761b2        	s32i	a11, a1, 28
4201118c:	152182        	l32i	a8, a1, 84
4201118f:	98bc      	beqz.n	a8, 420111cc <_dtoa_r+0x428>
42011191:	befed1        	l32r	a13, 42000d8c <_stext+0xd6c> (3ff00000 <ets_ops_table_ptr+0x210004>)
42011194:	61a8      	l32i.n	a10, a1, 24
42011196:	71b8      	l32i.n	a11, a1, 28
42011198:	0c0c      	movi.n	a12, 0
4201119a:	bedf81        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
4201119d:	0008e0        	callx8	a8
420111a0:	028ad6        	bgez	a10, 420111cc <_dtoa_r+0x428>
420111a3:	8188      	l32i.n	a8, a1, 32
420111a5:	d8ac      	beqz.n	a8, 420111d6 <_dtoa_r+0x432>
420111a7:	b188      	l32i.n	a8, a1, 44
420111a9:	0218e6        	bgei	a8, 1, 420111af <_dtoa_r+0x40b>
420111ac:	008f86        	j	420113ee <_dtoa_r+0x64a>
420111af:	61a8      	l32i.n	a10, a1, 24
420111b1:	71b8      	l32i.n	a11, a1, 28
420111b3:	befad1        	l32r	a13, 42000d9c <_stext+0xd7c> (40240000 <rom_rx_gain_force+0x239bd4>)
420111b6:	0c0c      	movi.n	a12, 0
420111b8:	bed981        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
420111bb:	0008e0        	callx8	a8
420111be:	530b      	addi.n	a5, a3, -1
420111c0:	b168      	l32i.n	a6, a1, 44
420111c2:	61a9      	s32i.n	a10, a1, 24
420111c4:	71b9      	s32i.n	a11, a1, 28
420111c6:	771b      	addi.n	a7, a7, 1
420111c8:	000386        	j	420111da <_dtoa_r+0x436>
420111cb:	816800        	src	a6, a8, a0
420111ce:	035d      	mov.n	a5, a3
420111d0:	000186        	j	420111da <_dtoa_r+0x436>
420111d3:	000000        	ill
420111d6:	035d      	mov.n	a5, a3
420111d8:	060c      	movi.n	a6, 0
420111da:	07ad      	mov.n	a10, a7
420111dc:	bed381        	l32r	a8, 42000d28 <_stext+0xd08> (40002334 <__floatsidf>)
420111df:	0008e0        	callx8	a8
420111e2:	61c8      	l32i.n	a12, a1, 24
420111e4:	0721d2        	l32i	a13, a1, 28
420111e7:	becd81        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
420111ea:	0008e0        	callx8	a8
420111ed:	beedd1        	l32r	a13, 42000da4 <_stext+0xd84> (401c0000 <rom_rx_gain_force+0x1b9bd4>)
420111f0:	0c0c      	movi.n	a12, 0
420111f2:	bef481        	l32r	a8, 42000dc4 <_stext+0xda4> (40002184 <__adddf3>)
420111f5:	0008e0        	callx8	a8
420111f8:	387c      	movi.n	a8, -13
420111fa:	0188a0        	slli	a8, a8, 22
420111fd:	f8ba      	add.n	a15, a8, a11
420111ff:	1661a2        	s32i	a10, a1, 88
42011202:	1761f2        	s32i	a15, a1, 92
42011205:	1a61a2        	s32i	a10, a1, 104
42011208:	1b61f2        	s32i	a15, a1, 108
4201120b:	046656        	bnez	a6, 42011255 <_dtoa_r+0x4b1>
4201120e:	bee4d1        	l32r	a13, 42000da0 <_stext+0xd80> (40140000 <rom_rx_gain_force+0x139bd4>)
42011211:	61a8      	l32i.n	a10, a1, 24
42011213:	71b8      	l32i.n	a11, a1, 28
42011215:	0c0c      	movi.n	a12, 0
42011217:	bec581        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
4201121a:	0008e0        	callx8	a8
4201121d:	1621c2        	l32i	a12, a1, 88
42011220:	1721d2        	l32i	a13, a1, 92
42011223:	0a6d      	mov.n	a6, a10
42011225:	0b7d      	mov.n	a7, a11
42011227:	bec381        	l32r	a8, 42000d34 <_stext+0xd14> (400023a0 <__gtdf2>)
4201122a:	0008e0        	callx8	a8
4201122d:	021aa6        	blti	a10, 1, 42011233 <_dtoa_r+0x48f>
42011230:	0151c6        	j	4201177b <_dtoa_r+0x9d7>
42011233:	1b21f2        	l32i	a15, a1, 108
42011236:	f87c      	movi.n	a8, -1
42011238:	018810        	slli	a8, a8, 31
4201123b:	1a21c2        	l32i	a12, a1, 104
4201123e:	30d8f0        	xor	a13, a8, a15
42011241:	06ad      	mov.n	a10, a6
42011243:	20b770        	or	a11, a7, a7
42011246:	beb481        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
42011249:	0008e0        	callx8	a8
4201124c:	20aa96        	bltz	a10, 4201145a <_dtoa_r+0x6b6>
4201124f:	0066c6        	j	420113ee <_dtoa_r+0x64a>
42011252:	000000        	ill
42011255:	bece91        	l32r	a9, 42000d90 <_stext+0xd70> (3c029748 <__mprec_tens>)
42011258:	860b      	addi.n	a8, a6, -1
4201125a:	b08890        	addx8	a8, a8, a9
4201125d:	08a8      	l32i.n	a10, a8, 0
4201125f:	18b8      	l32i.n	a11, a8, 4
42011261:	102182        	l32i	a8, a1, 64
42011264:	726a      	add.n	a7, a2, a6
42011266:	0bf816        	beqz	a8, 42011329 <_dtoa_r+0x585>
42011269:	0bdd      	mov.n	a13, a11
4201126b:	bea7b1        	l32r	a11, 42000d08 <_stext+0xce8> (3fe00000 <ets_ops_table_ptr+0x110004>)
4201126e:	0acd      	mov.n	a12, a10
42011270:	0a0c      	movi.n	a10, 0
42011272:	bed581        	l32r	a8, 42000dc8 <_stext+0xda8> (40002250 <__divdf3>)
42011275:	0008e0        	callx8	a8
42011278:	1621c2        	l32i	a12, a1, 88
4201127b:	1721d2        	l32i	a13, a1, 92
4201127e:	beab81        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
42011281:	0008e0        	callx8	a8
42011284:	1661a2        	s32i	a10, a1, 88
42011287:	1761b2        	s32i	a11, a1, 92
4201128a:	028d      	mov.n	a8, a2
4201128c:	71b8      	l32i.n	a11, a1, 28
4201128e:	61a8      	l32i.n	a10, a1, 24
42011290:	196182        	s32i	a8, a1, 100
42011293:	bea481        	l32r	a8, 42000d24 <_stext+0xd04> (400022d4 <__fixdfsi>)
42011296:	0008e0        	callx8	a8
42011299:	1a61a2        	s32i	a10, a1, 104
4201129c:	bea381        	l32r	a8, 42000d28 <_stext+0xd08> (40002334 <__floatsidf>)
4201129f:	0008e0        	callx8	a8
420112a2:	0acd      	mov.n	a12, a10
420112a4:	0bdd      	mov.n	a13, a11
420112a6:	61a8      	l32i.n	a10, a1, 24
420112a8:	0721b2        	l32i	a11, a1, 28
420112ab:	bea081        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
420112ae:	0008e0        	callx8	a8
420112b1:	1a2192        	l32i	a9, a1, 104
420112b4:	192182        	l32i	a8, a1, 100
420112b7:	30c992        	addi	a9, a9, 48
420112ba:	1621c2        	l32i	a12, a1, 88
420112bd:	1721d2        	l32i	a13, a1, 92
420112c0:	61a9      	s32i.n	a10, a1, 24
420112c2:	0761b2        	s32i	a11, a1, 28
420112c5:	004892        	s8i	a9, a8, 0
420112c8:	01c862        	addi	a6, a8, 1
420112cb:	be9381        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
420112ce:	0008e0        	callx8	a8
420112d1:	70ba96        	bltz	a10, 420119e0 <_dtoa_r+0xc3c>
420112d4:	61c8      	l32i.n	a12, a1, 24
420112d6:	71d8      	l32i.n	a13, a1, 28
420112d8:	beadb1        	l32r	a11, 42000d8c <_stext+0xd6c> (3ff00000 <ets_ops_table_ptr+0x210004>)
420112db:	00a0a2        	movi	a10, 0
420112de:	be9381        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
420112e1:	0008e0        	callx8	a8
420112e4:	1621c2        	l32i	a12, a1, 88
420112e7:	1721d2        	l32i	a13, a1, 92
420112ea:	be8b81        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
420112ed:	0008e0        	callx8	a8
420112f0:	1faa96        	bltz	a10, 420114ee <_dtoa_r+0x74a>
420112f3:	029677        	bne	a6, a7, 420112f9 <_dtoa_r+0x555>
420112f6:	003d06        	j	420113ee <_dtoa_r+0x64a>
420112f9:	bea8d1        	l32r	a13, 42000d9c <_stext+0xd7c> (40240000 <rom_rx_gain_force+0x239bd4>)
420112fc:	1621a2        	l32i	a10, a1, 88
420112ff:	1721b2        	l32i	a11, a1, 92
42011302:	0c0c      	movi.n	a12, 0
42011304:	be8681        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42011307:	0008e0        	callx8	a8
4201130a:	1661a2        	s32i	a10, a1, 88
4201130d:	1761b2        	s32i	a11, a1, 92
42011310:	61a8      	l32i.n	a10, a1, 24
42011312:	71b8      	l32i.n	a11, a1, 28
42011314:	bea2d1        	l32r	a13, 42000d9c <_stext+0xd7c> (40240000 <rom_rx_gain_force+0x239bd4>)
42011317:	00a0c2        	movi	a12, 0
4201131a:	be8081        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
4201131d:	0008e0        	callx8	a8
42011320:	61a9      	s32i.n	a10, a1, 24
42011322:	71b9      	s32i.n	a11, a1, 28
42011324:	068d      	mov.n	a8, a6
42011326:	ffd886        	j	4201128c <_dtoa_r+0x4e8>
42011329:	1621c2        	l32i	a12, a1, 88
4201132c:	1721d2        	l32i	a13, a1, 92
4201132f:	be7b81        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42011332:	0008e0        	callx8	a8
42011335:	1661a2        	s32i	a10, a1, 88
42011338:	1761b2        	s32i	a11, a1, 92
4201133b:	028d      	mov.n	a8, a2
4201133d:	71b8      	l32i.n	a11, a1, 28
4201133f:	61a8      	l32i.n	a10, a1, 24
42011341:	1a6182        	s32i	a8, a1, 104
42011344:	be7881        	l32r	a8, 42000d24 <_stext+0xd04> (400022d4 <__fixdfsi>)
42011347:	0008e0        	callx8	a8
4201134a:	0a6d      	mov.n	a6, a10
4201134c:	be7781        	l32r	a8, 42000d28 <_stext+0xd08> (40002334 <__floatsidf>)
4201134f:	0008e0        	callx8	a8
42011352:	0acd      	mov.n	a12, a10
42011354:	0bdd      	mov.n	a13, a11
42011356:	61a8      	l32i.n	a10, a1, 24
42011358:	0721b2        	l32i	a11, a1, 28
4201135b:	30c662        	addi	a6, a6, 48
4201135e:	be7381        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
42011361:	0008e0        	callx8	a8
42011364:	1a2182        	l32i	a8, a1, 104
42011367:	61a9      	s32i.n	a10, a1, 24
42011369:	004862        	s8i	a6, a8, 0
4201136c:	71b9      	s32i.n	a11, a1, 28
4201136e:	881b      	addi.n	a8, a8, 1
42011370:	5e9787        	bne	a7, a8, 420113d2 <_dtoa_r+0x62e>
42011373:	be65d1        	l32r	a13, 42000d08 <_stext+0xce8> (3fe00000 <ets_ops_table_ptr+0x110004>)
42011376:	1621a2        	l32i	a10, a1, 88
42011379:	1721b2        	l32i	a11, a1, 92
4201137c:	0c0c      	movi.n	a12, 0
4201137e:	be9181        	l32r	a8, 42000dc4 <_stext+0xda4> (40002184 <__adddf3>)
42011381:	0008e0        	callx8	a8
42011384:	0acd      	mov.n	a12, a10
42011386:	0bdd      	mov.n	a13, a11
42011388:	61a8      	l32i.n	a10, a1, 24
4201138a:	71b8      	l32i.n	a11, a1, 28
4201138c:	206770        	or	a6, a7, a7
4201138f:	be6981        	l32r	a8, 42000d34 <_stext+0xd14> (400023a0 <__gtdf2>)
42011392:	0008e0        	callx8	a8
42011395:	021aa6        	blti	a10, 1, 4201139b <_dtoa_r+0x5f7>
42011398:	005486        	j	420114ee <_dtoa_r+0x74a>
4201139b:	1621c2        	l32i	a12, a1, 88
4201139e:	1721d2        	l32i	a13, a1, 92
420113a1:	be59b1        	l32r	a11, 42000d08 <_stext+0xce8> (3fe00000 <ets_ops_table_ptr+0x110004>)
420113a4:	0a0c      	movi.n	a10, 0
420113a6:	be6181        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
420113a9:	0008e0        	callx8	a8
420113ac:	0acd      	mov.n	a12, a10
420113ae:	20dbb0        	or	a13, a11, a11
420113b1:	61a8      	l32i.n	a10, a1, 24
420113b3:	0721b2        	l32i	a11, a1, 28
420113b6:	be5881        	l32r	a8, 42000d18 <_stext+0xcf8> (400023dc <__ltdf2>)
420113b9:	0008e0        	callx8	a8
420113bc:	02ead6        	bgez	a10, 420113ee <_dtoa_r+0x64a>
420113bf:	093c      	movi.n	a9, 48
420113c1:	068d      	mov.n	a8, a6
420113c3:	660b      	addi.n	a6, a6, -1
420113c5:	0006a2        	l8ui	a10, a6, 0
420113c8:	f51a97        	beq	a10, a9, 420113c1 <_dtoa_r+0x61d>
420113cb:	086d      	mov.n	a6, a8
420113cd:	0183c6        	j	420119e0 <_dtoa_r+0xc3c>
420113d0:	a80000        	lsi	f0, a0, 0x2a0
420113d3:	71b861        	l32r	a6, 41fedab4 <_coredump_iram_end+0x1c6bbb4>
420113d6:	be71d1        	l32r	a13, 42000d9c <_stext+0xd7c> (40240000 <rom_rx_gain_force+0x239bd4>)
420113d9:	1a6182        	s32i	a8, a1, 104
420113dc:	0c0c      	movi.n	a12, 0
420113de:	be4f81        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
420113e1:	0008e0        	callx8	a8
420113e4:	1a2182        	l32i	a8, a1, 104
420113e7:	61a9      	s32i.n	a10, a1, 24
420113e9:	71b9      	s32i.n	a11, a1, 28
420113eb:	ffd386        	j	4201133d <_dtoa_r+0x599>
420113ee:	0188      	l32i.n	a8, a1, 0
420113f0:	138896        	bltz	a8, 4201152c <_dtoa_r+0x788>
420113f3:	e90c      	movi.n	a9, 14
420113f5:	729930        	lsi	f3, a9, 0x1c8
420113f8:	990b      	addi.n	a9, a9, -1
420113fa:	609090        	neg	a9, a9
420113fd:	749090        	extui	a9, a9, 0, 8
42011400:	128916        	beqz	a9, 4201152c <_dtoa_r+0x788>
42011403:	be6381        	l32r	a8, 42000d90 <_stext+0xd70> (3c029748 <__mprec_tens>)
42011406:	b08380        	addx8	a8, a3, a8
42011409:	0848      	l32i.n	a4, a8, 0
4201140b:	1858      	l32i.n	a5, a8, 4
4201140d:	142182        	l32i	a8, a1, 80
42011410:	0108d6        	bgez	a8, 42011424 <_dtoa_r+0x680>
42011413:	8198      	l32i.n	a9, a1, 32
42011415:	080c      	movi.n	a8, 0
42011417:	728890        	lsi	f9, a8, 0x1c8
4201141a:	880b      	addi.n	a8, a8, -1
4201141c:	608080        	neg	a8, a8
4201141f:	748080        	extui	a8, a8, 0, 8
42011422:	c8cc      	bnez.n	a8, 42011432 <_dtoa_r+0x68e>
42011424:	8188      	l32i.n	a8, a1, 32
42011426:	721b      	addi.n	a7, a2, 1
42011428:	828a      	add.n	a8, a2, a8
4201142a:	8189      	s32i.n	a8, a1, 32
4201142c:	000d86        	j	42011466 <_dtoa_r+0x6c2>
4201142f:	000000        	ill
42011432:	8188      	l32i.n	a8, a1, 32
42011434:	28ec      	bnez.n	a8, 4201145a <_dtoa_r+0x6b6>
42011436:	be5ad1        	l32r	a13, 42000da0 <_stext+0xd80> (40140000 <rom_rx_gain_force+0x139bd4>)
42011439:	0c0c      	movi.n	a12, 0
4201143b:	04ad      	mov.n	a10, a4
4201143d:	20b550        	or	a11, a5, a5
42011440:	be3781        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
42011443:	0008e0        	callx8	a8
42011446:	0acd      	mov.n	a12, a10
42011448:	0bdd      	mov.n	a13, a11
4201144a:	e1a8      	l32i.n	a10, a1, 56
4201144c:	f1b8      	l32i.n	a11, a1, 60
4201144e:	be3181        	l32r	a8, 42000d14 <_stext+0xcf4> (400023b8 <__ledf2>)
42011451:	0008e0        	callx8	a8
42011454:	021aa6        	blti	a10, 1, 4201145a <_dtoa_r+0x6b6>
42011457:	00c786        	j	42011779 <_dtoa_r+0x9d5>
4201145a:	080c      	movi.n	a8, 0
4201145c:	6189      	s32i.n	a8, a1, 24
4201145e:	070c      	movi.n	a7, 0
42011460:	00c206        	j	4201176c <_dtoa_r+0x9c8>
42011463:	000000        	ill
42011466:	e1a8      	l32i.n	a10, a1, 56
42011468:	f1b8      	l32i.n	a11, a1, 60
4201146a:	04cd      	mov.n	a12, a4
4201146c:	05dd      	mov.n	a13, a5
4201146e:	be5681        	l32r	a8, 42000dc8 <_stext+0xda8> (40002250 <__divdf3>)
42011471:	0008e0        	callx8	a8
42011474:	be2c81        	l32r	a8, 42000d24 <_stext+0xd04> (400022d4 <__fixdfsi>)
42011477:	0008e0        	callx8	a8
4201147a:	61a9      	s32i.n	a10, a1, 24
4201147c:	be2b81        	l32r	a8, 42000d28 <_stext+0xd08> (40002334 <__floatsidf>)
4201147f:	0008e0        	callx8	a8
42011482:	04cd      	mov.n	a12, a4
42011484:	20d550        	or	a13, a5, a5
42011487:	be2581        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
4201148a:	0008e0        	callx8	a8
4201148d:	0acd      	mov.n	a12, a10
4201148f:	0bdd      	mov.n	a13, a11
42011491:	e1a8      	l32i.n	a10, a1, 56
42011493:	f1b8      	l32i.n	a11, a1, 60
42011495:	076d      	mov.n	a6, a7
42011497:	be2581        	l32r	a8, 42000d2c <_stext+0xd0c> (400024fc <__subdf3>)
4201149a:	0008e0        	callx8	a8
4201149d:	6198      	l32i.n	a9, a1, 24
4201149f:	870b      	addi.n	a8, a7, -1
420114a1:	30c992        	addi	a9, a9, 48
420114a4:	004892        	s8i	a9, a8, 0
420114a7:	8188      	l32i.n	a8, a1, 32
420114a9:	5c9877        	bne	a8, a7, 42011509 <_dtoa_r+0x765>
420114ac:	0acd      	mov.n	a12, a10
420114ae:	0bdd      	mov.n	a13, a11
420114b0:	be4581        	l32r	a8, 42000dc4 <_stext+0xda4> (40002184 <__adddf3>)
420114b3:	0008e0        	callx8	a8
420114b6:	04cd      	mov.n	a12, a4
420114b8:	05dd      	mov.n	a13, a5
420114ba:	81a9      	s32i.n	a10, a1, 32
420114bc:	91b9      	s32i.n	a11, a1, 36
420114be:	be1d81        	l32r	a8, 42000d34 <_stext+0xd14> (400023a0 <__gtdf2>)
420114c1:	0008e0        	callx8	a8
420114c4:	241ae6        	bgei	a10, 1, 420114ec <_dtoa_r+0x748>
420114c7:	81a8      	l32i.n	a10, a1, 32
420114c9:	91b8      	l32i.n	a11, a1, 36
420114cb:	04cd      	mov.n	a12, a4
420114cd:	05dd      	mov.n	a13, a5
420114cf:	be1481        	l32r	a8, 42000d20 <_stext+0xd00> (4000228c <__eqdf2>)
420114d2:	0008e0        	callx8	a8
420114d5:	509a56        	bnez	a10, 420119e2 <_dtoa_r+0xc3e>
420114d8:	6188      	l32i.n	a8, a1, 24
420114da:	0ee807        	bbsi	a8, 0, 420114ec <_dtoa_r+0x748>
420114dd:	014046        	j	420119e2 <_dtoa_r+0xc3e>
420114e0:	aa0b      	addi.n	a10, a10, -1
420114e2:	facc      	bnez.n	a10, 420114f5 <_dtoa_r+0x751>
420114e4:	551b      	addi.n	a5, a5, 1
420114e6:	093c      	movi.n	a9, 48
420114e8:	0004c6        	j	420114ff <_dtoa_r+0x75b>
420114eb:	035d00        	lsi	f0, a13, 12
420114ee:	068d      	mov.n	a8, a6
420114f0:	9b3c      	movi.n	a11, 57
420114f2:	c0a620        	sub	a10, a6, a2
420114f5:	086d      	mov.n	a6, a8
420114f7:	880b      	addi.n	a8, a8, -1
420114f9:	000892        	l8ui	a9, a8, 0
420114fc:	e019b7        	beq	a9, a11, 420114e0 <_dtoa_r+0x73c>
420114ff:	991b      	addi.n	a9, a9, 1
42011501:	004892        	s8i	a9, a8, 0
42011504:	013606        	j	420119e0 <_dtoa_r+0xc3c>
42011507:	d10000        	mul16s	a0, a0, a0
4201150a:	0cbe24        	lsi	f2, a14, 48
4201150d:	810c      	movi.n	a1, 8
4201150f:	e0be03        	lsi	f0, a14, 0x380
42011512:	0008      	l32i.n	a0, a0, 0
42011514:	e1a9      	s32i.n	a10, a1, 56
42011516:	f1b9      	s32i.n	a11, a1, 60
42011518:	0c0c      	movi.n	a12, 0
4201151a:	0d0c      	movi.n	a13, 0
4201151c:	771b      	addi.n	a7, a7, 1
4201151e:	be0081        	l32r	a8, 42000d20 <_stext+0xd00> (4000228c <__eqdf2>)
42011521:	0008e0        	callx8	a8
42011524:	f3ea56        	bnez	a10, 42011466 <_dtoa_r+0x6c2>
42011527:	012dc6        	j	420119e2 <_dtoa_r+0xc3e>
4201152a:	920000        	lsi	f0, a0, 0x248
4201152d:	581021        	l32r	a2, 41fe7570 <_coredump_iram_end+0x1c65670>
42011530:	046dd1        	l32r	a13, 41fd26e4 <_coredump_iram_end+0x1c507e4>
42011533:	070c      	movi.n	a7, 0
42011535:	069916        	beqz	a9, 420115a2 <_dtoa_r+0x7fe>
42011538:	c198      	l32i.n	a9, a1, 48
4201153a:	1a29e6        	bgei	a9, 2, 42011558 <_dtoa_r+0x7b4>
4201153d:	182192        	l32i	a9, a1, 96
42011540:	698c      	beqz.n	a9, 4201154a <_dtoa_r+0x7a6>
42011542:	33a492        	movi	a9, 0x433
42011545:	889a      	add.n	a8, a8, a9
42011547:	0010c6        	j	4201158e <_dtoa_r+0x7ea>
4201154a:	1188      	l32i.n	a8, a1, 4
4201154c:	d158      	l32i.n	a5, a1, 52
4201154e:	cac882        	addi	a8, a8, -54
42011551:	608080        	neg	a8, a8
42011554:	000d86        	j	4201158e <_dtoa_r+0x7ea>
42011557:	818800        	src	a8, a8, a0
4201155a:	580b      	addi.n	a5, a8, -1
4201155c:	d188      	l32i.n	a8, a1, 52
4201155e:	182857        	blt	a8, a5, 4201157a <_dtoa_r+0x7d6>
42011561:	c05850        	sub	a5, a8, a5
42011564:	8198      	l32i.n	a9, a1, 32
42011566:	8188      	l32i.n	a8, a1, 32
42011568:	c06480        	sub	a6, a4, a8
4201156b:	080c      	movi.n	a8, 0
4201156d:	01d996        	bltz	a9, 4201158e <_dtoa_r+0x7ea>
42011570:	046d      	mov.n	a6, a4
42011572:	098d      	mov.n	a8, a9
42011574:	000586        	j	4201158e <_dtoa_r+0x7ea>
42011577:	000000        	ill
4201157a:	d188      	l32i.n	a8, a1, 52
4201157c:	112192        	l32i	a9, a1, 68
4201157f:	c08580        	sub	a8, a5, a8
42011582:	898a      	add.n	a8, a9, a8
42011584:	116182        	s32i	a8, a1, 68
42011587:	8188      	l32i.n	a8, a1, 32
42011589:	d159      	s32i.n	a5, a1, 52
4201158b:	00a052        	movi	a5, 0
4201158e:	a198      	l32i.n	a9, a1, 40
42011590:	41a8      	l32i.n	a10, a1, 16
42011592:	448a      	add.n	a4, a4, a8
42011594:	1b0c      	movi.n	a11, 1
42011596:	898a      	add.n	a8, a9, a8
42011598:	a189      	s32i.n	a8, a1, 40
4201159a:	201110        	or	a1, a1, a1
4201159d:	0073a5        	call8	42011cd8 <__i2b>
420115a0:	0a7d      	mov.n	a7, a10
420115a2:	080c      	movi.n	a8, 0
420115a4:	269c      	beqz.n	a6, 420115ba <_dtoa_r+0x816>
420115a6:	a198      	l32i.n	a9, a1, 40
420115a8:	0ea897        	bge	a8, a9, 420115ba <_dtoa_r+0x816>
420115ab:	438690        	min	a8, a6, a9
420115ae:	c04480        	sub	a4, a4, a8
420115b1:	c06680        	sub	a6, a6, a8
420115b4:	c08980        	sub	a8, a9, a8
420115b7:	0a6182        	s32i	a8, a1, 40
420115ba:	d188      	l32i.n	a8, a1, 52
420115bc:	056816        	beqz	a8, 42011616 <_dtoa_r+0x872>
420115bf:	102182        	l32i	a8, a1, 64
420115c2:	042816        	beqz	a8, 42011608 <_dtoa_r+0x864>
420115c5:	5188      	l32i.n	a8, a1, 20
420115c7:	55bc      	beqz.n	a5, 42011600 <_dtoa_r+0x85c>
420115c9:	41a8      	l32i.n	a10, a1, 16
420115cb:	07bd      	mov.n	a11, a7
420115cd:	20c550        	or	a12, a5, a5
420115d0:	201110        	or	a1, a1, a1
420115d3:	008aa5        	call8	42011e7c <__pow5mult>
420115d6:	0abd      	mov.n	a11, a10
420115d8:	51c8      	l32i.n	a12, a1, 20
420115da:	0a7d      	mov.n	a7, a10
420115dc:	0421a2        	l32i	a10, a1, 16
420115df:	201110        	or	a1, a1, a1
420115e2:	0071e5        	call8	42011d00 <__multiply>
420115e5:	61a9      	s32i.n	a10, a1, 24
420115e7:	51b8      	l32i.n	a11, a1, 20
420115e9:	41a8      	l32i.n	a10, a1, 16
420115eb:	201110        	or	a1, a1, a1
420115ee:	004d25        	call8	42011ac0 <_Bfree>
420115f1:	d188      	l32i.n	a8, a1, 52
420115f3:	c08850        	sub	a8, a8, a5
420115f6:	d189      	s32i.n	a8, a1, 52
420115f8:	6188      	l32i.n	a8, a1, 24
420115fa:	d198      	l32i.n	a9, a1, 52
420115fc:	5189      	s32i.n	a8, a1, 20
420115fe:	499c      	beqz.n	a9, 42011616 <_dtoa_r+0x872>
42011600:	d1c8      	l32i.n	a12, a1, 52
42011602:	08bd      	mov.n	a11, a8
42011604:	000106        	j	4201160c <_dtoa_r+0x868>
42011607:	d1c800        	mul16s	a12, a8, a0
4201160a:	51b8      	l32i.n	a11, a1, 20
4201160c:	41a8      	l32i.n	a10, a1, 16
4201160e:	201110        	or	a1, a1, a1
42011611:	0086a5        	call8	42011e7c <__pow5mult>
42011614:	51a9      	s32i.n	a10, a1, 20
42011616:	41a8      	l32i.n	a10, a1, 16
42011618:	01a0b2        	movi	a11, 1
4201161b:	201110        	or	a1, a1, a1
4201161e:	006ba5        	call8	42011cd8 <__i2b>
42011621:	112182        	l32i	a8, a1, 68
42011624:	61a9      	s32i.n	a10, a1, 24
42011626:	3fa816        	beqz	a8, 42011a24 <_dtoa_r+0xc80>
42011629:	0abd      	mov.n	a11, a10
4201162b:	41a8      	l32i.n	a10, a1, 16
4201162d:	08cd      	mov.n	a12, a8
4201162f:	201110        	or	a1, a1, a1
42011632:	0084a5        	call8	42011e7c <__pow5mult>
42011635:	080c      	movi.n	a8, 0
42011637:	e189      	s32i.n	a8, a1, 56
42011639:	0c2182        	l32i	a8, a1, 48
4201163c:	61a9      	s32i.n	a10, a1, 24
4201163e:	2e28e6        	bgei	a8, 2, 42011670 <_dtoa_r+0x8cc>
42011641:	080c      	movi.n	a8, 0
42011643:	e189      	s32i.n	a8, a1, 56
42011645:	122182        	l32i	a8, a1, 72
42011648:	d8dc      	bnez.n	a8, 42011669 <_dtoa_r+0x8c5>
4201164a:	132182        	l32i	a8, a1, 76
4201164d:	118840        	slli	a8, a8, 12
42011650:	58dc      	bnez.n	a8, 42011669 <_dtoa_r+0x8c5>
42011652:	132182        	l32i	a8, a1, 76
42011655:	a58480        	extui	a8, a8, 20, 11
42011658:	d88c      	beqz.n	a8, 42011669 <_dtoa_r+0x8c5>
4201165a:	a188      	l32i.n	a8, a1, 40
4201165c:	441b      	addi.n	a4, a4, 1
4201165e:	881b      	addi.n	a8, a8, 1
42011660:	0a6182        	s32i	a8, a1, 40
42011663:	01a082        	movi	a8, 1
42011666:	0e6182        	s32i	a8, a1, 56
42011669:	112182        	l32i	a8, a1, 68
4201166c:	1a0c      	movi.n	a10, 1
4201166e:	589c      	beqz.n	a8, 42011687 <_dtoa_r+0x8e3>
42011670:	6188      	l32i.n	a8, a1, 24
42011672:	6198      	l32i.n	a9, a1, 24
42011674:	4888      	l32i.n	a8, a8, 16
42011676:	a08890        	addx4	a8, a8, a9
42011679:	48a8      	l32i.n	a10, a8, 16
4201167b:	201110        	or	a1, a1, a1
4201167e:	0059e5        	call8	42011c1c <__hi0bits>
42011681:	e0caa2        	addi	a10, a10, -32
42011684:	60a0a0        	neg	a10, a10
42011687:	a188      	l32i.n	a8, a1, 40
42011689:	aa8a      	add.n	a10, a10, a8
4201168b:	44a0a0        	extui	a10, a10, 0, 5
4201168e:	0aac      	beqz.n	a10, 420116b2 <_dtoa_r+0x90e>
42011690:	e0ca82        	addi	a8, a10, -32
42011693:	608080        	neg	a8, a8
42011696:	1258a6        	blti	a8, 5, 420116ac <_dtoa_r+0x908>
42011699:	a188      	l32i.n	a8, a1, 40
4201169b:	e4caa2        	addi	a10, a10, -28
4201169e:	60a0a0        	neg	a10, a10
420116a1:	44aa      	add.n	a4, a4, a10
420116a3:	66aa      	add.n	a6, a6, a10
420116a5:	88aa      	add.n	a8, a8, a10
420116a7:	000506        	j	420116bf <_dtoa_r+0x91b>
420116aa:	260000        	lsi	f0, a0, 152
420116ad:	1148      	l32i.n	a4, a1, 4
420116af:	000046        	j	420116b4 <_dtoa_r+0x910>
420116b2:	080c      	movi.n	a8, 0
420116b4:	a198      	l32i.n	a9, a1, 40
420116b6:	1cc882        	addi	a8, a8, 28
420116b9:	448a      	add.n	a4, a4, a8
420116bb:	668a      	add.n	a6, a6, a8
420116bd:	898a      	add.n	a8, a9, a8
420116bf:	a189      	s32i.n	a8, a1, 40
420116c1:	0d14a6        	blti	a4, 1, 420116d2 <_dtoa_r+0x92e>
420116c4:	51b8      	l32i.n	a11, a1, 20
420116c6:	41a8      	l32i.n	a10, a1, 16
420116c8:	04cd      	mov.n	a12, a4
420116ca:	201110        	or	a1, a1, a1
420116cd:	0085a5        	call8	42011f28 <__lshift>
420116d0:	51a9      	s32i.n	a10, a1, 20
420116d2:	a188      	l32i.n	a8, a1, 40
420116d4:	1118a6        	blti	a8, 1, 420116e9 <_dtoa_r+0x945>
420116d7:	0621b2        	l32i	a11, a1, 24
420116da:	0421a2        	l32i	a10, a1, 16
420116dd:	20c880        	or	a12, a8, a8
420116e0:	201110        	or	a1, a1, a1
420116e3:	008465        	call8	42011f28 <__lshift>
420116e6:	0661a2        	s32i	a10, a1, 24
420116e9:	152182        	l32i	a8, a1, 84
420116ec:	c88c      	beqz.n	a8, 420116fc <_dtoa_r+0x958>
420116ee:	61b8      	l32i.n	a11, a1, 24
420116f0:	0521a2        	l32i	a10, a1, 20
420116f3:	201110        	or	a1, a1, a1
420116f6:	0093a5        	call8	42012030 <__mcmp>
420116f9:	009a96        	bltz	a10, 42011706 <_dtoa_r+0x962>
420116fc:	8188      	l32i.n	a8, a1, 32
420116fe:	035d      	mov.n	a5, a3
42011700:	b189      	s32i.n	a8, a1, 44
42011702:	000ac6        	j	42011731 <_dtoa_r+0x98d>
42011705:	51b800        	lsi	f0, a8, 0x144
42011708:	41a8      	l32i.n	a10, a1, 16
4201170a:	0d0c      	movi.n	a13, 0
4201170c:	0aa0c2        	movi	a12, 10
4201170f:	201110        	or	a1, a1, a1
42011712:	003ee5        	call8	42011b00 <__multadd>
42011715:	102182        	l32i	a8, a1, 64
42011718:	51a9      	s32i.n	a10, a1, 20
4201171a:	530b      	addi.n	a5, a3, -1
4201171c:	189c      	beqz.n	a8, 42011731 <_dtoa_r+0x98d>
4201171e:	41a8      	l32i.n	a10, a1, 16
42011720:	07bd      	mov.n	a11, a7
42011722:	00a0d2        	movi	a13, 0
42011725:	0aa0c2        	movi	a12, 10
42011728:	201110        	or	a1, a1, a1
4201172b:	003d65        	call8	42011b00 <__multadd>
4201172e:	207aa0        	or	a7, a10, a10
42011731:	b198      	l32i.n	a9, a1, 44
42011733:	080c      	movi.n	a8, 0
42011735:	728890        	lsi	f9, a8, 0x1c8
42011738:	880b      	addi.n	a8, a8, -1
4201173a:	608080        	neg	a8, a8
4201173d:	748080        	extui	a8, a8, 0, 8
42011740:	04d816        	beqz	a8, 42011791 <_dtoa_r+0x9ed>
42011743:	c198      	l32i.n	a9, a1, 48
42011745:	280c      	movi.n	a8, 2
42011747:	46a897        	bge	a8, a9, 42011791 <_dtoa_r+0x9ed>
4201174a:	b188      	l32i.n	a8, a1, 44
4201174c:	c8dc      	bnez.n	a8, 4201176c <_dtoa_r+0x9c8>
4201174e:	61b8      	l32i.n	a11, a1, 24
42011750:	41a8      	l32i.n	a10, a1, 16
42011752:	0d0c      	movi.n	a13, 0
42011754:	05a0c2        	movi	a12, 5
42011757:	201110        	or	a1, a1, a1
4201175a:	003a65        	call8	42011b00 <__multadd>
4201175d:	61a9      	s32i.n	a10, a1, 24
4201175f:	0abd      	mov.n	a11, a10
42011761:	51a8      	l32i.n	a10, a1, 20
42011763:	201110        	or	a1, a1, a1
42011766:	008ca5        	call8	42012030 <__mcmp>
42011769:	141ae6        	bgei	a10, 1, 42011781 <_dtoa_r+0x9dd>
4201176c:	142192        	l32i	a9, a1, 80
4201176f:	f87c      	movi.n	a8, -1
42011771:	305980        	xor	a5, a9, a8
42011774:	026d      	mov.n	a6, a2
42011776:	000406        	j	4201178a <_dtoa_r+0x9e6>
42011779:	035d      	mov.n	a5, a3
4201177b:	080c      	movi.n	a8, 0
4201177d:	6189      	s32i.n	a8, a1, 24
4201177f:	070c      	movi.n	a7, 0
42011781:	183c      	movi.n	a8, 49
42011783:	621b      	addi.n	a6, a2, 1
42011785:	004282        	s8i	a8, a2, 0
42011788:	551b      	addi.n	a5, a5, 1
4201178a:	074d      	mov.n	a4, a7
4201178c:	070c      	movi.n	a7, 0
4201178e:	008a06        	j	420119ba <_dtoa_r+0xc16>
42011791:	102182        	l32i	a8, a1, 64
42011794:	189816        	beqz	a8, 42011921 <_dtoa_r+0xb7d>
42011797:	0d16a6        	blti	a6, 1, 420117a8 <_dtoa_r+0xa04>
4201179a:	41a8      	l32i.n	a10, a1, 16
4201179c:	07bd      	mov.n	a11, a7
4201179e:	06cd      	mov.n	a12, a6
420117a0:	201110        	or	a1, a1, a1
420117a3:	007865        	call8	42011f28 <__lshift>
420117a6:	0a7d      	mov.n	a7, a10
420117a8:	e188      	l32i.n	a8, a1, 56
420117aa:	074d      	mov.n	a4, a7
420117ac:	88bc      	beqz.n	a8, 420117e8 <_dtoa_r+0xa44>
420117ae:	17b8      	l32i.n	a11, a7, 4
420117b0:	41a8      	l32i.n	a10, a1, 16
420117b2:	201110        	or	a1, a1, a1
420117b5:	002825        	call8	42011a38 <_Balloc>
420117b8:	0a6d      	mov.n	a6, a10
420117ba:	aacc      	bnez.n	a10, 420117c8 <_dtoa_r+0xa24>
420117bc:	bd76d1        	l32r	a13, 42000d94 <_stext+0xd74> (3c0291fa <Xthal_intlevel+0xce>)
420117bf:	0c0c      	movi.n	a12, 0
420117c1:	efa2b2        	movi	a11, 0x2ef
420117c4:	fe2f06        	j	42011084 <_dtoa_r+0x2e0>
420117c7:	47c800        	lsi	f0, a8, 0x11c
420117ca:	b7cb      	addi.n	a11, a7, 12
420117cc:	cc2b      	addi.n	a12, a12, 2
420117ce:	11cce0        	slli	a12, a12, 2
420117d1:	0ccaa2        	addi	a10, a10, 12
420117d4:	ba1581        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420117d7:	0008e0        	callx8	a8
420117da:	41a8      	l32i.n	a10, a1, 16
420117dc:	1c0c      	movi.n	a12, 1
420117de:	06bd      	mov.n	a11, a6
420117e0:	201110        	or	a1, a1, a1
420117e3:	007465        	call8	42011f28 <__lshift>
420117e6:	0a4d      	mov.n	a4, a10
420117e8:	b1a8      	l32i.n	a10, a1, 44
420117ea:	820b      	addi.n	a8, a2, -1
420117ec:	88aa      	add.n	a8, a8, a10
420117ee:	e189      	s32i.n	a8, a1, 56
420117f0:	122182        	l32i	a8, a1, 72
420117f3:	029d      	mov.n	a9, a2
420117f5:	048080        	extui	a8, a8, 0, 1
420117f8:	b189      	s32i.n	a8, a1, 44
420117fa:	61b8      	l32i.n	a11, a1, 24
420117fc:	0521a2        	l32i	a10, a1, 20
420117ff:	d199      	s32i.n	a9, a1, 52
42011801:	ff46a5        	call8	42010c6c <quorem>
42011804:	81a9      	s32i.n	a10, a1, 32
42011806:	30ca32        	addi	a3, a10, 48
42011809:	0521a2        	l32i	a10, a1, 20
4201180c:	07bd      	mov.n	a11, a7
4201180e:	201110        	or	a1, a1, a1
42011811:	0081e5        	call8	42012030 <__mcmp>
42011814:	a1a9      	s32i.n	a10, a1, 40
42011816:	61b8      	l32i.n	a11, a1, 24
42011818:	41a8      	l32i.n	a10, a1, 16
4201181a:	04cd      	mov.n	a12, a4
4201181c:	201110        	or	a1, a1, a1
4201181f:	0084e5        	call8	4201206c <__mdiff>
42011822:	0a6d      	mov.n	a6, a10
42011824:	3aa8      	l32i.n	a10, a10, 12
42011826:	1021c2        	l32i	a12, a1, 64
42011829:	d198      	l32i.n	a9, a1, 52
4201182b:	eacc      	bnez.n	a10, 4201183d <_dtoa_r+0xa99>
4201182d:	51a8      	l32i.n	a10, a1, 20
4201182f:	20b660        	or	a11, a6, a6
42011832:	201110        	or	a1, a1, a1
42011835:	007fa5        	call8	42012030 <__mcmp>
42011838:	d198      	l32i.n	a9, a1, 52
4201183a:	20caa0        	or	a12, a10, a10
4201183d:	41a8      	l32i.n	a10, a1, 16
4201183f:	06bd      	mov.n	a11, a6
42011841:	116192        	s32i	a9, a1, 68
42011844:	d1c9      	s32i.n	a12, a1, 52
42011846:	201110        	or	a1, a1, a1
42011849:	002765        	call8	42011ac0 <_Bfree>
4201184c:	c188      	l32i.n	a8, a1, 48
4201184e:	d1c8      	l32i.n	a12, a1, 52
42011850:	112192        	l32i	a9, a1, 68
42011853:	20a8c0        	or	a10, a8, a12
42011856:	b188      	l32i.n	a8, a1, 44
42011858:	691b      	addi.n	a6, a9, 1
4201185a:	20aa80        	or	a10, a10, a8
4201185d:	cacc      	bnez.n	a10, 4201186d <_dtoa_r+0xac9>
4201185f:	9a3c      	movi.n	a10, 57
42011861:	5b13a7        	beq	a3, a10, 420118c0 <_dtoa_r+0xb1c>
42011864:	a188      	l32i.n	a8, a1, 40
42011866:	4618a6        	blti	a8, 1, 420118b0 <_dtoa_r+0xb0c>
42011869:	000f86        	j	420118ab <_dtoa_r+0xb07>
4201186c:	a18800        	sll	a8, a8
4201186f:	00d896        	bltz	a8, 42011880 <_dtoa_r+0xadc>
42011872:	a1a8      	l32i.n	a10, a1, 40
42011874:	c188      	l32i.n	a8, a1, 48
42011876:	2088a0        	or	a8, a8, a10
42011879:	b1a8      	l32i.n	a10, a1, 44
4201187b:	2088a0        	or	a8, a8, a10
4201187e:	68fc      	bnez.n	a8, 420118b8 <_dtoa_r+0xb14>
42011880:	2c1ca6        	blti	a12, 1, 420118b0 <_dtoa_r+0xb0c>
42011883:	51b8      	l32i.n	a11, a1, 20
42011885:	41a8      	l32i.n	a10, a1, 16
42011887:	1c0c      	movi.n	a12, 1
42011889:	0a6192        	s32i	a9, a1, 40
4201188c:	201110        	or	a1, a1, a1
4201188f:	0069a5        	call8	42011f28 <__lshift>
42011892:	61b8      	l32i.n	a11, a1, 24
42011894:	51a9      	s32i.n	a10, a1, 20
42011896:	201110        	or	a1, a1, a1
42011899:	007965        	call8	42012030 <__mcmp>
4201189c:	a198      	l32i.n	a9, a1, 40
4201189e:	041ae6        	bgei	a10, 1, 420118a6 <_dtoa_r+0xb02>
420118a1:	bacc      	bnez.n	a10, 420118b0 <_dtoa_r+0xb0c>
420118a3:	096307        	bbci	a3, 0, 420118b0 <_dtoa_r+0xb0c>
420118a6:	9a3c      	movi.n	a10, 57
420118a8:	1413a7        	beq	a3, a10, 420118c0 <_dtoa_r+0xb1c>
420118ab:	8188      	l32i.n	a8, a1, 32
420118ad:	31c832        	addi	a3, a8, 49
420118b0:	004932        	s8i	a3, a9, 0
420118b3:	0040c6        	j	420119ba <_dtoa_r+0xc16>
420118b6:	a60000        	lsi	f0, a0, 0x298
420118b9:	141c      	movi.n	a4, 17
420118bb:	9a3c      	movi.n	a10, 57
420118bd:	0793a7        	bne	a3, a10, 420118c8 <_dtoa_r+0xb24>
420118c0:	983c      	movi.n	a8, 57
420118c2:	004982        	s8i	a8, a9, 0
420118c5:	003246        	j	42011992 <_dtoa_r+0xbee>
420118c8:	831b      	addi.n	a8, a3, 1
420118ca:	004982        	s8i	a8, a9, 0
420118cd:	003a46        	j	420119ba <_dtoa_r+0xc16>
420118d0:	e188      	l32i.n	a8, a1, 56
420118d2:	004932        	s8i	a3, a9, 0
420118d5:	029897        	bne	a8, a9, 420118db <_dtoa_r+0xb37>
420118d8:	002106        	j	42011960 <_dtoa_r+0xbbc>
420118db:	51b8      	l32i.n	a11, a1, 20
420118dd:	41a8      	l32i.n	a10, a1, 16
420118df:	0d0c      	movi.n	a13, 0
420118e1:	ac0c      	movi.n	a12, 10
420118e3:	201110        	or	a1, a1, a1
420118e6:	0021a5        	call8	42011b00 <__multadd>
420118e9:	51a9      	s32i.n	a10, a1, 20
420118eb:	0d0c      	movi.n	a13, 0
420118ed:	41a8      	l32i.n	a10, a1, 16
420118ef:	ac0c      	movi.n	a12, 10
420118f1:	07bd      	mov.n	a11, a7
420118f3:	0d9747        	bne	a7, a4, 42011904 <_dtoa_r+0xb60>
420118f6:	201110        	or	a1, a1, a1
420118f9:	002065        	call8	42011b00 <__multadd>
420118fc:	0a7d      	mov.n	a7, a10
420118fe:	0a4d      	mov.n	a4, a10
42011900:	000606        	j	4201191c <_dtoa_r+0xb78>
42011903:	111000        	slli	a1, a0, 16
42011906:	1fa520        	f64cmph	a10, a5, a2, 1
42011909:	0a7d00        	add.s	f7, f13, f0
4201190c:	41a8      	l32i.n	a10, a1, 16
4201190e:	04bd      	mov.n	a11, a4
42011910:	0d0c      	movi.n	a13, 0
42011912:	ac0c      	movi.n	a12, 10
42011914:	201110        	or	a1, a1, a1
42011917:	001ea5        	call8	42011b00 <__multadd>
4201191a:	0a4d      	mov.n	a4, a10
4201191c:	069d      	mov.n	a9, a6
4201191e:	ffb606        	j	420117fa <_dtoa_r+0xa56>
42011921:	060c      	movi.n	a6, 0
42011923:	61b8      	l32i.n	a11, a1, 24
42011925:	51a8      	l32i.n	a10, a1, 20
42011927:	ff3465        	call8	42010c6c <quorem>
4201192a:	926a      	add.n	a9, a2, a6
4201192c:	30ca32        	addi	a3, a10, 48
4201192f:	b188      	l32i.n	a8, a1, 44
42011931:	004932        	s8i	a3, a9, 0
42011934:	661b      	addi.n	a6, a6, 1
42011936:	13a687        	bge	a6, a8, 4201194d <_dtoa_r+0xba9>
42011939:	51b8      	l32i.n	a11, a1, 20
4201193b:	41a8      	l32i.n	a10, a1, 16
4201193d:	0d0c      	movi.n	a13, 0
4201193f:	0aa0c2        	movi	a12, 10
42011942:	201110        	or	a1, a1, a1
42011945:	001ba5        	call8	42011b00 <__multadd>
42011948:	51a9      	s32i.n	a10, a1, 20
4201194a:	fff546        	j	42011923 <_dtoa_r+0xb7f>
4201194d:	b188      	l32i.n	a8, a1, 44
4201194f:	090c      	movi.n	a9, 0
42011951:	060c      	movi.n	a6, 0
42011953:	01a987        	bge	a9, a8, 42011958 <_dtoa_r+0xbb4>
42011956:	680b      	addi.n	a6, a8, -1
42011958:	921b      	addi.n	a9, a2, 1
4201195a:	074d      	mov.n	a4, a7
4201195c:	669a      	add.n	a6, a6, a9
4201195e:	070c      	movi.n	a7, 0
42011960:	51b8      	l32i.n	a11, a1, 20
42011962:	0421a2        	l32i	a10, a1, 16
42011965:	01a0c2        	movi	a12, 1
42011968:	201110        	or	a1, a1, a1
4201196b:	005be5        	call8	42011f28 <__lshift>
4201196e:	61b8      	l32i.n	a11, a1, 24
42011970:	51a9      	s32i.n	a10, a1, 20
42011972:	201110        	or	a1, a1, a1
42011975:	006ba5        	call8	42012030 <__mcmp>
42011978:	161ae6        	bgei	a10, 1, 42011992 <_dtoa_r+0xbee>
4201197b:	daec      	bnez.n	a10, 420119ac <_dtoa_r+0xc08>
4201197d:	11e307        	bbsi	a3, 0, 42011992 <_dtoa_r+0xbee>
42011980:	000a06        	j	420119ac <_dtoa_r+0xc08>
42011983:	aa0b00        	floor.s	a0, f11, 0
42011986:	facc      	bnez.n	a10, 42011999 <_dtoa_r+0xbf5>
42011988:	183c      	movi.n	a8, 49
4201198a:	551b      	addi.n	a5, a5, 1
4201198c:	004282        	s8i	a8, a2, 0
4201198f:	0009c6        	j	420119ba <_dtoa_r+0xc16>
42011992:	068d      	mov.n	a8, a6
42011994:	9b3c      	movi.n	a11, 57
42011996:	c0a620        	sub	a10, a6, a2
42011999:	086d      	mov.n	a6, a8
4201199b:	880b      	addi.n	a8, a8, -1
4201199d:	000892        	l8ui	a9, a8, 0
420119a0:	e019b7        	beq	a9, a11, 42011984 <_dtoa_r+0xbe0>
420119a3:	991b      	addi.n	a9, a9, 1
420119a5:	004892        	s8i	a9, a8, 0
420119a8:	000386        	j	420119ba <_dtoa_r+0xc16>
420119ab:	068d00        	lsi	f0, a13, 24
420119ae:	093c      	movi.n	a9, 48
420119b0:	086d      	mov.n	a6, a8
420119b2:	880b      	addi.n	a8, a8, -1
420119b4:	0008a2        	l8ui	a10, a8, 0
420119b7:	f51a97        	beq	a10, a9, 420119b0 <_dtoa_r+0xc0c>
420119ba:	61b8      	l32i.n	a11, a1, 24
420119bc:	41a8      	l32i.n	a10, a1, 16
420119be:	201110        	or	a1, a1, a1
420119c1:	000fe5        	call8	42011ac0 <_Bfree>
420119c4:	849c      	beqz.n	a4, 420119e0 <_dtoa_r+0xc3c>
420119c6:	c78c      	beqz.n	a7, 420119d6 <_dtoa_r+0xc32>
420119c8:	0a1747        	beq	a7, a4, 420119d6 <_dtoa_r+0xc32>
420119cb:	41a8      	l32i.n	a10, a1, 16
420119cd:	20b770        	or	a11, a7, a7
420119d0:	201110        	or	a1, a1, a1
420119d3:	000ee5        	call8	42011ac0 <_Bfree>
420119d6:	41a8      	l32i.n	a10, a1, 16
420119d8:	04bd      	mov.n	a11, a4
420119da:	201110        	or	a1, a1, a1
420119dd:	000e25        	call8	42011ac0 <_Bfree>
420119e0:	053d      	mov.n	a3, a5
420119e2:	51b8      	l32i.n	a11, a1, 20
420119e4:	41a8      	l32i.n	a10, a1, 16
420119e6:	201110        	or	a1, a1, a1
420119e9:	000d65        	call8	42011ac0 <_Bfree>
420119ec:	080c      	movi.n	a8, 0
420119ee:	242192        	l32i	a9, a1, 144
420119f1:	004682        	s8i	a8, a6, 0
420119f4:	831b      	addi.n	a8, a3, 1
420119f6:	0989      	s32i.n	a8, a9, 0
420119f8:	262182        	l32i	a8, a1, 152
420119fb:	68bc      	beqz.n	a8, 42011a35 <_dtoa_r+0xc91>
420119fd:	0869      	s32i.n	a6, a8, 0
420119ff:	000c86        	j	42011a35 <_dtoa_r+0xc91>
42011a02:	920000        	lsi	f0, a0, 0x248
42011a05:	212621        	l32r	a2, 41fd9ea0 <_coredump_iram_end+0x1c57fa0>
42011a08:	bcd9      	s32i.n	a13, a12, 44
42011a0a:	bcd981        	l32r	a8, 42000d70 <_stext+0xd50> (3c02918a <Xthal_intlevel+0x5e>)
42011a0d:	198c      	beqz.n	a9, 42011a12 <_dtoa_r+0xc6e>
42011a0f:	fd0c46        	j	42010e44 <_dtoa_r+0xa0>
42011a12:	0007c6        	j	42011a35 <_dtoa_r+0xc91>
42011a15:	218200        	srai	a8, a0, 2
42011a18:	d62126        	beqi	a1, 2, 420119f2 <_dtoa_r+0xc4e>
42011a1b:	8cbc      	beqz.n	a12, 42011a57 <_Balloc+0x1f>
42011a1d:	c618      	l32i.n	a1, a6, 48
42011a1f:	06fd07        	bbsi	a13, 16, 42011a29 <_dtoa_r+0xc85>
42011a22:	880004        	lsi	f0, a0, 0x220
42011a25:	28e6c1        	l32r	a12, 41fdbdc0 <_coredump_iram_end+0x1c59ec0>
42011a28:	050602        	l8ui	a0, a6, 5
42011a2b:	ff          	.byte	0xff
42011a2c:	080c      	movi.n	a8, 0
42011a2e:	e189      	s32i.n	a8, a1, 56
42011a30:	1a0c      	movi.n	a10, 1
42011a32:	ff1446        	j	42011687 <_dtoa_r+0x8e3>
42011a35:	f01d      	retw.n
	...

42011a38 <_Balloc>:
42011a38:	004136        	entry	a1, 32
42011a3b:	9278      	l32i.n	a7, a2, 36
42011a3d:	026d      	mov.n	a6, a2
42011a3f:	77ec      	bnez.n	a7, 42011a6a <_Balloc+0x32>
42011a41:	0a1c      	movi.n	a10, 16
42011a43:	bb5081        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
42011a46:	0008e0        	callx8	a8
42011a49:	92a9      	s32i.n	a10, a2, 36
42011a4b:	0a7d      	mov.n	a7, a10
42011a4d:	facc      	bnez.n	a10, 42011a60 <_Balloc+0x28>
42011a4f:	bcdfd1        	l32r	a13, 42000dcc <_stext+0xdac> (3c02918f <Xthal_intlevel+0x63>)
42011a52:	bcdfa1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011a55:	0c0c      	movi.n	a12, 0
42011a57:	6ba0b2        	movi	a11, 107
42011a5a:	b99981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011a5d:	0008e0        	callx8	a8
42011a60:	080c      	movi.n	a8, 0
42011a62:	1a89      	s32i.n	a8, a10, 4
42011a64:	2a89      	s32i.n	a8, a10, 8
42011a66:	0a89      	s32i.n	a8, a10, 0
42011a68:	3a89      	s32i.n	a8, a10, 12
42011a6a:	3788      	l32i.n	a8, a7, 12
42011a6c:	88dc      	bnez.n	a8, 42011a88 <_Balloc+0x50>
42011a6e:	1c2c      	movi.n	a12, 33
42011a70:	4b0c      	movi.n	a11, 4
42011a72:	06ad      	mov.n	a10, a6
42011a74:	bcd881        	l32r	a8, 42000dd4 <_stext+0xdb4> (4037feb0 <_calloc_r>)
42011a77:	0008e0        	callx8	a8
42011a7a:	9688      	l32i.n	a8, a6, 36
42011a7c:	37a9      	s32i.n	a10, a7, 12
42011a7e:	3888      	l32i.n	a8, a8, 12
42011a80:	48cc      	bnez.n	a8, 42011a88 <_Balloc+0x50>
42011a82:	020c      	movi.n	a2, 0
42011a84:	000d06        	j	42011abc <_Balloc+0x84>
42011a87:	838000        	moveqz	a8, a0, a0
42011a8a:	0828a0        	lsx	f2, a8, a10
42011a8d:	528c      	beqz.n	a2, 42011a96 <_Balloc+0x5e>
42011a8f:	0298      	l32i.n	a9, a2, 0
42011a91:	0899      	s32i.n	a9, a8, 0
42011a93:	0007c6        	j	42011ab6 <_Balloc+0x7e>
42011a96:	170c      	movi.n	a7, 1
42011a98:	401300        	ssl	a3
42011a9b:	a17700        	sll	a7, a7
42011a9e:	c75b      	addi.n	a12, a7, 5
42011aa0:	11cce0        	slli	a12, a12, 2
42011aa3:	1b0c      	movi.n	a11, 1
42011aa5:	06ad      	mov.n	a10, a6
42011aa7:	bccb81        	l32r	a8, 42000dd4 <_stext+0xdb4> (4037feb0 <_calloc_r>)
42011aaa:	0008e0        	callx8	a8
42011aad:	0a2d      	mov.n	a2, a10
42011aaf:	fcfa16        	beqz	a10, 42011a82 <_Balloc+0x4a>
42011ab2:	1a39      	s32i.n	a3, a10, 4
42011ab4:	2a79      	s32i.n	a7, a10, 8
42011ab6:	080c      	movi.n	a8, 0
42011ab8:	4289      	s32i.n	a8, a2, 16
42011aba:	3289      	s32i.n	a8, a2, 12
42011abc:	f01d      	retw.n
	...

42011ac0 <_Bfree>:
42011ac0:	004136        	entry	a1, 32
42011ac3:	9278      	l32i.n	a7, a2, 36
42011ac5:	47ec      	bnez.n	a7, 42011aed <_Bfree+0x2d>
42011ac7:	10a0a2        	movi	a10, 16
42011aca:	bb2e81        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
42011acd:	0008e0        	callx8	a8
42011ad0:	92a9      	s32i.n	a10, a2, 36
42011ad2:	facc      	bnez.n	a10, 42011ae5 <_Bfree+0x25>
42011ad4:	bcbed1        	l32r	a13, 42000dcc <_stext+0xdac> (3c02918f <Xthal_intlevel+0x63>)
42011ad7:	bcbea1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011ada:	0c0c      	movi.n	a12, 0
42011adc:	8fa0b2        	movi	a11, 143
42011adf:	b97881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011ae2:	0008e0        	callx8	a8
42011ae5:	1a79      	s32i.n	a7, a10, 4
42011ae7:	2a79      	s32i.n	a7, a10, 8
42011ae9:	0a79      	s32i.n	a7, a10, 0
42011aeb:	3a79      	s32i.n	a7, a10, 12
42011aed:	d38c      	beqz.n	a3, 42011afe <_Bfree+0x3e>
42011aef:	9298      	l32i.n	a9, a2, 36
42011af1:	1388      	l32i.n	a8, a3, 4
42011af3:	3998      	l32i.n	a9, a9, 12
42011af5:	a08890        	addx4	a8, a8, a9
42011af8:	0898      	l32i.n	a9, a8, 0
42011afa:	0399      	s32i.n	a9, a3, 0
42011afc:	0839      	s32i.n	a3, a8, 0
42011afe:	f01d      	retw.n

42011b00 <__multadd>:
42011b00:	004136        	entry	a1, 32
42011b03:	4368      	l32i.n	a6, a3, 16
42011b05:	1a0c      	movi.n	a10, 1
42011b07:	027d      	mov.n	a7, a2
42011b09:	14c3b2        	addi	a11, a3, 20
42011b0c:	032d      	mov.n	a2, a3
42011b0e:	53aa60        	max	a10, a10, a6
42011b11:	238a76        	loop	a10, 42011b38 <__multadd+0x38>
42011b14:	0b88      	l32i.n	a8, a11, 0
42011b16:	f49080        	extui	a9, a8, 0, 16
42011b19:	829940        	mull	a9, a9, a4
42011b1c:	f58080        	extui	a8, a8, 16, 16
42011b1f:	995a      	add.n	a9, a9, a5
42011b21:	828840        	mull	a8, a8, a4
42011b24:	f5c090        	extui	a12, a9, 16, 16
42011b27:	88ca      	add.n	a8, a8, a12
42011b29:	f55080        	extui	a5, a8, 16, 16
42011b2c:	f49090        	extui	a9, a9, 0, 16
42011b2f:	118800        	slli	a8, a8, 16
42011b32:	889a      	add.n	a8, a8, a9
42011b34:	0b89      	s32i.n	a8, a11, 0
42011b36:	bb4b      	addi.n	a11, a11, 4
42011b38:	049516        	beqz	a5, 42011b85 <__multadd+0x85>
42011b3b:	2288      	l32i.n	a8, a2, 8
42011b3d:	3b2687        	blt	a6, a8, 42011b7c <__multadd+0x7c>
42011b40:	12b8      	l32i.n	a11, a2, 4
42011b42:	07ad      	mov.n	a10, a7
42011b44:	bb1b      	addi.n	a11, a11, 1
42011b46:	ffef25        	call8	42011a38 <_Balloc>
42011b49:	0a4d      	mov.n	a4, a10
42011b4b:	facc      	bnez.n	a10, 42011b5e <__multadd+0x5e>
42011b4d:	bca2d1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
42011b50:	bca0a1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011b53:	0c0c      	movi.n	a12, 0
42011b55:	baa0b2        	movi	a11, 186
42011b58:	b95a81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011b5b:	0008e0        	callx8	a8
42011b5e:	42c8      	l32i.n	a12, a2, 16
42011b60:	0cc2b2        	addi	a11, a2, 12
42011b63:	02ccc2        	addi	a12, a12, 2
42011b66:	11cce0        	slli	a12, a12, 2
42011b69:	0ccaa2        	addi	a10, a10, 12
42011b6c:	b92f81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42011b6f:	0008e0        	callx8	a8
42011b72:	02bd      	mov.n	a11, a2
42011b74:	20a770        	or	a10, a7, a7
42011b77:	fff4a5        	call8	42011ac0 <_Bfree>
42011b7a:	042d      	mov.n	a2, a4
42011b7c:	a08620        	addx4	a8, a6, a2
42011b7f:	5859      	s32i.n	a5, a8, 20
42011b81:	661b      	addi.n	a6, a6, 1
42011b83:	4269      	s32i.n	a6, a2, 16
42011b85:	f01d      	retw.n
	...

42011b88 <__s2b>:
42011b88:	004136        	entry	a1, 32
42011b8b:	bc9481        	l32r	a8, 42000ddc <_stext+0xdbc> (38e38e39 <UserFrameTotalSize+0x38e38d39>)
42011b8e:	958b      	addi.n	a9, a5, 8
42011b90:	b28980        	mulsh	a8, a9, a8
42011b93:	319f90        	srai	a9, a9, 31
42011b96:	218180        	srai	a8, a8, 1
42011b99:	c08890        	sub	a8, a8, a9
42011b9c:	0b0c      	movi.n	a11, 0
42011b9e:	190c      	movi.n	a9, 1
42011ba0:	000106        	j	42011ba8 <__s2b+0x20>
42011ba3:	999a00        	lsi	f0, a10, 0x264
42011ba6:	bb1b      	addi.n	a11, a11, 1
42011ba8:	f82987        	blt	a9, a8, 42011ba4 <__s2b+0x1c>
42011bab:	02ad      	mov.n	a10, a2
42011bad:	ffe8a5        	call8	42011a38 <_Balloc>
42011bb0:	0abd      	mov.n	a11, a10
42011bb2:	facc      	bnez.n	a10, 42011bc5 <__s2b+0x3d>
42011bb4:	bc89d1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
42011bb7:	bc86a1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011bba:	0c0c      	movi.n	a12, 0
42011bbc:	d3a0b2        	movi	a11, 211
42011bbf:	b94081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011bc2:	0008e0        	callx8	a8
42011bc5:	180c      	movi.n	a8, 1
42011bc7:	4a89      	s32i.n	a8, a10, 16
42011bc9:	5a69      	s32i.n	a6, a10, 20
42011bcb:	980c      	movi.n	a8, 9
42011bcd:	23a847        	bge	a8, a4, 42011bf4 <__s2b+0x6c>
42011bd0:	09c372        	addi	a7, a3, 9
42011bd3:	076d      	mov.n	a6, a7
42011bd5:	803340        	add	a3, a3, a4
42011bd8:	0006d2        	l8ui	a13, a6, 0
42011bdb:	ac0c      	movi.n	a12, 10
42011bdd:	d0cdd2        	addi	a13, a13, -48
42011be0:	02ad      	mov.n	a10, a2
42011be2:	fff1e5        	call8	42011b00 <__multadd>
42011be5:	661b      	addi.n	a6, a6, 1
42011be7:	0abd      	mov.n	a11, a10
42011be9:	eb9637        	bne	a6, a3, 42011bd8 <__s2b+0x50>
42011bec:	774a      	add.n	a7, a7, a4
42011bee:	f8c732        	addi	a3, a7, -8
42011bf1:	0000c6        	j	42011bf8 <__s2b+0x70>
42011bf4:	33ab      	addi.n	a3, a3, 10
42011bf6:	940c      	movi.n	a4, 9
42011bf8:	047d      	mov.n	a7, a4
42011bfa:	000586        	j	42011c14 <__s2b+0x8c>
42011bfd:	c08740        	sub	a8, a7, a4
42011c00:	838a      	add.n	a8, a3, a8
42011c02:	0008d2        	l8ui	a13, a8, 0
42011c05:	ac0c      	movi.n	a12, 10
42011c07:	d0cdd2        	addi	a13, a13, -48
42011c0a:	20a220        	or	a10, a2, a2
42011c0d:	ffef25        	call8	42011b00 <__multadd>
42011c10:	0abd      	mov.n	a11, a10
42011c12:	771b      	addi.n	a7, a7, 1
42011c14:	e52757        	blt	a7, a5, 42011bfd <__s2b+0x75>
42011c17:	0b2d      	mov.n	a2, a11
42011c19:	f01d      	retw.n
	...

42011c1c <__hi0bits>:
42011c1c:	004136        	entry	a1, 32
42011c1f:	f97c      	movi.n	a9, -1
42011c21:	028d      	mov.n	a8, a2
42011c23:	f59090        	extui	a9, a9, 16, 16
42011c26:	020c      	movi.n	a2, 0
42011c28:	043987        	bltu	a9, a8, 42011c30 <__hi0bits+0x14>
42011c2b:	118800        	slli	a8, a8, 16
42011c2e:	021c      	movi.n	a2, 16
42011c30:	f97c      	movi.n	a9, -1
42011c32:	419890        	srli	a9, a9, 8
42011c35:	043987        	bltu	a9, a8, 42011c3d <__hi0bits+0x21>
42011c38:	228b      	addi.n	a2, a2, 8
42011c3a:	118880        	slli	a8, a8, 8
42011c3d:	f97c      	movi.n	a9, -1
42011c3f:	419490        	srli	a9, a9, 4
42011c42:	043987        	bltu	a9, a8, 42011c4a <__hi0bits+0x2e>
42011c45:	224b      	addi.n	a2, a2, 4
42011c47:	1188c0        	slli	a8, a8, 4
42011c4a:	f97c      	movi.n	a9, -1
42011c4c:	419290        	srli	a9, a9, 2
42011c4f:	053987        	bltu	a9, a8, 42011c58 <__hi0bits+0x3c>
42011c52:	02c222        	addi	a2, a2, 2
42011c55:	1188e0        	slli	a8, a8, 2
42011c58:	00c896        	bltz	a8, 42011c68 <__hi0bits+0x4c>
42011c5b:	058e80        	extui	a8, a8, 30, 1
42011c5e:	221b      	addi.n	a2, a2, 1
42011c60:	018820        	slli	a8, a8, 30
42011c63:	092c      	movi.n	a9, 32
42011c65:	832980        	moveqz	a2, a9, a8
42011c68:	f01d      	retw.n
	...

42011c6c <__lo0bits>:
42011c6c:	004136        	entry	a1, 32
42011c6f:	0288      	l32i.n	a8, a2, 0
42011c71:	029d      	mov.n	a9, a2
42011c73:	24a080        	extui	a10, a8, 0, 3
42011c76:	aa9c      	beqz.n	a10, 42011c94 <__lo0bits+0x28>
42011c78:	020c      	movi.n	a2, 0
42011c7a:	58e807        	bbsi	a8, 0, 42011cd6 <__lo0bits+0x6a>
42011c7d:	096817        	bbci	a8, 1, 42011c8a <__lo0bits+0x1e>
42011c80:	418180        	srli	a8, a8, 1
42011c83:	0989      	s32i.n	a8, a9, 0
42011c85:	120c      	movi.n	a2, 1
42011c87:	0012c6        	j	42011cd6 <__lo0bits+0x6a>
42011c8a:	418280        	srli	a8, a8, 2
42011c8d:	0989      	s32i.n	a8, a9, 0
42011c8f:	220c      	movi.n	a2, 2
42011c91:	001046        	j	42011cd6 <__lo0bits+0x6a>
42011c94:	f4a080        	extui	a10, a8, 0, 16
42011c97:	020c      	movi.n	a2, 0
42011c99:	3acc      	bnez.n	a10, 42011ca0 <__lo0bits+0x34>
42011c9b:	f58080        	extui	a8, a8, 16, 16
42011c9e:	021c      	movi.n	a2, 16
42011ca0:	74a080        	extui	a10, a8, 0, 8
42011ca3:	005a56        	bnez	a10, 42011cac <__lo0bits+0x40>
42011ca6:	08c222        	addi	a2, a2, 8
42011ca9:	418880        	srli	a8, a8, 8
42011cac:	34a080        	extui	a10, a8, 0, 4
42011caf:	005a56        	bnez	a10, 42011cb8 <__lo0bits+0x4c>
42011cb2:	04c222        	addi	a2, a2, 4
42011cb5:	418480        	srli	a8, a8, 4
42011cb8:	14a080        	extui	a10, a8, 0, 2
42011cbb:	005a56        	bnez	a10, 42011cc4 <__lo0bits+0x58>
42011cbe:	02c222        	addi	a2, a2, 2
42011cc1:	418280        	srli	a8, a8, 2
42011cc4:	06e807        	bbsi	a8, 0, 42011cce <__lo0bits+0x62>
42011cc7:	418180        	srli	a8, a8, 1
42011cca:	221b      	addi.n	a2, a2, 1
42011ccc:	488c      	beqz.n	a8, 42011cd4 <__lo0bits+0x68>
42011cce:	0989      	s32i.n	a8, a9, 0
42011cd0:	000086        	j	42011cd6 <__lo0bits+0x6a>
42011cd3:	022c00        	andb	b2, b12, b0
42011cd6:	f01d      	retw.n

42011cd8 <__i2b>:
42011cd8:	004136        	entry	a1, 32
42011cdb:	02ad      	mov.n	a10, a2
42011cdd:	1b0c      	movi.n	a11, 1
42011cdf:	ffd5a5        	call8	42011a38 <_Balloc>
42011ce2:	0a2d      	mov.n	a2, a10
42011ce4:	0adc      	bnez.n	a10, 42011cf8 <__i2b+0x20>
42011ce6:	bc3cd1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
42011ce9:	bc39a1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011cec:	00a0c2        	movi	a12, 0
42011cef:	45a1b2        	movi	a11, 0x145
42011cf2:	b8f381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011cf5:	0008e0        	callx8	a8
42011cf8:	180c      	movi.n	a8, 1
42011cfa:	5a39      	s32i.n	a3, a10, 20
42011cfc:	4a89      	s32i.n	a8, a10, 16
42011cfe:	f01d      	retw.n

42011d00 <__multiply>:
42011d00:	006136        	entry	a1, 48
42011d03:	4368      	l32i.n	a6, a3, 16
42011d05:	4458      	l32i.n	a5, a4, 16
42011d07:	02ad      	mov.n	a10, a2
42011d09:	0d2657        	blt	a6, a5, 42011d1a <__multiply+0x1a>
42011d0c:	058d      	mov.n	a8, a5
42011d0e:	065d      	mov.n	a5, a6
42011d10:	086d      	mov.n	a6, a8
42011d12:	048d      	mov.n	a8, a4
42011d14:	204330        	or	a4, a3, a3
42011d17:	203880        	or	a3, a8, a8
42011d1a:	2488      	l32i.n	a8, a4, 8
42011d1c:	756a      	add.n	a7, a5, a6
42011d1e:	14b8      	l32i.n	a11, a4, 4
42011d20:	01a877        	bge	a8, a7, 42011d25 <__multiply+0x25>
42011d23:	bb1b      	addi.n	a11, a11, 1
42011d25:	ffd125        	call8	42011a38 <_Balloc>
42011d28:	01a9      	s32i.n	a10, a1, 0
42011d2a:	facc      	bnez.n	a10, 42011d3d <__multiply+0x3d>
42011d2c:	bc2bd1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
42011d2f:	bc28a1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011d32:	0c0c      	movi.n	a12, 0
42011d34:	62a1b2        	movi	a11, 0x162
42011d37:	b8e281        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011d3a:	0008e0        	callx8	a8
42011d3d:	0188      	l32i.n	a8, a1, 0
42011d3f:	090c      	movi.n	a9, 0
42011d41:	14c8b2        	addi	a11, a8, 20
42011d44:	a027b0        	addx4	a2, a7, a11
42011d47:	0b8d      	mov.n	a8, a11
42011d49:	0000c6        	j	42011d50 <__multiply+0x50>
42011d4c:	0899      	s32i.n	a9, a8, 0
42011d4e:	884b      	addi.n	a8, a8, 4
42011d50:	f83827        	bltu	a8, a2, 42011d4c <__multiply+0x4c>
42011d53:	14c332        	addi	a3, a3, 20
42011d56:	a09630        	addx4	a9, a6, a3
42011d59:	14c4c2        	addi	a12, a4, 20
42011d5c:	a085c0        	addx4	a8, a5, a12
42011d5f:	3199      	s32i.n	a9, a1, 12
42011d61:	15c492        	addi	a9, a4, 21
42011d64:	629890        	lsi	f9, a8, 0x188
42011d67:	990b      	addi.n	a9, a9, -1
42011d69:	609090        	neg	a9, a9
42011d6c:	0a0c      	movi.n	a10, 0
42011d6e:	749090        	extui	a9, a9, 0, 8
42011d71:	11a9      	s32i.n	a10, a1, 4
42011d73:	0e2916        	beqz	a9, 42011e59 <__multiply+0x159>
42011d76:	15c442        	addi	a4, a4, 21
42011d79:	604040        	neg	a4, a4
42011d7c:	448a      	add.n	a4, a4, a8
42011d7e:	414240        	srli	a4, a4, 2
42011d81:	1194e0        	slli	a9, a4, 2
42011d84:	1199      	s32i.n	a9, a1, 4
42011d86:	0033c6        	j	42011e59 <__multiply+0x159>
42011d89:	035800        	lsi	f0, a8, 12
42011d8c:	f49050        	extui	a9, a5, 0, 16
42011d8f:	05a916        	beqz	a9, 42011ded <__multiply+0xed>
42011d92:	f97c      	movi.n	a9, -1
42011d94:	309c90        	xor	a9, a12, a9
42011d97:	989a      	add.n	a9, a8, a9
42011d99:	419290        	srli	a9, a9, 2
42011d9c:	ac4b      	addi.n	a10, a12, 4
42011d9e:	d83b      	addi.n	a13, a8, 3
42011da0:	0bfd      	mov.n	a15, a11
42011da2:	0c4d      	mov.n	a4, a12
42011da4:	060c      	movi.n	a6, 0
42011da6:	991b      	addi.n	a9, a9, 1
42011da8:	023da7        	bltu	a13, a10, 42011dae <__multiply+0xae>
42011dab:	001856        	bnez	a8, 42011db0 <__multiply+0xb0>
42011dae:	190c      	movi.n	a9, 1
42011db0:	f03d      	nop.n
42011db2:	318976        	loop	a9, 42011de7 <__multiply+0xe7>
42011db5:	04e8      	l32i.n	a14, a4, 0
42011db7:	0fd8      	l32i.n	a13, a15, 0
42011db9:	c1ae50        	mul16u	a10, a14, a5
42011dbc:	f4d0d0        	extui	a13, a13, 0, 16
42011dbf:	aada      	add.n	a10, a10, a13
42011dc1:	f5e0e0        	extui	a14, a14, 16, 16
42011dc4:	0fd8      	l32i.n	a13, a15, 0
42011dc6:	c1ee50        	mul16u	a14, a14, a5
42011dc9:	aa6a      	add.n	a10, a10, a6
42011dcb:	f5d0d0        	extui	a13, a13, 16, 16
42011dce:	deda      	add.n	a13, a14, a13
42011dd0:	f5e0a0        	extui	a14, a10, 16, 16
42011dd3:	ddea      	add.n	a13, a13, a14
42011dd5:	f560d0        	extui	a6, a13, 16, 16
42011dd8:	f4a0a0        	extui	a10, a10, 0, 16
42011ddb:	11dd00        	slli	a13, a13, 16
42011dde:	20dda0        	or	a13, a13, a10
42011de1:	0fd9      	s32i.n	a13, a15, 0
42011de3:	444b      	addi.n	a4, a4, 4
42011de5:	ff4b      	addi.n	a15, a15, 4
42011de7:	1198      	l32i.n	a9, a1, 4
42011de9:	9b9a      	add.n	a9, a11, a9
42011deb:	1969      	s32i.n	a6, a9, 4
42011ded:	011362        	l16ui	a6, a3, 2
42011df0:	061616        	beqz	a6, 42011e55 <__multiply+0x155>
42011df3:	f97c      	movi.n	a9, -1
42011df5:	309c90        	xor	a9, a12, a9
42011df8:	989a      	add.n	a9, a8, a9
42011dfa:	419290        	srli	a9, a9, 2
42011dfd:	991b      	addi.n	a9, a9, 1
42011dff:	0ba8      	l32i.n	a10, a11, 0
42011e01:	2199      	s32i.n	a9, a1, 8
42011e03:	5c4b      	addi.n	a5, a12, 4
42011e05:	983b      	addi.n	a9, a8, 3
42011e07:	0cfd      	mov.n	a15, a12
42011e09:	0bed      	mov.n	a14, a11
42011e0b:	0add      	mov.n	a13, a10
42011e0d:	040c      	movi.n	a4, 0
42011e0f:	013957        	bltu	a9, a5, 42011e14 <__multiply+0x114>
42011e12:	28cc      	bnez.n	a8, 42011e18 <__multiply+0x118>
42011e14:	190c      	movi.n	a9, 1
42011e16:	2199      	s32i.n	a9, a1, 8
42011e18:	0f58      	l32i.n	a5, a15, 0
42011e1a:	f5d0d0        	extui	a13, a13, 16, 16
42011e1d:	c15560        	mul16u	a5, a5, a6
42011e20:	f4a0a0        	extui	a10, a10, 0, 16
42011e23:	554a      	add.n	a5, a5, a4
42011e25:	55da      	add.n	a5, a5, a13
42011e27:	11d500        	slli	a13, a5, 16
42011e2a:	20dda0        	or	a13, a13, a10
42011e2d:	0ed9      	s32i.n	a13, a14, 0
42011e2f:	011f42        	l16ui	a4, a15, 2
42011e32:	1ed8      	l32i.n	a13, a14, 4
42011e34:	c14460        	mul16u	a4, a4, a6
42011e37:	f4a0d0        	extui	a10, a13, 0, 16
42011e3a:	a4aa      	add.n	a10, a4, a10
42011e3c:	f55050        	extui	a5, a5, 16, 16
42011e3f:	2198      	l32i.n	a9, a1, 8
42011e41:	aa5a      	add.n	a10, a10, a5
42011e43:	f540a0        	extui	a4, a10, 16, 16
42011e46:	ff4b      	addi.n	a15, a15, 4
42011e48:	ee4b      	addi.n	a14, a14, 4
42011e4a:	990b      	addi.n	a9, a9, -1
42011e4c:	fc6956        	bnez	a9, 42011e16 <__multiply+0x116>
42011e4f:	1198      	l32i.n	a9, a1, 4
42011e51:	9b9a      	add.n	a9, a11, a9
42011e53:	19a9      	s32i.n	a10, a9, 4
42011e55:	334b      	addi.n	a3, a3, 4
42011e57:	bb4b      	addi.n	a11, a11, 4
42011e59:	3198      	l32i.n	a9, a1, 12
42011e5b:	02b397        	bgeu	a3, a9, 42011e61 <__multiply+0x161>
42011e5e:	ffca06        	j	42011d8a <__multiply+0x8a>
42011e61:	000046        	j	42011e66 <__multiply+0x166>
42011e64:	770b      	addi.n	a7, a7, -1
42011e66:	0717a6        	blti	a7, 1, 42011e71 <__multiply+0x171>
42011e69:	fcc222        	addi	a2, a2, -4
42011e6c:	0288      	l32i.n	a8, a2, 0
42011e6e:	ff2816        	beqz	a8, 42011e64 <__multiply+0x164>
42011e71:	0188      	l32i.n	a8, a1, 0
42011e73:	4879      	s32i.n	a7, a8, 16
42011e75:	082d      	mov.n	a2, a8
42011e77:	f01d      	retw.n
42011e79:	000000        	ill

42011e7c <__pow5mult>:
42011e7c:	004136        	entry	a1, 32
42011e7f:	148040        	extui	a8, a4, 0, 2
42011e82:	026d      	mov.n	a6, a2
42011e84:	032d      	mov.n	a2, a3
42011e86:	689c      	beqz.n	a8, 42011ea0 <__pow5mult+0x24>
42011e88:	bbd691        	l32r	a9, 42000de0 <_stext+0xdc0> (3c0296e8 <p05$0>)
42011e8b:	880b      	addi.n	a8, a8, -1
42011e8d:	a08890        	addx4	a8, a8, a9
42011e90:	08c8      	l32i.n	a12, a8, 0
42011e92:	00a0d2        	movi	a13, 0
42011e95:	20b330        	or	a11, a3, a3
42011e98:	20a660        	or	a10, a6, a6
42011e9b:	ffc665        	call8	42011b00 <__multadd>
42011e9e:	0a2d      	mov.n	a2, a10
42011ea0:	214240        	srai	a4, a4, 2
42011ea3:	07e416        	beqz	a4, 42011f25 <__pow5mult+0xa9>
42011ea6:	9658      	l32i.n	a5, a6, 36
42011ea8:	85ec      	bnez.n	a5, 42011ed4 <__pow5mult+0x58>
42011eaa:	0a1c      	movi.n	a10, 16
42011eac:	ba3681        	l32r	a8, 42000784 <_stext+0x764> (4037fe40 <malloc>)
42011eaf:	0008e0        	callx8	a8
42011eb2:	96a9      	s32i.n	a10, a6, 36
42011eb4:	0a5d      	mov.n	a5, a10
42011eb6:	0adc      	bnez.n	a10, 42011eca <__pow5mult+0x4e>
42011eb8:	bbc5d1        	l32r	a13, 42000dcc <_stext+0xdac> (3c02918f <Xthal_intlevel+0x63>)
42011ebb:	bbc5a1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011ebe:	00a0c2        	movi	a12, 0
42011ec1:	b3a1b2        	movi	a11, 0x1b3
42011ec4:	b87f81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011ec7:	0008e0        	callx8	a8
42011eca:	080c      	movi.n	a8, 0
42011ecc:	1a89      	s32i.n	a8, a10, 4
42011ece:	2a89      	s32i.n	a8, a10, 8
42011ed0:	0a89      	s32i.n	a8, a10, 0
42011ed2:	3a89      	s32i.n	a8, a10, 12
42011ed4:	2578      	l32i.n	a7, a5, 8
42011ed6:	e7cc      	bnez.n	a7, 42011ee8 <__pow5mult+0x6c>
42011ed8:	71a2b2        	movi	a11, 0x271
42011edb:	06ad      	mov.n	a10, a6
42011edd:	ffdfa5        	call8	42011cd8 <__i2b>
42011ee0:	25a9      	s32i.n	a10, a5, 8
42011ee2:	080c      	movi.n	a8, 0
42011ee4:	0a7d      	mov.n	a7, a10
42011ee6:	0a89      	s32i.n	a8, a10, 0
42011ee8:	023d      	mov.n	a3, a2
42011eea:	050c      	movi.n	a5, 0
42011eec:	000106        	j	42011ef4 <__pow5mult+0x78>
42011eef:	0a7d00        	add.s	f7, f13, f0
42011ef2:	023d      	mov.n	a3, a2
42011ef4:	048040        	extui	a8, a4, 0, 1
42011ef7:	214140        	srai	a4, a4, 1
42011efa:	289c      	beqz.n	a8, 42011f10 <__pow5mult+0x94>
42011efc:	02bd      	mov.n	a11, a2
42011efe:	07cd      	mov.n	a12, a7
42011f00:	06ad      	mov.n	a10, a6
42011f02:	ffdfe5        	call8	42011d00 <__multiply>
42011f05:	0a2d      	mov.n	a2, a10
42011f07:	03bd      	mov.n	a11, a3
42011f09:	06ad      	mov.n	a10, a6
42011f0b:	ffbb65        	call8	42011ac0 <_Bfree>
42011f0e:	349c      	beqz.n	a4, 42011f25 <__pow5mult+0xa9>
42011f10:	07a8      	l32i.n	a10, a7, 0
42011f12:	fdaa56        	bnez	a10, 42011ef0 <__pow5mult+0x74>
42011f15:	07cd      	mov.n	a12, a7
42011f17:	07bd      	mov.n	a11, a7
42011f19:	06ad      	mov.n	a10, a6
42011f1b:	ffde65        	call8	42011d00 <__multiply>
42011f1e:	07a9      	s32i.n	a10, a7, 0
42011f20:	0a59      	s32i.n	a5, a10, 0
42011f22:	fff286        	j	42011ef0 <__pow5mult+0x74>
42011f25:	f01d      	retw.n
	...

42011f28 <__lshift>:
42011f28:	006136        	entry	a1, 48
42011f2b:	4368      	l32i.n	a6, a3, 16
42011f2d:	04dd      	mov.n	a13, a4
42011f2f:	214540        	srai	a4, a4, 5
42011f32:	646a      	add.n	a6, a4, a6
42011f34:	13b8      	l32i.n	a11, a3, 4
42011f36:	2388      	l32i.n	a8, a3, 8
42011f38:	027d      	mov.n	a7, a2
42011f3a:	561b      	addi.n	a5, a6, 1
42011f3c:	000106        	j	42011f44 <__lshift+0x1c>
42011f3f:	bb1b00        	movgez.s	f1, f11, a0
42011f42:	888a      	add.n	a8, a8, a8
42011f44:	f82857        	blt	a8, a5, 42011f40 <__lshift+0x18>
42011f47:	07ad      	mov.n	a10, a7
42011f49:	01d9      	s32i.n	a13, a1, 0
42011f4b:	ffaee5        	call8	42011a38 <_Balloc>
42011f4e:	0a2d      	mov.n	a2, a10
42011f50:	14caa2        	addi	a10, a10, 20
42011f53:	01d8      	l32i.n	a13, a1, 0
42011f55:	0a9d      	mov.n	a9, a10
42011f57:	080c      	movi.n	a8, 0
42011f59:	0b0c      	movi.n	a11, 0
42011f5b:	62dc      	bnez.n	a2, 42011f75 <__lshift+0x4d>
42011f5d:	bb9ed1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
42011f60:	bb9ca1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
42011f63:	0c0c      	movi.n	a12, 0
42011f65:	dea1b2        	movi	a11, 0x1de
42011f68:	b85681        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42011f6b:	0008e0        	callx8	a8
42011f6e:	09b9      	s32i.n	a11, a9, 0
42011f70:	881b      	addi.n	a8, a8, 1
42011f72:	04c992        	addi	a9, a9, 4
42011f75:	f52847        	blt	a8, a4, 42011f6e <__lshift+0x46>
42011f78:	080c      	movi.n	a8, 0
42011f7a:	539480        	max	a9, a4, a8
42011f7d:	43c8      	l32i.n	a12, a3, 16
42011f7f:	a099a0        	addx4	a9, a9, a10
42011f82:	14c382        	addi	a8, a3, 20
42011f85:	0199      	s32i.n	a9, a1, 0
42011f87:	4440d0        	extui	a4, a13, 0, 5
42011f8a:	a0cc80        	addx4	a12, a12, a8
42011f8d:	06b416        	beqz	a4, 42011ffc <__lshift+0xd4>
42011f90:	fb7c      	movi.n	a11, -1
42011f92:	30b8b0        	xor	a11, a8, a11
42011f95:	bcba      	add.n	a11, a12, a11
42011f97:	e0c4a2        	addi	a10, a4, -32
42011f9a:	41b2b0        	srli	a11, a11, 2
42011f9d:	18c3e2        	addi	a14, a3, 24
42011fa0:	fc3b      	addi.n	a15, a12, 3
42011fa2:	60a0a0        	neg	a10, a10
42011fa5:	0d0c      	movi.n	a13, 0
42011fa7:	bb1b      	addi.n	a11, a11, 1
42011fa9:	013fe7        	bltu	a15, a14, 42011fae <__lshift+0x86>
42011fac:	0ccc      	bnez.n	a12, 42011fb0 <__lshift+0x88>
42011fae:	1b0c      	movi.n	a11, 1
42011fb0:	f03d      	nop.n
42011fb2:	1a8b76        	loop	a11, 42011fd0 <__lshift+0xa8>
42011fb5:	08e8      	l32i.n	a14, a8, 0
42011fb7:	09fd      	mov.n	a15, a9
42011fb9:	401400        	ssl	a4
42011fbc:	a1ee00        	sll	a14, a14
42011fbf:	20eed0        	or	a14, a14, a13
42011fc2:	0fe9      	s32i.n	a14, a15, 0
42011fc4:	08d8      	l32i.n	a13, a8, 0
42011fc6:	994b      	addi.n	a9, a9, 4
42011fc8:	400a00        	ssr	a10
42011fcb:	91d0d0        	srl	a13, a13
42011fce:	884b      	addi.n	a8, a8, 4
42011fd0:	15c382        	addi	a8, a3, 21
42011fd3:	628c80        	lsi	f8, a12, 0x188
42011fd6:	880b      	addi.n	a8, a8, -1
42011fd8:	608080        	neg	a8, a8
42011fdb:	749080        	extui	a9, a8, 0, 8
42011fde:	080c      	movi.n	a8, 0
42011fe0:	c98c      	beqz.n	a9, 42011ff0 <__lshift+0xc8>
42011fe2:	15c382        	addi	a8, a3, 21
42011fe5:	608080        	neg	a8, a8
42011fe8:	88ca      	add.n	a8, a8, a12
42011fea:	418280        	srli	a8, a8, 2
42011fed:	1188e0        	slli	a8, a8, 2
42011ff0:	0198      	l32i.n	a9, a1, 0
42011ff2:	898a      	add.n	a8, a9, a8
42011ff4:	18d9      	s32i.n	a13, a8, 4
42011ff6:	adec      	bnez.n	a13, 42012024 <__lshift+0xfc>
42011ff8:	000946        	j	42012021 <__lshift+0xf9>
42011ffb:	fa7c00        	mov.s	f7, f12
42011ffe:	30a8a0        	xor	a10, a8, a10
42012001:	acaa      	add.n	a10, a12, a10
42012003:	41a2a0        	srli	a10, a10, 2
42012006:	18c3b2        	addi	a11, a3, 24
42012009:	dc3b      	addi.n	a13, a12, 3
4201200b:	aa1b      	addi.n	a10, a10, 1
4201200d:	013db7        	bltu	a13, a11, 42012012 <__lshift+0xea>
42012010:	0ccc      	bnez.n	a12, 42012014 <__lshift+0xec>
42012012:	1a0c      	movi.n	a10, 1
42012014:	f03d      	nop.n
42012016:	078a76        	loop	a10, 42012021 <__lshift+0xf9>
42012019:	08c8      	l32i.n	a12, a8, 0
4201201b:	884b      	addi.n	a8, a8, 4
4201201d:	09c9      	s32i.n	a12, a9, 0
4201201f:	994b      	addi.n	a9, a9, 4
42012021:	205660        	or	a5, a6, a6
42012024:	4259      	s32i.n	a5, a2, 16
42012026:	03bd      	mov.n	a11, a3
42012028:	07ad      	mov.n	a10, a7
4201202a:	ffa965        	call8	42011ac0 <_Bfree>
4201202d:	f01d      	retw.n
	...

42012030 <__mcmp>:
42012030:	004136        	entry	a1, 32
42012033:	43a8      	l32i.n	a10, a3, 16
42012035:	028d      	mov.n	a8, a2
42012037:	4228      	l32i.n	a2, a2, 16
42012039:	c022a0        	sub	a2, a2, a10
4201203c:	82ec      	bnez.n	a2, 42012068 <__mcmp+0x38>
4201203e:	14c892        	addi	a9, a8, 20
42012041:	14c332        	addi	a3, a3, 20
42012044:	118ae0        	slli	a8, a10, 2
42012047:	a98a      	add.n	a10, a9, a8
42012049:	808380        	add	a8, a3, a8
4201204c:	fccaa2        	addi	a10, a10, -4
4201204f:	fcc882        	addi	a8, a8, -4
42012052:	0ac8      	l32i.n	a12, a10, 0
42012054:	08b8      	l32i.n	a11, a8, 0
42012056:	0b1cb7        	beq	a12, a11, 42012065 <__mcmp+0x35>
42012059:	120c      	movi.n	a2, 1
4201205b:	09bcb7        	bgeu	a12, a11, 42012068 <__mcmp+0x38>
4201205e:	f27c      	movi.n	a2, -1
42012060:	000106        	j	42012068 <__mcmp+0x38>
42012063:	a70000        	lsi	f0, a0, 0x29c
42012066:	e339      	s32i.n	a3, a3, 56
42012068:	f01d      	retw.n
	...

4201206c <__mdiff>:
4201206c:	006136        	entry	a1, 48
4201206f:	04bd      	mov.n	a11, a4
42012071:	03ad      	mov.n	a10, a3
42012073:	fffbe5        	call8	42012030 <__mcmp>
42012076:	0a7d      	mov.n	a7, a10
42012078:	dadc      	bnez.n	a10, 42012099 <__mdiff+0x2d>
4201207a:	02ad      	mov.n	a10, a2
4201207c:	0b0c      	movi.n	a11, 0
4201207e:	ff9ba5        	call8	42011a38 <_Balloc>
42012081:	0a2d      	mov.n	a2, a10
42012083:	9acc      	bnez.n	a10, 42012090 <__mdiff+0x24>
42012085:	bb54d1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
42012088:	0c0c      	movi.n	a12, 0
4201208a:	37a2b2        	movi	a11, 0x237
4201208d:	000a06        	j	420120b9 <__mdiff+0x4d>
42012090:	180c      	movi.n	a8, 1
42012092:	4a89      	s32i.n	a8, a10, 16
42012094:	5a79      	s32i.n	a7, a10, 20
42012096:	0046c6        	j	420121b5 <__mdiff+0x149>
42012099:	060c      	movi.n	a6, 0
4201209b:	007ad6        	bgez	a10, 420120a6 <__mdiff+0x3a>
4201209e:	038d      	mov.n	a8, a3
420120a0:	160c      	movi.n	a6, 1
420120a2:	043d      	mov.n	a3, a4
420120a4:	084d      	mov.n	a4, a8
420120a6:	13b8      	l32i.n	a11, a3, 4
420120a8:	02ad      	mov.n	a10, a2
420120aa:	ff98e5        	call8	42011a38 <_Balloc>
420120ad:	0a2d      	mov.n	a2, a10
420120af:	facc      	bnez.n	a10, 420120c2 <__mdiff+0x56>
420120b1:	bb49d1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
420120b4:	0c0c      	movi.n	a12, 0
420120b6:	45a2b2        	movi	a11, 0x245
420120b9:	bb45a1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
420120bc:	b80181        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420120bf:	0008e0        	callx8	a8
420120c2:	3a69      	s32i.n	a6, a10, 12
420120c4:	44a8      	l32i.n	a10, a4, 16
420120c6:	14c482        	addi	a8, a4, 20
420120c9:	a0aa80        	addx4	a10, a10, a8
420120cc:	ebca92        	addi	a9, a10, -21
420120cf:	43f8      	l32i.n	a15, a3, 16
420120d1:	c09940        	sub	a9, a9, a4
420120d4:	14c3d2        	addi	a13, a3, 20
420120d7:	419290        	srli	a9, a9, 2
420120da:	18c482        	addi	a8, a4, 24
420120dd:	ba3b      	addi.n	a11, a10, 3
420120df:	a0cfd0        	addx4	a12, a15, a13
420120e2:	14c252        	addi	a5, a2, 20
420120e5:	4e1c      	movi.n	a14, 20
420120e7:	070c      	movi.n	a7, 0
420120e9:	01c992        	addi	a9, a9, 1
420120ec:	023b87        	bltu	a11, a8, 420120f2 <__mdiff+0x86>
420120ef:	001a56        	bnez	a10, 420120f4 <__mdiff+0x88>
420120f2:	190c      	movi.n	a9, 1
420120f4:	f03d      	nop.n
420120f6:	368976        	loop	a9, 42012130 <__mdiff+0xc4>
420120f9:	b4ea      	add.n	a11, a4, a14
420120fb:	83ea      	add.n	a8, a3, a14
420120fd:	0888      	l32i.n	a8, a8, 0
420120ff:	0b68      	l32i.n	a6, a11, 0
42012101:	0189      	s32i.n	a8, a1, 0
42012103:	f4b060        	extui	a11, a6, 0, 16
42012106:	f48080        	extui	a8, a8, 0, 16
42012109:	c0b8b0        	sub	a11, a8, a11
4201210c:	0188      	l32i.n	a8, a1, 0
4201210e:	bb7a      	add.n	a11, a11, a7
42012110:	f56060        	extui	a6, a6, 16, 16
42012113:	f58080        	extui	a8, a8, 16, 16
42012116:	3170b0        	srai	a7, a11, 16
42012119:	c08860        	sub	a8, a8, a6
4201211c:	887a      	add.n	a8, a8, a7
4201211e:	317080        	srai	a7, a8, 16
42012121:	f4b0b0        	extui	a11, a11, 0, 16
42012124:	118800        	slli	a8, a8, 16
42012127:	62ea      	add.n	a6, a2, a14
42012129:	20bb80        	or	a11, a11, a8
4201212c:	06b9      	s32i.n	a11, a6, 0
4201212e:	ee4b      	addi.n	a14, a14, 4
42012130:	15c482        	addi	a8, a4, 21
42012133:	628a80        	lsi	f8, a10, 0x188
42012136:	880b      	addi.n	a8, a8, -1
42012138:	608080        	neg	a8, a8
4201213b:	749080        	extui	a9, a8, 0, 8
4201213e:	080c      	movi.n	a8, 0
42012140:	c98c      	beqz.n	a9, 42012150 <__mdiff+0xe4>
42012142:	15c442        	addi	a4, a4, 21
42012145:	604040        	neg	a4, a4
42012148:	44aa      	add.n	a4, a4, a10
4201214a:	414240        	srli	a4, a4, 2
4201214d:	1184e0        	slli	a8, a4, 2
42012150:	958a      	add.n	a9, a5, a8
42012152:	8d8a      	add.n	a8, a13, a8
42012154:	b84b      	addi.n	a11, a8, 4
42012156:	994b      	addi.n	a9, a9, 4
42012158:	0b6d      	mov.n	a6, a11
4201215a:	c0d5d0        	sub	a13, a5, a13
4201215d:	000886        	j	42012183 <__mdiff+0x117>
42012160:	06a8      	l32i.n	a10, a6, 0
42012162:	074d      	mov.n	a4, a7
42012164:	f4e0a0        	extui	a14, a10, 0, 16
42012167:	ee7a      	add.n	a14, a14, a7
42012169:	31e0e0        	srai	a14, a14, 16
4201216c:	f570a0        	extui	a7, a10, 16, 16
4201216f:	ee7a      	add.n	a14, a14, a7
42012171:	aa4a      	add.n	a10, a10, a4
42012173:	3170e0        	srai	a7, a14, 16
42012176:	f4a0a0        	extui	a10, a10, 0, 16
42012179:	11ee00        	slli	a14, a14, 16
4201217c:	20aae0        	or	a10, a10, a14
4201217f:	664b      	addi.n	a6, a6, 4
42012181:	05a9      	s32i.n	a10, a5, 0
42012183:	56da      	add.n	a5, a6, a13
42012185:	d736c7        	bltu	a6, a12, 42012160 <__mdiff+0xf4>
42012188:	881b      	addi.n	a8, a8, 1
4201218a:	628c80        	lsi	f8, a12, 0x188
4201218d:	880b      	addi.n	a8, a8, -1
4201218f:	608080        	neg	a8, a8
42012192:	748080        	extui	a8, a8, 0, 8
42012195:	0a0c      	movi.n	a10, 0
42012197:	988c      	beqz.n	a8, 420121a4 <__mdiff+0x138>
42012199:	cc3b      	addi.n	a12, a12, 3
4201219b:	c0ccb0        	sub	a12, a12, a11
4201219e:	41c2c0        	srli	a12, a12, 2
420121a1:	11ace0        	slli	a10, a12, 2
420121a4:	8a9a      	add.n	a8, a10, a9
420121a6:	000046        	j	420121ab <__mdiff+0x13f>
420121a9:	ff0b      	addi.n	a15, a15, -1
420121ab:	fcc882        	addi	a8, a8, -4
420121ae:	0898      	l32i.n	a9, a8, 0
420121b0:	ff5916        	beqz	a9, 420121a9 <__mdiff+0x13d>
420121b3:	42f9      	s32i.n	a15, a2, 16
420121b5:	f01d      	retw.n
	...

420121b8 <__ulp>:
420121b8:	004136        	entry	a1, 32
420121bb:	a58430        	extui	a8, a3, 20, 11
420121be:	397c      	movi.n	a9, -13
420121c0:	0188c0        	slli	a8, a8, 20
420121c3:	0199a0        	slli	a9, a9, 22
420121c6:	889a      	add.n	a8, a8, a9
420121c8:	0a0c      	movi.n	a10, 0
420121ca:	3018e6        	bgei	a8, 1, 420121fe <__ulp+0x46>
420121cd:	608080        	neg	a8, a8
420121d0:	319480        	srai	a9, a8, 20
420121d3:	381c      	movi.n	a8, 19
420121d5:	0d2897        	blt	a8, a9, 420121e6 <__ulp+0x2e>
420121d8:	180c      	movi.n	a8, 1
420121da:	0188d0        	slli	a8, a8, 19
420121dd:	400900        	ssr	a9
420121e0:	b18080        	sra	a8, a8
420121e3:	0005c6        	j	420121fe <__ulp+0x46>
420121e6:	ecc992        	addi	a9, a9, -20
420121e9:	e81c      	movi.n	a8, 30
420121eb:	01a0a2        	movi	a10, 1
420121ee:	0a2897        	blt	a8, a9, 420121fc <__ulp+0x44>
420121f1:	fa7c      	movi.n	a10, -1
420121f3:	01aa10        	slli	a10, a10, 31
420121f6:	400900        	ssr	a9
420121f9:	91a0a0        	srl	a10, a10
420121fc:	080c      	movi.n	a8, 0
420121fe:	083d      	mov.n	a3, a8
42012200:	0a2d      	mov.n	a2, a10
42012202:	f01d      	retw.n

42012204 <__b2d>:
42012204:	004136        	entry	a1, 32
42012207:	4258      	l32i.n	a5, a2, 16
42012209:	14c242        	addi	a4, a2, 20
4201220c:	a05540        	addx4	a5, a5, a4
4201220f:	fcc572        	addi	a7, a5, -4
42012212:	0768      	l32i.n	a6, a7, 0
42012214:	06ad      	mov.n	a10, a6
42012216:	ffa065        	call8	42011c1c <__hi0bits>
42012219:	e0ca82        	addi	a8, a10, -32
4201221c:	608080        	neg	a8, a8
4201221f:	0389      	s32i.n	a8, a3, 0
42012221:	ffa392        	movi	a9, 0x3ff
42012224:	a80c      	movi.n	a8, 10
42012226:	0199c0        	slli	a9, a9, 20
42012229:	2528a7        	blt	a8, a10, 42012252 <__b2d+0x4e>
4201222c:	f5cab2        	addi	a11, a10, -11
4201222f:	60b0b0        	neg	a11, a11
42012232:	400b00        	ssr	a11
42012235:	918060        	srl	a8, a6
42012238:	203890        	or	a3, a8, a9
4201223b:	090c      	movi.n	a9, 0
4201223d:	04b477        	bgeu	a4, a7, 42012245 <__b2d+0x41>
42012240:	f8c552        	addi	a5, a5, -8
42012243:	0598      	l32i.n	a9, a5, 0
42012245:	15ca82        	addi	a8, a10, 21
42012248:	401800        	ssl	a8
4201224b:	a18600        	sll	a8, a6
4201224e:	000c46        	j	42012283 <__b2d+0x7f>
42012251:	080c00        	lsx	f0, a12, a0
42012254:	04b477        	bgeu	a4, a7, 4201225c <__b2d+0x58>
42012257:	f8c572        	addi	a7, a5, -8
4201225a:	0788      	l32i.n	a8, a7, 0
4201225c:	f5caa2        	addi	a10, a10, -11
4201225f:	203690        	or	a3, a6, a9
42012262:	6aac      	beqz.n	a10, 4201228c <__b2d+0x88>
42012264:	e0cab2        	addi	a11, a10, -32
42012267:	401a00        	ssl	a10
4201226a:	816680        	src	a6, a6, a8
4201226d:	203690        	or	a3, a6, a9
42012270:	60b0b0        	neg	a11, a11
42012273:	090c      	movi.n	a9, 0
42012275:	04b477        	bgeu	a4, a7, 4201227d <__b2d+0x79>
42012278:	fcc772        	addi	a7, a7, -4
4201227b:	0798      	l32i.n	a9, a7, 0
4201227d:	401a00        	ssl	a10
42012280:	a18800        	sll	a8, a8
42012283:	400b00        	ssr	a11
42012286:	919090        	srl	a9, a9
42012289:	208890        	or	a8, a8, a9
4201228c:	082d      	mov.n	a2, a8
4201228e:	f01d      	retw.n

42012290 <__d2b>:
42012290:	006136        	entry	a1, 48
42012293:	02ad      	mov.n	a10, a2
42012295:	1b0c      	movi.n	a11, 1
42012297:	ff7a25        	call8	42011a38 <_Balloc>
4201229a:	0a2d      	mov.n	a2, a10
4201229c:	011a56        	bnez	a10, 420122b1 <__d2b+0x21>
4201229f:	baced1        	l32r	a13, 42000dd8 <_stext+0xdb8> (3c0291fa <Xthal_intlevel+0xce>)
420122a2:	bacba1        	l32r	a10, 42000dd0 <_stext+0xdb0> (3c02920b <Xthal_intlevel+0xdf>)
420122a5:	00a0c2        	movi	a12, 0
420122a8:	0fa3b2        	movi	a11, 0x30f
420122ab:	b78581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420122ae:	0008e0        	callx8	a8
420122b1:	118540        	slli	a8, a5, 12
420122b4:	a53450        	extui	a3, a5, 20, 11
420122b7:	418c80        	srli	a8, a8, 12
420122ba:	738c      	beqz.n	a3, 420122c5 <__d2b+0x35>
420122bc:	01a092        	movi	a9, 1
420122bf:	0199c0        	slli	a9, a9, 20
420122c2:	208890        	or	a8, a8, a9
420122c5:	0189      	s32i.n	a8, a1, 0
420122c7:	74bc      	beqz.n	a4, 42012302 <__d2b+0x72>
420122c9:	a14b      	addi.n	a10, a1, 4
420122cb:	1149      	s32i.n	a4, a1, 4
420122cd:	ff99e5        	call8	42011c6c <__lo0bits>
420122d0:	11b8      	l32i.n	a11, a1, 4
420122d2:	ca9c      	beqz.n	a10, 420122f2 <__d2b+0x62>
420122d4:	0198      	l32i.n	a9, a1, 0
420122d6:	e0ca82        	addi	a8, a10, -32
420122d9:	608080        	neg	a8, a8
420122dc:	401800        	ssl	a8
420122df:	a18900        	sll	a8, a9
420122e2:	2088b0        	or	a8, a8, a11
420122e5:	400a00        	ssr	a10
420122e8:	919090        	srl	a9, a9
420122eb:	5289      	s32i.n	a8, a2, 20
420122ed:	0199      	s32i.n	a9, a1, 0
420122ef:	000046        	j	420122f4 <__d2b+0x64>
420122f2:	52b9      	s32i.n	a11, a2, 20
420122f4:	0188      	l32i.n	a8, a1, 0
420122f6:	150c      	movi.n	a5, 1
420122f8:	290c      	movi.n	a9, 2
420122fa:	6289      	s32i.n	a8, a2, 24
420122fc:	935980        	movnez	a5, a9, a8
420122ff:	000346        	j	42012310 <__d2b+0x80>
42012302:	01ad      	mov.n	a10, a1
42012304:	ff9665        	call8	42011c6c <__lo0bits>
42012307:	0188      	l32i.n	a8, a1, 0
42012309:	20caa2        	addi	a10, a10, 32
4201230c:	5289      	s32i.n	a8, a2, 20
4201230e:	150c      	movi.n	a5, 1
42012310:	4259      	s32i.n	a5, a2, 16
42012312:	239c      	beqz.n	a3, 42012328 <__d2b+0x98>
42012314:	cdab82        	movi	a8, 0xfffffbcd
42012317:	338a      	add.n	a3, a3, a8
42012319:	33aa      	add.n	a3, a3, a10
4201231b:	cbca52        	addi	a5, a10, -53
4201231e:	0639      	s32i.n	a3, a6, 0
42012320:	605050        	neg	a5, a5
42012323:	000706        	j	42012343 <__d2b+0xb3>
42012326:	820000        	mull	a0, a0, a0
42012329:	ceab      	addi.n	a12, a14, 10
4201232b:	8a8a      	add.n	a8, a10, a8
4201232d:	0689      	s32i.n	a8, a6, 0
4201232f:	c87c      	movi.n	a8, -4
42012331:	a08580        	addx4	a8, a5, a8
42012334:	808280        	add	a8, a2, a8
42012337:	0528a2        	l32i	a10, a8, 20
4201233a:	1155b0        	slli	a5, a5, 5
4201233d:	ff8de5        	call8	42011c1c <__hi0bits>
42012340:	c055a0        	sub	a5, a5, a10
42012343:	0759      	s32i.n	a5, a7, 0
42012345:	f01d      	retw.n
	...

42012348 <__ratio>:
42012348:	006136        	entry	a1, 48
4201234b:	b14b      	addi.n	a11, a1, 4
4201234d:	02ad      	mov.n	a10, a2
4201234f:	ffeb65        	call8	42012204 <__b2d>
42012352:	0a4d      	mov.n	a4, a10
42012354:	0b5d      	mov.n	a5, a11
42012356:	0a6d      	mov.n	a6, a10
42012358:	0b7d      	mov.n	a7, a11
4201235a:	03ad      	mov.n	a10, a3
4201235c:	01bd      	mov.n	a11, a1
4201235e:	ffea65        	call8	42012204 <__b2d>
42012361:	0acd      	mov.n	a12, a10
42012363:	0b9d      	mov.n	a9, a11
42012365:	42a8      	l32i.n	a10, a2, 16
42012367:	0bdd      	mov.n	a13, a11
42012369:	43b8      	l32i.n	a11, a3, 16
4201236b:	01e8      	l32i.n	a14, a1, 0
4201236d:	c0aab0        	sub	a10, a10, a11
42012370:	11b8      	l32i.n	a11, a1, 4
42012372:	11aab0        	slli	a10, a10, 5
42012375:	c0bbe0        	sub	a11, a11, a14
42012378:	aaba      	add.n	a10, a10, a11
4201237a:	071aa6        	blti	a10, 1, 42012385 <__ratio+0x3d>
4201237d:	01aac0        	slli	a10, a10, 20
42012380:	7a5a      	add.n	a7, a10, a5
42012382:	000146        	j	4201238b <__ratio+0x43>
42012385:	01aac0        	slli	a10, a10, 20
42012388:	c0d9a0        	sub	a13, a9, a10
4201238b:	06ad      	mov.n	a10, a6
4201238d:	07bd      	mov.n	a11, a7
4201238f:	ba8e81        	l32r	a8, 42000dc8 <_stext+0xda8> (40002250 <__divdf3>)
42012392:	0008e0        	callx8	a8
42012395:	0a2d      	mov.n	a2, a10
42012397:	0b3d      	mov.n	a3, a11
42012399:	f01d      	retw.n
	...

4201239c <_mprec_log10>:
4201239c:	004136        	entry	a1, 32
4201239f:	ffa3b2        	movi	a11, 0x3ff
420123a2:	781c      	movi.n	a8, 23
420123a4:	0a0c      	movi.n	a10, 0
420123a6:	01bbc0        	slli	a11, a11, 20
420123a9:	0c2827        	blt	a8, a2, 420123b9 <_mprec_log10+0x1d>
420123ac:	ba7981        	l32r	a8, 42000d90 <_stext+0xd70> (3c029748 <__mprec_tens>)
420123af:	b07280        	addx8	a7, a2, a8
420123b2:	07a8      	l32i.n	a10, a7, 0
420123b4:	17b8      	l32i.n	a11, a7, 4
420123b6:	000446        	j	420123cb <_mprec_log10+0x2f>
420123b9:	ba78d1        	l32r	a13, 42000d9c <_stext+0xd7c> (40240000 <rom_rx_gain_force+0x239bd4>)
420123bc:	00a0c2        	movi	a12, 0
420123bf:	ffc222        	addi	a2, a2, -1
420123c2:	ba5681        	l32r	a8, 42000d1c <_stext+0xcfc> (40002418 <__muldf3>)
420123c5:	0008e0        	callx8	a8
420123c8:	fed256        	bnez	a2, 420123b9 <_mprec_log10+0x1d>
420123cb:	0a2d      	mov.n	a2, a10
420123cd:	0b3d      	mov.n	a3, a11
420123cf:	f01d      	retw.n
420123d1:	000000        	ill

420123d4 <__copybits>:
420123d4:	004136        	entry	a1, 32
420123d7:	330b      	addi.n	a3, a3, -1
420123d9:	4498      	l32i.n	a9, a4, 16
420123db:	213530        	srai	a3, a3, 5
420123de:	331b      	addi.n	a3, a3, 1
420123e0:	14c482        	addi	a8, a4, 20
420123e3:	a03320        	addx4	a3, a3, a2
420123e6:	a09980        	addx4	a9, a9, a8
420123e9:	02ad      	mov.n	a10, a2
420123eb:	0001c6        	j	420123f6 <__copybits+0x22>
420123ee:	08b8      	l32i.n	a11, a8, 0
420123f0:	884b      	addi.n	a8, a8, 4
420123f2:	0ab9      	s32i.n	a11, a10, 0
420123f4:	aa4b      	addi.n	a10, a10, 4
420123f6:	f43897        	bltu	a8, a9, 420123ee <__copybits+0x1a>
420123f9:	11c482        	addi	a8, a4, 17
420123fc:	628980        	lsi	f8, a9, 0x188
420123ff:	880b      	addi.n	a8, a8, -1
42012401:	608080        	neg	a8, a8
42012404:	748080        	extui	a8, a8, 0, 8
42012407:	0a0c      	movi.n	a10, 0
42012409:	c88c      	beqz.n	a8, 42012419 <__copybits+0x45>
4201240b:	11c442        	addi	a4, a4, 17
4201240e:	604040        	neg	a4, a4
42012411:	449a      	add.n	a4, a4, a9
42012413:	414240        	srli	a4, a4, 2
42012416:	11a4e0        	slli	a10, a4, 2
42012419:	22aa      	add.n	a2, a2, a10
4201241b:	080c      	movi.n	a8, 0
4201241d:	0000c6        	j	42012424 <__copybits+0x50>
42012420:	0289      	s32i.n	a8, a2, 0
42012422:	224b      	addi.n	a2, a2, 4
42012424:	f83237        	bltu	a2, a3, 42012420 <__copybits+0x4c>
42012427:	f01d      	retw.n
42012429:	000000        	ill

4201242c <__any_on>:
4201242c:	004136        	entry	a1, 32
4201242f:	42a8      	l32i.n	a10, a2, 16
42012431:	218530        	srai	a8, a3, 5
42012434:	14c292        	addi	a9, a2, 20
42012437:	232a87        	blt	a10, a8, 4201245e <__any_on+0x32>
4201243a:	22a8a7        	bge	a8, a10, 42012460 <__any_on+0x34>
4201243d:	443030        	extui	a3, a3, 0, 5
42012440:	c39c      	beqz.n	a3, 42012460 <__any_on+0x34>
42012442:	a0a890        	addx4	a10, a8, a9
42012445:	0ab8      	l32i.n	a11, a10, 0
42012447:	120c      	movi.n	a2, 1
42012449:	400300        	ssr	a3
4201244c:	91a0b0        	srl	a10, a11
4201244f:	401300        	ssl	a3
42012452:	a1aa00        	sll	a10, a10
42012455:	219ba7        	bne	a11, a10, 4201247a <__any_on+0x4e>
42012458:	000106        	j	42012460 <__any_on+0x34>
4201245b:	000000        	ill
4201245e:	0a8d      	mov.n	a8, a10
42012460:	a08890        	addx4	a8, a8, a9
42012463:	000206        	j	4201246f <__any_on+0x43>
42012466:	820000        	mull	a0, a0, a0
42012469:	fcc8      	l32i.n	a12, a12, 60
4201246b:	08a8      	l32i.n	a10, a8, 0
4201246d:	7acc      	bnez.n	a10, 42012478 <__any_on+0x4c>
4201246f:	f53987        	bltu	a9, a8, 42012468 <__any_on+0x3c>
42012472:	020c      	movi.n	a2, 0
42012474:	000086        	j	4201247a <__any_on+0x4e>
42012477:	120c00        	andbc	b0, b12, b0
4201247a:	f01d      	retw.n

4201247c <get_arg$isra$0>:
4201247c:	008136        	entry	a1, 64
4201247f:	102182        	l32i	a8, a1, 64
42012482:	1179      	s32i.n	a7, a1, 4
42012484:	0878      	l32i.n	a7, a8, 0
42012486:	2129      	s32i.n	a2, a1, 8
42012488:	21e8      	l32i.n	a14, a1, 8
4201248a:	0528      	l32i.n	a2, a5, 0
4201248c:	4159      	s32i.n	a5, a1, 16
4201248e:	0169      	s32i.n	a6, a1, 0
42012490:	837370        	moveqz	a7, a3, a7
42012493:	00e306        	j	42012823 <get_arg$isra$0+0x3a7>
42012496:	771b      	addi.n	a7, a7, 1
42012498:	000782        	l8ui	a8, a7, 0
4201249b:	42f816        	beqz	a8, 420128ce <get_arg$isra$0+0x452>
4201249e:	dbc8a2        	addi	a10, a8, -37
420124a1:	ff1a56        	bnez	a10, 42012496 <get_arg$isra$0+0x1a>
420124a4:	426816        	beqz	a8, 420128ce <get_arg$isra$0+0x452>
420124a7:	080c      	movi.n	a8, 0
420124a9:	a71b      	addi.n	a10, a7, 1
420124ab:	050c      	movi.n	a5, 0
420124ad:	0d0c      	movi.n	a13, 0
420124af:	f37c      	movi.n	a3, -1
420124b1:	060c      	movi.n	a6, 0
420124b3:	3189      	s32i.n	a8, a1, 12
420124b5:	000046        	j	420124ba <get_arg$isra$0+0x3e>
420124b8:	07ad      	mov.n	a10, a7
420124ba:	ba0191        	l32r	a9, 42000cc0 <_stext+0xca0> (3c029b24 <__chclass>)
420124bd:	000a82        	l8ui	a8, a10, 0
420124c0:	7a1b      	addi.n	a7, a10, 1
420124c2:	b98a      	add.n	a11, a9, a8
420124c4:	3198      	l32i.n	a9, a1, 12
420124c6:	000bc2        	l8ui	a12, a11, 0
420124c9:	b9feb1        	l32r	a11, 42000cc4 <_stext+0xca4> (3c029ab8 <__state_table>)
420124cc:	b0f990        	addx8	a15, a9, a9
420124cf:	bbfa      	add.n	a11, a11, a15
420124d1:	bbca      	add.n	a11, a11, a12
420124d3:	000b92        	l8ui	a9, a11, 0
420124d6:	b9fcb1        	l32r	a11, 42000cc8 <_stext+0xca8> (3c029a4c <__action_table>)
420124d9:	3199      	s32i.n	a9, a1, 12
420124db:	bbfa      	add.n	a11, a11, a15
420124dd:	bbca      	add.n	a11, a11, a12
420124df:	000bb2        	l8ui	a11, a11, 0
420124e2:	bb0b      	addi.n	a11, a11, -1
420124e4:	74b0b0        	extui	a11, a11, 0, 8
420124e7:	028bb6        	bltui	a11, 8, 420124ed <get_arg$isra$0+0x71>
420124ea:	00cac6        	j	42012819 <get_arg$isra$0+0x39d>
420124ed:	ba3dc1        	l32r	a12, 42000de4 <_stext+0xdc4> (3c029810 <__mprec_tens+0xc8>)
420124f0:	a0bbc0        	addx4	a11, a11, a12
420124f3:	0bb8      	l32i.n	a11, a11, 0
420124f5:	000ba0        	jx	a11
420124f8:	0c0000        	lsi	f0, a0, 48
420124fb:	069a      	add.n	a0, a6, a9
420124fd:	ad00c2        	l8ui	a12, a0, 173
42012500:	ac4607        	ball	a6, a0, 420124b0 <get_arg$isra$0+0x34>
42012503:	a0b200        	addx4	a11, a2, a0
42012506:	b76a      	add.n	a11, a7, a6
42012508:	3318      	l32i.n	a1, a3, 12
4201250a:	0a3b87        	bltu	a11, a8, 42012518 <get_arg$isra$0+0x9c>
4201250d:	cb4c      	movi.n	a11, 76
4201250f:	2618b7        	beq	a8, a11, 42012539 <get_arg$isra$0+0xbd>
42012512:	68a0b2        	movi	a11, 104
42012515:	0005c6        	j	42012530 <get_arg$isra$0+0xb4>
42012518:	71a0b2        	movi	a11, 113
4201251b:	1f18b7        	beq	a8, a11, 4201253e <get_arg$isra$0+0xc2>
4201251e:	70a0b2        	movi	a11, 112
42012521:	23bb87        	bgeu	a11, a8, 42012548 <get_arg$isra$0+0xcc>
42012524:	74a0b2        	movi	a11, 116
42012527:	0298b7        	bne	a8, a11, 4201252d <get_arg$isra$0+0xb1>
4201252a:	00bac6        	j	42012819 <get_arg$isra$0+0x39d>
4201252d:	7aa0b2        	movi	a11, 122
42012530:	0298b7        	bne	a8, a11, 42012536 <get_arg$isra$0+0xba>
42012533:	00b886        	j	42012819 <get_arg$isra$0+0x39d>
42012536:	000386        	j	42012548 <get_arg$isra$0+0xcc>
42012539:	880c      	movi.n	a8, 8
4201253b:	000046        	j	42012540 <get_arg$isra$0+0xc4>
4201253e:	082c      	movi.n	a8, 32
42012540:	206680        	or	a6, a6, a8
42012543:	00b486        	j	42012819 <get_arg$isra$0+0x39d>
42012546:	b20000        	mulsh	a0, a0, a0
42012549:	010a      	add.n	a0, a1, a0
4201254b:	6ca082        	movi	a8, 108
4201254e:	0a9b87        	bne	a11, a8, 4201255c <get_arg$isra$0+0xe0>
42012551:	082c      	movi.n	a8, 32
42012553:	206680        	or	a6, a6, a8
42012556:	7a2b      	addi.n	a7, a10, 2
42012558:	00af46        	j	42012819 <get_arg$isra$0+0x39d>
4201255b:	081c00        	lsx	f1, a12, a0
4201255e:	fff786        	j	42012540 <get_arg$isra$0+0xc4>
42012561:	61a0b2        	movi	a11, 97
42012564:	44a020        	extui	a10, a2, 0, 5
42012567:	0298b7        	bne	a8, a11, 4201256d <get_arg$isra$0+0xf1>
4201256a:	00e506        	j	42012902 <get_arg$isra$0+0x486>
4201256d:	3b3b87        	bltu	a11, a8, 420125ac <get_arg$isra$0+0x130>
42012570:	bfc882        	addi	a8, a8, -65
42012573:	748080        	extui	a8, a8, 0, 8
42012576:	7b1c      	movi.n	a11, 23
42012578:	24bb87        	bgeu	a11, a8, 420125a0 <get_arg$isra$0+0x124>
4201257b:	001686        	j	420125d9 <get_arg$isra$0+0x15d>
4201257e:	180c      	movi.n	a8, 1
42012580:	401b00        	ssl	a11
42012583:	a18800        	sll	a8, a8
42012586:	b9d2b1        	l32r	a11, 42000cd0 <_stext+0xcb0> (120821 <UserFrameTotalSize+0x120721>)
42012589:	3388b7        	bany	a8, a11, 420125c0 <get_arg$isra$0+0x144>
4201258c:	5b2c      	movi.n	a11, 37
4201258e:	11bb60        	slli	a11, a11, 10
42012591:	0208b7        	bnone	a8, a11, 42012597 <get_arg$isra$0+0x11b>
42012594:	00dd46        	j	4201290d <get_arg$isra$0+0x491>
42012597:	248180        	extui	a8, a8, 1, 3
4201259a:	364856        	bnez	a8, 42012902 <get_arg$isra$0+0x486>
4201259d:	000e06        	j	420125d9 <get_arg$isra$0+0x15d>
420125a0:	ba12b1        	l32r	a11, 42000de8 <_stext+0xdc8> (3c029830 <__mprec_tens+0xe8>)
420125a3:	a088b0        	addx4	a8, a8, a11
420125a6:	0888      	l32i.n	a8, a8, 0
420125a8:	0008a0        	jx	a8
420125ab:	a0b200        	addx4	a11, a2, a0
420125ae:	18b763        	lsi	f6, a7, 96
420125b1:	8219      	s32i.n	a1, a2, 32
420125b3:	9cc8      	l32i.n	a12, a12, 36
420125b5:	74b080        	extui	a11, a8, 0, 8
420125b8:	481c      	movi.n	a8, 20
420125ba:	c0b8b7        	bgeu	a8, a11, 4201257e <get_arg$isra$0+0x102>
420125bd:	000606        	j	420125d9 <get_arg$isra$0+0x15d>
420125c0:	045560        	extui	a5, a6, 5, 1
420125c3:	555a      	add.n	a5, a5, a5
420125c5:	106647        	bbci	a6, 4, 420125d9 <get_arg$isra$0+0x15d>
420125c8:	00d806        	j	4201292c <get_arg$isra$0+0x4b0>
420125cb:	051c00        	extui	a1, a0, 28, 1
420125ce:	105650        	and	a5, a6, a5
420125d1:	34c556        	bnez	a5, 42012921 <get_arg$isra$0+0x4a5>
420125d4:	00d006        	j	42012918 <get_arg$isra$0+0x49c>
420125d7:	260000        	lsi	f0, a0, 152
420125da:	880b03        	lsi	f0, a11, 0x220
420125dd:	0a2d11        	l32r	a1, 41fd4e94 <_coredump_iram_end+0x1c52f94>
420125e0:	a08380        	addx4	a8, a3, a8
420125e3:	0859      	s32i.n	a5, a8, 0
420125e5:	008c06        	j	42012819 <get_arg$isra$0+0x39d>
420125e8:	b50b      	addi.n	a11, a5, -1
420125ea:	2488      	l32i.n	a8, a4, 8
420125ec:	2a1b      	addi.n	a2, a10, 1
420125ee:	026bb6        	bltui	a11, 6, 420125f4 <get_arg$isra$0+0x178>
420125f1:	002806        	j	42012695 <get_arg$isra$0+0x219>
420125f4:	b9fec1        	l32r	a12, 42000dec <_stext+0xdcc> (3c029890 <__mprec_tens+0x148>)
420125f7:	a0bbc0        	addx4	a11, a11, a12
420125fa:	0bc8      	l32i.n	a12, a11, 0
420125fc:	f4b0a0        	extui	a11, a10, 0, 16
420125ff:	000ca0        	jx	a12
42012602:	0188      	l32i.n	a8, a1, 0
42012604:	24b8      	l32i.n	a11, a4, 8
42012606:	2a1b      	addi.n	a2, a10, 1
42012608:	b0aa80        	addx8	a10, a10, a8
4201260b:	8b4b      	addi.n	a8, a11, 4
4201260d:	2489      	s32i.n	a8, a4, 8
4201260f:	8c1c      	movi.n	a12, 24
42012611:	042c87        	blt	a12, a8, 42012619 <get_arg$isra$0+0x19d>
42012614:	14b8      	l32i.n	a11, a4, 4
42012616:	000206        	j	42012622 <get_arg$isra$0+0x1a6>
42012619:	012cb7        	blt	a12, a11, 4201261e <get_arg$isra$0+0x1a2>
4201261c:	482c      	movi.n	a8, 36
4201261e:	04b8      	l32i.n	a11, a4, 0
42012620:	2489      	s32i.n	a8, a4, 8
42012622:	bb8a      	add.n	a11, a11, a8
42012624:	fccbb2        	addi	a11, a11, -4
42012627:	0b88      	l32i.n	a8, a11, 0
42012629:	f37c      	movi.n	a3, -1
4201262b:	0a89      	s32i.n	a8, a10, 0
4201262d:	150c      	movi.n	a5, 1
4201262f:	007986        	j	42012819 <get_arg$isra$0+0x39d>
42012632:	8a7c      	movi.n	a10, -8
42012634:	887b      	addi.n	a8, a8, 7
42012636:	1088a0        	and	a8, a8, a10
42012639:	0198      	l32i.n	a9, a1, 0
4201263b:	a88b      	addi.n	a10, a8, 8
4201263d:	24a9      	s32i.n	a10, a4, 8
4201263f:	8c1c      	movi.n	a12, 24
42012641:	b0bb90        	addx8	a11, a11, a9
42012644:	042ca7        	blt	a12, a10, 4201264c <get_arg$isra$0+0x1d0>
42012647:	1488      	l32i.n	a8, a4, 4
42012649:	000206        	j	42012655 <get_arg$isra$0+0x1d9>
4201264c:	012c87        	blt	a12, a8, 42012651 <get_arg$isra$0+0x1d5>
4201264f:	8a2c      	movi.n	a10, 40
42012651:	0488      	l32i.n	a8, a4, 0
42012653:	24a9      	s32i.n	a10, a4, 8
42012655:	88aa      	add.n	a8, a8, a10
42012657:	f8c882        	addi	a8, a8, -8
4201265a:	1898      	l32i.n	a9, a8, 4
4201265c:	0888      	l32i.n	a8, a8, 0
4201265e:	1b99      	s32i.n	a9, a11, 4
42012660:	0b89      	s32i.n	a8, a11, 0
42012662:	006cc6        	j	42012819 <get_arg$isra$0+0x39d>
42012665:	0188      	l32i.n	a8, a1, 0
42012667:	24b8      	l32i.n	a11, a4, 8
42012669:	2a1b      	addi.n	a2, a10, 1
4201266b:	b0aa80        	addx8	a10, a10, a8
4201266e:	8b4b      	addi.n	a8, a11, 4
42012670:	2489      	s32i.n	a8, a4, 8
42012672:	8c1c      	movi.n	a12, 24
42012674:	042c87        	blt	a12, a8, 4201267c <get_arg$isra$0+0x200>
42012677:	14b8      	l32i.n	a11, a4, 4
42012679:	000206        	j	42012685 <get_arg$isra$0+0x209>
4201267c:	012cb7        	blt	a12, a11, 42012681 <get_arg$isra$0+0x205>
4201267f:	482c      	movi.n	a8, 36
42012681:	04b8      	l32i.n	a11, a4, 0
42012683:	2489      	s32i.n	a8, a4, 8
42012685:	bb8a      	add.n	a11, a11, a8
42012687:	fccbb2        	addi	a11, a11, -4
4201268a:	0b88      	l32i.n	a8, a11, 0
4201268c:	f37c      	movi.n	a3, -1
4201268e:	0a89      	s32i.n	a8, a10, 0
42012690:	650c      	movi.n	a5, 6
42012692:	0060c6        	j	42012819 <get_arg$isra$0+0x39d>
42012695:	0188      	l32i.n	a8, a1, 0
42012697:	24b8      	l32i.n	a11, a4, 8
42012699:	2a1b      	addi.n	a2, a10, 1
4201269b:	b0aa80        	addx8	a10, a10, a8
4201269e:	8b4b      	addi.n	a8, a11, 4
420126a0:	2489      	s32i.n	a8, a4, 8
420126a2:	8c1c      	movi.n	a12, 24
420126a4:	042c87        	blt	a12, a8, 420126ac <get_arg$isra$0+0x230>
420126a7:	14b8      	l32i.n	a11, a4, 4
420126a9:	000206        	j	420126b5 <get_arg$isra$0+0x239>
420126ac:	012cb7        	blt	a12, a11, 420126b1 <get_arg$isra$0+0x235>
420126af:	482c      	movi.n	a8, 36
420126b1:	04b8      	l32i.n	a11, a4, 0
420126b3:	2489      	s32i.n	a8, a4, 8
420126b5:	bb8a      	add.n	a11, a11, a8
420126b7:	fccbb2        	addi	a11, a11, -4
420126ba:	0b88      	l32i.n	a8, a11, 0
420126bc:	f37c      	movi.n	a3, -1
420126be:	0a89      	s32i.n	a8, a10, 0
420126c0:	050c      	movi.n	a5, 0
420126c2:	0054c6        	j	42012819 <get_arg$isra$0+0x39d>
420126c5:	0188      	l32i.n	a8, a1, 0
420126c7:	24b8      	l32i.n	a11, a4, 8
420126c9:	2a1b      	addi.n	a2, a10, 1
420126cb:	b0aa80        	addx8	a10, a10, a8
420126ce:	8b4b      	addi.n	a8, a11, 4
420126d0:	2489      	s32i.n	a8, a4, 8
420126d2:	8c1c      	movi.n	a12, 24
420126d4:	042c87        	blt	a12, a8, 420126dc <get_arg$isra$0+0x260>
420126d7:	14b8      	l32i.n	a11, a4, 4
420126d9:	000206        	j	420126e5 <get_arg$isra$0+0x269>
420126dc:	012cb7        	blt	a12, a11, 420126e1 <get_arg$isra$0+0x265>
420126df:	482c      	movi.n	a8, 36
420126e1:	04b8      	l32i.n	a11, a4, 0
420126e3:	2489      	s32i.n	a8, a4, 8
420126e5:	bb8a      	add.n	a11, a11, a8
420126e7:	fccbb2        	addi	a11, a11, -4
420126ea:	0b88      	l32i.n	a8, a11, 0
420126ec:	f37c      	movi.n	a3, -1
420126ee:	0a89      	s32i.n	a8, a10, 0
420126f0:	350c      	movi.n	a5, 3
420126f2:	0048c6        	j	42012819 <get_arg$isra$0+0x39d>
420126f5:	0188      	l32i.n	a8, a1, 0
420126f7:	2a1b      	addi.n	a2, a10, 1
420126f9:	b0aa80        	addx8	a10, a10, a8
420126fc:	2488      	l32i.n	a8, a4, 8
420126fe:	8b7c      	movi.n	a11, -8
42012700:	887b      	addi.n	a8, a8, 7
42012702:	1088b0        	and	a8, a8, a11
42012705:	b88b      	addi.n	a11, a8, 8
42012707:	24b9      	s32i.n	a11, a4, 8
42012709:	8c1c      	movi.n	a12, 24
4201270b:	052cb7        	blt	a12, a11, 42012714 <get_arg$isra$0+0x298>
4201270e:	1488      	l32i.n	a8, a4, 4
42012710:	000246        	j	4201271d <get_arg$isra$0+0x2a1>
42012713:	2c8700        	lsi	f0, a7, 176
42012716:	8b2c01        	l32r	a0, 41ff53c8 <_coredump_iram_end+0x1c734c8>
42012719:	0488      	l32i.n	a8, a4, 0
4201271b:	24b9      	s32i.n	a11, a4, 8
4201271d:	88ba      	add.n	a8, a8, a11
4201271f:	f8c882        	addi	a8, a8, -8
42012722:	1898      	l32i.n	a9, a8, 4
42012724:	0888      	l32i.n	a8, a8, 0
42012726:	f37c      	movi.n	a3, -1
42012728:	0a89      	s32i.n	a8, a10, 0
4201272a:	1a99      	s32i.n	a9, a10, 4
4201272c:	450c      	movi.n	a5, 4
4201272e:	0039c6        	j	42012819 <get_arg$isra$0+0x39d>
42012731:	8a7c      	movi.n	a10, -8
42012733:	887b      	addi.n	a8, a8, 7
42012735:	1088a0        	and	a8, a8, a10
42012738:	0198      	l32i.n	a9, a1, 0
4201273a:	a88b      	addi.n	a10, a8, 8
4201273c:	24a9      	s32i.n	a10, a4, 8
4201273e:	8c1c      	movi.n	a12, 24
42012740:	b0bb90        	addx8	a11, a11, a9
42012743:	052ca7        	blt	a12, a10, 4201274c <get_arg$isra$0+0x2d0>
42012746:	1488      	l32i.n	a8, a4, 4
42012748:	000246        	j	42012755 <get_arg$isra$0+0x2d9>
4201274b:	2c8700        	lsi	f0, a7, 176
4201274e:	8a2c01        	l32r	a0, 41ff5000 <_coredump_iram_end+0x1c73100>
42012751:	0488      	l32i.n	a8, a4, 0
42012753:	24a9      	s32i.n	a10, a4, 8
42012755:	88aa      	add.n	a8, a8, a10
42012757:	f8c882        	addi	a8, a8, -8
4201275a:	1898      	l32i.n	a9, a8, 4
4201275c:	0888      	l32i.n	a8, a8, 0
4201275e:	1b99      	s32i.n	a9, a11, 4
42012760:	0b89      	s32i.n	a8, a11, 0
42012762:	002cc6        	j	42012819 <get_arg$isra$0+0x39d>
42012765:	1188      	l32i.n	a8, a1, 4
42012767:	0888      	l32i.n	a8, a8, 0
42012769:	140866        	bnei	a8, -1, 42012781 <get_arg$isra$0+0x305>
4201276c:	11a8      	l32i.n	a10, a1, 4
4201276e:	80a0c2        	movi	a12, 128
42012771:	0b0c      	movi.n	a11, 0
42012773:	61d9      	s32i.n	a13, a1, 24
42012775:	51e9      	s32i.n	a14, a1, 20
42012777:	b6e281        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4201277a:	0008e0        	callx8	a8
4201277d:	61d8      	l32i.n	a13, a1, 24
4201277f:	51e8      	l32i.n	a14, a1, 20
42012781:	3d0b      	addi.n	a3, a13, -1
42012783:	53ee30        	max	a14, a14, a3
42012786:	0023c6        	j	42012819 <get_arg$isra$0+0x39d>
42012789:	1188      	l32i.n	a8, a1, 4
4201278b:	0888      	l32i.n	a8, a8, 0
4201278d:	140866        	bnei	a8, -1, 420127a5 <get_arg$isra$0+0x329>
42012790:	11a8      	l32i.n	a10, a1, 4
42012792:	80a0c2        	movi	a12, 128
42012795:	0b0c      	movi.n	a11, 0
42012797:	61d9      	s32i.n	a13, a1, 24
42012799:	51e9      	s32i.n	a14, a1, 20
4201279b:	b6d981        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
4201279e:	0008e0        	callx8	a8
420127a1:	61d8      	l32i.n	a13, a1, 24
420127a3:	51e8      	l32i.n	a14, a1, 20
420127a5:	1188      	l32i.n	a8, a1, 4
420127a7:	dd0b      	addi.n	a13, a13, -1
420127a9:	a08d80        	addx4	a8, a13, a8
420127ac:	0a0c      	movi.n	a10, 0
420127ae:	08a9      	s32i.n	a10, a8, 0
420127b0:	53eed0        	max	a14, a14, a13
420127b3:	001886        	j	42012819 <get_arg$isra$0+0x39d>
420127b6:	0188      	l32i.n	a8, a1, 0
420127b8:	24b8      	l32i.n	a11, a4, 8
420127ba:	f21b      	addi.n	a15, a2, 1
420127bc:	b02280        	addx8	a2, a2, a8
420127bf:	8b4b      	addi.n	a8, a11, 4
420127c1:	2489      	s32i.n	a8, a4, 8
420127c3:	8c1c      	movi.n	a12, 24
420127c5:	042c87        	blt	a12, a8, 420127cd <get_arg$isra$0+0x351>
420127c8:	14b8      	l32i.n	a11, a4, 4
420127ca:	000206        	j	420127d6 <get_arg$isra$0+0x35a>
420127cd:	012cb7        	blt	a12, a11, 420127d2 <get_arg$isra$0+0x356>
420127d0:	482c      	movi.n	a8, 36
420127d2:	04b8      	l32i.n	a11, a4, 0
420127d4:	2489      	s32i.n	a8, a4, 8
420127d6:	bb8a      	add.n	a11, a11, a8
420127d8:	fccbb2        	addi	a11, a11, -4
420127db:	0b88      	l32i.n	a8, a11, 0
420127dd:	0a7d      	mov.n	a7, a10
420127df:	0289      	s32i.n	a8, a2, 0
420127e1:	0f2d      	mov.n	a2, a15
420127e3:	000c86        	j	42012819 <get_arg$isra$0+0x39d>
420127e6:	d20000        	quos	a0, a0, a0
420127e9:	d0c8      	l32i.n	a12, a0, 52
420127eb:	9a0c      	movi.n	a10, 9
420127ed:	0001c6        	j	420127f8 <get_arg$isra$0+0x37c>
420127f0:	a0ddd0        	addx4	a13, a13, a13
420127f3:	90dd80        	addx2	a13, a13, a8
420127f6:	771b      	addi.n	a7, a7, 1
420127f8:	000782        	l8ui	a8, a7, 0
420127fb:	a89c      	beqz.n	a8, 42012819 <get_arg$isra$0+0x39d>
420127fd:	d0c882        	addi	a8, a8, -48
42012800:	ecba87        	bgeu	a10, a8, 420127f0 <get_arg$isra$0+0x374>
42012803:	000486        	j	42012819 <get_arg$isra$0+0x39d>
42012806:	820000        	mull	a0, a0, a0
42012809:	820007        	bnone	a0, a0, 4201278f <get_arg$isra$0+0x313>
4201280c:	d0c8      	l32i.n	a12, a0, 52
4201280e:	748080        	extui	a8, a8, 0, 8
42012811:	043a87        	bltu	a10, a8, 42012819 <get_arg$isra$0+0x39d>
42012814:	771b      	addi.n	a7, a7, 1
42012816:	fffb86        	j	42012808 <get_arg$isra$0+0x38c>
42012819:	3198      	l32i.n	a9, a1, 12
4201281b:	b80c      	movi.n	a8, 11
4201281d:	021987        	beq	a9, a8, 42012823 <get_arg$isra$0+0x3a7>
42012820:	ff2506        	j	420124b8 <get_arg$isra$0+0x3c>
42012823:	0007a2        	l8ui	a10, a7, 0
42012826:	ea8c      	beqz.n	a10, 42012838 <get_arg$isra$0+0x3bc>
42012828:	2188      	l32i.n	a8, a1, 8
4201282a:	728820        	lsi	f2, a8, 0x1c8
4201282d:	880b      	addi.n	a8, a8, -1
4201282f:	608080        	neg	a8, a8
42012832:	748080        	extui	a8, a8, 0, 8
42012835:	c5f856        	bnez	a8, 42012498 <get_arg$isra$0+0x1c>
42012838:	2188      	l32i.n	a8, a1, 8
4201283a:	93e8a0        	movnez	a14, a8, a10
4201283d:	002346        	j	420128ce <get_arg$isra$0+0x452>
42012840:	1188      	l32i.n	a8, a1, 4
42012842:	a08d80        	addx4	a8, a13, a8
42012845:	08c8      	l32i.n	a12, a8, 0
42012847:	dd1b      	addi.n	a13, a13, 1
42012849:	cc0b      	addi.n	a12, a12, -1
4201284b:	2488      	l32i.n	a8, a4, 8
4201284d:	5c6cf6        	bgeui	a12, 6, 420128ad <get_arg$isra$0+0x431>
42012850:	a0cc60        	addx4	a12, a12, a6
42012853:	0cc8      	l32i.n	a12, a12, 0
42012855:	000ca0        	jx	a12
42012858:	887b      	addi.n	a8, a8, 7
4201285a:	1088f0        	and	a8, a8, a15
4201285d:	c88b      	addi.n	a12, a8, 8
4201285f:	24c9      	s32i.n	a12, a4, 8
42012861:	042ac7        	blt	a10, a12, 42012869 <get_arg$isra$0+0x3ed>
42012864:	1488      	l32i.n	a8, a4, 4
42012866:	000206        	j	42012872 <get_arg$isra$0+0x3f6>
42012869:	012a87        	blt	a10, a8, 4201286e <get_arg$isra$0+0x3f2>
4201286c:	8c2c      	movi.n	a12, 40
4201286e:	0488      	l32i.n	a8, a4, 0
42012870:	24c9      	s32i.n	a12, a4, 8
42012872:	88ca      	add.n	a8, a8, a12
42012874:	f8c882        	addi	a8, a8, -8
42012877:	1898      	l32i.n	a9, a8, 4
42012879:	0888      	l32i.n	a8, a8, 0
4201287b:	1b99      	s32i.n	a9, a11, 4
4201287d:	0b89      	s32i.n	a8, a11, 0
4201287f:	001706        	j	420128df <get_arg$isra$0+0x463>
42012882:	887b      	addi.n	a8, a8, 7
42012884:	1088f0        	and	a8, a8, a15
42012887:	c88b      	addi.n	a12, a8, 8
42012889:	24c9      	s32i.n	a12, a4, 8
4201288b:	052ac7        	blt	a10, a12, 42012894 <get_arg$isra$0+0x418>
4201288e:	1488      	l32i.n	a8, a4, 4
42012890:	000246        	j	4201289d <get_arg$isra$0+0x421>
42012893:	2a8700        	mul.s	f8, f7, f0
42012896:	8c2c01        	l32r	a0, 41ff5948 <_coredump_iram_end+0x1c73a48>
42012899:	0488      	l32i.n	a8, a4, 0
4201289b:	24c9      	s32i.n	a12, a4, 8
4201289d:	88ca      	add.n	a8, a8, a12
4201289f:	f8c882        	addi	a8, a8, -8
420128a2:	1898      	l32i.n	a9, a8, 4
420128a4:	0888      	l32i.n	a8, a8, 0
420128a6:	1b99      	s32i.n	a9, a11, 4
420128a8:	0b89      	s32i.n	a8, a11, 0
420128aa:	000c46        	j	420128df <get_arg$isra$0+0x463>
420128ad:	c84b      	addi.n	a12, a8, 4
420128af:	24c9      	s32i.n	a12, a4, 8
420128b1:	042ac7        	blt	a10, a12, 420128b9 <get_arg$isra$0+0x43d>
420128b4:	1488      	l32i.n	a8, a4, 4
420128b6:	000206        	j	420128c2 <get_arg$isra$0+0x446>
420128b9:	012a87        	blt	a10, a8, 420128be <get_arg$isra$0+0x442>
420128bc:	4c2c      	movi.n	a12, 36
420128be:	0488      	l32i.n	a8, a4, 0
420128c0:	24c9      	s32i.n	a12, a4, 8
420128c2:	88ca      	add.n	a8, a8, a12
420128c4:	fcc882        	addi	a8, a8, -4
420128c7:	0888      	l32i.n	a8, a8, 0
420128c9:	0b89      	s32i.n	a8, a11, 0
420128cb:	000406        	j	420128df <get_arg$isra$0+0x463>
420128ce:	0188      	l32i.n	a8, a1, 0
420128d0:	b94861        	l32r	a6, 42000df0 <_stext+0xdd0> (3c0298a8 <__mprec_tens+0x160>)
420128d3:	b0b280        	addx8	a11, a2, a8
420128d6:	02dd      	mov.n	a13, a2
420128d8:	8a1c      	movi.n	a10, 24
420128da:	8f7c      	movi.n	a15, -8
420128dc:	000046        	j	420128e1 <get_arg$isra$0+0x465>
420128df:	bb8b      	addi.n	a11, a11, 8
420128e1:	022ed7        	blt	a14, a13, 420128e7 <get_arg$isra$0+0x46b>
420128e4:	ffd606        	j	42012840 <get_arg$isra$0+0x3c4>
420128e7:	8e1b      	addi.n	a8, a14, 1
420128e9:	728820        	lsi	f2, a8, 0x1c8
420128ec:	880b      	addi.n	a8, a8, -1
420128ee:	608080        	neg	a8, a8
420128f1:	748080        	extui	a8, a8, 0, 8
420128f4:	0a0c      	movi.n	a10, 0
420128f6:	d8bc      	beqz.n	a8, 42012937 <get_arg$isra$0+0x4bb>
420128f8:	820b      	addi.n	a8, a2, -1
420128fa:	608080        	neg	a8, a8
420128fd:	a8ea      	add.n	a10, a8, a14
420128ff:	000d06        	j	42012937 <get_arg$isra$0+0x4bb>
42012902:	450c      	movi.n	a5, 4
42012904:	020326        	beqi	a3, -1, 4201290a <get_arg$isra$0+0x48e>
42012907:	ff3446        	j	420125dc <get_arg$isra$0+0x160>
4201290a:	ff79c6        	j	420126f5 <get_arg$isra$0+0x279>
4201290d:	350c      	movi.n	a5, 3
4201290f:	020326        	beqi	a3, -1, 42012915 <get_arg$isra$0+0x499>
42012912:	ff3186        	j	420125dc <get_arg$isra$0+0x160>
42012915:	ff6b06        	j	420126c5 <get_arg$isra$0+0x249>
42012918:	020326        	beqi	a3, -1, 4201291e <get_arg$isra$0+0x4a2>
4201291b:	ff2f46        	j	420125dc <get_arg$isra$0+0x160>
4201291e:	ff5cc6        	j	42012695 <get_arg$isra$0+0x219>
42012921:	650c      	movi.n	a5, 6
42012923:	020326        	beqi	a3, -1, 42012929 <get_arg$isra$0+0x4ad>
42012926:	ff2c86        	j	420125dc <get_arg$isra$0+0x160>
42012929:	ff4e06        	j	42012665 <get_arg$isra$0+0x1e9>
4201292c:	150c      	movi.n	a5, 1
4201292e:	020326        	beqi	a3, -1, 42012934 <get_arg$isra$0+0x4b8>
42012931:	ff29c6        	j	420125dc <get_arg$isra$0+0x160>
42012934:	ff3286        	j	42012602 <get_arg$isra$0+0x186>
42012937:	4198      	l32i.n	a9, a1, 16
42012939:	8a2a      	add.n	a8, a10, a2
4201293b:	0989      	s32i.n	a8, a9, 0
4201293d:	102182        	l32i	a8, a1, 64
42012940:	0198      	l32i.n	a9, a1, 0
42012942:	0879      	s32i.n	a7, a8, 0
42012944:	2188      	l32i.n	a8, a1, 8
42012946:	b02890        	addx8	a2, a8, a9
42012949:	f01d      	retw.n
	...

4201294c <__ssprint_r>:
4201294c:	006136        	entry	a1, 48
4201294f:	2498      	l32i.n	a9, a4, 8
42012951:	0129      	s32i.n	a2, a1, 0
42012953:	035d      	mov.n	a5, a3
42012955:	398c      	beqz.n	a9, 4201295c <__ssprint_r+0x10>
42012957:	0468      	l32i.n	a6, a4, 0
42012959:	000106        	j	42012961 <__ssprint_r+0x15>
4201295c:	020c      	movi.n	a2, 0
4201295e:	003b46        	j	42012a4f <__ssprint_r+0x103>
42012961:	0688      	l32i.n	a8, a6, 0
42012963:	1638      	l32i.n	a3, a6, 4
42012965:	1189      	s32i.n	a8, a1, 4
42012967:	668b      	addi.n	a6, a6, 8
42012969:	ff4316        	beqz	a3, 42012961 <__ssprint_r+0x15>
4201296c:	25d8      	l32i.n	a13, a5, 8
4201296e:	0d7d      	mov.n	a7, a13
42012970:	02b3d7        	bgeu	a3, a13, 42012976 <__ssprint_r+0x2a>
42012973:	0024c6        	j	42012a0a <__ssprint_r+0xbe>
42012976:	0695f2        	l16si	a15, a5, 12
42012979:	80a482        	movi	a8, 0x480
4201297c:	109f80        	and	a9, a15, a8
4201297f:	239980        	sext	a9, a9, 15
42012982:	088916        	beqz	a9, 42012a0e <__ssprint_r+0xc2>
42012985:	55a8      	l32i.n	a10, a5, 20
42012987:	45b8      	l32i.n	a11, a5, 16
42012989:	0578      	l32i.n	a7, a5, 0
4201298b:	90aaa0        	addx2	a10, a10, a10
4201298e:	059fa0        	extui	a9, a10, 31, 1
42012991:	c077b0        	sub	a7, a7, a11
42012994:	99aa      	add.n	a9, a9, a10
42012996:	a71b      	addi.n	a10, a7, 1
42012998:	212190        	srai	a2, a9, 1
4201299b:	aa3a      	add.n	a10, a10, a3
4201299d:	20c220        	or	a12, a2, a2
420129a0:	04b2a7        	bgeu	a2, a10, 420129a8 <__ssprint_r+0x5c>
420129a3:	0a2d      	mov.n	a2, a10
420129a5:	20caa0        	or	a12, a10, a10
420129a8:	326fa7        	bbci	a15, 10, 420129de <__ssprint_r+0x92>
420129ab:	01a8      	l32i.n	a10, a1, 0
420129ad:	0cbd      	mov.n	a11, a12
420129af:	b8b681        	l32r	a8, 42000c88 <_stext+0xc68> (4037fea4 <_malloc_r>)
420129b2:	0008e0        	callx8	a8
420129b5:	07fa16        	beqz	a10, 42012a38 <__ssprint_r+0xec>
420129b8:	45b8      	l32i.n	a11, a5, 16
420129ba:	07cd      	mov.n	a12, a7
420129bc:	21a9      	s32i.n	a10, a1, 8
420129be:	b59a81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420129c1:	0008e0        	callx8	a8
420129c4:	0615a2        	l16ui	a10, a5, 12
420129c7:	7fabb2        	movi	a11, 0xfffffb7f
420129ca:	10aab0        	and	a10, a10, a11
420129cd:	80a0b2        	movi	a11, 128
420129d0:	20aab0        	or	a10, a10, a11
420129d3:	21d8      	l32i.n	a13, a1, 8
420129d5:	0655a2        	s16i	a10, a5, 12
420129d8:	000706        	j	420129f8 <__ssprint_r+0xac>
420129db:	000000        	ill
420129de:	01a8      	l32i.n	a10, a1, 0
420129e0:	b8af81        	l32r	a8, 42000c9c <_stext+0xc7c> (4037fe90 <_realloc_r>)
420129e3:	0008e0        	callx8	a8
420129e6:	0add      	mov.n	a13, a10
420129e8:	cacc      	bnez.n	a10, 420129f8 <__ssprint_r+0xac>
420129ea:	45b8      	l32i.n	a11, a5, 16
420129ec:	01a8      	l32i.n	a10, a1, 0
420129ee:	b89681        	l32r	a8, 42000c48 <_stext+0xc28> (4037fe84 <_free_r>)
420129f1:	0008e0        	callx8	a8
420129f4:	001006        	j	42012a38 <__ssprint_r+0xec>
420129f7:	45d900        	extui	a13, a0, 25, 5
420129fa:	c09270        	sub	a9, a2, a7
420129fd:	dd7a      	add.n	a13, a13, a7
420129ff:	05d9      	s32i.n	a13, a5, 0
42012a01:	5529      	s32i.n	a2, a5, 20
42012a03:	03dd      	mov.n	a13, a3
42012a05:	2599      	s32i.n	a9, a5, 8
42012a07:	000046        	j	42012a0c <__ssprint_r+0xc0>
42012a0a:	03dd      	mov.n	a13, a3
42012a0c:	037d      	mov.n	a7, a3
42012a0e:	11b8      	l32i.n	a11, a1, 4
42012a10:	05a8      	l32i.n	a10, a5, 0
42012a12:	07cd      	mov.n	a12, a7
42012a14:	21d9      	s32i.n	a13, a1, 8
42012a16:	b7b481        	l32r	a8, 420008e8 <_stext+0x8c8> (40001200 <memmove>)
42012a19:	0008e0        	callx8	a8
42012a1c:	2598      	l32i.n	a9, a5, 8
42012a1e:	21d8      	l32i.n	a13, a1, 8
42012a20:	c099d0        	sub	a9, a9, a13
42012a23:	2599      	s32i.n	a9, a5, 8
42012a25:	0598      	l32i.n	a9, a5, 0
42012a27:	997a      	add.n	a9, a9, a7
42012a29:	0599      	s32i.n	a9, a5, 0
42012a2b:	2498      	l32i.n	a9, a4, 8
42012a2d:	c09930        	sub	a9, a9, a3
42012a30:	2499      	s32i.n	a9, a4, 8
42012a32:	f2b956        	bnez	a9, 42012961 <__ssprint_r+0x15>
42012a35:	ffc8c6        	j	4201295c <__ssprint_r+0x10>
42012a38:	0188      	l32i.n	a8, a1, 0
42012a3a:	c90c      	movi.n	a9, 12
42012a3c:	0899      	s32i.n	a9, a8, 0
42012a3e:	061592        	l16ui	a9, a5, 12
42012a41:	0a4c      	movi.n	a10, 64
42012a43:	2099a0        	or	a9, a9, a10
42012a46:	065592        	s16i	a9, a5, 12
42012a49:	080c      	movi.n	a8, 0
42012a4b:	2489      	s32i.n	a8, a4, 8
42012a4d:	f27c      	movi.n	a2, -1
42012a4f:	080c      	movi.n	a8, 0
42012a51:	1489      	s32i.n	a8, a4, 4
42012a53:	f01d      	retw.n
42012a55:	000000        	ill

42012a58 <_svfiprintf_r>:
42012a58:	058136        	entry	a1, 0x2c0
42012a5b:	9a6142        	s32i	a4, a1, 0x268
42012a5e:	061382        	l16ui	a8, a3, 12
42012a61:	9d6122        	s32i	a2, a1, 0x274
42012a64:	9c6132        	s32i	a3, a1, 0x270
42012a67:	946152        	s32i	a5, a1, 0x250
42012a6a:	956162        	s32i	a6, a1, 0x254
42012a6d:	966172        	s32i	a7, a1, 0x258
42012a70:	10c142        	addi	a4, a1, 16
42012a73:	296877        	bbci	a8, 7, 42012aa0 <_svfiprintf_r+0x48>
42012a76:	4388      	l32i.n	a8, a3, 16
42012a78:	48ec      	bnez.n	a8, 42012aa0 <_svfiprintf_r+0x48>
42012a7a:	0b4c      	movi.n	a11, 64
42012a7c:	02ad      	mov.n	a10, a2
42012a7e:	b88281        	l32r	a8, 42000c88 <_stext+0xc68> (4037fea4 <_malloc_r>)
42012a81:	0008e0        	callx8	a8
42012a84:	9c2182        	l32i	a8, a1, 0x270
42012a87:	08a9      	s32i.n	a10, a8, 0
42012a89:	48a9      	s32i.n	a10, a8, 16
42012a8b:	aacc      	bnez.n	a10, 42012a99 <_svfiprintf_r+0x41>
42012a8d:	9d2192        	l32i	a9, a1, 0x274
42012a90:	c80c      	movi.n	a8, 12
42012a92:	0989      	s32i.n	a8, a9, 0
42012a94:	071346        	j	420146e5 <_svfiprintf_r+0x1c8d>
42012a97:	920000        	lsi	f0, a0, 0x248
42012a9a:	4c9c21        	l32r	a2, 41fe5d0c <_coredump_iram_end+0x1c63e0c>
42012a9d:	8908      	l32i.n	a0, a9, 32
42012a9f:	8259      	s32i.n	a5, a2, 32
42012aa1:	8ae4a1        	l32r	a10, 41ff5634 <_coredump_iram_end+0x1c73734>
42012aa4:	090c84        	lsi	f8, a12, 36
42012aa7:	896482        	s32i	a8, a4, 0x224
42012aaa:	986182        	s32i	a8, a1, 0x260
42012aad:	080c      	movi.n	a8, 0
42012aaf:	906192        	s32i	a9, a1, 0x240
42012ab2:	916192        	s32i	a9, a1, 0x244
42012ab5:	976192        	s32i	a9, a1, 0x25c
42012ab8:	996192        	s32i	a9, a1, 0x264
42012abb:	a26182        	s32i	a8, a1, 0x288
42012abe:	a06182        	s32i	a8, a1, 0x280
42012ac1:	a16182        	s32i	a8, a1, 0x284
42012ac4:	a36182        	s32i	a8, a1, 0x28c
42012ac7:	9f6182        	s32i	a8, a1, 0x27c
42012aca:	10c192        	addi	a9, a1, 16
42012acd:	e4a182        	movi	a8, 0x1e4
42012ad0:	fa7c      	movi.n	a10, -1
42012ad2:	898a      	add.n	a8, a9, a8
42012ad4:	4064a2        	s32i	a10, a4, 0x100
42012ad7:	060c      	movi.n	a6, 0
42012ad9:	a56182        	s32i	a8, a1, 0x294
42012adc:	9a2172        	l32i	a7, a1, 0x268
42012adf:	000046        	j	42012ae4 <_svfiprintf_r+0x8c>
42012ae2:	771b      	addi.n	a7, a7, 1
42012ae4:	000782        	l8ui	a8, a7, 0
42012ae7:	005816        	beqz	a8, 42012af0 <_svfiprintf_r+0x98>
42012aea:	dbc882        	addi	a8, a8, -37
42012aed:	ff1856        	bnez	a8, 42012ae2 <_svfiprintf_r+0x8a>
42012af0:	9a2182        	l32i	a8, a1, 0x268
42012af3:	c05780        	sub	a5, a7, a8
42012af6:	066516        	beqz	a5, 42012b60 <_svfiprintf_r+0x108>
42012af9:	982182        	l32i	a8, a1, 0x260
42012afc:	9a2192        	l32i	a9, a1, 0x268
42012aff:	1859      	s32i.n	a5, a8, 4
42012b01:	0899      	s32i.n	a9, a8, 0
42012b03:	972182        	l32i	a8, a1, 0x25c
42012b06:	885a      	add.n	a8, a8, a5
42012b08:	976182        	s32i	a8, a1, 0x25c
42012b0b:	992182        	l32i	a8, a1, 0x264
42012b0e:	881b      	addi.n	a8, a8, 1
42012b10:	996182        	s32i	a8, a1, 0x264
42012b13:	0788e6        	bgei	a8, 8, 42012b1e <_svfiprintf_r+0xc6>
42012b16:	982182        	l32i	a8, a1, 0x260
42012b19:	888b      	addi.n	a8, a8, 8
42012b1b:	000d86        	j	42012b55 <_svfiprintf_r+0xfd>
42012b1e:	992182        	l32i	a8, a1, 0x264
42012b21:	10c132        	addi	a3, a1, 16
42012b24:	8e6182        	s32i	a8, a1, 0x238
42012b27:	9c21b2        	l32i	a11, a1, 0x270
42012b2a:	972182        	l32i	a8, a1, 0x25c
42012b2d:	9d21a2        	l32i	a10, a1, 0x274
42012b30:	24a2c2        	movi	a12, 0x224
42012b33:	80c3c0        	add	a12, a3, a12
42012b36:	8f6182        	s32i	a8, a1, 0x23c
42012b39:	ffe125        	call8	4201294c <__ssprint_r>
42012b3c:	8e2182        	l32i	a8, a1, 0x238
42012b3f:	02d342        	addmi	a4, a3, 0x200
42012b42:	996182        	s32i	a8, a1, 0x264
42012b45:	8f2182        	l32i	a8, a1, 0x23c
42012b48:	976182        	s32i	a8, a1, 0x25c
42012b4b:	1a8c      	beqz.n	a10, 42012b50 <_svfiprintf_r+0xf8>
42012b4d:	06e2c6        	j	420146dc <_svfiprintf_r+0x1c84>
42012b50:	e4a182        	movi	a8, 0x1e4
42012b53:	838a      	add.n	a8, a3, a8
42012b55:	986182        	s32i	a8, a1, 0x260
42012b58:	9f2182        	l32i	a8, a1, 0x27c
42012b5b:	885a      	add.n	a8, a8, a5
42012b5d:	9f6182        	s32i	a8, a1, 0x27c
42012b60:	000782        	l8ui	a8, a7, 0
42012b63:	18cc      	bnez.n	a8, 42012b68 <_svfiprintf_r+0x110>
42012b65:	06d3c6        	j	420146b8 <_svfiprintf_r+0x1c60>
42012b68:	10c192        	addi	a9, a1, 16
42012b6b:	02d992        	addmi	a9, a9, 0x200
42012b6e:	0a0c      	movi.n	a10, 0
42012b70:	3a49a2        	s8i	a10, a9, 58
42012b73:	f97c      	movi.n	a9, -1
42012b75:	9b6192        	s32i	a9, a1, 0x26c
42012b78:	090c      	movi.n	a9, 0
42012b7a:	871b      	addi.n	a8, a7, 1
42012b7c:	065d      	mov.n	a5, a6
42012b7e:	9e6192        	s32i	a9, a1, 0x278
42012b81:	030c      	movi.n	a3, 0
42012b83:	020c      	movi.n	a2, 0
42012b85:	000206        	j	42012b91 <_svfiprintf_r+0x139>
42012b88:	619200        	lsi	f0, a2, 0x184
42012b8b:	0c9a      	add.n	a0, a12, a9
42012b8d:	218203        	lsip	f0, a2, 132
42012b90:	1b9a      	add.n	a1, a11, a9
42012b92:	4298      	l32i.n	a9, a2, 16
42012b94:	0008      	l32i.n	a0, a0, 0
42012b96:	9a6192        	s32i	a9, a1, 0x268
42012b99:	aa5c      	movi.n	a10, 90
42012b9b:	000106        	j	42012ba3 <_svfiprintf_r+0x14b>
42012b9e:	820000        	mull	a0, a0, a0
42012ba1:	829e61        	l32r	a6, 41ff361c <_coredump_iram_end+0x1c7171c>
42012ba4:	87e0c4        	lsi	f12, a0, 0x21c
42012ba7:	02ba      	add.n	a0, a2, a11
42012ba9:	0587c6        	j	420141cc <_svfiprintf_r+0x1774>
42012bac:	b89491        	l32r	a9, 42000dfc <_stext+0xddc> (3c0298c0 <__mprec_tens+0x178>)
42012baf:	a08890        	addx4	a8, a8, a9
42012bb2:	0888      	l32i.n	a8, a8, 0
42012bb4:	0008a0        	jx	a8
42012bb7:	810000        	src	a0, a0, a0
42012bba:	8f          	.byte	0x8f
42012bbb:	c6b8      	l32i.n	a11, a6, 48
42012bbd:	a20457        	bnone	a4, a5, 42012b63 <_svfiprintf_r+0x10b>
42012bc0:	109d21        	l32r	a2, 41fd6e34 <_coredump_iram_end+0x1c54f34>
42012bc3:	652011        	l32r	a1, 41fec044 <_coredump_iram_end+0x1c6a144>
42012bc6:	88fe02        	s32ri	a0, a14, 0x220
42012bc9:	ad1a      	add.n	a10, a13, a1
42012bcb:	8208      	l32i.n	a0, a2, 32
42012bcd:	81a361        	l32r	a6, 41ff325c <_coredump_iram_end+0x1c7135c>
42012bd0:	e0b5b3        	lsi	f11, a5, 0x380
42012bd3:	0008      	l32i.n	a0, a0, 0
42012bd5:	a161a2        	s32i	a10, a1, 0x284
42012bd8:	9d21a2        	l32i	a10, a1, 0x274
42012bdb:	201110        	or	a1, a1, a1
42012bde:	fe00e5        	call8	42010bec <_localeconv_r>
42012be1:	2a88      	l32i.n	a8, a10, 8
42012be3:	a06182        	s32i	a8, a1, 0x280
42012be6:	a12182        	l32i	a8, a1, 0x284
42012be9:	fa1816        	beqz	a8, 42012b8e <_svfiprintf_r+0x136>
42012bec:	a02182        	l32i	a8, a1, 0x280
42012bef:	f9b816        	beqz	a8, 42012b8e <_svfiprintf_r+0x136>
42012bf2:	000882        	l8ui	a8, a8, 0
42012bf5:	f95816        	beqz	a8, 42012b8e <_svfiprintf_r+0x136>
42012bf8:	00a482        	movi	a8, 0x400
42012bfb:	00b906        	j	42012ee3 <_svfiprintf_r+0x48b>
42012bfe:	10c182        	addi	a8, a1, 16
42012c01:	02d882        	addmi	a8, a8, 0x200
42012c04:	3a0892        	l8ui	a9, a8, 58
42012c07:	f83956        	bnez	a9, 42012b8e <_svfiprintf_r+0x136>
42012c0a:	092c      	movi.n	a9, 32
42012c0c:	004686        	j	42012d2a <_svfiprintf_r+0x2d2>
42012c0f:	180c      	movi.n	a8, 1
42012c11:	00b386        	j	42012ee3 <_svfiprintf_r+0x48b>
42012c14:	9a2182        	l32i	a8, a1, 0x268
42012c17:	9a0c      	movi.n	a10, 9
42012c19:	000882        	l8ui	a8, a8, 0
42012c1c:	d0c892        	addi	a9, a8, -48
42012c1f:	3d3a97        	bltu	a10, a9, 42012c60 <_svfiprintf_r+0x208>
42012c22:	9a2192        	l32i	a9, a1, 0x268
42012c25:	0a0c      	movi.n	a10, 0
42012c27:	491b      	addi.n	a4, a9, 1
42012c29:	09a0b2        	movi	a11, 9
42012c2c:	d0c882        	addi	a8, a8, -48
42012c2f:	a0aaa0        	addx4	a10, a10, a10
42012c32:	90aa80        	addx2	a10, a10, a8
42012c35:	000482        	l8ui	a8, a4, 0
42012c38:	441b      	addi.n	a4, a4, 1
42012c3a:	d0c892        	addi	a9, a8, -48
42012c3d:	ebbb97        	bgeu	a11, a9, 42012c2c <_svfiprintf_r+0x1d4>
42012c40:	492c      	movi.n	a9, 36
42012c42:	021897        	beq	a8, a9, 42012c48 <_svfiprintf_r+0x1f0>
42012c45:	ffd0c6        	j	42012b8c <_svfiprintf_r+0x134>
42012c48:	082c      	movi.n	a8, 32
42012c4a:	02a8a7        	bge	a8, a10, 42012c50 <_svfiprintf_r+0x1f8>
42012c4d:	06a2c6        	j	420146dc <_svfiprintf_r+0x1c84>
42012c50:	912182        	l32i	a8, a1, 0x244
42012c53:	aa0b      	addi.n	a10, a10, -1
42012c55:	10c1e2        	addi	a14, a1, 16
42012c58:	142a87        	blt	a10, a8, 42012c70 <_svfiprintf_r+0x218>
42012c5b:	000646        	j	42012c78 <_svfiprintf_r+0x220>
42012c5e:	b20000        	mulsh	a0, a0, a0
42012c61:	1b9121        	l32r	a2, 41fd9aa8 <_coredump_iram_end+0x1c57ba8>
42012c64:	c18296        	bltz	a2, 42012880 <get_arg$isra$0+0x404>
42012c67:	26b710        	lsi	f1, a7, 152
42012c6a:	0d4632        	s8i	a3, a6, 13
42012c6d:	000000        	ill
42012c70:	b0eae0        	addx8	a14, a10, a14
42012c73:	0e88      	l32i.n	a8, a14, 0
42012c75:	000686        	j	42012c93 <_svfiprintf_r+0x23b>
42012c78:	30a282        	movi	a8, 0x230
42012c7b:	8e8a      	add.n	a8, a14, a8
42012c7d:	34a2d2        	movi	a13, 0x234
42012c80:	40a2c2        	movi	a12, 0x240
42012c83:	0189      	s32i.n	a8, a1, 0
42012c85:	01def2        	addmi	a15, a14, 0x100
42012c88:	deda      	add.n	a13, a14, a13
42012c8a:	ceca      	add.n	a12, a14, a12
42012c8c:	07bd      	mov.n	a11, a7
42012c8e:	ff7ee5        	call8	4201247c <get_arg$isra$0>
42012c91:	0a88      	l32i.n	a8, a10, 0
42012c93:	9e6182        	s32i	a8, a1, 0x278
42012c96:	9a6142        	s32i	a4, a1, 0x268
42012c99:	069d      	mov.n	a9, a6
42012c9b:	001c06        	j	42012d0f <_svfiprintf_r+0x2b7>
42012c9e:	b08580        	addx8	a8, a5, a8
42012ca1:	001946        	j	42012d0a <_svfiprintf_r+0x2b2>
42012ca4:	9228a2        	l32i	a10, a8, 0x248
42012ca7:	fd1c      	movi.n	a13, 31
42012ca9:	02d882        	addmi	a8, a8, 0x200
42012cac:	ca4b      	addi.n	a12, a10, 4
42012cae:	322db7        	blt	a13, a11, 42012ce4 <_svfiprintf_r+0x28c>
42012cb1:	db1b      	addi.n	a13, a11, 1
42012cb3:	9161d2        	s32i	a13, a1, 0x244
42012cb6:	1268c2        	s32i	a12, a8, 72
42012cb9:	8d1c      	movi.n	a13, 24
42012cbb:	052dc7        	blt	a13, a12, 42012cc4 <_svfiprintf_r+0x26c>
42012cbe:	1128a2        	l32i	a10, a8, 68
42012cc1:	000286        	j	42012ccf <_svfiprintf_r+0x277>
42012cc4:	012da7        	blt	a13, a10, 42012cc9 <_svfiprintf_r+0x271>
42012cc7:	4c2c      	movi.n	a12, 36
42012cc9:	9421a2        	l32i	a10, a1, 0x250
42012ccc:	9661c2        	s32i	a12, a1, 0x258
42012ccf:	aaca      	add.n	a10, a10, a12
42012cd1:	fccaa2        	addi	a10, a10, -4
42012cd4:	0a88      	l32i.n	a8, a10, 0
42012cd6:	9e6182        	s32i	a8, a1, 0x278
42012cd9:	9e21a2        	l32i	a10, a1, 0x278
42012cdc:	b08b10        	addx8	a8, a11, a1
42012cdf:	48a9      	s32i.n	a10, a8, 16
42012ce1:	000a86        	j	42012d0f <_svfiprintf_r+0x2b7>
42012ce4:	1268c2        	s32i	a12, a8, 72
42012ce7:	8b1c      	movi.n	a11, 24
42012ce9:	072bc7        	blt	a11, a12, 42012cf4 <_svfiprintf_r+0x29c>
42012cec:	112882        	l32i	a8, a8, 68
42012cef:	000486        	j	42012d05 <_svfiprintf_r+0x2ad>
42012cf2:	a70000        	lsi	f0, a0, 0x29c
42012cf5:	012b      	addi.n	a0, a1, 2
42012cf7:	4c2c      	movi.n	a12, 36
42012cf9:	10c182        	addi	a8, a1, 16
42012cfc:	02d882        	addmi	a8, a8, 0x200
42012cff:	102882        	l32i	a8, a8, 64
42012d02:	9661c2        	s32i	a12, a1, 0x258
42012d05:	88ca      	add.n	a8, a8, a12
42012d07:	fcc882        	addi	a8, a8, -4
42012d0a:	0888      	l32i.n	a8, a8, 0
42012d0c:	9e6182        	s32i	a8, a1, 0x278
42012d0f:	9e2182        	l32i	a8, a1, 0x278
42012d12:	096d      	mov.n	a6, a9
42012d14:	e768d6        	bgez	a8, 42012b8e <_svfiprintf_r+0x136>
42012d17:	608080        	neg	a8, a8
42012d1a:	9e6182        	s32i	a8, a1, 0x278
42012d1d:	480c      	movi.n	a8, 4
42012d1f:	007006        	j	42012ee3 <_svfiprintf_r+0x48b>
42012d22:	10c182        	addi	a8, a1, 16
42012d25:	02d882        	addmi	a8, a8, 0x200
42012d28:	b92c      	movi.n	a9, 43
42012d2a:	3a4892        	s8i	a9, a8, 58
42012d2d:	ff9746        	j	42012b8e <_svfiprintf_r+0x136>
42012d30:	9a2182        	l32i	a8, a1, 0x268
42012d33:	000842        	l8ui	a4, a8, 0
42012d36:	981b      	addi.n	a9, a8, 1
42012d38:	a82c      	movi.n	a8, 42
42012d3a:	061487        	beq	a4, a8, 42012d44 <_svfiprintf_r+0x2ec>
42012d3d:	080c      	movi.n	a8, 0
42012d3f:	9c0c      	movi.n	a12, 9
42012d41:	004386        	j	42012e53 <_svfiprintf_r+0x3fb>
42012d44:	9a2182        	l32i	a8, a1, 0x268
42012d47:	9b0c      	movi.n	a11, 9
42012d49:	010882        	l8ui	a8, a8, 1
42012d4c:	d0c8a2        	addi	a10, a8, -48
42012d4f:	393ba7        	bltu	a11, a10, 42012d8c <_svfiprintf_r+0x334>
42012d52:	9a21a2        	l32i	a10, a1, 0x268
42012d55:	4a2b      	addi.n	a4, a10, 2
42012d57:	0a0c      	movi.n	a10, 0
42012d59:	d0c882        	addi	a8, a8, -48
42012d5c:	a0aaa0        	addx4	a10, a10, a10
42012d5f:	90aa80        	addx2	a10, a10, a8
42012d62:	000482        	l8ui	a8, a4, 0
42012d65:	441b      	addi.n	a4, a4, 1
42012d67:	d0c8c2        	addi	a12, a8, -48
42012d6a:	ebbbc7        	bgeu	a11, a12, 42012d59 <_svfiprintf_r+0x301>
42012d6d:	4b2c      	movi.n	a11, 36
42012d6f:	0218b7        	beq	a8, a11, 42012d75 <_svfiprintf_r+0x31d>
42012d72:	ff84c6        	j	42012b89 <_svfiprintf_r+0x131>
42012d75:	082c      	movi.n	a8, 32
42012d77:	02a8a7        	bge	a8, a10, 42012d7d <_svfiprintf_r+0x325>
42012d7a:	065786        	j	420146dc <_svfiprintf_r+0x1c84>
42012d7d:	912182        	l32i	a8, a1, 0x244
42012d80:	aa0b      	addi.n	a10, a10, -1
42012d82:	10c1e2        	addi	a14, a1, 16
42012d85:	132a87        	blt	a10, a8, 42012d9c <_svfiprintf_r+0x344>
42012d88:	000606        	j	42012da4 <_svfiprintf_r+0x34c>
42012d8b:	21a200        	srai	a10, a0, 2
42012d8e:	c61b91        	l32r	a9, 420045fc <esp_mprot_cpuid_valid+0x1c> (21e83987 <UserFrameTotalSize+0x21e83887>)
42012d91:	10c182        	addi	a8, a1, 16
42012d94:	2e26a7        	blt	a6, a10, 42012dc6 <_svfiprintf_r+0x36e>
42012d97:	000c46        	j	42012dcc <_svfiprintf_r+0x374>
42012d9a:	e00000        	subx4	a0, a0, a0
42012d9d:	b0ea      	add.n	a11, a0, a14
42012d9f:	0e88      	l32i.n	a8, a14, 0
42012da1:	000686        	j	42012dbf <_svfiprintf_r+0x367>
42012da4:	30a282        	movi	a8, 0x230
42012da7:	8e8a      	add.n	a8, a14, a8
42012da9:	34a2d2        	movi	a13, 0x234
42012dac:	40a2c2        	movi	a12, 0x240
42012daf:	0189      	s32i.n	a8, a1, 0
42012db1:	01def2        	addmi	a15, a14, 0x100
42012db4:	deda      	add.n	a13, a14, a13
42012db6:	ceca      	add.n	a12, a14, a12
42012db8:	07bd      	mov.n	a11, a7
42012dba:	ff6c25        	call8	4201247c <get_arg$isra$0>
42012dbd:	0a88      	l32i.n	a8, a10, 0
42012dbf:	049d      	mov.n	a9, a4
42012dc1:	06cd      	mov.n	a12, a6
42012dc3:	001c46        	j	42012e38 <_svfiprintf_r+0x3e0>
42012dc6:	b08580        	addx8	a8, a5, a8
42012dc9:	001a46        	j	42012e36 <_svfiprintf_r+0x3de>
42012dcc:	fb1c      	movi.n	a11, 31
42012dce:	362ba7        	blt	a11, a10, 42012e08 <_svfiprintf_r+0x3b0>
42012dd1:	9228e2        	l32i	a14, a8, 0x248
42012dd4:	ba1b      	addi.n	a11, a10, 1
42012dd6:	9161b2        	s32i	a11, a1, 0x244
42012dd9:	be4b      	addi.n	a11, a14, 4
42012ddb:	9268b2        	s32i	a11, a8, 0x248
42012dde:	8f1c      	movi.n	a15, 24
42012de0:	052fb7        	blt	a15, a11, 42012de9 <_svfiprintf_r+0x391>
42012de3:	912882        	l32i	a8, a8, 0x244
42012de6:	000346        	j	42012df7 <_svfiprintf_r+0x39f>
42012de9:	012fe7        	blt	a15, a14, 42012dee <_svfiprintf_r+0x396>
42012dec:	4b2c      	movi.n	a11, 36
42012dee:	9268b2        	s32i	a11, a8, 0x248
42012df1:	02d882        	addmi	a8, a8, 0x200
42012df4:	102882        	l32i	a8, a8, 64
42012df7:	88ba      	add.n	a8, a8, a11
42012df9:	fcc882        	addi	a8, a8, -4
42012dfc:	0888      	l32i.n	a8, a8, 0
42012dfe:	b0aa10        	addx8	a10, a10, a1
42012e01:	4a89      	s32i.n	a8, a10, 16
42012e03:	000c46        	j	42012e38 <_svfiprintf_r+0x3e0>
42012e06:	b20000        	mulsh	a0, a0, a0
42012e09:	9228      	l32i.n	a2, a2, 36
42012e0b:	8d1c      	movi.n	a13, 24
42012e0d:	ab4b      	addi.n	a10, a11, 4
42012e0f:	9268a2        	s32i	a10, a8, 0x248
42012e12:	02d882        	addmi	a8, a8, 0x200
42012e15:	072da7        	blt	a13, a10, 42012e20 <_svfiprintf_r+0x3c8>
42012e18:	112882        	l32i	a8, a8, 68
42012e1b:	000486        	j	42012e31 <_svfiprintf_r+0x3d9>
42012e1e:	b70000        	lsi	f0, a0, 0x2dc
42012e21:	012d      	mov.n	a2, a1
42012e23:	4a2c      	movi.n	a10, 36
42012e25:	10c182        	addi	a8, a1, 16
42012e28:	02d882        	addmi	a8, a8, 0x200
42012e2b:	102882        	l32i	a8, a8, 64
42012e2e:	9661a2        	s32i	a10, a1, 0x258
42012e31:	88aa      	add.n	a8, a8, a10
42012e33:	fcc882        	addi	a8, a8, -4
42012e36:	0888      	l32i.n	a8, a8, 0
42012e38:	fa7c      	movi.n	a10, -1
42012e3a:	5388a0        	max	a8, a8, a10
42012e3d:	9b6182        	s32i	a8, a1, 0x26c
42012e40:	0c6d      	mov.n	a6, a12
42012e42:	9a6192        	s32i	a9, a1, 0x268
42012e45:	ff5146        	j	42012b8e <_svfiprintf_r+0x136>
42012e48:	a08880        	addx4	a8, a8, a8
42012e4b:	000942        	l8ui	a4, a9, 0
42012e4e:	9088b0        	addx2	a8, a8, a11
42012e51:	991b      	addi.n	a9, a9, 1
42012e53:	9a6192        	s32i	a9, a1, 0x268
42012e56:	d0c4b2        	addi	a11, a4, -48
42012e59:	ebbcb7        	bgeu	a12, a11, 42012e48 <_svfiprintf_r+0x3f0>
42012e5c:	f97c      	movi.n	a9, -1
42012e5e:	538890        	max	a8, a8, a9
42012e61:	9b6182        	s32i	a8, a1, 0x26c
42012e64:	9e2182        	l32i	a8, a1, 0x278
42012e67:	ff4d46        	j	42012ba0 <_svfiprintf_r+0x148>
42012e6a:	80a082        	movi	a8, 128
42012e6d:	001c86        	j	42012ee3 <_svfiprintf_r+0x48b>
42012e70:	080c      	movi.n	a8, 0
42012e72:	9b0c      	movi.n	a11, 9
42012e74:	9a2192        	l32i	a9, a1, 0x268
42012e77:	d0c442        	addi	a4, a4, -48
42012e7a:	a08880        	addx4	a8, a8, a8
42012e7d:	908840        	addx2	a8, a8, a4
42012e80:	000942        	l8ui	a4, a9, 0
42012e83:	991b      	addi.n	a9, a9, 1
42012e85:	9a6192        	s32i	a9, a1, 0x268
42012e88:	d0c492        	addi	a9, a4, -48
42012e8b:	e5bb97        	bgeu	a11, a9, 42012e74 <_svfiprintf_r+0x41c>
42012e8e:	492c      	movi.n	a9, 36
42012e90:	021497        	beq	a4, a9, 42012e96 <_svfiprintf_r+0x43e>
42012e93:	ff4246        	j	42012ba0 <_svfiprintf_r+0x148>
42012e96:	092c      	movi.n	a9, 32
42012e98:	02a987        	bge	a9, a8, 42012e9e <_svfiprintf_r+0x446>
42012e9b:	060f46        	j	420146dc <_svfiprintf_r+0x1c84>
42012e9e:	580b      	addi.n	a5, a8, -1
42012ea0:	130c      	movi.n	a3, 1
42012ea2:	ff3a06        	j	42012b8e <_svfiprintf_r+0x136>
42012ea5:	218200        	srai	a8, a0, 2
42012ea8:	929a      	add.n	a9, a2, a9
42012eaa:	0008      	l32i.n	a0, a0, 0
42012eac:	68a082        	movi	a8, 104
42012eaf:	0d9987        	bne	a9, a8, 42012ec0 <_svfiprintf_r+0x468>
42012eb2:	9a2182        	l32i	a8, a1, 0x268
42012eb5:	881b      	addi.n	a8, a8, 1
42012eb7:	9a6182        	s32i	a8, a1, 0x268
42012eba:	00a282        	movi	a8, 0x200
42012ebd:	000886        	j	42012ee3 <_svfiprintf_r+0x48b>
42012ec0:	084c      	movi.n	a8, 64
42012ec2:	000746        	j	42012ee3 <_svfiprintf_r+0x48b>
42012ec5:	9a2182        	l32i	a8, a1, 0x268
42012ec8:	000892        	l8ui	a9, a8, 0
42012ecb:	6ca082        	movi	a8, 108
42012ece:	0a9987        	bne	a9, a8, 42012edc <_svfiprintf_r+0x484>
42012ed1:	9a2182        	l32i	a8, a1, 0x268
42012ed4:	881b      	addi.n	a8, a8, 1
42012ed6:	9a6182        	s32i	a8, a1, 0x268
42012ed9:	000106        	j	42012ee1 <_svfiprintf_r+0x489>
42012edc:	081c      	movi.n	a8, 16
42012ede:	000046        	j	42012ee3 <_svfiprintf_r+0x48b>
42012ee1:	082c      	movi.n	a8, 32
42012ee3:	202280        	or	a2, a2, a8
42012ee6:	ff2906        	j	42012b8e <_svfiprintf_r+0x136>
42012ee9:	912182        	l32i	a8, a1, 0x244
42012eec:	10c1e2        	addi	a14, a1, 16
42012eef:	d3ac      	beqz.n	a3, 42012f20 <_svfiprintf_r+0x4c8>
42012ef1:	08a587        	bge	a5, a8, 42012efd <_svfiprintf_r+0x4a5>
42012ef4:	b0e5e0        	addx8	a14, a5, a14
42012ef7:	000e92        	l8ui	a9, a14, 0
42012efa:	000746        	j	42012f1b <_svfiprintf_r+0x4c3>
42012efd:	30a282        	movi	a8, 0x230
42012f00:	8e8a      	add.n	a8, a14, a8
42012f02:	34a2d2        	movi	a13, 0x234
42012f05:	40a2c2        	movi	a12, 0x240
42012f08:	0189      	s32i.n	a8, a1, 0
42012f0a:	01def2        	addmi	a15, a14, 0x100
42012f0d:	deda      	add.n	a13, a14, a13
42012f0f:	ceca      	add.n	a12, a14, a12
42012f11:	07bd      	mov.n	a11, a7
42012f13:	05ad      	mov.n	a10, a5
42012f15:	ff5665        	call8	4201247c <get_arg$isra$0>
42012f18:	000a92        	l8ui	a9, a10, 0
42012f1b:	067d      	mov.n	a7, a6
42012f1d:	001f06        	j	42012f9d <_svfiprintf_r+0x545>
42012f20:	761b      	addi.n	a7, a6, 1
42012f22:	0aa687        	bge	a6, a8, 42012f30 <_svfiprintf_r+0x4d8>
42012f25:	b0e5e0        	addx8	a14, a5, a14
42012f28:	000e92        	l8ui	a9, a14, 0
42012f2b:	001b86        	j	42012f9d <_svfiprintf_r+0x545>
42012f2e:	920000        	lsi	f0, a0, 0x248
42012f31:	2e          	.byte	0x2e
42012f32:	fb1c92        	l16ui	a9, a12, 0x1f6
42012f35:	02dee2        	addmi	a14, a14, 0x200
42012f38:	a94b      	addi.n	a10, a9, 4
42012f3a:	362b87        	blt	a11, a8, 42012f74 <_svfiprintf_r+0x51c>
42012f3d:	b81b      	addi.n	a11, a8, 1
42012f3f:	9161b2        	s32i	a11, a1, 0x244
42012f42:	126ea2        	s32i	a10, a14, 72
42012f45:	8b1c      	movi.n	a11, 24
42012f47:	052ba7        	blt	a11, a10, 42012f50 <_svfiprintf_r+0x4f8>
42012f4a:	112e92        	l32i	a9, a14, 68
42012f4d:	000406        	j	42012f61 <_svfiprintf_r+0x509>
42012f50:	012b97        	blt	a11, a9, 42012f55 <_svfiprintf_r+0x4fd>
42012f53:	4a2c      	movi.n	a10, 36
42012f55:	10c192        	addi	a9, a1, 16
42012f58:	02d992        	addmi	a9, a9, 0x200
42012f5b:	102992        	l32i	a9, a9, 64
42012f5e:	9661a2        	s32i	a10, a1, 0x258
42012f61:	99aa      	add.n	a9, a9, a10
42012f63:	fcc992        	addi	a9, a9, -4
42012f66:	0998      	l32i.n	a9, a9, 0
42012f68:	b08810        	addx8	a8, a8, a1
42012f6b:	4899      	s32i.n	a9, a8, 16
42012f6d:	749090        	extui	a9, a9, 0, 8
42012f70:	000a46        	j	42012f9d <_svfiprintf_r+0x545>
42012f73:	6ea200        	f64rnd	a10, a2, a0, 2
42012f76:	881c12        	l16ui	a1, a12, 0x110
42012f79:	0728a7        	blt	a8, a10, 42012f84 <_svfiprintf_r+0x52c>
42012f7c:	112e82        	l32i	a8, a14, 68
42012f7f:	000486        	j	42012f95 <_svfiprintf_r+0x53d>
42012f82:	970000        	lsi	f0, a0, 0x25c
42012f85:	0128      	l32i.n	a2, a1, 0
42012f87:	4a2c      	movi.n	a10, 36
42012f89:	10c182        	addi	a8, a1, 16
42012f8c:	02d882        	addmi	a8, a8, 0x200
42012f8f:	102882        	l32i	a8, a8, 64
42012f92:	9661a2        	s32i	a10, a1, 0x258
42012f95:	88aa      	add.n	a8, a8, a10
42012f97:	fcc882        	addi	a8, a8, -4
42012f9a:	000892        	l8ui	a9, a8, 0
42012f9d:	10c182        	addi	a8, a1, 16
42012fa0:	01d8a2        	addmi	a10, a8, 0x100
42012fa3:	804a92        	s8i	a9, a10, 128
42012fa6:	02d892        	addmi	a9, a8, 0x200
42012fa9:	0a0c      	movi.n	a10, 0
42012fab:	3a49a2        	s8i	a10, a9, 58
42012fae:	048c06        	j	420141e2 <_svfiprintf_r+0x178a>
42012fb1:	081c      	movi.n	a8, 16
42012fb3:	202280        	or	a2, a2, a8
42012fb6:	912182        	l32i	a8, a1, 0x244
42012fb9:	10c1e2        	addi	a14, a1, 16
42012fbc:	02e257        	bbsi	a2, 5, 42012fc2 <_svfiprintf_r+0x56a>
42012fbf:	002f86        	j	42013081 <_svfiprintf_r+0x629>
42012fc2:	f3ac      	beqz.n	a3, 42012ff5 <_svfiprintf_r+0x59d>
42012fc4:	09a587        	bge	a5, a8, 42012fd1 <_svfiprintf_r+0x579>
42012fc7:	b0e5e0        	addx8	a14, a5, a14
42012fca:	0e58      	l32i.n	a5, a14, 0
42012fcc:	1e38      	l32i.n	a3, a14, 4
42012fce:	000786        	j	42012ff0 <_svfiprintf_r+0x598>
42012fd1:	30a282        	movi	a8, 0x230
42012fd4:	8e8a      	add.n	a8, a14, a8
42012fd6:	34a2d2        	movi	a13, 0x234
42012fd9:	40a2c2        	movi	a12, 0x240
42012fdc:	05ad      	mov.n	a10, a5
42012fde:	0189      	s32i.n	a8, a1, 0
42012fe0:	01def2        	addmi	a15, a14, 0x100
42012fe3:	deda      	add.n	a13, a14, a13
42012fe5:	ceca      	add.n	a12, a14, a12
42012fe7:	07bd      	mov.n	a11, a7
42012fe9:	ff4925        	call8	4201247c <get_arg$isra$0>
42012fec:	0a58      	l32i.n	a5, a10, 0
42012fee:	1a38      	l32i.n	a3, a10, 4
42012ff0:	067d      	mov.n	a7, a6
42012ff2:	00a946        	j	4201329b <_svfiprintf_r+0x843>
42012ff5:	761b      	addi.n	a7, a6, 1
42012ff7:	09a687        	bge	a6, a8, 42013004 <_svfiprintf_r+0x5ac>
42012ffa:	b0e5e0        	addx8	a14, a5, a14
42012ffd:	0e58      	l32i.n	a5, a14, 0
42012fff:	1e38      	l32i.n	a3, a14, 4
42013001:	00a586        	j	4201329b <_svfiprintf_r+0x843>
42013004:	922e92        	l32i	a9, a14, 0x248
42013007:	8a7c      	movi.n	a10, -8
42013009:	997b      	addi.n	a9, a9, 7
4201300b:	1099a0        	and	a9, a9, a10
4201300e:	fb1c      	movi.n	a11, 31
42013010:	02dee2        	addmi	a14, a14, 0x200
42013013:	a98b      	addi.n	a10, a9, 8
42013015:	3b2b87        	blt	a11, a8, 42013054 <_svfiprintf_r+0x5fc>
42013018:	b81b      	addi.n	a11, a8, 1
4201301a:	9161b2        	s32i	a11, a1, 0x244
4201301d:	126ea2        	s32i	a10, a14, 72
42013020:	8b1c      	movi.n	a11, 24
42013022:	062ba7        	blt	a11, a10, 4201302c <_svfiprintf_r+0x5d4>
42013025:	112e92        	l32i	a9, a14, 68
42013028:	000446        	j	4201303d <_svfiprintf_r+0x5e5>
4201302b:	2b9700        	oeq.s	b9, f7, f0
4201302e:	8a2c01        	l32r	a0, 41ff58e0 <_coredump_iram_end+0x1c739e0>
42013031:	10c192        	addi	a9, a1, 16
42013034:	02d992        	addmi	a9, a9, 0x200
42013037:	102992        	l32i	a9, a9, 64
4201303a:	9661a2        	s32i	a10, a1, 0x258
4201303d:	99aa      	add.n	a9, a9, a10
4201303f:	f8c992        	addi	a9, a9, -8
42013042:	0958      	l32i.n	a5, a9, 0
42013044:	1938      	l32i.n	a3, a9, 4
42013046:	10c192        	addi	a9, a1, 16
42013049:	b08890        	addx8	a8, a8, a9
4201304c:	0859      	s32i.n	a5, a8, 0
4201304e:	1839      	s32i.n	a3, a8, 4
42013050:	0091c6        	j	4201329b <_svfiprintf_r+0x843>
42013053:	6ea200        	f64rnd	a10, a2, a0, 2
42013056:	881c12        	l16ui	a1, a12, 0x110
42013059:	0728a7        	blt	a8, a10, 42013064 <_svfiprintf_r+0x60c>
4201305c:	112e82        	l32i	a8, a14, 68
4201305f:	000486        	j	42013075 <_svfiprintf_r+0x61d>
42013062:	970000        	lsi	f0, a0, 0x25c
42013065:	0128      	l32i.n	a2, a1, 0
42013067:	8a2c      	movi.n	a10, 40
42013069:	10c182        	addi	a8, a1, 16
4201306c:	02d882        	addmi	a8, a8, 0x200
4201306f:	102882        	l32i	a8, a8, 64
42013072:	9661a2        	s32i	a10, a1, 0x258
42013075:	88aa      	add.n	a8, a8, a10
42013077:	f8c882        	addi	a8, a8, -8
4201307a:	0858      	l32i.n	a5, a8, 0
4201307c:	1838      	l32i.n	a3, a8, 4
4201307e:	008646        	j	4201329b <_svfiprintf_r+0x843>
42013081:	036247        	bbci	a2, 4, 42013088 <_svfiprintf_r+0x630>
42013084:	005b06        	j	420131f4 <_svfiprintf_r+0x79c>
42013087:	e26700        	remu	a6, a7, a0
4201308a:	2a8602        	lsi	f0, a6, 168
4201308d:	c3ac00        	movf	a10, a12, b0
42013090:	09a587        	bge	a5, a8, 4201309d <_svfiprintf_r+0x645>
42013093:	b0e5e0        	addx8	a14, a5, a14
42013096:	009e52        	l16si	a5, a14, 0
42013099:	006046        	j	4201321e <_svfiprintf_r+0x7c6>
4201309c:	a28200        	muluh	a8, a2, a0
4201309f:	8e8a30        	f64iter	a8, a10, a3, 0, 0
420130a2:	34a2d2        	movi	a13, 0x234
420130a5:	40a2c2        	movi	a12, 0x240
420130a8:	05ad      	mov.n	a10, a5
420130aa:	0189      	s32i.n	a8, a1, 0
420130ac:	01def2        	addmi	a15, a14, 0x100
420130af:	deda      	add.n	a13, a14, a13
420130b1:	ceca      	add.n	a12, a14, a12
420130b3:	07bd      	mov.n	a11, a7
420130b5:	ff3c65        	call8	4201247c <get_arg$isra$0>
420130b8:	009a52        	l16si	a5, a10, 0
420130bb:	0057c6        	j	4201321e <_svfiprintf_r+0x7c6>
420130be:	761b      	addi.n	a7, a6, 1
420130c0:	08a687        	bge	a6, a8, 420130cc <_svfiprintf_r+0x674>
420130c3:	b0e5e0        	addx8	a14, a5, a14
420130c6:	009e52        	l16si	a5, a14, 0
420130c9:	0072c6        	j	42013298 <_svfiprintf_r+0x840>
420130cc:	922e92        	l32i	a9, a14, 0x248
420130cf:	fb1c      	movi.n	a11, 31
420130d1:	02dee2        	addmi	a14, a14, 0x200
420130d4:	a94b      	addi.n	a10, a9, 4
420130d6:	352b87        	blt	a11, a8, 4201310f <_svfiprintf_r+0x6b7>
420130d9:	b81b      	addi.n	a11, a8, 1
420130db:	9161b2        	s32i	a11, a1, 0x244
420130de:	126ea2        	s32i	a10, a14, 72
420130e1:	8b1c      	movi.n	a11, 24
420130e3:	052ba7        	blt	a11, a10, 420130ec <_svfiprintf_r+0x694>
420130e6:	112e92        	l32i	a9, a14, 68
420130e9:	000406        	j	420130fd <_svfiprintf_r+0x6a5>
420130ec:	012b97        	blt	a11, a9, 420130f1 <_svfiprintf_r+0x699>
420130ef:	4a2c      	movi.n	a10, 36
420130f1:	10c192        	addi	a9, a1, 16
420130f4:	02d992        	addmi	a9, a9, 0x200
420130f7:	102992        	l32i	a9, a9, 64
420130fa:	9661a2        	s32i	a10, a1, 0x258
420130fd:	99aa      	add.n	a9, a9, a10
420130ff:	fcc992        	addi	a9, a9, -4
42013102:	0958      	l32i.n	a5, a9, 0
42013104:	b08810        	addx8	a8, a8, a1
42013107:	4859      	s32i.n	a5, a8, 16
42013109:	235580        	sext	a5, a5, 15
4201310c:	006206        	j	42013298 <_svfiprintf_r+0x840>
4201310f:	126ea2        	s32i	a10, a14, 72
42013112:	881c      	movi.n	a8, 24
42013114:	0528a7        	blt	a8, a10, 4201311d <_svfiprintf_r+0x6c5>
42013117:	112e82        	l32i	a8, a14, 68
4201311a:	000406        	j	4201312e <_svfiprintf_r+0x6d6>
4201311d:	012897        	blt	a8, a9, 42013122 <_svfiprintf_r+0x6ca>
42013120:	4a2c      	movi.n	a10, 36
42013122:	10c182        	addi	a8, a1, 16
42013125:	02d882        	addmi	a8, a8, 0x200
42013128:	102882        	l32i	a8, a8, 64
4201312b:	9661a2        	s32i	a10, a1, 0x258
4201312e:	88aa      	add.n	a8, a8, a10
42013130:	fcc882        	addi	a8, a8, -4
42013133:	009852        	l16si	a5, a8, 0
42013136:	005786        	j	42013298 <_svfiprintf_r+0x840>
42013139:	02e297        	bbsi	a2, 9, 4201313f <_svfiprintf_r+0x6e7>
4201313c:	002d06        	j	420131f4 <_svfiprintf_r+0x79c>
4201313f:	d3ac      	beqz.n	a3, 42013170 <_svfiprintf_r+0x718>
42013141:	08a587        	bge	a5, a8, 4201314d <_svfiprintf_r+0x6f5>
42013144:	b0e5e0        	addx8	a14, a5, a14
42013147:	000e52        	l8ui	a5, a14, 0
4201314a:	000746        	j	4201316b <_svfiprintf_r+0x713>
4201314d:	30a282        	movi	a8, 0x230
42013150:	8e8a      	add.n	a8, a14, a8
42013152:	34a2d2        	movi	a13, 0x234
42013155:	40a2c2        	movi	a12, 0x240
42013158:	05ad      	mov.n	a10, a5
4201315a:	0189      	s32i.n	a8, a1, 0
4201315c:	01def2        	addmi	a15, a14, 0x100
4201315f:	deda      	add.n	a13, a14, a13
42013161:	ceca      	add.n	a12, a14, a12
42013163:	07bd      	mov.n	a11, a7
42013165:	ff3165        	call8	4201247c <get_arg$isra$0>
42013168:	000a52        	l8ui	a5, a10, 0
4201316b:	067d      	mov.n	a7, a6
4201316d:	001f06        	j	420131ed <_svfiprintf_r+0x795>
42013170:	761b      	addi.n	a7, a6, 1
42013172:	0aa687        	bge	a6, a8, 42013180 <_svfiprintf_r+0x728>
42013175:	b0e5e0        	addx8	a14, a5, a14
42013178:	000e52        	l8ui	a5, a14, 0
4201317b:	001b86        	j	420131ed <_svfiprintf_r+0x795>
4201317e:	920000        	lsi	f0, a0, 0x248
42013181:	2e          	.byte	0x2e
42013182:	fb1c92        	l16ui	a9, a12, 0x1f6
42013185:	02dee2        	addmi	a14, a14, 0x200
42013188:	a94b      	addi.n	a10, a9, 4
4201318a:	362b87        	blt	a11, a8, 420131c4 <_svfiprintf_r+0x76c>
4201318d:	b81b      	addi.n	a11, a8, 1
4201318f:	9161b2        	s32i	a11, a1, 0x244
42013192:	126ea2        	s32i	a10, a14, 72
42013195:	8b1c      	movi.n	a11, 24
42013197:	052ba7        	blt	a11, a10, 420131a0 <_svfiprintf_r+0x748>
4201319a:	112e92        	l32i	a9, a14, 68
4201319d:	000406        	j	420131b1 <_svfiprintf_r+0x759>
420131a0:	012b97        	blt	a11, a9, 420131a5 <_svfiprintf_r+0x74d>
420131a3:	4a2c      	movi.n	a10, 36
420131a5:	10c192        	addi	a9, a1, 16
420131a8:	02d992        	addmi	a9, a9, 0x200
420131ab:	102992        	l32i	a9, a9, 64
420131ae:	9661a2        	s32i	a10, a1, 0x258
420131b1:	99aa      	add.n	a9, a9, a10
420131b3:	fcc992        	addi	a9, a9, -4
420131b6:	0958      	l32i.n	a5, a9, 0
420131b8:	b08810        	addx8	a8, a8, a1
420131bb:	4859      	s32i.n	a5, a8, 16
420131bd:	745050        	extui	a5, a5, 0, 8
420131c0:	000a46        	j	420131ed <_svfiprintf_r+0x795>
420131c3:	6ea200        	f64rnd	a10, a2, a0, 2
420131c6:	881c12        	l16ui	a1, a12, 0x110
420131c9:	0728a7        	blt	a8, a10, 420131d4 <_svfiprintf_r+0x77c>
420131cc:	112e82        	l32i	a8, a14, 68
420131cf:	000486        	j	420131e5 <_svfiprintf_r+0x78d>
420131d2:	970000        	lsi	f0, a0, 0x25c
420131d5:	0128      	l32i.n	a2, a1, 0
420131d7:	4a2c      	movi.n	a10, 36
420131d9:	10c182        	addi	a8, a1, 16
420131dc:	02d882        	addmi	a8, a8, 0x200
420131df:	102882        	l32i	a8, a8, 64
420131e2:	9661a2        	s32i	a10, a1, 0x258
420131e5:	88aa      	add.n	a8, a8, a10
420131e7:	fcc882        	addi	a8, a8, -4
420131ea:	000852        	l8ui	a5, a8, 0
420131ed:	235500        	sext	a5, a5, 7
420131f0:	002906        	j	42013298 <_svfiprintf_r+0x840>
420131f3:	b3ac00        	movgez	a10, a12, a0
420131f6:	07a587        	bge	a5, a8, 42013201 <_svfiprintf_r+0x7a9>
420131f9:	b0e5e0        	addx8	a14, a5, a14
420131fc:	0e58      	l32i.n	a5, a14, 0
420131fe:	000706        	j	4201321e <_svfiprintf_r+0x7c6>
42013201:	30a282        	movi	a8, 0x230
42013204:	8e8a      	add.n	a8, a14, a8
42013206:	34a2d2        	movi	a13, 0x234
42013209:	40a2c2        	movi	a12, 0x240
4201320c:	05ad      	mov.n	a10, a5
4201320e:	0189      	s32i.n	a8, a1, 0
42013210:	01def2        	addmi	a15, a14, 0x100
42013213:	deda      	add.n	a13, a14, a13
42013215:	ceca      	add.n	a12, a14, a12
42013217:	07bd      	mov.n	a11, a7
42013219:	ff2625        	call8	4201247c <get_arg$isra$0>
4201321c:	0a58      	l32i.n	a5, a10, 0
4201321e:	067d      	mov.n	a7, a6
42013220:	001d06        	j	42013298 <_svfiprintf_r+0x840>
42013223:	761b      	addi.n	a7, a6, 1
42013225:	07a687        	bge	a6, a8, 42013230 <_svfiprintf_r+0x7d8>
42013228:	b0e5e0        	addx8	a14, a5, a14
4201322b:	0e58      	l32i.n	a5, a14, 0
4201322d:	0019c6        	j	42013298 <_svfiprintf_r+0x840>
42013230:	922e92        	l32i	a9, a14, 0x248
42013233:	fb1c      	movi.n	a11, 31
42013235:	02dee2        	addmi	a14, a14, 0x200
42013238:	a94b      	addi.n	a10, a9, 4
4201323a:	322b87        	blt	a11, a8, 42013270 <_svfiprintf_r+0x818>
4201323d:	b81b      	addi.n	a11, a8, 1
4201323f:	9161b2        	s32i	a11, a1, 0x244
42013242:	126ea2        	s32i	a10, a14, 72
42013245:	8b1c      	movi.n	a11, 24
42013247:	052ba7        	blt	a11, a10, 42013250 <_svfiprintf_r+0x7f8>
4201324a:	112e92        	l32i	a9, a14, 68
4201324d:	000406        	j	42013261 <_svfiprintf_r+0x809>
42013250:	012b97        	blt	a11, a9, 42013255 <_svfiprintf_r+0x7fd>
42013253:	4a2c      	movi.n	a10, 36
42013255:	10c192        	addi	a9, a1, 16
42013258:	02d992        	addmi	a9, a9, 0x200
4201325b:	102992        	l32i	a9, a9, 64
4201325e:	9661a2        	s32i	a10, a1, 0x258
42013261:	99aa      	add.n	a9, a9, a10
42013263:	fcc992        	addi	a9, a9, -4
42013266:	0958      	l32i.n	a5, a9, 0
42013268:	b08810        	addx8	a8, a8, a1
4201326b:	4859      	s32i.n	a5, a8, 16
4201326d:	0009c6        	j	42013298 <_svfiprintf_r+0x840>
42013270:	126ea2        	s32i	a10, a14, 72
42013273:	881c      	movi.n	a8, 24
42013275:	0728a7        	blt	a8, a10, 42013280 <_svfiprintf_r+0x828>
42013278:	112e82        	l32i	a8, a14, 68
4201327b:	000486        	j	42013291 <_svfiprintf_r+0x839>
4201327e:	970000        	lsi	f0, a0, 0x25c
42013281:	0128      	l32i.n	a2, a1, 0
42013283:	4a2c      	movi.n	a10, 36
42013285:	10c182        	addi	a8, a1, 16
42013288:	02d882        	addmi	a8, a8, 0x200
4201328b:	102882        	l32i	a8, a8, 64
4201328e:	9661a2        	s32i	a10, a1, 0x258
42013291:	88aa      	add.n	a8, a8, a10
42013293:	fcc882        	addi	a8, a8, -4
42013296:	0858      	l32i.n	a5, a8, 0
42013298:	313f50        	srai	a3, a5, 31
4201329b:	002396        	bltz	a3, 420132a1 <_svfiprintf_r+0x849>
4201329e:	0512c6        	j	420146ed <_svfiprintf_r+0x1c95>
420132a1:	603030        	neg	a3, a3
420132a4:	058c      	beqz.n	a5, 420132a8 <_svfiprintf_r+0x850>
420132a6:	330b      	addi.n	a3, a3, -1
420132a8:	605050        	neg	a5, a5
420132ab:	d82c      	movi.n	a8, 45
420132ad:	190c      	movi.n	a9, 1
420132af:	036006        	j	42014033 <_svfiprintf_r+0x15db>
420132b2:	820000        	mull	a0, a0, a0
420132b5:	e29121        	l32r	a2, 4200bcfc <_vfprintf_r+0x21c> (a121a206 <_rtc_reserved_end+0x4111a206>)
420132b8:	5710c1        	l32r	a12, 41fe8ef8 <_coredump_iram_end+0x1c66ff8>
420132bb:	c602e2        	l8ui	a14, a2, 198
420132be:	002b      	addi.n	a0, a0, 2
420132c0:	c3ac      	beqz.n	a3, 420132f0 <_svfiprintf_r+0x898>
420132c2:	07a587        	bge	a5, a8, 420132cd <_svfiprintf_r+0x875>
420132c5:	b0e5e0        	addx8	a14, a5, a14
420132c8:	0e98      	l32i.n	a9, a14, 0
420132ca:	000706        	j	420132ea <_svfiprintf_r+0x892>
420132cd:	30a282        	movi	a8, 0x230
420132d0:	8e8a      	add.n	a8, a14, a8
420132d2:	34a2d2        	movi	a13, 0x234
420132d5:	40a2c2        	movi	a12, 0x240
420132d8:	0189      	s32i.n	a8, a1, 0
420132da:	01def2        	addmi	a15, a14, 0x100
420132dd:	deda      	add.n	a13, a14, a13
420132df:	ceca      	add.n	a12, a14, a12
420132e1:	07bd      	mov.n	a11, a7
420132e3:	05ad      	mov.n	a10, a5
420132e5:	ff1965        	call8	4201247c <get_arg$isra$0>
420132e8:	0a98      	l32i.n	a9, a10, 0
420132ea:	06ad      	mov.n	a10, a6
420132ec:	001cc6        	j	42013363 <_svfiprintf_r+0x90b>
420132ef:	a61b00        	lsi	f0, a11, 0x298
420132f2:	07a687        	bge	a6, a8, 420132fd <_svfiprintf_r+0x8a5>
420132f5:	b0e5e0        	addx8	a14, a5, a14
420132f8:	0e98      	l32i.n	a9, a14, 0
420132fa:	001946        	j	42013363 <_svfiprintf_r+0x90b>
420132fd:	922e92        	l32i	a9, a14, 0x248
42013300:	fc1c      	movi.n	a12, 31
42013302:	02dee2        	addmi	a14, a14, 0x200
42013305:	b94b      	addi.n	a11, a9, 4
42013307:	322c87        	blt	a12, a8, 4201333d <_svfiprintf_r+0x8e5>
4201330a:	c81b      	addi.n	a12, a8, 1
4201330c:	9161c2        	s32i	a12, a1, 0x244
4201330f:	126eb2        	s32i	a11, a14, 72
42013312:	8c1c      	movi.n	a12, 24
42013314:	052cb7        	blt	a12, a11, 4201331d <_svfiprintf_r+0x8c5>
42013317:	112e92        	l32i	a9, a14, 68
4201331a:	000406        	j	4201332e <_svfiprintf_r+0x8d6>
4201331d:	012c97        	blt	a12, a9, 42013322 <_svfiprintf_r+0x8ca>
42013320:	4b2c      	movi.n	a11, 36
42013322:	10c192        	addi	a9, a1, 16
42013325:	02d992        	addmi	a9, a9, 0x200
42013328:	102992        	l32i	a9, a9, 64
4201332b:	9661b2        	s32i	a11, a1, 0x258
4201332e:	99ba      	add.n	a9, a9, a11
42013330:	fcc992        	addi	a9, a9, -4
42013333:	0998      	l32i.n	a9, a9, 0
42013335:	b08810        	addx8	a8, a8, a1
42013338:	4899      	s32i.n	a9, a8, 16
4201333a:	000946        	j	42013363 <_svfiprintf_r+0x90b>
4201333d:	126eb2        	s32i	a11, a14, 72
42013340:	881c      	movi.n	a8, 24
42013342:	0528b7        	blt	a8, a11, 4201334b <_svfiprintf_r+0x8f3>
42013345:	112e82        	l32i	a8, a14, 68
42013348:	000406        	j	4201335c <_svfiprintf_r+0x904>
4201334b:	012897        	blt	a8, a9, 42013350 <_svfiprintf_r+0x8f8>
4201334e:	4b2c      	movi.n	a11, 36
42013350:	10c182        	addi	a8, a1, 16
42013353:	02d882        	addmi	a8, a8, 0x200
42013356:	102882        	l32i	a8, a8, 64
42013359:	9661b2        	s32i	a11, a1, 0x258
4201335c:	88ba      	add.n	a8, a8, a11
4201335e:	fcc882        	addi	a8, a8, -4
42013361:	0898      	l32i.n	a9, a8, 0
42013363:	9f2182        	l32i	a8, a1, 0x27c
42013366:	0989      	s32i.n	a8, a9, 0
42013368:	318f80        	srai	a8, a8, 31
4201336b:	1989      	s32i.n	a8, a9, 4
4201336d:	0086c6        	j	4201358c <_svfiprintf_r+0xb34>
42013370:	046247        	bbci	a2, 4, 42013378 <_svfiprintf_r+0x920>
42013373:	005a86        	j	420134e1 <_svfiprintf_r+0xa89>
42013376:	670000        	lsi	f0, a0, 0x19c
42013379:	8602e2        	l8ui	a14, a2, 134
4201337c:	002b      	addi.n	a0, a0, 2
4201337e:	e3ac      	beqz.n	a3, 420133b0 <_svfiprintf_r+0x958>
42013380:	09a587        	bge	a5, a8, 4201338d <_svfiprintf_r+0x935>
42013383:	b0e5e0        	addx8	a14, a5, a14
42013386:	0e98      	l32i.n	a9, a14, 0
42013388:	000786        	j	420133aa <_svfiprintf_r+0x952>
4201338b:	820000        	mull	a0, a0, a0
4201338e:	8a30a2        	lsi	f10, a0, 0x228
42013391:	8e          	.byte	0x8e
42013392:	34a2d2        	movi	a13, 0x234
42013395:	40a2c2        	movi	a12, 0x240
42013398:	0189      	s32i.n	a8, a1, 0
4201339a:	01def2        	addmi	a15, a14, 0x100
4201339d:	deda      	add.n	a13, a14, a13
4201339f:	ceca      	add.n	a12, a14, a12
420133a1:	07bd      	mov.n	a11, a7
420133a3:	05ad      	mov.n	a10, a5
420133a5:	ff0d65        	call8	4201247c <get_arg$isra$0>
420133a8:	0a98      	l32i.n	a9, a10, 0
420133aa:	06ad      	mov.n	a10, a6
420133ac:	001d06        	j	42013424 <_svfiprintf_r+0x9cc>
420133af:	a61b00        	lsi	f0, a11, 0x298
420133b2:	07a687        	bge	a6, a8, 420133bd <_svfiprintf_r+0x965>
420133b5:	b0e5e0        	addx8	a14, a5, a14
420133b8:	0e98      	l32i.n	a9, a14, 0
420133ba:	001986        	j	42013424 <_svfiprintf_r+0x9cc>
420133bd:	922e92        	l32i	a9, a14, 0x248
420133c0:	fc1c      	movi.n	a12, 31
420133c2:	02dee2        	addmi	a14, a14, 0x200
420133c5:	b94b      	addi.n	a11, a9, 4
420133c7:	322c87        	blt	a12, a8, 420133fd <_svfiprintf_r+0x9a5>
420133ca:	c81b      	addi.n	a12, a8, 1
420133cc:	9161c2        	s32i	a12, a1, 0x244
420133cf:	126eb2        	s32i	a11, a14, 72
420133d2:	8c1c      	movi.n	a12, 24
420133d4:	052cb7        	blt	a12, a11, 420133dd <_svfiprintf_r+0x985>
420133d7:	112e92        	l32i	a9, a14, 68
420133da:	000406        	j	420133ee <_svfiprintf_r+0x996>
420133dd:	012c97        	blt	a12, a9, 420133e2 <_svfiprintf_r+0x98a>
420133e0:	4b2c      	movi.n	a11, 36
420133e2:	10c192        	addi	a9, a1, 16
420133e5:	02d992        	addmi	a9, a9, 0x200
420133e8:	102992        	l32i	a9, a9, 64
420133eb:	9661b2        	s32i	a11, a1, 0x258
420133ee:	99ba      	add.n	a9, a9, a11
420133f0:	fcc992        	addi	a9, a9, -4
420133f3:	0998      	l32i.n	a9, a9, 0
420133f5:	b08810        	addx8	a8, a8, a1
420133f8:	4899      	s32i.n	a9, a8, 16
420133fa:	000986        	j	42013424 <_svfiprintf_r+0x9cc>
420133fd:	126eb2        	s32i	a11, a14, 72
42013400:	881c      	movi.n	a8, 24
42013402:	0628b7        	blt	a8, a11, 4201340c <_svfiprintf_r+0x9b4>
42013405:	112e82        	l32i	a8, a14, 68
42013408:	000446        	j	4201341d <_svfiprintf_r+0x9c5>
4201340b:	289700        	lsi	f0, a7, 160
4201340e:	4b2c01        	l32r	a0, 41fe60c0 <_coredump_iram_end+0x1c641c0>
42013411:	10c182        	addi	a8, a1, 16
42013414:	02d882        	addmi	a8, a8, 0x200
42013417:	102882        	l32i	a8, a8, 64
4201341a:	9661b2        	s32i	a11, a1, 0x258
4201341d:	88ba      	add.n	a8, a8, a11
4201341f:	fcc882        	addi	a8, a8, -4
42013422:	0898      	l32i.n	a9, a8, 0
42013424:	9f2182        	l32i	a8, a1, 0x27c
42013427:	005982        	s16i	a8, a9, 0
4201342a:	005786        	j	4201358c <_svfiprintf_r+0xb34>
4201342d:	02e297        	bbsi	a2, 9, 42013433 <_svfiprintf_r+0x9db>
42013430:	002b46        	j	420134e1 <_svfiprintf_r+0xa89>
42013433:	c3ac      	beqz.n	a3, 42013463 <_svfiprintf_r+0xa0b>
42013435:	08a587        	bge	a5, a8, 42013441 <_svfiprintf_r+0x9e9>
42013438:	b0e5e0        	addx8	a14, a5, a14
4201343b:	0e98      	l32i.n	a9, a14, 0
4201343d:	000746        	j	4201345e <_svfiprintf_r+0xa06>
42013440:	a28200        	muluh	a8, a2, a0
42013443:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42013446:	34a2d2        	movi	a13, 0x234
42013449:	40a2c2        	movi	a12, 0x240
4201344c:	0189      	s32i.n	a8, a1, 0
4201344e:	01def2        	addmi	a15, a14, 0x100
42013451:	deda      	add.n	a13, a14, a13
42013453:	ceca      	add.n	a12, a14, a12
42013455:	07bd      	mov.n	a11, a7
42013457:	05ad      	mov.n	a10, a5
42013459:	ff0225        	call8	4201247c <get_arg$isra$0>
4201345c:	0a98      	l32i.n	a9, a10, 0
4201345e:	06ad      	mov.n	a10, a6
42013460:	001d06        	j	420134d8 <_svfiprintf_r+0xa80>
42013463:	a61b      	addi.n	a10, a6, 1
42013465:	07a687        	bge	a6, a8, 42013470 <_svfiprintf_r+0xa18>
42013468:	b0e5e0        	addx8	a14, a5, a14
4201346b:	0e98      	l32i.n	a9, a14, 0
4201346d:	0019c6        	j	420134d8 <_svfiprintf_r+0xa80>
42013470:	922e92        	l32i	a9, a14, 0x248
42013473:	fc1c      	movi.n	a12, 31
42013475:	02dee2        	addmi	a14, a14, 0x200
42013478:	b94b      	addi.n	a11, a9, 4
4201347a:	322c87        	blt	a12, a8, 420134b0 <_svfiprintf_r+0xa58>
4201347d:	c81b      	addi.n	a12, a8, 1
4201347f:	9161c2        	s32i	a12, a1, 0x244
42013482:	126eb2        	s32i	a11, a14, 72
42013485:	8c1c      	movi.n	a12, 24
42013487:	052cb7        	blt	a12, a11, 42013490 <_svfiprintf_r+0xa38>
4201348a:	112e92        	l32i	a9, a14, 68
4201348d:	000406        	j	420134a1 <_svfiprintf_r+0xa49>
42013490:	012c97        	blt	a12, a9, 42013495 <_svfiprintf_r+0xa3d>
42013493:	4b2c      	movi.n	a11, 36
42013495:	10c192        	addi	a9, a1, 16
42013498:	02d992        	addmi	a9, a9, 0x200
4201349b:	102992        	l32i	a9, a9, 64
4201349e:	9661b2        	s32i	a11, a1, 0x258
420134a1:	99ba      	add.n	a9, a9, a11
420134a3:	fcc992        	addi	a9, a9, -4
420134a6:	0998      	l32i.n	a9, a9, 0
420134a8:	b08810        	addx8	a8, a8, a1
420134ab:	4899      	s32i.n	a9, a8, 16
420134ad:	0009c6        	j	420134d8 <_svfiprintf_r+0xa80>
420134b0:	126eb2        	s32i	a11, a14, 72
420134b3:	881c      	movi.n	a8, 24
420134b5:	0728b7        	blt	a8, a11, 420134c0 <_svfiprintf_r+0xa68>
420134b8:	112e82        	l32i	a8, a14, 68
420134bb:	000486        	j	420134d1 <_svfiprintf_r+0xa79>
420134be:	970000        	lsi	f0, a0, 0x25c
420134c1:	0128      	l32i.n	a2, a1, 0
420134c3:	4b2c      	movi.n	a11, 36
420134c5:	10c182        	addi	a8, a1, 16
420134c8:	02d882        	addmi	a8, a8, 0x200
420134cb:	102882        	l32i	a8, a8, 64
420134ce:	9661b2        	s32i	a11, a1, 0x258
420134d1:	88ba      	add.n	a8, a8, a11
420134d3:	fcc882        	addi	a8, a8, -4
420134d6:	0898      	l32i.n	a9, a8, 0
420134d8:	9f2182        	l32i	a8, a1, 0x27c
420134db:	004982        	s8i	a8, a9, 0
420134de:	002a86        	j	4201358c <_svfiprintf_r+0xb34>
420134e1:	f3ac      	beqz.n	a3, 42013514 <_svfiprintf_r+0xabc>
420134e3:	0aa587        	bge	a5, a8, 420134f1 <_svfiprintf_r+0xa99>
420134e6:	b0e5e0        	addx8	a14, a5, a14
420134e9:	0e98      	l32i.n	a9, a14, 0
420134eb:	0007c6        	j	4201350e <_svfiprintf_r+0xab6>
420134ee:	000000        	ill
420134f1:	30a282        	movi	a8, 0x230
420134f4:	8e8a      	add.n	a8, a14, a8
420134f6:	34a2d2        	movi	a13, 0x234
420134f9:	40a2c2        	movi	a12, 0x240
420134fc:	0189      	s32i.n	a8, a1, 0
420134fe:	01def2        	addmi	a15, a14, 0x100
42013501:	deda      	add.n	a13, a14, a13
42013503:	ceca      	add.n	a12, a14, a12
42013505:	07bd      	mov.n	a11, a7
42013507:	05ad      	mov.n	a10, a5
42013509:	fef725        	call8	4201247c <get_arg$isra$0>
4201350c:	0a98      	l32i.n	a9, a10, 0
4201350e:	06ad      	mov.n	a10, a6
42013510:	001cc6        	j	42013587 <_svfiprintf_r+0xb2f>
42013513:	a61b00        	lsi	f0, a11, 0x298
42013516:	07a687        	bge	a6, a8, 42013521 <_svfiprintf_r+0xac9>
42013519:	b0e5e0        	addx8	a14, a5, a14
4201351c:	0e98      	l32i.n	a9, a14, 0
4201351e:	001946        	j	42013587 <_svfiprintf_r+0xb2f>
42013521:	922e92        	l32i	a9, a14, 0x248
42013524:	fc1c      	movi.n	a12, 31
42013526:	02dee2        	addmi	a14, a14, 0x200
42013529:	b94b      	addi.n	a11, a9, 4
4201352b:	322c87        	blt	a12, a8, 42013561 <_svfiprintf_r+0xb09>
4201352e:	c81b      	addi.n	a12, a8, 1
42013530:	9161c2        	s32i	a12, a1, 0x244
42013533:	126eb2        	s32i	a11, a14, 72
42013536:	8c1c      	movi.n	a12, 24
42013538:	052cb7        	blt	a12, a11, 42013541 <_svfiprintf_r+0xae9>
4201353b:	112e92        	l32i	a9, a14, 68
4201353e:	000406        	j	42013552 <_svfiprintf_r+0xafa>
42013541:	012c97        	blt	a12, a9, 42013546 <_svfiprintf_r+0xaee>
42013544:	4b2c      	movi.n	a11, 36
42013546:	10c192        	addi	a9, a1, 16
42013549:	02d992        	addmi	a9, a9, 0x200
4201354c:	102992        	l32i	a9, a9, 64
4201354f:	9661b2        	s32i	a11, a1, 0x258
42013552:	99ba      	add.n	a9, a9, a11
42013554:	fcc992        	addi	a9, a9, -4
42013557:	0998      	l32i.n	a9, a9, 0
42013559:	b08810        	addx8	a8, a8, a1
4201355c:	4899      	s32i.n	a9, a8, 16
4201355e:	000946        	j	42013587 <_svfiprintf_r+0xb2f>
42013561:	126eb2        	s32i	a11, a14, 72
42013564:	881c      	movi.n	a8, 24
42013566:	0528b7        	blt	a8, a11, 4201356f <_svfiprintf_r+0xb17>
42013569:	112e82        	l32i	a8, a14, 68
4201356c:	000406        	j	42013580 <_svfiprintf_r+0xb28>
4201356f:	012897        	blt	a8, a9, 42013574 <_svfiprintf_r+0xb1c>
42013572:	4b2c      	movi.n	a11, 36
42013574:	10c182        	addi	a8, a1, 16
42013577:	02d882        	addmi	a8, a8, 0x200
4201357a:	102882        	l32i	a8, a8, 64
4201357d:	9661b2        	s32i	a11, a1, 0x258
42013580:	88ba      	add.n	a8, a8, a11
42013582:	fcc882        	addi	a8, a8, -4
42013585:	0898      	l32i.n	a9, a8, 0
42013587:	9f2182        	l32i	a8, a1, 0x27c
4201358a:	0989      	s32i.n	a8, a9, 0
4201358c:	0a6d      	mov.n	a6, a10
4201358e:	fd5286        	j	42012adc <_svfiprintf_r+0x84>
42013591:	081c      	movi.n	a8, 16
42013593:	202280        	or	a2, a2, a8
42013596:	912182        	l32i	a8, a1, 0x244
42013599:	10c1e2        	addi	a14, a1, 16
4201359c:	02e257        	bbsi	a2, 5, 420135a2 <_svfiprintf_r+0xb4a>
4201359f:	002f86        	j	42013661 <_svfiprintf_r+0xc09>
420135a2:	f3ac      	beqz.n	a3, 420135d5 <_svfiprintf_r+0xb7d>
420135a4:	09a587        	bge	a5, a8, 420135b1 <_svfiprintf_r+0xb59>
420135a7:	b0e5e0        	addx8	a14, a5, a14
420135aa:	0e58      	l32i.n	a5, a14, 0
420135ac:	1e38      	l32i.n	a3, a14, 4
420135ae:	000786        	j	420135d0 <_svfiprintf_r+0xb78>
420135b1:	30a282        	movi	a8, 0x230
420135b4:	8e8a      	add.n	a8, a14, a8
420135b6:	34a2d2        	movi	a13, 0x234
420135b9:	40a2c2        	movi	a12, 0x240
420135bc:	05ad      	mov.n	a10, a5
420135be:	0189      	s32i.n	a8, a1, 0
420135c0:	01def2        	addmi	a15, a14, 0x100
420135c3:	deda      	add.n	a13, a14, a13
420135c5:	ceca      	add.n	a12, a14, a12
420135c7:	07bd      	mov.n	a11, a7
420135c9:	feeb25        	call8	4201247c <get_arg$isra$0>
420135cc:	0a58      	l32i.n	a5, a10, 0
420135ce:	1a38      	l32i.n	a3, a10, 4
420135d0:	067d      	mov.n	a7, a6
420135d2:	00a806        	j	42013876 <_svfiprintf_r+0xe1e>
420135d5:	761b      	addi.n	a7, a6, 1
420135d7:	09a687        	bge	a6, a8, 420135e4 <_svfiprintf_r+0xb8c>
420135da:	b0e5e0        	addx8	a14, a5, a14
420135dd:	0e58      	l32i.n	a5, a14, 0
420135df:	1e38      	l32i.n	a3, a14, 4
420135e1:	00a446        	j	42013876 <_svfiprintf_r+0xe1e>
420135e4:	922e92        	l32i	a9, a14, 0x248
420135e7:	8a7c      	movi.n	a10, -8
420135e9:	997b      	addi.n	a9, a9, 7
420135eb:	1099a0        	and	a9, a9, a10
420135ee:	fb1c      	movi.n	a11, 31
420135f0:	02dee2        	addmi	a14, a14, 0x200
420135f3:	a98b      	addi.n	a10, a9, 8
420135f5:	3b2b87        	blt	a11, a8, 42013634 <_svfiprintf_r+0xbdc>
420135f8:	b81b      	addi.n	a11, a8, 1
420135fa:	9161b2        	s32i	a11, a1, 0x244
420135fd:	126ea2        	s32i	a10, a14, 72
42013600:	8b1c      	movi.n	a11, 24
42013602:	062ba7        	blt	a11, a10, 4201360c <_svfiprintf_r+0xbb4>
42013605:	112e92        	l32i	a9, a14, 68
42013608:	000446        	j	4201361d <_svfiprintf_r+0xbc5>
4201360b:	2b9700        	oeq.s	b9, f7, f0
4201360e:	8a2c01        	l32r	a0, 41ff5ec0 <_coredump_iram_end+0x1c73fc0>
42013611:	10c192        	addi	a9, a1, 16
42013614:	02d992        	addmi	a9, a9, 0x200
42013617:	102992        	l32i	a9, a9, 64
4201361a:	9661a2        	s32i	a10, a1, 0x258
4201361d:	99aa      	add.n	a9, a9, a10
4201361f:	f8c992        	addi	a9, a9, -8
42013622:	0958      	l32i.n	a5, a9, 0
42013624:	1938      	l32i.n	a3, a9, 4
42013626:	10c192        	addi	a9, a1, 16
42013629:	b08890        	addx8	a8, a8, a9
4201362c:	0859      	s32i.n	a5, a8, 0
4201362e:	1839      	s32i.n	a3, a8, 4
42013630:	009086        	j	42013876 <_svfiprintf_r+0xe1e>
42013633:	6ea200        	f64rnd	a10, a2, a0, 2
42013636:	881c12        	l16ui	a1, a12, 0x110
42013639:	0728a7        	blt	a8, a10, 42013644 <_svfiprintf_r+0xbec>
4201363c:	112e82        	l32i	a8, a14, 68
4201363f:	000486        	j	42013655 <_svfiprintf_r+0xbfd>
42013642:	970000        	lsi	f0, a0, 0x25c
42013645:	0128      	l32i.n	a2, a1, 0
42013647:	8a2c      	movi.n	a10, 40
42013649:	10c182        	addi	a8, a1, 16
4201364c:	02d882        	addmi	a8, a8, 0x200
4201364f:	102882        	l32i	a8, a8, 64
42013652:	9661a2        	s32i	a10, a1, 0x258
42013655:	88aa      	add.n	a8, a8, a10
42013657:	f8c882        	addi	a8, a8, -8
4201365a:	0858      	l32i.n	a5, a8, 0
4201365c:	1838      	l32i.n	a3, a8, 4
4201365e:	008506        	j	42013876 <_svfiprintf_r+0xe1e>
42013661:	036247        	bbci	a2, 4, 42013668 <_svfiprintf_r+0xc10>
42013664:	005a06        	j	420137d0 <_svfiprintf_r+0xd78>
42013667:	e26700        	remu	a6, a7, a0
4201366a:	2b4602        	s8i	a0, a6, 43
4201366d:	c3ac00        	movf	a10, a12, b0
42013670:	09a587        	bge	a5, a8, 4201367d <_svfiprintf_r+0xc25>
42013673:	b0e5e0        	addx8	a14, a5, a14
42013676:	001e52        	l16ui	a5, a14, 0
42013679:	005f46        	j	420137fa <_svfiprintf_r+0xda2>
4201367c:	a28200        	muluh	a8, a2, a0
4201367f:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42013682:	34a2d2        	movi	a13, 0x234
42013685:	40a2c2        	movi	a12, 0x240
42013688:	05ad      	mov.n	a10, a5
4201368a:	0189      	s32i.n	a8, a1, 0
4201368c:	01def2        	addmi	a15, a14, 0x100
4201368f:	deda      	add.n	a13, a14, a13
42013691:	ceca      	add.n	a12, a14, a12
42013693:	07bd      	mov.n	a11, a7
42013695:	fede65        	call8	4201247c <get_arg$isra$0>
42013698:	001a52        	l16ui	a5, a10, 0
4201369b:	0056c6        	j	420137fa <_svfiprintf_r+0xda2>
4201369e:	761b      	addi.n	a7, a6, 1
420136a0:	08a687        	bge	a6, a8, 420136ac <_svfiprintf_r+0xc54>
420136a3:	b0e5e0        	addx8	a14, a5, a14
420136a6:	001e52        	l16ui	a5, a14, 0
420136a9:	0071c6        	j	42013874 <_svfiprintf_r+0xe1c>
420136ac:	922e92        	l32i	a9, a14, 0x248
420136af:	fb1c      	movi.n	a11, 31
420136b1:	02dee2        	addmi	a14, a14, 0x200
420136b4:	a94b      	addi.n	a10, a9, 4
420136b6:	362b87        	blt	a11, a8, 420136f0 <_svfiprintf_r+0xc98>
420136b9:	b81b      	addi.n	a11, a8, 1
420136bb:	9161b2        	s32i	a11, a1, 0x244
420136be:	126ea2        	s32i	a10, a14, 72
420136c1:	8b1c      	movi.n	a11, 24
420136c3:	052ba7        	blt	a11, a10, 420136cc <_svfiprintf_r+0xc74>
420136c6:	112e92        	l32i	a9, a14, 68
420136c9:	000406        	j	420136dd <_svfiprintf_r+0xc85>
420136cc:	012b97        	blt	a11, a9, 420136d1 <_svfiprintf_r+0xc79>
420136cf:	4a2c      	movi.n	a10, 36
420136d1:	10c192        	addi	a9, a1, 16
420136d4:	02d992        	addmi	a9, a9, 0x200
420136d7:	102992        	l32i	a9, a9, 64
420136da:	9661a2        	s32i	a10, a1, 0x258
420136dd:	99aa      	add.n	a9, a9, a10
420136df:	fcc992        	addi	a9, a9, -4
420136e2:	0958      	l32i.n	a5, a9, 0
420136e4:	b08810        	addx8	a8, a8, a1
420136e7:	4859      	s32i.n	a5, a8, 16
420136e9:	f45050        	extui	a5, a5, 0, 16
420136ec:	006106        	j	42013874 <_svfiprintf_r+0xe1c>
420136ef:	6ea200        	f64rnd	a10, a2, a0, 2
420136f2:	881c12        	l16ui	a1, a12, 0x110
420136f5:	0728a7        	blt	a8, a10, 42013700 <_svfiprintf_r+0xca8>
420136f8:	112e82        	l32i	a8, a14, 68
420136fb:	000486        	j	42013711 <_svfiprintf_r+0xcb9>
420136fe:	970000        	lsi	f0, a0, 0x25c
42013701:	0128      	l32i.n	a2, a1, 0
42013703:	4a2c      	movi.n	a10, 36
42013705:	10c182        	addi	a8, a1, 16
42013708:	02d882        	addmi	a8, a8, 0x200
4201370b:	102882        	l32i	a8, a8, 64
4201370e:	9661a2        	s32i	a10, a1, 0x258
42013711:	88aa      	add.n	a8, a8, a10
42013713:	fcc882        	addi	a8, a8, -4
42013716:	001852        	l16ui	a5, a8, 0
42013719:	0055c6        	j	42013874 <_svfiprintf_r+0xe1c>
4201371c:	02e297        	bbsi	a2, 9, 42013722 <_svfiprintf_r+0xcca>
4201371f:	002b46        	j	420137d0 <_svfiprintf_r+0xd78>
42013722:	c3ac      	beqz.n	a3, 42013752 <_svfiprintf_r+0xcfa>
42013724:	09a587        	bge	a5, a8, 42013731 <_svfiprintf_r+0xcd9>
42013727:	b0e5e0        	addx8	a14, a5, a14
4201372a:	000e52        	l8ui	a5, a14, 0
4201372d:	003246        	j	420137fa <_svfiprintf_r+0xda2>
42013730:	a28200        	muluh	a8, a2, a0
42013733:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42013736:	34a2d2        	movi	a13, 0x234
42013739:	40a2c2        	movi	a12, 0x240
4201373c:	05ad      	mov.n	a10, a5
4201373e:	0189      	s32i.n	a8, a1, 0
42013740:	01def2        	addmi	a15, a14, 0x100
42013743:	deda      	add.n	a13, a14, a13
42013745:	ceca      	add.n	a12, a14, a12
42013747:	07bd      	mov.n	a11, a7
42013749:	fed325        	call8	4201247c <get_arg$isra$0>
4201374c:	000a52        	l8ui	a5, a10, 0
4201374f:	0029c6        	j	420137fa <_svfiprintf_r+0xda2>
42013752:	761b      	addi.n	a7, a6, 1
42013754:	08a687        	bge	a6, a8, 42013760 <_svfiprintf_r+0xd08>
42013757:	b0e5e0        	addx8	a14, a5, a14
4201375a:	000e52        	l8ui	a5, a14, 0
4201375d:	0044c6        	j	42013874 <_svfiprintf_r+0xe1c>
42013760:	922e92        	l32i	a9, a14, 0x248
42013763:	fb1c      	movi.n	a11, 31
42013765:	02dee2        	addmi	a14, a14, 0x200
42013768:	a94b      	addi.n	a10, a9, 4
4201376a:	362b87        	blt	a11, a8, 420137a4 <_svfiprintf_r+0xd4c>
4201376d:	b81b      	addi.n	a11, a8, 1
4201376f:	9161b2        	s32i	a11, a1, 0x244
42013772:	126ea2        	s32i	a10, a14, 72
42013775:	8b1c      	movi.n	a11, 24
42013777:	052ba7        	blt	a11, a10, 42013780 <_svfiprintf_r+0xd28>
4201377a:	112e92        	l32i	a9, a14, 68
4201377d:	000406        	j	42013791 <_svfiprintf_r+0xd39>
42013780:	012b97        	blt	a11, a9, 42013785 <_svfiprintf_r+0xd2d>
42013783:	4a2c      	movi.n	a10, 36
42013785:	10c192        	addi	a9, a1, 16
42013788:	02d992        	addmi	a9, a9, 0x200
4201378b:	102992        	l32i	a9, a9, 64
4201378e:	9661a2        	s32i	a10, a1, 0x258
42013791:	99aa      	add.n	a9, a9, a10
42013793:	fcc992        	addi	a9, a9, -4
42013796:	0958      	l32i.n	a5, a9, 0
42013798:	b08810        	addx8	a8, a8, a1
4201379b:	4859      	s32i.n	a5, a8, 16
4201379d:	745050        	extui	a5, a5, 0, 8
420137a0:	003406        	j	42013874 <_svfiprintf_r+0xe1c>
420137a3:	6ea200        	f64rnd	a10, a2, a0, 2
420137a6:	881c12        	l16ui	a1, a12, 0x110
420137a9:	0528a7        	blt	a8, a10, 420137b2 <_svfiprintf_r+0xd5a>
420137ac:	112e82        	l32i	a8, a14, 68
420137af:	000446        	j	420137c4 <_svfiprintf_r+0xd6c>
420137b2:	022897        	blt	a8, a9, 420137b8 <_svfiprintf_r+0xd60>
420137b5:	24a0a2        	movi	a10, 36
420137b8:	10c182        	addi	a8, a1, 16
420137bb:	02d882        	addmi	a8, a8, 0x200
420137be:	102882        	l32i	a8, a8, 64
420137c1:	9661a2        	s32i	a10, a1, 0x258
420137c4:	88aa      	add.n	a8, a8, a10
420137c6:	fcc882        	addi	a8, a8, -4
420137c9:	000852        	l8ui	a5, a8, 0
420137cc:	002906        	j	42013874 <_svfiprintf_r+0xe1c>
420137cf:	c3ac00        	movf	a10, a12, b0
420137d2:	07a587        	bge	a5, a8, 420137dd <_svfiprintf_r+0xd85>
420137d5:	b0e5e0        	addx8	a14, a5, a14
420137d8:	0e58      	l32i.n	a5, a14, 0
420137da:	000706        	j	420137fa <_svfiprintf_r+0xda2>
420137dd:	30a282        	movi	a8, 0x230
420137e0:	8e8a      	add.n	a8, a14, a8
420137e2:	34a2d2        	movi	a13, 0x234
420137e5:	40a2c2        	movi	a12, 0x240
420137e8:	05ad      	mov.n	a10, a5
420137ea:	0189      	s32i.n	a8, a1, 0
420137ec:	01def2        	addmi	a15, a14, 0x100
420137ef:	deda      	add.n	a13, a14, a13
420137f1:	ceca      	add.n	a12, a14, a12
420137f3:	07bd      	mov.n	a11, a7
420137f5:	fec865        	call8	4201247c <get_arg$isra$0>
420137f8:	0a58      	l32i.n	a5, a10, 0
420137fa:	067d      	mov.n	a7, a6
420137fc:	001d06        	j	42013874 <_svfiprintf_r+0xe1c>
420137ff:	761b00        	lsi	f0, a11, 0x1d8
42013802:	07a687        	bge	a6, a8, 4201380d <_svfiprintf_r+0xdb5>
42013805:	b0e5e0        	addx8	a14, a5, a14
42013808:	0e58      	l32i.n	a5, a14, 0
4201380a:	001986        	j	42013874 <_svfiprintf_r+0xe1c>
4201380d:	922e92        	l32i	a9, a14, 0x248
42013810:	fb1c      	movi.n	a11, 31
42013812:	02dee2        	addmi	a14, a14, 0x200
42013815:	a94b      	addi.n	a10, a9, 4
42013817:	322b87        	blt	a11, a8, 4201384d <_svfiprintf_r+0xdf5>
4201381a:	b81b      	addi.n	a11, a8, 1
4201381c:	9161b2        	s32i	a11, a1, 0x244
4201381f:	126ea2        	s32i	a10, a14, 72
42013822:	8b1c      	movi.n	a11, 24
42013824:	052ba7        	blt	a11, a10, 4201382d <_svfiprintf_r+0xdd5>
42013827:	112e92        	l32i	a9, a14, 68
4201382a:	000406        	j	4201383e <_svfiprintf_r+0xde6>
4201382d:	012b97        	blt	a11, a9, 42013832 <_svfiprintf_r+0xdda>
42013830:	4a2c      	movi.n	a10, 36
42013832:	10c192        	addi	a9, a1, 16
42013835:	02d992        	addmi	a9, a9, 0x200
42013838:	102992        	l32i	a9, a9, 64
4201383b:	9661a2        	s32i	a10, a1, 0x258
4201383e:	99aa      	add.n	a9, a9, a10
42013840:	fcc992        	addi	a9, a9, -4
42013843:	0958      	l32i.n	a5, a9, 0
42013845:	b08810        	addx8	a8, a8, a1
42013848:	4859      	s32i.n	a5, a8, 16
4201384a:	000986        	j	42013874 <_svfiprintf_r+0xe1c>
4201384d:	126ea2        	s32i	a10, a14, 72
42013850:	881c      	movi.n	a8, 24
42013852:	0628a7        	blt	a8, a10, 4201385c <_svfiprintf_r+0xe04>
42013855:	112e82        	l32i	a8, a14, 68
42013858:	000446        	j	4201386d <_svfiprintf_r+0xe15>
4201385b:	289700        	lsi	f0, a7, 160
4201385e:	4a2c01        	l32r	a0, 41fe6110 <_coredump_iram_end+0x1c64210>
42013861:	10c182        	addi	a8, a1, 16
42013864:	02d882        	addmi	a8, a8, 0x200
42013867:	102882        	l32i	a8, a8, 64
4201386a:	9661a2        	s32i	a10, a1, 0x258
4201386d:	88aa      	add.n	a8, a8, a10
4201386f:	fcc882        	addi	a8, a8, -4
42013872:	0858      	l32i.n	a5, a8, 0
42013874:	030c      	movi.n	a3, 0
42013876:	ffab82        	movi	a8, 0xfffffbff
42013879:	102280        	and	a2, a2, a8
4201387c:	090c      	movi.n	a9, 0
4201387e:	01ebc6        	j	42014031 <_svfiprintf_r+0x15d9>
42013881:	218200        	srai	a8, a0, 2
42013884:	c1e291        	l32r	a9, 4200400c <memprot_ll_rtcfast_set_pms_area+0x18> (520c2327 <_coredump_rtc_end+0x20c2327>)
42013887:	c3ac10        	movf	a10, a12, b1
4201388a:	07a587        	bge	a5, a8, 42013895 <_svfiprintf_r+0xe3d>
4201388d:	b0e5e0        	addx8	a14, a5, a14
42013890:	0e58      	l32i.n	a5, a14, 0
42013892:	000706        	j	420138b2 <_svfiprintf_r+0xe5a>
42013895:	30a282        	movi	a8, 0x230
42013898:	8e8a      	add.n	a8, a14, a8
4201389a:	34a2d2        	movi	a13, 0x234
4201389d:	40a2c2        	movi	a12, 0x240
420138a0:	05ad      	mov.n	a10, a5
420138a2:	0189      	s32i.n	a8, a1, 0
420138a4:	01def2        	addmi	a15, a14, 0x100
420138a7:	deda      	add.n	a13, a14, a13
420138a9:	ceca      	add.n	a12, a14, a12
420138ab:	07bd      	mov.n	a11, a7
420138ad:	febce5        	call8	4201247c <get_arg$isra$0>
420138b0:	0a58      	l32i.n	a5, a10, 0
420138b2:	067d      	mov.n	a7, a6
420138b4:	001d06        	j	4201392c <_svfiprintf_r+0xed4>
420138b7:	761b00        	lsi	f0, a11, 0x1d8
420138ba:	07a687        	bge	a6, a8, 420138c5 <_svfiprintf_r+0xe6d>
420138bd:	b0e5e0        	addx8	a14, a5, a14
420138c0:	0e58      	l32i.n	a5, a14, 0
420138c2:	001986        	j	4201392c <_svfiprintf_r+0xed4>
420138c5:	922e92        	l32i	a9, a14, 0x248
420138c8:	fb1c      	movi.n	a11, 31
420138ca:	02dee2        	addmi	a14, a14, 0x200
420138cd:	a94b      	addi.n	a10, a9, 4
420138cf:	322b87        	blt	a11, a8, 42013905 <_svfiprintf_r+0xead>
420138d2:	b81b      	addi.n	a11, a8, 1
420138d4:	9161b2        	s32i	a11, a1, 0x244
420138d7:	126ea2        	s32i	a10, a14, 72
420138da:	8b1c      	movi.n	a11, 24
420138dc:	052ba7        	blt	a11, a10, 420138e5 <_svfiprintf_r+0xe8d>
420138df:	112e92        	l32i	a9, a14, 68
420138e2:	000406        	j	420138f6 <_svfiprintf_r+0xe9e>
420138e5:	012b97        	blt	a11, a9, 420138ea <_svfiprintf_r+0xe92>
420138e8:	4a2c      	movi.n	a10, 36
420138ea:	10c192        	addi	a9, a1, 16
420138ed:	02d992        	addmi	a9, a9, 0x200
420138f0:	102992        	l32i	a9, a9, 64
420138f3:	9661a2        	s32i	a10, a1, 0x258
420138f6:	99aa      	add.n	a9, a9, a10
420138f8:	fcc992        	addi	a9, a9, -4
420138fb:	0958      	l32i.n	a5, a9, 0
420138fd:	b08810        	addx8	a8, a8, a1
42013900:	4859      	s32i.n	a5, a8, 16
42013902:	000986        	j	4201392c <_svfiprintf_r+0xed4>
42013905:	126ea2        	s32i	a10, a14, 72
42013908:	881c      	movi.n	a8, 24
4201390a:	0628a7        	blt	a8, a10, 42013914 <_svfiprintf_r+0xebc>
4201390d:	112e82        	l32i	a8, a14, 68
42013910:	000446        	j	42013925 <_svfiprintf_r+0xecd>
42013913:	289700        	lsi	f0, a7, 160
42013916:	4a2c01        	l32r	a0, 41fe61c8 <_coredump_iram_end+0x1c642c8>
42013919:	10c182        	addi	a8, a1, 16
4201391c:	02d882        	addmi	a8, a8, 0x200
4201391f:	102882        	l32i	a8, a8, 64
42013922:	9661a2        	s32i	a10, a1, 0x258
42013925:	88aa      	add.n	a8, a8, a10
42013927:	fcc882        	addi	a8, a8, -4
4201392a:	0858      	l32i.n	a5, a8, 0
4201392c:	280c      	movi.n	a8, 2
4201392e:	202280        	or	a2, a2, a8
42013931:	10c182        	addi	a8, a1, 16
42013934:	02d882        	addmi	a8, a8, 0x200
42013937:	093c      	movi.n	a9, 48
42013939:	384892        	s8i	a9, a8, 56
4201393c:	78a092        	movi	a9, 120
4201393f:	394892        	s8i	a9, a8, 57
42013942:	b52d81        	l32r	a8, 42000df8 <_stext+0xdd8> (3c02915e <Xthal_intlevel+0x32>)
42013945:	030c      	movi.n	a3, 0
42013947:	a26182        	s32i	a8, a1, 0x288
4201394a:	01b846        	j	4201402f <_svfiprintf_r+0x15d7>
4201394d:	219200        	srai	a9, a0, 2
42013950:	c1e291        	l32r	a9, 420040d8 <memprot_ll_rtcfast_get_pms_area+0x8> (7162600 <UserFrameTotalSize+0x7162500>)
42013953:	c3ac10        	movf	a10, a12, b1
42013956:	07a597        	bge	a5, a9, 42013961 <_svfiprintf_r+0xf09>
42013959:	b0e5e0        	addx8	a14, a5, a14
4201395c:	0e48      	l32i.n	a4, a14, 0
4201395e:	000706        	j	4201397e <_svfiprintf_r+0xf26>
42013961:	30a282        	movi	a8, 0x230
42013964:	8e8a      	add.n	a8, a14, a8
42013966:	34a2d2        	movi	a13, 0x234
42013969:	40a2c2        	movi	a12, 0x240
4201396c:	0189      	s32i.n	a8, a1, 0
4201396e:	01def2        	addmi	a15, a14, 0x100
42013971:	deda      	add.n	a13, a14, a13
42013973:	ceca      	add.n	a12, a14, a12
42013975:	07bd      	mov.n	a11, a7
42013977:	05ad      	mov.n	a10, a5
42013979:	feb025        	call8	4201247c <get_arg$isra$0>
4201397c:	0a48      	l32i.n	a4, a10, 0
4201397e:	067d      	mov.n	a7, a6
42013980:	001d06        	j	420139f8 <_svfiprintf_r+0xfa0>
42013983:	761b00        	lsi	f0, a11, 0x1d8
42013986:	07a697        	bge	a6, a9, 42013991 <_svfiprintf_r+0xf39>
42013989:	b0e5e0        	addx8	a14, a5, a14
4201398c:	0e48      	l32i.n	a4, a14, 0
4201398e:	001986        	j	420139f8 <_svfiprintf_r+0xfa0>
42013991:	922e82        	l32i	a8, a14, 0x248
42013994:	fb1c      	movi.n	a11, 31
42013996:	02dee2        	addmi	a14, a14, 0x200
42013999:	a84b      	addi.n	a10, a8, 4
4201399b:	322b97        	blt	a11, a9, 420139d1 <_svfiprintf_r+0xf79>
4201399e:	b91b      	addi.n	a11, a9, 1
420139a0:	9161b2        	s32i	a11, a1, 0x244
420139a3:	126ea2        	s32i	a10, a14, 72
420139a6:	8b1c      	movi.n	a11, 24
420139a8:	052ba7        	blt	a11, a10, 420139b1 <_svfiprintf_r+0xf59>
420139ab:	112e82        	l32i	a8, a14, 68
420139ae:	000406        	j	420139c2 <_svfiprintf_r+0xf6a>
420139b1:	012b87        	blt	a11, a8, 420139b6 <_svfiprintf_r+0xf5e>
420139b4:	4a2c      	movi.n	a10, 36
420139b6:	10c182        	addi	a8, a1, 16
420139b9:	02d882        	addmi	a8, a8, 0x200
420139bc:	102882        	l32i	a8, a8, 64
420139bf:	9661a2        	s32i	a10, a1, 0x258
420139c2:	88aa      	add.n	a8, a8, a10
420139c4:	fcc882        	addi	a8, a8, -4
420139c7:	0848      	l32i.n	a4, a8, 0
420139c9:	b09910        	addx8	a9, a9, a1
420139cc:	4949      	s32i.n	a4, a9, 16
420139ce:	000986        	j	420139f8 <_svfiprintf_r+0xfa0>
420139d1:	126ea2        	s32i	a10, a14, 72
420139d4:	891c      	movi.n	a9, 24
420139d6:	0629a7        	blt	a9, a10, 420139e0 <_svfiprintf_r+0xf88>
420139d9:	112e82        	l32i	a8, a14, 68
420139dc:	000446        	j	420139f1 <_svfiprintf_r+0xf99>
420139df:	298700        	lsi	f0, a7, 164
420139e2:	4a2c01        	l32r	a0, 41fe6294 <_coredump_iram_end+0x1c64394>
420139e5:	10c182        	addi	a8, a1, 16
420139e8:	02d882        	addmi	a8, a8, 0x200
420139eb:	102882        	l32i	a8, a8, 64
420139ee:	9661a2        	s32i	a10, a1, 0x258
420139f1:	88aa      	add.n	a8, a8, a10
420139f3:	fcc882        	addi	a8, a8, -4
420139f6:	0848      	l32i.n	a4, a8, 0
420139f8:	10c192        	addi	a9, a1, 16
420139fb:	02d992        	addmi	a9, a9, 0x200
420139fe:	0a0c      	movi.n	a10, 0
42013a00:	9b2182        	l32i	a8, a1, 0x26c
42013a03:	3a49a2        	s8i	a10, a9, 58
42013a06:	016896        	bltz	a8, 42013a20 <_svfiprintf_r+0xfc8>
42013a09:	08cd      	mov.n	a12, a8
42013a0b:	0b0c      	movi.n	a11, 0
42013a0d:	04ad      	mov.n	a10, a4
42013a0f:	b4a481        	l32r	a8, 42000ca0 <_stext+0xc80> (40001344 <memchr>)
42013a12:	0008e0        	callx8	a8
42013a15:	060c      	movi.n	a6, 0
42013a17:	c08a40        	sub	a8, a10, a4
42013a1a:	7a7a56        	bnez	a10, 420141c5 <_svfiprintf_r+0x176d>
42013a1d:	01f346        	j	420141ee <_svfiprintf_r+0x1796>
42013a20:	04ad      	mov.n	a10, a4
42013a22:	b21e81        	l32r	a8, 4200029c <_stext+0x27c> (40001248 <strlen>)
42013a25:	0008e0        	callx8	a8
42013a28:	9b61a2        	s32i	a10, a1, 0x26c
42013a2b:	060c      	movi.n	a6, 0
42013a2d:	01ef46        	j	420141ee <_svfiprintf_r+0x1796>
42013a30:	081c00        	lsx	f1, a12, a0
42013a33:	202280        	or	a2, a2, a8
42013a36:	912182        	l32i	a8, a1, 0x244
42013a39:	10c1e2        	addi	a14, a1, 16
42013a3c:	02e257        	bbsi	a2, 5, 42013a42 <_svfiprintf_r+0xfea>
42013a3f:	002f86        	j	42013b01 <_svfiprintf_r+0x10a9>
42013a42:	f3ac      	beqz.n	a3, 42013a75 <_svfiprintf_r+0x101d>
42013a44:	09a587        	bge	a5, a8, 42013a51 <_svfiprintf_r+0xff9>
42013a47:	b0e5e0        	addx8	a14, a5, a14
42013a4a:	0e58      	l32i.n	a5, a14, 0
42013a4c:	1e38      	l32i.n	a3, a14, 4
42013a4e:	000786        	j	42013a70 <_svfiprintf_r+0x1018>
42013a51:	30a282        	movi	a8, 0x230
42013a54:	8e8a      	add.n	a8, a14, a8
42013a56:	34a2d2        	movi	a13, 0x234
42013a59:	40a2c2        	movi	a12, 0x240
42013a5c:	05ad      	mov.n	a10, a5
42013a5e:	0189      	s32i.n	a8, a1, 0
42013a60:	01def2        	addmi	a15, a14, 0x100
42013a63:	deda      	add.n	a13, a14, a13
42013a65:	ceca      	add.n	a12, a14, a12
42013a67:	07bd      	mov.n	a11, a7
42013a69:	fea125        	call8	4201247c <get_arg$isra$0>
42013a6c:	0a58      	l32i.n	a5, a10, 0
42013a6e:	1a38      	l32i.n	a3, a10, 4
42013a70:	067d      	mov.n	a7, a6
42013a72:	007e06        	j	42013c6e <_svfiprintf_r+0x1216>
42013a75:	761b      	addi.n	a7, a6, 1
42013a77:	09a687        	bge	a6, a8, 42013a84 <_svfiprintf_r+0x102c>
42013a7a:	b0e5e0        	addx8	a14, a5, a14
42013a7d:	0e58      	l32i.n	a5, a14, 0
42013a7f:	1e38      	l32i.n	a3, a14, 4
42013a81:	007a46        	j	42013c6e <_svfiprintf_r+0x1216>
42013a84:	922e92        	l32i	a9, a14, 0x248
42013a87:	8a7c      	movi.n	a10, -8
42013a89:	997b      	addi.n	a9, a9, 7
42013a8b:	1099a0        	and	a9, a9, a10
42013a8e:	fb1c      	movi.n	a11, 31
42013a90:	02dee2        	addmi	a14, a14, 0x200
42013a93:	a98b      	addi.n	a10, a9, 8
42013a95:	3b2b87        	blt	a11, a8, 42013ad4 <_svfiprintf_r+0x107c>
42013a98:	b81b      	addi.n	a11, a8, 1
42013a9a:	9161b2        	s32i	a11, a1, 0x244
42013a9d:	126ea2        	s32i	a10, a14, 72
42013aa0:	8b1c      	movi.n	a11, 24
42013aa2:	062ba7        	blt	a11, a10, 42013aac <_svfiprintf_r+0x1054>
42013aa5:	112e92        	l32i	a9, a14, 68
42013aa8:	000446        	j	42013abd <_svfiprintf_r+0x1065>
42013aab:	2b9700        	oeq.s	b9, f7, f0
42013aae:	8a2c01        	l32r	a0, 41ff6360 <_coredump_iram_end+0x1c74460>
42013ab1:	10c192        	addi	a9, a1, 16
42013ab4:	02d992        	addmi	a9, a9, 0x200
42013ab7:	102992        	l32i	a9, a9, 64
42013aba:	9661a2        	s32i	a10, a1, 0x258
42013abd:	99aa      	add.n	a9, a9, a10
42013abf:	f8c992        	addi	a9, a9, -8
42013ac2:	0958      	l32i.n	a5, a9, 0
42013ac4:	1938      	l32i.n	a3, a9, 4
42013ac6:	10c192        	addi	a9, a1, 16
42013ac9:	b08890        	addx8	a8, a8, a9
42013acc:	0859      	s32i.n	a5, a8, 0
42013ace:	1839      	s32i.n	a3, a8, 4
42013ad0:	006686        	j	42013c6e <_svfiprintf_r+0x1216>
42013ad3:	6ea200        	f64rnd	a10, a2, a0, 2
42013ad6:	881c12        	l16ui	a1, a12, 0x110
42013ad9:	0728a7        	blt	a8, a10, 42013ae4 <_svfiprintf_r+0x108c>
42013adc:	112e82        	l32i	a8, a14, 68
42013adf:	000486        	j	42013af5 <_svfiprintf_r+0x109d>
42013ae2:	970000        	lsi	f0, a0, 0x25c
42013ae5:	0128      	l32i.n	a2, a1, 0
42013ae7:	8a2c      	movi.n	a10, 40
42013ae9:	10c182        	addi	a8, a1, 16
42013aec:	02d882        	addmi	a8, a8, 0x200
42013aef:	102882        	l32i	a8, a8, 64
42013af2:	9661a2        	s32i	a10, a1, 0x258
42013af5:	88aa      	add.n	a8, a8, a10
42013af7:	f8c882        	addi	a8, a8, -8
42013afa:	0858      	l32i.n	a5, a8, 0
42013afc:	1838      	l32i.n	a3, a8, 4
42013afe:	005b06        	j	42013c6e <_svfiprintf_r+0x1216>
42013b01:	036247        	bbci	a2, 4, 42013b08 <_svfiprintf_r+0x10b0>
42013b04:	005b06        	j	42013c74 <_svfiprintf_r+0x121c>
42013b07:	e26700        	remu	a6, a7, a0
42013b0a:	2b4602        	s8i	a0, a6, 43
42013b0d:	c3ac00        	movf	a10, a12, b0
42013b10:	09a587        	bge	a5, a8, 42013b1d <_svfiprintf_r+0x10c5>
42013b13:	b0e5e0        	addx8	a14, a5, a14
42013b16:	001e52        	l16ui	a5, a14, 0
42013b19:	006046        	j	42013c9e <_svfiprintf_r+0x1246>
42013b1c:	a28200        	muluh	a8, a2, a0
42013b1f:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42013b22:	34a2d2        	movi	a13, 0x234
42013b25:	40a2c2        	movi	a12, 0x240
42013b28:	05ad      	mov.n	a10, a5
42013b2a:	0189      	s32i.n	a8, a1, 0
42013b2c:	01def2        	addmi	a15, a14, 0x100
42013b2f:	deda      	add.n	a13, a14, a13
42013b31:	ceca      	add.n	a12, a14, a12
42013b33:	07bd      	mov.n	a11, a7
42013b35:	fe9465        	call8	4201247c <get_arg$isra$0>
42013b38:	001a52        	l16ui	a5, a10, 0
42013b3b:	0057c6        	j	42013c9e <_svfiprintf_r+0x1246>
42013b3e:	761b      	addi.n	a7, a6, 1
42013b40:	08a687        	bge	a6, a8, 42013b4c <_svfiprintf_r+0x10f4>
42013b43:	b0e5e0        	addx8	a14, a5, a14
42013b46:	001e52        	l16ui	a5, a14, 0
42013b49:	0047c6        	j	42013c6c <_svfiprintf_r+0x1214>
42013b4c:	922e92        	l32i	a9, a14, 0x248
42013b4f:	fb1c      	movi.n	a11, 31
42013b51:	02dee2        	addmi	a14, a14, 0x200
42013b54:	a94b      	addi.n	a10, a9, 4
42013b56:	362b87        	blt	a11, a8, 42013b90 <_svfiprintf_r+0x1138>
42013b59:	b81b      	addi.n	a11, a8, 1
42013b5b:	9161b2        	s32i	a11, a1, 0x244
42013b5e:	126ea2        	s32i	a10, a14, 72
42013b61:	8b1c      	movi.n	a11, 24
42013b63:	052ba7        	blt	a11, a10, 42013b6c <_svfiprintf_r+0x1114>
42013b66:	112e92        	l32i	a9, a14, 68
42013b69:	000406        	j	42013b7d <_svfiprintf_r+0x1125>
42013b6c:	012b97        	blt	a11, a9, 42013b71 <_svfiprintf_r+0x1119>
42013b6f:	4a2c      	movi.n	a10, 36
42013b71:	10c192        	addi	a9, a1, 16
42013b74:	02d992        	addmi	a9, a9, 0x200
42013b77:	102992        	l32i	a9, a9, 64
42013b7a:	9661a2        	s32i	a10, a1, 0x258
42013b7d:	99aa      	add.n	a9, a9, a10
42013b7f:	fcc992        	addi	a9, a9, -4
42013b82:	0958      	l32i.n	a5, a9, 0
42013b84:	b08810        	addx8	a8, a8, a1
42013b87:	4859      	s32i.n	a5, a8, 16
42013b89:	f45050        	extui	a5, a5, 0, 16
42013b8c:	003706        	j	42013c6c <_svfiprintf_r+0x1214>
42013b8f:	6ea200        	f64rnd	a10, a2, a0, 2
42013b92:	881c12        	l16ui	a1, a12, 0x110
42013b95:	0728a7        	blt	a8, a10, 42013ba0 <_svfiprintf_r+0x1148>
42013b98:	112e82        	l32i	a8, a14, 68
42013b9b:	000486        	j	42013bb1 <_svfiprintf_r+0x1159>
42013b9e:	970000        	lsi	f0, a0, 0x25c
42013ba1:	0128      	l32i.n	a2, a1, 0
42013ba3:	4a2c      	movi.n	a10, 36
42013ba5:	10c182        	addi	a8, a1, 16
42013ba8:	02d882        	addmi	a8, a8, 0x200
42013bab:	102882        	l32i	a8, a8, 64
42013bae:	9661a2        	s32i	a10, a1, 0x258
42013bb1:	88aa      	add.n	a8, a8, a10
42013bb3:	fcc882        	addi	a8, a8, -4
42013bb6:	001852        	l16ui	a5, a8, 0
42013bb9:	002bc6        	j	42013c6c <_svfiprintf_r+0x1214>
42013bbc:	02e297        	bbsi	a2, 9, 42013bc2 <_svfiprintf_r+0x116a>
42013bbf:	002c46        	j	42013c74 <_svfiprintf_r+0x121c>
42013bc2:	c3ac      	beqz.n	a3, 42013bf2 <_svfiprintf_r+0x119a>
42013bc4:	09a587        	bge	a5, a8, 42013bd1 <_svfiprintf_r+0x1179>
42013bc7:	b0e5e0        	addx8	a14, a5, a14
42013bca:	000e52        	l8ui	a5, a14, 0
42013bcd:	003346        	j	42013c9e <_svfiprintf_r+0x1246>
42013bd0:	a28200        	muluh	a8, a2, a0
42013bd3:	8e8a30        	f64iter	a8, a10, a3, 0, 0
42013bd6:	34a2d2        	movi	a13, 0x234
42013bd9:	40a2c2        	movi	a12, 0x240
42013bdc:	05ad      	mov.n	a10, a5
42013bde:	0189      	s32i.n	a8, a1, 0
42013be0:	01def2        	addmi	a15, a14, 0x100
42013be3:	deda      	add.n	a13, a14, a13
42013be5:	ceca      	add.n	a12, a14, a12
42013be7:	07bd      	mov.n	a11, a7
42013be9:	fe8925        	call8	4201247c <get_arg$isra$0>
42013bec:	000a52        	l8ui	a5, a10, 0
42013bef:	002ac6        	j	42013c9e <_svfiprintf_r+0x1246>
42013bf2:	761b      	addi.n	a7, a6, 1
42013bf4:	08a687        	bge	a6, a8, 42013c00 <_svfiprintf_r+0x11a8>
42013bf7:	b0e5e0        	addx8	a14, a5, a14
42013bfa:	000e52        	l8ui	a5, a14, 0
42013bfd:	001ac6        	j	42013c6c <_svfiprintf_r+0x1214>
42013c00:	922e92        	l32i	a9, a14, 0x248
42013c03:	fb1c      	movi.n	a11, 31
42013c05:	02dee2        	addmi	a14, a14, 0x200
42013c08:	a94b      	addi.n	a10, a9, 4
42013c0a:	362b87        	blt	a11, a8, 42013c44 <_svfiprintf_r+0x11ec>
42013c0d:	b81b      	addi.n	a11, a8, 1
42013c0f:	9161b2        	s32i	a11, a1, 0x244
42013c12:	126ea2        	s32i	a10, a14, 72
42013c15:	8b1c      	movi.n	a11, 24
42013c17:	052ba7        	blt	a11, a10, 42013c20 <_svfiprintf_r+0x11c8>
42013c1a:	112e92        	l32i	a9, a14, 68
42013c1d:	000406        	j	42013c31 <_svfiprintf_r+0x11d9>
42013c20:	012b97        	blt	a11, a9, 42013c25 <_svfiprintf_r+0x11cd>
42013c23:	4a2c      	movi.n	a10, 36
42013c25:	10c192        	addi	a9, a1, 16
42013c28:	02d992        	addmi	a9, a9, 0x200
42013c2b:	102992        	l32i	a9, a9, 64
42013c2e:	9661a2        	s32i	a10, a1, 0x258
42013c31:	99aa      	add.n	a9, a9, a10
42013c33:	fcc992        	addi	a9, a9, -4
42013c36:	0958      	l32i.n	a5, a9, 0
42013c38:	b08810        	addx8	a8, a8, a1
42013c3b:	4859      	s32i.n	a5, a8, 16
42013c3d:	745050        	extui	a5, a5, 0, 8
42013c40:	000a06        	j	42013c6c <_svfiprintf_r+0x1214>
42013c43:	6ea200        	f64rnd	a10, a2, a0, 2
42013c46:	881c12        	l16ui	a1, a12, 0x110
42013c49:	0528a7        	blt	a8, a10, 42013c52 <_svfiprintf_r+0x11fa>
42013c4c:	112e82        	l32i	a8, a14, 68
42013c4f:	000446        	j	42013c64 <_svfiprintf_r+0x120c>
42013c52:	022897        	blt	a8, a9, 42013c58 <_svfiprintf_r+0x1200>
42013c55:	24a0a2        	movi	a10, 36
42013c58:	10c182        	addi	a8, a1, 16
42013c5b:	02d882        	addmi	a8, a8, 0x200
42013c5e:	102882        	l32i	a8, a8, 64
42013c61:	9661a2        	s32i	a10, a1, 0x258
42013c64:	88aa      	add.n	a8, a8, a10
42013c66:	fcc882        	addi	a8, a8, -4
42013c69:	000852        	l8ui	a5, a8, 0
42013c6c:	030c      	movi.n	a3, 0
42013c6e:	190c      	movi.n	a9, 1
42013c70:	00ef46        	j	42014031 <_svfiprintf_r+0x15d9>
42013c73:	c3ac00        	movf	a10, a12, b0
42013c76:	07a587        	bge	a5, a8, 42013c81 <_svfiprintf_r+0x1229>
42013c79:	b0e5e0        	addx8	a14, a5, a14
42013c7c:	0e58      	l32i.n	a5, a14, 0
42013c7e:	000706        	j	42013c9e <_svfiprintf_r+0x1246>
42013c81:	30a282        	movi	a8, 0x230
42013c84:	8e8a      	add.n	a8, a14, a8
42013c86:	34a2d2        	movi	a13, 0x234
42013c89:	40a2c2        	movi	a12, 0x240
42013c8c:	05ad      	mov.n	a10, a5
42013c8e:	0189      	s32i.n	a8, a1, 0
42013c90:	01def2        	addmi	a15, a14, 0x100
42013c93:	deda      	add.n	a13, a14, a13
42013c95:	ceca      	add.n	a12, a14, a12
42013c97:	07bd      	mov.n	a11, a7
42013c99:	fe7e25        	call8	4201247c <get_arg$isra$0>
42013c9c:	0a58      	l32i.n	a5, a10, 0
42013c9e:	067d      	mov.n	a7, a6
42013ca0:	fff206        	j	42013c6c <_svfiprintf_r+0x1214>
42013ca3:	761b00        	lsi	f0, a11, 0x1d8
42013ca6:	07a687        	bge	a6, a8, 42013cb1 <_svfiprintf_r+0x1259>
42013ca9:	b0e5e0        	addx8	a14, a5, a14
42013cac:	0e58      	l32i.n	a5, a14, 0
42013cae:	ffee86        	j	42013c6c <_svfiprintf_r+0x1214>
42013cb1:	922e92        	l32i	a9, a14, 0x248
42013cb4:	fb1c      	movi.n	a11, 31
42013cb6:	02dee2        	addmi	a14, a14, 0x200
42013cb9:	a94b      	addi.n	a10, a9, 4
42013cbb:	322b87        	blt	a11, a8, 42013cf1 <_svfiprintf_r+0x1299>
42013cbe:	b81b      	addi.n	a11, a8, 1
42013cc0:	9161b2        	s32i	a11, a1, 0x244
42013cc3:	126ea2        	s32i	a10, a14, 72
42013cc6:	8b1c      	movi.n	a11, 24
42013cc8:	052ba7        	blt	a11, a10, 42013cd1 <_svfiprintf_r+0x1279>
42013ccb:	112e92        	l32i	a9, a14, 68
42013cce:	000406        	j	42013ce2 <_svfiprintf_r+0x128a>
42013cd1:	012b97        	blt	a11, a9, 42013cd6 <_svfiprintf_r+0x127e>
42013cd4:	4a2c      	movi.n	a10, 36
42013cd6:	10c192        	addi	a9, a1, 16
42013cd9:	02d992        	addmi	a9, a9, 0x200
42013cdc:	102992        	l32i	a9, a9, 64
42013cdf:	9661a2        	s32i	a10, a1, 0x258
42013ce2:	99aa      	add.n	a9, a9, a10
42013ce4:	fcc992        	addi	a9, a9, -4
42013ce7:	0958      	l32i.n	a5, a9, 0
42013ce9:	b08810        	addx8	a8, a8, a1
42013cec:	4859      	s32i.n	a5, a8, 16
42013cee:	ffde86        	j	42013c6c <_svfiprintf_r+0x1214>
42013cf1:	126ea2        	s32i	a10, a14, 72
42013cf4:	881c      	movi.n	a8, 24
42013cf6:	0628a7        	blt	a8, a10, 42013d00 <_svfiprintf_r+0x12a8>
42013cf9:	112e82        	l32i	a8, a14, 68
42013cfc:	000446        	j	42013d11 <_svfiprintf_r+0x12b9>
42013cff:	289700        	lsi	f0, a7, 160
42013d02:	4a2c01        	l32r	a0, 41fe65b4 <_coredump_iram_end+0x1c646b4>
42013d05:	10c182        	addi	a8, a1, 16
42013d08:	02d882        	addmi	a8, a8, 0x200
42013d0b:	102882        	l32i	a8, a8, 64
42013d0e:	9661a2        	s32i	a10, a1, 0x258
42013d11:	88aa      	add.n	a8, a8, a10
42013d13:	fcc882        	addi	a8, a8, -4
42013d16:	0858      	l32i.n	a5, a8, 0
42013d18:	ffd406        	j	42013c6c <_svfiprintf_r+0x1214>
42013d1b:	368100        	lsi	f0, a1, 216
42013d1e:	6182b4        	lsi	f11, a2, 0x184
42013d21:	c1e2a2        	s32c1i	a10, a2, 0x304
42013d24:	218210        	srai	a8, a1, 2
42013d27:	e25791        	l32r	a9, 4200c684 <_vfprintf_r+0xba4> (97a32192 <_rtc_reserved_end+0x37932192>)
42013d2a:	2f8602        	lsi	f0, a6, 188
42013d2d:	f3ac00        	lsi	f0, a12, 0x3cc
42013d30:	09a587        	bge	a5, a8, 42013d3d <_svfiprintf_r+0x12e5>
42013d33:	b0e5e0        	addx8	a14, a5, a14
42013d36:	0e58      	l32i.n	a5, a14, 0
42013d38:	1e38      	l32i.n	a3, a14, 4
42013d3a:	000786        	j	42013d5c <_svfiprintf_r+0x1304>
42013d3d:	30a282        	movi	a8, 0x230
42013d40:	8e8a      	add.n	a8, a14, a8
42013d42:	34a2d2        	movi	a13, 0x234
42013d45:	40a2c2        	movi	a12, 0x240
42013d48:	05ad      	mov.n	a10, a5
42013d4a:	0189      	s32i.n	a8, a1, 0
42013d4c:	01def2        	addmi	a15, a14, 0x100
42013d4f:	deda      	add.n	a13, a14, a13
42013d51:	ceca      	add.n	a12, a14, a12
42013d53:	07bd      	mov.n	a11, a7
42013d55:	fe7265        	call8	4201247c <get_arg$isra$0>
42013d58:	0a58      	l32i.n	a5, a10, 0
42013d5a:	1a38      	l32i.n	a3, a10, 4
42013d5c:	067d      	mov.n	a7, a6
42013d5e:	00ab06        	j	4201400e <_svfiprintf_r+0x15b6>
42013d61:	761b      	addi.n	a7, a6, 1
42013d63:	09a687        	bge	a6, a8, 42013d70 <_svfiprintf_r+0x1318>
42013d66:	b0e5e0        	addx8	a14, a5, a14
42013d69:	0e58      	l32i.n	a5, a14, 0
42013d6b:	1e38      	l32i.n	a3, a14, 4
42013d6d:	00a746        	j	4201400e <_svfiprintf_r+0x15b6>
42013d70:	922e92        	l32i	a9, a14, 0x248
42013d73:	8a7c      	movi.n	a10, -8
42013d75:	997b      	addi.n	a9, a9, 7
42013d77:	1099a0        	and	a9, a9, a10
42013d7a:	fb1c      	movi.n	a11, 31
42013d7c:	02dee2        	addmi	a14, a14, 0x200
42013d7f:	a98b      	addi.n	a10, a9, 8
42013d81:	3b2b87        	blt	a11, a8, 42013dc0 <_svfiprintf_r+0x1368>
42013d84:	b81b      	addi.n	a11, a8, 1
42013d86:	9161b2        	s32i	a11, a1, 0x244
42013d89:	126ea2        	s32i	a10, a14, 72
42013d8c:	8b1c      	movi.n	a11, 24
42013d8e:	062ba7        	blt	a11, a10, 42013d98 <_svfiprintf_r+0x1340>
42013d91:	112e92        	l32i	a9, a14, 68
42013d94:	000446        	j	42013da9 <_svfiprintf_r+0x1351>
42013d97:	2b9700        	oeq.s	b9, f7, f0
42013d9a:	8a2c01        	l32r	a0, 41ff664c <_coredump_iram_end+0x1c7474c>
42013d9d:	10c192        	addi	a9, a1, 16
42013da0:	02d992        	addmi	a9, a9, 0x200
42013da3:	102992        	l32i	a9, a9, 64
42013da6:	9661a2        	s32i	a10, a1, 0x258
42013da9:	99aa      	add.n	a9, a9, a10
42013dab:	f8c992        	addi	a9, a9, -8
42013dae:	0958      	l32i.n	a5, a9, 0
42013db0:	1938      	l32i.n	a3, a9, 4
42013db2:	10c192        	addi	a9, a1, 16
42013db5:	b08890        	addx8	a8, a8, a9
42013db8:	0859      	s32i.n	a5, a8, 0
42013dba:	1839      	s32i.n	a3, a8, 4
42013dbc:	009386        	j	4201400e <_svfiprintf_r+0x15b6>
42013dbf:	6ea200        	f64rnd	a10, a2, a0, 2
42013dc2:	881c12        	l16ui	a1, a12, 0x110
42013dc5:	0728a7        	blt	a8, a10, 42013dd0 <_svfiprintf_r+0x1378>
42013dc8:	112e82        	l32i	a8, a14, 68
42013dcb:	000486        	j	42013de1 <_svfiprintf_r+0x1389>
42013dce:	970000        	lsi	f0, a0, 0x25c
42013dd1:	0128      	l32i.n	a2, a1, 0
42013dd3:	8a2c      	movi.n	a10, 40
42013dd5:	10c182        	addi	a8, a1, 16
42013dd8:	02d882        	addmi	a8, a8, 0x200
42013ddb:	102882        	l32i	a8, a8, 64
42013dde:	9661a2        	s32i	a10, a1, 0x258
42013de1:	88aa      	add.n	a8, a8, a10
42013de3:	f8c882        	addi	a8, a8, -8
42013de6:	0858      	l32i.n	a5, a8, 0
42013de8:	1838      	l32i.n	a3, a8, 4
42013dea:	008806        	j	4201400e <_svfiprintf_r+0x15b6>
42013ded:	146247        	bbci	a2, 4, 42013e05 <_svfiprintf_r+0x13ad>
42013df0:	138c      	beqz.n	a3, 42013df5 <_svfiprintf_r+0x139d>
42013df2:	005d06        	j	42013f6a <_svfiprintf_r+0x1512>
42013df5:	761b      	addi.n	a7, a6, 1
42013df7:	022687        	blt	a6, a8, 42013dfd <_svfiprintf_r+0x13a5>
42013dfa:	006986        	j	42013fa4 <_svfiprintf_r+0x154c>
42013dfd:	b0e5e0        	addx8	a14, a5, a14
42013e00:	0e58      	l32i.n	a5, a14, 0
42013e02:	008186        	j	4201400c <_svfiprintf_r+0x15b4>
42013e05:	02e267        	bbsi	a2, 6, 42013e0b <_svfiprintf_r+0x13b3>
42013e08:	002a46        	j	42013eb5 <_svfiprintf_r+0x145d>
42013e0b:	b3ac      	beqz.n	a3, 42013e3a <_svfiprintf_r+0x13e2>
42013e0d:	08a587        	bge	a5, a8, 42013e19 <_svfiprintf_r+0x13c1>
42013e10:	b0e5e0        	addx8	a14, a5, a14
42013e13:	001e52        	l16ui	a5, a14, 0
42013e16:	005e06        	j	42013f92 <_svfiprintf_r+0x153a>
42013e19:	30a282        	movi	a8, 0x230
42013e1c:	8e8a      	add.n	a8, a14, a8
42013e1e:	34a2d2        	movi	a13, 0x234
42013e21:	40a2c2        	movi	a12, 0x240
42013e24:	05ad      	mov.n	a10, a5
42013e26:	0189      	s32i.n	a8, a1, 0
42013e28:	01def2        	addmi	a15, a14, 0x100
42013e2b:	deda      	add.n	a13, a14, a13
42013e2d:	ceca      	add.n	a12, a14, a12
42013e2f:	07bd      	mov.n	a11, a7
42013e31:	fe64a5        	call8	4201247c <get_arg$isra$0>
42013e34:	001a52        	l16ui	a5, a10, 0
42013e37:	0055c6        	j	42013f92 <_svfiprintf_r+0x153a>
42013e3a:	761b      	addi.n	a7, a6, 1
42013e3c:	08a687        	bge	a6, a8, 42013e48 <_svfiprintf_r+0x13f0>
42013e3f:	b0e5e0        	addx8	a14, a5, a14
42013e42:	001e52        	l16ui	a5, a14, 0
42013e45:	0070c6        	j	4201400c <_svfiprintf_r+0x15b4>
42013e48:	922e92        	l32i	a9, a14, 0x248
42013e4b:	fb1c      	movi.n	a11, 31
42013e4d:	02dee2        	addmi	a14, a14, 0x200
42013e50:	a94b      	addi.n	a10, a9, 4
42013e52:	352b87        	blt	a11, a8, 42013e8b <_svfiprintf_r+0x1433>
42013e55:	b81b      	addi.n	a11, a8, 1
42013e57:	9161b2        	s32i	a11, a1, 0x244
42013e5a:	126ea2        	s32i	a10, a14, 72
42013e5d:	8b1c      	movi.n	a11, 24
42013e5f:	052ba7        	blt	a11, a10, 42013e68 <_svfiprintf_r+0x1410>
42013e62:	112e92        	l32i	a9, a14, 68
42013e65:	000406        	j	42013e79 <_svfiprintf_r+0x1421>
42013e68:	012b97        	blt	a11, a9, 42013e6d <_svfiprintf_r+0x1415>
42013e6b:	4a2c      	movi.n	a10, 36
42013e6d:	10c192        	addi	a9, a1, 16
42013e70:	02d992        	addmi	a9, a9, 0x200
42013e73:	102992        	l32i	a9, a9, 64
42013e76:	9661a2        	s32i	a10, a1, 0x258
42013e79:	99aa      	add.n	a9, a9, a10
42013e7b:	fcc992        	addi	a9, a9, -4
42013e7e:	0958      	l32i.n	a5, a9, 0
42013e80:	b08810        	addx8	a8, a8, a1
42013e83:	4859      	s32i.n	a5, a8, 16
42013e85:	f45050        	extui	a5, a5, 0, 16
42013e88:	006006        	j	4201400c <_svfiprintf_r+0x15b4>
42013e8b:	126ea2        	s32i	a10, a14, 72
42013e8e:	881c      	movi.n	a8, 24
42013e90:	0528a7        	blt	a8, a10, 42013e99 <_svfiprintf_r+0x1441>
42013e93:	112e82        	l32i	a8, a14, 68
42013e96:	000406        	j	42013eaa <_svfiprintf_r+0x1452>
42013e99:	012897        	blt	a8, a9, 42013e9e <_svfiprintf_r+0x1446>
42013e9c:	4a2c      	movi.n	a10, 36
42013e9e:	10c182        	addi	a8, a1, 16
42013ea1:	02d882        	addmi	a8, a8, 0x200
42013ea4:	102882        	l32i	a8, a8, 64
42013ea7:	9661a2        	s32i	a10, a1, 0x258
42013eaa:	88aa      	add.n	a8, a8, a10
42013eac:	fcc882        	addi	a8, a8, -4
42013eaf:	001852        	l16ui	a5, a8, 0
42013eb2:	005586        	j	4201400c <_svfiprintf_r+0x15b4>
42013eb5:	02e297        	bbsi	a2, 9, 42013ebb <_svfiprintf_r+0x1463>
42013eb8:	002b06        	j	42013f68 <_svfiprintf_r+0x1510>
42013ebb:	b3ac      	beqz.n	a3, 42013eea <_svfiprintf_r+0x1492>
42013ebd:	08a587        	bge	a5, a8, 42013ec9 <_svfiprintf_r+0x1471>
42013ec0:	b0e5e0        	addx8	a14, a5, a14
42013ec3:	000e52        	l8ui	a5, a14, 0
42013ec6:	003206        	j	42013f92 <_svfiprintf_r+0x153a>
42013ec9:	30a282        	movi	a8, 0x230
42013ecc:	8e8a      	add.n	a8, a14, a8
42013ece:	34a2d2        	movi	a13, 0x234
42013ed1:	40a2c2        	movi	a12, 0x240
42013ed4:	05ad      	mov.n	a10, a5
42013ed6:	0189      	s32i.n	a8, a1, 0
42013ed8:	01def2        	addmi	a15, a14, 0x100
42013edb:	deda      	add.n	a13, a14, a13
42013edd:	ceca      	add.n	a12, a14, a12
42013edf:	07bd      	mov.n	a11, a7
42013ee1:	fe59a5        	call8	4201247c <get_arg$isra$0>
42013ee4:	000a52        	l8ui	a5, a10, 0
42013ee7:	0029c6        	j	42013f92 <_svfiprintf_r+0x153a>
42013eea:	761b      	addi.n	a7, a6, 1
42013eec:	08a687        	bge	a6, a8, 42013ef8 <_svfiprintf_r+0x14a0>
42013eef:	b0e5e0        	addx8	a14, a5, a14
42013ef2:	000e52        	l8ui	a5, a14, 0
42013ef5:	0044c6        	j	4201400c <_svfiprintf_r+0x15b4>
42013ef8:	922e92        	l32i	a9, a14, 0x248
42013efb:	fb1c      	movi.n	a11, 31
42013efd:	02dee2        	addmi	a14, a14, 0x200
42013f00:	a94b      	addi.n	a10, a9, 4
42013f02:	362b87        	blt	a11, a8, 42013f3c <_svfiprintf_r+0x14e4>
42013f05:	b81b      	addi.n	a11, a8, 1
42013f07:	9161b2        	s32i	a11, a1, 0x244
42013f0a:	126ea2        	s32i	a10, a14, 72
42013f0d:	8b1c      	movi.n	a11, 24
42013f0f:	052ba7        	blt	a11, a10, 42013f18 <_svfiprintf_r+0x14c0>
42013f12:	112e92        	l32i	a9, a14, 68
42013f15:	000406        	j	42013f29 <_svfiprintf_r+0x14d1>
42013f18:	012b97        	blt	a11, a9, 42013f1d <_svfiprintf_r+0x14c5>
42013f1b:	4a2c      	movi.n	a10, 36
42013f1d:	10c192        	addi	a9, a1, 16
42013f20:	02d992        	addmi	a9, a9, 0x200
42013f23:	102992        	l32i	a9, a9, 64
42013f26:	9661a2        	s32i	a10, a1, 0x258
42013f29:	99aa      	add.n	a9, a9, a10
42013f2b:	fcc992        	addi	a9, a9, -4
42013f2e:	0958      	l32i.n	a5, a9, 0
42013f30:	b08810        	addx8	a8, a8, a1
42013f33:	4859      	s32i.n	a5, a8, 16
42013f35:	745050        	extui	a5, a5, 0, 8
42013f38:	003406        	j	4201400c <_svfiprintf_r+0x15b4>
42013f3b:	6ea200        	f64rnd	a10, a2, a0, 2
42013f3e:	881c12        	l16ui	a1, a12, 0x110
42013f41:	0728a7        	blt	a8, a10, 42013f4c <_svfiprintf_r+0x14f4>
42013f44:	112e82        	l32i	a8, a14, 68
42013f47:	000486        	j	42013f5d <_svfiprintf_r+0x1505>
42013f4a:	970000        	lsi	f0, a0, 0x25c
42013f4d:	0128      	l32i.n	a2, a1, 0
42013f4f:	4a2c      	movi.n	a10, 36
42013f51:	10c182        	addi	a8, a1, 16
42013f54:	02d882        	addmi	a8, a8, 0x200
42013f57:	102882        	l32i	a8, a8, 64
42013f5a:	9661a2        	s32i	a10, a1, 0x258
42013f5d:	88aa      	add.n	a8, a8, a10
42013f5f:	fcc882        	addi	a8, a8, -4
42013f62:	000852        	l8ui	a5, a8, 0
42013f65:	0028c6        	j	4201400c <_svfiprintf_r+0x15b4>
42013f68:	b3ac      	beqz.n	a3, 42013f97 <_svfiprintf_r+0x153f>
42013f6a:	07a587        	bge	a5, a8, 42013f75 <_svfiprintf_r+0x151d>
42013f6d:	b0e5e0        	addx8	a14, a5, a14
42013f70:	0e58      	l32i.n	a5, a14, 0
42013f72:	000706        	j	42013f92 <_svfiprintf_r+0x153a>
42013f75:	30a282        	movi	a8, 0x230
42013f78:	8e8a      	add.n	a8, a14, a8
42013f7a:	34a2d2        	movi	a13, 0x234
42013f7d:	40a2c2        	movi	a12, 0x240
42013f80:	05ad      	mov.n	a10, a5
42013f82:	0189      	s32i.n	a8, a1, 0
42013f84:	01def2        	addmi	a15, a14, 0x100
42013f87:	deda      	add.n	a13, a14, a13
42013f89:	ceca      	add.n	a12, a14, a12
42013f8b:	07bd      	mov.n	a11, a7
42013f8d:	fe4ee5        	call8	4201247c <get_arg$isra$0>
42013f90:	0a58      	l32i.n	a5, a10, 0
42013f92:	067d      	mov.n	a7, a6
42013f94:	001d06        	j	4201400c <_svfiprintf_r+0x15b4>
42013f97:	761b      	addi.n	a7, a6, 1
42013f99:	07a687        	bge	a6, a8, 42013fa4 <_svfiprintf_r+0x154c>
42013f9c:	b055e0        	addx8	a5, a5, a14
42013f9f:	0558      	l32i.n	a5, a5, 0
42013fa1:	0019c6        	j	4201400c <_svfiprintf_r+0x15b4>
42013fa4:	922e92        	l32i	a9, a14, 0x248
42013fa7:	fb1c      	movi.n	a11, 31
42013fa9:	02dee2        	addmi	a14, a14, 0x200
42013fac:	a94b      	addi.n	a10, a9, 4
42013fae:	322b87        	blt	a11, a8, 42013fe4 <_svfiprintf_r+0x158c>
42013fb1:	b81b      	addi.n	a11, a8, 1
42013fb3:	9161b2        	s32i	a11, a1, 0x244
42013fb6:	126ea2        	s32i	a10, a14, 72
42013fb9:	8b1c      	movi.n	a11, 24
42013fbb:	052ba7        	blt	a11, a10, 42013fc4 <_svfiprintf_r+0x156c>
42013fbe:	112e92        	l32i	a9, a14, 68
42013fc1:	000406        	j	42013fd5 <_svfiprintf_r+0x157d>
42013fc4:	012b97        	blt	a11, a9, 42013fc9 <_svfiprintf_r+0x1571>
42013fc7:	4a2c      	movi.n	a10, 36
42013fc9:	10c192        	addi	a9, a1, 16
42013fcc:	02d992        	addmi	a9, a9, 0x200
42013fcf:	102992        	l32i	a9, a9, 64
42013fd2:	9661a2        	s32i	a10, a1, 0x258
42013fd5:	99aa      	add.n	a9, a9, a10
42013fd7:	fcc992        	addi	a9, a9, -4
42013fda:	0958      	l32i.n	a5, a9, 0
42013fdc:	b08810        	addx8	a8, a8, a1
42013fdf:	4859      	s32i.n	a5, a8, 16
42013fe1:	0009c6        	j	4201400c <_svfiprintf_r+0x15b4>
42013fe4:	126ea2        	s32i	a10, a14, 72
42013fe7:	881c      	movi.n	a8, 24
42013fe9:	0728a7        	blt	a8, a10, 42013ff4 <_svfiprintf_r+0x159c>
42013fec:	112e82        	l32i	a8, a14, 68
42013fef:	000486        	j	42014005 <_svfiprintf_r+0x15ad>
42013ff2:	970000        	lsi	f0, a0, 0x25c
42013ff5:	0128      	l32i.n	a2, a1, 0
42013ff7:	4a2c      	movi.n	a10, 36
42013ff9:	10c182        	addi	a8, a1, 16
42013ffc:	02d882        	addmi	a8, a8, 0x200
42013fff:	102882        	l32i	a8, a8, 64
42014002:	9661a2        	s32i	a10, a1, 0x258
42014005:	88aa      	add.n	a8, a8, a10
42014007:	fcc882        	addi	a8, a8, -4
4201400a:	0858      	l32i.n	a5, a8, 0
4201400c:	030c      	movi.n	a3, 0
4201400e:	208530        	or	a8, a5, a3
42014011:	489c      	beqz.n	a8, 42014029 <_svfiprintf_r+0x15d1>
42014013:	126207        	bbci	a2, 0, 42014029 <_svfiprintf_r+0x15d1>
42014016:	10c182        	addi	a8, a1, 16
42014019:	02d882        	addmi	a8, a8, 0x200
4201401c:	093c      	movi.n	a9, 48
4201401e:	384892        	s8i	a9, a8, 56
42014021:	394842        	s8i	a4, a8, 57
42014024:	280c      	movi.n	a8, 2
42014026:	202280        	or	a2, a2, a8
42014029:	ffab82        	movi	a8, 0xfffffbff
4201402c:	102280        	and	a2, a2, a8
4201402f:	290c      	movi.n	a9, 2
42014031:	080c      	movi.n	a8, 0
42014033:	10c1a2        	addi	a10, a1, 16
42014036:	02daa2        	addmi	a10, a10, 0x200
42014039:	3a4a82        	s8i	a8, a10, 58
4201403c:	9b2182        	l32i	a8, a1, 0x26c
4201403f:	01d896        	bltz	a8, 42014060 <_svfiprintf_r+0x1608>
42014042:	20a220        	or	a10, a2, a2
42014045:	7faf82        	movi	a8, -129
42014048:	102280        	and	a2, a2, a8
4201404b:	1b0c      	movi.n	a11, 1
4201404d:	208530        	or	a8, a5, a3
42014050:	83b880        	moveqz	a11, a8, a8
42014053:	98cc      	bnez.n	a8, 42014060 <_svfiprintf_r+0x1608>
42014055:	9b21c2        	l32i	a12, a1, 0x26c
42014058:	180c      	movi.n	a8, 1
4201405a:	838bc0        	moveqz	a8, a11, a12
4201405d:	12d816        	beqz	a8, 4201418e <_svfiprintf_r+0x1736>
42014060:	421926        	beqi	a9, 1, 420140a6 <_svfiprintf_r+0x164e>
42014063:	e4a182        	movi	a8, 0x1e4
42014066:	022966        	bnei	a9, 2, 4201406c <_svfiprintf_r+0x1614>
42014069:	003dc6        	j	42014164 <_svfiprintf_r+0x170c>
4201406c:	10c192        	addi	a9, a1, 16
4201406f:	498a      	add.n	a4, a9, a8
42014071:	249050        	extui	a9, a5, 0, 3
42014074:	04ad      	mov.n	a10, a4
42014076:	404300        	ssai	3
42014079:	815350        	src	a5, a3, a5
4201407c:	440b      	addi.n	a4, a4, -1
4201407e:	30c992        	addi	a9, a9, 48
42014081:	413330        	srli	a3, a3, 3
42014084:	004492        	s8i	a9, a4, 0
42014087:	20b530        	or	a11, a5, a3
4201408a:	fe3b56        	bnez	a11, 42014071 <_svfiprintf_r+0x1619>
4201408d:	d0c992        	addi	a9, a9, -48
42014090:	128916        	beqz	a9, 420141bc <_svfiprintf_r+0x1764>
42014093:	02e207        	bbsi	a2, 0, 42014099 <_svfiprintf_r+0x1641>
42014096:	004886        	j	420141bc <_svfiprintf_r+0x1764>
42014099:	840b      	addi.n	a8, a4, -1
4201409b:	093c      	movi.n	a9, 48
4201409d:	004892        	s8i	a9, a8, 0
420140a0:	feca42        	addi	a4, a10, -2
420140a3:	004546        	j	420141bc <_svfiprintf_r+0x1764>
420140a6:	63dc      	bnez.n	a3, 420140c0 <_svfiprintf_r+0x1668>
420140a8:	980c      	movi.n	a8, 9
420140aa:	123857        	bltu	a8, a5, 420140c0 <_svfiprintf_r+0x1668>
420140ad:	10c182        	addi	a8, a1, 16
420140b0:	01d892        	addmi	a9, a8, 0x100
420140b3:	30c552        	addi	a5, a5, 48
420140b6:	e34952        	s8i	a5, a9, 227
420140b9:	e3a192        	movi	a9, 0x1e3
420140bc:	003e86        	j	420141ba <_svfiprintf_r+0x1762>
420140bf:	a18200        	sll	a8, a2
420140c2:	a462f4        	lsi	f15, a2, 0x290
420140c5:	0e0c00        	lsi	f0, a12, 56
420140c8:	818a      	add.n	a8, a1, a8
420140ca:	106260        	and	a6, a2, a6
420140cd:	a461e2        	s32i	a14, a1, 0x290
420140d0:	ac0c      	movi.n	a12, 10
420140d2:	0d0c      	movi.n	a13, 0
420140d4:	05ad      	mov.n	a10, a5
420140d6:	03bd      	mov.n	a11, a3
420140d8:	480b      	addi.n	a4, a8, -1
420140da:	b31781        	l32r	a8, 42000d38 <_stext+0xd18> (40002574 <__umoddi3>)
420140dd:	0008e0        	callx8	a8
420140e0:	a421e2        	l32i	a14, a1, 0x290
420140e3:	30caa2        	addi	a10, a10, 48
420140e6:	0044a2        	s8i	a10, a4, 0
420140e9:	ee1b      	addi.n	a14, a14, 1
420140eb:	04e616        	beqz	a6, 4201413d <_svfiprintf_r+0x16e5>
420140ee:	a02182        	l32i	a8, a1, 0x280
420140f1:	01af92        	movi	a9, -255
420140f4:	0008a2        	l8ui	a10, a8, 0
420140f7:	9a9a      	add.n	a9, a10, a9
420140f9:	040916        	beqz	a9, 4201413d <_svfiprintf_r+0x16e5>
420140fc:	3d9ae7        	bne	a10, a14, 4201413d <_svfiprintf_r+0x16e5>
420140ff:	63cc      	bnez.n	a3, 42014109 <_svfiprintf_r+0x16b1>
42014101:	990c      	movi.n	a9, 9
42014103:	023957        	bltu	a9, a5, 42014109 <_svfiprintf_r+0x16b1>
42014106:	002c86        	j	420141bc <_svfiprintf_r+0x1764>
42014109:	a12182        	l32i	a8, a1, 0x284
4201410c:	a321b2        	l32i	a11, a1, 0x28c
4201410f:	c04480        	sub	a4, a4, a8
42014112:	08cd      	mov.n	a12, a8
42014114:	20a440        	or	a10, a4, a4
42014117:	b2b781        	l32r	a8, 42000bf4 <_stext+0xbd4> (40001224 <strncpy>)
4201411a:	0008e0        	callx8	a8
4201411d:	a02182        	l32i	a8, a1, 0x280
42014120:	010892        	l8ui	a9, a8, 1
42014123:	398c      	beqz.n	a9, 4201412a <_svfiprintf_r+0x16d2>
42014125:	881b      	addi.n	a8, a8, 1
42014127:	a06182        	s32i	a8, a1, 0x280
4201412a:	ac0c      	movi.n	a12, 10
4201412c:	0d0c      	movi.n	a13, 0
4201412e:	05ad      	mov.n	a10, a5
42014130:	03bd      	mov.n	a11, a3
42014132:	b00b81        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
42014135:	0008e0        	callx8	a8
42014138:	0e0c      	movi.n	a14, 0
4201413a:	000706        	j	4201415a <_svfiprintf_r+0x1702>
4201413d:	a461e2        	s32i	a14, a1, 0x290
42014140:	ac0c      	movi.n	a12, 10
42014142:	0d0c      	movi.n	a13, 0
42014144:	20a550        	or	a10, a5, a5
42014147:	20b330        	or	a11, a3, a3
4201414a:	b00581        	l32r	a8, 42000160 <_stext+0x140> (40002544 <__udivdi3>)
4201414d:	0008e0        	callx8	a8
42014150:	a421e2        	l32i	a14, a1, 0x290
42014153:	33cc      	bnez.n	a3, 4201415a <_svfiprintf_r+0x1702>
42014155:	990c      	movi.n	a9, 9
42014157:	61b957        	bgeu	a9, a5, 420141bc <_svfiprintf_r+0x1764>
4201415a:	0a5d      	mov.n	a5, a10
4201415c:	0b3d      	mov.n	a3, a11
4201415e:	048d      	mov.n	a8, a4
42014160:	ffda46        	j	420140cd <_svfiprintf_r+0x1675>
42014163:	c19200        	mul16u	a9, a2, a0
42014166:	498a10        	s32e	a1, a10, -32
42014169:	a22182        	l32i	a8, a1, 0x288
4201416c:	349050        	extui	a9, a5, 0, 4
4201416f:	989a      	add.n	a9, a8, a9
42014171:	000992        	l8ui	a9, a9, 0
42014174:	404400        	ssai	4
42014177:	815350        	src	a5, a3, a5
4201417a:	440b      	addi.n	a4, a4, -1
4201417c:	413430        	srli	a3, a3, 4
4201417f:	004492        	s8i	a9, a4, 0
42014182:	209530        	or	a9, a5, a3
42014185:	fe0956        	bnez	a9, 42014169 <_svfiprintf_r+0x1711>
42014188:	000c06        	j	420141bc <_svfiprintf_r+0x1764>
4201418b:	000000        	ill
4201418e:	080c      	movi.n	a8, 0
42014190:	9b6182        	s32i	a8, a1, 0x26c
42014193:	10c1b2        	addi	a11, a1, 16
42014196:	e4a182        	movi	a8, 0x1e4
42014199:	4b8a      	add.n	a4, a11, a8
4201419b:	d9dc      	bnez.n	a9, 420141bc <_svfiprintf_r+0x1764>
4201419d:	0480a0        	extui	a8, a10, 0, 1
420141a0:	9b6182        	s32i	a8, a1, 0x26c
420141a3:	9b2182        	l32i	a8, a1, 0x26c
420141a6:	289c      	beqz.n	a8, 420141bc <_svfiprintf_r+0x1764>
420141a8:	01db82        	addmi	a8, a11, 0x100
420141ab:	093c      	movi.n	a9, 48
420141ad:	e34892        	s8i	a9, a8, 227
420141b0:	080c      	movi.n	a8, 0
420141b2:	9b6182        	s32i	a8, a1, 0x26c
420141b5:	0b9d      	mov.n	a9, a11
420141b7:	e3a182        	movi	a8, 0x1e3
420141ba:	498a      	add.n	a4, a9, a8
420141bc:	a52182        	l32i	a8, a1, 0x294
420141bf:	9b2162        	l32i	a6, a1, 0x26c
420141c2:	c08840        	sub	a8, a8, a4
420141c5:	9b6182        	s32i	a8, a1, 0x26c
420141c8:	000886        	j	420141ee <_svfiprintf_r+0x1796>
420141cb:	841600        	extui	a1, a0, 6, 9
420141ce:	4e          	.byte	0x4e
420141cf:	10c182        	addi	a8, a1, 16
420141d2:	01d892        	addmi	a9, a8, 0x100
420141d5:	804942        	s8i	a4, a9, 128
420141d8:	0a0c      	movi.n	a10, 0
420141da:	02d892        	addmi	a9, a8, 0x200
420141dd:	3a49a2        	s8i	a10, a9, 58
420141e0:	067d      	mov.n	a7, a6
420141e2:	190c      	movi.n	a9, 1
420141e4:	9b6192        	s32i	a9, a1, 0x26c
420141e7:	80a192        	movi	a9, 0x180
420141ea:	060c      	movi.n	a6, 0
420141ec:	489a      	add.n	a4, a8, a9
420141ee:	9b2182        	l32i	a8, a1, 0x26c
420141f1:	535680        	max	a5, a6, a8
420141f4:	10c182        	addi	a8, a1, 16
420141f7:	02d892        	addmi	a9, a8, 0x200
420141fa:	3a0992        	l8ui	a9, a9, 58
420141fd:	098c      	beqz.n	a9, 42014201 <_svfiprintf_r+0x17a9>
420141ff:	551b      	addi.n	a5, a5, 1
42014201:	230c      	movi.n	a3, 2
42014203:	103230        	and	a3, a2, a3
42014206:	002316        	beqz	a3, 4201420c <_svfiprintf_r+0x17b4>
42014209:	02c552        	addi	a5, a5, 2
4201420c:	84a082        	movi	a8, 132
4201420f:	108280        	and	a8, a2, a8
42014212:	a46182        	s32i	a8, a1, 0x290
42014215:	0d5856        	bnez	a8, 420142ee <_svfiprintf_r+0x1896>
42014218:	9e2182        	l32i	a8, a1, 0x278
4201421b:	10c1e2        	addi	a14, a1, 16
4201421e:	24a2c2        	movi	a12, 0x224
42014221:	c09850        	sub	a9, a8, a5
42014224:	ceca      	add.n	a12, a14, a12
42014226:	5819e6        	bgei	a9, 1, 42014282 <_svfiprintf_r+0x182a>
42014229:	003046        	j	420142ee <_svfiprintf_r+0x1896>
4201422c:	982182        	l32i	a8, a1, 0x260
4201422f:	b2f4f1        	l32r	a15, 42000e00 <_stext+0xde0> (3c029a3c <blanks$1>)
42014232:	0168d2        	s32i	a13, a8, 4
42014235:	0068f2        	s32i	a15, a8, 0
42014238:	972182        	l32i	a8, a1, 0x25c
4201423b:	10c882        	addi	a8, a8, 16
4201423e:	976182        	s32i	a8, a1, 0x25c
42014241:	348ba6        	blti	a11, 8, 42014279 <_svfiprintf_r+0x1821>
42014244:	8a6eb2        	s32i	a11, a14, 0x228
42014247:	9d21a2        	l32i	a10, a1, 0x274
4201424a:	9c21b2        	l32i	a11, a1, 0x270
4201424d:	02ded2        	addmi	a13, a14, 0x200
42014250:	8b6e82        	s32i	a8, a14, 0x22c
42014253:	9761d2        	s32i	a13, a1, 0x25c
42014256:	986192        	s32i	a9, a1, 0x260
42014259:	fe6f25        	call8	4201294c <__ssprint_r>
4201425c:	9721d2        	l32i	a13, a1, 0x25c
4201425f:	bd88      	l32i.n	a8, a13, 44
42014261:	adb8      	l32i.n	a11, a13, 40
42014263:	976182        	s32i	a8, a1, 0x25c
42014266:	472a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
42014269:	e4a1a2        	movi	a10, 0x1e4
4201426c:	10c1e2        	addi	a14, a1, 16
4201426f:	34a2c2        	movi	a12, 0x234
42014272:	982192        	l32i	a9, a1, 0x260
42014275:	aeaa      	add.n	a10, a14, a10
42014277:	cc1a      	add.n	a12, a12, a1
42014279:	f0c992        	addi	a9, a9, -16
4201427c:	9961b2        	s32i	a11, a1, 0x264
4201427f:	9861a2        	s32i	a10, a1, 0x260
42014282:	992182        	l32i	a8, a1, 0x264
42014285:	0d1c      	movi.n	a13, 16
42014287:	b81b      	addi.n	a11, a8, 1
42014289:	982182        	l32i	a8, a1, 0x260
4201428c:	a88b      	addi.n	a10, a8, 8
4201428e:	9a2d97        	blt	a13, a9, 4201422c <_svfiprintf_r+0x17d4>
42014291:	b2dbc1        	l32r	a12, 42000e00 <_stext+0xde0> (3c029a3c <blanks$1>)
42014294:	1899      	s32i.n	a9, a8, 4
42014296:	08c9      	s32i.n	a12, a8, 0
42014298:	972182        	l32i	a8, a1, 0x25c
4201429b:	808890        	add	a8, a8, a9
4201429e:	976182        	s32i	a8, a1, 0x25c
420142a1:	992182        	l32i	a8, a1, 0x264
420142a4:	4078a6        	blti	a8, 7, 420142e8 <_svfiprintf_r+0x1890>
420142a7:	9721a2        	l32i	a10, a1, 0x25c
420142aa:	10c192        	addi	a9, a1, 16
420142ad:	8e61b2        	s32i	a11, a1, 0x238
420142b0:	8f61a2        	s32i	a10, a1, 0x23c
420142b3:	9c21b2        	l32i	a11, a1, 0x270
420142b6:	9d21a2        	l32i	a10, a1, 0x274
420142b9:	24a2c2        	movi	a12, 0x224
420142bc:	02d982        	addmi	a8, a9, 0x200
420142bf:	80c9c0        	add	a12, a9, a12
420142c2:	976182        	s32i	a8, a1, 0x25c
420142c5:	fe6865        	call8	4201294c <__ssprint_r>
420142c8:	972182        	l32i	a8, a1, 0x25c
420142cb:	a898      	l32i.n	a9, a8, 40
420142cd:	b888      	l32i.n	a8, a8, 44
420142cf:	996192        	s32i	a9, a1, 0x264
420142d2:	976182        	s32i	a8, a1, 0x25c
420142d5:	403a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
420142d8:	e4a1a2        	movi	a10, 0x1e4
420142db:	10c192        	addi	a9, a1, 16
420142de:	89aa      	add.n	a8, a9, a10
420142e0:	986182        	s32i	a8, a1, 0x260
420142e3:	0001c6        	j	420142ee <_svfiprintf_r+0x1896>
420142e6:	b20000        	mulsh	a0, a0, a0
420142e9:	a29961        	l32r	a6, 41ffcd50 <_coredump_iram_end+0x1c7ae50>
420142ec:	829861        	l32r	a6, 41ff4d4c <_coredump_iram_end+0x1c72e4c>
420142ef:	8210c1        	l32r	a12, 41ff4b30 <_coredump_iram_end+0x1c72c30>
420142f2:	02d8      	l32i.n	a13, a2, 0
420142f4:	3a0892        	l8ui	a9, a8, 58
420142f7:	065916        	beqz	a9, 42014360 <_svfiprintf_r+0x1908>
420142fa:	992192        	l32i	a9, a1, 0x264
420142fd:	10c1b2        	addi	a11, a1, 16
42014300:	a91b      	addi.n	a10, a9, 1
42014302:	3aa292        	movi	a9, 0x23a
42014305:	9b9a      	add.n	a9, a11, a9
42014307:	9821b2        	l32i	a11, a1, 0x260
4201430a:	0b99      	s32i.n	a9, a11, 0
4201430c:	190c      	movi.n	a9, 1
4201430e:	1b99      	s32i.n	a9, a11, 4
42014310:	972192        	l32i	a9, a1, 0x25c
42014313:	991b      	addi.n	a9, a9, 1
42014315:	976192        	s32i	a9, a1, 0x25c
42014318:	992192        	l32i	a9, a1, 0x264
4201431b:	0a79e6        	bgei	a9, 7, 42014329 <_svfiprintf_r+0x18d1>
4201431e:	8b8b      	addi.n	a8, a11, 8
42014320:	986182        	s32i	a8, a1, 0x260
42014323:	9961a2        	s32i	a10, a1, 0x264
42014326:	000d86        	j	42014360 <_svfiprintf_r+0x1908>
42014329:	972192        	l32i	a9, a1, 0x25c
4201432c:	a8a9      	s32i.n	a10, a8, 40
4201432e:	b899      	s32i.n	a9, a8, 44
42014330:	976182        	s32i	a8, a1, 0x25c
42014333:	9c21b2        	l32i	a11, a1, 0x270
42014336:	10c182        	addi	a8, a1, 16
42014339:	9d21a2        	l32i	a10, a1, 0x274
4201433c:	24a2c2        	movi	a12, 0x224
4201433f:	80c8c0        	add	a12, a8, a12
42014342:	fe60a5        	call8	4201294c <__ssprint_r>
42014345:	972182        	l32i	a8, a1, 0x25c
42014348:	a898      	l32i.n	a9, a8, 40
4201434a:	b888      	l32i.n	a8, a8, 44
4201434c:	996192        	s32i	a9, a1, 0x264
4201434f:	976182        	s32i	a8, a1, 0x25c
42014352:	386a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
42014355:	e4a192        	movi	a9, 0x1e4
42014358:	10c182        	addi	a8, a1, 16
4201435b:	889a      	add.n	a8, a8, a9
4201435d:	986182        	s32i	a8, a1, 0x260
42014360:	068316        	beqz	a3, 420143cc <_svfiprintf_r+0x1974>
42014363:	992182        	l32i	a8, a1, 0x264
42014366:	38a292        	movi	a9, 0x238
42014369:	a81b      	addi.n	a10, a8, 1
4201436b:	10c182        	addi	a8, a1, 16
4201436e:	989a      	add.n	a9, a8, a9
42014370:	982182        	l32i	a8, a1, 0x260
42014373:	0899      	s32i.n	a9, a8, 0
42014375:	290c      	movi.n	a9, 2
42014377:	1899      	s32i.n	a9, a8, 4
42014379:	972182        	l32i	a8, a1, 0x25c
4201437c:	882b      	addi.n	a8, a8, 2
4201437e:	976182        	s32i	a8, a1, 0x25c
42014381:	992182        	l32i	a8, a1, 0x264
42014384:	0d78e6        	bgei	a8, 7, 42014395 <_svfiprintf_r+0x193d>
42014387:	982182        	l32i	a8, a1, 0x260
4201438a:	9961a2        	s32i	a10, a1, 0x264
4201438d:	888b      	addi.n	a8, a8, 8
4201438f:	986182        	s32i	a8, a1, 0x260
42014392:	000d86        	j	420143cc <_svfiprintf_r+0x1974>
42014395:	10c182        	addi	a8, a1, 16
42014398:	02d832        	addmi	a3, a8, 0x200
4201439b:	972182        	l32i	a8, a1, 0x25c
4201439e:	8e61a2        	s32i	a10, a1, 0x238
420143a1:	b389      	s32i.n	a8, a3, 44
420143a3:	9c21b2        	l32i	a11, a1, 0x270
420143a6:	10c182        	addi	a8, a1, 16
420143a9:	9d21a2        	l32i	a10, a1, 0x274
420143ac:	24a2c2        	movi	a12, 0x224
420143af:	c8ca      	add.n	a12, a8, a12
420143b1:	fe59a5        	call8	4201294c <__ssprint_r>
420143b4:	a388      	l32i.n	a8, a3, 40
420143b6:	996182        	s32i	a8, a1, 0x264
420143b9:	b388      	l32i.n	a8, a3, 44
420143bb:	976182        	s32i	a8, a1, 0x25c
420143be:	31aa56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
420143c1:	e4a192        	movi	a9, 0x1e4
420143c4:	10c182        	addi	a8, a1, 16
420143c7:	889a      	add.n	a8, a8, a9
420143c9:	986182        	s32i	a8, a1, 0x260
420143cc:	a42182        	l32i	a8, a1, 0x290
420143cf:	02e826        	beqi	a8, 128, 420143d5 <_svfiprintf_r+0x197d>
420143d2:	003406        	j	420144a6 <_svfiprintf_r+0x1a4e>
420143d5:	9e2182        	l32i	a8, a1, 0x278
420143d8:	c08850        	sub	a8, a8, a5
420143db:	0218e6        	bgei	a8, 1, 420143e1 <_svfiprintf_r+0x1989>
420143de:	003106        	j	420144a6 <_svfiprintf_r+0x1a4e>
420143e1:	10c192        	addi	a9, a1, 16
420143e4:	24a232        	movi	a3, 0x224
420143e7:	a93a      	add.n	a10, a9, a3
420143e9:	a461a2        	s32i	a10, a1, 0x290
420143ec:	001346        	j	4201443d <_svfiprintf_r+0x19e5>
420143ef:	21d200        	srai	a13, a0, 2
420143f2:	e198      	l32i.n	a9, a1, 56
420143f4:	c9b284        	lsi	f8, a2, 0x324
420143f7:	c21d      	lsi	f1, a2, 8
420143f9:	e99721        	l32r	a2, 4200ea58 <get_arg$isra$0+0x290> (1488052c <UserFrameTotalSize+0x1488042c>)
420143fc:	c20d      	lsi	f0, a2, 8
420143fe:	10cc      	bnez.n	a0, 42014403 <_svfiprintf_r+0x19ab>
42014400:	9761c2        	s32i	a12, a1, 0x25c
42014403:	2d8ba6        	blti	a11, 8, 42014434 <_svfiprintf_r+0x19dc>
42014406:	8a69b2        	s32i	a11, a9, 0x228
42014409:	8b69c2        	s32i	a12, a9, 0x22c
4201440c:	9c21b2        	l32i	a11, a1, 0x270
4201440f:	a421c2        	l32i	a12, a1, 0x290
42014412:	9d21a2        	l32i	a10, a1, 0x274
42014415:	02d932        	addmi	a3, a9, 0x200
42014418:	986182        	s32i	a8, a1, 0x260
4201441b:	fe5325        	call8	4201294c <__ssprint_r>
4201441e:	b388      	l32i.n	a8, a3, 44
42014420:	a3b8      	l32i.n	a11, a3, 40
42014422:	976182        	s32i	a8, a1, 0x25c
42014425:	2b3a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
42014428:	e4a1a2        	movi	a10, 0x1e4
4201442b:	10c192        	addi	a9, a1, 16
4201442e:	982182        	l32i	a8, a1, 0x260
42014431:	80a9a0        	add	a10, a9, a10
42014434:	f0c882        	addi	a8, a8, -16
42014437:	9961b2        	s32i	a11, a1, 0x264
4201443a:	9861a2        	s32i	a10, a1, 0x260
4201443d:	9921a2        	l32i	a10, a1, 0x264
42014440:	0c1c      	movi.n	a12, 16
42014442:	ba1b      	addi.n	a11, a10, 1
42014444:	9821a2        	l32i	a10, a1, 0x260
42014447:	aa8b      	addi.n	a10, a10, 8
42014449:	a32c87        	blt	a12, a8, 420143f0 <_svfiprintf_r+0x1998>
4201444c:	982192        	l32i	a9, a1, 0x260
4201444f:	b26dc1        	l32r	a12, 42000e04 <_stext+0xde4> (3c029a2c <zeroes$0>)
42014452:	1989      	s32i.n	a8, a9, 4
42014454:	09c9      	s32i.n	a12, a9, 0
42014456:	972192        	l32i	a9, a1, 0x25c
42014459:	898a      	add.n	a8, a9, a8
4201445b:	976182        	s32i	a8, a1, 0x25c
4201445e:	992182        	l32i	a8, a1, 0x264
42014461:	3b78a6        	blti	a8, 7, 420144a0 <_svfiprintf_r+0x1a48>
42014464:	972192        	l32i	a9, a1, 0x25c
42014467:	10c132        	addi	a3, a1, 16
4201446a:	8e61b2        	s32i	a11, a1, 0x238
4201446d:	9d21a2        	l32i	a10, a1, 0x274
42014470:	9c21b2        	l32i	a11, a1, 0x270
42014473:	24a2c2        	movi	a12, 0x224
42014476:	02d382        	addmi	a8, a3, 0x200
42014479:	c3ca      	add.n	a12, a3, a12
4201447b:	8f6192        	s32i	a9, a1, 0x23c
4201447e:	976182        	s32i	a8, a1, 0x25c
42014481:	fe4ca5        	call8	4201294c <__ssprint_r>
42014484:	972182        	l32i	a8, a1, 0x25c
42014487:	a898      	l32i.n	a9, a8, 40
42014489:	b888      	l32i.n	a8, a8, 44
4201448b:	996192        	s32i	a9, a1, 0x264
4201448e:	976182        	s32i	a8, a1, 0x25c
42014491:	247a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
42014494:	e4a192        	movi	a9, 0x1e4
42014497:	839a      	add.n	a8, a3, a9
42014499:	986182        	s32i	a8, a1, 0x260
4201449c:	000186        	j	420144a6 <_svfiprintf_r+0x1a4e>
4201449f:	61b200        	xsr.epc2	a0
420144a2:	a299      	s32i.n	a9, a2, 40
420144a4:	829861        	l32r	a6, 41ff4f04 <_coredump_iram_end+0x1c73004>
420144a7:	809b21        	l32r	a2, 41ff4714 <_coredump_iram_end+0x1c72814>
420144aa:	e6c066        	bnei	a0, 32, 42014494 <_svfiprintf_r+0x1a3c>
420144ad:	060216        	beqz	a2, 42014511 <_svfiprintf_r+0x1ab9>
420144b0:	2f          	.byte	0x2f
420144b1:	a23200        	muluh	a3, a2, a0
420144b4:	c18224        	lsi	f2, a2, 0x304
420144b7:	c83a10        	lsi	f1, a10, 0x320
420144ba:	0013c6        	j	4201450d <_svfiprintf_r+0x1ab5>
420144bd:	982182        	l32i	a8, a1, 0x260
420144c0:	b251d1        	l32r	a13, 42000e04 <_stext+0xde4> (3c029a2c <zeroes$0>)
420144c3:	18a9      	s32i.n	a10, a8, 4
420144c5:	08d9      	s32i.n	a13, a8, 0
420144c7:	972182        	l32i	a8, a1, 0x25c
420144ca:	10c882        	addi	a8, a8, 16
420144cd:	976182        	s32i	a8, a1, 0x25c
420144d0:	308ba6        	blti	a11, 8, 42014504 <_svfiprintf_r+0x1aac>
420144d3:	10c182        	addi	a8, a1, 16
420144d6:	02d832        	addmi	a3, a8, 0x200
420144d9:	972182        	l32i	a8, a1, 0x25c
420144dc:	8e61b2        	s32i	a11, a1, 0x238
420144df:	9d21a2        	l32i	a10, a1, 0x274
420144e2:	9c21b2        	l32i	a11, a1, 0x270
420144e5:	0b6382        	s32i	a8, a3, 44
420144e8:	9861c2        	s32i	a12, a1, 0x260
420144eb:	fe4625        	call8	4201294c <__ssprint_r>
420144ee:	b388      	l32i.n	a8, a3, 44
420144f0:	a3b8      	l32i.n	a11, a3, 40
420144f2:	976182        	s32i	a8, a1, 0x25c
420144f5:	1e3a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
420144f8:	e4a192        	movi	a9, 0x1e4
420144fb:	10c182        	addi	a8, a1, 16
420144fe:	9821c2        	l32i	a12, a1, 0x260
42014501:	809890        	add	a9, a8, a9
42014504:	f0c662        	addi	a6, a6, -16
42014507:	9961b2        	s32i	a11, a1, 0x264
4201450a:	986192        	s32i	a9, a1, 0x260
4201450d:	992182        	l32i	a8, a1, 0x264
42014510:	0a1c      	movi.n	a10, 16
42014512:	b81b      	addi.n	a11, a8, 1
42014514:	982182        	l32i	a8, a1, 0x260
42014517:	988b      	addi.n	a9, a8, 8
42014519:	a02a67        	blt	a10, a6, 420144bd <_svfiprintf_r+0x1a65>
4201451c:	b23aa1        	l32r	a10, 42000e04 <_stext+0xde4> (3c029a2c <zeroes$0>)
4201451f:	1869      	s32i.n	a6, a8, 4
42014521:	08a9      	s32i.n	a10, a8, 0
42014523:	972182        	l32i	a8, a1, 0x25c
42014526:	886a      	add.n	a8, a8, a6
42014528:	976182        	s32i	a8, a1, 0x25c
4201452b:	992182        	l32i	a8, a1, 0x264
4201452e:	3778a6        	blti	a8, 7, 42014569 <_svfiprintf_r+0x1b11>
42014531:	972182        	l32i	a8, a1, 0x25c
42014534:	10c132        	addi	a3, a1, 16
42014537:	8e61b2        	s32i	a11, a1, 0x238
4201453a:	9d21a2        	l32i	a10, a1, 0x274
4201453d:	9c21b2        	l32i	a11, a1, 0x270
42014540:	24a2c2        	movi	a12, 0x224
42014543:	80c3c0        	add	a12, a3, a12
42014546:	8f6182        	s32i	a8, a1, 0x23c
42014549:	fe4025        	call8	4201294c <__ssprint_r>
4201454c:	8e2182        	l32i	a8, a1, 0x238
4201454f:	02d362        	addmi	a6, a3, 0x200
42014552:	996182        	s32i	a8, a1, 0x264
42014555:	8f2182        	l32i	a8, a1, 0x23c
42014558:	976182        	s32i	a8, a1, 0x25c
4201455b:	17da56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
4201455e:	e4a192        	movi	a9, 0x1e4
42014561:	839a      	add.n	a8, a3, a9
42014563:	986182        	s32i	a8, a1, 0x260
42014566:	000146        	j	4201456f <_svfiprintf_r+0x1b17>
42014569:	9961b2        	s32i	a11, a1, 0x264
4201456c:	986192        	s32i	a9, a1, 0x260
4201456f:	982182        	l32i	a8, a1, 0x260
42014572:	9b2192        	l32i	a9, a1, 0x26c
42014575:	0849      	s32i.n	a4, a8, 0
42014577:	1899      	s32i.n	a9, a8, 4
42014579:	972182        	l32i	a8, a1, 0x25c
4201457c:	889a      	add.n	a8, a8, a9
4201457e:	976182        	s32i	a8, a1, 0x25c
42014581:	992182        	l32i	a8, a1, 0x264
42014584:	981b      	addi.n	a9, a8, 1
42014586:	982182        	l32i	a8, a1, 0x260
42014589:	888b      	addi.n	a8, a8, 8
4201458b:	3189a6        	blti	a9, 8, 420145c0 <_svfiprintf_r+0x1b68>
4201458e:	10c182        	addi	a8, a1, 16
42014591:	02d862        	addmi	a6, a8, 0x200
42014594:	972182        	l32i	a8, a1, 0x25c
42014597:	9c21b2        	l32i	a11, a1, 0x270
4201459a:	b689      	s32i.n	a8, a6, 44
4201459c:	9d21a2        	l32i	a10, a1, 0x274
4201459f:	10c182        	addi	a8, a1, 16
420145a2:	24a2c2        	movi	a12, 0x224
420145a5:	80c8c0        	add	a12, a8, a12
420145a8:	8e6192        	s32i	a9, a1, 0x238
420145ab:	fe3a25        	call8	4201294c <__ssprint_r>
420145ae:	b688      	l32i.n	a8, a6, 44
420145b0:	a698      	l32i.n	a9, a6, 40
420145b2:	976182        	s32i	a8, a1, 0x25c
420145b5:	123a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
420145b8:	e4a182        	movi	a8, 0x1e4
420145bb:	10c1a2        	addi	a10, a1, 16
420145be:	8a8a      	add.n	a8, a10, a8
420145c0:	02e227        	bbsi	a2, 2, 420145c6 <_svfiprintf_r+0x1b6e>
420145c3:	002846        	j	42014668 <_svfiprintf_r+0x1c10>
420145c6:	9e21a2        	l32i	a10, a1, 0x278
420145c9:	c03a50        	sub	a3, a10, a5
420145cc:	0213e6        	bgei	a3, 1, 420145d2 <_svfiprintf_r+0x1b7a>
420145cf:	002546        	j	42014668 <_svfiprintf_r+0x1c10>
420145d2:	10c122        	addi	a2, a1, 16
420145d5:	24a242        	movi	a4, 0x224
420145d8:	424a      	add.n	a4, a2, a4
420145da:	001106        	j	42014622 <_svfiprintf_r+0x1bca>
420145dd:	b20891        	l32r	a9, 42000e00 <_stext+0xde0> (3c029a3c <blanks$1>)
420145e0:	18a9      	s32i.n	a10, a8, 4
420145e2:	0899      	s32i.n	a9, a8, 0
420145e4:	972192        	l32i	a9, a1, 0x25c
420145e7:	08c882        	addi	a8, a8, 8
420145ea:	10c992        	addi	a9, a9, 16
420145ed:	976192        	s32i	a9, a1, 0x25c
420145f0:	298ba6        	blti	a11, 8, 4201461d <_svfiprintf_r+0x1bc5>
420145f3:	972182        	l32i	a8, a1, 0x25c
420145f6:	8a62b2        	s32i	a11, a2, 0x228
420145f9:	9d21a2        	l32i	a10, a1, 0x274
420145fc:	9c21b2        	l32i	a11, a1, 0x270
420145ff:	8b6282        	s32i	a8, a2, 0x22c
42014602:	20c440        	or	a12, a4, a4
42014605:	fe3465        	call8	4201294c <__ssprint_r>
42014608:	8b2282        	l32i	a8, a2, 0x22c
4201460b:	8a22b2        	l32i	a11, a2, 0x228
4201460e:	976182        	s32i	a8, a1, 0x25c
42014611:	02d262        	addmi	a6, a2, 0x200
42014614:	0c4a56        	bnez	a10, 420146dc <_svfiprintf_r+0x1c84>
42014617:	e4a182        	movi	a8, 0x1e4
4201461a:	808280        	add	a8, a2, a8
4201461d:	f0c332        	addi	a3, a3, -16
42014620:	0b9d      	mov.n	a9, a11
42014622:	0a1c      	movi.n	a10, 16
42014624:	b91b      	addi.n	a11, a9, 1
42014626:	b32a37        	blt	a10, a3, 420145dd <_svfiprintf_r+0x1b85>
42014629:	b1f5a1        	l32r	a10, 42000e00 <_stext+0xde0> (3c029a3c <blanks$1>)
4201462c:	1839      	s32i.n	a3, a8, 4
4201462e:	08a9      	s32i.n	a10, a8, 0
42014630:	972182        	l32i	a8, a1, 0x25c
42014633:	883a      	add.n	a8, a8, a3
42014635:	976182        	s32i	a8, a1, 0x25c
42014638:	2a79a6        	blti	a9, 7, 42014666 <_svfiprintf_r+0x1c0e>
4201463b:	10c182        	addi	a8, a1, 16
4201463e:	972192        	l32i	a9, a1, 0x25c
42014641:	8e61b2        	s32i	a11, a1, 0x238
42014644:	9d21a2        	l32i	a10, a1, 0x274
42014647:	9c21b2        	l32i	a11, a1, 0x270
4201464a:	24a2c2        	movi	a12, 0x224
4201464d:	c8ca      	add.n	a12, a8, a12
4201464f:	02d862        	addmi	a6, a8, 0x200
42014652:	8f6192        	s32i	a9, a1, 0x23c
42014655:	fe2f65        	call8	4201294c <__ssprint_r>
42014658:	b688      	l32i.n	a8, a6, 44
4201465a:	a698      	l32i.n	a9, a6, 40
4201465c:	976182        	s32i	a8, a1, 0x25c
4201465f:	5a8c      	beqz.n	a10, 42014668 <_svfiprintf_r+0x1c10>
42014661:	001dc6        	j	420146dc <_svfiprintf_r+0x1c84>
42014664:	9d0000        	lsi	f0, a0, 0x274
42014667:	820b      	addi.n	a8, a2, -1
42014669:	509e21        	l32r	a2, 41fe88e4 <_coredump_iram_end+0x1c669e4>
4201466c:	5358      	l32i.n	a5, a3, 20
4201466e:	9f2182        	l32i	a8, a1, 0x27c
42014671:	885a      	add.n	a8, a8, a5
42014673:	9f6182        	s32i	a8, a1, 0x27c
42014676:	972182        	l32i	a8, a1, 0x25c
42014679:	48ac      	beqz.n	a8, 420146a1 <_svfiprintf_r+0x1c49>
4201467b:	10c182        	addi	a8, a1, 16
4201467e:	02d862        	addmi	a6, a8, 0x200
42014681:	972182        	l32i	a8, a1, 0x25c
42014684:	9c21b2        	l32i	a11, a1, 0x270
42014687:	b689      	s32i.n	a8, a6, 44
42014689:	9d21a2        	l32i	a10, a1, 0x274
4201468c:	10c182        	addi	a8, a1, 16
4201468f:	24a2c2        	movi	a12, 0x224
42014692:	c8ca      	add.n	a12, a8, a12
42014694:	8e6192        	s32i	a9, a1, 0x238
42014697:	fe2b65        	call8	4201294c <__ssprint_r>
4201469a:	b688      	l32i.n	a8, a6, 44
4201469c:	976182        	s32i	a8, a1, 0x25c
4201469f:	9afc      	bnez.n	a10, 420146dc <_svfiprintf_r+0x1c84>
420146a1:	080c      	movi.n	a8, 0
420146a3:	996182        	s32i	a8, a1, 0x264
420146a6:	10c192        	addi	a9, a1, 16
420146a9:	e4a182        	movi	a8, 0x1e4
420146ac:	898a      	add.n	a8, a9, a8
420146ae:	076d      	mov.n	a6, a7
420146b0:	986182        	s32i	a8, a1, 0x260
420146b3:	f90946        	j	42012adc <_svfiprintf_r+0x84>
420146b6:	820000        	mull	a0, a0, a0
420146b9:	169721        	l32r	a2, 41fda118 <_coredump_iram_end+0x1c58218>
420146bc:	01d8      	l32i.n	a13, a1, 0
420146be:	9921a2        	l32i	a10, a1, 0x264
420146c1:	10c182        	addi	a8, a1, 16
420146c4:	8e61a2        	s32i	a10, a1, 0x238
420146c7:	9721a2        	l32i	a10, a1, 0x25c
420146ca:	24a2c2        	movi	a12, 0x224
420146cd:	8f61a2        	s32i	a10, a1, 0x23c
420146d0:	9c21b2        	l32i	a11, a1, 0x270
420146d3:	9d21a2        	l32i	a10, a1, 0x274
420146d6:	80c8c0        	add	a12, a8, a12
420146d9:	fe2725        	call8	4201294c <__ssprint_r>
420146dc:	9c2182        	l32i	a8, a1, 0x270
420146df:	061882        	l16ui	a8, a8, 12
420146e2:	166867        	bbci	a8, 6, 420146fc <_svfiprintf_r+0x1ca4>
420146e5:	f87c      	movi.n	a8, -1
420146e7:	9f6182        	s32i	a8, a1, 0x27c
420146ea:	000386        	j	420146fc <_svfiprintf_r+0x1ca4>
420146ed:	9b2182        	l32i	a8, a1, 0x26c
420146f0:	02ad      	mov.n	a10, a2
420146f2:	190c      	movi.n	a9, 1
420146f4:	94d8d6        	bgez	a8, 42014045 <_svfiprintf_r+0x15ed>
420146f7:	fe6ac6        	j	420140a6 <_svfiprintf_r+0x164e>
420146fa:	220000        	orb	b0, b0, b0
420146fd:	1d9f21        	l32r	a2, 41fdbd7c <_coredump_iram_end+0x1c59e7c>
42014700:	0000f0        	callx12	a0
	...

42014704 <_mbtowc_r>:
42014704:	004136        	entry	a1, 32
42014707:	b19781        	l32r	a8, 42000d64 <_stext+0xd44> (3fc92798 <__global_locale_ptr>)
4201470a:	02ad      	mov.n	a10, a2
4201470c:	0888      	l32i.n	a8, a8, 0
4201470e:	03bd      	mov.n	a11, a3
42014710:	392882        	l32i	a8, a8, 228
42014713:	04cd      	mov.n	a12, a4
42014715:	05dd      	mov.n	a13, a5
42014717:	06ed      	mov.n	a14, a6
42014719:	0008e0        	callx8	a8
4201471c:	0a2d      	mov.n	a2, a10
4201471e:	f01d      	retw.n

42014720 <__ascii_mbtowc>:
42014720:	006136        	entry	a1, 48
42014723:	038d      	mov.n	a8, a3
42014725:	838130        	moveqz	a8, a1, a3
42014728:	020c      	movi.n	a2, 0
4201472a:	049c      	beqz.n	a4, 4201473e <__ascii_mbtowc+0x1e>
4201472c:	e27c      	movi.n	a2, -2
4201472e:	c58c      	beqz.n	a5, 4201473e <__ascii_mbtowc+0x1e>
42014730:	000492        	l8ui	a9, a4, 0
42014733:	120c      	movi.n	a2, 1
42014735:	005892        	s16i	a9, a8, 0
42014738:	000482        	l8ui	a8, a4, 0
4201473b:	832880        	moveqz	a2, a8, a8
4201473e:	f01d      	retw.n

42014740 <_wctomb_r>:
42014740:	004136        	entry	a1, 32
42014743:	b18881        	l32r	a8, 42000d64 <_stext+0xd44> (3fc92798 <__global_locale_ptr>)
42014746:	02ad      	mov.n	a10, a2
42014748:	0888      	l32i.n	a8, a8, 0
4201474a:	03bd      	mov.n	a11, a3
4201474c:	382882        	l32i	a8, a8, 224
4201474f:	20d550        	or	a13, a5, a5
42014752:	f4c040        	extui	a12, a4, 0, 16
42014755:	0008e0        	callx8	a8
42014758:	0a2d      	mov.n	a2, a10
4201475a:	f01d      	retw.n

4201475c <__ascii_wctomb>:
4201475c:	004136        	entry	a1, 32
4201475f:	028d      	mov.n	a8, a2
42014761:	f44040        	extui	a4, a4, 0, 16
42014764:	020c      	movi.n	a2, 0
42014766:	339c      	beqz.n	a3, 4201477d <__ascii_wctomb+0x21>
42014768:	ffa092        	movi	a9, 255
4201476b:	09b947        	bgeu	a9, a4, 42014778 <__ascii_wctomb+0x1c>
4201476e:	8aa092        	movi	a9, 138
42014771:	0899      	s32i.n	a9, a8, 0
42014773:	f27c      	movi.n	a2, -1
42014775:	000106        	j	4201477d <__ascii_wctomb+0x21>
42014778:	004342        	s8i	a4, a3, 0
4201477b:	120c      	movi.n	a2, 1
4201477d:	f01d      	retw.n
	...

42014780 <init_efuse_secure>:
{
42014780:	004136        	entry	a1, 32
}
42014783:	020c      	movi.n	a2, 0
42014785:	f01d      	retw.n
	...

42014788 <esp_efuse_startup_include_func>:

void esp_efuse_startup_include_func(void)
{
42014788:	004136        	entry	a1, 32
    // Hook to force the linker to include this file
}
4201478b:	f01d      	retw.n
4201478d:	000000        	ill

42014790 <esp_efuse_utility_check_errors>:
    efuse_hal_read();
    efuse_hal_clear_program_registers();
}

esp_err_t esp_efuse_utility_check_errors(void)
{
42014790:	004136        	entry	a1, 32
    return ESP_OK;
}
42014793:	020c      	movi.n	a2, 0
42014795:	f01d      	retw.n
	...

42014798 <esp_system_include_startup_funcs>:
{
42014798:	004136        	entry	a1, 32
}
4201479b:	f01d      	retw.n
4201479d:	000000        	ill

420147a0 <get_reset_reason>:
{
420147a0:	004136        	entry	a1, 32
    switch (rtc_reset_reason) {
420147a3:	028266        	bnei	a2, 8, 420147a9 <get_reset_reason+0x9>
420147a6:	002206        	j	42014832 <get_reset_reason+0x92>
420147a9:	880c      	movi.n	a8, 8
420147ab:	1e3827        	bltu	a8, a2, 420147cd <get_reset_reason+0x2d>
420147ae:	025266        	bnei	a2, 5, 420147b4 <get_reset_reason+0x14>
420147b1:	0020c6        	j	42014838 <get_reset_reason+0x98>
420147b4:	0d62f6        	bgeui	a2, 6, 420147c5 <get_reset_reason+0x25>
420147b7:	021266        	bnei	a2, 1, 420147bd <get_reset_reason+0x1d>
420147ba:	002a86        	j	42014868 <get_reset_reason+0xc8>
420147bd:	4f3226        	beqi	a2, 3, 42014810 <get_reset_reason+0x70>
        return ESP_RST_UNKNOWN;
420147c0:	020c      	movi.n	a2, 0
420147c2:	002886        	j	42014868 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
420147c5:	747266        	bnei	a2, 7, 4201483d <get_reset_reason+0x9d>
        return ESP_RST_TASK_WDT;
420147c8:	620c      	movi.n	a2, 6
420147ca:	002686        	j	42014868 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
420147cd:	f80c      	movi.n	a8, 15
420147cf:	6f1287        	beq	a2, a8, 42014842 <get_reset_reason+0xa2>
420147d2:	203827        	bltu	a8, a2, 420147f6 <get_reset_reason+0x56>
420147d5:	37a226        	beqi	a2, 12, 42014810 <get_reset_reason+0x70>
420147d8:	c80c      	movi.n	a8, 12
420147da:	0e3827        	bltu	a8, a2, 420147ec <get_reset_reason+0x4c>
420147dd:	980c      	movi.n	a8, 9
420147df:	641287        	beq	a2, a8, 42014847 <get_reset_reason+0xa7>
420147e2:	b80c      	movi.n	a8, 11
420147e4:	649287        	bne	a2, a8, 4201484c <get_reset_reason+0xac>
        return ESP_RST_WDT;
420147e7:	720c      	movi.n	a2, 7
420147e9:	001ec6        	j	42014868 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
420147ec:	d80c      	movi.n	a8, 13
420147ee:	5f9287        	bne	a2, a8, 42014851 <get_reset_reason+0xb1>
        return ESP_RST_WDT;
420147f1:	720c      	movi.n	a2, 7
420147f3:	001c46        	j	42014868 <get_reset_reason+0xc8>
    switch (rtc_reset_reason) {
420147f6:	281c      	movi.n	a8, 18
420147f8:	083827        	bltu	a8, a2, 42014804 <get_reset_reason+0x64>
420147fb:	57b2b6        	bltui	a2, 16, 42014856 <get_reset_reason+0xb6>
        return ESP_RST_WDT;
420147fe:	720c      	movi.n	a2, 7
42014800:	001906        	j	42014868 <get_reset_reason+0xc8>
42014803:	c22200        	quou	a2, a2, a0
    switch (rtc_reset_reason) {
42014806:	b6eb      	addi.n	a11, a6, 14
42014808:	0c5122        	s16i	a2, a1, 24
        return ESP_RST_UNKNOWN;
4201480b:	160602        	l8ui	a0, a6, 22
4201480e:	820000        	mull	a0, a0, a0
        if (reset_reason_hint == ESP_RST_PANIC ||
42014811:	80fcc3        	lsi	f12, a12, 0x200
42014814:	40f8      	l32i.n	a15, a0, 16
42014816:	418580        	srli	a8, a8, 5
                reset_reason_hint == ESP_RST_BROWNOUT ||
42014819:	f7c392        	addi	a9, a3, -9
4201481c:	40f990        	nsau	a9, a9
4201481f:	419590        	srli	a9, a9, 5
        if (reset_reason_hint == ESP_RST_PANIC ||
42014822:	208890        	or	a8, a8, a9
42014825:	88fc      	bnez.n	a8, 42014861 <get_reset_reason+0xc1>
                reset_reason_hint == ESP_RST_TASK_WDT ||
42014827:	fbc382        	addi	a8, a3, -5
4201482a:	3828b6        	bltui	a8, 2, 42014866 <get_reset_reason+0xc6>
        return ESP_RST_SW;
4201482d:	320c      	movi.n	a2, 3
4201482f:	000d46        	j	42014868 <get_reset_reason+0xc8>
        return ESP_RST_INT_WDT;
42014832:	520c      	movi.n	a2, 5
42014834:	000c06        	j	42014868 <get_reset_reason+0xc8>
42014837:	820c00        	mull	a0, a12, a0
        return ESP_RST_DEEPSLEEP;
4201483a:	000a86        	j	42014868 <get_reset_reason+0xc8>
        return ESP_RST_UNKNOWN;
4201483d:	020c      	movi.n	a2, 0
4201483f:	000946        	j	42014868 <get_reset_reason+0xc8>
        return ESP_RST_BROWNOUT;
42014842:	920c      	movi.n	a2, 9
42014844:	000806        	j	42014868 <get_reset_reason+0xc8>
        return ESP_RST_WDT;
42014847:	720c      	movi.n	a2, 7
42014849:	0006c6        	j	42014868 <get_reset_reason+0xc8>
        return ESP_RST_UNKNOWN;
4201484c:	020c      	movi.n	a2, 0
4201484e:	000586        	j	42014868 <get_reset_reason+0xc8>
42014851:	020c      	movi.n	a2, 0
42014853:	000446        	j	42014868 <get_reset_reason+0xc8>
42014856:	020c      	movi.n	a2, 0
42014858:	000306        	j	42014868 <get_reset_reason+0xc8>
4201485b:	b20c00        	mulsh	a0, a12, a0
        return ESP_RST_USB;
4201485e:	000186        	j	42014868 <get_reset_reason+0xc8>
            return reset_reason_hint;
42014861:	032d      	mov.n	a2, a3
42014863:	000046        	j	42014868 <get_reset_reason+0xc8>
42014866:	032d      	mov.n	a2, a3
}
42014868:	f01d      	retw.n
	...

4201486c <get_cache_error>:
{
4201486c:	004136        	entry	a1, 32
    for (int i = 0; i < size; i++) {
4201486f:	090c      	movi.n	a9, 0
42014871:	000a86        	j	4201489f <get_cache_error+0x33>
42014874:	89c000        	lsi	f0, a0, 0x224
        const uint32_t bit = reg_bits[i].bit;
42014877:	838a11        	l32r	a1, 41ff56a0 <_coredump_iram_end+0x1c737a0>
4201487a:	08a8      	l32i.n	a10, a8, 0
        if ((status & bit) == bit) {
4201487c:	1dc2a7        	bnall	a2, a10, 4201489d <get_cache_error+0x31>
            err_info->err_str = reg_bits[i].msg;
4201487f:	1898      	l32i.n	a9, a8, 4
42014881:	0599      	s32i.n	a9, a5, 0
            err_info->vaddr = reg_bits[i].fault_addr_reg ? REG_READ(reg_bits[i].fault_addr_reg) : 0;
42014883:	2898      	l32i.n	a9, a8, 8
42014885:	498c      	beqz.n	a9, 4201488d <get_cache_error+0x21>
42014887:	0020c0        	memw
4201488a:	002992        	l32i	a9, a9, 0
4201488d:	1599      	s32i.n	a9, a5, 4
            err_info->size = reg_bits[i].fault_size_reg ? REG_READ(reg_bits[i].fault_size_reg) : 0;
4201488f:	3888      	l32i.n	a8, a8, 12
42014891:	388c      	beqz.n	a8, 42014898 <get_cache_error+0x2c>
42014893:	0020c0        	memw
42014896:	0888      	l32i.n	a8, a8, 0
42014898:	2589      	s32i.n	a8, a5, 8
            return;
4201489a:	000106        	j	420148a2 <get_cache_error+0x36>
    for (int i = 0; i < size; i++) {
4201489d:	991b      	addi.n	a9, a9, 1
4201489f:	d23947        	bltu	a9, a4, 42014875 <get_cache_error+0x9>
}
420148a2:	f01d      	retw.n

420148a4 <panic_soc_check_pseudo_cause>:
{
420148a4:	004136        	entry	a1, 32
}
420148a7:	020c      	movi.n	a2, 0
420148a9:	f01d      	retw.n
	...

420148ac <panic_get_address>:
{
420148ac:	004136        	entry	a1, 32
}
420148af:	1228      	l32i.n	a2, a2, 4
420148b1:	f01d      	retw.n
	...

420148b4 <panic_get_cause>:
{
420148b4:	004136        	entry	a1, 32
}
420148b7:	142222        	l32i	a2, a2, 80
420148ba:	f01d      	retw.n

420148bc <panic_set_address>:
{
420148bc:	004136        	entry	a1, 32
    ((XtExcFrame *)f)->pc = addr;
420148bf:	1239      	s32i.n	a3, a2, 4
}
420148c1:	f01d      	retw.n
	...

420148c4 <heap_caps_match>:
{
420148c4:	004136        	entry	a1, 32
    return heap->heap != NULL && ((get_all_caps(heap) & caps) == caps);
420148c7:	7288      	l32i.n	a8, a2, 28
420148c9:	08dc      	bnez.n	a8, 420148dd <heap_caps_match+0x19>
420148cb:	020c      	movi.n	a2, 0
420148cd:	000746        	j	420148ee <heap_caps_match+0x2a>
        all_caps |= heap->caps[prio];
420148d0:	a0a820        	addx4	a10, a8, a2
420148d3:	0aa8      	l32i.n	a10, a10, 0
420148d5:	2099a0        	or	a9, a9, a10
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
420148d8:	881b      	addi.n	a8, a8, 1
420148da:	0000c6        	j	420148e1 <heap_caps_match+0x1d>
420148dd:	080c      	movi.n	a8, 0
    uint32_t all_caps = 0;
420148df:	089d      	mov.n	a9, a8
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
420148e1:	eb38a6        	blti	a8, 3, 420148d0 <heap_caps_match+0xc>
420148e4:	04c937        	bnall	a9, a3, 420148ec <heap_caps_match+0x28>
420148e7:	120c      	movi.n	a2, 1
420148e9:	000046        	j	420148ee <heap_caps_match+0x2a>
420148ec:	020c      	movi.n	a2, 0
}
420148ee:	f01d      	retw.n

420148f0 <s_compare_reserved_regions>:
{
420148f0:	004136        	entry	a1, 32
    return (int)r_a->start - (int)r_b->start;
420148f3:	0228      	l32i.n	a2, a2, 0
420148f5:	0388      	l32i.n	a8, a3, 0
}
420148f7:	c02280        	sub	a2, a2, a8
420148fa:	f01d      	retw.n

420148fc <__esp_system_init_fn_esp_security_init>:
    };
#endif /* SOC_KEY_MANAGER_ECDSA_KEY_DEPLOY || SOC_KEY_MANAGER_FE_KEY_DEPLOY */
}

ESP_SYSTEM_INIT_FN(esp_security_init, SECONDARY, BIT(0), 103)
{
420148fc:	004136        	entry	a1, 32
            return err;
        }
    }
#endif
    return ESP_OK;
}
420148ff:	020c      	movi.n	a2, 0
42014901:	f01d      	retw.n
	...

42014904 <esp_security_init_include_impl>:

void esp_security_init_include_impl(void)
{
42014904:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
42014907:	f01d      	retw.n
42014909:	000000        	ill

4201490c <esp_intr_get_cpu>:
{
4201490c:	004136        	entry	a1, 32
    return handle->vector_desc->cpu;
4201490f:	0288      	l32i.n	a8, a2, 0
42014911:	0828      	l32i.n	a2, a8, 0
}
42014913:	052020        	extui	a2, a2, 16, 1
42014916:	f01d      	retw.n

42014918 <esp_sleep_gpio_include>:

void esp_sleep_gpio_include(void)
{
42014918:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
4201491b:	f01d      	retw.n
4201491d:	000000        	ill

42014920 <esp_libc_init_funcs>:

// Hook to force the linker to include this file
void esp_libc_init_funcs(void)
{
42014920:	004136        	entry	a1, 32
}
42014923:	f01d      	retw.n
42014925:	000000        	ill

42014928 <esp_libc_include_pthread_impl>:
    }
    return 0;
}

void esp_libc_include_pthread_impl(void)
{
42014928:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
4201492b:	f01d      	retw.n
4201492d:	000000        	ill

42014930 <esp_libc_include_getentropy_impl>:

    return 0;
}

void esp_libc_include_getentropy_impl(void)
{
42014930:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
42014933:	f01d      	retw.n
42014935:	000000        	ill

42014938 <esp_libc_include_syscalls_impl>:
{
    return _system_r(__getreent(), str);
}

void esp_libc_include_syscalls_impl(void)
{
42014938:	004136        	entry	a1, 32
}
4201493b:	f01d      	retw.n
4201493d:	000000        	ill

42014940 <_getpid_r>:
{
42014940:	004136        	entry	a1, 32
    __errno_r(r) = ENOSYS;
42014943:	885c      	movi.n	a8, 88
42014945:	0289      	s32i.n	a8, a2, 0
}
42014947:	f27c      	movi.n	a2, -1
42014949:	f01d      	retw.n
	...

4201494c <esp_libc_include_reent_syscalls_impl>:

/* No-op function, used to force linking this file,
   instead of the syscalls implementation from libgloss.
 */
void esp_libc_include_reent_syscalls_impl(void)
{
4201494c:	004136        	entry	a1, 32
}
4201494f:	f01d      	retw.n
42014951:	000000        	ill

42014954 <esp_libc_include_init_funcs>:
}
#endif /* CONFIG_VFS_SUPPORT_IO */

// Hook to force the linker to include this file
void esp_libc_include_init_funcs(void)
{
42014954:	004136        	entry	a1, 32
}
42014957:	f01d      	retw.n
42014959:	000000        	ill

4201495c <pthread_include_pthread_impl>:
    return configMAX_PRIORITIES - 1;
}

/* Hook function to force linking this file */
void pthread_include_pthread_impl(void)
{
4201495c:	004136        	entry	a1, 32
}
4201495f:	f01d      	retw.n
42014961:	000000        	ill

42014964 <pthread_include_pthread_cond_var_impl>:
    return ret;
}

/* Hook function to force linking this file */
void pthread_include_pthread_cond_var_impl(void)
{
42014964:	004136        	entry	a1, 32
}
42014967:	f01d      	retw.n
42014969:	000000        	ill

4201496c <pthread_include_pthread_local_storage_impl>:
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_local_storage_impl(void)
{
4201496c:	004136        	entry	a1, 32
}
4201496f:	f01d      	retw.n
42014971:	000000        	ill

42014974 <pthread_include_pthread_rwlock_impl>:
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_rwlock_impl(void)
{
42014974:	004136        	entry	a1, 32
}
42014977:	f01d      	retw.n
42014979:	000000        	ill

4201497c <pthread_include_pthread_semaphore_impl>:
    *sval = uxSemaphoreGetCount(freertos_semaphore);
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_semaphore_impl(void) { }
4201497c:	004136        	entry	a1, 32
4201497f:	f01d      	retw.n
42014981:	000000        	ill

42014984 <__cxa_guard_dummy>:
/**
 * Dummy function used to force linking this file instead of the same one in libstdc++.
 * This works via -u __cxa_guard_dummy flag in component.mk
 */
extern "C" void __cxa_guard_dummy(void)
{
42014984:	004136        	entry	a1, 32
}
42014987:	f01d      	retw.n
42014989:	000000        	ill

4201498c <__cxx_init_dummy>:
/**
 * Dummy function used to force linking this file.
 * This works via -u __cxx_init_dummy flag in CMakeLists.txt
 */
extern "C" void __cxx_init_dummy(void)
{
4201498c:	004136        	entry	a1, 32
}
4201498f:	f01d      	retw.n
42014991:	000000        	ill

42014994 <esp_timer_init_include_func>:

void esp_timer_init_include_func(void)
{
42014994:	004136        	entry	a1, 32
    // Hook to force the linker to include this file
}
42014997:	f01d      	retw.n
42014999:	000000        	ill

4201499c <include_esp_phy_override>:
static bool s_wifi_pwdet_xpd_flag;
static bool s_wifi_tsens_xpd_flag;
#endif

void include_esp_phy_override(void)
{
4201499c:	004136        	entry	a1, 32
    /* When this empty function is called, all functions below will be linked. */
}
4201499f:	f01d      	retw.n
420149a1:	000000        	ill

420149a4 <usb_serial_jtag_connection_monitor_include>:

void usb_serial_jtag_connection_monitor_include(void)
{
420149a4:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
420149a7:	f01d      	retw.n
420149a9:	000000        	ill

420149ac <usb_serial_jtag_close>:
{
420149ac:	004136        	entry	a1, 32
}
420149af:	020c      	movi.n	a2, 0
420149b1:	f01d      	retw.n
	...

420149b4 <usb_serial_jtag_vfs_include_dev_init>:
    _lock_release_recursive(&s_ctx.write_lock);
    _lock_release_recursive(&s_ctx.read_lock);
}

void usb_serial_jtag_vfs_include_dev_init(void)
{
420149b4:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
420149b7:	f01d      	retw.n
420149b9:	000000        	ill

420149bc <esp_vfs_include_console_register>:

#endif // CONFIG_VFS_SUPPORT_IO

void esp_vfs_include_console_register(void)
{
420149bc:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
420149bf:	f01d      	retw.n
420149c1:	000000        	ill

420149c4 <vfs_include_syscalls_impl>:
void rewinddir(DIR* pdir)
    __attribute__((alias("esp_vfs_rewinddir")));
#endif // CONFIG_VFS_SUPPORT_DIR

void vfs_include_syscalls_impl(void)
{
420149c4:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
420149c7:	f01d      	retw.n
420149c9:	000000        	ill

420149cc <esp_vfs_include_nullfs_register>:
#endif // CONFIG_VFS_INITIALIZE_DEV_NULL

void esp_vfs_include_nullfs_register(void)
{
420149cc:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
420149cf:	f01d      	retw.n
420149d1:	000000        	ill

420149d4 <nvs_sec_provider_include_impl>:

    return ESP_OK;
}

void nvs_sec_provider_include_impl(void)
{
420149d4:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
420149d7:	f01d      	retw.n
420149d9:	000000        	ill

420149dc <_ZN3etl13ibasic_stringIcE9push_backEc>:
    void push_back(T value)
420149dc:	004136        	entry	a1, 32
420149df:	743030        	extui	a3, a3, 0, 8
      if (current_size != CAPACITY)
420149e2:	0288      	l32i.n	a8, a2, 0
420149e4:	1298      	l32i.n	a9, a2, 4
420149e6:	1a1897        	beq	a8, a9, 42014a04 <_ZN3etl13ibasic_stringIcE9push_backEc+0x28>
        p_buffer[current_size++] = value;
420149e9:	3298      	l32i.n	a9, a2, 12
420149eb:	a81b      	addi.n	a10, a8, 1
420149ed:	02a9      	s32i.n	a10, a2, 0
420149ef:	898a      	add.n	a8, a9, a8
420149f1:	004832        	s8i	a3, a8, 0
        p_buffer[current_size]   = 0;
420149f4:	3288      	l32i.n	a8, a2, 12
420149f6:	0298      	l32i.n	a9, a2, 0
420149f8:	889a      	add.n	a8, a8, a9
420149fa:	090c      	movi.n	a9, 0
420149fc:	004892        	s8i	a9, a8, 0
420149ff:	000306        	j	42014a0f <_ZN3etl13ibasic_stringIcE9push_backEc+0x33>
42014a02:	00          	.byte	00
42014a03:	00          	.byte	00
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);
42014a04:	080282        	l8ui	a8, a2, 8
42014a07:	190c      	movi.n	a9, 1
42014a09:	208890        	or	a8, a8, a9
42014a0c:	084282        	s8i	a8, a2, 8
    }
42014a0f:	f01d      	retw.n
42014a11:	000000        	ill

42014a14 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_>:
    reverse(TIterator b, TIterator e)
42014a14:	004136        	entry	a1, 32
    if (b != e)
42014a17:	119237        	bne	a2, a3, 42014a2c <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_+0x18>
42014a1a:	0004c6        	j	42014a31 <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_+0x1d>
    {
#if __cplusplus < 201103L
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
#endif
      _Tp __tmp = _GLIBCXX_MOVE(__a);
42014a1d:	000282        	l8ui	a8, a2, 0
      __a = _GLIBCXX_MOVE(__b);
42014a20:	000392        	l8ui	a9, a3, 0
42014a23:	004292        	s8i	a9, a2, 0
      __b = _GLIBCXX_MOVE(__tmp);
42014a26:	004382        	s8i	a8, a3, 0
        ++b;
42014a29:	01c222        	addi	a2, a2, 1
      while (b < --e)
42014a2c:	330b      	addi.n	a3, a3, -1
42014a2e:	eb3237        	bltu	a2, a3, 42014a1d <_ZN3etl7reverseIPcEENS_9enable_ifIXsrNS_10is_pointerIT_EE5valueEvE4typeES4_S4_+0x9>
  }
42014a31:	f01d      	retw.n
	...

42014a34 <_ZN3etl18memory_clear_rangeIcEEvPVT_j>:
  void memory_clear_range(volatile T* begin, size_t n)
42014a34:	004136        	entry	a1, 32
    while (n--)
42014a37:	0002c6        	j	42014a46 <_ZN3etl18memory_clear_rangeIcEEvPVT_j+0x12>
      *p++ = 0;
42014a3a:	090c      	movi.n	a9, 0
42014a3c:	0020c0        	memw
42014a3f:	004292        	s8i	a9, a2, 0
    while (n--)
42014a42:	083d      	mov.n	a3, a8
      *p++ = 0;
42014a44:	221b      	addi.n	a2, a2, 1
    while (n--)
42014a46:	830b      	addi.n	a8, a3, -1
42014a48:	fee356        	bnez	a3, 42014a3a <_ZN3etl18memory_clear_rangeIcEEvPVT_j+0x6>
  }
42014a4b:	f01d      	retw.n
42014a4d:	000000        	ill

42014a50 <s_mem_caps_check>:
{
42014a50:	004136        	entry	a1, 32
    if (caps & MMU_MEM_CAP_EXEC) {
42014a53:	096207        	bbci	a2, 0, 42014a60 <s_mem_caps_check+0x10>
        if ((caps & MMU_MEM_CAP_8BIT) || (caps & MMU_MEM_CAP_WRITE)) {
42014a56:	481c      	movi.n	a8, 20
42014a58:	098287        	bany	a2, a8, 42014a65 <s_mem_caps_check+0x15>
    return ESP_OK;
42014a5b:	020c      	movi.n	a2, 0
42014a5d:	0001c6        	j	42014a68 <s_mem_caps_check+0x18>
42014a60:	020c      	movi.n	a2, 0
42014a62:	000086        	j	42014a68 <s_mem_caps_check+0x18>
            return ESP_ERR_INVALID_ARG;
42014a65:	02a122        	movi	a2, 0x102
}
42014a68:	f01d      	retw.n
	...

42014a6c <s_find_available_region>:
{
42014a6c:	004136        	entry	a1, 32
42014a6f:	02ad      	mov.n	a10, a2
    for (int i = 0; i < region_nums; i++) {
42014a71:	020c      	movi.n	a2, 0
42014a73:	000606        	j	42014a8f <s_find_available_region+0x23>
42014a76:	200000        	or	a0, a0, a0
        if (((mem_regions[i].caps & caps) == caps) && ((mem_regions[i].targets & target) == target)) {
42014a79:	a0a082        	movi	a8, 160
42014a7c:	b088      	l32i.n	a8, a0, 44
42014a7e:	6898      	l32i.n	a9, a8, 24
42014a80:	09c957        	bnall	a9, a5, 42014a8d <s_find_available_region+0x21>
42014a83:	7898      	l32i.n	a9, a8, 28
42014a85:	04c967        	bnall	a9, a6, 42014a8d <s_find_available_region+0x21>
            if (mem_regions[i].max_slot_size >= size) {
42014a88:	5888      	l32i.n	a8, a8, 20
42014a8a:	06b847        	bgeu	a8, a4, 42014a94 <s_find_available_region+0x28>
    for (int i = 0; i < region_nums; i++) {
42014a8d:	221b      	addi.n	a2, a2, 1
42014a8f:	e53237        	bltu	a2, a3, 42014a78 <s_find_available_region+0xc>
    int32_t found_region_id = -1;
42014a92:	f27c      	movi.n	a2, -1
}
42014a94:	f01d      	retw.n
	...

42014a98 <s_is_enclosed>:
 * @param new_block_size  New block size
 *
 * @return True: new block is enclosed; False: new block is not enclosed
 */
static bool s_is_enclosed(uint32_t block_start, uint32_t block_end, uint32_t new_block_start, uint32_t new_block_size)
{
42014a98:	004136        	entry	a1, 32
    bool is_enclosed = false;
    uint32_t new_block_end = new_block_start + new_block_size;
42014a9b:	545a      	add.n	a5, a4, a5

    if ((new_block_start >= block_start) && (new_block_end <= block_end)) {
42014a9d:	622420        	lsi	f2, a4, 0x188
42014aa0:	220b      	addi.n	a2, a2, -1
42014aa2:	602020        	neg	a2, a2
42014aa5:	623350        	lsi	f5, a3, 0x188
42014aa8:	330b      	addi.n	a3, a3, -1
42014aaa:	603030        	neg	a3, a3
42014aad:	743030        	extui	a3, a3, 0, 8
    } else {
        is_enclosed = false;
    }

    return is_enclosed;
}
42014ab0:	102230        	and	a2, a2, a3
42014ab3:	f01d      	retw.n
42014ab5:	000000        	ill

42014ab8 <s_is_overlapped>:
 * @param new_block_size  New block size
 *
 * @return True: new block is overlapped; False: new block is not overlapped
 */
static bool s_is_overlapped(uint32_t block_start, uint32_t block_end, uint32_t new_block_start, uint32_t new_block_size)
{
42014ab8:	004136        	entry	a1, 32
    bool is_overlapped = false;
    uint32_t new_block_end = new_block_start + new_block_size;
42014abb:	545a      	add.n	a5, a4, a5

    if (((new_block_start < block_start) && (new_block_end > block_start)) ||
42014abd:	629420        	lsi	f2, a4, 0x188
42014ac0:	628250        	lsi	f5, a2, 0x188
42014ac3:	102980        	and	a2, a9, a8
42014ac6:	088987        	bany	a9, a8, 42014ad2 <s_is_overlapped+0x1a>
            ((new_block_start < block_end) && (new_block_end > block_end))) {
42014ac9:	624430        	lsi	f3, a4, 0x188
42014acc:	623350        	lsi	f5, a3, 0x188
42014acf:	102430        	and	a2, a4, a3
    } else {
        is_overlapped = false;
    }

    return is_overlapped;
}
42014ad2:	f01d      	retw.n

42014ad4 <mpu_hal_set_region_access>:
#include "hal/mpu_types.h"

#include "soc/soc_caps.h"

void mpu_hal_set_region_access(int id, mpu_access_t access)
{
42014ad4:	004136        	entry	a1, 32
    // 0x60000000 = 3
    // 0x80000000 = 4
    // 0xa0000000 = 5
    // 0xc0000000 = 6
    // 0xe0000000 = 7
    return id * SOC_MPU_MIN_REGION_SIZE;
42014ad7:	012230        	slli	a2, a2, 29
    uint32_t addr = mpu_ll_id_to_addr(id);

    switch (access)
42014ada:	1b2326        	beqi	a3, 2, 42014af9 <mpu_hal_set_region_access+0x25>
42014add:	0733f6        	bgeui	a3, 3, 42014ae8 <mpu_hal_set_region_access+0x14>
42014ae0:	c3ac      	beqz.n	a3, 42014b10 <mpu_hal_set_region_access+0x3c>
42014ae2:	081326        	beqi	a3, 1, 42014aee <mpu_hal_set_region_access+0x1a>
42014ae5:	000d46        	j	42014b1e <mpu_hal_set_region_access+0x4a>
42014ae8:	183326        	beqi	a3, 3, 42014b04 <mpu_hal_set_region_access+0x30>
42014aeb:	000bc6        	j	42014b1e <mpu_hal_set_region_access+0x4a>
}

static inline void mpu_ll_set_region_rw(uint32_t addr)
{
    WDTLB(0x0, addr); // cached, no allocate
42014aee:	080c      	movi.n	a8, 0
42014af0:	50e280        	wdtlb	a8, a2
42014af3:	002030        	dsync
}
42014af6:	000906        	j	42014b1e <mpu_hal_set_region_access+0x4a>
    WDTLB(0x2, addr); // bypass cache
}

static inline void mpu_ll_set_region_x(uint32_t addr)
{
    WITLB(0x3, addr); // cached
42014af9:	380c      	movi.n	a8, 3
42014afb:	506280        	witlb	a8, a2
42014afe:	002000        	isync
}
42014b01:	000646        	j	42014b1e <mpu_hal_set_region_access+0x4a>
    WDTLB(0x2, addr); // bypass cache
42014b04:	280c      	movi.n	a8, 2
42014b06:	50e280        	wdtlb	a8, a2
42014b09:	002030        	dsync
}
42014b0c:	000386        	j	42014b1e <mpu_hal_set_region_access+0x4a>
42014b0f:	f80c00        	lsi	f0, a12, 0x3e0

static inline void mpu_ll_set_region_illegal(uint32_t addr)
{
    WITLB(0xF, addr);
42014b12:	506280        	witlb	a8, a2
42014b15:	002000        	isync
    WDTLB(0xF, addr);
42014b18:	50e280        	wdtlb	a8, a2
42014b1b:	002030        	dsync
            mpu_ll_set_region_illegal(addr);
            break;
        default:
            break;
    }
}
42014b1e:	f01d      	retw.n

42014b20 <_fwalk_sglue>:
42014b20:	004136        	entry	a1, 32
42014b23:	026d      	mov.n	a6, a2
42014b25:	00a022        	movi	a2, 0
42014b28:	2478      	l32i.n	a7, a4, 8
42014b2a:	1458      	l32i.n	a5, a4, 4
42014b2c:	0006c6        	j	42014b4b <_fwalk_sglue+0x2b>
42014b2f:	820000        	mull	a0, a0, a0
42014b32:	b60617        	bnone	a6, a1, 42014aec <mpu_hal_set_region_access+0x18>
42014b35:	1028      	l32i.n	a2, a0, 4
42014b37:	079782        	l16si	a8, a7, 14
42014b3a:	0a0826        	beqi	a8, -1, 42014b48 <_fwalk_sglue+0x28>
42014b3d:	07bd      	mov.n	a11, a7
42014b3f:	20a660        	or	a10, a6, a6
42014b42:	0003e0        	callx8	a3
42014b45:	2022a0        	or	a2, a2, a10
42014b48:	68c772        	addi	a7, a7, 104
42014b4b:	550b      	addi.n	a5, a5, -1
42014b4d:	fe05d6        	bgez	a5, 42014b31 <_fwalk_sglue+0x11>
42014b50:	0448      	l32i.n	a4, a4, 0
42014b52:	fd2456        	bnez	a4, 42014b28 <_fwalk_sglue+0x8>
42014b55:	f01d      	retw.n
	...

42014b58 <__sflags>:
42014b58:	004136        	entry	a1, 32
42014b5b:	000382        	l8ui	a8, a3, 0
42014b5e:	72a092        	movi	a9, 114
42014b61:	351897        	beq	a8, a9, 42014b9a <__sflags+0x42>
42014b64:	77a092        	movi	a9, 119
42014b67:	391897        	beq	a8, a9, 42014ba4 <__sflags+0x4c>
42014b6a:	61a092        	movi	a9, 97
42014b6d:	3f1897        	beq	a8, a9, 42014bb0 <__sflags+0x58>
42014b70:	681c      	movi.n	a8, 22
42014b72:	0289      	s32i.n	a8, a2, 0
42014b74:	020c      	movi.n	a2, 0
42014b76:	001746        	j	42014bd7 <__sflags+0x7f>
42014b79:	071ab7        	beq	a10, a11, 42014b84 <__sflags+0x2c>
42014b7c:	141a77        	beq	a10, a7, 42014b94 <__sflags+0x3c>
42014b7f:	0011c6        	j	42014bca <__sflags+0x72>
42014b82:	c00000        	sub	a0, a0, a0
42014b85:	e01022        	l16ui	a2, a0, 0x1c0
42014b88:	1088      	l32i.n	a8, a0, 4
42014b8a:	2022d0        	or	a2, a2, a13
42014b8d:	2088f0        	or	a8, a8, a15
42014b90:	000d86        	j	42014bca <__sflags+0x72>
42014b93:	886000        	lsi	f0, a0, 0x220
42014b96:	0bc620        	lsi	f2, a6, 44
42014b99:	090c00        	l32e	a0, a12, -64
42014b9c:	080c      	movi.n	a8, 0
42014b9e:	420c      	movi.n	a2, 4
42014ba0:	000506        	j	42014bb8 <__sflags+0x60>
42014ba3:	a69200        	lsi	f0, a2, 0x298
42014ba6:	180c00        	lsxp	f0, a12, a0
42014ba9:	820c      	movi.n	a2, 8
42014bab:	000246        	j	42014bb8 <__sflags+0x60>
42014bae:	920000        	lsi	f0, a0, 0x248
42014bb1:	0c08a2        	l8ui	a10, a8, 12
42014bb4:	2218      	l32i.n	a1, a2, 8
42014bb6:	0c08a1        	l32r	a10, 41fd7bd8 <_coredump_iram_end+0x1c55cd8>
42014bb9:	bb2c16        	beqz	a12, 4201476f <__ascii_wctomb+0x13>
42014bbc:	3c6c      	movi.n	a12, -29
42014bbe:	0d1c      	movi.n	a13, 16
42014bc0:	ce7c      	movi.n	a14, -4
42014bc2:	2f0c      	movi.n	a15, 2
42014bc4:	78a072        	movi	a7, 120
42014bc7:	116650        	slli	a6, a6, 11
42014bca:	0103a2        	l8ui	a10, a3, 1
42014bcd:	331b      	addi.n	a3, a3, 1
42014bcf:	fa6a56        	bnez	a10, 42014b79 <__sflags+0x21>
42014bd2:	208890        	or	a8, a8, a9
42014bd5:	0489      	s32i.n	a8, a4, 0
42014bd7:	f01d      	retw.n
42014bd9:	000000        	ill

42014bdc <esp_cpu_set_breakpoint>:
{
42014bdc:	004136        	entry	a1, 32
    if (bp_num == 1) {
42014bdf:	051266        	bnei	a2, 1, 42014be8 <esp_cpu_set_breakpoint+0xc>
        WSR(IBREAKA_1, bp_addr);
42014be2:	138130        	wsr.ibreaka1	a3
42014be5:	000086        	j	42014beb <esp_cpu_set_breakpoint+0xf>
        WSR(IBREAKA_0, bp_addr);
42014be8:	138030        	wsr.ibreaka0	a3
    RSR(IBREAKENABLE, brk_ena_reg);
42014beb:	036080        	rsr.ibreakenable	a8
    brk_ena_reg |= BIT(bp_num);
42014bee:	190c      	movi.n	a9, 1
42014bf0:	401200        	ssl	a2
42014bf3:	a19900        	sll	a9, a9
42014bf6:	208890        	or	a8, a8, a9
    WSR(IBREAKENABLE, brk_ena_reg);
42014bf9:	136080        	wsr.ibreakenable	a8
}
42014bfc:	020c      	movi.n	a2, 0
42014bfe:	f01d      	retw.n

42014c00 <periph_ll_get_clk_en_mask>:
#include "soc/syscon_reg.h"
#include "soc/dport_access.h"
#include "soc/soc_caps.h"

static inline uint32_t periph_ll_get_clk_en_mask(periph_module_t periph)
{
42014c00:	004136        	entry	a1, 32
    switch (periph) {
42014c03:	581c      	movi.n	a8, 21
42014c05:	029287        	bne	a2, a8, 42014c0b <periph_ll_get_clk_en_mask+0xb>
42014c08:	006506        	j	42014da0 <periph_ll_get_clk_en_mask+0x1a0>
42014c0b:	02b827        	bgeu	a8, a2, 42014c11 <periph_ll_get_clk_en_mask+0x11>
42014c0e:	003106        	j	42014cd6 <periph_ll_get_clk_en_mask+0xd6>
42014c11:	980c      	movi.n	a8, 9
42014c13:	029287        	bne	a2, a8, 42014c19 <periph_ll_get_clk_en_mask+0x19>
42014c16:	0062c6        	j	42014da5 <periph_ll_get_clk_en_mask+0x1a5>
42014c19:	533827        	bltu	a8, a2, 42014c70 <periph_ll_get_clk_en_mask+0x70>
42014c1c:	024266        	bnei	a2, 4, 42014c22 <periph_ll_get_clk_en_mask+0x22>
42014c1f:	006246        	j	42014dac <periph_ll_get_clk_en_mask+0x1ac>
42014c22:	2252f6        	bgeui	a2, 5, 42014c48 <periph_ll_get_clk_en_mask+0x48>
42014c25:	022266        	bnei	a2, 2, 42014c2b <periph_ll_get_clk_en_mask+0x2b>
42014c28:	006186        	j	42014db2 <periph_ll_get_clk_en_mask+0x1b2>
42014c2b:	0d32f6        	bgeui	a2, 3, 42014c3c <periph_ll_get_clk_en_mask+0x3c>
42014c2e:	186216        	beqz	a2, 42014db8 <periph_ll_get_clk_en_mask+0x1b8>
42014c31:	021226        	beqi	a2, 1, 42014c37 <periph_ll_get_clk_en_mask+0x37>
42014c34:	006186        	j	42014dbe <periph_ll_get_clk_en_mask+0x1be>
    case PERIPH_RMT_MODULE:
        return SYSTEM_RMT_CLK_EN;
    case PERIPH_LEDC_MODULE:
        return SYSTEM_LEDC_CLK_EN;
    case PERIPH_UART0_MODULE:
        return SYSTEM_UART_CLK_EN;
42014c37:	420c      	movi.n	a2, 4
42014c39:	0090c6        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014c3c:	023226        	beqi	a2, 3, 42014c42 <periph_ll_get_clk_en_mask+0x42>
42014c3f:	006046        	j	42014dc4 <periph_ll_get_clk_en_mask+0x1c4>
    case PERIPH_UART1_MODULE:
        return SYSTEM_UART1_CLK_EN;
    case PERIPH_UART2_MODULE:
        return SYSTEM_UART2_CLK_EN;
42014c42:	00a222        	movi	a2, 0x200
42014c45:	008dc6        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014c48:	027266        	bnei	a2, 7, 42014c4e <periph_ll_get_clk_en_mask+0x4e>
42014c4b:	005e86        	j	42014dc9 <periph_ll_get_clk_en_mask+0x1c9>
42014c4e:	1282f6        	bgeui	a2, 8, 42014c64 <periph_ll_get_clk_en_mask+0x64>
42014c51:	025266        	bnei	a2, 5, 42014c57 <periph_ll_get_clk_en_mask+0x57>
42014c54:	005e06        	j	42014dd0 <periph_ll_get_clk_en_mask+0x1d0>
42014c57:	026226        	beqi	a2, 6, 42014c5d <periph_ll_get_clk_en_mask+0x5d>
42014c5a:	005e06        	j	42014dd6 <periph_ll_get_clk_en_mask+0x1d6>
    case PERIPH_USB_MODULE:
        return SYSTEM_USB_CLK_EN;
    case PERIPH_I2C0_MODULE:
        return SYSTEM_I2C_EXT0_CLK_EN;
    case PERIPH_I2C1_MODULE:
        return SYSTEM_I2C_EXT1_CLK_EN;
42014c5d:	b06c21        	l32r	a2, 42000e10 <_stext+0xdf0> (40000 <UserFrameTotalSize+0x3ff00>)
42014c60:	008706        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014c63:	822600        	mull	a2, a6, a0
    switch (periph) {
42014c66:	5c4602        	s8i	a0, a6, 92
42014c69:	6a2100        	maddn.s	f2, f1, f0
    case PERIPH_I2S0_MODULE:
        return SYSTEM_I2S0_CLK_EN;
    case PERIPH_I2S1_MODULE:
        return SYSTEM_I2S1_CLK_EN;
42014c6c:	83c6b0        	moveqz	a12, a6, a11
42014c6f:	b26600        	mulsh	a6, a6, a0
    switch (periph) {
42014c72:	5a8602        	lsi	f0, a6, 0x168
42014c75:	081c00        	lsx	f1, a12, a0
42014c78:	2c3827        	bltu	a8, a2, 42014ca8 <periph_ll_get_clk_en_mask+0xa8>
42014c7b:	02a266        	bnei	a2, 12, 42014c81 <periph_ll_get_clk_en_mask+0x81>
42014c7e:	005986        	j	42014de8 <periph_ll_get_clk_en_mask+0x1e8>
42014c81:	c80c      	movi.n	a8, 12
42014c83:	133827        	bltu	a8, a2, 42014c9a <periph_ll_get_clk_en_mask+0x9a>
42014c86:	029266        	bnei	a2, 10, 42014c8c <periph_ll_get_clk_en_mask+0x8c>
42014c89:	0058c6        	j	42014df0 <periph_ll_get_clk_en_mask+0x1f0>
42014c8c:	b80c      	movi.n	a8, 11
42014c8e:	021287        	beq	a2, a8, 42014c94 <periph_ll_get_clk_en_mask+0x94>
42014c91:	005846        	j	42014df6 <periph_ll_get_clk_en_mask+0x1f6>
    case PERIPH_LCD_CAM_MODULE:
        return SYSTEM_LCD_CAM_CLK_EN;
    case PERIPH_TIMG0_MODULE:
        return SYSTEM_TIMERGROUP_CLK_EN;
    case PERIPH_TIMG1_MODULE:
        return SYSTEM_TIMERGROUP1_CLK_EN;
42014c94:	ad6221        	l32r	a2, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
42014c97:	007946        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014c9a:	d80c      	movi.n	a8, 13
42014c9c:	021287        	beq	a2, a8, 42014ca2 <periph_ll_get_clk_en_mask+0xa2>
42014c9f:	005646        	j	42014dfc <periph_ll_get_clk_en_mask+0x1fc>
    case PERIPH_PWM0_MODULE:
        return SYSTEM_PWM0_CLK_EN;
    case PERIPH_PWM1_MODULE:
        return SYSTEM_PWM1_CLK_EN;
42014ca2:	b05e21        	l32r	a2, 42000e1c <_stext+0xdfc> (100000 <UserFrameTotalSize+0xfff00>)
42014ca5:	0075c6        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014ca8:	381c      	movi.n	a8, 19
42014caa:	029287        	bne	a2, a8, 42014cb0 <periph_ll_get_clk_en_mask+0xb0>
42014cad:	005406        	j	42014e01 <periph_ll_get_clk_en_mask+0x201>
42014cb0:	153827        	bltu	a8, a2, 42014cc9 <periph_ll_get_clk_en_mask+0xc9>
42014cb3:	181c      	movi.n	a8, 17
42014cb5:	029287        	bne	a2, a8, 42014cbb <periph_ll_get_clk_en_mask+0xbb>
42014cb8:	005306        	j	42014e08 <periph_ll_get_clk_en_mask+0x208>
42014cbb:	281c      	movi.n	a8, 18
42014cbd:	021287        	beq	a2, a8, 42014cc3 <periph_ll_get_clk_en_mask+0xc3>
42014cc0:	005286        	j	42014e0e <periph_ll_get_clk_en_mask+0x20e>
        return SYSTEM_RMT_CLK_EN;
42014cc3:	00a222        	movi	a2, 0x200
42014cc6:	006d86        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014cc9:	481c      	movi.n	a8, 20
42014ccb:	021287        	beq	a2, a8, 42014cd1 <periph_ll_get_clk_en_mask+0xd1>
42014cce:	005086        	j	42014e14 <periph_ll_get_clk_en_mask+0x214>
    case PERIPH_UHCI1_MODULE:
        return SYSTEM_UHCI1_CLK_EN;
    case PERIPH_PCNT_MODULE:
        return SYSTEM_PCNT_CLK_EN;
    case PERIPH_SPI_MODULE:
        return SYSTEM_SPI01_CLK_EN;
42014cd1:	220c      	movi.n	a2, 2
42014cd3:	006a46        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014cd6:	f81c      	movi.n	a8, 31
42014cd8:	029287        	bne	a2, a8, 42014cde <periph_ll_get_clk_en_mask+0xde>
42014cdb:	004e86        	j	42014e19 <periph_ll_get_clk_en_mask+0x219>
42014cde:	6a3827        	bltu	a8, a2, 42014d4c <periph_ll_get_clk_en_mask+0x14c>
42014ce1:	a81c      	movi.n	a8, 26
42014ce3:	029287        	bne	a2, a8, 42014ce9 <periph_ll_get_clk_en_mask+0xe9>
42014ce6:	004d06        	j	42014e1e <periph_ll_get_clk_en_mask+0x21e>
42014ce9:	2f3827        	bltu	a8, a2, 42014d1c <periph_ll_get_clk_en_mask+0x11c>
42014cec:	881c      	movi.n	a8, 24
42014cee:	029287        	bne	a2, a8, 42014cf4 <periph_ll_get_clk_en_mask+0xf4>
42014cf1:	004bc6        	j	42014e24 <periph_ll_get_clk_en_mask+0x224>
42014cf4:	153827        	bltu	a8, a2, 42014d0d <periph_ll_get_clk_en_mask+0x10d>
42014cf7:	681c      	movi.n	a8, 22
42014cf9:	029287        	bne	a2, a8, 42014cff <periph_ll_get_clk_en_mask+0xff>
42014cfc:	004b06        	j	42014e2c <periph_ll_get_clk_en_mask+0x22c>
42014cff:	781c      	movi.n	a8, 23
42014d01:	021287        	beq	a2, a8, 42014d07 <periph_ll_get_clk_en_mask+0x107>
42014d04:	004a86        	j	42014e32 <periph_ll_get_clk_en_mask+0x232>
    case PERIPH_SPI2_MODULE:
        return SYSTEM_SPI2_CLK_EN;
    case PERIPH_SPI3_MODULE:
        return SYSTEM_SPI3_CLK_EN;
    case PERIPH_SDMMC_MODULE:
        return SYSTEM_SDIO_HOST_CLK_EN;
42014d07:	80a022        	movi	a2, 128
42014d0a:	005c86        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014d0d:	981c      	movi.n	a8, 25
42014d0f:	021287        	beq	a2, a8, 42014d15 <periph_ll_get_clk_en_mask+0x115>
42014d12:	004886        	j	42014e38 <periph_ll_get_clk_en_mask+0x238>
    case PERIPH_TWAI_MODULE:
        return SYSTEM_TWAI_CLK_EN;
    case PERIPH_RNG_MODULE:
        return SYSTEM_WIFI_CLK_RNG_EN;
42014d15:	ad4121        	l32r	a2, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
42014d18:	005906        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014d1b:	d81c00        	lsi	f0, a12, 0x360
    switch (periph) {
42014d1e:	029287        	bne	a2, a8, 42014d24 <periph_ll_get_clk_en_mask+0x124>
42014d21:	004606        	j	42014e3d <periph_ll_get_clk_en_mask+0x23d>
42014d24:	153827        	bltu	a8, a2, 42014d3d <periph_ll_get_clk_en_mask+0x13d>
42014d27:	b81c      	movi.n	a8, 27
42014d29:	029287        	bne	a2, a8, 42014d2f <periph_ll_get_clk_en_mask+0x12f>
42014d2c:	004506        	j	42014e44 <periph_ll_get_clk_en_mask+0x244>
42014d2f:	c81c      	movi.n	a8, 28
42014d31:	021287        	beq	a2, a8, 42014d37 <periph_ll_get_clk_en_mask+0x137>
42014d34:	004446        	j	42014e49 <periph_ll_get_clk_en_mask+0x249>
    case PERIPH_WIFI_MODULE:
        return SYSTEM_WIFI_CLK_WIFI_EN_M;
    case PERIPH_BT_MODULE:
        return SYSTEM_WIFI_CLK_BT_EN_M;
    case PERIPH_WIFI_BT_COMMON_MODULE:
        return SYSTEM_WIFI_CLK_WIFI_BT_COMMON_M;
42014d37:	b03c21        	l32r	a2, 42000e28 <_stext+0xe08> (78078f <UserFrameTotalSize+0x78068f>)
42014d3a:	005086        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014d3d:	e81c      	movi.n	a8, 30
42014d3f:	021287        	beq	a2, a8, 42014d45 <periph_ll_get_clk_en_mask+0x145>
42014d42:	004206        	j	42014e4e <periph_ll_get_clk_en_mask+0x24e>
    case PERIPH_BT_BASEBAND_MODULE:
        return SYSTEM_BT_BASEBAND_EN;
    case PERIPH_BT_LC_MODULE:
        return SYSTEM_BT_LC_EN;
42014d45:	b03921        	l32r	a2, 42000e2c <_stext+0xe0c> (30000 <UserFrameTotalSize+0x2ff00>)
42014d48:	004d06        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014d4b:	482c00        	ssx	f2, a12, a0
    switch (periph) {
42014d4e:	029287        	bne	a2, a8, 42014d54 <periph_ll_get_clk_en_mask+0x154>
42014d51:	003fc6        	j	42014e54 <periph_ll_get_clk_en_mask+0x254>
42014d54:	2a3827        	bltu	a8, a2, 42014d82 <periph_ll_get_clk_en_mask+0x182>
42014d57:	282c      	movi.n	a8, 34
42014d59:	029287        	bne	a2, a8, 42014d5f <periph_ll_get_clk_en_mask+0x15f>
42014d5c:	003e86        	j	42014e5a <periph_ll_get_clk_en_mask+0x25a>
42014d5f:	123827        	bltu	a8, a2, 42014d75 <periph_ll_get_clk_en_mask+0x175>
42014d62:	02c266        	bnei	a2, 32, 42014d68 <periph_ll_get_clk_en_mask+0x168>
42014d65:	003dc6        	j	42014e60 <periph_ll_get_clk_en_mask+0x260>
42014d68:	182c      	movi.n	a8, 33
42014d6a:	021287        	beq	a2, a8, 42014d70 <periph_ll_get_clk_en_mask+0x170>
42014d6d:	003d06        	j	42014e65 <periph_ll_get_clk_en_mask+0x265>
    case PERIPH_SHA_MODULE:
        return SYSTEM_CRYPTO_SHA_CLK_EN;
    case PERIPH_RSA_MODULE:
        return SYSTEM_CRYPTO_RSA_CLK_EN;
    case PERIPH_HMAC_MODULE:
        return SYSTEM_CRYPTO_HMAC_CLK_EN;
42014d70:	022c      	movi.n	a2, 32
42014d72:	004286        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014d75:	382c      	movi.n	a8, 35
42014d77:	021287        	beq	a2, a8, 42014d7d <periph_ll_get_clk_en_mask+0x17d>
42014d7a:	003b06        	j	42014e6a <periph_ll_get_clk_en_mask+0x26a>
        return SYSTEM_CRYPTO_RSA_CLK_EN;
42014d7d:	820c      	movi.n	a2, 8
42014d7f:	003f46        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42014d82:	682c      	movi.n	a8, 38
42014d84:	029287        	bne	a2, a8, 42014d8a <periph_ll_get_clk_en_mask+0x18a>
42014d87:	003946        	j	42014e70 <periph_ll_get_clk_en_mask+0x270>
42014d8a:	782c      	movi.n	a8, 39
42014d8c:	029287        	bne	a2, a8, 42014d92 <periph_ll_get_clk_en_mask+0x192>
42014d8f:	003946        	j	42014e78 <periph_ll_get_clk_en_mask+0x278>
42014d92:	582c      	movi.n	a8, 37
42014d94:	021287        	beq	a2, a8, 42014d9a <periph_ll_get_clk_en_mask+0x19a>
42014d97:	0038c6        	j	42014e7e <periph_ll_get_clk_en_mask+0x27e>
        return SYSTEM_DMA_CLK_EN;
42014d9a:	024c      	movi.n	a2, 64
42014d9c:	003806        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014d9f:	024c00        	andb	b4, b12, b0
        return SYSTEM_SPI2_CLK_EN;
42014da2:	003686        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_LCD_CAM_CLK_EN;
42014da5:	00a122        	movi	a2, 0x100
42014da8:	003506        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014dab:	182100        	lsxp	f2, a1, a0
        return SYSTEM_USB_CLK_EN;
42014dae:	3346b0        	clamps	a4, a6, 18
42014db1:	022c00        	andb	b2, b12, b0
        return SYSTEM_UART1_CLK_EN;
42014db4:	003206        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014db7:	f62100        	lsi	f0, a1, 0x3d8
        return SYSTEM_LEDC_CLK_EN;
42014dba:	46ad      	lsi	f10, a6, 24
42014dbc:	0c0030        	lsi	f3, a0, 48
    case PERIPH_DS_MODULE:
        return SYSTEM_CRYPTO_DS_CLK_EN;
    default:
        return 0;
42014dbf:	2f0602        	l8ui	a0, a6, 47
42014dc2:	0c0000        	lsi	f0, a0, 48
42014dc5:	2d8602        	lsi	f0, a6, 180
42014dc8:	021c00        	andb	b1, b12, b0
        return SYSTEM_I2S0_CLK_EN;
42014dcb:	002c46        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014dce:	220000        	orb	b0, b0, b0
        return SYSTEM_I2C_EXT0_CLK_EN;
42014dd1:	4680a0        	lsi	f10, a0, 0x118
42014dd4:	002a      	add.n	a0, a0, a2
        return 0;
42014dd6:	020c      	movi.n	a2, 0
42014dd8:	002906        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014ddb:	020c00        	andb	b0, b12, b0
42014dde:	002786        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_UHCI0_CLK_EN;
42014de1:	00a122        	movi	a2, 0x100
42014de4:	002606        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014de7:	0c2100        	lsi	f0, a1, 48
        return SYSTEM_PWM0_CLK_EN;
42014dea:	2446b0        	extui	a4, a11, 6, 3
42014ded:	000000        	ill
        return SYSTEM_TIMERGROUP_CLK_EN;
42014df0:	ae8521        	l32r	a2, 42000804 <_stext+0x7e4> (2000 <UserFrameTotalSize+0x1f00>)
42014df3:	002246        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42014df6:	020c      	movi.n	a2, 0
42014df8:	002106        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014dfb:	020c00        	andb	b0, b12, b0
42014dfe:	001f86        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_PCNT_CLK_EN;
42014e01:	00a422        	movi	a2, 0x400
42014e04:	001e06        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e07:	7a2100        	divn.s	f2, f1, f0
        return SYSTEM_UHCI1_CLK_EN;
42014e0a:	ae          	.byte	0xae
42014e0b:	001c46        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42014e0e:	020c      	movi.n	a2, 0
42014e10:	001b06        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e13:	020c00        	andb	b0, b12, b0
42014e16:	001986        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_CRYPTO_AES_CLK_EN;
42014e19:	220c      	movi.n	a2, 2
42014e1b:	001846        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_WIFI_CLK_WIFI_EN_M;
42014e1e:	020c      	movi.n	a2, 0
42014e20:	001706        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e23:	002100        	lsi	f0, a1, 0
        return SYSTEM_TWAI_CLK_EN;
42014e26:	1546b0        	extui	a4, a11, 22, 2
42014e29:	000000        	ill
        return SYSTEM_SPI3_CLK_EN;
42014e2c:	affd21        	l32r	a2, 42000e20 <_stext+0xe00> (10000 <UserFrameTotalSize+0xff00>)
42014e2f:	001346        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42014e32:	020c      	movi.n	a2, 0
42014e34:	001206        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e37:	020c00        	andb	b0, b12, b0
42014e3a:	001086        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_BT_BASEBAND_EN;
42014e3d:	add421        	l32r	a2, 42000590 <_stext+0x570> (800 <UserFrameTotalSize+0x700>)
42014e40:	000f06        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e43:	020c00        	andb	b0, b12, b0
        return SYSTEM_WIFI_CLK_BT_EN_M;
42014e46:	000d86        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42014e49:	020c      	movi.n	a2, 0
42014e4b:	000c46        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e4e:	020c      	movi.n	a2, 0
42014e50:	000b06        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e53:	772100        	lsi	f0, a1, 0x1dc
        return SYSTEM_SYSTIMER_CLK_EN;
42014e56:	46ad      	lsi	f10, a6, 24
42014e58:	0009      	s32i.n	a0, a0, 0
        return SYSTEM_CRYPTO_DS_CLK_EN;
42014e5a:	021c      	movi.n	a2, 16
42014e5c:	000806        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e5f:	420c00        	xorb	b0, b12, b0
        return SYSTEM_CRYPTO_SHA_CLK_EN;
42014e62:	000686        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42014e65:	020c      	movi.n	a2, 0
42014e67:	000546        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e6a:	020c      	movi.n	a2, 0
42014e6c:	000406        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
42014e6f:	a02200        	addx4	a2, a2, a0
        return SYSTEM_CLK_EN_DEDICATED_GPIO;
42014e72:	024680        	andb	b4, b6, b8
42014e75:	000000        	ill
    switch (periph) {
42014e78:	afe421        	l32r	a2, 42000e08 <_stext+0xde8> (10000000 <UserFrameTotalSize+0xfffff00>)
42014e7b:	000046        	j	42014e80 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42014e7e:	020c      	movi.n	a2, 0
    }
}
42014e80:	f01d      	retw.n
	...

42014e84 <periph_ll_get_rst_en_mask>:

static inline uint32_t periph_ll_get_rst_en_mask(periph_module_t periph, bool enable)
{
42014e84:	004136        	entry	a1, 32
    switch (periph) {
42014e87:	381c      	movi.n	a8, 19
42014e89:	029287        	bne	a2, a8, 42014e8f <periph_ll_get_rst_en_mask+0xb>
42014e8c:	005846        	j	42014ff1 <periph_ll_get_rst_en_mask+0x16d>
42014e8f:	02b827        	bgeu	a8, a2, 42014e95 <periph_ll_get_rst_en_mask+0x11>
42014e92:	002886        	j	42014f38 <periph_ll_get_rst_en_mask+0xb4>
42014e95:	028266        	bnei	a2, 8, 42014e9b <periph_ll_get_rst_en_mask+0x17>
42014e98:	005706        	j	42014ff8 <periph_ll_get_rst_en_mask+0x174>
42014e9b:	880c      	movi.n	a8, 8
42014e9d:	433827        	bltu	a8, a2, 42014ee4 <periph_ll_get_rst_en_mask+0x60>
42014ea0:	024266        	bnei	a2, 4, 42014ea6 <periph_ll_get_rst_en_mask+0x22>
42014ea3:	005646        	j	42015000 <periph_ll_get_rst_en_mask+0x17c>
42014ea6:	2252f6        	bgeui	a2, 5, 42014ecc <periph_ll_get_rst_en_mask+0x48>
42014ea9:	022266        	bnei	a2, 2, 42014eaf <periph_ll_get_rst_en_mask+0x2b>
42014eac:	005586        	j	42015006 <periph_ll_get_rst_en_mask+0x182>
42014eaf:	0d32f6        	bgeui	a2, 3, 42014ec0 <periph_ll_get_rst_en_mask+0x3c>
42014eb2:	156216        	beqz	a2, 4201500c <periph_ll_get_rst_en_mask+0x188>
42014eb5:	021226        	beqi	a2, 1, 42014ebb <periph_ll_get_rst_en_mask+0x37>
42014eb8:	005586        	j	42015012 <periph_ll_get_rst_en_mask+0x18e>
    case PERIPH_WIFI_MODULE:
        return SYSTEM_WIFIMAC_RST;
    case PERIPH_BT_MODULE:
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
    case PERIPH_UART0_MODULE:
        return SYSTEM_UART_RST;
42014ebb:	420c      	movi.n	a2, 4
42014ebd:	007ec6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014ec0:	023226        	beqi	a2, 3, 42014ec6 <periph_ll_get_rst_en_mask+0x42>
42014ec3:	005446        	j	42015018 <periph_ll_get_rst_en_mask+0x194>
    case PERIPH_UART1_MODULE:
        return SYSTEM_UART1_RST;
    case PERIPH_UART2_MODULE:
        return SYSTEM_UART2_RST;
42014ec6:	00a222        	movi	a2, 0x200
42014ec9:	007bc6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014ecc:	026266        	bnei	a2, 6, 42014ed2 <periph_ll_get_rst_en_mask+0x4e>
42014ecf:	005286        	j	4201501d <periph_ll_get_rst_en_mask+0x199>
42014ed2:	027266        	bnei	a2, 7, 42014ed8 <periph_ll_get_rst_en_mask+0x54>
42014ed5:	0052c6        	j	42015024 <periph_ll_get_rst_en_mask+0x1a0>
42014ed8:	025226        	beqi	a2, 5, 42014ede <periph_ll_get_rst_en_mask+0x5a>
42014edb:	005286        	j	42015029 <periph_ll_get_rst_en_mask+0x1a5>
    case PERIPH_USB_MODULE:
        return SYSTEM_USB_RST;
    case PERIPH_I2C0_MODULE:
        return SYSTEM_I2C_EXT0_RST;
42014ede:	80a022        	movi	a2, 128
42014ee1:	0075c6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014ee4:	d80c      	movi.n	a8, 13
42014ee6:	029287        	bne	a2, a8, 42014eec <periph_ll_get_rst_en_mask+0x68>
42014ee9:	005046        	j	4201502e <periph_ll_get_rst_en_mask+0x1aa>
42014eec:	2c3827        	bltu	a8, a2, 42014f1c <periph_ll_get_rst_en_mask+0x98>
42014eef:	b80c      	movi.n	a8, 11
42014ef1:	029287        	bne	a2, a8, 42014ef7 <periph_ll_get_rst_en_mask+0x73>
42014ef4:	004f06        	j	42015034 <periph_ll_get_rst_en_mask+0x1b0>
42014ef7:	153827        	bltu	a8, a2, 42014f10 <periph_ll_get_rst_en_mask+0x8c>
42014efa:	980c      	movi.n	a8, 9
42014efc:	029287        	bne	a2, a8, 42014f02 <periph_ll_get_rst_en_mask+0x7e>
42014eff:	004e46        	j	4201503c <periph_ll_get_rst_en_mask+0x1b8>
42014f02:	029226        	beqi	a2, 10, 42014f08 <periph_ll_get_rst_en_mask+0x84>
42014f05:	004e46        	j	42015042 <periph_ll_get_rst_en_mask+0x1be>
    case PERIPH_I2S1_MODULE:
        return SYSTEM_I2S1_RST;
    case PERIPH_LCD_CAM_MODULE:
        return SYSTEM_LCD_CAM_RST;
    case PERIPH_TIMG0_MODULE:
        return SYSTEM_TIMERGROUP_RST;
42014f08:	ae3f21        	l32r	a2, 42000804 <_stext+0x7e4> (2000 <UserFrameTotalSize+0x1f00>)
42014f0b:	006b46        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42014f0e:	260000        	lsi	f0, a0, 152
    switch (periph) {
42014f11:	4602a2        	l8ui	a10, a2, 70
42014f14:	004c      	movi.n	a0, 64
    case PERIPH_TIMG1_MODULE:
        return SYSTEM_TIMERGROUP1_RST;
    case PERIPH_PWM0_MODULE:
        return SYSTEM_PWM0_RST;
42014f16:	afc021        	l32r	a2, 42000e18 <_stext+0xdf8> (20000 <UserFrameTotalSize+0x1ff00>)
42014f19:	0067c6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014f1c:	181c      	movi.n	a8, 17
42014f1e:	029287        	bne	a2, a8, 42014f24 <periph_ll_get_rst_en_mask+0xa0>
42014f21:	004a06        	j	4201504d <periph_ll_get_rst_en_mask+0x1c9>
42014f24:	281c      	movi.n	a8, 18
42014f26:	029287        	bne	a2, a8, 42014f2c <periph_ll_get_rst_en_mask+0xa8>
42014f29:	0049c6        	j	42015054 <periph_ll_get_rst_en_mask+0x1d0>
42014f2c:	02b226        	beqi	a2, 16, 42014f32 <periph_ll_get_rst_en_mask+0xae>
42014f2f:	0049c6        	j	4201505a <periph_ll_get_rst_en_mask+0x1d6>
    case PERIPH_PWM1_MODULE:
        return SYSTEM_PWM1_RST;
    case PERIPH_UHCI0_MODULE:
        return SYSTEM_UHCI0_RST;
42014f32:	00a122        	movi	a2, 0x100
42014f35:	0060c6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014f38:	02c266        	bnei	a2, 32, 42014f3e <periph_ll_get_rst_en_mask+0xba>
42014f3b:	002886        	j	42014fe1 <periph_ll_get_rst_en_mask+0x15d>
42014f3e:	082c      	movi.n	a8, 32
42014f40:	523827        	bltu	a8, a2, 42014f96 <periph_ll_get_rst_en_mask+0x112>
42014f43:	881c      	movi.n	a8, 24
42014f45:	029287        	bne	a2, a8, 42014f4b <periph_ll_get_rst_en_mask+0xc7>
42014f48:	004506        	j	42015060 <periph_ll_get_rst_en_mask+0x1dc>
42014f4b:	2d3827        	bltu	a8, a2, 42014f7c <periph_ll_get_rst_en_mask+0xf8>
42014f4e:	681c      	movi.n	a8, 22
42014f50:	029287        	bne	a2, a8, 42014f56 <periph_ll_get_rst_en_mask+0xd2>
42014f53:	004446        	j	42015068 <periph_ll_get_rst_en_mask+0x1e4>
42014f56:	143827        	bltu	a8, a2, 42014f6e <periph_ll_get_rst_en_mask+0xea>
42014f59:	481c      	movi.n	a8, 20
42014f5b:	029287        	bne	a2, a8, 42014f61 <periph_ll_get_rst_en_mask+0xdd>
42014f5e:	004306        	j	4201506e <periph_ll_get_rst_en_mask+0x1ea>
42014f61:	581c      	movi.n	a8, 21
42014f63:	021287        	beq	a2, a8, 42014f69 <periph_ll_get_rst_en_mask+0xe5>
42014f66:	004246        	j	42015073 <periph_ll_get_rst_en_mask+0x1ef>
    case PERIPH_PCNT_MODULE:
        return SYSTEM_PCNT_RST;
    case PERIPH_SPI_MODULE:
        return SYSTEM_SPI01_RST;
    case PERIPH_SPI2_MODULE:
        return SYSTEM_SPI2_RST;
42014f69:	024c      	movi.n	a2, 64
42014f6b:	005346        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014f6e:	781c      	movi.n	a8, 23
42014f70:	021287        	beq	a2, a8, 42014f76 <periph_ll_get_rst_en_mask+0xf2>
42014f73:	004046        	j	42015078 <periph_ll_get_rst_en_mask+0x1f4>
    case PERIPH_SPI3_MODULE:
        return SYSTEM_SPI3_RST;
    case PERIPH_SDMMC_MODULE:
        return SYSTEM_SDIO_HOST_RST;
42014f76:	80a022        	movi	a2, 128
42014f79:	004fc6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014f7c:	b81c      	movi.n	a8, 27
42014f7e:	029287        	bne	a2, a8, 42014f84 <periph_ll_get_rst_en_mask+0x100>
42014f81:	003e06        	j	4201507d <periph_ll_get_rst_en_mask+0x1f9>
42014f84:	f81c      	movi.n	a8, 31
42014f86:	4f1287        	beq	a2, a8, 42014fd9 <periph_ll_get_rst_en_mask+0x155>
42014f89:	a81c      	movi.n	a8, 26
42014f8b:	021287        	beq	a2, a8, 42014f91 <periph_ll_get_rst_en_mask+0x10d>
42014f8e:	003c86        	j	42015084 <periph_ll_get_rst_en_mask+0x200>
        return SYSTEM_WIFIMAC_RST;
42014f91:	420c      	movi.n	a2, 4
42014f93:	004946        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42014f96:	482c      	movi.n	a8, 36
42014f98:	029287        	bne	a2, a8, 42014f9e <periph_ll_get_rst_en_mask+0x11a>
42014f9b:	003a86        	j	42015089 <periph_ll_get_rst_en_mask+0x205>
42014f9e:	1a3827        	bltu	a8, a2, 42014fbc <periph_ll_get_rst_en_mask+0x138>
42014fa1:	282c      	movi.n	a8, 34
42014fa3:	029287        	bne	a2, a8, 42014fa9 <periph_ll_get_rst_en_mask+0x125>
42014fa6:	003986        	j	42015090 <periph_ll_get_rst_en_mask+0x20c>
42014fa9:	382c      	movi.n	a8, 35
42014fab:	3a1287        	beq	a2, a8, 42014fe9 <periph_ll_get_rst_en_mask+0x165>
42014fae:	182c      	movi.n	a8, 33
42014fb0:	021287        	beq	a2, a8, 42014fb6 <periph_ll_get_rst_en_mask+0x132>
42014fb3:	003786        	j	42015095 <periph_ll_get_rst_en_mask+0x211>
    case PERIPH_DEDIC_GPIO_MODULE:
        return SYSTEM_RST_EN_DEDICATED_GPIO;
    case PERIPH_GDMA_MODULE:
        return SYSTEM_DMA_RST;
    case PERIPH_HMAC_MODULE:
        return SYSTEM_CRYPTO_HMAC_RST;
42014fb6:	022c      	movi.n	a2, 32
42014fb8:	004006        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42014fbb:	682c00        	lsi	f0, a12, 0x1a0
    switch (periph) {
42014fbe:	029287        	bne	a2, a8, 42014fc4 <periph_ll_get_rst_en_mask+0x140>
42014fc1:	0035c6        	j	4201509c <periph_ll_get_rst_en_mask+0x218>
42014fc4:	782c      	movi.n	a8, 39
42014fc6:	029287        	bne	a2, a8, 42014fcc <periph_ll_get_rst_en_mask+0x148>
42014fc9:	0035c6        	j	420150a4 <periph_ll_get_rst_en_mask+0x220>
42014fcc:	582c      	movi.n	a8, 37
42014fce:	021287        	beq	a2, a8, 42014fd4 <periph_ll_get_rst_en_mask+0x150>
42014fd1:	003546        	j	420150aa <periph_ll_get_rst_en_mask+0x226>
        return SYSTEM_DMA_RST;
42014fd4:	024c      	movi.n	a2, 64
42014fd6:	003886        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
    case PERIPH_DS_MODULE:
        return SYSTEM_CRYPTO_DS_RST;
    case PERIPH_AES_MODULE:
        if (enable == true) {
42014fd9:	0d3316        	beqz	a3, 420150b0 <periph_ll_get_rst_en_mask+0x22c>
            // Clear reset on digital signature, otherwise AES unit is held in reset also.
            return (SYSTEM_CRYPTO_AES_RST | SYSTEM_CRYPTO_DS_RST);
42014fdc:	221c      	movi.n	a2, 18
42014fde:	003686        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        } else {
            //Don't return other units to reset, as this pulls reset on RSA & SHA units, respectively.
            return SYSTEM_CRYPTO_AES_RST;
        }
    case PERIPH_SHA_MODULE:
        if (enable == true) {
42014fe1:	0d0316        	beqz	a3, 420150b5 <periph_ll_get_rst_en_mask+0x231>
            // Clear reset on digital signature and HMAC, otherwise SHA is held in reset
            return (SYSTEM_CRYPTO_SHA_RST | SYSTEM_CRYPTO_DS_RST | SYSTEM_CRYPTO_HMAC_RST) ;
42014fe4:	423c      	movi.n	a2, 52
42014fe6:	003486        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        } else {
            // Don't assert reset on secure boot, otherwise AES is held in reset
            return SYSTEM_CRYPTO_SHA_RST;
        }
    case PERIPH_RSA_MODULE:
        if (enable == true) {
42014fe9:	0cd316        	beqz	a3, 420150ba <periph_ll_get_rst_en_mask+0x236>
            /* also clear reset on digital signature, otherwise RSA is held in reset */
            return (SYSTEM_CRYPTO_RSA_RST | SYSTEM_CRYPTO_DS_RST);
42014fec:	821c      	movi.n	a2, 24
42014fee:	003286        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_PCNT_RST;
42014ff1:	00a422        	movi	a2, 0x400
42014ff4:	003106        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42014ff7:	872100        	lsi	f0, a1, 0x21c
        return SYSTEM_I2S1_RST;
42014ffa:	af          	.byte	0xaf
42014ffb:	002f46        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42014ffe:	210000        	srai	a0, a0, 0
        return SYSTEM_USB_RST;
42015001:	46af83        	lsi	f8, a15, 0x118
42015004:	002d      	mov.n	a2, a0
        return SYSTEM_UART1_RST;
42015006:	022c      	movi.n	a2, 32
42015008:	002c06        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
4201500b:	612100        	xsr.m1	a0
        return SYSTEM_LEDC_RST;
4201500e:	46ad      	lsi	f10, a6, 24
42015010:	002a      	add.n	a0, a0, a2
        } else {
            /* don't reset digital signature unit, as this resets AES also */
            return SYSTEM_CRYPTO_RSA_RST;
        }
    default:
        return 0;
42015012:	020c      	movi.n	a2, 0
42015014:	002906        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42015017:	020c00        	andb	b0, b12, b0
4201501a:	002786        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_I2C_EXT1_RST;
4201501d:	af7c21        	l32r	a2, 42000e10 <_stext+0xdf0> (40000 <UserFrameTotalSize+0x3ff00>)
42015020:	002606        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42015023:	021c00        	andb	b1, b12, b0
        return SYSTEM_I2S0_RST;
42015026:	002486        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return 0;
42015029:	020c      	movi.n	a2, 0
4201502b:	002346        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_PWM1_RST;
4201502e:	af7b21        	l32r	a2, 42000e1c <_stext+0xdfc> (100000 <UserFrameTotalSize+0xfff00>)
42015031:	0021c6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_TIMERGROUP1_RST;
42015034:	ac7a21        	l32r	a2, 4200021c <_stext+0x1fc> (8000 <UserFrameTotalSize+0x7f00>)
42015037:	002046        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
4201503a:	220000        	orb	b0, b0, b0
        return SYSTEM_LCD_CAM_RST;
4201503d:	4600a1        	l32r	a10, 41fe6840 <_coredump_iram_end+0x1c64940>
42015040:	1e          	.byte	0x1e
42015041:	020c00        	andb	b0, b12, b0
        return 0;
42015044:	001d06        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42015047:	020c00        	andb	b0, b12, b0
4201504a:	001b86        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_UHCI1_RST;
4201504d:	ade821        	l32r	a2, 420007f0 <_stext+0x7d0> (1000 <UserFrameTotalSize+0xf00>)
42015050:	001a06        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42015053:	a22200        	muluh	a2, a2, a0
        return SYSTEM_RMT_RST;
42015056:	184600        	lsxp	f4, a6, a0
42015059:	020c00        	andb	b0, b12, b0
        return 0;
4201505c:	001706        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
4201505f:	712100        	lsi	f0, a1, 0x1c4
        return SYSTEM_TWAI_RST;
42015062:	af          	.byte	0xaf
42015063:	001546        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42015066:	210000        	srai	a0, a0, 0
        return SYSTEM_SPI3_RST;
42015069:	6e          	.byte	0x6e
4201506a:	af          	.byte	0xaf
4201506b:	001346        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_SPI01_RST;
4201506e:	220c      	movi.n	a2, 2
42015070:	001206        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return 0;
42015073:	020c      	movi.n	a2, 0
42015075:	0010c6        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42015078:	020c      	movi.n	a2, 0
4201507a:	000f86        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
4201507d:	af6c21        	l32r	a2, 42000e30 <_stext+0xe10> (3e08 <UserFrameTotalSize+0x3d08>)
42015080:	000e06        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
42015083:	020c00        	andb	b0, b12, b0
        return 0;
42015086:	000c86        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_SYSTIMER_RST;
42015089:	ace921        	l32r	a2, 42000430 <_stext+0x410> (20000000 <UserFrameTotalSize+0x1fffff00>)
4201508c:	000b06        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
4201508f:	021c00        	andb	b1, b12, b0
        return SYSTEM_CRYPTO_DS_RST;
42015092:	000986        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return 0;
42015095:	020c      	movi.n	a2, 0
42015097:	000846        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
4201509a:	220000        	orb	b0, b0, b0
        return SYSTEM_RST_EN_DEDICATED_GPIO;
4201509d:	4680a0        	lsi	f10, a0, 0x118
420150a0:	000006        	j	420150a4 <periph_ll_get_rst_en_mask+0x220>
420150a3:	592100        	s32nb	a0, a1, 8
    switch (periph) {
420150a6:	af          	.byte	0xaf
420150a7:	000446        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
        return 0;
420150aa:	020c      	movi.n	a2, 0
420150ac:	000306        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
420150af:	220c00        	orb	b0, b12, b0
            return SYSTEM_CRYPTO_AES_RST;
420150b2:	000186        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
            return SYSTEM_CRYPTO_SHA_RST;
420150b5:	420c      	movi.n	a2, 4
420150b7:	000046        	j	420150bc <periph_ll_get_rst_en_mask+0x238>
            return SYSTEM_CRYPTO_RSA_RST;
420150ba:	820c      	movi.n	a2, 8
    }
}
420150bc:	f01d      	retw.n
	...

420150c0 <periph_ll_get_clk_en_reg>:

static inline uint32_t periph_ll_get_clk_en_reg(periph_module_t periph)
{
420150c0:	004136        	entry	a1, 32
    switch (periph) {
420150c3:	2d3226        	beqi	a2, 3, 420150f4 <periph_ll_get_clk_en_reg+0x34>
420150c6:	3232b6        	bltui	a2, 3, 420150fc <periph_ll_get_clk_en_reg+0x3c>
420150c9:	682c      	movi.n	a8, 38
420150cb:	353827        	bltu	a8, a2, 42015104 <periph_ll_get_clk_en_reg+0x44>
420150ce:	980c      	movi.n	a8, 9
420150d0:	383287        	bltu	a2, a8, 4201510c <periph_ll_get_clk_en_reg+0x4c>
420150d3:	f7c222        	addi	a2, a2, -9
420150d6:	180c      	movi.n	a8, 1
420150d8:	401200        	ssl	a2
420150db:	a18800        	sll	a8, a8
420150de:	af5691        	l32r	a9, 42000e38 <_stext+0xe18> (17c04001 <UserFrameTotalSize+0x17c03f01>)
420150e1:	2f8897        	bany	a8, a9, 42015114 <periph_ll_get_clk_en_reg+0x54>
420150e4:	559080        	extui	a9, a8, 16, 6
420150e7:	19fc      	bnez.n	a9, 4201511c <periph_ll_get_clk_en_reg+0x5c>
420150e9:	3778d7        	bbci	a8, 29, 42015124 <periph_ll_get_clk_en_reg+0x64>
420150ec:	af5221        	l32r	a2, 42000e34 <_stext+0xe14> (600c0008 <SYSTEM+0x8>)
420150ef:	000d06        	j	42015127 <periph_ll_get_clk_en_reg+0x67>
420150f2:	210000        	srai	a0, a0, 0
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_CLK_EN1_REG;
420150f5:	06ac25        	call8	4201bbb8 <_etext+0x5962>
420150f8:	000b      	addi.n	a0, a0, -1
420150fa:	210000        	srai	a0, a0, 0
    default:
        return SYSTEM_PERIP_CLK_EN0_REG;
420150fd:	06ac22        	movi	a2, 0xfffffc06
42015100:	0009      	s32i.n	a0, a0, 0
42015102:	210000        	srai	a0, a0, 0
42015105:	06ac20        	lsi	f2, a12, 24
42015108:	000007        	bnone	a0, a0, 4201510c <periph_ll_get_clk_en_reg+0x4c>
4201510b:	1e2100        	f64sexp	a2, a1, a0
4201510e:	06ac      	beqz.n	a6, 42015132 <periph_ll_get_rst_en_reg+0x6>
42015110:	000005        	call0	42015114 <periph_ll_get_clk_en_reg+0x54>
42015113:	1d2100        	lsi	f0, a1, 116
        return SYSTEM_PERIP_CLK_EN1_REG;
42015116:	06ac      	beqz.n	a6, 4201513a <periph_ll_get_rst_en_reg+0xe>
42015118:	000003        	lsi	f0, a0, 0
4201511b:	1c2100        	lsi	f0, a1, 112
        return SYSTEM_WIFI_CLK_EN_REG ;
4201511e:	06ac      	beqz.n	a6, 42015142 <periph_ll_get_rst_en_reg+0x16>
42015120:	000001        	l32r	a0, 41fd5120 <_coredump_iram_end+0x1c53220>
42015123:	182100        	lsxp	f2, a1, a0
        return SYSTEM_PERIP_CLK_EN0_REG;
42015126:	1dac      	beqz.n	a13, 4201514b <periph_ll_get_rst_en_reg+0x1f>
    }
}
42015128:	0000f0        	callx12	a0
	...

4201512c <periph_ll_get_rst_en_reg>:

static inline uint32_t periph_ll_get_rst_en_reg(periph_module_t periph)
{
4201512c:	004136        	entry	a1, 32
    switch (periph) {
4201512f:	2b3226        	beqi	a2, 3, 4201515e <periph_ll_get_rst_en_reg+0x32>
42015132:	2e32b6        	bltui	a2, 3, 42015164 <periph_ll_get_rst_en_reg+0x38>
42015135:	682c      	movi.n	a8, 38
42015137:	313827        	bltu	a8, a2, 4201516c <periph_ll_get_rst_en_reg+0x40>
4201513a:	980c      	movi.n	a8, 9
4201513c:	343287        	bltu	a2, a8, 42015174 <periph_ll_get_rst_en_reg+0x48>
4201513f:	f7c222        	addi	a2, a2, -9
42015142:	180c      	movi.n	a8, 1
42015144:	401200        	ssl	a2
42015147:	a18800        	sll	a8, a8
4201514a:	af3b91        	l32r	a9, 42000e38 <_stext+0xe18> (17c04001 <UserFrameTotalSize+0x17c03f01>)
4201514d:	2b8897        	bany	a8, a9, 4201517c <periph_ll_get_rst_en_reg+0x50>
42015150:	559080        	extui	a9, a8, 16, 6
42015153:	d9ec      	bnez.n	a9, 42015184 <periph_ll_get_rst_en_reg+0x58>
42015155:	3378d7        	bbci	a8, 29, 4201518c <periph_ll_get_rst_en_reg+0x60>
42015158:	af3a21        	l32r	a2, 42000e40 <_stext+0xe20> (600c000c <SYSTEM+0xc>)
4201515b:	000c06        	j	4201518f <periph_ll_get_rst_en_reg+0x63>
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_RST_EN1_REG;
4201515e:	ac0e21        	l32r	a2, 42000198 <_stext+0x178> (600c0024 <SYSTEM+0x24>)
42015161:	000a86        	j	4201518f <periph_ll_get_rst_en_reg+0x63>
    default:
        return SYSTEM_PERIP_RST_EN0_REG;
42015164:	ac0c21        	l32r	a2, 42000194 <_stext+0x174> (600c0020 <SYSTEM+0x20>)
42015167:	000906        	j	4201518f <periph_ll_get_rst_en_reg+0x63>
4201516a:	210000        	srai	a0, a0, 0
4201516d:	ac0a      	add.n	a10, a12, a0
4201516f:	000706        	j	4201518f <periph_ll_get_rst_en_reg+0x63>
42015172:	210000        	srai	a0, a0, 0
42015175:	ac08      	l32i.n	a0, a12, 40
42015177:	000506        	j	4201518f <periph_ll_get_rst_en_reg+0x63>
4201517a:	210000        	srai	a0, a0, 0
        return SYSTEM_PERIP_RST_EN1_REG;
4201517d:	06ac07        	bge	a12, a0, 42015187 <periph_ll_get_rst_en_reg+0x5b>
42015180:	000003        	lsi	f0, a0, 0
42015183:	2e2100        	f64norm	a2, a1, a0, 0
        return SYSTEM_CORE_RST_EN_REG;
42015186:	af          	.byte	0xaf
42015187:	000106        	j	4201518f <periph_ll_get_rst_en_reg+0x63>
4201518a:	210000        	srai	a0, a0, 0
        return SYSTEM_PERIP_RST_EN0_REG;
4201518d:	1dac02        	movi	a0, 0xfffffc1d
    }
}
42015190:	0000f0        	callx12	a0
	...

42015194 <periph_ll_enable_clk_clear_rst>:

static inline void periph_ll_enable_clk_clear_rst(periph_module_t periph)
{
42015194:	004136        	entry	a1, 32
    DPORT_SET_PERI_REG_MASK(periph_ll_get_clk_en_reg(periph), periph_ll_get_clk_en_mask(periph));
42015197:	20a220        	or	a10, a2, a2
4201519a:	fff265        	call8	420150c0 <periph_ll_get_clk_en_reg>
4201519d:	0a7d      	mov.n	a7, a10
4201519f:	0020c0        	memw
420151a2:	0a68      	l32i.n	a6, a10, 0
420151a4:	20a220        	or	a10, a2, a2
420151a7:	ffa5a5        	call8	42014c00 <periph_ll_get_clk_en_mask>
420151aa:	2066a0        	or	a6, a6, a10
420151ad:	0020c0        	memw
420151b0:	0769      	s32i.n	a6, a7, 0
    DPORT_CLEAR_PERI_REG_MASK(periph_ll_get_rst_en_reg(periph), periph_ll_get_rst_en_mask(periph, true));
420151b2:	02ad      	mov.n	a10, a2
420151b4:	fff765        	call8	4201512c <periph_ll_get_rst_en_reg>
420151b7:	0a7d      	mov.n	a7, a10
420151b9:	0020c0        	memw
420151bc:	0a68      	l32i.n	a6, a10, 0
420151be:	1b0c      	movi.n	a11, 1
420151c0:	02ad      	mov.n	a10, a2
420151c2:	ffcc25        	call8	42014e84 <periph_ll_get_rst_en_mask>
420151c5:	108a60        	and	a8, a10, a6
420151c8:	308860        	xor	a8, a8, a6
420151cb:	0020c0        	memw
420151ce:	0789      	s32i.n	a8, a7, 0
}
420151d0:	f01d      	retw.n
	...

420151d4 <periph_module_enable>:
    ref_counts[periph] = ref_count;
    periph_rcc_exit();
}

void periph_module_enable(periph_module_t periph)
{
420151d4:	004136        	entry	a1, 32
#ifdef __PERIPH_CTRL_ALLOW_LEGACY_API
    assert(periph < PERIPH_MODULE_MAX);
420151d7:	882c      	movi.n	a8, 40
420151d9:	10b827        	bgeu	a8, a2, 420151ed <periph_module_enable+0x19>
420151dc:	af1ad1        	l32r	a13, 42000e44 <_stext+0xe24> (3c0235e0 <_flash_rodata_start+0x34c0>)
420151df:	af1ac1        	l32r	a12, 42000e48 <_stext+0xe28> (3c027b94 <__func__$2>)
420151e2:	db3c      	movi.n	a11, 61
420151e4:	af1aa1        	l32r	a10, 42000e4c <_stext+0xe2c> (3c02361c <_flash_rodata_start+0x34fc>)
420151e7:	abb681        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420151ea:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
420151ed:	ac8181        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
420151f0:	0008e0        	callx8	a8
420151f3:	ea8c      	beqz.n	a10, 42015205 <periph_module_enable+0x31>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
420151f5:	fb7c      	movi.n	a11, -1
420151f7:	af16a1        	l32r	a10, 42000e50 <_stext+0xe30> (3fc91f58 <periph_spinlock>)
420151fa:	ac8581        	l32r	a8, 42000410 <_stext+0x3f0> (4037a130 <xPortEnterCriticalTimeout>)
420151fd:	0008e0        	callx8	a8
42015200:	000306        	j	42015210 <periph_module_enable+0x3c>
42015203:	7c0000        	lsi	f0, a0, 0x1f0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
42015206:	a1fb      	addi.n	a10, a1, 15
42015208:	81af12        	movi	a1, -127
4201520b:	e0ac81        	l32r	a8, 4200d4bc <_vfprintf_r+0x19dc> (871b0057 <_rtc_reserved_end+0x270b0057>)
4201520e:	0008      	l32i.n	a0, a0, 0
    portENTER_CRITICAL_SAFE(&periph_spinlock);
    if (ref_counts[periph] == 0) {
42015210:	af1181        	l32r	a8, 42000e54 <_stext+0xe34> (3fc94ad0 <ref_counts>)
42015213:	882a      	add.n	a8, a8, a2
42015215:	000882        	l8ui	a8, a8, 0
42015218:	005856        	bnez	a8, 42015221 <periph_module_enable+0x4d>
        periph_ll_enable_clk_clear_rst(periph);
4201521b:	20a220        	or	a10, a2, a2
4201521e:	fff765        	call8	42015194 <periph_ll_enable_clk_clear_rst>
    }
    ref_counts[periph]++;
42015221:	af0c81        	l32r	a8, 42000e54 <_stext+0xe34> (3fc94ad0 <ref_counts>)
42015224:	882a      	add.n	a8, a8, a2
42015226:	000892        	l8ui	a9, a8, 0
42015229:	01c992        	addi	a9, a9, 1
4201522c:	004892        	s8i	a9, a8, 0
    if (xPortInIsrContext()) {
4201522f:	ac7181        	l32r	a8, 420003f4 <_stext+0x3d4> (4037a10c <xPortInIsrContext>)
42015232:	0008e0        	callx8	a8
42015235:	ba8c      	beqz.n	a10, 42015244 <periph_module_enable+0x70>
        portEXIT_CRITICAL_ISR(mux);
42015237:	af06a1        	l32r	a10, 42000e50 <_stext+0xe30> (3fc91f58 <periph_spinlock>)
4201523a:	ac7681        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4201523d:	0008e0        	callx8	a8
42015240:	000246        	j	4201524d <periph_module_enable+0x79>
42015243:	03a100        	rsr.dbreakc1	a0
        portEXIT_CRITICAL(mux);
42015246:	af          	.byte	0xaf
42015247:	ac7381        	l32r	a8, 42000414 <_stext+0x3f4> (4037a280 <vPortExitCritical>)
4201524a:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
#endif
}
4201524d:	f01d      	retw.n
	...

42015250 <set_ocode_by_efuse>:
    val |= RTC_CNTL_SDIO_PD_EN;
    REG_WRITE(RTC_CNTL_SDIO_CONF_REG, val);
}

static void set_ocode_by_efuse(int calib_version)
{
42015250:	004136        	entry	a1, 32
    assert(calib_version == 1);
42015253:	111226        	beqi	a2, 1, 42015268 <set_ocode_by_efuse+0x18>
42015256:	af00d1        	l32r	a13, 42000e58 <_stext+0xe38> (3c0236c8 <_flash_rodata_start+0x35a8>)
42015259:	af00c1        	l32r	a12, 42000e5c <_stext+0xe3c> (3c027c08 <__func__$3>)
4201525c:	fca0b2        	movi	a11, 252
4201525f:	af00a1        	l32r	a10, 42000e60 <_stext+0xe40> (3c023709 <_flash_rodata_start+0x35e9>)
42015262:	ab9781        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015265:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_ocode(void)
{
    // EFUSE_BLK2,  141,    8,     ADC OCode
    return EFUSE.rd_sys_part1_data4.ocode;
42015268:	aeff81        	l32r	a8, 42000e64 <_stext+0xe44> (60007000 <EFUSE>)
4201526b:	0020c0        	memw
4201526e:	1b28f2        	l32i	a15, a8, 108
    // use efuse ocode.
    uint32_t ocode = efuse_ll_get_ocode();
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_EXT_CODE, ocode);
42015271:	74fdf0        	extui	a15, a15, 13, 8
42015274:	0e0c      	movi.n	a14, 0
42015276:	7d0c      	movi.n	a13, 7
42015278:	6c0c      	movi.n	a12, 6
4201527a:	1b0c      	movi.n	a11, 1
4201527c:	61a0a2        	movi	a10, 97
4201527f:	ac6981        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42015282:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_FORCE_CODE, 1);
42015285:	1f0c      	movi.n	a15, 1
42015287:	6e0c      	movi.n	a14, 6
42015289:	0edd      	mov.n	a13, a14
4201528b:	5c0c      	movi.n	a12, 5
4201528d:	0fbd      	mov.n	a11, a15
4201528f:	61a0a2        	movi	a10, 97
42015292:	ac6481        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42015295:	0008e0        	callx8	a8
}
42015298:	f01d      	retw.n
	...

4201529c <get_dig1v3_dbias_by_efuse>:
    }
    return rtc_dbias;
}

static uint32_t get_dig1v3_dbias_by_efuse(uint8_t pvt_scheme_ver)
{
4201529c:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
4201529f:	111226        	beqi	a2, 1, 420152b4 <get_dig1v3_dbias_by_efuse+0x18>
420152a2:	aef1d1        	l32r	a13, 42000e68 <_stext+0xe48> (3c023714 <_flash_rodata_start+0x35f4>)
420152a5:	aef1c1        	l32r	a12, 42000e6c <_stext+0xe4c> (3c027bec <__func__$2>)
420152a8:	6ca1b2        	movi	a11, 0x16c
420152ab:	aeeda1        	l32r	a10, 42000e60 <_stext+0xe40> (3c023709 <_flash_rodata_start+0x35e9>)
420152ae:	ab8481        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420152b1:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_k_dig_ldo(void)
{
    // EFUSE_BLK1,  148,    7,     BLOCK1 K_DIG_LDO
    return EFUSE.rd_mac_spi_sys_4.k_dig_ldo;
420152b4:	aeec81        	l32r	a8, 42000e64 <_stext+0xe44> (60007000 <EFUSE>)
420152b7:	0020c0        	memw
420152ba:	1528a2        	l32i	a10, a8, 84
420152bd:	65a4a0        	extui	a10, a10, 20, 7
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_v_dig_dbias20(void)
{
    // EFUSE_BLK1,  163,    8,     BLOCK1 voltage of digital dbias20
    return EFUSE.rd_mac_spi_sys_5.v_dig_dbias20;
420152c0:	0020c0        	memw
420152c3:	162892        	l32i	a9, a8, 88
420152c6:	748390        	extui	a8, a9, 3, 8
420152c9:	209880        	or	a9, a8, a8
    signed int k_dig_ldo = efuse_ll_get_k_dig_ldo();
    signed int v_dig_bias20 = efuse_ll_get_v_dig_dbias20();
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
420152cc:	3fa0b2        	movi	a11, 63
420152cf:	05bba7        	bgeu	a11, a10, 420152d8 <get_dig1v3_dbias_by_efuse+0x3c>
420152d2:	10aab0        	and	a10, a10, a11
420152d5:	60a0a0        	neg	a10, a10
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
420152d8:	056877        	bbci	a8, 7, 420152e1 <get_dig1v3_dbias_by_efuse+0x45>
420152db:	649090        	extui	a9, a9, 0, 7
420152de:	609090        	neg	a9, a9

    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
420152e1:	a09990        	addx4	a9, a9, a9
420152e4:	aee381        	l32r	a8, 42000e70 <_stext+0xe50> (2a59 <UserFrameTotalSize+0x2959>)
420152e7:	a09980        	addx4	a9, a9, a8
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
420152ea:	d3a082        	movi	a8, 211
420152ed:	aa8a      	add.n	a10, a10, a8
    uint32_t dig_dbias =15;
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
420152ef:	f20c      	movi.n	a2, 15
420152f1:	0003c6        	j	42015304 <get_dig1v3_dbias_by_efuse+0x68>
        uint32_t v_dig_nearest_1v3_mul10000 = 0;
        v_dig_nearest_1v3_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
420152f4:	ecc282        	addi	a8, a2, -20
420152f7:	828a80        	mull	a8, a10, a8
420152fa:	889a      	add.n	a8, a8, a9
        if (v_dig_nearest_1v3_mul10000 >= 13000) {
420152fc:	aedeb1        	l32r	a11, 42000e74 <_stext+0xe54> (32c7 <UserFrameTotalSize+0x31c7>)
420152ff:	063b87        	bltu	a11, a8, 42015309 <get_dig1v3_dbias_by_efuse+0x6d>
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
42015302:	221b      	addi.n	a2, a2, 1
42015304:	e81c      	movi.n	a8, 30
42015306:	eab827        	bgeu	a8, a2, 420152f4 <get_dig1v3_dbias_by_efuse+0x58>
            break;
        }
    }
    return dig_dbias;
}
42015309:	f01d      	retw.n
	...

4201530c <get_dig_dbias_by_efuse>:
{
4201530c:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
4201530f:	111226        	beqi	a2, 1, 42015324 <get_dig_dbias_by_efuse+0x18>
42015312:	aed5d1        	l32r	a13, 42000e68 <_stext+0xe48> (3c023714 <_flash_rodata_start+0x35f4>)
42015315:	aed8c1        	l32r	a12, 42000e78 <_stext+0xe58> (3c027bd4 <__func__$1>)
42015318:	4aa1b2        	movi	a11, 0x14a
4201531b:	aed1a1        	l32r	a10, 42000e60 <_stext+0xe40> (3c023709 <_flash_rodata_start+0x35e9>)
4201531e:	ab6881        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015321:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_dig_dbias_hvt(void)
{
    // EFUSE_BLK1,  171,    5,     BLOCK1 digital dbias when hvt
    return EFUSE.rd_mac_spi_sys_5.dig_dbias_hvt;
42015324:	aed081        	l32r	a8, 42000e64 <_stext+0xe44> (60007000 <EFUSE>)
42015327:	0020c0        	memw
4201532a:	162822        	l32i	a2, a8, 88
}
4201532d:	442b20        	extui	a2, a2, 11, 5
42015330:	f01d      	retw.n
	...

42015334 <get_rtc_dbias_by_efuse>:
{
42015334:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
42015337:	111226        	beqi	a2, 1, 4201534c <get_rtc_dbias_by_efuse+0x18>
4201533a:	aecbd1        	l32r	a13, 42000e68 <_stext+0xe48> (3c023714 <_flash_rodata_start+0x35f4>)
4201533d:	aecfc1        	l32r	a12, 42000e7c <_stext+0xe5c> (3c027bbc <__func__$0>)
42015340:	50a1b2        	movi	a11, 0x150
42015343:	aec7a1        	l32r	a10, 42000e60 <_stext+0xe40> (3c023709 <_flash_rodata_start+0x35e9>)
42015346:	ab5e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015349:	0008e0        	callx8	a8
    return EFUSE.rd_mac_spi_sys_4.k_rtc_ldo;
4201534c:	aec681        	l32r	a8, 42000e64 <_stext+0xe44> (60007000 <EFUSE>)
4201534f:	0020c0        	memw
42015352:	1528c2        	l32i	a12, a8, 84
42015355:	64cdc0        	extui	a12, a12, 13, 7
    return EFUSE.rd_mac_spi_sys_4.k_dig_ldo;
42015358:	0020c0        	memw
4201535b:	1528b2        	l32i	a11, a8, 84
4201535e:	65b4b0        	extui	a11, a11, 20, 7
    return (EFUSE.rd_mac_spi_sys_5.v_rtc_dbias20_1 << 5) + EFUSE.rd_mac_spi_sys_4.v_rtc_dbias20;
42015361:	0020c0        	memw
42015364:	1628a2        	l32i	a10, a8, 88
42015367:	24a0a0        	extui	a10, a10, 0, 3
4201536a:	11aab0        	slli	a10, a10, 5
4201536d:	0020c0        	memw
42015370:	152892        	l32i	a9, a8, 84
42015373:	459b90        	extui	a9, a9, 27, 5
42015376:	aa9a      	add.n	a10, a10, a9
    return EFUSE.rd_mac_spi_sys_5.v_dig_dbias20;
42015378:	0020c0        	memw
4201537b:	162882        	l32i	a8, a8, 88
4201537e:	749380        	extui	a9, a8, 3, 8
42015381:	098d      	mov.n	a8, a9
    k_rtc_ldo =  ((k_rtc_ldo & BIT(6)) != 0)? -(k_rtc_ldo & 0x3f): (uint8_t)k_rtc_ldo;
42015383:	fd3c      	movi.n	a13, 63
42015385:	05bdc7        	bgeu	a13, a12, 4201538e <get_rtc_dbias_by_efuse+0x5a>
42015388:	10ccd0        	and	a12, a12, a13
4201538b:	60c0c0        	neg	a12, a12
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
4201538e:	fd3c      	movi.n	a13, 63
42015390:	05bdb7        	bgeu	a13, a11, 42015399 <get_rtc_dbias_by_efuse+0x65>
42015393:	10bbd0        	and	a11, a11, a13
42015396:	60b0b0        	neg	a11, a11
    v_rtc_bias20 =  ((v_rtc_bias20 & BIT(7)) != 0)? -(v_rtc_bias20 & 0x7f): (uint8_t)v_rtc_bias20;
42015399:	086a77        	bbci	a10, 7, 420153a5 <get_rtc_dbias_by_efuse+0x71>
4201539c:	64a0a0        	extui	a10, a10, 0, 7
4201539f:	60a0a0        	neg	a10, a10
420153a2:	000086        	j	420153a8 <get_rtc_dbias_by_efuse+0x74>
420153a5:	74a0a0        	extui	a10, a10, 0, 8
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
420153a8:	056977        	bbci	a9, 7, 420153b1 <get_rtc_dbias_by_efuse+0x7d>
420153ab:	648080        	extui	a8, a8, 0, 7
420153ae:	608080        	neg	a8, a8
    uint32_t v_rtc_dbias20_real_mul10000 = V_RTC_MID_MUL10000 + v_rtc_bias20 * 10000 / 500;
420153b1:	a0aaa0        	addx4	a10, a10, a10
420153b4:	aeb391        	l32r	a9, 42000e80 <_stext+0xe60> (27c5 <UserFrameTotalSize+0x26c5>)
420153b7:	a0aa90        	addx4	a10, a10, a9
    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
420153ba:	a08880        	addx4	a8, a8, a8
420153bd:	aeac91        	l32r	a9, 42000e70 <_stext+0xe50> (2a59 <UserFrameTotalSize+0x2959>)
420153c0:	a08890        	addx4	a8, a8, a9
    signed int k_rtc_ldo_real_mul10000 = K_RTC_MID_MUL10000 + k_rtc_ldo;
420153c3:	c6a092        	movi	a9, 198
420153c6:	cc9a      	add.n	a12, a12, a9
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
420153c8:	d3a092        	movi	a9, 211
420153cb:	bb9a      	add.n	a11, a11, a9
    uint32_t v_dig_nearest_1v15_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
420153cd:	ecc332        	addi	a3, a3, -20
420153d0:	82bb30        	mull	a11, a11, a3
420153d3:	bb8a      	add.n	a11, a11, a8
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
420153d5:	f20c      	movi.n	a2, 15
420153d7:	000506        	j	420153ef <get_rtc_dbias_by_efuse+0xbb>
420153da:	000000        	ill
        v_rtc_nearest_1v15_mul10000 = v_rtc_dbias20_real_mul10000 + k_rtc_ldo_real_mul10000 * (rtc_dbias - 20);
420153dd:	ecc282        	addi	a8, a2, -20
420153e0:	828c80        	mull	a8, a12, a8
420153e3:	88aa      	add.n	a8, a8, a10
        if (v_rtc_nearest_1v15_mul10000 >= v_dig_nearest_1v15_mul10000 - 250) {
420153e5:	06af92        	movi	a9, -250
420153e8:	9b9a      	add.n	a9, a11, a9
420153ea:	06b897        	bgeu	a8, a9, 420153f4 <get_rtc_dbias_by_efuse+0xc0>
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
420153ed:	221b      	addi.n	a2, a2, 1
420153ef:	e81c      	movi.n	a8, 30
420153f1:	e8b827        	bgeu	a8, a2, 420153dd <get_rtc_dbias_by_efuse+0xa9>
}
420153f4:	f01d      	retw.n
	...

420153f8 <rtc_set_stored_dbias>:

static void rtc_set_stored_dbias(void)
{
420153f8:	004136        	entry	a1, 32
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
420153fb:	ae9a81        	l32r	a8, 42000e64 <_stext+0xe44> (60007000 <EFUSE>)
420153fe:	0020c0        	memw
42015401:	1428b2        	l32i	a11, a8, 80
42015404:	25b8b0        	extui	a11, a11, 24, 3
    return EFUSE.rd_sys_part1_data4.blk_version_major;
42015407:	0020c0        	memw
4201540a:	1b2892        	l32i	a9, a8, 108
4201540d:	149090        	extui	a9, a9, 0, 2
    4. save these values for reuse
    */
    uint8_t blk_minor = efuse_ll_get_blk_version_minor();
    uint8_t blk_major = efuse_ll_get_blk_version_major();
    uint8_t pvt_scheme_ver = 0;
    if ( (blk_major <= 1 && blk_minor == 1) || blk_major > 1 || (blk_major == 1 && blk_minor >= 2) ) {
42015410:	180c      	movi.n	a8, 1
42015412:	628890        	lsi	f9, a8, 0x188
42015415:	880b      	addi.n	a8, a8, -1
42015417:	608080        	neg	a8, a8
4201541a:	ab0b      	addi.n	a10, a11, -1
4201541c:	40faa0        	nsau	a10, a10
4201541f:	41a5a0        	srli	a10, a10, 5
42015422:	1288a7        	bany	a8, a10, 42015438 <rtc_set_stored_dbias+0x40>
42015425:	0f29f6        	bgeui	a9, 2, 42015438 <rtc_set_stored_dbias+0x40>
42015428:	990b      	addi.n	a9, a9, -1
4201542a:	40f990        	nsau	a9, a9
4201542d:	419590        	srli	a9, a9, 5
42015430:	180c      	movi.n	a8, 1
42015432:	6288b0        	lsi	f11, a8, 0x188
42015435:	380987        	bnone	a9, a8, 42015471 <rtc_set_stored_dbias+0x79>
        /* PVT supported after blk_ver 1.2 */
        pvt_scheme_ver = 1;
    }

    if (pvt_scheme_ver == 1) {
        uint32_t dig1v3_dbias = get_dig1v3_dbias_by_efuse(pvt_scheme_ver);
42015438:	1a0c      	movi.n	a10, 1
4201543a:	ffe625        	call8	4201529c <get_dig1v3_dbias_by_efuse>
4201543d:	0a7d      	mov.n	a7, a10
        uint32_t dig_dbias = get_dig_dbias_by_efuse(pvt_scheme_ver);
4201543f:	1a0c      	movi.n	a10, 1
42015441:	ffeca5        	call8	4201530c <get_dig_dbias_by_efuse>
        if (dig_dbias != 0) {
42015444:	9aac      	beqz.n	a10, 42015471 <rtc_set_stored_dbias+0x79>
            g_dig_dbias_pvt_240m = MIN(dig1v3_dbias, dig_dbias + 3);
42015446:	ba3b      	addi.n	a11, a10, 3
42015448:	63bb70        	minu	a11, a11, a7
4201544b:	ae8e81        	l32r	a8, 42000e84 <_stext+0xe64> (3fc91f74 <g_dig_dbias_pvt_240m>)
4201544e:	08b9      	s32i.n	a11, a8, 0
            g_dig_dbias_pvt_non_240m = MIN(dig1v3_dbias, dig_dbias + 2);
42015450:	8a2b      	addi.n	a8, a10, 2
42015452:	63a870        	minu	a10, a8, a7
42015455:	ae8c71        	l32r	a7, 42000e88 <_stext+0xe68> (3fc91f6c <g_dig_dbias_pvt_non_240m>)
42015458:	07a9      	s32i.n	a10, a7, 0
            g_rtc_dbias_pvt_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_240m);
4201545a:	01a0a2        	movi	a10, 1
4201545d:	ffed65        	call8	42015334 <get_rtc_dbias_by_efuse>
42015460:	ae8b81        	l32r	a8, 42000e8c <_stext+0xe6c> (3fc91f70 <g_rtc_dbias_pvt_240m>)
42015463:	08a9      	s32i.n	a10, a8, 0
            g_rtc_dbias_pvt_non_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_non_240m);
42015465:	07b8      	l32i.n	a11, a7, 0
42015467:	1a0c      	movi.n	a10, 1
42015469:	ffeca5        	call8	42015334 <get_rtc_dbias_by_efuse>
4201546c:	ae8981        	l32r	a8, 42000e90 <_stext+0xe70> (3fc91f68 <g_rtc_dbias_pvt_non_240m>)
4201546f:	08a9      	s32i.n	a10, a8, 0
            ESP_HW_LOGD(TAG, "not burn core voltage in efuse or burn wrong voltage value in blk version: 0%d\n", pvt_scheme_ver);
        }
    } else {
        ESP_HW_LOGD(TAG, "core voltage not decided in efuse, use default value.");
    }
}
42015471:	f01d      	retw.n
	...

42015474 <calibrate_ocode>:
{
42015474:	006136        	entry	a1, 48
    mspi_timing_change_speed_mode_cache_safe(true);
42015477:	01a0a2        	movi	a10, 1
4201547a:	ae8881        	l32r	a8, 42000e9c <_stext+0xe7c> (403784a4 <mspi_timing_change_speed_mode_cache_safe>)
4201547d:	0008e0        	callx8	a8
    soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
42015480:	ae8881        	l32r	a8, 42000ea0 <_stext+0xe80> (40378a04 <rtc_clk_slow_src_get>)
42015483:	0008e0        	callx8	a8
    if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
42015486:	071a26        	beqi	a10, 1, 42015491 <calibrate_ocode+0x1d>
    } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
42015489:	092a26        	beqi	a10, 2, 42015496 <calibrate_ocode+0x22>
    rtc_cal_sel_t cal_clk = RTC_CAL_RTC_MUX;
4201548c:	0a0c      	movi.n	a10, 0
4201548e:	000186        	j	42015498 <calibrate_ocode+0x24>
        cal_clk = RTC_CAL_32K_XTAL;
42015491:	2a0c      	movi.n	a10, 2
42015493:	000046        	j	42015498 <calibrate_ocode+0x24>
        cal_clk  = RTC_CAL_8MD256;
42015496:	1a0c      	movi.n	a10, 1
    uint32_t slow_clk_period = rtc_clk_cal(cal_clk, 100);
42015498:	64a0b2        	movi	a11, 100
4201549b:	ab2181        	l32r	a8, 42000120 <_stext+0x100> (403792f4 <rtc_clk_cal>)
4201549e:	0008e0        	callx8	a8
    uint64_t max_delay_cycle = rtc_time_us_to_slowclk(max_delay_time_us, slow_clk_period);
420154a1:	0acd      	mov.n	a12, a10
420154a3:	ab64a1        	l32r	a10, 42000234 <_stext+0x214> (2710 <UserFrameTotalSize+0x2610>)
420154a6:	0b0c      	movi.n	a11, 0
420154a8:	ae7f81        	l32r	a8, 42000ea4 <_stext+0xe84> (403793bc <rtc_time_us_to_slowclk>)
420154ab:	0008e0        	callx8	a8
420154ae:	0a4d      	mov.n	a4, a10
420154b0:	0b5d      	mov.n	a5, a11
    uint64_t cycle0 = rtc_time_get();
420154b2:	ac1781        	l32r	a8, 42000510 <_stext+0x4f0> (403793f0 <rtc_time_get>)
420154b5:	0008e0        	callx8	a8
    uint64_t timeout_cycle = cycle0 + max_delay_cycle;
420154b8:	55ba      	add.n	a5, a5, a11
420154ba:	44aa      	add.n	a4, a4, a10
420154bc:	01b4a7        	bgeu	a4, a10, 420154c1 <calibrate_ocode+0x4d>
420154bf:	551b      	addi.n	a5, a5, 1
    rtc_clk_cpu_freq_get_config(&old_config);
420154c1:	01ad      	mov.n	a10, a1
420154c3:	ab2a81        	l32r	a8, 4200016c <_stext+0x14c> (40378b44 <rtc_clk_cpu_freq_get_config>)
420154c6:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_set_xtal();
420154c9:	ae7781        	l32r	a8, 42000ea8 <_stext+0xe88> (40378f10 <rtc_clk_cpu_freq_set_xtal>)
420154cc:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 0);
420154cf:	0f0c      	movi.n	a15, 0
420154d1:	0fed      	mov.n	a14, a15
420154d3:	0fdd      	mov.n	a13, a15
420154d5:	0fcd      	mov.n	a12, a15
420154d7:	1b0c      	movi.n	a11, 1
420154d9:	61a0a2        	movi	a10, 97
420154dc:	abd281        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420154df:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 1);
420154e2:	1f0c      	movi.n	a15, 1
420154e4:	0e0c      	movi.n	a14, 0
420154e6:	0edd      	mov.n	a13, a14
420154e8:	0ecd      	mov.n	a12, a14
420154ea:	0fbd      	mov.n	a11, a15
420154ec:	61a0a2        	movi	a10, 97
420154ef:	abcd81        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420154f2:	0008e0        	callx8	a8
        odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_O_DONE_FLAG);
420154f5:	0e0c      	movi.n	a14, 0
420154f7:	0edd      	mov.n	a13, a14
420154f9:	3c0c      	movi.n	a12, 3
420154fb:	1b0c      	movi.n	a11, 1
420154fd:	61a0a2        	movi	a10, 97
42015500:	ae6b81        	l32r	a8, 42000eac <_stext+0xe8c> (40376784 <regi2c_ctrl_read_reg_mask>)
42015503:	0008e0        	callx8	a8
42015506:	160c      	movi.n	a6, 1
42015508:	836aa0        	moveqz	a6, a10, a10
        bg_odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_BG_O_DONE_FLAG);
4201550b:	3e0c      	movi.n	a14, 3
4201550d:	0edd      	mov.n	a13, a14
4201550f:	0ecd      	mov.n	a12, a14
42015511:	01a0b2        	movi	a11, 1
42015514:	61a0a2        	movi	a10, 97
42015517:	ae6581        	l32r	a8, 42000eac <_stext+0xe8c> (40376784 <regi2c_ctrl_read_reg_mask>)
4201551a:	0008e0        	callx8	a8
4201551d:	170c      	movi.n	a7, 1
4201551f:	837aa0        	moveqz	a7, a10, a10
        cycle1 = rtc_time_get();
42015522:	abfb81        	l32r	a8, 42000510 <_stext+0x4f0> (403793f0 <rtc_time_get>)
42015525:	0008e0        	callx8	a8
        if (odone_flag && bg_odone_flag) {
42015528:	248677        	bany	a6, a7, 42015550 <calibrate_ocode+0xdc>
        if (cycle1 >= timeout_cycle) {
4201552b:	c63b57        	bltu	a11, a5, 420154f5 <calibrate_ocode+0x81>
4201552e:	0295b7        	bne	a5, a11, 42015534 <calibrate_ocode+0xc0>
42015531:	c03a47        	bltu	a10, a4, 420154f5 <calibrate_ocode+0x81>
42015534:	aabe81        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
42015537:	0888      	l32i.n	a8, a8, 0
            ESP_HW_LOGW(TAG, "o_code calibration fail\n");
42015539:	1328b6        	bltui	a8, 2, 42015550 <calibrate_ocode+0xdc>
4201553c:	aac981        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
4201553f:	0008e0        	callx8	a8
42015542:	ae54c1        	l32r	a12, 42000e94 <_stext+0xe74> (3c023728 <_flash_rodata_start+0x3608>)
42015545:	0abd      	mov.n	a11, a10
42015547:	ae54a1        	l32r	a10, 42000e98 <_stext+0xe78> (3c023730 <_flash_rodata_start+0x3610>)
4201554a:	aac681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4201554d:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_set_config(&old_config);
42015550:	01ad      	mov.n	a10, a1
42015552:	ab0981        	l32r	a8, 42000178 <_stext+0x158> (40378ea0 <rtc_clk_cpu_freq_set_config>)
42015555:	0008e0        	callx8	a8
    mspi_timing_change_speed_mode_cache_safe(false);
42015558:	0a0c      	movi.n	a10, 0
4201555a:	ae5081        	l32r	a8, 42000e9c <_stext+0xe7c> (403784a4 <mspi_timing_change_speed_mode_cache_safe>)
4201555d:	0008e0        	callx8	a8
}
42015560:	f01d      	retw.n
	...

42015564 <rtc_init>:
{
42015564:	006136        	entry	a1, 48
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
42015567:	ae5291        	l32r	a9, 42000eb0 <_stext+0xe90> (60008090 <RTCCNTL+0x90>)
4201556a:	0020c0        	memw
4201556d:	0988      	l32i.n	a8, a9, 0
4201556f:	ae51a1        	l32r	a10, 42000eb4 <_stext+0xe94> (fffdffff <_rtc_reserved_end+0x9fedffff>)
42015572:	1088a0        	and	a8, a8, a10
42015575:	0020c0        	memw
42015578:	0989      	s32i.n	a8, a9, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_ISO);
4201557a:	ae4f91        	l32r	a9, 42000eb8 <_stext+0xe98> (60008094 <RTCCNTL+0x94>)
4201557d:	0020c0        	memw
42015580:	0988      	l32i.n	a8, a9, 0
42015582:	aba9a1        	l32r	a10, 42000428 <_stext+0x408> (efffffff <_rtc_reserved_end+0x8fefffff>)
42015585:	1088a0        	and	a8, a8, a10
42015588:	0020c0        	memw
4201558b:	0989      	s32i.n	a8, a9, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_RTC_REG, 0);
4201558d:	0f0c      	movi.n	a15, 0
4201558f:	2e0c      	movi.n	a14, 2
42015591:	0edd      	mov.n	a13, a14
42015593:	dc0c      	movi.n	a12, 13
42015595:	1b0c      	movi.n	a11, 1
42015597:	6da0a2        	movi	a10, 109
4201559a:	aba281        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
4201559d:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_DIG_REG, 0);
420155a0:	0f0c      	movi.n	a15, 0
420155a2:	3e0c      	movi.n	a14, 3
420155a4:	0edd      	mov.n	a13, a14
420155a6:	dc0c      	movi.n	a12, 13
420155a8:	01a0b2        	movi	a11, 1
420155ab:	6da0a2        	movi	a10, 109
420155ae:	ab9d81        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420155b1:	0008e0        	callx8	a8
    CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_PVTMON_PU);
420155b4:	ae4291        	l32r	a9, 42000ebc <_stext+0xe9c> (60008034 <RTCCNTL+0x34>)
420155b7:	0020c0        	memw
420155ba:	0988      	l32i.n	a8, a9, 0
420155bc:	aba0a1        	l32r	a10, 4200043c <_stext+0x41c> (fbffffff <_rtc_reserved_end+0x9befffff>)
420155bf:	1088a0        	and	a8, a8, a10
420155c2:	0020c0        	memw
420155c5:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_PLL_BUF_WAIT, cfg.pll_wait);
420155c7:	ae3e91        	l32r	a9, 42000ec0 <_stext+0xea0> (6000801c <RTCCNTL+0x1c>)
420155ca:	0020c0        	memw
420155cd:	0988      	l32i.n	a8, a9, 0
420155cf:	118880        	slli	a8, a8, 8
420155d2:	418880        	srli	a8, a8, 8
420155d5:	75a020        	extui	a10, a2, 16, 8
420155d8:	01aa80        	slli	a10, a10, 24
420155db:	2088a0        	or	a8, a8, a10
420155de:	0020c0        	memw
420155e1:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, cfg.ck8m_wait);
420155e3:	0020c0        	memw
420155e6:	0988      	l32i.n	a8, a9, 0
420155e8:	ae37a1        	l32r	a10, 42000ec4 <_stext+0xea4> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
420155eb:	1088a0        	and	a8, a8, a10
420155ee:	74a020        	extui	a10, a2, 0, 8
420155f1:	11aaa0        	slli	a10, a10, 6
420155f4:	2088a0        	or	a8, a8, a10
420155f7:	0020c0        	memw
420155fa:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER5_REG, RTC_CNTL_MIN_SLP_VAL, RTC_CNTL_MIN_SLP_VAL_MIN);
420155fc:	ae3391        	l32r	a9, 42000ec8 <_stext+0xea8> (6000802c <RTCCNTL+0x2c>)
420155ff:	0020c0        	memw
42015602:	0988      	l32i.n	a8, a9, 0
42015604:	ae32a1        	l32r	a10, 42000ecc <_stext+0xeac> (ffff00ff <_rtc_reserved_end+0x9fef00ff>)
42015607:	1088a0        	and	a8, a8, a10
4201560a:	00a2a2        	movi	a10, 0x200
4201560d:	2088a0        	or	a8, a8, a10
42015610:	0020c0        	memw
42015613:	0989      	s32i.n	a8, a9, 0
    rtc_init_config_t rtc_init_cfg = RTC_INIT_CONFIG_DEFAULT();
42015615:	ae2e81        	l32r	a8, 42000ed0 <_stext+0xeb0> (3c027bac <__func__$2+0x18>)
42015618:	0898      	l32i.n	a9, a8, 0
4201561a:	18b8      	l32i.n	a11, a8, 4
4201561c:	0199      	s32i.n	a9, a1, 0
4201561e:	28a8      	l32i.n	a10, a8, 8
42015620:	11b9      	s32i.n	a11, a1, 4
42015622:	061882        	l16ui	a8, a8, 12
42015625:	21a9      	s32i.n	a10, a1, 8
42015627:	065182        	s16i	a8, a1, 12
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_POWERUP_TIMER, rtc_init_cfg.wifi_powerup_cycles);
4201562a:	ae2a81        	l32r	a8, 42000ed4 <_stext+0xeb4> (60008024 <RTCCNTL+0x24>)
4201562d:	0020c0        	memw
42015630:	08a8      	l32i.n	a10, a8, 0
42015632:	ae29c1        	l32r	a12, 42000ed8 <_stext+0xeb8> (ffff01ff <_rtc_reserved_end+0x9fef01ff>)
42015635:	10aac0        	and	a10, a10, a12
42015638:	649090        	extui	a9, a9, 0, 7
4201563b:	119970        	slli	a9, a9, 9
4201563e:	209a90        	or	a9, a10, a9
42015641:	0020c0        	memw
42015644:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_WAIT_TIMER, rtc_init_cfg.wifi_wait_cycles);
42015646:	0020c0        	memw
42015649:	0898      	l32i.n	a9, a8, 0
4201564b:	00aee2        	movi	a14, 0xfffffe00
4201564e:	1099e0        	and	a9, a9, a14
42015651:	01a8      	l32i.n	a10, a1, 0
42015653:	84a7a0        	extui	a10, a10, 7, 9
42015656:	2099a0        	or	a9, a9, a10
42015659:	0020c0        	memw
4201565c:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_POWERUP_TIMER, rtc_init_cfg.bt_powerup_cycles);
4201565e:	0020c0        	memw
42015661:	0898      	l32i.n	a9, a8, 0
42015663:	ab1ed1        	l32r	a13, 420002dc <_stext+0x2bc> (1ffffff <UserFrameTotalSize+0x1fffeff>)
42015666:	1099d0        	and	a9, a9, a13
42015669:	01a8      	l32i.n	a10, a1, 0
4201566b:	65a0a0        	extui	a10, a10, 16, 7
4201566e:	01aa70        	slli	a10, a10, 25
42015671:	2099a0        	or	a9, a9, a10
42015674:	0020c0        	memw
42015677:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_WAIT_TIMER, rtc_init_cfg.bt_wait_cycles);
42015679:	0020c0        	memw
4201567c:	0898      	l32i.n	a9, a8, 0
4201567e:	ae17b1        	l32r	a11, 42000edc <_stext+0xebc> (fe00ffff <_rtc_reserved_end+0x9df0ffff>)
42015681:	1099b0        	and	a9, a9, a11
42015684:	01a8      	l32i.n	a10, a1, 0
42015686:	85a7a0        	extui	a10, a10, 23, 9
42015689:	11aa00        	slli	a10, a10, 16
4201568c:	2099a0        	or	a9, a9, a10
4201568f:	0020c0        	memw
42015692:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_POWERUP_TIMER, rtc_init_cfg.cpu_top_powerup_cycles);
42015694:	ae1381        	l32r	a8, 42000ee0 <_stext+0xec0> (60008030 <RTCCNTL+0x30>)
42015697:	0020c0        	memw
4201569a:	0898      	l32i.n	a9, a8, 0
4201569c:	1099c0        	and	a9, a9, a12
4201569f:	11a8      	l32i.n	a10, a1, 4
420156a1:	65a0a0        	extui	a10, a10, 16, 7
420156a4:	11aa70        	slli	a10, a10, 9
420156a7:	2099a0        	or	a9, a9, a10
420156aa:	0020c0        	memw
420156ad:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_WAIT_TIMER, rtc_init_cfg.cpu_top_wait_cycles);
420156af:	0020c0        	memw
420156b2:	0898      	l32i.n	a9, a8, 0
420156b4:	1099e0        	and	a9, a9, a14
420156b7:	11a8      	l32i.n	a10, a1, 4
420156b9:	85a7a0        	extui	a10, a10, 23, 9
420156bc:	2099a0        	or	a9, a9, a10
420156bf:	0020c0        	memw
420156c2:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_POWERUP_TIMER, rtc_init_cfg.rtc_powerup_cycles);
420156c4:	ae0891        	l32r	a9, 42000ee4 <_stext+0xec4> (60008028 <RTCCNTL+0x28>)
420156c7:	0020c0        	memw
420156ca:	09a8      	l32i.n	a10, a9, 0
420156cc:	10aac0        	and	a10, a10, a12
420156cf:	11c8      	l32i.n	a12, a1, 4
420156d1:	64c0c0        	extui	a12, a12, 0, 7
420156d4:	11cc70        	slli	a12, a12, 9
420156d7:	20aac0        	or	a10, a10, a12
420156da:	0020c0        	memw
420156dd:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_WAIT_TIMER, rtc_init_cfg.rtc_wait_cycles);
420156df:	0020c0        	memw
420156e2:	09a8      	l32i.n	a10, a9, 0
420156e4:	10aae0        	and	a10, a10, a14
420156e7:	11c8      	l32i.n	a12, a1, 4
420156e9:	84c7c0        	extui	a12, a12, 7, 9
420156ec:	20aac0        	or	a10, a10, a12
420156ef:	0020c0        	memw
420156f2:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_POWERUP_TIMER, rtc_init_cfg.dg_wrap_powerup_cycles);
420156f4:	0020c0        	memw
420156f7:	09a8      	l32i.n	a10, a9, 0
420156f9:	10aad0        	and	a10, a10, a13
420156fc:	21c8      	l32i.n	a12, a1, 8
420156fe:	01cc70        	slli	a12, a12, 25
42015701:	20aac0        	or	a10, a10, a12
42015704:	0020c0        	memw
42015707:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_WAIT_TIMER, rtc_init_cfg.dg_wrap_wait_cycles);
42015709:	0020c0        	memw
4201570c:	09a8      	l32i.n	a10, a9, 0
4201570e:	10aab0        	and	a10, a10, a11
42015711:	21c8      	l32i.n	a12, a1, 8
42015713:	84c7c0        	extui	a12, a12, 7, 9
42015716:	11cc00        	slli	a12, a12, 16
42015719:	20aac0        	or	a10, a10, a12
4201571c:	0020c0        	memw
4201571f:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_POWERUP_TIMER, rtc_init_cfg.dg_peri_powerup_cycles);
42015721:	0020c0        	memw
42015724:	0898      	l32i.n	a9, a8, 0
42015726:	1099d0        	and	a9, a9, a13
42015729:	21a8      	l32i.n	a10, a1, 8
4201572b:	65a0a0        	extui	a10, a10, 16, 7
4201572e:	01aa70        	slli	a10, a10, 25
42015731:	2099a0        	or	a9, a9, a10
42015734:	0020c0        	memw
42015737:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_WAIT_TIMER, rtc_init_cfg.dg_peri_wait_cycles);
42015739:	0020c0        	memw
4201573c:	0898      	l32i.n	a9, a8, 0
4201573e:	1099b0        	and	a9, a9, a11
42015741:	21a8      	l32i.n	a10, a1, 8
42015743:	85a7a0        	extui	a10, a10, 23, 9
42015746:	11aa00        	slli	a10, a10, 16
42015749:	2099a0        	or	a9, a9, a10
4201574c:	0020c0        	memw
4201574f:	0899      	s32i.n	a9, a8, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG_SLEEP, RTC_CNTL_DBIAS_1V10);
42015751:	7f1c      	movi.n	a15, 23
42015753:	0e0c      	movi.n	a14, 0
42015755:	4d0c      	movi.n	a13, 4
42015757:	5c0c      	movi.n	a12, 5
42015759:	1b0c      	movi.n	a11, 1
4201575b:	6da0a2        	movi	a10, 109
4201575e:	ab3181        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42015761:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, RTC_CNTL_DBIAS_1V10);
42015764:	7f1c      	movi.n	a15, 23
42015766:	0e0c      	movi.n	a14, 0
42015768:	4d0c      	movi.n	a13, 4
4201576a:	0dcd      	mov.n	a12, a13
4201576c:	1b0c      	movi.n	a11, 1
4201576e:	6da0a2        	movi	a10, 109
42015771:	ab2c81        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
42015774:	0008e0        	callx8	a8
    REG_SET_FIELD(RTC_CNTL_TIMER2_REG, RTC_CNTL_ULPCP_TOUCH_START_WAIT, RTC_CNTL_ULPCP_TOUCH_START_WAIT_DEFAULT);
42015777:	addc91        	l32r	a9, 42000ee8 <_stext+0xec8> (60008020 <RTCCNTL+0x20>)
4201577a:	0020c0        	memw
4201577d:	0988      	l32i.n	a8, a9, 0
4201577f:	addba1        	l32r	a10, 42000eec <_stext+0xecc> (ff007fff <_rtc_reserved_end+0x9ef07fff>)
42015782:	1088a0        	and	a8, a8, a10
42015785:	ada7a1        	l32r	a10, 42000e24 <_stext+0xe04> (80000 <UserFrameTotalSize+0x7ff00>)
42015788:	2088a0        	or	a8, a8, a10
4201578b:	0020c0        	memw
4201578e:	0989      	s32i.n	a8, a9, 0
    if (cfg.cali_ocode) {
42015790:	1872e7        	bbci	a2, 30, 420157ac <rtc_init+0x248>
42015793:	adb481        	l32r	a8, 42000e64 <_stext+0xe44> (60007000 <EFUSE>)
42015796:	0020c0        	memw
42015799:	1b28a2        	l32i	a10, a8, 108
4201579c:	14a0a0        	extui	a10, a10, 0, 2
        if (ocode_efuse_cali) {
4201579f:	061a66        	bnei	a10, 1, 420157a9 <rtc_init+0x245>
            set_ocode_by_efuse(blk_ver_major);
420157a2:	ffaae5        	call8	42015250 <set_ocode_by_efuse>
420157a5:	0000c6        	j	420157ac <rtc_init+0x248>
420157a8:	cca500        	lsi	f0, a5, 0x330
            calibrate_ocode();
420157ab:	ff          	.byte	0xff
    rtc_set_stored_dbias();
420157ac:	ffc4a5        	call8	420153f8 <rtc_set_stored_dbias>
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
420157af:	adb881        	l32r	a8, 42000e90 <_stext+0xe70> (3fc91f68 <g_rtc_dbias_pvt_non_240m>)
420157b2:	0008f2        	l8ui	a15, a8, 0
420157b5:	0e0c      	movi.n	a14, 0
420157b7:	4d0c      	movi.n	a13, 4
420157b9:	0dcd      	mov.n	a12, a13
420157bb:	1b0c      	movi.n	a11, 1
420157bd:	6da0a2        	movi	a10, 109
420157c0:	ab1981        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420157c3:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
420157c6:	adb081        	l32r	a8, 42000e88 <_stext+0xe68> (3fc91f6c <g_dig_dbias_pvt_non_240m>)
420157c9:	0008f2        	l8ui	a15, a8, 0
420157cc:	0e0c      	movi.n	a14, 0
420157ce:	4d0c      	movi.n	a13, 4
420157d0:	6c0c      	movi.n	a12, 6
420157d2:	1b0c      	movi.n	a11, 1
420157d4:	6da0a2        	movi	a10, 109
420157d7:	ab1381        	l32r	a8, 42000424 <_stext+0x404> (4037682c <regi2c_ctrl_write_reg_mask>)
420157da:	0008e0        	callx8	a8
    if (cfg.clkctl_init) {
420157dd:	5b7287        	bbci	a2, 24, 4201583c <rtc_init+0x2d8>
        CLEAR_PERI_REG_MASK(EXTMEM_CACHE_MMU_POWER_CTRL_REG, EXTMEM_CACHE_MMU_MEM_FORCE_ON);
420157e0:	adc4a1        	l32r	a10, 42000ef0 <_stext+0xed0> (600c412c <SYSTEM+0x412c>)
420157e3:	0020c0        	memw
420157e6:	0a98      	l32i.n	a9, a10, 0
420157e8:	e87c      	movi.n	a8, -2
420157ea:	109980        	and	a9, a9, a8
420157ed:	0020c0        	memw
420157f0:	0a99      	s32i.n	a9, a10, 0
        REG_WRITE(SYSCON_CLKGATE_FORCE_ON_REG, 0);
420157f2:	adc091        	l32r	a9, 42000ef4 <_stext+0xed4> (600260a8 <SYSCON+0xa8>)
420157f5:	0a0c      	movi.n	a10, 0
420157f7:	0020c0        	memw
420157fa:	09a9      	s32i.n	a10, a9, 0
        CLEAR_PERI_REG_MASK(EXTMEM_DCACHE_TAG_POWER_CTRL_REG, EXTMEM_DCACHE_TAG_MEM_FORCE_ON);
420157fc:	adbfa1        	l32r	a10, 42000ef8 <_stext+0xed8> (600c4008 <SYSTEM+0x4008>)
420157ff:	0020c0        	memw
42015802:	0a98      	l32i.n	a9, a10, 0
42015804:	109980        	and	a9, a9, a8
42015807:	0020c0        	memw
4201580a:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(EXTMEM_ICACHE_TAG_POWER_CTRL_REG, EXTMEM_ICACHE_TAG_MEM_FORCE_ON);
4201580c:	adbca1        	l32r	a10, 42000efc <_stext+0xedc> (600c4068 <SYSTEM+0x4068>)
4201580f:	0020c0        	memw
42015812:	0a98      	l32i.n	a9, a10, 0
42015814:	109980        	and	a9, a9, a8
42015817:	0020c0        	memw
4201581a:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(0), SPI_MEM_CLK_EN);
4201581c:	adb9a1        	l32r	a10, 42000f00 <_stext+0xee0> (600030e8 <SPIMEM0+0xe8>)
4201581f:	0020c0        	memw
42015822:	0a98      	l32i.n	a9, a10, 0
42015824:	109980        	and	a9, a9, a8
42015827:	0020c0        	memw
4201582a:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(1), SPI_MEM_CLK_EN);
4201582c:	adb6a1        	l32r	a10, 42000f04 <_stext+0xee4> (600020e8 <SPIMEM1+0xe8>)
4201582f:	0020c0        	memw
42015832:	0a98      	l32i.n	a9, a10, 0
42015834:	108980        	and	a8, a9, a8
42015837:	0020c0        	memw
4201583a:	0a89      	s32i.n	a8, a10, 0
    if (cfg.pwrctl_init) {
4201583c:	02f297        	bbsi	a2, 25, 42015842 <rtc_init+0x2de>
4201583f:	00a206        	j	42015acb <rtc_init+0x567>
        CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_CK8M_FORCE_PU);
42015842:	adb191        	l32r	a9, 42000f08 <_stext+0xee8> (60008074 <RTCCNTL+0x74>)
42015845:	0020c0        	memw
42015848:	0988      	l32i.n	a8, a9, 0
4201584a:	aafca1        	l32r	a10, 4200043c <_stext+0x41c> (fbffffff <_rtc_reserved_end+0x9befffff>)
4201584d:	1088a0        	and	a8, a8, a10
42015850:	0020c0        	memw
42015853:	0989      	s32i.n	a8, a9, 0
        if (!(cfg.xtal_fpu | cfg.bbpll_fpu)) {
42015855:	058b20        	extui	a8, a2, 27, 1
42015858:	059c20        	extui	a9, a2, 28, 1
4201585b:	208890        	or	a8, a8, a9
4201585e:	68dc      	bnez.n	a8, 42015878 <rtc_init+0x314>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
42015860:	adab91        	l32r	a9, 42000f0c <_stext+0xeec> (60008000 <RTCCNTL>)
42015863:	0020c0        	memw
42015866:	0988      	l32i.n	a8, a9, 0
42015868:	adaaa1        	l32r	a10, 42000f10 <_stext+0xef0> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4201586b:	1088a0        	and	a8, a8, a10
4201586e:	0020c0        	memw
42015871:	0989      	s32i.n	a8, a9, 0
42015873:	000506        	j	4201588b <rtc_init+0x327>
42015876:	910000        	srl	a0, a0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
42015879:	c0ada5        	call8	41fd6354 <_coredump_iram_end+0x1c54454>
4201587c:	880020        	lsi	f2, a0, 0x220
4201587f:	a109      	s32i.n	a0, a1, 40
42015881:	a0abe1        	l32r	a14, 41ffdb30 <_coredump_iram_end+0x1c7bc30>
42015884:	2088      	l32i.n	a8, a0, 8
42015886:	0020c0        	memw
42015889:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
4201588b:	ad8c91        	l32r	a9, 42000ebc <_stext+0xe9c> (60008034 <RTCCNTL+0x34>)
4201588e:	0020c0        	memw
42015891:	0988      	l32i.n	a8, a9, 0
42015893:	ada0a1        	l32r	a10, 42000f14 <_stext+0xef4> (fffbffff <_rtc_reserved_end+0x9febffff>)
42015896:	1088a0        	and	a8, a8, a10
42015899:	0020c0        	memw
4201589c:	0989      	s32i.n	a8, a9, 0
        if (!cfg.bbpll_fpu) {
4201589e:	36f2c7        	bbsi	a2, 28, 420158d8 <rtc_init+0x374>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
420158a1:	ad9a81        	l32r	a8, 42000f0c <_stext+0xeec> (60008000 <RTCCNTL>)
420158a4:	0020c0        	memw
420158a7:	0898      	l32i.n	a9, a8, 0
420158a9:	ad9ba1        	l32r	a10, 42000f18 <_stext+0xef8> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
420158ac:	1099a0        	and	a9, a9, a10
420158af:	0020c0        	memw
420158b2:	0899      	s32i.n	a9, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
420158b4:	0020c0        	memw
420158b7:	0898      	l32i.n	a9, a8, 0
420158b9:	ffada2        	movi	a10, 0xfffffdff
420158bc:	1099a0        	and	a9, a9, a10
420158bf:	0020c0        	memw
420158c2:	0899      	s32i.n	a9, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
420158c4:	0020c0        	memw
420158c7:	0898      	l32i.n	a9, a8, 0
420158c9:	7fafa2        	movi	a10, -129
420158cc:	1099a0        	and	a9, a9, a10
420158cf:	0020c0        	memw
420158d2:	0899      	s32i.n	a9, a8, 0
420158d4:	000cc6        	j	4201590b <rtc_init+0x3a7>
420158d7:	8d8100        	lsi	f0, a1, 0x234
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
420158da:	c0ad      	lsi	f10, a0, 0
420158dc:	980020        	lsi	f2, a0, 0x260
420158df:	a108      	l32i.n	a0, a1, 40
420158e1:	ab2c      	movi.n	a11, 42
420158e3:	2099a0        	or	a9, a9, a10
420158e6:	0020c0        	memw
420158e9:	0899      	s32i.n	a9, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
420158eb:	0020c0        	memw
420158ee:	0898      	l32i.n	a9, a8, 0
420158f0:	00a2a2        	movi	a10, 0x200
420158f3:	2099a0        	or	a9, a9, a10
420158f6:	0020c0        	memw
420158f9:	0899      	s32i.n	a9, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
420158fb:	0020c0        	memw
420158fe:	0898      	l32i.n	a9, a8, 0
42015900:	80a0a2        	movi	a10, 128
42015903:	2099a0        	or	a9, a9, a10
42015906:	0020c0        	memw
42015909:	0899      	s32i.n	a9, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
4201590b:	ad8491        	l32r	a9, 42000f1c <_stext+0xefc> (60008088 <RTCCNTL+0x88>)
4201590e:	0020c0        	memw
42015911:	0988      	l32i.n	a8, a9, 0
42015913:	ad83a1        	l32r	a10, 42000f20 <_stext+0xf00> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
42015916:	1088a0        	and	a8, a8, a10
42015919:	0020c0        	memw
4201591c:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_REGULATOR_FORCE_PU);
4201591e:	ad81a1        	l32r	a10, 42000f24 <_stext+0xf04> (60008084 <RTCCNTL+0x84>)
42015921:	0020c0        	memw
42015924:	0a88      	l32i.n	a8, a10, 0
42015926:	888a      	add.n	a8, a8, a8
42015928:	418180        	srli	a8, a8, 1
4201592b:	0020c0        	memw
4201592e:	0a89      	s32i.n	a8, a10, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PU);
42015930:	0020c0        	memw
42015933:	0a88      	l32i.n	a8, a10, 0
42015935:	aabfb1        	l32r	a11, 42000434 <_stext+0x414> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42015938:	1088b0        	and	a8, a8, a11
4201593b:	0020c0        	memw
4201593e:	0a89      	s32i.n	a8, a10, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_NOISO | RTC_CNTL_FASTMEM_FORCE_NOISO);
42015940:	0020c0        	memw
42015943:	0988      	l32i.n	a8, a9, 0
42015945:	aa7c      	movi.n	a10, -6
42015947:	1088a0        	and	a8, a8, a10
4201594a:	0020c0        	memw
4201594d:	0989      	s32i.n	a8, a9, 0
        if (cfg.rtc_dboost_fpd) {
4201594f:	1572a7        	bbci	a2, 26, 42015968 <rtc_init+0x404>
            SET_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
42015952:	ad7491        	l32r	a9, 42000f24 <_stext+0xf04> (60008084 <RTCCNTL+0x84>)
42015955:	0020c0        	memw
42015958:	0988      	l32i.n	a8, a9, 0
4201595a:	ad2ba1        	l32r	a10, 42000e08 <_stext+0xde8> (10000000 <UserFrameTotalSize+0xfffff00>)
4201595d:	2088a0        	or	a8, a8, a10
42015960:	0020c0        	memw
42015963:	0989      	s32i.n	a8, a9, 0
42015965:	000486        	j	4201597b <rtc_init+0x417>
            CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
42015968:	ad6f91        	l32r	a9, 42000f24 <_stext+0xf04> (60008084 <RTCCNTL+0x84>)
4201596b:	0020c0        	memw
4201596e:	0988      	l32i.n	a8, a9, 0
42015970:	aaaea1        	l32r	a10, 42000428 <_stext+0x408> (efffffff <_rtc_reserved_end+0x8fefffff>)
42015973:	1088a0        	and	a8, a8, a10
42015976:	0020c0        	memw
42015979:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
4201597b:	ad5091        	l32r	a9, 42000ebc <_stext+0xe9c> (60008034 <RTCCNTL+0x34>)
4201597e:	0020c0        	memw
42015981:	0988      	l32i.n	a8, a9, 0
42015983:	ad6471        	l32r	a7, 42000f14 <_stext+0xef4> (fffbffff <_rtc_reserved_end+0x9febffff>)
42015986:	108870        	and	a8, a8, a7
42015989:	0020c0        	memw
4201598c:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(SYSTEM_MEM_PD_MASK_REG, SYSTEM_LSLP_MEM_PD_MASK);
4201598e:	ad6691        	l32r	a9, 42000f28 <_stext+0xf08> (600c0014 <SYSTEM+0x14>)
42015991:	0020c0        	memw
42015994:	0988      	l32i.n	a8, a9, 0
42015996:	ea7c      	movi.n	a10, -2
42015998:	1088a0        	and	a8, a8, a10
4201599b:	0020c0        	memw
4201599e:	0989      	s32i.n	a8, a9, 0
        rtc_sleep_pu(pu_cfg);
420159a0:	0a0c      	movi.n	a10, 0
420159a2:	ad6a81        	l32r	a8, 42000f4c <_stext+0xf2c> (40378f1c <rtc_sleep_pu>)
420159a5:	0008e0        	callx8	a8
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_WRAP_FORCE_PU);
420159a8:	ad4281        	l32r	a8, 42000eb0 <_stext+0xe90> (60008090 <RTCCNTL+0x90>)
420159ab:	0020c0        	memw
420159ae:	0898      	l32i.n	a9, a8, 0
420159b0:	ad5fa1        	l32r	a10, 42000f2c <_stext+0xf0c> (ffefffff <_rtc_reserved_end+0x9fdfffff>)
420159b3:	1099a0        	and	a9, a9, a10
420159b6:	0020c0        	memw
420159b9:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_WRAP_FORCE_NOISO | RTC_CNTL_DG_WRAP_FORCE_ISO);
420159bb:	ad3f91        	l32r	a9, 42000eb8 <_stext+0xe98> (60008094 <RTCCNTL+0x94>)
420159be:	0020c0        	memw
420159c1:	09a8      	l32i.n	a10, a9, 0
420159c3:	11aae0        	slli	a10, a10, 2
420159c6:	41a2a0        	srli	a10, a10, 2
420159c9:	0020c0        	memw
420159cc:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_NOISO | RTC_CNTL_WIFI_FORCE_ISO);
420159ce:	0020c0        	memw
420159d1:	09a8      	l32i.n	a10, a9, 0
420159d3:	ad57b1        	l32r	a11, 42000f30 <_stext+0xf10> (cfffffff <_rtc_reserved_end+0x6fefffff>)
420159d6:	10aab0        	and	a10, a10, a11
420159d9:	0020c0        	memw
420159dc:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PU);
420159de:	0020c0        	memw
420159e1:	08a8      	l32i.n	a10, a8, 0
420159e3:	10aa70        	and	a10, a10, a7
420159e6:	0020c0        	memw
420159e9:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_BT_FORCE_NOISO | RTC_CNTL_BT_FORCE_ISO);
420159eb:	0020c0        	memw
420159ee:	09a8      	l32i.n	a10, a9, 0
420159f0:	ad51b1        	l32r	a11, 42000f34 <_stext+0xf14> (ff3fffff <_rtc_reserved_end+0x9f2fffff>)
420159f3:	10aab0        	and	a10, a10, a11
420159f6:	0020c0        	memw
420159f9:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_BT_FORCE_PU);
420159fb:	0020c0        	memw
420159fe:	08a8      	l32i.n	a10, a8, 0
42015a00:	ad4eb1        	l32r	a11, 42000f38 <_stext+0xf18> (ffffefff <_rtc_reserved_end+0x9fefefff>)
42015a03:	10aab0        	and	a10, a10, a11
42015a06:	0020c0        	memw
42015a09:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_CPU_TOP_FORCE_NOISO | RTC_CNTL_CPU_TOP_FORCE_ISO);
42015a0b:	0020c0        	memw
42015a0e:	09a8      	l32i.n	a10, a9, 0
42015a10:	ad4bb1        	l32r	a11, 42000f3c <_stext+0xf1c> (f3ffffff <_rtc_reserved_end+0x93efffff>)
42015a13:	10aab0        	and	a10, a10, a11
42015a16:	0020c0        	memw
42015a19:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_CPU_TOP_FORCE_PU);
42015a1b:	0020c0        	memw
42015a1e:	08a8      	l32i.n	a10, a8, 0
42015a20:	ad48b1        	l32r	a11, 42000f40 <_stext+0xf20> (ffbfffff <_rtc_reserved_end+0x9fafffff>)
42015a23:	10aab0        	and	a10, a10, a11
42015a26:	0020c0        	memw
42015a29:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PERI_FORCE_NOISO | RTC_CNTL_DG_PERI_FORCE_ISO);
42015a2b:	0020c0        	memw
42015a2e:	09a8      	l32i.n	a10, a9, 0
42015a30:	ad45b1        	l32r	a11, 42000f44 <_stext+0xf24> (fcffffff <_rtc_reserved_end+0x9cefffff>)
42015a33:	10aab0        	and	a10, a10, a11
42015a36:	0020c0        	memw
42015a39:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_PERI_FORCE_PU);
42015a3b:	0020c0        	memw
42015a3e:	0898      	l32i.n	a9, a8, 0
42015a40:	a9faa1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42015a43:	1099a0        	and	a9, a9, a10
42015a46:	0020c0        	memw
42015a49:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_NOISO);
42015a4b:	ad3481        	l32r	a8, 42000f1c <_stext+0xefc> (60008088 <RTCCNTL+0x88>)
42015a4e:	0020c0        	memw
42015a51:	0898      	l32i.n	a9, a8, 0
42015a53:	dfafa2        	movi	a10, -33
42015a56:	1099a0        	and	a9, a9, a10
42015a59:	0020c0        	memw
42015a5c:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_ISO);
42015a5e:	0020c0        	memw
42015a61:	0898      	l32i.n	a9, a8, 0
42015a63:	fa6c      	movi.n	a10, -17
42015a65:	1099a0        	and	a9, a9, a10
42015a68:	0020c0        	memw
42015a6b:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
42015a6d:	0020c0        	memw
42015a70:	0898      	l32i.n	a9, a8, 0
42015a72:	ad2ba1        	l32r	a10, 42000f20 <_stext+0xf00> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
42015a75:	1099a0        	and	a9, a9, a10
42015a78:	0020c0        	memw
42015a7b:	0899      	s32i.n	a9, a8, 0
        if (cfg.cpu_waiti_clk_gate) {
42015a7d:	1472d7        	bbci	a2, 29, 42015a95 <rtc_init+0x531>
            CLEAR_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42015a80:	ad3291        	l32r	a9, 42000f48 <_stext+0xf28> (600c0010 <SYSTEM+0x10>)
42015a83:	0020c0        	memw
42015a86:	0988      	l32i.n	a8, a9, 0
42015a88:	7a7c      	movi.n	a10, -9
42015a8a:	1088a0        	and	a8, a8, a10
42015a8d:	0020c0        	memw
42015a90:	0989      	s32i.n	a8, a9, 0
42015a92:	000446        	j	42015aa7 <rtc_init+0x543>
            SET_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42015a95:	ad2c91        	l32r	a9, 42000f48 <_stext+0xf28> (600c0010 <SYSTEM+0x10>)
42015a98:	0020c0        	memw
42015a9b:	0988      	l32i.n	a8, a9, 0
42015a9d:	8a0c      	movi.n	a10, 8
42015a9f:	2088a0        	or	a8, a8, a10
42015aa2:	0020c0        	memw
42015aa5:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_UNHOLD);
42015aa7:	ad0481        	l32r	a8, 42000eb8 <_stext+0xe98> (60008094 <RTCCNTL+0x94>)
42015aaa:	0020c0        	memw
42015aad:	0898      	l32i.n	a9, a8, 0
42015aaf:	a9dea1        	l32r	a10, 42000228 <_stext+0x208> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42015ab2:	1099a0        	and	a9, a9, a10
42015ab5:	0020c0        	memw
42015ab8:	0899      	s32i.n	a9, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_NOISO);
42015aba:	0020c0        	memw
42015abd:	0898      	l32i.n	a9, a8, 0
42015abf:	ad1ea1        	l32r	a10, 42000f38 <_stext+0xf18> (ffffefff <_rtc_reserved_end+0x9fefefff>)
42015ac2:	1099a0        	and	a9, a9, a10
42015ac5:	0020c0        	memw
42015ac8:	006892        	s32i	a9, a8, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_ISO);
42015acb:	acfb91        	l32r	a9, 42000eb8 <_stext+0xe98> (60008094 <RTCCNTL+0x94>)
42015ace:	0020c0        	memw
42015ad1:	0988      	l32i.n	a8, a9, 0
42015ad3:	accda1        	l32r	a10, 42000e08 <_stext+0xde8> (10000000 <UserFrameTotalSize+0xfffff00>)
42015ad6:	2088a0        	or	a8, a8, a10
42015ad9:	0020c0        	memw
42015adc:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
42015ade:	acf491        	l32r	a9, 42000eb0 <_stext+0xe90> (60008090 <RTCCNTL+0x90>)
42015ae1:	0020c0        	memw
42015ae4:	0988      	l32i.n	a8, a9, 0
42015ae6:	accca1        	l32r	a10, 42000e18 <_stext+0xdf8> (20000 <UserFrameTotalSize+0x1ff00>)
42015ae9:	2088a0        	or	a8, a8, a10
42015aec:	0020c0        	memw
42015aef:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
42015af1:	aaa381        	l32r	a8, 42000580 <_stext+0x560> (60008040 <RTCCNTL+0x40>)
42015af4:	090c      	movi.n	a9, 0
42015af6:	0020c0        	memw
42015af9:	0899      	s32i.n	a9, a8, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
42015afb:	aaa281        	l32r	a8, 42000584 <_stext+0x564> (6000804c <RTCCNTL+0x4c>)
42015afe:	f97c      	movi.n	a9, -1
42015b00:	0020c0        	memw
42015b03:	0899      	s32i.n	a9, a8, 0
    sar_periph_ctrl_init();
42015b05:	000065        	call8	42015b0c <sar_periph_ctrl_init>
}
42015b08:	f01d      	retw.n
	...

42015b0c <sar_periph_ctrl_init>:
static const char *TAG = "sar_periph_ctrl";
extern portMUX_TYPE rtc_spinlock;


void sar_periph_ctrl_init(void)
{
42015b0c:	004136        	entry	a1, 32
 */
__attribute__((always_inline))
static inline void sar_ctrl_ll_set_power_mode(sar_ctrl_ll_power_t mode)
{
    if (mode == SAR_CTRL_LL_POWER_FSM) {
        SENS.sar_peri_clk_gate_conf.saradc_clk_en = 1;
42015b0f:	ad1081        	l32r	a8, 42000f50 <_stext+0xf30> (60008800 <SENS>)
42015b12:	0020c0        	memw
42015b15:	4128a2        	l32i	a10, a8, 0x104
42015b18:	a98691        	l32r	a9, 42000130 <_stext+0x110> (40000000 <_heap_end>)
42015b1b:	209a90        	or	a9, a10, a9
42015b1e:	0020c0        	memw
42015b21:	416892        	s32i	a9, a8, 0x104
        SENS.sar_power_xpd_sar.force_xpd_sar = 0x0;
42015b24:	0020c0        	memw
42015b27:	f8a8      	l32i.n	a10, a8, 60
42015b29:	ad0a91        	l32r	a9, 42000f54 <_stext+0xf34> (9fffffff <_rtc_reserved_end+0x3fefffff>)
42015b2c:	109a90        	and	a9, a10, a9
42015b2f:	0020c0        	memw
42015b32:	f899      	s32i.n	a9, a8, 60
    //Put SAR control mux to FSM state
    sar_ctrl_ll_set_power_mode(SAR_CTRL_LL_POWER_FSM);

    //Add other periph power control initialisation here
}
42015b34:	f01d      	retw.n
	...

42015b38 <other_cpu_startup_idle_hook_cb>:
static const char* MAIN_TAG = "main_task";

#if !CONFIG_FREERTOS_UNICORE
static volatile bool s_other_cpu_startup_done = false;
static bool other_cpu_startup_idle_hook_cb(void)
{
42015b38:	004136        	entry	a1, 32
    s_other_cpu_startup_done = true;
42015b3b:	ad0781        	l32r	a8, 42000f58 <_stext+0xf38> (3fc94b0c <s_other_cpu_startup_done>)
42015b3e:	190c      	movi.n	a9, 1
42015b40:	0020c0        	memw
42015b43:	004892        	s8i	a9, a8, 0
    return true;
}
42015b46:	120c      	movi.n	a2, 1
42015b48:	f01d      	retw.n
	...

42015b4c <main_task>:
#endif

static void main_task(void* args)
{
42015b4c:	004136        	entry	a1, 32
    ESP_LOGI(MAIN_TAG, "Started on CPU%d", (int)xPortGetCoreID());
42015b4f:	a94481        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42015b52:	0008e0        	callx8	a8
42015b55:	0add      	mov.n	a13, a10
    asm volatile (
42015b57:	03ebf0        	rsr.prid	a15
42015b5a:	04fdf0        	extui	a15, a15, 13, 1
42015b5d:	acffb1        	l32r	a11, 42000f5c <_stext+0xf3c> (3c0240dc <_flash_rodata_start+0x3fbc>)
42015b60:	0bed      	mov.n	a14, a11
42015b62:	acffc1        	l32r	a12, 42000f60 <_stext+0xf40> (3c0240e8 <_flash_rodata_start+0x3fc8>)
42015b65:	3a0c      	movi.n	a10, 3
42015b67:	a94b81        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42015b6a:	0008e0        	callx8	a8
42015b6d:	03ebb0        	rsr.prid	a11
42015b70:	04bdb0        	extui	a11, a11, 13, 1
#if !CONFIG_FREERTOS_UNICORE
    // Wait for FreeRTOS initialization to finish on other core, before replacing its startup stack
    esp_register_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42015b73:	40fbb0        	nsau	a11, a11
42015b76:	41b5b0        	srli	a11, a11, 5
42015b79:	acfaa1        	l32r	a10, 42000f64 <_stext+0xf44> (42015b38 <other_cpu_startup_idle_hook_cb>)
42015b7c:	ecb325        	call8	420026b0 <esp_register_freertos_idle_hook_for_cpu>
    while (!s_other_cpu_startup_done) {
42015b7f:	acf681        	l32r	a8, 42000f58 <_stext+0xf38> (3fc94b0c <s_other_cpu_startup_done>)
42015b82:	0020c0        	memw
42015b85:	000882        	l8ui	a8, a8, 0
42015b88:	748080        	extui	a8, a8, 0, 8
42015b8b:	ff0816        	beqz	a8, 42015b7f <main_task+0x33>
42015b8e:	03ebb0        	rsr.prid	a11
42015b91:	04bdb0        	extui	a11, a11, 13, 1
        ;
    }
    esp_deregister_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42015b94:	40fbb0        	nsau	a11, a11
42015b97:	41b5b0        	srli	a11, a11, 5
42015b9a:	acf2a1        	l32r	a10, 42000f64 <_stext+0xf44> (42015b38 <other_cpu_startup_idle_hook_cb>)
42015b9d:	ecbde5        	call8	4200277c <esp_deregister_freertos_idle_hook_for_cpu>
#endif

    // [refactor-todo] check if there is a way to move the following block to esp_system startup
    heap_caps_enable_nonos_stack_heaps();
42015ba0:	ed0425        	call8	42002be4 <heap_caps_enable_nonos_stack_heaps>

    /*
    Note: Be careful when changing the "Calling app_main()" log below as multiple pytest scripts expect this log as a
    start-of-application marker.
    */
    ESP_LOGI(MAIN_TAG, "Calling app_main()");
42015ba3:	a92f81        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42015ba6:	0008e0        	callx8	a8
42015ba9:	acec71        	l32r	a7, 42000f5c <_stext+0xf3c> (3c0240dc <_flash_rodata_start+0x3fbc>)
42015bac:	07ed      	mov.n	a14, a7
42015bae:	0add      	mov.n	a13, a10
42015bb0:	aceec1        	l32r	a12, 42000f68 <_stext+0xf48> (3c024108 <_flash_rodata_start+0x3fe8>)
42015bb3:	20b770        	or	a11, a7, a7
42015bb6:	03a0a2        	movi	a10, 3
42015bb9:	a93681        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42015bbc:	0008e0        	callx8	a8
    extern void app_main(void);
    app_main();
42015bbf:	f1bee5        	call8	420077ac <app_main>
    ESP_LOGI(MAIN_TAG, "Returned from app_main()");
42015bc2:	a92781        	l32r	a8, 42000060 <_stext+0x40> (4037fbe0 <esp_log_timestamp>)
42015bc5:	0008e0        	callx8	a8
42015bc8:	07ed      	mov.n	a14, a7
42015bca:	0add      	mov.n	a13, a10
42015bcc:	ace8c1        	l32r	a12, 42000f6c <_stext+0xf4c> (3c024128 <_flash_rodata_start+0x4008>)
42015bcf:	07bd      	mov.n	a11, a7
42015bd1:	3a0c      	movi.n	a10, 3
42015bd3:	a93081        	l32r	a8, 42000094 <_stext+0x74> (4037fc28 <esp_log_write>)
42015bd6:	0008e0        	callx8	a8
    vTaskDelete(NULL);
42015bd9:	0a0c      	movi.n	a10, 0
42015bdb:	ace581        	l32r	a8, 42000f70 <_stext+0xf50> (4037ba64 <vTaskDelete>)
42015bde:	0008e0        	callx8	a8
}
42015be1:	f01d      	retw.n
	...

42015be4 <esp_startup_start_app>:
{
42015be4:	006136        	entry	a1, 48
    esp_int_wdt_init();
42015be7:	ebeee5        	call8	42001ad4 <esp_int_wdt_init>
    esp_int_wdt_cpu_init();
42015bea:	ebfa25        	call8	42001b8c <esp_int_wdt_cpu_init>
    esp_crosscore_int_init();
42015bed:	f41d25        	call8	42009dc0 <esp_crosscore_int_init>
    BaseType_t res = xTaskCreatePinnedToCore(main_task, "main",
42015bf0:	00a0d2        	movi	a13, 0
42015bf3:	01d9      	s32i.n	a13, a1, 0
42015bf5:	0dfd      	mov.n	a15, a13
42015bf7:	01a0e2        	movi	a14, 1
42015bfa:	acdec1        	l32r	a12, 42000f74 <_stext+0xf54> (2200 <UserFrameTotalSize+0x2100>)
42015bfd:	acdeb1        	l32r	a11, 42000f78 <_stext+0xf58> (3c024150 <_flash_rodata_start+0x4030>)
42015c00:	acdfa1        	l32r	a10, 42000f7c <_stext+0xf5c> (42015b4c <main_task>)
42015c03:	a9f681        	l32r	a8, 420003dc <_stext+0x3bc> (4037c5a4 <xTaskCreatePinnedToCore>)
42015c06:	0008e0        	callx8	a8
    assert(res == pdTRUE);
42015c09:	101a26        	beqi	a10, 1, 42015c1d <esp_startup_start_app+0x39>
42015c0c:	acddd1        	l32r	a13, 42000f80 <_stext+0xf60> (3c020f64 <_flash_rodata_start+0xe44>)
42015c0f:	acddc1        	l32r	a12, 42000f84 <_stext+0xf64> (3c027eac <__func__$0>)
42015c12:	6b5c      	movi.n	a11, 86
42015c14:	acdda1        	l32r	a10, 42000f88 <_stext+0xf68> (3c024172 <_flash_rodata_start+0x4052>)
42015c17:	a92a81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015c1a:	0008e0        	callx8	a8
    if (port_start_app_hook != NULL) {
42015c1d:	acdb81        	l32r	a8, 42000f8c <_stext+0xf6c> (0 <IDF_TARGET_ESP32S3>)
42015c20:	488c      	beqz.n	a8, 42015c28 <esp_startup_start_app+0x44>
        port_start_app_hook();
42015c22:	acda81        	l32r	a8, 42000f8c <_stext+0xf6c> (0 <IDF_TARGET_ESP32S3>)
42015c25:	0008e0        	callx8	a8
    vTaskStartScheduler();
42015c28:	acda81        	l32r	a8, 42000f90 <_stext+0xf70> (4037c7a4 <vTaskStartScheduler>)
42015c2b:	0008e0        	callx8	a8
}
42015c2e:	f01d      	retw.n

42015c30 <esp_startup_start_app_other_cores>:
{
42015c30:	004136        	entry	a1, 32
42015c33:	03eb80        	rsr.prid	a8
42015c36:	048d80        	extui	a8, a8, 13, 1
    if (xPortGetCoreID() >= 2) {
42015c39:	0528a6        	blti	a8, 2, 42015c42 <esp_startup_start_app_other_cores+0x12>
        abort();
42015c3c:	a92e81        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42015c3f:	0008e0        	callx8	a8
    while (port_xSchedulerRunning[0] == 0) {
42015c42:	acd481        	l32r	a8, 42000f94 <_stext+0xf74> (3fc94de8 <port_xSchedulerRunning>)
42015c45:	0020c0        	memw
42015c48:	0888      	l32i.n	a8, a8, 0
42015c4a:	ff4816        	beqz	a8, 42015c42 <esp_startup_start_app_other_cores+0x12>
    esp_int_wdt_cpu_init();
42015c4d:	ebf3e5        	call8	42001b8c <esp_int_wdt_cpu_init>
    esp_crosscore_int_init();
42015c50:	f416e5        	call8	42009dc0 <esp_crosscore_int_init>
    xPortStartScheduler();
42015c53:	acd181        	l32r	a8, 42000f98 <_stext+0xf78> (4037a048 <xPortStartScheduler>)
42015c56:	0008e0        	callx8	a8
    abort(); // Only get to here if FreeRTOS somehow very broken
42015c59:	a92681        	l32r	a8, 420000f4 <_stext+0xd4> (4037fc94 <abort>)
42015c5c:	0008e0        	callx8	a8
	...

42015c60 <multi_heap_register>:
{
42015c60:	004136        	entry	a1, 32
42015c63:	027d      	mov.n	a7, a2
    assert(start_ptr);
42015c65:	02dc      	bnez.n	a2, 42015c79 <multi_heap_register+0x19>
42015c67:	accdd1        	l32r	a13, 42000f9c <_stext+0xf7c> (3c022a1c <_flash_rodata_start+0x28fc>)
42015c6a:	accdc1        	l32r	a12, 42000fa0 <_stext+0xf80> (3c027838 <__func__$0>)
42015c6d:	85a0b2        	movi	a11, 133
42015c70:	accda1        	l32r	a10, 42000fa4 <_stext+0xf84> (3c022a3e <_flash_rodata_start+0x291e>)
42015c73:	a91381        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015c76:	0008e0        	callx8	a8
    if(size < (sizeof(heap_t))) {
42015c79:	381c      	movi.n	a8, 19
42015c7b:	2bb837        	bgeu	a8, a3, 42015caa <multi_heap_register+0x4a>
    size -= sizeof(heap_t);
42015c7e:	ecc332        	addi	a3, a3, -20
    result->heap_data = tlsf_create_with_pool(start_ptr + sizeof(heap_t), size, max_bytes);
42015c81:	0c0c      	movi.n	a12, 0
42015c83:	03bd      	mov.n	a11, a3
42015c85:	14c2a2        	addi	a10, a2, 20
42015c88:	004d65        	call8	42016160 <tlsf_create_with_pool>
42015c8b:	0a2d      	mov.n	a2, a10
42015c8d:	47a9      	s32i.n	a10, a7, 16
    if(!result->heap_data) {
42015c8f:	9a9c      	beqz.n	a10, 42015cac <multi_heap_register+0x4c>
    result->lock = NULL;
42015c91:	080c      	movi.n	a8, 0
42015c93:	006782        	s32i	a8, a7, 0
    result->free_bytes = size - tlsf_size(result->heap_data);
42015c96:	acc481        	l32r	a8, 42000fa8 <_stext+0xf88> (4037fb34 <tlsf_size>)
42015c99:	0008e0        	callx8	a8
42015c9c:	c0a3a0        	sub	a10, a3, a10
42015c9f:	17a9      	s32i.n	a10, a7, 4
    result->pool_size = size;
42015ca1:	3739      	s32i.n	a3, a7, 12
    result->minimum_free_bytes = result->free_bytes;
42015ca3:	27a9      	s32i.n	a10, a7, 8
    return result;
42015ca5:	072d      	mov.n	a2, a7
42015ca7:	000046        	j	42015cac <multi_heap_register+0x4c>
        return NULL;
42015caa:	020c      	movi.n	a2, 0
}
42015cac:	f01d      	retw.n
	...

42015cb0 <multi_heap_get_info>:
    info->total_blocks++;
    return true;
}

void multi_heap_get_info_impl(multi_heap_handle_t heap, multi_heap_info_t *info)
{
42015cb0:	004136        	entry	a1, 32
    uint32_t overhead;

    memset(info, 0, sizeof(multi_heap_info_t));
42015cb3:	cc1c      	movi.n	a12, 28
42015cb5:	0b0c      	movi.n	a11, 0
42015cb7:	03ad      	mov.n	a10, a3
42015cb9:	a99181        	l32r	a8, 42000300 <_stext+0x2e0> (400011e8 <memset>)
42015cbc:	0008e0        	callx8	a8

    if (heap == NULL) {
42015cbf:	053216        	beqz	a2, 42015d16 <multi_heap_get_info+0x66>
        return;
    }

    multi_heap_internal_lock(heap);
42015cc2:	20a220        	or	a10, a2, a2
42015cc5:	acba81        	l32r	a8, 42000fb0 <_stext+0xf90> (4037e6b8 <multi_heap_internal_lock>)
42015cc8:	0008e0        	callx8	a8
    tlsf_walk_pool(tlsf_get_pool(heap->heap_data), multi_heap_get_info_tlsf, info);
42015ccb:	42a8      	l32i.n	a10, a2, 16
42015ccd:	acb981        	l32r	a8, 42000fb4 <_stext+0xf94> (4037ebcc <tlsf_get_pool>)
42015cd0:	0008e0        	callx8	a8
42015cd3:	03cd      	mov.n	a12, a3
42015cd5:	acb5b1        	l32r	a11, 42000fac <_stext+0xf8c> (42015d18 <multi_heap_get_info_tlsf>)
42015cd8:	001fa5        	call8	42015ed4 <tlsf_walk_pool>
    /* TLSF has an overhead per block. Calculate the total amount of overhead, it shall not be
     * part of the allocated bytes */
    overhead = info->allocated_blocks * tlsf_alloc_overhead();
42015cdb:	4368      	l32i.n	a6, a3, 16
42015cdd:	acb681        	l32r	a8, 42000fb8 <_stext+0xf98> (4037e7c8 <tlsf_alloc_overhead>)
42015ce0:	0008e0        	callx8	a8
42015ce3:	8266a0        	mull	a6, a6, a10
    info->total_allocated_bytes = (heap->pool_size - tlsf_size(heap->heap_data)) - heap->free_bytes - overhead;
42015ce6:	3278      	l32i.n	a7, a2, 12
42015ce8:	42a8      	l32i.n	a10, a2, 16
42015cea:	acaf81        	l32r	a8, 42000fa8 <_stext+0xf88> (4037fb34 <tlsf_size>)
42015ced:	0008e0        	callx8	a8
42015cf0:	c0a7a0        	sub	a10, a7, a10
42015cf3:	1288      	l32i.n	a8, a2, 4
42015cf5:	c0aa80        	sub	a10, a10, a8
42015cf8:	c0aa60        	sub	a10, a10, a6
42015cfb:	13a9      	s32i.n	a10, a3, 4
    info->minimum_free_bytes = heap->minimum_free_bytes;
42015cfd:	2288      	l32i.n	a8, a2, 8
42015cff:	3389      	s32i.n	a8, a3, 12
    info->total_free_bytes = heap->free_bytes;
42015d01:	1288      	l32i.n	a8, a2, 4
42015d03:	0389      	s32i.n	a8, a3, 0
    info->largest_free_block = tlsf_fit_size(heap->heap_data, info->largest_free_block);
42015d05:	23b8      	l32i.n	a11, a3, 8
42015d07:	42a8      	l32i.n	a10, a2, 16
42015d09:	002225        	call8	42015f2c <tlsf_fit_size>
42015d0c:	23a9      	s32i.n	a10, a3, 8
    multi_heap_internal_unlock(heap);
42015d0e:	02ad      	mov.n	a10, a2
42015d10:	acab81        	l32r	a8, 42000fbc <_stext+0xf9c> (4037e6dc <multi_heap_internal_unlock>)
42015d13:	0008e0        	callx8	a8
}
42015d16:	f01d      	retw.n

42015d18 <multi_heap_get_info_tlsf>:
{
42015d18:	004136        	entry	a1, 32
    if(used) {
42015d1b:	748c      	beqz.n	a4, 42015d26 <multi_heap_get_info_tlsf+0xe>
        info->allocated_blocks++;
42015d1d:	4588      	l32i.n	a8, a5, 16
42015d1f:	881b      	addi.n	a8, a8, 1
42015d21:	4589      	s32i.n	a8, a5, 16
42015d23:	000346        	j	42015d34 <multi_heap_get_info_tlsf+0x1c>
        info->free_blocks++;
42015d26:	5588      	l32i.n	a8, a5, 20
42015d28:	881b      	addi.n	a8, a8, 1
42015d2a:	5589      	s32i.n	a8, a5, 20
        if(size > info->largest_free_block ) {
42015d2c:	2588      	l32i.n	a8, a5, 8
42015d2e:	02b837        	bgeu	a8, a3, 42015d34 <multi_heap_get_info_tlsf+0x1c>
            info->largest_free_block = size;
42015d31:	026532        	s32i	a3, a5, 8
    info->total_blocks++;
42015d34:	6588      	l32i.n	a8, a5, 24
42015d36:	881b      	addi.n	a8, a8, 1
42015d38:	6589      	s32i.n	a8, a5, 24
}
42015d3a:	120c      	movi.n	a2, 1
42015d3c:	f01d      	retw.n
	...

42015d40 <control_construct>:
{
42015d40:	004136        	entry	a1, 32
	if (bytes < sizeof(control_t))
42015d43:	382c      	movi.n	a8, 35
42015d45:	023837        	bltu	a8, a3, 42015d4b <control_construct+0xb>
42015d48:	005646        	j	42015ea5 <control_construct+0x165>
	control->fl_index_max = 32 - __builtin_clz(bytes);
42015d4b:	40f390        	nsau	a9, a3
42015d4e:	e0c992        	addi	a9, a9, -32
42015d51:	609090        	neg	a9, a9
42015d54:	748090        	extui	a8, a9, 0, 8
42015d57:	549090        	extui	a9, a9, 0, 6
42015d5a:	119980        	slli	a9, a9, 8
42015d5d:	42a8      	l32i.n	a10, a2, 16
42015d5f:	ac98b1        	l32r	a11, 42000fc0 <_stext+0xfa0> (ffffc0ff <_rtc_reserved_end+0x9fefc0ff>)
42015d62:	10aab0        	and	a10, a10, a11
42015d65:	209a90        	or	a9, a10, a9
42015d68:	4299      	s32i.n	a9, a2, 16
	if (bytes <= 16 * 1024) control->sl_index_count_log2 = 3;
42015d6a:	a92591        	l32r	a9, 42000200 <_stext+0x1e0> (4000 <UserFrameTotalSize+0x3f00>)
42015d6d:	133937        	bltu	a9, a3, 42015d84 <control_construct+0x44>
42015d70:	4298      	l32i.n	a9, a2, 16
42015d72:	ac94a1        	l32r	a10, 42000fc4 <_stext+0xfa4> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
42015d75:	1099a0        	and	a9, a9, a10
42015d78:	ac94a1        	l32r	a10, 42000fc8 <_stext+0xfa8> (300000 <UserFrameTotalSize+0x2fff00>)
42015d7b:	2099a0        	or	a9, a9, a10
42015d7e:	4299      	s32i.n	a9, a2, 16
42015d80:	000a46        	j	42015dad <control_construct+0x6d>
42015d83:	239100        	sext	a9, a1, 7
	else if (bytes <= 256 * 1024) control->sl_index_count_log2 = 4;
42015d86:	37ac      	beqz.n	a7, 42015dad <control_construct+0x6d>
42015d88:	1239      	s32i.n	a3, a2, 4
42015d8a:	4298      	l32i.n	a9, a2, 16
42015d8c:	ac8ea1        	l32r	a10, 42000fc4 <_stext+0xfa4> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
42015d8f:	1099a0        	and	a9, a9, a10
42015d92:	ac8ea1        	l32r	a10, 42000fcc <_stext+0xfac> (400000 <UserFrameTotalSize+0x3fff00>)
42015d95:	2099a0        	or	a9, a9, a10
42015d98:	4299      	s32i.n	a9, a2, 16
42015d9a:	0003c6        	j	42015dad <control_construct+0x6d>
	else control->sl_index_count_log2 = 5;
42015d9d:	4298      	l32i.n	a9, a2, 16
42015d9f:	ac89a1        	l32r	a10, 42000fc4 <_stext+0xfa4> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
42015da2:	1099a0        	and	a9, a9, a10
42015da5:	ac8aa1        	l32r	a10, 42000fd0 <_stext+0xfb0> (500000 <UserFrameTotalSize+0x4fff00>)
42015da8:	2099a0        	or	a9, a9, a10
42015dab:	4299      	s32i.n	a9, a2, 16
	control->fl_index_shift = (control->sl_index_count_log2 + ALIGN_SIZE_LOG2);
42015dad:	4298      	l32i.n	a9, a2, 16
42015daf:	25a490        	extui	a10, a9, 20, 3
42015db2:	ea2b      	addi.n	a14, a10, 2
42015db4:	24c0e0        	extui	a12, a14, 0, 3
42015db7:	11bcb0        	slli	a11, a12, 5
42015dba:	1fafd2        	movi	a13, -225
42015dbd:	1099d0        	and	a9, a9, a13
42015dc0:	2099b0        	or	a9, a9, a11
42015dc3:	4299      	s32i.n	a9, a2, 16
	control->sl_index_count = 1 << control->sl_index_count_log2;
42015dc5:	1b0c      	movi.n	a11, 1
42015dc7:	401a00        	ssl	a10
42015dca:	a1ab00        	sll	a10, a11
42015dcd:	54d0a0        	extui	a13, a10, 0, 6
42015dd0:	11fd20        	slli	a15, a13, 14
42015dd3:	ac8071        	l32r	a7, 42000fd4 <_stext+0xfb4> (fff03fff <_rtc_reserved_end+0x9fe03fff>)
42015dd6:	109970        	and	a9, a9, a7
42015dd9:	2099f0        	or	a9, a9, a15
42015ddc:	4299      	s32i.n	a9, a2, 16
	control->fl_index_count = control->fl_index_max - control->fl_index_shift + 1;
42015dde:	548080        	extui	a8, a8, 0, 6
42015de1:	c088c0        	sub	a8, a8, a12
42015de4:	748080        	extui	a8, a8, 0, 8
42015de7:	88ba      	add.n	a8, a8, a11
42015de9:	44e080        	extui	a14, a8, 0, 5
42015dec:	0f6c      	movi.n	a15, -32
42015dee:	1099f0        	and	a9, a9, a15
42015df1:	2089e0        	or	a8, a9, a14
42015df4:	4289      	s32i.n	a8, a2, 16
	control->small_block_size = 1 << control->fl_index_shift;
42015df6:	401c00        	ssl	a12
42015df9:	a1bb00        	sll	a11, a11
42015dfc:	7490b0        	extui	a9, a11, 0, 8
42015dff:	019990        	slli	a9, a9, 23
42015e02:	ac75c1        	l32r	a12, 42000fd8 <_stext+0xfb8> (807fffff <_rtc_reserved_end+0x206fffff>)
42015e05:	1088c0        	and	a8, a8, a12
42015e08:	208890        	or	a8, a8, a9
42015e0b:	4289      	s32i.n	a8, a2, 16
										(sizeof(*control->blocks) * (control->fl_index_count * control->sl_index_count));
42015e0d:	828ed0        	mull	a8, a14, a13
	control->size = sizeof(control_t) + (sizeof(*control->sl_bitmap) * control->fl_index_count) +
42015e10:	88ea      	add.n	a8, a8, a14
42015e12:	889b      	addi.n	a8, a8, 9
42015e14:	1188e0        	slli	a8, a8, 2
42015e17:	5289      	s32i.n	a8, a2, 20
	if (bytes < control->size + block_size_min)
42015e19:	88cb      	addi.n	a8, a8, 12
42015e1b:	02b387        	bgeu	a3, a8, 42015e21 <control_construct+0xe1>
42015e1e:	002206        	j	42015eaa <control_construct+0x16a>
	control->block_null.next_free = &control->block_null;
42015e21:	02cd      	mov.n	a12, a2
42015e23:	2229      	s32i.n	a2, a2, 8
	control->block_null.prev_free = &control->block_null;
42015e25:	3229      	s32i.n	a2, a2, 12
	control->fl_bitmap = 0;
42015e27:	080c      	movi.n	a8, 0
42015e29:	6289      	s32i.n	a8, a2, 24
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
42015e2b:	27c282        	addi	a8, a2, 39
42015e2e:	c97c      	movi.n	a9, -4
42015e30:	108890        	and	a8, a8, a9
	control->sl_bitmap = align_ptr(control + 1, sizeof(*control->sl_bitmap));
42015e33:	7289      	s32i.n	a8, a2, 28
	control->blocks = align_ptr(control->sl_bitmap + control->fl_index_count, sizeof(*control->blocks));
42015e35:	a08e80        	addx4	a8, a14, a8
42015e38:	883b      	addi.n	a8, a8, 3
42015e3a:	108890        	and	a8, a8, a9
42015e3d:	8289      	s32i.n	a8, a2, 32
	tlsf_assert(sizeof(unsigned int) * CHAR_BIT >= control->sl_index_count
42015e3f:	082c      	movi.n	a8, 32
42015e41:	10b8d7        	bgeu	a8, a13, 42015e55 <control_construct+0x115>
42015e44:	ac66d1        	l32r	a13, 42000fdc <_stext+0xfbc> (3c022a5c <_flash_rodata_start+0x293c>)
42015e47:	ac66c1        	l32r	a12, 42000fe0 <_stext+0xfc0> (3c027928 <__func__$13>)
42015e4a:	ab4c      	movi.n	a11, 74
42015e4c:	ac66a1        	l32r	a10, 42000fe4 <_stext+0xfc4> (3c022adb <_flash_rodata_start+0x29bb>)
42015e4f:	a89c81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015e52:	0008e0        	callx8	a8
	tlsf_assert(ALIGN_SIZE == control->small_block_size / control->sl_index_count); //ALIGN_SIZE does not match");
42015e55:	74b0b0        	extui	a11, a11, 0, 8
42015e58:	d28bd0        	quos	a8, a11, a13
42015e5b:	394826        	beqi	a8, 4, 42015e98 <control_construct+0x158>
42015e5e:	ac62d1        	l32r	a13, 42000fe8 <_stext+0xfc8> (3c022ae4 <_flash_rodata_start+0x29c4>)
42015e61:	ac5fc1        	l32r	a12, 42000fe0 <_stext+0xfc0> (3c027928 <__func__$13>)
42015e64:	4ea0b2        	movi	a11, 78
42015e67:	ac5fa1        	l32r	a10, 42000fe4 <_stext+0xfc4> (3c022adb <_flash_rodata_start+0x29bb>)
42015e6a:	a89581        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015e6d:	0008e0        	callx8	a8
		control->sl_bitmap[i] = 0;
42015e70:	7288      	l32i.n	a8, a2, 28
42015e72:	a08b80        	addx4	a8, a11, a8
42015e75:	090c      	movi.n	a9, 0
42015e77:	0899      	s32i.n	a9, a8, 0
		for (int j = 0; j < control->sl_index_count; ++j)
42015e79:	000346        	j	42015e8a <control_construct+0x14a>
			control->blocks[i * control->sl_index_count + j] = &control->block_null;
42015e7c:	82a8      	l32i.n	a10, a2, 32
42015e7e:	8288b0        	mull	a8, a8, a11
42015e81:	889a      	add.n	a8, a8, a9
42015e83:	a088a0        	addx4	a8, a8, a10
42015e86:	08c9      	s32i.n	a12, a8, 0
		for (int j = 0; j < control->sl_index_count; ++j)
42015e88:	991b      	addi.n	a9, a9, 1
42015e8a:	4288      	l32i.n	a8, a2, 16
42015e8c:	548e80        	extui	a8, a8, 14, 6
42015e8f:	e92987        	blt	a9, a8, 42015e7c <control_construct+0x13c>
	for (int i = 0; i < control->fl_index_count; ++i)
42015e92:	bb1b      	addi.n	a11, a11, 1
42015e94:	000086        	j	42015e9a <control_construct+0x15a>
42015e97:	0b0c00        	lsi	f0, a12, 44
42015e9a:	4288      	l32i.n	a8, a2, 16
42015e9c:	448080        	extui	a8, a8, 0, 5
42015e9f:	cd2b87        	blt	a11, a8, 42015e70 <control_construct+0x130>
42015ea2:	000186        	j	42015eac <control_construct+0x16c>
		return NULL;
42015ea5:	020c      	movi.n	a2, 0
42015ea7:	000046        	j	42015eac <control_construct+0x16c>
		return NULL;
42015eaa:	020c      	movi.n	a2, 0
}
42015eac:	f01d      	retw.n
	...

42015eb0 <default_walker>:
{
42015eb0:	004136        	entry	a1, 32
42015eb3:	02bd      	mov.n	a11, a2
42015eb5:	03dd      	mov.n	a13, a3
	printf("\t%p %s size: %x (%p)\n", ptr, used ? "used" : "free", (unsigned int)size, block_from_ptr(ptr));
42015eb7:	648c      	beqz.n	a4, 42015ec1 <default_walker+0x11>
42015eb9:	ac4cc1        	l32r	a12, 42000fec <_stext+0xfcc> (3c022b28 <_flash_rodata_start+0x2a08>)
42015ebc:	000106        	j	42015ec4 <default_walker+0x14>
42015ebf:	c10000        	mul16u	a0, a0, a0
42015ec2:	ac4b      	addi.n	a10, a12, 4
42015ec4:	f8cbe2        	addi	a14, a11, -8
42015ec7:	ac4ba1        	l32r	a10, 42000ff4 <_stext+0xfd4> (3c022b38 <_flash_rodata_start+0x2a18>)
42015eca:	f4fb25        	call8	4200ae7c <printf>
}
42015ecd:	120c      	movi.n	a2, 1
42015ecf:	f01d      	retw.n
42015ed1:	000000        	ill

42015ed4 <tlsf_walk_pool>:
{
42015ed4:	004136        	entry	a1, 32
	tlsf_walker pool_walker = walker ? walker : default_walker;
42015ed7:	13cc      	bnez.n	a3, 42015edc <tlsf_walk_pool+0x8>
42015ed9:	ac4731        	l32r	a3, 42000ff8 <_stext+0xfd8> (42015eb0 <default_walker>)
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42015edc:	fcc272        	addi	a7, a2, -4
	bool ret_val = true;
42015edf:	1a0c      	movi.n	a10, 1
	while (block && !block_is_last(block) && ret_val == true)
42015ee1:	000ec6        	j	42015f20 <tlsf_walk_pool+0x4c>
	return tlsf_cast(void*,
42015ee4:	678b      	addi.n	a6, a7, 8
		ret_val = pool_walker(
42015ee6:	04c080        	extui	a12, a8, 0, 1
42015ee9:	04dd      	mov.n	a13, a4
42015eeb:	190c      	movi.n	a9, 1
42015eed:	30cc90        	xor	a12, a12, a9
42015ef0:	cb7c      	movi.n	a11, -4
42015ef2:	10b8b0        	and	a11, a8, a11
42015ef5:	06ad      	mov.n	a10, a6
42015ef7:	0003e0        	callx8	a3
		if (ret_val == true) {
42015efa:	2aac      	beqz.n	a10, 42015f20 <tlsf_walk_pool+0x4c>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42015efc:	1788      	l32i.n	a8, a7, 4
42015efe:	c77c      	movi.n	a7, -4
42015f00:	107870        	and	a7, a8, a7
	block_header_t* next = offset_to_block(block_to_ptr(block),
42015f03:	fcc772        	addi	a7, a7, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42015f06:	807760        	add	a7, a7, a6
	tlsf_assert(!block_is_last(block));
42015f09:	390c      	movi.n	a9, 3
42015f0b:	113987        	bltu	a9, a8, 42015f20 <tlsf_walk_pool+0x4c>
42015f0e:	ac3bd1        	l32r	a13, 42000ffc <_stext+0xfdc> (3c022b50 <_flash_rodata_start+0x2a30>)
42015f11:	ac3bc1        	l32r	a12, 42001000 <_stext+0xfe0> (3c02797c <__func__$20>)
42015f14:	a1a0b2        	movi	a11, 161
42015f17:	ac3ba1        	l32r	a10, 42001004 <_stext+0xfe4> (3c022b83 <_flash_rodata_start+0x2a63>)
42015f1a:	a86981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42015f1d:	0008e0        	callx8	a8
	while (block && !block_is_last(block) && ret_val == true)
42015f20:	678c      	beqz.n	a7, 42015f2a <tlsf_walk_pool+0x56>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42015f22:	1788      	l32i.n	a8, a7, 4
42015f24:	0248b6        	bltui	a8, 4, 42015f2a <tlsf_walk_pool+0x56>
42015f27:	fb9a56        	bnez	a10, 42015ee4 <tlsf_walk_pool+0x10>
}
42015f2a:	f01d      	retw.n

42015f2c <tlsf_fit_size>:
{
42015f2c:	004136        	entry	a1, 32
	if (size == 0 || tlsf == NULL) {
42015f2f:	40f380        	nsau	a8, a3
42015f32:	418580        	srli	a8, a8, 5
42015f35:	40f290        	nsau	a9, a2
42015f38:	419590        	srli	a9, a9, 5
42015f3b:	208890        	or	a8, a8, a9
42015f3e:	054856        	bnez	a8, 42015f96 <tlsf_fit_size+0x6a>
	if (size < control->small_block_size) {
42015f41:	4288      	l32i.n	a8, a2, 16
42015f43:	758780        	extui	a8, a8, 23, 8
42015f46:	2fb387        	bgeu	a3, a8, 42015f79 <tlsf_fit_size+0x4d>
	if (size)
42015f49:	73ac      	beqz.n	a3, 42015f74 <tlsf_fit_size+0x48>
	return (x + (align - 1)) & ~(align - 1);
42015f4b:	333b      	addi.n	a3, a3, 3
42015f4d:	c87c      	movi.n	a8, -4
42015f4f:	103380        	and	a3, a3, a8
	if (control == NULL)
42015f52:	629c      	beqz.n	a2, 42015f6c <tlsf_fit_size+0x40>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
42015f54:	4298      	l32i.n	a9, a2, 16
42015f56:	549890        	extui	a9, a9, 8, 6
42015f59:	180c      	movi.n	a8, 1
42015f5b:	401900        	ssl	a9
42015f5e:	a18800        	sll	a8, a8
		if (aligned < tlsf_block_size_max(control)) 
42015f61:	0db387        	bgeu	a3, a8, 42015f72 <tlsf_fit_size+0x46>
			adjust = tlsf_max(aligned, block_size_min);
42015f64:	c80c      	movi.n	a8, 12
42015f66:	733380        	maxu	a3, a3, a8
42015f69:	0001c6        	j	42015f74 <tlsf_fit_size+0x48>
	size_t adjust = 0;
42015f6c:	030c      	movi.n	a3, 0
42015f6e:	000086        	j	42015f74 <tlsf_fit_size+0x48>
42015f71:	030c00        	rsr.scompare1	a0
		return adjust_request_size(tlsf, size, ALIGN_SIZE);
42015f74:	032d      	mov.n	a2, a3
42015f76:	000786        	j	42015f98 <tlsf_fit_size+0x6c>
	sl_interval = (1 << (32 - __builtin_clz(size) - 1)) / control->sl_index_count;
42015f79:	40f390        	nsau	a9, a3
42015f7c:	ab0681        	l32r	a8, 42000b94 <_stext+0xb74> (80000000 <_rtc_reserved_end+0x1ff00000>)
42015f7f:	400900        	ssr	a9
42015f82:	918080        	srl	a8, a8
42015f85:	4298      	l32i.n	a9, a2, 16
42015f87:	549e90        	extui	a9, a9, 14, 6
42015f8a:	d28890        	quos	a8, a8, a9
	return size & ~(sl_interval - 1);
42015f8d:	608080        	neg	a8, a8
42015f90:	102830        	and	a2, a8, a3
42015f93:	000046        	j	42015f98 <tlsf_fit_size+0x6c>
		return 0;
42015f96:	020c      	movi.n	a2, 0
}
42015f98:	f01d      	retw.n
	...

42015f9c <tlsf_add_pool>:
{
42015f9c:	004136        	entry	a1, 32
	const size_t pool_overhead = tlsf_pool_overhead();
42015f9f:	001ee5        	call8	4201618c <tlsf_pool_overhead>
	const size_t pool_bytes = align_down(bytes - pool_overhead, ALIGN_SIZE);
42015fa2:	c044a0        	sub	a4, a4, a10
	return x - (x & (align - 1));
42015fa5:	fcaf82        	movi	a8, -4
42015fa8:	108480        	and	a8, a4, a8
	if (((ptrdiff_t)mem % ALIGN_SIZE) != 0)
42015fab:	149030        	extui	a9, a3, 0, 2
42015fae:	00c916        	beqz	a9, 42015fbe <tlsf_add_pool+0x22>
		printf("tlsf_add_pool: Memory must be aligned by %u bytes.\n",
42015fb1:	4b0c      	movi.n	a11, 4
42015fb3:	ac15a1        	l32r	a10, 42001008 <_stext+0xfe8> (3c022b9c <_flash_rodata_start+0x2a7c>)
42015fb6:	f4ec65        	call8	4200ae7c <printf>
		return 0;
42015fb9:	020c      	movi.n	a2, 0
42015fbb:	005bc6        	j	4201612e <tlsf_add_pool+0x192>
	if (pool_bytes < block_size_min || pool_bytes > tlsf_block_size_max(tlsf))
42015fbe:	bb0c      	movi.n	a11, 11
42015fc0:	16bb87        	bgeu	a11, a8, 42015fda <tlsf_add_pool+0x3e>
	if (control == NULL)
42015fc3:	e28c      	beqz.n	a2, 42015fd5 <tlsf_add_pool+0x39>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
42015fc5:	42c8      	l32i.n	a12, a2, 16
42015fc7:	54c8c0        	extui	a12, a12, 8, 6
42015fca:	1b0c      	movi.n	a11, 1
42015fcc:	401c00        	ssl	a12
42015fcf:	a1bb00        	sll	a11, a11
42015fd2:	000046        	j	42015fd7 <tlsf_add_pool+0x3b>
		return 0;
42015fd5:	09bd      	mov.n	a11, a9
42015fd7:	1ebb87        	bgeu	a11, a8, 42015ff9 <tlsf_add_pool+0x5d>
			(unsigned int)(pool_overhead + block_size_min),
42015fda:	bacb      	addi.n	a11, a10, 12
	if (control == NULL)
42015fdc:	c28c      	beqz.n	a2, 42015fec <tlsf_add_pool+0x50>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
42015fde:	4288      	l32i.n	a8, a2, 16
42015fe0:	548880        	extui	a8, a8, 8, 6
42015fe3:	01a092        	movi	a9, 1
42015fe6:	401800        	ssl	a8
42015fe9:	a19900        	sll	a9, a9
		printf("tlsf_add_pool: Memory size must be between %u and %u bytes.\n", 
42015fec:	ca9a      	add.n	a12, a10, a9
42015fee:	ac07a1        	l32r	a10, 4200100c <_stext+0xfec> (3c022bd0 <_flash_rodata_start+0x2ab0>)
42015ff1:	f4e8a5        	call8	4200ae7c <printf>
		return 0;
42015ff4:	020c      	movi.n	a2, 0
42015ff6:	004d06        	j	4201612e <tlsf_add_pool+0x192>
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42015ff9:	fcc392        	addi	a9, a3, -4
	const size_t oldsize = block->size;
42015ffc:	19a8      	l32i.n	a10, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
42015ffe:	14a0a0        	extui	a10, a10, 0, 2
42016001:	2088a0        	or	a8, a8, a10
42016004:	1989      	s32i.n	a8, a9, 4
	block->size |= block_header_free_bit;
42016006:	1b0c      	movi.n	a11, 1
42016008:	20a8b0        	or	a10, a8, a11
4201600b:	19a9      	s32i.n	a10, a9, 4
	block->size &= ~block_header_prev_free_bit;
4201600d:	da7c      	movi.n	a10, -3
4201600f:	10a8a0        	and	a10, a8, a10
42016012:	20aab0        	or	a10, a10, a11
42016015:	19a9      	s32i.n	a10, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
42016017:	ca7c      	movi.n	a10, -4
42016019:	1088a0        	and	a8, a8, a10
	if (size < control->small_block_size)
4201601c:	42a8      	l32i.n	a10, a2, 16
4201601e:	75a7a0        	extui	a10, a10, 23, 8
42016021:	0fb8a7        	bgeu	a8, a10, 42016034 <tlsf_add_pool+0x98>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
42016024:	42b8      	l32i.n	a11, a2, 16
42016026:	54beb0        	extui	a11, a11, 14, 6
42016029:	d2aab0        	quos	a10, a10, a11
4201602c:	d288a0        	quos	a8, a8, a10
		fl = 0;
4201602f:	0b0c      	movi.n	a11, 0
42016031:	000c06        	j	42016065 <tlsf_add_pool+0xc9>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
42016034:	a88c      	beqz.n	a8, 42016042 <tlsf_add_pool+0xa6>
42016036:	40f8b0        	nsau	a11, a8
42016039:	e0cbb2        	addi	a11, a11, -32
4201603c:	60b0b0        	neg	a11, a11
4201603f:	000046        	j	42016044 <tlsf_add_pool+0xa8>
42016042:	0b0c      	movi.n	a11, 0
	return bit - 1;
42016044:	cb0b      	addi.n	a12, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
42016046:	42a8      	l32i.n	a10, a2, 16
42016048:	25d4a0        	extui	a13, a10, 20, 3
4201604b:	c0ccd0        	sub	a12, a12, a13
4201604e:	400c00        	ssr	a12
42016051:	918080        	srl	a8, a8
42016054:	1c0c      	movi.n	a12, 1
42016056:	401d00        	ssl	a13
42016059:	a1cc00        	sll	a12, a12
4201605c:	3088c0        	xor	a8, a8, a12
		fl -= (control->fl_index_shift - 1);
4201605f:	24a5a0        	extui	a10, a10, 5, 3
42016062:	c0bba0        	sub	a11, a11, a10
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
42016065:	82c8      	l32i.n	a12, a2, 32
42016067:	42a8      	l32i.n	a10, a2, 16
42016069:	54aea0        	extui	a10, a10, 14, 6
4201606c:	82aab0        	mull	a10, a10, a11
4201606f:	80aa80        	add	a10, a10, a8
42016072:	a0aac0        	addx4	a10, a10, a12
42016075:	0aa8      	l32i.n	a10, a10, 0
	tlsf_assert(current && "free list cannot have a null entry");
42016077:	011a56        	bnez	a10, 4201608c <tlsf_add_pool+0xf0>
4201607a:	abe5d1        	l32r	a13, 42001010 <_stext+0xff0> (3c022c10 <_flash_rodata_start+0x2af0>)
4201607d:	abe5c1        	l32r	a12, 42001014 <_stext+0xff4> (3c02795c <__func__$17>)
42016080:	90a1b2        	movi	a11, 0x190
42016083:	abe5a1        	l32r	a10, 42001018 <_stext+0xff8> (3c022c5b <_flash_rodata_start+0x2b3b>)
42016086:	a80e81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42016089:	0008e0        	callx8	a8
	tlsf_assert(block && "cannot insert a null entry into the free list");
4201608c:	114366        	bnei	a3, 4, 420160a1 <tlsf_add_pool+0x105>
4201608f:	abe3d1        	l32r	a13, 4200101c <_stext+0xffc> (3c022c74 <_flash_rodata_start+0x2b54>)
42016092:	abe0c1        	l32r	a12, 42001014 <_stext+0xff4> (3c02795c <__func__$17>)
42016095:	91a1b2        	movi	a11, 0x191
42016098:	abe0a1        	l32r	a10, 42001018 <_stext+0xff8> (3c022c5b <_flash_rodata_start+0x2b3b>)
4201609b:	a80981        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
4201609e:	0008e0        	callx8	a8
	block->next_free = current;
420160a1:	29a9      	s32i.n	a10, a9, 8
	block->prev_free = &control->block_null;
420160a3:	3929      	s32i.n	a2, a9, 12
	current->prev_free = block;
420160a5:	3a99      	s32i.n	a9, a10, 12
	return tlsf_cast(void*,
420160a7:	c98b      	addi.n	a12, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
420160a9:	a9bb      	addi.n	a10, a9, 11
420160ab:	cd7c      	movi.n	a13, -4
420160ad:	10aad0        	and	a10, a10, a13
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
420160b0:	111ca7        	beq	a12, a10, 420160c5 <tlsf_add_pool+0x129>
420160b3:	abdbd1        	l32r	a13, 42001020 <_stext+0x1000> (3c022cb0 <_flash_rodata_start+0x2b90>)
420160b6:	abd7c1        	l32r	a12, 42001014 <_stext+0xff4> (3c02795c <__func__$17>)
420160b9:	96a1b2        	movi	a11, 0x196
420160bc:	abd7a1        	l32r	a10, 42001018 <_stext+0xff8> (3c022c5b <_flash_rodata_start+0x2b3b>)
420160bf:	a80081        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
420160c2:	0008e0        	callx8	a8
	control->blocks[fl * control->sl_index_count + sl] = block;
420160c5:	82d8      	l32i.n	a13, a2, 32
420160c7:	42a8      	l32i.n	a10, a2, 16
420160c9:	54aea0        	extui	a10, a10, 14, 6
420160cc:	82aba0        	mull	a10, a11, a10
420160cf:	a8aa      	add.n	a10, a8, a10
420160d1:	a0aad0        	addx4	a10, a10, a13
420160d4:	0a99      	s32i.n	a9, a10, 0
	control->fl_bitmap |= (1U << fl);
420160d6:	62d8      	l32i.n	a13, a2, 24
420160d8:	1a0c      	movi.n	a10, 1
420160da:	401b00        	ssl	a11
420160dd:	a1ea00        	sll	a14, a10
420160e0:	20dde0        	or	a13, a13, a14
420160e3:	62d9      	s32i.n	a13, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
420160e5:	72d8      	l32i.n	a13, a2, 28
420160e7:	a0bbd0        	addx4	a11, a11, a13
420160ea:	0bd8      	l32i.n	a13, a11, 0
420160ec:	401800        	ssl	a8
420160ef:	a1aa00        	sll	a10, a10
420160f2:	208da0        	or	a8, a13, a10
420160f5:	0b89      	s32i.n	a8, a11, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
420160f7:	19a8      	l32i.n	a10, a9, 4
420160f9:	c87c      	movi.n	a8, -4
420160fb:	108a80        	and	a8, a10, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
420160fe:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42016101:	88ca      	add.n	a8, a8, a12
	tlsf_assert(!block_is_last(block));
42016103:	3b0c      	movi.n	a11, 3
42016105:	113ba7        	bltu	a11, a10, 4201611a <tlsf_add_pool+0x17e>
42016108:	abbdd1        	l32r	a13, 42000ffc <_stext+0xfdc> (3c022b50 <_flash_rodata_start+0x2a30>)
4201610b:	abbdc1        	l32r	a12, 42001000 <_stext+0xfe0> (3c02797c <__func__$20>)
4201610e:	a1a0b2        	movi	a11, 161
42016111:	abbca1        	l32r	a10, 42001004 <_stext+0xfe4> (3c022b83 <_flash_rodata_start+0x2a63>)
42016114:	a7eb81        	l32r	a8, 420000c0 <_stext+0xa0> (4037fd50 <__assert_func>)
42016117:	0008e0        	callx8	a8
	next->prev_phys_block = block;
4201611a:	0899      	s32i.n	a9, a8, 0
	const size_t oldsize = block->size;
4201611c:	1898      	l32i.n	a9, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4201611e:	14a090        	extui	a10, a9, 0, 2
42016121:	18a9      	s32i.n	a10, a8, 4
	block->size &= ~block_header_free_bit;
42016123:	2a0c      	movi.n	a10, 2
42016125:	1099a0        	and	a9, a9, a10
42016128:	1899      	s32i.n	a9, a8, 4
	block->size |= block_header_prev_free_bit;
4201612a:	18a9      	s32i.n	a10, a8, 4
	return mem;
4201612c:	032d      	mov.n	a2, a3
}
4201612e:	f01d      	retw.n

42016130 <tlsf_create>:
{
42016130:	004136        	entry	a1, 32
42016133:	20a220        	or	a10, a2, a2
42016136:	20b330        	or	a11, a3, a3
	if (mem == NULL)
42016139:	01e216        	beqz	a2, 4201615b <tlsf_create+0x2b>
	if (((tlsfptr_t)mem % ALIGN_SIZE) != 0)
4201613c:	148020        	extui	a8, a2, 0, 2
4201613f:	d88c      	beqz.n	a8, 42016150 <tlsf_create+0x20>
		printf("tlsf_create: Memory must be aligned to %u bytes.\n",
42016141:	4b0c      	movi.n	a11, 4
42016143:	abb8a1        	l32r	a10, 42001024 <_stext+0x1004> (3c022e2c <_flash_rodata_start+0x2d0c>)
42016146:	f4d365        	call8	4200ae7c <printf>
		return NULL;
42016149:	020c      	movi.n	a2, 0
4201614b:	000306        	j	4201615b <tlsf_create+0x2b>
4201614e:	e50000        	extui	a0, a0, 16, 15
	control_t* control_ptr = control_construct(tlsf_cast(control_t*, mem), max_bytes);
42016151:	be          	.byte	0xbe
42016152:	ff          	.byte	0xff
42016153:	0a2d      	mov.n	a2, a10
	return tlsf_cast(tlsf_t, control_ptr);
42016155:	000086        	j	4201615b <tlsf_create+0x2b>
42016158:	000000        	ill
}
4201615b:	f01d      	retw.n
4201615d:	000000        	ill

42016160 <tlsf_create_with_pool>:
{
42016160:	004136        	entry	a1, 32
42016163:	027d      	mov.n	a7, a2
42016165:	20b440        	or	a11, a4, a4
	tlsf_t tlsf = tlsf_create(mem, max_bytes ? max_bytes : pool_bytes);
42016168:	002456        	bnez	a4, 4201616e <tlsf_create_with_pool+0xe>
4201616b:	20b330        	or	a11, a3, a3
4201616e:	20a770        	or	a10, a7, a7
42016171:	fffbe5        	call8	42016130 <tlsf_create>
42016174:	202aa0        	or	a2, a10, a10
	if (tlsf != NULL)
42016177:	ea8c      	beqz.n	a10, 42016189 <tlsf_create_with_pool+0x29>
		tlsf_add_pool(tlsf, (char*)mem + tlsf_size(tlsf), pool_bytes - tlsf_size(tlsf));
42016179:	ab8b81        	l32r	a8, 42000fa8 <_stext+0xf88> (4037fb34 <tlsf_size>)
4201617c:	0008e0        	callx8	a8
4201617f:	c0c3a0        	sub	a12, a3, a10
42016182:	b7aa      	add.n	a11, a7, a10
42016184:	02ad      	mov.n	a10, a2
42016186:	ffe165        	call8	42015f9c <tlsf_add_pool>
}
42016189:	f01d      	retw.n
	...

4201618c <tlsf_pool_overhead>:
{
4201618c:	004136        	entry	a1, 32
}
4201618f:	820c      	movi.n	a2, 8
42016191:	f01d      	retw.n
	...

42016194 <log_level_get>:
{
42016194:	006136        	entry	a1, 48
42016197:	027d      	mov.n	a7, a2
42016199:	a7a481        	l32r	a8, 4200002c <_stext+0xc> (3fc91f3c <esp_log_default_level>)
4201619c:	0828      	l32i.n	a2, a8, 0
    esp_log_level_t level_for_tag = esp_log_get_default_level();
4201619e:	0129      	s32i.n	a2, a1, 0
    if (tag == NULL) {
420161a0:	47bc      	beqz.n	a7, 420161d8 <log_level_get+0x44>
    if (timeout) {
420161a2:	b38c      	beqz.n	a3, 420161b1 <log_level_get+0x1d>
        if (esp_log_impl_lock_timeout() == false) {
420161a4:	aba181        	l32r	a8, 42001028 <_stext+0x1008> (4037fb6c <esp_log_impl_lock_timeout>)
420161a7:	0008e0        	callx8	a8
420161aa:	9acc      	bnez.n	a10, 420161b7 <log_level_get+0x23>
            return ESP_LOG_NONE;
420161ac:	020c      	movi.n	a2, 0
420161ae:	000986        	j	420161d8 <log_level_get+0x44>
        esp_log_impl_lock();
420161b1:	ab9e81        	l32r	a8, 4200102c <_stext+0x100c> (4037fb44 <esp_log_impl_lock>)
420161b4:	0008e0        	callx8	a8
    bool cache_miss = !esp_log_cache_get_level(tag, &level_for_tag);
420161b7:	20b110        	or	a11, a1, a1
420161ba:	20a770        	or	a10, a7, a7
420161bd:	ec8025        	call8	420029c0 <esp_log_cache_get_level>
    if (cache_miss) {
420161c0:	cacc      	bnez.n	a10, 420161d0 <log_level_get+0x3c>
        esp_log_linked_list_get_level(tag, &level_for_tag);
420161c2:	01bd      	mov.n	a11, a1
420161c4:	07ad      	mov.n	a10, a7
420161c6:	ec7425        	call8	42002908 <esp_log_linked_list_get_level>
        esp_log_cache_add(tag, level_for_tag);
420161c9:	01b8      	l32i.n	a11, a1, 0
420161cb:	07ad      	mov.n	a10, a7
420161cd:	ec8a25        	call8	42002a70 <esp_log_cache_add>
    esp_log_impl_unlock();
420161d0:	ab9881        	l32r	a8, 42001030 <_stext+0x1010> (4037fba4 <esp_log_impl_unlock>)
420161d3:	0008e0        	callx8	a8
    return level_for_tag;
420161d6:	0128      	l32i.n	a2, a1, 0
}
420161d8:	f01d      	retw.n
	...

420161dc <xt_int_has_handler>:

//Returns true if handler for interrupt is not the default unhandled interrupt handler
bool xt_int_has_handler(int intr, int cpu)
{
420161dc:	004136        	entry	a1, 32
    return (_xt_interrupt_table[intr*portNUM_PROCESSORS+cpu].handler != xt_unhandled_interrupt);
420161df:	902230        	addx2	a2, a2, a3
420161e2:	ab9481        	l32r	a8, 42001034 <_stext+0x1014> (3fc921b8 <_xt_interrupt_table>)
420161e5:	b02280        	addx8	a2, a2, a8
420161e8:	0228      	l32i.n	a2, a2, 0
420161ea:	ab9381        	l32r	a8, 42001038 <_stext+0x1018> (40376cbc <xt_unhandled_interrupt>)
420161ed:	c02280        	sub	a2, a2, a8
}
420161f0:	180c      	movi.n	a8, 1
420161f2:	932820        	movnez	a2, a8, a2
420161f5:	f01d      	retw.n
	...

420161f8 <xt_set_interrupt_handler>:
  parameter specifies the argument to be passed to the handler when it is
  invoked. The function returns the address of the previous handler.
  On error, it returns 0.
*/
xt_handler xt_set_interrupt_handler(int n, xt_handler f, void * arg)
{
420161f8:	004136        	entry	a1, 32
    xt_handler_table_entry * entry;
    xt_handler               old;

    if( n < 0 || n >= XCHAL_NUM_INTERRUPTS )
420161fb:	f81c      	movi.n	a8, 31
420161fd:	373827        	bltu	a8, a2, 42016238 <xt_set_interrupt_handler+0x40>
        return 0;       /* invalid interrupt number */
    if( Xthal_intlevel[n] > XCHAL_EXCM_LEVEL )
42016200:	ab8f81        	l32r	a8, 4200103c <_stext+0x101c> (3c02912c <Xthal_intlevel>)
42016203:	882a      	add.n	a8, a8, a2
42016205:	000882        	l8ui	a8, a8, 0
42016208:	3148f6        	bgeui	a8, 4, 4201623d <xt_set_interrupt_handler+0x45>
        return 0;       /* priority level too high to safely handle in C */

    /* Convert exception number to _xt_exception_table name */
    n = n * portNUM_PROCESSORS + xPortGetCoreID();
4201620b:	222a      	add.n	a2, a2, a2
4201620d:	03eb80        	rsr.prid	a8
42016210:	048d80        	extui	a8, a8, 13, 1
42016213:	828a      	add.n	a8, a2, a8

    entry = _xt_interrupt_table + n;
42016215:	ab8791        	l32r	a9, 42001034 <_stext+0x1014> (3fc921b8 <_xt_interrupt_table>)
42016218:	b09890        	addx8	a9, a8, a9
    old   = entry->handler;
4201621b:	0928      	l32i.n	a2, a9, 0

    if (f) {
4201621d:	738c      	beqz.n	a3, 42016228 <xt_set_interrupt_handler+0x30>
        entry->handler = f;
4201621f:	0939      	s32i.n	a3, a9, 0
        entry->arg     = arg;
42016221:	1949      	s32i.n	a4, a9, 4
42016223:	000206        	j	4201622f <xt_set_interrupt_handler+0x37>
42016226:	a10000        	sll	a0, a0
    }
    else {
        entry->handler = &xt_unhandled_interrupt;
42016229:	a9ab84        	lsi	f8, a11, 0x2a4
4201622c:	8909      	s32i.n	a0, a9, 32
        entry->arg     = (void*)n;
4201622e:	8119      	s32i.n	a1, a1, 32
    }

    return ((old == &xt_unhandled_interrupt) ? 0 : old);
42016230:	87ab82        	movi	a8, 0xfffffb87
42016233:	460e92        	l8ui	a9, a14, 70
42016236:	0c0002        	l8ui	a0, a0, 12
        return 0;       /* invalid interrupt number */
42016239:	018602        	lsi	f0, a6, 4
4201623c:	020c00        	andb	b0, b12, b0
        return 0;       /* priority level too high to safely handle in C */
4201623f:	000046        	j	42016244 <xt_set_interrupt_handler+0x4c>
    return ((old == &xt_unhandled_interrupt) ? 0 : old);
42016242:	020c      	movi.n	a2, 0
}
42016244:	f01d      	retw.n
	...
